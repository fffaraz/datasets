Write a little program which prints out argc. Test it with different numbers of arguments. 
&gt; In fact, `&amp;t`, `&amp;t[0]` and `t` are all synonymous That's not true. See for example: #include &lt;stdio.h&gt; int main(void) { char t[32]; printf("t + 1 = %p\n", t + 1); // 0xffc4f23d printf("&amp;t[0] + 1 = %p\n", &amp;t[0] + 1); // 0xffc4f23d printf("&amp;t + 1 = %p\n", &amp;t + 1); // 0xffc4f25c return 0; } (The comments show the values printed on my machine.) The third value is different because `&amp;t` is a pointer to the array (its type is `char (*)[32]`), so if you add `1` to get to the "next element" you get a pointer to the next array of 32 chars just past `t`. 
Thanks for your help
The argument of `rev`, which you are specifying in `buffer`, is a name of a file, which contains lines should be reversed, not the text to be reversed itself. If you execute `rev` without any parameters, you can pipe the text into it through standard input
Oh, thanks! I was sending my buffer as a name of a file, as you say, and so I was getting that error. Now I got it to work, thanks again.
knowing and fully knowing are entirely different things bro ;)
argc is pretty much always at least 1. In your example, argv[0] would be "./input.x", or similar. One command-line argument passed to your program would result in argc == 2. You can either use argc &gt; 1, or argc == 2, depending on whether you need to separately detect different numbers of arguments.
Makes perfect sense. Thank you
It's probably fine to just have one log setting for the project globally. I would probably just do something like `getopt()`s `opterr` flag and have some global integer that may or may not be set. E.g. in `log.h` define some constants for what the log level could be, and export an `extern int loglevel` variable the user ca set, or leave as some default level.
C is a beautiful and simple language, I agree. I can't say the same for some of the code I've seen written in it though :'(
That's so cool. A complete decomposition of pointers.Complete, with the examples at the end.
Cool. I ran into the same problem once, this was my solution: enum logging_mode { LOG_LEVEL_DEBUG, LOG_LEVEL_INFO, LOG_LEVEL_WARNING, LOG_LEVEL_ERROR, LOG_LEVEL_CRITICAL }; /* Optional, if you want to use a constant log file */ #define LOG_FILE stderr /* Use this prefix in the log messages */ #define LOG_PREFIX __func__ #ifdef TERM_COLORS static char const LOG_LEVEL_DEBUG_STR[] = "DEBUG!"; static char const LOG_LEVEL_INFO_STR[] = "\033[4;37mINFO!\033[00m"; static char const LOG_LEVEL_WARNING_STR[] = "\033[0;33mWARNING!\033[00m"; static char const LOG_LEVEL_ERROR_STR[] = "\033[0;31mERROR!\033[00m"; static char const LOG_LEVEL_CRITICAL_STR[] = "\033[4;31mCRITICAL!\033[00m"; #else static char const LOG_LEVEL_DEBUG_STR[] = "DEBUG!"; static char const LOG_LEVEL_INFO_STR[] = "INFO!"; static char const LOG_LEVEL_WARNING_STR[] = "WARNING!"; static char const LOG_LEVEL_ERROR_STR[] = "ERROR!"; static char const LOG_LEVEL_CRITICAL_STR[] = "CRITICAL!"; #endif static char const * const LOG_ARR[] = { LOG_LEVEL_DEBUG_STR, LOG_LEVEL_INFO_STR, LOG_LEVEL_WARNING_STR, LOG_LEVEL_ERROR_STR, LOG_LEVEL_CRITICAL_STR, }; #define LOGGING(log_file, log_mode, ...)\ do {\ if (LOG_LEVEL &lt;= (log_mode)) { \ fprintf((log_file), "%s: %s ", LOG_PREFIX, LOG_ARR[(log_mode)]);\ fprintf((log_file), ##__VA_ARGS__);\ }\ if (LOG_LEVEL &lt;= LOG_LEVEL_DEBUG) {\ fflush((log_file));\ fsync(fileno((log_file)));\ }\ } while(0) /* The following wrapper macros write to LOG_FILE if LOG_LEVEL &lt;= something */ #ifdef LOG_FILE #define LOG_CRITICAL(...)\ LOGGING(LOG_FILE, LOG_LEVEL_CRITICAL, ##__VA_ARGS__) #define LOG_ERROR(...)\ LOGGING(LOG_FILE, LOG_LEVEL_ERROR, ##__VA_ARGS__) #define LOG_WARNING(...)\ LOGGING(LOG_FILE, LOG_LEVEL_WARNING, ##__VA_ARGS__) #define LOG_INFO(...)\ LOGGING(LOG_FILE, LOG_LEVEL_INFO, ##__VA_ARGS__) #define LOG_DEBUG(...)\ LOGGING(LOG_FILE, LOG_LEVEL_DEBUG, ##__VA_ARGS__) #endif /* LOG_FILE */ /* Misc */ #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #define REPORT_AND_EXIT do { perror(LOG_PREFIX); exit(EXIT_FAILURE); } while(0) #define LOG_AND_EXIT(...)\ do {\ LOG_CRITICAL(__VA_ARGS__);\ exit(EXIT_FAILURE);\ }while(0) 
I would try to avoid a lock. A global lock that applies to every log call will really hurt performance. That might mean a more complicated solution than `localtime` though.
Ya performance could take a hit but with the log-levels option a lot of people have suggested I feel like it would be good because users would be able to turn off logging in performance critical sections when needed.
There are non-standard alternatives you could use: [`localtime_r`](http://pubs.opengroup.org/onlinepubs/7908799/xsh/localtime_r.html) in *nix and [`localtime_s`](https://msdn.microsoft.com/en-us/library/a442x3ye.aspx) in MSVC. You could add a preprocessor check if either are available and only fall back to a lock if they aren't.
I just pushed a change set with support for multi-threading via pthreads. I don't know much about multi-threaded programs so I'm not sure I did it right. Would you be able to take a look and let me know if it seems good? Testing with and without enabling the pthread support seemed to show that the changes were working, but I might be missing something.
Sweet. I'll add the re-entrant function for *nix systems, but I don't run windows so I don't have an easy way to test with MSVC.
You forgot to include "createListByString".
You have *prev = NULL, then you try to dereference it with prev-&gt;next before you give prev a valid pointer address.
Also, walk through the code. What happens if the "key" matches the first character? What is 'prev' set to? A debugger should be able to help you determine why it is crashing. Most likely you have an invalid memory reference somewhere.
Have you run your code through a debugger?
I think you need to stop coding and start thinking/designing. If I gave you a list of numbers to sort, how would you do it? Let's try it. Walk me through how you'd sort these numbers, by looking at two at a time. In English, not in C. Your input is: 57 3 2 9 7 48 6 17 2 21 How would you do it if you were the computer? 
Your "Edit 2" is the correct solution.
I noticed you wrote your own implementation. It looks really tidy, nice! I guess it doesn't matter anymore, but if you do decide to use my library (maybe for performance reasons or whatever), than yeah, that's fine. As long as you don't have the "show legal information" feature, the copyright notice can be limited to the source code, I'm fine with that. When you do get a "show legal information" feature, then it would be nice to have that in. 
What's your question? What have you tried so far? What part are you getting stuck on?
I don't see where commandRight is declared. How does this code even compile?
I find this to be a good resource to follow when I get stuck and need help. You should take a read through it. http://www.catb.org/esr/faqs/smart-questions.html
Sorry, this is just one file of my program. This is the .c file containing the definitions for the functions. There is a separate file containing the declarations, and another file called main.c. The rightCommand array is declared in the parseRight function, the first line in that function definition. 
More specifically, by assigning it the initial value of "", it copies a null terminator, or '\0' (ASCII 0) character into the array. This is treated as a special character to string functions, and it signals the end of the string. `strcat` will append to the end of the provided string first by looking through the string until it reaches a '\0'. Once it reaches this point, it will begin copying the desired new characters, ending with a new '\0' character being written. Now, if the original string doesn't contain a null terminator, the initial scan that `strcat` performs will not work as expected and `strcat` will keep scanning off into unknown memory. Eventually, it will either find '\0' or crash. If it finds one, it begins copying the new string so you end up with a string full of gibberish at first. Keep in mind, letting strcat behave this way (reading/writing past the end of the string buffer) is undefined behavior and results in problems (like gibberish strings or a crash, or seemingly strange optimizations). You might not be able to use them in class, but learn about `strlcat` and `strlcpy`.
Please put four blanks in front of every line of code so your code appears readable.
It's a good idea to post these files, too. How am I supposed to analyse your code with a debugger if it isn't even complete?
Your program is crashing accessing commandRight. What is commandRight? It is not declared in the code you gave us.
Oh my gosh. Wow. Thanks so much. The commandRight is supposed to be rightCommand. Literally been staring at my screen for the last TWO hours wondering what was going on. Geesh. What a lifesaver! 
Fix the commandRight thing as suggested by others. I am going to assume that is a typo. Why are you using char** and not char*? Your life would be infinitely easier if you just used char*. Char* is a pointer to a character, it will be read till '\0' is not encountered. Char** is a pointer to a pointer to a character (this is not a string, if thats why you are using it) Also, to find the pipe you should compare characters and not string. Use == '|' instead of strcmp. 
Why are you using char** to store a string instead of char* though? It seems like you are dealing with just one line command, a single string that is, char* should suffice for that. And IMO it will make your like a lot easier. 
In that case, you are accessing rightCommand[sizeOfRight] after incrementing sizeOfRight, which is almost certainly another bug.
1) First of all, please use fclose() right after you need the file (so after the for loop with the fscanf). Keep stuff opened is never a good idea, if not needed. 2) Don't use all that if-else, for a simple check like that: a simple **switch** is enough. 3) Even better, you can have one printf() statement that prints out the count variable, avoiding it. 4) I'm not going to give you the solution but an hint: you can check in the same for loop if all the elements are present, but IF you find AT LEAST one number out-of-sequence, well... it's an "error", right?
Start from learning C [K&amp;R book](https://en.wikipedia.org/wiki/The_C_Programming_Language), then expand your knowledge to C++ classes, STL etc..
**The C Programming Language** The C Programming Language (sometimes termed K&amp;R, after its authors' initials) is a computer programming book written by Brian Kernighan and Dennis Ritchie, the latter of whom originally designed and implemented the language, as well as co-designed the Unix operating system with which development of the language was closely intertwined. The book was central to the development and popularization of the C programming language and is still widely read and used today. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
If you really need to learn both then start with C, but when switching to C++ keep in mind that they are different languages and that C-like programming in C++ will be considered very awkward by most C++ programmers (for good reasons as they have many other more common tools at their disposal).
https://stackoverflow.com/questions/20514587/text0x20-undefined-reference-to-main-and-undefined-reference-to-function
&gt; argc is pretty much always at least 1 Yes. Though ... esoteric trivia ... it's interesting that the language spec tells us `argc == 0` is *allowed*. It doesn't say when or why. [[5.1.2.2.1]](http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf) I've never seen that scenario, ever. 
I think everyone has or will or should write a logging library a few times in their life. Good one.
#C #Interview #Questions on #Variables and #Identifiers - #Java2python.com
Hai Learn #C #Interview #Questions on #Variables and #Identifiers http://java2python.com/c-interview-questions-variables/
Yeah. I said "pretty much" for that reason, but didn't want to sidetrack OP with allowed but never seen behavior.
üëç not the stuff of newbs
Yep, given the feedback I've gotten that's the next thing I'm going to try and add.
I would say C. While modern C++ is its own beast, it started out as "macros" for C. You will never truely appreciate the oop constructs of C++ until after you written or worked with a large C project. It also helps understand what C++ is doing under the hood.
Stop spamming.
IMO if you need both then C-&gt;C++ like most have already said but if in the end you need C++ then just skip C, although C is a subset of C++ they are different so why waste time. You have to think about what kind of job in what industry you want to work in, look at specific tools and library's used in that industry and focus on the language used most. Truly mastering a language takes time and a lot of practice even though you will not loss much by learning both, you will get an upper hand by only focusing on one, its all about compromise in the end.
This is of course going to be unpopular on this sub, but I'd actually suggest C++ first. That way you aren't polluted with a C mentality, which usually leads to shitty C++
&gt; I'm calling the sortScore in a switch statement. I asked for the code, not a vague description of it. &gt; However it's only swapping the first two numbers. `t` never changes. Like /u/dmc_2930 says, you need to stop coding and start designing. Write down (in English, not in code!) what your program does. Divide it into major steps or stages. Divide your code into separate functions for each step. Call them in order. Share as little information as possible between them.
&gt; although C is a subset of C++ they are different so why waste time. C **is not** a subset of C++. 
I started with C++ in 99 or so, ended up working with PHP (which was totally unrelated) and onwards to Ruby... When I wanted to refresh my C++ chops, I started with C. C is beautiful and simple and easy. It will take you a week to learn and years to master. It's also quite a stable language with mostly minor changes and conveniences added through the years (such as the [designated initializer](https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html) added in C99). So once you learn it, you have it. On the other hand, C++ is complex, with many features and quick to change. I don't use C++ anymore and I probably wouldn't know how to. They keep adding features and language constructs with every standard revision. Saying that, I don't think many people know all the features C++ has to offer nor all of it's semantics. People often know the basics (classes, templates etc') and a subset of the myriad features. To sum it up, I would start with C because it's easier and faster to learn. You'll also be learning "how to learn" along the way. When you start on C++ you will have the "how to learn" covered and you'll be ready to deal with the bigger challenge. As a side note, as much as I loved OOP in C++ and Ruby, I find I can do the same in C with better data isolation and control. There's this misconception that C doesn't support OOP... I have no idea why people keep propagating this nonsense. Good luck with both.
Absolutely this. I never really got C++ the way it was presented in books and in courses. It wasn't until I stopped thinking the C way and started treating C++ as it's own unique language that I got any good at it. But C is a *great* way to get the basics of the syntax and high-level-assembly machinery down. Like how you have to know algebra to be able to do calculus.
What is ‚Äúto flex‚Äù supposed to mean?
specify with ur skills
I have still no idea what you mean. What is ‚Äúspecify with ur skills‚Äù supposed to mean? Is ‚Äúur‚Äù short for ‚Äúyour?‚Äù Please consider using proper spelling and grammar.
What?
C is not what makes shitty C++.
Didn't say it did. In fact, learning C will probably make you better at C++. All I'm saying is that you should learn C++ first.
Cool, thanks. Might come back to your library if I need more crypto stuff in the future.
The string I'm using in this command is a pointer to an array of chars, so that's why I thought I needed to use a char* again . It will be used in a third function to pipe the commands, I obviously just haven't gotten there yet. 
Ass backwards.
So here is the problem I always have. C is a functional language, if he has a strong object oriented background it's almost impossible to easily pick up functional mentality again. So if you have more experience with object oriented start c++; if you have an almost equal split between oo and functional Do c first. Head first C is a good book with lots of projects. 
This question has been asked many times and received a bunch of good answers. Use the search function to search through old posts and follow the advice given there.
&gt;Once more, I NEED to learn both for the school program and probably the job market after school; I just want to avoid bad habits in both if possible. Are you actually absolutely sure that you need to learn them? Learn them both? Did you speak with someone who already did those classes and to what extend did they actually use C and C++ for their work? Do you know anyone from your desired professional field who told you that they need C and C++ for work, that it was a great help when they do X and Y? Or when you look at current jobs offers, do they ask for C/C++? Just saying that its kinda big bite you are taking and you should be sure you have correct information and purpose in mind. Maybe its just basics simple 101 class that does not really leads anywhere specific. &gt;I just want to avoid bad habits in both if possible. while old school loves to talk in those terms, programming is not like playing a guitar, where when you learn incorrectly holding a chord its a hell to switch to correct hold because of your muscle memory fighting you. Only if you would code without understanding would you are doing could there be issues.
Also, learn to use Google better, OP. Tutorials, documentation, and books for programming languages are some of the easiest things to find.
How do you manage to have better data isolation in C over C++? C does not support any type of encapsulation so I'm just confused on how that would be better over C++.
yeah agreed. the fundamental question in my view is this: "how do you teach abstraction?" this is important in both computer science and mathematics education. when you first encounter the 2nd fundamental theorem of calculus as an undergraduate, your homework will ask you to *use* the theorem to compute an area. it certainly won't be asking you to *prove* that theorem. at this level of abstraction, the theorem is a black box, accepted as true, and useful for solving a range of problems. perhaps later you can dig in and derive the proof, but for the purposes of the homework, that's unnecessary. similarly, when you first encounter maps or vectors in C++, you learn how to *use* them, not implement them. you might be assigned a project that uses a specific data structure, or perhaps you're asked to choose a better one, but the implementation of that data structure isn't a key element of the assignment, that will come later. so thinking like a computer scientist (or a mathematician) means being able to think in multiple levels of abstraction. at the beginning, learn to *use* data structures (or theorems) to solve specific problems. later on, you can dig into how to implement them (or prove the theorems) for deeper understanding. in this way i think the high-level C++ --&gt; low-level C transition is very natural, and provides the best ROI on time spent for most people. 
C is a procedural language. Erlang is a functional language
That's such a classic thing in C, it tells you there is an error but it doesn't say what the error is so you take 6 hours remaking everything and then realise you just used the wrong variable name and it was all fine.
Yeah, +1 to "If you REALLY need both, then C first or you're going to break your brain."
To contribute positively to the discussion, you should explain why you think that.
Another take on it is that you can begin to work with pointers with umique_ptr&lt;&gt;, and iterate over data structures with range iterators, and this is quite safe. This allows one to learn about compilation, translation units, program design, what pointers are and how to use them, all without tricky things like new, delete, malloc, calloc etc.
The fraction of C which is outside C++ is small even compared to C, which is itself a relatively small language.
The best way to learn C is to write in it programs you're actually going to use. Then write more of those. Read other people's code. Good code. Early in the process once you have developed the ability to read other people's code, aim to read about 500x more lines of code than you write.
To add to what others have said, I suggest that you learn it skill by skill. Learn how to use a for loop completely confidently, then learn how to use (for example) arrays completely confidently.
nerd
Char* should work for a pointer to arrays of chars. Just remember to null terminate your strings or else you'd be reading gibberish.
&gt; How do you manage to have better data isolation in C over C++? C does not support any type of encapsulation... That's a common misconception. In fact, C++ made encapsulation weaker as part of it's OOP model (C++ favored abstraction over encapsulation). For example, object files in C behave like black boxes when the `static` keyword is used correctly. I find it safer than classes in C++, that can be inherited in ways that might cause their internal state to be effected in complex ways (especially, but not only, when code get's entangled and lacks proper separation). As another example, think of `malloc` in C (and C++, same C style implementation)... how does `free` know the size of the data to deallocate? easy, `malloc` stores metadata *before* the pointer it returns, allowing the memory block object to contain properties that aren't accessible to the user. Similarly, C objects and have type data and virtual function tables attached before the actual object returned, allowing C objects to "inherit" and all sorts of magical stuff. Consider that the whole of the Ruby MRI language and interpreter is written in C (not C++), which is proof enough that C can be used for OOP. 
You're right, I need to get better about taking out a pen and paper and writing out what the program in pseudocode before I start just writing code and running into problems. Thanks for all your help. I figured out my errors in the bubble sort and got it all to work. 
You both are correct. Thanks for you help! 
I am not sure I follow your claim. There is a lot of hardware specific non-standard C code provided by embedded vendors. However can you provide an example of standard C code that does not compile in a C++ toolchain?
Yes it's apparently the classes use it and assume you know it, it's also a part of the requirements my preferred internships are asking for; however, I assume it's not to some insane level as they are just third-year internships. I have an entire year before I'm a junior and like 30-40 hours of time a week I can use to learn so I don't mind bitting at the first big meal if it helps to swallow the second. Thanks for that last comment and good wishes.
I'll definitely remember that. Thanks for the advice and suggestion!
I've heard this book was a must-read but is difficult on beginners. While I'm not entirely a begineer is this still recommended? I was about to start with "C Programming - A Modern Approach."
Looks like I'll be taking the dive into C; thanks for all the insight.
I didn't said a toolchain. I said a C++ compiler. Here is a valid C piece of code that will error if you run by a C++ compiler (in a .cpp file): int *a = malloc(10 * sizeof(int)); In C++, you *must* cast the result of malloc to an integer pointer: int *a = (int *) malloc(10 * sizeof(int)); Another one that won't compile with a C++ compiler: typedef struct { int x, y; } Point; int main() { Point pt = {.x = 10, .y = 8}; // ....... return 0; } 
No online resources is "best way to learn" anything...I would list: - a good book, - a personal instructor, and - Read famous C apps source code. Pick two of those at least...
Why would anyone need to learn C++? ...fawking terrible chit said to be a programming language! Just learn C. If you need more than C, pick Python, Go, Perl, Bash... 
There are things with identical or similar syntax that behave differently in C vs. C++. There are also parts of the C language that have no C++ equivalent like designated initializers.
No doubt. C is so much worse than C++. This assignment has definitely given me a greater appreciation for the linux shell (and even others for that matter). But, it has also deterred me from ever wanting to be an OS developer haha. Thanks for you small sense of humor! It made my day (: 
Here..pick your poison: https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list?answertab=votes#tab-top
Thanks for the null termination tidbit. Totally slipped my mind. 
If you have a basic understanding of any programming language, it will be doable especially if you do the examples
The pthread implementation is all good. See the pull request I made regarding the interface for your library.
Thanks a million. I'll probably merge it in tonight.
Cheers, all the best.
Thanks for the information, I appreciate the response! I'll definitely check out the lecture. I've always thought C only had an imperative procedural programming paradigm but with your specific examples (especially with malloc and free) I can see how C can support OO functionality.
Completely agree.
There‚Äôs a book out there on OOP in C and for a practical example ObjC
I would say otherwise. It is a much more natural transition to go from binary to assembly to C and then to C++. In many ways this is the path I took.
I'm not in front of a computer right now, but why not use scanf ("%7c", postalcode); postalcode[7] = '\0'; If you want to skip leading spaces, put a space at the beginning of the format string. 
[Check this answer](https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list). Choose a book from the beginning list. But I see you already have one. Go with it. In my opinion K&amp;R book is good when you already know how to program, and you are looking to learn the C language. It goes direct to the point of "In C we do this and do that".
There are other stdio input functions, you know. fgets(), or fread() if the string can include a new line.
Yeah I know. I'm just trying to use scanf just for the sake of it cause I don't really have a clear idea of how these specifiers work
Have you tried simply: scanf("%7s ", postalcode); This should read the next seven characters (spaces or not) and then consume any trailing whitespace (i.e. the return). Also, when using `[` the bracket _is_ the format specifier. You don't want a trailing s. 
I advise not trying to jump through hoops trying to tweak scanf when there are simpler more appropriate functions available.
scanf specifically ignores whitespaces. Basically, what you're trying to do is not possible with scanf.
`%7 [^\n]s` is not a format specifier. It's a specifier `%7 [^\n]` which will accept any 7 characters except new line, followed by `s` which tries to match character `'s'` exactly. Additionally set specifier `% []` and character specifier don't consume whitespaces before reading input, so the new line that exists in the input from reading the number immediately causes second `scanf` call to fail and the third call just reads the new line character
You would put yourself ahead of most of the developers in either language by grabbing the standards and understanding some key principles like implementation defined, unspecified and undefined behavior. If you aren‚Äôt using implementation defined behavior you may be using the wrong language. If your code expects behavior seen on one compiler on one OS on one processor with one set of flags which is unspecified or undefined you (or those of us who have to rewrite your work when you are fired) are in for a world of hurt. These help you understand programming 101 concepts such as ‚Äúwhat is an API?‚Äù which most C developers I‚Äôve seen over many decades of all experience levels still do not understand. On the topic of C, when you realize the C standard is well over 700 pages it should dawn on you that anyone saying C is simple is either an idiot or a genius, and most who think they are the latter are really the former. Not well known among far too many developers are concepts not named as such in the standard including ‚Äústrict aliasing‚Äù and ‚Äú[optimization unstable code](https://pdos.csail.mit.edu/papers/stack:sosp13.pdf).‚Äù On the topic of C++, I didn‚Äôt have access until a decade after I learned C, and even then much of what defines the language now either didn‚Äôt exist in the standard or was completely broken in most toolchains. That said, it took some time to trust the wisdom of what were presented as best practices even at that stage of language development. I eventually jumped that fence but many did not and became terrible C++ developers so I‚Äôm curious to see more input from people who started with C++. My library is in storage for rennovations but I recall doing some reboostrapping with ‚ÄúAccelerated C++‚Äù ages ago. You start by using the STL and work from high level concepts down which they claim dramatically improved the students‚Äô experience in learning the language. I would expect this would lead to better C++ developers than starting with C, but I‚Äôd love to hear about real world experiences so I can update my expectations.
Fair point, to me it felt like you were claiming that there is C code that is not able to be represented in C++, but I didn't take your initial point as literal as what you are saying, of taking C code exactly as is without a single change and parse it to a C++ compiler. 
don't forget to sanitise your input, if its coming from the internet its a possible hack!
You are giving very little information. You don't even mention the game the bitboard is supposed to represent. How you're using it. What line you're having trouble with. The general strategy you're trying to get bitboards to use. There are lots of different ways to use bitboards.
get a C book
&gt; Thanks, sscanf for making my life easier. I don't think I've ever seen scanf and easier used in the same sentence :P
Well, the alternative is rolling your own parsing, so I guess technically `sscanf` is easier. 
`"%7[^\n]\n"` should eat the newline for you. You don't actually us an s in there unless you want them to type an s.
I don't really like this way as it makes the code a bit too complex. This complexity is dangerous as possible to make bugs and errors in the code that hard to be detected. And despite there are program like checkmarx that might solve it, It's recommended to try and avoid them. Cautious can also solve it. Thank you.
I have a library for that on GitHub [here](https://github.com/VictorSCushman/Generic-C-Map). It's not perfect but it gets the job done and will work with keys/values of any type. Another library that's used a lot is [uhash](https://troydhanson.github.io/uthash/) and I heard that's pretty good.
Implement means writing your own, but the rest of your post sounds like you're trying to find a library to use instead. Which is it?
I'm looking for a library but I suspect I'm going to have to implement said library with the rest of my code.
glib has assorted useful data structures.
If you're looking for compile time static perfect hash tables look into GNU's gperf
What kind of key would you like to use in your hash table? Do you need strings as keys? Or arbitrarily structured data?
Donald Knuth's _Art of Computer Programming_. The volume on sorting and searching has hash algorithms. (C implementation is straightforward.) I'm an old dude. I wrote my own hash tables for most of my career. Knuth has always been the goto book for basic algorithms. (Hmmm... let me rephrase that!)
You could read the C standard.
[IonDB](https://github.com/iondbproject/iondb) has a lot of key value implementations written for C, including a hash table. It's written for minimal memory footprint and meant to be run on embedded platforms, though - so keep in mind some of the design choices made might not be what you're looking for.
Without seeing your code, this is impossible to say.
Visual studio don't have any wierd error handling that i can disable? I have two simple structs for example sturct item{ char name[50]; char unit[30]; float amout; } struct list{ struct item *pItem; } That is in my header file roughly. I have struct variables declared in my main and function on a diffrent .c file. All files have #include header
True, but better than doing this manually.
Please post the complete code that caused this error. Try to make a [MCVE](https://stackoverflow.com/help/mcve). It is very unlikely that this problem is due to the IDE you use.
Best way to upload code with several files? Pastebin gets messy?
When I was skimming data structures and algorithms, I found a short tutorial series. Technically, a hash table is an abstraction (or data structure) for a representation of a key value pair. Theres a video series that breaks that abstraction down. There may be some system libraries that do this for you as well depending on the use case. I would start here if you're really serious about it. [What is a HashTable Data Structure](https://www.youtube.com/watch?v=MfhjkfocRR0). You could create your own tiny interface (API), or just use data structures supplied by system libraries in which case you'll need to reference the documentation. For example, linux uses the glibc. Windows uses its own as well (i dont know what it's called, but most likely is tied to .NET or VS in some way). In any case, it's usually "black boxed" and you only have to worry about the implementation of that interface (API). Implementing and Interfacing with an API are 2 sides of the same coin so to speak. Dictionaries are a good example of a basic hast table. [Hash Table](https://simple.wikipedia.org/wiki/Hash_table). Here's a half-way decent video of implementing one on youtube. [Hash Table Implementation in C](https://www.youtube.com/watch?v=1_mnhZ20Vus). Good luck and have fun.
Github. Though it would be better if you could try to make an MCVE, that is, cut down your code to the bare minimum needed to reproduce the problem. This also makes it easier to get an answer because I don't have to wade through tons of irrelevant code.
Are you doing something like this? https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html If so I think that is a gcc extension rather than standard C so visual studio might not support it. 
Just out of curiosity, and having used the scanf family of functions, what to most people find difficult about them?
Designated initializers are C99. And I found out recently that VS2017, at least, understands them.
The one that trips most beginners up is how it consumes white space. The newline gets left behind and then gets mysteriously sucked up later on in the program. (comments and variable names added for realism) // get the number of dragons in my game scanf( "%d", &amp;numberOfDragonsInMyGame ); // ask the user if they are for real printf( "Are you for real?\n" ); // get the are you for real response scanf( "%c", &amp;userEnteredYesNoCharacterFromKeyboardThing ); // why this no working? In most posts asking for guidance they never check the return value so the resulting garbage in unmatched values always makes for good fun. It looks like a printf style formatting but the way arguments are handled is different (addresses rather than values) And the classic: scanf( "%s %s", city, state ); and it all works great until the user enters San Francisco CA 
Just out of curiosity, what is your interest here? Though the `*(t+1)` syntax works, it's usually a better practice to write `t[1]`.
The most widely hash table implementation in C is probably [uthash](https://github.com/troydhanson/uthash). It is fairly easy to use, but very inefficient especially for large tables. If you use hash tables in performance critical code, you should consider my implementation [khash.h](https://github.com/attractivechaos/klib/blob/master/khash.h) (doc [here](http://attractivechaos.github.io/klib/#Khash%3A%20generic%20hash%20table)). It is less user friendly due to the use of (ugly) macros, but it [was a couple of times faster](https://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/) than uthash and used much less memory. As I have just tested on the latest versions, the gap remains similar. The [top C implementation](http://benchmarksgame.alioth.debian.org/u64q/program.php?test=knucleotide&amp;lang=gcc&amp;id=1) of the [k-nucleotide benchmark](http://benchmarksgame.alioth.debian.org/u64q/knucleotide.html), where hash table is the performance bottleneck, is using khash.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [attractivechaos/klib/.../**khash.h** (master ‚Üí f1beb2c)](https://github.com/attractivechaos/klib/blob/f1beb2ce8bb39e09d0311d3d214eee800686051c/khash.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
If `r` is a random number in a sufficiently large `int` (say, 32 or 64 bits) then the expression `r % 100` will give you a good distribution of 0-99.
I'm doing the same project OP is and i've been trying to decode this hint for hours. I know exactly that we have to compare the elements between the given array and the user guesses but I cannot get this into code form. every attempt ends up with the program outputing that none pf the keys are correct and I just dont know why besides count not incrementing correctly, and I can't find anything in the code that is preventing count from incrementing. My code is near exact to OP's. any extra hints?
Multiplication and addition can give answers that require more bits than the operands. Eg, if N is 2 11 + 01 = 100 11 * 10 = 110 The results here both need 3 bits.
The only time you'd ever use pointer notation instead of arrays afaik is if you're doing string slicing in C and really don't like the ampersand operator
n-bits * n-bits ‚Üí 2n-bits 2n-bits + n-bits ‚Üí 2n-bits As an example for n=16, using maximum values: 1111 1111 1111 1111 * 1111 1111 1111 1111 = 1111 1111 1111 1110 0000 0000 0000 0001 + 1111 1111 1111 1111 = 1111 1111 1111 1111 0000 0000 0000 0000
Question 1 is underspecified. In C the result of arithmetic on `unsigned int` is another `unsigned int`. If the mathematical result would have been out of range, it's reduced modulo UINT_MAX+1. You could answer tautologically: the minimum number of bits needed is N. But it's also possible that the intent of the Question was to ask the minimum number of value bits needed to store the mathematical result. Another thing to bear in mind is integer promotion. The wording "unsigned integer" could be taken to mean an unsigned integer type narrower than `unsigned int`, such as `unsigned short`. In that case the operands are promoted to a signed int, usually. 
In Question 2 you miscounted. The right-most bit is bit 0. So the representation 10000 has bit 4 set. But you were asked for bit 5, i.e. 100000 in binary, or 2^5 = 32 in decimal.
When i read others codes, they all have different styles of writing. Some prefer *(t+1) some t[1]. Now this is not a problem because i know about these ways to refer to an element of an array, but i've come across several solutions where i didn't entirely understand what the author wrote.
Nice. Mathematically: Maximum value of an n-bit unsigned integer is 2^n+1 - 1. So a\*b+c will be at most - (2^n+1 - 1)^2 + (2^n+1 - 1) = (2^n+1 - 1)2^n+1 = 2^2(n+1) - 2^n+1 = (2^2(n+1) - 1) - (2^n+1 - 1) First term is the the maximum value of a 2n-bit unsigned integer and the second is the maximum value of an n-bit unsigned integer so the maximum value of a\*b+c needs 2n bits. 
Have you installed a C compiler?
What have you tried? What happens when you do that? What did you expect? See http://www.catb.org/esr/faqs/smart-questions.html for more help on how to ask a question in such a way that you get the most useful answer.
in cstdlib RAND_MAX is defined divide you random number by this and you get 0-1 which you can then scale to the desired range... 
If you're careful what cross platform libs you can take code back and forwards thanks to the Linux on windows framework... You probably are after an IDE https://www.tecmint.com/best-linux-ide-editors-source-code-editors/ (some examples from a quick look on startpage.com) however I'd thoroughly recommend you learn about makefiles and using gcc.... there are a bunch makefile tutorials... 
Open a terminal. Put your source code in a file named `hello.c`. Here is sample source code for a ‚Äúhello world‚Äù program: #include &lt;stdio.h&gt; int main() { puts("hello world"); return 0; } Then type: cc -o hello hello.c This compiles `hello.c` into `hello`. Next type ./hello to run your program.
VSC is for webdev dude... install a real IDE.
Am I taking crazy pills? how the hell does your IDE influence which standard library function you use?
For question 2, watch out. The rightmost bit is the 0th bit. You assumed it was the 1st one. For part B and C, It is about bit shifting. It is often used for masks, as 1 &lt;&lt; n will result in the nth bit set to 1, and all the others to 0.
i.e. vim
There's an extension called code runner, which supports many compilers (that need to be installed separately) - install it. Then in the editor context menu, click Run Code
&gt;Since beginning I was using Windows for my all computer work &gt;downloaded Visual Studio Code for my coding work &gt;I am stuck here Thus a lesson learned for all the rank amateurs coming from Windows with Microsoft hooks in their noses.
I think that I've seen mentioned here a site that will explain an expression, or possibly reformat (change white space, add or remove parens) the expression for clarity. Perhaps that would help you? 
It sounds like you might have been using Visual Studio in Windows, and now you're trying to use Visual Studio Code. The thing is, they don't have the same abilities. Visual Studio Code is an editor only - it knows how to format and work with the code, but doesn't automatically know how to compile it; think of it like a feature rich Notepad. Visual Studio is an Integrated Development Environment (IDE), so it has an editor and compiler, debugger, etc So, you have some options: * find an IDE with a compiler, or clear steps on using an installed compiler * find how to configure Visual Studio Code to use an installed compiler * learn to use a compiler at the command line Most of these will require installing the compiler. Your Linux distribution should have clear instructions for that. 
&gt; I'm an old dude. I wrote my own hash tables for most of my career. Did you need custom hash table implementations though? Apart from C, most languages have a standard library with these basic building blocks. Probably better to use these (unless you have good reasons not to) instead of rolling your own every time which may have a lot of bugs and inefficiencies.
 make hello ./hello 
Same same
Cut me some slack. This was the 1970's 1980's and 1990's.
Two things: 1. This is C++, not C, so you‚Äôd probably be better off asking this in a C++ related subreddit. 2. I am not very familiar with network routing algorithms, but how is the maximum number of hops defined? Because it seems like the true maximum could be unbounded if your network graph has any cycles in it.
lel
Some people can't imagine what life was like before the internet. People get upset when Stack Overflow goes down for an hour. 
Yeah. Tell you the truth, it was also the sixties, but that was FORTRAN...
Ok, let me explain. You do the first scanf(), then what's the first thing to check? You check if the first element if sorted_array[] is equal to your variable. If yes, count++. If not, you only need to decode the "error": if the variable is in the wrong order, you print "keys are correct, but...", if it's already used you print "each key once", if it isn't present, "Wrong key". Then you reset your **count** variable to zero. And so and so unitl you reach count==8 or tries &gt;= MAX. Is everything clear?
Be consistent. `load_code` exits if you can't open the file but returns `null` if `malloc` fails. Pick one strategy and stick with it. Don't use globals to pass variables. The path of the file to open should be passed to `load_code` with a parameter, not a global. Minimize scope of variables. For example, in `load_code` you have `length` in scope for the entire function but it's only used in one block so define it there. Along with that, whenever you can, only define a variable once you can give it a value. That is instead of writing: int x; // other statements x = foo(); you should write: // other statements int x = foo();
Thanks for the input, but I have few more questions regarding your answer. Firstly, I've already tried to pass and argument to the load_code function but it made the program print some garbage instead of actually interpreting brainfuck code. For example while declaring file_name in main function, passing it and then reading through the load_code function, it won't open the file. const char *file_name = argv[1]; char *source = load_code(file_name); ... char *load_code(const char *file_name) { FILE *source_code = fopen(file_name, "rb"); Second question is more theoretical, why is it better to define a variable while I give it a value? That's completely opposite from what they teach us at college. 
crystal. I appreciate it a lot
In C, strings are an array of chars terminated by a NULL ('\0') as is demonstrated by the following program: #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { char str[13] = "Hello, World!"; int i = 0; while(str[i] != '\0') { printf("str[%d] = '%c' (%d ASCII)\n", i, str[i], str[i]); i++; } if(str[i] == '\0') { printf("str[%d] = '\\0' (%d ASCII)\n", i, str[i]); } return 0; } Which produces the following output: str[0] = 'H' (72 ASCII) str[1] = 'e' (101 ASCII) str[2] = 'l' (108 ASCII) str[3] = 'l' (108 ASCII) str[4] = 'o' (111 ASCII) str[5] = ',' (44 ASCII) str[6] = ' ' (32 ASCII) str[7] = 'W' (87 ASCII) str[8] = 'o' (111 ASCII) str[9] = 'r' (114 ASCII) str[10] = 'l' (108 ASCII) str[11] = 'd' (100 ASCII) str[12] = '!' (33 ASCII) str[13] = '\0' (0 ASCII) So, an easy way to count the numbers of tokens is to use a loop to transverse the string and count the number of delimiters: 
Okay. Just making sure I understand: int get_num_tokens(const char str[], char delim) { int count = 0; int num_tokens = 0; char temp[1024]; int i = 0; strcpy(temp, str); //while loop evaluates every variable of string array until reaching last element, which is a null character while(temp[i] != '\0') { if(temp[i] == delim) { //count increases for each character of string array that equals the delimiter count++; } i++; } Then, the number of tokens is count + 1. Also, I should clarify, I know that atof changes a string to a float, and atoi changes a string to an integer, but I do not see a point in the program (so far) that I need to use these functions.
Cool project! Where are your concrete problems?
The 8080 supported virtual memory and paging?
No, I'm just using the 8080 instruction set, and writing process scheduling and memory paging around it
Can you explain what you mean by concrete problems?
Conrete problems as in, where exactly do you difficulties? What problems appear unsolvable to you?
No real concrete problems right now, I'm not really asking for help
Thank you. I am a programmer from 12 years now mostly into web applications. Somehow - i wish to start making my own pcb boards for things i need. I have been practicing C recently. I am curious as to why embedded engineers use and love C so much . How has c survived for so long as its the oldest among the current lot of languages and how and why is C the most preferred for embedded projects. Also could you give me a learning path for getting proficient in C . I am reading K and R book now.
What does it mean if its ~(1&lt;&lt;5)? I know it means shift left by 5 and subsequently multiply by 2^5, but what would the logical operator not do here? So the answer to C would just be 1 &lt;&lt; 5?
I would be glad for something like that! I'd appreciate it if you'd share it with me!
Hey , can you elaborate on why C needs to be replaced ?
I'll try to find it. 
Everything you said was super helpful, but how does the if(guess[j] == sorted_array[i]) after the scanf check for the placement in the array? The program runs but is only checking to see if the first number in the sorted array is correct and then not checking everything else. Also, if the above if statement is true, how would you write another if statement to check if both arrays are completely equivalent? sorry for asking so much, been googling all weekend and can't find anything similar 
Super cool! Looks great so far.
&gt;Second question is more theoretical, why is it better to define a variable while I give it a value? That's completely opposite from what they teach us at college. That's really bad form. There's 2 parts to it; if there is code between where the variable is declared and where it's value is set, it just makes it harder for anyone reading your code to find out what's going on. Second, if you make changes down the road, by splitting up the declaration and the setting of the variable, you are just making more places where mistakes can be made. Maybe you change the name of the variable, then forget to change it where it's set. Not a huge thing for 1 variable, but in a large program over hundreds or thousands of variables, it adds complexity without any benefit.
Sure. Prgrammers are bad at things like making sure that memory which has been allocated gets freed, writing off the end of buffers, making assumptions about what can and can't be done with the memory pointers refer to, how many references to a particular thing in memory there are, whether this memory is currently safe to write to or read from, etc. A great many things that are the cause of common bugs occur because the language doesn't prevent it. I'm somewhat familiar with Rust; it's designed to be a C replacement but with the advantage of making many of the bugs that are rampant in C code very difficult to do. Go is supposed to be another potential C replacement but I don't know anything about it. I'm also very familiar with Swift. Writing in Swift and then going back to C can be very frustrating -- the amount of 'boiler-plate' code you have to write in C to get anything accomplished is a significant burden. (Swift is, however, not a good choice for writing kernel or driver code.) That's most of it. 
Most likely what's happening is you have other code that is incorrect (such as reading/writing past the end of a buffer). Code that is incorrect may appear to work but then because of some other change that affect the memory layout, stops working. Looking at the actual interpreter loop, what keeps `pointer` from being incremented before the start or past the end of `memory`. As for defining a variable where you give it a value, it prevents future errors. Let's say you write code: int x; ... lots of code ... x = get_value(); Sometime later you decide to modify your code, and you end up doing something like: int x; ... some of the code. if (x &gt; 3) do_something(); ... more code x = get_value(); because `x` is already in scope, the compiler will allow this even though it is wrong. By only defining a variable once you can give it a useful value prevents this sort of class of errors.
Faced with a response as abrasive and hostile as this, who could blame them if they went right back?
This should get your up and running https://code.visualstudio.com/docs/languages/cpp
How are you planning to test it? Initially there will be bugs, right?
Testing each instruction will be a bit of a pain. I have a few hex files from a CPM emulator that I can use to test it as well. Memory paging will be a matter of checking the arithmetic, and scheduling will require some monitoring to see which processes are dequeued when, but some experience with writing my own malloc (https://danluu.com/malloc-tutorial/) makes the memory management a bit easier.
How long did it take you to learn programming well enough to write something advanced like this? Ive always found these programs really impressive.
I first started programming (with C) when I was 12, but I didn't get anywhere near good at it until I was 18 (seriously, I may as well not even mention it). I really got serious about programming then, and I've been doing C ever since (I'm 22 now). For me, the best project I've ever done that *really* made me feel like I understood how memory works in C was [this tutorial on writing your own malloc](https://danluu.com/malloc-tutorial/). I highly suggest it. I felt like I gained a super power after finishing it.
Yeah, let's me the thread about me and not the question. That will win your fight.
There might be some useful stuff here: http://altairclone.com/support.htm
You need a `break;` or 2. Or more.
Haha. That's embarrasing 
nahh...spacemacs! 
Save the file anywhere in your disk and open run it on a terminal. https://www.youtube.com/watch?v=B-ru-q_Bm2I PS: 
all distro have at least GCC pre installed! 
Your logic to count tokens by finding and counting delimiters looks correct as long as delim is a character (#define delim ','). `atof()` and `atoi()` would be used to convert each token to a int or a float, which was part of the second requirement for your program.
You need to put 4 spaces at the beginning of each line of code. A easy way to do this is to use sed: $ sed 's/^/ /' infile.c &gt; outfile.txt 
First, take a moment to properly indent your code and avoid cramming multiple variable declarations onto a single line, it is just more difficult to read that way. Local variables like `guess` that are not explicitly initialized are "undefined", so you might want to think about an initial value. On line 24 you read in a value when `j` is 0, then you drop into the next loop and compare `guess[j] == guess[k]` when `k` is also 0. You are effectively saying `guess[0] == guess[0]` which is also true. There are better ways to do what you are doing but they are a little more sophisticated so for now you can duct tape things by adding an AND condition to your if statement like so: `guess[j] == guess[k] &amp;&amp; j != k`
You should show all your code.
Edit to show functions used, but the rest of the code is just print statements. I also just realized that my bottom most else statement does enter, but it segmentation defaults at my get_tokens_array function, so there must also be an error there.
Not true.
This is a lot more advanced than anything I've attempted in C. Two questions out of curiosity. 1. Which School / University are you attending? Online the only resources I've found for attempting something like this would be Nand2Teris or the book "But How Do it Know"? Or maybe reading over the code of a Gameboy Emulator (which used an 8080 as far as I know). So I'm definitely curious what kind of information is "hidden" away at different institutions. 2. And the second question is what is the general approach for something like this? Do you allocate a specific amount of memory, and then use binary flags to test which command is being called and simply have a look up table? Or is there a way to break the process down into different steps, implementing the stack, implementing the ALU, ect, that can be put together once the pieces are in place?
Put 4 spaces in front of every line to format it. And yup, your big problem is in get_tokens_array(). Hint: what's the scope of that array?
The scope of my array is evaluating each element from the previous comma to the current comma and setting in that range into the new array element. So, for the last element, wouldn't it assign the final element into array[i] and end the while loop since there is no longer a string to tokenize after a comma? Or do I need to specify the null character at the end? I am changing the char to a float to make the string element compatible with the float array I am required to store my values inside.
What do you think `(float)'1'` is? Hint: it's not 1.
int dupCount = 0; for (int i = 0;i&lt;SIZE;i++) { for (int j = i+1;j&lt;SIZE;j++) { if (guesses[i] == guesses[j]) { dupCount++; } } } if(dupCount &gt; 0) ==&gt; duplicate guesses. 
Run a nested for on the guesses array to check if any element matches any other element. Place it before the first else if, I think that should do it.
Oh, no. I think I see. You're saying I should do atof to change the string to a float. 
Please put four blanks in front of every line of code so your code appears readable. Click ‚Äúedit‚Äù to edit your post and add the spaces. With code garbled as it is right now, nobody can help you.
This kind of complexity really puts your code to danger. It might lead you to suffer from bugs that are hard to be detected. Although there are programs that might help you with it, as checkmarx, it is recommended to try and keep it simple. Good luck :)
Using hash table on C might not give you what you want. It may sometimes make your code suffer from errors that are pretty hard to be detected as for high complexity. There programs that helps with it, like checkmarx, but it is recommended to try and just avoid those. Good luck anyway.
Also, I have the feeling a lot of people take frameworks and/or libraries for granted...
Wow, thank you!
I ended up implementing uthash in my code and, as of right now, it doesn't give me any warnings or errors. Hopefully it stays that way!
I go to Virginia Commonwealth University in Richmond, Virginia, but I didn't learn any of this at school (my university isn't known as an engineering school). Like you said, I looked over gameboy emulators and then approached it. I can answer the second question in a bit, I'll have to come back to it (I have to go to work :P)
Turn on compiler warnings and don't try to run your program until you have fixed all of them.
You need to initialize your variables. Like all of them.
i am getting 0 compiler warnings. 
even if i do,the same error occurs. 
Here's the approach I took: First off, a single process on the 8080 can use up to 64kib of memory (16 program counter = 2^16 = 65536). I increased this by using an instruction from the Game Boy architecture, which switches between 256 memory banks, increasing the total available memory to 16MiB. To actually emulate the architecture, I'm going through every instruction listed in an 8080 programmer's manual from Intel and recreating each instruction as a function in C. I then have an array of function pointers, and I wrote a quick script to generate an initialization function to assign the appropriate function pointers to each index of the array, which corresponds to the actual opcode for that instruction. For example, I have a function called STAX, which stores the contents of the accumulator into the register specified by the 5th bit from the right. The STAX opcodes are 0x02 and 0x12 for the B and D registers, respectively. I assign this to the array as such: InstructionSet[0x02] = STAX; //... InstructionSet[0x12] = STAX; I do the logic for which register to choose inside the actual function definition. This way, when I read in some char, `c` from memory, l simply call the function sort of like this: InstructionSet[c](); And that's the basic Idea. The memory is paged and dynamically allocated since this is an OS simulator, but from the process's perspective, it's static
Your variable n is the first thing I noticed that isn‚Äôt initialized. It has to have a variable set already or it‚Äôs a random value currently. 
yup fixed that,now it works but not how i want it to,can you take a look ? I have posted a screenshot of my output 
Then you need to turn the warnings up a bit, I get plenty: gcc -g -Wall -pedantic -std=c99 broken.c -o broken broken.c: In function ‚Äòmain‚Äô: broken.c:22:38: warning: format ‚Äò%i‚Äô expects a matching ‚Äòint‚Äô argument [-Wformat=] printf("The data in %i is : %i", a[i]); ^ broken.c: In function ‚Äòhashkey‚Äô: broken.c:29:17: warning: unused variable ‚Äòi‚Äô [-Wunused-variable] int x,count,i; ^ broken.c: In function ‚Äòprobe‚Äô: broken.c:44:9: warning: unused variable ‚Äòi‚Äô [-Wunused-variable] int i,j = 0; ^ broken.c: In function ‚Äòhashkey‚Äô: broken.c:40:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ broken.c: In function ‚Äòprobe‚Äô: broken.c:51:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ broken.c: In function ‚Äòhashkey‚Äô: broken.c:34:14: warning: ‚Äòcount‚Äô may be used uninitialized in this function [-Wmaybe-uninitialized] count++; ~~~~~^~ broken.c: In function ‚Äòmain‚Äô: broken.c:10:5: warning: ‚Äòn‚Äô is used uninitialized in this function [-Wuninitialized] for(i=0;i&lt;n;i++) ^~~ 
I'm wondering about the `&amp;_app_start`, are you sure this is correct? You can only use the ampersand and lvalues. Otherwise, I'd say it casts this address into a `uint32_t*`, then uses the array index notation to access the next element (ie. +32), cast this value again as a function pointer returning void and specifying no parameters. uint32_t *p = _app_start; // cast #1 void (*f)() = ((void (*)()) p[1]; // index/dereference and cast #2 I have no way to verify that rn though.
guess[count] == sorted_array[count]. It automatically resets when is wrong.
This subreddit is about programming in C. As your question concerns C++ code, it is off topic. Please ask elsewhere, for example in /r/cpp_questions.
This sub is for C, not C++. You'll want to post in /r/cpp_questions instead. In the meantime, [here's some documentation](http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution) for producing random numbers within a range, and an example at the bottom to get you started.
You are correct. The _app_start symbol is defined in the linker file.
This makes sense, do you understand the explanation or is something yet unclear?
I don't understand why you'd want to access the next 32-bit address with [1]
hm, I don't know about the specifics of this device but it seems as if the actual function only starts at `_app_start+32`. You can equivalently write void (*f)() = (void (*)()) *(p+1);
I also suggest you to make a Flowchart of your actions. Programming is (first of everything) solving the problem, then write the solution. Whatever the language you are using for.
Not sure if it's relevant here, but an interesting quirk of the Cortex series MCUs is that they set the low bit of an address to indicate that it's a THUMB instruction that it's jumping to. Actual addresses are all aligned to 32-bit boundaries. So if your address is coming out 0x80002001, that's why.
What happens if I enter -1 as a value to be hashed?
works fine,actually i did try doing that. 
But since this is a pointer, adding one will increment it by it's unit which is `sizeof (uint32_t) = 4`, ie. `p+1 = 0x80002004`. It'd make sense if one'd have this code: extern const char _app_start; const char *p = &amp;_app_start +1; // set low bit void (*f)() = (void (*)())p; // cast f(); // call
Were you specifically asked to implement the 8080, or did you pick that architecture yourself? You might consider implementing [MMIX](https://en.wikipedia.org/wiki/MMIX) or [DLX](https://en.wikipedia.org/wiki/DLX) instead.
**MMIX** MMIX (pronounced em-mix) is a 64-bit RISC architecture designed by Donald Knuth, with significant contributions by John L. Hennessy (who contributed to the design of the MIPS architecture) and Richard L. Sites (who was an architect of the Alpha architecture). In Knuth‚Äôs own words: MMIX is a computer intended to illustrate machine-level aspects of programming. In my books The Art of Computer Programming, it replaces MIX, the 1960s-style machine that formerly played such a role‚Ä¶ I strove to design MMIX so that its machine language would be simple, elegant, and easy to learn. At the same time I was careful to include all of the complexities needed to achieve high performance in practice, so that MMIX could in principle be built and even perhaps be competitive with some of the fastest general-purpose computers in the marketplace. *** **DLX** The DLX (pronounced "Deluxe") is a RISC processor architecture designed by John L. Hennessy and David A. Patterson, the principal designers of the Stanford MIPS and the Berkeley RISC designs (respectively), the two benchmark examples of RISC design (named after the Berkeley design). The DLX is essentially a cleaned up (and modernized) simplified MIPS CPU. The DLX has a simple 32-bit load/store architecture, somewhat unlike the modern MIPS CPU. As the DLX was intended primarily for teaching purposes, the DLX design is widely used in university-level computer architecture courses. There are two known implementations: ASPIDA and VAMP. ASPIDA project resulted in a core with many nice features: open source, supports Wishbone, asynchronous design, supports multiple ISA's, ASIC proven. VAMP is a DLX-variant that was mathematically verified as part of Verisoft project. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; Maximum value of an n-bit unsigned integer is 2n+1 - 1. No, it's 2^n - 1.
It is also the same as `*(1 + t)` and `1[t]`.
I figured out why the [1]. This is a bootloader for an ARM processor. The first memory location in the application for an ARM processor is a pointer to the start of the stack. The second item is the first instruction.
My magic 8 ball tells me that you need to post more code.
We need to see an actual testcase. It doesn't do any good to omit parts of the code, because you don't know which parts are relevant and which aren't. (That's not an invitation to look at some 1000+ line mess, it means reduce it down to a simple testcase by removing everything that doesn't matter.) 
I updated my code, but I don't know if it'll be too useful. I'm going through all of my code to see if there's anything else I can post without just posting a mass of code. The only thing I can think of is an assignment from an uninitialized variable, but I can't find any. All assignments are either constants or from another struct that's also initialized with zeros.
Seems that you think that every "error" is know by seasoned programmers... gimme more info! 
I really like the book ‚ÄúProgramming: Principles and Practices using C++‚Äú. The author from this book is also the creator of C++. Another good book is ‚ÄúC++ Primer‚Äú. 
 if(request-&gt;service_name[MAX_SERVICE_NAME_LEN + 1] != 0) That's reading past the end of the buffer.
The stuff you have posted is not relevant at all. That is what I mean by you not being able to judge what is relevant or not. Start by showing us each frame of the stack mentioned in the output, in particular the parts at ns.c lines 60 and 114. 
How is this related to programming in C? What does your syllabus say about this?
This subreddit is about programming in C only. Please post C++ questions elsewhere, e.g. in /r/cpp_questions.
The logical not would leave you with *all* bits *except* the fifth set. 0000 0000 0000 0000 0000 0000 0000 0001 1 0000 0000 0000 0000 0000 0000 0010 0000 1 &lt;&lt; 5 1111 1111 1111 1111 1111 1111 1101 1111 ~(1 &lt;&lt; 5) With a bitwise `and` (`&amp;`), the inverted value can be used to clear the bit. So `x &amp; ~(1 &lt;&lt; n)` unconditionally sets the `n`th bit of `x` to zero.
This makes sense, however I'd then not cast to `uint32_t*` unless this is the canonical way to do it but to `void **` since each element is not a `uint32_t` but a `void *` ie. address itself and an address (be it to the start of the stack or the start of the program) and I thinm it's more portable (works for 64bit too). Also then you wouldn't need to cast it again to `void (*)()` since `void*` are implicit, resulting in: extern const void *_app_start; void *s = (&amp;_app_start)[0]; // stack void (*f)() = (&amp;_app_start)[1]; // entry point f(); // call
You're supposed to take what you know about the normal IEEE formats an apply the same pattern to a hypothetical 5-bit floating point representation. For example, with an IEEE single- or double- precision number, the largest positive number is represented when the exponent is all 1's except the last (as all 1's is for NaN or Inf) and a full mantissa. In your case, that means the largest number is 0b01101. The exponent field is 0b110 or 6 in decimal. But we have to subtract the bias, which isn't given. I'll assume it's calculated just like other IEEE floating point formats as 2^(E-1) - 1, or 3 in your case. So the resulting exponent is 6 - 3 = 3. For the mantissa, we have a single bit plus the implicit bit. Together, they hold the value 1.5 in decimal. The final value is calculated as 1.5 \* 2^(6-3) = 12. The smallest non-zero positive number would be determined similarly. The problem statement doesn't say if you're supposed to include denormalized numbers, though. If we include denormalized numbers, the smallest value is 0b00001, which has the value 0.5 \* 2^-2 = 0.125. If we only use normalized numbers, the smallest value is 0b00010 or 1.0 \* 2^(1-3) = 0.25.
Could you clarify what you mean in saying? &gt; I know it means shift left by 5 and subsequently multiply by 2^5 I fear you may be confused.
Better cast to `(void(**)())` as you really have a pointer to a function pointer.
Commenting out that line fixes the error, but I don't see why it's past the buffer. The buffer is defined as `service_name[MAX_SERVICE_NAME_LEN + 1]`. It's just checking to see if it's null terminated.
If the buffer is (MAX_SERVICE_NAME_LEN + 1) elements long then valid indices are 0 -&gt; MAX_SERVICE_NAME_LEN
Oh duh. Thank you.
I was working on a gameboy emulator at first and then decided to merge the two projects. 8080 is a subset of the gameboy instruction set so i chose it
You mean mean have `&amp;_app_start` to be a `void(**)()`? But `(&amp;_app_start)[0]` is not a function pointer, that's why I chose it to be a generic pointer to a void pointer, because it holds addresses of different types (stack start and entry point function).
I'm a saint, all praise unto me. Here's your code not looking like minified javascript: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //prototypes int functionpercent(float); int functionamount(int); int functiontime(int); int functionmath(int); int math(int); float damount, apercent, CD; int tmonths, nextam, nextpart, famount; int functionamount(int damount) { while(damount&gt;=1000&amp;&amp;damount&lt;=10000) { if(damount&lt;1000||damount&gt;10000) { printf("Please try again\n"); scanf("%d", &amp;damount); } } return damount; } int functionpercent(float apercent) { while(apercent &gt;= 1.0 &amp;&amp; apercent &lt;= 15.0){ if(apercent&lt;1.0||apercent&gt;15.0) { printf("Please try again\n"); scanf("%f", &amp;apercent); } } return apercent; } int functiontime(int tmonths) { while(tmonths&gt;=12&amp;&amp;tmonths&lt;=360){ if(tmonths&lt;12||tmonths&gt;360) { printf("Please try again\n"); scanf("%d", &amp;tmonths); } } return tmonths; } int functionmath(famount) { int i = 0, j; int fpercent = apercent/1200; famount = (damount + damount * fpercent); printf("\nMonths.....CD Amount"); for(i = 0; i &lt;= tmonths; i = i + 1) { printf("\n%d .....%d", i, famount +1); } } int main() { int damount, apercent, tmonths; printf("\nPlease enter deposit amount: \n"); //asks for deposit amount scanf("%f", &amp;damount); //takes input number and sets it as value for 'damount' { damount = functionamount(damount); } printf("\nPlease enter annual percentage: \n"); //asks for annual percentage scanf("%f", &amp;apercent); //takes input number and sets it as value for 'apercent' { apercent = functionpercent(apercent); } printf("\nPlease enter the number of months\n"); //asks for number of months scanf(" %d", &amp;tmonths); //takes input number and sets it as value for 'tmonths' { tmonths = functiontime(tmonths); int i = 0, j; int fpercent = apercent/1200; famount = (damount + damount * fpercent); printf("\nMonths.....CD Amount"); for(i = 0; i &lt;= tmonths; i = i + 1) { printf("\n%d .....%d", i, famount +1); } } }
&gt;I'm a saint, all praise unto me. No, you're proboardslolv5.
That's called a _minifloat_. [Here](https://gist.github.com/legends2k/b991066f84de4dfa1220)'s a complete enumeration of such a data type with source and limits. I think this might just be what you want.
Oh FFS. That's such an embarrassing mistake. I'm, not sure what I was I thinking. Still the logic stands if we squint our eyes and pretend every n+1 is really n. :( 
You could avoid this sort of error by writing: if ( request-&gt;servicename[ sizeof request-&gt;service_name - 1 ] != 0 ) However I would rethink this strategy; the last byte of a char array that's meant to hold a string is often not particularly meaningful, e.g. if you at some stage fill `service_name` with garbage but then write `strcpy(service_name, "FOO");` then it will still report invalid. In other words, for the `is_invalid` function to work properly, it relies on the `service_name` field only being modified in specific ways in the rest of the code. This is called "spaghetti code" - a dependency that's not at all obvious to anyone reading the rest of the code. Perhaps you could instead check to see if there is a 0 somewhere in the array, e.g. `if ( ! memchr(request-&gt;service_name, 0, sizeof request-&gt;service_name) ) return 3;`
Shifting a number x to the left by N would multiply x by 2^N, right? So x &lt;&lt; 4 would mean x*2^4 or x*16
What do you think the answer is an why? As is this question appears to be asking for someone to do your homework and even providing an explanation directly might not be beneficial because it won‚Äôt directly talk to any misconceptions you have which prevent you from answering this currently.
What does input point to when you use it with scanf()?
I'm a little confused by the question. input is a null char pointer
It's not a null pointer. It's uninitialized and points to some random address. Using it is undefined behavior and a crash is your best case scenario. It has to point to a chunk of memory you have permission to write to that's big enough to hold the string being read.
I think the first one is O(1) because it will always run through the program five times while the second is O(N) because it will run through N times. It is linear because the input changes the amount of times it will run through the loop. 
Where did the -2 come from in 0.5 * 2^(-2) when finding out the smallest non-zero positive number? 
You are correct.
I've updated my code as follows and it works more so as intended. However, I now have a weird issue where the prompt is printed during each loop of the strsep loop. An example is that I can input "test 1 2" and I receive: Minix Console$ test 1 2 test Minix Console$ 1 Minix Console$ 2 Minix Console$ Commenting out the print statement in the strsep loop gives me: Minix Console$ test 1 2 Minix Console$ Minix Console$ Minix Console$ int i; char prompt[] = "Minix Console$ "; char *input = malloc(50), *token, *delim=" ", *buffer; // initialize the command pointers char **command = (char**)malloc(2*sizeof(char*)); for(i = 0; i &lt; 2; i++) command[i] = (char *)malloc(50*sizeof(char *)); // the main loop for the minix console while (1) { printf("%s", prompt); scanf("%s", input); buffer = strdup(input); while ( (token = strsep(&amp;buffer, delim)) != NULL ) { command[i] = token; } runCommand(input); } What could be happening that causes the prompt printf to be called during the nested while loops execution?
What result does it produce? Unless I'm missing something, that code should return 1 if the numbers are different, and 0 if they aren't.
Yeah that's what its supposed to produce
I am on mobile but in this case bitwise operators are your friend. Things like bitshift, bitwise or, and bitwise and are likely the things you need. 
sounds like homework
Say you want to convert a value "y" into "y" '1' bits in a row. The value '1&lt;&lt;y' represents 2 to the power of y, and if you subtract 1 from it, you get the desired result of "y" '1' bits in a row. In your case, given l and r, you want "l - r + 1" bits in a row shifted up by r bits. So, "(1&lt;&lt;(l-r+1)-1)&lt;&lt;r" will give you the right mask. Then just or ('|') that into x and return it. An example might help. Say l and r are 5 and 2 respectively. Then "1&lt;&lt;(l-r+1)" is 2 to the 4th power, 16, and subtracting 1 from it, you get 1111. Shift that left by 2 and you get 111100. OR that into a number x and bits 2 through 5 will be set.
Translate x into its 8 bit (or how ever many bits) representation and save it as another String (let's call this new value, String bit). Loop through each char in "String bit". If the digits is within the specified range, change this char to a 1 like you said. Once we are done with this loop, make a new int like "int new_X". We then convert "String bit" to its regular number representation and store it in "new_X". That would be my guess. 
The exponent for denormalized numbers is a constant based on the number of exponent bits. Look up what a 32 bit float has and how it's calculated.
No, no string conversion is needed at all.
Thanks for the information, gonna check them out. Cheers
My bad gonna repost it there.Thanks for letting me know and keeping the post ü•Ç 
Idek what OP wants to do. The whole point of the string is to be able to look at each bit individually. 
555 is not a valid address for an int on your system? And if it was, what number are you expecting to be stored there?
 555 is data i want to store at some garbage address print(*Z) why its not printing my 555 data 
&gt; int *z=555; z is a pointer to an int and you're trying to initialize it with the address 555. Which is very unlikely to be a valid address because of alignment restrictions, and unless you're doing embedded stuff or dealing with memory mapped hardware devices or other esoteric things, a fixed address like that is unlikely to be usable. And if you're doing stuff like that you hopefully should already know this stuff.
Great, I've rewritten the code with your suggestions and it works perfectly. Thanks! 
 Int a; a=*z; If i print(a) ; Shall i get my data 555
No, you'll get a bus error or the like for trying to dereference an invalid int pointer.
 Int *p =some valide adress ; *p=555;// data Print (*p);//this will print 555 huh?? 
Yup.
If you're using Linux, malloc will (close to) never return NULL just because you're out of RAM. You might, however get a NULL return if the size argument is just infeasibly big. and this can happen if (as you pointed out in your edit) you are using an uninitialized variable. Skimming your code there's something else I'd like to talk about: if((key = malloc(sizeof(char) * state_count * 2)) != NULL){ First, sizeof(char) is, by definition, 1. Always. When I see sizeof(char) in code, I use this as a signal (please don't be offended!) to be extra vigilant, because the author may be missing some understanding of how the language works. Second, you have a multiplication in the argument to malloc. How will you prevent integer overflow? The results of _signed_ integer overflow have _undefined behaviour_ in C. Meaning that, if integer overflow is possible in a program, the program can do anything at all, including generating incorrect results at runtime, or generating code that doesn't behave at all as you might expect). To avoid this, it is often better to use calloc(), which performs the multiplication for you, safely.
Correct, but you used ‚Äúsubsequently‚Äù wrong. Perhaps you meant ‚Äúconsequently‚Äù?
Some nits: return(FALSE); `return` isn't a function, the expression doesn't need parentheses. #include &lt;stdbool.h&gt; #define TRUE 1 #define FALSE 0 The point of stdbool.h is that it defines `true` and `false`. #define RANK 10 #define RNDS 10000 Consider using `enum` for magic numbers; one of the benefits of `enum` over `#define` is that the debugger can see the symbolic names for enums. while(dealer.total &lt; 17){ add_node(&amp;dealer); } Think about the naming of things. Inside a function, one is concerned about _how the function is implemented_ and so the variables you use inside the function should reflect that. Outside the function, though, one should not need to be concerned with how the function is implemented (this principle is known as [coupling](https://thebojan.ninja/2015/04/08/high-cohesion-loose-coupling/)). One way in which you can improve things here is for the name of the function to reflect what it _does for the caller_. You might call this function, for example, `deal_card`. if((new = (malloc(sizeof(Node)))) != NULL){ else{ printf("Malloc Failure(Dealer Node). Exiting.\n"); exit(EXIT_FAILURE); } You can wrap your calls to `malloc` into a convenience function that issues the error message and calls `exit. You should send the error message to `stderr` not `stdout`. Some of the other functions also need renaming. `change_node` for example has a name which communicates nothing to me about what the function does. The functions `reduce` and `upgrade` are strongly related, and in fact they do opposite things. You can make your code clearer by giving them more clealy opposite names. Such as `upgrade` and `downgrade` or `reduce` and `increase`. }//end upgrade What happens when you edit your code and the comment gets out of sync with the actual code? For example, like this: void* allocate(size_t items, size_t itemsize) { void *result = calloc(items, itemsize); if (NULL == result) { perror("failed to allocate memory"); exit(EXIT_FAILURE); } }//end_upgrade My point is not, particularly, that this is likely. My point is that this kind of comment (where the comment and the code can get out of sync) is actually a liability, not a benefit. Use your text editor/IDE to help you navigate your code, not hand-written comments. void print_list(Hand d_info){ while(d_info.root_card != NULL){ printf("%d ", d_info.root_card-&gt;r); d_info.root_card = d_info.root_card-&gt;next; } printf("\n"); } This code has a **major** bug. Its job is to print a hand. But it **modifies the data that it is printing**. That's at the very lease likely to be confusing for the caller. The `state_to_key` function appears to have the same problem. void write(Hand *d_info, char *string){ `write` is also the name of a library function (on many systems). It's best to avoid using the same name for your own function. FILE *file; Node *temp = d_info-&gt;root_card; file = fopen(string, "a+"); In modern C, there is bot usually a need to separate a variable's declaration from its initialization. You can just re-order your code like this: Node *temp = d_info-&gt;root_card; FILE *file = fopen(string, "a+"); In `key_found` you should just be able to use the standard library function `strcmp` to compare strings. 
&gt; I cannot for the life of me get it right. Can anyone help me? What's the problem (in your opinion) with what you have?
&gt; *EDIT: I'm an I.D.I.O.T. I did NOT initialize state_count! That's weird, I thought `-Wall -pedantic` would have something to say about that. Oh well.
C++ is off topic in this subreddit. Please ask C++ questions elsewhere.
Let system choose address, it will be SAFE: int x = 555; //initialize value 555 int *p = &amp;x; //assign address printf("Number at address %p is %d", p, *p); or if you want to operate only on address in memory: int *p = malloc(sizeof(int)); //allocate space for your int value *p = 555; // put value in that space printf("Number at address %p is %d", p, *p); free(p); // free you reserved space
Please add four spaces in front of every line and remove the useless ‚Äúend of whatever‚Äù comments, they serve no purpose except to clutter up your code.
If you add parent pointers to your nodes (so you can move directly from a node to its parent), you can traverse the tree in order without recursion or a queue. It's not trivial to figure out, but once you do, the code is very simple, as there are only five possible cases.
on one side C is still being used a lot by embedded system developers. on the other hand we need a replacement. also - rust , go do not fill the replacement inspite of solving the problems ? All this confuses me further about C :) I like C a lot as it allows me to do a lot of making stuff that other languages cannot allow me to do at the moment. 
I don't have time to look through the whole program properly at the moment, but that's a pretty unusual way to loop through a linked list. I would do something more like: for (tmp=new; tmp != NULL; tmp=tmp-&gt;nextptr) { sum += tmp-&gt;data; } Hopefully someone else will see this and be able to spend the time to find the actual cause of the problem.
Sorry I've implemented a lot of what you said but I forgot to reply...my bad. Your answer really helped me at the time and I was able to solve the problem. Thanks a lot!
OK, but you'll have a much easier time implementing a 32-bit or 64-bit RISC architecture that already has paging than trying to reinvent it and graft it onto an old 8-bit instruction architecture.
 What is the difference between below two line Int *p=&amp;x; *p=&amp;x;
It looks you are double counting in the last ‚Äúfor‚Äù loop. Which means you are de referencing the last NULL node. You can change it to &lt; n (instead of &lt;=) and also always check for NULL before dereference as a good programming practice. 
Well the instruction set and the memory paging are kind of distinct. The 8080 processes run as if they were independent machines. inside the process, they have no conception of paging. 
Your for-loop to add nodes does not match the input that you are requesting. First off, you do not check for bad input, such as adding the last 7 nodes of a 5 element list, etc. which will obviously lead to null pointer dereferences, as you're trying to add up more elements than exist. Even with good input, you will get massively wrong answers, as you're asking for the number of nodes to add[1], but you then use that number as the index from which to start adding nodes. Take the following example: 1. We have a list with two elements: 1 and 2. 2. I request the sum of the last two elements, this means `an` is 2. 3. your addnode() function tries to find the an-th element using the while-loop. After the while loop `tmp` is already `NULL`, because you iterated over `an == 2` elements of a list that contains two elements. 4. your for-loop tries to add up elements from `an == 2` up to and including `n == 2`, and thus dereferences `tmp == NULL` leading to your segmentation fault. Note that even when computing the correct first index for adding up the last `an` elements -- I leave how to do that as an exercise -- you will get segmentation faults, as you start counting elements at 0 but in your for-loop iterate up to the element with index `n`, i.e. the (n+1)th element which will never exist. [1] The prompt is a bit ambiguous, it took me a second to figure out that you mean add as in addition, and not add as in add new nodes to the list
I have a hunch that this is going to end with your prof saying ‚Äúnice job, but this was not the assignment‚Äù and failing you...
The requirement is to implement memory paging, process scheduling, IO, and a couple other things. How the processes work is up to us, and he said he would give us 10% extra if we go "above and beyond" the requirements of the project
Bad bot. I am a saint. Very bad bot \&gt;:(
Holy shit. Please format it first. One command on a line is the convention. You had it sort of right for the time. You're using %s instead of %d for decimal value. You can't just use the variable in the print string. printf("TID: [%d] --", id); %d is a token for your variable input for your number. Try that out. You can also have multiple tokens separating variables with commas. printf("TID: [%d] -- [%d]", id, time); pthread_exit() is unnecessary because it's going to end right after your return statement anyway. Use it if you want to exit a pthread while it's in an infinite loop. Your threads are also ending right after your runner ends, so try adding a loop to keep it running. Your next step would be to look into mutexes. 
Uhm, ping /u/FUZxxl ; maybe the guide on how to post code should be restated. Way too many people seems to think that they are supposed to actually insert "‚ê£" characters instead of whitespace.
trying my best to make it legible, I know it sucks :( Think it looks a little better now but I can't figure out how to segment the code in a block like all the other posts.
There's a markup to do it, but I can't remember. Try other sites like pastebin and post the link.
Sorry I definitely did misunderstand how the code should be posted. Should I edit all the "‚ê£" with just four blank spaces to make it more legible? Sorry :/
Thank you! Posted it on pastebin and updated my post.
Four spaces at the start of each line. The `‚ê£` is supposed to represent a space. As for `printf`, you need to give it a format, and if that format contains certain placeholders, you need to give it the values to go in those placeholders. e.g. printf("Hello, World!\n"); will just print out `Hello, World!` followed by a new line. printf("The answer is %d\n", 42); will print out `The answer is 42` followed by a new line. `%d` is the placeholder for an integer. There's more info here: https://linux.die.net/man/3/printf
I found this very interesting, and it sort of made me want to write my own emulator. One question: are you writing an emulator for the 8080, or an OS, or both?
Ok thanks
Much better! I've added suggestions to my original post. 
Thanks for the explanation. But when i try to concatanate the three prints, it does nothing :( printf("TID: [%ld] -- [%s] \n", ctime(&amp;c)); is my formatting okay or am I just messing up somewhere else :x
You're supplying two placeholders there, `%ld` and `%s`, but only providing one value. You need to tell it what the thread id is as well as the time and date - you'll also need to figure out how to determine what this is. Assuming you do and you store it in a variable `tid` then this should work fine(ish): printf("TID: [%ld] -- [%s] \n", tid, ctime(&amp;c)); *However*, now I can see the code more clearly, you shouldn't be using `ctime`. It's not safe to use in threads. `ctime_r` would be better. Another thing with `ctime` (and `ctime_r`) is that they include a newline in the string they produce, which in this instance is undesirable. You should probably look at using `strftime` instead.
I wrote this (just for the practice) a while ago - I would say its perfect!! but it might give you some inspiration https://github.com/chriscamacho/clist 
I am writing an 8080 emulator inside of an OS **simulator**. I'm not writing an ACTUAL OS, but instead I'm grabbing a block of memory and then dividing chunks of it up to "processes" inside the simulator. This runs on a Linux machine, not as an independent OS.
There may be extensions using an installed gcc/clang and gdb or llvm's debugger, check out [C/C++ for VS Code (Preview)](https://code.visualstudio.com/docs/languages/cpp)
So, what have you done so far, and where are you stuck? Post your code, and please make sure it's formatted correctly (or even better, use a code-sharing site). Keep in mind that this sub is for C, not C++. If you want help with C++, try /r/cpp_questions or /r/learnprogramming.
What have you tried so far? Is your program breaking with errors or just not doing what you'd like? You say C/C++ in the title. Does it matter which language? For C++, there are some nice functions such as replace() in the algorithm library that'll do what you need. For C, it'll be slightly more difficult but I would think about spliting the string and using the toupper() function
The best way is to code with knowing excatly where your code could fall. Find any vulnerability and fix it. If you won't, errors may rise, and those are hard to be detected. And unless you're using some program as checkmarx for help it can take a lot of time. Good luck.
Thanks,this is a life saver for my test tommorow :)
all of it actually im doing an online college course and just starting out but this week I am stuck and can't focus lol. Pretend your last name is McDonnell. You're sick and tired of people misspelling it as Mcdonnell (without the capital D in the middle). Write a program that changes all lower case d's in the input to upper case Ds. Use the sample program in the leacure notes under the heading *READ THIS PART* for this chapter as your starting point. Instead of watching for '\n', you'll watch for 'd'. Samples: If the user types Does your dogsled go to detroit Dr. Mcdonnell?# the computer will display Does your DogsleD go to Detroit Dr. McDonnell? If the user types abcdefghijklmnop#qrstuv the computer will display abcDefghijklmnop this is what the teacher wants to see but I haven't got any help this week.
and it is the C language 
I'd recommend you to watch out with malloc as it make the program a lot more complex. Complexity leads to bugs ans errors in the code that are hard to be detected and unless your'e using a program as checkmarx I'd also recommend to work slow and try to detect every vulnerability in the code. Good luck.
Have you written any code yet?
It sounds like you have a sample program that you have to do very little to make it work for your problem already. Have you looked at the sample program in those lecture notes? You usually won't get too much help by just posting your problem and telling us to solve it for you.
Those characters represent spaces. They're used so you can see how many spaces are needed. For future reference, you can just highlight all your code and press the code button on the formatting toolbar. It'll add the spaces to every line for you
walk the string and search for 'd' and raplace it with 'D'. This is a very simple approach that should do it.
#include &lt;stdio.h&gt; #define STOP '#' main() { char ch; /* the character we're currently looking at */ printf("Enter a message and I will tell you what characters are in it.\n"); printf("When you are done, enter a # and I will quit.\n"); ch = getchar(); /* get the first character */ while (ch != STOP) { if (ch=='\n') { printf("\\n"); /* to print a '\', use \\ -- see table 4.1 */ } else { putchar(ch); } ch = getchar(); /* get the next character */ } }
this is what I have I added in the essentials but the code still doesn't compile
The format specifier `%s` in `scanf` reads in whitespace-separated strings. You probably meant to use `fgets` instead.
it should be but I think im over doing it and can't get the programme to do it.
See how that loop runs gets the first character and then checks if is '\n' and then does something if so? You should try to do something very similar, except look for a 'd' instead. It looks like you'll be given '#' at the end of your string as well, so you can keep your code mostly the same. Think about what you need to do when you find a 'd' though. In the example, you print '\\n' when you find a newline. Perhaps you want to print something else? Again, you need to make some sort of attempt. I'm helping more than I probably should based on what you've given. You've just copy-pasted your problem and then the sample code. You'll never learn this if you don't try and ask more specific questions related to your attempt.
This should be really, really simple. Right now you have a program that reads the input and replaces all `'\n'` characters with the string `"\\n"`. You need to do the same, but replaces the `'d'` characters with `"D"`. All that's left is to change the first `printf` so the message to the user matches what the program does.
ok I will give it a shot. I tried changing the \n but maybe I had something wrong within the code.
this: int* p=&amp;x; is like: int* p; p=&amp;x; this:*p=&amp;x; is just what it is and is different from the above. So there is a difference that is a little tricky. Edit: reddit formatting hates me.
I understand its online and I need to see it done in order to understand it just this week is kicking my ass LOL. Other than that I bet I have something so simple out of place causing all the headaches.
Make sure you understand exactly what the original code is doing and why, then the modifications you need to make should be clear.
If you named your program "minix" because it's supposed to be a "mini linux", you should know that there's an operating system called Minix that predates Linux
I did try the code that was supplied but I couldn't get it to work I added the stuff needed to complete it but nothing.
I'm not telepathic. You'll have to show us what you've tried.
Got it I missed a ';' god code can be so tedious sometimes LOL. Thanks everyone for the help.
I'm not really saying that Rust doesn't solve the problems, but Rust has a really difficult learning curve, and there are some things about it that are pretty strange for a c programmer (they look kind of haskell-ish if I remember correctly). I am an embedded system developer, and I use C every day. You can't go wrong learning C, I think. I'm just saying that it needs a modern language replacement. That may or may not happen. 
Ahhh, you're right! I didn't understand the difference between scanf and fgets. Thank you!
That's actually why it's called minix! The project is create a shell to mount and interact with a given minix FS image. 
I recommend you download Microsoft Visual Studio or Notepad++ to test your programs with. (Notepad++ is free, btw.) When you get an error, it will often tell you what is causing it and what line is the problem. In particular, it will tell you if you forgot to put a semicolon or a bracket. It can save you a lotta time.
In the first one, the `*` is part of the type. It should be read as, "declare p of type `int *` (pointer to int)". In the second one, the `*` is the dereference operator. It should be read as, "dereference `p` and store the address of `x` there." This is of course invalid, because the address of `x` is a pointer, but `*p` is an int (because `p` is a pointer to int, and it's being dereferenced.) 
`int *z=555;` is a constraint violation. An integer may not be assigned to a pointer without a cast, except for the special case of a zero constant expression. If you don't see an error message it's time to configure your compiler, as you will be missing out on messages that help to identify mistakes in your code.
Cool. Do you see rust being used in embedded. I used rust but then came across gtk+ which was far ahead and even better organized than the corresponding rust libraries. In fact rust has api's to gtk. So i guess C is still winning for UI apps. I shall look forward to your thought on rust use in embedded and UI.
C/C++? lmaooooooooooo 
1^st write a program which prints every character entered by the user. Hint : inside the loop you need to call both getchar and putchar. Once you have that working, you can think about how to call putchar only if i %3 is 0
That's only there in RES.
If you write a better guide I'll replace the current one.
I can probably do that. Using a picture of code with explanatory text and a red arrow pointing towards the whitespace instead might do the trick? I'll whip up something tomorrow in any case.
I don't think you can put pictures in there.
Sure you can; but it has to be done manually by e.g. a href CSS selector.
I would rather not do that. Try to make it without this sort of thing.
 void print_list(Hand d_info){ while(d_info.root_card != NULL){ printf("%d ", d_info.root_card-&gt;r); d_info.root_card = d_info.root_card-&gt;next; } printf("\n"); } I fail to see how this is an error. Unless I was passing the address of d_info, I cannot see how I am modifying data within d-_info. Other than that, everything else I can see needing to be fixed. Looks like I have much still to learn about C.
Okay. I was under the impression malloc was safe. (This is C, so nothing is safe.)I figured: malloc: general memory allocation calloc: clear new address space and allocate memory realloc: reallocate more address space What makes calloc so unique to that of malloc that multiplication can cause an overflow bug?
A string is an array. So yes, you can treat it as an array. Just make sure to terminate the string with a NUL byte (`'\0'`). This is done implicitly in string literals; your literal `"0123456789"` is actually `"0123456789\0"`. But when you craft your own strings, you have to take care of the termination.
You can treat it like an array if you know its length, but you can just iterate over the pointer until you reach 0 ( '\0' ), if you increment a pointer, it'll move in the size of the variable it points to, so like for a char, it'd move 8 bytes forward and point to the next 8 bytes, just check if that is a nul terminator or not and continue the iteration if needed. Also, arrays are just fancy pointers anyway.
still stuck I'm new to this 
I will find out who you are, and I will give you a zero for this class
Even if I didn't expressly declare it as an array `char str[size]`? What if I wanted to parse the string every two elements 01, 23, 45, etc. Would I then have to create a new separate array for every "token"?
&gt;What if I wanted to parse the string every two elements What do you mean by parse? You can reference any of those substrings by index. If you want each of them separated into their own null-terminated string then yes, you'll have to copy them elsewhere. If you don't happen to care about what's between the groups (if there was *something* between the groups) you can put your nulls there. I end up doing that quite a lot in the embedded world when there's no RAM to spare. If you wanted to copy out 01, 23, and 45 you could do it with strncpy(dest, &amp;str[0], 2), strncpy(dest, &amp;str[2], 2), etc.
I understand. Thank you. 
You have a couple issues, namely you are getting junk data left over in your buffers. #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define LEN 20 int main(void) { char cat[LEN]; char loc[LEN] ... if (input == 'V' || input == 'v') { inv = fopen("inventory.txt","r"); rewind(inv); // this can probably go since inv is just opened above // EDIT: originally I was using these memsets to clear memory while using fscanf // but then kept them to set the NUL byte once I switched to using fgets and strtok. memset(&amp;cat, 0, LEN); memset(&amp;loc, 0, LEN); // calloc comes pre zero-filled char *line = calloc(100, sizeof(*line)); // fgets is naughty, but it keeps the example simple fgets(line, 100, inv); // break the line up into tokens separated by a comma char *p = strtok(line, ","); sscanf(p, "%d", &amp;item); p = strtok(NULL, ","); strncpy(cat, p, LEN); p = strtok(NULL, ","); sscanf(p, "%f", &amp;cost); p = strtok(NULL, ","); strncpy(loc, p, LEN); p = strtok(NULL, ","); sscanf(p, "%d", &amp;date); printf("%d, %s, %f, %s, %d\n\n", item, cat, cost, loc, date); fflush(stdout); fclose(inv); free(line); } ... }
I don't get it. the `&lt;ctype.h&gt;` is accessible by both C and C++
I am not sure that I see the problem with using `malloc(size(char))`. It makes the intent of the statement completely clear and, since it is evaluated at compile time, it has no effect on performance. The only downside that I see is that it takes longer to type, but I am of the opinion that is better to make your code readable and clear than it is to save keystrokes. At least in my experience, clear, neatly structured code is much easier to debug. Not a criticism (I am not a very experienced programmer), I am just curious.
Also: In your inner while loop, you're using "i" as an array index but not setting it in that part of the logic. It is still set to 2 from the exit condition of the for loop higher up, which is out of bounds.
If you know exactly the values you are looking for, you can use a Huffman prefix code. https://en.wikipedia.org/wiki/Huffman_coding
**Huffman coding** In computer science and information theory, a Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. The process of finding and/or using such a code proceeds by means of Huffman coding, an algorithm developed by David A. Huffman while he was a Sc.D. student at MIT, and published in the 1952 paper "A Method for the Construction of Minimum-Redundancy Codes". The output from Huffman's algorithm can be viewed as a variable-length code table for encoding a source symbol (such as a character in a file). The algorithm derives this table from the estimated probability or frequency of occurrence (weight) for each possible value of the source symbol. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I wouldn't use strncpy there because it won't nul terminate the new strings.
[removed]
You're over thinking it. Use a temporary variable to store `array[position]` before modifying the array, then fill `array[n-1]` with that value afterwards.
What would I have to remove in my code to make this work?
you can do something like, &gt; int n = arr[position] &gt; for(int i = pos; i &lt;= arrlength; i++) { &gt; arr[pos] = arr[pos+1]; &gt;} 
Nothing, really. You have to define an `int` variable. Before the `for` loop, you set that variable to the value of the element in the desired position of the array, and after the `for` loop you set the last element to the value of that variable.
Which for loop would you be speaking of? Sorry I am very new to programming
The for loop you use to set every element to the next one.
So the third one, correct?
The second one. The third one is to print the new array. However, in the third array you do have to change something: since now the last value is something you want to display, you have to change the limit of the for loop from `n-1` to `n`.
That expression will not result in signed integer overflow, at least not how it is currently written. `sizeof (char)` returns a `size_t`, an unsigned type (likely an `unsigned long`, though it depends on implementation). In any case, it almost certainly has higher conversion precedence than either of those other two values. They will be automatically converted to a `size_t` as well so the only overflow will be of the unsigned variety. That can still cause unexpected behavior but it is well defined.
`calloc` checks if the multiplication will overflow before doing it. Unless performance is absolutely critical and benchmarking shows `calloc` is the bottleneck, I'd generally opt for `calloc`. Zeroed-memory is a bit safer than uninitialized memory, plus there is the overflow checking as well.
So before the loop I would do something like Temp = position Then after the for loop do Position = temp ?
Close enough. Change `position` to `array[k]` and you have it (note that before the loop `k` is not set, so you have to use `array[0]` instead).
For some reason when I do this the final element just spits out a random number, is this due to wrong placement?
Apart from this being fixed in 1 line of code, could you give an alternative to `strncpy`?
OK, I think I see the problem. First, I made a mistake before: before the second for loop it *is* `temp=array[position]`, not `temp=array[0]`. Second, in that loop, you copy the value of the element `k+1` into the `k`th element. However, since you make `k` go until the last element, you are copying an element that is beyond the end of the array into its last element, and that's why you're getting a random value: you're accessing an uninitialized value. You should change it so that the limit is `n-1` instead of `n`. And with that it should work without problem (I think).
Thank you very much for the help I finally finished it, couldn‚Äôt have done it without your help :) 
strlcpy(), which does what people *think* strncpy() does, is nice. Non standard, though, sadly.
There's a difference between ‚Äúabove and beyond‚Äù and ‚Äúoff to the side‚Äù. He wants you to implement a minimal operating system, and you're implementing a hypervisor instead.
This doesn't do what you think it does: char *str = malloc(10 * sizeof(char)); str = "0123456789"; It first sets `str` to point to a newly allocated block of sufficient size to store ten characters, then sets it to point to an eleven-character string constant containing the digits 0 through 9 and a NUL character. The block of ten characters you allocated is lost, and any attempt to modify the string pointed to by `str` or to pass `str` to `free()` will likely cause your program to crash. What you want instead is either this: char *str = malloc(11); // sizeof(char) is 1 by definition, so no need to multiply strcpy(str, "0123456789"); or this: char *str = strdup("0123456789"); or this: char str[] = "0123456789"; 
wtf?
1. Please add four spaces to the start of each line. 2. Enable compiler warnings and fix all warnings before trying to run your code or asking for help. 3. What does the `getchar` line do? 4. What is the value of `userInput`? 5. What does the `putchar` line do? 6. Given the answers to the previous two question, what does the loop do? 7. Less important: your code defines two separate variables named `i` with different scopes and lifetimes, the first of which is never used. I would suggest writing the program [in English](https://en.wikipedia.org/wiki/Structured_English) first, then translate it to C, possibly via [pseudocode](https://en.wikipedia.org/wiki/Pseudocode).
**Structured English** Structured English is the use of the English language with the syntax of structured programming to communicate the design of a computer program to non-technical users by breaking it down into logical steps using straightforward English words. Structured English gives aims to get the benefits of both the programming logic and natural language: program logic helps to attain precision, whilst natural language helps with the familiarity of the spoken word. It is the basis of some programming languages such as SQL (Structured Query Language) "for use by people who have need for interaction with a large database but who are not trained programmers". *** **Pseudocode** Pseudocode is an informal high-level description of the operating principle of a computer program or other algorithm. It uses the structural conventions of a normal programming language, but is intended for human reading rather than machine reading. Pseudocode typically omits details that are essential for machine understanding of the algorithm, such as variable declarations, system-specific code and some subroutines. The programming language is augmented with natural language description details, where convenient, or with compact mathematical notation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It's sad the glibc still refuses to include this replacement, apparently for [efficiency reasons](http://www.sourceware.org/ml/libc-alpha/2000-08/msg00053.html). I fully agree that it should be part of the standard. &gt;strlcpy(), which does what people *think* strncpy() does [...] I don't think this is necessarily true. It is inconsistent and definitely might be confusing the first time someone encounters `strncpy`, however the man pages (and pretty much all other docs) do a pretty great job of describing this functionality.
You have more faith than I do that people read the docs, especially the fine print. 
* Please insert four spaces at the start of each line. * Your definition of `main()` is incorrect. If you copied it verbatim from a textbook, you need to burn that textbook and get a better one. * The entire `if` / `else` is superfluous; `putchar(ch)` will do the right thing for newline characters. * Read the documentation for `getchar()` *closely*. What does it say about the return type? The type of `ch` needs to match that. * Your loop stops when it encounters a `#`, but not when it encounters the end of your program's input. * Your program does not even *attempt* to do what you need it to do. What's missing? * When talking about a program you've written that doesn't work, or about changes you've made, *always* include the actual code, not just a description of it.
You have three separate `printf()` statements. Each thread will execute *its own* three `printf()` statements in order, but you have no way of knowing which order the threads will run in, or when they might interrupt each other, or which one will win the race if they are running in parallel on separate CPU cores. Your program *may* work as intended if you consolidate the three `printf()` calls into one, but that depends on how `printf()` is implemented. In the extreme case, the output could be interleaved character-by-character, so your program ends up printing `TTTTIIIIDDDD:::: [[[[` etc. In practice, if you're working on Linux, BSD or Windows, you will *probably* be fine.
Maybe just say "indent by 4 spaces, hereafter denoted as '‚ê£'."?
I already say something to that effect but I can try to adjust the wording.
Please post what you got already, where you are stuck. Just copying the assignment text is zero effort, we are not here to make your assignments.
This is more like "hey do my project for me haha! " Which is not welcome here tbh. Try and create at least the basic structre of the program and then when you face problems you can ask them. Good luck!
I think brevity is key, people are usually too lazy to read more than a few short sentences of instructions.
Yeah, good point. If you can send me a reasonably good new guide, I'll replace the current one with it.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i, howMany; int total = 0.0; float average = 0.0; int * pointsArray; printf("How many minutes do you want to eat?\n"); scanf(" %d", &amp;howMany); pointsArray = (int *) malloc(howMany * sizeof(int)); printf("Enter the candies in a bag! \n"); for(i=0; i&lt;howMany; i++){ scanf(" %d", &amp;pointsArray[i]); total += pointsArray[i]; } average= (float)total + (float)howMany; printf("total bags are %f", average); return 0; } I'm a noob in this So I tried to solve this using Bucky's technique but I'm stuck haha :P
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i, howMany; int total = 0.0; float average = 0.0; int * pointsArray; printf("How many minutes do you want to eat?\n"); scanf(" %d", &amp;howMany); pointsArray = (int *) malloc(howMany * sizeof(int)); printf("Enter the candies in a bag! \n"); for(i=0; i&lt;howMany; i++){ scanf(" %d", &amp;pointsArray[i]); total += pointsArray[i]; } average= (float)total + (float)howMany; printf("total bags are %f", average); return 0; } I'm a noob in this So I tried to solve this using Bucky's technique but I'm stuck haha :P
To start: &gt; Input specification: The input is a sequence of integers. The first integer N is the number of bags. The next integer K is the number of minutes you have. The next N integers is the number of candies in the bags. Your code to read input as it is now isn't following that spec. Edit: &gt; Output specification: The output of your program is a single integer which represents the maximum number of candies you can eat. **Do not produce any extra text other than this.** Your output doesn't obey this spec either. Thirdly, the O(n log n) runtime, plus the obvious solution of repeatedly finding the maximum value out of the available bags, suggests a particular data structure. What have you covered that might be suitable to store this *heap* of bags of candy? Or if that doesn't ring a bell, any sort algorithms that run in O(n log n) time?
Although this also is quite long, I think it emphasizes the core points better as it's less continuous text, what do you think? --- **Posts with embedded code:** For in-line code surround it with backticks ('`') like this: &gt; This is normal text and `this is monospaced`. For larger blocks of code, indent every line with four spaces (hereafter denoted as '`‚ê£`'. Eg. the following &gt; A simple ``Hello, World!'' program. &gt; &gt; ‚ê£‚ê£‚ê£‚ê£#include &lt;stdio.h&gt; &gt; ‚ê£‚ê£‚ê£‚ê£ &gt; ‚ê£‚ê£‚ê£‚ê£int main() &gt; ‚ê£‚ê£‚ê£‚ê£{ &gt; ‚ê£‚ê£‚ê£‚ê£‚ê£‚ê£‚ê£‚ê£printf("Hello, world!\n"); &gt; ‚ê£‚ê£‚ê£‚ê£} becomes: &gt; A simple ``Hello, World!'' program. &gt; &gt; #include &lt;stdio.h&gt; &gt; &gt; int main() &gt; { &gt; printf("Hello, world!\n"); &gt; } *For more details, please have a look at the commenting wiki page where the full syntax for formatting in reddit posts / comments is explained.*
This looks good. Can you post this again indented by four spaces so I can copy/paste it into the submission guide?
Indent all code blocks with four spaces please, as written in the submission guidelines.
There you go. Ninja edit: Forgot two spaces at some EOL. ----- **Posts with embedded code:** For in-line code surround it with backticks ('`') like this: &gt; This is normal text and `this is monospaced`. For larger blocks of code, indent every line with four spaces (hereafter denoted as '`‚ê£`'. Eg. the following &gt; A simple ``Hello, World!'' program. &gt; &gt; ‚ê£‚ê£‚ê£‚ê£#include &lt;stdio.h&gt; &gt; ‚ê£‚ê£‚ê£‚ê£ &gt; ‚ê£‚ê£‚ê£‚ê£int main() &gt; ‚ê£‚ê£‚ê£‚ê£{ &gt; ‚ê£‚ê£‚ê£‚ê£‚ê£‚ê£‚ê£‚ê£printf("Hello, world!\n"); &gt; ‚ê£‚ê£‚ê£‚ê£} becomes: &gt; A simple ``Hello, World!'' program. &gt; &gt; #include &lt;stdio.h&gt; &gt; &gt; int main() &gt; { &gt; printf("Hello, world!\n"); &gt; } *For more details, please have a look at the commenting wiki page where the full syntax for formatting in reddit posts / comments is explained.* 
Almost perfect, just add a link to the commenting wiki page into the last line. Just edit the comment and let me know.
Im creating all the necessary scheduling and paging algorithms. I dont see what else would qualify this as meeting the requirements of the assignment
I see you were faster, was on mobile
No problem.
That's because usually the character `'1'` is not equal to the number `1`. For example, in the common ASCII character set, `'1'` is equal to 49. To fix your code, simply change `firstA == 1` to `firstA == '1'`.
Thank you very much for your quick help, what an easy fix!
I hope that Rust, or something like it, makes gains in embedded systems. I help fund (at a low level) the development of redox, an OS written in Rust. AFA UI and languages, the underlying GUI libs are generally written in C and C++, but that doesn't say much about the languages choices you have for constructing a UI. Mostly that's going to depend on the target platform, I would think. Personally I've written about zero UI code in C. Mostly I write UI code in swift and objective C because I do that on my own time on a Mac. As far as linux goes, I've used Qt (C++) but have little experience with GTK. With linux, I think your only real choices are Qt and GTK+ (I could be out of date on that). 
thank you for discussing in depth :) cheers.
You do you.
There is no difference between `char* a`, `char * a` and `char *a`. All three of them declare a pointer to `char` called `a`. They're just different styles. I prefer `char *a` but others might prefer the other options. A pointer is something which refers to some other space in memory. Imagine the following: char hello[] = "Hello, World!"; char *a = &amp;hello[0]; This would look a bit like this in memory: +---+---+---+---+---+---+---+---+---+---+---+---+---+----+ | H | e | l | l | o | , | | W | o | r | l | d | ! | \0 | +---+---+---+---+---+---+---+---+---+---+---+---+---+----+ ^ | a Here you can see `a` is pointing at the start of the "Hello, World!" array of characters. Sorry I don't have time to give a fuller answer but there's a lot of info out there about pointers.
No difference, only syntax. I like to stick my ```*```'s on the variable name like char *foo or when casting (char *) foo [Here's a very professional video explaining pointers](https://www.youtube.com/watch?v=5VnDaHBi8dM)
so what does `char *a = "Hello World"` do?
There's a static string in your programs executable (in Linux: .data section) whiches address is saved in a.
That declares `a` to be a pointer to `char` and makes it point to the beginning of some memory area which contains the bytes `Hello World` and a NUL byte at the end. That memory area is allocated statically which means that it's allocated once at the beginning of the program and remains allocated for the entire duration of the program.
Watch [this video](https://www.youtube.com/watch?v=5VnDaHBi8dM). Everything should be clear then.
ah ok
The other answers are correct, but for the sake of illustration, these are different when multiple declarations are used. char* a, b; // Declares a as a pointer-to-char and b as a char char *a, b; // Does the same thing char *a, *b; // Both variables are now pointers-to-char Basically, white space doesn't matter, but the * binds to the variable not the type. One way you can get around this is with a typedef: typedef char *myString; myString a, b; // Both of these are pointers-to-char
Fundamentally different at the core. "C/C++" cannot and should not be written.
The general solution is to place an object representing each bag of candy in a sorted data structure, then repeatedly remove the largest bag, add its size to the running total of candies eaten, and insert a new bag with half as many candies rounded down. You do this K times and print the total. If you know in advance the maximum number M of candies that a bag can contain, there is a very simple O(M+N) algorithm: let I, N, K, S, X be integers let C be an array of M integers read N read K for I from 1 to N ( read A C[A] := C[A] + 1 if A &gt; X ( X := A ) ) for I from 1 to K ( while C[X] = 0 ( X := X - 1 ) S := S + X C[X] := C[X] - 1 C[X/2] := C[X/2] + 1 ) print S Note that this program assumes that you won't run out of candy. The fact that the assignment explicitly says your running time must not exceed O(n log n) suggests that you are expected to use a tree, but that doesn't seem likely if the assignment is intended for beginners. BTW, your program looks like you copy-pasted the solution to an entirely different problem and made very little effort to solve the one you were given.
In complement to what others said you may like that analogy: Let's say you have a cool video that you want to share with your friends. You may copy it on a USB stick and give that stick away. It works but you must do a copy per friend and that takes time and resources (memory in particular as you need to buy new sticks). Also if you change the video you need to share it all over again because your friends will still have the old version. Another option is to put the video somewhere everone can find it such as youtube. That way you don't have to copy the video, you only have to share its location, its URL. Of course you still have to copy this URL for each friend but it's way lighter and requires less resources, less memory. Furthermore if you change the video everybody benefits from it. In C you share data by copying it. If you pass data to a function a copy is realized. That corresponds to our first example. In the second one you're using pointers. An URL is litteraly a pointer to some online content. The only difference is that C pointers point to places in memory, not web services. All advantages and disadvantages we discussed also apply to C pointers. Sometimes you want each function to behave on its own version of data (for example because it will modify it but you want to keep the original). In that case you should copy it. But if you want each function to act on the very same data just tell the function where that data lies instead. That information, this memory address, is called a pointer.
&gt; I want to do an audio wiki.I need someone to code it How much are you willing to pay?
Are they different in context to OP's question? I mean, he'd be alright to use the `ctype` header regardless, just like tons of other headers. I'm not saying C and C++ are the same language but they share a lot of similarities.
&gt;And what is a pointer in general? I'm glad someone finally asked this question. I haven't been able to find an answer to it in any book on C or the internet. EDIT: lol
When you parse a prefix code when you read a single bit the very first code you get will be the correct value. So therefore you do not need delimiters at all.
That doesn't solve OP's problem. In fact, it replaces the relatively simple problem of reading characters from a string with the far more complicated problem of maintaining a dictionary and reading variable numbers of bits from a bitstream.
I would explain you their differences but google for it!
*facepalms* that explains the seemingly random outputs between runs haha. I just didn‚Äôt understand how to put them in one line because I‚Äôve never worked in C before(Operating system class). Thankfully I get it now and just need to figure out how to get the unique thread id. Thank you üôÇ
Similarities sure... Then again, C++ is (mostly?) backwards compatible with C, but C certainly is not forwards compatible with C++. They are extremely different in many aspects, and not only syntactically, but also the approach to programming, or paradigms used. That's why I refuse to say "C/C++". To answer you question though: I guess it doesn't really matter that much since he could indeed use `#include &lt;cctype&gt;` (no `.h`). However, it's possible that OP gets different suggestions for solutions if someone decides to approach it the C++ way instead of the C way. 
Did it solve it? Because I think I see an issue which might also be causing a problem. 
I know how they are different but how relevant are they in OP's problem?
I found [Ted Jensen's tutorial on pointers](http://pweb.netcom.com/~tjensen/ptr/pointers.htm) extremely helpful. 
Define a struct with all the variables and then define an array of that struct. typedef struct{ int item; int cost; ... (add the rest) } item_t; item_t atrecords[100]; Or if you don't know how much items you want to store in the array, have a look into linked lists. 
Show the whole program. This must be being called from a loop.
The function is in a library triangle.c, with prototypes in header triangle.h. Main.c is completely unrelated, since according to printf in the function, the loop happens there. Otherwise the function is not called anywhere, if not by a printf("%lf", distance(triangle.x,triangle.y)); There isn't a single while, or for in the whole program, nor a recursion. I have no clue.
The thread ID (as returned by `pthread_self()`) is opaque‚Äîyou can't make any assumptions about its type or meaning. However, it is *usually* a pointer, so you can print it with `%p` and a cast to `void *`: printf("thread %p\n", (void *)pthread_self()); 
Man, C is WYSIWYG and KISS, no loops/gotos/recursion = single pass. No way you can escape that, except *maybe* with some horribly corrupted stack, but I can't really imagine a real life situation.
Post the whole program. Then others can see exactly what you have. Show inputs and outputs too.
Ok, as requested, here is the whole code (sorry for awfull formatting)
4 spaces in front of every line will format it properly
Got it, thanks! I'm still having one issue though. The only function our professor mentioned for getting the system's time is cTime. It's obvious to me now that at the end of cTime, a new line is produced. time_t c; c = time(NULL); printf("TID: [%ld] -- [%s]\n",pthread_self(),ctime(&amp;c)); Sample output: TID: [25769804592] -- [Wed Nov 1 11:38:32 2017 ] How would I get the ']' to stay on the same line? /u/henry_kr mentioned to use strftime but the professor never mentioned that. Is there a way I can convert the time to a string and 'substring' off the "\n." Like I said, this is literally the second cprogram I've ever had to write so the unfamiliarity is real. 
It doesn't appear to be printing the printf you have in main, One explanation is you're running an older version of the executable. Rebuild and make sure you have no compilation errors
I have no loops in my code
Mmm nope. Doesnt seem to work. :(
Well you're either not compiling what you think you are or not running what you think you built, because if you've shown all the output then it's not the output from the code
I'll restart my PC and see where it leads me
I am very tired so I probably missed something, or you haven't posted your actual code, but here you *are* calling `distance` seven times (three times from each of two of the `is_` functions, plus one by itself) and in those functions and elsewhere you're evaluating the functions themselves in the comparisons. So, instead of `if(is_scalene(t))`, you're writing `if(is_scalene)`, which is not what you want, and, though not by definition, is tautological in modern systems (you're checking if `is_scalene` is stored in a non-zero address, which always is in a modern system unless you write your own OS to prove me wrong).
You could say that in the example char *a, b; you are *declaring* two variables of type char, namely b and *a. For b, this is already enough to define the memory where b is stored, whereas for *a it is not. But after assigning a piece of memory to a, *a and b behave pretty much the same.
What's the declaration of `search_array`? I'm betting you didn't leave enough room for a null terminator, which is getting overwritten.
I would have dealt with this issue properly if only I could have distance that works. Isolating just function distance() still gives me the same result.
Bare in mind that i've posted 3 different files.
I'm using Visual Studio community 2017, I always build and debug with latest files. There is no way I'm not compiling the right project.
Hmm. Again, maybe it's just me, but I don't see a declaration for `distance` in `triangle.h`? I don't know a lot about that, but I think C assumes default types (in this case, `float`) for parameters and return values from functions that aren't declared, and interprets the values as if they belonged to those types, with no actual casting, which would cause a wrong interpretation (as `float` and `double` aren't compatible in the way `int` and `long` are), but I may be making it up or misremembering. About the function looping 7 times, however, I'm a bit more concerned. If you really isolated that function, so that you have a dummy `main` that calls `distance` and returns and nothing else, and still you loop seven times, either you need to ditch the old binary files, the compiler or the OS.
&gt; `char *a, *b; // Both variables are now pointers-to-char` In this case, are both pointers to the same char, or different ones?
Here's an update. By removing printf in the function, console output had main.c's printf thay showed the value of my distance function. The value however was grossly innacurate: 1078002303.000000 Oh and triangle.h doesnt have distance decalred, since it's a utility funcion for triangle.c. Which doesnt make sense, since printf inside the function showed correct values. Could this be some sort of stack corruption? UPDATE: ok so I realised using a utility function in main was a stupid move, however after declaring it in triangle.h I had an error "function cannot convert from point to point." Could this be the real issue? Function not recognizing struct inside a struct? 
I see you've still not got the hang of putting four spaces in front of code, don't worry, you'll get there in the end. You can supply a precision to `printf` via the format string, to limit how many characters are printed. e.g. printf("TID: [%ld] -- [%.24s]\n",pthread_self(),ctime(&amp;c));
&gt;Oh and triangle.h doesnt have distance decalred, since it's a utility funcion for triangle.c. I don't quite understand you. If you are using `distance` outside `triangle.c`, you should declare it in `triangle.h`. If you want to remove it later from there, remove also any usage in `main.c`. &gt;Which doesnt make sense, since printf inside the function showed correct values. Could this be some sort of stack corruption? I thought this disproved my theory, but now that I think about it, I think it proves it (or makes it seem more probable). Declare the function in the header and try again.
Yes, my bad, I did not declare distance function in the header for usage in main (that's why it never showed up in the output!). Anyways, it still doesnt appear to work correctly, and does the same thing: loop 7 times, return a very big number.
**Pointers** are a type of **variable**. Other types of variables are: - **int** (integers) - a Real Number that ranges from 0-255. It is made of 8 bits. - **float** (floating point numbers) - a number that can be positive or negative and can have decimals after it. It is 32 bits long. - **char** (characters) - A single letter. - **string** - a row of characters. this can make a sentence. Just like how an **int** can hold a *number* and a **char** can hold a *single letter*, a **pointer** holds something. That something is called a *memory address*. ---- *Lets make a variable:* int x = 100; This command is actually doing 5 things: - It found a space in memory that is the size of 8 bits. - It allocated (or reserved) that space in the computer's memory. Nothing can take that space unless we specifically tell it to be taken. - It recorded the address of where that memory is. - It associated that address with the variable name X. - It changed the 8 bits in that spot in memory to reflect the number 100 in integer form. ---- In math, we consider that X represents a number. In this case, 100. In computer science, X represents 3 things: - A name that humans can recognize. - That name "points" to a piece of memory that holds a value. - That name also represents what kind of value we are looking at. In this case, an 8 bit integer. We used int x, so it is an integer. If we used char x, it would be a character. **So, in the math world we think:** x = 100 **In the computer world we think:** x = **The name that human programmers gave the data type:** X **Data Type:** Integer **Address:** 0x7fff9575c054 **There is an invisible process that fetches the value at the address:** **Value at Address 0x7fff9575c054:** 100 ---- **But lets say we wanted to look at what address that x "points" to.** We first need to realize that pointers are not numbers or a string of chars. They are their own datatype. The data type for an int pointer looks like int*. This is kind of confusing because the asterick goes before the variable, not after the data type. Ex: ([derived from this](http://www.java2s.com/Code/C/Pointer/Useprintftooutputvariablesaddress.htm)) int x=100; int y=200; int *pointerX, *pointerY; pointerX = &amp;x; pointerY = &amp;y; printf("Addresses pointed to at X and Y: %p %p", pointerX, pointerY); **The output might look like:** Addresses pointed to at X and Y: 0x7fff9575c054 0x7fff12345678 ---- #So, what are pointers? "int *pointerX" is a pointer. It's sole purpose is to merely hold the address of a piece of memory. Which piece of memory? int *pointer = &amp;whatever_piece_of_int_formatted_memory_you_like You can do this with char and float also. just remember that: int *a; char *b; float *c; Are NOT the same kind variables. They are in fact, 3 different "kinds" of pointers. You can't use a letter pointer for a number. 
Please update the code so that we can see what you have until now. Still, I find it pretty weird. I think I'm out of ideas; I guess I'll try to run it on my own computer. Tell me the input you used, and the expected output.
Yea, that did it. I had it set to 5, changed it to 8 and it works great now. Thanks a million!
&gt; w they are different but how relevant are they in OP's problem? I dont care about his issue...I got annoyed by the C/C++ and smiled...thats all!
I think I solved the issue. VS was indeed building an outdated version. I restarted the PC and VS, after a good hard reset it compiled everything without a problem. Thank you for your time, sorry for the bother :).
Restarting my PC helped! VS was building an old version for some reason. After a restart everything works like it should. Thank's for the help, and sorry for bothering you!
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char ch[30]; printf(" enter string"); scanf("%c", &amp;ch); for(int i = 0; i &lt; 30; i++) { if(i % 3 == 0) { printf(""); } else { putchar(ch); } } return 0; } 
This is what I have so far but now my problem is I can not get any inputs to print 
I do hope you will be writing your own version and not passing it off as your own...
Talk to the guys at xiph who worked on Ogg Vorbis, FLAC, and Opus. Pretty cool people honestly. But best in the world is not at all cheap.
If you are new to programming, I'll say give "Head First C" a shot. It explains memory and pointers nicely without being overwhelming.
So where are you stuck? Please format your code by indenting every line of code with four blanks, otherwise it's very hard to read.
&gt; They're just different styles. I prefer char *a but others might prefer the other options. I think this way is better because it makes it clear that a is a pointer. Plus if you declare multiple pointers on a single line, then you need to make sure the asterisk is in front of each variable name. So for example, if one did this: `char* a, b, c;` It's not totally clear what one is trying to accomplish. But what you'll have is a char pointer to a, and 2 regular chars, b and c. If you want three pointers you have to do: `char *a, *b, *c;` So I think keeping the asterisk with the variable name makes it cleaner and clearer. 
 #include &lt;math.h&gt; #include &lt;stdio.h&gt; int main(void){ int n = 100; double sum = 0; for(int i = 0; i &lt; n; i++){ double square = pow(i, 2); double dividend = pow(square + 5, 3); double divisor = sqrt(n); sum += (dividend/divisor); } printf("%f\n", sum); } replace n with your value
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #define MAX_LENGTH 1024 #define DELIMS " \t\t\r\n" int main(int argc, char *argv[]) { char *cmd; char line[MAX_LENGTH]; while (1) { printf("$ "); if (!fgets(line, MAX_LENGTH, stdin)) break; // Parse and execute command if ((cmd = strtok(line, DELIMS))) { // Clear errors errno = 0; if (strcmp(cmd, "cd") == 0) { char *arg = strtok(0, DELIMS); if (!arg) fprintf(stderr, "cd missing argument.\n"); else chdir(arg); } else if (strcmp(cmd, "exit") == 0) { break; } else system(line); if (errno) perror("Command failed"); } } return 0; } This is my code and only working without pipes
 int main(int argc, char *argv[]) { char *cmd; char line[MAX_LENGTH]; while (1) { printf("$ "); if (!fgets(line, MAX_LENGTH, stdin)) break; if ((cmd = strtok(line, DELIMS))) { errno = 0; if (strcmp(cmd, "cd") == 0) { char *arg = strtok(0, DELIMS); if (!arg) fprintf(stderr, "cd missing argument.\n"); else chdir(arg); } else if (strcmp(cmd, "exit") == 0) { break; } else system(line); if (errno) perror("Command failed"); } } return 0; } Here's your code, formatted
You need to put four spaces in front of every line of code, otherwise your code comes out unreadably! Please click "edit" and fix this. So, what stops you from implementing pipe support?
I don't think an "int" is 8 bits anywhere anymore. More likely 32 bits. However the point is made.
if you use it incorrectly you can clog up the buffer
they have different names and are different "things" with different memory addresses. You can stuff anything you want into those memory addresses but in general you would stuff the address of some char string thing somewhere. 
upvote the ascii art !
also the pointer 'a' points to the memory address of the H in Hello World. the rest follow in memory. iirc
Don't do OP's homework for them.
You are correct about `print_list`, sorry. I misread the code, because passing structs by value is so unusual. A more conventional implementation would look like this: void print_list(const Hand *h){ for (const Node* card = h-&gt;root_card; card != NULL; card = card-&gt;next) { printf("%d ", card-&gt;r); } printf("\n"); } 
&gt; However the point is made. Hehe...
Please pay attention You fixed item 7 on my list but completely ignored items 1 through 6. You won't get any help from me until you address them all. 
1. Please insert four spaces in front of every line of code. 2. Enable compiler warnings and fix them all before asking for help (unless, of course, you're asking how to fix a warning). 3. Did you read what I wrote about the return value from `pthread_self()`? 4. Don't use `ctime()`. Ever. Use `strftime_r()` instead. 
Looks like you're trying to implement a [monitor](https://en.wikipedia.org/wiki/Monitor_%28synchronization%29). This is usually done with a mutex and one or more condition variables. BTW, when `&lt;sys/types.h&gt;` is used, it should be listed first. 
**Monitor (synchronization)** In concurrent programming, a monitor is a synchronization construct that allows threads to have both mutual exclusion and the ability to wait (block) for a certain condition to become true. Monitors also have a mechanism for signaling other threads that their condition has been met. A monitor consists of a mutex (lock) object and condition variables. A condition variable is basically a container of threads that are waiting for a certain condition. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Okay. How about simply tweaking it such that we remove the '‚ê£' characters, bold "four spaces", and remove the bold focus on "Posts with embedded code": # submitting to /r/C_Programming Posts with embedded code: For in-line code surround it with backticks ('\`') like this: This is normal text and `this is monospaced`. For larger blocks of code, indent every line with **four spaces**. Eg. the following A simple "Hello, World!" program. \ \ \ \ #include &lt;stdio.h&gt; \ \ \ \ \ \ \ \ int main( void ) \ \ \ \ { \ \ \ \ \ \ \ \ printf("Hello, world!\n"); \ \ \ \ } becomes: A simple ``Hello, World!'' program. #include &lt;stdio.h&gt; int main( void ) { printf("Hello, world!\n"); } For more details, please have a look at the commenting wiki page where the full syntax for formatting in reddit posts / comments is explained.
Others have explained how `char* a` and such are the same thing. I think of pointers as indexed into an array. All of memory is basically a huge array, and a pointer is just an index. For example, it's sometimes easier or faster to move indexes around than to move entire chunks of memory. I learned this years ago in Applesoft Basic. When sorting an array of strings, swapping array elements was time consuming. So, imagine an array, A, as follows (beware: Basic pseudo-syntax follows) 10 REM Initialize an array unsorted 20 A(1)="Zebra": A(2)="Walrus": A(3)="Koala":A(4)="Lion": ... A(120)="Baboon" 30 N=120 Now, to do a simple bubble sort of this array would require a lot of swapping which took a lot of time on the 1MHz CPU (yes, 1 megahertz). So, it is faster to have an array of indexes like so: 50 REM Set up an array, I, of indexes 60 FOR J = 1 TO N: I(J) = J: NEXT 100 REM Now, do a stupid-simple bubble sort 110 FOR J = 1 to N-1: FOR K = 1 to N-1 200 IF A(I(K)) &lt;= A(I(K+1)) THEN GOTO 220 210 X=I(K): I(K)=I(K+1): I(K+1)=X 220 NEXT K: NEXT J Now, back to modern times. It is still sometimes faster to manipulate pointers than an entire `struct` in C. It is also sometimes more convenient for memory that has is allocated at run-time like with `malloc`. In C, a pointer is also needed to allow a function to modify a variable that isn't global. 
I did some more research and wrote it differently. #include&lt;stdio.h&gt; #include&lt;string.h&gt; main() { char s[30]; int i; printf("Enter a string: "); scanf("%s", &amp;s); for(i = 0; s[i] != '\0'; ++i); { if(i % 4 == 0) { printf("%s", s[i]); } } return 0; } Now i have the program testing the length of the string from the user. Next it takes the length and modulo it by 3 i want every third character from that string. The output is starting to display nothing. So now i am stuck on the output 
 Thanks, I get it now :D Also thank you for showing me how to ignore the \n. Really appreciate it.
 1. I get it now, I mistakingly put 5 spaces previously and that's why it didn't work. 2. I already have compiler warnings, I just wasn't getting any. My code was compiling. 3. I read what you wrote about the return value from pthread_self() but I don't know if that's the value my teacher is looking for. I'll ask him. 4. He specifically only told us about ctime(). I have no idea what strftime_r() does. This is only my second cprogram :p Thanks for everything though. Beyond helpful and appreciative. 
Note the name of this subreddit.
This is a C subreddit, not c#, you'd be better off in /r/dotnet , and much better off on stack overflow, and much much better off with a better description. AD is a dog at the best of times, so good luck.
Did you have an actual question?
Yes, sorry for not posting it. https://uploaduj.me/Storage/Slike/Uploads/Al5Wu-1509577735.jpg
I was drunk and bored im sorry
get a book...or read some half ass answers!
Ah I see. So you didn't plan to delete your post.
Please pay attention You fixed item 7 on my list but completely ignored items 1 through 6. You won't get any help from me until you address them all. 
1. No, five spaces would have worked. You were using fewer than four. And use four spaces for input and output as well. 2. If you aren't getting compiler warnings, they're either turned off or not turned on high enough. The fact that your program compiles and runs is immaterial; I'm talking about *warnings*, not *errors*. 3. I told you the correct way to print the return value from `pthread_self()`. You went and did something different. 4. Sorry, I meant `striftime()`. I'm sure your system comes with documentation, and if not, there's always Google. If your prof insists on `ctime()`, tell him that it's not thread-safe and that its output is ambiguous and difficult to parse. Use `strftime()` instead with a format string of `"%F %T %Z"`.
Don't worry, your program is subtly wrong, so they'll fail if they just copy it. It's also slightly inefficient, but no biggie.
1. Okay I apologize. Obviously not intentional and I‚Äôll try to make sure I follow the correct format from now on. 2. Never heard about compiler warnings but I‚Äôll definitely turn them on/up. 3. I actually //commented what you said in my code and planned on asking my instructor about it. Trust me I listened to everything you said and even watched videos trying to inform me. I was just listening to another posters comment on how to print the line as well. 4. Will definitely mention this as well to my instructor. Thanks again I really appreciate your feedback :)
What's wrong about it
1. Please insert four spaces at the start of each line. 2. Please turn on compiler warnings and fix them all before asking for help. 3. In `addRecord()`, read through the loop line by line and tell yourself out loud what each line does. 4. Use a struct.
Is passing the address of a struct as a constant pointer the C Standard standard? Or is it mostly just an industry/commercial standard?
Try it with n = 1.
C and C++ are different languages.
We're actually going over nearly the exact same subject in my OS class right now. I thought our textbook covered the subject really well, and it's free online: Check out [Operating Systems in Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/); you're going to want chapter 31. It goes over semaphores in about 20 pages or so, and if I remember correctly there's example code implementing producer-consumer with semaphores, just like you're looking for.
No blog spam please.
That is because although you have allocated memory for holder you do not allocate for `int *num`
Your post is not related to programming in C so I removed it.
`holder-&gt;num` is uninitialized, and dereferencing it invokes undefined behavior. You have to assign `num` to point to something valid before you can write `num[x]`. 
Thank you very much for this resource!!! My textbook is alright, but my class is not so great at explaining the programming side of things. I will definitely take a look at this!
Somewhat unrelated, and it‚Äôs been a while since my algorithms course, but wouldn‚Äôt the naive solution with an array that you iterate through linearly K times be O(n)? Assuming of course that n is the same as N. 
co-founding
Both examples are wrong and will provide incorrect results. If you want to know if two arrays are equal, you have to check every element for equality. You can only conclude that the arrays are equal if you've checked all elements and found that they are all equal. In both of your examples you're trying to return a true or false value immediately after only checking the first pair of elements, which has no hope of working. You can conclude that the arrays are not equal by stopping at the first pair of elements that are not equal, but not vice versa. 
I'm sorry, the code is not complete, this is the if inside a for, before it I already had compared if the number of elements were equal. This if is used when the number is equal, but only the first one works. Why? I did this post in the mobile as I dont have access to the code now.
I'm really rusty on big-O using multiple variables, but I believe you're right. If OP had ever replied I was hoping to continue to hit him over the head with clues by mentioning heapsort as an O(n log n) sort algorithm, from which bringing up other heap operations naturally follow. Assuming `K &lt;= N`, standard binary heap operations with a max-heap should satisfy the complexity requirement. If there's no constraint for K... I don't know a way that does off the top of my head.
What does it mean for two arrays to be equal? If the arrays are the same size, and, for each index i, the element of the first array at index i is equal to the element of the second array at index i. As a corollary, an array is not equal to another array if they are different sizes or, there exists an index i for which the element at i of the first array does not match the element at i of the second array. You only want to return immediately false when the element at index i of the first array doesn't match the element at index i of the second array. This is because an inequality of the elements at any index i causes the arrays to be unequal. However, just because elements at an index i are equal does not cause the whole array to be equal, so you do not want to immediately return true. In other words, if you immediately return true, you would be ignoring the rest of the array, which could potentially contain an inequality. Your return for "true" should be if you reach the end of the array with no inequalities. Only then can you safely say that the two arrays are equal, since you've checked every element. As far as your code, the two snippets are functionally identical, they just invert the logic and the return value, so your error is in the surrounding code.
And how do I return only after comparing the whole array?
This is my array comparison snippet. bool array_compare(const char *a, const char *b, int length) { const char *ptr_a = a; const char *ptr_b = b; while(length--) { if(*ptr_b++ != *ptr_a++) return false; } return true; }
Get rid of: else return true; and simply add the line: return true; after the loop.
I use `char *a` myself (force of habit) but to be honest `char* a` makes more sense to me. `pointer` is part of the type after all, not of the variable name.
Think of it as a toilet and signs to that toilet. Having a toilet in a big building like an airport is a pretty good idea. Building a toilet wherever you usually place signs to that toilet would be ridiculous. Both are useful in their own way.
like /u/Noobflair said. you only allocated memory for the holder. What you did is, you allocated memory for 10 structures called hold. What you actually want to do is. allocate memory for the holder and than allocated 10 times memory for hold-&gt;num
Don't do OPs homework.
No problem! It's been a really good text so far, the chapters are short and easily digestible and the code has been very clear. Hopefully it helps!
It solved exactly the problem I asked for, but if you can spot another mistake, let me know!
Stack and heap, folks.
This is a subreddit about C. None of the things you mentioned are C.
Thanks I'll remove it
Return will exit the loop and the entire function automatically. You can use return if false because you know that it is not equal and you don't have to check any more, but if 1 element is equal that does not mean all elements are equal. Try something like: for(...) { if (a[i] != b[i]) return false; } return true; If the for loop is able to complete without finding any inequalities, it knows the arrays are equal.
As I told you the last time, enable compiler warnings and fix them all before asking for help.
But, I though by allocating the struct, we automatically allocated memory for every field inside that struct. What's the point of allocating a struct then, if I'm just goona have to allocate every field I plan to use?
That can't be your full code, because it doesn't compile.
It isn't fully finished but it compiles and runs fine for me as long as I don't have those two pieces of code in it, I just don't understand why they bring about the problem, any ideas?
&gt; I though by allocating the struct, we automatically allocated memory for every field inside that struct. It does. But allocating memory for a pointer does not also allocate memory for it to point to. They are two separate things. It's exactly the same as writing a declaration like int *num; This allocates memory for a pointer, but it does not point to anything valid. &gt; What's the point of allocating a struct then, if I'm just goona have to allocate every field I plan to use? Not every field is a pointer. For example if you had a struct representing a point in 3D space: struct Point { double x, y, z; }; ... struct Point *p = malloc(sizeof *p); p-&gt;x = 10.5; p-&gt;y = 12.7; p-&gt;z = -2.1; (...setting aside how ridiculous it would be performance-wise to allocate each point as a separate entity on the heap.) 
Your compiler should be telling you about this line: scanf("%s", &amp;ch); `%s` means a string, but `ch` is an `int`, and its name and how you're using it suggests you actually wanted a `char`. Your loop has a second `i++` that you probably didn't intend (again, your compiler might warn you about this). On the other hand, you have a `break` that quits the loop before you do this second increment, meaning you only ever go through your loop once. That's certainly not what you intended, either.
 checkers.c: In function 'testInvalid': checkers.c:207:44: error: 'O' undeclared (first use in this function) *g = (game) {{{N,N,N},{N,N,N},{N,X,N}},O,1}; ^ In file included from checkers.c:7:0: checkers.c:208:12: error: too few arguments to function 'valid' assert(valid(g, "c2") == BadCell); You have undefined behaviour in `assert(valid(g, "2b", "c4") == BadLetterT2);` as well, since the function when called with that will index `grid[-1][-1]`.
That much code would have better been off going on gist or pastebin or whatever. Anyways, I imagine that trying to use the arguments to main() like they're a VLA doesn't work very well.
`testInvalid` has some compile errors. Commenting that out, I can compile, but I get an assertion failure: assertion "g-&gt;grid[1][4] == B" failed: file "test.c", line 165, function: testNew It's going to be hard to help you while your code is broken in other ways.
Just create a function that does it for you. Let it accept a string to print out and maybe the sleep value, and in that function you just iterate over each character of the string, printing the character (`putchar`) and sleeps. You may want to call `fflush(stdout);` after `putchar` because `stdout` might be line-buffered (this means it is only printed when an `\n` is printed).
It's very rare to pass structs by value because it's less efficient to do so. Hence essentially nobody does it. That includes both the industry generally and the designers of the standard library. If you plan for your function not to change the structure - or more importantly if the interface contract is that it will not be modified - then the pointer should be const. Personally, I find clear use of const-correctness is one of the key habits separating competent C programmers from the rest.
I'm still new to this and read this 5 times over I know the puts and putchar can be used for displaying but the rest confused me
Something like this: void print_slowly(char *s) { for (size_t i = 0; s[i] != '\0'; i++) { putchar(s[i]); sleep(1); } } You can adjust the number in the `sleep` call to make it faster or slower.
When you ask for help, it is the friendly thing to do to make a copy of your current code, and then remove everything from the copy code which isn't necessary to reproduce the problem you are having. See http://www.catb.org/esr/faqs/smart-questions.html for more tips.
Not related to the problem you originally had, but you should assign the result of scanf() to a variable and do something appropriate when scanf() is trying to tell you that it failed.
Thank you for making your post look nice. That's very helpful.
First of all, `while(n &lt; AMOUNTOFGRADES + 1)`, with `n` starting at 0 will iterate 11 times. You need to remove the `+ 1`. If you are wondering why you're getting that weird output, that is because since the while loop iterates 11 times, you end up executing `Grades[10] = Grade`. Since arrays in C are 0 indexed, an array of size 10 doesn't have a 10'th index position. This means you are writing out of bounds of the array. Unluckily for you, the memory just after the array happens to be some important data that is necessary for the program, so basically everything just becomes weird after that point. For example, when I run your code, I get an error saying "stack smashing detected", which means the code accidentally overwrote some important data required to keep track of the call stack, which is used to keep track of function calls. 
That fixed it. Thanks a ton, always the dumb mistakes...
This alone is not enough because the output gets buffered until a newline.
This is why we don't like to hire people who graduate from UNB.
This is why we don‚Äôt hire assholes who pass judgement on students from one code snippet or the school they‚Äôre from. 
 int *arrStorage = malloc(row * col * sizeof(int*)); should be `sizeof(int)` not `sizeof(int*)` for (i = 0; i &lt; row; i++) { for(j=0; j &lt; col; j++) { free(arr); } } This is freeing the same block of memory row*col times. You have 2 mallocs, so you need exactly 2 frees. one for each thing that was malloced. Your recursion is incorrect because it never stops. Consider the simplest case a 2x1 array : [1,1]; When you enter the recursion looking at (0,0) it will check all the neighbours. There's only 1 valid neighbour so it will call (0,1). Now its forgotten that it has already counted (0,0) and it will recurse again. and again and again, alternately counting the left 1 and the right 1
Check the docs for `printf()`. What variable type is `%s` used for? Also, what kind of variable is `s[i]`? 
You would need to play with termios to ensure the output is not buffered until a NL/CR. Or flush the buffer after each character, I presume. 
Yes, it clearly said to change the values as you counted them so they don't get counted twice in the assignment handout you where given
Jeez there's going to students who have problems with code everywhere. Don't be a dickhead about it
To help with bugs, so you know what the error was. Zero is no bug, anything else is an error code. For instance -ENOENT, etc.
if main returns 0 then it's assumed the program ended successfully.
Is it always 0 or can it be any integer you choose? 
If you are using any kind of learning resource that in any way suggests that `void main()` is valid, then toss it in the fireplace because it's junk. There are only two valid signatures for `main()` according to the standard. int main(void); int main(int, char **); Other signatures are allowed in special circumstances (such as freestanding implementations) but that's very rarely relevant. The point is that `main()` always returns `int`. 
`usleep` is `unistd.h`, which should get you finer control over your pauses.
Only zero means no problem. Other values have their own meaning. For example, if you include stdlib.h(STD C), you can use`EXIT_SUCCESS`(0) and `EXIT_FAILURE`(1). If you include `sysexits.h`(POSIX), you can use many other ‚Äòmeaningful‚Äô exit codes such as `EX_USAGE` or `EX_IOERR`.
Did you mean `errno`?
In linux/Unix , 0 represents a successful execution status and 1 returns a failure . So , you are basically telling the OS that the program executed successfully and to return the control to the OS . Void main() is a bad practice , it's not even a standard , avoid using it .
Other signatures are implementation-defined, which isn't exactly "special circumstance". In fact it is common for `int main(int argc, char **argv, char **envp)` to be defined by implementations.
`main` is a special case; since C99 , you can omit the `return` statement and it will implicitly return `0`.
I use char* a, except "a" is actually "p_nameOfVariable" with whatever type ident i feel is appropriate if necessary. The type is usually logical to whatever the variable is storing. To be honest, i skip the "p_" for most things now as so many of my variables are pointers lately that it becomes redundant...
In this diagram the `a` should also be in a box of its own -- it's important to understand that `a` is a variable with a value (that value being the address of a memory location)
4/10, some bites
Pointer variables are variables. But pointer values are not variables. For example, `&amp;a + 1` is a pointer value that is not a variable. 
So as other people have said, `void main(void)` isn't technically valid by the C standard. However, it wasn't quite perfectly explained what the `int` in `int main(void)` does. The value that's returned from `main` is provided back to the operating system, and then other processes (programs running on the computer) can use the return value to learn some information about the program exited. As some other people have mentioned, returning 0 from `main` usually means "success" or "no error." Returning anything *besides* 0 means there was some kind of error. This lets you encode many different error conditions in your program to let other processes know some basic information about what happened in the program. For example, if your program runs out of memory, you might always return 1 from your program, or if an error with reading/writing a file occurs, you might always return 2. The way UNIX is usually set up, you can have up to 256 distinct error codes. There's a few more details involving parent/child process hierarchy that I've glossed over for simplicity, but for a high-level overview, I hope that helped.
&gt; 1 returns a failure It doesn't necessarily have to be 1; it's anything *but* 0 is usually a failure. And even then, non-zero doesn't *necessarily* mean "failure." That's just by convention. For example, the `diff` utility uses the return code to encode whether the files are identical or not. It returns 0 if they are and 1 if there are differences, even though that's not really a "failure."
Just make ch a char. &gt;Char ch; Or &gt;char ch[n] &gt;scanf("%s",ch);
By not naming the parameter in the function definition you won't be able to use the parameter.
In a function prototype, there is no difference; the parameter names are optional. It is considered good practice to include them, however, since they can help document how the function is supposed to be called. For example, compare these two possible prototypes for the library function `strcpy` (string copy): char *strcpy(char *, const char *); char *strcpy(char *dest, const char *src); If all you had was the first one, you might accidentally pass the source string as the first parameter, and end up with a nasty bug in your program.
`sysexits.h` is not in POSIX. It's BSD convention and rarely used. OP can make up whatever convention he likes, but interaction with outside tools can be a bit more difficult if he doesn't make zero stand for success.
No blog spam please.
this is what the output looks like Please enter the dimension of the square: 3 Please enter the data for row 1: 123 Please enter the data for row 2: 456 Please enter the data for row 3: 78 123 0 0 456 0 0 78 0 0
Your arr variable is a matrix . So at dimensions 3 it will be a 3x3 matrix . That means 9 slots. Now you have there 3 numbers so 6 slots are empty in the matrix (they have value 0). Your loop goes through all elements of the matrix (including the 0s).
I'm remembering something about an empty parameter list in a definition being equivalent to `(void)`, only in a declaration making any difference, so why do you say writing `int main(void) {}` would be preferable?
I was going to do that originally but I didn't want it to look like the character 'a' somewhere in memory. Any suggestion on how I can do that?
The C standard mentions to basic environments to code in: hosted and not hosted. Hosted means that you have a standard library etc. -- basically an operating system you code on. Not hosted means coding without that. Of course defining an entry point name (ie. "`main`") only makes sense in a hosted environment. In Linux you have `_start` as the "actual" entry point (it's defined in the C library and wraps your `main`). The only definitions that are *required to be supported* as per the standard are: int main(void); int main(int argc, char *argv[]); Anything else is allowed to be supported by the implementation and there are actually quite some additional signatures usually supported but these are non-standard extensions ie. not necessarily portable. The return code of `main` is called "exit code" and usually is interpreted as signaling error. On most (all?) Unix systems 0 is conventionally "success" and nonzero "error". `stdlib.h` also defines the macros `EXIT_SUCCESS` and `EXIT_FAILURE` which expand to the values conventionally used on the target system, on Unix to 0 and 1 respectively.
its a little pedantic, and in that case I'd suggest you use descriptive variable names (instead of c) but make sure they are not too long... also consider adding doxygen comments (you never know you might get extra credit) and if you get into the habit of commenting as you go it becomes almost zero overhead and your code is always reasonably documented...
It's not equivalent; the `void` version forms a prototype. Example: int main(void) { main(5); // Error } vs. int main() { main(5); // No error, silent undefined behaviour }
Put the "a" above the box perhaps
Either `fflush()` or `setbuf()`, no need for non-portable termio.
The C standard defines only `EXIT_SUCCESS` (equivalent but not necessarily equal to 0) and `EXIT_FAILURE`. Anything else is implementation-defined.
While neither C nor POSIX disallow `-ENOENT`, it will not do what you expect. On POSIX systems, the value returned to the parent process will be something like `(256 - ENOENT) % 256` which usually evaluates to 254 since `ENOENT` is usually 2, although there is no guarantee of that. You could use plain `ENOENT`, provided it is less than 256, but there is no tradition for returning an `errno` value from a program, so the parent process won't know what to do with it‚Äîunless, of course, the parent process was written specifically to expect an `errno` value.
The C standard does not permit `main()` to have any other return type than `int`.
&gt; It is considered good practice to include them, Depends who you ask. The BSD style guide recommends naming parameters in kernel code but not in userland code, to avoid namespace issues.
These are prototypes, not definitions. A function definition include its body and *must* name its parameters. A prototype merely declares that a function with that particular name, type and parameter list exists and may omit the names of its parameters.
Since OP is learning, other *equivalent* signatures are valid (it's a bit early to discuss how they are equivalent), such as int main (int argc, char *argv[]) Also, unless I am mistaken, the names *argc* and *argv* are merely convention. 
So what you're saying is that you've made a bad word processor?
In C, you have no limitations :) The only limitation is your access to the machine. Try to just log `/dev/input/event*`.
Where are you stuck?
i do not know how to do
What part of the assignment do you not know how to do?
I guess you could call it that lol, but it was intended to just be more a learning thing for file input/output. Then I wanted to make it more like a security breach, where I could theoretically identify user's private information remotely but embedding the program into a larger file. 
Think about this for a second... First you should understand that you will be doing 2 calculations (one for rabbits, one for birds). You have 2 starting variables containing initial populations. These populations are recalculated over and over until one population is greater than the other (that's your while loop condition). So inside the loop you'll be doing these calculations. 
Yeahhh not with a userspace program, you can't do that.
with the loop (for while)
Do you know how to solve this problem on paper (without any programming language involved)? If not, figure that out first. 
yes i know but i dont know how to write with c, i dont join loops lesson 
Do you have to do it in user-space? It would be fairly straightforward as a [kernel module](http://elixir.free-electrons.com/linux/v4.6/source/include/linux/keyboard.h#L18). You'd have to translate the keycodes to ASCII yourself, though.
can anyone help ?
You need to drop the class.
Technically you don't even need C for this. `2272 √ó 1.012^x = 1042 √ó 1.038^x` ‚Üí `log(2272) + log(1.012^x) = log(1042) + log(1.038^x)` ‚Üí `0.0119286 x + 7.72842 = 0.0372958 x + 6.9489` ‚Üí `x ‚âà 30.7294` 
You need two variables that holds populations for both animals. Then inside the loop you need to change these two values and print out the results. In the comments you mention you're not sure about for loops in C, it's similar to most other programming languages: for (int i = 0; i &lt; years; i++) where "years" is the number of times you want to do the calculation.
but i make with c because this my homework
Learn how to ask questions properly, post your code, and at least fucking try before begging for us to do your homework.
 for (rabbit&gt;bird; rabbit=rabbit+(rabbit/100)*3.8;) { } this ?
I can not do it anymore
This is not so much a programming language question as an operating system question. There's nothing in the C language that guarantees you'll be able to get access to keyboard input from outside your program. In an extreme case (think secure OS with mandatory access control) there could be effective impenetrable barriers between your code and raw I/O. If you name a specific environment, someone might be able to suggest an approach. I'm mostly an embedded systems guy and don't deal with desktop OSes. I can tell you that back on the Commodore 64 the way you'd do it (usually in assembly) was by hooking the keyboard interrupt. Your wedge would get a chance to run every time a key was struck. If you can get in at the device driver level, you can do the same thing today and catch keys before the OS gets them.
In embedded C programming, main() will typically never exit - there's no where to exit to, and nowhere to pass a return value. It's common to see void main(void) there, partly as a reminder of that.
This is how for loops work: for (int years = 0; years &lt; 10; years++){ printf("%d\n", i); } this will print: 123456789 Inside the for loop you need to do all your calculations and print your results. The loop will repeat as long as years is less than 10 (years &lt; 10). You should probably brush up on C a bit. Good Luck! 
I think this was basically the first Java program I ever wrote, about 20 years ago - except it'd print everything in bright green on black, and then go back an instant later and reprint it in dark green to give it a fade effect. 20 years ago the green screen effect was a cliche, and we're still seeing that in 'high tech' movies today...
It generally requires elevated permissions, which might've been what you meant, but you don't need to have code running in ring 0 to have a functional keylogger. Hook some win32 functions and you have yourself a Windows keylogger; for Linux there's *at least* three different ways: using Xorg, ptracing processes and reading from `/dev/input/`. 
Please share the code that is causing the issue
I am not sure if I understand correctly, are you telling me to use a variable instead of a whole array?
Noo I didn't realize you could do that. I had to include the disclaimer because I've never really looked into it. I should of thought of "using xorg" and /dev/input but oh well. Thanks for the explanation.
&gt; should of Did you mean should've? -------------------------------------- I am a bot account.
It happens with any code. When creating a new project, this is the default code included: #include &lt;stdio.h&gt; int main() { printf("Hello, World!\n"); return 0; }
According to the ANSI C standard, the scope of a parameter name is limited to the function definition or declaration in which it appears: &gt; [¬ß3.1.2.1 ¬∂3](http://port70.net/~nsz/c/c89/c89-draft.html#3.1.2.1) Every other [non-label] identifier has scope determined by the placement of its declaration (in a declarator or type specifier). [...] If the declarator or type specifier that declares the identifier appears inside a block or within the list of parameter declarations in a function definition, the identifier has block scope, which terminates at the } that closes the associated block. If the declarator or type specifier that declares the identifier appears within the list of parameter declarations in a function prototype (not part of a function definition), the identifier has function prototype scope, which terminates at the end of the function declarator. Now, I'm sure BSD has a good reason for adopting its particular style‚Äîperhaps they value compatibility with pre-ANSI compilers. But I would be very hesitant to recommend that a newcomer to C follow the BSD style guide in this particular case.
Make sure that ghfjhgfhg.exe isn;t still running. Kill it in taskmanager if it is. The linker can't write a new version if the previous version is still running
Unfortunately this is not the fix, the program is not running. When trying to delete the .exe windows requests admin permission to delete it but doesn't grant it for the user.
Are you running antivirus? I know my antivirus will sometimes block creation and execution. Check your rules. And see if that helps at all. 
thanks for the information. my research has dealt with embedded systems security so it's cool to hear what your thoughts were. 
`X[i]` is exactly equivalent to doing the pointer arithmetic `*(X+i)`. By the commutative property, that's the same as `*(i+X)`, which we can rewrite back into array notation as `i[X]`. In other words, `0[X]` is just a silly way of writing `X[0]`.
I personally haven't seen this format, but array indexing in C is [commutative](https://en.wikipedia.org/wiki/Index_notation#C_implementation_details) so `0[x]` is equivalent to `x[0]`
&gt; My professor told me I'm leaving too much to the compiler You're not leaving anything to the compiler, the first is a declaration of a function named `calculate`, that takes a single `char` parameter and returns nothing.
&gt; According to the ANSI C standard, the scope of a parameter name is limited to the function definition or declaration in which it appears: You've got it backwards. Imagine that a program defines a function-like macro called `max` (which is fairly common), then includes a header file that includes a prototype for a function that takes a parameter named `max`. Compilation will fail, completely unnecessarily, with a potentially confusing error message.
ok got it thanks guys! think I'll keep using x[0] as its much more readable...
Disabling it didn't help, thank you though!
It's not entirely pointless, as it saves a set of parentheses: #define countofA(x) (sizeof(x) / sizeof(0[x])) #define countofB(x) (sizeof(x) / sizeof((x)[0])) 
Off-topic slightly, but that `printf` has the wrong format string, so it‚Äôs counter-standard and rather nonportable. Probably should use format `%zu` instead of `%i`: `countof` yields a `size_t`, which (a.) is unsigned (hence `%u`), and (b.) has no portable correspondence to `int` or `long` so you can‚Äôt just get away with `%u` or `%lu` unless your target ABI happens to match.
Since this is a macro, you should use `(x)[0]`‚Äîwhich is precisely why the author chose `0[x]` instead.
Trying running it as an admin perhaps? It seems like it doesn't like you modifying it? Hense the permission denied error. Otherwise I'm out of help. 
I suppose ... but I'm having a hard time coming up with something where those parentheses actually matter.
sorry that doesn't make sense you seem to be saying option B is correct which is exactly why option A was used?
Makes sense writing it that way, if the header is meant for use in C++ too. That way, you don't run into a problem if `[]` is overloaded.
Minor readability improvement, less line noise 
It would be fine to use with `std::array`, actually, but not any other standard C++ container.
 According to the 1999 ISO C standard (C99), size_t is an unsigned integer type of at least 16 bit (see sections 7.17 and 7.18.3). great so could be a bazillion bits wide for all we know....
What the person above said is that you need to use parentheses, as this is a macro. The reason is that in macros arguments are interpreted literally, so without parentheses around them you can change the meaning of the expression. An example would be a macro to get the half of a number: if you define it as `x/2`, the result of calling it with `3+3` as argument would be 4 (because it'd be changed to `3+3/2`), whereas if you define it as `(x)/2`, the result is 3, because it becomes `(3+3)/2`. In this case, however, it only makes sense to call the macro with the name of a variable, not the result of an expression, so parentheses aren't really necessary.
Theoretically that‚Äôs true even for `char`. IIRC there‚Äôs one DSP architecture family where everything up through `long` is 40 bits.
CLion is run as admin, I don't know how to modify any permissions in Windows 10. Maybe the default admin permissions are not sufficient...
&gt; In this case, however, it only makes sense to call the macro with the name of a variable, not the result of an expression, Are you sure? What if the argument is something like `*p`? `*p[0]` is not equivalent to `(*p)[0]`.
`countof(*p)` for a suitable definition of `p`, as `*p[0]` is not the same as `(*p)[0]`.
It's good style in macros to use parens for safety. Consider the contrived example n=countof(a+1); // a is an array of arrays Without parens, this becomes n=sizeof(a+1)/sizeof(a+1[0]); With parens, it becomes n=sizeof(a+1)/sizeof((a+1)[0]); Which is equivalent to n=sizeof(a+1)/sizeof(0[a+1]);
Yeah, but as far as I know, `sizeof` only returns the size of arrays when they are defined literally with the size in the same function, and otherwise it returns the size of the pointer itself. So `count(*p)` would return the size of a pointer divided by the size of one of its elements, which is pretty much useless (unless you want to know how many elements you can fit in a pointer, which is quite hacky and not very useful).
Well, yes, but this isn't specific to parameters; you could just as easily have a collision between a macro and a function name, or the name of a global variable, or a typedef... As I understand it, this sort of thing is why it's usually recommended to name macros in ALL_CAPS, and is one of the reasons preprocessor use is discouraged in general. (The specific example you gave is actually wrong, since function-like macros are only expanded when they're followed by parentheses, but the problem still exists for object-like macros.)
There it is. I was trying to be too convoluted, but that's a simple example of how it could go wrong.
No, `*p` can be an array of known size: typedef int i2317[23][17]; i2317 *p; but right now I can't find a way to make `*p[0]` and `(*p)[0]` give different results. They are not semantically equivalent, but end up being two paths to the same answer.
`*p` is the same as `p[0]`. Either case results in `p[0][0]`.
&gt; Well, yes, but this isn't specific to parameters; you could just as easily have a collision between a macro and a function name, or the name of a global variable, or a typedef... Except those are part of the (hopefully documented) API, whereas parameter names are not. And note my use of the word ‚Äúunnecessarily‚Äù.
Go through a few tutorials until you figure it out. You will not progress if you don't understand these basics. You haven't even attempted it. Nobody is going to do your homework. You're just going to get downvoted.
Technically it is ‚Äústandard‚Äù since the standard allows for custom main signatures. It isn‚Äôt portable, though. 
Fair enough. I thought compilers just didn't care, even if the size could be determined at compile time, unless you used the literal name of the array.
What suitable definition of `p`? All the examples I can think of give the same result. We know that `p` has to be a pointer, so `p[0]` is exactly the same as `*p`. `*p[0]` is therefore the same as `**p`. Now, we don't know what `p` points to, but it has to be something that can be accessed as an array. So `p` either points to an array or to another pointer. Either way, indexing it is the same as dereferencing, so `(*p)[0]` is the same as `**p` as well.
According to the operator precedence table [] is one of the highest order operators. Things liie address-of and dereference would lose to brackets 
Do you have to read the documentation just to figure this out? Wish the book I'm reading would point out little interesting things like this.
Just one of those things I heard somewhere. It's used rarely enough that it won't be included in most books. I guess the only way you'd be likely to figure it out yourself is if you're writing a compiler.
Someone else already pointed out dereferencing, but as near as I can tell it doesn't matter. You get the size of the exact same thing, albeit taking different paths to get there. However, I've thought about address-of a bit more. Let's say we pass `&amp;p` to our macro: is `sizeof(&amp;p[0])` the same as `sizeof((&amp;p)[0])`? For this to compile, `p` has to be either a pointer or an array (of some type `T`). `sizeof(&amp;p[0])` gives the size of a `T*` regardless. `sizeof((&amp;p)[0])` is the same as `sizeof(p)`. If `p` is a pointer, these are the same. But if `p` is an array, the extra parentheses matter! Of course, there's absolutely no sane reason why someone would call `countof(&amp;p)` ...
Well, it's your assignment, so tell us: How would you find it, and what are you having trouble with?
So I figured you're gonna need a helper function, since there's no other way to iterate through the array and still maintain a count of the pairs if you're just given those two parameters. 
How about p+1
So, why can't you loop through the array and keep count of matching conditions in a variable again?
Which is why `%zu` exists.
Right. Just couldn't remember what it was called.
I suppose it's more practical. I'm working alone most of the time on the code, so it didn't occur to me. Thanks!
Why not? Just initialize a variable outside the loop with 0 and increase it every time you find a match... am I missing some restriction you were given?
Syntax error, since `1[0]` is meaningless. However, if we flip it around to `1+p`, we get something interesting. Assuming that p is a pointer of some sort, `sizeof((1+p)[0])` is the same as `sizeof(p[0])`, not overly interesting. However, `sizeof(1+p[0])` will depend on the size of the thing being pointed to. If `p[0]` is an `int` or larger, then it's `sizeof(p[0])`. But if it's a `char` or `short`, then the result is `sizeof(int)` due to the promotion rules. So, there's another example. Though, once again, I don't see why you'd ever call `countof(1+p)` when you start with a `short *p`.
I know, what I'm saying is that it provides protection against it.
You should post SDL questions in the SDL subreddit.
It's a very important distinction. If you can't remember ‚Äúprototype‚Äù, at least try to remember ‚Äúdeclaration‚Äù.
Nothing gets dereferenced, `sizeof()` is evaluated at compile time and is based solely on type.
You're thinking of C++. C is different.
There are two slightly different versions of the `sizeof` operator: `sizeof(type)` and `sizeof expr`. The first evaluates to the size of the given type. The latter evaluates to the size of the type of the given expression. Both are evaluated at compile time, but the expression is never evaluated, so it is perfectly legal to do `sizeof 0`, `sizeof ((int *)0)`¬π and `sizeof *(int *)0`. ¬π extra parentheses required to differentiate from `(sizeof(int *))0`, which is a syntax error
Computers see everything in 0 and 1 (binary form)... `'a'` is a `char` which is an 8 bit integer... it has a mathematical value. `'a'` should be 97, if I remember correctly.
'a' is an ASCII character, and its numeric value is 97.
I may be wrong, it has been a while, but I believe it is interpreting that location in memory as a number/integer. 
Ah ok. Thank you!
(usually)
Protection against what, though? What would you expect the output of `countof(1+p)` to be? I can prove that the behavior changes by including the parentheses, but neither version produces meaningful results. Don't get me wrong: I agree that when writing a macro you should always add plenty of extra parentheses to head off any problems. But I don't think it's necessary in this case, so using the parentheses to explain why the original author used `0[X]` just doesn't work.
&gt;How do I find the number of elements in the array that satisfies arr[i] == arr[i+1]*3 What does this mean?
A background is just a texture/surface. You draw it as you would any other texture/surface
It's 129 on my IBM Deathstation 9000.
Yes, you have found a way to intercept and store a series of characters. (when your program is running) Now do it as a silent OS service. 
Since var is a pointer, incrementing it by one is pointer arithmetic, which basically means that you're going to increment by the machine word size. Google "c pointer arithmetic" if you want more information on that. What you want is: *var = *var + 1; which is dereferencing var, adding 1 to it, and storing that value back into the memory location that var points to.
The default Windows command prompt screen buffer is around 200 lines (iirc). Is it possible the rest of the output was cut off?
If you want to modify the value pointed to by var in differentFunction you have to dereference it. As it is, you're just changing the address it points to to something different than that of var in someFunction.
Ah, I guess intuitively for me it looks weird saying pointer = pointer + 1 TY!
How come *var++ doesn't work though? Is it not the same as *var = *var + 1;
First, you skip `field[0]` and at the end you access `field[1000]`, which is outside of the array and not allowed. Move `i++` after `printf` but before the closing brace for the `while` loop, because if `i` is `999`, it is incremented to `1000` before being used in `field[i] = i * i`. To your actual problem, maybe your terminal just holds 200 lines. You can usually set the amount of lines of "scrollback" in the settings. If not, you can always redirect the output to a file `myapp &gt; myfile.txt` and view the file in any editor you like. If you're on linux (or most any other modern unix inspired systems), you can pipe the output to a pager like `less`: `myapp | less`
Thank you very much for your help!
A_i = 3A_(i+1)
Operator precedence. http://en.cppreference.com/w/c/language/operator_precedence ++ applies before unary *, so you are incrementing the pointer and then dereferencing that. Change to (*var)++; 
In C every single variable type is a numeric value. Characters are an 8-bit integer and are translated to symbols, numbers and letters using the [ASCII encoding](http://www.asciitable.com/). Therefore, when you compare with 'a', you compare with its numerical value. Same goes for when you do any other operation with a character.
How might you go about overcoming variations in the ASCII sets across different systems? 
The good ol' printf method or look up a gdb tutorial.
valgrind, a debugger, compiling with `-fsanitize=address`...
I wasn't thinking in C++, in fact, in C++, `()` is equivalent to writing `(void)` everywhere. I was unsure about this int f(); int main(void) { f(5); // possible } but this not: int f() { /* impl */ } int main(void) { f(5); // error } but apparently both is no error, even though in the C standard we have &gt; An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. see also https://stackoverflow.com/a/36292431/4453524 I'm still not sure why the latter is no error as to me this is a function declarator which is part of a definition...
I was unsure about this in the C standard: &gt; An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. But at least GCC does not enforce that with just `-Wall -Wextra -pedantic` Clang does, however.
No. scanf has a return value. Read the documentation for that function. Use the value returned by scanf.
Yeah, I'm confused, too. 6.7.6.3 seems pretty clear: &gt; An identifier list declares only the identifiers of the parameters of the function. An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied. Since `f` is being defined, it's clear that it takes no parameters. This is the same as if it were declared as `int f(void)`: &gt; The special case of an unnamed parameter of type void as the only item in the list specifies that the function has no parameters And yet, that defect report makes it clear that the committee believes otherwise, and the behavior of at least two compilers follows the committee, allowing this code to compile. But, in the end the rule is pretty simple. If the parameter list is empty, it means the compiler will accept any number of parameters when the function is called. If you call the function with any arguments, it's undefined behavior. If you want to be explicit that there's no parameters and want the compiler to enforce this, use `void` as the parameter. So: void f() { } void g(void) { } int main(void) { f(42); // Compiles, but undefined behavior if this is actually called g(42); // Error } The same goes for your second example: int main(void) { int (*fp)() = main; fp(5); // Undefined behavior int (*gp)(void) = main; gp(5); // Error } That's my understanding of how it actually works, even though it conflicts with my understanding of the standard.
Please don't post this kind of shitty video tutorial.
ASCII has no variation. But sometimes (very very very rarely nowadays), the charset of the platform may not be ASCII, and ‚Äòa‚Äô would not be 97...
text[0] - 'a' returns how many letters past 'a' text[0] is. So if text[0] is 'a', it returns 0, if text[0] is 'b' it returns 1, and if text[0] is 'c' then it returns 2.
Just because CLion is running as admin doesn't mean ld.exe is. What are the permission on ghfjhgfhg.exe? What are the permissions of the parent directory? Also, you might try running CLion as a non-privileged user. It could be that the utilities CLion is using to build your program are dropping privileges.
&gt; But sometimes (very very very **often** nowadays), the charset of the platform may not be ASCII FTFY
A character literal will fit in an `unsigned char`, but its type is `int`.
&gt; `'a'` is a `char` which is an 8 bit integer... `'a'` is an `int` which must be at least 16 bits wide.
Learn to use gdb. 90% of the questions on this sub could be answered by spending 30 minutes doing a gdb tutorial.
90% of the questions on this sub are about code that doesn't compile or hasn't even been written. Or is that just in the fall?
Yay EBCDIC: "I'm not dead yet."
Huh. TIL! So I guess you could do a check and see if the charset matches the numbers you were expecting and then deem it safe to start comparing chars? Or I'm sure there's a better way.
Any good gdb resource you'd recommend to read first?
Just want to know how it'd be done recursively and w/o loops
Just want to know how it'd be done recursively and w/o loops
The better way is to not rely on any particular character having any hardcoded numeric value, and not assuming that, say, 'z' comes after 'a'. (Except for '0' through '9'. The standard mandates that those be sequential in the character set.)
&gt; `'a'` is an `int` There's more to this discussion than a noob would require to understand how a `char` value could be less than or grater than `'a'`. I know my statement wasn't 100% accurate, but it was a perfect fit for the scope of this discussion. I will not start a discussion here about the (questionable) existence of the 8 bit `char` type within logical operations (and/or function calls) or the way compilers will use an `int` with a bit mask (` &amp; 0xFF`), an `int` without a bit mask, or (very frequently) a `size_t` without a bit mask... ... this isn't the place for this discussion. As OP will learn more about C, they will start realizing the added work behind the scenes. **Side note**: trying to set the remaining 8 bits (i.e. `'ab'`) will result in undefined behavior, so the 16 bit knowledge doesn't really help at all.
It's pretty uncommon to care about the value of a character in C. If you ever care about the value of a character in C (with the exception of the null character, which must have a value of 0), you are either (1) doing something wrong; (2) doing an assignment with contrived specifications for homework (like OP); or (3) doing something unusual, which is probably wrong. There are functions/macros in ctype.h such as isalpha, isdigit, isupper, etc., which supposedly let you classify a character that you're dealing with. There is a problem with those, though, which is that they only deal with values that can fit an an unsigned char. Typically not all of your characters will fit an unsigned char. Systems that use ASCII are becoming a rare breed these days. Most systems are using a Unicode encoding such as UTF-8. How do you determine if one of *those* characters is a letter, for instance? Well, you can try to deal with things as a wchar_t and use functions/macros like iswalpha, but now you've opened up a big can of worms. What are you writing your conditions on? Code points? Glyphs? Graphemes? Code units? The general piece of advice I would give for writing string-handling code in C is to pretend that there are only 2 types of characters: the null character, and a meaningless stream of blobs that are not null characters. Trying to be fancy and do anything beyond that *will* cause bugs with almost complete certainty. There are a few cases where you must assign meaning to certain characters, such as (1) parsing; and (2) graphical user interfaces. Those 2 tasks should be left to dedicated libraries and tools to do, since the developers of those libraries can devote a lot of time to squashing Unicode-related bugs (and, sadly, even then will still have some bugs).
 while(scanf("%c", inputs) != EOF) { useless++; } This code does not going to work. What are you trying to do here? I would recommend that you put the following line in this loop to see what is happening: printf("inputs[%d] = %c\n", useless, inputs[useless]); 
You don't have to check it against numbers, ASCII is ASCII whatever platform you're using, C interprets char 'a' as 97 in ASCII and won't care that your system uses UTF-8.
It's supposed to be a loop to input every line of input as a string into the array output. I put a function down but it wouldnt have worked, and then forgot to replace it with something else. I don't know exactly the best way to go about doing that. 
In a recursive function there's a stopping condition and a "loop" condition. The stopping condition here is size being 1, so just add that if (arraylen == 1) return 0; The "loop" here is returning 1 or 0 (if the condition holds for the first element of the array you receive) plus the value of the rest of the loop. return func(&amp;arr[1], arrlen-1)+(arr[0]*3==arr[1]); This should work.
&gt; from what I can gather, there's no way such thing could be empty -- ie. the quoted paragraph from the C standard would be just pointless. I don't think it's pointless, the part you quoted is just contrasting a declaration that is part of a definition with a declaration that is not. See the sentence immediately after that quote: &gt; An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. **The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied.** So it's just making it clear that `()` in a *declaration* (without a definition) says nothing about the parameters, but `()` in a *definition* means the function has no parameters -- even though it still doesn't act as a prototype. 
To not use a loop you would need to create a method to call from within itself and you would need to increment a global variable to keep track of the count for successful conditions. Make sure you pass the current index to the method as a parameter, so you know when to exit the method.
Ok. A couple of things: First, `%c` is the format specifier for a character. unless you put a number in front of it, it reads one character. `%nc` will read exactly `n` characters. To use `scanf()` to read the input string you are specifying, you would need to do the following: scanf("[a-z 0-9 -c], inputs); A better option might to use `gets()` From your comment after your input loop, it looks like you are trying to allow the user to input multiple strings. If this the case, you won't be able to store them in your `inputs[]` variable as it will only store one string. A string in C is a array of characters terminated with a NULL ('\0'). I would recommend that you start by processing one string at a time to start. 
If I need to take multiple lines of input, and I decode a key for a new line, would the best course of action be to just concatenate the lines into one string?
I see, and what if we want to maintain the structure and elements of the array, i.e. don't modify it?
Here's a really neat example of this in action. [This self-hosting C compiler](http://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days.html) doesn't actually have an ASCII table built in. It just learns the character set from the compiler that compiled it: &gt; There is a piece of information that can be passed on to the next generation only via executables in binary format, despite not being written in compiler source code. &gt; For example, my compiler interprets "\n" (a sequence of backslash and character "n") in a string literal as "\n" (a newline character in this case). If you think about this, you would find this a little bit weird, because it does not have information as to the actual ASCII character code for "\n". The information about the character code is not present in the source code but passed on from a compiler compiling the compiler. Newline characters of my compiler can be traced back to GCC which compiled mine.
I would still recommend that you start by reading one line. I think you will find that it is easier to learn if you start simple and build one step at a time testing and getting each step working before proceeding to the next step. That being said, how do you need to read the lines? Do you: 1. need to read them all at once, then process them? 2. can you read a line process that line, then read another line process that line and so on? If you have to read them all at once, you could use a 2-dimensional array. On the other hand if you don't need to read them all at one, you can use a loop. Either way, you will probably want to use a sentinel value so you program will know when to stop processing.
You aren't modifying it, you're just telling the next function to read the array from a different place. You can pass an index argument, too, and then you would have to increase the index, instead of changing the size, but you would need a helper function.
Not that I don't like beginners asking questions, is there a C sub that is for experienced programmers? Something like r/cpp but for c.
Here's a sneak peek of /r/cpp using the [top posts](https://np.reddit.com/r/cpp/top/?sort=top&amp;t=year) of the year! \#1: [I just found a use for the poop emoji in C++](https://np.reddit.com/r/cpp/comments/75gohf/i_just_found_a_use_for_the_poop_emoji_in_c/) \#2: [C++17 is formally approved](https://herbsutter.com/2017/09/06/c17-is-formally-approved/) | [97 comments](https://np.reddit.com/r/cpp/comments/6yjerb/c17_is_formally_approved/) \#3: [Bjarne Stroustrup awarded 2017 Faraday Medal](https://www.cs.columbia.edu/2017/bjarne-stroustrup-awarded-2017-faraday-medal/) | [23 comments](https://np.reddit.com/r/cpp/comments/72gxkw/bjarne_stroustrup_awarded_2017_faraday_medal/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Yeah, I have to read them all and then process them.
0[x] is why we can't have nice things :) 
Nice article. Definitely an under utilized but of the spec.
Utf-8 is a strict superset of ASCII, so on many, the ASCII values remain valid
Ok, so you are trying to process a file. Typically this is still done one line at a time, otherwise how would you know how much storage you need to have to store the file in memory. My recommendation still stands. Take it one small step at a time building on each step. You will find it a lot less frustrating writing your program one feature at a time. It is much easier to debug a few lines at a time. I would suggest that you start by: 1. open a file 2. use a loop to read each line of the file 3. print each line as you read it 4. close the file You will want to read up on C file I/O, especially: + `fopen()` + `fgets()` + `fclose()` Even if you are required to read the whole file first, I would still start off processing the file one line at a time. 
You are not giving us much to go on, but a couple of thing you can check are: 1. array access - make sure that the index is not going out of the array bounds 2. de-referencing pointers Some other strategies are: 1. comment out code a section at a time until the bug goes away - the last thing you commented was the location of the problem 2. put `printf()` statements at the beginning and end of functions and blocks of code 3. use `printf()` to print out variable values - check these values to make sure they are reasonable 4. gdb
(Why do people downvote instead of correcting?) You are severely confused. A C compiler on an [EBCDIC](https://en.wikipedia.org/wiki/EBCDIC) platform would interpret ‚Äòa‚Äô as 129. Also, UTF-8 is a superset of ASCII (which is obviously not true for UTF-16) There is zero problem doing UTF-8 in C or C++. You can use √©charpe of [mbtowc](http://en.cppreference.com/w/cpp/string/multibyte/mbtowc). Think about it: the most popular utf-8 platform is Linux (C-based) and the most popular UTF-16 is windows (C++based).
**EBCDIC** Extended Binary Coded Decimal Interchange Code (EBCDIC) is an eight-bit character encoding used mainly on IBM mainframe and IBM midrange computer operating systems. EBCDIC descended from the code used with punched cards and the corresponding six bit binary-coded decimal code used with most of IBM's computer peripherals of the late 1950s and early 1960s. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It specifies that it has no parameters, but it doesn't form a prototype (those are distinct concepts)
Yep, this is what they said in the defect report too, but I'm not quite sure about when this paragraph applies actually, but I've submitted a dedicated post for that.
Yep, that's what I'm doing too, I'd just like to know when does that paragraph even apply?
Your first program is undefined behaviour with no diagnostic needed. This gets asked all the time, I guess because the rules are unintuitive. C originally didn't have prototypes. When prototypes were added, violation of a prototype is an error that must be diagnosed at compile-time. But they decided not to break pre-existing code. Code that doesn't use prototypes is just undefined behaviour if the wrong parameters are given. `int f() {}` is not a prototype, so `f(42);` need not be diagnosed (the compiler can warn about it, but not fail to compile it). `int f(void) {}` is a prototype and `f(42);` is an error that must be diagnosed. 
But is there any difference between function declarations that *don't form a prototype* with **unspecified** parameters and with **no parameters**? I mean what's this: void f(); void g() {} int main(void) { f(42); // case 1 g(42); // case 2 } Is the first "might be correct" because it's basically an old-style declaration without prototype and the implementation of `f()` could choose to actually take parameters? And is the second wrong? The GCC explicitly doesn't warn by default, quoting the defect report as why this'd be "OK", too ...
&gt; Since f is being defined, it's clear that it takes no parameters. This is the same as if it were declared as int f(void) It *has* no parameters. There is no such thing as "takes no parameters" . You might be mixing up parameters and arguments. Parameters are a property of the function . Arguments are a property of a function call expression. It's not the same as `int f(void)` which specifies additionally that it is a constraint violation to call `f` with arguments. 
&gt; It's pretty uncommon to care about the value of a character in C. It's reasonably common (in beginner code, anyway) to care about the English alphabet being contiguous.
`'ab'` is implementation-defined, not undefined. Lol @ you trying to defending your completely false statement about the type of `'a'`.
Thanks, I think I wrapped my head around it now, mostly! Probably the most I've learned about C in the last years :) I'm just a bit confused though about the first example yet: `void f() {}` defines that the function does not take parameters, but wasn't even in early C this true, you'd write void f1(a) int a; { } for a function that does take parameters. I assume in K&amp;R C you could write `void f()` and it's parameters were unspecified? But how then is the first example undefined behavior if they want not to break old code, because I'd say, making something suddenly UD is breaking it. Or is, strictly speaking, any K&amp;R C compiled with a C99+ compiler just relying on undefined behavior and the compiler being so kind to try to compile it properly? That is, a compiler *is allowed* to reject K&amp;R C but is also allowed to accept it?
Before the first standard, everything was undefined behaviour, you could say. The standard defined a lot of things but did not define what happens when you call a function with the wrong parameters, and they chose not to turn that into an error. Undefined behaviour can't be rejected unless it occurs in all code paths (.e.g `if (0) f(5);` must be accepted)
Hint: use a while loop. The condition will be while sum &lt; 10 and you will have to evaluate the sum for each iteration in the loop.
Okay, this makes sense! And since the compiler cannot know that I'm later linking with the `crt0.a` and it'll run in a hosted environment such that `main` is the entry point, thus not knowing that void f() {} int main(void) { f(42); } is definitely UD in all code paths it basically cannot reject if it's strict to the standard. Hmm, that's a bummer but at least GCC does have a optional warning flag for that. Thanks again, the best explanation I've had about this and the only one that got in every detail!
We can't tell what's wrong with your approach since you didn't give enough details. Please read http://www.catb.org/esr/faqs/smart-questions.html and then edit your question. 
‚Äúdidn't work‚Äù is not an error description. Tell us why this approach failed so we can suggest a better one.
That's exactly why I keep returning C sub reddit haha
####"the compiler must assume that the first store could have ended up writing in the same area as in_vector, in other words, that out_vector_a could be an alias for in_vector. " Outrageous...thanks for the tip it. I will dive into alias and alike! 
You are correct except for recommending wchar+mbtowc, that's a (mostly historical) construct that's not really helpful at all for dealing with Unicode. 
&gt; the only thing it is a perfect fit for would be a trash can. int fire = htonl( 'üî•' ); printf( "%.4s\n", &amp;fire ); 
Program dosen't give me any answer, i checked and it computes properly 10 -1/2 - 1/3... -1/n but only for small n, for example n=500 is ok (but n, which i'm looking for is way bigger). It dosen't work with big number because numerator is too big even for long long. That's why i assume maybe diffrent approach is required. Do you have any ideas?
Do you need an exact result or is an approximation sufficient?
Do you need an exact result or is an approximation sufficient?
This is a sub for C, not C++, but anyway: Declare two variables, one for odd numbers and other for even numbers, and set them to 0. For every number you read, you check if it's even (`n%2` would be 0) or not. If it is, you increase the variable for even numbers; if it isn't, you increase the variable for odd numbers. I.e., you don't store all the numbers, you only process one number each time. That's everything I can do for you without actually doing your assignment.
It's extremely well documented. From their site: https://sourceware.org/gdb/current/onlinedocs/gdb/ Go through the first 5 chapters or so and you'll have a very solid foundation of how to use it. Finish the first 10 and you'll probably know more about gdb than 98% of other people that write software. Bonus: If you do that, put gdb on your resume if you're in software. If you can use the most 5 common gdb commands in an interview settings you're probably the best candidate they've seen all day.
Awesome, good to know!
*sigh* the tile should say any not and!
For declaring dependencies I'm using something like: LIBS = libcurl openssl ifneq ($(LIBS),) CFLAGS += $(shell pkg-config --cflags $(LIBS)) LDFLAGS += $(shell pkg-config --libs $(LIBS)) endif 
C++ is off topic in this subreddit. Please ask elsewhere, e.g. in /r/cpp_questions.
neat idea for those kinds of libs, may well use something like this at a later date, GL and even GLFW are in fairly standard locations now-a-days....
I like to use "SUFFIXES" rules for the .c -&gt; .o part: .SUFFIXES: .o .c .c.o: $(CC) $(CFLAGS) -c $&lt; I also like to have a target that reformats the code according to the style in use for that software project to ensure consistency before checkin.
I would name my include directory `include` as that's the standard name. Otherwise, welld done!
You check the second character first, so if it doesn't validate, it returns `BadDigit` because you expected a digit there, not a letter. So just put the `text[0]` check before the `text[1]` check. By the way, you may want to "invert" the checks because, at least for me, it is a bit confusing at first glance. I suggest something like `!(text[0] &gt;= 'a' &amp;&amp; text[0] &lt;= 'c')`. Just my personal opinion, feel free to ignore.
You may want to use `$(CC)` than `gcc` because people might want to compile with eg. `clang` or any other compatible compiler or cross compiling.
Ah thank you! And I'll change it, we get marked on readability so this is a good idea.
I need an exact result
An IBM mainframe encoding, way to go! What's next, GB18030?
I think you can use the inverse of the integral logarithm to get thw desired result.
`CFLAGS` belongs to the user. Here is my take on your Makefile CFLAGS?=-O2 CPPFLAGS+=-std=c99 -Wall -Wextra -Iinc LDLIBS+=-lglfw -lGL -ldl OBJ=obj/foo.o ... .PHONY: all clean swrend all: game game: $(OBJ) $(CC) $(CFLAGS) $^ -o game $(LDLIBS) obj/%.o: src/%.c $(CC) $(CFLAGS) $(CPPFLAGS) $^ -c -o $@ swrend: game LIBGL_ALWAYS_SOFTWARE=1 ./$^ clean: $(RM) game $(RM) obj/* - split CFLAGS and CPPFLAGS - use $^ instead of $&lt; - add PHONY - add $(CC) - simplifications 
I looked at suffixes but apparently are obsolete ? (https://www.gnu.org/software/make/manual/html_node/Suffix-Rules.html) but good reminder about reformatting I'll probably make an astyle rule... 
good point thanks!
Some simple games: Minesweeper Checkers (Chess as a follow up project) Connect-four Othello (Go as a follow up) Solataire Input and graphics are not that hard in a terminal. The interface won't look great but it will be enough. Feel free to pm if you're stuck.
Start simple and build a little at a time. Most import, test and debug each step as you go. I would start with a two player game at first; that way your program only places the pieces and does scoring. You could: 1. start with a loop that takes user input then prints it out 2. add the boards and a function to print them out 3. add functions to place ships 4. add logic let users alternate turns 5. add logic to check for hits 6. add logic to check if a ship is sunk 7. add logic to keep score 8. add a PC player 
Huh. TIL. For the record, I'm older than the average Redditor, and I learned make about 20 years ago, from the 1994 2nd edition of "Mastering Make". Fortunately, SUFFIXES still works for ~~backwards compatibility~~ old farts like me.
For serious stuff IMHO listing the c files manually is better, and it's no work anyway. Generate a list and paste into the Makefile, done.
firstly UTF-8 is a superset and secondly a char cannot fit all Unicode code points anyway -- just the lower 8 bit of UTF-8, which, as said, are ASCII
Because this is buried in the subcomments, a gentle reminder that characters are encoded in an implementation-defined format, *usually* ASCII. Also a Byte is not always 8 bit (but POSIX mandates this) and thus so is not char. One could come up with a platform where a Byte is 64 bit and chars are encoded in KOI-8. AFAIK only the charset covering *at least* ASCII or equivalent is mandatory.
That's just some stupid wording in the GNU Make manual. They're only obsolete if you don't care about portability. Like `patsubst` and `wildcard`, patterns rules were never standardized, and so you can only use them with GNU Make. They *are* certainly more flexible. For example, you're using it to specify an out-of-source build (`obj/`). Suffix rules cannot do this.
Here you can find the structure of data http://www.evenx.com/vcard-3-0-format-specification
Do you have a question?
No need for `?=` or `+=`. These are non-standard, completely unnecessary, and virtually always misused. With the normal, standard `=` macro definition, users can always override `CFLAGS` using an argument: make CFLAGS='-Og -g' game Command line arguments override definitions in the Makefile. &gt; use $^ instead of $&lt; Don't do this. It's non-standard and it's wrong here anyway. The other prerequisites often include header files and such, which mustn't be included in the command. &gt; add $(CC) Yes! Let the user select the compiler. make CC=clang 
This subreddit is about programming in C. C# is off topic, please ask elsewhere.
&gt; Don't do this. It's non-standard and it's wrong here anyway. The other prerequisites often include header files and such, which mustn't be included in the command. That depends on the command. Using `$&lt;` would be catastrophic for the `game:` rule.
I liked the description so I went ahead and implemented something for fun. #include &lt;iostream&gt; typedef int validity; constexpr int OK = 0x00; constexpr int BadFormat = (1 &lt;&lt; 0); constexpr int BadDigit = (1 &lt;&lt; 1); constexpr int BadLetter = (1 &lt;&lt; 2); constexpr int BadCell = (1 &lt;&lt; 3); constexpr int Bad = (1 &lt;&lt; 4); constexpr char N = ' '; struct game { char grid[3][3]; void reset() { for (char* g = grid[0]; g &lt; grid[0] + 9; ++g) *g = N; } }; //#abc //1### //2### //3### validity AssertLength(const char *text, int length) { int errors = 0; if (!text) { return BadFormat; } for (const char * c = text; c == text + length; c++) if (*c == 0) ++errors; if (text[length] != 0) ++errors; return (errors &gt; 0) ? BadFormat : OK; } validity ConvertValue(char value, char base, int * converted, int lower, int upper) { //'a' - 'a' =&gt; 0 //'c' - 'a' =&gt; 2 *converted = value - base; if (*converted &lt; lower || *converted &gt; upper) return Bad; else return OK; } validity GetRow(const char *text, int * row) { if (ConvertValue(text[0], '1', row, 0, 2) != OK) return BadDigit; else return OK; } validity GetColumn(const char *text, int * column) { if (ConvertValue(text[1], 'a', column, 0, 2) != OK) return BadLetter; else return OK; } validity AssertBaordFree(game *g, int r, int c) { if (g-&gt;grid[r][c] != N) return BadCell; else return OK; } validity valid(game *g, const char *text) { validity ret; int row, column; ret = AssertLength(text, 2); if (ret != OK) return ret; // row and column could be ored together if validity behaves like flags ret = GetRow(text, &amp;row); if (ret != OK) return ret; ret = GetColumn(text, &amp;column); if (ret != OK) return ret; ret = AssertBaordFree(g, row, column); return ret; } void check(game *g, const char * text, validity expected) { validity actual = valid(g, text); char safety[40]; if (text) strncpy_s(safety, 40, text, 40); else strncpy_s(safety, 40, "&lt;null&gt;", 40); if (actual != expected) std::cout &lt;&lt; safety &lt;&lt; "\n expected 0x" &lt;&lt; (void*) expected &lt;&lt; "\n but was" &lt;&lt; (void*) actual &lt;&lt; "\n\n"; else std::cout &lt;&lt; safety &lt;&lt; "\n expected 0x" &lt;&lt; (void*)expected &lt;&lt; "\n test ok" &lt;&lt; "\n\n"; } int main() { game g; g.reset(); char cell[3] = { 0,0,0 }; for (char r = '1'; r &lt; '4'; ++r) for (char c = 'a'; c &lt; 'd'; ++c) { //Happy Path cell[0] = r; cell[1] = c; check(&amp;g, cell, OK); } check(&amp;g, "0a", BadDigit); check(&amp;g, "4a", BadDigit); check(&amp;g, "aa", BadDigit); check(&amp;g, "1A", BadLetter); check(&amp;g, "1d", BadLetter); check(&amp;g, "11", BadLetter); check(&amp;g, "1", BadFormat); check(&amp;g, "111", BadFormat); check(&amp;g, "1a1", BadFormat); check(&amp;g, 0, BadFormat); g.grid[0][0] = 'X'; check(&amp;g, "1a", BadCell); return 0; } 
Unicode has only recently started supplanting 8-bit encodings such as ISO 8859-1 and 8859-15 or the non-standard encodings used in Windows. 
Fine then, but I'd in this case I'd phrase it different, not "nowadays" but "til recently"
I have no idea wtf you are on about. The type of a character literal in C is `int`, not `char` as you claim. The type of the result of a logical operator is also `int`. Your talk of ‚Äúthe 8 bit `char` type within logical operations‚Äù is meaningless babble. % cat &gt;size.c &lt;&lt;EOF #include &lt;stdio.h&gt; int main(void) { printf("%zu %zu %zu %zu\n", sizeof(char), sizeof(int), sizeof('a'), sizeof('a' == 97)); return 0; } EOF % cc -Wall -Wextra -std=c99 -o size size.c % ./size 1 4 4 4 
Unicode isn't necessarily ASCII either. The native character encoding on Windows these days is UTF-16, which, unlike UTF-8, is not a superset of ASCII. MacOS uses UTF-8 while Linux and BSD use an unholy mix of plain ASCII, UTF-8 and various 8-bit encodings.
So Ascii-7 is wildly understood. the code goes back to before computers were a real thing. Essentially computers use numbers so 'A' needs to be made into a number. There is a good mapping here for the bits for the integer range from 0 to 127 Here is Tom Scott explaining a lot about it all: https://www.youtube.com/watch?v=wCQSIub_g7M https://www.youtube.com/watch?v=MijmeoH9LT4 Do not assume anything above integer 128, it all falls apart there. You can do reasonable things with that and evil things. Here is an assortment of reasonable and evil things: #include &lt;iostream&gt; int main() { int toupper = 'b' - 'B'; std::cout &lt;&lt; "upper case " &lt;&lt; ('A') &lt;&lt; " is lower case " &lt;&lt; ('A' + toupper) &lt;&lt; "\n"; std::cout &lt;&lt; "letter " &lt;&lt; ('A') &lt;&lt; " has a value of " &lt;&lt; ((int)'A') &lt;&lt; "\n"; std::cout &lt;&lt; "value " &lt;&lt; (73) &lt;&lt; " is the letter " &lt;&lt; ((char)73) &lt;&lt; "\n"; int a = 'EVIL'; std::cout &lt;&lt; "E in hex: " &lt;&lt; (void*)'E' &lt;&lt; "\n"; std::cout &lt;&lt; "V in hex: " &lt;&lt; (void*)'V' &lt;&lt; "\n"; std::cout &lt;&lt; "I in hex: " &lt;&lt; (void*)'I' &lt;&lt; "\n"; std::cout &lt;&lt; "L in hex: " &lt;&lt; (void*)'L' &lt;&lt; "\n"; std::cout &lt;&lt; "EVIL in hex: " &lt;&lt; (void*)'EVIL' &lt;&lt; "\n"; std::cout &lt;&lt; "a in hex: " &lt;&lt; (void*)a &lt;&lt; "\n"; std::cout &lt;&lt; "a as int " &lt;&lt; a &lt;&lt; "\n"; std::cout &lt;&lt; "do not actually initialise integers like that\n"; return 0; } 
This is a [partial sum of the harmonic series](https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Partial_sums). Since *H_n* converges towards *ln n* for large enough values of *n* and you are looking for the smallest value of *n* such that *H_n &gt; 10*, we can estimate that *‚åäe^9‚åã ‚â§ n ‚â§ ‚åàe^10‚åâ* or *8103 ‚â§ n ‚â§ 22027*.¬π That's not a large number, but the numerator and denominator get very big very fast; *H_24 = 1347822955 / 356948592* will fit in two 32-bit unsigned integers, but *H_25 = 34052522467 / 8923714800* will not, and *H_47 = 280682601097106968469 / 63245806209101973600* won't fit in 64 bits. ¬π a few minutes on [Wolfram Alpha](https://www.wolframalpha.com/input/?i=12367th+harmonic+number) shows that *n = 12367*.
Did I nail it? #include &lt;iostream&gt; int main() { //Hello friends i am asking for your experience in c programming :) //i have a text file of vCards so a sequence of data structured like this: char * textfile = " BEGIN:VCARD VERSION:3.0 PRODID:-//Apple Inc.//iOS XXX//EN ... item1.TEL;type=pref: blablabla REV:YYYY-MM-DDTHH:MM:SSZ END:VCARD BEGIN:VCARD etcetc "; //I need to print two test files, one with data that contains the raw char * theraw = "REV:YYYY-MM-DD"; std::cout &lt;&lt; theraw &lt;&lt; "\n"; //and another text file which contains all data with the raw of others date. std::cout &lt;&lt; textfile &lt;&lt; "\n"; //Thanky you for your time and I appreciate if someone could help me. return 0; } 
oh geez
Yeah, I said UTF-8 is a superset of ASCII, not all formats. On most platforms ASCII works as an approximation for alphanumerics. But in the end it doesn't matter since one shouldn't assume what a char is, and one doesn't need to usually either. On Linux you usually have UTF-8, the BSDs out there are either using ISO8859 or UTF-8 too, except the C language code which is ASCII, actually quite sorted tbh.
 #include &lt;iostream&gt; template&lt;typename T, std::size_t Size&gt; std::size_t GetArrLength(T(&amp;)[Size]) { return size; } #define countof(x) (sizeof(x) / sizeof(0[x])) void print_makro(int * a) { //You will write this when it is late and the coffee maker ran out of coffee std::cout &lt;&lt; "count of " &lt;&lt; countof(a) &lt;&lt; "\n"; } //Compile Time Error - way better than Run Time Error //void print_template(int * a) //{ // std::cout &lt;&lt; "count of " &lt;&lt; GetArrLength(a) &lt;&lt; "\n"; //} int main() { int a[4] = { 10, 20, 30, 40 }; //this is the same thing because of the compiler replaces the expression before compiling. std::cout &lt;&lt; a[2] &lt;&lt; "\n"; std::cout &lt;&lt; 2[a] &lt;&lt; "\n"; std::cout &lt;&lt; *(a + 2) &lt;&lt; "\n"; std::cout &lt;&lt; *(2 + a) &lt;&lt; "\n"; std::cout &lt;&lt; "count of " &lt;&lt; countof(a) &lt;&lt; "\n"; print_makro(a); // obvious flaw but would still compile //consider template version //https://stackoverflow.com/questions/3368883/how-does-this-size-of-array-template-function-work std::cout &lt;&lt; "count of " &lt;&lt; GetArrLength(a) &lt;&lt; "\n"; return 0; } 
&gt; the C language code which is ASCII The C standard makes a distinction between the source character set and the execution character set. Nothing is as simple as you make it out to be.
There are three valid signatures for main. int main(); int main(int argc, char* argv[]); int main(int argc, char** argv); Use a differnet one or ommit the return value and the compiler may or may not come to the rescue. Prepare for trolling if you post a minimal example on a website and the signature of the main function is void main(); If this compiles your compiler secretly made an int main() and returned 0 at the end. Depending on your language version some other things may be actually legal but the best approach would be to stick to the three most agreed forms that are legal in all version of the standards. #include &lt;iostream&gt; int main(int argc, char * argv[]) { for (int i = 0; i &lt; argc; ++i) { std::cout &lt;&lt; "arg " &lt;&lt; i &lt;&lt; ": '" &lt;&lt; argv[i] &lt;&lt; "'\n"; } return 0; } 
Even better: program.py: Hello friends i am asking for your experience in c programming :) i have a text file of vCards so a sequence of data structured like this: "BEGIN:VCARD VERSION:3.0 PRODID:-//Apple Inc.//iOS XXX//EN ... item1.TEL;type=pref: blablabla REV:YYYY-MM-DDTHH:MM:SSZ END:VCARD BEGIN:VCARD etcetc " I need to print two test files, one with data that contains the raw "REV:YYYY-MM-DD" with a specified date, and another text file which contains all data with the raw of others date. Thanky you for your time and I appreciate if someone could help me. 
Even better: program.py: Hello friends i am asking for your experience in c programming :) i have a text file of vCards so a sequence of data structured like this: "BEGIN:VCARD VERSION:3.0 PRODID:-//Apple Inc.//iOS XXX//EN ... item1.TEL;type=pref: blablabla REV:YYYY-MM-DDTHH:MM:SSZ END:VCARD BEGIN:VCARD etcetc " I need to print two test files, one with data that contains the raw "REV:YYYY-MM-DD" with a specified date, and another text file which contains all data with the raw of others date. Thanky you for your time and I appreciate if someone could help me. 
[This](https://sourceforge.net/projects/libvcard/) library to parse vCards might be useful.
C++ is off topic in this subreddit. Please ask elsewhere, e.g. in /r/cpp_questions.
They are not at all obsolete. GNU just likes to write this kind of bullshit so your Makefiles are incompatible with other make implementations. Percent rules aren't even in the standard.
obj/%.o should also depend on your headers.
Do not post images of code. Always post code as text. I have removed your post for this reason, feel free to resubmit it with code as text. Make sure to put four blanks in front of every line of code so reddit formats the code correctly.
Yeah it‚Äôs funny, I spent so many years trying to automate away all the subtle quirks you can encounter by auto-populating the files to build. When the most robust/simple solution is a list of files to build.
Drawing the board shouldn't be all that daunting: A B C D E F G H I J 1 . . . . . . . . . . 2 . . . . . . . . . . 3 . O X X . . . . . . 4 . . . . . . . . . . 5 . . . . . . . . . . 6 . . . . . # # # # . 7 . . . . . . . . . . 8 . . . . # . . . . . 9 . . . . # . . . . . 10 . . . . . . . . . . 0 = shot that missed X = shot that hit # = section of your ship The user just inputs "D1" to fire a shot The tedious part would be entering the coordinates to initially position your ships. To get started, you could randomly place the ships for both sides instead of having the user do it. If all that seems to daunting, blackjack has a pretty simple UI. 
These amaze me every time and it never gets old.
I was hoping for Objective C
I used to do a Makefile by hand every time. I drank the kool-aid and started using CMake...never touching a Makefile again unless I have to. 
&gt; the tile 
I'm not talking about the C language here but the language code like `en_US.UTF-8`. This usually is ASCII (I think this is even mandated by POSIX). 
Which is why every build system I know also does this, CMake, Meson -- even vcxproj ;) Of course there are other neat build systems like Cargo which work differently just by having one main source file which references the others. Modules woooo -- makes many things muuuch easier.
**GET /\r\n** isn't a valid HTTP request, you need two line breaks at the end. 
It works, thank you so much. Long long isn't big enough so I presupposed precision of double is either not big enough to compute this. And God it was that easy, sorry for dumb question. I love you man, and really appreciate your help.
It kind of is....for HTTP/0.9... But you're right, I updated it. Unfortunately it doesn't solve my issue.
Replace SOCK_DGRAM with SOCK_STREAM. You're asking getaddrinfo for a UDP socket instead of a TCP one. 
No...
YESSSS thank you!
X = 30 Y= 20
please correct me if I'm wrong: q = &amp;x; (q points to address of x, referncing) *q = 10; (assign 10 to x/address of q ie. x = 10) p = q; (p is also a pointer to x) y = *p + *q; (y = address of p + address of q = 10 + 10 = 20) *p = x + y; (address of p = x + y, therefore x = x + y = 30); 
Should it not be x = 27 and y = 20? X was 7 and has not been reassigned
`*p` (and `*q`) means the value pointed by the pointer, not the address (which is just simply `p` or `q` in this case). Other than that, it's correct as far as I can see.
The value of x changes because q points to that *address* So the address of q now holds 10 But what is the address of q? The address at which x is. This can be difficult to wrap one's head around Was for me too....
He wants to know why it's correct
Sort of, but you are mixing up referencing with dereferencing a bit in your reasoning. When dereferencing you can think "value of" instead of "address of".
&gt; please correct me if I'm wrong He wanted to be corrected. I just corrected it.
so is *p = p? assuming *p = 10, is *p = x same as p = x? ie. x = 10?
edited like this? &gt; *q = 10; //assign 10 to the (value at address of q) ie. x = 10 &gt; y = *p + *q; //y = (value at address of p) + (value at address of q) = 10 + 10 = 20) &gt; *p = x + y; //(value at address of p) = x + y, therefore x = x + y = 30; 
That C++, this subreddit is about programming in C.
He didn't say, "Give me teh answerz". 
No, if `p = &amp;x`, then `*p == x` and `p == &amp;x`. `p` is the pointer (holds the address, in this case the address(/reference) to `x`), `*p` is the value of the address it is pointing at (also called dereferencing, in this case `x`). Maybe it is better to print each value after each step: (Comments indicate what is printed, addresses might vary) #include &lt;stdio.h&gt; /* Comments indicate what is printed */ int main(void) { int x = 42, y = 1337; int *p; printf("x=%d &amp;x=%p y=%d &amp;y=%p\n", x, &amp;x, y, &amp;y); /* x=42 &amp;x=0xffffcbf4 y=1337 &amp;y=0xffffcbf0 */ p = &amp;x; printf("p=%p *p=%d\n", p, *p); /* p=0xffffcbf4 *p=42 */ p = &amp;y; printf("p=%p *p=%d\n", p, *p); /* p=0xffffcbf0 *p=1337 */ *p = 0; printf("p=%p *p=%d\n", p, *p); /* p=0xffffcbf0 *p=0 */ printf("x=%d &amp;x=%p y=%d &amp;y=%p\n", x, &amp;x, y, &amp;y); /* x=42 &amp;x=0xffffcbf4 y=0 &amp;y=0xffffcbf0 */ return 0; } 
You provided C++ code, not C.
My only issue with this is that hardly anyone takes the time to properly list the object file dependencies so you are stuck doing single threaded builds. Usually it is a minor annoyance but some of the bigger projects I work on take nearly an hour to do a clean build of on modern hardware.
What helped me understand pointers was to use the %p print specifier to see the address. The best way I have found to understand new concepts is to write small programs to experiment with the new concept. #include &lt;stdio.h&gt; int main(void) { int *p, *q; // declare two pointers to ints int x, y; // declare two ints x = 7; y = 8; printf(" q = %p\n", q); // address stored in q before initialization printf("&amp;x = %p\n", &amp;x); // address where x is stored q = &amp;x; // store the address where x is stored in q // address stored in q after assignment // note that q stores the address of x printf(" q = %p\n\n", q); printf("x = %d, *q = %d\n", x, *q); // x and *p are the same *q = 10; // store 10 in the address pointed to by q (x) printf("x = %d, *q = %d\n\n", x, *q); // changing *q changes x // address stored in p and q before assignment printf("p = %p\n", p); printf("q = %p\n", q); p = q; // set p equal to the address stored in q. p and q both point to x printf("p = %p\n", p); // q is now storing the same address as p printf("y = %d\n", y); // before assignment // since p and q both point to x, this is equivalent to y = x + x y = *p + *q; printf("y = %d\n", y); // after assignment printf("x = %d, y = %d\n", x, y); return 0; }
Thanks for the advice! So, in terms of actually starting writing the program where should I begin? In the slightly pre written program that we had to develop there was all sorts of structures and enums and things. Is it better to start with things like this or sort of go backwards from the main function?
I'd suggest getting a copy of Wireshark, or at least tcpdump, and get used to looking at packet captures. You'll go nuts doing much low-level network work without those tools.
Usually, I will start with the main loop. All programs take input, do some processing then generate output. So, that is usually how I breakdown my plan of attack. Also, you will need the main loop and the input functions to test everything else. &gt; Is it better to start with things like this or sort of go backwards from the main function? Designing everything first is good _if_ you know how to do everything up front. If you don't know how to do everything up front, I would suggest that you use a iterative approach to developing your program. It will be easier and much less frustrating if you write a program a little at a time testing as you go. It is sometime even a good strategy to stop and write a separate small program to test a design or to prototype an idea. You may also want to design somethings else using paper and pencil. I would also recommend that you start with the simplest version of the feature you are working on. Using battleship as an example, you might want to write your function to place ships to first use ships that are only one grid square long. Once that is working you could make your ships take up more than one grid square but facing only one direction. Then add logic to let the ships be oriented in any direction. After that add logic to detect if the ship is inbounds. The main idea is to write small amount of code, then test it. It is much easier to find a bug in 10 - 20 lines of code than it is to find one in 100 - 200 lines of code. 
That seems like a good plan! Thank you, I want to write functions to debug as I go but what I find hard to know what the actual bugs would be that I am testing for if you get what I mean.
Please put four spaces before each line of code in order to make it readable. Also, this is C++ code but you've posted in a C programming subreddit. Finally, you seem to have some misconceptions about how variable assignment works. When you write `int Matrix[3][3] = { { a, b, c }, { d, e, f }, { g, h, l } }`, none of those variables have a defined value so you will end up with garbage output.
Please stop posting shitty video tutorials. They are shitty even when you embed them into a self-post.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, for example to /r/cpp_questions.
You can #ifdef statements to add debugging code to your functions #ifdef DEBUG printf("function_name: variable = %d\n", variable); #endif You can then turn the debug code on and off at [compile time](http://www.rapidtables.com/code/linux/gcc/gcc-d.htm).
&gt; I'm just getting a tons of errors If you get errors, why don't you tell us what errors you get? It's very hard to resolve an error you haven't shown us.
&gt; a tons of errors And they are ... ?
[Error list](https://i.gyazo.com/44d53372912e173ab572b11a7910b769.png) And I was hoping it would the Address of ( Address of array b [ a ] ) and that a would increase with the for loop. 
Why do you want to take the address twice? Why do you want `scanf` to write to the address of `b[a]`? What do you think this does? 
Please do not post this list as an image. Always post text. I cannot copy/paste interesting parts out of an image which makes responding to the errors hard. I'm too lazy to type in the error messages just because you don't feel like copy/pasting them.
Did not know I could copy paste them. recipe for target 'main.o' failed expected 'int *' but argument is of type 'int (*)[10]' expected 'int *' but argument is of type 'int (*)[10] passing argument 1 of 'printb' from incompatible pointer type [-Wincompatible-pointer-types] passing argument 1 of 'scanfb' from incompatible pointer type [-Wincompatible-pointer-types] invalid type argument of unary '*' (have 'int') label 'b' used but not defined format '%d' expects argument of type 'int *', but argument 2 has type 'void *' [-Wformat=] expected ')' before '[' token &lt;-- stupid error And I do not want scanf to write the address of b[a] I want it to scan for a input then place that into b
Why do you think a nested for loop would only do [0][0] [1][1] and so on?
&gt; And I do not want scanf to write the address of b[a] I want it to scan for a input then place that into b Then you want just one `&amp;` because you want `scanf` to write into `b[a]`, so you pass the address of `b[a]`. &gt; expected 'int *' but argument is of type 'int (*)[10]' To fix this error, do not take the address of `b` when calling `scanb` and `printb`. When you pass arrays to functions, a pointer to their first element is passed. This is usually what you want. &gt; invalid type argument of unary '*' (have 'int') This error indicates that `*b[a]` is wrong. `b[a]` is the value of item `a` in array `b`. Why do you think a `*` is needed here? &gt; label 'b' used but not defined I have no idea what causes this error. &gt; format '%d' expects argument of type 'int *', but argument 2 has type 'void *' This error is caused by the compiler trying to make sense of the previous problems. If you fix them, it should go away.
As a learning exercise, I would suggest calling printf() on different pointer/address operations of b. For instance: printf(b) printf(b[0]) printf(*b) printf(&amp;b) printf(&amp;b[0]) Be sure to use hex formatting. See if the results are what you expect. If not, look up more info on the syntax that gives you an unexpected result. 
Thanks I will give this a try. 
Can you elaborate a little on what do you mean by "algorithmic bias"? I can only think of AI/ML where a model can become 'biased' but maybe I'm wrong. 
I think they're envisioning using a single variable for both indices.
 int i = 0; int j = 0; for(i=0; i&lt;5; i++) { for(j=0; j&lt;5; j++) { array[i][j] = something; } } If you know about the % operator, you can do this using a single variable: for(i=0; i&lt;5*5; i++) { array[i/5][i%5] = something; }
Ah yeah I was just thinking about it wrong my bad! 
You need two loops, one inside the other: // Clear board for( int y = 0; y &lt; BOARD_HEIGHT; y++ ) { for( int x = 0; x &lt; BOARD_WIDTH; x++ ) { board[ y ][ x ] = 0; } } You use `[ y ][ x ]` notation instead of `[ x ][ y ]` because it more efficient to access memory in linear forward patterns. Two dimensional array are stored as linear blocks of memory for the rightmost index. For int my_array[ y_count ][ x_count ] where, say, both counts are 3, memory looks like this: my_array[ 0 ][ 0 ] my_array[ 0 ][ 1 ] my_array[ 0 ][ 2 ] my_array[ 1 ][ 0 ] my_array[ 1 ][ 1 ] my_array[ 1 ][ 2 ] my_array[ 2 ][ 0 ] my_array[ 2 ][ 1 ] my_array[ 2 ][ 2 ] Another way to see it: int value = 1; for( int y = 0; y &lt; 3; y++ ) { for( int x = 0; x &lt; 3; x++ ) { board[ y ][ x ] = value; value++ } } Memory: 1 2 3 4 5 6 7 8 9 If we use `[ x ][ y ]` ordering instead: board[ x ][ y ] = value; Memory: 1 4 7 2 5 8 3 6 9 It works, but won't run as fast. Maybe not important for a small game, but badly-ordered memory accesses for larger programs can really slow it down.
`assert()` does not return a value. However, you expect it to return a value and compare it with `false`. Perhaps you meant assert(isvalid(5,4) == false); instead.
Yeah I realised just after posting this would work, I was thinking that the for loop would go back to the first one for some reason.
Perfect, thank you!
You can use some preprocessor for start to help you familiar with code like this. #define AddressOf &amp; #define pointer * int printb(int pointer b) { for (int a = 0; a &lt; 10; a++) printf("%d", b[a]); return 0; } int scanfb(int pointer b) { for (int a = 0; a &lt; 10; a++) scanf("%d", AddressOf b[a]); return 0; } int main(void) { int b[10] = { 0,1,2,3,4,5,6,7,8,9 }; while (1) { printb(&amp;b); scanfb(&amp;b); } return 0; } @line *b[a] is unnecessary to load indirect value from pointer because when you use "[]" with pointer "b" it already load indirect. b[a] == *(b + (a * sizeof int))
Use the `%` operator to reduce the range of the random value.
This is exactly what I am talking about. Either (1) algorithm learning from historical data sets, which are biased, and therefore perpetuating the bias, or (2) the algorithm is biased, unintentionally, due to the programmers own biases. 
So rand() % 4 + 1 would reduce the range to 1,2,3,4, but how would I include 0?
What I've seen from the POSIX spec, it does.
* What does `rand() % 4` do? * What range of numbers can it produce? And how many numbers are there in that range? * What range of numbers do you want? And how many numbers are in the range you want? ^ ^ Those questions should guide you, and help you work out how to include 0 yourself.
rand() % 5
I see. I'm afraid I can't help you. Try posting on r/MachineLearning 
Here's a sneak peek of /r/MachineLearning using the [top posts](https://np.reddit.com/r/MachineLearning/top/?sort=top&amp;t=year) of the year! \#1: [\[R\] Neural Color Transfer between Images](https://i.redd.it/1qync11pltpz.jpg) | [91 comments](https://np.reddit.com/r/MachineLearning/comments/748cco/r_neural_color_transfer_between_images/) \#2: [\[R\] Deep Image Analogy](https://i.redd.it/4n1j4tvhq7vy.jpg) | [123 comments](https://np.reddit.com/r/MachineLearning/comments/68y8bb/r_deep_image_analogy/) \#3: [\[D\] Why can't you guys comment your fucking code?](https://np.reddit.com/r/MachineLearning/comments/6l2esd/d_why_cant_you_guys_comment_your_fucking_code/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
skills
`rand() % 5`
Actually don't do this; this won't create a uniform distribution. Instead do: int num = floor((float) rand() / RAND_MAX * max); to create a random integer from `0` to `max`.
Thank you so much for your time and effort! I will go there now. 
If you want to include 0, just use `rand() % 5`.
This is true, but I though that mentioning this would confuse OP (who is clearly a beginner) too much. Also, you should at least use a `double` instead of a `float` to not lose entropy.
If RAND_MAX numbers don't map uniformly to X numbers using %, then they're not going to map uniformly using any other operator either. To guarantee a uniform distribution you need to discard some inputs. In reality the deviation from uniformness is usually not small enough to care about.
rand() % 5
Thanks that helped a lot! 
Unfortunately it's running off of a server on a different network. I don't have a Linux machine at home. Suppose I could set up a virtual machine... 
Although that will give the same sequence of random numbers if the program is run multiple times within the same second; or if the user changes the system clock.
Doesn't need to be a Linux box. I run Wireshark on Windows all the time. And I run tcpdump on remote servers.
No, you'll still get aliasing. You need something like [OpenBSD's `arc4random_uniform()`](https://github.com/openbsd/src/blob/master/lib/libc/crypt/arc4random_uniform.c).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openbsd/src/.../**arc4random_uniform.c** (master ‚Üí b97e28d)](https://github.com/openbsd/src/blob/b97e28d2da3b89357d92a02714153a789af11e78/lib/libc/crypt/arc4random_uniform.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Try this: #include &lt;stdio.h&gt; int main(int argc, char const *argv[]) { int b[10]; for(int a = 0; a &lt; 10; a++) { scanf("%d", (b + a)); } for(int a = 0; a &lt; 10; a++) { printf("b[%d] = %d\n",a, b[a]); } return 0; }
both gcc and clang are in a miserable bloat state
thank you!
thank you!
No problem. Keep at it, pointers give everyone problems.
It's input code false that 0 appear, input section only write value of first column of matrix so 2nd and 3rd still 0; if you just don't want 0 to show then just add check value on printing line. int item = arr[row][col]; if(item) printf("%d \n", item);
The void in question was the assert(), and the compiler complained that you were using its value rather than ignoring it. That also meant that your asserts were testing the isvalid() instead of testing that isvalid() is false.
This probably won't matter to you, but be aware that rand() has potential risks. Depending on where you use it and how, it's sometimes possible for attackers to determine the values that generate the randomness. This has caused huge damage to (for example) online gambling sites, as the attackers were able to reliably predict hands, slots, etc. Also, there are tools that have fingerprints for the rand() function in certain C libraries. These tools can "unrandomize" an application and make it always return specific values by patching it in memory.
You shouldn't be using that for cryptographic strength numbers anyway. 
It could be a copy paste error, but check your closing brace on the else case. I'm guessing it should come after changing the next player and before updating the number of moves.
That didn't seem to work either :(
[Take a look here](https://github.com/krpors/cfiddle/blob/5b36a41c4a0aacc16a594776966ecc932a9ebf00/kbd/kbd.c). It's not fully functional and probably error prone, but this is what I quickly wrote as a proof of concept of intercepting keys, system-wide. 
Well I think we need more context. What's the debugging test? How else does it fail to satisfy expected behaviors?
Please edit your post and insert four spaces at the start of each line of code.
Please excuse the negativity, but your last 20 or so posts are just asking questions regarding this project of yours. Do you bother spending any time by doing some actual research into your issues, or you just assume everybody else's time is less valuable than yours?
Youre looking for r/cpp or r/learncpp 
First one is empty, th second looks good, thx
Fixed it, was missing underscore
Come on dude/dudette, the answer is literally in at least one of the videos you posted! I get not wanting to do homework, but being too lazy to watch a video with the answer in, is a new low!
Writing this small scope question takes longer than debugging it. You need to learn how to use the debugger. Debugging gets easier if you call your code from a testing project and write tests for your source code before you write the production code. The keyword is TDD. The simple version of debugging involves clicking in front of the line where interesting stuff happens and then running the project with the debugger. your project will halt where you clicked and you can look at the values in the variables. Further you can move line by line through the code and see how the values change. Writing test code can be done using frameworks like boost test or google test. Do that in about a month or so. Split your project into three parts. A core library compiled as a static library. An executable that imports the core library. a testing project that imports the core library. That will get you pretty far and will help you to understand and debug more stuff. To your question: here is something i wrote up as a hipshot that should reflect your codebase a bit. If you want to know how it works debug it and split the lines you do not get into multiple lines with temporary variables in the mix. #include &lt;iostream&gt; typedef char player; player O = 'O'; player X = 'X'; player N = ' '; struct game { player grid[3][3]; int moves; }; // Make a move at the given valid position. void move(game *g, int r, int c) { g-&gt;grid[r][c] = ((g-&gt;moves) % 2) ? O : X; g-&gt;moves += 1; } int main(int argc, char * argv[]) { game g; for (int i = 0; i &lt; 9; ++i) { *(g.grid[0] + i) = N; } move(&amp;g, 1, 1); move(&amp;g, 1, 2); return 0; } 
ops - I actually did that a couple of times now. Sorry. Will pay more attention.
I just found the notifications that this is a C subreddit. I will pay attention next time and provide clean c code - sorry for the c++ infestation.
OP isn‚Äôt asking a question, this is a ‚Äútutorial‚Äù 
If you post one more of these, I'll ban you.
There is a lot to random and there is no good c library to deal with random numbers. Read up on the function here and consider its weaknesses: http://en.cppreference.com/w/c/numeric/random/rand Here is a talk from WALTER E. BROWN on the ins and outs of the problem. The talk is for c++ but the concepts are independently valid. https://www.youtube.com/watch?v=6DPkyvkMkk8 Consider int rand(); your engine - your engine would have a normal distribution. You need to use the values of the engine to drive your distribution. The distribution is what determines how likely each of your values should be. Here is some example code where I would hope it delivers close normally distributed Values from [0 - 4]. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int mydistribution(int engine_random) { int retvals[] = { 0,1,2,3,4 }; int retvals_count = sizeof(retvals) / sizeof(retvals[0]); int distance = RAND_MAX / retvals_count ; int index = engine_random / distance; return retvals[index]; } int mynext() { int engine_random = rand(); //0 and RAND_MAX included int distributed_random = mydistribution(engine_random); return distributed_random; } int main(void) { srand(1); //seed - you may want to use the current time here printf("%i", mynext()); for (int i = 0; i &lt; 100; ++i) { printf(" %i", mynext()); } printf("\n"); } 
I went back and forth a bit but I had some fun implementing the distribution: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int mydistribution(int engine_random) { int retvals[] = { 0,1,2,3,4 }; int retvals_count = sizeof(retvals) / sizeof(retvals[0]); int distance = (RAND_MAX / retvals_count) + 1; int index = engine_random / distance; return retvals[index]; } int mynext() { int engine_random = rand(); //0 and RAND_MAX included int distributed_random = mydistribution(engine_random); return distributed_random; } int main(void) { int results[5] = { 0,0,0,0,0 }; srand(1); //seed - you may want to use the current time here printf("min value %i\n", mydistribution(0)); printf("max value %i\n", mydistribution(RAND_MAX)); for (int i = 0; i &lt; RAND_MAX; ++i) { int n = mydistribution(i); ++results[n]; } int n = mydistribution(RAND_MAX); ++results[n]; for (int i = 0; i &lt; 5; ++i) { printf("count of %i was %i\n", i, results[i]); } printf("stream of random:"); for (int i = 0; i &lt; 100; ++i) { printf(" %i", mynext()); } printf("\n"); } 
Note that `x == false` is the same as just `!x`.
Or even better read a book...
Yes, both must be aligned.
Here's the rule: *all pointers* must be properly aligned to the natural alignment of the pointed-to type, at all times. So if you have size_t *header = /* |h| */; then `|h|` must be aligned to `alignof(size_t)`. Similarly, if you have some_type *block = /* b */; then `b` must be aligned to `alignof(some_type)`. So yes, both have to be separately aligned.
Please put four spaces before each line of code in order to make it readable. Also, this is C++ code but you've posted in a C programming subreddit.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
However if alignof (size_t) is the max alignment value for the platform you are on, things are easy
Thanks!
Btw pre-C11 `max_align_t`, how could you find that out?
Just one more question, related to this topic I don't really get. What happens when I want to write a `struct` into such a block? For example if I have struct test { int i; char str[10]; } then the full `sizeof(struct test)` will be aligned, but shouldn't be the members too? What really happens when I access `test-&gt;str`? 
Structs have padding that keeps their members aligned. For example: ``` struct test { char c; // 1 byte // 3 bytes of padding int i; // 4 bytes char str[10]; // 10 bytes // 2 bytes of padding (to keep i aligned in an array of struct test) }; ``` `alignof(struct test)` will probably be the maximum alignment of each of its fields.
Particularly my use of `malloc` and the way I am creating Node and List objects. I used to do a lot of C++, so I'm not sure if this is the "standard" way it would be done in C. My `createNode` and `createList` functions are supposed to feel like a C++ constructor (maybe?), but I don't think that is *the* way to to it in C. Any comments and advice would be much appreciated!
You usually want to check bounds when using `str*` functions (pass a `size_t len` too and make the array length a define). From a style perspective: Most C code is in snake_case and I also prefer my variables not to be capitalized
Thank you, I'll make those changes.
The weak indentation and the waste of lines for opening parentheses makes your code quite hard to read. Also, make sure to check the return value of `malloc()`. It could be `NULL` and you have to handle that. I also dislike the lack of comments. Each function should have a brief comment specifying what that function does and what its assumptions (e.g. the argument may not be NULL) and invariants (i.e. how you can expect the function to behave) are.
By weak indentation do you mean my use of spaces? Are tabs standard in C programming? Also, i thought keeping opening braces in their own lines is standard in C? I will check for that return value. This was really my first time writing serious C code and I guess I still don't really understand `malloc` too well. I will definitely add more comments, I guess I just expected everyone to know how a doubly linked list tends to behave, this was just for practice anyway. Thank you for your feedback.
The biggest problem that I can see is that this will leak memory. When you insert nodes, you call createNode, which calls malloc, allocating you memory on the heap to store your node. However, when it comes to delete your nodes, you call deleteNode, but nowhere in that code do you call free. This means that you are never releasing any of the memory you allocated in your malloc calls. Meaning that if you use this code, and insert and delete nodes, your programme will leak memory as it allocates memory but never frees it.
&gt; By weak indentation do you mean my use of spaces? Are tabs standard in C programming? Yes, tabs are standard. &gt; Also, i thought keeping opening braces in their own lines is standard in C? Not really. There are different opinions on this topic, but arguably the most useful one is KNF (kernel normal form). Read about it [here](http://man.openbsd.org/style). Basically, the opening brace is only put on the next line in function definitions. This is because in K&amp;R-style function definitions, arguments are declared between the formal parameter list and the beginning of the function's block like this: int puts(str, stream) char *str; FILE *stream; { /* ... */ } In all other situations, there is no point in wasting another line for no reason. However, since K&amp;R-style function definitions are very rare and obsolete today, many programmers stopped doing this exception. &gt; I will check for that return value. This was really my first time writing serious C code and I guess I still don't really understand malloc too well. The function `malloc()` is simple: if it can allocate memory, it returns a pointer to the allocated block. If not, it returns `NULL`. Very easy. &gt; I will definitely add more comments, I guess I just expected everyone to know how a doubly linked list tends to behave, this was just for practice anyway. Indeed, that can be expected. However, there are so many design decisions to make when implementing doubly linked lists, you should really comment what choice you made. This is also useful for checking if the code is correct: if it disagrees with the comments, one of the two is certainly wrong. If both agree, you can simply look at the comment to know how the function behaves when writing code that uses your interface.
So would the appropriate place to call free be inside of deleteNode? Also, is it even ideal to implement this using malloc at all? Is there another way?
I will switch to tabs then. Cool, I had not heard about KNF or K&amp;R before, thank you!
As far as style goes, I personally like the Linux kernel style guide. Definitely worth reviewing when you're new to C. [Link](https://www.kernel.org/doc/html/v4.10/process/coding-style.html)
Its a great start! Dont let anyone discourage you. I am listing the issues/comments below only to help you get better :) You dont seem to set the previous head's `prev` to the new head in `insertAtHead`: https://gist.github.com/jorgegonzalez/3a416655d255f793907fd6325f1745b0#file-dll-c-L49-L52 In `insertAtTail`, you are not setting the new tail's `prev`. `printList` can be written in a shorter way: for (Node* current = ddl-&gt;head; current != NULL; current = current -&gt;next) printf("%s\n", current-&gt;data); You dont update `prev` in `deleteNode`. If it is the last node in the list, you need to update `tail` as well. I will echo comments from other posters about leaking memory in `deleteNode`. In case you dont know, look into tools like [valgrind](http://valgrind.org/docs/manual/quick-start.html) that will help you identify leaks. Something like [ddd](https://www.gnu.org/software/ddd/) will help you see the list visually and see how it transforms. I would suggest improving `main` or going with an actual unit test suite and adding more tests.
It's certainly not the *only* way to do it in C, but it's definitely appropriate for a linked list. Using `sizeof *node` (etc.) is really nice. You've heard it before, but in C you have to be explicit about the deconstructors, too. You should have a `deleteNode` and `deleteList` that call `free` somewhere inside. And at some point you might need to start worrying about namespaces, or the lack thereof. Some people use an OOP convention that puts the name of the type at the beginning of 'methods' on that type, i.e. `listInsertAtTail` and `listCreate`, but as a style suggestion, take it with a grain of salt. It's not the only way.
&gt; Yes, tabs are standard. They are? Certainly the Linux kernel uses tabs, but (for example) [Python uses 4 spaces](https://www.python.org/dev/peps/pep-0007/). In my experience there isn't really a standard except for a particular project.
do you have the correct permissions on your executable file?, because it sounds like you don't have permission.
While I can't deny that some projects write C with spaces, it's really a style I cannot recommend. Tabs allow the reader to select an appropriate indentation level manually and generally stick out farther than space-based indentation, which helps with readability. Not being able to write deeply nested code due to much of the line real-estate being taken up by the indentation is a feature, not a bug.
Yes, it is a good place. No, in C you have to ask for the memory to create a linked list. Also, as another web dev getting into C, valgrind is a great tool to use when testing. It lets you know about memory usage and any leaks.
If you‚Äôre dealing with simple (i.e., non-array-, non-function-ish types), or if you have some way of wrapping up types like `__typeof__`, you can make a rough `alignof` macro using `offsetof` from `&lt;stddef.h&gt;`: #define struct_alignof(T)\ offsetof(struct {char a; __typeof__(T) b;}, b) (Of course, if you have `__typeof__` you have `__alignof__` too.) This isn‚Äôt quite the same as a normal, non-`struct`-based `alignof` operator for reasons, but it‚Äôs close enough.
I think it would be sensible to put your free in the deleteNode function. (Unrelated to memory) You might also want to consider what happens if you have duplicate nodes. Currently you will just remove the first one you come across. Is that what a user would expect? If you want to use dynamic memory you need some mechanism of allocating and deallocating that memory. Do you *need* to use malloc? Not necessarily, you could provide an allocater, like in C++ STL and use that to request your memory (but obviously you would need to write that, and it would at the very least have to support allocation and freeing). 
I will check that out, thank you.
&gt; printList can be written in a shorter way: I would have never even thought of that. I will make all the changes you suggested, thank you!