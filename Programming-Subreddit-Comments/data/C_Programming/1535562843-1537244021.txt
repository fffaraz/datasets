I'm not sure why, but I too feel sceptical about modal interactions. How do you propose to scroll text without leaving homerow? More modifier keys?
I meant for the question to be the libraries that you're most likely have programming problems for in long programming career. E.g what library for databases, what library for compression, what library for GUI, what library for crypto etc. Which ones have you perhaps used most often and perhaps had to choose between libraries and found the best and most stable. That's the reason for the question because surely I could google all of the answer and conduct extensive research, but I'm sure somebody done this before me.
Good answer. If you don't mind me asking a question because I'm new to these libraries; what's in glib, gobject, gio. Is it GTK?.
There are too many individual subjects to list all relevant libraries. If you tell me any list of things you are interested in I can suggest you relevant good libraries.
&gt; What about in the event that the user doesn't have the dependency installed on their machine? If the user is well versed in open source development I guess you can just tell them to download, build, and compile the dependency themselves from source, but from my experience that's enough to compete dissuade them from using your software (too much hassle). I try to restrict myself to dependencies that are likely packaged for this reason. It is never too much to demand the users installs a bunch of packages from package management. Of course you should list the required packages in your documentation and optionally provide package lists for the most popular systems. &gt; Recently I came across a dependency management solution that works incredibly well (IMO). Using CMake's find_package you can poll for the existence of a package, if it doesn't exist, you can download it using git submodes. After this CMake handles platform specific building (for the dependency and your own project). Sounds good at first but totally subverts the concept of signed and checksummed release tarballs. Why sign your tarball when during compilation you download arbitrary code from the internet?
No single compression algorithm covers all cases. The right algorithm for the job depends on the nature of the data you're compressing, whether you can tolerate loss (lossy compression), and how many computers resources (memory, CPU time) you're willing to spend for a particular compression ratio. zlib is the primary implementation of the DEFLATE algorithm. That's the algorithm at the heart of gzip, .zip, and virtually all HTTP compression. At an important point in history DEFLATE sat in a sweet spot that gave good results at low cost that worked very well for many applications. Some more recent algorithms are objectively better than DEFLATE ‚Äî faster *and* better compression ratio. Other algorithms sit at a better trade-off points for specific types of applications. So the reason to learn zlib isn't because it's the best compression algorithm nor always the right choice of algorithm. Rather, DEFLATE continues to be the most widely used compression algorithm, and zlib is the most common way to access it directly. 
You check this: https://github.com/kozross/awesome-c
This is a really good concise explanation and exactly what I was asking for.
I've seen that and it is indeed a really good list and it's open source, but my gripe with this is which do I choose, how can I know which libraries are worth learning and practicing with?.
Where is libevent mostly used?. Where does it excel?. What can you do with it?
That's interesting I must say. So libuv supercedes libevent?.
Which embedded library is worth learning?.
&gt;So libuv supercedes libevent? libuv may used that library in first versions but AFAIK, it was dropped later. 
Another one: [https://github.com/jemalloc/jemalloc](https://github.com/jemalloc/jemalloc) for fast allocating memory. actually I'm working on lot of libraries (you can see some of them on github) for my projects, so I only need these libraries as third party (for now): \- libxml: parse XML \- jansson ([https://github.com/akheron/jansson](https://github.com/akheron/jansson)): parse JSON \- [https://github.com/zserge/jsmn](https://github.com/zserge/jsmn) (alternative to above) \- cmocka ([https://cmocka.org](https://cmocka.org)): unit tests \- jemalloc ([https://github.com/jemalloc/jemalloc](https://github.com/jemalloc/jemalloc)): alloc/free memory \- libcurl (r/http://github.com/curl/curl): getting URL content
Thanks for this.
Well, you're right that knowing that information makes me think twice about the issue. I should say: it seems *to* *me* to be more in the spirit of C to allow the programmer the choice of whether or not to pass the size of an array. Knowing that Walter Bright thinks otherwise tells me there are smart people with way more relevant experience than me who think it's a mistake. (I would guess that Walter Bright needs no such hand-holding to get it right but he is concerned that this aspect of the language makes it easier for others to make mistakes.)
I've seen nearly all of these listed in other posts, but the book *21st Century C* lists a handful of general libraries that you have a fair chance of coming across for tasks. * GLib * POSIX (specifically mmap and pthreads) * GNU Scientific Library * SQLite * libxml * cURL
Compiles here on macOS 10.13.6 using LLVM 9.1.0. ``` ~ netstat -an | grep 8001 tcp4 0 0 *.8001 *.* LISTEN ~ nc localhost 8001 HTTP/1.1 200 OK &lt;!DOCTYPE html&gt;&lt;body&gt; Hello, World! &lt;/body&gt;&lt;/html&gt; ``` However, Safari is not happy with the response, and claims "the server unexpectedly dropped the connection". Of course this is correct, because your coded response is not valid HTTP/1.1. [See this example](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Client_request), where you can see that any number of headers may be expected after `HTTP/1.1 200 OK` and they *must* be separated from the content body by two CR-LFs. The content body itself may also want to be terminated with a CR-LF, although I do not know if this is required by the HTTP spec.
Depends on how you define "best", most people probably substituted that with "most commonly used". Virtually everything uses zlib for compression, sqlite for small database, protobuf for serialization, ffmpeg for anything a/v related and so on. We are talking "best" in a sense that these things are easy to setup, open source and "just work" so you don't have to reinvent the wheel every time you want/need a XML parser.
I was befuddled for a moment wondering why Megatokyo art popped up in my reddit feed when it's supposed to only be on my twitter. :D
hjkl?
I see your point. I'll add more clarity on the purpose of the project to its readme.
I like JSMN but it's already mentioned above, also LittleVGL, haven't seen deeply in it tho.
A fairly recent crypto library: [monocypher](https://monocypher.org/) written by /u/loup-vaillant i'd consider a "best" crypto library.
My school ‚Äúteaches‚Äù C by providing us with quite a bunch of practical projects to work on. I find it to be a good way to learn. I‚Äôm implementing my own printf() at the moment. I can give some subjects if you want to try.
Use `htonl(INADDR_ANY)` on ln 18 and try netcat again :)
What would this accomplish?
Thanks for the recommendation. :-) A core strength of Monocypher is its simplicity. No dependency, relatively few core functions. If you just want to use it, there's very little to learn, besides cryptography itself. As such, it is not "essential for the OP to practice with": there's very little to practice with, and that's kind of the point. (That said, writing a simple encryption/decryption utility with Monocypher may be a good beginner's exercise.) If the OP is interested about how to _make_ good libraries, then I confess I am quite proud of Monocypher ‚Äîespecially the documentation, for which I received top notch help (contributors basically rewrote everything). 
Oh, you're right, both end up as zero, my bad. Actually, you are probably not closing the socket properly, e.g. it should (does for me) work the first time, but not the second time and it stays open for a while after you terminate your program, thus when you run it again, you can't claim the socket? You can either do close(server_sock) at the end of the program, but you'd have to refrain from terminating it or enable reusing of the old socket. Sth like this before bind for socket reuse. ` int enable = 1; setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &amp;enable, sizeof(int)); ` Also, print (or otherwise "debug") return values of bind, listen and accept.
Yes, but the point was to not enter "hjkl" into the current document you're writing.
Your code works for me, Chrome has no problems displaying the content. There are some problems with your HTTP and HTML however: - Your `Connection: keep-aliveA` contains an invalid `A` at the end. - Your connection header should probably be `close` anyway, since you immediatly close the connection. [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection). - Your Content-Type is invalid, you probably meant `text/html`. [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type). Specifying the charset also wouldn't hurt. - Your Content-Length is also wrong, this should be the actual length of your response_data in bytes. [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length). - Your `response_data` is invalid HTML. A simple HTML5 hello-world looks like [this](https://gist.github.com/timbergus/5812402).
If you're moving around, you're not inserting...
This thread is worth saving, OP should add all answers to a list and place them in Question.
How would I go about measuring the content-length of my html?
Use close (read shutdown doc too) and set up `while` when binding the socket. Check for errno EADDRINUSE and sleep if need be, print your error message and exit if it's any other error. When you close the socket, it's only marked as closed. If there is a pending connection (try netcat [without terminating it] vs browser), it should take more time for OS to close the socket if a browser was connected to it (because netcat connection should be still active). Try `netstat -antp` and note that some may have TIME_WAIT (if you try it shortly after you run your server and connect with netcat, then close the server, you should see localhost [e.g. your connection] there too), those are waiting to be closed. Reusing address is the way to go around this :) You can also kill the socket forcibly (I'd not recommend that as a standard practice howerer)
The content length is literally the number of bytes of content you send. So since you store your content in a C-String, you can just call strlen to get the number of bytes. Your string is encoded in ASCII -&gt; 1 byte per character.
I see /u/Lisoph already handled your code question, but you mentioned you were having trouble connecting to `localhost`. It may be that your system also thinks `localhost` is `::1` (IPv6), whereas your code specifically listens seemingly on IPv4 only. You may try `nc 127.0.0.1 8001` or `http://127.0.0.1:8001` instead of `localhost` to get around that behaviour.
I advice for using the libcrypto instead becuase it is less likely to have security issues than someones homegrown crypto code.
If I'm correct, I'd have to kill the socket forcibly before trying anything as it's currently open and won't accept connections, no? If so, how would I go about doing that? tcpkill?
If you're already comfortable with the basics of C, give this a try : https://viewsourcecode.org/snaptoken/kilo/ This project based tutorial guides you through building your own text editor. It was an awesome learning experience for me and now I have a new text editor I enjoy writing code with. 
I usually recommend adventofcode.com for learning a new language. There are three years of events that start off simple and escalate to pretty challenging stuff. There's also /r/adventofcode with helpful tips and advice if you get stuck.
Make it `server_address.sin_port = htons(8001);` on ln 34
Still nothin'
I hope it wasn't because of my first comment. There I meant to write ln 20 (came out as 18 :/) in the first code you posted, but as INADDR_ANY is all zeroes, byte order doesn't affect it (though you'd need it when using INADDR_LOOPBACK) 
&gt; Still nothin' That's weird, https://pastebin.com/NZwM8Cbv works for me (though it's a single request). You sure you compiled it? Any errors?
Compiles fine. I think the issue comes from my first time opening the socket and not closing it. (It worked the first time I ran it, then just stopped working overall) 
Great, np :)
Not op, but this is really cool. I'll be working through this in some spare time.
Thank you.
Thank you for reviewing and explaining my code. Would you mind if I copy your comments to my GitHub repository? I'll probably try to add some notes about this particular proof of concept project to my other Red Pitaya notes at [this link](http://pavel-demin.github.io/red-pitaya-notes/). BTW. The code in the initial post is from one of the earliest versions of this project. I'd suggest /u/PacakeMSTR to have a look at the more recent version in the master branch of the repository at [this link](https://github.com/pavel-demin/red-pitaya-notes/blob/master/projects/adc_recorder/adc-recorder.c).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pavel-demin/red-pitaya-notes/.../**adc-recorder.c** (master ‚Üí 78b3e9d)](https://github.com/pavel-demin/red-pitaya-notes/blob/78b3e9db562db2a21b91dcb854bcec036aebbc51/projects/adc_recorder/adc-recorder.c) ---- 
C++ is off topic in this subreddit. Please look for C++ jobs in /r/cpp_questions.
This is extremely useful and I appreciate your work very much. The operations on cfg are, I'm guessing, binary arithmetic, right? But I'm not sure I understand how it's working. Consider cfg[0] &amp;= ~4; // set bit 2 to 0 - '&amp;=' is logical and - '~4' is "not 4", or 011 (?) So when we &amp; cfg[0] with 4 = 011, why is it, as you say, only altering bit 2, rather than the last three bits? 
Thanks. This reallyyyyy helped!
There isn't really a general purpose library I know of. What is the library supposed to do for you? In C, especially on embedded systems, it's very common to write everything you need yourself as there is usually very little you can reasonably take from the outside.
Thank you for the heads up, I apologize for posting in the wrong subreddit!
I'd second this. You can skip the very first lecture which introduces you to scratch and just go to the next ones that intro the C problem sets, or maybe even skip some of those depending on prior knowledge.
Books are as interactive as I want...so I am fine with them! hehe
Books are great, but for me extensively long winded. That‚Äôs why I linked mooc because its explanations are super condensed and to the point. I do t need the history/story. 
So you are better off programming. We read, read, read, talk, hear... that is pretty much it! 
Same, looks good
&gt;The operations on cfg are, I'm guessing, binary arithmetic, right? Right. &gt;So when we &amp; cfg\[0\] with 4 = 011, why is it, as you say, only altering bit 2, rather than the last three bits? `cfg[0] &amp;= ~4;` can also be written as `cfg[0] = cfg[0] &amp; (~4);` If we work with 8-bit integers, then `(~4)` is `11111011`. `xxxxxxxx` &amp; `11111011` = `xxxxx0xx` So, only one bit is set to 0. All other bits remain untouched.
&gt; their whole ecosystems are based on these statically linked micro libraries. I don't like this either. Perhaps this is a good argument for not introducing module functionality into a language: if you don't have an easy way to make libraries, people make less libraries and less people write shitty node.js-esque code.
Agreed. What could be a good way to do that without modal interactions?
Related LWN article: https://lwn.net/SubscriberLink/763641/c9a04da2a33af0a3/
I'm sure an emacs user could tell you.
Im a big proponent of learning by doing. find a project youll be addicted to complete. Something that could have a concrete, positive impact on your life. Honestly that part is usually harder than the technical aspects.
Come on guys, don't downvote. I know it seems like a funny mistake to make, but we all had confusion and embarrassing misunderstandings in our early days. OP posted their code, asked a clear question, and accepted good advice. No need to downvote.
Two best ways are by writing code, and reading other people's code. Books can only get you so far, although I always have the K&amp;R book near by when I have a question.
After you type the letter you press enter. That enter is waiting there in the input stream and is used for the following %s.
Ok, so how would I go about fixing that. Also why didn't it show up sooner? Thanks for the help :P
`scanf` wants its input to be an exact match to the specifiers you tell it to look for. You can add another format specifier to read the enter key, or you can read it with something else like `getchar`. You could skip scanf all together and read input some other way. Just remember it wants exactly what you tell it to expect. Everything else is left in the stream for your next read.
Just add getchar() after all the scanfs. You need this cause the enter key is a newline and it flows into the next prompt
Do you have more examples of practical projects? For me it's always difficult to find new ideas for projects...
NOT ANSWERING YOUR QUESTION: ...but some switch statements instead of all the elifs would make this more readable I think.
I have quite a bunch of projects like that. You can take a look at my github ([https://github.com/pdeguing](https://github.com/pdeguing)). I try to include the instructions pdf in each repository so you can take a look at what I've done so far and do the exercice yourself if you want. I would be happy to discuss any work you do on that. If you want more advanced stuff, message me what you are looking for and I'll look into all the projects to see if some may interest you.
Don't use `scanf` to read whole lines. It's really quite tricky to use it correctly. Use `fgets` or `getline` to read a whole line, then parse that line to extract the fields you need (possibly using `sscanf`, possibly through other means).
Your for loop is the problem: `for (i++; str[i]!='x'; i){` This will loop as long as `str[i] != x`, whether or not the while loop's conditions still hold true. That's because the `for` loop statement is completely independent of the `while` loop. So your `for` loop terminates twice - once for each 'x' in `str`, but then continues indefinitely past the end of `str`, since it never again sees the `x`.
Oh sweet Jesus thank you. Staring me right in the face. 
As a matter of fact you don't even need the for-loop inside the while-loop. You get the position of the first character that `strtol` couldn't parse in `ptr`. If `strtol` can parse the whole input, then `ptr` will be `NULL`. So you can simply advance `ptr` by 1, if it is not `NULL` to find the next element that you need to parse.
I‚Äôm pretty sure it has something to do with the input you‚Äôre giving scanf, very tricky to use that correctly, but it looks like other people have given you more detailed responses about that. I‚Äôve found that it helps to just slowly go through the program in GDB to find the error, however in this case that probably wouldn‚Äôt have helped you very much. 
No shadow support in the current version. In the future I plan to add shadows. I think the engine will immediately look much better.
Among other things, it looks like you're probably going over the bounds of your array. In a `float array[n]`, you can access elements from `array[0]` to `array[n-1]` but you seem to be going from `X[1]` to `X[n]`. Also, you're not using your `R` array and you're either not touching enough of `X` or you're going past the end of `b` (you're indexing both arrays up to `n` but they're different sizes).
Yes, lighting is, to me, a very important component in a game engine. I would love there were more game engines written in C and less in C++. I look forward to having shadows, and wish you the best luck with Permafrost Engine!
I happen to love the Zig language for this reason. It improves on C's error handling and legacy functionality. There are too many features to list here. Zig is the only modern language I know of that has a serious shot at competing with C. Rust is a close runner-up, but it does not cater to as much to low-level programming because it prefers to focus on safety.
Some good ideas but it's too small to have enough people who really think things through. Last time I checked (quite some time ago) I wasn't satisfied with all design decisions. Also I think that nowadays the shifted focus on security like in Rust is good.
Looks like `import_name` just looks up the object in the module, not the class. So after looking in some pages, it looks like it's like that: PyObject *module = PyImport_ImportModule("themoduletheclassisin"); PyObject *class = PyObject_GetAttrString(module, "Lifter"); PyObject *method = PyObject_GetAttrString(class, "lift"); [`PyObject_GetAttrString`](https://docs.python.org/3/c-api/object.html#c.PyObject_GetAttrString) is basically `first.second`. Note that this is untested. You probably need to also increase the reference counts.
&gt; Rust is a close runner-up, but it does not cater to as much to low-level programming because it prefers to focus on safety Inb4 the Rust Evangelism Strike Force finds this comment. ü§£
I found this hack which works somehow. I'd love if someone can improve this further and make it less "hacky" #include &lt;stdio.h&gt; #include &lt;limits.h&gt; int main(void) { int *const jagged[] = { (int []) {0, 1}, (int []) {2, 3, 4} }; for(int i = 0 ; i &lt; 1 ; i++) { int a = 0; while(*((*jagged + i) + a) &gt; SHRT_MIN) { printf("%d \n",*((*jagged + i) + a++)); } } return (0); }
Ikr
The problem is you're using an `if/else if` chain. As a result, since the first `if` succeeds it doesn't bother even checking all the other conditions, and only one denomination is printed. If you use a smaller input number you'll find that only the largest denomination will print, for the same reason. Each of these statements should be an independent `if` statement. As a side note, in general you don't want to be using floating point numbers with money values. It's better to use an integer that stores the total number of the smallest denomination (one cent in this case). You'd use `%` instead of `fmod` to do the calculations.
Thanks for the reply, I'll try to do your suggestion.
I've tried it quite a bit for embedded programming. Honestly, it's too early to say. The language is changing so much still that it's hard to say how 1.0 will end up. But I will say that everything they've been doing so far feels spot on to me. The key here is that it's a true C replacement. Most other languages go too far, adding too many features. The only other language I know that attempts this is C2. The next one that's close to doing this is Rust. But I'd argue Rust is not a true C replacement, because the compiler needs to be too advanced. A C language should be dead simple. A good way to think of it, could you write something like TCC for it? If not, it's not a C replacement. I'm really looking forward to writing more embedded code with it once it matures a bit. I hope the async features work well in embedded. &amp;#x200B;
&gt; could you write something like TCC for it? Question: what would be the necessity of this if you can easily cross compile?
I don't get it, why do so many langues use this weird variable declaration: var y: i32 = 5678; What's wrong with: i32 y = 5678; ?
The colon syntax makes it harder to get along without a special-cased typename token type distinct from a normal identifier type in C‚Äôs case. Makes it easier to handle complex type syntaxes (or expand type syntax later) without getting the name tangled up. Also sticks closer to the usual math type syntax (e.g., (Œªx : T . f x)).
This is my first time seeing Zig. I'm afraid the language is too big (and too well thought-out!) to give a real assessment of. I'll play around with it when I have time, though. I have one nit with integer types. I hate this new trend of making exact-size integers (e.g., i8, u8, i16, u16, ...) and nothing else. There is only one possible scenario where you could need an integer of an exact size, and that's if you need to conform to some binary protocol (e.g., networking protocol, hardware device, protocol). In any other situation, if your code depends on an integer variable being an exact size, your code is fundamentally broken. What most people actually want when they make an i32 (or whatever) is (in C's parlance) `int_fast32_t`. It's a type which is *at least* 32 bits in size, and is the *fastest* integer that is at least that size. On some platforms, that may be 32 bits. On other platforms, it maybe 64 bits. On weirder platforms, it might be 36 bits, or 80 bits. What I'd like to see is something like i32 (`int_fast32_t`), i32le (`int32_t` which makes it clear it's only for serializing to/from little-endian), i32be (similarly). The documentation doesn't seem to cover memory allocation? I'm curious to see how common data structures (e.g., binary trees) are implemented in Zig. Overall it looks super cool, though!
Very cool! How popular is plain C in the game industry? I know C++ is very widely used. Also, could this be used in a C++ project? Sorry for what are probably newb questions.
if the question is "can a C library/project be used in C++" the answer is basically always yes. C++ is the easiest language to interop with C.
I'm sorry, but I'm going to be a bit harsh. That wouldn't be production code. If you want to get a good grade in the class I think /u/boredcircuits has pointed you in the correct direction. If you want to be a good programmer you should look into test driven development. For C I use unity, [http://www.throwtheswitch.org/](http://www.throwtheswitch.org/). Let's look at your code. It's all running in main. You want as little code in main as possible. You have three things going on; getting input, processing the input, and printing the output. Those should be 3 separate functions. &amp;#x200B; When I was in school I spent a lot of time debugging my code. If you use test driven development and split your code into 3+ functions it will make it easy to troubleshoot and add features. &amp;#x200B; In terms of your approach, what happens when the customer or your boss wants to add support for 10,000? Or 100,000? That's a lot of code to change. Is there a more generic algorithm? This is a simpler version of the convert number to text 1235.00 = One Thousand Two Hundred... And shares some similarities with the Roman numeral conversion. &amp;#x200B; Mixing float and int is a recipe for unexpected behavior based on integral promotion. You should keep the scope of your variables as narrow as possible. You have a lot of global variables right now. &amp;#x200B; Feel free to PM me if you want me to code review the next version or assignment. Good luck on your studies.
It makes implementing type inference much cleaner and yields a more consistent grammar for the language.
[http://wiki.c2.com/?TheKenThompsonHack](http://wiki.c2.com/?TheKenThompsonHack)
Why not more dangerous? 
That is a fair comment regarding integer types. There do exist `usize` and `isize` though which are unsigned and signed integers respectively which are both pointer-sized for the target platform (same as `size_t` and `ssize_t`). In my experience this is enough for all cases and I haven't seen any major performance issues just yet from using narrower than optimal types.
Ah, gotcha. Thanks so much for the help!
Sorry to bother you again, but it's still not quite working. [This](https://i.imgur.com/xuo8VPU.png) is what I have now. What have I done wrong? 
You still have the extraneous `struct` keywords on the line you called `malloc()` on. Whenever you have a `typedef` that acts almost like a find replace, and replaces anything on the far right of the statement (in this case the string "ST") with whatever proceeds it (in this case the string "struct sl"). So when you declare `dArr` as type `struct ST**` it's going to get expanded to `struct struct sl**`, which is not what you want.
&gt; This is why one of the reasons I avoid the whole `typedef struct ... Name` idiom. Maybe what I'm about to say is one of your other reasons... but I would suggest that any `struct` type that isn't completely opaque (i.e. manipulated through functions only) probably shouldn't be typedefed at all.
Ohhh I had to remove all of them at once, sorry. Thanks again!
Multiple compilers are a benefit for many reason. Usually they will have different strengths and weaknesses, different licenses, etc
Hey sorry, this isn't my original question but after I applied the new changes to my actual C program and run it, I get a segmentation fault. It compiles fine though. Would you mind taking a look at [my code](https://i.imgur.com/DI72EgN.png)? It prints the line with the long printf statement just before the while loop, then the program seems to crash. I'm reading from binary files and putting the data into structs, then putting struct pointers in a dynamic array so I can sort them later on. Sorry about this, am I using a NULL value somewhere?
It's totally absurd to explicitly initialize every variable, this *hides* errors. But iirc Linus didn't actually promote this but said he liked a compiler extension that initialized variables implicitly to hinder information leakage, which is a totally different thing.
As I mentioned with my other comment, only first class structures will be allocated automatically. If you declare a structure pointer then you'll have to allocate the space. Change up your `ST* foo` line.
So I have to assign values to everything in my struct? I was hoping the read statements would cover that. I may not be understanding what you mean.
They do. But declaring foo as just `ST* foo;` and then writing to foo-&gt;sponge is undefined behavior since you never specified the address of foo. You probably want to allocate the struct in dynamic memory. `ST* foo = malloc(sizeof(*foo));`.
Can you please explain what extra pointer do you mean, i want to learn.
You just need to download the development bit of the opens library, which your distribution's package manager should be able to do for you. Which Linux distribution are you using?
Thanks for the remarkable comment dear good person, I'll make sure not to forget this good advice that can surely help other beginners like me.
It uses [@fieldParentPtr()](https://ziglang.org/documentation/master/#fieldParentPtr), which is identical to the Linux kernel's container_of(), which is explained here: http://radek.io/2012/11/10/magical-container_of-macro/
Check out https://cdecl.org, "the spiral rule", etc.
I disagree. Usually when you declare a variable you have requirements like "this variable must be able to hold numbers between 0 and 2^40" and the only platform independend way to satisfy this requirement is to use a sized type. The *fast*_t variants are often not a good choice because they might not actually be faster because the speed depends on the use case (large arrays and memory bandwidth) and the size is implementation dependend potentially wasting a large amounts of memory.
Yes, I've noticed that function, but i was wondering what actual benefit can you get by using such structure. Is it for memory saving, or does it improve runtime performance? I've read the article that you linked, but unfortunately it only tells you how it works, and not what can you gain from it.
&gt;C is ALMOST a complete subset of C++ This made me chuckle, you always read where C++ is a superset of C. This is like in Dr. Who when everyone says the Tardis is "bigger on the inside" except Clara who claimed it was "smaller on the outside".
What's wrong with C function pointer syntax? char (*foo(int (*a)[10]))[10] vs func foo(a: *int[10]) *char[10] It's a no brainer. 
This looks very interesting!
`current` and `printme` are pointers to the same node. When you advance one, you also advance the other. You are advancing them twice as much as you think.
It's a shitty knockoff of rust with just as bad syntax.
Think about what the following code should output: int head, current; head = 1; current = head; head = 2; printf("%d", current); Should that print 1 or 2 ??
I would recommend https://wiki.osdev.org/Expanded_Main_Page
bitwise
I've been wondering lately, is all system programming done in a Linux environment?
No, Windows has an embedded OS. There is others. &amp;#x200B; [https://en.wikipedia.org/wiki/Windows\_IoT](https://en.wikipedia.org/wiki/Windows_IoT) [https://www.freertos.org/about-RTOS.html](https://www.freertos.org/about-RTOS.html) [https://www.windriver.com/products/vxworks/](https://www.windriver.com/products/vxworks/) [https://blackberry.qnx.com/en](https://blackberry.qnx.com/en) &amp;#x200B;
Would outputting data for consumption by another utility be acceptable? I've often used [Gnuplot](http://gnuplot.info/) for ad-hoc graphing needs.
Any way will be better that I do now (prototype in Matlab and rewrite in C) =) I will check it, thanks!
If you need something more heavy duty, I can also recommend the [pgfplots TeX package](http://pgfplots.sourceforge.net/). Again, this is a case where you'd be feeding in data from your program for use by something else (TeX, in this case, which is a huge topic on its own). For light uses it's definitely a case of cracking a walnut with a sledgehammer, but [the variety and flexibility of its output](http://pgfplots.sourceforge.net/gallery.html) is exceptional.
Take a look at this "c project based tutorials". I am following the System Programing from 0 to 1, and looks like a good book to start https://www.reddit.com/r/C_Programming/comments/872rlt/c_project_based_tutorials/?utm_source=reddit-android
C people try to safe every byte they can. The simple solution is don't. If you really have to use a union rather than random pointer casts. If you see pointer casts other than to `void *` and back be suspicious. The line where your have to raise a mental red-flag was: int32_t *buf = malloc(sizeof(msg)); You have two different pointer types on both sides non of them is void * (actually the right side is void *, but you should better think of it as msg *). And one last thing to throw in here is the restricted keyword in modern C that explicitly hints the compiler to don't care about aliasing. 
You want to avoid wide namespaces. And generally you want to keep things dynamic. But what you are doing can have an influence on that. Max size is generally limited by your available memory, taking paging into account. On a modern x86-64 that's 2^48 addresses.
The size limit for static allocations depends entirely on the host platform. Exceeding it will result in a compile-time (or link-time) error. However, a successful compile still doesn't mean the program will successfully load because the loader could fail to allocate that space. Your example array is excessively large for static arrays and should probably be dynamically allocated. In *practice*, the limit is generally not very big, and if you initialize it with anything other than zero it will greatly blow up the size of your binary. When the array is zero-initialized, the memory is effectively allocated dynamically by the loader (a `.bss` section) when the program is loaded. This allocation could potentially fail, causing your program to fail to load before executing a single line of its own code. 
I look at this, and try something, but have no success. Could you please provide some example for windows? I have exactly this problem: https://superuser.com/q/1335532/919189
&gt; My rule of thumb is that if the arrays size is big enough where writing all of the elements out directly in the code is to much work. That is the point where I make it dynamically allocated Static allocation like that is generally frowned upon because it leads to brittle designs that are expensive to go back and extend later when someone inevitability wants more than _X_ widgets.
Yes I agree completely, however there are times where dynamic arrays are simply not needed and you don't want to pay for the cost of dynamic allocation. The best example I can think of right now is in a 2D renderer. Sprites have 4 vertices and 6 indecies. And while the vertex data could change and should be dynamic, the index data will always be ```{ 0, 1, 2, 2, 3, 0 }``` (to make the rectangle out of two triangles) and so you can make a const unsigned int array and statically initialize those values directly in the code.
It's also interesting to note, that while in C type-punning through unions is allowed, in C++ it doesn't make sense (https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-and-undefined-behavior). Another reason why C++ is no superset of C :-)
LLVM
When reading a number with scanf you don't need the space in the format string
oh, my bad. didn't see that one. thanks.
If I'm understanding this right (big if), I can tell you that I've seen "fancy pointer syndrome" cause seg faults when code gets ported over to embedded platforms and the compiler can't *quite* catch that multiple layers of casts and re-casts might end up with byte alignment issues. It could be a runtime error that you won't see until your code has been off in production for a while and goes through just the right memory contortions, and it might disappear when inside the debugger, etc. etc. Insomuch as there's a rule, it's that "with great power comes great responsibility." We tend get a little lazy and assume the compiler will always save us from ourselves when it comes to type-casting, but it has its limitations. So just try to keep things simple and you should be OK. If you never write code running outside of an x86 environment, you'll probably be OK too. I hope that's at least a little helpful and on somewhat of the right track....
Objects are formally bounded (w.r.t. maximal indices and underlying sizes) by the characteristics of type `size_t`, which has upper limit `SIZE_MAX`. That‚Äôs the largest object the compiler can theoretically ‚Äúconsider,‚Äù although it may be the case that you can never *actually* allocate that much memory (e.g., a lot of systems won‚Äôt let you allocate more than half the address space at once), or that you could allocate more memory than that via non-C-standard mechanisms (e.g., a memory map syscall). I‚Äôd generally stick with ‚â§32K for a statically allocated array on a normal 32+-bit system, and that‚Äôd be for things like pregenerated LUTs. Anything more than that, and you get into the range where you probably want to dynamically allocate. E.g., `calloc` might preallocate the pages so you don‚Äôt end up with a ton of page faults when you fill it, or `mmap` would let you set sharing and access options. Potentially-really-large stuff also tends to be more useful as a run-time parameter, at least with stuff I‚Äôve ever dealt with‚Äîyou don‚Äôt want to have to recompile every time you come up with a differently-sized data set.
&gt; On a modern x86-64 that‚Äôs 248 addresses. Per-process, right? Since it‚Äôs virtual memory? 
Right, I was just trying to make a quick visual point. But you would then have to go initialize all that memory
https://www.edx.org/professional-certificate/dartmouth-imtx-c-programming-with-linux You have the option to audit (take for free) the individual courses that make up the series. https://www.class-central.com/course/coursera-introduction-to-embedded-systems-software-and-development-environments-8458 https://www.udacity.com/course/advanced-operating-systems--ud189 https://www.udacity.com/course/introduction-to-operating-systems--ud923 https://www.udacity.com/course/gt-refresher-advanced-os--ud098 https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/ 
To elaborate on why this is causing your issue: scanf will continue matching whitespace with the space character in the format until it finds a non-whitespace character. When you press enter it happily consumes the newline as a whitespace, and keeps waiting for more.
Give it a go, then show us what you tried and we'll help you fix it.
Yes, the top answer is substantially wrong. It's a great example of the phenomenon on sites that allow user voting of answers (*cough*), something is well formatted and has upvotes so the reader assumes it is correct and then, presumably, goes "oh, this is correct I'll upvote it!" I've previously downvoted it but what else can you do? The answer by Shafik Yaghmour is good (his answers are almost always excellent). The first example in the top answer: whether it's correct or not actually depends on implementation-defined properties. The code accesses an `unsigned int` as a `uint32_t`. However, on common systems, `uint32_t` is a typedef for `unsigned int`. On those systems the code is correct. On other systems the code violates the strict aliasing rule The answer doesn't actually mention this problem *at all* (it's discussed in comments). Maybe the author's angle was that it should be assumed the code is undefined because it's undefined on some systems. But the text explanation seems to take the position that `Msg *msg = (Msg*)buff;` leads to a problem because `buff` had type `uint32_t *`. However that is no problem; the rule strictly (no pun intended) refers to the effective type of memory being accessed; intermediate pointer types have no bearing whatsoever. I suspect some readers might take this misunderstanding away from reading it, even if the author didn't. ---- The suggestion of using a `union` is correct. It was worded poorly in standards prior to C11, but the intent was always that union aliasing circumvents the strict aliasing rule. There are other SO questions on this topic. 
Thank you for pointing out shafiks answer he seems to write very thorougly and understandable.
As long as you dont access the allocated memory it has no type, so whatever type buff is on the left side doesnt matter. It is confusing though.
 while(4 == fscanf(fp, "%lf, %lf, %lf, %lf\n", &amp;d.xvalue, &amp;d.yvalue, &amp;d.uvalue, &amp;d.vvalue)) { if (total + 1 == buf_size) { buf_size = buf_size * 2; dataset = realloc(dataset,buf_size * sizeof(flow_data)); if (dataset == NULL) { printf("error allocating memory!\n"); exit(EXIT_FAILURE); } } dataset[total] = d; if (d.xvalue &gt;= 20) { total++; } } dataset = realloc(dataset,total * sizeof(flow_data)); // &lt;-- why is this here.
In the first code sample do you use `%f` to read a `double`? That would be incorrect
Found this https://www.reddit.com/r/cpp_questions/comments/6xsdfx/what_does_this_error_message_mean_undefined_ref/
Couldn't you just use a bit shift and the binary and operator to get this in one loop.
No. Macros and pre-processor directives are handled before the compiler even sees the code. It should be impossible for a C compiler to even know that printf was ever written. (In reality, these days, the preprocessor and compiler are usually pretty tightly coupled, and many compilers will include information about macros as debugging information, but that shouldn't affect any behaviour of the compiled code)
Macros are handled by the preprocessor. If you aren't recompiling the library, it won't make a difference. More info here: https://stackoverflow.com/questions/17349387/scope-of-macros-in-c
Uhm, the windows.h file from minGW only includes declarations. The implementation comes from respective .dll files -- and these minGW does not try to reimplement, afaik.
Ah I see, it does come with all it's own .dlls though, and therefore it's own winmm, user32, et al, but probably more realistic that thay're just renamed/rebuilt to conform to GCC's format. When something similar happened to me, the function that worked, and the one that didn't were both contained in the same .dll which has left me with the suspicion that minGW still has real gaps. 
&gt; I am currently attemping to compile a program I have been given in windows. I want to compile this program for windows. But i don't know what to change in order for this to happen.
If you #include after #define and the macro is used somewhere in the header files of your library, there is a chance that it might make the interfaces of your library's classes/functions differ from the actual definitions in the respective .so files. This is very unlikely as most of the macros that can change function signatures/class interfaces (if used, which is by itself even more unlikely) are system- or standard-specific macros (e.g. __cplusplus or _WIN32), so defining your own macros should (almost) never change anything (important) in your library header files (source/.so files are always unaffected!). My tipp to avoid such things completely: always #include everything library-specific before making any #defines. I prefer this order/grouping (top to bottom): * standard library headers * external library headers * current project headers
Your while statement executes untill end of file is encountered. You need to switch that out and instead check for newline (\\n). How you do that can be an exercise for the reader. (:
Never use `while (!feof`. You want to read until you can read no more, not until feof condition is set.
You could do: int c; while ( EOF != (c = fgetc(filePointer)) &amp;&amp; c != '\n' ) putchar(c); Also you should check whether `fopen` succeeded before doing this
Don't use [Yoda conditionals](https://en.wikipedia.org/wiki/Yoda_conditions). They offer no benefit whatsoever and make your code harder to read.
Here is the shortest definition I can think of: Aliasing is when a memory address is reachable by multiple pointers. No this is why it can break your code: The C compiler my assume that a memory location is not aliased. void double(int a[], size_t len_a, int b[], size_t len_b) { for (int i = 0; i &lt; len_a; ++i) { a[i] *= 2; } for (int i = 0; i &lt; len_b; ++i) { b[i] *= 2; } } What happens here when the compiler does heavy optimization and the pointer refer to overlapping memory is: int arr[] = {1, 2, 3, 4, 5}; double(arr, arr+2); What we may get is {2, 4, 6, 8, 10} but what we expect is {2, 4, 12, 16, 20}. What happens is that the compiler preloads the memory locations. These are therefore cached. In the first loop everything works perfectly fine, but in the second loop the compiler does not fetch the memory and reads the preloaded values. Then the latter fields in the array are overwritten with the same values again. 
&gt; reducing risk of typoes How so?
1. is addressed in C usually by typedefing any type that may change so that there is only one point to edit. Other languages should prefer typing by interface which provides a similar function. Type inference is unnecessary for this. 2. I think (and I am sure many agree) features which tie users to an IDE to be usable are a bad idea.
Well, reducing the impact of typos rather than the risk of them happening. If you have a constant on the lhs of an assignment the compiler will barf, e.g. if you accidentally do `if (NULL = p)` instead of `if (NULL == p)` the code won't compile. However if you make the same mistake the other way around, `if (p = NULL)` the code will compile but not do what you want it to. These days a lot of compilers will warn you about this with the right flags though so there's some discussion about the value of using this approach.
&gt; These days a lot of compilers will warn you about this I was just about to say this. Everybody everywhere should always enable all the warnings the compiler is able to emit and then it's not really a problem.
&gt; reducing risk of typoes Moot with modern compilers. &gt; easy to read If I ask you to compute the sum of two numbers, would you answer ‚Äúfour is made by two plus two‚Äù or ‚Äútwo plus two make four‚Äù?
I think it only ships with some `.lib.a` files which are statically linked and just replacements for Windows' `.lib` files which are also statically linked. AFAIK those then actually do the indirect loading of the actual symbols through `.dll`s -- but the WinAPI is completely weird and nothing I actually want to touch ;) Mostly MinGW should thus though be able just reuse MS' code, they cannot actually even re-implement the Win32 API since they do not know and cannot execute the actual syscalls needed.
1. A-priori it may not be obvious which types may change in the future. Erring on the side of few typedefs leads to more refactoring trouble (not helped by the presence of implicit conversions), whereas erring on the other side, using excessive typedefs leads to a lack of clarity IMO. 2. Would you saying using a REPL (which typically comes with the compiler) is also a bad idea? If you load your module into a REPL, you can inspect types there too, IDE not needed. You could write a small daemon to reload the module in the REPL on saving the file. W.r.t tying users to an IDE, I understand your sentiment. However, I would also like to know -- how do you typically change the name of a function throughout your code? (1) use rename-all-occurrences in your editor/IDE of choice or (2) use sed or some similar tool (3) something else? If you're doing (2) or (3), do you think it is practical for relatively large codebases (say 20k+ SLOC or even 100k+ SLOC)?
Some other benefits of type inference: 3. Using lambdas is much more convenient in the presence of inference. Using higher-order functions is much more convenient if writing lambdas is convenient. For example (in Typescript-like syntax): let ok = baskets.iter().all(b =&gt; b.apples == 1 &amp;&amp; b.oranges == 2) Of course, if you say "I'm doing just fine without higher-order functions/lambdas", then this point may not seem useful to you. (I don't think Zig has lambdas but they are under discussion [here](https://github.com/ziglang/zig/issues/1048)).
Yes I did analize it but I'm still not sure how to use it
Use `avrshock2_poll(&amp;buttons, axis)` to poll for a controller input. Each button / control stick will return a specific code (look in the header or just experiment, printing each input out to stdout). Use the return code to decide on what to do. The library is pretty shitty with no documentation, so you're going to have to dig into the source to figure out how to actually set things up. I'd recommend looking for something more well documented.
I'd just like to interject for a moment. What you're referring to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX. Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called "Linux", and many of its users are not aware that it is basically the GNU system, developed by the GNU Project. There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called "Linux" distributions are really distributions of GNU/Linux. 
Thanks for the explanation! I guess I just always assumed x86_64 used 64 bits for addressing, but now I remember that `/proc/cpuinfo` shows 48 bits. The dots have been connected!
The concept is not difficult enough to warrant a full book. Perhaps try an introduction to data structures. Is there anything in particular about them you have trouble with? 
Linked list is a very simple concept, don't worry too much about it. This page should suffice, but if you're having problem with something specific just say so https://www.learn-c.org/en/Linked_lists
This is a treasure https://www.ossblog.org/learn-c-programming-with-9-excellent-open-source-books/
&gt; `(void *)0 + thread_count` Pointer arithmetic isn't allowed on void pointers. What's the size of the object being pointed to? GCC, as an *extension*, makes it work like `char *`, but it should be avoided. Second, creating a null pointer and then doing arithmetic on it is undefined behavior. So don't do that either. Instead just cast the integer directly to a pointer: `(void *)thread_count`. If you want to be super strict then `thread_count` should be an `intptr_t`, which is specifically designed for this sort of casting. Overall the way you're "gathering" the results is uninteresting and non-deterministic. There's an implicit lock on the `FILE *` stream, so calling `printf` like that is *safe* but the outputs are interleaved in essentially a random, unpredictable order. What would be more interesting is to either have each thread write its result into a designated element in an array, or to have it return its result, to be printed by the caller of `thread_join()` as it joins each thread. Either way the output will be deterministic and clean despite the use of threads. 
Assuming you're not just looking for the basics of a linked list, https://kernelnewbies.org/FAQ/LinkedLists is a good introduction to how you could implement them. The kernel defines a list inside of its elements, rather than the elements being inside of the list. It's a weird paradigm to get used to, but it is way more generic since you can make a linked list of any type simply by adding a struct list_head to its members.
There are lot of resources posted here: [https://www.quora.com/What-are-the-best-books-to-learn-algorithms-and-data-structures-Are-there-any-good-blogs-posts-on-these-Which-books-explain-these-concepts-in-a-simpler-way](https://www.quora.com/What-are-the-best-books-to-learn-algorithms-and-data-structures-Are-there-any-good-blogs-posts-on-these-Which-books-explain-these-concepts-in-a-simpler-way)
Can you give an example? I can't get it shorter than: void dectobin(int n) { int bin[32], i = 0; do bin[i++] = n%2; while((n = n &gt;&gt; 1) &gt; 0); for(--i ; i &gt;= 0 ; i--) printf("%i", bin[i]); } 
A bit OT: 1. `void main()` is probably illegal as an entry-point, the standard only defines `int main(void)` and `int main(int argc, char *argv[])` -- your implementation of C might define extra entry-points, but usually this is wrong. 2. `UPPER_CASE` is usually used for constants only, not for `typedef`s 3. You don't need, perhaps even should, cast the return value of `malloc()` in C. 4. Instead of repeating the type in the argument to `sizeof` in `malloc`, it's good style to use the variable instead, ie. `head = malloc(sizeof (*head));`, that way you can change the type and the code will still work fine. 5. Please check for the return value of `scanf()` and `malloc()`! 7. I do not like the `if-first-else` part in the loop, can't this reworked into an initialization outside of the loop? While you're at it, how do you tell apart an "empty" list with no members from one that doesn't exist? I think you cannot create an empty list with the structure right now. A common idiom is to always have a dummy element that contains no value and is at the end of the list, this makes many operations easier. 8. You write `NODE *temp = 0` and later also `first = 0` or `first != 0`. These are all pointers, use `NULL` instead. Also the initalization of `temp` is unneeded and might even hide errors. 9. Why is there a space before "status of the list"? 10. You `malloc()` quite some memory, but never free it.
Look at glib (part of gtk) and its glist and gslist structures and functions, for a real world example that it used all over.
And `fflush(stdin)` is right out.
ok first thanks for your input !! How can i pass multiple arguments to pthread\_create ? If all the threads access different index of a same array does i need mutex ? How can i compute all the value of the fibonacci suite on 8 thread ? I'm working on a fractal explorer and i want to multi-thread the compute of each pixel.
True, I wondered about it but forgot to include it. It doesn't even make sense to flush *anything there* I'd say
&gt; How can i pass multiple arguments to pthread_create ? Create a struct with all the values you want to pass and pass a pointer to an instance of one. struct arg { int index; int *outputs; }; int outputs[N]; struct arg args[N]; for (int i = 0; i &lt; thread_count; i++) { args[i].index = i; args[i].output = outputs; pthread_create(toby + i, 0, compute, args + i); } But be very careful about scope: // BAD! Variable potentially out of scope before thread accesses. for (int i = 0; i &lt; thread_count; i++) { struct arg arg = {i, outputs}; pthread_create(toby + i, 0, compute, &amp;arg); } &gt; If all the threads access different index of a same array does i need &gt; mutex ? In *practice*, with `int` elements, this will work fine. Technically speaking you're required to protect the array with a mutex lock, *even though* no thread accesses the same element. Why? I don't know how to prove it from any specification, but I can give an example of why this is so: the [Alpha AXP's smallest-addressable memory is aligned 32-bit words](https://blogs.msdn.microsoft.com/oldnewthing/20170814-00/?p=96806). To read values smaller than a word, the compiler has to generate code to read the aligned word that contains that value then extract the relevant bytes. To write small values, it has to read the containing aligned word, modify the relevant bytes, then write an entire word back. This means on the Alpha AXP, arrays with elements smaller than 32 bits cannot be safely written by different threads. Imagine an architecture that's like this but limited to 64-bit reads, then your program wouldn't work correctly. &gt; How can i compute all the value of the fibonacci suite on 8 thread ? I don't know what you mean. Your Fibonacci algorithm is actually extremely inefficient because it's computing the same values again and again. I didn't comment on this since I figured your real purpose was to practice using pthreads. If done right, you can compute the first 46 elements of the Fibonacci sequence in less than a *microsecond* on a single thread. Beyond 46 will require a larger integer. &gt; I'm working on a fractal explorer and i want to multi-thread the &gt; compute of each pixel. Sounds like a cool project and you're off to the right start. However, you shouldn't create one thread per pixel. Instead you should create a work queue. Make one thread per core, then have the main thread add one new job per pixel, with the threads drawing jobs from the queue and writing their results into your image array. You'll have to learn about mutex locks and such to make your own work queue, but at its core it's not terrible difficult. If you need some material to work from I recommend this free book: [The Little Book of Semaphores](http://greenteapress.com/wp/semaphores/). 
Tuples would be a great addition to the C standard, it would make those things clearer and less debatable. In languages with tuple values it's way obvious that a behavior similar to a static array is better for those cases.
Blame bad C books.
‚ÄòAlgorithm development and Program Design Using C‚Äô by Gary Bronson. One of the most thorough books I‚Äôve ever read.
You haven't given us nearly enough information to answer the question. Maybe you need BFS, maybe you need DFS, maybe any traversal algorithm will do. But more importantly, this is not a C question.
Sorry, I tried to keep it as simple as possible thinking it would be enough, but because I don‚Äôt really know what you need to know to decide which algorithm to use I guess I removed some needed information. In the exercise if possible you have to ‚Äúremove‚Äù (just print out) edges to make number of edges coming from each node even including 0. (Its actually shorter this way :) ) I am asking this question in this subreddit because I want to solve it in C and avoid getting answers in other languages. 
Hackerrank.com has solved examples in multiple languages including ‚ÄòC‚Äô.
Thank you that worked!
As far as books go, [this one is good](https://www.amazon.co.uk/Mastering-Algorithms-C-Kyle-Loudon/dp/1565924533). It covers linked lists and all the variants (doubly linked lists, circular...) alongside their Big O assessment, including examples of where you'd use these data structures as well as full, working code examples in C. It covers much more than linked lists though. Pretty much all the major data structures and well-known computing algorithms are explained too.
No language-specific libraries. Start with the easy stuff, like code to read input and construct the graph, then sketch out your algorithm in pseudo-code and try to translate it to C. Show us what you have and we'll help you fix it.
Here's how *not* to do it: int ll_avg(node* l){ int n,s; for(n=1,s=0;s+=l-&gt;val,l=l-&gt;next;n++); return s/n; }
&gt; ` status = pthread_create (&amp;toby[thread_count], NULL, compute, (void *)0 + thread_count);` Why don‚Äôt you check the status here?
oups, i thought about it and forgot it &gt;&lt; . I've made a edit.
Do it K&amp;R-style: avg(l) node *l; { n = 0, s = 0; while (l) ++n, s+= l-&gt;val, l = l-&gt;next; return (s / n); }
Is that the one most developers use nowadays?
Afaik it's used a lot, yes. 
curl?
&gt;Moot with modern compilers. No it isn't. And some setups don't use modern compilers. &gt; If I ask you to compute the sum of two numbers, would you answer ‚Äúfour is made by two plus two‚Äù or ‚Äútwo plus two make four‚Äù? Straw man 
ah good! thanks!
this is command line interface?
Yes, and the reason for this is to reduce the number of memory look ups needed when a TLB miss occurs. Since systems that have access to more than 2^48 bytes of memory are few and far between, this was an acceptable trade off.
Of course.
Use the "Elephant at Cairo" pattern, it's much easier / less error prone. ie. If you want to find an elephant in Africa, the above code must start in Cape Town, check to see whether it's reached Cairo, if not, check to see if there is an elephant there, if not, take a step north and repeat. It's much easier and simpler and faster to first put an elephant in Cairo, then starting in Cape Town, check for an elephant, if not step north and repeat. 
I try to only use dependencies other people can install from their package managers. Then I distribute my source code with a makefile and some commentary as to what dependencies to install. If the dependency are in weird places, the user might have to change some flags to compile successfully.
This is the model I've been following, and it works reasonably well as long as someone building doesn't have an old frozen linux distro. Maybe I should keep doing that :'D
Depends greatly on your application and what libraries you're trying to use, but if you can get away with it, the cleanest way (IMO) is to use source-only libs, without other dependencies. I'm not certain if that's the correct term for it, but I consider SQLite to be a source-only lib, meaning, you can't link to it, you simply include the source file into your project's source, and compile it into your application. I think you'd be hard pressed to find a lot of libs like that, but when I can get away with it, I go with that.
Ah yeah, that's kinda what I've experimented with using git submodules as dependencies. &amp;#x200B; It works pretty well, but the overhead of adding a library is kinda high (making sure the dependencies build system works with yours etc).
If you keep your dependencies conservative, even old-ass Linux distributions should work.
&gt; source-only libs If you do this, please provide an option to unbundle the library and link against the system's copy in your configure script. Copying the source of a library into your project is a nightmare for any package maintainer. No distribution wants to have 21485 different versions of SQLite spread across its packages, just because it is more convenient to ship your own copy.
Do you have any tips on keeping dependencies conservative? Only use popular libraries etc? &amp;#x200B;
Only use popular and stable libraries. Take a library version from five years ago and develop against that so you don't accidentally use new features. As a rule of thumb, if the library has been in the repository of a bunch of popular Linux distributions for five years or so it's common enough to be a non-issue.
Thanks!
It‚Äôs a MS extension to C. See the example on this [page.](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=vs-2017)
Postman gives you so much more than curl. The GUI, obviously, but also remembers your requests and allows you to group them. I am a very basic user, but I don't see why you'd use curl if you have access to more than a command line.
you can easily read one line with fgets &amp;#x200B; **fgets**() reads in at most one less than *size* characters from *stream* and stores them into the buffer pointed to by *s*. Reading stops after an **EOF** or a newline. If a newline is read, it is stored into the buffer. A terminating null byte (aq\\0aq) is stored after the last character in the buffer. 
Good point!
Alternatively, if they're ordered, you take the value of the last minus the value of the first and divide by the time it takes to reach the end.... which is likely just the number of elements. But that's just if you want to be funky and treat your linked list like some kind of force
Thank you, I will try :)
Thanks! Looks great :)
You can watch MyCodeSchool videos on Youtube. They are very good made by famous HumbelFool.
Well if all you're doing is printing the int in bits then couldn't you use something like this: void DecToBin(int decNum) { for(int i =0; i &lt; (sizeof(int) * 8); i++) { printf("%d", (decNum &amp; (1 &lt;&lt; i)) &gt;&gt; i); } } Of course you'll still have to account for the endianness of the cpu you're using.
Oh no, can't MS shut the fuck up and implement C and not some weird Frankenstein language? They even say one *must* call it before reading input or similar, but I do not find a reason for that. If that'd be true, OP would need to call it before the other scanf() too... .
No, this doesn't work.
In the documentation it says: &gt; If the stream was opened in read mode, or if the stream has no buffer, the call to fflush has no effect, and any buffer is retained. Where did you find this: &gt; They even say one must call it before reading input or similar 
I use rust for all my native programming needs and have played around with Zig. /u/isaac92 is 100% right. Also guys, please stop propagating this "Rust Evangelism Strike Force" thing, it doesn't exist.
I did expect no less... 
You can save your requests in a text file, essentially the same thing. I think it's the same thinking in why someone would choose Vim over a fully featured IDE
Practically speaking, Zig does not require you use the type most of the time. That acts more or less like an explicit cast. So code will generally look like this: \`\`\` var i = 0; \`\`\` Or this: \`\`\` var i: i32 = undefined; \`\`\` I like that mutability is a required keyword (\`var\` vs. \`const\`), but type is deduced.
IDK how true this is now that LLVM exists. If LLVM gets more backend support, this point might become moot.
Both use LLVM IR and draw inspiration from it (not the integer type syntax). I do not believe Zig is much like Rust at all.
Ah I see, thanks for this example. The original Code prints the bits in correct order. Yours in reverse. That's why we need the 2nd loop.
This has nothing to do with the C programming language. Find a homework help sub
Yes. Even B had `auto`. It's the keyword to indicate a variable in automatic storage.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
ok sorry, thanks for redirecting me
Is this going to be finished? There are still todos in there.
This subreddit is about the C programming language not C++. Try /r/cpp instead To answer though, in general the only reason you would do it the old way would be if you couldn‚Äôt use a newer version for some reason. Some projects require specific compiler versions which may not support the newer features of the updated standard. If you can use a compiler that supports the new features you should use them.
Wrong sub: we talk about C here, not C++. /r/cpp and /r/cpp_questions are what you're looking for. To answer your question though ... yes, the "old ways" are still useful to know, but focus on learning the "new ways" first. The most important reason is because there's a lot of old code out there -- probably billions of lines of code that uses these old methods. You have to be able to read, maintain, and interface with this code. Likewise, if you want to interface with C code you'll find yourself using the old methods as well. It's also important to note that very few things have actually been deprecated (much less actually removed) in modern C++. That's because the old techniques are still perfectly valid, and are even more useful in specific situations, especially in resource-constrained environments. But the first tool you should look to in the majority of situations are the things introduced in modern C++ versions. They're safer, more general, easier to use, etc. So learning the new ways should be your priority.
Sorry for the absence, I've been busy. So right now I'm trying to open a file for mode read and here is what i have: \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; \#include "C:\\Users\\pauls\\Desktop\\CS 122\\Programming Assignment 1\\FitbitData.csv" &amp;#x200B; &amp;#x200B; typedef struct fitbit { char patient\[10\]; char minute\[9\]; double calories; double distance; unsigned int floors; unsigned int heartRate; unsigned int steps; }; &amp;#x200B; &amp;#x200B; int main() { FILE \*FitbitData = fopen("FitbitData.csv", "r"); getchar(); return 0; } &amp;#x200B; The csv file that i'm using has the columns listed in the struct as well as 1440 rows which are the minutes in a 24 hour period. I know that somehow I'm supposed to incorporate an array in there somehow, but i am kinda lost as of now.
A good book is never "finished". Merely published.
I had to look it up as I've never come across it. Guess I know why now. This SO answer is hilarious :D https://stackoverflow.com/a/2192761
Are you sure there's no whitespace characters lurking at the end of your token? What do you see if your change your debug line to: printf("\nwait or later '%s'\n", waitorlater);
Is headnode some special OS setting or something? I don't see you initializing/declaring it in your program.
Greate!!!!
What output *do* you get?
If that's the only condition left, why check for the token at all? Just change it to an else and move on.
Can you explain what you do understand about loops?
What's the problem you're [trying to solve](http://xyproblem.info)? An array - whether a member of a structure or not - is a list of objects all of which have the same type.
It has nothing to do with the variable being static. The order of evaluation of parameters to a function is undefined. `9 10 9` is just as valid as anything else.
Your code modifies `i` while also referencing it multiple times between sequence points. This is undefined behaviour and there is no way to tell what your code is supposed to do. Please don't program like that.
Thank you.
If I understood your question correctly, the answer is no. You're trying to set a variable (the fact that it is a structure member isn't very relevant) to more than one type. In C this isn't possible since the syntax doesn't allow it, the main reason being that each type has a specific size in memory. This is also true for arrays: each time you create one, you must not only state its size (or immediately fill it) but also the type of its elements, one and only one. With structs it's the same, since you need to reserve enough space for all adjacent members in a single memory location. And yes, different structs can be members of other structs. If you need to allow that member to be one of a possible set of types then what you need is a union. It works like a struct, but you can set it only once, when you initialize it. When you initialize one of its members you actually set the whole thing to be of one of the possible types, and then you use it as such. The way this works is by reserving enough memory space to account for the largest type that you include. And after all, technically speaking what you say isn't impossible: things like that with variables and arrays can be done with pointers, type casting and memcpy, for example. The problem is that if you don't know exactly what you're doing/which machine(s) it'll run on you will almost certainly end up with illegal memory accesses or corruption, and a not portable code.
Unspecified, not undefined.
Meta: please indent everything by four spaces to format it as code: int main(void) { static int i = 10; printf("%d %d %d",i,i--,i); return 0; }
The bootstrap compiler is made in C++ and it uses LLVM on the backend, which is primarily targeted towards C++
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Tip #1: post in the correct subreddit. :) This sub is for C-programming, for C++ there's r/cpp and r/cpp_questions. Then there's also r/learnprogramming with &gt; 600.000 subscribers.
https://isocpp.org/get-started And you'll want this forum to start: https://www.reddit.com/r/cpp/ There are kind of 3 ways to pick up C++... 1. Pretend it's just C, learn the procedural basics, start adding on objects 2. Start with basic C++, learn OO initially and let the procedural aspects come just because, and then move onto modern C++ 3. Start with the latest and greatest version of C++ and all of it's fancy features Approach 2 is probably the best way. Approach 1 can get you to the end, but the switch to OO might prove a bit of a challenge because you need to rethink how you've trained yourself to do things. Approach 3 is fine and lets you look down on others with disgust for not doing things the modern way, but I can almost guarantee that your class won't be doing that style of C++, so learning the latest and greatest later will be fine in your case. C++ isn't so bad to learn, it just is generally taught poorly. Just go slow and write a bunch of practice programs to see how the mechanics interact and you'll be fine. Also, HTML is easy, but the CSS and JS and whatever else people add these days to make HTML pages pretty gets a bit trickier. It wouldn't be terrible to learn how to do it on your own on the side though because it gives you an easy to use front end to output data from your C++ (as in, your program can output HTML and you get pretty output in a web browser... if that makes sense. If it doesn't, ignore this paragraph).
Thanks, didn't realize that this was a C language subreddit only.
Try to avoid code smell and use pointer to pointer https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a
The languages are different enough at this point that they can't really be compared
Your code section is formatted incorrectly. For a block of code you start each line with four spaces. No need to enclose it in backticks. Thos are for when you want to include a bit of code in-line like `this`.
It's automatically done, i shall try to reformat &amp;#x200B;
I'm not sure if I want to open this Pandora's box by adding exceptions to C.
Neat.
I don't know precisely what you want to accomplish, but you almost certainly want an array of structs. struct example person[1000]; for (size_t i = 0; i &lt; sizeof person / sizeof *person; i++) { // do something with person[i].age }
Create and populate an array of example structs and use a for loop. 
Wouldn‚Äôt it print something like: a1b2c3 instead(or of any order)? Because if you call a(), it prints *a* and then returns 1, which then gets printed in main, isn‚Äôt it?
No, a, b and c are called (in any order). But 1, 2, 3 are passed in printf in that order. a() c() b() printf("%d%d%d",1,2,3);
I‚Äôm not getting it. a() b() c() are called in random order, and upon being called, it would execute the function and return the value. So upon a() being called, it would print *a* and then return 1, which goes into one of the placeholders in main, isn‚Äôt it?
&gt; it would print a and then return 1 Yes. But printf isn't called until after a,b and c have been called.
Well by list I meant array, apologies for the phrasing. And for the for-each, you could just use a normal for loop &amp; iterate like that. 
C is very simple to learn but hard to do fast
And how would he do that?
Then don't use it?
Since you are not in a subreddit for one particular programming language and not in a general programming subreddit, your code should work *in that language*. 
This *does* look rather well thought-through, also I'm not quite sure whether I want it in C. Interesting though, indeed.
The annual International Obfuscated C Code Contest 1990's "Best Small Program": v,i,j,k,l,s,a[99]; main() { for(scanf("%d,&amp;s);*a-s;v=a[j*=v]-a[i],k=i&gt;!j)," #Q"[l^v?(l^j)&amp;1:2])&amp;&amp;++l||a[i]=s*k&amp;&amp;++a[--i]) ; } This program, written by Doron Osovlanski and Baruch Nissenbaum, prints all solutions to the Eight Queens problem (the problem of placing eight queens on a chessboard in such a way that no queen attacks any other queen). In fact, it works for any number of queens between four and 99. For more winning programs, visit [www.ioccc.org](https://www.ioccc.org/), the contest's website. *-from "C Programming: A modern Approach" by. K.N. King* &amp;#x200B; `v,i,j,k,l,s,a[99];` `main()` `{` `for(scanf("%d,&amp;s);*a-s;v=a[j*=v]-a[i],k=i&gt;!j)," #Q"[l^v?(l^j)&amp;1:2])&amp;&amp;++l||a[i]=s*k&amp;&amp;++a[--i])` `;` `}`
Just awesome! 
You have two choices basically: use an array of struct (seems the simplest in your case), or link those structs in a linked list and iterate over it.
I think you might want to have a look at "Type Punning" 
Really nice projects.
I am not familiar with that specific code, but it sounds like something the Linux kernel also has. The Linux version isn't optimized for entry-level readability, but for generally and speed. In other words, this isn't good code to learn from if you're still learning about lists, queues, etc. :-) As others have said, writing your own can help tremendously with learning. There are, likely literally, hundreds of resources for learning linked lists (even ones without pointers - just array indexes). 
Could you elaborate? What do you mean with ‚Äúgenerate music from specified frequencies?‚Äù
Meaning if I was to specify a certain frequency a music note will be played
Hm, I see. Note that frequency alone isn't really sufficient to generate a nice sounding note. You also need some [envelope parameters](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope) and a basic wave-form to make the instrument sound well. Though for simple purposes it might suffice to simply evaluate sample = sin((2 * M_PI) * t * f); at points in time `t` for the desired frequency `f` to generate samples. You can then send these samples to the speaker using a platform-specific API. It's not that hard, I have done it before. If this does not perform well enough, use a lookup-table for the samples.
Yes, *main is usually a function;* the compiler even warns you when it is not! I'm not sure how to interpret your instructions. Could you elaborate?
im suppose to change the program above into a function.
Well, it already is a function, so you are done.
The calculation of the cylinder volume is a good candidate to move into its own function since it's reusable.
how would i do that?
i gotta make it somthing like this Return_type function_name (arguments list) { Body of function; } 
It already is. The return type is `int`, the function name is `main`, the arguments list is empty (could also be `void`) and the body is your code.
Freaking awesome man !!!!! Keep it up, I hope I do the same thing üòÇ
Everything you said is incorrect.
You have rows and columns mixed up. Your array has 50 rows, each of 5 columns : M a t t h e w \0 
just found the old programs and shared for fun, I think you can do much better :)!
Declare it (i.e., tell the compiler it exists; also called ‚Äúprototyping‚Äù) up top like static double calc_cylinder_volume(double radius, double height); `static` because nothing outside this file needs to see it; `double` is the return type; and it takes two parameters. At the bottom, define it (i.e., tell the compiler what the ‚Äúvalue‚Äù of the function is/what it does): static double calc_cylinder_volume(double radius, double height) { return M_PI * radius * radius * height; } Note that `M_PI` is provided by `math.h`, so you don‚Äôt need to define it. (`M_PI` is given at the maximum precision that can be handled by a `long double`, so stick with it unless you have a good reason to do otherwise. Also the Greek letter œÄ is spelled ‚Äúpi‚Äù unlike the tasty dessert which has the E on the end.)
The CPU has a physical address space, usually with a 32‚Äì48-bit bus that dictates the maximum amount of RAM and MMIO space that can be used at any one time. Typically, all of the system memory and most devices‚Äô registers and buffers (including video memory) are given physical addresses at boot time. In Linux, `sudo cat /proc/iomem` (assuming you can be root) will show you where things are mapped physically. Most CPUs also provide a virtual mapping mechanism, which allows the OS to establish a pretend mapping, sometimes with a different address size than the bus‚Äîe.g., Pentium Pros could map a 32-bit virtual address space onto a 36-bit physical address space, and modern x86-64 chips have a 48-bit virtual address space that can be extended to 64-bit, usually with a 36‚Äì40-bit physical address space. A running process will only see the mappings provided by the OS. Typically, the OS will leave a few pages (‚Üêvirtual mapping granularity) of addresses starting at 0 unmapped so `NULL` accesses fault properly, and then there‚Äôs code, read-only data, data, heap space, stacks, and DLLs floating around above that. (`cat /proc/self/maps` will show you where things are in that instance of `cat`‚Äôs process‚Äôs memory.) In modern computers, every 8-bit byte is given a different address; some older or embedded computers only address larger words (e.g., 16- or 40-bit) but you don‚Äôt generally need to worry about those. `CHAR_BIT` from `&lt;limits.h&gt;` will tell you what you‚Äôre dealing with; typically it‚Äôs 8. Arrays and structs and things are allocated contiguously, so they occupy a range of byte addresses. For example: const char *string = "Hello, world"; puts(string + 7); This will print `world`, because that‚Äôs what‚Äôs at 7 bytes (`char`s, really) past the address pointed to by `string`. Or a more complicated version: struct foo { int x, y; } bar = {1, 2}; printf("%d\n", 1 + (int *)&amp;bar); That will print `2`, because `y` is one `int`‚Äôs worth of bytes past the beginning of `bar`, and `y` has the value 2.
The ELI5 is that say some value is a box with stuff in it, lets say marbles. So you have a box (a byte) that can hold 255 marbles (ignoring the whole bit thing for now) but you have like a billion of these boxes all with different number of marbles in them. So you place them in a row on the floor and number them so you know which is where. That is the values (the boxes with marbles) and their memory address (which number they are). C and other languages gives you cards that have a name on them and a few numbers telling you what starting box it refers to (address) and how many boxes it refers to (type size, 4 boxes would be an 32-bit integer). A pointer or byte address is just basically saying "I forget what the card was called, but it started at box 3450 and was 4 boxes." Feel free to ignore that those cards with all that information are also composed of some of those boxes, since it is not usually important.
Yeah, C# is two doors down. This here is just plain ol' C.
I think you are asking this in the wrong subreddit. Try r/csharp or r/learncsharp or something similar. 
This is a C sub, what you're looking for is C#. r/csharp A Windows Forms app using Visual C# could do the job I'd say. 
Thank you! &amp;#x200B;
Thank You! &amp;#x200B;
This is no declaration, a declaration needs a declarator, usually the type and, in case of strings, a declarator of pointer type.
\\\*edited details\\\*
You can basically put as many additional braces around the initializer as you want. It even produces the exact same binary. However, sometimes you *need* braces, ie. everytime you're initializing some non-integral variable (arrays, structures, ...) to group the "individual" initialized parts. Eg.: int *a = { 0, 1, 2, 3 }; // ... or similarly ... int b[] = { 4, 5, 6, 7 }; A string is actually no exception, however there's the "syntastic sugar" of using a string literal as an rvalue for initialization, that is you can equivalently write: char *s1 = "hello"; // ... same as: char *s2 = { 'h', 'e', 'l', 'l', 'o', '\0' }; As already said, any *additional* braces are optional. This is useful if you want to emphasize that your linear array should actually be seen as a two-dimensional matrix, for example: int m[] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; You can just omit the inner braces and it's just as valid -- just perhaps less clear to the programmer.
What do you mean by "they get each character one by one?" Creating an array of characters is simple (it's no different than any other array in C). Input via `scanf` is pretty simple as well (use the `"%s"` format specifier, and just pass the array as an argument; for extra credit, limit the width to the number of characters available and check for errors).
By getting every character i mean. Lets say you input "Reddit". I want a loop to check every character 'R' 'e' 'd' 'd' 'i' 't'.
Yikes. Here's a new assignment to make things interesting: Update, clean up, and modularize your code; Make it so it accepts images of more sizes at least, to look less like a homework assignment done badly; Don't use a C++ compiler, especially a 30y/o one.
Do you want to compare the string for instance a password check or just return the string? You say one by one, but it's sort of a moot point as you wouldn't see a difference between receiving via a serial interface one by one and all at once.
Well i have this example here which wants me to check if there are letters written with a pattern of lowercase and uppercase something like this "ReDdIt". I want to do that myself but i don't know how can i break down the array to check every character.
That doesn't really answer my question. But I'll read between the lines a bit and make a guess. You'll probably want a `for` loop with an index that goes from 0 to less than the size of the string the user entered (possibly using `strlen` or checking for the null terminator, your choice). From there, you can use standard array syntax: `if ( str[i] == 'R' ) { /* Do something */ }`.
oops! that's a tough assignment, given that i don't work on C/C++ for more than last 10 years, also keep in mind it was written almost in the last century :), that time a compiler 30-year old now was not that old :), so I shall leave it as exercise for one who is working on similar problems now, only with the intention that he/she may get some help from these badly done homeworks more than one and half decades back :). 
Thank you for posting these projects! It would be nice if you could space out your submissions to one submission per day so other submissions have a chance to reach the top of the subreddit, too. Right now, the whole subreddit is just your projects which might turn off some people.
Note that C++ is off topic in this subreddit. Please post your C++ programs to /r/cpp instead.
Sure, thanks
Okay, thanks.
Do you want your array of characters to include spaces? If so, use fgets() or scanf(%\[\^\\n\]s, myString). Then to print the every single character of that string use a for loop that goes from i = 0 to length of myString - 1. In that loop use printf("%c ", myString\[i\] ). I hope this helps man.
My question is why not label address one as containing the number one? And what‚Äôs with the 255? 
Also, thank you! 
Thank You for the Motivation, I will try me best :)
`%c` means to read in one character, so that's what the computer does.
Well, I got you here. First of all: the format specifier `%c` works for single characters. *** I'll tell you some theory before telling you what can you do: * An array of chars is commonly named *string*. * A string ends with the character `'\0'`. It is invisible, but it is always at the end of any string, and is added automatically when you press enter. Well, now, you have two different classes of strings: **with** and **without** spaces. That is, **words** or **phrases**, respectively. 1. **WORD:** if you want to read a word, you can simply do `scanf("%s", letters);`. Because, *voil√†*, there is a particular format specifier to strings! (Yes, it means you can use it in printf too, so that you don't have to write the for block). 1. **PHRASE:** well, if you want to read spaces too, it's a bit more difficult. Particularly, the line is `scanf("%[\^\n]s", letters)`. In real words, you can understand it as "*Reads a string until the character is a newline* ", where `^` means **until**. Hope you can understand, and if you have any question please don't be afraid of asking me. 
It‚Äôs been a while for me and C but aren‚Äôt strings just an array of characters?
Thank you for this it really helped. Im still solving the problem but this gave me a fresh start.
look into tokenization 
Honestly, there needs to be something on this sub that days "if you're using `scanf`, you're doing it wrong". To a first approximation it's correct...
thanks a lot. That was an interview question I had today and I didn't have much clue.. Yeah even I was surprised whether or not that has anything to do with sysadmins.
Sure dude. I'll check them out. Thanks a lot again :P 
Is this what the question is looking for? If that was it, I would have expected the question to have been sth like "what primitives do the alloc family routines use for their implementation". I think the question is about memory allocation strategies, eg simply allocate consecutive memory chunks or creating one or more pools of allocations and then talking about issues like memory fragmentation or memory corruption. A quick google search gave me [Memory Management on wikipedia](https://en.wikipedia.org/wiki/Memory_management), [malloc implementation on stackof #1](https://stackoverflow.com/questions/3479330/how-is-malloc-implemented-internally) and [malloc implementation on stackof #2](https://stackoverflow.com/questions/5422061/malloc-implementation) and an [possibly interesting article](https://danluu.com/malloc-tutorial/).
 while(a) { s; } equals loop: if (a) goto end; s; goto loop; end: do { s; } while(a); equals loop: s; if (a) goto end; goto loop; end: for(a;b;c) { s; } equals a; if (!b) goto end; loop: s; c; if (!b) goto end; goto loop; end: in the latter, if *b* is omitted, it's always true.
&gt; Is this what the question is looking for? If that was it, I would have expected the question to have been sth like "what primitives do the alloc family functions use for their implementation". I didn't know it was an interview question when I made that comment. But, yes, if someone asked me "how do I create a custom `malloc` implementation", I would certainly answer "start with `mmap`; you need to know how to get memory from the OS first". &gt; I think the question is about memory allocation strategies, eg simply allocate consecutive memory chunks or creating one or more pools of allocations and then talking about issues like memory fragmentation or memory corruption. In an interview I'd probably waffle on along those lines too.
Let's break it down into two ifs if (strcmp(waitorlater, "later") == 0) { if (headnode_CHAT == NULL) { printf("\ni'm in 1\n"); printf("TryLater %s %d\n",client, *current_time); } else { printf("\ni'm in 2\n"); del_begin_rep(); } } else if (strcmp(waitorlater, "wait") == 0) { if (headnode_CHAT == NULL) { printf("\ni'm in 3\n"); addpoint_end_hold(client); } else { printf("\ni'm in 4\n"); del_begin_rep(); } } See what your code does now...
Yes, read from RAM after the first read from EEPROM. As for the write, there are a number of ways to avoid wearing the memory out. You could search for load balancing algorithms although they are more common for flash memory. If you want to stick with the single copy of the structure in EEPROM (which is probably fine as long as you aren't modifying the values constantly), how about keeping two copies in RAM, one that represents what is currently in EEPROM and a "live" version that you use from your code. When you've modified the live copy, call a copy routine that compares the live copy with the current EEPROM copy. The copy routine doesn't need to be aware of the structure. It can go byte by byte through the live copy and the EEPROM copy, any difference write the live copy value to both the EEPROM and the EEPROM copy.
I've had two diametrical use-cases for this type of storage. On the one hand, there's the write-once-read-many type of settings, like network access settings - generally set only once during installation. On the other hand, there are things like state data, in case of a power loss it would let the firmware read the last known state on boot and continue from that point onward. I guess I should've added another question - would I be better off writing a one-size-fits all solution, or one for slowly changing data and one for quickly changing data?
My idea would be to keep the EEPROM in two parts: in the first part, you have the data as it originally was. In the second part, you have a journal of changes. Now the important bit is that you only ever append to this journal. Once it is full, you overwrite the bytes that changed with new parts and clear the journal (e.g. by erasing its first byte, overwriting it with `0xff`). On startup, you load the initial copy of the structure into RAM and apply all complete entries from the journal to that copy. That's the last know value of the structure. This approach has two advantages: * you spread the wear over a pretty large number of bytes, even if the same byte is always modified * if you program this correctly, the EEPROM contents can never be inconsistent if power goes out during a write And here are the disadvantages: * you need more EEPROM for this to work * it's more difficult to implement * if you mess up the implementation, the crash-proof property might not apply
In the past I've broken it into two structures. One that sits at a fixed address in the EEPROM and mostly stays constant. The other changes more frequently and gets written throughout the rest of EEPROM with the most recent one tagged. That does load leveling for you, but it will be slower than the other solution where you only update changed values. You really need to do some analysis of your situation and figure out: * how often data is going to change * how fast the update needs to take place * how many write cycles each location can take Based on that information you can determine what the best solution is for you and if any of them are viable with your current hardware.
Lol, yeah. I'm in my first year of CS and I'm trying to practice making sure I handle improper input for every assignment
[removed]
`scanf` returns the number of format specifiers that were satisfied. `scanf("%d", &amp;var)` will return `1` if an integer was available in the input stream, and `0` if a non-numeric string was entered.
I know that. The question is how can i make the user input integers into an array until he inputs a non num character.
The reason why certain boxes contain certain values is historical and complex, made even more complex by modern architectures. This was simply a metaphor to better understand how memory works. But as a metaphor it doesn't cover all the possible pitfalls. To be useful a computer needs to be able to store arbitrary values. As for the 255, each byte contains 8 bits, and 8 bits can represent a total of 256 values (2 to the power of 8), which means from 0 to 255. In the case of marbles, no marbles would be 0, and 255 is well 255, which covers the entire range of values.
You are welcome. If you still cannot solve this write to me again. 
A server wide default LD_PRELOAD environment variable is probably what they were looking for, given the sysadmin bit.
I donno, computers don't speak C++, that part is correct.
Amazing! This is a response when people say that computer programming is a new discipline (or at least only relevant recently)!!!
On your second question, yes, it‚Äôd just have to be macro that uses `offsetof` within its expansion. On your third question, yes, and there are a few ways to do that. The easiest and (IMO) least-annoying way is to do something like this: #define setEEPROMData(field, value) (__extension__({\ const __typeof__(((struct EEPROM *)0)-&gt;field) setEEPROMData__0 = (value); \ copyToEEPROM(offsetof(struct EEPROM, field), &amp;setEEPROMData__0, sizeof(setEEPROMData__0)); })) Setting that variable basically acts like a mechanism similar to normal argument-passing‚Äîit‚Äôll convert compatible-ish things to the right format, and it‚Äôll raise a bit of a warning/error if something really weird (e.g., a pointer) gets passed in. Alternatively, you can use the C11 `_Generic` feature (ick) or the GNU `__builtin_types_compatible_p` predicate to check types explicitly, but that can easily run into problems with type incompatibility if you aren‚Äôt casting the fuck out of the setter‚Äôs arguments. (E.g., if you pass a bare `0` to something that demands a `uint8_t`, the types aren‚Äôt going to match exactly.
Look at std::max to cap a value to 5 after you've calculated it
Look at std::max to cap a number to 5 after you've calculated it
There was some discussion on this topic in [this post](https://www.reddit.com/r/cscareerquestions/comments/4ymbou/where_can_i_find_companies_that_asks_fizzbuzz/) [This](https://www.reddit.com/r/cscareerquestions/comments/4ymbou/where_can_i_find_companies_that_asks_fizzbuzz/d6plwsp/) comment is my favourite explanation there.
It's not that hard to get it wrong. It's easy to make it a kludgy mess. Bonus follow up question: how would you modify your code to print boop for every number divisible by 7? Can your original solution be easily amended? It's not a great question, but a quick way to filter out hopeless cases.
I first heard of it back in 2007 from [Why Can't Programmers.. Program?](https://blog.codinghorror.com/why-cant-programmers-program/): &gt; Write a program that prints the numbers from 1 to 100. But for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz". For numbers which are multiples of both three and five print "FizzBuzz". &gt; &gt; Most good programmers should be able to write out on paper a program which does this in a under a couple of minutes. Want to know something scary? The majority of comp sci graduates can't. I've also seen self-proclaimed senior programmers take more than 10-15 minutes to write a solution. The mistake I think the article makes, and a lot of the discussion about FizzBuzz, is that job candidates are not nearly representative of programmers in general. Good candidates don't remain candidates for long, and bad candidates try over and over again, which causes oversampling.
This is C programming, not C++. Ask in /r/learncpp or /r/cpp_questions
Will you be my friend?
This sub is for C, not C++...
Wrong sub
[Emulate the CPU](http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf) Emulate the hardware (ROM, RAM, Cartridge, Screen, Buttons, Sound, ...) from/to some memory buffers Write a UI to display those buffers, feed those buttons or change the cartridge I wrote a couple of emulators, it is *extremely* rewarding, but can be *very* challenging. 
http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/ this was a pretty cool project when i did it just recently
https://youtu.be/y71lli8MS8s warning c++ ahead
r/emudev
Of course thats a thing 
I wouldn't make it overly complicated. For the config data, just read the whole thing into RAM and then write the whole thing back. Include a CRC (or at least a checksum) on the struct so you can detect corruption. If you want to be able to recover from corruption, write the table in one spot, verify the written CRC, write it to a backup spot. It's going to be slow, but then you are writing config data to an I2C eeprom... It's going to be slow no matter what. As long as you don't change the config 1000000 times you won't wear anything out. For the persistent state you want to keep, figure out how often you actually need to write it back (is it ok to use a second old, minute old, hour old value after a power loss?) Estimate the max total runtime your system will expect to see, and multiply by that write frequency. If that's less than the eeprom write cycle life, your job is easy; save the state to one eeprom address along with a CRC, and then immediately write it to a backup address with a CRC as well. Otherwise, you'll need to be implement wear leveling regardless of the form it takes. You could use a region of eeprom as a circular buffer, writing the state and a CRC in the next index each time. You'll need a way to determine which entry is the most recent; either write sequence numbers, or just erase the entry at the previous index after writing to the next index. Another option is to just intentionally wear out the EEPROM one chunk at a time. This assumes the EEPROM only experiences isolated wear failures though. Partition the EEPROM into fixed size chunks along with a byte for each chunk indicating whether it is worn out. Since you can detect corruption using your CRC, on a verification failure, mark the chunk worn out and start using the next free one. You can use the first good chunk for a primary struct and the second good chunk for a backup struct so that you can still tolerate power loss. But CRCs are slow! Not nearly as slow as EEPROMs, or the time spent hacking around a persistent storage system that silently corrupts data...
Kind of piggybacking off this question... what would be recommended prereqs before starting to learn how to write one?
The problem is that, if you want to *truly* work with a framebuffer, it's necessarily really unportable. Every platform does framebuffers in a very different way. [libggi](https://en.wikipedia.org/wiki/General_Graphics_Interface) is probably your best bet (that I can think of) that doesn't give you much beyond a simple input and some simple 2D primitives, but is still a little bit portable.
**General Graphics Interface** General Graphics Interface (GGI) is a project that aims to develop a reliable, stable and fast computer graphics system that works everywhere. The intent is to allow for any program using GGI to run on any computing platform supported by it, requiring at most a recompilation. GGI is free and open-source software, subject to the requirements of the MIT License. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The handmade hero guy ported his code to Linux I thought... Unfortunately I'm not sure what technology he used. Maybe check out those videos on YouTube.
 Array : 8 6 Max position: 791621423 What do you expect it to print? Is the variable you print ever set to the value you expect? 
in the Output #1 it shows 0, as it should be, and yes, it is set to the value of the position of the highest int in the array. The array is [8,6], and the max value (8) is in the position (0).
&gt; yes, it is set to the value of the position of You're printing `posicion`. And, no , it is never set to 0.
Right out of the blue I would maybe try to implement a hashmap for the opcodes first where maybe the hex from rom are key and value is a function, but I dont even know if that is possible in C 
Great source thank you!
What's wrong with OpenGL? 
The last one's type is `char**` which is implicitly converted to `char*` in ur assignment. 
Although not the color, [The Ultimate Game Boy Talk](https://www.youtube.com/watch?v=HyzD8pNlpwI) should be largely relevant system info.
SDL2 to be specific 
SDL2 to be specific 
Check out [SDL](https://www.libsdl.org/) (2.0). If you want something lighter, check out [GLFW](http://www.glfw.org/). Both are great and have good documentation/tutorials. &gt; Any pointers? Heh.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.libsdl.org/) - Previous text "SDL" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
why dont you look at the source code of open source projects that do exactly that?
Saw this used in a CS50 problem set...thought it was pretty cool. [https://www3.nd.edu/\~dthain/courses/cse20211/fall2013/wavfile/](https://www3.nd.edu/~dthain/courses/cse20211/fall2013/wavfile/)
Don‚Äôt. Those CPU were cheap for the reason that stuff was staightforward. I don‚Äôt know the GBC,but it looks like some sort of 8080/Z80. You have two general options: 1 - decode. You take the opcode, and use the fact that they are into group (ie: specific bit patterns give instruction groups, like store, or compare, etc.) you extract the group, and switch on it. 2 - a 256 entry table or switch that will call specific functions with the right parameters. This is easier, as you don‚Äôt have to immediately make sense of the instruction format. In general, people use heavy macros to do that efficiently. I used C++ template meta programming, but I wasn‚Äôt too happy with the result, so for y 6502 emulator, I went with the big switch approach. The #1 challenge you will have is testing. One way to make it work is to embed an existing emulator implementation, run both and check that the result are identical (I did that when my emulator was mostly finished, it helped tremendously to iron some last bugs. i found some bugs in the library I used, too). &gt; but I dont even know if that is possible in C Everything is possible in C. You said you were ‚Äòsolid‚Äô is C and assembly, but you may discover that you have plenty to learn. Good luck.
A Game Boy might be a difficult project to emulate, due to the cartridge system. Each cartridge could include additional hardware such as sound acceleration or a co-processor.
You do realise don't need (to learn) 99% of libSDL for the task you just described above? libSDL is the way to go.
he said "Low Level" 
he said "Low Level" 
he said "Low Level" 
Every platform does graphics differently, so there is no low-level library that works on all of them. For a reasonably simple and portable library, try SDL.
That's *undefined behaviour* and the compiler should have warned you.
It did not! I compiled with the flags stated in the post, and gcc -vv gives: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.10)
No, while *the order of execution* is *unspecified*. However it says in the standard: 6.5 Expressions, ¬∂ 2 (emphasis mine): &gt; Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read *only* to determine the value to be stored. The last sentence means that in an expression, in a segment between two sequence points, where a value is stored (here '`i`'), it may only be accessed for the only task of determining the new value of '`i`'. This is also explicitly listed under J.2 Undefined Behavior, ¬∂ 1: &gt; The behavior is undefined in the following circumstances: &gt; * [...] &gt; * Between two sequence points, an object is modified more than once, or is modified and the prior value is read other than to determine the value to be stored (6.5).
Even worse, in this case it's undefined behavior: https://reddit.com/r/C_Programming/comments/9d79hg/static_variable_in_c/e5lw687?context=3
For completeness sake: There's a sequence point after the evaluation of the function arguments and directly before the call of the function. So a(), b(), c() *must* be evaluated (ie. "called") before the function the expression containing the printf() is evaluated.
Stenographers generally take 5 minutes to conceive 9 months to gestate, 18 years to raise and a year or two to train. C is rarely involved in any part of this process.
Try allegro.
Very appreciated!
https://i.imgur.com/0ninJZQ.png Firstly there are a pile of people here all saying "SDL" or "OpenGL" and that is not at all what you asked for. Low level is what you said. The question is, how low can you go? I usually say to people that we can go down to the wire if we need to and look at chip level problems but that is generally a chip design and fabrication type of discussion. I see from your actual question, which I actually did read, that you want to play with "raster" type data and you tossed in "RGB" pixel stuff. Okay so we are way up from the transmission lines and bus transfer logic. Way way up higher than the TTL chip designer. Cool. Let's assume you have a working computer and you want to work with UNIX or a Linux variant. You don't care about system architecture design and you don't care about the machine. Got it. So let's pick the level that is pretty much assembly language in the graphics world. Some level down deep enough that you can get a pixel but you don't care about where that data resides in memory or the graphics display processors or even the actual picture element on your screen and how it suddenly turned a bright red. All of that we will call "magic". So that then gets us to the Xlib level. Well up from the "shannon" level ( Bill and Karen ) but not too far. I suggest that you look into libX11 and just get to the ability to generate a NoOperation protocol request to an X server. Start there. I should warn you that getting a trivial string "Hellow Woryld" to appear on the screen will need many hundreds of lines of C code. Which is to say, not assembly. No dealing with memory directly. The "magic" happens for you but you can get a pixel on the screen. Let's go upwards a tiny itty bitty step further and we are at the Xt level. The Xt library allows you to avoid writing hundreds of lines just to get a pixel formation and the letter "J" on the screen somewhere. You can get a box type "window" and with a little work a "button" type thing that means a key press or a mouse click "event" may be detected and handled. So X11 is your friend here and not much lower below that. I have built all of xorg/X11 from sources over and over on various machines and systems ( big endian, little endian, risc or whatever ) and you don't need to go there. However you can draw stuff and get pixel type stuff from X11. Fancy stuff like shade and lighting effects and hollywood will need OpenGL and NVidia GPU tech. I run quadro gear for professional reasons but X11 only needs the most trivial framebuffer and a driver. Also there isn't any "event" trapping here. If you resize the window then kaboom. You lose the picture but keep the window. #include &lt;X11/Xlib.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; Window create_simple_window(Display*disp, int width, int height, int x, int y); GC create_gc(Display*disp, Window win, int reverse_video); int main(int argc, char*argv[]) { Display * disp; int screen_num; Window win; unsigned int disp_width, disp_height, width, height; char *disp_name = getenv("DISPLAY"); GC gc; Colormap screen_colormap; XColor red, brown, blue, yellow, green; XPoint triangle_points[] = {{0,0},{45,45},{0,45},{0,0}}; int npoints = sizeof(triangle_points) / sizeof(XPoint); /* 4 */ /* Status retcode; don't really need this but for trivial stuff */ disp = XOpenDisplay(disp_name); if (disp == NULL) { fprintf(stderr, "%s: no X server?? '%s'\n", argv[0], disp_name); exit(EXIT_FAILURE); } screen_num = DefaultScreen(disp); disp_width = DisplayWidth(disp, screen_num); disp_height = DisplayHeight(disp, screen_num); /* take up a small eighth chunk of screen */ width = (disp_width/4); height = (disp_height/4); printf("width %i height %i\n", width, height); win = create_simple_window(disp, width, height, 0, 0); gc = create_gc(disp, win, 0); /* fart with the reverse option */ XSync(disp, False); screen_colormap = DefaultColormap(disp, DefaultScreen(disp)); if (XAllocNamedColor(disp, screen_colormap, "red", &amp;red, &amp;red) == 0) { fprintf(stderr, "XAllocNamedColor - no red color?\n"); exit(EXIT_FAILURE); } if (XAllocNamedColor(disp, screen_colormap, "green", &amp;green, &amp;green) == 0) { fprintf(stderr, "XAllocNamedColor - red works but green no??\n"); exit(EXIT_FAILURE); } if (XAllocNamedColor(disp, screen_colormap, "blue", &amp;blue, &amp;blue) == 0) { fprintf(stderr, "XAllocNamedColor - red and green okay but blue??\n"); exit(EXIT_FAILURE); } /* want a red pixel .. we talked pixel right ?? */ XSetForeground(disp, gc, red.pixel); XDrawPoint(disp, win, gc, 5, 5); XDrawPoint(disp, win, gc, 5, height - 5); XDrawPoint(disp, win, gc, width - 5, 5); XDrawPoint(disp, win, gc, width - 5, height - 5); /* a green line */ XSetForeground(disp, gc, green.pixel); XDrawLine(disp, win, gc, 50, 0, 50, 200); XDrawLine(disp, win, gc, 0, 100, 200, 100); /* a blue curve */ XSetForeground(disp, gc, blue.pixel); XDrawArc(disp, win, gc, 50 - (30 / 2), 100 - (30 / 2), 30, 30, 0, 360 * 64); /* red lines form a triangle */ XSetForeground(disp, gc, red.pixel); XDrawLines(disp, win, gc, triangle_points, npoints, CoordModeOrigin); XSetForeground(disp, gc, BlackPixel(disp, screen_num)); XDrawRectangle(disp, win, gc, 120, 150, 50, 60); XSetForeground(disp, gc, green.pixel); XFillRectangle(disp, win, gc, 60, 150, 50, 60); XFlush(disp); /* flush all pending to X server. */ sleep(30); /* stare at it for 30 secs */ /* close the connection to the X server. */ XCloseDisplay(disp); return EXIT_SUCCESS; } Window create_simple_window(Display*disp, int width, int height, int x, int y) { int scr = DefaultScreen(disp); int border_width = 2; /* sure, 2 pixels, why not */ Window foo_win; foo_win = XCreateSimpleWindow(disp, RootWindow(disp, scr), x, y, width, height, border_width, BlackPixel(disp, scr), WhitePixel(disp, scr)); XMapWindow(disp, foo_win); XFlush(disp); return foo_win; } GC create_gc(Display*disp, Window win, int reverse_video) { GC gc; unsigned long valuemask = 0; XGCValues values; unsigned int line_width = 2; int line_style = LineSolid; int cap_style = CapButt; int join_style = JoinBevel; int screen_num = DefaultScreen(disp); gc = XCreateGC(disp, win, valuemask, &amp;values); if (gc &lt; 0) { fprintf(stderr, "XCreateGC: \n"); } /* foreground and background colors */ if (reverse_video) { XSetForeground(disp, gc, WhitePixel(disp, screen_num)); XSetBackground(disp, gc, BlackPixel(disp, screen_num)); } else { XSetForeground(disp, gc, BlackPixel(disp, screen_num)); XSetBackground(disp, gc, WhitePixel(disp, screen_num)); } /* line style */ XSetLineAttributes(disp, gc, line_width, line_style, cap_style, join_style); /* fill style is solid */ XSetFillStyle(disp, gc, FillSolid); return gc; } That will draw a box on your screen and then a triangle and a circle and a few lines. No fancy libs. At all. Well, hold on a sec. I lied. You need libX11 and a few others are dragged in by that but you compile it with gcc -m64 -g -o foo foo.c -lX11 Nothing else needed. I should go fart with the reverse video option however. See comment in code. 
It really depends on your definition of low level. Compared to unreal engine or unity, I'd call opengl pretty low level üòé but yes, not what OP wanted
At our school we use library called mlx. It can be compiled on Linux and macOS. All of the functionality you described is the entirety of this library. It's really simple, but it is an abstraction still.
Great in-depth information.
In the applications I work on, we divide settings into three sections. Factory data for things like calibration is typically written once. User data is written any time the user changes a setting. Maintenance data (mostly min/max sensor readings) is constantly accumulated, and written once every 24 hours. The commit time for the maintenance data was chosen for our application to balance wear vs. lost data from a power interruption. 
https://youtu.be/iyLNYXcEtWE?list=PL9D558D49CA734A02&amp;t=1406
There are many different ways to do it. The easiest, though least type safe, is to use `void *`pointers everywhere you would normally have pointers to your elements. The other two approaches I've used in the past involve macros. The easier-to-explain way of these two is basically to generate new versions of all of the functions for any type you want to put in your data structure, kind of similarly to C++ templates. Basically, you write a massive macro that takes in the type you want in the data structure and a name for the new data structure; you use the passed name to define new typed structure and to "namespace" all the operations (with token pasting), and you use the passed type instead of the "real" type where you would have before. This second approach may not be the most size efficient, but it is type-safe.
Look at how something like qsort or bsearch handles types.
Either using void*, or using preprocessor macros. The preprocessor macros solution are kind of poor man's templates. That's one of the main reasons I don't like C. You have to reimplement almost everything from scratch every time.
Pass a pointer to the first element of the array. If the array is not terminated in some predictable manner (like with a NULL), then you may want to also pass the size of the array as a separate argument.
you can use a void * as has been mentioned. The other thing I've done in the past, to avoid preprocessor macros, was to implement a struct like this; struct item { int item_type; size_t item_size; void *item_ptr; }; I mean, it's all taste really, and whether you really want to spend the effort. And there's a performance cost to this approach. It really depends on what you're doing. If you have a stack that's only ever going to store the same things, then you don't need to do that. But you know, it gives you the ability to say, give me the next item of type blah, and let you store different types in the same stack, and know how big they are, if they are things like char arrays.
Were you kicked in the head by a horse as a child?
Take a look at ContainerIO. it's basically just a struct containing some info, and a union for each supported type. it's dead simple.
Yes, which is why I craftily shifted to the example with side-effects. Order of evaluation is what they were asking about and it's easier to explain 1 concept than 2.
That can be dangerous, as it allows access to the data via the wrong type. Using a void pointer forces a typecast to the desired type. Of course, if you're coding to an old standard, you may have to use char *.
thanks but to be honest that is crap code. I never bothered with XFreeGC() nor did I write the XCreateSimpleWindow() call correctly where really the border and background colors should both be black to start. It works .. but badly. Also one should never check the value of a pointer as being less than zero. That is really taser me crap. Also never bothered with ArcChord or ArcPieSlice for a curve. Anyways ... low level enough.
1. `void*`. This is the most common solution but [can be slow][1] (see also [this][9] on a hash table microbenchmark). A bad choice for huge datasets. 2. [Intrusive data structures][2]. A widely known example is [double-linked list from the Linux kernel][3]. Intrusive or semi-intrusive data structures can also be used to [implement binary trees][4] and chaining-based hash tables, but for the best performance, you need to combine it with techniques from the following: 3. Marcos. This subreddit hates macros, but when it comes to performance, macros are the king and often the only way to match the speed/memory of type-specific containers. There are different ways to use macros. Here are a few examples: [tree.h][5] from freebsd, [rb.h][6] from jemalloc, [khash.h][7] and [kavl.h][8] from klib. These are among the most performant C implementations of similar data structures. [1]: https://attractivechaos.wordpress.com/2008/10/02/using-void-in-generic-c-programming-may-be-inefficient/ [2]: https://stackoverflow.com/questions/5004162/what-does-it-mean-for-a-data-structure-to-be-intrusive [3]: https://isis.poly.edu/kulesh/stuff/src/klist/ [4]: https://attractivechaos.wordpress.com/2018/04/19/a-single-header-generic-intrusive-avl-tree-in-ansi-c/ [5]: https://github.com/freebsd/freebsd/blob/master/sys/sys/tree.h [6]: https://github.com/aerospike/jemalloc/blob/master/include/jemalloc/internal/rb.h [7]: https://github.com/attractivechaos/klib/blob/master/khash.h [8]: https://github.com/attractivechaos/klib/blob/master/kavl.h [9]: https://attractivechaos.wordpress.com/2018/01/13/revisiting-hash-table-performance/
That's really cool that you took the time to explain all of this and even cook up an example
you should explain yourself.
\`\`\`c \#define Vec(T) T\* \`\`\`
`fgets` reads until it filled the buffer or when the line ended (`\n` encountered). You only call it once (every loop iteration), and tries to parse the same line twice (one as if it were the first line and once as if it were the second line).
Yeah, but where's the fun in that :P
could you elaborate a bit more?
I tried but i get a memory location in return. It doesn't seem to read the number;
**Char***: Wait! You have to take me to the stack safely. According to the Code of the Order of the Strict Aliasing... **Compiler**: First, your return to the stack safely was not part of our type negotiations nor our agreement so I must do nothing. And secondly, you must be a strict alias for the strict alias's code to apply and you're not. And thirdly, the -fstrict-aliasing code is more what you'd call "guidelines" than actual rules. Welcome aboard the Type Pun, Miss Char-pointer.
Thank you for your reply, I think I may have fixed it by adding `fgets` a second time in my loop!
thanks .. I updated it gently
Not sure exactly how the output is garbage, but a few ideas: Was the file opened sucessfully? Is 40 chars enough for every entire line in the file? If the printf prints lines concatenated together, and shouldn't, try adding another \\n to the end of the format string of the printf.
Hot damn, that's gonna take some time to unpack. Thanks for the detailed response.
Sorry you netted so many downvotes in this thread. I actually will check out SDL again, given how many people recommended it, but I appreciate your adherence to my specific request. And I'll definitely look into your recommendations.
The real answer is: you don't. Try to design your program such that you don't need special type-independent data structures.
I've find this technique (which I call struct wrapping) very useful in writing type agnostic data structures (linked list, hadh table, C++ style vector) without relying too much on void*. To avoid the type unsafety and ease of use I usually wrap the functions with helper macros which unwrap the struct and access the correct inner member and pass it to the data structure functions - which all take struct list* for example.
Hello, this subreddit is for the C programming language. You're writing in C++. Try /r/cpp_questions instead.
&gt; Try to design your program such that you don't need special type-independent data structures. I am sure you can achieve that. I can't. Since I switched back from C++ 10 years ago, I have developed over a dozen of mid-sized projects. Nearly all of them need hash tables or trees with non-standard keys. khash.h and kbtree.h, as ugly as they are, are easily my most reused code and have greatly accelerated developement. Developers are different. You don't need generic data structures, but some others do.
So what you're looking for is non-blocking I/O. Unfortunately you're going to have to break out of the standard for that as far as I know. You either need to start writing against platform APIs (poll for example in unix) or pick a library which abstracts those cross-platform APIs for you.
/r/cpp_questions for c++ questions 
Thank you
You can't really. A big benefit of C++ is it's type awareness, but it makes the language complex. The big benefit of C is the language's simplicity. Just store the data internally as a char array, and do something like: struct stack_s { size_t item_size; char *top; char *storage; char *storage_end; }; void stack_init(struct stack_s *stack, char *storage, size_t storage_size); bool stack_push(struct stack_s *stack, const void *val); bool stack_pop(struct stack_s *stack, void *val); Do memcpy's inside push and pop and you avoid any potentially bad aliasing.
True, but using void* will prevent you from doing anything without casting.
Can you elaborate? A stack of float and stack of char is differentiated only by the data type. So it doesn't make sense to rewrite stack for every data type, basically do macro's job. 
You cannot pass arrays but you can pass pointers to arrays. If you know the size of array you pass a pointer to array: void foo(int (*array)[N]) int array[N] foo(&amp;array) If you don't you pass array symbol which gets decayed to pointer to first element: void foo(int *array, size_t len) foo(array, len) 
&gt;ContainerIO Link? &amp;#x200B; google only throws results about kubernetes.
If it is OK to use c ncurses might be the way to go since it works on multiple platforms (I think). There are also many good tutorials online :p
echo "/s" &gt; /dev/fb0
There's no such function as `_getch()` in either C or C++ btw. Anyhow, non-blocking I/O is nothing the C standard specifies, you can write against POSIX though and use select/poll.
A stack is so simple that abstracting it away is not particularly useful anyway. Same with linked lists. To push on the stack you just do stack[++tos] = value; and to pop from it you do value = stack[--tos]; No need to abstract anything. What I'm trying to say is that if a data structure is sufficiently complicated that implementing it inline where needed is not feasible, it's likely that you only need it in this one place anyway, so you just write a specialised implementation.
That might be possible.
What about when array len exceeds capacity? Reallocation. Hashmaps for example would need rehashing etc. Why waste time writing basic data structures for every program when you could write it once and think about other more important stuff? 
If you need a stack with dynamic memory allocation, use a linked list. I never had this use case. &gt; Hashmaps for example would need rehashing etc. You can use rehashing, but often a fixed-sized hash table does the trick just as good. &gt; Why waste time writing basic data structures for every program when you could write it once and think about other more important stuff? I use three basic data structures in my C programs: structs, arrays, and linked lists. Everything else is so rare that I implement it on the spot for the purpose at hand.
Do you have a github or gitlab? I'm interested in seeing your code
http://github.com/fuzxxl Most of it isn't public though.
[https://imgur.com/a/36eF7ef](https://imgur.com/a/36eF7ef)
is uus_tee a char*?
No, "uus\_tee" is the same type as "tee", here is the full recursive function: void tree\_crawler(struct punkt \*el, int \*tee, long tee\_pikkus, int suund){ &amp;#x200B; &amp;#x200B; int \*uus\_tee; long i; &amp;#x200B; printf("\\n"); for(i=0; i&lt;tee\_pikkus; i++){ printf("%d", tee\[i\]); } printf("\\n"); &amp;#x200B; uus\_tee = malloc(sizeof(char)\*(tee\_pikkus + 1)); for(i = 0; i&lt;tee\_pikkus; i++){ uus\_tee\[i\] = tee\[i\]; printf("uus\_tee\[%d\] = %d\\n", i, uus\_tee\[i\]); } &amp;#x200B; uus\_tee\[tee\_pikkus\] = suund; printf("uus\_tee\[%d\] = %d \\t%d\\n\\n", tee\_pikkus, suund, el-&gt;sagedus); el-&gt;tee = uus\_tee; el-&gt;teepikkus = tee\_pikkus+1; &amp;#x200B; &amp;#x200B; if(el-&gt;A != NULL){ /\*printf("\\nAlla A, sagedus %d\\n", el-&gt;sagedus); system("pause");\*/ tree\_crawler(el-&gt;A, uus\_tee, tee\_pikkus+1, 0); } if(el-&gt;B != NULL){ /\*printf("\\nAlla B, sagedus %d\\n", el-&gt;sagedus); system("pause");\*/ tree\_crawler(el-&gt;B, uus\_tee, tee\_pikkus+1, 1); } if(el-&gt;A == NULL &amp;&amp; el-&gt;B == NULL){ printf("\\n L√ïPP: %c ", el-&gt;t2ht\[0\]); for(i = 0; i&lt;tee\_pikkus+1; i++){ printf("%d", el-&gt;tee\[i\]); } printf("\\n"); system("pause"); } &amp;#x200B; &amp;#x200B; &amp;#x200B; }
then that's your problem. You're mallocating only enough room for char-sized elements, so you're reading and writing to memory that is undefined (probably stack space used by the printf procedure)
Thank you so much, I must have accidentally written that char there. I just finished quite a chunk of char array juggling code which included writing sizeof(char) over and over again.
file1.h: struct stack; typedef struct stack stack_t; file1.c: struct stack { void** data_ptr; size_t quantity; size_t size; };
Those were the original files, but it was all messy using "struct stack" in my functions, so I renamed it using *typedef*. 
Yes, I also renamed it using typedef.
it can still be a good hint to what you're allocating for
If I do so, my functions inside file1.c (which make use of stack_t) will stop working...
you need to shift the string over each time. what functions are you using? strcpy or memmove are what you need. be mindful of how much space is in your string buffer of you will crash
May I ask you something ? What were your resources to learn C and what side projects did you do to learn C while you were a beginner :)
I am doing it for school and teacher is a whiny 78yo
Not OP but I use C on a daily basis. I would recommend starting by downloading OPs code and really understand how it works and play around with it a bit. One of the things that helped me go to the next level was to see how real applications are put together.
DISCLAIMER: I DID NOT WRITE CRAFT. I am posing it here because I too find it a PIECE OF ART!
it is pointer maths, nothing to do with char values. its testing that there are enough bytes in the buffer to contain `n` bytes
Note that this subreddit is about C only, if you want answers from C++ programmers, try asking in /r/cpp or /r/cplusplus.
Okay, I'll make a second post in r/cpp and edit this for just C programmers. Thank you
Not OP, but I would recommend everyone learning C also learn a bit of assembly first. It helps A LOT. Programming from Ground up is a good book to start with. C will be a breeze afterwards 
Thank you deaf_fish 
5 and 9 are integers
It‚Äôs better to come up with an entirely new buffer (count words, size the prefix string, and calculate the right buffer length that way), and construct that as you walk the input buffer. Then, either free the input buffer and swap the new buffer‚Äôs pointer in (if dynamically allocated and by pointer), or copy the new buffer over the original (assuming it fits).
The most common error I get is error: expected ‚Äò;‚Äô before ‚Äòl‚Äô or syntax error: missing ';' before identifier 'l' But I don't see how this is a very useful question.
Thanks for the answer, my purpose for this poll is purely for my personal interest what the community will respond with. I had plans to use the results of the answer from here and the post on r/cpp to draw up some charts and maybe post it to r/dataisbeautiful if I get enough answers. 
Using 5.0f instead of 5 and 9.0f instead of 9 may work.
Not a problem. I work in the real world which needs real solutions and software that is ( usually ) portable and stable across a seven year cycle. Plenty of rewards therein.
C is amazing because you have just enough control over memory to really understand what the computer is doing. It's called the Latin of programming languages because it's the backbone of them. Want to write a library that you can port to any language and share a fast, native codebase with? You use C. C is also used in the embedded market because of it's low footprint.
Unlike Latin, C is a widely used language - especially for embedded systems. There many important and widely used programs that are written in C: + Linux kernel + BSD kernel + Apache web server + Nginx web server + Postfix email server + Asterisk PBX to name a few. Also, many other programming languages were influenced by C. Finally, since C is a low level language, learning C will help you to better understand computer architecture. 
Recieve the input as a string. Then iterate the string (for loop). For each character ask if it is less than `'0'` or greater than `'9'`, if that's true, then your string contains _not numbers_. If you exit the loop without meeting that case, then your string is only numbers.
I like to use [non-canonical mode](https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html) for this purpose. Basically, you turn off input buffering and echoing. Then you read input one char at a time. By doing this, you can accept only valid characters and you can limit the length of the input. So, in your case, you would only accept numerals as input and a maximum of five characters. You can check that the user input does not exceed the maximum after the user finishes input, or as each number is input.
 char checkOnlyNumbers(const char *input){ for(int i = 0; i &lt; strlen(input); i++){ if(input[i] &lt; '0' || input[i] &gt; '9'){ return 0; // Contains a not number } return 1; }
Download the source code and you will see why!
I think C is a fantastic way to understand what other higher level languages (like Java or Python) are doing under the hood, and how to analyze runtimes. In C, you have to build all of your data structures yourself. You have to write the algorithms to trace through those structures. You have to manage the memory, and understand how everything fits together. So you get to know why you'd want a linked list vs. an array and how traversing them affects runtimes, or why merge sort is faster and more efficient than bubble sort. In Java, for example, you don't have to write your own linked list class, or traversal algorithms. You don't have to write a library that dynamically resizes and reallocates arrays. You don't have to write your own sorting algorithms. But once you know what it's doing behind the scenes, you can choose data structures that are more appropriate for your needs, and how the methods you're calling will affect your runtimes. Unless you want to do embedded development, you're not going to be working in C. But the knowledge you gain from it is a great foundation going forward to help you be a better developer with other languages that you'll learn. 
It's also really easy to understand the entire of C. It's not very complex, once you understand its semantics as there's no 'standard library' built in. I'm aware of libc, but it's just not as integrated as is the case with others such as C++/C#. Annoyingly you have to do everything yourself, but if you can write good and safe C then you really understand how memory works. It teaches you to dislike abstraction as well. For instance, I get annoyed at the lack of structures in Python. Sometimes I want to apply certain semantics to a region of memory and just can. It's blisteringly fast too.
So what will i able to make with C at the end? 
What you'll realistically be able to do is write linked list libraries, heap libraries, hash tables, write sorting algorithms, and write small applications that illustrate these things. You could probably write a small desktop application (perhaps terminal-based), but you're really not going to want to build anything more complicated with C at that point (unless you have a desire to go into embedded or systems development). Really, think of your time with C as building a foundation. At my school, after our intro to C programming and computer science 1 classes, we moved on to other classes that worked in Java or Python or other higher level language. A lot of people hated their time working in C, but it really informed their understanding of other language as they moved on. 
Oh ok. Thanks for your input üôè 
Largely dissimilar. Syntactically there are relevant comparisons to be made but that is where the similarities start and end. There is a vast discrepancy in how C manages memory (it doesn't and doesn't abstract you from underlying details of implementation. I'd do a bit more reading‚Äîperhaps the C programming language book by K&amp;R‚Äîto understand these implementation differences. 
Something which is seldom mentioned about programming in whole is that is way more about concepts and the art of programming itself. I learned many languages over the past few years and every language is distinct on its own. Maybe it is scripted, object oriented, functional or procedural (just to name a few of the differences) but what is really important if you want to write a computer Programm is to understand how thinks really work in the background and get to know about the concepts. In my opinion C is one of the best languages to getting started. The main reasons are the mostly straight forward syntax, that you have to fuck around with memory and maybe that you have to build many things on your own. It is was easier to understand how a garbage collector works if concepts like heap, stack and memory management as a whole are nothing new to you. I like to think of a programming language as a tool. There are multiple tools that archive the same thing and yes sometimes there is a right tool for a specific task. But it‚Äôs way more important to understand what you want to archive and choosing the right tool for the right task than using the wrong tool for some tasks. I think the question is not about what you can do with C and more about what you can do with programming. If you know C you just can Programm anything (just not in any language;) ) 
This guy is a tensai
Because C forces you how to see how a computer really works. The level of abstraction is just high enough not to be too painful. 
For sure, references are a big one. Understanding that `Myobj obj = new Myobj();` is basically the same (from a memory point of view) as `Myobj *obj = malloc(sizeof(Myobj));` is incredibly helpful. And understanding that passing those objects around as references is like passing around pointers, really makes a massive difference in understanding Java. 
That‚Äôs my new favorite explanation I‚Äôm gonna quote ;) 
Also Python, Perl, Ruby, JVM, [insert language here] were written in C. 
Oh crap. This is by the same guy the released that Minecraft in python project. Dude, he‚Äôs epic.
nobody ever remembers the other guy. whats his name again?
Abraham Lincoln
&gt; So what will i able to make with C at the end? Absolutely *ANYTHING*.
, Vampire Slayer
after one semester... probably not much. If you stick with it, everything you could think of can be built with C, where as low level system calls in python still require a library compiled in C. My professor always said "python and java solve today's problems. C solves tomorrow's problem".
I literally just found this yesterday for my 3 year old daughter to play, so she could feel like her big sister (who was playing MC). Unfortunately it was compiled using a buggy version of GLFW and the view scrolls up as if the mouse is moving, when it's not. So I downloaded Freeminer, which is actually a far more fleshed out and MC-like game.
no the other guy
Steve Jobs.
Brian Kernigham
More discussion in /programming, including about updated forks: https://old.reddit.com/r/programming/comments/9eey17/beautiful_minecraftlike_written_in_pure_c_and/ (Shameless plug! https://satoshinm.github.io/NetCraft/)
Section 6.5p7 of C11 draft revision N1570 is a rule which is, according to a footnote, intended to indicate when objects might alias. The published rationale goes into a bit more detail, indicating that the rule is intended to relieve a compiler, given something like: int x; int test(double *p) { x=1; *p=2.0; return x; } from having to pessimistically allow for the "dubious" possibility that `x` might be affected by the write to `p`. The rule as written specifies that various object types may only be accessed by lvalues of specific other types. The rule was presumably not intended to apply to lvalues that are visibly derived from the objects being accessed, but the authors may have intended to treat the ability to recognize object derivation in various circumstances as a "quality of implementation" issue. A non-garbage implementation would obviously have to, at minimum, allow structures or unions to be accessed using lvalues of forms like `theStruct.member` or `structPtr-&gt;member`, but quality implementations like icc can also recognize some other access patterns like `useStructMember(&amp;someUnion.member)` in cases where all access to the union is performed through the passed pointer. Some other implementations like gcc and clang, however, are too primitive to handle such cases. 
RIP. Happy Birthday Dennis.
The name C refers to two diverging languages: one invented by Dennis Ritchie and described by the book "The C Programming Language, Second Edition", and the other described by the C17 Standard. The first language, with a few extensions, can be processed by most compilers when optimizations are disabled and features an abstract machine *that can do almost anything the execution environment allows it to do*. The second is similar, except that the wheels will fall off the abstract machine if it tries to do anything beyond what the authors of the Standard expected. Unfortunately, some people insist that only the second language is "really" C, and that code written in the first language is "broken". As a consequence, many optimizers are only compatible with the second language, which makes them unsuitable for tasks requiring the first. I'd suggest that the former language is not only suitable for many more purposes than the second--it's also a lot more fun. There are many kits available that combine a small ARM-based microcontroller, USB interface, and a bunch of pins to which one may attach lights, buzzers, speakers, servos, or just about anything else imaginable. Given such a kit and an evaluation version of Keil's evaluation compiler, you can write C programs that can make noises or flash lights in response to button pushes, and with additional experience you can advance to doing more sophisticated tasks. While one could write programs using the second (more limited) version of C, there's not really much that language can do that other languages can't do better. By contrast, the language described in K&amp;R2, with a few extensions, is uniquely suitable for many purposes where there aren't really any practical alternatives. 
Is minecraft too complex for 3 yos?
Well, you haven't given us much to go on here, but at a guess, `celsius` is declared as an integer or is being fed into something else that is narrowing it to an integer before you're seeing it output. The expression you're using to perform the conversion is correct as written and will evaluate to a floating-point value, not an integral value, but that doesn't matter if you're immediately converting it to an integer as I suspect you are.
Try raylib! Or perhaps vulkan with glfw
&gt;What am i gonna be able to do with c realistically? Anything that you can do with any other programming language. &gt;But whats the end goal? That's like asking what's the end goal of learning any programming language or its like asking what's the end goal of learning programming. You learn it so that you can write programs.
Probably depends on the 3yr old. I'm sure that, statistically speaking, boys are better at focusing and being goal-driven at something like MC, and then of course just the natural affinity due to genetics/environment/etc that may vary a kid's aptitude for FPS/survival/building games.
What makes you say that? I've seen no effort that the Standard made any particular effort to avoid characterizing as UB behaviors that could often be usefully supported at essentially zero cost on the vast majority of implementations, since they expected that implementations where such behaviors would be useful and cheap would support them *whether the Standard required to do so or not*. Instead, they wanted to avoid requiring that implementations behave consistently in a particular situation if there might exist any implementations where that might be impractical. As evidence of that, consider the effect of left-shifting a negative number. C89 usefully defined the behavior as equivalent to multiplication on a two's-complement machine whose integer types have no padding bits, in cases where repeated multiplication by 2 would not overflow. The way behavior was defined was less than ideal on other machines. C99 changed the behavior to undefined on all machines, including those where the behavior had been defined usefully. The only way such action makes any sense would be if the Committee expected that implementations where the old behavior was useful would continue to act that way. The problem with making things like shifts wider than a word Implementation Defined is that the term is intended for actions which will behave consistently, but compilers might combine shifting operations in ways which would result in inconsistent behavior. For example, if `x` is signed, then given `(x &lt;&lt; 2) &gt;&gt; 33` it may be useful for a compiler to substitute `x &gt;&gt; 31`, but that wouldn't be allowed if the behavior of `x &gt;&gt; 33` was defined as equivalent to `x &gt;&gt; 1`. Perhaps an implementation could specify that when `y` is greater than 32, `x&gt;&gt;y` will yield either `x&gt;&gt;(y-1)&gt;&gt;1` or `x &gt;&gt; (y &amp; 31)`, chosen in Unspecified fashion, but that would be stretching the interpretation of what "Implementation Defined" is supposed to mean. What would be helpful, then, would be a category of behaviors which quality implementations are strongly encouraged to specify as precisely as practical, but are not required to specify in cases where doing so would be impractical. If some predefined macros were added to indicate how behaviors process certain actions (somewhat analogous to FLT_EVAL_METHOD) then those actions could be treated as defined within code that tests such macros and confirms that the implementations guarantee to treat them as required. Such code would then have defined behavior on all implementations, though behavior on implementations that don't support the behaviors would defined as failing with `#error This code requires a higher-quality dialect than this compiler is configured to handle`. In any case, the notion that behaviors were only characterized as UB after long and careful consideration is inconsistent with the evidence. 
&gt; The standard says it is undefined behaviour. The implementation (compiler, device, phase-of-moon, the whole shebang) is not required to have any predictable or consistent behaviour. I haven't checked all the working group's documentation to confirm it, but I would not surprised this is to permit implementations to perform optimisations. If the Standard says something invokes Undefined Behavior, that means that the Standard does not require implementations do anything as a condition of conformance. It says nothing about whether *quality* implementations intended to be *suitable for various purposes* might be required to behave in a particular way *in order to most usefully serve those purposes*. According to the published Rationale, the authors expected that commonplace implementations would process operations on signed and unsigned types identically in constructs where all defined behaviors were identical, even in cases which involve values beyond the range of the signed type. They expected that commonplace implementation would process something like `uint1 = ushort1*ushort2;` in a way that would yield arithmetically-correct results for values up to UINT_MAX without needing special rules to prevent the short unsigned types from being converted to signed types in those situations, and cite that expectation as a reason to simply have short types promote to signed types regardless of context. If even the authors of the Standard have expectations about how compilers will behave in cases where they impose no requirements, why should programmers not be entitled to similar expectations?
Well, he Thompson was responsible for Unix and Kernighan is definitely remembered I'd say, although he is mostly known for writing great books etc. about all that.
Uhm, C is pretty much completely backwards-compatible, and even if they weren't -- there's no diversion, merely a succession you do not approve of. "Modern" C just added some more things but is still handling an abstract machine model, doesn't require `CHAR_BIT` to be 8, doesn't require pointers to be addresses, doesn't require`NULL` to have the numeric value of zero (just a comparison must be true), etc. K&amp;R2 or ANSI/C89 is not that different from any newer C. They added some stuff to the libc, some useless stuff, some useful. But that's the library, if this doesn't work on your platform, you just don't choose to use it.
If you have enough EEPROM, store two copies of your data structure along with a three bytes indicating which one is current. If you have enough RAM, load the current copy into RAM on startup and set a "dirty" flag any time anything changes. Periodically check the dirty flag and, if it has changed, store your data structure over the non-current copy in flash, and then update the "current copy" bytes using three separate update operations. Using three separate writes for the "current copy indicator" bytes will help protect against problems if the EEPROM loses power while it's writing one of those bytes. While it may seem like it would be a good idea to try to avoid writing parts of the EEPROM that already contain correct data, doing so safely would require a bit of extra work. If an EEPROM loses power while writing a byte, it's possible that reading that byte might sometimes yield the value written and sometimes yield something else. If power was lost while writing the non-current record, code that tries to write the record at a later time might decide it doesn't need to write a byte that seemed to already have correct data, but a later read of that byte might yield an erroneous value. If code had rewritten that byte even though it didn't seem to need it, the data would have been written properly.
The programmer who wrote the standard library defined what to do together with the one who wrote the kernel. There is someone who decided that stdin is a file. A system architect probably... So the one who wrote the standard library wrote printf to write on this file. In the OS this file is mapped to the memory area corresponding to the console. In the end it has just to form a string and copy each character on the video output address.
What system calls are used by what C library functions is determined by whoever wrote the C standard library in question. There are many implementations of the C standard library - some are specific to certain OSes (musl); some are portable to many OSes (glibc, newlib) and have different implementations for each of them, usually in a "glue" layer that connects the rest of the libc to the underlying system. Maybe it would help you to see a complete example with a toy operating system. Let's look at a simple [Hello World](https://github.com/klange/toaru-nih/blob/master/apps/hello.c#L11) - it calls `puts("Hello, World");`. `puts` is defined [in the operating system's implementation of the C standard library](https://github.com/klange/toaru-nih/blob/master/libc/stdio/puts.c) and in this case calls `fwrite`. `fwrite`, meanwhile, is also [part of the C standard library](https://github.com/klange/toaru-nih/blob/master/libc/stdio/stdio.c#L307) (and would normally implement an output buffer that only writes when it's full or a linefeed character is reached, but bear with me, this is a toy implementation of libc), and this is where we get to the real meat: this implementation of the `stdio` interface calls an underlying `write` system call. That system call function `syscall_write` is [defined in yet another part of the libc](https://github.com/klange/toaru-nih/blob/master/libc/unistd/write.c#L4) through a macro that implements the architecture-specific system call interface, [a call to `int 7Fh` with arguments passed as various registers in this case](https://github.com/klange/toaru-nih/blob/master/base/usr/include/syscall.h#L35).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [klange/toaru-nih/.../**hello.c#L11** (master ‚Üí 6074363)](https://github.com/klange/toaru-nih/blob/607436348475f04f72195f197920347ce6570cfa/apps/hello.c#L11) * [klange/toaru-nih/.../**write.c#L4** (master ‚Üí 6074363)](https://github.com/klange/toaru-nih/blob/607436348475f04f72195f197920347ce6570cfa/libc/unistd/write.c#L4) * [klange/toaru-nih/.../**stdio.c#L307** (master ‚Üí 6074363)](https://github.com/klange/toaru-nih/blob/607436348475f04f72195f197920347ce6570cfa/libc/stdio/stdio.c#L307) * [klange/toaru-nih/.../**syscall.h#L35** (master ‚Üí 6074363)](https://github.com/klange/toaru-nih/blob/607436348475f04f72195f197920347ce6570cfa/base/usr/include/syscall.h#L35) * [klange/toaru-nih/.../**puts.c** (master ‚Üí 6074363)](https://github.com/klange/toaru-nih/blob/607436348475f04f72195f197920347ce6570cfa/libc/stdio/puts.c) ---- 
The C library does not intercept the call, the call goes into the C library. There is no interception going on. The use of system calls is an implementation detail and every implementation of the C language is free to use system calls as needed to implement its functionality.
`printf` writes to `stdout`, not `stdin`.
A couple of differences are that K&amp;R2 says that integer overflow generally wraps, except when targeting platforms where it doesn't, while "modern" C says that integer overflow can negate the laws of time and causality. More significantly, K&amp;R2 describes a two-way relationship between the values of objects in the abstract machine whose addresses are known to a program, and the values stored in sequences of bytes starting at those addresses, without adding an extra "effective type" layer on top. 
That's true, but usually you can work around such issues quite well afaik, so that trade-off was deemed acceptable.
I know that my 8yo girl cousins love building houses. That's what most girls I know do in minecraft. PvP is mostly done by boys 
Like the difference between airplanes and bicycles 
Also Peter J Weinberger who is mainly known for his work on `awk` and his face.
Douglas McIlroy, the man behind UNIX pipes and coroutines in general.
Yea, my 7yr daughter is constantly showing me her little well-planned constructions. I'm pretty sure that's all my 3yr old wanted to do too, which is why I thought Craft would've been fine for her, but it just was too limited with lack of config settings to make it run smoother on the little netbook I let her use and then the view perpetually scrolling upwards glitch wasn't helping either. Freeminer is a much more accurate Minecraft depiction, but I admire Craft's C engine because that's the kind of thing I've been doing for 2 decades.
Please post your complete code and format it correctly by indenting every line of code with four spaces and putting a blank line between code and surrounding text.
Fixed!
Also agreed this looks much better 
I like this approach. It's how Python implements many of it's data types. 
I hope this helps you.
Hey, please don't delete your post after receiving an answer! That's really not cool! How are future readers with the same problem supposed to receive help from this post if you deleted it? Don't do that!
It's called Latin of the programming languages because you get one character or pointer index wrong and you may summon an ancient daemon by accident. 
The end goal for me turned out to be that once I understood C (and C++), I grasped the reasoning behind many choices that have been made historically by a lot of other software. 
...or on purpose. Try that with Java.
Sure, there are tradeoffs, one is not better than the other, the right tool should be chosen for the job. One needs to be aware that while fire is infinitely useful it's also hot.
&gt; ... it's C++ This subreddit "r/C_programming". Please refer to r/cpp
I'm actually impressed at how low effort this post is. ü§£ It's common to see C++ questions in here, but this is literally just a _screenshot of a pdf from your phone!_
Better post /r/cpp_questions. A post like this will just get deleted from /r/cpp. 
I think I'm going to start collecting these, so when we have that discussion about whether or not we should have homework allowed, we have some examples :)
Let's take 7 one step further: int (*foo(void))[10] { static int arr_10[10]; return &amp;arr_10; }
As you've already heard, C is the *lingua franca* of the majority of modern computing, as virtually all hardware is designed to work specifically with it and the majority of programming languages descend from or are heavily influenced by it. Modern computers are byte-addressable and designed for C's finite stacks and row-major array accesses and so forth. But forget that for a moment. Unix and Linux are written in C. Can have apps and libraries in any language, but inherently they're C. Unix, Linux, and the standard C library implement "POSIX", which is more or less a brand and trademark-agnostic way to say Unix. NT's kernel `ntoskrnl.exe` was mostly C for at least two decades, but Microsoft might be moving it to "C with classes" now to better suit their in-house toolchains, as they still think adding object-oriented programming to C was a pretty neat idea. Up to and including [Petzold's Fifth Edition](http://www.charlespetzold.com/pw5/), C was still the favored method to control the quirky Win32 API. When we want to write programs with high efficiency, high speed, and low resource usage, we most often reach for C. Not only the kernel and shell you're using were written in C, but most front-end and static-resource web servers, the majority of web proxies, and the libraries used even by web applications written in non-C languages. Write a library once in C, and it's fast when used from any language. The C ABI is simple, stable, entirely predictable, and easy to debug, so every language can access the C ABI with one of its "Foreign Function Interfaces", or FFIs. Sometimes those languages can also access non-C languages, but they can always access C. Where isn't C the *lingua franca* today? Traditional mainframe operating systems, architectures with non-octet byte sizes (which are also inevitably mainframes, today), microcontrollers with word size below 16 bits, and [the odd bit of hardware designed as a stack machine for Forth](http://www.excamera.com/sphinx/fpga-j1.html). Whereas C is the systems language on all Unixes, on most mainframes still in use it's assembly or PL/I. On Burroughs-descended MCP it's presumably still their versions of ALGOL, but that's a 48-bit high-level language architecture that doesn't have opcodes or an assembly, like a Lisp Machine. 
&gt; My professor always said "python and java solve today's problems. C solves tomorrow's problem". That can be read several different ways, but I think it's safe to say that your professor was saying that the most efficient solution wins over time, even if rapid prototyping was useful initially. But there's also the fact that computers have mostly stopped getting faster. Circa 2000, it was popular in programming circles to point out that skilled programmer time was more valuable than computer time, because after all, in a year or two the computers would all be twice as fast. Microsoft couldn't have succeeded with the inefficiency of VB, C++ and Windows in the 1990s if hardware didn't improve so rapidly and new and previous customers didn't buy that hardware so readily. 
&gt; you may summon an ancient daemon by accident. My nose hurts already. No wonder wizards are subtle and quick to anger. 
The short answer is that you almost never want to do this. In the vast majority of cases, you should simply make your program multi-threaded and let the OS do its job. If you are new to multi-threaded programming, just don't mess with affinity at all. In situations where doing this is actually a good idea, the reasons are generally complicated and very program/domain specific, so the only general answer is "it depends".
Swift is a descendant of Objective-C, and I think has C++ influence, which is all descended from C. They're removing some C syntax when I last checked in on them, though. Python is influenced by C in the same way that PHP was (and both are implemented in C), but it's superficially less C-like because it doesn't use C's freeform syntax with brackets, but uses whitespace to mean things instead. I expect Python to be less C-like than is Swift. 
A tagged union hasn't been mentioned. That would seem to meet most definitions of "any datatype", depending what you plan to do with it. 
Video game engine 
When I look at the example for 7 it doesn't compile? Does anyone know the correct compiler or flags to use? It actually sounds like a pretty useful feature, if you're in to very specifc typing of variables.
Line 15 explicitly won't compile, since a pointer to an array of 11 items isn't the same thing as a pointer to an array of 10 items. That's a feature, not a bug.
It was a lapsus
The standard output is buffered. Add `fflush(stdout);` at any point where you want to be sure that everything you've printed so far has actually been displayed.
Show your code.
The Return Sequel and JFK Prequel 
also they could add a `\n`, assuming they don't mind the input appearing on the next line
 vector&lt;string&gt; GetWordVector(ifstream, string); streams can't be copied. Pass it by reference. Relevant piece of error : `error: ‚Äòstd::ios_base::ios_base(const std::ios_base&amp;)‚Äô is private`
This subreddit is for C, not C++; you can try asking in /r/cpp_questions but you should also put your code somewhere or at least put four spaces in front of it so it renders as a code block on reddit.
Is your array dynamically resized (with realloc), or is it statically allocated with a fixed upper bound on the size? If it's statically allocated, you just decrement the "size" variable. If it's dynamically allocated, you have a bit more work on your hands, possibly. Depending on exactly you have the rest of the code set up, you might have to shift the elements down (e.g., using a memmove) and then realloc() to shrink the array.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
I use libcurl in my production indie wares. Thanks.
Assuming `stdout` is line-buffered. I don't remember if either C or POSIX guarantees that.
My favourite is #8: Static array size modifier (is that the canon term?). It's really useful to signal how large an array-argument needs to be, even if it's just documentation when passing a pointer.
curl is the swiss army knife of moving packets from place to place. 
I'm sure that there are. But, a good college level textbook on computer architecture might be just as useful. Something used in a CS Engineering or EE curriculum for a mid-level course. Many years ago my Computer Architecture and Machine Programming courses (which I may have taken in the same semester) helped me immensely with a deep understanding of how C turns into machine code and how that machine code behaves on the hardware.
A book on (efficient) algorithms and data structures that uses C for examples might cover *some* of the architectural concerns. C is relatively tiny though, I would spend a couple days learning it first before diving into architecture. For instance, the intuition behind pointers is huge when it comes to understanding memory addressing schemes. Besides, many architecture books are rightfully language agnostic. My suggestion would be *The C Programming Language* by K&amp;R, followed by *Computer Architecture: A quantitative approach" by Hennessy and Patterson.
Advanced programming in the unix environment is what you want.
when you go "low level" you want to read up on a particular architecture/CPU instead that happens to use C examples
C targets an virtual memory system and instruction set architecture (ISA). It's an abstraction over the hardware implementation of the ISA. Those worlds are just different, and you'll gain a better understanding if you just study them separately. for computer architecture, I've found two books to be most helpful. https://www.amazon.com/Digital-Design-Computer-Architecture-Harris-ebook/dp/B00HEHG7W2 https://www.amazon.com/Structured-Computer-Organization-Andrew-Tanenbaum/dp/0132916525/ref=sr_1_1?ie=UTF8&amp;qid=1536687062&amp;sr=8-1&amp;keywords=tanenbaum+computer+architecture&amp;dpID=41B7uYANs%252BL&amp;preST=_SX218_BO1,204,203,200_QL40_&amp;dpSrc=srch
My 2 cents: you might do well to play with writing C for an MCU, which doesn't abstract away the machine and whatnot the way a desktop machine will.
https://en.wikipedia.org/wiki/Lions%27_Commentary_on_UNIX_6th_Edition,_with_Source_Code
this is made in C https://www.youtube.com/watch?v=tScCneiTGm4 https://www.michaelfogleman.com/projects/craft/ this is made in C https://store.steampowered.com/app/697550/It_Lurks_Below/ 
It doesn't precisely teach C, but I think my favourite textbook ever might be what you're looking for: [Computer Systems: A Programmer's Perspective](https://www.amazon.com/Bryant-Computer-Systems_3-Randal/dp/013409266X) 
"Computer systems from a programmer's perspective" is really good.
When in doubt, check [the man page](https://linux.die.net/man/3/ferror): &gt; These functions should not fail and do not set the external variable errno. (However, in case fileno() detects that its argument is not a valid stream, it must return -1 and set errno to EBADF.) The non-standard [`explain_ferror`](https://linux.die.net/man/3/explain_ferror) function might help you, though.
There is a lot of c baked into this one, and if you get stuck you can just look up a tutorial.
Get an Arduino or Raspberry Pi and do something with it. Make some indicator LEDs flash for instance - sure it's silly, but you'll have to learn a lot to do even that. I'm an ancient C guy, have always felt that understanding assembly level as well as what the output from a C compiler looks like are hugely beneficial to *understanding what's going on*. Later maybe write your own implementation of malloc and free; not 'necessary' but highly educational (guess how I know?)
yeah you gotta declare as float for it to return a float
No, the title doesn't say it all. You need to provide an example of what you're talking about, because it's pretty much ambiguous at this point.
Gah. No. I mean the Lions book is awesome. But you need something a bit more expository if you're going to actually learn what's going on and why. 
Oh, I'm not allowed to post anything regarding the project. I figured this would be a common issue. Okay, so I'm trying to allocate memory and dereference the pointers corresponding with a struct. In a function I already allocated memory for the struct, which I am pointing to but I don't know if its necessary to do this for the specific poitners that are pointing to memory addresses.
code please
If you‚Äôre allocating memory for a struct from a function, malloc will only make room for the struct‚Äôs members and given you a pointer to that memory (myptr), which is almost always going to be stored in an automatic variable. struct mystruct *myptr = (struct mystruct *)malloc(sizeof(struct mystruct));
I suspect the answer is "yes", but an example would really help. 
*anymore
https://en.wikipedia.org/wiki/Code:_The_Hidden_Language_of_Computer_Hardware_and_Software ?
People rave about it but I've never read it. It keeps getting bumped down in my queue.
Nope. I'm not allowed to post code for this assignment otherwise it's considered cheating. I'm good, I just wanted to talk about concepts.
Again, ideally I'd like to post code but it is considered academic dishonesty so I'd rather just discuss things conceptually. 
"Write Great Code: Vol 1: Understanding the Machine" -- Randal Hyde It gets into the nitty gritty of numeric representation for both ints and floats, binary arithmetic, bit operations, memory organization and access, composite data types, CPU architecture and ISAs. Examples are a mix of C and x86 assembly, although it's lessons are easily applied to any architecture or language.
pls provide code
Agreed. Learning to program the hardware directly is an *excellent* gateway into learning what the compiler is doing under the hood.
some might argue that if you can't provide analogous code i.e. struct myStruct { int foo; int \*bar}; you should learn how to
Post made up code that captures the problem. I can't believe that would be any more dishonest than your basic question. Anyway if you have a struct with, say, a couple of char * pointers in it, and you allocate memory for the struct, you separately have to allocate the memory for the char * pointers to point to.
that's fair ^^ I will do that in the future
The canonical C book is pretty good for this. If you want to learn about lower-level stuff, I'd recommend a book on Assembly. My personal favorite is *PC &amp; XT Assembly Language: A Guide for Programmers* by Leo J. Scanlon.
If you are not allowed to post code of the project, make an example that illustrates your problem but is unrelated to your project.
you never did. 
yeah, I meant returning an address to a local static not the ptr to array
I think malloc returned chars at some point.
So I need the RGB led to cycle through 512 colors. I was creating 3 vectors that take the 512 colors and evenly distribute them (512/3 = 170.666) and so for each color vec. create 171 diff values evenly spaced. Then in the next set of for loops, it supposed to iterate through the color vecs and assign them to the duty vect, which should be assigned to the RGB led and change the color
I already understood what I needed clarified so I'm good for now. I will keep that in mind for the future though! Thanks!
Yup, this book is great and is the closest to what OP is looking for.
*From NAND to Tetris* is a great followup to Code.
in OPs defense that's only a problem for 3-170
i learn c since 6 month and this is the book i was looking for. Awesome job Thx for sharing
I liked [Introduction to Computing Systems: From Bits &amp; Gates to C &amp; Beyond](https://amazon.com/Introduction-Computing-Systems-Gates-Beyond/dp/0072467509) It does start out at the low level, and uses a made up Instruction Set Architecture, the LC3 (or LC2 in older editions). Simulators are available so you can actually run code for this machine.
The free book [Programming from the Ground Up](https://download-mirror.savannah.gnu.org/releases/pgubook/ProgrammingGroundUp-1-0-booksize.pdf) - not exclusively C
[removed]
ELEMENTS value is undefined at the beginning, so you shouldn't be using it for an array size until after it's value is defined.
ELEMENTS value is undefined at the point where you defined the array size, so the array size itself is effectively random/undefined.
Yeah, I was thinking about this. But I thought all of the variables had to be declared at the top of the method? How is the user supposed to specify the size of the array in that case?
&gt;I thought all of the variables had to be declared at the top of the method Variables can be declared where ever they make sense. You should only make a static array when the size is known. If you were to use a dynamic array, you *could* declare it at the beginning and allocate the memory for it later once it is needed.
Thanks, this was the issue.
Computer Systems: A Programmer's Perspective (3rd) (CSAPP) and K&amp;R beforehand was what I went for. The latter is only about 100 pages or so, but CSAPP is closer to a dense thousand. CSAPP was assigned by my University, and has a lot of projects in it that are pretty common in University CS systems classes. It definitely opened my head to a lot of concepts that I still use.
I got you bb
Some book recommendations: * [21st Century C]( https://www.amazon.com/21st-Century-Tips-New-School/dp/1491903899/) * [C Programming: A Modern Approach](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504/) * [Understanding and Using C Pointers](https://www.amazon.com/Understanding-Using-Pointers-Techniques-Management/dp/1449344186/) * [Assembly Programming and Computer Architecture for Software Engineers](https://www.amazon.com/gp/product/1943153329/) I got each of these books mostly for learning modern C and assembly practices. Obviously the assembly one covers a lot on lower-level concepts than C, but the C books themselves cover a decent amount of that too.
This is great. Thank you very much!
Bonus: all the lecture videos are online (https://www.cs.cmu.edu/~213/). The fall semester videos will be up as the semester goes on but if you're feeling impatient look for videos from old semesters under sidebar -&gt; Resources.
KN Kings, C Programming: A Modern Approach was fantastic and really cleared up a lot when I was learning C. 
Hacking The Art of Exploitation by Jon Erickson (2nd Edition) https://nostarch.com/hacking2.htm
Since storage for array is allocated at the time of compilation, this wont work since ate that time the value of ELEMENTS will be undefined. Look into malloc().
har har har ... you did make me laugh a little. 
The compiler is free to resolve arguments to a function in any order. So, either of a, b, or c may he executed first. Now, since there are print statements in each function, either of 'a', 'b', or 'c' may be printed first. Note that this is still during the argument resolution stages, so the original print if isn't printing any values yet. Once a(), b(), and c() have all been resolved (to 1, 2. 3 respectively), then the original print if prints out 123 in that order. 
T1 can be of any single type. It can be a float. It can be an integer. It can be a struct. It can be a array of arrays of integers. But it cannot be multiple types at the same time for the most part, no. C does have what's called a union, which can store multiple variables of different types. But it cannot use those variables at the same time and its probably not what you're looking for. C does not have support for union of types, meaning that a variable must only take on one data type. There are workarounds such as casting if the items have the same storage size or by carefully using void pointers (void*), but I wouldn't advise it. At best, if you want to mimick say an array of (union Int float), I would create a struct with an array of each. 
WTF?
have a look at http://vendu.twodots.nl/wizardcode.html there is a pdf document which I found very useful 
Yes, that does it.
How can you create an array at runtime without malloc?
You would still need to use malloc(). Create a pointer at the beginning and then only use malloc once the size is known/derived. The only reason I mentioned doing it that way was because OP wants/was-told to have all variables and data objects declared at the beginning.
Oh I misunderstood you. I thought you were telling op that he shouldn‚Äôt do this using malloc. My bad.
For the second question: You're using the output specifier %d which prints the integer value of the character '7', that is 55 in ASCII. You should use %c in order to print '7'.
&gt; If I allocate a char array of 10 elements and initialize only 5 (like in the case above), what value do rest of the elements take? The other five are each initialized to '\0'. [C side of cppreference](https://en.cppreference.com/w/c/language/array_initialization#Initialization_from_brace-enclosed_lists), [C standard](http://port70.net/~nsz/c/c11/n1570.html#6.7.9p21) &gt; Where am I going wrong in my reasoning? You're going wrong with "So 7 is printed.". That would be true if you used %c, but you used %d, so 55 is printed. Try `printf("%d\n", '7');`
1. if you only provide initialisers for parts of an array, the rest of the array is initialised to zero. This does not apply if you omit the initialiser entirely. In this case, the entire array contains undefined values (automatic variables) or zeroes (static variables).
Thanks for the correction! Didn't remember that.
&gt; someone correct me if I'm wrong You're not wrong
\+1 for H&amp;P, great book. Depending on what all OP needs/wants it may also be worth looking into an OS text book like Tanenbaum's *Modern Operating Systems*.
One correction, it is not '5' + '2', it's '5' + 2. '5' + '2' = 'g'
[LMGTFY](https://www.google.de/search?q=c+read+binary+file)
What have you tried so far?
 snprintf(buffer, sizeof(buffer), "sshpass -p libreelec scp fluxus.txt root@%s:/storage/downloads/fluxus.txt", argv\[1\]); system(buffer); But there seems to be an issue with buffer, I am a python guy sry
I Think 500 but where do I exactly delcare it? &amp;#x200B;
clock.h isn't a standard header. Why do you think you need it? What are you expecting to be in it?
Well clock.h is not one of the standard header files, maybe you meant time.h? Either that or someone needs to provide that file
`char buffer[500] = {0};` Please be more specific. Give us any error messages or warnings your compiler produces. Maybe also paste the whole c file. What compiler are you using? Which options?
We're writing some loops and measuring the time in ms.
Definitely should use time.h. Check it out. http://pubs.opengroup.org/onlinepubs/7908799/xsh/time.h.html
Thanks! I will talk to my professor, maybe he got confused and told us clock.h
Also if you have a clock.h file, make sure it is in the same location as your main file and use #include‚Äùclock.h‚Äù this makes gcc find the file locally.
Chars initialized to characters are always positive. Signs of uninitialized chars are undefined. Here char will simply get cast into unsigned and since sizeof(unsigned) &gt; sizeof(char) nothing strange will ocur. Has it been otherwise, i.e. unsigned getting cast into char, some bits of the unsigned would become "lost" and the question of which bits depends on the endiannes of the system. Long story short, no compiler error if it's spec-compliant. Regarding the "firing" part, I don't care; do what you want.
Clearly I'm not on this sub enough to be aware of any sort of meta haha
Paraphrased from K&amp;R C v2 chapter 2.7: When an operator has operands of different types, they are converted to a common type according to a small number of rules. In general, the only automatic conversions are those that convert a "narrower" operand into a "wider" one without losing information, such as converting an integer to floating point in an expression ike f+ i. ... A char is just a small integer, so chars may be freely used in arithmetic expressions. This permits considerable flexibility in certain kinds of character transformations.
My advice is: stop what you're doing and learn the basics of C, because you're just going to constantly be frustrated if you keep trying to write C without understanding C. Python is a fantastic language and I strongly recommend it as a first language, but you can't just go straight from Python to C and expect to have an easy time. Python does basically all of the work for you. It abstracts the way that the computer actually works in order to make things easy so you can get shit done fast. C is basically the exact opposite of Python. What you see is what you get. You can look at C and tell pretty much exactly what the assembly is going to look like. You get to do everything by hand, but you also have to do everything by hand. Pick up a C programming book and learn what variables are, what the stack is, and how strings work.
You are right, find a python alternative
If I encrypt the message "Send three and fourpence. We are going to a dance." and your program decrypts it to "SEND THREE AND FOURPENCE. WE ARE GOING TO A DANCE." then case has not been preserved. Basically it means the decrypted plaintext must be identical to the original plaintext
 - Your connection routine leaves sockets open when it fails. - You should use snprintf(), and use its return value as an argument to send() instead of strlen()ing the buffer that sprintf might not have terminated
Small correction, '5' + 2 (no quotes) == '7', but '5' + '2' == 53+51==104 == 0x68 == 'h'.
Thanks man! I understand now. I do have another question though. Do you know how to shift each character in a string by 1 key? For example if you insert a string with ‚Äúabcde‚Äù should return ‚Äúbcdef‚Äù? I would like to know what the possibilities are. 
Well, chars are really just ints, if you increment each char in the string then you'll get the shifted string.
r/dadjokes ? 
What's a Pan Am flight?
An old airline
Will make the changes.
After 30+ years of programming in C, I've moved beyond the K&amp;R style, but it was succinct and beautiful.
Was it at a time when you could still smoke on flights?
Hahahaha!
It's a very common idiom. Most people don't realize it's reserved. I used to do it myself because early syntax-highlighting editors were based on simple tables and regexes, and giving a type a name that ended in `_t` ensured that it would be recognized as such by the editor.
&gt;What's dead may never die But rises again harder and stronger
I use Make for pretty much anything, small, simple and succint. However there are almost no good resources on how to write Makefiles *well*. The best Makefile is an empty one (or none).
&gt; Linux is not POSIX, maybe POSIX-ish Linux is a superset of a subset of POSIX. The combination of Linux, a GNU userland, and the GNU C and Fortran toolchains is a superset of most of POSIX, with some components (e.g. SCCS) intentionally left out.
&gt; Linux is a superset of a subset of POSIX. I.e. Linux is not POSIX, maybe POSIX-ish.
There aren't really that many alternatives: * Use type names like `frame` without any suffix, but you might run into collisions with variable names. And it makes the code harder to read because you can't immediately tell types and other identifiers apart. * Use UpperCamelCase for types. A good idea if you are already using lowerCamelCase for other identifiers, but it may look inconsistent if you use underscores otherwise. And some people don't like camelCase at all. * Avoid typedefs and use `struct frame`etc. everywhere. Often recommended but makes especially function prototypes take to much space, leading to ugly line breaks. * Use any other suffix than `_t`, but which? There isn't really any established alterative. So `_t` is often used even if POSIX reserves it. 
You beat me to it.
Thank you for this answer.
Just add one to every character in the letter.
&gt; The BSDs are much worse in that respect. Citation needed. As long as fundamental things like `pwrite` behave incorrectly on Linux with no will to repair this in sight, I don't think Linux is really interested in complying with POSIX.
Hey, **Some context for the code** A string is simply an array of characters with a null terminating character that is '\\0' as the last and a character is simply an integer number between 0 and 127. So each number is tied to a character. The characters and the numbers increase sequentially, that is A is 61, B is 62 and on and on for uppercase and a is 97 and b is 98 and on and on for lower case. [The rest can be found here](http://www.asciitable.com/) So incrementing each element of a string which is an array increments the number of the character which makes it shift to the next character. #include &lt;stdio.h&gt; int main() { int i; char s[] = "abcde"; for(i = 0; i &lt; 5; i++) s[i]++; printf("%s", s); return 0; } The control condition of the loop uses the number of characters involved. Using the ASCII table you can shift by 2, 3, ...so this part of the code becomes: `s[i] = s[i] + 2;`
Well okay, namespace pollution is a point. Do you mean with respect to feature-test-macros? Note that as far as I know, POSIX doesn't actually mandate that platform-specific functions are hidden by default, so FreeBSD is not wrong in this regard.
&gt; Pan Am Went to the great runway in the sky in 1991.
No, I mean symbols showing up in the application namespace when they're not supposed to be there (i.e. when the correct header has not been included). On the one hand, it breaks valid programs being ported *to* FreeBSD; on the other, it lets developers get away with leaving out required headers, which causes problems when porting *from* FreeBSD.
Yes, as much as I think, because I know what I think and I know the standard and I know Linux. Forcing POSIX is nothing that POSIX mandates not be needed, and you have to do that with Linux too, anyway. But even then, it's not compliant. Different BSDs are different, but GNU coreutils and libraries are most definitely not POSIX.
&gt; No, I mean symbols showing up in the application namespace when they're not supposed to be there (i.e. when the correct header has not been included). As far as I know, this is allowed. Implementations of POSIX are allowed to make arbitrary other identifiers visible when including POSIX headers. POSIX only mandates what identifiers must be visible, it does not say that others cannot be visible.
And to ask you one more thing: In `fun2`, where I pass the pointer, I print out `321` and not `32100000` because 0 (integer) is interpreted as `\0`, right?
This post inspired me to find my old K&amp;R book. It is signed by my boss and dated 2/14/1986. If memory serves he bought copies for all of the C developers on his team. Thanks for inspiring an old memory.
Yep, string are initialized with \0 in the end. Whenever a standar func in c encounters '\0' it will take it as the end of the string.
They bought us copies of K&amp;R because we all learned C together as a team in 1986 for a new project. The team came from a variety of backgrounds from COBOL to assembly. I feel quite lucky that the company I worked for chose C for the project. The skills I learned I 1986 are still in demand.
I was able to get clang to issue a warning by using \`-Weverything\` when compiling. &amp;#x200B; c.c:3:10: warning: no previous prototype for function 'foo' \[-Wmissing-prototypes\] unsigned foo (unsigned bar) \^ c.c:12:27: warning: implicit conversion changes signedness: 'char' to 'unsigned int' \[-Wsign-conversion\] unsigned retVal = foo(x); \~\~\~ \^ 2 warnings generated. &amp;#x200B;
So is that cross platform or what?
Ah, ha! Now just add `-Werror` and we finally have an error!
Still useful though. Few years back I had to write some monitoring daemons and the only thing that would work was good old K&amp;R. When I showed the code to the vendor they just started at me ... then the offers for the code started :)
I do similar things with perl scripts that scan source files and output a C file that gets included where needed.
Your post got caught in our spam filter. I apologize for the inconvenience.
&gt;I work in the real world which needs real solutions and software So... SDL it is, then?
&gt;The problem is that, if you want to truly work with a framebuffer at a low level, it's necessarily really unportable. Shouldn't the opposite be true? It's certainly more portable than using a hardware-acelerated API. All you'd have to do to port to a new platform is find out how to put an image on the screen, upload your pixel data to that image and you're done.
The only thing SDL does is abstract a few slightly annoying boilerplate pieces like window creation and sending an array to the screen. Everything else (like the entire rendering pipeline) is up to you.
Why are you calling SDL not low-level when you're writing things like `XSetForeground, XDrawPoint, XSetLineAttributes`? I don't remember having access to fancy background and line drawing when writing my software renderer, only a single chunk of pixel memory. The only thing low-level about your code is the set-up; after that it's actually pretty high-level. If OP was to use SDL, he could skip the boiler plate and get straight to the real low-level renderer stuff.
Not sure if this is ideal, but I've seen people adding special symbols right before their function names and they wrote special tools to process them. These symbols were #define'd to expand to nothing 
My copy got water damaged so I got another one on Ebay. It had a concert ticket stub from the early 90's in it.
Did you try the Cmake tutorial? [https://cmake.org/cmake-tutorial/](https://cmake.org/cmake-tutorial/) Try this short tutorial [http://derekmolloy.ie/hello-world-introductions-to-cmake/](http://derekmolloy.ie/hello-world-introductions-to-cmake/) for intro. Then go through CMake's tutorial page. &amp;#x200B; What exactly are you expecting in terms of a build system? How much documentation are you okay going through? 
Any reason people couldn't use `_T` ?
https://www.cs.usfca.edu/~galles/visualization/HeapSort.html This will probably help you visualize the ‚Äúpopping off.‚Äù I believe the popping off you‚Äôre referring too is reducing the heap size after the shuffle operation. Reducing the heap size is shown visually in the graphic by the grayed out boxes after each shuffle. As a tip: Heaps are difficult to wrap your head around without first understanding 1. Binary Search Trees 2. Selection Sort Make sure to study these first. Also if you‚Äôre having difficulty with an algorithm question then sometimes it‚Äôs always best to just do a test case on paper and follow the algorithm! Where can you find the exact algorithm written out? We‚Äôll code is exactly that, and most algorithms for most languages can be found on Rosetta Code. Hope this helps a bit.
https://en.m.wikipedia.org/wiki/ASCII https://en.m.wikipedia.org/wiki/UTF-8 For some context to ASCII and it‚Äôs successor
maybe you can do an script with regex to find the function prototypes?
Nice explanation and tests,thanks !!!!
Provide code or you are just hand waving.
I'm not sure what you're asking. The programs shown should be portable, but I ran everything on Linux with GCC.
On what architecture?
x86
Exactly. In order to look at CPU cache and memory sub-systems one much look at various CPU types and that means IBM Power9 and Oracle SPARC and ARM and ye old PowerPC and then amazing new RISC-V and IBM AS/400 and DEC Alpha and maybe many others. Otherwise it is just a look at "personal computers" and not actual computers.
&gt; That's true, but usually you can work around such issues quite well afaik, so that trade-off was deemed acceptable. So far as I can tell, there has never been any clear consensus as to what the rules are supposed to mean in many corner cases. If programmers and compiler writers think that their interpretation of the rules would represent an acceptable trade-off, but their interpretations are incompatible, I'm not sure who can really be said to have deemed the trade-off "acceptable". 
Can I get your thoughts on "Computer Organization And Design 5th Edition". It's also by Hennessy and Patterson.
nope .. just a 40 line sample posted here for everyone to see .. that would be fine.
SDL_Init(SDL_INIT_VIDEO); SDL_Window* window = SDL_CreateWindow("SDL", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 320, 240, SDL_WINDOW_SHOWN); SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC); SDL_Texture* texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBX8888, SDL_TEXTUREACCESS_STREAMING, 320, 240); uint32_t* screen; int pitch = 320*4; SDL_LockTexture(texture, NULL, screen, &amp;pitch); SDL_UnlockTexture(texture); /* software render however you like */ SDL_RenderClear(renderer); SDL_RenderCopy(renderer, texture, NULL, NULL); SDL_RenderPresent(renderer);
Well, taking the Overflow-Wrapping issue as an example, the programmer could look into the documentation of the hardware in the rare cases where it doesn't wrap and simply take precautions. I don't see the problem of "what should happen" here, it's pretty clearly specified in the documentation of the chip.
I wish I could speak German, that would be very cool, lol. thanks a ton sir! you were very helpful ^_^
Is this used anywhere? I think this would be confusing because upper case is usually reserved for preprocessor names and enum constants. I think I have seen `_type` (e.g. `frame_type`) occasionally.
Yeah, I did take the Cmake tutorial, that's what got me started with Cmake. Nothing fancy, check for dependency, perhaps download them, compile my source code, put it in a directory that I specify, run tests. I believe Cmake could do all of that, but I'm kind of frustrated (you know those times where you just don't get it and you feel you're incompetent), and I don't mind going through the documentation, as long as they're meaningful, lol. thank you for you time ^_^
I was just going to explain how`0` and `'\0'` are the same in a few senteces, but then I kinda forgot to stop typing. So now I guess you have a really nerdy thing to hang on the inside of your toilet door. I hope this helps! --- `0` and `'\0'` are identical. Remember how `'x'` produces (or "yields") the ASCII character value for `x`? There are some special characters in the [ASCII table](http://www.asciitable.com/) that are untypable, as shown by the whole first column on that page. We still want to use those untypable characters in our programs though, so programming language designers came up with a clever solution to type them in code: Escape sequences. Escape sequences are those things you type between the `'` or `"` symbols, beginning with a backslash. Here are a few examples: `\t`, `\n`, `\r`. They work just like the "normal" characters like `'x'` or `'5'`, in that they produce the character value for the corresponding ASCII character. So for example, `\t` is the escape sequence for the "horizontal tab" ASCII character (= 9), or `\n` is a line feed (= 10). Now here's the fun thing: `\0`. An escape sequence with a number. Funky. You can also do this: `\3`. In fact, you can put up to three digits in there: `\123`. So what the heck are those things? Which ASCII characters do these correspond to? Well, these special number escape sequences are kind of the opposite of `'\t'`, `'\n'`, `'5'` etc.: They don't give you the character value for the character, *you* give the character value. Imagine you're thinking: "I need my program to write this string of characters, where the third character is the value 17, for whatever reason." Like `puts("AB?DE");` where `?` is supposed to be character 17. Character 17 is "device control 1", by the way. How the heck do we place that thing at the questionmark? Do you know how to type *device control 1* in code? I don't see it on my keyboard anywhere. Do you know the "normal" escape sequence for it (like `\t`)? Does it even have one? I don't know man. Hey I know, let's just make use of the number escape sequence and type it in directly: `puts("AB\21DE");`. This prints the characters A (65), B (66), device control 1 (17), D (68) and E (69). Hooray, the program works! Hey wait, why did we write `\21` and not `\17`? That 21 we've written *is* 17. Literally. What I've been calling "number escape sequence" is actually called "octal escape sequence". You give it the character value, but you notate it in octal (base 8). Decimal 17 is octal 21.
Makes sense
See this clang pr, https://reviews.llvm.org/D40225 &gt; This patch adds these flags and updates STDC_VERSION based on the C17 FDIS. Note that C17 is going out for balloting in December. I spoke with the GCC maintainer for the flags about what they will do when C17 is published in 2018 and their plan is to add c18, iso9899:2018, and gnu18. I will add the additional flags to Clang when the C17 ballot succeeds.
It was called C17 as it was originally expected to be finished in 2017, but it wasn't finished until 2018 so the name was updated to C18
I think I shall call it C17 too, then. &gt; The C17 and C18 are both just unofficial names What is the official name? Do you mean "ISO/IEC 9899:2018", or perhaps "ISO/IEC 9899:2017"?
C17 is male, C18 is female. How hard can that be?
Hehe, I don't quite get it, but I think I like it. :-)
I speak German, mind sharing the presentation? Thanks
Well if by a sweep they mean that they performed the `extract-min` operation, the array would look like this: 2 6 5 10 8 9 7 1 but we're performing *descending* heapsort and I don't know how it plays together with minheap. Could you please clarify this? Thanks in advance!
Nope. C17 is minor, C18 is major!
I love that key! 
Well officially, it is "ISO/IEC 9899:2018", so calling it C18 makes sense too. This happened before with *ISO/IEC 9899/AMD1:1995*. It specified `__STDC_VERSION__ ` as 199409L, but was published in 1995, and became inofficially known as *C95*.
Whoa, I had never even heard of C95. I can't find it in the [GCC options](https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options). Is it somehow not one of the normal C versions?
Your post is very garbled. Note that reddit accepts a different flavour of markdown than github, so please fix your post.
I love cache topics - it is one of my favorite arguments against brainless OOP. If you are interested checkout famous Mike Acton [https://www.youtube.com/watch?v=rX0ItVEVjHc](https://www.youtube.com/watch?v=rX0ItVEVjHc) note at CPP conference. Here is small prove of concept for filling 100% cache line from above vid I did on x86 [https://github.com/t4th/tools/tree/master/batch-calculator-example](https://github.com/t4th/tools/tree/master/batch-calculator-example) And this is only small change in code for almost 2.5x performance gain! 
Sure, here's the presentation and the handout (also about git): https://github.com/LeonardKoenig/c_kurs_folien/blob/master/6.1-make.pdf https://github.com/LeonardKoenig/c_kurs_folien/blob/master/6.x-mod-make-git_handout.pdf To anyone later reading this: I just pushed them into the repo for lack of more time, back then, so they might vanish there and be reupped somewhere else. If you find them 404-ing, just comment here / ping me again, in case I forgot to update these links.
You're talking about the language defined by Dennis Ritchie, and described in K&amp;R2. Some compiler writers these days are more interested in the language defined by the Standard, where overflow is not constrained by the effects of time and causality, and where an overflow in a function like `uint32_t mul(uint16_t x, uint16_t y) { return x*y; }` can cause unpredictable side-effects on the calling code. For example, given: #include &lt;stdint.h&gt; uint32_t count; uint32_t sum(uint16_t x, uint16_t y); uint32_t sum65535(uint16_t x) { return sum(x,65535); } uint32_t mul(uint16_t x, uint16_t y) { return x*y; } uint32_t sum(uint16_t x, uint16_t y) { uint32_t tot = 0; x |= 32768; for (int i=32768; i&lt;=x; i++) { count++; tot+=mul(i,y); } return tot; } GCC's generated code for `sum` will ignore the value of `x`, and unconditionally increment `count` by one unconditionally and return 2147450880. Nothing in the Standard would forbid such behavior, but I don't think anything in K&amp;R2 suggested that it should be expected from platforms without weird integer overflow hardware. Incidentally, the rationale for the C Standard says how *the authors of the C Standard* expected that most current implementations would handle a function like `mul`, and gcc's behavior--while permissible--violates the expectations underlying the decision to make short unsigned types promote to signed `int`. Personally, I don't think there's anything wrong with having compilers sometimes behave as though signed integer arithmetic yields arithmetically-correct results even when that would exceed the type range, allowing e.g. `x*45/15` to be optimized to `x*3` without worrying about whether that might eliminate wrapping effects in cases where x*45 would overflow. IMHO, if a programmer explicitly *wants* the overflow wrapping effects, a quality implementation should yield them if the code is written as (int)(x*45)/15, but should have some flexibility in the absence of the cast. On the other hand, the language processed by gcc without optimizations disabled, code must prevent overflows at cost *even in situations where the result wouldn't matter*. 
First, I wasn't sure what you meant and researched also your older comment here: https://www.reddit.com/r/programming/comments/9el8uv/future_directions_for_optimizing_compilers/e5sakxe/ So you're saying that GCC, on O3, decides that on the iteration 1 the multiplication overflows and thus this'd trigger UB, deciding to optimize the loop away and only incrementing and multiplying once (iteration 0) and no more (btw. GCC warns me about aggressive-loop-optimizations here).
No problem. I understand it might be difficult. Just put the initial effort in it. It will be worth it. If you have questions about cmake, feel free to ask on r/cmake r/learnprogramming or r/askprogramming. If you want a fun challenge for yourself, try using bitbake from Yocto/OpenEmbedded project as a build tool. (Yocto project is used for creating custom embedded Linux distro images. It uses bitbake as a task execution engine) :) 
Since your question is focusing on algorithms I focus my answer on that subject. For writing efficient algorithms it is crucial to understand complexity and why it is so much worse to write (for example) an sorting algorithm which uses quadratic running time instead of logarithmic running time. The other part are data structures. Here it‚Äôs important to understand why it‚Äôs way faster to use some data structure over another.( and also when to use which data structure). I would suggest to look up books and stuff in the internet (there is plenty) which focus on algorithms. Maybe start which the most famous example of sorting a list ;) Also it is helpful to understand how the big O notation and friends work. Even it is a little theoretical painful in the beginning. It is important to understand its implications for comparison. Also do not focus on optimizing low Level Code and Memory management and stuff like that. Trust you compiler he can do that way better than you and the gain is negligible. 
It is not really hard to write efficient code, it is just really hard to write optimal code, i.e. code which cannot be made any faster. This is because for optimal performance you typically have to make your program less structured and employ uggly hacks. This is usually just not worth it. For matrix multiplication and linear algebra, use a blas (basic linear algebra subprograms) library. These contain fine-tuned implementations of the basic algorithms with excellent performance.
Yes
Danke! Will check them out later :)
Just like C89 vs. C90.
And the OP could read the blas source to learn about optimizing C. 
Write code that is clear and concise, and then measure how it runs. Use perf on Linux and you can measure how different ways of using memory affect performance. Look at the assembly generated for your code and see if it could be simplified. Efficient code is more about understanding what you are doing and how it can be most simply achieved on a particular machine than having the best algorithm. One example of this is using doubles for all floating point computation when you don't need that extra precision. Float-only math is usually faster, so it's important to figure out if your computations require double precision or not. 
Sometimes. The reference implementation is. https://en.m.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms
**Basic Linear Algebra Subprograms** Basic Linear Algebra Subprograms (BLAS) is a specification that prescribes a set of low-level routines for performing common linear algebra operations such as vector addition, scalar multiplication, dot products, linear combinations, and matrix multiplication. They are the de facto standard low-level routines for linear algebra libraries; the routines have bindings for both C and Fortran. Although the BLAS specification is general, BLAS implementations are often optimized for speed on a particular machine, so using them can bring substantial performance benefits. BLAS implementations will take advantage of special floating point hardware such as vector registers or SIMD instructions. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
\&gt; To my best knowledge there is no single core algorithm which speeds that up by a large factor. Only small improvements are possible Strassen algorithm is asymptotically faster than the naive algorithm, so it's a very large factor improvement indeed for large enough matrices: [https://en.wikipedia.org/wiki/Strassen\_algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm). Coming up with better matrix multiplication algorithms is still an active research area. In any case, using more cores does not improve the asymptotic complexity (unless you have an unlimited number of cores), it's only a constant speed-up.
&gt; So you're saying that GCC, on O3, decides that on the iteration 1 the multiplication overflows and thus this'd trigger UB, deciding to optimize the loop away and only incrementing and multiplying once (iteration 0) and no more (btw. GCC warns me about aggressive-loop-optimizations here). From what I can tell, if gcc is configured to try to warn on all cases where such optimizations might have a breaking effect, it will also generate warnings in nearly all cases where such optimizations could have a useful effect, greatly undermining the usefulness of either the optimization or the warning. In any case, my main point was that it's a lot more fun to program in a dialect that will process `mul` in a way that is unconditionally free of side-effects, than one which interprets the Standard's permission to behave otherwise as encouragement to do so, which is why I favor learning the former dialects. I also think it's much more fulfilling to be able to know that compilers behave a certain way because the underlying hardware does as well, rather than knowing that compilers behave unpredictably even on commonplace hardware because the authors of the Standard thought they'd behave sensibly whether or not they were compelled to do so. 
What does it do instead of working? What do you expect it to do?
i expect it when i compile to print the following. but its not working. i will summon the butler function you rang sir? yes. bring me some tea and writeable dvds.
yup that was my mistake, i needed a semi colon at of the second line. how did you figure that out?
It works for me (after adding the missing # and the missing ; ) [http://cpp.sh/2waikk](http://cpp.sh/2waikk)
I saw that your Butler function is below main, so I thought you need a forward declaration, I looked at it and saw no semicolon. Basically, it's just experience.
Read your compiler errors, or use and IDE that shows you these errors as you're typing.
ya i needed semi colon lol such a noob mistake :)
oh nice, so your a professional programmer.
Wasn't C89 the name of the standard approved by one particular organism and C90 the name of an identical standard approved by another organism one year later? (I think the latter was ISO, but I don't know the other.)
ANSI in 89, ISO in 90
What C compiler doesn't support arrays?
&gt; as the compiler that I am forced to use does not support arrays (but does support pointers, like pointers to an integer). Wait ... say that again? You have a C compiler **that doesn't support arrays**???? That's literally unbelievable. Here's an easy overflow, reading outside the bounds of the string: char foo() { const char* str = "Hello, world!\n"; return *(str + 15); }
Well, the above wouldn't work because `str` isn't pointing to something on the stack. It sounds like all you need to do is create a pointer to a local variable, do some simple arithmetic on that pointer (whatever it takes to get to the canary), and then write to the resulting pointer.
So using *malloc* to allocate space on a specific pointer, then writing onto that adress more than the allocated space would be enough ?
That would certainly be a buffer overflow. But it wouldn't test your canaries, if that was the goal.
Umm, overflow a struct, or just memcpy into a normal type e.g. int is four bytes, copy 8 into it. Just pick a bit of memory and copy too much.
What do you mean by "the canary at the epilogue of the function call?" The canary (as far as I know, maybe you're doing things differently?) is a special value that sits between the local variables and the return address (and the like), which is checked during the epilogue before actually using the return address. The goal, I believe, is to manipulate a pointer to point to the canary value and then modify it. It would be very hard to modify the canary-checking code in the function epilogue, as that's located in a completely different part of memory.
I think you understand things right.
Alright, knowing that my basic idea of the process and the underlying mechanics isnt wrong gives me hope. Then would overflowing allocated space by writing too much information onto it (just enough to reach the adress of the canary) overwrite the canary value as I intend to ? Or do i specifically need to create a pointer (by using the overflow), pointing to the canary value and changing it afterwards ?
&gt; Then would overflowing allocated space by writing too much information onto it (just enough to reach the adress of the canary) overwrite the canary value as I intend to ? That's exactly what you need to do, and that's how traditional buffer overflow attacks work. For example: void foo() { char buffer[8]; for ( int i = 0; i &lt; 16; i++ ) buffer[i] = 'x'; }; This will write to `buffer`, go past the end, and (hopefully) overwrite our canary (assuming an appropriate stack layout). However, doing this with `malloc` instead of an array won't work very well. The `buffer` variable I declared above is a local variable, on the stack so it's right next to the canary. `malloc` provides a buffer that lives who-knows-where (and if `malloc` is doing it's job, it's nowhere near the stack at all). So you'd have to go very far to eventually get back to the stack, among other problems. The "buffer" you use needs to be a local variable (even if it's not an array).
Alright then instead of using an array like : char buffer[8] and not using *malloc* either as you explained as it is rather unsuited for what i wish to do, I have to use a local variable (for example an int) and use a pointer (pointer to int) which points to that variables adress. What I so far do not understand is : &gt; do some simple arithmetic on that pointer (whatever it takes to get to the canary), and then write to the resulting pointer. As from my understanding a pointer, pointing to an adress will always only point to an adress. In what way can I make it "overflow" or use it to overwrite other adresses ? Because in your example buffer[i] clearly is going past the allocated space of buffer[8] and I can clearly see that adresses beyond what was reserved for that variable being overwritten. But as a pointer only points to a single adress and not a field of adresses, by what means can I cause the pointer to change adresses and the content of it repeatedly until it reaches the canary and overwrites it as well ?
OKay .. so let's keep going here .. make a complete trivial sample that paints a sine wave on the screen. Nothing too interesting. 
u/chimpan_z has the right of it, both are solid but *O&amp;D* is definitely more introductory, but just to add some more insight here is my experience. In undergrad we used *O&amp;D* (5^(th) edition) for the second Architecture course offered. The first course focused exclusively on ARM while the second was more general and went more into theory, but *O&amp;D* was still very much an undergraduate textbook. It did a great job of explaining the overarching structure and design of modern CPUs; it was easily enough for anyone concerned with architecture on the software side while providing a good foundation for anyone going into computer engineering or electrical engineering with a strong focus on computers. By contrast *CA* could easily be a graduate level text. This was a book I went out of my way to read on my own because I found the subject personally interesting. It's more math heavy than *O&amp;D*, which can be a turn off to some people, and in some respects it will likely go more in depth than you want. That being said it is easily the canonically best book for this subject: it's thorough, clear, and has a proven track record of success and popularity. At the end of the day, go with whichever one is more accessible. You really can't go wrong when choosing between these two books. If they're both available, I preferred *CA* over *O&amp;D*, but your goals may be different than mine were.
&gt; But as a pointer only points to a single adress and not a field of adresses, by what means can I cause the pointer to change adresses and the content of it repeatedly until it reaches the canary and overwrites it as well ? Time to talk about one of the most important aspects of C! While it's true that a pointer can only point to a single thing, it can change what it points to. So can do: int a, b; int* p = &amp;a; // Point to a p = &amp;b; // Now point to b You can also point to something inside an array: int array[10]; p = &amp;array[5]; p = array; // Arrays automatically "decay" into a pointer to the first element (&amp;array[0]) Now, we need to talk about pointer arithmetic. If you're pointing to something inside an array, you can change the pointer using the standard operators: p = &amp;array[2]; p++; // p now points to &amp;array[3]; p += 3; // p now points to &amp;array[6]; p --; // p now points to &amp;array[5]; This can lead to code like: for ( int* p = array; p &lt; array + 10; p++ ) printf("%d\n", *p); This does the same thing as if you had used a traditional loop: for ( int i = 0; i &lt; 10; i++ ) printf("%d\n", array[i]); There are times when the pointer version is preferred, especially by advanced programmers. Ok, this doesn't quite help you yet. According to the language, you can move a pointer around anywhere you want inside an array, and that's fine. But the language also allows you to do: int i; int* p = &amp;i; p += 100; // Uh, what does p point to now? *p = 42; // Oops... This brings us to "undefined behavior" -- the language lets you do this, but it doesn't guarantee what will actually happen. Your goal here is to trigger UB and do something interesting. (As an aside, and I don't normally do this ... address and two d's not one.)
 int x, y; for (x = 0; x &lt; WIDTH; ++x) { y = ((sin(x/16.0)*32)+(HEIGHT/2); *(screen+(y*WIDTH)+x) = 0xFFFFFFFF; }
&gt; Ok, this doesn't quite help you yet. According to the language, you can move a pointer around anywhere you want inside an array, and that's fine. But the language also allows you to do: &gt; &gt; int i; &gt; int* p = &amp;i; &gt; p += 100; // Uh, what does p point to now? &gt; *p = 42; // Oops... &gt; This brings us to "undefined behavior" -- the language lets you do this, but it doesn't guarantee what will actually happen. Your goal here is to trigger UB and do something interesting. &gt; &gt; (As an aside, and I don't normally do this ... address and two d's not one.) First of all, I am super thankful for you being so nice and dedicated to explain things to me in such detail and with understandable examples, this is really helpful. From what I understand the value of p after p = &amp;i is an adress in HEX form. Some thing like 0x08048622. Using p += 100 would go 100 adresses further wouldnt it ? (assuming that += works correctly with HEX) *p is the value stored at the adress i My problem here is now : Given that i can increase the number of the adress which p is pointing towards i could overwrite the memory of the adresses which it is pointing to. However, this leads me to the question whether this actually works in the way i hoped, because I can not be sure that i would overwrite the canary value afer 100 or 1000 or more repetitions of a loop which increases p and overwrites the adress it is pointing to in each run of the loop. void loop(int a, int b) { // a as the input value which shall be written over the contents of the adresses, // b as the number of repetitions of the loop int i; // to gain a local starting variable of whatever value int* p = &amp;i; // gain the adress of said starting variable for ( i = 0; i &lt; b; i++ ) { *p = a; // replace the contents of the adress p is pointing to with a p += 1; // increase the count of p to get the next adress }; }; Would this - as badly formatted as it is - work ? Can *p - the value at the pointed-to-adress - even be changed that way ? And would this be, given the circumstances of not being able to use arrays, be a good way to go through the adresses until the adress the canary is saved at is reached and overwritten ? (I believe counting upwards at least gets one closer to the canary's value address, counting downwards shouldnt lead anywhere from how i understand the stack works)
Thanks for your input. I appreciate it!
This saved me thank you
I think that C code is way more efficient that same code writed on other programming language, with the exception of assembler... That say, for faster calculations you must avoid for loops and do all multiplications line by line whenever is possible
Average editors and IDE do that for us. I reccomend Emacs, Vim, VsCode ...
no....
Ty
Can you use an integer and add in a decimal point when you display it? A lot of times when software is doing something with money amounts people will just store, say, $15.00 dollars as 1500. You can end up with inaccuracies trying to store these as a float and rounding because floating point numbers are stored as binary and not base 10.
This is a C programming subreddit. This question is much more suitable for /r/cpp_questions. However, I've done way more C++ than C, and when I started I just downloaded CLion(I was already a big fan of JetBrains) and I've never had any trouble(well I have but it's not related) with using the standard libraries, I think CLion will install them if you don't already have them, but don't quote me on that. I just know that last time I updated CLion it seemed to update Clang as well. It sounds like you are a student. You can get a free license from JetBrains for CLion(and some other tools) because you are a student. It may help to just go that way to make it easier beginning the language honestly. But you are unlikely to get much advice here, this is a C programming subreddit. C and C++ are extremely different languages. Also, it's generally acceptable to name your 'whateverfile.cpp' to 'main.cpp'. Additionally, I'm not trying to push JetBrains stuff, I just found it easy for me to immediately get going with the C++ programming language, which is what you want when getting started with a language, therefor i would suggest the same for you. Alternatively , you could open up your terminal in Eclipse and try this command `g++ -Wall whateverfile.cpp -o whateverfile` ... though I would suggest you change whateverfile to main.
That's not a valid C _or_ C++ program. You're missing lots of syntactically meaningful characters. The classic C++ hello world is something along the lines of: #include &lt;iostream&gt; int main(int argc, const *char argv[]) { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; } I'm really not sure what to make of the bits and pieces of code you posted.
Not like you're saying, but in a sense. If the decimal point doesn't move it's not floating point - it's fixed point. To use a simple example, instead of recording dollars to two decimal places, you would record cents, in an integer type. If you want to display dollars, it's up to you to remember that it's in cents and to convert appropriately for display. One of my applications has functions that take frequencies in Hertz, but they need at least 1/10 Hz resolution, so my frequency variables are declared like `uint32_t freq_hz_q8`. The 'hz' part is because I always try to include units for that sort of thing, and 'q8' signifies that the low 8 bits are the fractional portion. Thus 1 is actually 1/256 Hz. That doesn't convert cleanly to a fixed number of decimal places in base 10, but it does let you represent exact values (unlike floating point) and you know exactly what your range and resolution are.
You can just treat integers like fixed point decimal numbers. Just realize that 3.14159 = 314159 / 100000. You can store 314159 in an integer, and you just remember and properly deal with the fact that it's implicitly a fraction. For example, if you had 314159 in an integer representing pi, to five places, and you wanted to square it, you'd square it to get 98695877281, but then you'd divide by 100000 to normalize it, getting 986958, which looks like the correct representation of pi squared, to five places, times 1000000.
Thank you! I appreciate your help, I searched C++ in the reddit search bar and this subreddit popped up so I assumed the ++ characters weren't valid. I didn't actually name my file "whateverfile" though, that was just me being careless with that detail here because I felt it was irrelevant. However, I do really appreciate your advice, I'll try your suggestions. If they don't resolve the issue I'll make my way over to the other thread. Oh and additionally, I didn't write actual code here either because I know the actual code I wrote in my IDE was correct. It was just the matter that it wasn't recognizing some of they key syntax. Like my main function, cout statements, etc. I suppose I need to quite a bit more detailed, but I thought posting code on this type of subreddits where prohibited. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
What exactly is unsupported if you say ‚Äúthe compiler does not support array?‚Äù
Then just write double pi = 3.14159;
Okay, I think I understand what you mean and the first point is definitely backed by your example, however afaik O3 is exactly for such "exploiting" optimizations, if you don't want them, just use O2 and it should give you pretty much exactly what you want. For the other point I honestly still don't see the problem as I'd think you can write code in a way that it works as the underlying hardware does in those few cases that it does not work as it usually does. Those are *really* neglible cases.
&gt; malloc provides a buffer that lives who-knows-where (and if malloc is doing it's job, it's nowhere near the stack at all). So you'd have to go very far to eventually get back to the stack, among other problems. The "buffer" you use needs to be a local variable (even if it's not an array). paging /u/Geistermeister since the following is mostly for him but I'm still quoting you. What would typically happen is that the OS will see you're trying to write to unallocated memory, that your process does not have read or write access to and will segfault way before you get to the stack memory.
Please explain what you are trying to achieve at a higher level.
I think you can¬¥t, but there are others ways to doit. You can override each arithmetic function over a new type of float with your requirements 
&gt; Chars initialized to characters are always positive. Signs of uninitialized chars are undefined. Just wanted to note that regardless of the sign of the char, calling a function expecting an unsigned with a char will implicitly type cast the argument, and that cast is well defined in the standard: &gt; 6.3.1.3 Signed and unsigned integers &gt; 1. When a value with integer type is converted to another integer type other than_Bool, if the value can be represented by the new type, it is unchanged. &gt; 2. Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type. 
I believe as long as you're using the newest edition you're mostly okay. Its just the first edition referred to as "k and r C" is deprecated. The new ones are at least up to ANSI standards... Other than stuff like they just put main() Rather than int main(void)
Yeah I'm reading the second edition, and I noticed the lack of return type, so I specify int (but thanks for reminding me about (void) for parameters). I guess reading some reference for the language would be enough? I know cppreference has a C section with parts labelled as C99 and C11: https://en.cppreference.com/w/c
I learned a lot from [21st Century C](http://shop.oreilly.com/product/0636920033677.do) and [C Pocket Reference](http://shop.oreilly.com/product/9780596004361.do) when I was in a similar position a few years ago. 
Looks like you're getting stuck in an infinite loop. You set j=br, and the first value of br is 1. Then you say "while ( j != 0 )" but never change j. Thus, it is stuck in this while loop forever. Truthfully I still have no idea what this program is trying to accomplish anyway because what you say it's supposed to do is not what it would do.
You should really use markdown ticks
first off, you should THOROUGHLY learn ansi c before moving on to less relevant versions of C second, ansi c is close to the hardware and other versions of C are not because they do high level things like fixed size data type memory mangement which is not portable between embedded compilers third, the majority of the most relevant c code you will maintain is ansi c fourth, you should read "practical c programming" from o'reilly followed by "mastering algorithms in C" (oreilly) followed with "understanding and using pointers in C" (oreilly) followed with "c traps and pitfalls" and "expert c programming - deep C secrets" and then youll be ready for "21st century C" and "learn C the hard way" and "secure c and c++ programming cookbook" and "SEI's secure programming in c and c++ 2016 edition". 
21st Century C
Another good C book is [C in a Nutshel 2nd edition](http://shop.oreilly.com/product/0636920033844.do).
By less relevant versions, you mean like newer and less frequently adopted versions? I'm reading the second edition of the K&amp;R book, which is about ANSI C.
I looked around on stack overflow and saw a pretty clever solution using floorf, roundf or ceilf where you do: float newnum = roundf(100000*yournum)/100000 https://stackoverflow.com/questions/1343890/rounding-number-to-2-decimal-places-in-c
It prints numbers that are disible by 7: 714212835424956...I'm not using space so you could understand [it.](https://it.So)So if I input k, let's say 5 it should print: digit in that location is 1, because loop is starting from 1 and that is 7, so 2 is 1, 3 is 4, 4 is 2,...
Have you even read this thread? That's been made quite obvious. My apologies for making a simple mistake and intruding in your subreddit. But quite honestly, I made a mistake and posted to the wrong subreddit, there's no reason for so many of you to be so nasty about it. 
I'm sorry if I appear to be nasty. I do not intend to be nasty at all. But as a moderator, it is my duty to remove posts that are off topic; that's why I wrote this comment with a constructive remark to inform you about this (so you don't wonder why you won't get any more responses) and point your towards the right place to ask your question. Basically, this is the same comment I write below all C++ posts before closing them.
Thanks for the reply, it seems I'll be able to focus on other topics pretty soon then. I like how this language seems to have a pretty stable history.
It's also worth noting that there are some very long lasting C projects out in the wild. My last two jobs were working on 30 year old projects written primarily/entirely in C and one of those was built around a compiler that didn't support ANSI C, so sometimes you still run into the original K&amp;R stuff (we were porting it from that compiler to a current GCC when I joined that project, but it still bit me on at least one bug fix).
I'd add [Computer Systems: A Programmer's Perspective](https://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X)
Wait ‚Ä¶ they added threading stuff to C?
It's worth it.
It's so fun, I wish they also added a file system and networking so we could easily make little retro games, etc. like on the Commodore.
The least common multiple of numbers 1 through n inclusive? Is this for a homework assignment? Is it supposed to be specially optimized or anything? Do you need it in one line or what? (On phone away from pc so I can't test anything)
Instead of asking for help, you should just go ahead and try something.
I am busy learning ASM x86 and C currently. Learning them like that gives you a great understanding of ur C code and the architecture.
Yup. Unlike C++ threads they've been really slow to get adopted though. Frustrating.
You can compute the least common multiple of two numbers according to the formula &gt; lcm(a, b) = a * b / gcd(a, b) or slightly better (avoids overflow): &gt; lcm(a, b) = a * (b / gcd(a, b)) Computing the greatest common divisor (gcd) is quite easy, look up Euklid's algorithm.
Designated initializers and compound literals are the biggest omissions from that list I can think of.
Thanks for the advice, I went with learning C because I felt tired of learning languages with more advanced paradigms and I wanted to learn more about the machine I'm writing code on, and how all of this fits together.
What do you use to assemble the ASM?
It is for a homework. But I don't really know where to start 
What did they add?
Well how do you know that it's 60? If you did math to get there just put that into code, if you had to look up what the lcm was for those numbers then this isn't a cs question, it's a math question. If you don't know how to put it into code, what kinds of programming have done done so far? Phone about to die so response unlikely till I get home after this
Well this look like fun. Two languages that couldn't be more different. One is fairly close to the machine and gets actually compiled and linked into an executable that actually runs on the machine and the other is translated into byte code barf for a java virtual machine. Ranting aside about the vomit that is Java let me look at the output : $ cat -n BarfNum.java 1 2 public class BarfNum { 3 4 public static void main(String[] args) { 5 double foo = Double.parseDouble(args[0]); 6 System.out.println(foo); 7 } 8 9 } OKay and that barf results in : $ java BarfNum 0 0.0 $ java BarfNum 442773495.25 4.4277349525E8 $ java BarfNum 43329446.11 4.332944611E7 $ java BarfNum 109570974.15 1.0957097415E8 $ java BarfNum 721054.00 721054.0 So yep .. that jives with your table of data there. Sort of makes me wonder what the heck System.out.println() does with a double floating point data element when you give it no instructions whatsoever. Makes a guess? To really answer the question we have to "use the source Luke" : http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/cf44386c8fe3/src/share/classes/java/lang/System.java OKay so 1200+ lines of joy there. Thankfully it has wonderful comments with stupid html tags embedded.. so let's see : * The "standard" output stream. This stream is already * open and ready to accept output data. Typically this stream * corresponds to display output or another output destination * specified by the host environment or user. * For simple stand-alone Java applications, a typical way to write * a line of output data is: * System.out.println(data) * See the println methods in class PrintStream. * * @see java.io.PrintStream#println() * @see java.io.PrintStream#println(boolean) * @see java.io.PrintStream#println(char) * @see java.io.PrintStream#println(char[]) * @see java.io.PrintStream#println(double) * @see java.io.PrintStream#println(float) * @see java.io.PrintStream#println(int) * @see java.io.PrintStream#println(long) * @see java.io.PrintStream#println(java.lang.Object) * @see java.io.PrintStream#println(java.lang.String) */ All-righty-then. So we need to keep digging. http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/solaris/native/java/io/FileOutputStream_md.c nope .. not there ... must be .. you know .. it may be a good idea to just use format tools to get your numbers. $ cat -n BarfNum.java 1 2 public class BarfNum { 3 4 public static void main(String[] args) { 5 double foo = Double.parseDouble(args[0]); 6 System.out.println(foo); 7 System.out.println(String.format("%%f says %f", foo)); 8 } 9 10 } 11 $ javac BarfNum.java $ java BarfNum 0 0.0 %f says 0.000000 $ java BarfNum 442773495.25 4.4277349525E8 %f says 442773495.250000 $ java BarfNum 43329446.11 4.332944611E7 %f says 43329446.110000 $ java BarfNum 109570974.15 1.0957097415E8 %f says 109570974.150000 $ java BarfNum 721054.00 721054.0 %f says 721054.000000 hows that ?
make sure you read 4 or 5 intermediate to advanced books on ansi C before moving on to C99 and C11
The what?
K&amp;R 2 was based on C89 though, the improvements in C99 are very significant, including inline functions, VLAs and Flexible Array Members. C11 also adds a few substantial convenience features like _Generic() and anonymous structures/unions.
Benefit of the doubt, maybe they think they can find the spec or the compiler code on github?
The top customer reviews on Amazon do not inspire confidence. :/
C11 added the optional (an implementation can conform to C11 without including) `threads.h` threading API. I haven't really used it, but the chatter I've heard is that in the API's attempt to be universal, it doesn't allow you to do a lot of useful things that existing solutions allow. Also due to it being optional, it has lower support than C11 itself. Pthreads is still widely used as a cross-platform solution to threading instead.
Programming languages have their repositories online, no?
Not necessarily, no. /u/quintus_horatius has a succinct follow-up https://www.reddit.com/r/C_Programming/comments/9g6531/where_is_the_c_repository_on_github/e61qkah/
I mean like, where is the stuff with the standard libraries and everything?
No actually I wasn't thinking about compilers
Here: [https://github.com/topics/c](https://github.com/topics/c)
libc? Maybe search for libc? 
**C (programming language)** C (, as in the letter c) is a general-purpose, imperative computer programming language, supporting structured programming, lexical variable scope and recursion, while a static type system prevents many unintended operations. By design, C provides constructs that map efficiently to typical machine instructions, and therefore it has found lasting use in applications that had formerly been coded in assembly language, including operating systems, as well as various application software for computers ranging from supercomputers to embedded systems. C was originally developed by Dennis Ritchie between 1969 and 1973 at Bell Labs, and used to re-implement the Unix operating system. It has since become one of the most widely used programming languages of all time, with C compilers from various vendors available for the majority of existing computer architectures and operating systems. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
That's my b, find the second edition pdf. They have lectures for cmu online to accompany the book, and labs.
C is a standardized language. You can read the standard, but there is no official C "repository". Only implementations of said standard
There are multiple implementations of libc. You need to think of C like a family of implementations, it's not just one thing.
//This should do the trick &amp;#x200B; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { unsigned int limit, multiple = 1; int * numbers; puts("Pick a number: "); scanf("%u", &amp;limit); numbers = (int*) malloc(limit * sizeof(int)); for(int i = 0; i&lt;limit; i++) numbers[i] = i+1; while(1) { for(int i = 0; i &lt; limit; i++) { if(multiple % numbers[i] != 0) { i = 0; multiple++; } } break; } printf("The minimun comon multiple for all the numbers from 1 to %d is %d",limit, multiple); free(numbers); return 0; } &amp;#x200B;
by the way, is not the most eficcient program ever made, so it may take some time to calculate big numbers
C predates Github by about 36 years. I'm not sure what exactly you're looking for, but I'm somewhat sure it doesn't exist. There's no "C repository" at all. The C language and libraries are defined by an [international standard](http://www.iso-9899.info/wiki/The_Standard). This is a document maintained by ISO, and is the closest you'll find to being the official "repository" for C ... but there's no source code involved for the compiler or libraries, just a formal document from which those could be made. From there, various companies and organizations [have made implementations](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers) of C (to various degrees of conformance to the standard). The most popular of these are GCC, MSVC (aka Visual Studio), Clang, and ICC. Visual Studio is a proprietary, closed-source implementation, and so does not have anything like a github repository. The closest thing you'll find is [this site](https://visualstudio.microsoft.com/) where you can download it and read documentation. The same goes for the Intel C Compiler. [Here's its product page](https://software.intel.com/en-us/c-compilers). GCC is an open-source implementation, though. The project is not hosted on github, however, but has [its own website](https://gcc.gnu.org/), which also hosts the source code. Given that this is the most popular open-source C compiler, this is as close as you'll come to "the C repository." Clang is also open source, [hosted as part of the LLVM project](http://clang.llvm.org/), and you can find its code repository through that site as well. With other languages with less intricate history and fewer implementations of the language, the situation is much simpler and everything can be hosted under a github repo ... but that's simply not the case with C.
what did i just read
Your question isn't as dumb as you are thinking Actually, C++ has a Github. Sort of. There is no official implementation of C++, but there is an official Github where the draft for the next standard is being written: https://github.com/cplusplus/draft The working drafts for C are not on Github, but you can find information about them here: http://www.open-std.org/jtc1/sc22/wg14/
You sir are a problem solver extraordinare! Bravo! 
This is an actor system experimentation using bounded message queues. Still experimental. Thoughts and feedback are welcome :)
Where did you meet him??
I didn't actually meet him in person, I only spoke to him over email
AFAIK java and almost all string to decimal and back libraries out there aren't actually perfect (round well, make sure the number will go in and out as the same representation etc) it's actually a pretty hard problem to solve, I was recently reading about the [Dragon4 algorithm here](http://www.ryanjuckett.com/programming/printing-floating-point-numbers/) So yeah, you probably don't want to do things the way java does.
&gt;Thankfully it has wonderful comments with stupid html tags embedded.. There is a table in the comments, it's amazing! /s &amp;#x200B; &gt;hows that ? So in that case you're proposing that I change the way the numbers are shown in Java, rather than trying to reinvent the wheel with C, right? I agree 100%, but my teacher apparently does not. The context is that my teacher made a Java code to solve a problem, gave us the output and said: "Solve this same problem in Java and C and show the same output." But he only did in Java, so the correction system of my university only has the Java output for both languages and in that case there is nothing I can do about Java output. But i did some things here in C and i reached a 98.5% correct output. I'll try to make some adjustments, but that's okay. Thank you. &lt;3
Let's start over here ... looks like you ONLY have this to work with : input string output string 0.00 0.0 442773495.25 4.4277349525E8 43329446.11 4.332944611E7 109570974.15 1.0957097415E8 721054.00 721054.0 Hrmmm ... so input is zero and you output zero point zero. Single digit after the decimal place. Anything less than one million gets the same treatment and everything larger gets scientific notation. OKay... seems easy to me. 
close : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc,char *argv[]) { double puke; char *endp; if (argc&lt;2){ fprintf(stderr,"ERROR:barf barf barf gimme a number!\n"); fprintf(stderr," : %s some_floating_point_num\n",argv[0]); return EXIT_FAILURE; } puke = strtod(argv[1], &amp;endp); printf("INFO : you gave me \"%s\" and I see %14.10g\n",argv[1],puke); if(puke&gt;1000000.0F){ printf(" : maybe %14.10E\n", puke); } else { printf(" : perhaps %8.1f\n", puke); } return EXIT_SUCCESS; } tricky because of the exponents : input string output string 0.0 0.0 442773495.25 4.4277349525E8 43329446.11 4.332944611E7 109570974.15 1.0957097415E8 721054.00 721054.0 $ $ ./puke ERROR:barf barf barf gimme a number! : ./puke some_floating_point_num $ $ $ ./puke 0.00 INFO : you gave me "0.00" and I see 0 : perhaps 0.0 $ $ ./puke 442773495.25 INFO : you gave me "442773495.25" and I see 442773495.2 : maybe 4.4277349525E+08 $ $ $ ./puke 43329446.11 INFO : you gave me "43329446.11" and I see 43329446.11 : maybe 4.3329446110E+07 $ $ ./puke 109570974.15 INFO : you gave me "109570974.15" and I see 109570974.2 : maybe 1.0957097415E+08 $ $ ./puke 721054.00 INFO : you gave me "721054.00" and I see 721054 : perhaps 721054.0 $ So there the trailing zeros are an issue and so is the sign within the exponent. Hrmmmmmmmm.... 
Pretty cool project, but: &gt; it uses C (by default, safety and productiviy is out of the window as you, now, officialy live in the debugger) This isn‚Äôt universally applicable. Plenty of productive C developers exist.
Yes! I have made some modifications and it comes very close to the expected result. char temp[23]; if(number == 0){ printf("0.0"); } else{ if(number &gt; 1000000.0F){ snprintf(temp, 23, "%14.10E", number); } else{ snprintf(temp, 23, "%8.1f", number); } char *result = NULL; result = replace(temp, "E+0", "E"); result = replace(result, "0E", "E"); result = replace(result, "0E", "E"); result = replace(result, "0E", "E"); printf("%s", result); free(result); } Yes! I have made some modifications and it comes very close to the expected result. But in many cases, as you said, there are problems with zeros and decimals. What I also realized is that comparing with a million does not always work, since the number 4217475.0 is expected to be displayed as 4217475.0 (Java) and not as 4.2174750E6 (C, after the above function). Some other issues too, such as 897205.77 being displayed as 897205.8 in C, etc. Anyway, I really need to sleep now. I've been in this for a long time. I recommend that you do not worry about it either. hahaha. Thank you anyway, you're amazing!
As others have already commented on some of the available compilers for C, I thought I'd drop some comments on the C standard library - libc. As I'm sure you're aware C is a very versatile language which is simply defined by a specification. I'm not sure there is even a "reference" implementation. For each particular implementation there will be differences. You can write C code which will compile for use on a modern x86 computer running windows, on old Power PC running Mac OS, or an ARM microcontroller without any OS at all. In each case the compiler will handle the differences in CPU architecture, but there are other considerations. Just as a super basic example, malloc will work differently when used on x86 with windows than on x86 with a Linux kernel. These differences are handled by the C standard library. For Linux probably the most popular implementation is glibc which is open sourced and maintained by the GNU project, but there are other implementations as well. Things start to get a bit weird when you look at super small embedded systems with no OS at all - otherwise known as bare metal applications. In general, for these applications there is no standard C library at all, this is partly because these systems are so specialized and individual. What should printf output to? There's no monitor, there may not even be a serial console. How does malloc work? Well, that depends on if you're only using the onboard memory, or if you have the "luxury" of off-processor ram. In these cases you will typically write implementations of these functions yourself based on other common implementations (like glibc) and adapting for your own hardware implementations. If you're simply interested in looking at the C language in general I would recommend GCC targeting linux and glibc for a standard library on x86, or x86-64. This is the basic configuration you'll see for many open source projects.
Cool project! 
Oh, absolutely, but that‚Äôs part of the fun! :D
No advertisements please.
Yeah it works. But i don't really understand how it works. Like why do you do int*numbers at the beginning. Thank you but I'd rather understand the code first before using it
Upvoting this because the answers are great. Lots of good explanations for people who come from more ‚Äùmodern‚Äù languages and - understandably - could make the same assuptions as OP. 
That type of questions are easily answered by a debugger. Use one from your IDE or preferred compiler. The problem is on the surface, I think. I don't see where you call numbers(). Correct me if I'm wrong.
That's a lot of code to eyeball, and you haven't provided us with a `bigdata.txt` to actually test with. I suggest you run your program through a memory usage analysis tool (such as [Valgrind](http://valgrind.org/)) to see what it flags.
When readfile() is first called the if statement is triggering because linecount == array_len (both 0) meaning you are calling realloc before you allocate any memory. This results in a segfault because realloc requires that memory already be allocated before it is called.
Realloc with NULL pointer as input argument [is fine](http://c-faq.com/malloc/reallocnull.html)
Never define `__USE_GNU` yourself. That's an internal macro, not an interface. Instead, define `_GNU_SOURCE` before including any headers. `__INTERNALS__H__` and `__TCPM__H__` are reserved identifiers. Identifiers ending in `_t` are reserved by POSIX. Your queues aren't actually lockfree. You're just building your own spinlocks, more than once. If it was lockfree, I could pause/terminate any thread at any time, and the other threads would still be guaranteed to eventually make progress on the queue. However, `last` locks it for pushers, and `first` locks it for poppers. If that thread is paused or terminated before updating `seq`, the queue will be permanently locked. `seq` is a 64-bit atomic integer, but only the bottom 32 bits ever get used. Since 64-bit atomics are often unsupported on 32-bit archtectures, don't use it if you don't have to. 
You should add a check in your loops that fill buf[] to make sure you're never writing past the maximum size of buf[]
Indeed. Many high quality answers. Really good stuff.
Every vendor has its own standard library. Some of these are even open source. You should have received a copy of your vendor's documentation with your system.
Why do you use fixed with types in various places? Is there anything that absolutely requires a fixed width? It is generally better to use a typedef for a native type. Only use fixed width types when you need them.
Why is it wrong to use fixed width types?
Fixed width types put a constraint on the implementation of C to use that particular size type, even if it is not particularly well-suited for the target platform. I recommend you to only use them if you need a fixed width type. Don't just default to fixed width types for no good reasons. An `int` is usually a better choice.
In readfile function you must allocate memory using melloc or calloc before reallocating it
C does not need standard libraries to work or run.
Post C99 companies still do roll their own (or use the header they defined previously at least).
Can't argue there :), but I am talking about the worst that can happen: debugging a multi-threaded C application on the server with a tight deadline. 
Old habit, I try to guarantee as much, cross platform compiler behavior.
No you don't. `realloc()` works just like `malloc` if the first parameter is a null pointer.
What if you change your include to this: #include &lt;asm-generic/signal.h&gt; And add this path to your compile step: gcc -I/usr/src/linux-headers-4.12.0-kali2-common/include file.c ?
Look at some projects written in C, perhaps Linux (though it may use GCC extensions in some places). Of you want to learn about insane compiler extensions (like anonymous functions), look at the GCC manual.
Unlike meme languages (you mention Go), C has multiple implementations and multiple standard libraries. If you want a small, easy-to-grok C compiler, check out TCC. Do not use TCC. If you want full implementation of a C compiler, check out GCC's C compiler, or Clang's C frontend. These are massive, multifaceted projects. For the standard library, uCLibC and muSL are the two lightweight (and thus likely easier to understand) libraries. GLibC ("libc") is more or less the de-facto standard C library for all non-windows (and even some windows) development.
&gt; GCC is an open-source You mean Free Software? 
Why did you delete your first post about this?
Why are you pulling in the asm headers?
There are also about a zillion proprietary compilers and libc's in the embedded world.
I pulled them in because when I first tried compiling with including the asm header dir, it would give me a fatal error: asm/page.h: No such file or directory. I then included that dir. &amp;#x200B; Then, it would give me "/usr/src/linux-headers-4.12.0-kali2-common/include/asm-generic/signal.h:4:10: fatal error: uapi/asm-generic/signal.h: No such file or directory \#include &lt;uapi/asm-generic/signal.h&gt;" &amp;#x200B; I tried overcoming this by adding asm to the signal.h, but then that's resulted in the long exception
Needless to say, I am trying to compile code that I didn't originally write. I am doing a pentest on a machine, and I am trying to compile code into an executable. So I didn't actually write this piece of code, but was just something that I found online that I am trying to edit. &amp;#x200B;
No. You mentally challenged person
I learned a ton reading these answers.
no, they mean open source: https://en.wikipedia.org/wiki/Open-source_software
**Open-source software** Open-source software (OSS) is a type of computer software whose source code is released under a license in which the copyright holder grants users the rights to study, change, and distribute the software to anyone and for any purpose. Open-source software may be developed in a collaborative public manner. According to scientists who studied it, open-source software is a prominent example of open collaboration. The term is often written without a hyphen as "open source software".Open-source software development, or collaborative development between multiple independent contributors, generates an increasingly more diverse scope of design perspective than any one company is capable of developing and sustaining long term. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Because Linux is the only Unix that exists? (I know otherwise, but maybe the author doesn't?) In my opinion, there is *no* way to handle POSIX signals sanely and they should be avoided at all costs. I know that's not often possible though. 
You should #include &lt;string.h&gt; and compare with strncmp(yesno, "yes", strlen("yes") + 1);
And the issue is that you are comparing two pointers instead of the value of those pointers. Like u/gorillamoonx said, you need strcmp, which compares the contents. Yeah, I agree, it is weird that C thinks "yes" is a pointer. However, that makes it simple and consistent. 
error: too few arguments to function 'strncmp' if (strncmp (yesno, "yes")==0)
You did not just say h**k on this good Christian website!
strncmp(yesno, "yes", 3)
I would do 4, because even if the user types "yesmin" it would evalute to true and return 0. With 4 you make sure that 'y' , 'e', 's', '\0' are the same in src and dest
Fuck. Thanks for correcting me
Indeed learned something today
Not to draw attention away from the main point that strings need to be compared with the correct function (e.g. strcmp or the like), but... is yesno big enough for both the word "yes" and the terminating '/0'?
Can you please show us the whole program, and format your code properly? Four spaces in front of every line, no extra blank lines, no extra backslashes.
sorry didn't even realise it broke when copying, hopefully it is more clear now
One extra blank line at the end. 
The code is still incomplete and you still haven't added four spaces to the front of every line like I told you to.
? &amp;#x200B;
Is it not correctly formatted now? i added the rest of the code which just prints the strings in the 2d array?
"Unlike meme languages (you mention Go)" *shots fired*
I have added the definitions and included relevant libraries, hopefully this clears up confusion
user inputs data into array and outputs both arrays as-well as average of all grades and the highest test grade.
Wild guess here without looking to hard - maybe your array is also capturing the '\r' character? Try printing out each character as a '%d' value to see if this may be the case.
This is C++ code but you've posted on a C programming subreddit. Try /r/cpp_questions
That seems to be something to do with it, I changed the if statement to check for '\\r' as well but it now increments n 2 times the number of strings...
Just ignore the '\r' (don't change `n` or `i`), it will be paired with a '\n'
Could you explain what you mean by this? I have changed the if statement to: if (c != '\\n' &amp;&amp; c != '\\r') It this what you mean?
No, add another conditional block. if (c == '\r') { //Do nothing } else if (c != '\n') { //Add it } else { //Next word }
&gt;An `int` is usually a better choice if there are no other constraints. ...cache line?
Okay It's been a while since I did some C but i think i can help use this-- #define MAX 100 #define ASCENDING 0 #define DESCENDING 1 #define WEIGHT 0 #define HEIGHT 1 struct person{ string name; float weight; float height; }selection[MAX]; struct personStruct{ struct person entry[MAX]; int index; }db; int result_count=0; //Prototypes void read_from_file(void); void find_similar_data(float weight_start, float weight_end, float height_start, float height_end, int sort_parameter, int sort_order); void sort_selection(int sort_parameter, int sort_order); int main(){ read_from_file(); //read user data..... find_similar_data(weight_start,weight_end,height_start,height_end,sort_parameter,sort_order); display_result(); return 0; } void read_from_file(void){ FILE *fp=fopen("exp.txt","rb"); fread(&amp;db,sizeof(db),1,fp); fclose(fp); } void find_similar_data(float weight_start, float weight_end, float height_start, float height_end, int sort_parameter, int sort_order){ result_count=0; for(int i=0; i&lt;MAX;i++){ if( (db.entry[i].weight&gt; weight_start) &amp;&amp; (db.entry[i].weight&lt; weight_end) &amp;&amp; (db.entry[i].height&gt;height_start) &amp;&amp; (db.entry[i].height&lt; height_end)){ selection[result_count] = db.entry[i]; result_count++; } } sort_selection(sort_parameter, sorr_order); } void sort_selection(int sort_parameter, int sort_order){ struct person tmp; if(sort_order==ASCENDING){ for(int i=0; i&lt;result_count-1;i++){ if(sort_parameter == WEIGHT){ if(selection[i].weight&gt;selection[i+1].weight){ tmp=selection[i]; selection[i]=selection[i+1]; selection[i+1]= tmp; } } if(sort_parameter == HEIGHT){ if(selection[i].height&gt;selection[i+1].height){ tmp=selection[i]; selection[i]=selection[i+1]; selection[i+1]= tmp; } } } if(sort_order==DESCENDING){ for(int i=0; i&lt;result_count-1;i++){ if(sort_parameter == WEIGHT){ if(selection[i].weight&lt;selection[i+1].weight){ tmp=selection[i]; selection[i]=selection[i+1]; selection[i+1]= tmp; } } if(sort_parameter == HEIGHT){ if(selection[i].height&lt;selection[i+1].height){ tmp=selection[i]; selection[i]=selection[i+1]; selection[i+1]= tmp; } } } } PS. This code is written in a hurry and might miss some braces but please understand the logic You probably only need the sorting function in the end.
So here is the code. It has really bad indentation as i was in a hurry. You can use simple sorting logic using for loop. For this I have store data from file to an array of structure. I'd suggest not to use so many global variables in you program though. [Sort.c](https://gist.github.com/samarthak/490c493943e6cab90309921e50967ef1) 
If I send you my code. Is there a way for you to implement the sort by functions? It would help me so much!!! Thank you.
Sure! i'll give it a try.
The code is long so when people see it, they just skip it right away. I want people to read what is the problem first before I post the code. Sorry for any confusion :)) You are right I will post the code next time along with the summary. Thanks for your input!
Thank you. It makes it much easier. We don't need all the code, just the problematic part to get an idea of what you're doing.
What do you mean?
With signal masks you can handle them pretty well if you know what you are doing.
The use of `strncmp` is superfluous in this example as one string is a string literal. 
Free as in freedom. 
You are severely limited in what functions you can call safely from a signal handler (and the various `mem*()` and `str*()` calls were only marked asynch-safe in 2016!) that even with signal masks, it's still (in my opinion) a crap-shoot.
You rarely need to call othe functions anyway with proper program design.
[ProjectDemoWithSort.c](https://gist.github.com/samarthak/8909c16176ff76bc44f9181fe8efbb82) So you already had necessary indexing functions so I reused your own functions added some functions. But i'm not sure about those pointers though. I'm not so great with pointers. So please check them out but this code should show you the way. Ps. I left out sorting with weight becuse i already added ascending/descend sort with age, weight is similar to that
"I'm having trouble with functions " isn't a question. OK, so you're having trouble. What do you want us to do about it?
Note that `explain_ferror` is not a standard library function, neither in the C standard nor in the glibc. In fact, it comes from a separate library.
It means you've tried to access memory in a way that your OS doesn't think your program should. As I said in [your other thread](https://redd.it/9g9lv6), you should run your code through a memory usage debugger. I'm almost certain it will point exactly what you're doing wrong.
So somebody else here has mentioned something related to `\r`. The thing is, though, that should _not_ be a problem, so long as your input correctly uses your platform's line endings. In C, `\n` is the "newline" character. On Windows systems, the newline character is represented _externally_ as a carriage-return line-feed sequence. _Inside your program_, however, it is just a single character. You should _not_ need to handle `\r` specially. So long as your input uses the correct sequence of bytes to represent a newline, it will be read as a single `\n` character. What platform are you compiling this code for? Are you entering the input manually or redirecting a file in as input? If the latter, what line endings does it use?
It's both
This is a problem ( possibly not the only one): new = strndup(prefix, (strlen(currLine-&gt;line) + strlen(prefix) + 1)); strcat(new, currLine-&gt;line); I'm guessing you think the second argument of `strndup` is the number of bytes to allocate . It isn't. It's the maximum number of bytes to read from the source, excluding terminator. The number of bytes allocated is `MIN( strlen(arg1) + 1, arg2 )`. You then go on to write out of bounds with `strcat`. 
I dont think VS deserves a mention though. LLVM/Clang and GCC should be mentioned first.
Reddit formatting for code is 4 spaces at front of each line and a blank line at the end to separate the formatted text from the rest. I usually put one at the top as well 
It's not weird, it's how it works. It's perfectly defined.
It's "weird" in the sense that every other modern language supports operator overloading for string comparison. And for someone coming from any other language, this is a strange 'gotcha' that really shows how low-level C is acting. &amp;#x200B; Seriously, while it's totally consistent, being able to do: printf("Yes\\0No!" + ((b==0)&lt;&lt;2)); isn't the kind of endearing feature of C. &amp;#x200B; &amp;#x200B;
What were you thinking of, then?
`"yes"` just tells the compiler to insert the bytes `79 65 73 00` into the .data segment of the compiled program. A pointer to the memory address where they are written is then inlined wherever you reference `"yes"`. If your user input is getting written to 0xffffdddd, and your `"yes"` lives at 0xccccbbbb, using the `==` operator just performs a straight-up arithmetic comparison and finds that 0xffffdddd is not equal to 0xccccbbbb. You can see this by writing a small program that has a stack buffer and a string literal and printing out their locations in memory: #include &lt;stdio.h&gt; int main() { char yesno[3]; printf("stack buffer ptr: %p\n.data segment ptr: %p\n", yesno, &amp;"yes"); }
I thought there was a centralized place with the implementation of the language and its standard library, with stdio.h, stdlib.h, etc.
`"yes"` just tells the compiler that your program's .data segment, which stores some various stuff that the program needs, needs to store the bytes `79 65 73 00`. Whenever your reference "yes" in your code, it's inlined with a pointer to those bytes. `char yesno[3]` allocates 3 bytes of space on the stack when `main()` is called, and a pointer to these bytes is referenced whenever your source mentions `yesno`. Using the `==` operator on them is just a straight-up arithmetic comparison. If `"yes"` is in .data at idk, 0xccccbbbb and `yesno` is on the stack at 0xffffdddd, the CPU is going to subtract one from the other and say "Hmmmmmm, the result was 0x33332222, which isn't 0x00000000, so the two values must be different!". You can see this for yourself with a tiny program that contains a stack buffer and a string literal, and prints out their respective locations in memory: #include &lt;stdio.h&gt; int main() { char stack[8]; printf("stack ptr: %p\n.data ptr: %p\n", stack, &amp;"literal"); } Other people have said to use strcmp. This is why strcmp works but your code breaks. strcmp goes to the location in memory of the two strings and compares the bytes there, which is a lot harder than a basic arithmetic operation. Also, NEVER EVER EVER use scanf with %s. In the program in your post, your stack is free real estate.
You could have avoided the confusion if you'd simply given us the entire program from the start, and reading the instructions on the posting page. So, first, here is your program, properly formatted: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; /* Max length of 20 chars + 1 for null character */ #define MAXCHARS 21 /* Max amount of words */ #define MAXWORDS 1000 int main(int argc, char *argv[]) { int i = 0, n = 0, j = 0, chars = 0; char c, strarray[MAXWORDS][MAXCHARS]; while ((c = getchar()) != EOF) { if (c != '\n' &amp;&amp; c != '\r') { strarray[n][i] = c; i++; chars++; } if (c == '\n' || c == '\r') { strarray[n][i] = '\0'; n++; i = 0; } } strarray[n][i] = '\0'; for (i = 0; i &lt;= n; i++){ printf("\n"); for (j = 0; j &lt; MAXCHARS; j++) printf("%c", strarray[i][j]); } return 0; } Let's take it from the top: 1. You only need `&lt;stdio.h&gt;`. Your program does not use anything that is declared in the other three. 2. Your program does not use command-line arguments, so you don't need to declare them. Just use `int main(void)`. 3. You defined `c`, which you use to store the return value from `getchar()`, as `char`, but `getchar()` returns an `int`. Specifically, `getchar()` can return any value that will fit in a `char` *plus* `EOF`. This just happens to not have any practical consequences in this case, but in other circumstances, it might. 4. You modified your program based on incorrect information from other commenters. As far as I recall, the original `if` / `else` structure inside the input loop was perfectly fine. 5. You print a newline before each line instead of after. This is wrong. Not only will it result in a blank line at the top, but it will also result in output that isn't technically a text file, which is generally defined as a sequence of lines *terminated* by newline characters. 6. The current version of your program prints out the entire array, including uninitialized characters. I don't remember if the original also did that. You need to stop as soon as you reach the first null character, which is the one you yourself put there. Once again this just happens to not have any practical consequences in this program on your system (nor on mine), but unlike the `getchar()` issue earlier, you're actually *not allowed* to do it; it ‚Äúinvokes undefined behavior‚Äù, which is a technical phrase which you'll see a lot if you try to learn C in depth. And by the way, when you get to that null character, make sure you don't print it, or your output will, once again, not be a valid text file. 7. All in all, except for item 3 and possibly item 6 (and item 5, but that's mostly cosmetic), your original program was perfectly fine. It does exactly what it's supposed to with the input it is given. The problem is that your input contains blank lines, and your program does nothing to detect and ignore them. Assuming, of course, that what you showed us is the exact input you used; we can't be certain, because you didn't format it properly, despite repeated reminders to do so with your code.
It depends on the kind of data you're working it. Of it's dynamic, and you don't know what's the size is going to be you'll need to allocate inside the function, no way around it (we'll there is a way but it's pretty complicated. If you do know the length before hand then you can allocate before the call (or even better, if the size is static allow allocate it on the stack).
In general, it is safest to have allocation and deallocation (`malloc()` and `free()`) be handled by the same logical piece of the code. There are, of course, limitations. For instance, the caller might not know how much data is to me allocated: imagine a `read_next_paragraph()` function). The biggest problem with #2 is that it's a "special case" which can easily be overlooked, leading to hard to find bugs and odd logic. Consider how complicated the logic of `realloc()` can be just because of all the special cases. In your case, what if someone forgets to set the value to NULL? It's easy to forget that `free()` does not set the value to NULL. So, ideally, I would answer with #1, otherwise #3. Note that `strdup()` follows #3, for better or worse (I've had memory leaks because I didn't pay attention to that detail). 
If there are useful use cases where the user might chose his own place to allocate the structure, I go with (1). If there is no such use case, I go with (3).
2 is my least favorite because there's no need for that sort of "comfort" and it makes it hard to read code that sometimes does, sometimes doesn't allocate something before a call. All around terrible in my view. 3 is my favorite because the function knows how much memory is needed. Let's say you change the function down the road and it needs additional memory for the same task. You modify the amount allocated in the function, and all calling code still works. If you went with approach (1), you'd have to change all the calling code. I also think it makes sense to provide a de-allocation function instead of using free() directly. Who knows, maybe the cleanup will become more complicated in the future, or you're allocating two things instead of just one.
I agree with your points, particularly the one about having malloc and free handled by the same logical piece of code (if possible). I was leaning the same way but was struggling to convince myself that I wasn't over analyzing this issue and if it really mattered. Glad I asked.
If the caller knows the size of the object to allocate (because the struct definition or array size is known to the caller) then it is best the let the caller allocate it (or pass a pointer to a variable on the stack instead). But often the caller doesn't and shouldn't know the size, because it is not part of the API. In that case, the function should call malloc, and somehow return an out-of-memory error to caller if this fails. &amp;#x200B;
No need to fill up the CPU cache line (usually only 64 bytes) with ints when chars or shorts get the job done.
In general though it's a good habit to use small types when you don't need big ones.
There are probably hundreds of implementations of those with varying degrees of compatibility with the different C standards. The standards are encoded as documents describing how the language and the standard libraries *should* work and what assumptions the implementations can make. Every now and then, the committee responsible for the standards release a new one that adds new features and flattens out ambiguities. So it's not at all like Python (which has a reference implementation). C really predates any effort to standardize it. For a while the de facto standard was whatever came with UNIX. Then for a while, the Portable C Compiler was the de facto reference implementation. It wasn't until 1989 that the first ANSI C standard was complete, some 15 years after the Portable C compiler.
Not quite as small types (especially `short`) some times perform worse than ‚Äúlarge‚Äù types like `int` or `long int` and come with a bunch of caveats. For example, in C all types smaller than an `int` are converted to `int` for arithmetic which might be surprising. Another caveat is that often the range of a small type is going to be insufficient for the desired task in the near future. For example, consider the complications caused by insufficiently sized `time_t`, file offset (a 32 bit `long` was generally used before `off_t` came about), and `uid_t`. Unless there is a high chance that objects of the given type are used in high quantities, using a small type is often a premature optimisation.
&gt; For instance, the caller might not know how much data is to me allocated We can still use #1. One solution is to let the library function inform the caller how many bytes are needed. Glibc's `snprintf()` follows this route. `fgets()` sets another example, though it doesn't explicitly tell you if your buffer is large enough. In practice, however, this solution, especially the way `fgets()` implements it, is hard to work with and may be less efficient. Another solution that some libraries use is to let the caller specify the memory allocator.
&gt;**int** main &amp;#x200B;
What are you trying to do? Why is what returning an int?
That's only true in a hosted environment. It's implementation-defined in a freestanding one . 
Even then an implementation may provide other valid main functions iirc
Take a step back and explain at a higher level what you're trying to do, because having main return anything but an int (technically only 0, EXIT_SUCCESS and EXIT_FAILURE are portable values) makes no sense. You have an [XY problem](http://xyproblem.info/) right now.
If you want the program to print the commission then you need `printf` before return. Returning the answer, at the program's end, isn't very useful.
You shouldn't be trying to return a double from the main() function. You should be returning an int (as you have defined it) that indicates whether the program terminated in success or failure. As for your "double commission" value, what are you trying to return it to?
True, but always is a really strong word.
returning from main usually denotes the end of the application. main is the entry point of the program, and the exit point. Everything in between is what matters. Printing stuff, rendering stuff, writing files, etc. In your case, you already printed the value, so what more did you want to do with the commission value? maybe what you intend is to write a more general function that can be called from other functions. In this case, don't call the function main. call it double calculation_commision_from_input() put this into a header, then you can include the header in any application that needs this function.
True. In that case, the caller must know a max size, or know how to handle "less than expected" 
A dollar is 20, not 25
Print out what `1 / 3` is.
My outputs are displaying as 0 0 Instead of the inputted value and the outputted value.
I'm assuming your issue is accuracy. First of all, the format specifier `%f` is for float. `%lf` is for double. You should've received a warning for this from your compiler. The issue comes from your formula: 1 / 3 truncates to 0. So you're really doing `sqrt(2 * n * PI)`. You need to add a decimal to the 1 or the 3 (or both) to let the compiler know that those are doubles, not ints.
Strange that it didn't show any errors... Changed it to %1f and the formula 1 / 3 to 1.0 / 3 however it is now displaying as 0 1 I'm getting a little closer but still having issues.
I usually take option 4: write a pair of functions, a foo_alloc function that takes any initial values as arguments and returns a pointer to a foo. e.g. struct foo *foo_alloc(int val) { struct foo *f = malloc(sizeof(*f)); f-&gt;val = val; return f; } Then I would write a section function, foo_free, taking a pointer to foo. In this function, I would only free memory allocated by foo_alloc. So if foo happens to hold a pointer to a user allocatable data structure, its on them to deallocated it. The philosophy there is that we don't want to impose on the life time of data we didn't allocate. e.g. void foo_free(struct foo *f) { free(f); } 
That's supposed to be an L (`%lf`), not a 1. "Long float," basically.
Now I'm getting .0f .0f
Make sure you're also changing %f to %lf (L not 1) in your output function as well.
Did you lose the % somehow? printf("%.0lf\n", n); printf("%.0lf\n", n_fac);
There is no way to pass a `float` to `printf`, so `%f` means `double` there. It is `scanf` for which `%f` means `float*` and `%lf` means `double*`.
Makes no difference there; `%f` and `%lf` both mean `double` to `printf`, since there's no way to pass a `float` to a C variadic function.
%lf works for printf too. It's easier to learn 1 rule than 2.
Why do you even practise this kind of programs?
Thanks, I'll give this a try!
This a very newbie question, but, is there any specific way to implement the .syv directives? The machine is using GLIBC\_2.5, and I tried just adding this to the code: __asm__(".symver memcpy, memcpy@GLIBC_2.2.5") 