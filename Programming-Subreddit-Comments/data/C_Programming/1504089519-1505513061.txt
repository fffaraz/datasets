You can do this with almost all compiled languages, including Pascal, Haskell, Rust, [Go](https://stackoverflow.com/q/32215509/417501). Depending on how ‚Äúhigh level‚Äù the language you try to link with is, the effort might be somewhat high though.
Hi, Phlink75. If you were born in 1975, you're 4 years older than me. The book itself assumes no prior programming experience, and we're going to march forward a chapter at a time, together, through the book. So yes, it's noob friendly. I'm in Pennyslvania, USA, which is Eastern Daylight Time, UTC-4. I'm getting a handful of people saying they want to join, but don't expect that people will be online when you are. It could feel more like email sometimes, where you see what things the previous people said and then you add your own 2 cents, and the next day someone will respond to it. That still is more interesting than going through the book by yourself, with nobody to talk to about it. Would you be willing to make at least a single page of notes and share it, for each chapter that we go through?
If you need, I can try to summarize all concepts in an afternoon, with a kind of "fast-forward" approach. Maybe might help when you start to read the book. (I always read the entire book before start to study it on the second pass!) Let me know.
Look at [this](https://en.wikipedia.org/wiki/Application_binary_interface)
**Application binary interface** In computer software, an application binary interface (ABI) is the interface between two program modules, one of which is often a library and/or operating system and the other one is usually an application created by a regular programmer. In contrast to an API, which defines structures and methods one can use at software level, an ABI defines the structures and methods used to access external, already compiled libraries/code at the level of machine code. It does this by determining in which binary format information should be passed from one program component to the next, or to the operating system in the case of a system call. Thus it sets details such as the calling convention. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
That is a generous offer, thank you, but I'm not saying yes or no. About the word "need"... nobody in the group will *need* your notes, since everyone is supposed to be making their own. Your notes should be tailored to yourself, for what details you care about. Can be sloppy. Can use abbreviations that only you understand. That said, if it would benefit you and interest you to make the overall summary of the book, I'm sure the group would look at it and get benefit from it too. It's up to you if you feel like doing it. I wouldn't do that myself and I won't expect it of you. A lot of the time, materials that took a long time to prepare end up going unappreciated anyway. 
I never mentioned "notes." I was talking about having a friendly discussion/conversation on skype/whatever, on which in a couple of hours we can summarise the content of the book. The K&amp;C might scare, and most important: the book never answer stupid (but fundamental, when you start to learn) questions. BTW I feel some disappointment for my proposal, so I apologize and I retract it. Have fun with C, guys! It is still a great language :) (IMHO) 
How can I join? Can you also tell me about the Haskell study? I am also interested in but couldn't find any info.
I'm interested too.
I am very interested in joining this study group!
The Haskell group is following the book "Real World Haskell". Some members are using the paper version while others are using the free online veresion. We're going to be done with chapter 1 and starting chapter 2 on September 6, the same day the K&amp;R C group will be beginning their chapter 1. Would you be alright with making and sharing notes for each chapter that we go through?
Yes. I am more than alright since I have been studying the Haskell programming book from principles and making notes. So at least I am not totally new to the Haskell and I would be more motivated if working with others.
I'm in!
The code as you posted it does not even compile: cc -std=gnu11 -O2 -Wall -Wshadow -Wmissing-field-initializers -Wredundant-decls -Wstrict-prototypes -Wold-style-definition llist.c -o llist llist.c: In function ‚Äòmain‚Äô: llist.c:26:11: error: ‚ÄòNO‚Äô undeclared (first use in this function) p1 = (NO*)malloc(sizeof(NO)); ^ llist.c:26:11: note: each undeclared identifier is reported only once for each function it appears in llist.c:26:14: error: expected expression before ‚Äò)‚Äô token p1 = (NO*)malloc(sizeof(NO)); ^ llist.c:27:14: error: expected expression before ‚Äò)‚Äô token p2 = (NO*)malloc(sizeof(NO)); ^ llist.c:28:14: error: expected expression before ‚Äò)‚Äô token p3 = (NO*)malloc(sizeof(NO)); ^ llist.c:30:5: error: ‚Äònode1‚Äô undeclared (first use in this function) node1.ch = k1; ^ llist.c:31:5: error: ‚Äònode2‚Äô undeclared (first use in this function) node2.ch = k2; ^ llist.c:32:5: error: ‚Äònode3‚Äô undeclared (first use in this function) node3.ch = k3; ^ llist.c:18:10: warning: unused variable ‚Äòn3‚Äô [-Wunused-variable] node n3; ^ llist.c:17:10: warning: unused variable ‚Äòn2‚Äô [-Wunused-variable] node n2; ^ llist.c:16:10: warning: unused variable ‚Äòn1‚Äô [-Wunused-variable] node n1; ^ Also, when posting code, please format it with 4 leading spaces for each line, so reddit doesn't mangle it.
This also doesn't match the code you've posted. The variable 'n' is not declared anywhere.
D is compatible with the c abi, and you can actually write in a c/d language. It's c but with some sugar. Vala transpiles to c, nim transpiles to c, pony has a c abi. That's not an exclusive list, just off the top of my head. 
I'm interested ! I will probably read K&amp;R diagonally just to know what you guys are learning exactly each week but i'll mostly stick to my french book for learning C. I've learnt a few things already, but i'm still interested about that study group. Also i'm curious about the haskell study group, i'll check this out ^_^ So yeah, where do i sign up ?
Hi, KeroK127. The Haskell group is working through the book "Real World Haskell" (which is available free online) and began chapter 1 this past Sunday, Aug 27. For whichever group you want to join (maybe both), you'll have to be okay with making and sharing notes about each chapter as we go. Being a member of one group would let you see what the other group is doing and satisfy your curiosity without having to make notes for it. But at least one subject, you have to make notes for. Can you commit to doing that with either group?
Yes, i am interstes into working with others people, especially for learning C or Haskell. I'll probably take notes for both groups, but i can promise you i'll at least help for C. 
No blog spam please.
That's called casting, you're telling the compiler that the void pointer malloc is returning = ObjectName type, and the asterisk is the pointer. You don't HAVE to do it, I do it just to shut up the warnings.
Looks like you didn't fully remove this one.
Thank you. Now I did.
Having an .o file (or archive that contains the equivalent) is necessary but not sufficient to link with C. Naturally, the target architecture must match, and the .o file must have been generated with the right ABI. There's more though. Higher level concepts in the other language like exceptions and classes must be mapped somehow to C. See [SWIG](http://www.swig.org/compare.html) for a tool that generates the glue to interoperate with C.
If your starting from scratch I would say yes. I joined up having already done some coding and found it kind of tedious. 
Something else I ran into: valgrind doesn't like when checking a malloc'ed value for NULL. The program still runs, however. Using calloc instead solved the problem. Is this some kind of trade-off between speed and safety? 
I'm in ! We already have a discord server for this: I'll just post it here. https://discord.gg/DJdG9k
Tedious in what way? Because I know the fundamentals of programming
wtf is Code::Blocks?
I started it with a bit of programming knowledge. The C portions are only half the course and it seems to me the instructor uses C as kind of a "learn on a stick shift" approach. There's a point halfway through the course where the instructor literally throws a pair of training wheels off the stage and that marks the point where you begin to learn about other languages and some of the lower level operations of computer memory etc. Where I've been getting value in the course is learning about how programming works. I'm concurrently also taking a very good Java course from the University of Helsinki and what I've learned in CS50 has definitely made the course work easier for me. I would recommend CS50 as a broad introduction to how computer languages work and C is used as a teaching aid. I'm sure there are other good online courses to learn the C family of languages if you want to specialize in that language. 
When I click that link, it says "The instant invite is invalid or has expired." There has only been one invite link that has been made to invite people to the server and discord.gg/DJdG9k isn't it. You aren't one of the redditors I have spoken with before, so are you just trollin'?
No mate, the Link's broken and that's my bad. I'll create another one and post. Sorry ! Please calm down :(
I'm not upset, just confused by your post. I'm calm, no worries.
I am EST as well, in Rhode Island I was just curious as I would like to participate in discord as much as possible. What are you thinking notes wise? I am not the best note taker, but would be willing to give it a shot. 
Well it does compile and properly swaps stuff. Shouldn't it ?
Rhode Island -- nice. :) The notes should be done in whatever style suits you personally, selfishly, best. We can all pick up some good things from looking at each other's notes, but we don't have to write the notes like a tutorial. If you want to use cryptic abbreviations, do it. If some of the most important stuff of the chapter is something you know you won't forget, then don't jot notes about it, find something else to focus on. I want your notes to be of service primarily to you. See if you can at least fill up a page with notes, for each chapter. If you can do more, that's a bonus. You can type them -- or -- you can handwrite them and take a photo of them. The notes serve a handful of purposes actually, from helping others remember or realize good tidbits, to fostering the feeling of group cohesion -- that we're in this together. The primary benefit of notes is that they show me that the person is still invested in the study group and still gives a crap, enough to put in the effort and time to produce that documentation. I need to keep my finger on the pulse of people's level of involvement, because I don't want a sense of apathy and complacency to take over and destroy the group 3 months down the road. Glad to hear that you're on-board with the plan. On September 5 or 6 I will send you a link to the Discord server. If you want any help setting up a compiler before then, so that you know it's ready to compile your files, let me know. I don't want anyone to waste their first week of the study group by fighting with the settings on their computer. :-)
I think you should consider also providing a tutorial using Nginx. The problem is that Nginx does not support CGI so you need to use FastCGI only. Another problem is that Nginx does not currently have a FastCGI process manager and needs to rely on external software like spawn CGI. In Nginx you might have this: location /fcgi/ { fastcgi_pass unix:run/fcgi.sock; fastcgi_split_path_info ^(/fcgi/)(.*); fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; include fastcgi_params; } Then as part of some process manager you need to use spawn-fcgi (or similar software). $ spawn-fcgi -s /var/www/run/fcgi.sock -n /path/to/executable I'm not using CHL, but just basic FastCGI to run some sites that need a little bit of dynamic content.
Cross post to /r/programming They'd probably hate it because it'd outshine their language of the week, but whateve.
You can set the pointers with the desired values like so: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; typedef struct estr { char ch; struct estr *next; } node; int main(void) { node *n1; node *n2; node *n3; char k1; char k2; char k3; k1 = 'A'; k2 = 'B'; k3 = 'C'; n1 = (node *)malloc(sizeof(node)); n2 = (node *)malloc(sizeof(node)); n3 = (node *)malloc(sizeof(node)); n1-&gt;ch = k1; n2-&gt;ch = k2; n3-&gt;ch = k3; n1-&gt;next = n2; n2-&gt;next = n3; n3-&gt;next = NULL; while (n1) { printf("%c ", n1-&gt;ch); n1 = n1-&gt;next; } return (0); } 
I am usually wasting my time on discord anyway, I'll join although I am GMT +5.30
I've never used valgrind so I have no clue what's going on there. I prefer to use calloc because it guarantees the memory is zeroed when I get it back, and some places say it could be faster than just using malloc, but I haven't actually tested that myself. What OS are you on? that sounds like a really weird bug.
Just looking at this code tells me it won't compile. What is NO? What are node node etc? Your making three nodes on the stack AND on the heap. I imagine whatever version of this you got to compile has the stack nodes pointing to the heap nodes, which may or may not exist later. What you need to do is setup a bunch of functions that each safely do something like add a new node, remove a node, queries the list and returns a pointer to the node that has whatever value... 
It's an integrated development environment for C, C++, and Fortran based projects..
Any systems language worth its salt. Chicken Scheme. Technically Lua and other embedded scripting languages, though even if they do, they're likely wrapping a slow interpreter rather than truly compiling machine code.
I swear everytime I see the anonymous mask I cringe inside so hard.
&gt;they're likely wrapping a slow interpreter Not always. If you're clever you can find a way to make it run Lua-y compiled code using the same interfaces as normal native code. Also there's LuaJIT which intelligently generates native code at runtime as a "compilation" of the source code.
K&amp;R assumes some basic programming knowledge, even if it doesn't assume any previous knowledge of C. I'd be wary of saying it assumes 'no prior programming experience'.
No. First of all, you're assuming that `sizeof(*ptr)` will return the size of whatever `ptr` points to, but it doesn't‚Äîit returns the size of the type that `ptr` was declared to point to (in this case, `void`). Second, `sizeof(void)` is undefined. It may work with some compilers with warnings turned off, but that's a holdover from a time when people commonly used constructs such as `#define void char` so their code would work with compilers that didn't have `void` (which was introduced in the late 1980s). So I guess if you're on a little-endian platform and using a compiler that evaluates `sizeof(void)` to 1 instead of rejecting it like it should and you try to `ft_swap(&amp;a, &amp;b)` where `a` and `b` are both integers of small or nearly equal values, it will seem to work because `ft_swap()` will swap the first (least-significant) byte. But try it with `int a = 0, b = -1` or strings or whatever and you'll see that it doesn't work. Besides, it adds a huge amount of overhead to what should be a simple memory-to-memory operation in the worst case, and register-to-register in the best case (where the compiler has optimized away both arguments, which using `ft_swap()` prevents). The best way do swap two values in C is to use something like the following macro: #define swap(a, b) do { (a) ^= (b); (b) ^= (a); (a) ^= (b); } while (0) It will only work reliably for integer types‚Äîit *may* work for floats and pointers, but probably not without a warning (I can't be bothered to check right now, but I'm pretty sure it's undefined for pointers, and either undefined or implementation-defined for floats). Addendum: The advantage of the above macro is that it does not need to know the type of the variables it is swapping. You can write a more general version of that macro, which will work with any scalar type, but it's more cumbersome as you need to specify the exact type each time: #define tswap(a, b, type) do { type t = (a); (a) = (b); (b) = t; } while (0) For pointers only, you *could* use something like this: #define ptrswap(a, b) do { void *t = (a); (a) = (b); (b) = t; } while (0) but you're courting undefined behavior if `a` and `b` are not the same type, and depending on compiler settings, it may not work for qualified pointers (like `const char *`). If you want to swap the *contents* of two arrays or structs, rather than just pointers to them, you can write a function that takes two pointers and a size and use the xor trick to avoid allocating a temporary buffer: void bigswap(void *a, void *b, size_t len) { while (len &gt; sizeof(unsigned long)) { *(unsigned long *)a ^= *(unsigned long *)b; *(unsigned long *)b ^= *(unsigned long *)a; *(unsigned long *)a ^= *(unsigned long *)b; a = (char *)a + sizeof(unsigned long); b = (char *)b + sizeof(unsigned long); len -= sizeof(unsigned long); } while (len &gt; 0) { *(unsigned char *)a ^= *(unsigned char *)b; *(unsigned char *)b ^= *(unsigned char *)a; *(unsigned char *)a ^= *(unsigned char *)b; a = (char *)a + 1; b = (char *)b + 1; len -= 1; } } This assumes that the objects pointed to by `a` and `b` are properly aligned for `unsigned long` (which is true of any pointer returned by `malloc()`). If you can't guarantee proper alignment, you'll have to remove the first loop.
Sounds similar to this: https://learnbchs.org/
It's pretty hard to understand what you really need. But trying is important when dealing with C program that's how you know if things work. Just watch out, as programming with C can get a bit complex sometimes and it might affect with errors within the code. Those errors must be dealt and fixed as fast as possible. There are programs that helps detecting those, such as checkmarx. After that you have to fix them. Good luck!
Which tutorials or books shouls i study to understabd your post? Sincerely, old C programmer. Not even kidding.
I find going over stuff I already know is kind of boring. While I don't know everything or even a fraction of what's taught I couldn't tough it out to get to where I was learning stuff that was new/challenging/interesting. 
That's just a config file, read nginx's man page.
I believe it implements its own fastcgi.
Funny, I started tonight reading KnG instead of K&amp;R ... But I am more a lone wolf! haha
I'm not a big stickler about licencing, so I just use the MIT license in all my projects. People can use my stuff pretty much however they want.
[Apple's](https://opensource.apple.com/source/Libc/Libc-825.24/string/strcat.c) `strcat` implementation. You can create your own way of doing pretty much anything that is in any C header. These C header files are there as a commodity, to help you save time by not having to implement common things like: allocating memory, copying strings, concatenating strings and so on... Search for `string.h` implementation and you'll see that it's just C code that you can write yourself.
Yep, they are just null terminated arrays. You can download c standard libraries reference implementations and build/modify them yourself.
huaehueahu!
MacOS or Windows? I rather stare the sky all day long, instead! 
I imagine buying an anonymous mask must feel about like a teen buying condoms for the first time.
Count me in too! Just picked up a copy the other day so great timing
oh...the scope resolution operator confused me. I though he was asking about something related to a C/C++ library. Why would code::blocks name themselves that way...I guess it's a nice way to attract the young crowd.
There is no reference implementation.
This is so interesting. Will definitely check out!
C is very flexible and you can do pretty much everything with. By the way, that's what makes it a bit more complex and therefore vulnerable to errors and bugs. Those can be dealt with programs as checkamrx or just be avoided when programming correctly without errors.
That look pretty good. I'd recommend you keep on what you and get better. C is all about practicing, you have to do it for a long time to be better. C is a very complex language which makes it a lot harder then other languages. This complexity can sometimes lead your code to suffer from bugs and errors, those can be dealt with programs such as checkmarx but it always recommended to learn how to detect them on your own while writing your code. Good luck.
This doesn't make sense. You can't make the strict itself equal to anything. 
Well, that's only partly true. The as-if rule allows hosted implementations to replace calls to standard library functions with any code that produces the exact same result. For instance, calls to `printf()` or `fprintf()` with no other arguments than the format string, or a format string consisting only of `%s`, are often replaced with calls to `fputs()`. More importantly in this case, most compilers will replace calls to functions such as `strcat()`, `strcpy()`, `strlen()`, `memset()`, `memcpy()` etc. with inline code; on x86 and its descendants, `memcpy()` can be done in just four instructions. So if you want to write your own `strcat()` (but why would you?) you'd better call it something else. And even then, the compiler might recognize what it does and replace it with inline code that does the same thing...
You can assign one struct to another of the same type as long as they don't contain flexible members. But the code in question won't compile, because it's assigning a pointer to a struct. There is a `*` missing on either one side of the assignment or the other. My best guess here is that `p` is a pointer to `struct addrinfo`, and it has already been determined that `p-&gt;ai_family == AF_INET` so that `p-&gt;ai_addr` *actually* points to a `struct sockaddr_in`; the assignment to `v4` (which is almost certainly intended to be a pointer, not a struct) allows the rest of the code to access its contents without having to constantly cast the pointer. See [getaddrinfo(3)](https://www.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3) and [inet(4)](https://www.freebsd.org/cgi/man.cgi?query=inet&amp;sektion=4) for further details.
p is dereferenced with p-&gt; and the ai_addr struct is then copied to v4.
You can in general. There's no problem initializing a struct from another variable. ...Except...assuming `p` is a pointer to a `struct addrinfo`, there's still a missing `*` operator. If you changed it to: struct sockaddr_in v4 = *(struct sockaddr_in *)p-&gt;ai_addr; There's no problem with it. To OP: the answer to "what does this code mean" depends on what you know already. But an addrinfo represents a network service. One of the fields in that network service is `ai_addr`, which is the network address the operating system is telling you to either bind to or connect to, depending on what kind of socket you're making. `ai_addr` is of type pointer to `struct sockaddr`, which is an abstract type representing any type of network address. If you know the address is an IPv4 address, you need to explicitly cast it to a pointer to `struct sockaddr_in` (which is an IPv4 address) and then dereference it. If that didn't make sense, you're going to have to be more explicit about what you understand and don't understand.
&lt;3
Cool!
Okayüëçüëç
Yeah but buying condoms normally indicates getting laid while this mask normally indicates the opposite.
Ya, that v4 is actually *v4.
Right, so it's assigning one pointer to another to avoid casts. The compiler will most likely optimize `v4` away entirely.
Yes, reference is a bad word, that implies it comes from the standards committee.
mean* it's casting ai_addr in struct p to a pointer to sockaddr_in
I mean, the naive way to do it is to get the length of the both strings, and loop from the end of the first to the end of the second, after calling realloc with String1Size + String2Size as the size
C strings are just char arrays with a null ('\0') char marking it's "real" end (instead of the size of the array). In that sense, C string manipulation are just arrays with a twist. And that's the cause of so much pain and buffer overruns and segmentation faults in many software.
Thanks:)
Others have pointed out that this is a cast. In the _Ye Olde Days_ (pre C89) `malloc()` actually returned `char *` rather than `void *` because `void *` was not part of the language yet and at that time `char *` was how you did type independent stuff. At that time, a cast here was considered "good form". Now that `malloc()` returns `void *` the compiler is able to automatically do the cast for you so there is no reason to explicitly do the cast. Plus, the cast could squelch potential issues the compiler would otherwise squawk about.
I haven't read it but I can't think of any reason not to do it.
I checked and you are right, I was wrong. Oops. Thanks for the correction. I will let people know.
wtf
I tried googling for KnG programming book, but still couldn't figure out what you're referring to. What's the title?
 oh wow .. CGI still alive after all these years. https://tools.ietf.org/rfc/rfc3875.txt 
Well that makes things much more clear! The asterisk means v4 is only holding an address to where the struct is in memory.
Some highlights that stood out to me: - Improper use of git (`CHL_OLD_SRC` dir in the repo) - Anonymous mask (much haxx0rs wow) - **C** web framework that's **easy to use** - PHP-like(&lt;3) templates (love me some C mixed with HTML) - **Unique** build system
So... Is it still beginner friendly?
Did any of those libraries redefine something like the size_t?
I don't see anything wrong with the code you provided. On the other hand, I don't see anything that would call `malloc`, making me think the error is elsewhere. It *could* be a library bug, but it's far, far more likely there's an error in your code (maybe relying on implementation-defined behavior or having some undefined behavior somewhere).
That depends on the beginner. Some people "get it" a lot easier than other people. I'm willing to spend some hours helping anyone who needs it. That might be all you need, or you might need a lot more help than I can provide. We can still try to do it. If you get lost within the first couple weeks, at least you'll have learned a few things and not be any worse off than if you hadn't tried to learn it.
 FILE *fp; FILE *pp; fp = fopen("dadosUser.dat", "r"); pp = fopen("dadosDocumento.dat", "r"); int quantidadeUser = 0, quantidadeDoc = 0; utilizador *registo = malloc(MAX * sizeof (utilizador)); Documento *registo1 = malloc(MAX_DOC * sizeof (Documento)); if (ficheiroExiste("dadosUser.dat") == 1) { printf("Ficheiro dadosUser.dat existe.\n"); printf("A carregar informacao ...\n"); free(registo); registo = leFicheiroBinario_User(&amp;quantidadeUser); } if (ficheiroExiste("dadosDocumento.dat") == 1) { printf("Ficheiro dadosDocumento.dat existe.\n"); printf("A carregar informacao ...\n"); free(registo1); registo1 = leFicheiroBinario_Documento(&amp;quantidadeDoc); } quantidadeDoc = acrescentaDoc(registo1, quantidadeDoc); // gravaFicheiroBinario_Documento(registo1, quantidadeDoc); I only used malloc here 
You're right. I need to learn C anyway, and I'm willing to learn and research on my own(there are other subs and people I could ask). The pace doesn't seem to be too fast and I have quite a bit of free time in the next 30 days, so at least in the beginning I should be fine. 
That looks reasonable, too. (Tip: put four spaces in front of each line of code so Reddit formats it correctly.) What's usually going on in situations like this is heap corruption. For example, maybe somewhere else you might be writing outside the memory you've allocated here. Like, if there's more than `MAX_DOC` entries being read or something. This type of bug can be very hard to track down. That's why tools like valgrind exist, and that should be your next step.
How do we use valgrind? Never listened about this tool before 
Have you tried running your code through valgrind? valgrind --tool=memcheck ./program You probably have a memory corruption issue. Maybe you've underallocated memory somewhere and written over the end, or used a pointer after freeing it. Valgrind should help you identify if there's any use of unallocated memory and where it occurs. I also can't find any problem in the code you've posted that would cause this, often memory corruption can happen much earlier in the program than when the fault occurs so this code might not be to blame.
Didn't you know? C is unsafe for everything! You should write it in ~~Haskell~~ ~~Go~~ ~~Node.js~~ ~~Electron~~ Rust!
[Here's the quick start](http://valgrind.org/docs/manual/quick-start.html). It's usually pretty simple to run, but interpreting the results can be tricky. I would highly recommend compiling with debug enabled (`-g`) to get line numbers when it detects an error.
This is awesome man!
If you don't mind old, mostly unmantained, and completely macro based code, you could try [Sglib](http://sglib.sourceforge.net/). Unfortunately C is the land of NIHS and DIY people, so there are very few general purpose libraries.
The CHL_OLD_SRC is only there for the feels. The anonymous mask is for the hackzz. 
I write my own tuned to the specific use case when I need it. So far, use cases have been rather rare.
Yeah. When learning C, I definitely appreciate its simplicity over the convenience of having the exact thing you need in a language, at the expense of a vast knowledge of all the standard functions, features, structures, behaviours, etc.
C is elegance in simplicity. The learning curve of other languages (Rust in this case) comes from the fact that, even though C is straightforward, it doesn't mean that it's easy to write maintainable C code. Rust helps you write more reliable code most of the time, while C doesn't.Take Rust ownership model, for example, it's there to prevent bugs that C will allow you to make. Maybe you'll have an easier time if you approach learning Rust as if it was a tool that prevents you from writing completely buggy C programs. Whenever you're reading about a Rust feature try to reason about why it's there. Try to imagine how you could mess up if you wrote the same piece of code in both C and Rust, then you'll see the value of these things. I would say that many Rust features do not actually add any height to the learning curve, they are just preventing problems that you did not have to thought about yet, so you never got to experience what the C code equivalent would be, hence why they look like they are new things. It took me a while to learn Rust because of my own lack of experience, because it's a language that requires you to write what would be more reliable C code from the start, but when you finally understand it, the payoff is actually quite nice. In my experience, it made me a better C programmer quicker than it would take if I kept myself just writing C.
C is easy to learn, very hard to master. A lot of what beginner and intermediate C programmers think is correct, is in fact very wrong. Compilers allow it, until they don't. C also lacks the ability to model a lot of things. The typing system is super loose, which results in everyone tries to build up their own complex system on top of it, which then has to be learned when trying to use the larger external libraries. The history of C also shows up. Having lived much of its life without types that had absolutely defined sizes (e.g. uint16_t, int32_t), lots of libraries declare their own types for the simplest things. A lack of namespaces means variable end up with prefixes. The build system gets complex very quickly. For small simple projects it is really simple, for larger projects, the build system is a measurable % drag on productivity. I love C, and if large C projects are ran with a very strict hand, the language can scale up wonderfully, but nothing in C's design makes it easy to do the correct thing. 
==29633== Invalid write of size 4 ==29633== at 0x109295: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f928 is 0 bytes after a block of size 0 alloc'd ==29633== at 0x482E1FC: malloc (vg_replace_malloc.c:298) ==29633== by 0x4830520: realloc (vg_replace_malloc.c:785) ==29633== by 0x108D89: leFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089D8: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== ==29633== Invalid write of size 4 ==29633== at 0x1092B7: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f92c is 4 bytes after a block of size 0 alloc'd ==29633== at 0x482E1FC: malloc (vg_replace_malloc.c:298) ==29633== by 0x4830520: realloc (vg_replace_malloc.c:785) ==29633== by 0x108D89: leFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089D8: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== m m ==29633== Invalid read of size 1 ==29633== at 0x483559C: __GI_mempcpy (vg_replace_strmem.c:1525) ==29633== by 0x48C3D6A: _IO_file_xsputn@@GLIBC_2.1 (fileops.c:1327) ==29633== by 0x48B896C: fwrite (iofwrite.c:39) ==29633== by 0x108CB1: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f957 is 1 bytes before a block of size 1,024 alloc'd ==29633== at 0x482E2BC: malloc (vg_replace_malloc.c:299) ==29633== by 0x48B743E: _IO_file_doallocate (filedoalloc.c:101) ==29633== by 0x48C5A75: _IO_doallocbuf (genops.c:398) ==29633== by 0x48C4AAB: _IO_file_underflow@@GLIBC_2.1 (fileops.c:564) ==29633== by 0x48C5B2A: _IO_default_uflow (genops.c:413) ==29633== by 0x48B8E50: _IO_getline_info (iogetline.c:60) ==29633== by 0x48B8F8D: _IO_getline (iogetline.c:34) ==29633== by 0x48B7D88: fgets (iofgets.c:53) ==29633== by 0x109338: lerString (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108F70: Registo1 (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x109210: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== ==29633== Invalid read of size 1 ==29633== at 0x4835590: __GI_mempcpy (vg_replace_strmem.c:1525) ==29633== by 0x48C3D6A: _IO_file_xsputn@@GLIBC_2.1 (fileops.c:1327) ==29633== by 0x48B896C: fwrite (iofwrite.c:39) ==29633== by 0x108CB1: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f956 is 2 bytes before a block of size 1,024 alloc'd ==29633== at 0x482E2BC: malloc (vg_replace_malloc.c:299) ==29633== by 0x48B743E: _IO_file_doallocate (filedoalloc.c:101) ==29633== by 0x48C5A75: _IO_doallocbuf (genops.c:398) ==29633== by 0x48C4AAB: _IO_file_underflow@@GLIBC_2.1 (fileops.c:564) ==29633== by 0x48C5B2A: _IO_default_uflow (genops.c:413) ==29633== by 0x48B8E50: _IO_getline_info (iogetline.c:60) ==29633== by 0x48B8F8D: _IO_getline (iogetline.c:34) ==29633== by 0x48B7D88: fgets (iofgets.c:53) ==29633== by 0x109338: lerString (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108F70: Registo1 (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x109210: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== ==29633== Syscall param write(buf) points to uninitialised byte(s) ==29633== at 0x4930C13: __write_nocancel (syscall-template.S:84) ==29633== by 0x48C36C4: _IO_file_write@@GLIBC_2.1 (fileops.c:1271) ==29633== by 0x48C25C0: new_do_write (fileops.c:526) ==29633== by 0x48C48AC: _IO_do_write@@GLIBC_2.1 (fileops.c:502) ==29633== by 0x48C40E2: _IO_file_close_it@@GLIBC_2.1 (fileops.c:173) ==29633== by 0x48B7590: fclose@@GLIBC_2.1 (iofclose.c:58) ==29633== by 0x108CF0: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1ff44 is 52 bytes inside a block of size 4,096 alloc'd ==29633== at 0x482E2BC: malloc (vg_replace_malloc.c:299) ==29633== by 0x48B743E: _IO_file_doallocate (filedoalloc.c:101) ==29633== by 0x48C5A75: _IO_doallocbuf (genops.c:398) ==29633== by 0x48C4D70: _IO_file_overflow@@GLIBC_2.1 (fileops.c:828) ==29633== by 0x48C3DCF: _IO_file_xsputn@@GLIBC_2.1 (fileops.c:1339) ==29633== by 0x48B896C: fwrite (iofwrite.c:39) ==29633== by 0x108C9D: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Appeared this long error, don't understand anything about it yet, can u help? 
Never used it before, but tried and gave me this error: ==29633== Invalid write of size 4 ==29633== at 0x109295: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f928 is 0 bytes after a block of size 0 alloc'd ==29633== at 0x482E1FC: malloc (vg_replace_malloc.c:298) ==29633== by 0x4830520: realloc (vg_replace_malloc.c:785) ==29633== by 0x108D89: leFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089D8: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== ==29633== Invalid write of size 4 ==29633== at 0x1092B7: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f92c is 4 bytes after a block of size 0 alloc'd ==29633== at 0x482E1FC: malloc (vg_replace_malloc.c:298) ==29633== by 0x4830520: realloc (vg_replace_malloc.c:785) ==29633== by 0x108D89: leFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089D8: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== m m ==29633== Invalid read of size 1 ==29633== at 0x483559C: __GI_mempcpy (vg_replace_strmem.c:1525) ==29633== by 0x48C3D6A: _IO_file_xsputn@@GLIBC_2.1 (fileops.c:1327) ==29633== by 0x48B896C: fwrite (iofwrite.c:39) ==29633== by 0x108CB1: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f957 is 1 bytes before a block of size 1,024 alloc'd ==29633== at 0x482E2BC: malloc (vg_replace_malloc.c:299) ==29633== by 0x48B743E: _IO_file_doallocate (filedoalloc.c:101) ==29633== by 0x48C5A75: _IO_doallocbuf (genops.c:398) ==29633== by 0x48C4AAB: _IO_file_underflow@@GLIBC_2.1 (fileops.c:564) ==29633== by 0x48C5B2A: _IO_default_uflow (genops.c:413) ==29633== by 0x48B8E50: _IO_getline_info (iogetline.c:60) ==29633== by 0x48B8F8D: _IO_getline (iogetline.c:34) ==29633== by 0x48B7D88: fgets (iofgets.c:53) ==29633== by 0x109338: lerString (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108F70: Registo1 (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x109210: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== ==29633== Invalid read of size 1 ==29633== at 0x4835590: __GI_mempcpy (vg_replace_strmem.c:1525) ==29633== by 0x48C3D6A: _IO_file_xsputn@@GLIBC_2.1 (fileops.c:1327) ==29633== by 0x48B896C: fwrite (iofwrite.c:39) ==29633== by 0x108CB1: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f956 is 2 bytes before a block of size 1,024 alloc'd ==29633== at 0x482E2BC: malloc (vg_replace_malloc.c:299) ==29633== by 0x48B743E: _IO_file_doallocate (filedoalloc.c:101) ==29633== by 0x48C5A75: _IO_doallocbuf (genops.c:398) ==29633== by 0x48C4AAB: _IO_file_underflow@@GLIBC_2.1 (fileops.c:564) ==29633== by 0x48C5B2A: _IO_default_uflow (genops.c:413) ==29633== by 0x48B8E50: _IO_getline_info (iogetline.c:60) ==29633== by 0x48B8F8D: _IO_getline (iogetline.c:34) ==29633== by 0x48B7D88: fgets (iofgets.c:53) ==29633== by 0x109338: lerString (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108F70: Registo1 (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x109210: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== ==29633== Syscall param write(buf) points to uninitialised byte(s) ==29633== at 0x4930C13: __write_nocancel (syscall-template.S:84) ==29633== by 0x48C36C4: _IO_file_write@@GLIBC_2.1 (fileops.c:1271) ==29633== by 0x48C25C0: new_do_write (fileops.c:526) ==29633== by 0x48C48AC: _IO_do_write@@GLIBC_2.1 (fileops.c:502) ==29633== by 0x48C40E2: _IO_file_close_it@@GLIBC_2.1 (fileops.c:173) ==29633== by 0x48B7590: fclose@@GLIBC_2.1 (iofclose.c:58) ==29633== by 0x108CF0: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1ff44 is 52 bytes inside a block of size 4,096 alloc'd ==29633== at 0x482E2BC: malloc (vg_replace_malloc.c:299) ==29633== by 0x48B743E: _IO_file_doallocate (filedoalloc.c:101) ==29633== by 0x48C5A75: _IO_doallocbuf (genops.c:398) ==29633== by 0x48C4D70: _IO_file_overflow@@GLIBC_2.1 (fileops.c:828) ==29633== by 0x48C3DCF: _IO_file_xsputn@@GLIBC_2.1 (fileops.c:1339) ==29633== by 0x48B896C: fwrite (iofwrite.c:39) ==29633== by 0x108C9D: gravaFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x108A02: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== 
Rust is a complex language that allows you to express things simply. C is a simple language that makes you express simple thing difficultly. With Rust, you'd do best to write some small test bed programs to explore and better understand the type system, barrow checker, and idioms in rust. Get a feel for the language before jumping headlong in. It's a different beast than what almost everyone is used to.
No idea about Rust, but you might try Python. I found that barrier to entry pretty low. It works well for task-based applications such as a replacement for advanced bash-scripting or data science analyses. I tend to find that things like frameworks and common corporate practices take much more time to learn than languages themselves. For example, I could write a simulation in C# pretty easily, and used to be able to create web applications when ASP.Net was pretty new. But now everyone is mixing with Angular, using NuGet packages and integrating with Azure. It's an entire ecosystem. It's similar to Java - plain Java is pretty easy, but writing an Android app is much more than just Java.
You should really recompile your code with `-g` (as /u/boredcircuits recommended), that will make valgrind show the line numbers where the errors happened. It's not that hard to read that valgrind output. The first 3 lines of ==29633== Invalid write of size 4 ==29633== at 0x109295: acrescentaDoc (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089ED: main (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== Address 0x4a1f928 is 0 bytes after a block of size 0 alloc'd ==29633== at 0x482E1FC: malloc (vg_replace_malloc.c:298) ==29633== by 0x4830520: realloc (vg_replace_malloc.c:785) ==29633== by 0x108D89: leFicheiroBinario_Documento (in /root/NetBeansProjects/LP_ESPECIAL/main) ==29633== by 0x1089D8: main (in /root/NetBeansProjects/LP_ESPECIAL/main) say that some code in function `acrescentaDoc` is doing a write of size 4 (so probably an `int`) to a region of memory that shouldn't be written to. To know where exactly is this code you must compile your code with `-g`. The next 5 lines are saying that the memory that was written to is 0 bytes after a block that was allocated with size `0` (and that block was allocated with `realloc()` in function `leFicheiroBinario_Documento`). Again, to know the exact location of that `realloc()` call you must compile with `-g`. The problem seems to be that you're calling `realloc()` with size `0` where it should be some other size.
You are receiving data from socket, so you know the length of data which you received. You can just check if the end of the data is null. If not add the null terminator.
thanks!
&gt; There is a maximum size that this string can be, so we can statically allocate a char array. If you are sure there is room for the null terminator in the char buffer, then you can add one with `buf[len] = '\0'` where len is the length of the received string.
I think we need a bit more details before being able to answer this question.
There is a lot of information missing. Platform, compiler, IDE, etc.
Active debugger config: GDB/CDB debugger:Default Building to ensure sources are up-to-date Selecting target: Debug ERROR: You need to specify a debugger program in the debuggers's settings. (For MinGW compilers, it's 'gdb.exe' (without the quotes)) (For MSVC compilers, it's 'cdb.exe' (without the quotes)) 
this is what it says
im using codeblocks, my compiler is GNU GCC
plz help, this is driving me insane :(
im using codeblocks, my compiler is GNU GCC.....plz help :(
my code wont freaking run
https://stackoverflow.com/questions/21083560/how-do-you-specify-a-debugger-program-in-codeblocks-12-11
I was thinking that the barrier for entry to C was actually really high, which is why most programs aren't written in C anymore: sure you can learn how to write a function and about arrays and loops and conditional/switch statements, but few people make anything noteworthy with it (edit) anymore (/edit) because it requires the skill and finese of a rocket scientist - depending on the project. Someone who knows what they're doing in C is going to see much better performance and efficient use of the underlying machine than any of the managed code languages that add more degrees of separation between the coder and the machine hardware that they're trying to leverage. 
that's an IDE issue, not a C issue, and you didn't even bother to tell us what IDE you're having trouble with. Ask in /r/TechSupport, the proper forum for this type of question.
I don't quite understand the question. 
gdb
All true. When C was invented, it was described to me as a substitute for assembly language. In those days, assembly language was the only way to do a lot of things, and especially the only way to write operating system code. I was super skeptical that C could replace assembly, but it totally does. The key thing is: C lets you do almost anything you could do in assembly, and does *nothing* to prevent you from screwing yourself badly. The other thing is: the bulk of the C standard library consists of stuff they thought was a good idea in 1972. Use Java or Python long enough, then go back to C, and you'll be banging your head against the wall. Still, I write a lot of operating system code, and there's no other language for that but C or C++. An old joke, but still applicable: Pascal is a squirt gun filled with distilled water. C is a .45 which is pointed at your foot by default. Which would you give to students to learn with? Which would you rather have in your hand if you had a real problem to solve? Ansi C adds a safety to that .45
Make your buffer one more byte than the maximum allowed string. (Or more if you allow Unicode.)
Networking code is agnostic as to how addresses are specified. There's IPv4, IPv6, Unix sockets, and so forth. So p points to a structure that contains information about what kind of addressing is in use, and a pointer to the address in whatever format it's in. This fragment of code has examined the structure and determined that the address is an IPv4 address (or assumed this, which is double-plus ungood). Having determined that p-&gt;ai_addr is a pointer to an IPv4 address, it's then cast to a pointer to "struct sockaddr_in" which is an IPv4 address, and then assigned to the variable v4. This code is broken, I think. Probably a typo when you typed it in. **v4** should be a *pointer* to struct sockaddr_in.
Certainly. It would be an interesting Programming 101 homework assignment or an interview question. After all, the strcat() function was written in C in the first place.
&gt; I was wondering what you guys and gals use as your go-to hash map? I very rarely have data that can't be pre-sorted into an array, and then accessed with a simple binary search, so there's not that much need for a map type. When I need one, I tend to just hash into a fixed-sized array of lists (or arrays) that contain the hash collisions. That's easier written than borrowed from elsewhere. What's your use-case for a map? 
The book and exercises are well worth it and overall cater to self-studying enthusiasts (e.g. [here are some cool labs](http://csapp.cs.cmu.edu/3e/labs.html) for self-study students).
Ha. I had a company that I interned with contract with someone to have a product demo that was a web app, and it was too slow to properly demo their high speed data features. This was after I made a console visualization application (c/c++) for their previous product where a good chunk of my presentation was how I went out of my way to make it able to handle and display high speed data transfers from the DSP core. They tried to make their new product's web app perform at speed with Javascript. This is a great idea! Thanks.
Please don't spam.
&gt; C is easy to learn, very hard to master. A lot of what beginner and intermediate C programmers think is correct, is in fact very wrong. Compilers allow it, until they don't. This captures my experience with C very well. Recently I was wondering why my compiler warned me about passing a float\*\* as an argument to a function expecting a void\*\*. It wasn't too hard to find the correct answer, but on my way there I came across several posts advising to simply cast the float\*\* to void\*\*, without mentioning that this isn't correct by any C standard; it's just overwhelmingly likely to coincidentally work on your concrete implementation. The creators of C initially compromised ease of writing C code for the ease of implementing C compilers. (\*In Bill Nye's 'old guy' voice\*: Well, you know, we had to work 29 hours a day, translating our code to holes in cardboard by dribbling sulphuric acid from our nostrils, and pay the mainframe owner for permission to come to work, and when there was a syntax error, the managers would kill us, and dance about on our graves singing 'Hallelujah'.) Since then, they've been extremely reluctant to break backwards compatibility. When I write production-quality Python, I sometimes get so bored that I spin off a recreational side project that, for example, factors out asynchronous cross-cutting concerns into metaclasses injected via class decorators. Of course I know better than to foist such a monstrosity onto unsuspecting colleagues; it's just an amusing way of furthering my knowledge of the language. Yet when I write just about adequate C, I'm still discovering interesting quirks of fucking pointers, which should have stopped happening in my second year of studying computer science. This isn't saying anything about barrier to entry. There are many fruitful approaches to plotting two circles. I'm merely musing about what's going to happen once you want to draw the rest of the fucking owl.
plz to help
&gt; but few people make anything noteworthy with it ‡≤†_‡≤† You just dissed every embedded engineer out there with one sweeping bleat of ignorance. Dude, you have *no clue*.
If your question is interpreted as a trick question, then technically speaking, you don't need to include (use) string.h in order to call the regular strcat(). From the standard (7.1.4#2): "Provided that a library function can be declared without reference to any type defined in a header, it is also permissible to declare the function and use it without including its associated header." 
&gt; Compilers allow it, until they don't. Getting into the habit of compiling with at *least* `-Wall -Wextra -Werror` is good. I would say `-Weverything -Werror`, but that can be a bit too restrictive, complaining about things that aren't technically in the standard but every compiler people care about allows.
&gt; Use Java or Python long enough, then go back to C, and you'll be banging your head against the wall. C would be great with some clean data structures that come *in the standard* in a usable form. Like a hashmap. `hcreate` seems to be a POSIX standard, so that sounds great, there's a hashmap in the standard that you can use everywhere! Except you can only use *one* hashmap, since it uses a global variable for state. And the re-entrant versions are GNU extensions (And it's kinda a shit API as is). Just put the most commonly used data structures in with a clean API that lets you provide your own hashing and equality function, for example. 
lots and lots of new projects are done in C, but they don't/won't get noticed because everyone assumes C is really hard/dangerous. Search around Github for projects done in C Also, the types of projects made with a given language vary widely, and thus their fame varies widely, esp because of what fields/technologies are popular or hot at any given time. And everyone rags on C like it "requires the skill and finese of a rocket scientist" but so do projects written in **any** language. A huge MMO has many "rocket scientist" types keeping everything running smoothly. A Python backed website has at least a few "rocket scientist" types to keep it working well. Too many people have strong opinions about C without having used it for something substantial. (I use C for tool writing every day in my work. Everything from tiny CLI programs to very large numerical simulations)
In fact I did not: they don't have the option to use anything else because nobody is dumb enough to try to use a managed language on an embedded device. I know, I've developed proprietary firmware for patented devices.
I have used C for 20 years, because it can do everything I need a language to do, for projects big and small.
&gt; but few people make anything noteworthy with it (edit) anymore (/edit) because it requires the skill and finese of a rocket scientist C is still widely used for brand-new projects, because often the only suitable languages are C or C++. Many people don't like the complexity of C++, so that leaves C. For example, if I want to write a system daemon that should run on multiple operating systems and multiple types of devices (even embedded systems), C or C++ are still the best choices. If I want to write a device driver, C is pretty much it. If I want to write a library that is usable from many other languages, again C is basically the only option. Even modern software systems that are mostly C++ depend on active and modern C projects. For example Google's V8 Javascript engine heavily relies on libuv, which is C. By extension then all the Node.js Javascript stuff is depending on C code. Then of course pretty much everything, at some point, relies on the standard C library.
Yep. It only looks easy until you start learning to do it correctly.
Perf doesn't really matter? Oh boy, I just cursed whoever wrote Android..that shit freezes out of nowhere. A fcking $245 Android mobile freezing with almost no apps installed. I will just get an Apple again. It at least is written in a fast language! 
Care to elaborate which project does not need to concern about performance? Cause I don't recall one. Even on JavaScript, performance is crucial on bigger social sites as Facebook/Google! 
True. I never said that a project shouldn't be concerned about perfomance though. 
Okay well that's not very relevant
haha..it aint! haha
Is it too late to join?
Try recursion. 
Is this good or can it be done better? int func() { static int x = 10; printf("x equals %d\n", x); if (x == 1) return 0; else { x--; func(); } }
~~Nope, every time you re-call func() you're setting x to 10.~~ Try this: void func(int x) { if (x != 0) { printf("x equals %d\n", x); func(x - 1); } } 
what about this #include &lt;stdio.h&gt; void counter (void) { static int i = 10; if (i) { printf ("x equals %d.\n", i--); counter (); } } int main (void) { counter (); return 0; }
But I set x as a static int, doesn't that work too? Either way, yours is much cleaner and simpler.
Your initial program does work, yeah, except that it will print "x equals 0" in the end. You mistakenly used a regular slash instead of a backslash, as well.
Nope, never too late, unless we're finished the book already. People can join as long as they can do the chapter the group is on. Right now we haven't even started -- that'll be September 6. For each chapter that you go through with us, are you okay with creating and sharing a page of notes?
And strings. Don't forget strings. If C had a real string object, half the software exploits in the world would just go away.
Also, can't you have a memory page that will trip an alarm if it's ever accessed? So for every data structure in general (arrays of any data type, strings) in which the compiler can't *prove* that you can't have an out of bounds access, encase the allocated memory in guard pages and kill the process if they're accessed. (Modified malloc function, maybe?) Though at that point you might as well just require that any array data type (or really anything that can be overflowed) is proven to not be out of bounds. Don't know how hard that would be.
when I tried your code I was getting error messages and I couldn't compile it. Any ideas why?
so your code works except it only counts down on the left and doesn't count up on the right.
You are correct, I missed the static keyword when looking at your code
Can't help if i don't know the exact error output. I assume you wrote a main function and called func(10) from it?
unresolved external symbol _func referenced in function _main. 
You *could*, but nobody ever *does* except for during testing. It would mean allocating an entire page (typically 4k bytes) for every individual array or string, *and* having an unallocated page between every pair of objects. Picture a data structure that contains multiple strings. Picture an array of those data structures. Your memory usage blows up incredibly fast.
Did you put func after main? If so you need to either move it above main or write a prototype
I'm not entirely sure how practical it is to expect the compiler to be able to do this, but I was thinking that you wouldn't need to guard *every* allocated block, if the compiler can work out if you didn't need it. So if you malloc a buffer of length *x*, then re-use that variable in a for loop or a check to otherwise make it impossible for an out of bound write to happen (Say, you're using strncpy and you properly passed the size of the allocated buffer you're copying the string to), then you don't need to guard it, since out of bound writes *can't* happen. Assuming no bugs in the standard library, which for a simple string copy tool, is unlikely. That would cut down on the amount of overhead if you could do it in enough places. Or just use a language that enforces all of this for you and doesn't have unsafe operations, but then it wouldn't really be C.
I just realized y'all are trolling noobs with this shit lol. 10/10
Believe it or not, but I actually am trying to lend a hand without doing the actual homework for them. Merely trying to pique their interest. 
Try recursion.
Inline assembler. 
 #include &lt;stdio.h&gt; void counter (void) { static int i = 10, j = 0; if (i) { printf ("%2d. x equals %d.\n", ++j, i--); counter (); } } int main (void) { counter (); return 0; } prints the following 1. x equals 10. 2. x equals 9. 3. x equals 8. 4. x equals 7. 5. x equals 6. 6. x equals 5. 7. x equals 4. 8. x equals 3. 9. x equals 2. 10. x equals 1.
I tried using a struct to contain different error codes, but it's kind of a PITA, and the way I had it setup I had to add a new function to contain error codes for each function, and it got wildly out of control. now, I just have a log function that either opens a file from a path specified by a user, or print to stderr, this is the only simple cross platform way to o it without having to use another library, or having to use the wildly different syslog on some UNIX variants (not OS X tho), and WindowsErrorReporting which use wildly different formats and structures to hold the error logs. I mean basically every OS has it's own logging system, it's just ridiculous. `void Log(const uint8_t ErrorSeverity, const char *LibraryOrProgram, const char *FunctionName, const char *Description, ...)` ErrorSeverity is simply an old fashioned logging i forget what it's called, shit like LOG_EMERG, LOG_ERR, etc; if it's not defined I define it myself in an enum. there there's a few variables that say the library and function the error occurred in, and then there's a variadic macro to handle any trailing user options, it's like bare minimum but honestly I love how simple and flexible it is. and as I said, we take this information and build a string with it, then when we're done we either output it to a global file pointer (I know it's gross but there's no other way to do it with my setup, that I know of anyway), or to stderr. [You can see the source here](https://github.com/bumblebritches57/BitIO)
 #include &lt;stdio.h&gt; static void doit(int value) { printf("%2d. x equals %d.\n", 11 - value, value); if(value &gt; 1) doit(value - 1); } int main() { doit(10); return(0); } 
I'm a bit late, but I actually read it on my own, and it's... tough. You have to do the exercises, you have to read it carefully, especially the first chapters, and you can get a good grasp of what's actually going on when you compile, link or execute a program.
If the compiler encounters a function call without a definition or prototype in scope, it must assume that a function of that name exists with parameters compatible with the actual arguments and a return type of `int`. In other words, when it sees `func(10)`, the compiler will create the implicit prototype `int func(int);`. Any subsequent calls to `func()` in the same compilation unit will be treated as if that prototype had been explicitly given, and any subsequent call, explicit prototype or definition that does not match the implicit prototype should result in a compiler warning. /u/Nadekap, we need to see the complete program (and preferably also know which compiler you're using) in order to help you with that error.
/u/Nadekap, I'm pretty sure your prof wants you to discover or learn recursion, like /u/Rapt0r- said. While this solution uses a recursive function, it is not a proper application of the concept of recursion. You must find a solution that does not use static variables. I would suggest starting by writing a non-recursive version and try to see how you can turn it into a recursive version with no other state or variables than function arguments and return values.
lol right? you wrote it in C?!?!??!?!?! the universe is gonna explode now you asshole111!!111!!!111
You've got a array of pointers. As you can see, they're sequential like you expect. However, the value of the pointers are determined by `malloc`, and what address it gives you is depends on many factors, including the algorithm behind it. It looks like it gives away 16-byte blocks, because it might be easier to manage in the view of the memory allocator. There's not much you can do using the standard library. If you want really want sequential structures, allocate one big memory, like `malloc(sizeof(test) * 5)`.
This may help you: [The Lost Art of Structure Packing](http://www.catb.org/esr/structure-packing/)
Thanks that's great once I know it's malloc doing it and not some basic misunderstanding on my part. I would therefore assume that the block of memory allocated to testCollection is actually 32 bytes when it should take up 20 bytes. Is there a way to test this? 
Since it seems that the memory allocator seems to give memory away sequentially, maybe just allocate such block twice in a row and compare the addresses. But please don't rely on it, other allocators might do different things.
static variable
One other thing to remember is that malloc can include extra memory in each allocation for it's overhead.
Where are you stuck?
What syntax should I use to replace any char of a string with another string?
You will need to create a new string and copy the appropriate characters from the original strings into it.
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char PS[105]; char Final[105]; char ch; gets(PS); scanf("%c",&amp;ch); scanf("%s",Final); for(int i=0;i&lt;strlen(PS);i++) { if(PS[i]==ch) { for(int i=0;i&lt;strlen(Final);i++) printf("%c",Final[i]); } else printf("%c",PS[i]); } return 0; } What changes I have to make in this program to Print the string PS with every occurence of a char replaced by s.
The block allocated to testCollection is 20 bytes. That's what you asked from malloc and that's what it gave you. Whatever malloc does internally is none of your business and even if you figure out what it does you are not allowed to use that information. Malloc needs to keep track of the allocations it gave you. On some systems this is done just before or after the blocks of allocated memory. On some other systems this information is saved somewhere else. Also, malloc may round up allocations so that it doesn't have to keep track of all possible allocation sizes (it makes some math easier). Also, malloc may randomize its allocations for security. It may do all of those things at the same time, or none of them. A program that relies on this information is a broken program, so all you know is that malloc gave you as many bytes as you asked it for, no more, no less.
Please edit your post and put 4 spaces before each line of code so that Reddit formats it properly.
Your code looks ok to me. Can you give an example of the input that it doesn't work on?
 Input:abcxy b should be replaced with mf The output should be amfcxy
That depends, but most likely, yes. However, you can't assume that's the case, even if your tests seem to confirm your hypothesis. You can't assume that successive allocations will be consecutive, either. In fact, you're not allowed to make any assumptions whatsoever about the representation or values of pointers except that `malloc()` will return a pointer which is correctly aligned for every possible type supported by your implementation. And the size of a struct is not necessarily equal to the sum of the sizes of its members. Most `malloc()` implementations round small allocations up to either the next power of two or the next multiple of a specific power of two. 16 is quite common. The reason for rounding up is twofold: first, to ensure that the block it returns is properly aligned, and second, because very small allocations are wasteful in terms of the work and memory required to keep track of them. Large allocations are usually handled differently from small ones and will be page-aligned and rounded up to the nearest multiple of the page size. Further reasons why successive allocations might not be consecutive: * If your program (or a library it uses) has previously allocated multiple blocks of memory and freed some of them out of order, `malloc()` may try to fill the gap before ‚Äúappending‚Äù to the latest allocation. * If your `malloc()` is a slab allocator, you might get a jump when the slab fills up and it allocates a new one. * If your program is multithreaded, there is a good chance that `malloc()` uses multiple arenas to avoid synchronization and cache aliasing issues. * Your `malloc()` might randomize allocations to mitigate buffer overflow attacks. * Your `malloc()` might place housekeeping data or canaries before or after your allocation, especially if it has leak detection features. Embedded systems are a different story altogether‚Äîtheir `malloc()` implementation, if they have one, will usually be designed to minimize fragmentation and overhead rather than maximize performance.
This is irrelevant. His struct is already optimally packed.
Well, it's wasteful. The inner loop can be replaced with a single `printf()`, and the `strlen()` in the outer loop can be replaced with a comparison to 0.
What output do you get?
Your program works correctly if you give it the input it expects: abcxy b mf You should add a `printf("\n");` at the end, though, and consider the changes I suggested in my previous comment.
I got nothing as output 
Valid. Use cases are just infrequent enough that no generalized solution is super valid.
Oh sweet I've never heard of that. Is there just no maintainer?
Thanks for responding. I'm not quite sure how to approach it. The class that the text was modeled after seems to have read, work the practice problems, and then the labs. That's it. 
Should I also do some end of chapter exercises? The class itself seems to suggest doing reading + practice problems as you go along plus the labs 
I would recommend the course for beginners. The lectures are good and informative, the content is explained well, and the psets are challenging but very doable. It is a great jumping off point if you are interested in programming.
Honestly, I didn't do all the exercises, I just worked until I understood everything, but some parts of the book are tedious..
I'm about halfway through chapter 1 on the K&amp;R C book. I'd love to join up here. The examples in Chapter 1 are taking me more time than I realized(I started over a month ago with limited time to commit each day), but mostly because I'm trying to work through each example with my own limited experience. For the later examples I've been working through them by checking stacktrace for each question and I'm curious on the notes or concepts everyone would focus on for the example programs in chapter 1. I'm in MDT so 2 hours earlier than EDT if anyone wants to coordinate up in MDT You've had pretty large response here and managing 15 conversations may become a real piece of work depending on the level of engagement for everyone. If things become unwieldy I'd love to help out in the MDT timezone where possible. Everyone's available hours will be varied so who really know, but honestly having someone explain something to you over chat or voice is invaluable to understanding a concept.
There is one exception to the "just use a sorted array" rule, and it's whenever I have a map that uses strings as a key. Doing a binary search in a sorted array with string keys means having to do O(log(n)) calls to strcmp, and the thought of that is causing me physical pain, and I use a trie. the one I use is based on a data structure proposed by djb, and I've got a general-purpose implementation in my github: https://github.com/ennorehling/clibs/blob/master/critbit.h 
There are some very good single-file libraries, for which stb maintains [a list](https://github.com/nothings/single_file_libs), which allow you to pull in only what you need. It's a nice exercise to try and write your reusable code that way (I've written a few myself). Of course, a good linker will eliminate a lot of the "waste" that you pull in when you use only one function out of a gargantuan library, but when that function is written in terms of many other parts of said library, even using a single function can quickly grow (boost, I am looking at you). 
Of course you can join up ...if you're okay with making at least one page of notes per chapter and sharing it. (You are, right?) Yes, the exercises can be a sinkhole of time, because they aren't just testing your vocab, they're testing your ability to puzzle-solve, but at least the puzzles are real-world and relevant. Seeing what other members of the group come up with for the solutions will help you build that knowledge. You aren't being relied on to solve everything yourself. It's cool. What do you mean you check stacktrace for each question? Is that a website? I've tried stacktrace.com and tried googling, but not seeing a good hit. I think the most time and effort intensive part of managing the conversations is here at the beginning, getting everyone coordinated and set up. After that, the group isn't reliant upon me and they can interact with each other.
Awesome, I've got notes that I'm creating myself, but mostly for memorization purposes, not that my notes are all that different from whats actually in the book. Sorry I meant stackoverflow. So far I've seen most of the examples posted in Stackoverflow for this. https://stackoverflow.com
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main (void) { int i; char *pstr = "This is the primary string."; char *rstr = "CHEESE"; char rep = 's'; for (i=0; i&lt;strlen(pstr); i++) { if (pstr[i] == rep) printf ("%s", rstr); else putchar (pstr[i]); } puts (""); // \n return 0; }
Memory allocation will be contiguous for a single request (such as allocating five pointers in one call or allocating five structure's worth at once). You malloc a new structure each time through the loop, in which case it's up to the allocator to place them in available memory, which can be hard to predict. If you need all five structures to be contiguous, they need to be allocated in a single malloc. The pointer returned by the single malloc can still be accessed with an array index. But if dynamic allocation of the structures is required, you cannot assume they will be next to each other in memory. It may well work out that way, but cannot be assumed.
I recently picket up Python as my go-to for quick tasks, proof of concept, etc. But my work is often severely limited by memory and performance constraints. C and assembly aren't going away anytime soon in the embedded world. I love Python for its flexibility, but for production code I always prefer C. But I've been called a stubborn old man, so what do I know...
I'm exactly the same way. Python for lightweight tools, C for real production code. At Google, the primary languages were C++, Python, and (for Android) Java
i'm using visual studios 2017. I haven't written my own program yet, I'm still trying to use and learn from the ones everyone is posting on reddit. For some reason I'm still running into error messages with all of them. With the most recent programs posted my compiler is giving me an error asking me if I forgot to use #include "stdafx.h" but even adding that won't work. If you have any good literature or a good website to read up on and learn "Recursion" (which is what people have been telling me this program requires) if you wouldn't mind linking it so I could try to teach myself. I appreciate your help and I also want to apologize for my ignorance on the subject.
I worked through it over the summer. It was a lot of work, but rewarding. If you are diligent and go through all the examples and exercises, you will learn to reason about computer programs at multiple levels of abstraction--an invaluable skill. If you're not familiar with binary numbers and haven't taken some sort of discrete mathematics course (or some proof-based math course), the second chapter might seem a little daunting. Beyond that, some familiarity with C syntax and basic programming concepts are the only requirements. Seriously, though: Do every single example and exercise. If you need any help, shoot me a PM. I'm pretty sure I still have my solutions and assorted notes saved...somewhere.
You may be interested in hiring a programmer. There are [sites that specialize in this](https://www.upwork.com/hiring/development/how-do-you-hire-a-programmer/), but reddit is not one of them.
&gt; If you have any good literature or a good website to read up on and learn "Recursion" Have you tried Wikipedia? And are you trying to compile a C program as a C++ program? Those are two different languages.
This is a joke, right?
I'm trying to print 5 unique dice roll. How could I go about doing it
Move the "idice =" to the while block, so it gets executed every time.
Also, use scaling (multiplication and division) instead of modulo to ensure an even distribution. As it stands, your program has a small bias in favor of 1-3.
You give iDice a random value **once**, and then print that value five times. Move that line in the while loop so iDice gets a random value each time the condition is checked
It's still producing the same result :&lt;
how do i do that?
Show your code. And copy-paste it this time instead of posting a screenshot.
you're assigning a 'random' value to iDice once and then printing that value 5 times. Instead you should call the function ( rand() % bla bla ) in the loop like such main(){ srand ((unsigned)0); for (i=0; i&lt;5; i++) printf("%d\n", rand() % 9); } bad example but maybe you get it
Hints: [rule of three](https://en.wikipedia.org/wiki/Cross-multiplication#Rule_of_Three) and `RAND_MAX`. You will need to either cast the result of `rand()` to a wider type or reduce it before applying the rule of three in order to avoid overflow.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //Library for rand() #include &lt;time.h&gt; //Library for time() #define max 6 #define min 1 int main(void) { int count=0,iDice; while (count&lt;5) { srand((unsigned) time(NULL)); iDice = rand()%((max+1)-min)+min; printf("Single roll of dice gives: %d\n", iDice); count++; } } 
i get what you're saying, but idk how to go about coding it in
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ srand ((unsigned) 0); int i =0; while(i++&lt;5) printf("%d\n", rand() % 9); } try that
move the srand out of the loop now you are reseeding it everytime and it uses the same one
You only have to initialize the random generator (aka. calling *srand()*). But because you call it in every iteration, the "initial random value" (aka. [seed](https://en.wikipedia.org/wiki/Random_seed)) remains the same (because you always set it to the value of *time()*), so it produces the same results. To fix this, move the *srand()* line out of the while loop. Normally, you need to call it only once in a program. P.S. I don't want to come across as rude or something, but the previous answers told you to move the *rand()* line into the while loop, ONLY the that line. 
&gt; include &lt;stdio.h&gt; &gt; &gt; include &lt;stdlib.h&gt; //Library for rand() &gt; &gt; include &lt;time.h&gt; //Library for time() &gt; &gt; define max 6 &gt; &gt; define min 1 &gt; &gt; int main(void) { int count=0,iDice; &gt; &gt; while (count&lt;5) &gt; { &gt; srand((unsigned) time(NULL)); &gt; iDice = rand()%((max+1)-min)+min; &gt; printf("Single roll of dice gives: %d\n", iDice); &gt; count++; &gt; } &gt; } Ahhh, it worked out too. thanks haha, neh, it's not rude, i'm naturally dense HAHA
Okay thanks! This one worked out too.
Problem solved. Thanks everyone for the help :)
Please edit your comment and insert four spaces at the start of each line (even those that already start with spaces).
No blog spam please.
For the future, please do not post pictures of code. Instead, copy-paste your code into your question. 
`rand()` returns a number between 0 and `RAND_MAX`. You want to scale that down to a number between 0 and 5 (and then add 1). It works just like calculating percentages, except you use 5 instead of 100. The link I gave you explains the (very simple) mathematics of it.
Dude, Idk how you're not getting it. your while loop is printing the VALUE of the random variable 5 times, but the VALUE of that variable doesn't change once it's created because it's not in the loop.
Also, you defined main to return an integer... You should add a return value.
It's implicit in C99 and C11.
... and indent it by a few spaces so Reddit will format it as code.
I've been writting a Generic Map using uint64_t keys and using uint8_t[] for data, so you can store any kind of data using casting, I want to remove key type restriction, but I dont want to use macros. Probably with other uint8_t[] type for keys and a pointer to a comparation function, i can do the trick, but I dont know how it will affect to performace instead of substract numbers...
Nice. You really did *all* the exercises? If you don't mind me PMing you that would be great. 
Also, did you do the labs associated with the course? 
Most performance hits are usually from cache misses, pushing/popping stack frames, and hash functions (at least when I was profiling code). As long as the code is "pipelinable" it don't think that would cause a bottleneck.
Or put it on pastebin, or that online compiler. 
fflush (stdin);?
yeah, I've tried that. Didn't work
http://en.cppreference.com/w/cpp/language/main_function
What are you exactly trying to achieve? Note that you typically cannot access the keyboard buffer (if there is any, not everywhere do keyboards have buffers) from your program as the operating system takes care of that.
That's undefined behaviour, don't do that.
I'm trying to flush out the buffer. 
You mean clear the text shown when you type stuff to stdin? You need to use raw mode for that.
I got that. But what are you trying to achieve by doing that? What do you think the ‚Äúkeyboard buffer‚Äù is?
Can you explain raw mode
I'm just trying to learn stuff. 
Okay. Then learn: There is no keyboard buffer and you can't flush it. Whoever told you something about ‚Äúflushing keyboard buffers‚Äù is an idiot who doesn't know how to program in C.
You have declared a pointer to a `struct stat`. Where does that pointer point to?
I'm pretty sure you can flush a keyboard buffer. And there is something called a keyboard buffer. Search it up 
Yes, some implementations might have something like this, but the C language does not know about this. For your C program, there is no such thing as a keyboard buffer. The C language provides no mean to manipulate a keyboard buffer if your platform uses this concept. It is possible that there is a platform specific API to do such a thing, but even then: If you need to flush the keyboard buffer, you are doing it wrong in all but extremely exotic situations. If you write a program where you think you need to do that, you are very likely making a huge mistake and writing a terribly broken program, so don't do that.
So than what does fflush(stdin) do ?
It's undefined behaviour. On some platforms, it drops the contents of the buffer associated with `stdin`, breaking the ability to pipe input to your program as there is no way to know how many characters are in the input buffer right now, so essentially, a random amount of characters is dropped. This is only useful in extremely exotic situations. If someone teaches you to use `fflush(stdin)` because he sucks at using `scanf()`, then find a different teacher.
Oh, I think I get it. I was working with the opendir function earlier and that function returns a pointer to a dirent struct. I assumed that the kernal generated a stat struct and put a pointer to it in buf. But if it did that, then I would have needed to send a pointer to a pointer to a stat struct as the second parameter. This was really bothering me. Thanks for pointing this out. Now I just need to figure out why the print statement makes it work.
no its not lol
Raw mode is a certain setting for the UNIX terminal driver. In raw mode, all translations are turned off and the operating system sends you characters as they are typed instead of accumulating full lines in the terminal driver's internal buffer. Note that this buffering is independent of `stdio` buffering. Note that raw mode is only a thing on UNIX terminals. There is no terminal driver you can send into raw mode when you receive input from some other source (e.g. redirected from a file).
Yes it is. Compare ISO/IEC 9899:2011 ¬ß7.21.5.2 ¬∂2: &gt; If stream points to an output stream or an update stream in which the most recent operation was not input, the fflush function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; *otherwise, the behavior is undefined.* (emphasis mine). `stdin` is not an output or update stream, so behaviour is undefined.
[removed]
It's undefined behaviour. Perhaps the `putchar` causes the compiler to generate different code, causing `buf` to be initialized with a random value that happens to be a valid pointer. In any way, to fix this, just declare `buf` to be a `struct stat` instead of a pointer to a `struct stat` and pass a pointer to `buf` to `stat` using the take-address operator `&amp;`. As a general rule of thumb: Very few library functions allocate structures for you. That's a rather uncommon design pattern because dynamic memory allocation is rather expensive and easier to get wrong then just putting structures on the stack.
[removed]
[removed]
Please don't troll. I'm trying to help OP, you are making this very hard with your trolling and derailing.
Oh, opendir doesn't return a pointer to a dirent struct. readdir does. This dirent struct comes from a directory file though, so it's not allocated like I was thinking. I'm all confused today I guess. I do understand exactly what went wrong though. I wrote code earlier that uses the stat function properly by sending the address of the stat struct rather than a pointer to a nonexistent stat struct. I guess I'm not experienced enough with pointers yet to visualize and understand clearly the exact meaning of what I'm writing when it comes to pointers. 
Pointers are easy, just follow this tutorial: [blinky pointer fun](https://www.youtube.com/watch?v=6pmWojisM_E). There's really nothing more to it except perhaps pointer arithmetic, which is not really important for you right now.
[removed]
I know the rules of pointers. I'm just not experienced enough with pointers to have a sort of intrinsic understanding that allows me to find errors that I made easily. It could also be that I feel like I don't know what I don't know, and so I was speculating about possible explanations that weren't related to pointers.
I watched that video and something about it seems a little incorrect to me. They declared pointers like this: int* x;. Shouldn't pointers be declared like this: int **x*;. I understand that both syntaxes work, but the first implies that you can declare pointers like this: int* x, y; Pointers should be declared the other way because it's more clear what is meant. 'int *x;' means that 'x' is a value that when dereferenced results in an 'int'. Therefore, 'x' is a pointer to an int. 
I see. Just follow the rule of thumb that you always need to make a pointer point to something. Functions can't overwrite their arguments in C, so passing in an uninitialized pointer is pointless.
Yeah, `int *x` is better. The video was made for a bunch of programming languages with just the subtitles changed which might explain this sloppiness (or C++ fanboys being at work).
Please stop this. It's not funny and I'm going to ban you if you continue.
That's a good rule to remember. I'll keep that in mind. Thanks.
[removed]
You won't learn anything if you refuse to help people who try to help you.
Alright what else do I say? I said I'm just learning about c. I'm not trying to do anything just learn the language. He kept asking me what do you want to do like it even matters. Flushing out a buffer is totally outside of knowing what I'm trying to do. 
&gt; Flushing out a buffer is totally outside of knowing what I'm trying to do. Except that's not true. The word 'buffer' has no precise meaning and neither does the word 'flush'. You're acting as if C has some unified concept of a buffer when in reality the word buffer is just convenient terminology which has come to mean a place where data is stored temporarily. We can't tell you how to flush an abstract 'buffer', you need to tell us specifically what buffer you are trying to flush. So far you have not been very descriptive and just said 'look it up'. A lot of people here have programmed in C for many years: doesn't the fact that nobody knows what your talking about indicate you're asking a bad question?
Ight but tell me how I told him that 
I have no idea what you're asking now. If you want help, I've told you what you need to do.
it forces all that data accumulated in in stderr to be flush. You don't flush an input buffer so that makes no sense.
You could also run it on a file instead of interactively. From a shell: $ printf 'Line one\nLine two\n' &gt;testfile $ myprog &lt;testfile Assuming `myprog` is the name of your binary.
What you want to do does matter. In my experience, the only situation beginners ask for ‚Äúflushing the keyboard buffer‚Äù or other nonsense like that is when they misuse `scanf()`, see that their program behaves strangely, and then ask someone equally clueless who suggests to ‚Äúflush the keyboard buffer.‚Äù From a pedagogical point of view, this is a very nice opportunity to explain the behaviour of `scanf()` and how your code can be fixed to work in a portable manner. However, since you refuse to give me this information, this strategy cannot be employed. 
How should `fflush(stdin)` affect `stderr`? These two are different `FILE` structures.
Please note that ‚Äúit didn't work‚Äù is not really a useful error description. Instead of ‚Äúit didn't work,‚Äù try writing something like ‚ÄúI tried ... and expected ... to happen, but instead ... happened.‚Äù This way, other people can easily understand both your expectations, your code, and what your program did. This makes it very easy to fix your code or explain why the code did something else than you expected. I'm really trying to help you, but helping is a process that requires both parties to participate.
Some people prefer it next to the targeted type because it is part of the type and not the variable name (i.e. x is of type 'pointer to int'). But I agree, it gives this misconception that all variables listed in the statement are of type pointer to int. 
Reread my comment until you understand it.
I don't see how else I am supposed to interpret the sentence &gt; it forces all that data accumulated in in stderr to be flush. So clearly, I'm missing something. Could you elaborate?
I often use `nano` and of course `ed`, the standard UNIX text editor. The visual editor `vi` is very popular, too.
if youre worried about spying use vim
This question is asked at least twice a fucking week, can automod be set up to block this spam?
Emacs, of course! "the one and only true operating system."
I don't know why it matters, other than features like code completion, or automating your build process, most smaller projects can be done in nano, vi/vim, emacs. If you really need a fancy text editor, Sublime Text is both aesthetically pleasing, and highly flexible due to the built-in plugin manager. I hear Atom is similar but haven't tried it. For $75 bucks you can have a licensed version of Sublime Text, otherwise just use the free one. For a full-up IDE, I'd recommend CLion, I am personally a fan of all Jetbrains products. Students can get a license for free, annually renewable. It's $199/year for the whole suite of IDEs, $149/year after 2 years. They are good products but paying the subscription fee every year, you should probably be using the more advanced features and making money doing programming to justify it.
‚ÄúEmacs is a wonderful operating system, too bad it lacks a good editor‚Äù I jest, of course. Emacs is love, Emacs is life.
&gt; I hear Atom is similar but haven't tried it. I'm not sure I will ever be able to trust Atom given its history of silently collecting identifiable information from all users. Granted, it now asks your permission on first run, but the [announcement](http://blog.atom.io/2016/10/11/atom-1-11.html) when they made that change is mind-blowingly tone-deaf.
Magnetized needle and a steady hand. Occasionally I'll break out the butterflies or just use vim. I need editors for typing and editing. Most of the bells and whistles are just a distraction. 
A guy walks into a bar sees someone sitting at the end of the bar and asks; What's your IQ? Guy says 135 guy answers me too and the start talking about physics, meta-physics the meaning of existence... Other end of the bar two guys meet and share IQs; mines 70! Hey mines 75, what editor do you use? Emacs or VI?
Short answer: because that's the way the function was created Longer answer: the function itself was made such that you MAY provide preferences on the type of return value you'd like. You could always create your own interface to make it so you'd only have to pass the hostname
Hey guys, so sorry! I've been stuck in other programs for college and completely neglected this one. I'm almost finished with this new version (there a few exceptions I still have to treat (mainly regarding minutes), but I feel better about the code, dunno, it seems more like the program is doing it's work, instead of me doing it for him: https://gist.github.com/gustavohmsilva/78d51995d8ce4de9b5a6e7fd9d250227#file-_talkingclock-vers-4-c As always, any comments are welcome, it's mainly how I improve anyway.
I use vim for all my programming need. EDIT: Why? I want a lightweight editor that is still heavily customizable. I want my editor to be what I need, nothing more. Also, once you learn how to use it, it's a lot faster than a standard point-and-click interface.
and the bartender responds, emacs is not an editor... is the meta-physics answer to existence
Many exotic compilers only support ANSI C (if at all). Thus, very portable C code is still written against ANSI C with special precautions to support pre-standard compilers.
Vim user here- actually ported it over to Windows for work in powershell- it's really all you need- fancy ide's are just that... fancy- not to mention you have to wait for them to load and open, and learn all their respective menus and blazablah- just learn to use vi, vim or nano- even leaf pad works- if you're still using autocomplete, you still have a lot of studying to do x.x
What would be the use case for something like that? Would you be writing for some legacy systems? Embedded systems with limited support and thus no modern/standard compilers?
I did a load of C coding with Geany. It's great - fast, lightweight. I never got past the basics of Vim so definitely can't code in it (editing scripts is about my limit). I never got into emacs so can't comment. I now use Sublime Text. Just as fast and lightweight as Geany but has support for more languages (e.g. Rust). I tried Atom and Visual Studio Code. I really wanted to like Atom (I really did) but it's slow - and just slow enough that it starts to annoy after a while. Visual Studio is also slow but I didn't spend much time with it. And both just hog memory. I also tried QtCreator and KDevelop (probably more IDEs than editors). Some nice features but I didn't want to tie my project to a specify project format. I think it's better to manually manage your project (e.g. Cmake) and auto generate the IDE file you want. 
What is `word`? Show your code in context or people can't help.
I commented on how flushing stdin doesn't make sense then described how it worked for something that did make sense. I even explained that in the comment, but maybe i shouldve been more explicit.
When I write "quick and dirty" applications that are small in size, I tend to target C99. When I write larger codebases, especially library code, I tend to target C89/ANSI. The reason for that is that there is a greater chance that I will want to someday run the code on some system with fewer compiler choices, and yes, that includes legacy systems. C89/ANSI is not a particularly limited version of the language compared to C99, so I generally don't feel that much more effort is incurred by targeting the older standard, and on the off chance that I do need to run the code on an older system at a later date, the effort saved vs a porting effort is significant. As the saying goes, your mileage may vary.
I use vim and Sublime Text 3. 
The thing that is wrong about your description is that `fflush(stdin)` does not flush anything in the buffer of `stderr` (note also that `stderr` is unbuffered by default). If you called `fflush(stderr)`, then yes, the description would be correct, but you say so nowhere.
What has the choice of the editor to do with spying? Does vim has less security vulnerabilities than other editors?
A couple of years ago, I think I read that part of Python was in C89 because some compiler didn't support C99. Until recently, it was commonly espoused that Visual C had incomplete support for C99. 
Vim had a pretty bad security record, but at least it never had surreptitious telemetry like Atom used to. 
Microsoft Visual Studio has kept cross-platform projects back. Its C99 support was non-existent until only a few years ago, and even now it is not fully C99 compliant. They mostly only fixed what was mandated by C++11 and C++14. 
Forgot to say...Microsoft was embarrassed by Git. Everybody was using it in the rest of the computing world, but Visual Studio couldn't compile it for its use of some simple C99-isms. So they fixed Visual Studio enough to handle Git and made a big PR thing about how they could now compile Git. But they stopped short of actual C99 compliance. 
Some DSPs have closed libraries (usually fancy filters and math-y stuff) and you need to use the vendor's compiler if you want to use those features. And the vendor's compiler is usually an ANSI compiler because they're not really in the business of creating a better compiler, just a functional one. So, IMO, very few people choose to by-pass the good stuff that comes with c99 on purpose and stick with c89. It's usually the hand you're dealt.
Please note that this subreddit is for programming in C only. Please ask C++ questions elsewehre, e.g. in /r/cpp_questions. I have removed your question as it is off topic.
/r/C_homework
yeah i need to create a interger program
Write a console application that sums the integers from 1 through 500. Which type of loop will you choose? 
The Python reference implementation, CPython, and its standard library were supposed to be C89 only (they messed up pretty often with that rule...) up until a year or two ago. They recently switched since they effectively only support three compilers (GCC, Clang, and MSVC) and three platforms (Linux, macOS, and Windows) at this point. It's actually quite miserable trying to support CPython on anything else as the core devs are less than understanding in my experience...
I mostly write C89 because it's how I learned to write C. I also heavily employ the OpenWatcom compiler in my work, which defaults to C89. It does provide C99 compatibility, but I don't seem to need it with my own code.
You can do it with any kind of loop. The code will be slightly different for each one, but they will all work.
Recently one PM appeared at /r/cpp and said that the official position changed a couple of months ago. Before MS said very clearly that Visual Studio offered a C++ compiler and that it was officially the system language for Windows from now on and C support was on maintainace and they were going to support only the necessary features to compile **some** important C projects like Git and FFmpeg. They decided that from now on standard C support should be a goal and the priority was to support all the standard C features supported by recent versions of GCC.
Think of a macro as a text replacement. If you write #define FOO 10 Then anywhere when `FOO` appears in code will be replaced with `10`. So int val = FOO * 100; Will literally turn into int val = 10 * 100; Depending on how you use them these text replacements can be used for things as simple as defining a constant such as a number or string, all the way up writing [entire libraries](https://github.com/VictorSCushman/EMU/blob/master/EMUtest.h) that use text replacement to emulate functions and write bits of code on the fly.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [VictorSCushman/EMU/.../**EMUtest.h** (master ‚Üí ba07db8)](https://github.com/VictorSCushman/EMU/blob/ba07db881231fd037be7210e087eea5f992887cc/EMUtest.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmkr3i7.)^.
I use MightEMacs. It is fast, powerful, fairly easy to learn (for an Emacs variant), and very customizable. Has built-in support for C, Ruby, Shell, Perl, and MightEMacs scripting.
So why us a macro over a regular variable?
Most of the time, it's fine to use either. [Here's some discussion on Stackoverflow](https://stackoverflow.com/questions/1674032/static-const-vs-define-vs-enum) of the differences between the two approaches.
C89 is used too much tbh. IDK about specific makefile options targetting c89, but I know that FLAC and FFmpeg define all kinds of stupid shit that's included in C99 (like bool, and various int types) to support being compiled by ancient c89 only compilers. Shit, they even use old fashioned function argument definitions for the same reason.
You got a source? I made a feature request to visual studio to add support for C11 threading and generic functions, and I haven't heard back from them but last I read they were only gonna support the common subset of C that C++ uses. Edit: It looks like VS 2017 supports _Generic functions tho.
Emacs
If it's a constant aka won't change there's no reason to add the performance overhead, but I prefer using enums for my constants, it's a lot cleaner, and more predictable.
Old thread on the topic: https://bytes.com/topic/c/answers/667811-ctime-n-rationale Another: https://stackoverflow.com/questions/19543997/why-does-the-string-returned-by-ctime-contain-a-line-feed More: http://www.lysator.liu.se/c/rat/d12.html#4-12-3-1 The answer seems to be it's that way because it's that way and has been for a very long time. Use strftime() or strip out the newline yourself if you don't like it.
The advantage declaring variables that way is they are constants, and they don‚Äôt have a type (can be a inconvenient too) As for the macro functions (I‚Äôm not sure that‚Äôs the right name), they can be declared like this (I use this one a lot) #define REP(i,a,b) for(int (i) = (a); (i) &lt; (b); ++(i)) Or these ones: // replacing 0 by 1 if I want to activate the debugging #define PDEB if(0) printf #define DEBUG if(0) Such definitions can come in handy in order to simplify the syntax of some functions you use often, or in the second case when you want to turn on and off debugging parts of the code. Also, the parenthesis in REP around i, a, and b ensure there won‚Äôt be any syntax problem.
Macros are typically not a replacement for variables because you can't write to macros (as they are just a textual replacement) and you can't take their address. Macros are used because you can set their value at compile time in quite complicated ways. For example, I have the following logic to detect if my system has the function `__builtin_popcount`: #ifdef __GNUC__ # define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) #else # define GCC_VERSION 0 #endif /* for clang */ #ifndef __has_builtin # define __has_builtin(x) 0 #endif /* check if __builtin_popcount() is available */ #ifndef HAS_POPCOUNT # if __has_builtin(__builtin_popcount) || GCC_VERSION &gt;= 30400 # define HAS_POPCOUNT 1 # else # define HAS_POPCOUNT 0 # endif Without macros, such a thing is very difficult to do.
You don't have to provide any hints, you can just pass `NULL` instead.
&gt; Until recently, it was commonly espoused that Visual C had incomplete support for C99. I'm not sure what you mean by ‚Äúcommonly espoused‚Äù. It's a trivially [provable fact](https://docs.microsoft.com/en-us/cpp/c-runtime-library/compatibility). MSVC didn't support `long long` until 2015 and didn't provide a complete `printf()` implementation until 2017. Their C library is still incomplete.
&gt; four platforms (Linux, BSD, macOS, and Windows) FTFY 
You can even do it without a loop, in at least three different ways!
_You can even do_ _It without a loop, in at_ _Least three different ways!_ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^a4qbfb ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
I was being a bit snarky. It *should* compile on BSDs, but I'm wondering if the Python core devs would care if, for instance, something didn't quite work on NetBSD. Their [buildbots](http://buildbot.python.org/all/waterfall?category=3.x.stable), for instance, only seem to build against FreeBSD.
I was on my phone and didn't have the time to provide proof so I tempered my statement. Thank you for the proof. 
Well then &gt; four platforms (Linux, FreeBSD, macOS, and Windows) 
Maybe I'm crazy, but honestly C doesn't feel like a challenge to me at all, it just feels natural. higher level languages feel like a real damn chore tho (except string handling, that could be easier in C)
You should use a for loop.Which language do you want to use
https://www.reddit.com/r/cpp/comments/6mqd2e/why_is_msvc_usually_behind_the_other_compilers_in/dk45tdk/?st=j77mllh6&amp;sh=900d3d7a https://www.reddit.com/r/cpp/comments/6mqd2e/why_is_msvc_usually_behind_the_other_compilers_in/dk4mlfd/?st=j77mlfsc&amp;sh=b920748f
Honestly have no idea ill be putting in my code for it later to see if I'm right.
Cool thanks for the links. It just seems odd for a function in C to do something extra for you that you may or may not want. I guess it was just easier for them to include it when implementing the Unix date command.
Nobody uses `ctime()` or `asctime()` these days. What's wrong with `strftime()`?
One is recursion Would you give the other two??
One is recursion Would you give the other two??
Seems a bit annoying to have to write `EMU_END_TEST()` at the end of every test. The framework should probably be able to handle that itself. Also, something I always found annoying about minunit was that you had to manually return some non-zero error code from main if a test failed (this was only a one line of code change in the minunit source, but still annoying). That sort of thing is vital in a lot of build systems or continuous integration systems. EDIT: TBH I don't really see that this library adds much to minunit. It looks pretty similar apart from having `assert_gt`/`assert_lt` etc and a few more functions of that type. Nothing that couldn't easily be added to minunit, from what I see.
[Robot OS](http://ros.org) might be a good place to start.
Nothing is wrong with `strftime()`, it's what I use to format my date strings. In fact, I don't think I have ever used `ctime()` or `asctime()`. I was just curious - that's all.
Doesn't seem like it has any advatage over Catch 
&gt; The key thing is: C lets you do almost anything you could do in assembly, and does nothing to prevent you from screwing yourself badly. At the lowest level for embedded, a lot of compiler intrinsics are needed. Anytime hardware is being interfaced with, a lot of platform library code (which drops to assembly) or intrinsics end up being used. I'd argue that C is a long ways off from what modern assembly is expected to do. It is close enough for 99% of software purposes though, and we live in a nice world where most devs don't have to futz with hardware. C's programming model unfortunately no longer resembles what hardware does. Hardware is interrupt driven, and in large part, async. As an example, if I am going to write to a flash controller, I'll send some commands off to it, and expect results back eventually. In some cases, commands are loaded up into a FIFO, there can be errors sending those commands out. C that interfaces with hardware (in a power efficient way and w/o just polling!) ends up being a lot of callbacks, which can be hard to manage. Modern high level languages with their *async* constructs actually mentally map more closely to the underlying hardware now days, even if the code is many layers of abstraction deep. Imagine what it is like at the lowest level to try and read a file from disk. 1. Get a callback when the bus is available to put a message on it 2. Put a message on the bus getting the root of the file system 3. Callback that is fed 4k or so chunks in. Depending on your controller, you may or may not need to handle each 4k chunk on your own. (Odds are the controller is also written in C so they are doing all this work!) 4. Lookup the file location in the returned table. 5. Make another bus request, setting the callback to an appropriate handler. Except odds are you have one interrupt handler for everything, so hopefully that massive interrupt handler is well written! (Odds are it is a nasty switch statement, better languages make registering and unregistering callbacks to the main handler easier, C can do it, but it doesn't make it easy to do the right thing) 6. Handler is called. Based on how everything works, maybe you are being fed the file 4k chunks at a time, or maybe instead you have setup a DMA channel to send the file directly to whoever wants it. 7. C has no good mechanisms for "this file has been partially delivered by DMA". C has no concept of what DMA is. C has no concept of arrays that get filled out in the background by hardware. You can probably get callbacks during some portion of this operation. Unless your DMA controller is horrible, you'll get told when the operation completes. Hopefully you get more than just a status flag being set. 8. Sad path, no DMA, instead you get callbacks for every 4k or whatever size, of data. State machine nightmare to deliver it to the right person. Thankfully even modern embedded systems include really super cool DMA controllers (and are one of the things I miss when doing desktop development, modern DMA controllers are an incredibly powerful way to get data from point A to point B!), so odds are after someone spends a few weeks (or more) making C understand your system's DMA controller, things become C-like. But reading from raw flash is a trivial example of interacting with HW. I haven't done any desktop OS development, so I cannot imagine what they go through. 
Other could be to use a formula :D n(n+1)/2 where n is as you said 500.
Then me too, I would like to join. This is my github: https://github.com/naens. I already have the book and set up my emacs environment.
There's a whole lot to this topic, most of which doesn't have anything directly to do with C (electronics, sensors, motors, etc.), and a bunch that is only indirectly relevant to C (interrupts, flash ROM vs. SRAM), but here's some advice on the programming portion of it: 1. Get yourself an AVR-based microcontroller, such as an Arduino UNO or one of its clones (much cheaper, like US$10 or so). But if you're really serious about learning this stuff, don't bother with the Arduino software. Just take advantage of the platform. AVR currently has the best tooling around ‚Äî which is really great because microcontroller development tools are typically awful. Really awful. Typically you don't want to drive motors and sensors and such from something like a Raspberry Pi which has a full OS. There are real-time issues, and it's overall more complicated. Plus you're probably going to break it as you learn, so stick with the cheapest thing you can. 2. Install avr-gcc, [avr-libc](http://www.nongnu.org/avr-libc/), etc. If it wasn't obvious, you're best off working from a unix-like OS, like Linux (such as on your Raspi). These will be packaged for you, making this step trivial. Once installed, you can invoke the compiler as `avr-gcc` to produce code to run on your microcontroller. It works exactly like GCC, making it really easy and comfortable to use. 3. Install [avrdude](http://www.nongnu.org/avrdude/). This is what you will use to upload the image built by avr-gcc. 4. While you're waiting for your microcontroller to arrive, read the [avr-libc manual](http://nongnu.org/avr-libc/user-manual/). This will teach you about programming on an AVR and how it's different than programming C for your desktop. 5. While you're still waiting, become familiar with the datasheet for your specific Atmel chip. For example, if you got an UNO that would be the [ATmega328P](http://www.atmel.com/Images/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328-328P_Datasheet.pdf). This is a dense technical document, so don't try to understand it all at once. 6. Something else to check out is [C Programming for Microcontrollers](http://dsp-book.narod.ru/CPMicro.pdf) by Joe "Smiley" Pardue. It's ... alright. But it covers some important core topics. Initially learn how to operate some LEDs from a C program. Then learn how to use sensors, then stepper motors, and before you know it you've got a robot. 
Adafruit, element14(iirc?) And co have parts alot surprisingly cheaper than you would think but make no mistake it can get costly as youll sometimes need multiple of one part like motors. Pretty much most online stores carrying a pi will have these types of parts but keep in mind some parts might be on backorder or hard to get or find, documentation for these things is incredibly nonexistent so much so youll often find yourseld reading documentation written by a user who took the time to document things as they poked and prodded the part/microcontroller trying to get it to function. A rather notorious touchscreen display is a prime example I dont know the part number right off but dude spent days trying to figure it out, wrote a library for it to aid other devs and wrote documentation because the manufacturer had not provided anything but the part no software, no tech sheet, no documentation of any kind save for the power requirements
I fail to see how this is related to C programming. Removed as it is off topic.
I assume you are programming in 32 bit x86 assembly using the cdecl calling convention. To call a C function in assembly, push the arguments onto the stack (from right to left), then call the function: push esp push format call printf add esp,8 ... format: db 'esp = %p',10,0 The `add esp,8` afterwards pops the arguments back off the stack. You might also need to declare the function you want to call as `extern` before you can call it. Note that the syntax might differ depending on the assembler you use. To call assembly functions from C, simply declare them: extern void my_function(void); and then call them: my_function(); it should ‚Äújust work.‚Äù Note that you generally need to declare your functions as global so the linker finds them. Don't forget to link the assembly file. If you like, I can make an example for you.
A simple example would be nice. I *almost* understand what you're saying, an example may help :)
What kind of example would you like to have? What assembler do you use (so I can match the syntax)? Do you use an ELF toolchain?
I'm using NASM, and I'm not using the ELF toolchain. Maybe just reading a variable from C into an Assembly register? Something like that? Again, sorry, I haven't learned that much assembly.
What kind of toolchain do you use? If it's not ELF based, what object format do you use? This matters because depending on the toolchain, the calling convention and symbol decoration might differ.
Programs compile to .bin, I don't know what the toolchain is, I made a paste for the script used to compile though [here](http://termbin.com/vvfo)
Okay, you use no object file format and no linker (bin is just a binary image without any meta data). I'm afraid that you need both to be able to program in C because a C compiler won't create a full program but rather an object file that has to be linked with other object to form a binary. So what you need to do is roughly this: 1. select a toolchain (I recommend using the GNU binutils and gcc) and an object file format (I recommend using ELF). nasm can generate ELF objects 2. write a linker script. This script describes what addresses the sections of your object are relocated to. In the beginning, you can simply use one of the default scripts shipped with the linker you use. 3. in your kernel, implement something that can load programs in the executable format to chose. I also recommend to use ELF for that as ELF is really easy to implement in a kernel. Note that you have to do all this anyway eventually. It's the only sensible way to build your kernel once you want to go beyond a single source file. I would recommend you to read a book about this, but I don't know a good one. Note that while you can use bin files for your executables and make the linker generate such files, I advise you to not do that as this design decision is going to bite you later.
Alright, I'll read up on that. Thanks!
C doesn't come standard with all the standard stuff you would expect to have with other languages, including data structures like hash tables. The goal is to keep the language small, simple, and portable; including things like hash tables just doesn't fit with that philosophy. Instead, tradition seems to be that everybody make their own. I've even heard of old programmers who brought their own hash table libraries with them from company to company. This is, as you can imagine, a horrible thing in practice. The best thing to do is use a third party library. There might even already be one on your system (the POSIX standard has one, for example). [Here's an old thread](https://www.reddit.com/r/programming/comments/9ridg/surely_there_is_a_decent_container_data_structure/) with some other suggestions.
Thanks!
Just checking, you're okay with sharing a page of notes for each chapter? :-)
Since you're only updating your table once a day, have you considered using a sorted array / binary search instead of a hash table? In theory hash table lookup is constant time vs logN for binary search, but in practice you might find they're more competitive. Plus the array will be more space efficient - e.g. possibly better use of cache.
Yeah, it's a really good idea. But I've been hesitating because some exercises look complicated, like writing a parser for the C language (it may take a lot of time). And how should the notes be shared (where, in which format)? 
Yeah, it's a really good idea. But I've been hesitating because some exercises look complicated, like writing a parser for C (it may take a lot of time). And how should the notes be shared (where, in which format)? 
Yeah, it's a really good idea. But I've been hesitating because some exercises look complicated, like writing a parser for C (it may take a lot of time). And how should the notes be shared (where, in which format)? 
Yeah, some of those exercises are intimidating, but you can skip whatever you want. If you go through each chapter and do just 2 exercises from each, you will finish the book with a much better understanding of C than before you even opened the book. The point is to get through it and be smarter, without having to understand everything. When you have higher familiarity and programming skill, that's the time to come back for another round, and try to tackle the hardest stuff. You can share the notes in plain text format, on whatever site you prefer that lets you share files. Dropbox, OneDrive, Google Drive, Codeplex, GitHub, etc. There are tons of sites. You might even have a website of your own, that you pay for, like adaddr.com (since your user name here is Adaddr), and you could put the files up on that and link us to them.
That's a good idea. thanks.
I'm not entirely sure how it compares to other hash tables performance-wise, but if you're using glibc (which would be the case if you're on Linux) there's a built-in hash table. https://www.gnu.org/software/libc/manual/html_node/Hash-Search-Function.html
Depends on how fast you need it to be. We (AppNexus, super fast ad serving auctions) use ck_ht_t from concurrencykit.org at work. Blazing fast, plus it's lock-free. The API isn't the friendliest, but it works really well.
We should talk! 
You already got some nice help regarding your specific situation, but here's some general information that might help you search in the future. The answer to "how do I call a function in my platform in assembly" is generally answered by the platform's ABI, or Application Binary Interface. The Wikipedia page on the topic is a good intro: https://en.wikipedia.org/wiki/Application_binary_interface The C language specification leaves a lot of ABI-level details up to the implementation, so the writers of C compilers have to work with the writers of the OS their compiler targets to come up with some of the details of how their compiler will fit the constraints of the hardware, OS, and C specification. In established environments like Windows, Linux, and MacOS, most of the details are defined at the OS layer and the compilers for a given OS all work the same way. In a home-grown OS without a native C compiler, there may or may not be alignment between how the target OS expects the ABI to work and how your host environment's C compiler is going to expect its native ABI to work. You may be able to paper over ABI mismatches with assembly wrappers at the boundaries, but hopefully MikeOS doesn't end up giving you too many mismatches. It's worth knowing that this kind of mismatch is possible, though; it could be the source of some strange bugs.
**Application binary interface** In computer software, an application binary interface (ABI) is the interface between two program modules, one of which is often a library and/or operating system and the other one is usually an application created by a regular programmer. In contrast to an API, which defines structures and methods one can use at software level, an ABI defines the structures and methods used to access external, already compiled libraries/code at the level of machine code. It does this by determining in which binary format information should be passed from one program component to the next, or to the operating system in the case of a system call. Thus it sets details such as the calling convention. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
I use the original Minunit in my projects, and this looks a cool improvement. I'll definitely give it a try.
I use vim when doing small test projects and Qt in larger projects, it autocomplete functions, doxygen comments, and as I'm trying to learn CMake I use that build system when configuring the project.
Good bot.
Thank you loganjamison for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Good bot.
You are the 6734^th person to call /u/GoodBot_BadBot a good bot! ^^^^/u/Good_GoodBot_BadBot ^^^^stopped ^^^^working. ^^^^Now ^^^^I'm ^^^^being ^^^^helpful.
You are the 6735^th person to call /u/GoodBot_BadBot a good bot! ^^^^/u/Good_GoodBot_BadBot ^^^^stopped ^^^^working. ^^^^Now ^^^^I'm ^^^^being ^^^^helpful.
A ton of amazing information here for anybody with similar questions! Thanks a ton!
Good bot.
You are the 1925^th person to call /u/Good_Good_GB_BB a good bot! ^^^^And ^^^^now ^^^^I'm ^^^^being ^^^^anti-community.
The best approach is to simply use an existing ABI for your own project. I recommend adapting the SysV ABI.
C++ maybe? You should check C++14 it has a lot of nifty feature both in the language and in the standard library. Other than that, perhaps Rust is what you're looking for.
[Cello?](http://libcello.org/) 
I do think Cello was it, thank you! 
I seriously don't get why someone would use this instead of C++. The syntax is horrible and would have similar performance (most probably worse) as equivalent C++ code.
What I'd prefer is Go, but I am thinking of doing something on a Retro machine/os that is not likely to ever have Go ported to it, but it does have a C compiler
C++ Support on/for my target system is limited and I went straight from C to Java, skipping C++ for the most part so I don't really know it all that well. 
Do notice, from the `libcello` website: &gt; It might be better to try Cello out on a hobby project first. Cello does *aim to be production ready*, **but because it is a hack it has its fair share of oddities and pitfalls**, and if you are working in a team, or to a deadline, there is much better tooling, support and community for languages such as C++. This isn't to say that it shouldn't be used in production, only that care should be taken (perhaps using more tests etc').
Thanks, I saw that, anything I do would definitely not be for work.
As a new to C I recommend you to work slowly at first. In c you've got to stay focused while writing because there are a lot of vulnerabilities. That's my recommendation for you. If you're having problems detecting those kind of vulnerabilities you can try using any program to help you, I've heard of one called Checkmarx so you can try.. Good luck.
Objective C? 
Currently you're only printing 2 things, not three. 
I don't understand. Sorry, I'm new to this
&gt; You didn't write out the number read in There's the key. Right now you're only printing two things: twice the value and the square of the value. You need to be printing three things (so you'll need three `%d` in the format string).
Right now, you are only printing the double and the square of the number. You aren't printing the original value.
OK so I changed my output to this printf("%d%d%d", x, x * 2, x * x); but it's still incorrect
Even with a C library rather than a whole new language, you'd still need to learn a new API and way of doing things. And it really shouldn't be too hard to learn C++ if you already know C and Java, C++ even allows you to write nearly your whole program in something nearly indistinguishable from C, only using the C++ features when you actually need them.
Read the instructions again very carefully. Details matter when programming. Don't guess, don't make random changes until something works. Your program needs to do exactly what the instructions say, no more, no less. Next, run your program and examine the output. For example, if I give it the value 42, the output should be: 42 84 1764 In other words, "the variable's value, twice the value, and the square of the value, separated by spaces." But your program (with the latest modifications) will produce: 42841764
&gt; example SO spaces between the "%d"' 's. That worked
Bah, this 'MikeOS' is a rip-off of Microsoft's 'Metro' - a.k.a. 'modern UI' (!), a.k.a. 'Window' (*sic*). I bet it runs better, though.
Atom and somtimes Eclipse CDT.
 man math.h man stdio.h 
I have tried that, I just get a message saying there is no manual entry for math.h
well then something is missing on your system man math.h math.h(0P) POSIX Programmer's Manual math.h(0P) PROLOG This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux. NAME math.h ‚Äî mathematical declarations SYNOPSIS #include &lt;math.h&gt; DESCRIPTION Some of the functionality described on this reference page extends the ISO C standard. Applications shall define the appropriate feature test macro (see the System Interfaces volume of POSIX.1‚Äê2008, Section 2.2, The Compilation Environment) to enable the visibility of these symbols in this header. The &lt;math.h&gt; header shall define at least the following types: and so on for several pages... 
don't scan the input as float or any other number type. scan as string, check for break (via strncmp()) and cast after that to float or whatever.
Yes int exit_loop = 0; while (!exit_loop) { //do something exit_loop = _expression_; }
Without the spyware, too :)
What type of system are you running? Because I tried on an Ubuntu machine and osx machine. Same message.
there is nothing wrong with the system, but a packet missing. I use Gentoo but I really don't think Ubuntu or stuff can't deliver. Maybe some user of Ubuntu can post the needed packet name... 
I think you're right, I just spun up an archlinux vm and it works. Bummer.
Hehe, I was in Paris for the piscine of august!! How was it?? Did they accept you?
I have learned that my machine does not have a directory called man0 in /usr/share/man, but archlinux does.
Thanks!
cool :-)
Good job :D
for ubuntu you may install the package manpages-posix-dev
You can't cast a string to a float. You have to convert it. 
Is there a LLVM backend for the system? If so, it might be pretty easy to get Go working on the system, since there's a LLVM frontend for it. Therefore, you might also be able to just compile Go to C, which you then compile on the system compiler. 
Every function has a manpage. Headers typically don't, what was shown in the other comment is a separate package. Use the apropos tool to find functions for your use case.
Thank You.
Note that these header manpages sre from the POSIX standard. They describe what the standard says, not what your system has.
technical details. I think he got what I've meant
Noted
[Vala](https://wiki.gnome.org/Projects/Vala) compiles to C and uses GObject.
yep, no worries :)
There is nothing missing. These man pages do not describe the system, they are just the POSIX standard in man page form. Note that the content of the POSIX standard may differ considerably from your system documentation, especially on Linux.
No, it's 68k, there's barely a GCC for it. There are compilers that run on the platform (AmigaOS for anyone who's interested) plus I assume there'd be some work to port the runtime over (threads, io, etc)
I like vala (I've used it for one little thing - mostly just some slightly customized example code) but my interest in C is for AmigaOS on 68k (Vampire 080) since it's one of the few options open to me and it's been 20 odd years since I wrote any Amiga code (C is about 17 years)
I been wanting to play around with Vala. I had an Amiga back in the day and loved it. It is to bad that Commodore so mishandled the product line as it was mile ahead of other personal computers of the time (except maybe the Atari Jaguars). Have you checked out the new Amiga hardware that was recently released?
Quite an important technical detail when a beginner tries a cast and can't figure out why when he then prints his float, he's getting what looks like a totally gibberish value. Some beginners might spend a long time trying to figure out that a cast isn't what they want. 
Might not be what you're looking for, but I enjoy using [Cython](http://cython.org/) quite a bit. You have the development ease and velocity of Python, with the power and performance of C when you need it.
Yep. We kept the fire burning for a few years after they folded, but eventually moved on. I am waiting for Vampire v4 stand alone... my 1000 is not in a runnable state :-/
Is there a reason to not use C or Java? You say C++ support is limited I cant for the life of me think of a system where C and Java run but C++ wouldn't prettt much any system with C support will have C++ support namely because if the system isn't ultra niche and used to any extent at all someone would take the time to port C++ over if the system has C already Edit: just read comments system is 68k
You can also try `info libc`. It's the GNU libc info manual, I think it's a bit out dated but nevertheless quite good.
Thank you
You managed to do a square, but not triangle. It is 1/4th less work :)
Get an Arduino UNO. Download and install the Arduino IDE. It has many simple example programs you can upload and study. When you're ready you can move up to a more serious programming environment.
Use the first one.
In GCC, turn on `-Wstrict-prototypes` so you don't forget. Then turn on `-Werror` so you really don't forget. I find this very hard to remember when switching between Java and C.
What graphics API do you use for this purpose?
C doesn't have the concept of work spaces. To use a library that is not installed in the standard place, you need to pass appropriate flags to the compiler. Pass `-I/path/to/include/directory`, `-L/path/to/library/directory` and `-llibraryname`. The last option goes to the end of your linker invocation. The library name is the name of the library file with leading `lib` and file extension removed. E.g., `libfoo.a` becomes `-lfoo`. Typically, you would put these options into your Makefile so you don't have to manually type them out. If you use a Linux distribution, install CSFML from your distribution's package management. This will install the library into the right place so you only need the `-lcsfml` operand. If you want to distribute your code to other people, you should consider using something like autotools to automatically detect and configure libraries. 
In function definitions, there is no difference: Both with and without `void`, you declare a function taking no arguments. However, in function *declarations* you should not leave out the `void`. If you do, you tell the compiler that your function takes an unknown amount of arguments of unknown type. Whatever you actually pass, the compiler has no means of checking for correctness. Do you really want this to happen?
Not correct. There is no difference in function definitions.
This is all a bit advanced for me at this stage but I'll keep moving forward slowly and get there eventually. http://www.network-theory.co.uk/docs/gccintro/gccintro_79.html https://www.youtube.com/watch?v=Sy9rGuvfmO0 Some of these seem pretty helpful. Thanks for your input I'll read through your comment again when I've finished the tutorial, hopefully then it will make sense to me ;)
Good idea! Try to get familiar with C before you try to use libraries.
C11 threads are useless. Use pthreads instead.
Amiga represent! :) I presume you've seen this: https://www.youtube.com/watch?v=p83QUZ1-P10&amp;list=PLc3ltHgmiidpK-s0eP5hTKJnjdTHz0_bW
Video linked by /u/Keyframe: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Amiga Hardware Programming 1 - Use the Assembler and wait for left click](https://youtube.com/watch?v=p83QUZ1-P10&amp;list=PLc3ltHgmiidpK-s0eP5hTKJnjdTHz0_bW)|ScoopexUs|2013-06-19|0:02:53|247+ (99%)|32,957 &gt; The first steps from getting an Amiga or emulator to run... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/Keyframe ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dmogaz8\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
I guess I shouldn't even ask... but... how did that subtle difference between declaration and definition come to be?
As others have said, There mistakes in this piece of code. I recommend you to detect those mistakes as quick as possible and solve. There are programs that helps doing that, such as checkamrx but it is also achieved by programming slowly in taking in advance all possibilities in your code. And remember, the bigger the code, the higher is the possibility to have bugs and errors. Good luck.
No, but thats cool!
I do, that way people reading the code know that it takes no parameters for sure and isn't some kind of weird bug or something.
Can you refresh my memory on what the difference between definition and declaration is? the definition is where you actually implement the function, right?
It absolutely works on OS X, so you either messed up your environment or something. What shell are you using, and when was the last time you rebooted?
Define "modernish features"
A *declaration* tells the compiler what type an object or function has. These are declarations: extern int foo[24], bar[], *baz, quux(); char fun(int, char); float lol1(), lol2(void); *Definitions* tell the compiler what value an object or what implementation a function has. Definitions are always also declarations. These are definitions: int foo[24]; /* tentative definition */ int bar[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int *baz; /* another tentative definition */ extern int quux() { return 42; } When you define a global variable (by declaring it without `extern` and initializer), you create a *tentative definition* which is used as a definition (i.e. makes the compiler emit a bunch of zeros to initialize the variable) unless another definition follows, in which case the last definition is used.
It's because when you define a function, the exact number of arguments the function takes is always known to the compiler, so it doesn't make any sense to allow the compiler to forget this information. The C language originally didn't have a mean to specify what arguments a function takes from just a declaration and to not break existing code, function declarations without anything in the argument list behave as they always did and not specify anything about the number and type of arguments (except that the function doesn't take a variable argument list).
Yeah right, it actually makes sense, thanks.
I think that the first version is superfluous, but that's just me. 
The standard permits `char *` to alias with anything, and it's defined to not have a trap representation. Casting to `char *` in order to do byte indexing is perfectly legitimate. The VLA trick is is a neat idea and it should work perfectly fine on any compiler that supports VLAs. However, VLAs became optional in C11, and were never supported in MSVC, so this trick makes your code a little less portable despite not *really* using VLAs (e.g. actual dynamic stack allocation).
This should work, but note that you can't assign to arrays.
It is also different in definitions. The empty parentheses do not form a prototype there either. Definitions are also declarations.
There is actually no "subtle difference" here, the guy you responded to described the situation incorrectly. 
In C you should always use `void`. In C++ it makes no difference, however pedants/purists will try and tell you that it is good style to omit the `void`. Rationale for C: you should always use prototypes for functions (this applies to all declarations of functions - including definitions , because all definitions are also declarations). This is because a prototype means the compiler is required by the standard to raise a diagnostic message if you then call the function with the wrong number or types of arguments. A prototype is a function declaration that specifies the types of the parameters , or void. Empty parentheses do not form a prototype. Without a prototype, the compiler may not warn you about a later call mistake, and furthermore, the standard requires the compiler to compile the code even though it may break at runtime if execution actually reaches the erroneous call site. This may all seem rather strange, but it came about because the language did not have prototypes initially, and when they were added, it was decided that existing code should keep working if it was working before.
foo() and foo(void) means the same thing in both C and C++ when declaring functions. As far as the preferred style is considered, I prefer the one without void as it doesn't really add any new information and it's 4 more characters :p
Hmmm... #include&lt;stdio.h&gt; void x(); void x(int i) { printf("hasargs %i\n", i); } int main() { x(2); return 0; } compiles. #include&lt;stdio.h&gt; void x(void); void x(int i) { printf("hasargs %i\n", i); } int main() { x(2); return 0; } Does not compile.
`1` is `0000 0001`, just the rightmost bit is set. And then just shift to the left by `n`: `1 &lt;&lt; n`. n | result --:|:-- `0` | `0000 0001` `1` | `0000 0010` `2` | `0000 0100` `3` | `0000 1000` `4` | `0001 0000` `5` | `0010 0000` `6` | `0100 0000` `7` | `1000 0000` `8`+ | (Undefined) So now you've a mask you can use to OR (`|`) to set the bit: `statusflags | (1 &lt;&lt; n)`. Use the inverse for a mask you can use with AND (`&amp;`) to clear the bit: `statusflags &amp; ~(1 &lt;&lt; n)`
Except C11 threads are portable to non-POSIX platforms. Did you even think about what you were saying?
C11 threads are pthreads with half the interfaces and guaranteeds removed and everything renamed. They were introduced by Microsoft into the C standardization committee so they have a chance to take over the power to define future directions for the threading interface from the POSIX committee (which has refused all attempts to get bought by Microsoft, as opposed to the C committee). The API is completely pointless, it only exists for reasons of politics and so Microsoft can claim that they implement a standardized threading API without actually allowing people to write portable programs. Note further that as the glibc has yet to support C11 threads (which are an optinal part of C11 btw), your software won't compile on Linux if it uses C11 threads. I do support this decision to boycott this terrible interface.
And if you specifically want to toggle a bit (set it to the opposite state of what it was), use an XOR (`^`).
I am using bash, and I just did a reboot and there are still no manual entries for stdio.h or math.h on OSX.
wouldn't what is in my array's cell need to be in decimal for this to work? since its in binary its just going to assume im trying to toggle a bit on a really large or small number.
Yeah there arent man pages for headers, there for functions. Type man printf
&gt;implying what the copyleft zealot gpl people do is model open source behavior Also, fuck glibc, and fuck linux. Pdclib supports the C11 threads header, and Apple might with Xcode 9? If VS adds support, along with Xcode, i'll absolutely use C11 threads and not look back.
I understand how the man command works, and there are man pages for headers. They do not come initially installed on ubuntu, but (as I wrote in my edit) you can install them with the package `manpages-posix-dev`
Except for compatibility reasons with *really* old code. See the comment by FUZxxl below.
Oh wait, you have an array of 8-bit numbers. To find out the index, use `n / 8`. Because they're integers, they're rounded down, so if `n` is between `0` and `7`, inclusive, then it would be `0`, if `n` is between `8` and `15`, it would be `1`. And then use the modular operator `%` to get the `n` that you can use like the parent comment: `n %= 8`. 1 &lt;&lt; (n % 8): 7654 3210 7654 3210 7654 3210 7654 3210 uint8_t array: 0000 0000 | 0000 0000 | 0000 0000 | 0000 0000 n / 8 (index): 3 2 1 0 len - 1 - n / 8 (index): 0 1 2 3 It might not be "sequential" by bits, but if you want that, you need to start the index from the end. Simply "reverse" it by subtracting the calculated index by the max index. Also, numbers are numbers, the base doesn't matter, as it is just an representation of a number.
Maybe this [this](https://stackoverflow.com/questions/20038297/simple-capitalization-of-first-letter-of-each-word-in-c)?
so would array[index] ^ = 1 &lt;&lt; n; produce 00010000 from 00000000 if n=4?
We were talking about Mac...
Break the problem down and tackle it one step at a time: 1. Write code to transverse a string and print out each character one at a time. For this you will want to research how C stores strings and the relationships between strings and arrays in C. You will also want to learn about using sentinel values to terminate loops 2. Add code to convert each character in the string to uppercase For this step, you will want to look at a ASCII chart. 3. Add code to detect the beginning of a word. 
&gt; Why is this considered better style vs &gt; extern &lt;type&gt; food = 100; It doesn't seem to work: $ gcc -Wall -Wextra -o test test.c test1.c test.c:3:12: warning: ‚Äòfood‚Äô initialized and declared ‚Äòextern‚Äô extern int food = 100; ^ test1.c:1:12: warning: ‚Äòfood‚Äô initialized and declared ‚Äòextern‚Äô extern int food = 100; ^ /tmp/cctFkwm3.o:(.data+0x0): multiple definition of `food' /tmp/ccRVaOQl.o:(.data+0x0): first defined here collect2: error: ld returned 1 exit status 
This is false. From the N1256 draft of the C99 standard: &gt; 6.7.5.3 Function declarators (including prototypes) &gt; &gt; [...] &gt; &gt; 14 An identifier list declares only the identifiers of the parameters of the function. An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied.126) &gt; &gt; 126) See ''future language directions'' (6.11.6). &gt; &gt; [...] &gt; &gt; 6.11.6 Function declarators &gt; &gt;1 The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature. 
So just because Microsoft boycotts POSIX and insteads makes their own shitty NIH threading API, everything else sucks?
Hmm. I'm on my Windows machine at work so I can't test right now but perhaps I meant: //bar.h extern int foo; foo = 100; vs //bar.h extern int foo; //bar.c foo = 100; If the former doesn't work then I'm just mistaken.
You were talking about mac, I made this post for ubuntu. I also tested on my mac to see if it would work.
You can only define each variable once in your entire program. If you put the definition into your header file, it is present in every translation unit that includes it, violating this rule.
Is this where a #include guard is useful? How else would you define a variable in a header file? Edit: Just realized I was thought you were speaking of declaring, not defining. So there is not a way to define a variable in a header? Just to declare it?
This is something that is very easily googled, hence the downvotes (we're not here to do your homework). If you want to actually learn try to reformulate, what exactly are you having a problem with?
No, because i'm not letting gpl zealots decide how I write my software. Plus i may still just go for OpenMP afterall, it's supported by Clang and VS, and easier to use. The only thing I don't like about it is having to use signed ints in loops.
Yes, you just declare variables in headers. You put the declaration into the header and the definition into a source file.
Yeah. Instead, you let Microsoft's embrace, extend, extinguish strategy decide how you write your software. Good luck!
Don't you have toe jam to eat stallman?
I am not a great fan of Stallman either, I am not sure why you are so fixated on him. But I can smell blatant attempts at grabbing power from miles away.
Correct me if I'm wrong, but loop unrolling tends not to be applied to forever loops, though unrolling 99 copies and leaving 1 goto could significantly reduce jump waste, for example in Web servers that run continuously.
I don't get it. What's the point of all these *abysmally* bad Indian/(~Asian?) tutorials? Pretty much every sentence had something wrong about it. Why would you want to teach something you barely know anything about yourself? Is it some requirement by universities that every student create a tutorial for learning purposes? Farming advertisement revenue?
Proprietary shill pls go
Good call, turning on those tags is a great reminder! I've tested this, and calling `gcc` without those tags will allow code with declarations that aren't prototypes to compile, even if I called those functions with the wrong number of args. I'm sure this can result in subtle bugs.
Graphics.h? 
But I need it done anyhow lol 
Unconditional jumps you've taken before are the best case for branch prediction, so the loop doesn't really cost you much in terms of pipelining (there'll probably be a pipeline flush first time round). Unrolling it a lot of times will mean the body takes up numerous cache lines, so you increase the chance of instruction cache misses. Unrolling works best for a loop taken a small number of times with a small body. 
Okay. If you can show us your code, I can try to help you expand it so it can draw triangles.
You seem to be correct. From what I've been taught, function definitions are also declarations. However, if there is a correct declaration earlier in the code (or in a header file) the compiler doesn't seem to care if I leave `void` out of the actual definition. With `-Wstrict-prototypes` and `-Werror` turned on, this doesn't compile, but without those tags it does: #include &lt;stdio.h&gt; void foo(); void foo(int bar) { printf("I have args %d\n", bar); } int main(void) { int my_int; foo(my_int); return 0; } If I change it so that foo doesn't take parameters and then call it with a parameter by mistake, it will still compile if I leave the warnings off: void foo(); void foo() { printf("I have no args\n"); } // Later function call with incorrect number of args... foo(my_int) If I declare `foo()` with this: // Declaration with void void foo(void); The compiler will catch that mistake, and `-Wstrict-prototypes` and `Werror` won't throw up errors about `void foo()` not being a valid prototype. GCC doesn't seem to care if the actual definition has `void` in the parentheses if I already have a valid declaration earlier in the code, even with all warnings turned on. But if I only have the definition of foo, with no earlier declaration, it considers the definition to be the declaration and will throw up errors with the strict prototypes tag if I write something like this: // Definition is also declaration void foo() { printf("I have no args\n"); } Without the strict prototypes tag, GCC will compile this, but it cannot check to see if I always call `foo()` with the right number of arguments. I don't want that. :\ I think I'll be using `void` in all declarations and definitions just to be consistent, though it seems to make no difference in function definitions as long as I have a valid declaration.
It never makes a difference in function definitions.
What a baseless argument lmao. Oooh noooezz he doesnt like copyleft argumentz = micro$oft $hill!!!111 If anything i'm a permissive license shill but stay mad.
How does mentioning him once == obsessed? Oh cuz you're a gpl shill.
But this also compiles: #include &lt;stdio.h&gt; void x() { printf("args?\n"); } int main() { x(2); return 0; } So it's not true that a definition with no parameters acts as a prototype that says the function receives no arguments. However, I *think* this is undefined behavior as per [C99's 6.9.1 paragraph 8](http://port70.net/~nsz/c/c99/n1256.html#6.9.1p8): &gt; If a function that accepts a variable number of arguments is defined without a parameter type list that ends with the ellipsis notation, the behavior is undefined.
&gt; What's the best way to manage these states? Use an `enum` to define the list of possible states. You can then have a variable that contains the current state as read from the EEPROM. &gt; It's pretty minor but neither of these seem like a fantastic way of doing this to me. What issues do you see with the `enum` method? &gt; Also is it safe to compare an enum type (which I believe is guaranteed to be of type int) to a uint8_t? An `enum` will be at least the same size as `int`, though it could be larger if the values exceed the range of `int`. Comparing against a `uint8_t` is totally fine (though obviously values larger than 255 couldn't be used in your variable). &gt; Bonus question: It's not just cleaner, it's required. You simply can't do `extern &lt;type&gt; food = 100;` in a header. A global variable (which should generally be avoided, of course, though they're more acceptable in the world of microcontrollers) lives in a .c file, and only one of them. Other .c files can access that global if you put a declaration to it in the header using `extern` (meaning external -- this variable lives somewhere else).
It does; did you have a question about a specific part of that?
That quote supports my point 
I too have always had an interest in non-mainstream computers. I would love to be able to run Linux on a RiscV CPU; and there does seem to be some interest in developing hardware for. Unfortunately, it is very difficult for new OS/hardware platforms to gain market share (even when they are better). I might have to down load AROS and install it in a VM.
If you're actually going to call them STATE1, STATE2, ... then I see little reason not to use an array to hold the states and integer literals to access the elements. &gt; typedef enum states{STATE1 = 0, STATE2, ...}; Really... You're going to give STATE1 the value 0 instead of 1. This is going to turn around and bite you at some point. Of course, if you have more descriptive names for the states, an enum makes more sense than using integer literals. 
Over the years, I've come up with this style. First, I put all global files into a single C file, and give each one a name starting with 'g' (or 'g_', depending upon mood). int g_state; struct config g_config; struct items *g_items; size_t g_numitems; C guarantees global variables are 0 upon start up, so unless a global is something other than 0, don't bother with initializing them. By using the prefix 'g_' it makes it easy to find uses of the global variables in the rest of the code. I then have a header file that will declare each global variable: extern int g_state; extern struct config g_config; extern struct items *g_items; extern size_t g_numitems; By isolating all global variables into a single file, it will show you just how many global variables you really have (which should be minimal---the more global variables you have, the more unintentional side effects (i.e. bugs) you'll have). 
Why do you expect serious answers to your shitpost? But alright, let me try. Why are you so butthurt about copyleft? What do you think is wrong with it?
At work we use enums or more often just #defines. typedef uint8_t Prefix_StateType; #define PREFIX_STATE_NAME ( (Prefix_StateType)0 ) But, I want the . Operator to work in th IDE! So, my "terrible" idea is to use compound literally to do something similar to your structure idea, that the optimizer should rip through. In the header typedef uint8_t Prefix_StateType; typedef struct Prefix_StateNameTag { Prefix_StateType Name0; Prefix_StateType Name1; } Prefix_StateName; #define Prefix_State ((Prefix_StateName){0, 1}) Then when you use it you can do Prefix_StateType state = Prefix_State.Name0; My coworkers didn't like that, so I don't do it.
Yeah that was just an example I was writing up quickly, didn't really think about it much. In my code they have descriptive names.
Issue was mostly that I felt vaguely uncomfortable comparing an enum type to a uint8_t. I once had a real hair puller bug when I made an assumption about comparing types, and since pain is the greatest teacher I have erred on the side of caution since. 
Yeah I personally prefer Prefix_State.Name0. Luckily this is for a personal project, so no one gets to complain about my style. :] Why the double parens in the #define? I recall reading something about doing that but don't remember exactly what.
Cool, I like this a lot. It really forces you to think about adding a global every time you do it, too. 
Well, it does if your definition is also your declaration. When I tried to compile this with `-Wstrict-prototypes` and `-Werror`, I got no complaints: /* function declaration */ void foo(void); /* definition with no void keyword */ void foo() { // do stuff... } When I removed the function declaration entirely and just left the definition (without `void`), I got an error: me@linuxbox $ gcc -Wall -Wstrict-prototypes -Werror -o test test.c test.c:5:6: error: function declaration isn‚Äôt a prototype [-Werror=strict-prototypes] void foo() ^ cc1: all warnings being treated as errors But when I changed the definition to void foo(void) { // do stuff... } GCC compiled it without complaint. You're right that the compiler only cares about `void` in function declarations, but sometimes our definition IS our declaration as well. :) Most of the time the declarations are in header files though so I doubt this is a common practice in big C programs.
http://en.cppreference.com/w/c/language/operator_precedence Its to ensure the whole #define statement is guaranteed to be evaluated first. Though casting is a higher priority operator. If you have #define CastToUint8Ptr(data) (uint8_t *)data uint32_t Array[2] = {0x55555555UL, 0xAAAAAAAAUL}; uint8 foo = CastToUint8Ptr(Array)[1]; //[ ] gets Array[1] first, then casts 0xAAAAAAAAUL to a uint8_t ptr. I think this will compile warning at least. Using the comma operator, and mixing it with parentheses is cool too. uint8_t foo = 0, 1; //foo = 0 uint8_t bar = (0, 1); //bar = 1 What have I seen this used for. Aliasing a function call and overriding its return. #define Call_AliasFunction(input) (Call_ActualFunction(input), 0) //Always return 0.
You can also do //bar.h static const int foo = 100; //declared at file scope, not function scope Each c file you include the header will have its own version, but, if you trust the optimiser, it should realise its essentially a strongly typed define. edit: as mentioned in my other reply, this too is not a constant-statement, and cannot be used in switch statements edit2: https://stackoverflow.com/questions/1674032/static-const-vs-define-vs-enum/1674459#1674459
Ohh, reading a little, I dont think a compound literal like that could be used in a switch statement. Switch statements need constant-statements, IE #define or enum.
1: nice projection captain shitpost. 2: what made you think i expect actual answers when you're the one that devolved the conversation to strawmen and insults?
It literally says that an empty parameter list has a different meaning in a declaration than in a definition. If that isn't "a subtle difference between declaration and definition," I'm not sure what is.
Can I post any images here? Idk! I'll type it for ya #include&lt;stdio.h&gt; #include&lt;graphics.h&gt; Main () { Int gd=DETECT,gm; Initgraph(&amp;gm,&amp;gd,"C:\\TC\\BGI"); Rectangle (100,100,200,200); getch () return 0; } That's how far I've got, I'm not able to make the triangles inside it. I was thinking of making it with direct lines but it's hopeless I can't do it. I have to make it look like a X inside the box I don't think I can do it. Would you please help.
post yer code
Well, a definition defines a function and a non-definition doesn't. Apart from that they are the same. The original answer incorrectly said that a definition declares a function differently than a non-definition declaration.
I tried, guess it didn't go through. Let me get back to my pc then I'll try again
#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;iomanip&gt; #include &lt;string&gt; #include &lt;sstream&gt; using namespace std; int main(void) { string bookname; string author; int price; ofstream outfile; char reply = 'Y'; outfile.open("C:/Users/Bradley/Desktop/Book_List.txt"); if (!outfile) { cout &lt;&lt; "Unable to find or open output file." &lt;&lt; endl; cin.get(); return(1); } cout &lt;&lt; "Creating Book list file" &lt;&lt; endl; do { cout &lt;&lt; "Enter the information in the following order" &lt;&lt; endl; cout &lt;&lt; "Book Title, Author Name, and Price" &lt;&lt; endl; cout &lt;&lt; endl; getline(cin, bookname); getline(cin, author); cin &gt;&gt; price; //I keep getting a loop here and can not figure out why //getline(cin, price); //stringstream myStream(price); //if (!(cin &gt;&gt; price)) //{ //cout &lt;&lt; "Price input error"; //system("pause"); //} outfile &lt;&lt; left &lt;&lt; setw(40) &lt;&lt; setfill('.') &lt;&lt; bookname; outfile &lt;&lt; left &lt;&lt; setw(25) &lt;&lt; setfill('.')&lt;&lt; author ; outfile &lt;&lt; right &lt;&lt; setw(7) &lt;&lt; setfill('.') &lt;&lt;setprecision(2)&lt;&lt; price &lt;&lt; endl; cout &lt;&lt; "Would you like to enter another book?" &lt;&lt; endl; cout &lt;&lt; "Enter Y for yes and N for no" &lt;&lt; endl; cin &gt;&gt; reply; } while (reply == 'Y' || reply == 'y'); cin.get(); return 0; } 
the commented out parts are things i tried as alternatives with changing the reply data type to string
C and C++ are two different languages.
Oh my bad, I typed I c++ but this is all reddit brought up. Sorry guys
The `uint8_t` will be promoted to `int` for the comparison. Google ‚ÄúC integer promotion‚Äù or look up ¬ß6.3.1.1 in C99 or whatever the equivalent paragraph is in C11, I don't have my copy in front of me.
Try /r/Cplusplus
**Here's a sneak peek of /r/Cplusplus using the [top posts](https://np.reddit.com/r/Cplusplus/top/?sort=top&amp;t=year) of the year!** \#1: [Testing, don't upvote.](https://np.reddit.com/r/Cplusplus/comments/6mpqhe/testing_dont_upvote/) \#2: [I would like to share 400+ data structure and algorithms problems](https://np.reddit.com/r/Cplusplus/comments/6t86lg/i_would_like_to_share_400_data_structure_and/) \#3: [Interview with Bjarne Stroustrup, Creator of C++](https://np.reddit.com/r/Cplusplus/comments/6pgkj8/interview_with_bjarne_stroustrup_creator_of_c/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I'm surprised that nobody pointed this out, but your `struct` example won't work. It won't even compile. But this is precisely what `enum` is for.
Works for me. Can you provide the input that causes it to loop?
As a new to C, I'd say it's not an easy language. You need to practice as much as you can as things gets really complicated in C. Complexity may lead you code to suffer from bugs and errors which going to spend a lot of your time. There are ways to detect and solve those, with programs as checkmarx but a slow work can also do it. Keeping your code safe is important. Good luck.
It loops as soon as you input the author name on the SECOND row entry, which is why it throws me off. Why would it work fine the first time but mess up on the SECOND do while. Also it doesnt matter what the input is, random letters or actual words
Please put four blanks in front of every line of code so the code comes out readable.
Don't do this. `foo` will be allocated a bunch of times and waste memory.
Only if your optimizer can't be trusted
You get an error because you tell gcc to treat something that is not in violation of the standard as a warning and make that an error. This is a ‚Äúdoctor, if I shoot myself into my foot it hurts‚Äù scenario. Personally, I think the gcc warning is wrong here because the standard clearly says that `foo` is declared as a function without arguments in this case, cf. ISO/IEC 9899:2011 ¬ß6.7.6.3 ¬∂14: &gt; An identifier list declares only the identifiers of the parameters of the function. An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied.
C++ is off topic in this subreddit. Please ask elsewhere, e.g. on /r/cpp_questions.
The optimizer can't optimize this away because the C standard guarantees that each variable in static storage occupies a different address.
You are going to have to throw down references to the C spec. When you declare a static file scope variable, the translation unit optimiser is allowed to remove it depending on how it is used, decent compilers will do this. Static changes the storage duration of a variable and scope. static int bar; void foo(int input) { bar = input; //If this is the only reference to bar in the translation unit, it doesn't need to even write the data, and bar won't even exist in the translation unit. } The only time it needs to actually create data is if you access is via pointer. But again, static at a file level can be optimised across the translation unit. //Call function outside of translation unit, now it has to have address call_bar(&amp;foo); edit: GCC options related to this -fkeep-static-consts -fipa-reference
I don't understand this either. However, unless there is an unhealthy amount of advertisements or the content is ripped off, I don't remove these posts. You have vote buttons to choose content.
That's fine. It's kinda fun sometimes to look at these things and count the errors, as well...
1/10 that's the best I can give you, now pls go proprietary cuck.
What I meant is not that the compiler can't throw out unreferenced variables. What I mean is that when multiple translation units use the static variable, each gets its own copy. The compiler is not allowed to merge the different copies into one. This wastes space.
Most(all?) of GNU Coreutils and most other GNU projects are written in C89 to support older architectures that don't have modern C compilers. So, yes, a very large and prominent codebase in written and maintained in C89
Try clearing the buffer. `cin.clear()` followed by`std::cin.ignore(INT_MAX);` after you read the response.
100¬£ for the work :)
Likely these sorts of videos are used to fill clickbait articles in said regions, boosting ad revanue.
No thanks :) I've done it myself. 
Always use it in C++. With C, the issue is that it might not work with older compilers, so you've made your code less portable. On the flip side, if the compiler *does* accept it, you should use it; strict prototyping is a good thing.
&gt; well then something is missing on your system I just tried it on MacOS and Debian and neither have math.h or stdio.h man pages. I've been in this business a long time, and never heard of such a thing. What OS are you running? On the other hand, there *is* a "stdio" man page on my Debian box, and both "stdio" and "math" man pages on my MacOS system. In other words, this is one of those things that vary by operating system.
Lose the blank line before the "while" clause, it makes your code confusing. Your code is reading a floating-point number, not a string. So as far as the code is concerned, "00", "0", "0.0", "0.", etc. are all the same thing. No need to write "00". Are you sure that 0 isn't a valid value? If there's any chance that there could be a zero in your data set, this code will exit prematurely. Even if 0 isn't a valid data point, and thus is a reasonable way to signal end-of-data, the zero value will still get averaged in, which I assume you don't want. What happens if the user enters an empty list? Your `sum / count` expression will be a divide-by-zero error. Here's an alternative solution: signal the end-of-list via end-of-file. If your program is taking input from a file, it will Just Work. If your program is taking input from the user terminal, the user will need to enter \^D (on Unix, might be \^Z on Windows) to signal end-of-file. If you use end-of-file to indicate end of input, scanf() will return the constant EOF*. So now your code could look like: while (scanf("%f", &amp;num) != EOF) { sum += num; ++count; } avg = count &gt; 0 ? sum/count : 0.0; ---- \* The return value for scanf() may be os-specific, so consult your man page first. Alternatively, you could do `while (scanf("%f", &amp;num) == 1)`
it is called education, you would've knew if you had some!, you racist!
&gt;Says the communist &gt; Neglecting your family for your whole career to contribute to the communist utopia‚Ñ¢ that never comes.
You need to add a '&amp;' before your fahrenheit parameter in your scanf call. printf takes values for numbers, but scanf takes pointers to values to fill. In this case the fahrenheit integer is just being treated as a pointer itself, rather than a value. It is in a global variable, so it is initialized to zero (stack variables are NOT initialized to zero) so in effect you are trying to write to a null pointer here.
you gotta use a pointer with scanf: scanf("%d", &amp;farenheit); That's because scanf needs to know where to write what it reads from the user's input and not the actual value of farenheit.
I'll expand a little bit on this... It's unfortunate that C's early "hello world" type programs rely on some more sophisticated functionality of C, namely "variadic functions". Basically printf and scanf are declared in a way where they can take a variable number of arguments, and then those arguments are accessed through some specific code inside the function. Normally functions take a fixed number of arguments, like your conversion function. Unfortunately, one artifact of the way these variadic functions work in C, is that some type information is lost. It would be much more obvious if they simply took parameters of a fixed number and specific type. Then your compiler (depending on settings and which compiler) could spit out a warning or error if you passed in an integer ("fahrenheit") when it was expecting a pointer-to-integer ("&amp;fahrenheit"). But as it is, it just sees a bunch of generic 32-bit or 64-bit chunks of memory and expects the receiving function to know what to do with them (which is why printf and scanf use "%d" for integers, "%f" for floats, and so on). It's up to you to make sure that you feed it a float when you specify a "%f" or an int when you specify a "%d". You can try mismatching these things intentionally (passing a float when you specify a "%d") to see what happens as a result. Many compilers now specifically look for mismatched types going into printf and scanf, and I would advise you to turn on all of these warnings. On Clang and GCC, this flag is "-Wall".
&gt; This is a ‚Äúdoctor, if I shoot myself into my foot it hurts‚Äù scenario. I think the warning is quite useful. If I don't explicitly declare a function to be `void` when it has no parameters, the compiler won't warn me if I incorrectly pass arguments to it in function calls. I've tried this multiple times, and each time get the same result. #include &lt;stdio.h&gt; void foo() { printf("I has no args\n"); } int main(void) { int bar = 52; // But foo was given an arg anyway... foo(bar); return 0; } GCC will compile this quite happily when the stricter warning level is turned off, and the code will run. But this could easily be a source of bugs, and I'd rather that GCC caught this as an error. And GCC does not seem to be happy with functions be given the wrong number of arguments when it can catch them: #include &lt;stdio.h&gt; // Now GCC knows the foo() takes no arguments void foo(void); void foo() { printf("I has no args\n"); } int main(void) { int bar = 52; // But foo was given an arg anyway... foo(bar); return 0; } When I compile this with no enhanced warnings, GCC throws up an error: me@linuxbox:~/code$ gcc -o test test.c test.c: In function ‚Äòmain‚Äô: test.c:17:3: error: too many arguments to function ‚Äòfoo‚Äô foo(bar); ^ test.c:7:6: note: declared here void foo() ^ Now, maybe the GCC isn't entirely conforming to the ISO standard here. It seems to interpret an empty list in a function declarator that is also the function definition as not supply any information about the number and type of parameters, rather than specifying an empty list, since it doesn't catch me passing bar to foo() in the first code snippet. But whatever the case, I prefer to give GCC all the information it needs to check my code for errors, and the enhanced warning level helps make sure I do. :) I'd rather not have GCC let something like this compile: #include &lt;stdio.h&gt; int foo() int main(void) { printf("%d\n", foo(100)); printf("%d\n", foo(5, "bar")); printf("%d\n", foo(23.4, 'a', NULL)); return 0; } int foo(int x, int y) { return x + y; } It just seems like a bad idea to leave the compiler in the dark about how many arguments a function should take!
If `printf` is confusing for new programmers then you can use `puts` which makes a bit more sense.
I suspect this is undefined behavior as well. Every time I wrote test code snippets like yours, GCC happily let them compile, even though this could clearly create bugs in a real program. Turning on `-Wstrict-prototypes` and `-Werror` fixes this. :)
I'm very sorry, your post got stuck in our spam filter. I approved it now.
Your post got stuck in our spam filter. I approved it now. I'm sorry for the inconvenience.
It works up until you need to start outputting numbers and stuff too. I guess we would need a putint() and putfloat() and so on. puts() also inserts its own newline for you, which may be more or less confusing to new users. But, hey, at least it's not as weird as C++, where to understand "hello world" you must understand std::ostream's operator overloading when you use std::cout for it.
https://stackoverflow.com/questions/2692329/int64-on-a-32-bit-machine
I want to join
Can you clarify your meaning? Technically speaking, C **is** datatype loose, just use void* everywhere. But be mindful of the consequences.
Waaah waaah I hate free software, people can fix things because they use the software and then share that fix with everyone else, fuck people who help others please shove that cock further down my throat microsoft I can still breathe - you
&gt; Wouldn't it take two instructions to write one 64 bit value to memory? Yes &gt; Woudn't that be slower? Sure - but 64 bit types are useful, so the alternative of not having them is not pretty compelling either.
&gt; Unfortunately, one artifact of the way these variadic functions work in C, is that some type information is lost. It would be much more obvious if they simply took parameters of a fixed number and specific type. It really has nothing to do with this. If you want to pass a variable to a function and fill it with data (have it hold a possibly different value when the function call ends), then you have to pass the address of the variable, and not the variable itself. In C when you pass something to a function, you are passing by value, not by reference. That means that instead of the actual variable being passed, it passes what's stored in the variable. Therefore: int etown = 1; func( etown ); Really is this: func( 1 ); Inside the function, it may look like this: void func( int etown ) { etown++; printf( "etown: %d\n", etown ); } But that won't change the variable being passed once the function ends. 'etown' won't be 2 when the function ends. Inside the function it will be 2, but outside of it, that variable `etown` will be 1. This is the real reason you have to pass the address of a variable to scanf. When you pass the address of a variable, it too is passed by value, but inside of the function, since the argument is a pointer instead of a non-pointer variable, you use it slightly differently: void func( int *etown ) { (*etown)++; ... } You'd call it differently also: func( &amp;etown ); And when all was said and done, you'd wind up with `etown` holding the value of 2 after the function ended.
This is completely tangential to what I was describing in that sentence. The type information I was describing as lost was the different between an "int" and an "int\*". These are two distinct types, and the receiving function can NOT tell what type was passed in using *the C varargs interface*. The compiler is not smart enough to tell except for special cases made for some standard C functions like scanf and printf, when the first argument is a string literal. But if you do not use varargs, the type information is there and readily available to the compiler, meaning that it can give you warnings or errors when you try to pass an "int" when the function takes an "int\*". Everything you described concerns the fact that scanf needs to modify the thing passing in, which is not related to what I was talking about. That was implicit, though it is the *reason* for taking an "int\*" instead of an "int" it has nothing to do with the mechanism by which it is passed and the lack of the compiler's ability to error check it. Edit: Formatting making my asterisks disappear.
I misunderstood which point you were replying to then. You can put an \\ before your \* to make the formatting keep. 
Why are you even here? Stallmans dick is in /r/linux Also i didn't bother to read more than 1 word of that wall of tldr. Throw your tantrum elsewhere commie. Crazy that someone that supports Donald Trump would be a communist.
Of course it is slower but at least it is functional. 
Looks like everyone has got your problem sorted out. But, why use global variables like you do? The way you have it set up is very weird: You set the global celsius variable to a value in the function, then return that value back to a statement which sets the global variable celsius to that value. Your function could do this instead: double convert(int f) { return 5/9*(f-32); } then it never used the global variable within the function, and you don't need to have global variables at all. Since you're passing the f variable as an argument, the function doesn't need to have access to the global variable.
I never thought of that, I'm just changing over to C from basic so I'm still kinda thinking that way about it all. I also have the program end instantly instead of displaying anything or at least it doesn't stop so I can see and I remember there's something to put in to have it stop to display it instead of instantly closing 
It's worth noting that C implementations do *not* have to have 64-bit types. As of C99, implementations must offer at least 1 type which is *at least* 64 bits in size (called `long long`), even if its implementation is slow. However, none of the `intXX_t` or `uintXX_t` types are guaranteed to exist, though they often do.
Possibly referring to some of the automatic typing feature c++ has?
Well that's not a "loose datatype" system, it's just inferring the type from context.
Code blocks XD
as I wrote below, just Gentoo. it's probably hidden in some developer-package that gets not installed by default. the stdio man page is not the same as stdio.h STDIO(3) Linux Programmer's Manual STDIO(3) NAME stdio - standard input/output library functions SYNOPSIS #include &lt;stdio.h&gt; FILE *stdin; FILE *stdout; FILE *stderr; DESCRIPTION The standard I/O library provides a simple and efficient buffered stream I/O interface. Input and output is mapped into logical data streams and the physical I/O characteristics are concealed. The func‚Äê tions and macros are listed below; more information is available from the individual man pages. A stream is associated with an external file (which may be a physical device) by opening a file, which may involve creating a new file. Cre‚Äê ating an existing file causes its former contents to be discarded. If a file can support positioning requests (such as a disk file, as vs stdio.h(0P) POSIX Programmer's Manual stdio.h(0P) PROLOG This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux. NAME stdio.h ‚Äî standard buffered input/output SYNOPSIS #include &lt;stdio.h&gt; DESCRIPTION Some of the functionality described on this reference page extends the ISO C standard. Applications shall define the appropriate feature test macro (see the System Interfaces volume of POSIX.1‚Äê2008, Section 2.2, The Compilation Environment) to enable the visibility of these symbols in this header. The &lt;stdio.h&gt; header shall define the following data types through typedef: as the list of all functions defined in this header file (as OP requested) is just found in the second one.
they even work on 8 bit micro controllers like avr's and pic's
&gt;muh free software is communism Retard, yeah I can see how much you don't care to read my post because you just keep posting your shit
Why should i read it? You haven't presented a single argument, why waste my time on commie bullshit.
SpacEmacs and Neovim! 
There are that much difference in how IDE deal with projects? if so, I will keep my distance from IDEs haha!
there is auto-complete and fancies IDE features on Vim through plugins. 
Although the statement is correct, in practice most implementations are required to provide the fixed width types where these exist (and they might not always exist or they might not include the 64bit type). Section 7.20.1.1 (paragraph 3) in C11 states (I added the stress to "shall"): &gt; These types are optional. However, if an implementation provides integer types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed types) that have a two‚Äôs complement representation, it **shall** define the corresponding typedef names.
Vim messed up code base can't easily be fixed if crackers invade it. I rather recommending Neovim
Ever tried to manually set up a project with a Makefile or CMake? It can be a real pain. The various IDEs do it for you. You simple include files via the IDE and hey presto, they're part of your build. 
Interesting. So even though there are differences in how IDEs deals with projects, it easier using an IDE than on my own. I will give both ways a try! 
Because your initial value for minMiles should probably be +99 instead of -99. Your first if statement always evaluates to false unless minMiles is less than -99. -10 is greater than -99 so it doesn't get assigned to minMiles. In a situation like this, you want to set your initial value to something arbitrarily high, so that the first time through, the initialized value always gets overwritten.
 for (i = NUM_VALS - 1; 0; i--) In a for loop you have "for (initial state; loop condition; endofloop statement) Your looping condition is '0', which will always be false, meaning it will never loop. What you want is something like 'i &gt;= 0'.
Your second for loop should probably be for (i = NUM_VALS; i &gt;= 0; i--)
minMiles = MAX_INT;
You can tighten your code up a bit: You can declare your loop variable in the loop - eliminating the separate declaration and unnecessary initializations. for(int i = 0; i &lt;= NUM_ROWS - 1; i++){ for(int j = 0; j &lt;= NUM_COLS - 1; j++){ You can do your initialization of milesTracker as part of the definition - eliminating the 4 assignment statements: int milesTracker[NUM_ROWS][NUM_COLS] = { [0][0] = -10, [0][1] = 20, [1][0] = 30, [1][1] = 40, } Edit - to make the above work you'll need to use `#define` for `NUM_ROWS` and `NUM_COLS` You dereference `milesTracker[i][j]` four times in the body of the loop. It would be better to do it once and store it in a local. A smart enough compiler might make this optimization for you, esp in this case since the body of the loop is so simple, but there are definitely situations where the compiler can't and the onus would be on you. This last point you may, or may not, find helpful depending on your level of understanding of C. Feel free to disregard. Arrays elements are stored contiguously. Since you're simply iterating through them and don't really care which row,col each element is in, you can just treat the array as a one dimensional array of `NUM_ROWS* NUM_COLS` ints. In principle, accessing them this way is faster because a multiplication is avoid when computing an elements address. Though, I suppose a smart enough compiler could make this moot. int *milesTracker1D = milesTracker[0]; // or &amp;milesTracker[0][0] if you prefer const int NUM_ELTS = NUM_ROWS* NUM_COLS; for (int i = 0; i &lt; NUM_ELTS; ++i) { int miles = milesTracker1D[i]; if(miles &lt; minMiles){ minMiles = miles; } if(miles &gt; maxMiles){ maxMiles = miles; } }
Is this BGI, the Borland Graphics Interface? I haven't seen that since I was writing code on DOS, how does it still exist? I believe that if you want to draw a triangle, drawpoly(int numpoints, int *points) is the function to call. For example: int points[] = { 100, 100, 100, 200, 200, 100 }; drawpoly(3, points); I have no idea what a xender logo is, so you'll have to adapt the actual coordinates yourself.
I prefer initializing your min and max to the first element of the array, I think this is better because not every time you will know the range of the input e.g: In your program if you initialized min to 99 and all the input was &gt; 99, min will still equal to 99 and that's wrong.
What the program looks like when ran. https://imgur.com/hypk8lF
Forgot the %f in your printf
Show your code. And not as an image.
Please do not post code as images. Always post code as text!
Thank you.
Sorry new here, and to coding. Thanks for letting me know!
`NUM_VALS - 1` is correct. `NUM_VALS` is past the array.
No problem, just keep that in mind next time. I can't take your picture and compile it. This makes it very difficult for me to find out what the problem with your code is.
This is the best strategy, and I was just about to explain this before seeing your post. I'd like to add as well, that it's mathematically correct in any case, for any range, for any values, since the minimum and maximum of a set has to be a member of that set.
&gt;They were introduced by Microsoft into the C standardization committee so they have a chance to take over the power to define future directions for the threading interface from the POSIX committee (which has refused all attempts to get bought by Microsoft, as opposed to the C committee). Do you have a source on that or are you talking out of your ass?
It's fairly obvious what has happened. If the C11 committee (resp. Microsoft) wanted a good industry standard, they would have adopted pthreads (or a subset of them). What they did instead is right out of Microsoft's EEE textbook strategy.
Again, do you have a source? Where is the evidence that backs the claim that MS was the one who made or even cared about the C11 multithreading proposal? Show me something.
Sorry what's DSP?
See, the paper calls C unmanageable and disgusting, but I would say the exact same thing about Javascript. It seems to be about the mindset as you go into projects, and if necessary, taking the required time to clean up your, "unmanageable mess" to make it manageable. Seems very doable if you realize the problems ahead of time.
Who's the mother?
He was one of the substantial computer scientist in the world.
Hope he was done paying child support. 
This subreddit is about C, not C++. I have removed your submission as it is off topic. Please ask elsewhere, e.g. in /r/cpp_questions.
Unfortunately, he has much less recognition than he deserves. RIP our Saviour.
The mother was a total B.
That was a good read, do we have the safe C he described implemented anywhere? 
I think the address sanitiser implemented by gcc and clang is very close.
It's funny how you constantly see the work of Richie, Thompson, and Kernighan pop up everywhere.
A genius. Think of what C created. And what those creations led to. Sure, if he wasn't there back then someone else would have came up with a similar language, which would have had the same impact. But think about what he did. Not just C, but UNIX and other pillars of modern computer science. He is, wether you want it or not, responsible for today's civilisation. And it's such a shame other people like Steve Jobs appear more in pop culture and get credited much more. It's been 6 years, Ritchie, and some people won't forget you.
Short for BCPL.
Fantastic explanation of how my proposed optimization turns out to be premature. Thanks dude!
Dennis Ritchie is due a lot of respect for the work he did, but this is over-the-top ridiculous. C and Unix are not pillars of computer science; they're the particular implementations of the concepts of "systems programming language" and "computer operating system" that happened to win in the marketplace. If some inventions are responsible for today's civilization, I'd cite the internal combustion engine or the refrigerator or something--do you know what engineer worked on the first widespread refrigerator? I do, because I just looked it up to make the comparison, and if Dennis Ritchie deserves fame and adoration from all, then so does that guy: http://www.industrialdesignhistory.com/node/148 Ritchie (along with Thompson, of course) was an excellent systems programmer and definitely put his fingerprints on a whole lot of today's computing infrastructure. I really like that he was also a pretty humble, low-key guy that just quietly built the stuff he wanted to have. He was pretty straightforward in his writings (which are very interesting to read--he was a pretty good writer, too) about how Unix and C evolved, where the ideas came from, and what his contributions were. He really didn't invent a whole lot of the ideas in C or Unix; his talent was in identifying good ideas, understanding how they fit together, and then coming up with small, efficient implementations of them. Basically, someone with an engineering mindset who ended up with a great team of other thinkers and engineers. C was not invented out of whole cloth. It came to Ritchie by way of Ken Thompson's B language, which was a slightly modified version of Martin Richards' BCPL. BCPL was in turn a stripped-down version of CPL, which was largely the brainchild of Christopher Strachey. Most of the concepts in CPL were borrowed from Algol 60 (designed by a huge committee, but pulled together into coherence largely by Peter Naur) and other languages of the day such as Fortran (John Backus and others). Such is the nature of these things; no one person deserves all the credit, and all of those people and others deserve credit for the actual contributions they made. Ritchie actually told us exactly what changes he made to B in order to create C. Mostly it's the type system--he took some inspiration from Algol 68's types, created his own syntactic idea of "declaration follows use" and added structures as well. He made a lot of effort to break compatibility with B as little as possible, since B had become familiar to people in the labs and they were generally happy with it. As far as Unix goes, by all accounts he did a whole lot of hacking on it during the early days, but several others were involved as well and aside from a few novel ideas (largely from others) it's not a very large or groundbreaking system, especially at the time of its creation. Its success was due in no small part to the engineering talent of Thompson and Ritchie, but also in large part due to the timing of its release and the political situation Bell Labs was in, making it nearly free of charge for universities but not officially supported. This led to the development of User Groups supporting it unofficially and a vibrant community around it at universities, where a great deal of the action in computing was taking place. One of his big contributions to Unix, which I think was pretty clever but which did not really catch on, was the Streams interface for terminals and networking. It allowed for writing efficient, modular protocol layers in the kernel for line disciplines, protocol encapsulation, etc. It got bloated later on in the System V days, never got picked up in Linux, and was eventually dropped from POSIX. Anyway, I think it's foolish and maybe even a bit disrespectful to make some techno-messiah out of Ritchie. I don't think he wanted a lot of fame, and would prefer to be remembered as a research engineer and research engineering manager that got to work on some cool, influential technology with some other excellent engineers. He gets the respect he deserves from the people who know enough to give it, and I think that's enough. He'll definitely be remembered far longer than the guy who engineered the first commercially successful refrigerator.
Still learning C but I reckon how much this sir made. As Tiobe index top 8 languages are all made on C! 
Sounds like what zig is trying. You can specify blocks of code as hot paths and selectively turn off some safety checks. It isn't even at 0.1 release yet though, but it seems interesting to watch. ziglang.org
&gt; printf("Volume of the cylinder is: ", vol); That is not how printf works. You need to add a placeholder for the value to the string, in this case %f, because vol is of type float: printf("Volume of the cylinder is: %f", vol); 
Seeing as the jdk is written in c++ there are no platforms that support Java but not c++.
Peopler have already pointed out what the problem is (the scanf call needs a pointer), so here's some additional advice: You should always enable (and read) all warnings that your compiler can give you. In the case of gcc, that's done with the -Wall command-line option, and with clang, you get even more warnings with -Wall -Wextra. In Visual Studio, there's a preference to set the warning level someplace in the GUI, consult your manual. Without those options, C compilers are not very strict about type checking (thank you, Misters Kernighan and Richie) and will allow all kinds of conversions that most of the time simply indicate an error like the one you made.
I referring to have a C language that works more like PHP or Python. It will be really great to have a language like this.
You could possibly find someone to give that moniker to, but it is unnecessary considering the Mother of the Internet was Radia Perlman; and the Mother of Programming was Ada Lovelace. 
I'd like to know more
I also want to know and have C ++ code
it simulates being a good programming language too...haha
This subreddit is about programming in C. Please ask C++ questions elsewhere, e.g. on /r/cpp_questions. I have removed your post as it is off topic.
Your post got caught in our spam filter. I apologize for the inconvenience.
Your post got caught in our spam filter. I apologize for the inconvenience.
So, what parts of C remain?
C++ is off topic in here. Please post C++ content elsewhere.
Really? I'm not too familiar with Java only know bits and pieces of it.
What is your exact question? `malloc` accepts a number of bytes you'd like to have, and the memory allocator behind it allocates and reserves a bit of memory of the size you specified and returns a pointer to the allocated block of memory. If it can't (all blocks are full, the operating system won't give new blocks of memory...), it returns `NULL`. The allocated block of memory can be given back for further use using the `free` function. If you want to look into a memory allocator, look at the sources, like from [glibc](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=1c2a0b05b78c84cea60ee998108180d51b1f1ddf;hb=HEAD).
&lt;3 
There are two ways of allocating memory with C. You can either say how much you want during compilation, in which case it comes from an area known as the "stack" or you can ask for it while the program is running, in which it comes from the "heap." You use static memory whenever you declare a variable, like "int i = 0" or "char name[16]." In each case the compiler knows exactly how much memory is needed and can take it from the stack. But what if you don't know how much memory you need beforehand? Say you have a program to input and store phone numbers. The user could put in two or two hundred. If it's two, you don't want to waste lots of memory by holding a giant block of memory. If it's two hundred, you need somewhere to put the data. Now you can ask the user how many numbers they want to enter (let's store it in a variable called "totalNumbers"), then call malloc(totalNumbers * sizeof(int)) to get exactly the right amount of memory. Obviously you wouldn't store phone numbers as ints, but that makes it simpler here. And don't forget the sizeof(int) part. Each item will take up more than one byte of memory, and the operating system doesn't know what you're going to do with the memory. You store the result in a pointer and use it like you would any other pointer. But it's also important not to lose track of where the memory block you got starts. The downside of allocating memory during run time is that you also have to release it when you're done. After you finish using the memory, call free() on the original pointer. Here you don't have to worry about the size. The operating system knows how much you took and releases it all. One last point - I said that you're asking for memory. You're not guaranteed to get it. If there's isn't enough available, malloc will return NULL. Free() will only fail if you give it an invalid address, which will cause undefined behavior
&gt; there are errors when i try to compile. Don't make people guess. What are the errors? And put 4 spaces in front of each line for formatting
the errors shown are following and thanks for your suggestion: ubuntu@ubuntu:~$ cd Documents ubuntu@ubuntu:~/Documents$ cd 1 ubuntu@ubuntu:~/Documents/1$ gcc -std=c99 -Wall -pedantic PP.c PP.c:1:1: error: expected identifier or ‚Äò(‚Äô before ‚Äò/‚Äô token PP.c:1:1: error: stray ‚Äò\342‚Äô in program PP.c:1:1: error: stray ‚Äò\210‚Äô in program PP.c:1:1: error: stray ‚Äò\227‚Äô in program PP.c:1:1: error: stray ‚Äò\342‚Äô in program PP.c:1:1: error: stray ‚Äò\210‚Äô in program PP.c:1:1: error: stray ‚Äò\227‚Äô in program PP.c:2:1: error: stray ‚Äò\342‚Äô in program PP.c:2:1: error: stray ‚Äò\210‚Äô in program PP.c:2:1: error: stray ‚Äò\227‚Äô in program PP.c:2:1: error: stray ‚Äò@‚Äô in program PP.c:2:1: error: stray ‚Äò\342‚Äô in program PP.c:2:1: error: stray ‚Äò\210‚Äô in program PP.c:2:1: error: stray ‚Äò\227‚Äô in program PP.c:3:1: error: stray ‚Äò\342‚Äô in program PP.c:3:1: error: stray ‚Äò\210‚Äô in program PP.c:3:1: error: stray ‚Äò\227‚Äô in program PP.c:3:1: error: stray ‚Äò\342‚Äô in program PP.c:3:1: error: stray ‚Äò\210‚Äô in program PP.c:3:1: error: stray ‚Äò\227‚Äô in program PP.c:4:1: error: stray ‚Äò\342‚Äô in program PP.c:4:1: error: stray ‚Äò\210‚Äô in program PP.c:4:1: error: stray ‚Äò\227‚Äô in program PP.c:4:1: error: stray ‚Äò\342‚Äô in program PP.c:4:1: error: stray ‚Äò\210‚Äô in program PP.c:4:1: error: stray ‚Äò\227‚Äô in program PP.c:5:1: error: stray ‚Äò\342‚Äô in program PP.c:5:1: error: stray ‚Äò\210‚Äô in program PP.c:5:1: error: stray ‚Äò\227‚Äô in program PP.c:5:1: error: stray ‚Äò\342‚Äô in program PP.c:5:1: error: stray ‚Äò\210‚Äô in program PP.c:5:1: error: stray ‚Äò\227‚Äô in program In file included from /usr/include/stdio.h:75:0, from PP.c:7: /usr/include/libio.h:334:3: error: unknown type name ‚Äòsize_t‚Äô /usr/include/libio.h:338:67: error: ‚Äòsize_t‚Äô undeclared here (not in a function) /usr/include/libio.h:366:62: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/libio.h:375:6: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/libio.h:497:19: error: expected ‚Äò=‚Äô, ‚Äò,‚Äô, ‚Äò;‚Äô, ‚Äòasm‚Äô or ‚Äò__attribute__‚Äô before ‚Äò_IO_sgetn‚Äô In file included from PP.c:7:0: /usr/include/stdio.h:338:20: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdio.h:387:44: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdio.h:391:45: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdio.h:706:15: error: expected ‚Äò=‚Äô, ‚Äò,‚Äô, ‚Äò;‚Äô, ‚Äòasm‚Äô or ‚Äò__attribute__‚Äô before ‚Äòfread‚Äô /usr/include/stdio.h:712:15: error: expected ‚Äò=‚Äô, ‚Äò,‚Äô, ‚Äò;‚Äô, ‚Äòasm‚Äô or ‚Äò__attribute__‚Äô before ‚Äòfwrite‚Äô In file included from PP.c:8:0: /usr/include/stdlib.h:140:15: error: expected ‚Äò=‚Äô, ‚Äò,‚Äô, ‚Äò;‚Äô, ‚Äòasm‚Äô or ‚Äò__attribute__‚Äô before ‚Äò__ctype_get_mb_cur_max‚Äô /usr/include/stdlib.h:471:22: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:473:22: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:473:38: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:485:36: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:756:9: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:756:25: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:761:34: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:761:50: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:860:38: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:864:36: error: expected declaration specifiers or ‚Äò...‚Äô before ‚Äòsize_t‚Äô /usr/include/stdlib.h:871:15: error: expected ‚Äò=‚Äô, ‚Äò,‚Äô, ‚Äò;‚Äô, ‚Äòasm‚Äô or ‚Äò__attribute__‚Äô before ‚Äòmbstowcs‚Äô /usr/include/stdlib.h:874:15: error: expected ‚Äò=‚Äô, ‚Äò,‚Äô, ‚Äò;‚Äô, ‚Äòasm‚Äô or ‚Äò__attribute__‚Äô before ‚Äòwcstombs‚Äô ubuntu@ubuntu:~/Documents/1$ 
All those errors about `stray something` mean your source file contains characters the compiler doesn't recognise. You must use a plain text editor to create C source, not a word processor. Or you may have copied this from a website or document. You should type it in again using your favourite text editor
Thank you for reading the submission guideline. However, you misunderstood it! You aren't meant to type `‚ê£` characters, `‚ê£` is just used to visualize how many spaces you are supposed to type. Instead of `‚ê£`, just type a space!
At least hotspot (the jvm from openJDK) is written in c++. I guess there could be one written in another language that would work without c++ support, but I don't know if any, and at that point porting the jvm would be a ton of work anyway, so there isn't a good reason to not also bring along the work of a gcc or llvm backend.
Did you have a specific question?
This que i found on online competition exam and i was unable to it! Its c programming que
Thanks for your help! It took away the errors
We already have that, it's called Perl.
&gt; You dereference milesTracker[i][j] four times in the body of the loop. It would be better to do it once and store it in a local. A smart enough compiler might make this optimization for you [...] A compiler that doesn't isn't worth using. 
Did you attempt to solve the problem at all? If so, please post any code you wrote.
&gt; If you want to look into a memory allocator, look at the sources, like from glibc. I wouldn't recommend that. Modern high-performance allocators like jemalloc or glibc's or even uClibc's are too complex to understand for a beginner. Find one that was designed for simplicity, ideally for teaching purposes.
&gt; You can either say how much you want during compilation, in which case it comes from an area known as the "stack" or you can ask for it while the program is running, in which it comes from the "heap." C has no concept of stack or heap. And on implementations where these words mean something, memory allocated by ‚Äúsaying how much you want during compilation‚Äù might also come from the heap, or from a third area which is neither the stack nor the heap. &gt; You use static memory whenever you declare a variable, The word ‚Äústatic‚Äù has a very specific meaning in the context of C, and this is not it. &gt; Free() will only fail if you give it an invalid address, which will cause undefined behavior Sure, but... I think it's a little early to talk about UB. Just say ‚Äúwill cause your program to crash or malfunction in unpredictable ways‚Äù.
Thanks for correcting some of the mistakes. I wrote my answer in a rush and didn't look it over enough before posting
I like this one too. https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/
NP. I once witnessed a protracted flame war on comp.lang.c over the concept of stack, with one person stubbornly insisting that it was impossible to build a computer or write a program without one and the rest pointing out that the word does not appear even once in the standard and that there are programming languages (Simula, for one) that do not use a traditional stack...
I'm not sure something else would have replaced it, it hit a sweet spot where I suspect several languages would have replaced it but we wouldn't have the lingua franca like we do today.
Someone posted this just a few hours ago, you might find it interesting: [Implementing malloc and free](https://www.reddit.com/r/C_Programming/comments/6zci6a/implementing_malloc_and_free/) Note that modern implementations generally use `mmap()` rather than `brk()` or `sbrk()`, but the principle remains (mostly) the same.
Your code got caught in our spam filter. I apologize for the inconvenience.
Slightly ironically, your code got caught in our spam filter. I apologize for the inconvenience.
Your post got caught in our spam filter. I apologize for the inconvenience.
Your post got caught in our spam filter. I apologize for the inconvenience.
I told you last time to cut out on your shitty tutorials. Also, this subreddit is about C only. C# is off topic. Please go spam elsewhere.
I wish C had perl-style named loops, which are really nice for cases like this. But it doesn't, so no harm in using goto.
No problem, thanks for letting me know
I use Catch. It''s a single-header C++ framework, but it works fine with C. You'll have to add extern C to your headers though
Short version: a C program is portable if you can compile and execute it on many different computers without changing its source code. Long version: https://en.wikipedia.org/wiki/Software_portability
**Software portability** Portability in high-level computer programming is the usability of the same software in different environments. The prerequirement for portability is the generalized abstraction between the application logic and system interfaces. When software with the same functionality is produced for several computing platforms, portability is the key issue for development cost reduction. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Kernighan and Ritchie said: *If you want to go somewhere, goto is the right way to do that.* You wanted to go somewhere, you used goto, everything is good. 
[removed]
Kindly fuck off and enjoy your ban.
Your post got caught in our spam filter. I apologize for the inconvenience.
The %s format specifier is for printing strings, not individual characters.
In your printing function you only try to print the value if the node has something next. This will mean that a list of length less than two won't behave as you expect. Examples: What is there is one item in the list? What if there are no items in the list?
Really ? I did the July one :) Yeah I made it, going to start in November. However I'm moving to the Cluj campus in Romania, not a big fan of France, so I'm quite happy to get the fuck out of this city.
Also, the function `print_list` will always print one element less due to the line while(l1-&gt;next!=NULL) It should be changed to `while(l1!=NULL)`
Using a goto is definitely OK by my book. In many cases it can mean a significant performance improvement and C is all about squeezing that last bit. There are certainly people that will argue you could rewrite the logic to avoid using goto, but in this case the usage is quite obvious and IMHO safe. BTW ‚Äì a little known fact ‚Äì using goto is also recommended for freeing resources in the opposite order of their initialization, take a look at this [security recommendation](https://www.securecoding.cert.org/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources).
C has decent portability, but you do need to be careful what constructs you use. For instance, using c99 things may reduce portability. IE typedef struct FooTypeTag { uint8 Bar; } FooType; FooType Foo = { .Bar = 1 }; This uses structure initialization from C99. We do this heavily now, but 5 years ago where I work, we were weary of it because we had compilers where this did not work. C90 is usually considered well supported
The most usable one for my purposes is [Criterion](https://github.com/Snaipe/Criterion). It's simple to use, is actively developed, has good documentation, smart design and very friendly main developer. Basically, every time I needed a feature it was already there. For instance, every test is executed in it's own process. Also, the syntax is quite readable, very clean and not cluttered with hard to read macros. I definitely recommend this one!
Hello, fellow C devs! Some days ago I posted on /r/Programming about a useful (for me at least) Notepad++ plugin which I wrote entirely in C. Please tell me what you think about the style and the quality of the code. I'm striving to improve every day and criticism is more than welcome; I highly value the expertise of the community. Few words about the project. The plugin is an extension to NppExec, another very useful plugin, that allows you to execute elaborate scripts. NppEventExec allows you to execute these scripts *automatically* upon Notepad++ events (e.g. "format a source file before saving it and compile it afterwards"). I wrote it in C, because... well, I love C and I'm also quite fond of the loading time, performance and memory footprint of Notepad++. Also, I didn't want to compromise security, so I tried to catch every potential error and not to ignore significant return codes. Proper buffer management and undefined behavior are certainly big challenges. Writing and unit testing the CSV parser was quite fun and, of course, exploring the depths of the Win32 API is always rewarding! Even though I'm putting serious effort, the code is probably full of bugs... 
Interesting - I was ignoring the C++ ones on the assumption that getting them to work with C would be a painful experience :-) I'll give that a try - thanks
`goto spam_filter;`
Some defines and ifdefs can help with that, if the goal is ultimate backwards portability or portability to legacy hardware. But it can be challenging.
you're telling scanf that the integers are delimeted by commas, and then your inputting 1 integer
Hi theoriginalanomaly, thank you for your reply! I just start learning programming. I see your point but do you have any idea what I should do to make it right?
1,2,4,3 should be the input
But I have to use 1243 as my input .... it is my assignment's requirement.
I didn't have much time to play with it much but it seems pretty neat! Thanks for sharing! 
that may or may not be possible with scanf, you'd have to read up on the documentation, or find another method
I'm going to throw my own framework [EMU](https://github.com/VictorSCushman/EMU) into the mix. More verbose than MinUnit, less complicated than Catch. Specifically designed for C (with some C++ features for try catch). Use it or don't. Just throwing it in there.
So you need to scan individual digits. You could: 1. scan a 4-digit integer and then build your individual digits by a succession of divide/modulo 10 operations. 2. scan the input as a string and proceed each character. 3. scan the input as characters with `%c` format. 4. scan the input as integers, but limiting the field length to 1 digit with`%1d` format. The 4^th option is the easiest to apply to your program (#3 is the second easiest, but using characters as numbers might confuse you). 
I'm very curious, what is allowed, or... what is expressly specified?
Automatic test discovery is nice, googletest does that too. (Both seem to be xUnit)
I wonder how should I write the scanf part if the input is like there are whitespace between each other? like 1 2 4 3? I wrote like this: scanf ("%d %d %d %d",&amp;a,&amp;b,&amp;c,&amp;d); but it doesnt work properly.
I noticed that your [CSV parser](https://github.com/MIvanchev/NppEventExec/blob/a78a579921578c1d920946c9c498ecc0a7c3c380/csv.c#L664) accepts overlong sequences contrary to the UTF-8 spec: every code point should have the shortest possible encoding, so a 2-byte sequence must encode a code point above `0x7f`, a 3-byte above `0x7ff` and a 4-byte above `0xffff`. In your use, it's fine if you want to be lenient and accept overlong encodings, since you convert to UTF-16 right away. However, it's common to reject them because they might mean someone is trying to do something nefarious, like sneaking some ASCII character past some checker (like delivering `'` without having a byte with value 39 (the ASCII code for `'`) present like it should if the text were properly encoded in UTF-8). EDIT: corrected code point limits for each byte sequence length
Uhh, what? Can you explain this further? Why is this a security flaw and how can it be used against potential victims?
Suppose you write a program that accepts file names and reads them from the user directory `/tmp/USER`. You want to ensure the file name doesn't contain any "`/`" (that is, it's a pure file name with no directories). If it's proper UTF-8, you can just check each byte to see if it's `0x2f` (the ASCII code for "`/`"). Now, suppose someone sends you a file name containing the byte sequence (`0x2e`, `0x2e`, `0xc0`, `0xaf`). The method above wouldn't see any `0x2f` and conclude there is no `/`. Then a parser that doesn't check for overlong sequences would decode those 4 bytes as "`../`" (the 2-byte sequence `0xc0`, `0xaf` is an overlong way to encode `/`). The end result is your program being tricked into accessing a file outside the user's directory. 
the scanf part worked after me retyping it but not the whole code but still thanks!
like white space between inputs e.g. 2 6 3 5
But its just arrays and loops that are not allowed?
exactly
 scanf("%1d%1d%1d%1d", &amp;a, &amp;b, &amp;c, &amp;d); But I would go and double-check. That's a rather bizarre requirement that you have a series of decimal numbers with no separators between them at all.
I hate puzzles that are "find a baroque way to do this thing that can easily be done in a standard way." But what the hell, I like a challenge #define swap(x, y) do {tmp=x; x=y; y=tmp;} while(0) // Bubble sort if (a &gt; b) swap(a, b); if (b &gt; c) swap(b, c); if (c &gt; d) swap(c, d); if (a &gt; b) swap(a, b); if (b &gt; c) swap(b, c); if (a &gt; b) swap(a, b);
IMHO, this is a perfectly legitimate use of goto, and if someone wanted to argue about why even have goto, I would point to this post as an example.
This is the C programming subreddit not the C++ programming subreddit. This video does not belong here.
Gonna point out another error: celcius = 5/9*(fahrenheit - 32); There's a lot of ways this can break, but there's a good chance that the answer is always going to be zero. That's because you used integers everywhere. The compiler is going to evaluate this expression left-to-right. That means it first computes (5/9) and then multiplies by (fahrenheit - 32). But (5/9) is zero. So now your function is actually returning 0*(fahrenheit - 32). In fact, your compiler is likely to simply replace that entire line of code with `celsius = 0`. If you're going to be multiplying and dividing by integers, you should first multiply everything, then divide: celcius = 5*(fahrenheit - 32)/9; (But see below for another bug this introduces.) And still, this result will be inaccurate due to round-off error. Even *if* the integer expression didn't evaluate to zero, you want to do this. Example: fahrenheight = 9/5*celcius + 32; would be the same as fahrenheight = 1*celcius + 32 Now, you could have salvaged this by doing celcius = 5.0/9*(fahrenheight - 32); By using "5.0" instead of "5", you've caused that constant to become a double. And this, in turn, causes everything in the expression to be converted to double. Now you'll get an accurate answer. But really, the right solution would have been to do the entire program with just using doubles. Make fahrenheit a double in the first place (and use a %g format to read it) and do all your math in double. You're not saving any memory or time by using integers anywhere; all you're doing is forcing the compiler to keep converting things from one format to another. ---- Final problem, alluded to above: using a construct like this: a * b / c will significantly reduce the numeric error, but now you risk having `a * b` overflow the capacity of an int, even though `a * b / c` would not have been an overflow. Whenever you're working with integer math this way, you always need to be thinking about where and how you might get an overflow, an underflow, or a divide-by-zero. **In Conclusion** Any time you see an integer multiply in your code, you should stop and ask yourself if there's any chance this could overflow. Any time you see an integer divide in your code, an alarm bell should go off in your head. You need to double-check that the divisor can never be zero, and you should stop and ask yourself how much round-off error there will be and if it will cause problems.
1. Please don't post code as images. We can't compile an image. 1. Show your entire code. You're currently missing, among other things, the definition of `check_command()` and `tmp_command`. 1. What have you tried already? This looks a lot like homework, which we don't want to do for you.
For a really simple test framework, try libtap.
C is the most portable language in existence...
As a new to C, I recommend you taking some courses on the web as they can really useful and save you a lot of troubles. They are also free most times. It's really important to know how to deal with errors and detect them quickly. If you're having troubles doing that on your own you can always use a program as help. I tend to use checkmarx and it works fine. Good luck!
it means that the size/type (signed/unsigned) that you `return`ed doesn't match the function definition. For example: uint8_t wat(void) { int8_t Yoo = 0; return Yoo; } 
This subreddit is about C only. Please post C++ content elsewhere.
Your post got caught in our spam filter. I apologize for the inconvenience.
exampleFunc(&amp;example.c);
You can but you really shouldn't. Why don't you pass a pointer to an instance of the struct instead of a pointer to the member?
C ‚â† C++
Read the full text if the error message to see what it means. The [-Wint-conversion] part is telling you which warning flag enables this warning.
No, you can't. You're passing `a` *by value*, so `exampleFunc()` has no idea where the struct is. If, however, `exampleFunc()` is declared as `exampleFunc(int **ap)` and called as `exampleFunc(&amp;e.a)`, then it can cast `ap` to a `struct example *` and access `e.c` through there.
C++ is off topic here. If you violate this.rule again, I have to ban you.
Most compilers will compile in C99 for example. K&amp;R, 2nd edition will give examples with dangerous syntax elements that were forbidden later, either by standard or by some compilers. Sometimes you may need to compile using -std=c89 or -std=ansi for it to work. For example, when implementing the getline function, if you do not specify -std=ansi, then an implicit definition of getline will conflict with yours and fail the compilation. But that's compiler-specific. In the end, the C itself is still correct.
TBH, although this is a C subreddit, I really doubt C is the best choice for this particular project. C++ would have allowed for a much cleaner and more maintainable code without any performance or memory drawbacks. Generally, the code reuse would be much better. For instance, every dialog in the plugin currently has a separate DlgProc implementation. Expanding the plugin in the future will probably take a lot of effort. OP seems to reinvent the wheel a couple of times as well. There are several CSV parsers available and I doubt there is a need to do manual string management which, as a lot of people would agree, opens Pandora's box.
that's ok, thank you for your help!
assuming you can't do that. you are not in control of the argument being sent to `exampleFunc`. It will be `a`.
well I'm working with glfw and I have a struct that has information for my window (such as worth and height). The callback function has to have only a pointer to my window object inside my struct as well as two ints to hold the new width and height. so I was hoping by getting the address of the pointer I'd get to add 2 to it and that would land me on the address of my struct's width and height which I could then modify from within the struct. Don't get me wrong I fully understand that I'm a horrible person for doing this and it should never be done but it seems like fastest solution.
can you not take the address of `a` as such `&amp;a` and that would have you end up at the location of where the struct is?
Nope. `a` is copied when passed to your function. If you take the address, you get the address of that copy.
Does the struct contain the window struct or merely a pointer to it? In the first case, what you want is possible, in the second case, it is not.
Nested conditionals, mayne
WOW!!! Thank you sincerely for looking at the parser code, I was not aware of overlong sequences until today. I will create a new Github issue and implement the checks as soon as I have the time.
this is the struct I'm working with typedef struct windowStruct{ GLFWwindow *window; GLFWmonitor *monitor; int width, height; char *title; uint8_t aaSamples; uint8_t display; } windowStruct; and the callback function is `windowResize(GLFWwindow *window, int newWidth, int newHeight)` and for the `window` argument I'm just given the `window` member of the struct.
that makes sense I guess. However yesterday I did try to just print the value by adding to the address and it seemed to work but I assume that's undefined behavior and isn't a reliable way to do things.
Yeah, that's not going to work. Consider placing your `struct windowStruct` into a global variable so you can modify it from your callback.
Indeed.
Well... sometimes it's a matter of personal preference :) Your point that C++ would help to avoid code duplication with no performance penalty is valid; modern C++ compilers are indeed quite smart. Also, RAII is an appealing concept. I'm not using 3rd party code for the parser and the strings simply because I didn't find anything that matched my requirements. It could exist, I'm just not aware of it. For example, I needed an extensible parser that can read UTF-8 and output UTF-16. It also needed to be performant, because the code is executed while Notepad++ is launching. Also, all the strings in the plugin are encoded in Windows' native null-terminated UTF-16 format. I couldn't find a library for the proper management of such strings. 
yeah that's what I have so far, I was hoping I could do it that way to not deal with public variables. oh well, what can you do.
No problem, thank *you* for stopping by. This is a really nice C community.
They didn't disallow recursion... I was thinking that would be a nice addition to the answer.
Who invokes your callback? Perhaps you can change the code such that you can pass an extra argument to your callback function.
01 makes me think it's a printf error... and to not loop, just do what the compiler does, directly. make a big ass list of array accesses manually, though that's a retarded requirement.
Honestly, I don't use unit testing... Whenever I make a change, I just manually mentally retest the output with 0, 1, and whatever the max is. and negative if it's signed. :/ Can anyone explain what unit testing actually is? how does it work? do you just write a function that verifies another functions output? and what about simple functions that are mathematically correct, like a slightly fancier mod one? do you test those, or just assume the compiler won't fuck it up and that since the math is sound it will always be correct and won't need testing?
Why not just pass in a pointer to the struct? that's how all my code works...
It just takes double the CPU cycles to access them. Just like those bigint libraries that provide 128 bit ints.
I haven't read your code, but 99% of the time you get a segmentation fault, it's because a pointer wasn't allocated.
Fuck if I know. I feel like it's an OS abstraction like fread, where the OS goes and gets X pages of memory for you, but idk.
glfw, you set the callback function as such `glfwSetWindowSizeCallback(window, window_size_callback)` where `window` is a pointer to the window that will be passed to your callback and `window_size_callback` is your function whcih glfw will call with 3 arguments, those being the pointer to the window (the argument you gave to `glfwSetWindowSizeCallback`) and two ints, the new width and the new height of the window.
I explained above, but basically it's because the function is a call back function that glfw calls, I can't control what it puts in.
LOL. Disallow loops but allow recursion? I like it.
Do you allocate the `GLFWwindow` structure yourself? If you do, there are some tricks you can do. For example, you can change your `windowStruct` like this: typedef struct windowStruct{ GLFWwindow window; GLFWmonitor *monitor; int width, height; char *title; uint8_t aaSamples; uint8_t display; } windowStruct; (note how `window` is no longer a pointer) and then simply cast the pointer you receive in your callback to a pointer to `struct windowStruct`.
Please spare us from these.
Glfw being opengl?
You doing it old school? Trick with triangles is to break them into two. Raster down line by line, until you get the knee, then change the vector on the side of the knee. http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html You not really framed the question in a way that helps. No API or platform given. Cario is a good C 2D graphics API. But you have started already by the sounds of it.
yup
that might work actually, I'll just have to rewrite a whole bunch of stuff. I'll try it out and hopefully it works.
i like the header-only approach. It really simplifies the dependencies for a project - no libraries to download/complile/apt-get. Thanks - i'm might give it a try.
Why would you want to do this thing
&gt; Can anyone explain what unit testing actually is? how does it work? do you just write a function that verifies another functions output? In effect, this is correct. You have a function (or module/class) and you write code to test (usually) the public interfaces. The real benefit is for maintainability....if you re-work some code, your tests verify that the operation is as before. Example : you have a C function that returns the first 'n' primes. You write a test that calls it, and verifies the returned values. At some later stage, you rewrite the code (eg, chnage to a "faster" or "better" algorithm for finding primes). Running your tests will verify you haven't broken anything. The premise underlying unit testing is that you usually spend longer maintaining/changing/tweaking code than you do initially writing it, and this is "paying forward" to reduce your maitenance overhead. It really works if you do a big refactor and all your test pass first time....it's a real high point of your day :-)
Seconded. There is no reason this code is necessary. Additionally, the styling of the blog page and the lack of any real content of substance on your blog would make me not want to trust your code. Your code has no comments, no real purpose, is not a project or code review question, and doesn't spark and discussion. This just looks like spam to me.
Use glfwSetWindowUserPointer to save a pointer to your struct and glfwGetWindowUserPointer to retrive your pointer inside the callback.
And I suppose the `struct GLFWwindow` is opaque and doesn't offer an extra member like a `void *user_ptr`? Fuck, libraries with this kind of things drives me nuts: callback functions with no extra `void *` parameter for the user, fixed structures with no extra `void *` member for the user. As soon as you want to embed extra info, extra processing which is not limited to the only case the original programmer thought of, you're fucked or have to resort to more or less dirty tricks. Yes, `ftw()`, I am looking at you (amongst many others). EDIT: Ah, so in fact there is a user pointer :-) https://www.reddit.com/r/C_Programming/comments/6zjuso/change_values_of_struct_members_given_only_a/dmx2ee0/
this is the right answer. Thank you.
How do you verify that the checker knows the correct results tho? Serious question.
this gives you an incomplete type error. /u/biolunar got the right answer on this one
No blog spam please.
No blog spam please.
lol yeah, he got the right answer on that one, didn't know that function even existed, but to be fair they didn't have those functions until version 3.
If the `GLFWwindow` structure happens to end with a flexible array member and you try to use this trick, you are screwed, are you not?
Yes.
So my rant is just outdated :-)
Your checker code knows what to expect....you write it that way. Maybe an example....this is a function to...well, you get the idea int add(int a, int b){ return a + b; } One unit test for this would be: int result = add(5, 3); assert_true(result == 8); result = add(0,0); assert(result == 0); That's your unit test. Ideally, you test for edge cases, like negatve numbers, etc. It gets trickier if your function takes pointers to structs and so on, because you need to "mock" valid structs member values such that the code being tested, works sufficiently well to get an answer out. I think it's safe to say that you need to think about unit testing as you write your code, so you can organise your interfaces/functions to make testing easier. It's obviously easier to test small functions than test very large functions. 
Just to clear something up for you, the "w" part means "warning" this is "warning int conversion".
Is there a difference between using assert and just checking for equality? Where did you learn about this stuff btw? I could obviously use some reading up on it.
Man, encodings are dumb.
Imo as long as you only use goto to go downwards in the function its perfectly fine to use. With that restriction its difficult to get into spaghetti code situations that goto is notorious for. 
The error message will usually say what line the error occurred on, so look at that line, see what variable is being returned, and see if that variable is declared as the same type as the function return value. That should be enough to get started investigating the problem.
OK, I googled and found this page of documentation: http://www.glfw.org/docs/latest/window_guide.html#window_userptr In particular, this pair of functions: glfwSetWindowUserPointer() and glfwGetWindowUserPointer() So, store a pointer to your windowStruct object with glfwSetWindowUserPointer(). Now your callback looks like: void windowResize(GLFWwindow *window, int newWidth, int newHeight) { windowStruct *ws = glfwGetWindowUserPointer(window); // now go ahead and modify your windowStruct } This is the way you're supposed to do it.
In general, most systems that work through callbacks will either allow you to attach extra information to the objects like this, or they allow extra data to be passed along to the callbacks, or both.
System("pause");
Firstly it's completely ok do do this. People telling you not to have not written real C imo. See linux kernel etc. the thing that you're trying to do is pretty common. Secondly use offsetof macro.
oh fuck you're right I completely forgot about that, the problem is solve now so it's ok, but I'll keep it in mind for next time.
Your code got caught in our spam filter, I apologize for the inconvenience. Yes, you need to put four blanks in front of every single line of code. That includes `#include` lines. There is no other way. Three backticks don't work here. Al
Your post got caught in our spam filter. I apologize for the inconvenience.
Your post got caught in our spam filter. I apologize for the inconvenience. To receive help, you should be more specific about your problem. ‚Äúvscode never runs‚Äù is not an error description. Explain exactly what you did and exactly what happened. Only then it is possible to tell what the problem is.
Which OS? Which compiler? What do you expect to happpen?
Thank you for teaching me the C language.
Well, you just need to stop writing when you get the 10^th ~~value~~ end-of-line. while ((bytes_read = read(fd, buf, BUF_SIZE)) &gt; 0 ) { for (int i =0; i &lt; bytes_read; ++i) { if (buf[i] == '\n') { n += 1; /* here we just insert a test to check if n reached max_n */ if(n==10) { // 10 is default but you can use another value, or get it from command line write(1,buf,i+1); exit(0); } } That's for the default version. For a 'complete' version, you need to decide, according to the number of command line arguments, if you use the default value or if you need to parse an extra argument `argc==2` -&gt; `max_n=10` (default value) ; `filename=argv[1]` `argc==3` -&gt; parse `argv[1]` to extract `max_n` ; `filename=argv[2]`. Hope this helps.
Have you installed `Code Runner` plugin?
It is a catch-all, or what? :-)
It sure has been behaving strangely recently.
yes i did .and TDM gcc compiler too
&gt; Is there a difference between using assert and just checking for equality? "assert" is an easy to have the test exit if the condition is true. Different unit test frameworks have different versions of assert, but they usually only log the test result for later reporting (ie, don't terminate the test run), but they all ultimately log the test name and result (pass/fail). In a large application, you could have thousands of tests so having some test report at the end is vital. &gt;Where did you learn about this stuff btw? Started using junit back in the early 2000's for Java, but didn't really buy into it. Most recently, have been using nunit for C# development, and have really bought into it. I don't write code without making sure it's testable and tested. 
What's wrong with using the command line? VSCode is not an IDE. Use Visual Studio if that's what you expect
Digital signal processing
It does, thank you. When it comes to getting the number of lines to print, what I have done is this: int numLines = atoi(argv[1]); Which I can then use that number to determine how many lines to print. The program works fine now (thank you), but I now have two more problems; atoi doesn't allow for chars and ints (for example the professor wants the argument to be "-5" to specify number of lines not just "5", so could I use maybe sscanf instead? But then there is the issue that these are both section 3 functions. I haven't asked yet if I am allowed to use these to parse the command line. Is there a way to do so without using section 3? For now I have left it with atoi() since that is the easiest way to do it. 
There is no method that works on all platforms. If you write your code such that it uses all cores on the system, you might be doing it wrong. Consider providing a `-j` option for the user to set the number of threads or evaluate the `NPROC` environment variable.
I think the private aspect you describe is pretty completely accomplished with static functions, but I do agree that namespaces would be nice. As far as what I think C is missing, I would have to say generic programming features. C++'s STL is a headache a lot of the time, but generic containers are really nice. I can't count the number of time's I've had to use macros to fake generics, and C11's `_generic` keyword doesn't solve the problem in any useful way.
Agreed...generics would be nice alright.
`libuv` has a function called something like `uv_get_cpu_info`. You could take a look in the source code to see how that's implemented.
I'm doing data-crunching and I wants to get it done as fast as possible without more threats then there are cores. Logical cores anyways.
I think generics would be nice, but it wouldn't be my first choice. There are refactoring strategies to get the functionality in my opinion. Private and public can be handled with naming convention, but in the same vein of Namespace, I'd say packaging. A bigger topic, but one marred with many different standards. If you look at what is becoming of the Jai programming language, out of all the features I think a Compile time function being the same language/syntax as runtime is possible the best feature. Macros in c is a different language and disjointed from the runtime language, hence we get automake, cmake, and all the others. Between the internal macros, external build tools there is a lot of complexity for packaging. D also has moved in this direction. But being able to pull in a library, and not have to untangle the build system and macros would save a lot of friction. For instance if I could #import io = stdio.printf io.printf (); except more complex packages that don't need to be integrated into the complex build system. Along with versioning namespace, and dependencies. #import io = stdio(Version 1,01).printf; That's just my opinion of course.
I've been following some of the stuff with Jai. It looks like it's going to be a really nice language for low level programming. Like what C++ could have been.
function overloading
You could probably push the number of thread if some of the threads are stalled by I/O, or waiting for a shared resource (in which case more thread would not help )
There aren't any shared resources there is just going to be one big set of read-only resources that's going to be divided up among the threads.
what about the output ?
Either hard code it in if you're running a single implementation, or give a command line argument to allow the user to set it. I use -t for threads or --threads=x and that works fine. 
I actually don't want function overloading in C. I think in some languages function overloading is a great tool, but in a data-oriented language like C the explicitness of function signature seems more in line with the "C mentality". Same goes for operator overloading.
Can also be hacked in with void *s and some way to mark the type (like an enum). Did this in college as a proof of concept (polymorphism in C). It was quickly scrapped.
Different files.
So what is a core going to do while it's waiting for the hard drive/memory to write the data?
Don't think about it that way. Put each block on a separate thread logically, and it'll auto use as many cores as it needs.
I'm torn on operator overloading. I would be fine if the arithmetic and equality operators could be overloaded. Mathy types like matrices/vectors, complex numbers, Laplace expressions... the code for all of these could be vastly simplified with a few operators instead of add_mat(mult_mat(mat_A, mat_x), mat_B).
... which only works in Windows. Better use something like `getchar` i.e. printf("Press a key to end this program..."); getchar(); return 0;
This can be acomplished somewhat with gccs `#pragma weak`. You can't overload functions with a different signature, though...
That might not be a good idea either, context switches aren't free.
&gt; If you write your code such that it uses all cores on the system, you might be doing it wrong Nope. In-fact he's doing something right that more people must be doing what he's doing...making your code core aware. Not only will it lead to intel to stop looting us by providing substandard core counts but it will also help amd who now has more cores at lesser cost.
If your program uses as many threads as there are cores, catastrophic things happen when you run it on something like our university's shell server with 120 cores (not supposed to be used by one person at the same time). That's why such a program should really be written to at least support evaluating `NPROC` or receiving the number of cores to use as an argument. Ideally, just running on all cores should be available as an option but not as the default.
Your post got caught in our spam filter. I apologize for the inconvenience.
&gt; catastrophic things happen when you run it Bad things will still happen if you just use 20% of cores with the same code because the code itself is faulty because it probably has very high lock contention that is the root cause of the issue. Unless the code isn't churning cpu for encryption/de/compression etc. you can safely use all core for all applications if you don't have insane contention and have proper locking hierarchies. Per-core/Per-Thread data structures to reduce contention are also recommended. This is now a standard practice in properly written code. Eg. memory locators rarely take locks these days by maintaining per thread states. Also if your code heavily uses spinlocks, tweaking /proc/sys/kernel/sched_* is also recommended. So proper code can use all cores give fastest responsiveness possible and not slow down the machine. 
I don't understand what you're asking. What does the address of a function have to do with stack smashing protection? They're completely unrelated things. The `-fstack-protector` feature adds a stack canary that can detect if a buffer is overflowed. That has nothing to do with address space layout randomization, and would not have any effect on the addresses of functions, because functions do not live on the stack. If you want that you need to enable position-independent code generation and indicate to the linker that you want a position-independent executable; with gcc on a unix platform that can be done with `-fPIE` when compiling and `-pie` when linking, respectively. 
Add me as another one who thinks determining the number of threads to spawn programmatically is a bad idea. There are some cases where you'll get optimal performance where numthreads=numcores, but that's not common, and it'll vary a lot of from system to system. You might find that in a system with an SSD you'll get optimal performance from N+2 threads and then if you swap out the SSD for an HDD, suddenly you get optimal performance from N+4 threads, for instance. I really think it's best to just let the user specify.
Try 'sysctl'. It's in the standard C library. The doc: man 3 sysctl. 
&gt; @ 100 ms. service. This introduces a paragraph containing the text ‚Äú100 ms. service.‚Äù &gt; @&lt;100 ms. service@&gt;=+ This adds the code below it to the snippet named ‚Äú&lt;100 ms. service@&gt;‚Äù You need to search through the program to find where the rest of this snippet is defined and used. This does not make the code below execute every 100 ms on its own, but it is possible that the author programmed it this way. I recommend you to read the CWEB documentation. On a system with texlive, type `texdoc cwebman` to retrieve it. CWEB is a preprocessor for C and you need to understand what it does to work efficiently with it. Preprocess the source like this: ctangle web.w This generates `web.c` from `web.w`. You can feed `web.c` to your C compiler. Then generate TeX documentation like this: cweave web.w This generates `web.tex` which you can feed to `pdftex` (not `pdflatex`) to generate a PDF.
You don't need `atoi()` or `sscanf()` or anything. First, see if `argv[1]` starts with a hyphen. If it does, the rest of the string are the digits that make up the line count. Just iterate over them, multiply by 10 and add. If not, it's a file name and you use the default line count of 10. For extra credit, move the `open()`, loop, `close()` into a separate function which you call once for every element in `argv` so you can process multiple files with a single command.
Then have the user pass a thread count on the command line, or in a configuration file, or in an environment variable. There is no reliable way to detect the number of cores, and even if there was, you can't just blithely start one thread per core. For one, there might be other jobs running. For another, you might actually get better performance with more threads than cores, especially if your threads occasionally do I/O.
On FreeBSD and macOS it's `sysctl hw.ncpu` but no such `sysctl` call exists on Linux. This approach is not portable and thus fails to meet OPs demands.
So i tried searching through the program to find where it is defined and used, but I cant seem to find it. I'll keep searching and read some of the CWEB documentation. 
It's Linux that fails again.
It is possible that this is the only definition of ‚Äú100 ms. service.‚Äù Note that in usage and all but the first definitions (i.e. in all definitions that end with `=+`), snippet names may be abbreviation. If you use `cweave` to generate a PDB, `cweave` should generate an index of all snippets cross referencing the section numbers where the snippets are used.
No. It's just not a portable interface. macOS copied this interface from FreeBSD so it's the same. But every other system has a different interface for this purpose.
If this was a Linux sub, they would claim it's a FreeBSD failing.
It's way too late now, but a built-in string type would have saved a great deal of pain had it been available from the beginning.
It's not really anybody's failing. Rather, the Austin group (authors of POSIX) should standardize an interface for this purpose.
Yes a built-in string type and a little better string support in standard library would have prevented so many bugs.
Your post got caught in our spam filter. I apologize for the inconvenience. :)
I reformatted it for readability: static void stream_update_dep_set_rest(nghttp2_stream *stream) { nghttp2_stream *si; if (stream == NULL) { return; } DEBUGF(AtlTrace("stream: stream=%d is rest\n", stream-&gt;stream_id)); if (stream-&gt;dpri == NGHTTP2_STREAM_DPRI_REST) { return; } if (stream-&gt;dpri == NGHTTP2_STREAM_DPRI_TOP) { stream-&gt;dpri = NGHTTP2_STREAM_DPRI_REST; return; } for (si = stream-&gt;dep_next; si; si = si-&gt;sib_next) { stream_update_dep_set_rest(si); } } Probably the very first `if` statement, where it checks if the given `stream` argument equals `NULL`. It looks like the struct is a linked list of `nghttp2_stream` structs. In the for loop it iterates over this list (see the `si = si-&gt;sib_next`). `si` will be passed to the recursive function call, and it may be NULL. That's when it returns.
I'm a little worried that it looks like it will be coupled with llvm. 
C11 isn't really that portable. Hell mvsc still doesn't support it fully iirc.
I agree that operator overloading would be great in some contexts, but the ambiguity of it would make it a bad choice for C. In C++ and other higher level languages it makes more sense.
I have a couple of libraries I use fake generics for and there always seems to be a tradeoff. With macros you run into double evaluation everywhere and with void* you get cache misses and casting everywhere. It's just annoying enough to make me frustrated.
I've heard a lot of things, but most of the responses are people telling me to have a command line argument specifying how many cores to use. Thanks for the help guys.
&gt; macOS copied this interface from FreeBSD They copied 90% of the kernel from FreeBSD.
Just exit I suppose. There is a loop that calls fprintf and the last function call before pthread_exit is fclose.
What do you have so far? In what way doesn't it work?
Multiple variable returns. And the ability for the compiler to tell you the target's byte and bit order.
We have generics... They even work in MSVC
Saner type rules / syntax: * No decay rules - array values are just as legal as struct values * Ptr syntax (asterisk) is post-fix - so that you can pass ptrs-to-arrays to functions easily. * As a consequence, function pointers must be dereferences -- these indirect calls? Make me see the indirection. This would have the nice side effect that people would suddenly be able to read C type declarations.
You need to show a good faith attempt at solving your problem before this sub will assist you
Umm you mean the optional stuff like threads and annex k aren't portable? Everything else seems to be supported well. even _Generic is supported in MSVC17
I think someone is asking Reddit to do their homework for them.
You mean `sysconf`, as in `sysconf(_SC_NPROCESSORS_ONLN)`
For Unix-likes (Linux, BSD, macOS, etc.), this tells you how many cores are currently online: return sysconf(_SC_NPROCESSORS_ONLN); For Linux specifically, this tells you how many cores your process is allowed to run on cpu_set_t cpuset; sched_getaffinity(0, sizeof(cpuset), &amp;cpuset); return CPU_COUNT(&amp;cpuset); For Windows: SYSTEM_INFO sysinfo; GetSystemInfo(&amp;sysinfo); return sysinfo.dwNumberOfProcessors;
And to get the numerical value of a character digit: `num_val=digitchar-'0';`, because all(?) character encodings guarantee that `'0'` is followed by `'1'`, which is followed by `'2'`, and so on up to `'9'`.
1. Why? 1. On what OS? 1. With which graphics library? 1. What's the output format (.bmp, .png, etc.)? You haven't given us a lot to work with
You're going to need to be more specific here.
1. It's an assignment. 2. I'm running turbo c on win10 x64 3. #include&lt;graphics.h&gt; Other library I'm usikg: #include&lt;dos.h&gt; #include&lt;stdlib.h&gt; etc. 4. Actually the idea is to make a level like Mario or Flappy Bird, where the background is in motion and the character stays in a fixed position. It's just a class project. 
Namespaces, generics, classes, RAII, and function overloading Wait...
so theres a couple ways to do it. one is to use sprites. its a tad more complicated but allows more complex designs and faster render time OR if you know how to draw rectangles. you create a function that draws the rectangles required to create your character. thats how we did things in the early parts of my class where we learned c via coding for the gba using vba
So basically saying I can create triangles and use the functions to do the trick, I'll give it a go and get back to you. Thankyou. Let me see if I can pull this thing 
Turbo C? As in the early 90's DOS compiler from Borland? For the love of whatever you consider holy, why? 
As the comrades say, what you ask is very diffuse. but if it serves you, in c and with ncurses, https://github.com/nasciiboy/ncurses/tree/master/mario-c g++ -o mario mario.c -lncurses test on your terminal emulator and if it goes wrong, on a tty
I can think of one instance where I used a `goto` to jump backwards in a function. The function started with a `for` loop to grab audio packets and copy them into a buffer. Then it tries to write the buffer to the audio device. If there's an error, after recovering the device buffer may be emptier than we expect, and I needed to copy additional packets into the buffer to write to the device in one shot. I used a `goto` to jump backwards into the inside of the `for` loop, without reinitializing its variables (so filling the buffer would resume where it left off). (Something like that, anyway. The details are fuzzy, but that's the gist of it.) There's probably a way to do it with an outer loop, but in the course of piecing it together, a backwards `goto` was what seemed easiest at the time.
Im pretty sure the main version jonthan is working on doesnt need llvm.
I've been following it for a little. I know he originally had a c++ backend. I don't know which was implemented first x64 or llvm. Thinking back it would make sense to not use llvm if his goal is to have extremely fast compile times.
Depending on what you're doing, that might not work out too well. Like, if I have 50 thousand files to process, I don't think the OS would like needing to handle 50 thousand different threads.
Oh yeah! I totally forgot about this `sysconf`.
Arrays that don't decay to pointers and always keep track of their length even after being passed to a function.
Haha, welcome to modern CS education. I had to write WASM syntax assembly for DOS in 2017. Or rather, the course notes were written for DOS, but we were expected to use the win32 API.
From https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html#Instrumentation-Options &gt; Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call alloca, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits. I'm guessing you have this confused with ASLR? To get ASLR to work with executables, you need to build them position independently, i.e. with the `-pie` flag.
Thanks. I looked up about PIE and that explains it
SDL is primarily for games and graphics programming, but the library has a number of other nifty features you can make use of for cross-platform programming. Including a function to tell you the number of logical cores present on the current machine: https://wiki.libsdl.org/SDL_GetCPUCount If you can't or don't want to add SDL as a dependency (I know you said you're already focused on pthreads), the project is open sourced under the zlib license, so you may be able to pick out some relevant code from their solution and appropriate it for your own project without licensing worries. I'm no lawyer though - so double check the terms before you decide to do so. http://hg.libsdl.org/SDL/file/d4f87399777f/src/cpuinfo/SDL_cpuinfo.c#l406
VSCode's [documentation](https://code.visualstudio.com/docs/languages/cpp) on C/C++ development explains the process adequately enough, but I really wasn't too impressed with it for C development. You'll ultimately need to define a task for compiling in Code's tasks.json file that instructs it how to run clang, gcc, whatever. Read their instructions thoroughly and follow them closely and you should wind up with a working setup. It's important to understand that VS Code won't do anything for you, or save you from learning how to use the command line. You still need to describe to it exactly what command line arguments need to be run for your code to compile. If you're looking for a "hit the play button and the code compiles" experience, I'd recommend Visual Studio (not VSCode) on Windows, or Xcode on Mac. Nevertheless, you'll still need to learn how to compile something on the command line sooner or later. There will almost certainly come a time when you won't be able to avoid it.
thank you so much sir.I understood üòá
If the data in the file can't be interpreted as a double then scanf will fail (return less than 3)
Thanks! It is fixed now. But the question is still unanswered!
The
Not sure exactly what you‚Äôre asking, but you could try using `fgets` to snarf an entire line at once, skip the first batch of non-whitespace characters, and see what `strtod` gives you.
c++ enum classes. I use c for microcontrollers, and I use enum to enumerate sensors registers, c++ enum classes might be useful for making sure I'm reading an existent/valid sensor register.
Yeah i'm actually working on that problem myself (but upwards of a million, with a common average being about 120,000)...
Can it also technically be done via library link order, not that that's straight forward.
That was fun. I'm looking forward to seeing it in Haskell.
I found that's something you also need to think about when using `weak`. The whole thing is a rickety mess, really. Don't recommend using it if you have a choice. 
This has nothing to do with C.
But... according to recruiters, that's the same thing ;-)
Ahh, the mythical C/C++ language. I've heard it mentioned a few times, but never seen it in the wild. The closest I've been to it, is the excrement trails it leaves behind: strbuf = (char *) malloc(1024); 
This subreddit is about C only. Please post C++ content elsewhere, e.g. in /r/cpp.
If you need to know the byte order, you are most likely doing it wrong. I have no idea what you even want to know the bit order for (whatever that is).
A proper module system would be terrible because it kills the ability to use C in projects that don't confirm to the structure imposed by the module system. This also makes refactoring code a real pain in the ass because you can no longer simply move functions from one file to the other as that would change what module they are in. I'm very happy with C's lack of a ‚Äúproper‚Äù module system. It's one of the things that makes the language so versatile.
Note that function pointers are actually the other way round: the left operand to the `()` (function call) operator needs to be a pointer to a function. The compiler silently takes the address when you call an identifier of function type. This is in line with how a function call is compiled, after all, the `call` instruction (or whatever your machine uses for function calls) receives the address of the function you call, not the content of the memory at that address.
No, please not. That's such a pain to program against because you have to fill in dummy length values everywhere.
How about using a bunch of assertions instead? I really don't want a feature that forbids me from passing certain values to a function. A warning is fine, but if the compiler refuses to accept my code because I want to use an undocumented register (and thus, pass a number for which no enumeration constant exists), I'm going to use a different language.
Very interesting! I am excited about the functional version next.
That's C++ not C. You have an [illegally] declared array with 5 elements - numbered 0 to 4. But you're reading into elements 1 to 5. And when you're printing it, you using the uninitialised `i3` every time. You could really do with some consistency. You index your array 3 times, each time differently while (l-1&lt;s) for(int i=0; i&lt;=4; i++) for(int i=0; i&lt;5; i++)
This is c++, and thus not suited for this subreddit. Your post has been removed
Down the rabbit hole we gooo^o^o^o
This subreddit is about programming in C. Please post C++ content elsewhere, e.g. on /r/cpp.
Set a hard limit of 4096 or something, then spawn those? Low enough to be handled fine, high enough to be higher than any reasonable amount of CPU's?
Some time ago I asked how to assert if a certain enum is valid, but I find enum classes a to be an easier way to do it. How can I assert valid enum values at compile time in C? Enumerating the valid registers only might be a security feature (not writing to a read-only register for example, some sensors don't care about it, others leave the sensor in a unknown state).
&gt; How can I assert valid enum values at compile time in C? You can use `_Static_assert`. &gt; Enumerating the valid registers only might be a security feature (not writing to a read-only register for example, some sensors don't care about it, others leave the sensor in a unknown state). If you want to forbid people from doing something, C is not the right language for you.
What you're describing is a result of the decay in C. If it hadn't decayed, the rule could be made to make more sense - where () applies to function types, instead of function pointer types (which sometimes decay from functions).
No, I don't think so. The C rules make very much sense as they are written for the reasons I already explained. What you propose doesn't make any sense: A function object isn't a thing in C. Functions aren't objects. Functions can only be described indirectly by pointers to them. What exactly should happen if a function appears in an expression with your rules? The only sensible thing is for the address to be taken implicitly.
Call takes an address, just like variable access takes an address. Yet variables do not decay into ptrs. A function object isn't a thing, and array values aren't a thing -- but they *should be* for simplicity's sake and for consistency. &gt; What exactly should happen if a function appears in an expression with your rules? Nothing. If you call it - it's called. If you take its address, you get its address. If you try to do anything else with it (e.g: pass it as an argument) it causes a compilation failure. Just like in current C, if you try to declare a struct field of function type. It's syntactically possible, you just get a compiler error. Decaying to a pointer isn't very sensible, it's just an ad-hoc arbitrary rule. With arrays it's even worse. Decay there is downright confusing - to the point that many (most?) users of C don't understand the difference between arrays and pointers. It's also inconsistent, and less safe, consider: int f(int *arr_of_5) { .. } int x[5]; f(x); Which is what C users do now, because of array decay -- compared to what they would do under my changes. Assume the post-fix ptr syntax uses ^ like Pascal: int f(int arr_of_5^[5]) { .. } int x[5]; f(&amp;x); The type information that the passed array is of size 5 isn't lost. In C type information is thrown away every time an array value decays to a pointer to its first element. And the only good reason to do so - is that the syntax for dealing with ptrs-to-arrays in C is abysmal, and that's because ptr syntax is prefix instead of postfix.
Here, I'm passing you X, X.len can be read. Oh, I only want you to process N, well here's N too as a second argument. Now you can decide what to do. Under our current system, you always have to pass in N anyways. Say that I tell you my little character buffer has 100 elements, but for some reason I tell you to process 5000 elements, you can do a sanity check iff you want. 
It's not a pain at all in other languages that handle arrays sanely.
I'm not sure I see the conflict, The builtin module system would be uniform across all projects, thus making it easier to use different projects. The moving functions is a problem with the author. Even without a module system, if you write a single function that depends on a gazillion globals defined... you cannot currently simply copy and paste a single function. The good news for that is, it's really hard to use poorly written libraries.
Apologies for the code picture but I wanted to show how the printList() looked in my IDE. I'm wondering if this would break in some platforms or if it's just a problem with the IDE being able to find locally declared functions. Notice that printList() and printPointers() are also grayed out meaning the IDE can't see them being called anywhere ( they both are in other places ) The program compiles and runs fine 
Don't apologize, instead, just post your code as text, too.
Do you get warnings when compiling your code? Have you turned on all warnings?
Functions in functions is not valid C, it is a GCC extension, so CLion might get confused. Pass the pointer as a parameter/argument instead. 
I should have stated in the title that C seems to be THE most energy efficient language
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
I'm not talking about global variables (not sure where you get this from). The problem is that when you move a function from one module to another in a modular language, it's fully qualified name changes, breaking the API of your code. If you have a proper module system, you can't move the implementation of a function into a different module without changing the function name. However, when refactoring code this is very common to maintain compatibility. If your language only considers the ‚Äúdo it right in the first place‚Äù approach to software development, it's a shit language because that's not how the real world works. C is one of the few languages that do not enforce modularity, allowing you to choose a modularisation that suits your project. You can structure your code in an arbitrary way while satisfying an arbitrary interface. Languages that enforce modularity can't do this because you typically cannot declare symbols that aren't part of your own package. That sucks. 
Sounds like a question for your teacher.
Nope. Fuck hard limits. I've added a few options to my command line parser to take in the start and end points. Then for each thread i detect, i'll spawn a thread.
Well, I've asked and got nothing more than "don't cheat", so I assumed I could turn to this subreddit. I'll take your as a no, though. Thank you.
I'm writing an IO library dude... I kinda need to know those details, and it would be great if you guys could stop sharing generic advice as if i don't know what i'm doing.
I think we're in agreement, but the one case I see where this pops up is dealing with binary protocols -- whether it be for networking ("Network byte order" aka Big Endian"), talking to external hardware, etc. Knowing the byte order can at least tell you whether you have to swap bytes or not when packing/unpacking data. Even functions like `htons()` only have "real" implementations of the host is little-endian. On big-endian systems they just return their argument. This is not to say that you shouldn't *call* the functions anyway, but knowing the byte ordering allows trickery like above. Other than this though, I pretty much agree with you.
Really, what do you think is a ‚Äúbit order?‚Äù
If you need to ‚Äúswap bytes‚Äù you are doing it wrong. Instead, view the buffer you got from network as a stream of bytes and manually marshall that into an integer: val = buf[0] &lt;&lt; 0 | buf[1] &lt;&lt; 8 | buf[2] &lt;&lt; 16 | buf[3] &lt;&lt; 24; /* read little endian value */ val = buf[0] &lt;&lt; 24 | buf[1] &lt;&lt; 16 | buf[2] &lt;&lt; 8 | buf[3] &lt;&lt; 0; /* read big endian value */ This does the right thing on both little and bit-endian systems. No need to know the byte order of the platform plus you don't have issues with unaligned pointers.
So wait, how many threads do you spawn on average? Because if you're hitting 100% CPU usage (overall, not for a single core), you have enough, and any more is just going to make the OS's job harder.
I think I see what you're saying now. However, in the pseudo code I posted I think my example addressed that, and why I spoke about namespacing. #import io = stdio.printf; io.printf; so changing the module is 1 code change. #import io = newstdio.printf; io.printf; // hasn't changed the code calling convention Or is this still not the problem you are trying to identify?
If code that uses my library needs to change, then I just broke the API. For professional software development, it is extremely important that this never happens. If I have 1000 customers, I waste at least 1000 man hours, likely many more by having the edit their source code so it still compiles with the new name. That's unacceptable and often not possible, for example with open source software where you can't be exactly sure what version of the library you link against.
May be in C, #include &lt;stdio.h&gt; int main(void) { // your code goes here write(1, "our own code", 13); return 0; } 
On my system (linux, fedora), I have to call glutPostRedisplay(), otherwise it will only draw once. You can easily check by printf'ing something in the display function. I think it's a difference between freeglut and glut. But back to your main question. gluLookAt() doesn't put a camera in the scene, it simply creates a transformation and puts it in the current matrix. AFTER calling it, you can put your objects in the scene (in the usual way), and THEIR coordinates will be transformed. In your code, you create the viewing matrix after the coordinates of the objects were transformed, so nothing changes. One possible solution: //main glutIdleFunc(idle); void idle(void) { glutPostRedisplay(); } void display(void) { glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); static double t = -1.0; glLoadIdentity(); gluLookAt( t, t, -1.0, 0.0,0.0,0.0, 0.0,1.0,0.0 ); t += 0.001; if (t &gt; 1.0) t = -1.0; glPushMatrix(); glTranslated(-0.6,0,0); glColor3d(1,0,0); glutSolidSphere (0.1, 50, 36); glPopMatrix(); glPushMatrix(); glTranslated(0,-0.4,0); glColor3d(0,1,0); glutSolidSphere (0.1, 50, 36); glPopMatrix(); glPushMatrix(); glTranslated(0.6,0,0); glColor3d(0,0,1); glutSolidSphere (0.1, 50, 36); glPopMatrix(); glFlush (); } You can read more here: http://www.glprogramming.com/red/chapter03.html
Is it possible to post an embedded picture in a text post? I didn't think so
Yes all warnings are on and I don't get any when compiling
Thanks that's the answer I was looking for, I was just trying to reduce the verbosity since this is a test file and involves an awful lot of repeated calls to functions like these but I guess I'll go back to real functions. 
No it isn't, but you can post a comment.
Hm, weird. Perhaps you could give me the source code so I have a chance at finding out what is going on.
`isdigit` tests a single character, not an array of them
The source argument of strcpy should be a pointer, not a char.
The function takes a character. But as it's common to use `int` to represent a character, since that allows for an `EOF` value that is not equal to any valid `char` value, many functions dealing with characters take `int` and not `char`. You're passing an array that has decayed to a pointer. There is an implicit conversion from a pointer to an int, which is why it compiled. But you're invoking undefined behavior, because that pointer value is not a valid character, and the ctypes functions are usually implemented with lookup tables, causing it to access invalid memory when it tries to look up your not-character value in the table. Range checking is omitted for speed, which is why you get a crash; that's allowed, because you're invoking undefined behavior so all bets are off. 
...asm?
the context is higher level languages
No surprises that Go, Dart, Swift, and Rust are faster than Python, Javascript, C#, and C++! haha Late I will reserve time to learn both Rust and Go! 