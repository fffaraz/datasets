ok, about the strlen part, I'll try to fix it over the week. Thank you very much and hopefully I can fix it good, if not I'll come back with more questions =P Ok, you tested it with a xml, it probably has alot of spaces, that's what causes it, if you open the file there should be a bunch of weird characters there. I'll also try to fix it. If you test it with a single word or just write something without spaces it shouldn't cut anything. Altho it still woun't decrypt becuse of the strlen problem as you pointed out. Thank you very much so far and I hope I can fix it, if not, may I get back to you via pm? Anyway, you've been really helpful so far, thank you very much.
hi there, I'm learning C as well, enjoying it a lot while doing HarvardX CS50 free online course. Check it out you'll love it. 
One issue might be that you're missing the NULL sentinel at the end of your `execlp` function's argument list, and using the `execl` family will prevent you passing in an arbitrary argument list if you want to be able to pass anything into the command you're running. (E.g., `ls -lR`.) Furthermore, I'd note that if `execlp` returns *at all*, it failed. Don't do an `if` around it, just complain and exit. Either way, print out what `*strSatz` is before you try to `exec` it, and make sure what it's trying to run is properly terminated and in your `PATH`. Also, it's *very* rarely a good idea to `typedef` any pointer type that's not supposed to be entirely opaque, and that includes things like `typedef char *string`. Especially since "`string`", when it exists as a type, tends to refer to a higher-level structure with a length attached and not just a `char *`. (And it doesn't help that string literals have the type `char[]`, either.)
I am not entirely sure what you are trying to achieve, but I noticed a few things. First, use the "pipe()" command. This will create a pipe (pair of sockets, one for one child, another for another). Then fork() your children and "dup2()" the descriptors in the children down to the pipe sockets created with"pipe()", followed by closing the high pipes. This creates the connected reader/writers I think you are trying to set up. Second, when you compute"(k-1)*2" versus "2*k +1", do you really mean that? Your comments say "0, 2, 4" versus "1, 3, 5", but take k=1 for example. The two equations compute 0 and 3, not 0 and 1 like you intend it seems.
String literals have type const char*.
The answer to your q is yes. The x used in the square function (in mod2.c) is the same as the x that's declared in mod1.c and also the x used in doSquare. The reason x is declared in mod2.c is because mod1.c and mod2.c are compiled separately. When mod2.c is compiled it has no knowledge of mod1.c. In order to compile mod2.c the type of x needs to be known - i.e. that it's a double. Normally, x would be declared in a header file (mod1.h) and mod2.c would include that header file. Including the header accomplishes the same thing a declaring x in mod2.c, but in a preferable way. If you had a third file, mod3.c that used x, it would also include mod1.h. And, if you later decided to change the type of x (e.g. to float) you could simply change mod1.h instead of having to fix up declarations in mod2.c and mod3.c. As your intuition, correctly, tells you, it would be much clearer code if the square function took a parameter. The usual term for a variable like x is a "global variable" and their usage is generally discouraged for a variety of reasons. I'm assuming the point of this exercise is to just puzzle out what's going on as opposed to really designing code. 
The term I'd use is "declaring" as opposed to "initializing." Generally, initializing is more of a runtime thing, like assigning a value to a variable. Declaring is just providing information to the compiler. In this case the information is that x a variable of type double. The compiler uses this information to generate appropriate code - e.g. floating point instructions as opposed to integer instructions. &gt;So the extern double x at the top of mod2 - that's basically a promise, rather than anything of value... ? Like initialising a function at the top of main and then writing it out underneath...? Both cases are declarations, but I wouldn't say they're not of any "value." It's essential to correctly declare functions and variable before they're used. But, in contrast to definitions, you could say that declarations don't cause code to be generated - they're just information for the compiler.
#include &lt;'studio.h'&gt; int main(){ printf("hello"); return 1; } That should compile. 
Sorry for bold, I'm on mobile
This is an interesting idea! Im guessing you are planning on basically using a bittorrent style connection scheme, where you 'announce' to a server, and the server connects the peers, and all traffic flows directly to the peers?
Yeah that pretty much summarizes the idea. This is what I have: Tracker server: Would have a request system and an add server system. You can tell it to add a server, it would check every once in a while to make sure all the servers are still online and remove offline ones. Chat clients would request IPs by a "fetch" command. Sending chats: You send a message to all other chat "servers" to download. I don't know how to deal with what would happen if the user wasn't port forwarding, I don't know how that'd work. The clients could requests another servers chat level so if its ahead of the local server, the client could request an update on the chats. Receiving chats: Port forward the chat port and wait for messages to be sent to the server. It'd send its IP to the tracker server when it logs in. Getting old chats: Every time a chat is sent, it would increase the chatlog "level" by 1, so if you reconnected at a later time, you could download the chats you missed, or download all the chats if you've never connected.
could be done with irc, join a server/channel (tracker), dcc with who you want to... id assume there are loads of scripts for various clients to do the encryption..
Yes its true, but there are tonnes of resources to get info from. Anyway if you are serious about learning I'm happy to work with you and share ideas about cs50. I'm doing pset3 today. Cheers
Put it up on github? I'd contrib to this.
Here's a repo: https://github.com/liaml7/P2PChatbox I'm developing in Ubuntu, so someone might need to port this for other OS's... My code is really messy because I've mostly been copying other code and meshing, this is my first project.
*stdio.h
interesting, my style of notations is pretty inconsistent in this code(its just an exercise), but a former colleague made heavy use of Hungarian Notations in c# programming. Especially with a high level IDE it seems pretty redundant now (after reading through the disadvantages in the wiki page) variable names like ucsehUpdatedControlSelected didn't really help decipher the type, hovering just displays it ^^
You could first try to send out some kind of hello message to broadcast address and see who will/can connect. This is not p2p idea, but always worth considering users on local network.
holy, i don't know how to format this... it looks so unreadable :( 
wow thanks! edited with error description too
your strings are probably in read only memory and also not equal in length. cad_copiar leaves i at the strlen of s1 and then adds to it in the while loop.
got it, thanks everyone!
Yeah, this allows me for instance to almost look at code in a language I've never met and understand what it does. I wouldn't be able to write in that language *right there*, but I can pick up stuff fast.
Thanks. The point is it's not like I *can't* code, it's that I've never done anything worthwhile. I did a client-server based program when I was a teenager that allowed to control a remote machine. Of course, the code was embedded in a seemingly more useful program: a zip compressor/decompressor with a nice interface. I did some other things, but I didn't really stick to it and increase the difficulty (which is the most important part to evlove, aking to working out: you increase the load every time). For instance, now I'm doing MATLAB for automatic ECG analysis. I can do stuff, eventually. I'll eventually do it in another language after graduation, because it seems fun and Academia is locked down on itself, vulturing for h-index and all.. Oh well, rant over. For Crussian, I'd advise him to get involved with Open Source projects: If you don't have an idea on your own to code, get involved with an idea that seems interesting to you and offer your help. You'll learn how to write clean, safe code. You'll follow guidelines (For instance, check out the Linux Kernel Coding Style). And you are right: Read, read, read, read, read, code, code, code ! Exactly like literature: You read, and write, and read and write. Pick idioms, etc.. Thanks, man.
Also, you can't do this: char *str = "string"; str[0] = 'a'; The literal string `"string"` must not be modified. Rather, you'd want to do this: char str[] = "string"; str[0] = 'a'; Keep in mind, also, that `'\0'` is just another way of writing `0`. So you could do this: while (s1[i] != 0) i++; Or, since anything different than zero is acceptable as a "true" value, this: while (s1[i]) i++;
I thought that'd be cool to try but I didn't know how we'll it'd work. I guess there could be a main client that everyone would talk to to help find other clients. It would still be sort of ran with a tracker but not quite...
I started with the msp430 on the launchpad (which use the G series processors)and really enjoyed working with them. You can go higher end with the larger F series, and the ARM procs. I've only played around a little with the ARM based procs, but for the price, it's a nice intro. 
The `(void *)` is a cast. `phyRx_goodHeader_callback` has the signature: int phyRx_goodHeader_callback(Macframe* packet); ...which means a pointer to it has the type `int (*)(Macframe *)`. `warpmac_setCallback` has the signature: void warpmac_setCallback(int event, void(*handler)()); In other words, `warpmac_setCallback` is a function that returns void and takes an int and a pointer to a function that takes unspecified arguments and returns void. When you write the name of a function without the parens to call it, like `phyRx_goodHeader_callback`, it decays to a pointer to function. In this case it will have type `int (*)(Macframe *)`, i.e. a pointer to a function that returns int and takes a pointer to `Macframe`. That does not match the declared type of the second argument of the function's signature, so the cast was needed to make it work. `void *` is a kind of "anything goes" pointer type in C, which lets you fit a square peg in a round hole. This code is actually quite sloppy in the way that it's completely lax about getting function pointer types to match. The problem that they're facing is that the different callbacks have different signatures (i.e. they take various different kinds of arguments and return various things) but there's only the one `warpmac_setCallback()` function that handles all of them. The C standard says it's undefined behavior to call a function through a pointer that doesn't match the function's definition. In the receiving end, the function pointer is stored as: case EVENT_PHYGOODHEADER: usr_goodHeaderCallback = handler; break; where `usr_goodHeaderCallback` is declared as: int (*usr_goodHeaderCallback) (); and called as: if(~usr_goodHeaderCallback(rxPacket)){ warpphy_clearRxPktStatus(); } where `rxPacket` is Macframe* rxPacket; So in this example there is no undefined behavior, but it's awfully close to it, and using empty argument lists to denote unspecified arguments is really an anachronism of C that should not be used. Don't pick up any habits from this code, it's not a good example at all. 
Thank you very much for your excellent reply. It was very helpful.
| it could be that I don't have a main function defined You need to show some sample code, but you're mising some very basic steps here. Try what /u/xandout suggested
C# is heavily windows biased, where you would see Hungarian notation. C is not. Unrelated to your issue, [this](https://www.kernel.org/doc/Documentation/CodingStyle) is a good style guide for C 
Coming from a Unix/Linux standpoint, the two easiest ways for me to compile C on Windows is via MinGW or Cygwin (Cygwin has it's own version of gcc). Besides that, there is also Icc (Intel's C compiler - I've never used it). You might be able to find Clang for Windows, and there are also some other smaller compilers out there that may have Window's versions, Ex. Tcc, Pcc, etc.. You should keep in mind, while the compiler is important (Particular in the point of supporting standard C) a lot of what you'll have to worry about is also library support. The big difference between MinGW and Cygwin is that MinGW compiles natively against the normal Windows C runtime DLL's. So while it does has support for some extras, you don't get a full POSIX setup. Depending on what you need this may or may not be an issue. If you do need full POSIX support, then you should compile using gcc inside of Cygwin, which provides a POSIX environment for your program. The changes are you probably don't need to worry about POSIX at the time being, so MinGW is probably your best bet since you'll have an easier time using it.
I have found [Pelles C](http://www.smorgasbordet.com/pellesc/) to be a very good C only compiler for Windows. It comes with a nice simple IDE, full C99 support (plus some C11 (at least more than Microsoft Visual Studio)) and is a very lightweight.
genuine question, why do you say that about visual studio regarding C?
I've heard alot about it not supporting the latest c99 or something like that, also, I have to write the syntax a bit differently compared to what I do at uni or other compilers, instead of scanf("etc") its scanf_s("etc")
C is not a derivative of UNIX. It was created by the creators of UNIX so that they can write a new version of UNIX in a language that is more high-level than assembly. While the Windows kernel is also written in C, learning C on windows is painful because the C standard libraries on Windows are slightly off compared to the C standard libraries on POSIX-like systems, not to mention that the Win32 API is a clusterfuck compared to the POSIX API. I suggest either installing [Cygwin](http://www.cygwin.com/) or setting up an Ubuntu virtual machine in [VirtualBox](https://www.virtualbox.org/).
You can either set up a VM with linux, or if you like pain you can use Cygwin.
what kind of pain are we talking about when using Cygwin?
Soul crushing terror kind of pain
Well it's not the real deal. Some system calls like fork() are emulated using black magic. If you want to use extra libraries you can expect some problems on cygwin. On Linux you can just use the package manager and Bam! - everything is there and works.
Thanks for the response. In your opinion and when it comes to programming, do you think it is better to own a windows machine, or a linux machine?
Imagine the pain of trying to build a LEGO model with one eye closed while wearing boxing gloves and being in a swimming pool full of treacle. It's that sort of pain.
Not OP, but I agree with his answer. To follow up, I work on both Windows and Linux, and the environment I've settled on is precisely what he suggested--Windows as the host, with Linux running in a VirtualBox VM. I've tried the opposite, but Windows is a bit screwy in a VM, whereas Linux runs nearly flawlessly. A compiler option no one seems to have mentioned is the MinGW compiler suite, which you can install under Windows. It's more up to date and standard compliant than the Microsoft compiler, and usually easier to install than Cygwin. Regardless of my setup, I always install Cygwin in Windows, not necessarily for GCC (the compiler), but because it lets you use a lot of standard Unix / Linux shell commands on the Windows / DOS command line. The DOS shell is kind of worthless and crippled without it.
&gt; I've heard alot What does one sound like? I imagine it would be some low roar or bear-like sound from their appearance. 
Interesting assessment. Recently, I have thought to purchase a new windows machine, even though I currently own a mac. However, as I become more interested in programming, I think I might stick with the mac. It is a difficult decision. The primary motivator for me is actually learning how to program, rather than just learning a language and letting an IDE do all the rest. That seems to be something most seasoned programmers recommend, anyway.
You don't have to use the "secure" functions, read the warning for a hint about how to disable it.
The last time I tried to use fork() in Cygwin, it was ignored completely. So, YMMV
damn not treacle.
Don't. Retain your sanity and install [a linux distro](http://distrowatch.com/) (I'm a big fan of Fedora, personally).
Use virtual machines and you can have all 3, though to be legal you'd have to have a windows license. Generally most developers I know think Mac is just about as easy to learn to program on as Linux, especially if you use a mac package manager like homebrew or the like. You could also dual-boot your mac with Linux if you don't like virtual machines. You could even triple boot Linux, Mac, and Windows. Edit: Forgot to mention, the people who think mac is as easy are using Mac OS X.
Just keep using your Mac. You already have a shell and a Unix environment.
 This works too. while (scanf("%d", &amp;x) &amp;&amp; x != 0 ){
Linux. No contest. I better be paid damn well to program in Windows, because it makes programming so painful.
wow that analogy they use with the guitar is horrendous... I think the point (learning via text rather than IDE) is correct, just that example was rank
I wanna do the same on my gentoo system but then to test my codes id have to boot up the windows drive =/
Minigw all the way OP!
I code quite happily with Mingw (and MSYS when needed). I have native versions of most of the usefull *nix tools as well. So a few Scite and ConEmu instances and im golden :)
Cygwin user, can confirm. Initially thought that Cygwin would be slightly easier than getting things to play nice with my touchscreen, I was wrong. At this point in time I'm just waiting for a weekend to devote to getting something hacked together.
Clang. Unfortunately setting it up is quite hard, as, provided you don't have Visual Studio, you need to set up MinGW too, for the linker and the runtime, and I guarantee you won't get it to work in 15 minutes (number pulled from thin air). But the error messages are fantastic. Once you can get it to work.
I'll point you in the right direction, but first, this author is derogatory and insulting TO YOU, and biased. Everything about this is wrong or unnecessary. Fuck that asshole for suggesting an IDE makes you stupid. The tools are out there to make your life easier. Auto indentation, syntax highlighting, tab completion, project management, integrated revision control, integrated build management, and some sort of intellisense, if your tool has it, are all things you're going to need to do anyway, help you reduce errors, or do your job faster and easier; doing them manually, after you do it manually the first time for the educational experience, is a waste of your god damn time. It is important that you learn C and your tools, what is not important is going through a laborious, tedious, manual, and error prone exercise again and again. And again. Using a straight up text editor is outright insufficient, and no one in the professional world does it this way if they can absolutely help it. And since we're on the subject of learning C, you're obviously a complete beginner, which is in no way a bad thing, but the point is, the small nuances between platform implementations simply won't be relevant for some time in your education. And by the time you do get there, you'll know what you're doing such that it will be trivial. --- If you want a *nix environment on a Windows platform, install Virtual Box (it's free), download Ubuntu Linux or Linux Mint (these are just my preferences, you do what you want), and install it as a virtual machine through Virtual Box. You'll have a complete Linux OS running in a window on your desktop. You can do whatever you want, access the internet and such, fuck the whole thing up, and blow it away and start from scratch as you learn. You can even back the whole thing up real easily before you do something that might fuck it up. You can even easily share files and resources between the two environments. There's no disk partitioning necessary, and you can probably just poke around until you figure out how to get it going, I consider it that easy. Friends of mine with absolutely no IT or Linux experience have managed to figure it out on their own without documentation. I have hope for you. In the Windows world, you can download Visual Studio Express. It supports C++; I've no idea what sort of C support it has other than the backwards support inherent in C++. DJGPP is the GCC port for Windows, and its just shit. Two words: steaming-fucking pile. GCC - good. DJGPP - bad. Clang works on Windows, I believe. You can use whatever integrated environment you want with it. I like Code Blocks, but you can probably use Eclipse with it too, which is a bit heavier.
[tcc](http://bellard.org/tcc/) or [lcc](https://sites.google.com/site/lccretargetablecompiler/) should work until you get gcc running.
Getting Visual Studio and using it with clang should work. There's an experimental Windows installer that integrates clang with VS. Clang doesn't itself include a C library, but it does support the language up to the C11 spec. With VS integration it uses Visual Studio's implementation of the standard C library.
That will go into an infinite loop if you reach end-of-file
It's quite annoying to use for large projects though.
 #include &lt;stdio.h&gt; int main() { printf("hello world\n"); return 0; } Fixed for formatting and other things, don't confuse him more !
Virtualize, man. Works great.
&gt; Mac OS X is fully POSIX compliant OS X is fairly POSIX compliant, but it has not been approved as implementing some of the later standards.
If you're worried about dual-booting Ubuntu being difficult, it literally couldn't be easier. Put it on a flashdrive, boot from it, and it has a manager that partitions your drive and everything for you if I remember right. I did it at the beginning of the school year after trying to get Cygwin to work for a week and it was cake.
I think what the author is trying to distinguish between IDEs like Eclipse and text editors like Vim or Emacs. I do all of my work in tmux+vim but I would never use Notepad (or even Textmate or GEdit) for anything serious. I personally would rather use command line tools and Vim rather than a monolithic IDE simply due to the greater flexibility, programmability, and power I have over my development environment.
First figure out what each hex digit is in decimal ... ... A =&gt; 10 B =&gt; 11 C =&gt; 12 D =&gt; 13 E =&gt; 14 F =&gt; 15 Here's a hint. Each hex character represents a binary string of length 4. 0 =&gt; 0000 1 =&gt; 0001 2 =&gt; 0010 . . E =&gt; 1110 F =&gt; 1111 When you convert a hex string to binary, its very easy: A2DB =&gt; 1010 0010 1101 1011 because A =&gt; 1010 2 =&gt; 0010 D =&gt; 1101 B =&gt; 1011 Now that you know this, you can make a program to convert each hex digit to its binary equivalent and concatenate them together.
This is really nice! I like some of the node inspired stuff.
I had a feeling someone was going to say that. I think I might just say fuck it and whip up virtual box.
Making a simple chat program is always a good start. Once you have it working, make it multi user. Add support for channels, operators, etc. Essentially try and make IRC :D
Here's one idea I've had for a while but never found it necessary enough: A printf wrapper to print things in colors in an easier way. It would add new flag characters for colors and bold versions of it. Something like: prettyf("You have saved %Rbd dollars today\n", savings); where %R is bold, %b is blue and %d is the normal decimal. So the library would convert the above call to: printf("You have saved %s%s%d%s dollars today\n", BOLD, BLUE, savings, RESET); BOLD, BLUE, and RESET are defined like: #define BLUE "\x1b[34m" You get the point.
I like this as it allows you to keep adding more and more features. Cheers.
Awesome! This is something I'd like to try for practice. Thanks for the idea!
I should probably correct myself: works decent. Windows can be iffy virtualized, but it should be feasible for testing.
I'm trying to build a peer to peer chat system, if you're interested in helping me, feel free to message me. Reddit post [here](http://www.reddit.com/r/C_Programming/comments/21vskj/peertopeer_chat_clientserver/).
We don't have enough information to answer the question. What is your programming background? Do you know any other languages? How confident are you in your programming? How much time do you have to spend on the book a day? A week? EDIT: I see you said you have about an hour a day. Depending on your speed at picking up C, and your grasp of the language, it shouldn't take longer than a few weeks.
It should take longer if you do the problems, which I do highly suggest. The problems and examples are all very excellent
Just start it and go from there. It's a great book and worth going through. Second edition, right?
If you're interested, I'd start with a netcat clone. Get it to send stdin -&gt; socket, and read from socket -&gt; stdout. If that's good, it's actually quite simple to build a basic web server. &lt;500 lines for one that does quite a good job.
Second edition.
True enough. I just hate how I keep switching from one method (i.e., CS50x) to another. I need to pick something and stick to it. 
I'm a graduating senior studying computer science. Last semester I took an intense C course [(Advanced Programming in C and C++ (Spring 2014 course page))](http://www.cs.columbia.edu/~jae/3157/). The majority of the class focused on C, with the last few weeks introducing C++ concepts such as the built-in data structures and templating. The hardest project was writing a web server in C, and although you probably won't be doing anything like that, I recommend you dive into these books alongside K&amp;R: [Advanced Programming in the UNIX Environment, Third Edition](http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0321637739). Can be pricy, but you may be able to find this online if you know where to look. I recommend you have a hard copy as a reference manual though. [Learn C The Hard Way](http://c.learncodethehardway.org/book/). Say what you want about Zed Shaw, but I worked through this book alongside K&amp;R just before I started Advanced Programming and really liked the way he takes you through the C fundamentals. The book is free in HTML form, or you can opt to buy the eBook. Hope that helps!
True, C99 does make allowances, however it's undefined in C89. It's also UB in C++ including C++14. Using memcpy does the same thing and is not UB in either C or C++. It also results in performance at least as good as, if not better than, union based punning on modern compilers. Personally I also find it more readable. http://blog.regehr.org/archives/959 memcpy should be the recommending punning method. And in C++ one can define a handy bit_cast, the usage of which is even more readable. template&lt;typename Dst, typename Src&gt; inline Dst bit_cast(Src const &amp;src) { static_assert(sizeof(Src) == sizeof(Dst), "size of types must not match"); Dst d; std::memcpy(&amp;d, &amp;src, sizeof src); return d; } bit_cast&lt;int&gt;(1.f);
In case anyone else needs to look it up, like me, K&amp;R is short for: **The C Programming Language, by Kernighan and Ritchie**
Took me less than 2 weeks but some days I spent less than an hour and some I spent more.
If you want to try some more advanced stuff with sockets, try writing an implementation of ping(1) or traceroute(1). You'll learn a lot about how the IP protocoll works.
I'll second this, another quite fun idea that's relatively simple is to calculate TCP Header Checksums. You will get to do a bit of math and learn some interesting concepts of TCP headers. 
Thanks for the ideas guys, I knew you would have some good ones.
You can calculate the mod in every prime number, if it's 0, the mod number is one of the primes componing the initial number. I don't know if you can use lists or arrays, I don't know a lot of C.
Getting the prime factors if you already know how to test for primality is actually quite easy. ( You can just brute force.) So you should perhaps think a bit about it again. Otherwise I uploaded a somewhat simpler algorithm: http://pastebin.com/8Whbpm5C but you should try to understand why that one works. ( At least in my tests.) 
Before you do any coding, you at least need a conceptual idea of your algorithm. Ignoring the part of actually doing the factorization and depending on some other constraints on your input, you're probably going to have a function like this: int get_factors(int num, int factors[]); You send it an already made array of int's to store the factors in (And this array is large enough to fit all of the factors). The function returns the number of factors it found. This version uses less pointers and will be easier to write overall since it doesn't require allocating any memory, but it puts a constraint on the number of factors your allowed to have (If you just set this to be Ex. 1000 you're probably fine). You would use it like this: #define FACT_MAX 1000 int get_factors(int num, int factors[]) { /* ... code ... */ } int main() { int buf[1000]; int count; int num = 22500; count = get_factors(num, buf); for (int i = 0; i &lt; count; i++) printf("%d * ", buf[i]); return 0; } Something kinda like that. The above code doesn't follow your format completely but it comes close. The only complicated part is figuring out how to do the factorization. You need two things for this, the definition of a prime number, and the definition of a prime factor. A prime number is a number who's only divisors are 1 and itself (By divisor, this means divides cleanly with a remainder of zero). A prime factor of a number can be defined as a prime number which divides cleanly into that number. (By these definitions, it also follows that no prime numbers have prime factors since no prime numbers besides itself divide cleanly into it). With that, all you need is to know what the prime factorization is. We'll be defining this in recursive terms, but the solution doesn't actually have to be recursive. The prime factorization of a number is a prime factor of that number plus the prime factors of the number left over. It'll be easier to see this by example. So take 22500: 22500: Through looping and use of %, we can find that 2 divides cleanly (22500 % 2 == 0). 2 is also a prime number. Therefore, 2 is a prime factor. Add 2 to our list of factors. The result number of 22500 / 2 is 11250. Now find the prime factorization of 11250 11250: Through looping and use of %, we can find that 2 divides cleanly (22500 % 2 == 0). 2 is also a prime number Therefore, 2 is a prime factor. Add 2 to our list of factors. The result number of 11250 / 2 is 5625. Now find the prime factorization of 5625 5625: Through looping and use of %, we can find that 3 divides cleanly (5625 % 3 == 0). 3 is also a prime number ... Our prime factorization reached a result number of '1' (Meaning, we got to a case were all we had was a prime number, Ex. 2. And 2 / 2 == 1). At this point we're done factorizing and our 'list' contains the prime factors of 22500. That's the basic idea of the algorithm. In general, there are a few different ways to write this. Keep in mind, you both need to test numbers until you find one that divides cleanly, and also test if that number is prime. There are some cool optimizations you can add to this, but in general I would just worry about getting it working, not speed.
When you are done, exploit your server/netcat. ( Seriously, its fun and you will learn a lot. ) 
It still wasn't undefined in C89, just implementation defined. I'll take your word about C++. And I agree that memcpy is usually the more desirable solution since you often want to pun two pointers that aren't already pointing to objects that are part of a union, and in that situation it's the one more often compiled into a simple TBAA-aware bitcast. The only thing that bugs me about it is that despite how common and well-supported it is I've never been able to read the standard in a way that confirms that it's actually legal, since memcpy doesn't change the so-called effective type of the bytes passing through it, which means strict aliasing should still be in effect.
There should be no need for you to do any explicit prime testing. E.g. by the time you get around to testing if 21 is a factor, you will have already tested 3 and 7 - you'll have divided out all the 3's and 7's and therefore 21 won't divide into what's left.
Ah, yes C89 does say implementation defined (and some implementations treat it as an aliasing violation and thus UB. Namely Sun CC). C99 and C11 go ahead and require the desired behavior. &gt; The only thing that bugs me about it is that despite how common and well-supported it is I've never been able to read the standard in a way that confirms that it's actually legal, since memcpy doesn't change the so-called effective type of the bytes passing through it, which means strict aliasing should still be in effect. The effective type of an object with a declared type is always the declared type. Copying bytes around only affects the effective type when copying to an object that has no declared type. So when used properly, punning via memcpy does not produce aliasing violations.
I'm currently working on an IRC client. It's pretty interesting, I've written a simple one before in a different language and it's a decently fun project. FTP clients are also similarly pretty simple and fun (I like networking stuff). I've also been working on a console-based Reddit client, it's also pretty cool. The project I'm working on has the reddit-api implemented as a C library, so you could make use of it in your project and just deal with the interfacing. Though, the library isn't completed yet (You could always work on the library a bit for us if you want ;D). I could get you links for either of these projects if you're interested.
That's an advanced course in C? Is there something more advanced or is it all up to you after that?
um yea, Im sorry I'm just so lost and frustrated.
No problem. Comment if/when you have a problem with your arrays(it's fairly inevitable) and I'll help :)
I had a lot of fun writing a multi-file command line file downloader that downloads each file on a separate thread.
I will contribute to this! I've been looking for an interesting project. I'm going to fork and begin documenting all of your code that you've currently written, then I'll start contributing some code. I assume I can PM you with any questions?
Your else-if block doesn't end with an else. It's hard to see what's wrong without more information. What does the compiler say? 
http://imgur.com/5nxzbM6 um does this help?
You didn't declare the functions before main, also you didn't set a return type to updateRange and is returning nothing in the end. Edit: I must say something else, you should read the "formatting help" or paste your code in something like paste.ubuntu.com or gist.github.com.
libevent executes a callback function when a certain event occurs, it's based around networking servers
Your IDE (I assume VS?) is assuming you're writing C++, *not* C. I'm not sure how to configure your IDE to fix this; perhaps changing the file extensions to `.c` would be enough. Barring that, some pointers: * Functions need return types. Your `main()`, for example, is returning an integer (zero), so it should be `int main() {}`. * `updateRange()` is missing an endbrace to the for loop and should have `void` as its return type. * Your `i` variable is only used inside `updateRange()`. It should be set there (though in this particular case it doesn't matter). 
Fix what forbidden 404 said as well as changing the "else if (a &lt;= -1)" part to just "else", because you aren't closing out the block. 
&gt; because you aren't closing out the block. It isn't necessary to have an `else` block at the end, so "not closing out the block" is not the reason for this. Rather, the reason is that OP intends that last block to be executed if none of the previous conditions apply, and that is what `else` does.
Thanks but I'm not really sure what to declare
That's what I meant to say, I just didn't know how to write it.
Well, you can go about it two ways: move `main()` to the bottom, or declare your functions in the same area you declared a, i, r[1-6], etc. Function declaration is similar to writing them entirely. In this case it'd be simple: void displayRange(void); void updateRange(void); int acc[15]; /* ...and so on. */ One could argue that the `void` inside the parens is unnecessary, but explicitness is helpful when you're learning IMO.
For starters I'd LOVE it if you could figure out what's going wrong with the file read function. It's not working and I have spent hours trying to figure out why it's not working. Feel free to PM me questions!
Alright, switched to gedit and everything somehow seems to be working perfectly fine. One question though: I was discussing the return 0; part with some friends and though they said code doesn't run without it, mine compiles just fine and displays what I want. I've been making it a habit to include it just for good syntax, but it seems to serve no purpose. If it helps I'm just running my .c files straight through the command prompt of Ubuntu. What would be a situation where the return 0; command is vital? Thanks for all the help by the way, this past week has been an intense crash course in C so I can survive my computational physics class. Knowing python has helped, but C has proven to be a beast of its own... EDIT: Wow, I just happened to still have my first "hello.c" file hanging around and I forgot the # signs in front of my header files (doh). If it's not too much to ask (since it seems like you're pretty knowledgeable on this subject), what's the benefits of creating a makefile? One of my computer savvy friends today was trying to explain that a .c file compiled creates a .o file which in turn helps run an executable. I just don't know why those extra steps are necessary if my code is compiling/displaying results just fine. Also, if I'm missing anything or my reasoning's off feel free to kick me down a few notches. I'm all about this new learning experience and want to make sure I have my foundation 100% correct!
The return is not required to run the code, the return of any function is in most cases used to indicate success(return 0) or error(non-zero). In most cases, the compiler tries a best case approach to compile your code, and main does not have a fixed format to it. This is a overly simplified statement and this is only to help you understand, but essentially main() is just another function and whether you need to return anything from it depends on how you define main(). When you define a void main(), you lose the ability to ever return an exit status, and in general this is bad practise. The official standard recommends you use int main(void) { /* ... */ } or int main(int argc, char *argv[]) { /* ... */ } or equivalent The "or equivalent" part here leaves space for definitions like void main(void) 
I've barely looked at the code, but I assume you mean you're having trouble parsing the config file tracker.dat? EDIT: I've made some changes and submitted a pull request
SSL won't work because of how it's implemented. It's implemented on the socket but I need to implement the encryption onto text that can be sent over the socket afterwards.
Woops, was not paying attention when I forked that. I'll check it out and take a look.
I think you need to look at the OpenSSL API again, it's not all just the secure socket layer. There are also routines for encrypting blocks of data, specifically AES, like you requested. Google aes_cbc_encrypt, that should produce all the info you need.
In that case you may want to look at OTR. http://en.m.wikipedia.org/wiki/Off-the-Record_Messaging
OTR looks really good, I found the website [here](https://otr.cypherpunks.ca/). I'd need help implementing the source into my C code though...
If you have to ask this, you have no business implementing any sort of encryption. You will do something wrong and fuck your users.
OpenSSL is not just a TLS/SSL library. It provides implementations of crypto algorithms which you can use in isolation and other important algorithms you'll need. As another commenter has said, if you don't know this, you really need to ask what steps you can take to assure your users that you are implementing the cryptosystem correctly. 
This is great and helpful, but unfortunatley were only allowed to use functions and other things from c that we've learnt which so far should be only if/eles, and while/for loops 
Just as a complement to sporkbox's answer... When using C, and probably C++ too, you have to **write the functions before using them**, because when the compiler is making your source code a binary, it will face the fact that you're calling a function that doesn't "exist" yet. Thinking line by line, it would be something like this: Integer i will receive 10 as value and integer j will receive 5; Now do gcd(i,j); -&gt; The program *doesn't know* what gcd is yet. Implement gcd(int i, int j); -&gt; Now the program knows, but you've used it before. You can solve this by writing the function **before** using it or like *sporkbox* said, you **declare** them, just to make the compiler aware of it, like: "This is the function void displayRange(void), I didn't implement it **yet**, but I will, so when you see any displayRange() being called in main, there's no need to get crazy, I will implement it later"; Other thing, when you're making a function, this function will return something or nothing, but **you have to tell which one**. It might sound confusing, but it's something like this: If you want the function to return a integer in the end, you have to say in the beginning that you want to return that, so the compiler will expect an integer as a result of your function. This works for any type, like int, char, float etc. If you want the function to return **nothing**, you have to declare *void* and inside your function, you **will not return anything**, do you get it? You weren't saying if you wanted to return something or nothing before displayRange and still you were returning nothing in the end. If you want the function to return nothing, you declare void before the name of the function, just like void updateRange() and also, you **don't write return in the end of the function**. About the formatting help, every time you write something with 4 spaces before, it becomes a code, so we can read it better than plain text. Ex.: #include &lt;stdio.h&gt; void displayRange(void); //declaring the function before implementing it so the compiler knows about its existence //also I'm declaring that the function will return void, or nothing. //You will see after some learning that void functions can return something, but in this case, you're returning nothing. void updateRange(void); //same here int acc[15]; int a, i; int r1 = 0, r2 = 0, r3= 0, r4 = 0, r5 = 0, r6 = 0; int main() { // ...main... } void updateRange(void) { //implementation// //no return in the end } void displayRange(void) { //same as updateRange() } To summarize, if you're going to use a function that will be implemented yet, you have to "give a hint" before using. When you write a function, you have to tell if it's going to return something or nothing, if you're going to return nothing, you don't use *return* at all
Ye, cause nobody can ever learn anythinh new. 
nice one! :)
I had this exact idea for a site before, glad to see someone less lazy implemented it.
i tried integrating Marmite into scrambled eggs the other week, didn't work. 
STOP! NOW!
I like it, but I wish it would not mix, or at least make separate C89/C99/C11 language features.
If you want to tackle C + systems programming, try writing a UNIX shell. [Linux Application Development](http://www.amazon.com/exec/obidos/ISBN=0321219147) offers a guide/exercise to do that. Writing a shell isn't tricky or impressive, but it does give you solid grounding in C for later projects. Also if you want something algorithm extensive: a prime number generator for arbitrary precision numbers (think 1024 or 2048 bit) including the underlying library (see [Prime Numbers: a computational perspective](http://www.amazon.com/Prime-Numbers-A-Computational-Perspective/dp/1441920501)), and you can add RSA encryption/decryption on top of that if you want, and possibly a shell like `bc`. 
Encryption is a requirement for the program, if I don't have it there is no point in the program. If you'd like to help me implement the encryption, feel free! I am going to need to figure out how to put it in somehow though.
About time something like this existed for C :D
That would be slow as fuck as a malloc costs up to a thousand cycles plus a possible system call if it needs to allocate more memory. malloc() also has to scan noncontinuous chunks of memory to find free space, fucking up your caches in the process. What exists is a technique known as [split stacks](http://gcc.gnu.org/wiki/SplitStacks). Each function contains a small prologue that checks if the stack space is sufficient and allocates more (albeit in a different location) if needed. This is currently used in the Go language reference implementation, although the developers are going back to continuous stacks wherever possible as split stacks have a not-so-small performance penalty. TL;DR malloc()'ing your stack-frames is like using a HDD for your memory â€“ you can do it, but it's slow as fuck.
I love normally-formatted documentation like this. It opens up so many possibilities. I was inspired to Emacs support to hook into devdocs.io: [devdocs-lookup](https://github.com/skeeto/devdocs-lookup). 
&gt; I believe this would be very useful for deep recursion, Why?
And for the uninitiated split stacks basically work like this: 1. call foo(bar), 2. inline is foo() close to the guard page size? 3. expand the stack and copy crap over to the new stack. 
Cool! I added a link to your project on DevDocs's wiki: https://github.com/Thibaut/devdocs/wiki
It is usually possible to extend the stack at run time.
Hey mate, I don't know much about porting but I'm interning at a reputed institute in my country where I am going to develop algorithms for network security. I don't know how GitHub works but I do know C programming 
I'm confused as to how this is organized.
I've setup a little [Github tutorial](http://www.reddit.com/r/P2PChatbox/comments/22bvuk/forking_the_github_repository_tutorial/) on the [P2PChatbox subreddit](http://www.reddit.com/r/P2PChatbox/). Network security algorithms will help a lot, [here's](http://www.reddit.com/r/P2PChatbox/comments/2295bd/encryptiondecryption/) the encryption/decryption thread. That currently needs to be developed a bit... I don't know how to implement AES or anything like that.
Nope. That's the approach you take with continuous stacks. With split stacks it's more like this: 1. call foo(bar) 2. Is stack space sufficient? If yes, proceed with foo(), else: 3. Allocate a new segment of stack somewhere else 4. Place metadata and a pseudo-stackframe ontop of the new stack 5. Change sp to point to the new stack 6. Proceed with foo() 7. when foo() returns, it returns to an address that has been written into the pseudo stack frame. 8. The function at that address deallocates the second stack frame and manipulates sp to point back to the original stack frame 9. The function returns and nobody knows a stack split happened If the segment size is choosen carefully, this scheme is capable of executing code without many stack reallocations.
Yeah, that bugs me as well. Also, the documentation fails to describe some things correctly. For instace, the documentation for the static keyword fails to address it's new usage to make an assertion about guaranteed array length.
I was thinking on along the lines of public key crypto. How about setting up a chat server in which authentication runs in the background and the two users communicate with each other. The system would roughly work as this- Let's say Bob wants to communicate with Alice. To do so he has two keys one public and one private, he gives his public key to Alice using which she calculates her private session key and then sends an encrypted message to Bob. Bob who already knows his private key is able to decode it and they arrive at a common key. Then comm can begin without any fear of being tapped.
Can you use the encryption/decryption thread? That way this'll be easier to track. We could use the private-public key method but would you know how to make it accept groups of 50 people?
I disagree. Proof by contradiction: op asked on reddit about encryption, and got spoon fed "you need to do more research". Ergo op did the right thing anyway. Look, it's all about politeness. A lot of developers have so much hubris and inflated sense of self-worth, that they would go on a tangent at the slightest provocation. For all you know op could be some kind of super genius, and his only weakness is with crypto libraries. Saying that he has no business messing with that stuff is demeaning at best. Also, unless you are in business of braking crypto-systems or involved with rigorous proofing, it's actually not that difficult to learn the basics. I had two undergrad courses in crypto, 2 more in data security - and it was pretty easy after a few humps - for everybody involved. So I'm doubly irate at the notion that this knowledge is somehow unattainable. 
This is a subreddit about C, not Objective C. 
Everyone hates me:( lol. That's what I thought but the last time I was struggling with a problem I posted in r/objectivec and they criticized me because they thought it belonged here since the program was considered mostly C? The class I'm taking is called Intro to Objective-C so that's why I posted in there for the last problem; however, I thought I'd take their advice this time. Should I re-post this in r/objectivec or keep it here?
Have you tried stackoverflow.com?
I've searched the website but haven't posted to there. I've looked all through out my book, online, and sample programs but can't seem to find the syntax I'm looking for. In general, is stackoverflow a better/faster way to get my questions answered? 
&gt; I keep getting a "incompatible types when assigning to type double[12][12] from type double" error. ... on which line? That's a good place to start looking for the error. Is is the ``return nextDen[12][12];`` line? Is it the ``double current[12][12] = currentDen[12][12];`` line? Is it something else? I've a few questions but first please read http://cm.bell-labs.com/who/dmr/chist.html up to: &gt; "Compilers in 1977, and even well after, did not complain about usages such as assigning between integers and pointers or using objects of the wrong type to refer to structure members. Although the language definition presented in the first edition of K&amp;R was reasonably (though not completely) coherent in its treatment of type rules, that book admitted that existing compilers didn't enforce them. Moreover, some rules designed to ease early transitions contributed to later confusion. For example, the empty square brackets in the function declaration &gt; &gt; int f(a) int a[]; { ... } &gt; &gt; are a living fossil, a remnant of NB's way of declaring a pointer; a is, in this special case only, interpreted in C as a pointer. The notation survived in part for the sake of compatibility, in part under the rationalization that it would allow programmers to communicate to their readers an intent to pass f a pointer generated from an array, rather than a reference to a single integer. Unfortunately, it serves as much to confuse the learner as to alert the reader." Then attempt to answer the following questions *to yourself*. They should reveal the error. 0. How do you initialise the ``current`` array? Recalling that arrays are very nearly just pointers, is this going to copy the 144 doubles or do something else? 1. What is the return type of your function? Is it an array? 2. Is the memory for your return array allocated on the stack or the heap? When is it de-allocated explicitly (heap) or implicitly by the compiler (stack)? 3. What does the expression ``nextDen[12][12]`` give you? 4. What does ``return foo;`` do in a function? 5. Therefore, what does ``return nextDen[12][12]`` do? Is it what you want? 6. Storage allocated on the stack is automatically reclaimed when the function returns. Storage allocated on the heap is not. Where is your return value allocated?
Edit: /u/gblargg pointed out that my code is fucked up. Confirmed.
Yeah I would say so. Just explain what you've done so far to find a solution .....they will be able to help you out.
The short answer is that you **cannot** make a function that returns an array type. There is no way to do that in&amp;nbsp;C. Instead, functions that "return arrays" actually return *pointers*. The target of the returned pointer is the first element of the array. (Likewise, you also cannot *pass* an array to a function. Whenever you think you are passing an array to a function, what you are really doing is passing a *pointer* to the first element of the array.) So you will need to understand the relationship between pointers and arrays in order to make this work. You may also need to understand dynamic memory allocation (using `malloc` and `free`), because if you intend your function to allocate a new array and return a pointer to that new array, then you will need to use `malloc` to allocate it (and later you will need to `free` it somewhere else in your code).
&gt; void funcName (double (*pointerToVar)[3][3]) &gt; { &gt; (*pointerToVar)[0][0] = 8008135.0; &gt; } FTFY. To OP, note that the above can be simplified (as you do it) if you don't mind a little less type checking: void f2(double a[3][3]) { a[0][0] = 3.14159; } void example() { double array[3][3]; funcName( &amp;array ); f2( array ); // no &amp; needed double array2 [2][3]; funcName( &amp;array2 ); // rejected as you want f2( array2 ); // this is accepted even though it's not what f2 wants } 
&gt; You should look into pointers. If you learn pointers, you will understand why this doesn't work. The first problem I see is with this line: &gt; &gt; double current[12][12] = currentDen[12][12]; &gt; &gt; Let me break this down into 4 lines so you can understand what is happening. The notation array[N][N] has different behavior during initialization and afterwards. &gt; &gt; double current[12][12]; // creates a 12x12 array &gt; double value = currentDen[12][12]; // dereferences the array currentDen, beyond its boundaries (max values in there should be [11][11]) and gets one value &gt; current = value; // you then assign a single double to the pointer current &gt; &gt; So, when declaring an array the [12][12] notation initializes it with 12 elements. Any time after that, the [N][M] notation dereferences the array and gets the value at those indices. current isn't a pointer at all, and the declaration doesn't "initialize" it with 12 elements; it's an array object containing twelve double[12] elements. current=whatever is illegal since you can't assign arrays in C. &gt; double **nextDensity(double **current) { &gt; double **nextDen = (double **)malloc(sizeof(double *)*12); &gt; int i, j; &gt; &gt; for(i=0; i&lt;12; ++i) { &gt; nextDen[i] = (double *)malloc(sizeof(double *)*12); &gt; } This code is broken; the initialization of nextDen allocates space for 12 double *pointers*, rather than 12 doubles. An easy way to avoid inconsistencies like this is to calculate the size based on what the pointer is being assigned to (also no need to cast the result of malloc): double **nextDensity(double **current) { double **nextDen = malloc(12*sizeof *nextDen); int i, j; for(i=0; i&lt;12; ++i) { nextDen[i] = malloc(12*sizeof *nextDen[i]); } &gt; I'd wager you don't understand malloc, so this might be a little easier to use. &gt; &gt; void nextDensity(double **current, double **nextDen) { &gt; int i, j; &gt; &gt; for( j = 0; j &lt; 12; j++) { &gt; for( i = 0; i &lt; 12; i++) { &gt; if(j == 0 || j == 11) { &gt; nextDen[i][j] = current[i][j]; &gt; } else if (i == 0 || i == 11) { &gt; nextDen[i][j] = current[i][j]; &gt; } else { &gt; nextDen[i][j] = (current[i + 1][j] + current[i -1][j] + current[i][j] + current[i][j + 1] + current[i][j - 1]) / 5.0; &gt; } &gt; } &gt; } &gt; } &gt; &gt; int main() { &gt; double current[12][12]; &gt; double nextDen[12][12]; &gt; &gt; // populate current &gt; &gt; nextDensity(current, nextDen); &gt; } This isn't valid at all. Did you mean to define nextDensity like this? void nextDensity(double current[12][12], double nextDen[12][12]) { 
have the function return a pointer to a double. and return nextDen. &gt; double current[12][12] = currentDen[12][12]; you can't assign arrays like that. double current[12][12]; for(int i = 0;i&lt;12;i++) { for(int j = 0;j&lt;12;j++) { current[i][j] = currentDen[i][j]; } } that is what you want.
Below, a is an object of type char[2]. It's not a pointer. sizeof a yields 2 as expected, not 8 like &amp;a[0] yields. I also take a pointer to a, of type char(*)[2]. The only pointer-ness of an array is that it will yield a pointer to the first element when its value is used, e.g. *(a+1), a[1], char* p = a. #include &lt;stdio.h&gt; int main( void ) { char a [2]; char (*ap)[2]; ap = &amp;a; printf( "%zd %zd\n", sizeof a, sizeof &amp;a[0] ); // prints 2 8 on my machine } 
No. Not yet I'll have to figure it out... it is possible though....I'll keep you updated. though and sure I have already subscribed to it so I'll post it there
Oh this looks fascinating! I'm going to work my way through it ASAP.
This project is being developed for Linux only right now. We have [a subreddit](http://www.reddit.com/r/P2PChatbox/) with a [thread created for encryption/decryption](http://www.reddit.com/r/P2PChatbox/comments/2295bd/encryptiondecryption/) ideas. If you can describe how to encrypt and decrypt text using lxqtwallet.c and lxqtwallet.h, we could use your code.
The lxqtwallet library will not be ideal since it assumes the encrypted and decryption data will be stored in files.Your solution will need to be modified a little and to take the whole library just for two functions will be adding unnecessary bloat. Will submit a pull request shortly with my solution for you to look at.
This looks very interesting. I'm familiar with C, but not Lisp, and I've always had a fascination with programming language implementation. Thank you for posting!
Ok so I got that. When writeing Console.WriteLine("Values: {0}, {1}", val1, val2); the 0 is going to be replaced with whatever is listed first after the " and , then same for the 1 and whatever is in the place of val2. But is there a more simple way to just get Console.WriteLine to display a variable after a string literal. It seems a little convoluted to have to type in 0, 1 then list the corresponding variables.
Ah ok. That seems a bit weird coming from C++. But I suppose you may be able to work with this easier. Copy pasting list of variables then rearranging them in the string literal by list number. Thanks!
One of the main advantages of using the substitution mechanism is that if you are doing localisation of strings for other cultures then the order of the variables may be changed in the translated string. This cannot be handled when doing string concatenation.
 I just created a solution[1] powered by libgcrypt these guys could use. There are encryption libraries they could use,they are just not abstracted to the level they want.My proposed solution abstracts libgcrypt to a level their request is looking for. [1] https://github.com/mhogomchungu/crypt_buffer
Wow - impressive. Question refers to three different languages, *NONE* of them the subject of this subreddit. Well done! And (more serious) kudos to /u/HighCore for actually attempting to answer the question.
I'm mildly interested in checking this out based on the intro page. But, I'm only about halfway through a beginner level book, and have to type one-handed due to broken arm. Do you think this would be over my head, or too tedious with one hand?
Working through this right now actually and it's pretty cool for someone who's still relatively new to programming
Is this what you mean? char *c = "hello"; &gt; How is the memory for this string constant being reserved? Logically, it is (usually) put in the "read-only" section of the final executable (.rodata using gcc). But physically, on most (maybe all) systems, it's just another memory address. You can change the string "hello" using a debugger or by some other means. But if your program tries to modify it, the result will be undefined behavior. &gt; Can anyone elaborate on why it's immutable I don't know the historic reason, but I'd guess being able to reuse the same string, and enabling caching and optimization of some operations might be some of the reasons.
&gt; I don't know the historic reason, but I'd guess being able to reuse the same string, and enabling caching and optimization of some operations might be some of the reasons. You gave the reason: it's part of the code portion of the process memory. That memory portion is made read-only because it is very unsafe to let a process dynamically modify its code. Most of the time, "undefined behavior" in C really means it's supposed to be a crash, but it's kept as undefined in the standard so that C compilers are less constrained in the optimizations they can do. For programmers, "undefined behavior" means "DON'T DO IT".
I'm not new to programming but I've probably only written &lt;100 lines of c since college. It's pretty cool for new too.
Well but why not put it in .data? Global variables etc. are kept there and can be modified without issues. I wonder if string literals being lvalue (rather than rvalue) have anything to do with it but I can't say I know enough about compilers to comment about that.
I believe some newer (probably not new at all) versions of GCC support mutable string literals placed in .data via a macro or something like that. Haven't tried it myself, but I think I read that somewhere. CORRECTION: Looked into it, and I believe it was a modified version of GCC a guy modded to his liking for osdev, which is very much a standards grey-area.
Because again, modifying code in runtime is a security vulnerability. Think of string literals as acting like integer literals. If you write: if (amount &gt; 145) reject_transaction(); you really want 145 to be immutable: nothing in the code should be able to change it. Similarly, if you write: printf("I'm a little teapot\n"); You don't want your program to ever spit out "I'm a little peatot". You especially don't want something overwriting your terminating null character. But if you were to put the string literals in modifiable memory, that's exactly what could happen. The only difference with integer literals is that they're usually small enough to be embedded in the instructions themselves and don't need to be placed elsewhere. If you want a mutable string, you need to allocate writable memory, either on the stack, on the heap, or in the global section, and copy a string literal to it. Recent revisions of the standard even give you some syntactic sugar to do this easily. The following works: char string[] = "I'm a little teapot\n"; string[13] = 'p'; But this essentially compiles to the same thing as: char string[21]; bcopy(string, "I'm a little teapot\n", 21); string[13] = 'p'; 
I don't think so. Why would modifying global variables initialized by the compiler in .data not a security vulnerability? .rodata is still a data section, just like .data. (note: Apparently, it's not even mandated to store the literal in a read-only section. So your compiler can store it in .data if you wish.) If having modifiable data in one is a security threat, it should be the same for the other one. Your printf example uses just the literal but does not initialize a pointer with it. So in other words, why is this: char str[] = "hello"; not a security vulnerability but: char *str = "hello"; is? "hello" in memory is a string literal in both cases, but it's mutable in one just fine. I don't think modifying unnamed arrays is a security vulnerability when modifying named arrays is not. BTW the first statement (array init) has been allowed since ANSI. When I compile with -std=c89, it compiles and runs fine. Reading more about it: * http://c-faq.com/decl/strlitinit.html * http://www.c-faq.com/ansi/strlitnotconst.html There are a few other related questions but nothing on the initial decision to treat unnamed arrays like this and giving them program scope. The closest I found (note: no sources) is this thread: http://cboard.cprogramming.com/c-programming/159149-assigning-pointer-string-literal-undefined-behavior.html It says, to my surprise, the historic reason is lazy programmers lobbying for char pointer initialization using string literals. Read the link :) It also explains why you can do this: char *a = "hello"; but not this: float *f = 3.14; There was no lobbying to allow other types of literals be created the same way since it was usually not needed.
There's no reasonable use of modifying a string literal. You can't make it longer. It would become an obscure global variable: char* s = "hello"; Would this point s at a string with the contents "hello"? There would be no way to know without examining more of the program to see if it later might modify it. If you really want to modify it, make it an array: char s [] = "hello"; If you want changes to last the rest of the program, make it static: static char s [] = "hello"; Making it read-only also allows some optimization opportunities, in allowing multiple uses of the same literal to share the same memory (useful for things like the assert macro), and two literals where one is suffix of the other.
I wasn't sure if it was in the standard from the start, since it's syntactic sugar and C is usually very low-level in its constructs. Doesn't really matter. What matters is the difference between the two statements. char str[] = "hello"; means "allocate an array on the stack big enough to hold this string of bytes, then copy them into it". char *str = "hello"; means "create a pointer of type char, and set the value to the address of wherever you chose to put the static, immutable string of characters". They are two very different things. In the former, the compiler may choose to hold a copy of the string in read-only memory, and copy the bytes, or (I would guess) if the string is small, output however many immediate memory write instructions. Then you can do whatever you want with the array because it's allocated on the stack, it's under your control and you are responsible for making sure you use it correctly. In the latter, the standard says the compiler can treat the string as immutable (that's what modifying being undefined means), so it can place it in read-only memory or in .data, but the only thing you have under your control is the pointer. It is good practice to actually use a const char in this case so the compiler catches any unwanted access to that part of memory. The answers at the link you provided basically state exactly what I've said so far. The security concern is about what the programmer expects. If you're hunting for buffer overflow issues, you should do so in your own memory, you don't want to have to worry about memory that is supposed to be immutable.
It's simple, before the last strcpy you have : str_a[0] = 'H' /* &lt;&lt; pointer points here */ str_a[1] = 'e' str_a[2] = 'l' /* &lt;&lt; pointer2 points here (pointer+2 bytes) */ str_a[3] = 'l' [...] So once you do the strcpy(pointer2, "y you");, strcpy will start to copy the string "y you" at the address pointer2 is pointing to, that is just after the first 2 bytes of "Hello World!". strcpy() copies a string at a given address, strcat() copies another string at the end of the first one you give him. You're expecting the behaviour of strcat() while you're using strcpy(). 
thank you so much! Also @Nimbal. Now it's clear!! thanks guys
I guess you were expecting strcat, instead you used strcpy (strcpy will replace instead of adding it at end), and it replaced "ello, World"\0 with "y you"\0. Also since you are using \n, this will print in new line. Thus the output that should print from your code is definitely. pointer: Hello, world! pointer+2: llo, world! pointer: Hello, world! y you pointer2: llo, world! y you 
&gt; You may be stuck a few versions behind with compilers, though. I dunno, LLVM is pretty slick. I don't own a Mac, whats stopping anyone from running the latest LLVM or GCC toolchain?
VM is the way to go. Pick whatever OS you like the most to be the host. VMs nowadays have accelerated graphics, not to mention thin virtual nics, and fast storage. Practially, native speeds are possible. Just make sure your hardware supports all of this and has it enabled!
&gt;Fedora Pfft, Debian testing, or if you want to hang with the cool kids, Slackware. Volkerding knows his shit. 
What sort of control do you have over your work computer? What is the blessed OS on it? 
I actually switched to Debian Testing yesterday. I'm really liking it so far.
If you're completely new to C you might get stuck not understanding what a bit of code means. In that case, just set it aside and continue with your beginner level book and come back once you know more. Typing with one hand sounds miserable, though, and learning any sort of programming that way sound tedious to me. This book shouldn't be any worse for that. Most of the code is already written, so you would mainly be modifying code for the exercises. 
If you really want to learn and understand C and how it works, buy this http://www.mixsoftware.com/product/powerc.htm and this http://www.mixsoftware.com/product/pctrace.htm Run it under MSDOS or in DOSBOX and you can step through your programs watching exactly what happens to every byte of data. Way easier to learn this way than any other way I tried.
What is this, are we in the 90's?
OK Thank you!
You cannot set an `int` variable to infinity. "Infinity" is not a value that can be represented by an `int`. But if you `#include &lt;limits.h&gt;` then you get constants called `INT_MAX` and `INT_MIN` that represent the maximum and minimum values that are representable by an `int`, so you can use those.
I tried it using the limits.h it works great, thank you so much.
I'm sorry but i don't understand the hint :P I did it with the limits.h and it works like i want it. Can you share the alternative way without involving the limits ? I'd be obliged.
If I give you a list of 1 numbers: 5. What's the largest number? 5. Now let's say that list increases to 3. (5, 2, 7). What's now the largest number? 7. The way I could do it is simply to store the largest value in some temp variable and compare that temp variable to each of the new numbers. When you're done, the value in that temp var must be the largest. Another way could first sort the numbers, then look at the end for the largest number. Using different sorting algorithms can get it done quicker. The method I mentioned above would work, but the computation time scales with the number of elements in the list. O(n) aka, not very efficient.
I think he does that but he wants to start with negative infinity as the first "maximum". OP, try starting with the first element of your array as the maximum instead.
I wouldn't bother with infinity, `INT_MAX` or header files, but just set `big` and `small` to `-1` at the start of the program. If they're still -1 when the loop is finished, you know you haven't seen any positive ints. If during the loop you find any positive number, you unconditionally replace your `-1`'s with it. Otherwise you do the compare to see if the value is smaller than your smallest or larger than your largest. Here's what I hacked up: #include &lt;stdio.h&gt; int main () { int num,big,i,small; printf("This program will find you the biggest and smallest positive out of 20 integers\n"); /* Initialize to invalid values: */ big = small = -1; for (i = 1; i &lt;= 20; i++) { printf("Give number %d: ",i); scanf("%d", &amp;num); /* Not a positive number? Try again: */ if (num &lt; 0) { continue; } /* If small is -1 or bigger than num, this is the smallest positive number yet: */ if (small == -1 || num &lt; small) { small = num; } /* If big is -1 or smaller than num, this is the biggest positive number yet: */ if (big == -1 || num &gt; big) { big = num; } } if (big == -1) { printf("No positive numbers seen!\n"); } else { printf("The biggest positive is %d\n",big); printf("The smallest positive is %d\n",small); } return 0; }
that's a pretty smart techniques. Haven't thought of that. Thanks for showing it to me.
Yes. When i used the &lt;limits.h&gt; i initialized big = INT_MIN and small=INT_MAX and that did the trick.
I would actually recommend something slightly different, and just avoid the entire issue of figuring out a sane default value. You *know* that you're going to get 20 integers, so just use the first integer you get as your initial big and small values, and then go into your loop like normal.
Your small value could be initialized with a negative number, which will win any comparison with other small yet positive numbers in the input. So this approach won't always find the smallest positive number.
i tried that, but in the case that the first number is negative then the smallest value always remains negative since i look for only the positive smallest values. When it goes in the loop it will compare for example if num&lt;small but if small had an initial value of -1 for example the num variable can never get a positive value.
For future reference, remember that computation floating point numbers and the mathematical real numbers are entirely different things too.
Out of interest, what are the values of INT_MAX and INT_MIN?
If your architecture represents ints are 2's complement (which virtually all modern architectures do), then INT_MAX is 2^(base-1)-1, and INT_MIN is -2^(base-1), where base the bit size of the int, i.e 32 for a 32 bit arch, 64 for a 64 bit arch.
You're absolutely right; I hadn't even thought about LLVM. Back in the day, there was some version-4 GCC that was all anybody with a Mac had. Don't remember why.
The values of `INT_MAX` and `INT_MIN` depend on your computer and your compiler. The C&amp;nbsp;standard specifies only that `INT_MAX` must be greater than or equal to 32767, and `INT_MIN` must be less than or equal to âˆ’32767.
That's perhaps even closer to 80's. 
What he/she said! Also, don't use strcpy in production code... ever. Use strlcpy instead.
It's a refinement of what you're already doing. In the case of a list with one element then max == min == list[0]. Sanitize input first, and then just do your comparisons starting at the second element in your list on. It saves you a couple steps. 
Most 64 bit architectures are LP64, not ILP64, so you probably won't find `INT_MAX` being 2^(63)-1 anywhere. 
Would you trust him with the task of securing your bank account? Or would you trust someone with nothing more than a first aid certificate to perform open heart surgery? Sometimes people need to be reminded that you shouldn't always jump in at the deep end...
Die stupid and ignorant then.
I didn't say information is useless. I said *your* information is useless.
Read his post again,he is working on a project that has encryption as a component and he is looking for an existing solution that is customized enough for his need so that he can simply integrate it. He does not need to be an expert in crypto to have a good project,all he need is a well documented solution that allows him to use it in a recommended way. He is doing what he is supposed to be doing,concentrate on core aspects of his project and let somebody else deal with crypto mumble jumble he does not need to know details of. Nobody is born knowing everything,he is doing his thing in the open,if you can,why not take the time to look into what he is doing and maybe guide him in the right direction. If lives depend on secrecy and privacy,just taking code off github seem irresponsible to me regardless of who is cranking out the code.In these situations,you need solution backed by people you can sue out of existance or solutions that have been vouched by people you trust. Anyway,i have heard his request and came up with a solution i think will be perfect for him and my solution is here[1].I did nothing fancy,just abstracted libcrypt in a way i think will be ideal for his project. [1] https://github.com/mhogomchungu/crypt_buffer 
I would caution you on this, as it is unnecessary. A simpler solution is initializing both big and small to the first value of those you're comparing. When you've only looked at one value, it is the biggest and the smallest. Comparing to that will work as expected.
 int num, num2, factor=2; printf("enter number: "); scanf("%d", &amp;num); num2=num; while(num!=1) { if(num%factor==0) { num/=factor; if (num!=1) printf("%d*", factor); else printf("%d=", factor); } else factor++; } printf("%d", num2); maybe like that? i'm still newbie too
Strings in C are actually arrays (of bytes) in memory, with a special value ('\0') as an end marker, referenced by a pointer to the first array item. God knows what comes in memory locations behind it. `strcpy` *overwrites* part of one such array, with a copy of the data in another such array. `pointer2` points to the third character in the string referenced by `pointer`. You overwrite what was there and in subsequent memory locations) (which contained `"llo, world!\n\0"` (13 bytes)), with `"y you\0"` (6 bytes). So there only `"llo, w"` (6 bytes) was overwritten, and you end up with `"y you\0orld!\n\0"`, plus the `"He"` in front of that from before.
I think I'm misunderstanding but why not use ioctl_param to pass the channel ID to the kernel? Is that what you're asking?
I use it. It's simple, fast, and does everything i need. 
Have you worked with procs at all? I think that would be the easiest solution. Unless there is a valid reason user mode needs to see the memory. With a proc you can just copy the kernel memory to the user mode buffer, in what looks like a read/write to user mode. If the data is larger than 3072 bytes you have to do some buffer arithmetic and handle multiple proc callback calls, because that is the default proc page size. Even with the mmap route you'll need to convert that address to a user mode accessible address space. A few years back, I wrote a project that shared a hash table between kernel and user space. It felt hacky, but I was able to create a char device and then from user space I would call the mmap on the char device. My mmap kernel callback would convert the address to user space and mmap back to the user. I'm pretty sure this is how it's done in LDD3, because I used that book a lot when I first got going on kernel dev. I'm at the office now, so I don't have more time to go into detail. If you want more info I can try and provide more later. 
Vim is anything but a lightweight editor, and once you get over the somewhat substantial learning curve, may well be the last text / code editor you ever use. Through standard functionality and plugins, vim can provide text editing functionality the typical "notepad-like" editor can't even dream of. Once you get the hang of vim, you'll be significantly faster at editing code or text than you will ever be using an editor that requires a mouse to move around / select text. 
I use it for quick tasks where I'm already at the terminal, and will want to get in and out, or if I'm mostly writing a single file in one direction. Vim is pretty much always on the other end of a SSH login, so it's frightfully useful for anything remote as well. I tend to use KWrite for any file I want to hang around outside the terminal, or wherever I'm doing lots of copy-and-pasting, or when I want a less antiquated regex syntax. Kate (a bunch of KWrites tied together) is good for things like TeX where you have a bunch of documents in the same place or need to throw together a quick-and-dirty batch of shell scripts, things like thatl; occasionally I'll use it for a small C project. Eclipse is my go-to for projects of any significant size or complexity.
I used to be one of those people who was like "Oh, those Vim users, they're just hipsters trying to be underground with their weird no-mouse no-gui text editors." Then I tried Vim, and *wow*. I don't understand how a text editor over 20 years old has still not had any text editors better than it, but seriously. It's so good.
It takes some learning, but once you get comfortable with a set of editing commands that suit your workflow it is a smooth ride on to learning more. 
I use it for all my editing (code or otherwise). Once you start getting used to using it, it just feels extremely comfortable and lets you edit code quickly. It takes a while to get in the mindset, but now when I'm in vim I really don't have to think much about how to control vim. Vim really has it's own 'expressive language' for editing which allows you to do pretty complex tasks pretty easily. Admittedly, in general I mostly just use a subset of this 'language', but there's a lot of power in being able to develop simple solutions to issues. For example, a few days ago I had a list in a file that I needed to change the format of (It was something like moving the first item in the list outside of it, deleting the extra comma, something like that). It would have take forever to get it done in a regular editor (Position cursor, highlight, cut, move paste, position cursor again... etc.. for every line). In Vim, I started a new macro and then made the change to the first line just via some simple movement, copying, and pasting commands (Ex. move to the first '(' character, delete the next word, move back two words, paste the deleted word, etc...). When I was done with the change (Which didn't take to long to perform), I ended the macro. Then I just typed '40@q' and Vim ran the macro over the next 40 lines and I was done. I used to use gedit and geany and some others, but you just can't match that type of editing in any other editors. None of it was hard to do either, because it's a lot like working with a Unix command-line, you just have little pieces and parts which you fit together to get your work done.
Use an editor that suits you. I find that for C editors are not that important for productivity. Autocomplete is not really necessary, as function and variable names are usually short and dontSufferFromStupidNamingConvetions() that other languages (mostly OO) have. Personally I find vim meh and prefer some notepad-like editor :) I spend most of my time reading man pages or API headers anyways.
nice - what kind of project size stuff do you use it with? 
ha I've heard the same kind of thing, people using tricky thing's for the sake of using tricky things. I think I might have a go.... can you give a 'top three' thing's about VIM (for you)? 
I haven't met modes yet! But I'll bear in mind the short cut... Although `ctrl esc` is just as close as `ctrl [` isn't it? I might have missed something there... 
Here: 1. Unless you're on windows, you don't need to install it. It's just there. 2. It's incredibly customisable and does exactly what you need. Any other editor's features can be and probably have been implemented into vim. 3. It's fast, both in opening and saving, but also in the way that, if I need to quickly edit like a single line of a file, I can just quickly open vim rather than booting up an IDE which takes longer to start up than linux. 
sweet, that's pretty much the impression that I got off it... The logic to learn the shell seemed to apply to learning VIM. I'm trying to do everything from the terminal at the moment to get used to it, cd / ls-ing into thing's are kind of slow at the moment, but I'm expecting it to be quicker for thing's in the long run What would you say the top thing's are for you with VIM? That you use regularly.... Normal / Insert mode sounds interesting, I'll check it out, cheers
sweet... Hopefully it won't take too long to get used to! What are the top thing's you like about VIM? (For you...)
&gt; Have you worked with procs at all? No, I have not. I think I read somewhere that it is bad practice to do so with linux device drivers, maybe I am imagining. Also it is a requirement of this project that it is handled via ioctls. &gt; Even with the mmap route you'll need to convert that address to a user mode accessible address space. Yes, for sure. &gt; A few years back, I wrote a project that ... That is _EXACTLY_ how I am planning to do it. I just can't seem to get a hang of it. I read the parts in LDD3 multiple times and googled for hours. I even wrote a generic mmap function in my device. What I am missing is how to mmap my specific buffer. The user has to be able to do something like this (pseudo code): ioctl(mmap, outgoing_buffer[4]); And with this he has to gain access to the ring buffer of the fourth ougoing queue, which the device previously has kmalloc'ed like this channels_out[4].queue = kmalloc(BUF_SIZE, GFP_KERNEL); Thus the user shall be able to mmap individual buffers. Sorry if I do not explain myself quite as good as I could, but it was a looooong day at work.
Then the device has the ID of the queue, yes. I am doing something similar when allocating the queues with IOCTLs. I just don't know what to do in mmap exactly. Somehow it eludes me :)
You can hit Ctrl[ without moving from home row, which is why many use it. Historically, ESC was where capslock is, so it made a lot more sense to use. As for modes, in vim modes are used for everything, press i to enter insert mode, type some stuff, ESC to return to command mode. Some of VIMS nicest features need to be turned on explicitly, there's a pretty good premade vimrc file [here]( http://amix.dk/vim/vimrc.html) that is well suited for programming. Main thing is to find the parts you like and over time customize vim to work exactly how to you want it to.
many pro coders use vim, don't think it as a lightweight editor, it is really powerful, extensible and with a great community behind (not gedit as far I know). I previously used vim for at least 10years for everything, now I mostly switched to emacs for some reason, but what I can advice you is don't bother really much on the editor, se it up with just syntax highlighting, and maybe completion is a plus, other features like refactoring, on the fly error checking, most of the cases are not really needed, what you should really really, and repeat really, do is write a lot of code, read a lot more, and use an editor that permits you to navigate the code easily and doesn't get in the way. For what concerns linux, yeah learn and master it, end of the story :)
Take it from someone who's been using vi/vim for 20+ years, you won't regret learning it. It a given that you'll have some sort of vi on any Unix-based box you log into. Even with 20+ years of usage, I don't use it as my main editor (Slickedit in Brief mode, you think Emacs people are nuts?), but I use it constantly for quick edits in files. I know enough to do most simple tasks in vim (search/replace, etc) but not a hard core user. There's a slew of plugins, but I would be careful.. If you start relying on those plugins, when you switch to another machine, it'll be vim, but not 'your vim', and you'll feel really lost. Whatever editor you choose, learn it, and learn it well.. Most programming editors (editors designed for writing code, not 'text editors' like wordpad/kwrite and other mentioned), have a slew of features that are designed just for programmers.. In my case (brief), I have block select, which is invaluable for code editing, and I've never seen it in wordpad-like editors. Having auto-complete is nice, but what I like is autoformatting.. Slickedit (and others) can be configured to format your code as you type. This means less typing on your part. Less typing is faster coding (usually). In any case.. Like i said above.. Whatever editor you choose, learn it well..
Cool - I was wondering about other languages actually and just had a Google to see if it can do JavaScript, apparently it can. Do you have auto complete set up? Any 'can't live without' plug ins? Cheers
Why switch to Emacs then? Cheers
Yeah, I've only just found out that it can do auto complete and stuff (not sure about auto formatting) which sounds interesting, I didn't realise that it could do that kind of thing. Haven't heard about -rc files, going to have to work out how to use them. nice one 
nice :) I've a lot to learn, with programming and Linux, so hopefully adding VIM to the list makes it more holistic rather than over whelming 
&gt; I find that for C editors are not that important for productivity Whys that? I'm only learning at the moment, so C is the language that I'm following currently. JavaScript interests me quite a bit, though I haven't done enough to really say at the mo 
3 is a good reason, it's just kind of 'there' already... I've only recently used `grep`, that seems pretty handy
&gt; I imagine that it's a pretty light weight editor, It's a trap. * **Pro**: It is almost as good as Emacs * **Con**: It is the middle of e**vi**l, and will devour you soul. 
Hmm... The only real catch is that vim does have a bit of a learning curve, it's not really fun to be fighting the editor when you have lots of other new things going on. There's no shame in pulling out gedit from time to time. At the same time, if you pop open a terminal and run the command 'vimtutor' and make it all the way to the end, it'll teach you basically everything you need to go to get going and you should be fine to be using vim at least as fast as a normal editor within a few days. I'd recommend also looking up writing a simple .vimrc for yourself (And unmap the arrow keys so you don't use them). The biggest mistake I made when learning vim was using the arrow keys all the time.
I use it because you can build custom behaviors through scripts. You can also run shell commands on your buffer, or highlighted parts of your buffer. So the possibilities for transformation are effectively endless. I like it because once you get through some of the tutorials, your hands never leave the keyboard. You can split the window into multiple views, as well, so you can have a list of compiler output, and there's some integration where you can select warnings or errors that will take you to the offending line of code. Getting fancy with hierarchy views and such gets kind of dodgy, as it's all ASCII and I don't consider it or other more elaborate displays very view space efficient.
Or alternatively it's available within the emacs operating system in which case it is simply [**evil**](http://www.emacswiki.org/emacs/Evil). You lack a soul by that point anyway.
&gt;There's no shame in pulling out gedit from time to time Ha, no.... I've heard that some people use thing's like this for some kind of cool factor, but there's no pull in that for me &gt;pop open a terminal and run the command 'vimtutor' Wow! That's ace, cheers dude :) I'm sure that's far more productive than some of the youtube videos that I've seen &gt;looking up writing a simple .vimrc for yourself Yeah someone else has mentioned that and IDK what it is really, some kind of preferences file I'm guessing though. I'll have to have a look and see what I can do
Ha, IDK enough to filter jokes out yet! In what was would emacs be better than VIM? In what way is it evil? 
Splitting the window up sounds ace... Do they 'snap' to quarters and such? &gt;You can also run shell commands on your buffer Not sure what you mean by this? What's the buffer? I guessed that there would be some kind of shell integration in it... Cheers
Well I'm quite the beginner with vim myself but I like it because of the flexibility of the commands and the speed and fluidity of editing it makes possible. Read a few tutorials on basic editing and you will very soon start to see the power that is under your fingers. 
I've seen this kind of thing before (code posted online, I'm meant to do something with it....) What is this process? What do I need to search to learn how to do something useful with that link? cheers
&gt; have only used gedit, TBH I'm not sure what that has auto wise... Auto formatting is when the editor automatically puts a second {} for you and that kind of thing, isn't it? Never really used gedit, so I don't know. As for my formatting, in my C style, I place braces on the next line. When I type if(, my editor will not only add the additional ), but the {}'s on the following lines, and when I'm done typing in the middle of the ()'s, I hit 'tab', and the cursor jumps to between the braces, with the proper indent. It takes some configuration to get to this point, but I like it.. Its also different for different filetypes.. In xml, when I type an opening tag, it generates the closing tag for me... For me, the 'not my editor' is easy to deal with because my editor is completely different than anyone else's (slickedit). I just fire up vim on someone elses box and use plain old vi commands. I can see that someone who highly mods their vim, when they switch to someone else's vim, they don't feel comfortable because its missing feature xyz...
&gt; Does it handle large projects alright? In terms of multiple files, Vim's only capability is opening side-by-side. I find that GNU Screen + Vim is very helpful for working on larger projects. Basically, you won't have the project management you'll get in a larger IDE, but in some ways that can be a good thing. Instead, you have to depend on your terminal skills. Don't be worried if that sounds daunting; you'll get the hang of it.
Fair enough. Some people do get that mindset (Heck, I get that mindset too sometimes with command-line stuff). It's always worth noting in mind that you can just take things at your own pace. vimtutor is what I started with, it's extremely helpful. It's also cool because it's all inside of vim, so you can test out anything you want inside while you're going along. It doesn't teach you everything, but it puts you at a good starting point so you're not just fumbling around everywhere, and it's also good hands-on stuff. Another recommendation, make [this](https://bitbucket.org/tednaleid/vim-shortcut-wallpaper/raw/tip/vim-shortcuts.png) your wallpaper and make your terminal a bit see-through if you can. Being able to look at this page to navigate is a life-saver and very helpful for learning. You're never going to remember them all right away, but the sooner you start using them to move around the better. I couldn't ever get the hang of it until I made that my wallpaper. In Linux, lots of programs have simple text configuration files, usually called 'rc' files. They reside in your home directory (For me, that's /home/dsman195276). Vim has a file like this, and it's just the file '.vimrc' in that directory. (Note: In Unix, files starting with dots are 'hidden files'. Use ls -a to see them). The .vimrc file (Which you can edit in vim ;) ) is written in 'VimL' which is basically a kinda ugly scripting language built into vim. When vim starts, it will load this file and run the contents, so if you have Ex "map &lt;C-m&gt; P" then every time you hit &lt;C-m&gt; (control+m), it acts as though you typed 'P'. I would recommend this for a simple .vimrc: set nocp set number syntax on noremap &lt;Up&gt; "" noremap! &lt;Up&gt; &lt;Esc&gt; noremap &lt;Down&gt; "" noremap! &lt;Down&gt; &lt;Esc&gt; noremap &lt;Left&gt; "" noremap! &lt;Left&gt; &lt;Esc&gt; noremap &lt;Right&gt; "" noremap! &lt;Right&gt; &lt;Esc&gt; The first line turns off 'vi' compatibility (Don't worry about what that means, but you do want this). The second line turns on line numbers. The third line turns on syntax hilighting. The lines after that disable the arrow keys. And here's some instructions on how to put that into .vimrc using vim (When you enter vim, press all the keys I list on the left: ~$ vim ./.vimrc (Select and copy what I posted) "+p (Paste what you copied into vim) 0 (Move to the beginning of the first line) &lt;C-v&gt; (Hit Control+v. It will enter 'visual block' mode) G (This will move you to the bottom line) h (This will move the cursor one column to the left - You'll see all the leading spaces are highlighted now) x (This deletes everything highlighted, all the spaces) :wq (This writes the file and then quits) That should do it, assuming I got that all correct ;) You'll learn what all that does as you go on. Most of it is fairly easy stuff (Entering visual block mode, and then just using movement commands). :wq and :w are things you'll be using a lot (:wq writes and quits, :w just writes). "+p is a bit of black magic, but it just pastes the contents of the "+" 'register' (Registers in vim are just named locations that hold text basically). "+" is a special register that refers to the system clipboard, which is why that pastes what you copied. 
ok fallback to BASIC mode. probably you need an intro to git or other vcs, but is far from me to give you one here. github happens to host git managed repositories, when you see services like that, start reading the README to see what to do, the common usage of github is, you see the code, read the readme, git clone url , and follow the istructions. VAM in particular helps you managing the vim configuration and extensions, starting plugins based on file type, upgrading them easily and more.
&gt; In terms of multiple files, Vim's only capability is opening side-by-side. That's not even close to true. Vim supports horizontal and vertical splits, tabs, and buffers. It's in fact much *more* flexible than a "new window for every file" type editor.
Emacs is a text editor that is really an implementation of Lisp, which lends itself to easy extension. Modern Emacs is more or less a mini-OS that happens to be able to edit text. There's a mode for Emacs (evil-mode) that has vim modes and keybindings. It's an entirely different editor requiring a different mindset, so don't get confused thinking emacs and vim are remotely similar (or even compatible, tbh).
Text editors don't "do" one language or another. If it's like vim and supports syntax highlighting, all it needs to "do" a language is have a syntax file written for it, and BAM.
There is a concept of the active view, and a split command will divide it into two. You can specify horizontally or vertically and how much (you can move the edge whenever). You then move the active view to which ever view you want, and any commands or editing you do will occur in that window. So that's when you set up that view to do whatever you want it to do. You can do this to any view you like, split views indefinitely. Naturally, you can script this behavior for views that are complex. The view is on a buffer. Vim doesn't keep a file handle open on the file you're editing, it opens, reads, and closes. Most editors work this way. So the contents you're editing is in a buffer in memory. Saving a file is flushing the buffer to the file on disk. I don't know if Vim supports open file handles, otherwise, you could use Vim as a terminal. I use the term buffer because that's what it really is. In most programs, when you're "editing a file", you're really editing a buffer in memory, and not a file right on the hard drive (that would be insanely slow). And Vim uses this term, so I'm reinforcing it. You can also open multiple buffers. Vim doesn't have document tabs, obviously, so if you want to open multiple files, Vim will manage a list of them. You can switch between them in any view you want with a couple command strokes. The shell is your user interface. That could be a command line (like Bash), a windowing system, a graphical user interface (like your desktop), a 3D environment, etc. In this case, you can go to your command line interface and execute commands, using your buffer data as the input to that command. The output of the command will overwrite whatever is highlighted, or get dumped at the cursor position. Sorting is most often what I use it for. I don't know if Vim itself has a sorting feature.
Like I wrote, I spend most of my time reading documentation. In the past I've used VS, Sublime, Eclipse, Geany, Monodevelop, vim etc.. and I noticed I wasn't coding any faster than with notepad++ or gedit.
I write C code for a living and haven't used a text editor other than vim in ages. I'm not at all a power user, but I know enough to make it super helpful. It really doesn't take that long to get used to it and before too long it will be a much faster way to edit text files than anything else. 
&gt; emacs and vim are remotely similar Well, they are the most powerfull text editors out there, they run in a terminal and are mostly used by people with a large beard.
OK now I understand what you're trying to do and I think this code looks OK. Each node would get its own buffer saved in private data and would be mapped to the address userspace requests. Give it a try and see if it works OK.
vi/vim is on every unix/linux machine. Emacs is not an editor but an operating system with an editing function. I am partially disabled, and my fingers will not stretch to do the 3 fingered requirements of attempting to use emacs. No argument that emacs is estensible, but then so is vim. vi/vim is easy enough to use - only about 15 commands to remember to do good work, once you remember that it is a modal editor ie text entry mode or movement/command mode and that the escape key stops editing and goes to movement/command mode.
Yeah, use ed.
&gt; (which you will if you are a Linux user) That isn't necessarily true here in the magical world of 2014! I'm sure most Linux users here on /r/C_Programming do, though. ;)
Try Shawn Biddle's vim videos, they can help you learn vim configuration. https://www.youtube.com/user/sabiddle
When I read this: &gt; It is written by a novice, and is intended for use by a novice. I was pretty damn worried. But the primer looks pretty sharp. 
I wouldn't call it bad practice, some just think procs are getting too cluttered and unstructured. Similar to the complaint about the Windows registry. Sysfs is the newer model. ioctl and mmap are separate file_operations. I'm not sure what you need ioctl for, unless you need to have user space trigger the kernel module to do something. Anyway, I created a char device and registered the fops that I needed. I did all the work in the mmap callback. I used vmalloc instead of kmalloc to allocate my buffer. I needed a big buffer and vmalloc is not guaranteed to be backed by physical pages. I then used vmalloc_to_pfn, and remap_pfn_range and mapped to the to the vma that is provided in the mmap callback. Where do you seem to be failing in the process? 
I posted a pseudo code of what I will try to do at work today, it is a longer post with lots of code samples. Would you look over it and give it your worst? I think it looks ok in principle and it explains much better what I am trying to do :)
Yeah, for sure. If I had done this for a personal project I'd just send ya a snippet of the source. I've got a deadline on Friday so don't think I forgot about you, in case I don't get back to you over the next couple days. If you send something over I'll do my best to point you in the right direction. 
People aren't going g to like this, but I was faster in Emacs in a week than I was in Vim after six months. I absolutely hated having to jump in and out of modes just to move my damn cursor around. Both editors keep your hands on the keyboard, Emacs doesn't make you hit escape (or it's remapping) all the time. Granted, remapping caps lock to control is hella nice.
Haha, don't stress it. I will find a good solution no matter what, maybe I should just have read and thought about it for more than one day, before writing here. I will go to work now too and try it out. No matter how it turns out, I will give feedback here and then probably come back to you for help ;)
Did you read the documentation for libssh that is linked from that page? http://api.libssh.org/master/libssh_tutor_sftp.html
&gt; I've only recently used grep, that seems pretty handy More than you know. Vim even has its own built-in grep-like tool (`:help vimgrep`), because it's just *that important.*
`ed` is *the* [standard text editor](https://www.gnu.org/fun/jokes/ed-msg.html).
Nice... Only just realised that it's got its own help pages!
Cool... That sounds nice to work in auto complete wise. I need to learn how to do the. .vimrc files and stuff.... I still don't know how customise bash and things like that, so there's a lot to learn that's not even programming ha
Ha true... All about installation wizards these days!! I'm learning, but hoping to be able to use it in a productive manner before too long
Cheers man I'll have a look. So these are all called repos? I need to learn how to install repos? Thanks :)
Try out [Visual Studio Express](http://www.visualstudio.com/en-US/products/visual-studio-express-vs). Alternatively, if youre a student you can use [DreamSpark](https://www.dreamspark.com/Product/Product.aspx?productid=72) to grab a full copy of visual studio. 
http://www.bloodshed.net/download.html or if you want to use command line, http://www.mingw.org/
Use code blocks! http://www.codeblocks.org/ It's an ide , but as i remember the compiler works out of the box on windows, it's got mingw bundled with it.
MSVC actually does have a C compiler. Since version 2013 it even can compile ffmpeg which uses some C99 features that won't compile as C++. edit: Also, the current MSVC++ is in fact very close to being fully compliant. They [estimate](http://blogs.msdn.com/b/somasegar/archive/2013/06/28/cpp-conformance-roadmap.aspx) they will make it this year.
C99? Really? Could you remind me of what year it is? 
There is a [newer version](http://orwelldevcpp.blogspot.ae/) of Dev-C++.
Starting from VS 2013, Visual Studio supports C99 which should be more than sufficient.
I didn't actually know about tabs, and now I feel stupid. I have used buffers since almost the beginning of my Vim conversion, and have always loved them in combination with GNU Screen for tabbing. But now there is absolutely no reason for me to use Screen, as Vim tabs have exactly the functionality I was looking for! I've been playing around with programming using tabs for the past few hours, and in combination with buffers it solves so many annoyances. I'm working on a C++ project, and it's so nice to be able to have my header file and implementation split side-by-side in a single tab, and the next tab will be for a different header/implementation split.
Few compilers support C11 anyway (except Pelles C) and OP is developing on Windows, so POSIX is of no use to them.
You need to learn git. Or, at least, *some* version control system. You only have to lose source code once to realize how critical it is.
Pelles C is a nice windows only C only development environment (editor, compiler, linker, project manager, etc) that is free and is most likely the easiest way to get a C compiler installed and working on a Windows system. It is a pretty good compiler afaik however it is not as widely used as GCC for example so does not have as good support from the community. You can install one of the many MinGW distros available. Personally I quite like the build that /u/STL makes available at www.nuwen.net. Installation is as easy as it gets but it is just the command line tools so you will need to learn how they work. It is just generic gcc though so pretty simple to learn. He includes gdb now as well :) Microsoft Visual Studio 2013 Express for Windows Desktop (god what an awful product name!) comes with Microsoft's C/C++ compiler which has a bit of a (well deserved) bad reputation for C support. To be fair it is Microsoft's *C++* compiler. It has much better support for C99 in the very latest version. Personally I would go for gcc. 
Looks nifty. Downloading now - will try it out and see. Thanks!
This is what my university requires first year engineering students to have and learn from. Works very well
Ha yeah man, completely fresh! It's hard because I have no shorthand for anything. So when you say &gt;You need to install git. Then you can clone the repository using `git clone &lt;repo url&gt;` I think : * 1 - Is that sudo apt-get? * 2 - what's a repository? * 3 - why what who where when? So googling 'linux repository' informs me that the repository is the place where information / databases are kept... I don't know what context we're talking about though... Code? System files? Preferences? Programs? So it's all a long process for me at the mo ha cheers
Have you considered [this](http://c.learncodethehardway.org/book/)
Have you checked your local university or community college?
it's pretty much plain c except plan9 things, there's no rc shell involved.
I thought this looked cool-- but then it makes you use a special library that reads the syntax and handles all the hard stuff for you. If I'm gonna build my own language, I wanna build it from the ground up.
&gt; I'm talking about a Git repository. ah OK, cool.... so it creates a directory that's a replication of the on-line directory? That's ace.... Does it work like dropbox? (Is that an awful analogy?) &gt;Since you are brand new to Linux you SHOULD NOT use my files Ha cool... I had a little look through and some of them make sense, the date one for `now` and stuff... &gt;Do some googling and figure out what each is used for Yeah I will do.... fair bit to try and catch up on, sometimes I don't know exactly what it is I'm meant to be doing though, which can make the searching harder. Any chance of some bullet points (to aid search!) * Git Repository * .vimrc file editing and creation (not sure what umbrella this would be under, system configuration?) Cheers though dude! 
That link is broken for me, think you want: http://api.libssh.org/stable/libssh_tutorial.html
Huh. It was working 21&amp;nbsp;hours ago, and apparently it was working on December&amp;nbsp;3, 2012.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Git (software)**](https://en.wikipedia.org/wiki/Git%20(software\)): [](#sfw) --- &gt; &gt;In [software development](https://en.wikipedia.org/wiki/Software_development), __Git__ /É¡Éªt/ is a [distributed revision control](https://en.wikipedia.org/wiki/Distributed_revision_control) and [source code management](https://en.wikipedia.org/wiki/Source_code_management) (SCM) system with an emphasis on speed. Git was initially designed and developed by [Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds) for [Linux kernel](https://en.wikipedia.org/wiki/Linux_kernel) development in 2005. &gt;Every Git [working directory](https://en.wikipedia.org/wiki/Working_directory) is a full-fledged [repository](https://en.wikipedia.org/wiki/Repository_(version_control\)) with complete history and full version tracking capabilities, not dependent on network access or a central server. &gt;Git is [free software](https://en.wikipedia.org/wiki/Free_software) distributed under the terms of the [GNU General Public License](https://en.wikipedia.org/wiki/GNU_General_Public_License) version 2. &gt;==== &gt;[**Image**](https://i.imgur.com/bhm9ln0.png) [^(i)](https://en.wikipedia.org/wiki/File:Git_session.png) --- ^Interesting: [^Cogito ^\(software)](https://en.wikipedia.org/wiki/Cogito_\(software\)) ^| [^Linus ^Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds) ^| [^Comparison ^of ^revision ^control ^software](https://en.wikipedia.org/wiki/Comparison_of_revision_control_software) ^| [^Distributed ^revision ^control](https://en.wikipedia.org/wiki/Distributed_revision_control) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgpijwc) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgpijwc)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If you're in Chicago, check out the University of Chicago. CS15200 is all about C. So are pretty much all of their CS classes. 
The goal is to learn c. The language part of it is just the project to help you learn c. And, you can also start thinking more programming languages in general.
On line 21 it the for should be `for (j=0; string_cur[j] != '\0'; j++) {` you maybe had `for (j=0; j &lt; strlen(string_cur); j++)` there earlier? and the `j &lt;` was a leftover? 
Looks to me like this line is the problem: &gt; for (j=0; j&lt;string_cur[i] != '\0'; j++) { Take a look at at what you're comparing j to.
`else printf("%s%d", string_cur[j], num_letter+1); num_letter = 0; ` you need to surround that else-block in curly brackets edit: indentation of your code shows what you're intending to do, but you are missing the curly brackets which causes num_letter=0; to get executed on every iteration.
Now you need to surround the new if block in curly braces :p edit: Also, you are using i to index string_cur in the for loop, but you should be using j 
Opps :P Done! But yet, still gives me 3 blank lines. Thank you RANDOM STRANGER FOR YOUR HELP THUS FAR!
Did you manage to get everything running fine ?
Sure. The solution assumes that you have an array of inputs that were sanitized (negative numbers removed, all non-integers removed, etc). a is your sanitized input array count_a is the number of elements that made it past sanitization. min = max = a[0]; for (i=1;i&lt;count_a;++i){ if (max &lt; a[i]){ max = a[i]; continue; if (min &gt; a[i]) min = a[i] Then just print min and max. You can set things to the first valid number you got in your input. Does that answer your question?
No, it took another turn. I got another task, which I had to prioritize. Really bummed me out but that is the route the decision makers want to go. Thanks anyways. If I come around to try it, I will message you.
THANKS I FIGURED IT OUT! Thanks for all your help!
What about college lectures on youtube? I learned a lot from [this](https://www.youtube.com/playlist?list=PL6B940F08B9773B9F) series, it starts with transistors and gates and moves up to assembly and the rest is C.
Really nice IDE, I use it with Clang as the compiler.
First - this is a good start! A really quick review: * As you said, this is a little different from what I had in mind in that the user will have to call it like: prettyf("The rest of this text is %kblack until here%C."); This is not bad but I feel like it doesn't abstract the coloring as well as my original idea. First, the word "black" needs to be merged with "%k" if we don't want to have extra spaces. Second, the user must remember to add the reset to the end every time they use the colors. * The first thing I notice is you might be using the [loop-switch sequence anti-pattern](http://en.wikipedia.org/wiki/Loop-switch_sequence). If you're going to use the replace_str function, you really don't need the switch statement. You can just have an array of special characters and call str_replace on each one of them like: char a[] = { 'k', 'K', 'r', 'R', ... }; char *b[] = { PF_BLACK, PF_BLACK_B, PF_RED ... }; for (i = 0; i &lt; sizeof(a); i++) { char replace_this[3] = { '%', 0, 0 }; replace_this[1] = a[i]; replace_str(gen, replace_this, b[i]); } Even this is actually not good (very suboptimal) because it will traverse the string many times. Ideally you can go over the string only once and replace the character you are on. * prettyf should take `const char *` as its first input argument. That const matters and is good practice in applicable situations like this. * I didn't review replace_str since you got it from someone else. I think it would be more useful if you wrote your own version though. This version does have a lot of malloc (partly unavoidable) which can be a slow operation.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Loop-switch sequence**](https://en.wikipedia.org/wiki/Loop-switch%20sequence): [](#sfw) --- &gt; &gt;A __loop-switch sequence__ (also known as the __for-case paradigm__ or Anti-[Duff's Device](https://en.wikipedia.org/wiki/Duff%27s_Device)) is a programming [antipattern](https://en.wikipedia.org/wiki/Antipattern) where a clear set of steps is implemented as a switch-within-a-loop. The loop-switch sequence is a specific derivative of [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code). &gt;It is not necessarily an [antipattern](https://en.wikipedia.org/wiki/Antipattern) to use a switch statement within a loopâ€”it is only considered incorrect when used to model a known sequence of steps. The most common example of the correct use of a switch within a loop is an event handler. In event handler loops, the sequence of events is not known at compile-time, so the repeated switch is both necessary and correct (see [event-driven programming](https://en.wikipedia.org/wiki/Event-driven_programming), [event loop](https://en.wikipedia.org/wiki/Event_loop) and [event-driven finite state machine](https://en.wikipedia.org/wiki/Event-driven_finite_state_machine)). &gt;Note that this is not a performance antipattern, though it may lead to an inconsequential performance penalty due to the lack of an [unrolled loop](https://en.wikipedia.org/wiki/Loop_unwinding). Rather, this is a clarity antipattern, as in any non-trivial example, it is much more difficult to decipher the intent and actual function of the code than the more straightforward refactored solution. &gt; --- ^Interesting: [^Telephone ^exchange](https://en.wikipedia.org/wiki/Telephone_exchange) ^| [^Sun](https://en.wikipedia.org/wiki/Sun) ^| [^Control ^flow](https://en.wikipedia.org/wiki/Control_flow) ^| [^Music ^sequencer](https://en.wikipedia.org/wiki/Music_sequencer) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgpxvad) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgpxvad)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Awesome, thank you! As for your first point, you can call it with something like this: prettyf("i have %R%d%C th%vings %L%s\n", i, "hi") ; So you need only use the format placeholders instead of the word "BLACK", is that what you mean? Or are you referring to having to write "%" in front of the placeholders? Also, a "reset" code *is* appended on the end of each prettyf call. Found that one out the hard way when all of a sudden my prompt was colored! As for the second point, this is awesome information - this is the kind of stuff I never get to learn from just language tutorials. I want to learn more about algorithms and program design at the same time I'm learning how to actually write code to make it work. I'm going to work on this part and get back to you with a smarter implementation! Point three: added and read about why I should use it. Thanks! Finally, point four: you're right. I'm going to tackle this next. 
I'm going through this, while keeping K&amp;R just as a reference: http://c.learncodethehardway.org/book/ I've found it more effective this way.
That's a great reference! I highly recommend jumping over to http://www.reddit.com/r/dailyprogrammer and start doing the challenges in C. You'll learn a ton from work/practice yourself and from reading the examples posted.
This is an awesome answer. The guys at dailyprogrammer work their collective asses off trying to create problems for people to solve. It is an incredible service to the programming community. 
I always recommend picking a tool, finding its source, and making it do something different as a way to start, even if it's trivial and useless. 99% of your programming life is going to be "working on existing code" anyway. 
My usual inspiration are Linux/unix tools. See what you have in /bin , /usr/bin and write your own versions of each and every tool you find there. When you're done you will have written lots of: text processing, file system, network tools, possibly a small shell. Then you move onto something more sophisticated like multithreaded programs, servers, write your own compiler, a calculator. When you start thinking this is getting easy then try to build your own clones of some system libraries. I understand that none of those will be extremely useful but will give you more practice opportunity than anything else. And when you finally come up with your very own project you will have enough experience to keep going.
I am a novice C programmer myself, so you should not take my advice too seriously. My advice would be to learn another programming language or two concurrently, that way you can assess their relative strengths and weaknesses and pick the right tool. It also allows you to realize commonalities and differences. If you learn about programming concepts instead of one specific programming language, you can ask questions like: "How would this concept be implemented in language X", instead of just being aware of how a certain language does things. * For example some systems / libraries are designed around "objects". This is an abstraction that is not directly encoded in the C language but still used. Take for example [glfw](http://www.glfw.org/documentation.html). They have objects declared as GLFWwindow* window; and provide functions with which to manipulate those. A program written by you is not concerned with what GLFWwindow actually is. Behind the scenes there is a struct that holds the state of a GLFWwindow, which is dynamically allocated by glfwCreateWindow in this case. I know this without looking at the source, simply because I recognize the pattern. So if you were to write a library of your own you could consider structuring it by introducing "objects" you want to manipulate. * Things like programming languages are more difficult to implement, but implementations again use patterns more or less independent of the implementation language. You will find that languages like Ocaml or Haskell make your life considerably easier, because they support pattern matching, algebraic data types and are garbage collected (they aquire and release used memory automatically, which is very useful when you are manipulating abstract syntax trees). Just to reiterate the knowledge how to implement a programming language is not really tied to the implementation language, once you understand how to do it in principle the question reduces to a number of subquestions of the form: How do I write a recursive descent parser, how do I represent an abstract syntax tree, how do I represent a symbol table, etc.. * Operating systems are also very complex beasts, but again you can decompose its task in several subtasks that you can consider: For example how do I implement a scheduler. Again all those questions will really turn out to be questions about algorithms rather than a specific programming language. If you want to play with a toy kernel (os), look at http://pdos.csail.mit.edu/6.828/2012/xv6.html . It has excellent documentation and provides for a good reference on how to implement the absolut rudiments. You will find that alot of the really low level details depend actually on the cpu (in this case x86) with plenty of magical constants and conventions that have to be looked up in manuals. * If you have no experience with other programming languages, chances are you will find them more pleasant to use than C. Take a look at Python, read https://mitpress.mit.edu/sicp/, maybe try out Haskell http://learnyouahaskell.com/ or ocaml. Knowing some of those will give you perspective on when it is a good idea to use C. * If you don't already try to install some flavor of Linux or use OSX, outside of the Microsoft Ecosystem of Languages (C#,F# etc.) they provide a much nicer developer environment. 
you should make a writer function writing each element of the struct, the way you do it now makes a literal copy of the pointer instead of the string. Writing structs this way is also a bad practice and non portable. 
Reading/writing structs is not portable. Try Google Protobufs, there's a C library.
Nobody here is actually getting to the real heart of the problem (Writing structs to files aside). What's actually contained in your struct? Here's the memory layout of the struct that you allocated: Human *human char * (malloc(max_char)) char *name = 0x12345678 ------------------&gt; "Alberto" int height = 25 int age = 89 So now, seeing that memory layout, you'll notice right away that the "Alberto" string is actually contained in separate memory (You did do a separate malloc for it didn't you?). Your struct's memory really only contains the pointer to "Alberto", which is just some number telling us where "Alberto" is. When you write the struct to a file, you end-up writing this pointer value, but not the actual string "Alberto". So basically, in your file you only have the stuff on the left, but none of the stuff on the right. Then, when you read in 'human' again, you get that '0x12345678' value in your name pointer, but that pointer points to a location that you no longer have access to (Remember, you did a free(human-&gt;name), and name was at '0x12345678'). So the "Alberto" data is gone because you never actually saved it, just saved it's location. One easy way to fix this is to turn your pointer into an array. For example: typedef struct human { char name[maxlen]; int height; int age } Human; Human *human = malloc(sizeof(Human)); strcpy(human-&gt;name, "Alberto"); human-&gt;height = 25; human-&gt;age = 89; Now the memory layout looks like this: Human *human char name "Alberto" int height; int age; The difference is that the 'name' array is inside the same memory as the struct itself, instead of being located elsewhere. When you write the struct now, it writes out an array of chars 'maxlen' long (Since that's how long the array is). If 'maxlen' is large and your names are short, you'll actually have some significant blank space in the struct. You have to keep in mind that the size of a struct is a compile-time constant. Meaning, the size of every struct in your program is determined at compile time. So if you want a string inside a struct that's not a pointer, it has to have a defined length so the compiler knows how big the struct is. Writing structs isn't a great idea in general, just because it's not an easly writable/readable/extendable format. Whenever you change the struct you break all your files. Noting that, as long as every program that reads this file is compiled by the same compiler, it will work, even if it's 'bad practice'. My point being, I wouldn't worry about it to much if you're just writing a simple toy program like this one, it's not worth getting to crazy, writing and reading the struct directly will work fine as long as your structure doesn't contain any pointers (If it does contain pointers, you'll have to save their contents separate, and that gets a bit more complicated).
DSMan195276 has the right answer, but another thing I noticed is that this: Human *human = malloc(sizeof(Human *)); should actually be this: Human *human = malloc(sizeof(Human)); sizeof(Human *) will actually get you the size of a pointer to a Human, not this size of a Human. You want the latter, since you need enough space to store the struct.
You can't serialize pointers, so what you're trying to do is just fundamentally impossible. You either need to change the struct so that it contains an array instead of a pointer (and suffer with all the problems that brings, including the fact that you have a fixed limit on the length of a name, and the fact that every `Human` requires the maximum amount of memory needed to store the longest possible name, even if most of it is wasted) or you need to abandon the idea of writing a struct directly. You can still serialize variable-length data to disk, you just can't do it with structs. For example, you could use a textual representation where height and age are converted to strings along with the name, and comma separated. It's still possible to use a binary representation if you absolutely must, but it becomes very complicated since you're dealing with variable length records. For instance, you might define your bespoke binary file format as: &lt;one or more of:&gt; &lt;32 bit little-endian integer&gt; &lt;32 bit little-endian integer&gt; &lt;one or more non-null characters terminated by a null&gt; Again, you can't just read that by reading a struct, because structs always have fixed size, and your records are not fixed size. 
Thank you for this detailed answer, it helped me to understand what I was doing wrong with the char* pointer. I'm still interested to know how it could be implemented if the struct had a max_data element which the user could prodive and not a Preprosessor defined constant. That is to say if there was f.x. a Database that had user defined max_data and max_rows or something like that which was used to store N many Humans in a Database (of course all with the same max_data and max_rows). Do you understand where I'm going?
Allright point taken and agreed. The longest name in the english I belive is "Christopher" which is 11 chars and then theres middle names etc. The shorter names like "John" would most likely feel lonley in a 11 char array and thus cause the memory to run out more quickly. Would it the ben better to store the barebone variables in a file instead and have a write/read parser function to do the communicating between the file and the program? 
If you're asking about supporting strings of different length, then typically what you do is keep the length of the string separate from its contents, instead of using a fixed-length array. (That makes it so you either can't use long names like "Ramachandran" or waste a bunch of bytes for short names like "Joe".) If you've absolutely got to/must/can't live without packing it all into a `struct` and writing it directly out in one piece, you might have to do something like struct Human { int height, age; size_t nameLen; char name[]; }; And then when you allocate you do size_t len = strlen(name); Human *human = malloc(sizeof(Human) + len + 1); // ^ extra memory for the string after it human-&gt;height = whatever; human-&gt;age = whateverElse; human-&gt;nameLen = len; memcpy(human-&gt;name, name, len+1); and then you have a single contiguous block of memory with the name attached. You can write it out by using the same length you passed to `malloc` (otherwise the name won't be included). You can `free` it with a single call to `free`, too, which is often convenient. People have differing, typically very strong opinions on whether this sort of thing is a good idea, of course, but it seems to fit the situation you're trying to set up.
On a side note, it doesn't make sense to `malloc()` a fixed-size buffer, unless: a) the buffer is too large for the stack; or b) you're just testing a `struct` with `char*` included. In a real-world situation, if you know your string is limited by `SIZE`, then declared it as `char[SIZE]`, not `char*`.
&gt; Staring &gt; og &gt; rap Oh, this is gonna go well. 
Also: - there's no need to flush a file descriptor before closing it. `fclose()` will flush it for you; - there's no need to use `rewind()` when you've just opened a file for reading. `fopen()` will position the stream at the beginning of the file for you; - the better way to malloc is this: `Human *human = malloc(sizeof *human);`. The operator `sizeof` is evaluated at compile time, so this will never deference an invalid pointer.
Yes that is most certainly a possible solution. The issue I'm faced with now is how to retrieve this block of memory back from the file because I don't know before reading the file how big the name_len var is for each Human block will be. Maybe it is best for now to settle for a prefixed name_size, I don't see one obvious solution to this problem.
select() is one of a number of ways to find out if a descriptor can be read from or written to without freezing the program waiting for data.
nerd4code provided a fairly nice solution for when you have one variable length field. If you're wondering about reading this, you'd actually have to read in sizeof(Human), write that into a Human struct (Just a temporary one on the stack), then read the 'nameLen' value from that temporary variable to figure out how much more data from the file to read (Ex. If the nameLen is 20, then your string is 21 bytes long, so allocate sizeof(Human) + nameLen + 1, copy the temp variable to it, and then read in nameLen + 1 as the name field). It's basically becomes a two-stage reading, where you read the basic parts of the Human struct first, and then use the length to figure out how much more to read. Using length prefixed strings is fairly easy, but it does up the complexity a fair amount (More then you'd guess). The biggest issue is that you can't seek to parts of the file anymore (Ex. If you have 5 Human's in a file, you don't know where the 4th Human starts in the file without reading the first 3, since you need to figure out how long the variable length fields are). Once you get to this point, you're better off considering a more complex file-format that handles these cases better. The biggest issue you face with the way you're doing it now is that every file update requires recreating the entire file instead of just updating part of it. Fixed length strings are definitely the way to go if you can live with them, they make life tons easier.
Really you have between 1 and N file descriptors, one for the listen socket and one for each socket created when you 'accept' a connection. 
in the earlier days it was something which was done all the time, map a structure to a file header and read it in that way and such. It was also a time where compilers didn't align the structure for faster access and your data file wouldn't be read by a computer with a different endian format. I think these are the reasons it's bad practice these days. If you write all the fields out as ascii for example you can be sure you can read it back wherever you are, this saves you the trouble of defining a binary format. e: the size of the structure might not be what you think it is and this is where it goes wrong. Even when wanting a binary format you'll need a writer and reader for it. There are compiler pragma's to do what you mean but i wouldn't teach these things.
Variable length string can also be achieved using [zero length array](http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html). A detailed explanation is [here](http://stackoverflow.com/questions/11733981/what-is-the-purpose-of-a-zero-length-array-in-a-struct).
`malloc` a dummy instance of the struct with no space for `name`, or set it up on the stack/statically. `fread` it, including its string length. (That'll read just the head.) `malloc` an instance with enough extra memory after it, and copy over the struct body. `fread` the string into the `name` field of the `malloc`d struct.
ZLA is a MS/GNU extension AFAIK. Flexible arrays are the C99 version of this.
- Use `gdb` to figure out why your program's hanging---compile with `-g -O0`, run `gdb --args your_shell_program`, `run`, wait until it hangs, then press Ctrl-C and type `bt` (backtrace) to see where you're at. I'm guessing it's the `wait` calls that're the problem. Probably because you're using them wrong. - You `malloc` 100 `char`s for `line` (for some damn reason; try `sysconf(_SC_ARG_MAX)` or `_POSIX_ARG_MAX`) and then `fgets` up to 1024 characters into it, setting yourself up for a spectacular crash. - You `malloc` 50 `char *`s for `command`, without knowing whether that's enough space, and then fill it with `malloc`s of 50 `char`s, without knowing whether any of them is enough. (Try counting first, and this isn't how you should do it anyway.) You then assign into `command`, losing the pointers to your `malloc`ated memory and ensuring a proper memory leak. - Along those same lines, you never `free` anything you `malloc`. - Whoever keeps teaching people to use `strtok` needs to be shot and made into a stew. Don't use it, ever. Especially here, since you're just using it as a glorified `strchr`. - What happens if `fgets` doesn't finish the line it's reading? - Your `if`/`else if` structure gets pretty crazy. It's probably best to `continue` or issue a function call here and there, and not have to nest out that deeply. - You have a `while(1)` loop on line 45 that uses `i` but never does anything to update it. Any time you have a loop variable like that, you should probably be using a `for`. (A "forever" loop can be just `for(;;)`, also.) As it is, this loop is borked. - I see you calling `exit(o)`. Do not make variables named `o` or `O` (I don't even see where `o` is declared; does this compile?), and in fact `call_func` should be named something proper and return `int` so that you don't have to `exit` from it. `exit` and `abort` should be reserved only for major error conditions where you can't return an error code and exit the program cleanly. If you intended to `exit(0)` (zero, not `o`), well, you shouldn't've in those circumstances anyway because 0 as an exit code indicates that everything is peachy-keen. `exit(127)` is a typical action for inability to `exec`. - What if `fork` doesn't succeed? What if `system` doesn't succeed? (Cheating, BTW; `system` passes off your command line to a shell. If you're using `system`, there's absolutely no reason for you to be doing all this other work. Just `fgets` and hand it off.) - You allocate `argb` arrays of 20 elements, then do nothing with 17 of them and ensure that only one command-line argument will ever get passed through. Heaven help the person who wants to `ls -lh dir1 dir2 dir3`. - You're using `wait` wrong. The value you pass in will receive the status, and won't be used otherwise. You almost certainly want `waitpid` or `waitid`. Look up the things you're using before using them. - `errno` is a delicate variable which will be overwritten by just about any C function call. You need to check `errno` right after whatever function call sets it, and you should only check it if that function call indicates an error status. (There are even some functions where you have to set `errno=0` before the call, so you're sure that `errno`'s value came from that call and not somewhere else.) Just checking it arbitrarily at the end of a loop is not a good idea, especially because it could have any old value if nothing encountered an error. - You `dup2` but don't close one of the original FDs. This means that the called process will have an extra file descriptor hanging around. (Once you move `pfds[1]` to stdout or stdin, close it.) - You *really* need to learn how to deal with strings. In fact, I'd wager you'd benefit much more from writing your own string-handling routines than from pfutzing around with anything the standard library gives you beyond `strlen`, `strchr`, `strcmp`, or `memcpy`. For example, you could use functions like char *findNonWhitespace(char *str) { for(; *str &lt;= ' '; str++) // or use isspace if(!*str) return NULL; return str; } char *findWhitespace(char *str) { for(; *str &gt; ' '; str++) if(!*str) return NULL; return str; } to help you find argument boundaries and count them. You can also terminate command-line arguments in-place by setting things that would otherwise be spaces to `'\0'`. - You don't need to `malloc` so much---assuming it's big enough to hole the entire command line, your argument pointers should point into your line buffer, not into a separate buffer for each argument. This means that you might have a `malloc`/`realloc` for your line-buffer, and you might have a `malloc`/`realloc` for your `argv` buffer. That's it, no more needed. Also, remember to `free` anything you `malloc`. - You need to separate out commands into an array, so that you don't have to write a special `strcmp` case for each. Give each one its own function that returns `int` and takes `int argc, char **argv` just like `main`; that way, you can deal with them just like any other command. E.g., static int cd_action(int argc, char **argv); ... static const struct builtin { const char *name; int (*action)(int argc, char **argv); } BUILTINS[] = { {"cd", cd_action}, ... }; enum {NR_BUILTINS = sizeof(BUILTINS)/sizeof(BUILTINS[0])}; ... for(i=found=0; i&lt;NR_BUILTINS; i++) if(!strcmp(argv[0], BUILTINS[i].name)) { rv = BUILTINS[i].action(argc, argv); found = 1; break; } This lets each action handle its own arguments, check them separately, give help separately, etc. without having to be in a giant, all-encompassing `if`. - You need to separate out command processing from piping and `exec`ing, by placing things into appropriate functions. Find the next `|` operator or end-of-line, split up the command up to that point, fork &amp; exec, and repeat until you're out of stuff to do. - Check every return value from every function call you make. Quite a few of these functions you're using can fail, and if they do that you'll be caught with your pants down and crash, overwrite your data accidentally, etc. Some of these functions can succeed, but return things you aren't expecting---`wait`, for example, has a whole bunch of macros that tell you *why* it returned (`WIFEXITED`, `WIFSTOPPED`, etc.) which may not be because your child process exited.
select() is a non-blocking multiplexer. You can use it for accept() (by including your listening socket in the list), and when you have connected peers, you can keep on using it to read() and write() data to your peers (by adding each of your connected sockets to the same list).
Thanks for your advice!
Usually you will want to scan a whole line of input. If you only want a single character, look at `getc/getchar`
Thank you so much! It works now
Am I alone in lamenting that /r/C_Programming is turning into /r/learnprogramming? Or am I misunderstanding the purpose of this subreddit? Forgive me OP, this isn't a dig at you, but looking at the list of topics currently active here, everything seems to be from students just starting the language. I'm sure there used to be advanced topics before...
It can be loaded into an area that is actually read-only. For example, one device I work on, the CODE pages stay in Flash and the DATA gets loaded into RAM. The string literals are in the code page, so you couldn't write them even if you tried. It's important for security reasons that the CODE not be writeable. The device has a lot more Flash than it does RAM, so the more you can put into the code area the better. Sharing literals also saves space, which used to be at more of a premium than it is now. But it still saves money if I can keep my program down to 3x 64K code pages instead of 4x, for example; when you have to do a remote software update with 10,000 terminals dialling in via 1200 modem, this really makes a diffference.
Or `memcpy(&amp;current, &amp;currentDen, sizeof current)` , assuming that `currentDen` is an array.
As crackez alluded to, really your best option is to wrap the array in a struct. Structs are copyable; arrays are not. typedef struct { double content[12][12]; } Den; Den func( Den currentDen ) { Den current = currentDen; ... return current; } You have the option of passing the arguments by pointer if you want pass-by-reference semantics , instead of making a copy. The return value has to be a value, but you can "return" via an extra parameter instead if that suits better.
There is also the Embarcadero compiler. bcc64.exe is up to date with C++11, although bcc32 lags behind (The 64bit is nearly a complete rewrite with the "clang" front end, AFAIK). There is a free edition of C++Builder .
The problem is the fact that many noobs start out learning C (which is a very good thing), and we are the community that (theoretically) is all about C programming. So I think the questions are okay. There are still intermediate pointer and referencing questions and advanced theory discussions every day on this subreddit too. We seem to run the gambit.
It would yield the same result.
I would recommend looking into another function for reading input. Use of scanf makes your programs vulnerable to buffer overruns because it doesn't check that the bounds of the input are less than that bounds of the buffer it stores to. I would recommend using fgets as a safer alternative; after reading in a line with it you can use sscanf for formatted input from the string.
&gt; Use of scanf makes your programs vulnerable to buffer overruns because it doesn't check that the bounds of the input are less than that bounds of the buffer it stores to. That's an overly broad and undeservedly ominous statement. Specifiers such as `%c` and `%d` are perfectly safe. Yes, there is a danger of buffer overruns if you use the `%s` specifier improperly, but `scanf` allows specifiers such as `%255s` to specify the size of the buffer.
It's easy to write a loop like `while (1) { c = getchar(); if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') break; }`
I think you meant "gamut", but good comment nonetheless! ^(Sorry to be that guy...)
Same thing with /r/hacking 
It's just as easy to replace `c = getchar()` with `scanf("%c", &amp;c)`.
Dammit Jim, I'm a programmer not an English Professor! No, in all seriousness, thanks for the fix. :p
The only problem I see in your code is that the while loop will be infinite as it is right now. input is != NULL, and nothing changes that, so it will never end. Removing that while makes it work with no problems in my system.
I would just read and classify a character at a time. What if you're given more than 50 characters? Also, you have all non-uppercase characters counting as lower case... Your runtime error is caused by giving one of the isfoo functions a value out of range of an 8 bit character. Probably garbage in the input array when given less than 50 characters since you scan the entire thing, not just what was filled in by fgets().
I don't understand your final paragraph, about what is causing the runtime error. Also I am not able to read and classify a character at a time. How would I be able to count words then?
Thank you for the help. So I think I need the array to be just 1 character longer then whatever the user has inputted. How can I do that though because I wont know what the user inputted till it is entered?
Essentially what this comes down to is I have not been taught how to create an array where I do not know what is going in it, therefore I do not know its size. It's size could be anything, who knows how much the user will enter? I don't believe I have been taught that.
It's pretty difficult to read your code here, please see formatting help (specifically, 4 spaces = code) or use a pastebin, and explain what your problem is. Simply input output isn't intuitive. 
 isupper(input[i]) ? total_upper++ : total_lower++; Trick questions: Is a number upper or lowercase? What about punctuation? 
Coding, I would think.
I echo your sentiments. I have absolutely no idea why he would bother with this junk instead of just making all `Obj *` live in a file-scope stack that the GC runs over, and the functions use `Obj **` to point into that stack. Also perplexed as to why he used `void *` instead of just using `Obj *`. It just introduces more non-portability for no reason. The sentinel value `(void *)-1` is unnecessary non-portability, he could have instead made the first or second entries of the table be a length count. **edit:** I think I figured it out; by using this structure his faux-stack gets its memory taken from the C stack as needed, as opposed to my suggestion which would require dynamic allocation or an object limit. There's pros and cons to each approach (the biggest con being that since there is no stack overflow checking, his version cannot do anything to mitigate the effect of a stack overflow). 
Personally I would educate myself such that I knew the fundamentals of pointers, structures, memory allocation and file and memory storage. But that's just me.
Sure :) I enjoyed figuring it out, it's actually a pretty neat little algorithm (sans the horrible code).
You read "some number" of characters with fgets(). The 2nd value passed presumably limits that to a maximum of 51 but there is no minimum specified or queried. You then check 50 characters regardless of what happened during the fgets() call. The first bytes will contain the characters typed in. The rest; any old garbage. Edit: Learn to love printf debugging. You could have begun each iteration of the for loop with print("%i: %c.\n", i, input[i]) and seen where it was going wrong (alternatively use a fancy debugger with breakpoints and watches and things).
That can only allocate within a function though; I was thinking of having a single bloc of memory holding all the Obj* pointers. Obviously this can't be in the C stack. I was pretty sure his code broke aliasing rules (but I can't drum up the enthusiasm to go back and double check it now and have to look at that again)
The catch is that your method won't work for the GC's purposes. When the function returns your Obj * will still exist in your external memory, and so you need to either free them or mark them when you leave the function. It can be done, but it's a much more hands-on GC then this is. By putting it on the stack you avoid those problems and have automatic clean-up at the cost of stack-space. I can't say I like it, but it is a pretty cool solution for this type of GC. Honestly, you'd probably just want to put in a different GC and avoid this entire issue. He definitely had some iffy spots but I think he was ok. There's lots of void * stuff going on so it's kinda hard to tell, but I don't think he ever dereferences a pointer as a different type of pointer, which is the important part.
It depends on how your teacher's style but what was most helpful to me was to "break things." Try to break printf, or structs, get a segfault with malloc, etc. After getting better scores I remembered what a physics professor told me a while ago: "There's this idea in Physics that you don't really know a phenomena until you know where it break down." I think that's true of programming and CS generally too. Good luck!
Implement some data structures and algorithms. Doubly linked list, binary tree, binary search are some easy ones that come to mind.
Study!
I'm not sure how your exams are done but one trouble I had was writing out the code on paper. I would suggest doing at least a couple problems written out instead of typed. 
Are you passing a NULL to one of your test functions? input[i] == 0 should probably be a test somewhere in your code.
Write a few code out by hand. Look at the question and write it out by hand . And code / compile it on a PC later. This will show you where you make your syntax errors and what part of logic doesn't make any sense. 
You don't need arrays at all. Simple get one character at a time: char ch = fgetc(stdin); if (is_alpha(ch)) .... Also looks like you'll need to revisit your logic. You're counting the number of capital letters, not words per your description. For that you'll need to track state and look for spaces, newlines or tabs for incrementing your word counters.
The thing that worked for me is to try to solve some old exams by using pen and paper because it can feel so much harder then typing it on the computer.
The final strcpy call finishes copying the string. Your are missing exactly what p and r point to during execution (what does "pointer arithmetic" really achieve?). Run the algorithm in your head (or on paper) for `replace_str('XYZ', 'Y', 'A')` You can step in gdb like so : $ gdb ./a.out gdb&gt; break main.c:20 gdb&gt; r GDB : breakpoint hit at main.c line 20 gdb&gt; print p gdb&gt; step Another good way to understand a simple run is to output one line via printf for each loop iteration (with all pointers etc.). For example: `printf("%p %p\n", p, r);`
&gt; At this point in the code, isn't "r" the complete string? No. Only the portion of the string up to the end of the last match of `old` has been copied. The "tail" of any trailing text with no matches in it still remains to be copied. In the case where there are no matches, that's the whole string, as the loop did no copying at all. &gt; I wasn't able to find a way I would have been able to do that. Is that possible? Of course it's possible. Are you familiar with how to set breakpoints and/or watchpoints, and how to inspect data? You might be stymied by the fact that the string being built-up is not null terminated until the very end when `strcpy()` is called after the loop completes, but you can work around that by casting a pointer to an array of char of some length to limit the length printed. Edit: as to simplifying, I'd probably rewrite this: retlen = p - str + strlen(p) + count * (newlen - oldlen); as retlen = strlen(str) + count * (newlen - oldlen);
Wow, that wiki page is pure PR. Do you feel it's better than clang at analysis and such ? That's what I use normally, and pretty happy with it
&gt; Now I learnt that when we pass a pointer we have to prefix it with an ampersand like so You learned wrong. The `&amp;` is the address-of operator and it is used to create a pointer to something. But your `mypoint` variable is *already* a pointer to int (type `int *`), and taking the address of a pointer to int yields a pointer to a pointer to an int (type `int **`), which is emphatically *NOT* what you want. It just so happens that any pointer type can be implicitly converted to a pointer to void (type `void *`), which is the type of argument that `free()` takes. (Note: you should never declare `free()` yourself. That's the job of `&lt;stdlib.h&gt;`. Get rid of that.) That means the call will compile, but it's completely and totally wrong, and it's going to invoke undefined behavior. You should write just `free(mypoint);`. `mystring` is also already a pointer to char -- its type is `char *`. Taking its address would yield a variable of type pointer to pointer to char (`char **`), which is *not* what you want. The `%s` format specifier wants a pointer to char, and that's what `mystring` is, so you can pass it without the `&amp;` in front. `regex` is not a pointer, it has type `regex_t`. The first argument to `regcomp()` must be a value of type `regex_t *` (pointer to `regex_t`), so you must use `&amp;` here to create such a pointer. 
u/Rhomboid already clear all the issues. I'll write your code in a simpler way so you might understand it better : /* your are not using argc &amp; argv, so why use that definition of main ? */ int main() { /* get used to this way of declaring, ret is an int, mypoint is a pointer */ int ret, *mypoint; char *mystring = "Hello there!"; regex_t regex, *regex_ptr; mypoint = malloc(sizeof(int)*10); free(mypoint); printf("I said: %s\n", mystring); /* regex needs to be initialized before use, regex_ptr needs to be allocated &amp; initialized before */ ret = regcomp(&amp;regex, "\"stream\":null"); ret = regcomp(regex_ptr, "\"stream\":null"); }
The function declaration is there just as a point, not actual code ;) OK That helps quite a lot but what about this example. myfunc(int *first, int *second) { return *first + *second } int main(int agrc, char **argv) { int *mypoint = 10; int *secpoint = 11; int result = 0; result = myfunc(&amp;mypoint, &amp;secpoint); } This is how all the tutorials show pointers being passed, with the ampersand. I understand ampersand is take-address-of and '*' is dereference (Give me the value pointed at). Without either of these what is a lone pointer? Thanks for the quick reply. 
OK, I need to explain this is not actual code as such. Just something I whipped up with comments as an example. So there is no need to fix the code itself ;) Also the two examples of regcomp() were very useful, thanks.
No, that's completely bogus. You declare `mypoint` and `secpoint` as pointers to int, and you initialize them to point to totally invalid locations -- `10` and `11` are not valid addresses. Then you take their addresses, creating values of type `int **`, but your function wants values of type `int *`. This is how it would be written: myfunc(int *first, int *second) { return *first + *second; } int main(int agrc, char **argv) { int mypoint = 10, secpoint = 11; int result = myfunc(&amp;mypoint, &amp;secpoint); } Or: myfunc(int *first, int *second) { return *first + *second; } int main(int agrc, char **argv) { int mypoint = 10, *p1 = &amp;mypoint, secpoint = 11, *p2 = &amp;secpoint; int result = myfunc(p1, p2); } Again, you only need the ampersand if you need to create a pointer where one does not already exist, or where you need to add another layer of indirection. That's not always going to be the case, so you need to completely flush from your mind this idea that pointers are always passed with `&amp;`. It always depends.
Thank you so much! You really have no idea how long this concept has bugged me, and with your examples and /u/studioidefix I finally understand it :D Enjoy the Gold :)
A pointer stores an address in memory. An address is just some numbers representing a specific location in the memory. You can see it for yourself: int a = 22; printf("a's address: %d", &amp;a); Notice that the printf above will not print '22', but some other number. This "other number" is the address where the value '22' is stored in memory. You can also do it in another way: int a = 22; int* pa = &amp;a; printf("a's address: %d", pa); Disclaimer: The snippets does not show the best way of printing an address, but they will suffice for edification purposes.
I evaluated it for a previous employer on a small custom OS (~100kloc of C) around 2010. It was pretty good at detecting possible null pointer dereferenceing, possible memory leaks, and I generally liked it. Another engineer had evaluated coverity a few months before and when we compared notes it seemed like they had similar performance.
I think you're still slightly confused about assignment. Note this : int *ptr = 10; int *ptr; *ptr = 10; Have completely different meanings. 
The main problem you have here is that you're implicitly rounding integers when you're doing floating point math. For example: float quotient2 = b / 10; What the compiler sees is (int) divided by (int), so it does a normal int division. It doesn't care that you're trying to store the result in a float, by then it's already been truncated. So you would have to explicitly cast it: float quotient2 = (float)b / 10; You've also got some problems with your math. That line should be dividing remainder1 by 10, because you want to find the difference between the quotient and the roundoff. Even better, you should use the modulo operator, %, which will simplify things a lot. remainder1 = dollar % 20; Tada! Much simpler.
I don't think arrays are one of the tools to use at this point in the lesson.
my bad, haven't read that book myself, assumed chapter two would have arrays introduced already
Could you please give some links. I'm curious what clang offers here.
The [Clang static analyzer](http://clang-analyzer.llvm.org/index.html) and [what it can check](http://clang-analyzer.llvm.org/available_checks.html).
Yeah that was my initial thought because I know programming for matlab but I didn't learn about arrays yet. That solution works very well though, thanks.
Yes you are correct. By fixing the problem with quotient2 using b instead of remainder1, it fixes both problems because it is now dividing an actual float by 10. Nice catch, thanks a lot. For using modulo, is there any way to get decimal point precision? It doesn't seem to let me use floats, which means I wouldn't be able to find cents that way. I.e if I enter dollar as 67.50, it gives a remainder of 7 instead of 7.50
I like to use clang and valgrind as well.
The modulo operator isn't defined for floats. I would probably just convert cents to an integer: int cents = (dollar - (int)dollar)*100; And then use modulo as normal.
&gt; No. Only the portion of the string up to the end of the last match of old has been copied. The "tail" of any trailing text with no matches in it still remains to be copied. In the case where there are no matches, that's the whole string, as the loop did no copying at all. Ah, understood! Duh. &gt; Of course it's possible. Are you familiar with how to set breakpoints and/or watchpoints, and how to inspect data? I wasn't, and I guess I did a poor time looking. /u/mixblast 's tips got me started. I also thought that ```retlen = p - str``` line was a bit more verbose than it had to be. Thank you for your help!
Er... Could you explain the difference?â‡
Hint %s is the wrong format to use when printing the address of a **p**ointer.
Okay so you seem to be aware that you are aware that you are slipping the last element therefore you have that if statement. What you are actually printing in that print statement is wrong though, sp-&gt;head points to the first element so you will be printing that out and not the element that your while loop misses. See if you can fix it with my and raevnos's advice.
For part b) we must follow the linked list until next is NULL (NULL being most commonly 0x00000000 ). So we analyse the memory layout and we see that the address + 1's value is the address of the next element in the list. We start at 0x..1000 (given) we look at 0x..1001 value which has the address of the next element and we follow that to 0x...30000 and so on until we get to the final element in the list with value.... ?
so I'm thinking right now to not skip the last element to have this void print (struct StringList* head){ struct StringList* sp = Head; while ((sp-&gt;next)-&gt;next != NULL){ printf( "value: %d", &amp;sp-&gt;value); }
No need to reference anything. Just %p, sp-&gt;value should do it. 
6a - Solution void printListAddress(struct StringList *list) { if(!list) { return; } printf("%p\n", list-&gt;value); if(list-&gt;next) { printListAddress(list-&gt;next); } } This function prints the current address of value and then calls itself sending it the address of the next pointer. Once next = NULL, all the function calls exit backwards and you return to where you first called the function. non-recursive version: void printListAddress(struct StringList *list) { for(struct StringList *temp = list; temp; temp = temp-&gt;next) { printf("%p\n", temp-&gt;value); } } 
The function declarations in the library are going to be riddled with void pointers and function pointers. Looking at it will only confuse you until you're more familiar with those concepts. For now, scanf requires variables be referenced with &amp;, but the %s already knows it is a pointer, so when dealing with strings, you use no &amp;. In printf, you never have to use &amp;. If you want to print an address, use %p. if you make a function and you need to pass an array or list to it, using a * before your array or list name in the function header will allow you to be able to pass arguments with a &amp; which passes them by reference. Basically, anytime you need to pass an address, you have to dereference the item in your function header one extra time first. This may not make sense, but that's just the penalty of using C.
Use heaps. It will teach you all of those skills.
(a) does say to print the *address* of value, not the address *in* value, so &amp;sp-&gt;value is what is requested. It also says that Head is a StringList*, but the second page (with the memory dump) apparently wants you to treat Head as a StringList which is only used for its next member (if you treat the second page as having Head a pointer, you get stuck without the relevant memory shown).
 int *ptr = 10 makes ptr to the address 0x10 in memory int *ptr; *ptr = 10; stores 10 in the address pointed to by ptr (please note ptr was used initialized in this example, this is wrong and purely for the sake of the example) This is because the *(indirection) operator is used to dereference the pointer. However when used in a definition/declaration the * is part of declaration/definition(used to indicate a pointer) and not an operator
&gt; address of a pointer. Now I'm confused. Is OP supposed to print the address of the string (`value`) or the address of the pointer that points to the string?
Just wanted to give you a comment, in addition to an upvote for opening me up to looking at things from the other perspective. I think looking at problems in different ways is one of the best ways to solve them.
Yeah I used your/his method, but I multiplied everything by 100 to remove the decimals to do the cents and bills in one loop, and made an array of strings of each bill and coin name to print out. Works well now :)
Have you tried compiling and running the code in question?
Honest question: why would someone use Pelles C rather than MinGW or Clang? The latter are open source and, I would bet, produce better output. 
If you're looking for a way to read strings on stdin, use scanf() or gets().
The reason that your program is looping is that scanf is not consuming the input. You are telling it to find an integer with %d. If you type a number, scanf sees that it matches the "%d" and removes it from the input. However, if you type an "A", scanf sees that it does not match "%d" and stops reading the input *without* removing it. In other words, scanf stops scanning when the input does not match its format string. fgets is more what you are looking for. This will read a whole line of text, which can then be checked to see if it contains the password. fgets also will read the "enter" character as a newline ("\n"), so you will need to add that to your check, too. #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main () { char password[64]; int accepted; printf ("Please Enter the Password:\n"); accepted = 0; while (!accepted) { fgets (password, sizeof(password), stdin); if (strcmp (password, "28\n") == 0) { printf ("Correct Password!\n"); accepted = 1; } else { printf ("Incorrect Password. Please try again.\n"); } } /* Other actions here */ return 0; } 
So, it has to do with how the scanf() function that you're using to get input with works. Behind scanf() and getchar() is a common 'stream' called 'stdin' (The standard-in, you used it once directly in your rewind() call). There's also standard-out, which is what putchar and printf and etc. use, and also standard-error which acts a lot like standard-out (It's meant for error messages, getting into it would take us off-topic). Now, I mentioned that stdin is like a 'stream'. 'stream' is a somewhat more technical term in computing, but the basic idea is there is a flow of data from one side to the other (Ex. Streaming a movie, or streaming audio, etc.). When dealing with stdin, one side is (generally) your keyboard, and the other side is your program. When you use scanf(), it reads the data from this stream and matches it against the string you provide it with (Ex. It matches %d with data that looks like a number, and then return it to you). When data can't be matched though, it's simply left on the stream. Functions like scanf() are not guaranteed to actually assign a new value, instead, scanf() actually returns the number of values it actually assigned. This example should clear it up a bit: Iteration 1: stdin: empty scanf("%d", &amp;a) is called -&gt; is waiting for input Iteration 3: stdin: "1234\n" (We typed '1234' and then hit the enter key) scanf sees the '1234' and recognizes it as an integer number. It takes the '1234' off of stdin, makes it into the integer value of 1234 and assigns 'a' to that value. scanf is done processing input returns the value '1' signifying that it read one value from stdin (The integer). Iteration 4: stdin: "" (empty) a == 1234 (scanf returned) 'a' doesn't equal 28, so the loop starts. Iteration 5: (Loop 1) stdin: "" (still empty) scanf("%d", &amp;a) is called. scanf is waiting for input on stdin Iteration 6: (Loop 1) stdin: "asdf\n" (We typed some random characters and then hit enter) scanf says "Woah, that's not a number, and we're supposed to be getting a number! Abort!!!" scanf runs away, leaves stdin as it is, and returns 0 signifying that no values were assigned. Iteration 7: (Loop 1) stdin: "asdf\n" (Still there.) scanf returned, we loop back. 'a' still has it's original value from before the scanf call (1234) so the loop test fails since a != 28. we run the printf statement again Iteration 8: (Loop 2) stdin: "asdf\n" (Still there...) scanf("%d", &amp;a) is called. It then immediately sees the "asdf\n" that's still in stdin. scanf says "Woah, that's not a number, and we're supposed to be getting a number! Abort!!!" scanf runs away, leaves stdin as it is, and returns 0 signifying that no values were assigned. Iteration 9: (Loop 2) stdin: "asdf\n" (Still there.....) scanf returned, we loop back. 'a' still has original value (1234). a != 28 so we loop and run the printf ... As you can tell, that pattern will keep going till infinity, the reason being that when scanf fails it leaves the characters it failed at in stdin. It's possible to fix this, you'll note I explicitly mentioned the return value of scanf. scanf is defined like this: int scanf(const char *, ...) You'll note that while you've been ignoring the return value of scanf (And it's valid to do that) it does in-fact return an int value. So all you have to do in this case is check the return value of scanf, and if it's not 1 then clear the line they entered into stdin before you call scanf again (So whatever it choked on in stdin isn't left there) By line, I mean "characters up to and including the \n character". There isn't any standard library function to do this for you, but it's pretty easy to write your own function to do it. Keep in mind, functions like getchar() will remove a character from stdin for you, so if you just keep calling a function like that until it returns \n then it'll work. I'll leave that full solution up to you, I can provide hints/assistance if wanted.
Thanks a lot for taking the time to type out the explanation. At first I was a little confused, but after reading it over a few times, I think I understand it for the most part now. When scanf is given a value it can't use, it skips processing it, and in my case, the loop would start again using whatever standard-in value was in memory. So until I clear the standard-in, the loop would keep repeating. I took your advice I tried adding a getchar(); function, and it stopped the infinite loop! I added it like this: printf ("The password is incorrect...\n"); getchar(); scanf("%d", &amp;a); However, the printf function seems to repeat for each letter inputted. For example, if I typed "asdf" the printf function would repeat 4 times. Is there something I could do to stop that?
No problem :) And yes you can fix it, you actually already almost answered your own question ;) If you just read one character at a time, then you need to loop for every character until standard-in is actually cleared. However, if you just loop getchar() by itself then you you won't keep running the printf() every loop. Every scanf will end reading when it hits a '\n', so you can just loop getchar() until it either returns EOF or '\n' (EOF meaning standard-in is empty). Something like this: int c; while ((c = getchar()) != EOF, c != '\n')) ; That's kinda ugly though, you could also do something like this: int c; do { c = getchar(); } while (c != EOF &amp;&amp; c != '\n'); Noting that, just doing this all the time isn't optimal. A better solution is to only do it when scanf reports it didn't actually read your integer (So, it returns 0 instead of one). So you could do this: if (scanf("%d", &amp;a) != 1) { int c; do { c = getchar(); } while (c != EOF &amp;&amp; c != '\n'); } I think that should do it.
âŠ™â–ƒâŠ™
I'm surprised. You had quite the list of those faces. 
That's actually what I can't get passed! I've been looking through my books and previous code and I guess I'm just missing it. Anyways, thanks for the comment, as it did confirm what I thought was wrong.
It's just a bot that I'm testing out.
STAMP_COST is a constant, it's value is defined as 0.37 and it cannot be changed. You are multiplying it by number, and then storing the result of that multiplication where? You need it to be: sum = STAMP_COST * (float)number; the (float) flag before number is called the cast. It treats number as if it is a float even though it's an int. It may not be necessary here, but it's a good habit to get into especially when you use division. Basically, you have to store the value of your multiplication somewhere, which is what float result is for. Then you can print result and you'll have your answer. That would look like: printf("You need %.2f for those stamps.\n", sum); // Note here, %.2f means it will print a float // value, and with only 2 digits after the decimal. // Also the "sum" has to go within the parenthesis as I've shown. Hope that helps!
Okay here it is thanks for the input guys! #include &lt;stdio.h&gt; #define STAMP_COST 0.37 int main() { int number; float sum; printf("Input the number of envelopes you need stamps for.\n"); scanf("%d", &amp;number); sum = STAMP_COST * number; printf("You need $%.2f for those stamps.\n", sum); fflush(stdin); /* clear input area so you can pause */ printf("Press any key to exit program."); getchar(); /* force the computer to pause until you press a key on the keyboard */ return 0; }
Wouldn't it be better to use a string instead? Wrote one with some different ideas that may help you. Tested and the following code compiles and executes with no errors. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define PW_MAX_SIZE 12 // We use password defined here, so you only need to update this // one place to change it throughout the program. #define PASSWORD "28" int main() { char a[PW_MAX_SIZE]; printf("Please Enter the Password: \n"); scanf("%s", a); // You don't need &amp; when scanning a string with %s flag. // strcmp compares 2 strings, and returns '0' if they are equal. while (strcmp(a, PASSWORD) != 0) { printf("Incorrect Password. Please try again.\n"); scanf("%s", a); } // You don't currently need a IF statement, as it cannot exit the // above loop unless the condition is true. printf("Correct Password!\n"); // rewind is not necessary for stdin. getchar(); return 0; }
Why are you trying to replace it with anything at all?
You don't need to remove any characters. Just don't print the vowels in the first place.
Sounds like you're making this harder for yourself than it is. You don't need to read in the whole input and then process it. It you can just process each input character at a time. Read a character with `getchar`, check if it's a vowel, and if it's not, use `putchar`.
http://i.imgur.com/J8K3L.jpg
Looks good. Just a small thing that might be useful in the future. By setting stamp cost to 0.37, it will become a double when it is used in code which is really a lot larger than you need. I recommend using 0.37f ... this will make it a float. For this program it doesn't matter, but if you ever start programming on embedded hardware, things like this will bite you because the performance can be a problem. It's a good habit in C to think about how everything will be treated and be explicit.
 #include &lt;unistd.h&gt; main() { char *args[] = { "/bin/bash", "-c", "sed 's/[AEIOUaeiou]//g'", NULL }; execv("/bin/bash", args); }
Spoiler Alert: #include &lt;stdio.h&gt; /* for getchar() and putchar() */ #include &lt;ctype.h&gt; /* for tolower() */ #include &lt;stdlib.h&gt; /* for exit() */ int main(int argc, char *argv[]) { int c; while ((c = getchar()) != EOF) { switch (tolower(c)) { case 'a': case 'e': case 'i': case 'o': case 'u': break; default: putchar(c); } } exit(0); } 
Thanks for your reply. I added the "if" command inside the loop. When I tried using your bottom suggestion, I would have to type numbers in twice for the program to respond. I ended up changing the if (scanf("%d", &amp;a) != 1) to if (a != 28), and everything seems to be working fine now. Anyway, I learned a lot while editing the code and looking at comments here. I didn't know how standard-in and scanf worked before, but now I have a better understanding. I just started taking C programming and computer science classes, so I'm grateful for people helping a total beginner like me. 
Thanks for the comment. I just started taking C programming classes this week, and all I have learned so far are the basics (Hello World! using printf and \n). I was reading some about strings online, but didn't understand them yet. I'll look into using something like that. 
As everyone here has pointed out, you shouldn't be trying to do it this way. However, for future reference, to remove an element of an array (for example, to remove a `char` from a string, because a string is an array of `char`), you don't *replace* that element with anythingâ€”you *shift* all the elements after it one place to the left. Because of all the necessary shifting, it's inefficient to insert and remove items from the middle of an array. If you need to be inserting and removing things, you shouldn't be using an array; you should be using something like a linked list.
Thanks for the comment. I'm still a total beginner to C. I still don't fully understand strings and such (Just did Hello World for first time yesterday). In that code, what does the "while (!accepted)" part mean. Does (!accepted) mean that while accepted = 0 the loop will continue? 
I think 0=false, other than 0=true. So *while(!accepted)* = *while(!0)* = *while(true)*. While will only works when the condition is true. Am i right? still beginner too.
Good advice!
Almost guys. "while (!accepted)" is the same as writing "while (accepted == 0)". Think of the "!" as meaning "while (accepted is false or equal to 0)". In the code by /u/FazJaxton "accepted" is assigned the value of 0 immediately before the while loop begins. If the password is correct then the value of accepted becomes 1 and the while loop ends.
On the other hand, for financial calculations floating point (of either size) is a bad idea because of the hazard of unpredictable rounding errors. In this case the price of a stamp is better expressed in pennies as an integer value.
You are not allowed to use fflush on an input buffer like stdin. It results in undefined behaviour.
Ohh, sorry. If you use that 'if' statement which calls scanf() inside it, you also need to remove the other scanf() statement in the while() loop. Every scanf() call will ask for an integer, so if you have two of them (One outside of the 'if' and one in the 'if's parameter), they'll both run and grab an integer. Your change works fine to fix it, though you could probably toss-out the 'if' part completely and just leave the internal loop (The 'if' was just a small optimization anyway). I'm glad to hear it :) I'm always happy to explain things and help people out, and I think a fair amount of the others on here are as well.
You've provided literally zero actionable information in your original post or this reply. What do you expect anyone to do?
Break down your task in many simple, limited one of which you see clearly when they are done (this function read a string and output a node. Bam, done). Start by the simplest, most basic (and in the end, central) one. You said you had some work already done. Host your node creation function and how you try to print the stored string (pastebin.com will allow you to use syntax hilighting, which is a nice courtesy to your reader), and give us the link. (otherwise, you can append four blanks at the start of the line for a short snippet of code embedded in your reddit comment, this will be more readable and should respect indentation). Without some starting point we cannot help you.
Here is the create node and the current version of the insertString functions, along with the node struct: http://pastebin.com/YfCiLyfm Here is the given functions to print a trie, they can not be modified: http://pastebin.com/Y2Jk6BTQ
Create node, insert string, and struct for node: http://pastebin.com/YfCiLyfm Print functions that work together: http://pastebin.com/Y2Jk6BTQ
Good point. In COBOL there is a data type called packed decimal as I recall that is used when you cannot have rounding errors. That's really reaching in the old memory.
From what I remember, MinGW is not native and Clang is difficult to set up under Windows. Also, it's good to know that your sources work with multiple C implementations.
&gt; it's good to know that your sources work with multiple C implementations. I definitely agree with this. I'll throw TCC at my code sometimes as this sort of test. That's probably the only reason I'll personally ever be interested in Pelles C. I guess my question was more like "Why use Pelles C *instead* of ..." which you were answering with your first sentence. 
When posting code on Reddit, indent every line of code with four spaces so that Reddit formats it properly as code.
Just curious, what do you mean by &gt; MinGW is not native 
hey you might want to repost this as a top level comment. I think you know this, but all i did was reformat his post.
Um. What. "I'm not allowed to use any strings, if statements..." This task is physically impossible without strings since you can't output anything. Also its pretty difficult without if statements. You don't appear to have thought about it much so I won't give you the answer. Start breaking down the problem and you can ask more specific questions. Below shows how you might start to break it down - Check for correct word matches in the string - read up to the first dot - compare all characters to this point with a stored answer On the strings note, are you trying to say this is a C++ task and you can't use std::string? Because this is a sub for C programming and not C++ but it would be perfectly possible without std::string
Like with any reasonably complex programming problem, break the problem up into sections, and do the sections one at a time. This is how I would do it: 1. Write code to allow the user to enter the list of words with periods, and just print out the same line back to the user. 2. Write code to separate the line into the 6 words, using the periods to separate the line, and storing those words into variables. 3. Modify that code to handle user errors (not enough words/periods, too many periods). 4. Write code that given 2 words, you can compare and say whether they are equal. 5. Use this code to compare each of the words that you've separated to what they should be, and keep a total of how many correct words there were. 6. Write code that given a score, will output one of 5 results. 7. Combine all this code to read in a line from the user, separate the line while handling user errors, comparing all the words to what they should be and in doing so getting a total, and using that total to output the correct result. Since you're not allowed to use Strings, I'm assuming that this is an exercise in using arrays, and arrays will do well here. I can't see of a way of writing a program like this without using loops, as you don't know how long the user input will be. I really don't see how this program can be done without if statements.
So the assignment itself is explicit about not using if statements, switch statements, or (:?) which I have no idea what that is at all. As well the FAQ for the assignment says that strings cannot be used. The output would just be a single number so strings aren't really necessary. The exact problem is 6 sentences with blanks in them. Each can be answered with a single word, that would either use the american spelling of the word or the british spelling of the word and it determines which you use more and gives a result dependant on that. There are no stored answers. This is not a C++ task, it's being written in ANSI-C. I broke it up into sections. The printing of the sentences with a blank was easy. For the first 3 words being input, there are the same number of character in both styles so it would be easy for me to just input a string of characters and it just needs to check 1 from each word to figure out which one it is. A simple true or false statement solves that for me, the problem I encouter is in the next 3 words which have different numbers of characters for each type of spelling. For the first 3 since I can't use strings I just did a bunch of individual chars in my scanf and I encounter no problems, I just have no idea how it would even be possible to get the next 3 words using the same method because if I use enough %c to go for the longest, then if I input less characters than that the program won't run in the first place.
This is so much like a real world assignment.
Number 1 I think I can manage but not positive. Number 2 is where I would have my issues since I don't know how to do that, as well Number 3 isn't neseccary since we are supposed to write the program to work under the assumption that all inputs will always be correct. Number 4 I can do manage using a true/false method easily enough. Number 5 is also easy assuming I can get to this point, as is number 6. And number 7 is just combining so that should not be an issue as well. Essentially number 2 is what's killing me on this assignment since I can't use strings. If you could suggest a method, with loops if need be (the FAQ for the assignment is a bit unclear about it, but I don't think I will lose points for usings loops) that would be a great help, thanks.
Thanks, I did not know how to format my code correctly when posting.
&gt;This task is physically impossible without strings since you can't output anything. Not impossible but the obfuscation required wouldn't make it a useful assignment to anyone.
Would it be better to use gets instead of getc to read in the pixel values? My program needs to be able read in any image no matter where the comment line is in the PPM header.
Input and output is handled by strings, it is physically impossible without referring back to strings in one way or another
b1 is a string.
Let me rephrase the question. Where is the string here? uint16_t b1 = 0x6F6C; uint32_t b2 = 0x00686500; putc(b2 &gt;&gt; 16,stdout); putc((b2 &gt;&gt; 8) &amp; 0xFF,stdout); putc(b1 &amp; 0xFF,stdout); putc(b1 &amp; 0xFF,stdout); putc(b1 &gt;&gt; 8,stdout);
It's impossible to tell from what you've posted, since it's not clear what the program is supposed to do, but one problem is that you are using the same variable names multiple times. Both `var2` and `multiply` are declared once as function arguments and once as local variables. Now about when to use `*` and `&amp;`. The latter is the easy one: it gives you the memory address of a variable, i.e. a pointer to the location where the variable's value is stored. That's also called *referencing a value*. The asterisk is for *dereferencing a pointer* and gives you access to the value the pointer points to. You can use this either to read a value from the memory location the pointer points to, or to store a value there: int value = 0; int* ptr = &amp;value; // Take memory location of "value" *ptr = 42; // Store something in "value" printf("%d", value); // Prints "42" value = 3; int otherValue = *ptr; // Read from memory location printf("%d", otherValue); // Prints "3" value = 5; printf("%d", otherValue); // Still prints "3", assignment to value leaves otherValue untouched
Fair point. Although all you've done here is put the string in a different data type. The stack looks like: 6C 6F 00 65 68 00 Which is: 'l', 'o', nul, 'e', 'h', nul Which is a string. You're rejumbling it. Also, putc handles strings.
I've been editing my post, so re-read for the full example!
Ok by the ANSII definition of a string, yes I'm wrong. It's perfectly possible to do without a C string. The point I'm more getting at is strings are such a fundamental concept that no matter how you try to avoid you will always end up just creating a different way of handling them. The ANSii definition doesn't take into account strings handled (for example) with a [length][data] format, so I guess they aren't strings by definition. There is still a string in your code, but its not being coded as an ANSii string. But if it makes you feel any better I'll admit defeat to the point of there being no C string in that code which is presumably what OPs teacher was referring to. Putc buffers the character to stdout with the rest of the strings. Also I should point out the stack had nothing to do with my point, other than that was where the data happened to be. And yes you can rejumble something into memory and say its the same. That's how encryption works.
I would assume that by "no strings" it would mean character arrays are allowed, but using the string library (ie. strcmp, strcpy, strcat etc) isn't allowed, as it hides the character array manipulation, which the teacher wants to teach (ie. make your own strcmp function).
[Learn C The Hard Way](http://c.learncodethehardway.org/book/) seems like a decent choice. You might want to look into [Learn Python The Hard Way](http://learnpythonthehardway.org/) beforehand if you've never touched code before.
Schol will teach you a lot.
You have a lot of errors in this code. Much of what you wrote doesn't make any sense. What you tried to do here was to write the *entire* program in one go, before you had tested any part of it. That is *not* the right way to write a program. What you need to do is start with a *simple* program that does nothing, and get that working. Then add a small piece to that program, and get that working. Then slowly add features, bit by bit, testing as you go. This program that you have is hopelessly confused. I recommend that you scrap it and start over. Begin by just writing a program that does nothing at all. Make sure that program compiles and runs correctly. Then add code to that program to ask for an integer, read an integer from standard input, and just *print* the integer. Nothing else. Then make sure that program compiles and runs correctly.
For starters, int main(); is a ~~valid C program that returns 0.~~ (See zifyoip's comment below.) The compiler then trips, because on the next line a block starts ( the { ... } ), but without any identifier ( that is you did not name the block). This is just a complicated way of saying that there should be no ';' after main. Additionally, z!=int is not C. And anyhow your check if z is a integer is not working, you read some data into the integer z, so z will always be a integer. ( With a nonsense value, if the user does not type a int.) And the "" should be " ", that is you need an explicit space in your strings. Apart from this and a few typos, the good news is that your algorithm works as intended ( for the one case I checked.) 
What's your current programming background?
&gt; For starters, &gt; &gt; int main(); &gt; &gt; is a valid C program that returns 0. No, because that doesn't provide a *definition* for the function `main`. It only *declares* the function `main`. A C&amp;nbsp;program requires the `main` function to be defined, not just declared.
hmm, I will start with one question then. How do you check if a variable is an integer or not? My code: if(z != int) { printf("must enter integer\n"); This is wrong
spoiler alert: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { for(int i = 0; ((printf("enter ODD size &gt; 0: "), scanf("%d", &amp;i)) == 1);) { if (((i % 2) == 0) || (i &lt; 0)) { printf("%d is not odd and &gt; 0\n", i); continue; } for (int x = 1, cur = 1, end = i * 2 - 1; cur &lt;= end; cur += 2, x += (cur &gt; i) ? -2 : 2) { printf("x=%03d, %*.*s",x, (i-x)/2, (i-x)/2, ""); for (int p = 0; p &lt; x; p++) putchar('*'); putchar('\n'); } } exit(0); } 
Don't just do OP's homework.
do you know what #pragma is for?
 (9/5*celsius)+32 is equivalent to (1*celsius)+32. You probably want (celsius*9/5)+32.
I don't know assembly, but [this website](http://assembly.ynh.io/) is pretty neat for helping to visualize some of what's going on. Running your code through with the optimization flag turned off seems to roughly replicate your asm. 
Don't be a dick. 
* [Are you performing integer division instead of floating-point division?](http://www.reddit.com/r/learnprogramming/wiki/qtsgfb#wiki_are_you_performing_integer_division_instead_of_floating-point_division.3F)
If you wish to drop some knowledge on me, by all means feel free to do so without a prelude of questions. If I was talking about pragmas, it stands to reason that at the very least I think I know what they are for. Oh and if the knowledge nugget is about how they are non standard, or that your uncles' friends brother knows a compiler where "#pragma once" is a shortcut for "praise be to satan"; then try not to be too smug about it - I believe it's common knowledge. 
I like watching Invader Zim because it's random, like me!
I think his content should be boycotted for the horrible things he did.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 15. [**Division by a constant**](https://en.wikipedia.org/wiki/Division_algorithm#Division_by_a_constant) of article [**Division algorithm**](https://en.wikipedia.org/wiki/Division%20algorithm): [](#sfw) --- &gt; &gt;The division by a constant *D* is equivalent to the multiplication by its [reciprocal](https://en.wikipedia.org/wiki/Multiplicative_inverse). Since the denominator is constant, so is its reciprocal (1/*D*). Thus it is possible to compute the value of (1/*D*) once at compile time, and at run time perform the multiplication *N*Â·(1/*D*) rather than the division *N/D*. In [floating point](https://en.wikipedia.org/wiki/Floating_point) arithmetic the use of (1/*D*) presents little problem, but in [integer](https://en.wikipedia.org/wiki/Integer_(computer_science\)) arithmetic the reciprocal will always evaluate to zero (assuming |*D*| &gt; 1). &gt;It is not necessary to use specifically (1/*D*); any value (*X*/*Y*) that reduces to (1/*D*) may be used. For example, for division by 3, the factors 1/3, 2/6, 3/9, or 194/582 could be used. Consequently, if *Y* were a power of two so the division step reduces to a fast right bit shift. The effect of calculating *N*/*D* as (*N*Â·*X*)/*Y* replaces a division with a multiply and a shift. Note that the parentheses are important, as *N*Â·(*X*/*Y*) will evaluate to zero. &gt;However, unless *D* itself is a power of two, there is no *X* and *Y* that satisfies the conditions above. Fortunately, it is not necessary for (*X*/*Y*) to be exactly equal to 1/*D*, but only that it is "close enough" so that the error introduced by the approximation is in the bits that are discarded by the shift operation. &gt; --- ^Interesting: [^Euclidean ^division](https://en.wikipedia.org/wiki/Euclidean_division) ^| [^Polynomial ^long ^division](https://en.wikipedia.org/wiki/Polynomial_long_division) ^| [^Long ^division](https://en.wikipedia.org/wiki/Long_division) ^| [^GrÃ¶bner ^basis](https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgy06kv) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgy06kv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
wtf... and cool!
You're right, should have. 
There are a lot of fundamental issues with that program that lead me to believe that perhaps you should re-do your previous assignments for insight.
Question: is the PPM file in P6 or P3 format? Is the image stored in binary format (P6), 1 byte per color component, 3 bytes per pixel or is it stored in ASCII format like this where the color component is a readable number: P3 #A comment line 3 2 255 255 0 0 0 255 0 0 0 255 255 255 0 255 255 255 0 0 0 There are some issues with how you are reading. First, your loop checking for comment lines will only work if there is one and only one comment line. Because you are reading the width, height and color values inside the **while** loop you have to have at least one comment line, but no more, or you never enter that loop. You could change that loop to look like: while(c == '#' ) { while(getc(inFile) != '\n') ; c = getc(inFile); if( c == '#' ) continue; } which will handle more than one comment line but not be an issue if there are no comment lines. You also have a different problem to address, whether you have comment line or not. Because you have to read ahead one character to detect if you have a '#', you may have actually read the first character of the width value of your PPM file. So after you've checked for the '#' and found you didn't have one, you need to return that read character, so you do a ungetc(c, inFile); Now, when you do the read for the height and width it should read the correct values: fscanf(inFile, "%d %d", &amp;height, &amp;width); Also, the PPM format lists that the dimensions are in WIDTH first then HEIGHT format, so you should probably switch this to fscanf(inFile, "%d %d", &amp;width, &amp;height); Now to reading the data. If your data is in P3 (ASCII) format, then you need to change your input line to read a set of ASCII numbers with spaces: for(i = 0; i &lt; height; i++) { for(j = 0; j &lt; width; j++) { fscanf(inFile, "%d %d %d", &amp;psize[i][j].r, &amp;psize[i][j].g, &amp;psize[i][j].b); } } If, however, your data is in byte format packed RGB, then your current "%c%c%c" approach should work or you could do a binary read something like this: for(i = 0; i &lt; height; i++) { for(j = 0; j &lt; width; j++) { fread(&amp;psize[i][j], sizeof(pixel_t), 1, inFile); } } Because your structure is 3 bytes (r,g,b) this should read the bytes correctly. Depending on what you are trying to output, your output loop will print each byte as an ASCII character. If you want the numeric value, you might change the output so instead of using **%c** you use **%d**. 
[This book](http://www.dwheeler.com/secure-programs/) is pretty good, although it's not C specific and focused on Unix environments. It is free online though.
For an understanding of how C software can be exploited, _Hacking: The Art of Exploitation_
Have that, pretty good read. I like No Starch Press. List of their books here: http://en.wikipedia.org/wiki/List_of_No_Starch_Press_books
A lot of secure coding is simply following good practice, and to that end I recommend reading the GNU C library reference.
And the PPM header im reading in looks similar to this; P6 #comment 200 100 255 or it could look like this: P6 200 100 #comment 255
http://www.amazon.com/The-Software-Security-Assessment-Vulnerabilities/dp/0321444426
[CERT](https://www.securecoding.cert.org/confluence/display/seccode/CERT+C+Coding+Standard) is also available online for free. I recommend reading the comments too for each rule. There are usually pretty good discussions about the rule/recommendation.
Yeah, mentioned in the initial post.
What problem are you having?
Because `fgets` doesn't return `EOF`, it returns `NULL`. Turn on &amp; heed all warnings (you're comparing an `int`, likely `-1`, with a `char *`) and RTFM.
yes! thankyou heaps, it worked now! 
The last character is actually a new line. Think about what you type in: blahblahblah&lt;ENTER&gt; the enter sends it from the buffer, but if you're reading character by character it will show up. It might not always be a '\n' newline but it'll definitely be something standard.
Good point, I completely forgot about that. It's there some way to end the scanf after a return even if it still waiting for more characters?
When you loop through with getchar() or scanf("%c") then you will reach a point when the character returned by these functions is "\n". At this point you stop reading because you've reached a new line. For example: char c = 0; scanf("%c", &amp;c); while (c != '\n') { ...compare c to this character in your answers scanf("%c", &amp;c); } (This would be simpler with getchar): char c = 0; while ((c = getchar()) != '\n') { ... } 
Thanks! Will try this shortly
I know nothing about the GDimage library but the code in gist is a mess. You call gdImageCreate several times in a row and assign it to the same pointer twice. You then call gdImageDestroy shortly after you call gdImageGifAnimBegin. You repeat almost every call twice or three times. It's possible that the library is not expecting such levels of... wild coding. For example, maybe the file read position pointer is never reset so the second time you call this, you're already at the end of the file. I don't know.
If `malloc` returns a null pointer, and then you attempt to dereference that null pointer, your program has undefined behavior according to the C&amp;nbsp;standard. That means that you have *absolutely no guarantees about the behavior of any part of your program*. The C&amp;nbsp;standard does *not* guarantee that dereferencing a null pointer will cause a crash. It says nothing at all about what should happen when a null pointer is dereferenced. The program might be fine at first but crash later, or it might *appear* to run normally but return faulty results, or it might corrupt data somewhere, for example. It might even run successfully and correctly. Undefined behavior means anything at all might happen. It is better to detect a `malloc` failure and exit cleanly with a descriptive error message than to have undefined behavior, at which point you no longer have any guarantees about the behavior of any part of your program.
When an unrecoverable error occurs, it's always a good idea to fail as early as possible. Allocated memory is not always used immediately. Maybe the pointer is passed down into some library. It could even be valid to pass a null pointer to that library, further masking the cause of the error. For the user, it won't matter if the program crashes now or a few nanoseconds later, but for the developer debugging the crash (or weird behaviour), it can be the difference between an hour long debugging session or seeing "out of memory" in the console and immediately knowing what's going on. In short, simple example programs, it might seem like overkill to check for unlikely error conditions. But skipping those checks there will make you more likely to forget them when it's important.
I think this question is well worth asking. Firstly, `malloc` failure is extremely rare, and secondly once `malloc` has failed your options for further handling are really rather limited. It's also necessary to distinguish between operation on a server or workstation where one set of rules apply, and operation in an embedded system. I'm going to argue that in 99% of cases there is no point in checking for `malloc` failure and that simply crashing and burning is a good a solution as you're going to get. First, let's look at how `malloc` can fail. Failure happens when the heap is exhausted, I guess in this case either `brk` has collided with the stack (in which case it's likely you're dead already) because you've run out of address space, or because the kernel has refused to allocate you more pages. The latter case can happen in the presence of configuration settings which restrict the use of resources by processes ... in this case it may be worth trying to do something, but your options at this point are *very* limited. A third case, and frankly the most common case, particularly now we're working with 64-bit address spaces, is that `malloc` never fails ... instead the kernel overcommits and only later discovers that it can't deliver on its promise. So let's review the failure modes: 1. Running out of address space. Won't happen on 64-bit systems (well, I suppose it can be contrived), when it does recovery options are limited. 2. Hitting configured memory usage limit. This is the one case that's worth checking for, but it;s not going to happen on most systems. 3. Overcommitting. This is the most likely scenario, and I'm afraid in this case the application will never hear about it. Ok, let's see what we can do. Our options are really rather limited, as anything that will attempt to allocate from the heap will fail. One trick might be to preallocate a large chunk of memory which can then be freed to allow error handling code to proceed, the only other sensible option is to ensure that none of the error handling code makes system calls that can call `malloc`. The options seem to be: 1. Thread complex error checking and catching code through *everything* and never test it because it never happens. 2. The simplest option is to ignore the allocation failure. For most reasonably small allocations the next time you try and touch any part of the allocation the program will raise a `SIGSEGV` signal and die. 3. Or if you're feeling cute you can try and catch the `SIGSEGV` (probably using a preallocated stack frame) and shout before you die. Personally I have never ever seen an application of mine die with a `malloc` failure, and I have tried quite hard in the past. The idea of investing a lot of effort into catching an error that just doesn't happen when the default behaviour of instantly crashing is probably as good as I'm going to get anyway. In brief: `malloc` doesn't fail, if it does it's not worth doing anything about it. (Edit: `SIGSEGV`, not `SIGBUS`.)
Is there a way to configure, say, GCC with errors or warnings that let you know when there's undefined behavior according to the spec?
GCC 4.9 and later clang versions will try their best to warn you at runtime if you add a `-fsanitize=undefined`. Note that some undefined behaviour cannot always be detected at compile time.
Sweet, thanks for the tip!
Can it be somehow done that when a null pointer is dereferenced, instead of crashing or undefined behaviour, a program jumps to predefined place where a message is shown with maybe a stack and program exits cleanly? Like some define hack like #define NULL CleanTerminate() int CleanTerminate() { ShowMessage(); return 0; } Then no error checking for null would be required for malloc.
Because you might want to do something else in case of memory exhaustion. Not all systems programmed in C have masses of memory and over-commit. Also, you may use it as a sign that you need to tidy up, run a GC cycle, etc, and then retry.
Depending on how your OS is configured, it won't overcommit too much memory. If you try this [program](http://fuz.su/~fuz/src/overcommit.c) on your system and it fails with Cannot allocate that much memory! instead of crashing later on, your system won't let you overcommit much memory. (In this case, 1 TiB).
Yes, I think that particular case is one where my argument is not so valid. Mind, 1TB is bigger than my swap file, so I might reasonably expect `malloc` to fail in this case. I've had a peek at the options for `/proc/sys/vm/overcommit_memory`, and it's rather intriguing. Edit: Good grief -- my `overcommit_ratio` is 50! Umm. That allows some *huge* mallocs. I fear there's an essay to be written on error checking for `malloc`, but 99% of the time it's just not worth all the extra infrastructure -- just die already!
here are 2 points: 1. Examples are just examples, and while in many cases, e.g. interactive command line tools, the only thing you might do is to exit (and have the user manually try again). That doesn't mean exiting or crashing is the right approach everywhere, but in many cases it is. If you're out of memory, your options are quite limited. If you're writing a web server and you go out of memory, you'd rather want to try to return an http 500 status code instead of crashing(And unwinding a request might free up quite some memory for future requests to be handled) 2. You want visibility into what's happening. Yes, crashing IS bad, because you don't know what happened and why. Did the program have a bug ? Was some data invalid ? Are there not enough memory ? When someone calls you at 3am and wonders why the program you wrote last year crashed, you're much better off having a log that says what happened, instead of telling them to turn on coredumps and try to debug that if it happens again. It also eases user frustration and support questions you'll have if you tell the users what is happening and why. People can relate to an error message that says you're out of memory, out of disk space, the network is down etc. A segmentation fault message helps noone. 
Only if you call a print function that doesn't call malloc itself. AFAIK, printf calls malloc. 
Yeah, silently perishing in a user callable library is unfriendly, I accept that -- it's taking the option of trying to do something away. Goodness, this story gets more and more complicated, but my original point still applies. As for "releasing resources" -- can you describe a sensible use case? Let's assume the application is written to correctly handle the system shutting down unexpectedly (that has to be a given), so I'm wondering what cleanup an application can do when OOM which won't be done by the (probably dying) OS. After all, in this situation we're probably at risk of being bombed by the kernel's OOM killer anyway!
If you have child processes, perhaps you want to tell them that you die soon. Perhaps you want to delete some lock files (although this is solved with O_EXCL). Perhaps you want to shut down some daemon before. Perhaps you want to tell the other end of a serial line that they can stop listening now. Perhaps you are an X server and you want to revert to text mode before dieing. Many use cases.
Depends what your programming for. While you can argue back and forth, for userspace your probably better off simply setting up a malloc wrapper which just crashes the program with a meaningful error message (And does a bit of clean-up, Ex. Writing file contents to the disk so you don't lose them). If you're programming for Linux, it over-commits memory anyway so it doesn't matter (malloc always returns a valid address assuming you don't simply run out of addresses to hand-out). Instead of checking the return of malloc, you should have a SIGSEGV signal handler setup so it gets called when you segfault (And, among other things you can treat this area as 'malloc failed' - Do final clean-up and exit the program). Also worth noting, crashing the program with a seg-fault isn't necessarily a bad thing for debugging. For example, I usually use my own assert() macro over the normal one because the normal assert does a clean exit and makes it annoying to get a stack trace. My custom one literally does a *((char *)NULL) = 1, crashing the program with a SIGSEGV (Which I don't currently handle at the moment). When it actually crashes, getting dumps and stack traces is tons easier.
I'm not being quarrelsome, I think this is an interesting conversation. I'm going to pursue the line that catching `malloc` failure is unreliable (because it practically never happens and is therefore almost impossible to test) and so we need to come up with other mechanisms for cleanup. I think my general argument is along these lines: catching `malloc` failure and cleaning up is a soft failure ... but you need to cope with hard failure (unexpected crashes) anyway, so let's try to make hard failure behave right. For instance, child processes will learn that their parent has gone soon enough. Your other examples are more challenging: shutting down daemons, tidily closing a serial line (sending a "goodbye" message of some sort), and closing your X server. Perhaps a general and possibly safer approach would be to fork your application after critical resource allocation, let the child fork run to completion, and finally the parent fork can do cleanup. This way it doesn't matter *how* the child dies. Forgive: I think I've extracted all the juice there is in this topic and some; going further would require working on a real application!
Of course, what you say is true -- but it totally depends on the target system (which is what "undefined behaviour" really means in practice). There are probably two systems of interest to us: with and without memory protection. In the presence of memory protection the "undefined" behaviour is completely predictable, writing to `*NULL` will cause a memory protection violation, and OS specific handling will kick in. Of course, in the absence of memory protection everything you say applies and in spades. So I'd say the developer's first question has to be whether their software will be running with or without memory protection (and if they don't understand the question then the answer is "with"). If the answer is "without" then be totally paranoid about `malloc`!
Sorry for appearing rude to you. This wasn't my intention. You make a good point. Let it crash is a very good paradigm. Designing an application in a way that a crash is no different from an ordinary shutdown (i.e. a crash is not worse than ordinary shutdown) is very good design. If I recall correctly, this was one design aspect of Plan 9. The OS actually has no shutdown mechanism. You have to stop the file servers manually (because the have not yet implemented a journalling file system) and then turn of the system. Programs have to be written in a way that they tolerate aprupt shutdown. There are a couple of other reasons why you would like to catch malloc failure: Sometimes, your application can free memory somewhere else (e.g. deleting cashes) or choose a different approach to the problem (e.g. if you can't allocate enough memory to read the file only once, re-read the file multiple times instead of keeping it in-core [this doesn't really matter with mmap()]). What I really miss in the Unix paradigm is a signal that tells processes that the system is under memory pressure and that the process should try to release memory. Having infinite memory is something people take for granted nowadays, but this is simply not the case in many scenarios. Consider for instance a single-board computer like the Raspberry Pi. OOM'ing on a system with as much as 512 MiB is a real possibility. Assuming malloc failure rarely happens is a dangerous proposition.
No, you didn't appear rude, but our conversation was getting ... tricky ... and it's hard to communicate tone. It's an interesting topic, but quite an odd one. I'm happy to leave it here. Edit: Ooh, a "memory pressure" signal -- nice idea. I think I wouldn't mind if malloc failure created a signal (which of course can be done by wrapping `malloc`, so long as nobody else futzes around under the hood).
In earlier GCCs, use `-Wall -Wextra` to detect some undefined-behavior situations. You might need to kick on optimizations for the compiler to notice certain things, though.
According to the C standards, the compiler is free to operate under the assumption that no null pointer access ever occurs. So if the compiler emits every pointer dereference as a memory access in the order you tell it to, then yes, address space protection will probably be enough. If the compiler is optimizing at all, then you may run into problems. Thing is, though, there's no way to tell what the compiler will actually do until it does it.
See this [Stackoverflow question](http://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for)
According to the C standards, the compiler can operate under the assumption that no null pointer access ever occurs. This means that saying `*(char *)NULL = 1` (a.) explicitly invokes undefined behavior, and (b.) could result in that and whatever code reaches it being declared unreachable. Things like `__builtin_trap()` or `raise(SIGWHATEVER)` are a better idea for crashing the program, because they won't invoke undefined behavior.
I realize that type of assert invokes undefined behavior, I'd never do a 'production build' with asserts compiled in so it's not as much of a concern. In this specific case, the compilers that I debug with (gcc, clang) are really the only ones I promise my code will compile on, and both simply generate the code to try to deference NULL, so it's UD but the resulting code is predictable. Admittedly it's not the best thing to do, but since it's really just for debugging I don't worry about it as much. __builtin_trap() is curious though, I didn't actually know about that builtin (But of course, using builtin's like this already pretty much limits me to gcc and clang anyway). And raise(SIGKILL) should work as well I think.
The resulting code is only sorta-predictable if the compiler isn't optimizing, though---it can assume that the assertion always succeeds, because the assertion failing would result in a `NULL` dereference. (I.e., it can optimize it to `assert(1)` whenever it wants, without telling you.) I think you could get away with using something like `for(;;) (volatile char *)1 = 0` or `for(;;) (void)*(const volatile char *)1`, though. Still undefined behavior, but a little bit cleaner and it wouldn't become unreachable. `raise(SIGKILL)` would immediately kill your program, so I'd go with something like `SIGBUS` or `SIGSEGV` to let you core-dump. `abort()`/`raise(SIGABRT)` is still probably the most portable/safe way to abnormally terminate, though.
True, I'd be slightly surprised if the compiler optimized out the dereference (If only for the reason that if you're doing os-dev work, dereferencing 0 could actually be valid - though you'd want to avoid that anyway). Using 1 is basically the same, but the compiler is less (or can't) optimize it out, so that's a pretty good idea. It's still in the first page so it's unlikely it'd ever be treated differently then zero. Noting that, I *want* assert() to crash the program abnormally, because Ex. if I'm running in gdb or valgrind it'll stop execution and I can do a stack trace or examine things from there. Normal assert() just calls abort() and the program exits cleanly, making debugging harder since the debugger doesn't know there was actually a problem. SIGKILL would probably let this work, using abort() wouldn't, which is why I avoided it. Admittedly, that's a bit tailored to my specific debugging setup, but I'm also the only one doing dev work on it right now so it's not really a concern.
&gt; It seems that people think that programs 'crashing' is a bad thing, and that by 'exiting cleanly' they're fixing it, but I can't see any benefit from that http://www.gully.org/~mackys/miscpix/youshouldkillyourself.gif Or just go work for MicroSoft. I hear they like people with your mentality. ("It compiles - ship it!")
It's undefined behavior *with respect to the C language.* On basically every modern OS it becomes defined as "Segmentation Fault."
That assumes that the compiler emits instructions to dereference the null pointer. But the compiler may assume that the pointer cannot be null, since it is being dereferenced, which may allow the compiler to perform additional optimizations or mark dead code or something, so there is no guarantee that an attempt to dereference a null pointer in the C&amp;nbsp;code will result in an executable containing an attempt to dereference a null pointer.
&gt; In the presence of memory protection the "undefined" behaviour is completely predictable, writing to *NULL will cause a memory protection violation, and OS specific handling will kick in. char* p = malloc( really_large ); p [really_large - 1] = 0; This might not be caught on an OS with memory protection.
`write(2)` is fine. All it does is load some registers and transfer to kernel mode.
I never said it is ok for a program to crash. My point is that "letting the program crash", and "catching the crash and then doing a crash (exiting) yourself" has the same end results.
No. It's possible to memory map address 0 and safely dereference NULL. On Linux it depends on if /proc/sys/vm/mmap_min_addr is set. https://blogs.oracle.com/ksplice/entry/much_ado_about_null_an1
Yes, that is a problem. Perhaps it's better to replace `malloc` with: void *safe_malloc(size_t size) { void *result = malloc(size); if (__builtin_expect(result == NULL, 0)) __builtin_trap(); return result } I guess there's a mechanism for replacing `malloc` in place so that all libraries use this version? Never tried.
Wait, the entire program? What about entirely unrelated subroutines?
Yes, crashing would also affect other subroutines. 
Classic printf's are carefully written to not call malloc(). Glibc on the other hand does call malloc.
:|
The first rule of undefined behavior: Don't make assumptions about what would happen if you did something with undefined behavior. Statements that cause undefined behavior should not be part of a good C program.
&gt; there is no guarantee that an attempt to dereference a null pointer in the C code will result in an executable containing an attempt to dereference a null pointer. While you are correct, this is sort of faulty logic. There is similarly no guarantee that *any* of the code you write compiles to an executable corresponding to that code given an optimizing compiler. For that matter, how do you know your compiler even implements the language standard correctly? At some point, these arguments become absurd. Writing code that depends on undefined behavior like dereferencing null pointers is a bad idea. But it's still the case that, with today's compilers and operating systems, 99% of the time dereferencing a null is going to give you a segfault.
A program should only crash if it has a bug. You should never allow a crash on a valid condition and out-of-memory is a valid condition that can happen. A crashing program produces a coredump for further analysis which is usually to be debugged and causes work for admins.
If your program contains undefined behavior, then the C&amp;nbsp;standard is no longer applicable to that program. You have no guarantees at all from the C&amp;nbsp;standard, because the standard itself no longer applies.
You should read "What Every C Programmer Should Know About Undefined Behavior": * Part&amp;nbsp;1: http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html * Part&amp;nbsp;2: http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html (especially the section "Interacting Compiler Optimizations Lead to Surprising Results," which is directly relevant to your comment) * Part&amp;nbsp;3: http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html
&gt; 99% of the time dereferencing a null is going to give you a segfault. ORLY? $ cat foo.c #include &lt;stddef.h&gt; int main() { int *p = NULL; return *p == 42; } What do you think this does? Does this result in a segmentation fault due to trying to dereference the null pointer? No, not necessarily: $ clang foo.c -S -o - -mllvm --x86-asm-syntax=intel -O2 -fno-asynchronous-unwind-tables .file "foo.c" .text .globl main .align 16, 0x90 .type main,@function main: # @main # BB#0: xor eax, eax ret .Ltmp0: .size main, .Ltmp0-main .ident "clang version 3.4 (tags/RELEASE_34/final)" .section ".note.GNU-stack","",@progbits Nope, no null pointer dereference whatsoever. clang turned this into `return 0;`. **You cannot reason about what might happen when you invoke undefined behavior.** 
&gt; My point is that "letting the program crash", and "catching the crash and then doing a crash (exiting) yourself" has the same end results. And killing someone violently vs. protecting them until they die of old age also has the same end result.
As the `README.md` on Github says, this is just a personal project for me to learn from. Feel free to learn likewise but don't expect too much feature completeness or thread/memory safety (but at the time of writing this is memory-safe providing you `ldlist_removeall` to clean up.)
Surprising that nobody mentioned the possible security implications of somebody trying to write to an address offset from the return of malloc. That may point to a completely valid (not null), but also entirely unintentional part of memory. http://security.stackexchange.com/questions/5762/security-implications-of-null-dereference data = malloc(1000000 * sizeof(struct somedata)); data[800000].a = something;
Wow, I wish I could be personally tutored programming!
I am probably stupid and naive, but do you want money for this?
PM me :)
Let me get in on some of this.. I have experience in both c and c++ Edit: very very limited in both.
There's nothing wrong in revisiting your basics from start. Afterall, having a strong foundation of your basics is what matters 
Most C developers wrap malloc in a macro or another inline that does exactly that. And, yes, if you think about it long enough, failure to malloc is an exceptional condition in many applications that warrants calling exit with a failure code. Some applications which pre-allocate buffers and memory pools can possibly recover, but the great majority of applications are doing the right thing by simply exiting. An actual crash from a signal has different, and perhaps unwanted, behavior. The exit tells you something... the later crash from a failed malloc may not, and may actually take some time to ferret out. 
&gt; I'd never do a 'production build' with asserts compiled in so it's not as much of a concern. I hear this a lot. Unless you are concerned with performance of those assertion checks, there is little reason *not* to do production builds with assertions turned on. Catching signals lets you unwind the stack (possibly) and get a stack crawl, in the log. But, are you going to get the core? Maybe. Probably not. At least with assertions, you can logged the failed conditions, right along with the stack. And, yes, you can argue that you should never have production code running that could hit a failed assertion. I would argue it's a) entirely unreasonable to think that any test suite could guarantee this, and b) maybe you just don't have enough assertions in the first place. 
&gt; when the default behaviour of instantly crashing Doesn't this assume that the code following the failed malloc triggers this behavior within some short number of cycles afterwards? There's no guarantee of that. 
Well then I agree with you completely then, though in general user-space programs I find that truly assertable conditions don't come-along *that* often, or at least not nearly as much as most user-space problems I see think. Ex. For a text editor, instead of assert()ing for most conditions, I'd much rather at the very least dump open-files to the disk and then exit with a reasonable error message (or even better, just report it in a returned error code and take the appropriate action upstream). You can still save debug state for bug hunting, but in the end you're faced with a usability problem if you just leave blind assert's in that crash the program without saving the users work first. In the end though, it really just comes down to me thinking that if you think an assert has a possibility of happening outside of a dev environment, just do proper error handling on it instead of exiting the program, and really I think we can agree on that. assert() has it's place, it's just not for error handling, and that tends to be where I see it most.
I see your parents didn't teach you any manners apparently... Douche.
Sigh. This is of course true. Forgive me, I feel I've done this topic to death!
I write server code which deals with lots of network input... it's hard to predict what might happen with any particular sequence of input from thousands of client connections. It's also hard to predict what assumptions other server engineers might make about your module/library. When you have 50,000 active client connections sending network traffic in roughly, say, 1-30 times a second, and a similar amount of outbound traffic, internal server state changes very rapidly, so, the less you do when things aren't how they should be, the better. In these cases, asserting is the best thing to do because you are already in an unrecoverable state, and the worst thing you can do is to not preserve as much evidence of the crime as possible. When new engineers start working under me, and I see them put in code that tests for some condition like so: if (thing_that_should_never_happen) { LOG("thing that should never happen happened, shouldn't be here"); return -1; } ... I usually impress upon them (often repeatedly)... "what does thing_that_should_never_happen mean?" And if they answer "that should never happen", the answer back is "then why are you returning an error code and attempting to continue to run? You should exit. If that exit condition is hit, file a bug, and then fix the bug." In my line of work, a bug that causes the server to exit even once a week from an assert like this would be a very high priority fix. Obviously, application specifics matter a lot. I would be much less inclined to leave asserts in a production build of something like a text editor, definitely. 
Your logic led to an exploitable local privilege escalation vulnerability in the linux kernel.
You think C is high level enough to handle this "dynamically". Use strcpy. You can also affect the value like that (c99). player = (stats){ .name=" rob", .gender="male", ...}; Not sure if partial init is OK.
To add to my other comment, most standard libraries allow you to override their functions. For instance, you could provide your own malloc() implementation with the semantics you describe above.
Thanks, the strcpy worked great!
Because name and gender were declared as arrays and not pointers, you cannot change where they point to. As /u/gniark said, you have to use strcpy. If they were declared like char * name, you could do what you're doing. 
&gt; declared like char * name Not really since you'd be pointing to what should be treated as immutable data.
I don't think this is the place to be paying people to do your homework. Perhaps if you provided more information about the problems you were having, what you've tried, and what online resources you've looked at people would give more help.
Be careful with `strcpy`, prefer `strncpy` (which specifies the buffer size, 16 in your case). It will avoid you a lot of headaches when user input comes into the picture...
I have programmed many embedded systems where address 0 contains something (sometimes a CPU register, which made you overwrite the program counter on NULL dereferences, fun stuff!).
While strncpy will prevent writing beyond the buffer, it doesn't guarantee a zero terminator. That problem is addressed by BSD's strlcpy. Anyway, in this case the gender should be an enum.
isdigit works on chars, not ints. Try again where char n = '3';. Is digit functions specifically to tell you whether a character in a string can safely be converted to a number.
Your problem is that isdigit tests whether an ASCII code point (represented as an integer!) is an ASCII digit. So what you are asking is: "Is the ASCII code point 3 an ASCII digit?". Since code point 3 is a control character (ETX - end of text), the answer is "No". In C, characters (and character constants) are really single bytes representing ASCII code points. Try: int n = '3'; or int n = 51; /* 51 is the code point for the digit 3 */
So let's say I am looking for using input. What function what I use to verify that the user input is a number? 
You could use one of the [`scanf` functions](http://man.cx/scanf) or `strtol` to convert the user input into an integer. If the function fails, the input was invalid (i. e. not a number). In the case of `strtol(const char *str, char *endptr, int base)`, you would need to check if `str == endptr` after the functions returns. If yes, the input was invalid. In the case of `scanf`, you need to check if the function call returns the right number of converted input items (e. g. 1 if you specified only one conversion specifier like `%d`). There's also `atoi`, but don't use it. It does not allow for any error checking.
Actually you shouldn't pass a plain char to the isdigit() or any of the other isxxx() functions. These functions are designed to work with the result of getc(), so if you have a plain char you need to cast it to unsigned char first. This is one of the many areas where C is surprisingly tricky. http://pubs.opengroup.org/onlinepubs/009696699/functions/isdigit.html
Thanks guys - I figured it out without using isdigit.
&gt; Actually you shouldn't pass a plain char to the isdigit() or any of the other isxxx() functions. These functions are designed to work with the result of getc(), so if you have a plain char you need to cast it to unsigned char first. No. The `isXXX` functions take a parameter of type `int`, but a value of type `char` can be used wherever a value of `int` can be usedâ€”the promotion from `char` to `int` is done automatically.
Promotion from char to int might result in a negative value. But the specification is clear: only 0 to 255 and EOF are allowed. So you first have to cast your char to unsigned char.
Hmm, you're right.
&gt; write(client, &amp;sname, 11); The variable `sname` is a pointer to `char`. You are passing `&amp;sname`, which is the address of a pointer to `char`â€”that means it's a pointer to pointer to `char` (i.e., `char **`). That isn't what you want. You just want to pass `sname`, which is already a pointer. Likewise when you read.
This is full of undefined behavior. You're confusing the array of characters (the actual string) and the pointer that points to it. &gt; char* sname = (char*)malloc(11); &gt; strncpy(sname, "Bob", 11); These are fine. &gt; write(client, &amp;sname, 11); Here, you're sending the actual *pointer* (which is just a numerical value pointing you to where the string is) over the socket. Moreover, you're overstepping the boundaries of the variable, because it's probably only 8 bytes long on your machine, and you're copying 11. (Make sure to check the return value of this function as well.) &gt; char* sname = (char*)malloc(11); Okay, that's fine. &gt; read(server, &amp;sname, 11); Nope. You're copying here the pointer the server gave you into a pointer of your own, which for the server will basically just be a garbage pointer pointing to nothing in particular. Again, you're overstepping the bounds of the pointer variable by reading 11 bytes, and you should again be checking the return value of this function. The fix is simple enough: use `sname` rather than `&amp;sname` in your `read` and `write` calls.
Wow, I feel pretty dumb. That was the problem. I guess just whenever we've been dealing with pointers in class, we'd always use &amp;variable for what we were doing (nothing with sockets), and I just got stuck thinking that's what I needed to do. Thanks a lot for the quick reply, maybe I can make some headway with this work now. Just can't believe I'd make a dumb mistake like that. Also, in the end I do want a char** (need to send a list of names), though I'm not sure I can send that, and may have to send each individually (which would be a pain). Had to get at least a char* sent through first though. I appreciate the help!
Thanks for the reply. Using the &amp; was the problem, guess I just got stuck in using &amp;variable because whenever dealing with pointers in our homework, that's what we had to do (nothing to do with sockets). I'm curious what you mean with overstepping the boundaries of the variable. Doing sizeof(char*) does indeed give me 8 bytes, but the write call claims it wrote 11 bytes of data. So it seems okay, but I guess that's a bad thing to assume with C isn't it? =P Thanks again for the response, I feel pretty dumb messing that up and getting stuck in how we were doing things for past assignments &gt;_&lt;
It never makes sense to send the value of a pointer itself through a socket. A pointer is a memory address. Sending a memory address through a socket is meaninglessâ€”that's a memory address for something on the sender's side, and the receiver won't have the same memory layout.
&gt; Using the &amp; was the problem, guess I just got stuck in using &amp;variable because whenever dealing with pointers in our homework, that's what we had to do (nothing to do with sockets). Never, ever send pointers over sockets. &gt; Doing sizeof(char*) does indeed give me 8 bytes, but the write call claims it wrote 11 bytes of data. Well, sure: it wrote the 8 bytes of the pointer, and then the 3 bytes after, whatever they happened to be. The thing is that there's no telling what those 3 bytes might be. (And this is technically undefined behavior anyway so you shouldn't be doing this in any case.)
&gt; Never, ever send pointers over sockets. Duly noted. Will definitely avoid doing such things in the future. &gt;Well, sure: it wrote the 8 bytes of the pointer, and then the 3 bytes after, whatever they happened to be. The thing is that there's no telling what those 3 bytes might be. (And this is technically undefined behavior anyway so you shouldn't be doing this in any case.) Hmmmm, this may be problematic later, as the names can be up to 10 characters long in the end. If those last 3 bytes are just whatever/garbage, that's definitely going to cause a problem. Is there really no way around that besides sending 2 char* variables and smashing them together on the client side (they'll be changed to C++ strings for convenience)? There must be a way to send a string of length greater than 8 characters without having to send multiple char* variables. That seems like a very strange way to go about a language.
I suppose you're right, though if it sent the value of the pointer itself, that should be an int or a long, so I still feel that *something* should have been written into the client's sname variable, so I feel a segfault on sname[0] shouldn't have occurred, but I'm probably completely wrong there.
Again, you need to wrap your head around the difference between arrays and pointers. &gt; Is there really no way around that besides sending 2 char* variables and smashing them together on the client side You should not be sending pointers over sockets. You need to be sending *strings* over sockets. The issue with overstepping the variable boundary is fixed if you do `write(client, sname, 11)` rather than `write(client, &amp;sname, 11)`.
Okay, I thought you were saying that even if I change it to write(client, sname, 11), I'd still have an issue with those last 3 bytes. I have changed it to work correctly, and am no longer receiving a segfault. I won't be sending pointers over a socket, unless I have a very good reason, which I'm sure those are pretty sparse.
&gt; though if it sent the value of the pointer itself, that should be an int or a long No, it's a pointer. It's not an `int` or a `long`. It's a pointer. &gt; I still feel that *something* should have been written into the client's sname variable It was, probably. Some meaningless value was written to `sname` (and the 3&amp;nbsp;bytes following `sname`, apparently). &gt; so I feel a segfault on sname[0] shouldn't have occurred Why? You have some meaningless value in a pointer variable, and then you attempt to access the memory at that address. Why *shouldn't* that cause a problem?
&gt; No, it's a pointer. It's not an int or a long. It's a pointer. Hmmm, maybe I'm confused then, as I was storing a pointer to a pthread, and for whatever reason printed it, and it returned a numeric value. Kinda thought that maybe it was represented as an int or a long in the architecture. &gt; Why? You have some meaningless value in a pointer variable, and then you attempt to access the memory at that address. Why shouldn't that cause a problem? Good point. I guess by happenstance/luck I could have gotten something besides a segfault, but that would have probably been unlikely.
&gt; I was storing a pointer to a pthread, and for whatever reason printed it, and it returned a numeric value. Kinda thought that maybe it was represented as an int or a long in the architecture. A pointer is represented as a sequence of bits (just like every other kind of data), and that sequence of bits can be interpreted as an integer. This is also how pointer arithmetic works. So yes, you can think of a pointer as a number. But don't think of a pointer as an `int` or a `long`. Those are data types in&amp;nbsp;C, and in the C&amp;nbsp;language they are completely separate from pointers. When writing C&amp;nbsp;code, you should think of pointers and integer types as entirely separate things. Don't try to convert back and forth between them.
Huh, interesting, since I see people trying to convert from pointer to int and int to pointer. Guess that's not a good thing to do. I really appreciate your responses to me. As stupid as I might sound sometimes, I do enjoy learning new things, especially about C. For some strange reason I enjoy using C, but pointers still get to me, so I'll take any information I can get that might help me understand them better! You're awesome.
&gt; I see people trying to convert from pointer to int and int to pointer. Guess that's not a good thing to do. This results in implementation-defined behavior according to the C&amp;nbsp;standard, which means you can do it if you are certain you understand what it means for your particular system and your particular compiler. But doing this is not portable.
&gt; Here, you're sending the actual pointer (which is just a numerical value pointing you to where the string is) over the socket. Moreover, you're overstepping the boundaries of the variable, because it's probably only 8 bytes long on your machine, and you're copying 11. (Make sure to check the return value of this function as well.) He's taking the address of the pointer, which happens to be a stack address. I think he may have intended "*sname", not "&amp;sname". 
You get a segfault on sname[0] because &amp;sname isn't what you think it is. Your "read" call, in fact, is writing right onto the stack, which is, well, bad. 
Just a critique of the malloc'ing. * The casts are unnecessary since malloc returns (void *) * No sizeof used * Example of good malloc usage: char \*p = malloc(sizeof(\*p)\*11); struct foo \*bar = malloc(sizeof(\*bar)); This style is preferred since you then donot have to know the type of or if the type changes, no updating all of the mallocs in the code. 
that is a bad example. // p is a pointer and sizeof(p) equals 4 or 8 char *p = malloc(sizeof(p)*11); // less bad char *p = malloc(sizeof(*p)*11); // this won't even compile struct foo bar = malloc(sizeof(bar)); // i think you want this struct foo* bar = malloc(sizeof *bar); 
If I don't cast, it yells at me about an invalid conversion from void* to char*. If I'm just using a char*, is there a reason I should use sizeof, when I know it's just a certain number of characters, which sizeof(char) will be 1? I've not really done any struct stuff (never had to at this point), so I can't really comment on that part.
Yeah, I felt pretty stupid about it (still do). I should read the man pages a little closer, and would have seen it asks for a "void *buf", and sname was already a pointer, so it didn't need the &amp;.
There's the optional intptr_t that almost every implementation provides. 
Sure, but the only thing that the standard guarantees is that if a `void` pointer is converted to an `intptr_t` (or `uintptr_t`), then converted back to a `void` pointer, the result will compare equal to the original pointer.
&gt; I think he may have intended "*sname", not "&amp;sname". Well that would be wrong too.
You're using a C++ compiler if you are getting errors about invalid conversions between `void *` and `char *`. These types can be implicitly converted in normal C, so the cast is not necessary (and can actually mask a much more serious error if using a non-C99-compliant compiler, forgetting to include `stdlib.h`).
While I'd much prefer working in just C than in C++, unfortunately for what we're doing, I'm forced to work in C++. Though it just seems weird that for something that works in native C, it doesn't work in something that is built off of C so closely. More reasons for me not to like C++ I guess =P
That seems pretty dumb seeing as C++ is built off C and so close to it, but it can't retain that sort of stuff. I can't say I like using C++, and I definitely would rather be working in just plain C for what we're doing. A byte is always 8 bits, why would a char be an indeterminate number of bits if it's a byte? ._.
It's a break from C because it's unsafe. The compiler cannot know the "true" type of a void pointer, so it cannot stop you from doing things that fall outside of what the language standard defines. This is more of an issue in C++ because of how objects can be implemented, but that's reaching beyond the scope of the thread. Also, a byte (in C terms) is not necessarily 8 bits. In the 70s when C was designed, there were plenty of computers that used 7-bit, 9-bit, 16-bit, 36-bit, etc. bytes. Mostly likely you'll only deal with computers that use 8-bit bytes, but if you work with old hardware or esoteric embedded hardware, who knows what you'll run into. That said, any code that relies on bytes containing exactly 8 bits technically isn't compliant to the C (and C++) standard(s).
Please please use pastbin
&gt; #define PRECINCT 5 &gt; #define CANDIDATE 4 Don't use #define for symbolic constants, use enum instead: enum { PRECINCT = 5, CANDIDATE = 4, }; &gt; int total_Votes( votesPerCanidate, &amp;totalVotes) This is illegal syntax, but you might be compiling with a C++ compiler (don't do that) so it accepts that. The right way to declare a pointer argument is with a * instead of an &amp;. Also, don't leave out the argument type. You're accidentially using K&amp;R style which is bad as the compiler *will not check types* correctly. Some of your argument types are actually incorrect as well, like makeJudgement(): The percentagevotesPerCandidate argument is probably supposed to have type double[] and not type double. A good compiler can warn you in these cases (provided that you use correct declarations), but you have to tell the compiler to do so. Don't ignore warnings. Here is the declaration corrected: int total_Votes(int votesPerCandidate, int *totalVotes) Also, try not to mix naming conventions. Use either camelCase or underscore_case (recommended), not both. In this statement: &gt; printf("Runoff between %c and %c", firstMaxVotes+65, secondMaxVotes+65); Do not use magic numbers. If you want to have a character, explicitly use a character constant. Also, you're missing a new-line. printf("Runoff between %c and %c\n", firstMaxVotes + 'A', secondMaxVotes + 'A'); Try to keep a sane indentation style. Here is your makeJudgement function indented with Bill Joy's normal form: double makeJudgement(double percentagevotesPerCandidate[]) { int i, flag=0; int firstMaxVotes,secondMaxVotes; for (i = 0; i &lt; CANDIDATE; i++) { if (percentagevotesPerCandidate[i] &gt; 50.0) { printf("The winner of the election is candidate %c",i+65); flag = 1; break; } if (flag != 1) { maximumVotes(percentagevotesPerCandidate, &amp;firstMaxVotes, &amp;secondMaxVotes); printf("Runoff between %c and %c", firstMaxVotes+65, secondMaxVotes+65); } } } A lot of your code looks strange, too. What is that line double maximumVotes(percentagevotesPerCandidate, &amp;firstMaxVotes, &amp;secondMaxVotes); supposed to do? Right now, it declares a function, instead of calling it (as you probably wanted). If the compiler throws an error at you, don't randomly alter syntax till it stops complaining. Try to understand what the error is. Sticking double in the front has unforeseen consequences.
Have you actually tried to compile this piece of code?
The `case` labels merely indicate *entry* points into the block of code. So if `OP == '/'`, then the execution of the code will jump to the line labeled `case '/'`, and then it will start executing everything in the block following that point. The execution will not automatically leave the block of code when it reaches another `case` statement, because that's just another *entry* point. If you want to leave the block of code, you need to use a `break` statement. switch (OP) { case '+': result += num; printf("Result=%.2d\n", result); break; case '-': result -= num; printf("Result=%.2d\n", result); break; /* etc. */ }
The `%c` specifier does not skip leading whitespace in the input stream, unlike other specifiers such as&amp;nbsp;`%d`. This surprises many people, and it might be the cause of this bugâ€”the `scanf("%c", &amp;ans)` call may be reading the newline character&amp;nbsp;`'\n'` that was added to the input stream by the previous press of the Enter key. To skip leading whitespace in the input stream, put a space before the `%c` specifier: `scanf(" %c", &amp;ans)`. You probably want to do this whenever you are using the `%c` specifier, unless you want to read whitespace. Your `getchar()` call is a hack to get around this problem, isn't it? You don't need that if you just put a space in front of the `%c` specifier so that it skips leading whitespace.
Interesting. I used getchar(); and a replacement for fflush(stdin);. I seemed to have solved the problem by changing int ans; to char ans; 
Yes. Take the flowchart as a guideline and try to make your own with sane naming conventions. I highly suggest you to get "The C programming language, 2nd edition" by Kernighan &amp; Ritchie from your local library. It is by far the best introductionary book into C.
Flushing an input stream is undefined behavior and should be avoided. 
Should I stick to getchar()? I just need something that would clear the buffer, otherwise the scanf picks up the previous statements. 
These are the two things you are asked to compute. The "job capacity in current order" is "the total number of jobs that can be completed if they are executed in the order they are entered by the user." The "optimized job capacity" is "the maximum number of jobs that can be completed if you complete the jobs in the set in any order."
I wouldn't use scanf() at all; as you're seeing, it's too hard to recover from problems with the input. Use fgets() to read a line at a time and parse that instead. 
Yes, each job is represented by a number, which is the time required to complete that job.
Ah, ok that makes it easier. Thanks, I think I can just do it from here.
Two basic problems with what you've said: * Instantly crashing when dereferencing NULL isn't everyone's default. Portable programs should always test malloc()'s return value. * Overcommitting also isn't everyone's default. User-friendly (not to mention developer-friendly) programs should always at least perror("malloc") instead of acquiescing to a SIGSEGV, which isn't informative until you backtrace.
You need to break after each statement. 
I think you are mixing undefined and implementation-defined behavior. While I have no doubt NULL dereference is handled practically identically on current systems, there's no guarantees at all that it still applies tomorrow.
You can certainly use char *string="badger"; The compiler will create a buffer behind the scenes and make your pointer point to it. However, if you want to make a variable that holds a string, you need to use a char array. `char string[] = "badger";` is basically syntactic sugar for doing so. However, it will limit the size of the array to 7 entries - 6 for badger and 1 for the terminating null. You can also specify a size to the array if you want. Ninja edit: while assigning a string to a pointer works, it tends to put the autocreated string buffer into read-only memory, so if you write to it, expect a world of segfaults.
Homework assignment questions are not allowed here.
Overall I like it. It's simple enough to follow without keeping track of too many things. A few observations: 1. I don't understand why `list_create()` allocates a dummy node, and I don't think the function is really needed. Just initialize head/root to NULL (and why both?) 2. Since your "list" is a stack, I'd implement it as a static array instead of a list to avoid malloc/free penalty every time. 3. This code: return (operand0-&gt;x == operand1-&gt;x) ? list_push(1) : list_push(0); is basically: return list_push(operand0-&gt;x == operand1-&gt;x); 4. I don't like that half of the code is the repetition of check list length, pop op0 and op1. Why not just consolidate these? 5. You have to think - if you want to extend this language to cover other operators, expressions or anything else, how much more code do you have to write? For the size of the program this is fine, but I feel like you'd have to think about more formal compiler/interpreter design rules if you would like to extend the feature set. Good luck!
Thanks. What would you recommend as a fix for the argc &gt; 1 be?
I have been trying to get rid of list_create for a while, but just getting rid of it and setting root and head to NULL results in Segmentation fault: 11 On any attempt to use a list changing function. What must be done to the list pointers to avoid this?
I'm guessing in `list_push` you need to assign the newly allocated memory to head if head is null. Otherwise assign it to head-&gt;next.
The main point is you have an empty dummy node with no reason. It doesn't really hurt anything but it's odd to have something like that. So where you allocate it is not really the issue but the fact that your code requires your stack to be started with a non-zero length is. It's up to you if you want to keep it that way or not.
Declaring a variable reserves the space for the variable, and also declares its type. Then you can copy the address of that into the pointer. In your char \*s = "..." example, the **"** itself allocates the space for its contents, and evaluates to the appropriate address: you can do printf("%p\n", "..."), %p for pointer, and that's the address for that string literal, which is what the = is transferring to the left-hand variable in your example. Or you can just imagine that "badger" is &amp;"badger", it's the same thing (print out its address and see); pointers to functions and stuff get the &amp; for free too. Edit: changed "string literally" to "string literal" 
Have you ever looked at FORTH? It has postfix notation in common with your language and might be interesting to you.
What, you mean to send a hexadecimal representation to a stream? Use the `%a` specifier for `printf`, or use `fprintf` or `sprintf` if appropriate.
Well, a string - so how large of a string should I put it in?
The answer to that question is implementation-dependent.
So it isn't better than casting to an integer type?
Better in what way? What are you trying to do?
I need to be able to write arrays of various types to a file (for saving in a game), and it'd be *much* easier if I could write it all down where each different type is fixed width.
Because I'm using ASCII control codes for various things.
Or I could have a well structured file where I do know all of those things, write all the data in hex, make it easier to edit with a text editor *(or at least a hex editor), and have a consistent structure, while also not having to worry about anything reading a control code on accident.
Do binary-to-hex conversion on its representation. (Non-portable but should be OK , IEEE 754 is nearly ubiquitous now). 
Isn't pretty much the entire solution spelled out in the assignment? What exactly is causing you trouble? Do you understand what a linked list is, what structs are, and how to use them? Have you used pointers before?
If you don't mind using an external libray, I'd suggest using [libconfuse](http://www.nongnu.org/confuse/) for your config needs. It's pretty easy to add it to any project. But I don't want to sound like I'm discouraging you from writing your own config parser.
Sweet, I was wondering if there were any good external libraries for this - should have done more searching for that. I'll look into that later today, decide if it fits my needs. Thanks a bunch :)
Thatk you for writing this.
I would suggest you to add the [POSIX standard](http://pubs.opengroup.org/onlinepubs/9699919799/) to your list. By restricting yourself to features found in POSIX, you can easily write portable software.
Always good to have more resources for learning. Many thanks for sharing!
&gt; it can be fantastic when used correctly. The problem is that it's so easy to use badly and so difficult to use well A bit like, say, C?
&gt; The Kernel CodingStyle[2] , has some pretty good advice. Not only has it good advice, it is also quite entertaining in some parts :)
So there are multiple issues going on here. The first is that you probably don't want to be writing structs straight to files. The second is that the way your doing the casting isn't guaranteed to work with packing and such. The last is that your pointer-arithmetic is wrong. You're adding offsetof() which returns a value in bytes, but your pointer is to a master_config_t, so you're not adding bytes but adding sizeof(master_config_t). You're basically doing (&amp;config_data)[offsetof()]. If you cast &amp;config_data as (char *) then it would be correct. For doing this type of casting and conversion, you should define connection_config_t above master_config_t and then include entries of type connection_config_t in to you master_config_t (So, instead of having to cast directly as a connection_config_t, the part that matches connection_config_t will simply be a connection_config_t). typedef struct master_config { char util_config_alignment_check_char; int max_number_running_threads; connection_config_t conn_conf; } master_config_t; Then you can simply take the address of the connection_config_t (&amp;config_data.conn_conf) and be on your way.
Not to promote my own projects on your post, but I've been using libconfuse in a project of mine fairly successfully. [Here](https://github.com/DSMan195276/fircd/blob/master/src/config.c) is my source which actually uses libconfuse to parse the config file. It's not the simplest thing to read, but basically my code calls config_read() with the file to read from. Above at the top of the code 'main_opts' and 'network_opts' are defined as arrays of configuration items (They have simple macros I used to define them). It calls cfg_init() and then cfg_parse to actually parse the file and return the parsed result as an cfg_t. From there, it's just a matter of using the commands to accessed the parsed result (Ex. cfg_getbool() takes the name of a boolean config option you specified and returns the value.). I have an example config file of what this code can parse [here](https://github.com/DSMan195276/fircd/blob/master/doc/fircdrc.example).
I was thinking as I got up this morning, that I should have added this!
Thanks, and I will fix the link.
Here's one I'd have on my own list: * [What Every C Programmer Should Know About Undefined Behavior](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html) 
You're right that it takes a certain scale of project to justify Autotools, and there are indeed many cases when a straight Makefile is better. In my case with custom drivers and vendor SDKs that were likely to be missing on end-user systems, Autotools could cleanly detect that these dependencies were missing so I could compile out the code that would otherwise break. And with gnulib, I could easily port to Darwin where things like O_DIRECT are not defined, by simply adding gnulib's fcntl_h module. My point was less about using GNU extensions themselves, but the fact that in reading about them I learned stuff that I would have otherwise never come across. But I believe we are in agreement!
Well, why are you using a list instead of a stack? A stack is easier to implement, faster and has less overhead. In C the simplest implementation is a pointer: double *stack_begin = malloc(sizeof(double)*stack_size); double *stack = stack_begin; To push: *stack++ = value; To pop: if(stack != stack_begin) value = *stack--;
Does anyone have opinions on the difference/overlap between: **Advanced Programming in the Unix Environment** and **The Linux Programming Interface**
I believe we're in agreement as well. To be fair, there are lots of projects decent in size that have plain Makefile's going perfectly fine, and lots where the Makefile probably won't scale very well. My projects are all decent in size, and my setup's fairly nice for how I'm developing the project. Also worth noting is that the current project I'm working on is a hobby OS kernel, so autotools isn't much use when I don't have any standard libraries to use anyway ;). Being able to do some automatic configuration is extremely nice, you can do it via plain Makefiles but it's not always as clean and you'll have to keep updating it for every supported arch (Any user-space programs I write really only target Linux and MacOSX, if that, so it's not as much of an issue for me. None of them are large projects in terms of users). In the end, I won't deny that there's something I enjoy about rolling my own build system with pure make and some scripting, part of the reason I don't use autotools definitely stems from me simply wanting to do it myself.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Fast inverse square root**](https://en.wikipedia.org/wiki/Fast%20inverse%20square%20root): [](#sfw) --- &gt;__Fast inverse square root__ (sometimes referred to as __Fast InvSqrt()__ or by the [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) constant __0x5f3759df__) is a method of calculating x^âˆ’Â½, the [reciprocal](https://en.wikipedia.org/wiki/Multiplicative_inverse) (or multiplicative inverse) of a [square root](https://en.wikipedia.org/wiki/Square_root) for a 32-bit [floating point](https://en.wikipedia.org/wiki/Floating_point) number in [IEEE 754 floating point format](https://en.wikipedia.org/wiki/Single_precision_floating-point_format#IEEE_754_single_precision_binary_floating-point_format:_binary32). The algorithm was probably developed at [Silicon Graphics](https://en.wikipedia.org/wiki/Silicon_Graphics) in the early 1990s, and an implementation appeared in 1999 in the *[Quake III Arena](https://en.wikipedia.org/wiki/Quake_III_Arena)* source code, but the method did not appear on public forums such as [Usenet](https://en.wikipedia.org/wiki/Usenet) until 2002 or 2003. At the time, the primary advantage of the algorithm came from avoiding [computationally expensive](https://en.wikipedia.org/wiki/Computationally_expensive) floating point operations in favor of integer operations. Inverse square roots are used to compute [angles of incidence](https://en.wikipedia.org/wiki/Angles_of_incidence) and [reflection](https://en.wikipedia.org/wiki/Reflection_(computer_graphics\)) for [lighting](https://en.wikipedia.org/wiki/Lighting) and [shading](https://en.wikipedia.org/wiki/Shading) in [computer graphics](https://en.wikipedia.org/wiki/Computer_graphics). &gt;==== &gt;[**Image**](https://i.imgur.com/c8XSaAU.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:OpenArena-Rocket.jpg) - *Lighting and reflection calculations \(shown here in the first-person shooter OpenArena\) use the fast inverse square root code to compute angles of incidence and reflection.* --- ^Interesting: [^Methods ^of ^computing ^square ^roots](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots) ^| [^Newton's ^method](https://en.wikipedia.org/wiki/Newton%27s_method) ^| [^Binary ^number](https://en.wikipedia.org/wiki/Binary_number) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch5ab46) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch5ab46)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Alright - I'll probably try to get this working, just to give it a try. I wasn't thinking of writing structs to files ever - I just meant that each .c file had it's own version of the struct. My idea of the memory was something like:' master_config { {memory block for util_config} {memory block for conn_config} {memory block for foo_config} {memory block for bar_config} }' Then in connection.c (and util.c, foo.c, bar.c, etc....) I would have a struct named (conn_config, util_config, foo_config...) which had identical elements to it's "section" in the master_config struct. Then just create a util_config pointer which I just point to the memory block that represents the util_config options in the master_config struct. So all the config options are stored once in master_config, but each file has a pointer to what looks like its own config options. I don't think it's a great approach though - I would have to update both the sub-file and the master config file every time I want to add an option, as well as making sure the order/packing in each file is perfect. I think it would be a valuable excercise to try to implement though, so I think I'll still try it then scrap it. So I think my other options are to have the master config file which has a struct with just pointers to the config structs of the other files - or just use libconfuse. I suppose I could have a config naming scheme where by looking at the config option being passed in it knows which files config_init() function to pass it to to fill out it's own struct. Then the master_config file is just responsible for allocating the memory for each sub_config struct and initial parsing of the input. The libconfuse looks like a pretty good option though - so I may just go with that and use your code as a guide. Having code to follow along with always makes it easier :)
I have, I use a 'fake'-recursive make strategy, in some ways. You can take a look [here](https://github.com/DSMan195276/protura/blob/master/Makefile) if you'd like. The basic of it though is that 'subdir_inc' function which sets some variables and then include's subdir's specified by a file. So I call subdir_inc on the first Makefile in the ./src/ directory, and then it has definitions on which sub-directories to include and eventually it gets down to files like [this](https://github.com/DSMan195276/protura/blob/master/arch/x86/kernel/Makefile) which specify which object files to create and how to generate files if necessary. .o files are automatically built by matching named .S or .c files, but you can also specify a .o to be built out of multiple other .o files linked together (Though I don't currently have an example). Also in that example I have a perl script which generates some assembly, and make will automatically search for that rule and built the .S file automatically when it sees it so it's pretty easy to add too. Personally I don't think recursive make is *horrible*, it can just get pretty ugly depending on how you do it. With that, people never put in the time to have some actual *nice* output from their build system, so if you build something big like gcc you get flooded with text about make executing in a new directory or leaving a directory. The Linux Source build system is extremely clean and it's all recursive. You'd never notice it by just running make though because they intentionally silence make completely and do their own output for compilation.
Do you use any header files? Just make a generic header file with the master_config definition as well as the util_config definition, conn_config definition, etc... and then #include the file in all of your source files. You should be fine if you do that. With my libconfuse setup, I just use libconfuse to fill-in my own struct of configuration items (See: [this](https://github.com/DSMan195276/fircd/blob/master/include/config.h)). Once that's filled-in I toss all the cfg_t stuff from libconfuse and don't touch it again. Feel free to use any of the libconfuse code I wrote. libconfuse also has a [website](http://www.nongnu.org/confuse/) with some examples, and I first got the idea to use libconfuse from the code in [i3status](https://github.com/DSMan195276/i3status/blob/master/i3status.c) and [example config](https://github.com/DSMan195276/i3status/blob/master/i3status.conf) which you might find useful. All the libconfuse stuff is in that .c file I linked and if you just focus on the config stuff it's a pretty easy read.
Sweet, this is majorly helpful. I don't know why I didn't think of just one .h file with all the configs in it. Hopefully I have minimal working code soon, work kinda gets in the way a bit right now :/
Oh wow. I'll see how my program works if rewritten with this. Thanks
thanks for that zify - I was getting mixed up with what I had to specify, I thought that it was going to automatically sort itself out because I had initialised it whilst declaring it! Apparently not. Specifying the length works, thanks. 
I comletely understand what structs are how they are used. Linked lists however is a whole nother ordeal...
I've been using this "fake" recursive make for a hobby OS I've been working on with great success. I make use of the variables defining the object files to export everything in a separate folder hierarchy identical to my source directories. Works like a charm.
Thanks for the comments! As far as the #defines go, I prefer to use enums when the data is related, and defines when its just a constant. As you said though, that's just preference.
Casting in order to get the same bits.
The idea of an embedded linked list is that each element of the list has a pointer to the next element. Then you can just retain the pointer to the first one, and you can access them all. Basically: struct Customer { // blah whatever struct Customer * next; }; And, for a queue, store both the head and tail of the list somewhere: static struct Customer * head = 0; static struct Customer * tail = 0; To add something to the list, allocate a new element, then check if head is null. If yes, set both the head and tail to it (and don't forget to set it's next to null). If not, set the next of tail to point to the new element, and set tail to the new element. To take something out, check if head null, if yes, nothing to take. If not, take it, set head to old head.next. to iterate though the list just do: for (struct Customer * c; c; c = c.next) I would strongly suggest spending some time with a linked list tutorial.
Stepping back up a level. Notice that this xvel logic occurs twice in the program - which made me think there should be a constant to use instead of .8 - so they don't get out of sync. But, then I noticed all the surrounding code is almost the same. The common logic in newGame and resetGame should be factored out - into either a third fn or perhaps newGames calls resetGame and sets the scores to zero. 
A 2d array of characters is an unusual choice for a data structure unless, for example, you're creating a scrabble or boggle game where the board is actuall a 2d array and you want to do things like find the char at row i, col j. For a list of strings I think you'll find it's more natural to use an array of char*'s. Like so: const char *colour[] = {"blue", "orange", "purple", "pink", "green",}; 
Doesn't seem to work in either FF or Chrome. 
&gt; if I just call it with nothing sitting in stdin it sits there and expects a char from getc, and I guess never reaches EOF. It's waiting for input. Standard input is connected to the terminal if you don't redirect it. Type something and then hit ctrl-d (unix) or ctrl-z (Windows) to signal the end of file condition. If a program run without stdin redirected were to behave as if there was no input, then you wouldn't be able to write interactive programs. The *whole point* of standard input is that it's a universal way for the program to accept input, whether it's via the user typing on the keyboard, the output of another program, or the contents of a file. The program doesn't know or care which one of those it is -- it works the same regardless, without having to be modified. &gt; Is there a way I can check to see if there is nothing in stdin and kick back "You forgot to pass data!" or something? No, nor would you want to do that even if you could. The user *didn't* forget to pass data, they are being given the opportunity to type it. Also, your program neglects to null terminate the string, which means it invokes undefined behavior. It might appear to work fine if the array happens to contain nulls, but you absolutely can't rely on that; if it's working it's only by sheer luck. 
Just a quick note, at least on POSIX compliant and similar systems you can use the [isatty function](http://pubs.opengroup.org/onlinepubs/9699919799/functions/isatty.html) to find out if the standard input is a terminal device or something else (file, output of another program). It is commonly used to detect if a program is running in interactive mode. It looks like Visual Studio does have isatty as well, but it is deprecated and it instead recommends _isatty and I have no experience with those.
That's just Visual Studio being overly pedantic. All functions that aren't specified by ISO C90 are given identifiers that begin with an underscore. Since such identifiers are reserved for the implementation, a user can't complain if they clash with their existing code. There is an "oldnames" library that provides aliases that let the non-underscore versions link, but I don't know if that library is included in the link by default or not.
Works fine for me in Fx 24, Gentoo stable. I was able to complete the game, even.
You can go to about:gpu to see if WebGL is available.
Yes, it says "WebGL: Unavailable". I managed to enable it and the game works!
You're making ch a char, but a char might be unsigned, causing ch != EOF to be perpetually true (an unsigned value can't be negative). getc() returns an int to make sure that EOF (-1) is a distinct value. Change the type of ch to int and you might be settled.
First of all, it isn't necessary to have a char *name[], that is a pointer a a string, you can just have a string with char name[30], and scanf/printf that with just person.name. Secondly, I'm not sure where your error is. gcc reports that its coming from line 12 of the file point.c, could you provide line numbers for point.c?
Is it still compiling (that's just a warning..) and you're getting a functional "a.out" ?
There's a couple of issues. First of all, you don't need the typedef in the definition of struct data (I suspect that's why gcc complains). You can just say struct data { ... }; and then declare **person** just like you did. Second, you are defining **name** as an array (of size 30) of pointers to a character. You can just say char name[30]; and that will allocate an array of 30 characters which can then be used to store a string. You can then read **name** like this: scanf("%s", person.name); that is, without the '\*'. When you use the name of the array (**person.name** in this case) by itself, the compiler interprets this as a pointer to the first element of the array. This is passed to scanf, and scanf fills the array starting at that position. Note that scanf *only* gets a pointer to the start of the array, and it does not know how big it is. So if you type in a string that is longer than 30 bytes, bad things *will* happen.
&gt;You can then read name like this Ah yeah of course... nice one &gt;So if you type in a string that is longer than 30 bytes, bad things will happen Yeah, I'm not really sure how I'd go about solving that to be honest :/ Cheers
No sure how to give line numbers (I'm copy pasting from VIM...) But the place that was being pointed to was the closing curly brace on the `struct` Apparently I don't need to use type def for this though ^^^^apparently ^^^^I ^^^^need ^^^^to ^^^^learn ^^^^what ^^^^typedef ^^^^is ^^^^really ^^^^used ^^^^for 
One solution to use fgets to read some input from stdin to a char array and to then run sscanf (think string scanf) over the input you get. EDIT: scanf and fscanf let you specify a max width with a string format specifier. For example, to fill a 30 byte buffer, you use "%29s". Last character is a null-terminator. Will truncate the excess and leave it available for reading in the future, though..
OK cool, I haven't done anything with `fgets` before, though I'm aware `gets` was used in a virus or something jazzy ages ago! I'll have to have a look into it. 
As someone else pointed out, it looks like your problem was with the typedef. In Vim, show line numbers by typing ":set number" (no quotes). 
gets is dangerous because it takes a pointer to some memory without any size information and just fills from stdin until it hits a newline. fgets reads at most a number of characters from a file. Very different for some odd reason.
Would fscanf be a better choice? You can tell it how many characters to expect? Sorry, I'm just learning C so I might be wrong.
Nope. fscanf has the same problem as scanf. It doesn't know the size of the destination buffer. The only reason sscanf is safer is because you know beforehand the size of the string you're scanning. In theory scanf and fscanf can be guaranteed safe for some format strings because, for example, an `int` can only be so big, but if your format string contains an format specifier that takes a type of unbounded size (e.g. a string), all bets are off. EDIT: Turns out I'm partially wrong. scanf and fscanf let you specify a max width of a string format specifier. For example, to fill a 30 byte buffer, you use "%29s". Last character is a null-terminator. Will truncate the excess and leave it available for reading in the future, though..
This makes sense. I guess I just need to think about it in a different way. This code wasn't really trying to accomplish a real task but was mainly an experiment to see what I could and couldn't do. I see now why it doesn't work the way i thought it would.
Change scanf("%d", ages); to scanf("%d", &amp;ages[i]); and it should work. Although you have declared an integer array, you are not storing values in the array and advancing it. Above line is also equivalent to. scanf("%d", (ages + i)); 
Well it worked??? 
hm. apparently you can as of c99...that's what I get for trying to drop knowledge in this sub.
Code works exactly how it looks like it'd work. It'll print one more than the last age you entered, then the rest with garbage values. So it works as far as I can tell.
Yes, it's fine. C99 is only 15 years old; I think it's OK to use that language standard over C90 or C89 :)
Yup, but they are allocated in the stack, so for any array that could be big, you're better with malloc)
Yeah, that's the point of this entry-validating loop, right ?
Are you declaring the c files with @file
Edit: @mainpage and @file are now working. @ file shows the .c files function and variable names, but does not allow me to view the full code. Why could this be? ///comments are still disappearing. Thanks.
Please try to indent your code correctly so it is more readable. Here is your code indented in the Bill Joy style. #include &lt;stdio.h&gt; int main(void) { int n, i j; do { printf("How many people are in the room?\n"); scanf("%d", &amp;n); } while (n &lt; 1); int ages[n]; for (i = 0; i &lt; n; i++) { printf("What is the age of person %d", i + 1); scanf("%d", ages); } for (j = 0; j &lt; n; j++) { printf("In one year person %d will be %d\n", j + 1, ages[j] + 1); } } 
You are mixing up VLAs with flexible arrays.
DOH! i think i fixed it... I added char name[20]; and it seems to work properly
Here are some notes. #include &lt;stdio.h&gt; /* FIXME -- main() should at least return int */ main() { int gameScores[10] = {12, 5, 21, 15, 32, 10}; int totalPoints = 0; int i; float avg; /* FIXME -- this is a single char. It should be an array of some length. */ char name; //only need scores for last 4 games. lower loop will cover next 4 games printf("What is the players name?\n"); /* FIXME -- once you change name to an array, you must remove the ampersand. */ scanf("%s", &amp;name); for (i=6; i &lt; 10; i++) { printf("What did the player score in game %d? ", i+1); scanf(" %d", &amp;gameScores[i]); } //now you have all 10 scores, loops through to get average of points per game for (i=0; i&lt;10; i++) { totalPoints += gameScores[i]; } //use float point for average /* FIXME -- Too many parens. If you want to promote the entire expression to double you could say: avg = totalPoints / 10.0; If you want to explicitly make 10.0 a float you can use: avg = totalPoints / 10.0f; */ avg = ((float)totalPoints/10); /* You shouldn't have to use the address of name if you correct the declaration. It should be simply: printf("\n\n%s's scoring average is %.1f\n", name avg); */ printf("\n\n%s's scoring average is %.1f. \n", &amp;name, avg); return(0); } Another thing I would suggest is to declare and initialize variables as close to their usage as possible. This means declaring them inline and in for() loops. These have been C99 features for quite a while and I think were GCC extensions for even longer than that. Also consider using the sizeof operator to determine the size of gameScores[] instead of using a constant (10) all over the place. #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int gameScores[10] = {12, 5, 21, 15, 32, 10}; int nscores = sizeof (gameScores) / sizeof (int); //only need scores for last 4 games. lower loop will cover next 4 games char name[20]; printf("What is the players name?\n"); scanf("%s", name); for (int i = 6; i &lt; nscores; i++) { printf("What did the player score in game %d? ", i+1); scanf(" %d", &amp;gameScores[i]); } // now you have all 10 scores, loops through to get average of points per game int totalPoints = 0; for (int i = 0; i &lt; nscores; i++) totalPoints += gameScores[i]; // use float point for average float avg = totalPoints / (float)nscores; printf("\n\n%s's scoring average is %.1f. \n", name, avg); return(0); }
Who teaches these weird indentation styles to beginners?
Thank you for your help, i'll try to implement a couple new things.
I'm a newb and learning it from a book so I don't really have a teacher lol..I kind of just try to copy the example from the book and the indentation style it uses. Normally I get some odd syntax errors but im getting pretty decent at identifying those. After i build the example then I try to mess around with it to personalize it or tweak it to include other things if I can manage them to get working. Thank you for your help :)
You're definitely right. When I googled it a bit later I realized I remembered the wrong name.
Your fix introduces a buffer-overflow vulnerability. Your scanf for the name should be length-limited somehow, otherwise entering a name longer than 19 characters will cause your program to write to and print unallocated memory. scanf("%19s", name); 
Anyone looking for solid C background can also add: K&amp;R, Writing Solid Code and the comp.lang.C FAQ
Though not strictly C since he gets into a lot of assembly this book has definitely made me a better programmer. Even just reading the first few chapters made me approach programming problems differently. [Michael Abrash's Black Book](http://www.jagregory.com/abrash-black-book/)
It is even nicer to have size_t nscores = sizeof(gameScores) / sizeof(*gameScores); because then even if you change the type of gameScores you don't have to change that in the code.
Usually you add one tab to the start of the line each time you open a new brace, or remove one tab when you close a brace. What your code does is very inconsistent and hard to read.
Completely agree.
http://www.slideshare.net/olvemaudal/deep-c
Found it totally boring and too much stuff about pthreads and such. :p
[this](https://www.kernel.org/doc/Documentation/CodingStyle) might help you a bit. It's meant for the kernel, but recommended for any C project.
lol that looks really awesome. I'll keep trying to emulate that, mine seems to just come out as a hot mess lol. I'm on chapter 25 now and hopefully this looks a little better? #include &lt;stdio.h&gt; main() { int i; int ctr = 0; char ans; //Declaring our array of 9 characters then initialize them char* movies[9] = { "Amour", "Argo", "Beasts of the Souther Wild", "Django Unchained", "Les Miserables", "Life of Pi", "Lincoln", "Silver Linings Playbook", "Zero Dark Thiry"}; int movieratings[9]; // corresponding array of 9 intergers for ratings char *tempmovie = "This will be used to sort rated movies"; int outer, inner, didSwap, temprating; //sorting loop printf("\n\n*** Oscar Season 2012 is here! ***\n\n"); printf("Time to rate this year's best picture nominees:"); for (i=0; i&lt;9; i++) { printf("\nDid you see %s (Y/N)", movies[i]); scanf(" %c", &amp;ans); if ((toupper(ans)) == 'Y') { printf("\nWhat was your rating on a scale "); printf(" of 1-10: "); scanf(" %d", &amp;movieratings[i]); ctr ++; //this will be used to print only movies you've seen continue; } else { movieratings[i] = -1; } } //Now sort movies by rating (unseen will go to the bottom) for (outer = 0; outer &lt;8; outer ++) { didSwap = 0; for (inner = outer; inner &lt; 9; inner++) { if (movieratings[inner] &gt; movieratings[outer]) { tempmovie = movies[inner]; temprating = movieratings[inner]; movies[inner] = movies[outer]; movieratings[inner] = movieratings[outer]; movies[outer] = tempmovie; movieratings[outer] = temprating; didSwap = 1; } } if (didSwap ==0) { break; } } //Now print the movies you saw in order printf("\n\n** Your Movie Ratings for the 2012 Oscar"); printf("Contenders **\n"); for (i=0; i&lt; ctr; i++) { printf("%s rated a %d! \n", movies[i], movieratings[i]); } return(0); } 
Not quite. Let me just reformat the source for you (takes a while). Try to be as close as possible to the style I show you. The most important things are the indentation (every nesting is one tab, but a continued statement is only four spaces) and the placement of braces (the opening brace comes on the next line in function declarations, and on the same in control structures. Leave the braces out if not needed).
Okay. Here is the source code reformated with some extra comments: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i, ctr = 0; int outer, inner, did_swap, temp_rating; //sorting loop int movie_ratings[9]; /* ratings for movies */ char ans; /* Declaring our array of 9 characters then initialize them */ const char *movies[9] = { "Amour", "Argo", "Beasts of the Souther Wild", "Django Unchained", "Les Miserables", "Life of Pi", "Lincoln", "Silver Linings Playbook", "Zero Dark Thiry" }, *temp_movie = "This will be used to sort rated movies"; printf("\n\n*** Oscar Season 2012 is here! ***\n\n"); printf("Time to rate this year's best picture nominees:"); for (i = 0; i &lt; 9; i++) { printf("\nDid you see %s (Y/N)", movies[i]); scanf(" %c", &amp;ans); if (toupper(ans) == 'Y') { /* There's no need to use two printf's */ printf("\nWhat was your rating on a scale of 1-10: "); scanf(" %d", &amp;movie_ratings[i]); /* this will print only the movies you've seen */ ctr++; /* continue is superfluous */ } else movie_ratings[i] = -1; } /* Sort movies by rating (unseen will go to the bottom) */ for (outer = 0; outer &lt; 8; outer++) { did_swap = 0; /* consider using a function if your loops are deeply nested */ for (inner = outer; inner &lt; 9; inner++) { /* DO NOT COMPARE STRINGS WITH &gt; &lt; = (use strcmp) */ if (movie_ratings[inner] &gt; movie_ratings[outer]) { temp_movie = movies[inner]; temp_rating = movie_ratings[inner]; movies[inner] = movies[outer]; movie_ratings[inner] = movie_ratings[outer]; movies[outer] = temp_movie; movie_ratings[outer] = temp_rating; did_swap = 1; } } if (did_swap == 0) break; } /* Print the movies you saw in order */ printf("\n\n** Your Movie Ratings for the 2012 Oscar Contenders **\n"); for (i = 0; i &lt; ctr; i++) { printf("%s rated a %d! \n", movies[i], movie_ratings[i]); } /* put a space after return. return is not a function */ return (EXIT_SUCCESS); } Please, never ever compare strings with comparison operators. Comparison operators will only compare the pointers and not the contents of the strings. The order of the pointers is totally unpredictable. Use the function strcmp() instead. One thing that makes code much easier to read is a style called "early exit". The idea is, that instead of using if-else clause with long blocks, you try to structure your code in a way that extraordinary conditions exit the current block as early as possible; the code path that is usually taken should not be inside a conditional clause. Here is your code reworked to add this concept: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i, ctr = 0; int outer, inner, did_swap, temp_rating; //sorting loop int movie_ratings[9]; /* ratings for movies */ char ans; /* Declaring our array of 9 characters then initialize them */ const char *movies[9] = { "Amour", "Argo", "Beasts of the Souther Wild", "Django Unchained", "Les Miserables", "Life of Pi", "Lincoln", "Silver Linings Playbook", "Zero Dark Thiry" }, *temp_movie = "This will be used to sort rated movies"; printf("\n\n*** Oscar Season 2012 is here! ***\n\n"); printf("Time to rate this year's best picture nominees:"); for (i = 0; i &lt; 9; i++) { printf("\nDid you see %s (Y/N)", movies[i]); scanf(" %c", &amp;ans); /* exit early if no occurs */ if (toupper(ans) != 'N') { movie_ratings[i] = -1; continue; } printf("\nWhat was your rating on a scale of 1-10: "); scanf(" %d", &amp;movie_ratings[i]); /* this will print only the movies you've seen */ ctr++; } /* Sort movies by rating (unseen will go to the bottom) */ for (outer = 0; outer &lt; 8; outer++) { did_swap = 0; /* consider using a function if your loops are deeply nested */ for (inner = outer; inner &lt; 9; inner++) { /* exit loop early if we don't want to swap */ if (movie_ratings[inner] &lt;= movie_ratings[outer]) continue; temp_movie = movies[inner]; temp_rating = movie_ratings[inner]; movies[inner] = movies[outer]; movie_ratings[inner] = movie_ratings[outer]; movies[outer] = temp_movie; movie_ratings[outer] = temp_rating; did_swap = 1; } if (did_swap == 0) break; } /* Print the movies you saw in order */ printf("\n\n** Your Movie Ratings for the 2012 Oscar Contenders **\n"); for (i = 0; i &lt; ctr; i++) { printf("%s rated a %d! \n", movies[i], movie_ratings[i]); } /* put a space after return. return is not a function */ return (EXIT_SUCCESS); }
I think i understand, I'm really new to C and following examples exactly how they're written in the book. This is my first attempts at learning it and it seems I've got miles to go. Currently I'm using Programming C: Absolute Beginners guide 3rd edition, i'm using it to work on taking the CS50 class because it's recommended. Any other additional videos or books that would be helpful that you would recommend?
Ok awesome! I found it at my local bookstore and they'll rent it to me for 60 days for $10. I'll check it out and try to run through it, thanks a ton for helping me :)
By any chance does it show how to implement a GUI? The programs I keep making run in CMD and are neat but making something functional i can use would be immensely more fulfilling. 
Thank you so much. That is the one. You are a scholar and a gentleman. 
&gt; is actually a string because it is created with a string literal cheers dude :)
hmm... to be honest I haven't really learnt much about `const`. AFAIK it's just something that's fixed / not going to be changed.... I'll have to have a read up though
Also you don't have to and probably shouldn't cast the result of malloc().
before searching the list you should do pi = head again, you mess up pi by doing the iteration to print all the items and finishing in NULL
Ah, yes... that makes sense. I also realized that I forgot to have a prototype before main. I fixed that, and did searchList(head) but still, nothing prints out... :(
The major issues here could be solved by compiling with -Wall and fixing the warnings.
 pi = malloc(sizeof(struct Item));
works for me
or even better pi = malloc(sizeof *pi);
there's [wchar.h](https://en.wikipedia.org/wiki/Wchar.h) I've never used it however.
I don't have a very good answer but [this faq](http://www.cl.cam.ac.uk/~mgk25/unicode.html#libs) is a good start.
You may be looking for something like [ICU](http://site.icu-project.org/). But as for some of your comments, you really have to consider **why that information is important**. When you're dealing with a UTF-8 representation, why is the **number of characters** important? Moreover, what do you mean by "*character*"? Do you mean "*code point*" or "*grapheme*"? How is either of those counts more or less meaningful to your purposes than the number of bytes (i.e. "*code units*")?
&gt;* `strn*` type of function should treat n as characters, not as bytes! * `strlen` should return the count of the characters in a string, not bytes! Set your locale with `setlocale()`, convert your UTF-8 string to wide char with `mbstowcs()`, and use the [`wcs*` functions](http://en.cppreference.com/w/c/string/wide) (`wcslen()` instead of `strlen()`, `wcsncmp()` instead of `strncmp()`, etc.). For example: printf("%zu characters\n", wcslen(L"èŠ±åœ’")); Prints `2 characters`.
&gt; ICU seems too much complicated and heavy for me The hidden expectation in the quote above is that handling Unicode strings can be simple. Perhaps the complexity inside the ICU library really is needed to handle complex Unicode strings correctly. The thing to evaluate then is whether the ICU API is easy to use for the use-cases you care about, rather than whether the actual ICU implementation is complex.
I was going to suggest that, as it's my preferred way, but people's reluctance to accept it had me trying to see the benefits of not doing this. One I could hear them saying was "I can't tell what type I'm allocating space for!". Since it was a learning thread, I figured I'd not press my own style. Also, I too like leaving out the parenthesis when getting the size of an expression. Putting parenthesis is like putting them on a return statement. Looks silly.
Two problems with that: * character conversion is dependent on optional support in the standard library and some implementations (mingw in particular) simply don't handle UTF-8 to UTF-16 conversion * wcslen simply returns number of bytes divided by 2 on Windows, it doesn't return the number of code points (what most people think of when they think of Unicode characters) or grapheme clusters (which is the visible groups on the page). To avoid these problems, you ned to know that your version of the standard library handles UTF-8 to UTF-16 conversion and to have a way of dealing with Windows (if Windows support is required). I don't know about one for plain C. I use [utf8cpp](http://utfcpp.sourceforge.net) as a lightweight library to handle these things (except grapheme clusters) in C++. You'd need to find an equivalent in C.
Did you mean to post this to /r/shittyprogramming? It'd be perfect there.
Try it yourself and see. You get a compiler error, because that is not legal. $ clang -std=c99 -Wall -Wextra -o program program.c program.c:11:9: error: assigning to 'union &lt;anonymous union at program.c:4:3&gt;' from incompatible type 'int' p -&gt; d = 10; ^ ~~ 1 error generated.
(a) can't be right since the struct only has direct access to variables d and e. I think c is the only valid answer.
Remember that when initializing a struct/union, you have lots more flexibility in what you use as an initializer than later when you're assigning a new value to it. When assigning, you have to specify exactly what member is going to get assigned to.
Eh, you can say that, and then you can look at implementations like the one in GLib that does everything your Joe Schmo needs to do with Unicode and it's easy to reason that ICU is a bit bloated. Probably yet another time I wish GLib were split into a smaller number of easier-to-buy-in libraries, but eh.
&gt; - `strn*` type of function should treat `n` as *characters*, not as bytes! &gt; - `strlen` should return the count of the *characters* in a string, not bytes! The problem with this is that 'character' is an application specific concept. Sometimes the characters you care about are really code points, sometimes you care about graphemes as defined by Unicode's example algorithm, sometimes you care about graphemes but with some application specific changes to the example algorithm. So trying to define some kind of standard algorithm is really not as useful as we might like.
`wchar_t` is specified by the standard to effectively be codepoints. The standard specifies that every 'supported character' in a locale must convert to exactly one `wchar_t` value. The only reason Microsoft's usage of UTF-16 for wchar_t arguably conforms is that Microsoft doesn't support any locale with character outside the BMP. Anyway, C++11 mandates support for `char32_t`, so you can just use [`std::mbrtoc32`](http://en.cppreference.com/w/cpp/string/multibyte/mbrtoc32) and then count those. Of course all of this is dependent on you caring about number of codepoints rather than number of characters.
Windows 2000 and greater support characters outside the BMP, which means that multiple wchar_ts are definitely possible on Windows. This makes C and C++'s wchar_t functions largely useless on Windows. Yes, this doesn't apply to Posix platforms where wchar_t is almost always 32-bit. But even on the Mac, if you encounter "unichar" instead of wchar_t, it's also a 16-bit character and requires similar handling to the Windows wchar_t. These kinds of multi-platform anachronisms and annoyances are one of the reasons why UTF-8 and UTF-8 aware functions are preferred wherever possible â€“ UTF-8 is free from platform inconsistency. Sure, if you're targeting Linux exclusively, you're in a better position but remember: UTF-32 requires roughly 2.5 times greater storage. That data size makes it a loss in most cases (even in iteration speed â€“ the iteration speed is offset by the slower load speeds).
&gt; Windows 2000 and greater support characters outside the BMP, which means that multiple wchar_ts are definitely possible on Windows. This makes C and C++'s wchar_t functions largely useless on Windows. What matters as far as the specification is concerned is characters supported by locale encodings. Can you name any locale that supports non-BMP characters on Windows? If not then I can't think of any way you'd run into a surrogate character so long as you're sticking to standard functions. Anyway, I agree that UTF-8 is a better choice, because wchar_t functions are pretty much useless everywhere due to the nature of Unicode.
The recording system is pretty cool, and it's been my baby for about four years. Overall I'm pretty proud of it, but I'll have to part with it soon since I'm changing jobs. I just hope it will be in good hands once I leave! I wish I could post screenshots or even open-source some of my work, but that is a bit tricky with my employer. If you're still learning the *language* I would recommend reading K&amp;R. If you know the language and want to learn *good practice* -- i.e., how to write robust code that won't crap the bed the minute something unexpected happens -- read the GNU C Library reference. The chapters are layed out pretty well. Basically everything from "Error reporting" down to Sockets is pretty fundamental. Some topics are optional, IMHO - I have never needed to do anything with message translation or localization, for example. Then I'd read the CodingStyle -- it's a pretty sane document and has great advice about splitting large functions up into smaller simpler ones. 
Right, so the only way a program could run into a non-BMP character in wchar_t is if it uses something other than the standard library, and thus doesn't have strictly well defined behavior under the standard. My point was that Windows is arguably conforming to the standard because there's this loophole in the spec, even though the spec does effectively say that each wchar_t is a codepoint. Anyway if you'd like to know more you can go read my answers on this topic on stackoverflow, such as this one: http://stackoverflow.com/a/11107667/365496
I've used something similar to this in a few projects, and am currently writing a small library which also uses this technique internally. I always get the sense that the kinds of people who frown upon these sorts of things are the same who avoid using goto at all costs and consider any kind of C preprocessor trickery the work of the devil. In addition to what you're doing, I've also went a step further and added `indexof()` and `remove()` macros so given a list of integers you could do `remove(vec, 200)` to remove the integer `200` if it exists in the array. Due to these macros using `memcmp`s instead of real equality compares they can't be reliably used on floats (which may evaluate equal, but who's underlying bits may not be equal), and you have to be sure all the padding in structs you use is zero set before using it there (or just not use it on structs); for ints and pointers you shouldn't run into any issues. I also tend to implement `foreach` macros (`foreach`, `foreach_ptr`, `foreach_rev`...) int i, x; vec_foreach(vec, x, i) { printf("the value at index %d is %d\n", i, x); } I've never encountered any issues with these, but understand some people really dislike the idea of it.
&gt; I always get the sense that the kinds of people who frown upon these sorts of things are the same who avoid using goto at all costs and consider any kind of C preprocessor trickery the work of the devil. Well, I don't like C preprocessor stuff, gotos and the like. It's not because it seems like trickery or evil stuff - I just dislike reading code where the flow isn't obvious. You write code once, you (and others) read it many times. Also it's hard to argue something about safety in a program with a weird flow.
Thanks. I've fixed the formatting. As a practical implementation, can you comment on whether the likely issues in practice would be with the endianness and alignment?
In the example you gave, it's likely that `charlie` will be aligned to a 32 bit boundary anyway, because the compiler will probably put a byte of padding after `beta` so that `delta` will have its natural alignment. That puts `charlie` at an offset of 32 bits from the beginning of the struct, and because the struct begins with a 32 bit value, the overall alignment will also be 32 bits, making `charlie` 32 bit aligned. Of course, the compiler is not required to align each member to its natural alignment, and may have been configured not to. You can't really make any definitive statements about what will happen either way -- nothing is guaranteed, especially given that this is all undefined behavior. As to endianness, yes, the endianness of the machine will have to match the endianness of whatever values are stored in `charlie` in order for reading from it 4 bytes at a time to work.
Rewriting your example code to be more concise: uint8_t b [4]; uint32_t* p = (uint32_t*) b; This isn't portable already. Your uint32_t* might not be able to point to an arbitrary byte that's not aligned properly. So let's use a union: union { uint8_t b [4]; uint32_t i; } u; Now you at least know that b is suitably aligned for a uint32_t. Now the issue is accessing its representation with b in a portable way. Besides memcpy(), I'm not sure. I'm pretty sure that gcc encourages using a union like this, because the compiler can reasonably be able to tell that you're trying to modify its representation and generate proper code. Assuming you use the union approach, then the question is what the representation of a uint32_t is on your machine. That like you said depends on the byte order. u.i = 0; u.b [0] = 1; May give u.i the value 1, or some other value (like 0x1000000). 
It sounds like you don't understand what endianess is, and fixing that is the fastest way to resolve your problem. Endianess refers to, where an integer is stored across multiple bytes, the arrangement of those bytes in memory. The arrangement is in terms of increasing memory (byte) addresses. In this case, 32 bits, there are 4 bytes. Number the bytes 1â€“4 from the byte with the smallest bit value 2^0 = 1 to the largest 2^31 = 2,147,483,648. Little endian order is 1, 2, 3, 4; big endian order is 4, 3, 2, 1; more exotic orderings such as 2, 1, 4, 3 have existed (note that in big endian, the bits are arranged entirely in descending order). So, if you read and write a multi-byte integer on either on a little endian machine or a big endian machine, there will be no issue. However, if you write on one, and read on the other, the order will be reversed. If you read a multi-byte integer as an array of bytes, the order will be 1, 2, â€¦ on a little endian machine, and â€¦, 2, 1 on a big endian machine. 
It would help if you specified what you are actually trying to do.
C newbie here. Isn't this kind of thing rather widely used? How come homebrew solutions like this are so commonplace, instead of a well tested library?
My understanding is that newNode points to a node object, so *newNode is the node object and is the "thing like 'k'". You could have also written example 1 as int * ptr; *ptr = 55; You never needed k in that example.
You're not initializing `ptr` to any memory location before attempting to de-reference it. This will fail to run properly, but may compile. K is necessary in this context. EDIT: Spelling.
So is this kind of way of thinking about objects more common than the way given in example 1? Because the way I've been seeing it, although *newNode can be used in a sense of `newNode-&gt;data = 22;` how would I use it in the sense of `newNode.data = 22` I guess that I can't...? Because I don't have access to the actual thing, only a pointer to the memory where the thing is... But maybe that's all I need... confusing the shit out of me though. Cheers! EDIT : so `* newNode` is the thing... and `newNode` is the pointer... not the node.
The only fix I noticed for example 2 is that you need to type cast to a node before malloc newNode = (node*) malloc(sizeof(struct node)); And my rewrite of example 1 requires calling new int * ptr; ptr = new int [1]; ptr[0] = 55; Thanks. Also, the error is "Segmentation Fault. (core dumped)"
cheers solstice... It lives on the heap because malloc was used, I get that... Does that make a difference to the way that these work then? As in, the first example (as I wrote it...) couldn't be translated to variable `k` living on the heap. Because malloc() returns a void pointer? Can you ever actually access a struct that's on the stack using the dot method `newNode.data = 234` ? Or will it always be `newNode-&gt;data = 234` ? So when dynamic memory is used... the "thing" (object) will always be `* object` and the objects pointer will be `object` rather than having a system like the example one where you have object ` k ` and pointer `ptr` I know that they say that `* object` is the object but it's not really is it? thanks 
not in C you don't.... But this thread isn't really about the nitty gritty of the code that I provided. It's about the logic and comprehension on a higher level... cheers
In case 1 you had variable k that *already existed* on the stack. You set the pointer to the address of k. In case 2 you have a pointer and malloc *both* creates the space for the object *and* sets the pointer to that address. &gt; I know that they say that * object is the object but it's not really is it? Correct. It isn't the object. It is a pointer to the object. And you can have multiple pointers all pointing to the same object. &gt; Can you ever actually access a struct that's on the stack using the dot method newNode.data = 234 ? Or will it always be newNode-&gt;data = 234 ? You use the -&gt; notation with pointers. The dot (.) notation is used with addresses. So if it was struct node newNode; //a struct NOT a ptr to a struct you could use newNode.data = whatever; 
`int num = 10` is obvious, there's an object called num thats of type int and stores the value 10. Do I ever actually use the object though (example 2 scenario)? Or is it always pointers to the object? I'm finding that part kind of confusing... 
not sure if you've edited this or if I just missed a lot of it.... but : &gt;##You use the -&gt; notation with pointers. The dot (.) notation is used with addresses With addresses...? I don't think I've heard this before, maybe some confusion is here for me... What do you mean addresses? The actual object rather than a pointer to the object? That's how I understand it, but you saying addresses has made me think that perhaps you're referring to something else. &gt;##So if it was `struct node newNode;` (a struct NOT a ptr to a struct) you could use `newNode.data = whatever;` Are these two to always remain separate...? I'm not sure how to think about the object when using pointers to it... `newNode-&gt;data = 23` Is this to do with the dynamic allocation...? Are these always to remain separate? Ie, when dynamically allocating a struct the data will always be assigned and accessed using the -&gt; methods rather than the dot ` . `? 
yeah I knew, thanks. I think that the confusion is arising because I'm unsure how to actually think of the objects... I'm wondering at the moment whether this is just how dynamic memory allocation is treated? And then when doing so one never actually accesses the object directly, it's always through a pointer... so the object never actually has a name, it just has it's address saved in a pointer...
Good question -- I know of one library like that, [klib](https://github.com/attractivechaos/klib), but in this case I thought I could do "better"; this version of the macro doesn't have to explicitly mention the element type in anything but the typedef, which I thought was cool.
You are over thinking it. See [Matrixel's](http://www.reddit.com/r/C_Programming/comments/25d8mq/beginner_basic_pointer_question_struct/chg2lt4) answer below. That's about as well as I can explain it.
I am, I always do and it's so frustrating :( It'd be alright if I was actually clever but nothing ever really comes out of it!! I think the distinction that it's relating to the use of malloc, and being on the heap is helping a lot with my ease though... Its making more sense now thank you
I think that this is where I'm getting confused... So basically, the heap memory state isn't allocated until runtime (can can be affected during) so it's impossible to have an object per say whilst writing the code, one can only use the address of where it's going to be... That's kind of confusing in itself, I hope it makes sense though. thanks!
Yes, that's exactly right. When you declare an int k, the compiler knows, at compile time, that you want an int, and allocates space for it statically, and gives it a name. When you allocate memory with malloc, it has no name, and the compiler isn't even aware it exists at runtime (it's just a function call). There's no name for the returned memory from malloc; only an address. You can *use* that memory, still, through a pointer variable, which you've named so it stays around (and the pointer cell itself is a named variable allocated statically, just like int k was). This is the same thing that would happen if you did int *pi; pi = (int *)malloc(sizeof(int)). There would be no int you could name directly; only a chunk of memory that you can refer to indirectly through the pointer. 
cheers, having the memory aspect explained and verified certainly makes sense, thank you both. I think it's hard to learn independently sometimes, thing's that would take a 2 minute in person explanation can take a day! 
That kind of depends. On platforms that require reads and writes of `size_t` to be aligned, is there padding included in the bodies of the strings to ensure that? How you write the portable version depends on the answer. 
Further, size_t is a poor choice for portability since its size is commonly one of two values (4 or 8). Further, the byte order can vary. A portable read of them would thus most simply be stream-oriented, parsing four bytes as a little-endian size, and then that many bytes for the string. Then there's no alignment issues.
This matters if we know that these packed structs leave the machine. It is good practice to do that anyway.
ASN.1 (BER/DER) comes to mind but I would prefer JSON if performance is not important...
I guess it's more sane to use more proper serialization. For the size parameter at least; the string can be encoded verbatim, and so you can point directly into the memory buffer, if you want to. For example a protobuf-like serialization could be used, with a 64-bit varint that encodes the length, and then the string simply follows (including terminator). A portable program will return an error upon decoding a length value larger than SIZE_MAX.
Are you transferring the packed_strings between different machines?
Your question doesn't really make sense. You should try being a little more verbose if you are unsure of terminology. Attempting to answer the shape of the question: the compiler is free to assign registers as it sees fit according to the calling convention of the platform. In particular, quirks like the `register` and `volatile` keywords aside, any variable (even one called `c`) may ping forward and back from memory to any number of registers at the whim of the compiler. Relying on any other behaviour is unwise. If you want to learn how to interface C and assembly, I suggest you make use of Google. Some likely looking results: * http://www.codeproject.com/Articles/15971/Using-Inline-Assembly-in-C-C [C -&gt; assembly] * http://courses.engr.illinois.edu/ece390/books/labmanual/c-prog-mixing.html [assembly -&gt; C] * https://stackoverflow.com/questions/61341/is-there-a-way-to-insert-assembly-code-into-c Before attempting to follow these instructions, make sure to learn the calling convention for your target platform and make sure you put back the way you found them any registers the compiler doesn't expect to be modified.
I tried to clarify
Yes,I tried to clarify
You need to specify which things are getting ported. The data, the code, the binaries?
Bill Joy's style is the indentation style of the Solaris kernel.
oh wow powerpc assembler. This depends on the [calling convention](http://www.csd.uwo.ca/~mburrel/stuff/ppc-asm.html) if you're interfacing with a compiler or os. If not you could make up your own. e: i should add that m68k is a way more helpfull platform to program in assembler when you want to learn about foreign architectures.
ah right... I doubt I'll ever see that! 
Building each target at most once should be the default behavior. Can you send a minimal example of a Makefile that does not work as you expect?
You may not be aware but each computer architecture has its own assembly language and instruction set. The one you're asking about seems to be PowerPC. You should mention that when asking future questions about its assembly language.
OP didn't mention that this is PowerPC. Some instructions (like addis) ignore the value of r0 and always treat it as containing zero. Others like mflr use r0 normally. Thus, r0 isn't as general-purpose as the other registers and you won't be able to get your compiler to use it generally. &gt; E.g. addis 4, r0, r8 &gt; &gt; Puts 4 into r8 and treats r0 as zero. Wouldn't that put 0x40000 into r8? (are you thinking of addi?) Design-wise, there are four basic approaches I see: have a separate instruction like load-immediate-shifted that doesn't add another register, treat r0 as always containing zero and thus reduce the number of registers to 31, have no special case and require the programmer to keep 0 in r0 (or some other register), or have a special case for two-source-operand instructions that one of them is treated as zero when it's r0. This latter approach has the benefit of keeping r0 open for other uses and a more compact encoding than having a separate instruction, and less error-prone than keeping zero in some register at all times.
What other computer languages and programming experience do you have (if any)?
I've done a ton of Matlab and a semester of Java. 
What is covered in the advanced course? Have you read k&amp;r? (Do keep in mind that ANSI C isn't much like c99 or c11, but the basic concepts are still there.)
Here's the course ABET outcomes. I passed all of them, but didn't do well enough on the exams to pass the class. A student who successfully fulfills the course requirements will have demonstrated: an ability to read and write C programs that use recursion. an ability to read and write C programs that use structures. an ability to read and write C programs that use dynamic data structures. an ability to read and write C programs that use files.
You should spend time studying the class materials and doing your homework. These concepts barely breach the intermediate stage. Can I see your syllabus?
Here is the course page: https://engineering.purdue.edu/OOSD/S2014/index.html
I've found that accessing the members of the byte array and shifting as appropriate will be optimized by the compiler to be the same as dereferencing the (u32) pointer providing the byte array is declared as const. This is good enough for me. I.e. they both use a single load word instruction in assembly (32-bit). I'm just looking for portable C code that can be optimized as well as writing it the "bad way".
Ya I know it's called advanced but it's really only a 200 level course. More complex concepts are taught in some different courses not under the c programming name.
On my phone now but I could probably post the syllabus later.
I think you can make dummyfile a phony target and use order-only prerequisites. So dummyfile target will be executed first and the rest will follow. 
Thanks! My big question is, if *ptr = ptr[0] and *(ptr +1) = ptr[1], then why do we have both forms? It just seems to cause me more confusion than anything.
There's a good reason for this, and it has to do with how memory is indexed. Memory is actually indexed by byte, and pointers can point to many different sizes of structures, which is why the type that a pointer is pointing to is part of its type. When you use [] to index into an array, it does an extra operation for you that I omitted from my explanation. ptr[i] is actually *(ptr + i) which is actually *(ptr + i * sizeof(ptr)) where that second * is a binary multiplication operator, and sizeof(ptr) is equal to the size of the type ptr is pointing to. Running in 32 bit mode, an int will probably be 4 bytes, a char 1 byte, etc. Structs also have their own sizes. So the main reason to use [] is ~~to have the compiler grab the right type size for you, which is suggested, since if you mess up manual indexing, you get undefined behavior, which is bad~~ convenience. Note that this transformation occurs opaquely, as /u/pinealservo pointed out, the + operator for pointers itself performs the correct mathematical operations to allign the pointer to the next array entry. Edit: I am in error, I must rededicate myself to the study of the programming koans.
O I see. So could I eventually use operations similar *(ptr + 1 * sizeof(ptr)) to reduce heap memory needed for a program? Like sometimes you don't need all 4 bytes to successfully store an int?
~~There's really no need to use the long form. If absolutely every bit is important, you can use structs with bit fields to have fine control over how many bits your data is using. The expansion of the [] operator in C is really only useful for teaching what it does.~~ They're exactly the same, its just convenience.
I feel that the trick to understanding C is understanding its particular abstract computer model. This will naturally lead to understanding pointers, because all the mystery goes away. There are some basic concepts to get down: A **value** is, in an abstract sense, an expression that can't be evaluated any further. In another way of describing it, values are the inputs and outputs of the basic manipulations we can do. The **store** is an abstract place where bits of data (values) can be placed. The store is *indexed*, which means that you can find any specific location in the store by its **address**. An address is also a value; it's a value that indexes the store. Any value remembered by the program is in the store, and the place it's located in the store is unambiguously identified by its address. Variables tie together the concepts of *value* and *store* along with some other properties: **name**, **scope**, and **extent**. The name refers to a location in the store *and* the value that is stored there. The **scope** of a variable refers to which part of the text of a program where the name of a variable will refer to *that* particular value and store location. The **extent** of a variable refers to the length of time during program execution that the variable exists. The basic way to *get* an address is to use the **address-of (&amp;)** operator. The address is only useful for the extent of the variable; after that it becomes a garbage value and should not be used. But it can be used outside the *scope* of the variable that you applied the operator to. The basic way to *use* an address is to use the **dereference (*)** operator, which allows you to treat a variable whose value is an *address value* as if it had the value that the actual address value refers to in the store. Internalize those concepts, and you'll be golden.
My comments were in no way based on the performance of the code, but on its correctness. It would help if you defined what you were trying to port: code, data, binaries?
So when you say `int k;` there are two things this tells the compiler to do: to allocate an int-sized chunk of memory somewhere in the store, and to create a variable binding that makes the name "k" refer to whatever's stored at that chunk of memory. When you call the malloc() function, there's some magical trickery (i.e. implementation-defined behavior) involved by which it collaborates with the operating system (if there is one, which is not always the case when writing C) to do something roughly like what the compiler does for the code `int k;`. The implementation of malloc has its own variables to refer to this memory, but you don't get to look at them directly, and it could be implemented in any one of a variety of ways. A really simple version of malloc() running on a bare-metal computer might have something like this: char base[HEAP_SIZE]; You'd use the linker to assign the address of base to a value that's in the usable address space of your RAM, and then malloc would return the address to some offset within `base`. In this (extremely simplified) case, `base` is more or less what `k` is in your example. But it's more likely that your program can get memory from the OS dynamically by making a malloc-like system call to the OS rather than having to have it assigned statically by the linker, in which case the `k`-like entity moves into the kernel!
No, `x[y]` is exactly equivalent to *(x + y), no matter what size pointer is involved. In fact, you can exploit this fact in your entry to the [IOCCC](http://www.ioccc.org/) by writing 1[ptr] instead. If `x` is of type "pointer to T" where `sizeof(T)` is 4, `*(x + 1)` points at the location 4 `char`s beyond `x`. If `y` is of type "pointer to S" where `sizeof(S)` is 8, `*(y + 1)` points at the location 8 `char`s beyond `y`. If you cast a pointer to `(void *)`, the `+` operator is completely undefined. If you cast it to `(char *)`, only then does incrementing by 1 point to the next `char`. Pointers in C are not numbers; the addition and subtraction operations are overloaded to work on pointers and a subset of integers in a specific way, but it's not quite the same way as normal addition and subtraction. The reason that both notations there is simply notational convenience for working with arrays. It's the same reason the redundant `-&gt;` operator exists for pointers to structures. Just syntactic sugar! It's a little confusing to learn, but not by far the most confusing aspect of C.
Small issue: you confused malloc with calloc, it only takes one argument.
I think the primary reason that C has both forms is to accommodate arrays and pointer. Arrays are memory allocated to the program at compile or load time and pointers point to arbitrary memory, memory allocated by the compiler or at run time using malloc() and friends. There's just free conversion between an array name, which is like a constant pointer, to an associated pointer type. int foo[10]; Declares an array of 10 ints. foo in this case is like a constant pointer. int *foo = malloc(10, sizeof(int)); Declares a pointer foo1 that points to an int and the code above initializes this to an allocated space for 10 ints. In the second case, foo can be assigned to point elsewhere. foo1 and foo are not of the same type. To facilitate writing routines that deal with arbitrary size arrays, array names are freely converted to a pointer. For example, you can write a routine that searches arbitrary sized arrays or allocated space. 
Oh, right, yeah. Actually I pretty much always use calloc(). Meh. :)
Yeah, I almost always use calloc too. There's one case where malloc() can be better, though - if you access the uninitialized memory, valgrind will alert you about it (not so with calloc, since it's not undefined any more).
Thanks for all these explanations ;)
&gt; int *c = NULL; /* I always initialise all variables for safety */ Out of curiousity, could you provide examples where using a non-initialized pointer is less safe than a null-pointer? I can see that NULL would be more predictable than using whatever assigned *chunk* of memory exists, but I can't speak to the safety of it since it's usually unintended behavior anyway. (I'm not doubting you, I'm just curious)
You need to play with pointer's internal yourself until you get it (there is no shortcut). Here is one way, you might understand it. Use a simple pointer example (one using malloc) and use gdb to step through the program. At every step where pointers are involved print the value it is pointing. Lets go through an example. 1. Simple c file (simple.c) #include &lt;stdlib.h&gt; int main() { int dummy = 1; char *simple_char; simple_char = NULL; simple_char = malloc(50); return 0; } 2. Compile it with debug symbol $ gcc -g -o simple simple.c 3. Run it in gdb $ gdb ./simple (gdb) list # list the source code (gdb) start # start the program (gdb) disassemble # assembly language code (gdb) p simple_char $1 = 0x7fffffffe8c0 "\001" (gdb) step 6 simple_char = NULL; # This is the next instruction that will be executed (if we step) # i.e simple_char is pointing at random address. (gdb) p simple_char $2 = 0x7fffffffe8c0 "\001" # If we print simple_char, we can see it pointing at that random address as our previous instruction. Lets step and execute simple_char = NULL. (gdb) step 7 simple_char = malloc(50); (gdb) p simple_char $3 = 0x0 As you can see, now simple_char is pointing at NULL (i.e 0 address). Also we know from above (2) commands, that next instruction to be executed is malloc (i.e we are going to finally get a memory chunk from the operating system, which our simple_char can point). (gdb) step 9 return 0; (gdb) p simple_char $4 = 0x601010 "" Finally, simple_char is pointing at address 0x601010. What can we discern from all these information. A pointer is only 8-bytes long (in a 64-bit machine), regardless of the type of data it is pointing. Yes type of pointer (int, double) determines, the number of consecutive memory address it represents, but a pointer only points to the first location of any of these memory chunks (and we know a 64-bit machine uses 64-bit or 8-bytes to represent an address). It is the responsibility of the underlying compiler to determine, how many consecutive blocks we need for that data type (we also have our data type). Never confuse pointers with size of data type (all the pointers are same size and mostly size equal to size of the machine address size). A pointer can only store (store is not the right term, point) an address. As 64-bit machine requires 8-bytes to represent an address, that is how big a pointer is. Even if simple_char variable was a pointer to int or double, it would still be 8 bytes long. Print the sizeof(simple_char) in gdb and see for yourself. (gdb) p sizeof(simple_char) $5 = 8 I hope this was enough information, for you to know about pointers. 
One example in C would be matrices in linear algebra - a direction vector multiplied with a calloc()-ed matrix (and then normalized) will cause a division by zero.
Dereferencing a NULL pointer will (almost always) cause a segmentation fault - if it wasn't set to NULL, there's a chance that the deferencing will seem to work (but return garbage data), which is harder to notice and debug.
Can you show us the course subjects? And if you barely passed at the introductory level C, maybe you should take that one again. 
Don't have the time. I'm graduating next semester, already re-signed up for this course, and have all summer to work on my programming skills.
That's true, good point! Didn't even think of that. But there are (unfortunately) even more subtle examples... Like on some platform, if you set all the bits of an integer to zero, it could theoretically be a trap value and terminate your program once you attempt to use it (although no platform in existence actually does this, of course -- but the C standard allows for it) In C++ the problem is more real, because overwriting arbitrary objects with zero can stomp their vtable flat, which can have bad consequences.
You can't rely on malloc() returning memory that isn't all zero's, though. Its by definition, undefined.
I'd want the 'type' to execute even if gcc doesn't fail Edit.. ok, so if I have it on the next line, it will execute
In basic terms, you want to go through each element in the list. Once you find the value that you want to insert after, you make that elements next pointer point to the new element. You then want the inserted element's next value to point to the element that is next. Drawing it out may help
I tried this, and it doesn't work: void insert(struct Item* pi) { char partNum[10]; char partNum2[10]; struct Item *temp; char *pp; printf("Enter a part number: "); scanf("%s", &amp;partNum); while (pi != NULL) { if (partNum == pi-&gt;partNum) { printf("Enter a new part number: "); scanf("%s", &amp;partNum2); pp = partNum2; temp-&gt;next = pi-&gt;next; pi-&gt;next = temp; } pi = pi-&gt;next; } }
Want me to write the solution for you?
If you wouldn't mind, I am so lost with this problem :(
Start with what you know and gradually work from there. Name the variables that you will need, set their initial values and set up your prompts for input. Then work on the rest of the problem from there. Take it a piece at a time and guess and check if you have to. Don't give up before you start. 
Thanks, that comment made me check something that fixed my problem.
Do you already know how to perform numerical integration? (there are many methods to do it, but you can just pick one of them) If not, checkout the wikipedia article. I'd recommend to just use the trapezoid rule, since it's pretty much the simplest one. Once you've understood the method for how something is integrated numerically, you should be able to see that it's fairly straightforward to implement in C.
You're in good shape, actually. Only one major issue: - Consider the value of 'rolls' the 2nd time you go through the trial loop (and also every subsequent time). Fix that and you're good. A couple of minor issues. - The calculation for x will round down unless you cast totalRolls to a double. - If you could be consistent in your indents in the if/else, while and for clauses it would be easier to read. - Variables 'rolls' and 'totalRolls' don't need to be static since the main() function is only called once.
What is wrong with the value of 'rolls' throughout the loop?
The bitcoin tip for 22.5100 milli-bitcoins ($10.00) has been confirmed and collected by /u/k21 **[What's this?](https://www.changetip.com/tip-online/reddit)**
You're welcome. If you have any more questions I can help you with and I happen to stumble upon them, I'll be sure to answer them to the best of my knowledge. 
&gt; if (partNum == pi-&gt;partNum) One problem you have is here. Both partNum and pi-&gt;partNum are pointers to char so when you compare them using == you're checking if they have the same value (i.e. the same memory address) rather than checking if the content of the two arrays are the same. I think you will also need to allocate memory at some point to create the new node in the linked list, but that is a different problem.
&gt; *x+1 = 100; &gt; *x+2 = 200; &gt; *x+3 = 300; This is invalid c code. Correct form is *(x+1) = 100; *(x+2) = 200; *(x+3) = 300; In your code, *x is the dereferenced form in itself, i.e it is an integer variable, and we know int a = 1; a+2 = 3; is wrong (lvalue required as left operand of assignment). Therefore, to dereference next address from x we need to get the address first (by enclosing the offset inside a bracket), and then de-reference. Other than that, pretty good explanation :) 
Woosh
you are of course right, I did write the piece whilst eating and I didn't think to run anything through a compiler to double check my code haha ;) Lazy me.
I just pointed out, because so that the original poster would not get wrong direction. You have already mentioned about de-referencing quite well in other parts, so no complaints about the overall post.
yeah I fixed the bit you mentioned, and the call to malloc() that someone else mentioned.
khan academy would be a good place to hit up too. He explains integration pretty well
Post the code you already have, point out the exact problem you are having, and maybe then we will help you with your homework.
He's talking about plain C, though. Other than that, I fully agree with you: Break it down. 1. Do it with pen and paper for a single example 2. Make sure you can enter data into a single-linked list or something like that in C (don't do any math yet) 3. Transfer the calculations you did by hand in 1 to the C code in 2 and make your single example work in C 4. Unless you're doing it wrong, you should have a general solution already in 3 A small notice is that you probably want to use a floating point datatype for the task. Double is a good one. 
This is a maths problem, not a programming problem. You don't answer it by rolling dice, virtual or otherwise.
How about creating the variable in main and give a pointer to the input fuction? [http://pastebin.com/0XwhsP6V](http://pastebin.com/0XwhsP6V)
Thank you.... I guess they have to stay in their scope then! I knew that.... but wasn't sure If I could create a pointer and use that within main. I'm working my way up to building a basic address book... so just going through a few thing's ! 
yeah my code works... I didn't mean to imply that It didn't, I was just wondering :)
No if you allocate memory with malloc() you can use it outside of it's calling function. The memory is allocated from the heap, not the stack, so it doesn't care which function you are in when you call it. The tricky part is that you would need to free() that memory at some point which can be easy to forget if you are freeing something in a different function from where you malloce'd it, so it's generally best not to do it. Do something like: int takeUserInput() { int num; scanf("%i", &amp;num); return num; } There is no real reason to pass around a pointer in this situation. edit: Oops, somebody already said this.
Cool cheers dude... The reason I'm asking this question is that I'm going to make a little address book (purely for learning's sake) so I was just trying to break the problem down into smaller bits... Basically it's just going to be a struct, which has three fields : * name * number * next struct So it'll be a linked list... Then I'd like to make it so that there's a hash table, and the struct's are stored alphabetically. [0] = A... [1] = B... etc etc... But first I'm just making the little bit's. I wasn't too sure how to get user Input for the actual structs. I guess that I'll have to create a function `addNewUserStruct` that * get's an int off user * gets a name off user * assign's these names to newStruct-&gt;name and newStruct-&gt;number * assign's the pointer to the next struct, or NULL. I'm just trying to break thing's down a bit so I can actually do it :)
Even if you create a pointer to a variable in takeUseInput, the variable will still be gone when it is used in main.
I'm not sure.... the second perhaps as it doesn't need to return anything? 
For something the size of an int there is no real difference. In my opinion returning the value is clearer. If you want to fill a larger struct, however, using a pointer will avoid the need to copy the entire object on return.
Are you a EE (Since you took ECE 264 instead of CS 240)?
the aim of this is biting of little pieces as I work my up to making a (very basic) address book that has structs, linked lists etc.... That's probably why it feel's very contrived. 
I tried to make it as stripped back as possible... there's no point in this other than a piece of the puzzle. The scanf checks can be done after. I'm going to try and make a little address book. Just name &amp; number. So they'll be structs with 3 elements, * Name * num * next node And I want to eventually make it so the user can input the information. Maybe I should try and design the structs first and then get user info? IDK cheers 
Try a dispatch table. http://en.wikipedia.org/wiki/Dispatch_table 
What's is it about the switch that you want to avoid?
No matter what you do, you're going to have to write a ~line of code per message id - whether that's a case in a switch statement or to initialize an entry in your table of fn pointers. I'd say it's simplest to start with the switch statement. In fact, a switch is kind of tailor made for this situation - your message id's are all ints. If the message id's were strings, that would be a different story. If your were using FORTRAN you could consider using a computed goto (wow, does that bring back memories). But, since you're in C it's not a consideration. 
As others have already pointed out, a switch statement is probably a good option here. If you are hesitant because it's a lot of repetitive code, that's what macros are for: #define CMD_CASE(messageId, func) case messageId: func(data); break; ... switch(messageId) { CMD_CASE(MSG_INIT, init); CMD_CASE(MSG_DATA, processData); CMD_CASE(MSG_SHUTDOWN, shutdown); } 
1. There's really nothing inherently wrong with a big switch statement, so use that unless it is unmanagble - it's the easiest option. 2. Another approach is that you do use a function pointer array, but you are smart when you assign message IDs. Start at 0 or 1. You're unlikely to use all the 4 billion message ID's, so your function pointer array will be small if you assign ID's without gaps. 3. Yet another variant of the above is that you group message iDs. e.g. use the top 16 or 8 bits of the message ID as a group. You then implement a (hopefully small) switch() on the group ID, which each look up in the respective array of function pointers of the message ID. (Again, start assigning message id at 0 within each group. 4. You might not need an array of function pointers where you directly index the function based on the message id. A linear search through an array that maps message id to function pointer is not gong to be an issue for up till a 100 (or probably more) different message IDs. 5. If you have large gaps in the message ID's, and a huge number of message IDs, you might want to use a hash table for the function pointers instead of an array. 
&gt; int x,y,i,j,a[i][j]; C doesn't allow dynamic length for arrays, you have to initialize them with a fix dimension. If you don't want to do that, you need to allocate memory on the fly.
Oh man, i'd just spend half a day figuring out how to map ids to existing function addresses. It would be so sweet!
You're half right. 
Yep, you can do it in C99 or later.
in this particular case, 'i' and 'j' are junk at the time the array is initialized, so the problem remains.
Actually, compiler support for VLAs was made optional in C11, so you can only say for certain that you can do it in C99.
I'm hesitant because, while a normal switch statement is probably the best way to go, it always feels so wrong to do it that way. I really like this solution though. Its the same idea, but it at least cleans up the code space a bit.
You're right, I'm actually dealing with a CAN message, which only goes up to 0x7FF in the mode i am using. I just didn't want the question to get too complicated. Unfortunately, I need to be able to handle potential messages from the entire range. Table sounds like a good idea though, just didn't want to complicate the code base with searching and sorting algorithms, but a binary search isn't unreasonable. 
One thing I see that no one has mentioned yet that could cause some problems is that you are using 1-based indexes when C is a 0-based language. by that, I mean your for-loops would be better off looking more like for (i = 0 ; i &lt; x ; i++) { for (j = 0 ; j &lt; y ; j++) { // ... } } This becomes very important when you index into your arrays, so a[0][0] is the first element, not a[1][1], and a[x][y] would be out of bounds.
The default behavior is enabled though, if I'm not mistaken?
try using gets() to retrieve the value inputs as strings, and sscanf() the values from them
Get yourself another book. Never use gets().
[Computed gotos](https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Labels-as-Values.html) are available in gnu C, if you're not picky about writing standard C. Whether a switch is appropriate to the situation or not depends on how general you want the code you're writing to be. If your protocol has a 32-bit message ID, it's likely that the designers expected it to be pretty general, and for products that use it to have some way of choosing a subset of the full range for their particular use. If your code is for a specific product and its message IDs are fixed, then a switch statement is a good idea. But if your code is for a general protocol library, then you may not know what set of messages any given library user will need to use. Then a switch statement is useless, and you need a function pointer table (which is more or less a computed function call rather than a computed goto). Alternatively, the library user could supply a dispatch function that maps IDs to function pointers. The user could then use a switch statement. But the actual generated code for dispatch might not be any nicer than a cascade of conditional branches if the IDs aren't grouped together. It's up to the compiler what sort of dispatch code gets generated, and strategies differ between compilers. It might even compile to a binary-searched jump table!
IMHO static initialization is always better if you want a structure full of zeros. struct foo *foo = malloc(sizeof(strict foo)); *foo = (struct foo){ .bar = 42 }; foo.bar gets set to 42 and everything else is set to 0. I think its a nicer and more explicit way to initialize memory. You can always zero it with a *foo = (struct foo){ 0 };
There's a lot of confusion surrounding arrays and pointers in C. They are actually distinct types. An array variable in C, like all other variable types, keeps track of the size of its allocation. That is, the `sizeof` operator will return the number of chars of space it occupies in the store. A variable of pointer type only refers to a single element of the type it's a pointer to; i.e. `sizeof` on a pointer type refers to the storage length of an address, and `sizeof` the type a pointer refers to is the storage length of a single value of that type. The size of the type the pointer refers to is used by the compiler to implement pointer arithmetic; adding 1 bumps the address value of the pointer by that size so that it points to the next item in memory (assuming there's one there, which it's up to you to keep track of). So, array variables are the only things that are properly called arrays in C, and those can only be allocated by the compiler via a variable declaration, whether your compiler supports variable-length arrays or not. The memory returned by malloc() is never an array; malloc() returns a value of type (void *), which is clearly not an array. So how come you can look up a value in malloc-returned memory via square brackets just like you can in an array? More confusion ensues when you use the square bracket notation to refer to a location in memory. This syntax has absolutely nothing to do with arrays; it only works with pointers! An array variable that has an element indexed via square bracket notation is first decayed to a pointer value, and then the pointer value and index are added. That is, the syntax `x[i]` means *exactly* the same thing as `*(x + i)`. And when you use an array variable where a pointer is expected, the address of the first element of the array is used as its value. So this is really a case of an array acting like a pointer rather than pointers acting like arrays. And yet more confusion arises when you declare a formal function parameter with square bracket syntax. If you were declaring a variable, that syntax would give you an array variable. When you use it to declare formal function parameter, you instead get a pointer-typed parameter!
I'm on Chapter 28 of 32 of my current book. C Programming: Absolute Beginners guide by Perry/Miller. I Would like to finish the last couple of exercises because I've made it this far. I've got my second book lined up. Programming in C: Third Edition by Stephen Kochan. Should I just skip to that? I feel like a loss of accomplishment if I can't figure this out lol
Look at your for statements *very* closely. This is why consistency is very important. Also, I believe that you have switched to using puts() in your input section instead of figuring out why printf() wasn't working. Finally, putting newlines at the beginning of the next line to output is just plain weird.
Do you have a different book you would recommend for someone new?
I like to reframe it as C is offset based, while other languages its an index. Which is also closer to the reality, and unifies a[1] being the same as a + 1.
Wow. At least I can now avoid VLAs like I've always wanted to and have a technical justification :)
Excellent summary. So many things conspire to blur the boundary between an array and a pointer to its first element, but understood as you describe the boundary remains clear.
Hint: a semicolon
No you shouldn't. But the fact that the author of your books even suggests to use gets() says a lot about the quality of these books. gets() is a function that introduces a security hole into your program, regardless of how you use it. gets() reads user input into a buffer in an unbound fashion - there is no way to avoid a buffer overflow. If the user inputs a string that is longer than it should be, your program will most definitly crash.
Your for-loop doesn't have a body because of the semicolon. for (ctr = 0; ctr &lt; 3; ctr++); ^
I'm looking at the book right now, and it totally doesn't have a semicolon...
Totally switching to my second book. 
It shouldn't have a semicolon, but you added one in your code.
&gt; If the user inputs a string that is longer than it should be, your program will most definitly crash. Noâ€”your program will have undefined behavior. Crashing would be the *good* outcome! The bad outcome would be that your program *doesn't* crash, but produces erroneous results. The really bad outcome would be that your program begins executing arbitrary code supplied by somebody on the Internet.
Thank you for correcting me. /u/zifyoip is absolutely right â€“ in the best case, your program crashes. 
Try using strncpy instead (I know it says cplusplus.com but the function is also available in C), http://www.cplusplus.com/reference/cstring/strncpy/ The warning shouldn't be ignored, especially if you're developing software that others will use. As you may know, misusing strcpy is one of the most means of exploiting a buffer overflow. Even though it sounds like you're using more correctly than most, I personally use bound checking and/or strncpy to ensure safety.
You should always use strncpy instead of strcpy. In the rare cases that I use strcpy, it's because of one of these two reasons: * I want to be able to exploit my program. * I'm writing one-time software and am being lazy. Seriously though, in 6 months you will have forgotten almost everything about your code. Let's say you revisit it, change a couple of string sizes and so forth... it would have been a lot easier to just do `strncpy(buf, str, BUFSZ)` instead of having to check each and every `strcpy(...)` to see if you're using a changed size. If you're lazy, you can even try doing something crazy, like write a wrapper: char *strcpy2(char *dest, char *src) { return strncpy(dest, src, sizeof(dest)); } Just kidding. Don't do something like that. `sizeof(dest)` is equivalent to `sizeof(char *)` which evaluates to the size of a pointer. You'll note that your buffers will be passed as pointers even if they are declared as `char buf[BUFSZ]`. Don't try and use `strlen(dest)` either, as it will either cause a segfault (or some undefined behavior) or it'll return the wrong size (or if you're extremely lucky, it'll return the right size, but do not count on it). **TL;DR: Use `strncpy`, always.**
Middle paragraph? Paragraph 2.5? Honestly I don't understand why you're doing whatever you're doing, but use `strncpy` anyway. It's safer, and maybe one day you'll accidentally change something, or someone else will, or you'll make a small typo somewhere.
Write code to compute the functions ln(x) and e^(x), and then compute x^(y) as e^(yâ‹…ln&amp;#40;x&amp;#41;). You can use Taylor series to approximate ln(x) and e^(x).
Well it's a bad thing to not know how the increment operator works. It's also a bad thing to not know what the conversions from one type to another are in arithmetic expressions. Anyway, if you're confused about fundamentals, have another look at K&amp;R, particularly the appendices which go into gory detail about how the language works. 
http://www.amazon.com/The-Puzzle-Book-Alan-Feuer/dp/0201604612 Who needs K&amp;R? :) I learned most of my C through this book.
For continuous "sharpening," follow programming blogs, programming subreddits, do /r/dailyprogrammer challenges in C. Here are some things you can do right now: * [A Quiz About Integers in C](http://blog.regehr.org/archives/721) * [What Every C Programmer Should Know About Undefined Behavior](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html) (be sure to follow all the links to background information) * Go through K&amp;R. * Study the Linux kernel. These are some of the sharpest C programmers in the world. Articles like these make for good entrypoints: [C11 atomic variables and the kernel](http://lwn.net/Articles/586838/), [Linux kernel design patterns](http://lwn.net/Articles/336224/) * Similarly, study OpenBSD's efforts. They put a lot of effort [into correctness and security](http://insanecoding.blogspot.com/2014/04/common-libressl-porting-mistakes.html), fighting against C's tendencies away from these. 
Sounds like a good recco. I will definitely give it a read.
Wow this makes sense. Regular quizzes will definitely help. I will try to get regular on /r/dailyprogrammer. I wrote a small driver char drivers years ago and have been taking keen interest in Kernel, and I couldn't agree more that, they are some of the sharpest C Programmer in the world.
If you haven't already you should read "C Traps and Pitfalls" by Andrew Koenig. It's based on a [paper](http://www.literateprogramming.com/ctraps.pdf) which is available on the web. Also, "Expert C Programming: Deep C Secrets" by Peter van der Linden. And finally, keep a good reference book around. Instead of K&amp;R I prefer "C A Reference Manual" by Harbison &amp; Steele, but there's not a C11 version out yet.
One thing to keep in mind when reading Linux kernel source is that the kernel developers are sometimes willing to take advantage of gcc-specific behavior. This isn't necessarily a problem, and some platform-specific behavior is unavoidable in a kernel, but it's something to be aware of if you want to hone your knowledge of the actual C standards.
Don't be afraid to read the actual C language specifications and have them handy for reference. If you have a question, learn where to find it and how to interpret the text that determines the answer. After you take a quiz, look up the answers in the specification and see how they jive with the quiz-maker's answers. You may actually find some of them to be incorrect, or dependent on a particular version of the specification.
What was so bad about gcc?
May I ask what you need to migrate? I'm curious what the differences are between Turbo C and GCC / standard C99
Well, Turbo C is really old; it predates the ANSI C/C89 standards, though version 2 probably supported the draft ANSI standard. You could probably put gcc in a fairly compatible mode as well, though, as it's also really old. Mostly likely the problem is not with the language itself, but with supporting libraries. The C library itself is *very* basic, and most programmers supplement it with some platform-specific libraries such as those supplied by Windows, POSIX, or in this case Borland's implementation.
That sounds like a nightmare. Get a distro that isn't minimalist and gcc should come with it and work trivially. Gcc hello.c. Nothing more if you don't need it. 
I was going to mention this in my other post, but there is a tutorial on small executable sizes for Linux using gcc. Basically you can compile with no standard library and it will drop the overhead to 1 KB or so. http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html http://web.archive.org/web/20111214171623/http://www.phreedom.org/solar/code/tinype/
The Turbo C memory models don't make a whole lot of sense on modern systems. The segmented memory model doesn't exist in protected/long mode.
Plan 9's standard library has nice Unicode string functions. http://plan9.bell-labs.com/magic/man2html/2/rune http://plan9.bell-labs.com/magic/man2html/2/runestrcat 
gcc should actually come with a fairly standard set of libraries, other libraries are available from your distribution. Do not randomly download stuff from the internet. Use the package manager. Notice that there are a few libraries that don't exist / exist in a different fashion under Linux / Unix. For instance, there is no conio.h. Unixoid systems instead have a library called curses (or ncurses for an extended version) that is far more powerfull. Of course, you have to pass the right linker flags to gcc when using that. TL;DR: How did you install gcc? Did you use packages provided in your distributors package manager?
GCC is easiest to install because it is probably already there. GCC is easiest to "start using for very simple needs, like just byte stream processing". For example, a (simple) swap case utility involves creating a file called swapcase.c: /* swapcase.c - swap case of letters read from stdin and * write to stdout */ #include &lt;stdio.h&gt; int main(int argc, char** argv) { int c=0; while((c=fgetc(stdin)) != EOF) { /* Swap case of c, note: assumes ASCII is still everywhere */ if((c &gt;= 'a') &amp;&amp; (c &lt;= 'z')) { c += ((int)'A') - ((int)'a'); } else if((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) { c += ((int)'a') - ((int)'A'); } fputc(c, stdout); } return 0; }; Running the compiler: $ gcc -o swapcase swapcase.c And testing: $ echo 'this IS a test 01234' | ./swapcase THIS is A TEST 01234 I genuinely can't see how that could be much simpler.
&gt; But I was in a hurry then, and get back do MSDOS without further investigation. Which libraries did you use under DOS then? If it was plain ol' standard C without any Borland-specific stuff then the same C should work under GCC.
&gt; reading and writing directly into memory addresses by using pointers, etc. As in raw physical memory access? That's not going to happen under Linux without some fiddling. 
If you're looking for small C compilers, have a look at [TCC](http://bellard.org/tcc/), and [PCC](http://pcc.ludd.ltu.se/) is also still around.
I admire the people who study the specification, but I'm one of those people that can't really learn by reading or remembering, I can only learn by doing. Enter `hacking`! Create exercises for yourself, missions if you will, where you take advantage of "bugs" caused by incorrect C grammar and so forth. For example, take a look at this code: int prevent_overflow(int balance) { if (balance + MAX_WIN &gt; INT_MAX) { fprintf(stderr, "You already have enough money.\n"); return -1; } else { return 0; } } This code will most probably assemble into something like this: push %ebp mov %esp, %ebp xor %eax, %eax leave ret In other words, it will always return 0. But why? Aha! `balance + MAX_WIN &gt; INT_MAX` will **NEVER** be evaluate to true^* because even if `balance` is `INT_MAX-1` and `MAX_WIN` is `2`, the left hand side of the expression will become `-2147483648` (or `0x80000000` `==` `INT_MIN`). Now, let's say you've just read this somewhere, create an exercise where you can leverage this knowledge to exploit something (maybe make a function called "success" which is never called and try to call it). You'll have a lot of fun and you'll get a really keen eye for correct grammar. Â­ Â­ Â­ Â­ Â­ Â­ Â­ ^Â­^* ^(implementation specific)
&gt; even if `balance` is `INT_MAX-1` and `MAX_WIN` is `2`, the left hand side of the expression will become `-2147483648` (or `0x80000000` `==` `INT_MIN`). You do not have this guarantee. You cannot assume that `(INT_MAX - 1) + 2 == INT_MIN`. Overflow of a signed integer yields undefined behavior, which means that if it happens you have absolutely no guarantees about the behavior of any part of your program. This is why it is important to read and understand the language specification. You are making an assumption here that is not guaranteed by the language. Unfounded assumptions like this can lead to bugs. You should read "[What Every C Programmer Should Know About Undefined Behavior](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html)" (and [part&amp;nbsp;2](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html) and [part&amp;nbsp;3](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html)). Also "[A Guide to Undefined Behavior in C and C++](http://blog.regehr.org/archives/213)" (and [part&amp;nbsp;2](http://blog.regehr.org/archives/226) and [part&amp;nbsp;3](http://blog.regehr.org/archives/232)).
That's definitely possible. You can mmap() /dev/mem.
You're absolutely right that there is no guarantee, this is just what happens most of the time due to the way numbers are represented in memory. You're also right about why it's important to read and understand the language specification -- my example was just to show how exploiting deliberate bugs in code can help you understand some of the no-no's of C.
I absolutely have no problem with reading standards, or whatsoever. What's the problem is, I tend to forget the stuff I don't use. I was thinking of doing regular exercise, liked the one you suggested. Thanks.
A good part of day of tomorrow defintely will be spent to learn about Undefined behavior. A lot of people are are recommending this one.
Thanks for the recommendation. 
+1 for TCC. TCC is hands down the easiest C compiler to get up and running with. And it seems to produce pretty good binaries too.