C++ masks and hides implementation details that you will have to learn (and write) when using C. In this sense it is helpful to learn C in order to have a deeper understanding... But, this is also true about JavaScript and many other languages. You obviously don't need to learn C before you program in JavaScript and the same is true for C++. So, no, you don't _need_ to learn C in order to program in C++ (or any language) ...but learning C will give you a deeper understanding.
Emacs + [ggtags](https://github.com/leoliu/ggtags) or maybe [CEDET.](http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html) See also [this page.](https://tuhdo.github.io/c-ide.html)
Not trying to start a flamewar, but I dislike modal editors because they feel unintuitive and inferior to real-time editors. At least, that's my opinion. Full disclosure: I am an Emacs user.
&gt; I've opened the docker image, and run `whereis dlfcn.h`, which gives me dlfcn: `/usr/include/dlfcn.h` That one would only be used when building software to run in the container itself or in another equivalent environment. Your code, which targets a different environment, is built using a different (cross-)compiler and a different set of headers. 
Wrong language, wrong sub. 
But this leads to issues when name to enum conversion is needed, as mentioned in the link.
Maybe it wasn't clear from your comment what your proposed change was. I stand by my statement that concise code is better than 'fast' code almost all of the time. 
You need `undef` too, it's an error to try and redefine a macro that already exists
This is great. I appreciate it.
It seema 'correct' but I would not call it 'good' because it is difficult to notice at a glance that this function does not dereference a wild pointer. It definitely should have a comment above the while, stating that in the case of one of the strings being shorter, the loop is exited in time.
The disadvantage of your approach is that you perform two checks inside the while-loop for every character that is the same. What you could do instead, which (at least in my opinion) will also increase the readability of the function because it makes it more clear that you will never dereference past the end of the string, is to increment the pointers as long as both strings are equal and non-terminated, and then only do a comparison of the first potentially non-equal character: ``` int qqwy_strcmp(char* stra, char *strb) { while (*stra &amp;&amp; *strb &amp;&amp; *stra == *strb) { ++stra; ++strb; } if (*stra &lt; *strb) { return -1; } else if (*stra &gt; *strb) { return 1; } else { return 0; } } ``` [Runnable example](https://repl.it/repls/StimulatingUnhappyCollaborativesoftware) Depending on your liking of syntax this can obviously be 'refactored' to: ``` int qqwy_strcmp_alt2(char* stra, char *strb) { while (*stra &amp;&amp; *strb &amp;&amp; *stra == *strb) ++stra, ++strb; if (*stra &lt; *strb) return -1; if (*stra &gt; *strb) return 1; return 0; } ``` but personally I think I prefer the readability of the former.
Three comments: 1) you iterate through the strings twice (the first time to find their length). While this does not change the time complexity in O-notation, it will mean the implementation is a constant time slower than an implementation that does not do so. 2) Why `return (res);` instead of `return res;`? 3) There is too much going on at the same time on the line `res = *ps1++ - *ps2++;`. I think `res = *ps1 - *ps2; ++ps1; ++ps2;` is a lot more clear.
By the way, after looking up the definition of `strcmp` again, I realized that there is no reason to always produce `{-1, 0, 1}`. Any value less than zero or greater than zero is allowed when the first string is lexicographically less than or greater to the second respectively. This simplifies the function to: int qqwy_strcmp(char* stra, char *strb) { while (*stra &amp;&amp; *strb &amp;&amp; *stra == *strb) { ++stra; ++strb; } return *stra - *strb; }
1) you're right. 2) Norme impose by my school. 3) this notation save me the curly brace {} of the while and i like it. Thx a lot for your comment :) PS: you can find my other implementations of the libc [here](https://github.com/nihuynh)
But both names start with the letter L and end with S.
As pointed in the link, this works fine for small value, positive, dense enums. If for some reason your enum starts at value 1000, you're creating an array with 1000 NULL char pointers before your first meaningful data. Not sure why you would need that however.
No it doesn't. The switch does, name to enum is easily achieved by looping over the array...
Well for starters unlike windows you can compile and run C and C++ out of the box. It also has a better shell/terminal which you're gonna use a lot while learning the language. 
Are you so confused you can't even explain what you're confused about?
&gt; this reported an error Thanks for telling us what it was.
so what's wrong with this compound literal 's grammar?show me some guide？
Dude, paste the whole compiler output with the error message
gcc only gives a warning, but yes that's correct
 enum e { foo, bar } const char *const tab[] = { [foo] = "foo", [bar] = "bar" } const size_t ntab = sizeof(tab) / sizeof(*tab); const char *e2str(enum e e_val) { return e_val &lt; ntab ? tab[e_val] : NULL; } I can't argue that this is any less concise than the original.
Just random guess. It could be that VS2017 compiles this as C++ and C++ does not support compound literals very well. Try to compile it with a C compiler.
Compiles on my machine.
"Severity Code Description Project File Line Suppression State Error (active) E0029 expected an expression C\_Programming\_practice d:\\C\\Hello World\\C\_Programming\_practice\\C\_Programming\_practice\\C\_Programming\_practice\\C\_Programming\_practice.cpp 1465" here it is,sorry i use VS in non-English,install language pack took a while\~ 
&gt; What's the difference between a readonly array (the char** array) that describes an enum and a function (the switch statement) that describes an enum? One is a table in the data segment, the other in the code. I have seen it make a huge performance difference if the compiler doesn't do the switch-to-table transformation.
thx\~,i\`ll give a shot, happy if it is not a invisiable grammer error\~\~ and thx a lot!
I would love the reason they have for the requirement to put parentheses around return values. Please share, because it is the first time I've heard something like this ^.^!
I think it for readability, I try to ask next time
sorry,i didn't mean that,i am trying to express my question in english,in fact am both newbee in C and English,sorry if i didn't put it right,next time i'll try to make some improve
Your code formatting gave me cancer.
Yep, especially if you have bitflags this will be horrible
Please don't post this kind of video. Also, C++ is off topic in this subreddit.
OK. I just mean the array of structs treats the string and the value as equal in the sense that neither can be accessed directly. I guess the difference is when the enums are negative and/or a sparse set.
MSVC is almost fully C99 compliant. I don't remember seeing compound literals in the list of exceptions.
Files ending in `.cpp` are assumed to contain C++ code, not C, and C++ does not support compound literals.
thank you very much! this explain a lot! and thank you for your gentleness as well! May the bug be away from you!
I think it’s logically correct, but one should strive when writing code for it to be self-evidently correct. One needs to think too hard to know if this code is correct.
True, but the compiler should be making that optimization if possible, turning it into 3 instructions total. Or 6(ish) if you want bounds checks. Assuming the compiler will do the optimisation, is there much of a difference?
Or in short: check_output(['file', '--brief', '--mime', '--', some_path])
No self-promotion unless it's specifically about C. No, it doesn't count as “specifically about C” because you could write your application in C.
libmagic already exists...
Hi! I'm the author. I am aware of libmagic, file(1) and such, But I needed something small and portable that I can integrate easily in my code.
The null check is the responsibility of the caller according to the standard C library. All of the string functions in the C standard library take in "a pointer to a null-terminated string". NULL doesn't point to anything, ergo NULL is not a "string" and isn't a valid input to these string functions, and the behavior if you pass in NULL is formally undefined. However, depending on what the application is, it may be better to make these functions check for NULL anyway. I previously worked on an embedded system in which there was no task to terminate; the whole system would simply crash and have to be rebooted if you dereferenced NULL. Thus, we put in asserts to check for NULL (so you could catch it in the debugger), and decided that our implementation of the string functions would return some sensible value rather than crashing if the debugger wasn't available.
I've taken some time to implement a slightly more mature library with documentation based on this ad-hoc example, including early-returns and proper support for `break` and `continue`-statements: https://www.reddit.com/r/C_Programming/comments/9002tx/a_simple_library_to_provide_raii_in/ It uses a lifetime stack for the early return functionality, but this stack is implemented as a linked list, where each nested `raii_with` becomes the new head of the list. The list is implemented using variable shadowing to be able to keep on doing this when nesting `raii_with`-calls.
RAII is so closely tied to OO, I don't think it's correct to call it RAII in a non-OO language like C. To me this looks more like Go's "defer" construct.
I heard you have to rob an Emacs user for your initiation ritual 
Especially similar to Go's defer construct in that both use heap allocated lists to maintain the deferred functions to be run.
Cool! I guess it's more performant because you encoded the magic right into the source code, right? Not criticizing, just wondering if that's the reason why.
I have always found the integrated debug functionality in Code::Blocks to be very flaky; as well as doing what you describe, it often hangs , or doesn't work in various other ways. I eventually changed to a different IDE where the debugging works a lot better (QtCreator). 
Do you mean to have the trailing semi-colon after your age &gt;= 16 check? It terminates your if statement and makes it do nothing.
You should strdup char choice. You don’t malloc anything to it so scanf causes a buffer overflow.
Take a close look at this line: scanf(" %c", choice); If you don't see it, look up what type of arguments `scanf` expects. 
Careful with `extern inline` as the semantics are 100% different between gnu89 and newer standards. The semantics can be changed with compiler flag and function attribute as well. [I just changed the Linux kernel to always use gnu_inline semantics](https://lkml.org/lkml/2018/6/21/478). [This is my favorite article on the semantic differences](http://blahg.josefsipek.net/?p=529).
Also, the combination Eligible if age &gt;= 16, not eligible if age &lt; 60 seems odd...
Can you explain this in more detail? While any language that allows some kind of polymorphism (so not only class-oriented languages like C++ but for instance also Rust and Haskell) is able to fully hide the fact that the construction/destruction of a type is specialized, it does not alter the fact that you are performing resource acquisition and relinquishment when an instance of that type goes in/out of scope respectively. Go's "defer" construct (which I didn't know about, I have no experience with Go), seems more closely modeled after GCC's non-standard "cleanup" attribute. I modeled this library after Python's `with`-blocks (See [PEP 343](https://www.python.org/dev/peps/pep-0343/); maybe there is another, more accurate name than RAII that relates to block-scope resource handling, I'd love to know. :D
Just for correctness' sake: This library does not use a heap-allocated list, but rather a stack-allocated one. (every nested `raii_with`-block allocates a new head for the list, which goes out of scope at the end of that block). I think this is one of this library's great features, since it seems better than either managing an explicit lifetime-object that has to work with heap-space, or create some global pre-allocated stack of some arbitrary maximum size (which takes up unneccesarily much memory in small programs and ends up being not large enough for complex programs).
Remove the semicolon on the line: If(choice == ‘y’) ; ...and replace with a bracket {
Well you don't tell us what it's doing, so I'll just note one error I spotted. You say **if(age &gt;= 16); { ... }** and this is almost undoubtedly an error. What this is saying is "if age is greater than or equal 16, then perform the empty statement and then do everything inside these braces regardless of what the if statement did." Remember that all statements in C are either: * An expression followed by a semicolon, such as **i++;** or **a = f();** * A number of statement enclosed inside braces, such as **{ i++; a = f(); }** * Or the empty statement, a single semicolon. So what that if statement does is... nothing. If age &gt;= 16 then do the empty statement and then continue on. And as someone else mentioned your scanf line is wrong, and should have given you compiler warnings. I think part of the problem here is your formatting. It is bad. You didn't use code tags correctly when posting so I don't think I can see your indentation, but the braces are all kinds of messed up. Adopt a clean, consistent style and don't do stray from it. This seems like arbitrary meaningless advice, but consistent and readable code is very important. I've done my best to fix up and format your code. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { printf("Welcome to the age verification program.\n"); printf("Enter your name: "); char name[16]; scanf(" %s", name); printf("Hey %s ! To continue please enter y and for abandoning enter n&gt;&gt;&gt;&gt;&gt;&gt; ", name); char choice; scanf(" %c", &amp;choice); if(choice == 'y' ) { printf("Please enter your age now: "); int age; scanf(" %d",&amp;age); if(age &gt;= 16) { printf("Thank You %s for completing the age verification. Since your age is %d you are eligible to participate.\n",name,age); } else if(age &lt; 60) { printf("Sorry! But you are not eligible.\n"); } } else if ( choice == 'n') { printf("Thank you for your patience\n"); } }
char choice[2] will be more apt (statement terminator)
thankyou so much! I'll consider your advice.
&gt; #include &lt;stdio.h&gt; &gt; #include &lt;stdlib.h&gt; &gt; #include &lt;string.h&gt; &gt; &gt; int main() &gt; { &gt; printf("Welcome to the age verification program.\n"); &gt; printf("Enter your name: "); &gt; &gt; char name[16]; &gt; scanf(" %s", name); &gt; printf("Hey %s ! To continue please enter y and for abandoning enter n&gt;&gt;&gt;&gt;&gt;&gt; ", name); &gt; &gt; char choice; &gt; scanf(" %c", &amp;choice); &gt; &gt; if(choice == 'y' ) { &gt; printf("Please enter your age now: "); &gt; &gt; int age; &gt; scanf(" %d",&amp;age); &gt; &gt; if(age &gt;= 16) { &gt; printf("Thank You %s for completing the age verification. Since your age is %d you are eligible to participate.\n",name,age); &gt; } else if(age &lt; 60) { &gt; printf("Sorry! But you are not eligible.\n"); &gt; } &gt; } else if ( choice == 'n') { &gt; printf("Thank you for your patience\n"); &gt; } &gt; } and your code worked very very fine!!! Great 
the code worked very fine!! 
Could not get even a single piece of what you just said!!
&gt; Do not perform pointer-swaps with var_decl; the destructor will still be run on the original structure, because raii keeps its own reference to the resource. But this is a problem in constructor-like functions, where you create objects that you want to be automatically freed if the constructor fails, but kept and returned (directly or as part of an aggregate) when the constructor succeeds. Glib, which also has RAII ([g_autoptr](https://developer.gnome.org/glib/stable/glib-Miscellaneous-Macros.html#g-autoptr) implemented using non-standard cleanup attributes), has the [g-steal-pointer](https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-steal-pointer) macro to deal with this; it sets the automatically freed pointer to NULL (so nothing will be freed anymore), and returns the reference it contained. But such a macro won't work with your library if it keeps its own reference.
 scanf(" %s",name); this should be scanf(" %s", &amp;name);
I suppose it depends on how liberally you interpret the concept of RAII - it's commonly defined in terms of class invariance, object lifetime, constructors and destructors - all of which are OO concepts. I completely understand that you're creating something analogous to that in C, but personally I'd say that it's "like RAII" rather than it "is RAII" because in my mind RAII is specific to languages with classes, constructors and destructors. Anyway it seems like a very neat piece of work in any case so I don't mean to take anything away from your achievement. It's really just a quibble over terminology.
https://github.com/trending/c
There is also a possible buffer overflow by using \--&gt; scanf("%s", name); // change this to scanf("%15s", name); 
I like to mess around with socket connections a lot. I personally make a Text over IP sort of thing with GTK on Linux. Maybe so something with encryption or ask your friends for a simple program.
Try the [Advent of Code](https://adventofcode.com/events). There are currently 75 exercises (25 each for 2015, 2016 and 2017) plus 25 bonus questions for the 2017 exercises. Put your solutions on Github and ask for reviews.
Oh ya lol
bchs kwebapp kgci ksql. learn those and improve them. pgsql support for ksql would be nice. please implement several different availability and concurrency architectures for us. :D
RAII has nothing to do with OOP. For example, rust isn't an OOP language but relies on RAII, and gcc and clang also add RAII to C via the *cleanup* attribute. On the other hand, RAII is not used in the majority if OOP languages, or only when specifically needed (e.g. python's *with*, C#'s *using*).
Remove the "a.out" file from your repo.
You would think so, but in this case `name` is an array, and equivalent to `&amp;name[0]`.
A.I.
You can technically make iPhone apps in C too. 
You can do anything in C. If you have a project you are struggling with, let me know and I can [give you some pointers](https://xkcd.com/138/).
Why did you bother if you had no reason? What can you do with C? Well, almost everything you use is written in C, either in part or completely, so start with that.
One option is to get into programming microcontrollers (such as AVR, STM32, PIC, or ARM to name a few).
&gt; I have learned C but am unable to breakout of my beginner phase. &gt; I know C very well. This confuses me a bit, I must say.
&gt; it would improve my programming skill Um. No. It's just a version control hosting site. &gt; what can you do on github Maybe you should ask your friends.
github is a site where you can publish your source code and contribute to other people's source code. They also have bug trackers, wikis, and a whole lot of other stuff for this purpose.
I wanted to create single header library with no dependencies, I don't want it to grow beyond the original design.
Change the question: what can you do with a computer? You want to create a calendar? A video game? A program that tracks the evolution of the stock market? Well, you can do all of that in C, and with other languages as well.
I tought exactly the same. I remember feeling like he does in my second year in college
So you want to implement something. You will need to learn more than the programming language. I would suggest start reading up on posix (not an OS, but a set of guidelines for one), as I and many others found that the easiest and best way to learn. Then start doing some unix/Linux programming. Simple stuff like reading a file, then you can change the permissions, etc. Get used to reading documentation and man pages. 
start by automating simple tasks that you do every day. 
This. I second this. I loved making my own socket connection. The most fun is when you are doing a connection between two machines you have control of, you can do whatever encryption you want, not just ssl. Make your own 8192 bit rsa key and use it, or try some new encryption, but on the socket layer :P.
In C? Hell no.
Great stuff
&gt; I remember feeling like he does in my second year in college Didn't want to say it myself, but yeah, same here. I generally I'm very wary when I hear someone say "I know C/C++" because it's generally an empty statement.
It's free code storage! What is there not to like? I think other than that you could gain some good habits from using topic branches and commiting often. Reasoning about what you're actually doing.
esp8266! It's really cheap.
Umm #!/usr/bin/gcc ... Sounds like a plan.
int *ptr; void *ptr2; There ya go, a couple of pointers.
Build an [open source PBX/telephony/media platform](https://github.com/asterisk/asterisk/). 
Fuck off you living retardation. /s
What I do on GitHub (by which I mean GitLab) is push code to repositories so others can get it and use it if they want. I don't think that improves my programming skills, but it does make me more aware of what I'm putting out there, because I don't want it to look like I produce garbage. That encourages me to use good programming practices, comment it well, that kind of thing. Your friends might have something else in mind.
Do some microcontroller stuff. Not (just) Arduino.
The fact that it only supports ASCII filenames is really limiting. A portable file system abstraction that doesn't address [the messy file name issues](https://simonsapin.github.io/wtf-8/#motivation) isn't *really* tackling the truly hard part of the problem. 
Knowing the basics of the language and knowing how to do stuff with it / specific libraries are different things and it took me a long time to understand that. Akin to learning a spoken language, but not knowing a single idiom or metaphor. Yes, you can *speak* that language, but anything you do is arduous and awkward.
+1 For microcontrollers. It's one of the few places were C has significant advantages over everything else. 
Yeah you can do a lot with C, I make a pretty good living off writing it for instance. But as for your question of how to expand your repertoire. Next I would start writing some simple Linux programs that move and organize files etc. then as u/L33tneo said I would get a micro controller and some peripherals (LEDs, electric motors, switches) and just see what you can do. 
Your function is essentially what glibc and musl have as `asprintf`. And how you implemented it is the normal way to to it: snprintf() with NULL, malloc, and snprintf() again to the actual buffer. [Here is the musl version of vasprintf.](https://git.musl-libc.org/cgit/musl/tree/src/stdio/vasprintf.c) A possible optimization would be to first allocate a reasonably sized buffer that is *probably* large enough, so the second snprintf is only required if the estimate was wrong.
What do you need that string for, that cannot be solved by `(f)printf()`? Also, although it's a somewhat contrived example, you will probably have a problem with a format string like "%1$d%2$n%2$d"¹ 1. This is an extension IIRC. 
Like everything. What do you think all those hipster languages are written in? Operating systems? Games? In a way it's the move away from MS-DOS, away from the hardware and everything seems safe and removed from messing with the iron.
I'll take facepalm for $600, Mr Trebek
It's version control, you check in your code, and push up changes to it, and If at some point you need to roll back to an older version of your code, you can! (along with a lot of other neat things) Many people keep their open source projects on github, so you can find one you like, clone it (basically downloading the code) and try and improve it. You can also see how folks solved problems that may be similar to ones you are facing when writing your own code So, it's just a big ol repository of code written by all different people, you can keep your own code on it, you can find other people's code on it (if they choose to make their code public) and you can use it to collaborate on writing code
That would work fine also with microcontroller, where malloc are banned for good
All three should print the exact same thing: the address of `num`. You never change the pointer to point to anything else, so it always points to `num`. If you instead printed out `printf("%d\n", *ptr);`, A would print 5, B would print 10, and C would print 15.
Imagine a "normal" variable as a drawer in a cupboard. And pointers as a guy pointing to a drawer. If you assign a new value to a variable you just open the cupboard and exchange the value in it. So A and B doesn't change anything about the pointer. With the third assignment you just tell the compiler to open the drawer on which your pointing guy is pointing to. So only an operation on the "normal" variable too. To change the pointer, you really have to interact on it, so assign a new value, or do arithmetic on ptr. Hope I could help. 
A, B, and C will all be the same, because you are printing the address stored in ptr (i.e. &amp;num). If you meant to print the value at ptr then you use prinf("%d \\n", \*ptr); and using the indirection operator (\*) will give you the value AT the address in ptr. That being said, if the latter is what you meant, then A should print 5, B should print 10, and C should print 15. because you are modifying the value at the address of num.
But if I assign a new value to num shouldn't it be allocated to a different space in memory with a different address? 
No, you just overwrite the old value. It's like using an eraser on paper to remove the old word (value) and then write a new word (new value) with a pencil. The location hasn't been changed, but the word (value) has.
50 for each year. Every day has two parts... Also /r/adventofcode gets a little bit of activity during the off season.
Your points are null and void
is this shit for real
Write a chess program from scratch. Not an easy task, but you'll know how much C you know, and probably will learn quite a lot too.
Yes, exactly, it's not about learning a language but learning what's above the language. Lets just assume a language is just a mean to express an idea. If you don't have that idea, you couldn't express it even if you knew every language on Earth. Programming language is a small part of what you need to be able to construct something worth. It's like saying you know maths perfectly as you can add and multiply numbers.
Yeah, until you run out of memory and your only hope is to write it in asm.
Except the languages that are written in themselves? And the OS/Games/... that are written in themselves
&gt; What can you do with C? Brian, Ritchie, Ken, Torvalds: Hold our beers.
You could write a web server built of httpd!
I use C for working on an MSP430 that has 128 *bytes* of RAM.
As an addendum to his question, I too struggled with understanding how to move on from CRUD applications in a console window. I'm not actively using C so I'm very rusty with it, but I started reading about micro-controllers and I found that it just seemed like there's a crevasse between writing some functions and outputting to a file or the screen and interacting with hardware or other API's without having to read 500-1000 page manuals for each step of the way. Crossing that gap could be what separates the hobbyist coders and the real software engineers.
Pretty sure [zombo.com](http://zombo.com) was written in C... [and since flash is dead](http://en.wikipedia.org/wiki/Zombo.com)
[The XMK realtime OS is almost entirely C, with a minimum footprint of 340 bytes of ROM and 18 bytes of RAM.](http://www.integerfox.com/xmk/#FAQ) It was originally targeted at 8-bit microcontrollers, where C is less popular because C started on 16-bit PDP-11s and the standard specifies `int` as 16 bits minimum. 
The overwhelming trend for new languages is to write their compiler in their language as quickly as possible. Even Go, which is less concerned with marketing and appearances, did this before too long. I think they see it as credibility, but it's inevitably justified on the basis that language converts can contribute to the compiler. As if a compiler is the most important thing for new language converts to work upon... 
Write desktop utilities, games, all kinds of stuff. You have to utilize some OS APIs or some library that abstracts OS APIs (for creating windows, handling input, playing sound, etc) and possibly learn a graphics API (OpenGL). I do all kinds of stuff with C (http://deftware.itch.io)
The trick is to pick something you can realistically finish without being frustrated and discouraged, but still enough to challenge you. It must be something you find very interesting, at least for a while. Tell us what you've already done and what you like and don't like. I like and have problems to solve in networking, file-format conversion, portability of existing code, virtualization, web apps. I like to access other functionality from C, not make entirely self-contained programs. 
That's going to be hard to flash into my chip with only 256bytes of ROM.
Buy two microcontroller and make then communicate with each other using a wired bus (spi, uart, can) then use a wireless chip. Afterwards you can add sensors (temperature, humidity, sound, range etc) and try to interface them to your uC and make them communicate their data :) This is a first step in the world of embedded !
If you're running out of RAM you're either using poor programming practices, or choosing the wrong microcontroller for the application.
Game development,solving problems,making new algorithms,creating graphics,software engineering and so much more!
Is there a similar solution for [strftime(3)](http://man7.org/linux/man-pages/man3/strftime.3.html)?
&gt; If you're running out of RAM you're either using poor programming practices, or choosing the wrong microcontroller for the application. First of, we're talking about ROM not RAM. Free compilers are well known for outputting bade code on say PIC mcus. If you're depending on the GCC toolchain, chances are you won't face this problem of a compiler that pretty much bloat the outputted ASM on purpose to force you to buy the license. Secondly, if the device has the "hardware" for your task, it's not your fault if the code generated by the compiler is so bloated. You could certainly pay more money for a more expensive MCUs, but you could literally buying an overpriced MCU to blink a led and read temperature from a sensor. That would be choosing the wrong microntroller for the application. You can buy a cheap MCU that will be able to do exactly what you need but space limitation might mean, C isn't a choice anymore and writing direct ASM could be simpler and less bloated. There's also issues with C compiler with MCUs, unfortunately MCU's hardware doesn't always allow it to make C work the same way as it would with more modern chips. Say goodbye to recursion. Say goodbye to "nice" paradigm because your stack is limited to 7 function call. Then there's all the problem related to the hardware itself that doesn't actually do what the datasheet says it should do in certain particular situation. All I'm saying is that not all MCUs are made equal and while arduino is a good start, getting into more complicated things will have you spend more time reading the datasheets that writing actual code for a good time or you'll have to pay a lot of money for chips that have the backbone already done for you (Arduino). Then the question is if you get high end MCU with lot of ROM and RAM, why would you program them in C if you're likely going to be able to program them in C++ or may be an other language that will make the journey much more enjoyable. 
 while( condition ) { sleep(1); if( condition ) { doSomething(); } } You could make the test condition use a `volatile` variable as well.
after cin: if(scores[entry] &lt; 0 || score[entry] &gt; 100){ cout &lt;&lt; "Invalid score, please try again" &lt;&lt; endl; entry--; } by subtracting 1 from entry, it will be incremented again at the end of the loop and you'll reenter it with the same value as before, essentially as long as the user inputs invalid numbers you keep asking them to try again until they enter a valid score. By the way, this is c++, not C. There are also a lot of ways to do this and most of them are easier to find than this one, the reason it's an exercise is to train you to think about problems using the language's tools, I encourage you to think of a different way to solve the problem on your own.
`cin &lt;&lt;` and `cout &gt;&gt;` look like C++, you might want to ask in /r/cpp_questions. To answer your question: You only increase `entry` when the input meets the requirements.
This does not work. For example, if the button is pressed as sleep(1) was just called, I'll have to wait almost two seconds for doSomething to be called. I need the maximum wait time to be one second.
I can't write a full answer right now but you would want to use pthread_cond_timedwait and check the return value. It's signaled via pthread_cond_signal. 
Thanks, I'll look into that.
Use usleep or microsleep (forget which it is). It takes its argument in milliseconds (or microseconds? can't remember) instead of seconds. However, do NOT make the condition variable volatile, it NEEDS to be atomic, or you will get torn reads. In this case, if the condition is the only work done on the signaling thread that the receiving thread needs to know about, you can update the condition variable with memory_order_relaxed to regain some optimization, but volatile is not strong enough for multithreaded programming.
I'm not sure how that usleep will help me? I need to interrupt the sleep midway and restart it, doesn't matter much whether it is in seconds or miliseconds or microseconds.
I apoligize, wasn't sure of the differences. Thanks for the advice.
You could use [`select(2)`](http://man7.org/linux/man-pages/man2/select.2.html). It returns `0` if the timeout expires before anything interesting happens.
Thanks for the advice, I'm just having a tough time understanding how arrays work. And I'll be sure to post in the correct subreddit from now on.
No, unfortunately not.
Very astute. I've added an appropriate `.gitignore`!
Not NULL. They’re uninitialized. 
Very interesting! Yes, you are right, this currently won't work; currently you would be required to move or copy the datastructure to be able to move it out safely (moving the pointer is not enough since the lifetime stack uses its own separate reference). If we change the macro from `raii_with(mytype name, constructor, destructor) {...}` to `raii_with(mytype, name, constructor, destructor){...}`, then this would be possible since we are able to access the name outside of the single line where it is initialized (since we have then the name without its type in front). This would: - allow the lifetime stack to keep a `void**` instead, which means that swaps would be a way to switch what data is destructed at the end of a scope. (And that someting similar to `g_steal_pointer` could be written).
Nice! I hadn't even considered that! :D
As others have mentioned, you can use `pthread_cond_timedwait` and a mutex to accomplish what I think you're trying to do. #include &lt;pthread.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/time.h&gt; #include &lt;time.h&gt; #include &lt;errno.h&gt; #include &lt;stdlib.h&gt; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int g_ms = -1; int iterations = 0; void waitMillis(int ms) { int n; struct timeval tv; struct timespec ts; gettimeofday(&amp;tv, NULL); ts.tv_sec = time(NULL) + ms / 1000; ts.tv_nsec = tv.tv_usec * 1000 + 1000 * 1000 * (ms % 1000); ts.tv_sec += ts.tv_nsec / (1000 * 1000 * 1000); ts.tv_nsec %= (1000 * 1000 * 1000); pthread_mutex_lock(&amp;mutex); n = pthread_cond_timedwait(&amp;cond, &amp;mutex, &amp;ts); pthread_mutex_unlock(&amp;mutex); if (n == 0) { printf("waitMillis: We were signalled!\n"); } else if (n == ETIMEDOUT) { printf("waitMillis: We timed out!\n"); } } void *threadRoutine(void *arg) { while (1) { waitMillis(g_ms); iterations++; printf("threadRoutine: Finished (%d)\n", iterations); } } int main(int argc, const char **argv) { pthread_t thread; int input, ms; if (argc &lt; 2) { fprintf(stderr, "Error: Please pass milliseconds for our timer!\n"); exit(-1); } ms = atoi(argv[1]); if (ms &lt; 100) { fprintf(stderr, "Error: Pas at least 100ms!\n"); exit(-1); } g_ms = ms; pthread_create(&amp;thread, NULL, threadRoutine, NULL); while (1) { printf("Main: Enter a number\n"); scanf(" %d", &amp;input); if (input == 0) { printf("Main: Signalling thread...\n"); pthread_cond_signal(&amp;cond); } else { printf("Main: Not signalling\n"); } } } [Link to a GitHub gist](https://gist.github.com/michael-grunder/69bde7190c4d0e8139faaa41689832c3) Full disclosure: It's been a bit of time since I wrote code directly using these pthread concepts, but it does appear to accomplish what you're going for. Edit: You'll also probably want to handle exiting the threaded timer in a clean way which I am not doing here.
No worries! Thanks for your feedback! I've slightly altered the wording in the Readme to be more open to different interpretations of the term RAII.
&gt; Kind of the maximum IPV4 address length is 15 by "255.255.255.255" and maximum (converted to string) port length is 5 by ("65535"). So the maximum length for the format "%IP:%Port" is 15 + 5 + 1 and so 21. The buffer should have a size of 22 with the terminator. This is a bit off-topic, but no, please don't use a buffer that small to format IP+port. The maximum length for an IP is `NI_MAXHOST` and the maximum length for a service name is `NI_MAXSERV`, as documented on `getnameinfo(3)` (which _is_ the function you're using, right?). We're not in 1995 anymore. There are more address families than IPv4 and there are plenty of services with names longer than 5 characters (e.g. "kerberos-master").
&gt;&gt; until you run out of memory &gt;we're talking about ROM not RAM. Perhaps you should learn the difference between **memory** and ***storage***. If you're running out of *MEMORY*, you're running out of ***RAM***. If you're running out of ROM/FLASH, you're out of volatile memory, a.k.a. *storage*. &gt;Free compilers are well known for outputting bade code on say PIC mcus That's kind of a straw man. The PIC hasn't enjoyed free compilers the same as the AVR or ARM processors have. Your complaints don't really fly on ARM and AVR. &gt;If you're depending on the GCC toolchain, chances are you won't face this problem of a compiler that pretty much bloat the outputted ASM on purpose to force you to buy the license. Yeah, well that's why I don't depend on closed source compilers. Again, you're finding specific exceptions and holding them up as an argument for the whole. &gt;You could certainly pay more money for a more expensive MCUs Why would I? I always design with the assumption that they're go into production, at which point, *every* penny counts. &gt;but you could literally buying an overpriced MCU to blink a led and read temperature from a sensor. Well, I'm not an amateur, and appreciate keeping my BOM costs low. &gt;You can buy a cheap MCU that will be able to do exactly what you need but space limitation might mean, C isn't a choice anymore and writing direct ASM could be simpler and less bloated. In 20+ years of embedded engineering, I've *never* had this happen. I've written assembly for *performance* reasons, but never because the compiler's code was too "bloated". Maybe it's your poor coding style that's causing bloat. &gt;There's also issues with C compiler with MCUs, unfortunately MCU's hardware doesn't always allow it to make C work the same way as it would with more modern chips. Are you making shit up as you go along? Do you have a *specific* instance to prove your point? Which compilers? Which MCUs? Everyone else seems to get along just fine. &gt;Say goodbye to recursion #FAIL. If you're doing recursion on an MCU with a paltry few K bytes of RAM, then you're **DOING IT WRONG**. &gt;Say goodbye to "nice" paradigm because your stack is limited to 7 function call WTF!? You're coding on a device with limited resources! Program accordingly. It sounds like you're using programming techniques appropriate for desktop systems on tiny processors. That's *YOUR* fault, not the processor or compiler. &gt;Then there's all the problem related to the hardware itself that doesn't actually do what the datasheet says it should do in certain particular situation. Name a piece of hardware that *doesn't* have these problems. They're complex devices, and mistakes happen. I've learned to avoid those parts/systems with such deficiencies. &gt;All I'm saying is that not all MCUs are made equal Did I *ever* say they were?
[My pointer is wilder than yours...](https://imgur.com/a/i3E6RBU) I actually went ahead and made a couple of T-shirts with that slogan :D
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
In that case maybe put the work in a signal handler, or wait on a mutex or something. There are non-sleepy ways to do it, but I don't recall them off the top of my head (besides spinlocking, which is expensive).
Thanks! Not at the computer right now but I'll try it later!
Pretty close, but a few things: POSIX.1-2008 deprecated gettimeofday() in preference of clock_gettime() pthread_cond_wait and pthread_cond_timedwait should be checked for spurious wakeups, and hence need a predicate value, i.e.: pthread_mutex_lock(&amp;mtx); rc = 0; while (!predicate &amp;&amp; rc == 0) rc = pthread_cond_timedwait(&amp;cnd, &amp;tmtx, &amp;ts); pthread_mutex_unlock(&amp;mtx);
Question should be turned around; what can't I do with C? You can solve almost anything with it! 
You have no idea what standard C functions like strdup or malloc do?
Try /r/cpp_questions for C++ questions. And tell them what you've got so far and where you're stuck.
&gt; I know C very well. No you don't. You think you do, but that's because you've yet to encounter all the nooks and crannies of the language that will show you just how little you know of it.
C
Pretty easy and straightforward if you know how to use loops - which I assume you've just recently learned about in class, and should be a pretty strong hint as to what you should be using to solve the problem.
1990? Honestly, I can't think of any job that does C-only programming. Most that want C want someone who knows enough about both to cross that language/API boundary and/or convert the old C code to C++
Cuba is what you should type, literally they're almost 100% c and they could use people they pay a fuck ton for consultant work.
volatile use here is incorrect. In concurrency or parallelism you should always use atomic operations to read and write shared memory without the use of locks volatile only tells the compiler that it should not assume that the variable can be cached in a register, but does not ensure that the value in the L1 cache is coherent with value in the thread that wrote it.
&gt; Why would I? I always design with the assumption that they're go into production, at which point, every penny counts. There's a middle to find in money spent on development on a chip with small resources and squeezing the possibilities and spending more on a chip that does more than needed but spending less time on development. There's probably a best of both world to find here. &gt; In 20+ years of embedded engineering, I've never had this happen. I've written assembly for performance reasons, but never because the compiler's code was too "bloated". Maybe it's your poor coding style that's causing bloat. Here again, it's probably microchip's fault for not fixing their compiler or not moving to an open source one. I had issues with a PIC16F683 chip, it has pretty low amount of resources but can do a lot for its tiny size. I made a simple thermostat with a PID controller based on a 1-wire thermometer out of it. I ended up using 99% of the ROM. An empty function would take a relevant amount of program space. &gt; If you're doing recursion on an MCU with a paltry few K bytes of RAM, then you're DOING IT WRONG. Well, it really may depend on the compiler, recursive function aren't inherently going to take more RAM if the compiler can do tail call optimizations. In these circumstances the recursive method will run in fixed amount of memory. The problem is more in how the recursive call isn't possible on certain chip (but I'm not sure if it's a hardware limit or a compiler limit). &gt; WTF!? You're coding on a device with limited resources! Program accordingly. It sounds like you're using programming techniques appropriate for desktop systems on tiny processors. That's YOUR fault, not the processor or compiler. Well obviously, except don't expect a person that barely know how to do stuff in C to be ready for those kind of issues. That's quite a steep learning curve here. All I'm saying is while embedded programming is cool, the field isn't the easiest as you're facing problems on every corner. All of those problems can be quite discouraging at first. Because you're not just programming but also have to connect devices to the MCU to make anything usable. All of those thing may work or not. I remember how I had a hard time programming my first dsPic chip because the board the dev board I had was inverting signals and the programmer I had wouldn't be able to program it because the ICSP pins on the dev board were not correctly connected. After a couple of months and countless time reading the datasheets I finally got it to work on a breadboard. I probably didn't have the best experience to recommend a person with little experience to start with anything else to something like arduino. 
I'm only a hobbyist and don't know much about the C job market. I'm surprised their isn't a decent amount of work for older codebases though. Aren't there even COBOL jobs still in demand from financial institutions relying on it?
Any place that makes financial software. I work in the field, the demand for C programmers exists. Converting those old codebases is never an option, too expensive and error prone for little gain. When you're looking at mainframes there may not even be compilers. Those companies usually have newer gen software in c# or java or whatever, but the old code base still makes a lot of money.
How do you feel about embedded devices?
I think Embedded Software and related is your best chance. Maybe kernel development.
Software engineering is a lot more than just knowing a language. Think of some problems you want to solve, look at how other people have solved similar ones, and learn about the patterns and strategies needed to solve them. Have you ever read or heard of the Gang of Four book? Some of it isn't as applicable to C since it's aimed at object-oriented design mainly, but it can give you some ideas on how to approach complex problems and structure a larger project.
Or `poll(2)`, or `epoll(2)` (if you're on Linux), or `kqueue` (if you're on BSD).
Example: Simple neural network library in ANSI C. https://github.com/codeplea/genann
Smaller 8-bit and 32-bit embedded systems are largely written using C
Try a Microchip PIC10F with 16 *bytes*. I've actually found uses for them in a couple projects.
&gt;Cuba is what you should type, literally they're almost 100% c Are you talking about Cuba the country? Or do you mean Cuda?
make the condition be tied to a check inside the looping code that gets triggered when the user inputs what you want to stop the loop on 
This feels like you're coming to the job search backwards. There are focuses that pretty much will require C (embedded, system code, security, maybe binary analysis) but you don't just go to those jobs cause they use C, you use C cause it's the right tool. This is sort of like if you really liked PL our compilers, you'd probably need to know Haskell
Agree... Though nowadays there're less chance for a 8bit MCU project. I'm in the embedded field for years, and all of our project goes to 16bit/32bit, all of them is developed in C. (Our last sub-16bit project appeared in 6 years ago, it used a 4bit MCU and programmed in assembly). To OP, mind you that you need a rather strong low level knowledge in embedded software development, both in software and hardware... 
If it matters if a job uses C or C++, you aren’t ready yet, my young padawan.
I do know C quite well. It’s useless to me.
Cuba the country
Linux kernel/drivers.
There's still a lot of embedded software written in C, particularly for smaller devices. OS programming is almost always done in C. I've written a few linux device drivers in C for instance. And right now I'm writing control software for a synchrotron in C, because it has to interoperate with their existing EPICS system which is written in C.
*Carmack*
i think i know where my problem is. occasionally read an article on my phone just now . which talk about“imperative sentence” in different language system. it gived an example about ordering in McDonald's "Please give me a Big Mac with fries and a large soda"which is impolite and the better way is “Can I have a Big Mac with fries and a large soda”. in my mother language there is a specific mark in a sentence and which corresponding to the"please" during directly translation. so i really didn't mean any offense. actually, i think when i use English , it is more likely i am trying to use some kind of programming language. have a nice day~
Do they? Aren't they basically broke? Do they remote?
... Interesting... Do tell more...
r/cpp
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Honestly dude, just learn C++. Why would you limit yourself. It’s very confusing at first but it can be a great tool once you get the hang of it. 
This looks extremely cool! I am in the middle of making my own 8-bit computer, and after that is finished, I would really like to try some embedded stuff. Great job!
You mean objective-c? Last time I looked at it I was hella confused. It's not like it's too difficult to learn though but it feels like a whole other programming language.
&gt; RAII is so closely tied to OO Although I agree that this is not RAII: * RAII is not tied to OO (as an other commenter noted Rust uses RAII and is not OO, also ATS, basically [substructural type systems](https://en.wikipedia.org/wiki/Substructural_type_system) is at least partially a formalisation of the concept and not at all tied to OO) * This is closer to the "context managers" you find in Python (`with` statement) or C# (`using` statement) or Common Lisp (`unwind-protect` special form) or Ruby/Smalltalk (pass a block to a method) than it is to `defer`, `defer` is completely disconnected from the resource while this uses the resource *through* the cleanup construct/procotol.
**Substructural type system** Substructural type systems are a family of type systems analogous to substructural logics where one or more of the structural rules are absent or only allowed under controlled circumstances. Such systems are useful for constraining access to system resources such as files, locks and memory by keeping track of changes of state that occur and preventing invalid states. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Looks like you posted a wikipedia article, let me summarize it for you... Click [here](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) if you'd like me to stop bugging you. ***** **[Substructural type system](https://en.wikipedia.org/wiki/Substructural_type_system)** &gt;Substructural type systems are a family of type systems analogous to substructural logics where one or more of the structural rules are absent or only allowed under controlled circumstances. Such systems are useful for constraining access to system resources such as files, locks and memory by keeping track of changes of state that occur and preventing invalid states. ***** **^([)** ^([About](https://np.reddit.com/r/ultimatewikibot/wiki/index)) **^(|)** ^([Source code](https://github.com/brrm/ultimatewikibot)) **^(|)** ^(Downvote to remove) **^(])** 
Yes of course. However, you should do some tweaks in code listings to get them to work on your PIC Chip. It's an absolutely easy job once you've got the basic understanding of how each module is actually working. Good Luck Dude ^^
A `sleep` call is interrupted by signals. Once the signal handler returns, `sleep` immediately returns with error `EINTR` (interrupted system call). So here is what you can do: * pick a real time signal (e.g. `SIGUSR1`) and ignore it * right before you sleep, establish a dummy signal handler for the signal * sleep for a second. If the sleep is interrupted, do it again * ignore the signal once again * if you want to asynchronously wake up the thread, use `pthread_kill` to send the signal you picked before to the thread this should yield the desired behaviour and is reasonably easy to implement. Ignoring the signal outside of the sleep is not strictly necessary but might make programming overall easier because you don't have to account for stray signals interrupting your system calls.
I am a huge fan of using pipe and select. It allows you to implement signalling from unrelated processes using named pipes or Unix domain sockets.
I vaguely recall some regulatory reform in Cuba that made software a better industry in that country awhile back but never followed the story closely... Cuba *did* have a reputation for being good at medicine at one time, though that might have been due to pragmatic quarantine of AIDS patients. :/
"embedded"
In order to write this answer you have been relying on sh\*tload of C code. Remember that a lot of people are employed to maintain it and add new features.
I know C++, I just wanna work in a primarily C shop (if it exists) :).
There seems to be a decent share of non-habitual C programmers who believe that because C has pointers and largely unrestricted pointer arithmetic, every C program is an orgy of weird pointer shit and arbitrary memory access, when in reality C programmers mostly use the exact same operations on pointers programmers of other programming languages implicitly do. Then they try to write their own C programs with all the weird tricks they read in blog posts and end up in a tangled mess of their own attempts to implement generics, lambdas, or whatever weird thing, only to conclude that C is a shit language to program in. How about you write simple straightforward programs and just don't do all this weird-ass stuff? You surely wouldn't have done so in another language either. What is so difficult about programming in C like you program in any other language?
Yeah, I've seen Embedded C jobs all over. Maybe that's my only real option... What I want, really, is a shop that uses C and not *just* for legacy systems. Maybe this lalaland doesn't exist.
Legacy? Automotive and Embedded are two of the growing and most innovative out there. And they rely heavly on C
You'd be surprised how many AAA game studios still use pure C as much as possible. *cough*callofduty*cough*
IoT?
They are good at a lot of things, education is very important there and is free, universities included. Indeed they have very good doctors because the state devotes public money to research and formation. But something different is the salaries and conditions the actual profesionals get, moreso compared to USA or similar :)
Yes, you are correct, but outside of that, seems like it's a ton of legacy.
That's actually really cool.
iPhone apps are coded in Objective-C, yes, but object-C is a super-set of C and therefor just knowing C is enough. You can code an iPhone app in Objective-C which includes all of C in it. So you can technically code objective-c by just coding C and not utilizing any of the additional components objective-c brings to the table. I think there are a few exceptions that Apple has modified but they are rare, things like inline functions are now a sort of block-invocation style, and a few other minor things are deprecated, but for the most part, all of C will work on iOS app dev. 
Well, the more you know! Thanks for your comprehensive answer :)
Don't store money using a floating point type. Use an integer, storing the number of cents (10 is $0.10, 250 is $2.50, etc). If you need to use a floating point type, the best way to round is: int cents = (int)(cash * 100.0 + 0.5);
&gt; How do I implement the round function correctly? Are you writing your own `round` function? If so, show it. I get 420 when I tested this. However, small [floating point errors](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems) are not uncommon due to the nature of how they are represented by the computer. That is why their use for doing math with money is discouraged. Instead, use integer cents. 
I'm using the round function from the &lt;math.h&gt; library. I forgot to mention that the error occurs after accepting user input, so I give the program the 4.20 but due to the floating point error, it actually is something like 4.19999548 etc. I then need to get the correct amount of cents, which should be 420, but i get 419 using the piece of code above.
Thanks for the reply. Thing is that I use the input from a user, so I accept logical numbers for money, which is a float (or a double). Due to a floating point error, the user inputs 4.20, but in the debugger i can see the value is stored as 4.19999981, which turns into 419 cents. I want to multiply the float 4.199... by one hundred, turning it into 419.99 and then round it up to the nearest integer. Can I do that?
You could follow /u/boredcircuits's suggestion, or also capture the integral and fractional parts of the input separately, e.g.: int dollars, cents; printf("Enter money: $"); scanf("%d.%d", &amp;dollars, &amp;cents);
You should delete the decimal point from the string and convert the string to int. If you want to do the other way, a lot of floating point code usually passes a delta value for comparison (say 0.01) when they test for equality, as: absoluteValue(intendedValue - actualValue) &lt; delta in place of a strict == equality test. Maybe you can find a way to tweak that to suit your problem (although if you store back into a float YMMV) 
I had a professor that a few years back would do 3 months for around 80-90k primarily all in c. She would have to go to Canada to fly to Cuba and reverse the same way. It was not remote.
MPW 4 life
Most likely, those tutorials are a good start, but doesn't seem exhaustive. For example, I don't think it shows how to dereference a pointer to a structure (i.e. using -&gt;) https://pastebin.com/raw/HJefG2Pd 
[TCC](https://en.wikipedia.org/wiki/Tiny_C_Compiler) actually does support shebangs!
**Tiny C Compiler** The Tiny C Compiler (a.k.a. TCC, tCc, or TinyCC) is an x86, X86-64 and ARM processor C compiler created by Fabrice Bellard. It is designed to work for slow computers with little disk space (e.g. on rescue disks). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://en.wikipedia.org/wiki/Tiny_C_Compiler) - Previous text "TCC" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I would not recommend watching thenewboston. He makes literally thousands of tutorials on everything which means he learns nothing in depth. He's just regurgitating other tutorials he finds. Tutorials themselves are a kind of compromise in learning something, information is left out to not overwhelm a newbie but when you have someone learning from a tutorial and then immediately turning around and making their own tutorial then it's bound to not go well. In the videos of his I've seen (I haven't seen the C series) he gets a slew of terminology wrong and everything is just a bit off and half-assed. I don't really have a replacement series of videos in mind though. If you do continue with them then don't take them as gospel. As for your actual question, I'm not sure what you're asking.
Our &gt;32-bit processors are programmed in PL/m.
Assuming you have some experience in python or some similar higher level language due to the link you posted, I'd really recommend you read Simon's article on C: [The Descent to C](https://www.chiark.greenend.org.uk/~sgtatham/cdescent/). After that, I'd suggest reading through the `comp.lang.c` FAQ which is linked in the sidebar. You can go through the entirety of it in a fairly short period of time if you understand the majority of C's gotchas and rules, and if not, this will introduce you to the things you don't know that you don't know. Make sure you're comfortable with operator precedence, as I find that's one of the most common mistakes people (and myself included) have made while becoming more experienced with C, in particular when bit twiddling.
What rounding function are you using? There are several provided by `math.h`, for instance, have a look at the [ceil family](https://en.cppreference.com/w/c/numeric/math/ceil).
Here is one for you. Use the nftw() system call to traverse a directory tree and for every file found compute the SHA512 hash of the contents with the OpenSSL EVP_foo collection of functions. Output the resultant SHA512 signatures into an output file structure with the same tree as the source tree however under a "dot" directory called ".sha512" in the root of the source tree. Bonus points for finding all duplicate SHA512 hashes and issueing delete and hardlink instructions to remove those dups from the file structure.
Rounding in financial calculations can be serious business when a rounding error can be millions of dollars, and the definition of "rounding error" had to either be negotiated or based on whatever the original lagacy system did. :/
Why adding 0.5?
I’m sure someone better at pthreads will come along and help soon but I will chime in and say you shouldn’t brush aside those casting warnings, esp when you’re having memory issues.
I appreciate it. I just wish I had an idea of what to even do at this point. Seriously, I fucking hated my C class, and there's no reason I should've passed it. It was a PhD student teaching it and I'm pretty sure he gave everyone a HUGE curve.
Can you tell me what lines are indicated by the warnings? Do you understand why there is an implicit cast?
It should tell you where those warnings are. Start there. And maybe pthreads prevents this, but I thought even gdb will break at a seg fault?
 for (i = 0; i &lt; 8; i++) { pthread_create(&amp;threads[i], NULL, myFunc, (void *) i); pthread_join(&amp;threads[i], NULL); } Think about what is happening here. This does not fire off 8 simultaneous threads. The for loop begins, i is set to zero. pthread_create() fires off the thread. Then [pthread_join](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html) suspends execution of the calling thread until the target thread terminates. That means your main thread will wait here until your first thread terminates. Only after that will your main thread continue with the next iteration of the for loop with i set to one. You aren't running more than one thread at a time with this. Put the pthread_create() and the pthread_join() in two separate for loops.
It's 14 and 87.
I'm no c expert, by which I mean I couldn't write a valid C program to save my life. I am a programmer by trade though. However, I would agree with the above, if you're having issues then stop ignoring warnings (infact I would go so far as to suggest everyone, wherever possible, adheres to _at least_ no.10 of [JPL'S Power of 10](http://pixelscommander.com/wp-content/uploads/2014/12/P10.pdf). Something else to look into is valgrind, which may give you further hints as to where you problems lay.
Your post doesn't have line numbers. Can you show me the lines? Why do you think does the compiler complain? I'm asking you because I want you to understand the problem so you can fix it yourself and gain a better understanding of what went wrong.
That makes sense!
That may take a moment, I'm switching up a bunch of my code because it was trash.
So you've got a few options here. You could stare at this code for a long time, and just hope that the problem jumps out at you. You could post it here, and let us do the same thing. Or... you could run it in a debugger, watch what your code is doing _as it's doing it_. I can never understand why programming courses teach students how to use a compiler, but completely neglect how to use a debugger. If you ever do any kind of serious programming, you'll spend _far_ more of your time working with a debugger than with a compiler.
 13 void *myFunc(void *thread) { 14 int threadNo = (int) thread; Next you have casting issues. Think about what type the variable you are feeding into this function is: 89 pthread_create(&amp;threads[i], NULL, myFunc, (void *) i); You are taking the number zero (at least in the first thread), and calling it a void pointer. You don't want this. You want to pass the address of the variable i like this: 89 pthread_create(&amp;threads[i], NULL, myFunc, (void *) &amp;i); Remember that [pthread_create()](http://man7.org/linux/man-pages/man3/pthread_create.3.html) requires the last argument be a void pointer. That means you can pass it a pointer to any data type, but it must be a pointer. The &amp; operator in front of a variable name like that means we want a pointer to that variable, not the variable itself.
Piece of cake for me. TBH. I’m still bored.
I don't use pthreads much, but I think your segfault might be from using `&amp;threads[i]` in calling pthread_join. Create takes a reference, but looking at the spec, join doesn't. Of course, amfournda's point still stands, but I'd imagine it would run... just sequentially.
[https://imgur.com/a/qP6EhHp](https://imgur.com/a/qP6EhHp) I put up the specific warnings and the code segment with line numbers here.
&gt; You want to pass the address of the variable i like this Which will fail utterly once that loop is fixed so that multiple threads are running concurrently and the lifetime of `i` ends. Note that the OP is simply casting that "bad pointer" back to an `int` inside the thread function. This is likely to work perfectly well.
Yeah I'm just reading through this after a long day. It just hurts me a little to see a NULL pointer passed into pthread_create like this lol. You are right, it probably works just fine.
&gt; pthread_join(threads[i], NULL); Quite true, most universities just put in some PhD students and have that be their first class that they teach, and the classes are treated like mills to get people out. God willing, I won't have to do any serious programming when I get out into the real world...
So I'll reiterate: please use a debugger. I'll let you start with an easy one. Use a debugger to get a backtrace telling you where the segfault happens. That's a start, right?
For the next time: never ever post pictures of text. Always post error messages and the like as text. Nobody wants to even look at images. That said, why do you cast `i` to a pointer? That doesn't seem to make particularly much sense. You can't just cast random integers to pointers, that's undefined behaviour and will break on some platforms. Find a different way to pass an integer to the function, e.g. by passing a pointer to an integer. Also, the function `piCalc` is not part of any source code you posted, so I can't see if that invocation is correct. What is line 87 trying to achieve? Why do you pass `&amp;threads` to it? 
&gt; I'm aware I'm not storing the address as a string but rather as uintptr_t which to me seems fine. The value of the `uintptr_t` is undefined when used in the `sprintf` call, which yields undefined behaviour. Anything that works past that point is purely coincidental.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;inttypes.h&gt; int main() { char *string = "THIS IS A TEST STRING"; char *stringAddress = malloc(sizeof(&amp;string)); sprintf(stringAddress, "%p", string); char *stringCopy = stringAddress; printf("%s\n", stringCopy); } This does not fix it but does it provide the defined behavior. Can you suggest a solution?
Fix your warnings, see if the segfault goes away. The warnings are the compiler doing a rudimentary "I don't think you've written what you want here" check for you. Join -Werror club ;)
Thank you for that insight. Can you just provide a solution to the question without trying to fix the semantic issues unrelated to the problem?
&gt; This does not fix it but does it provide the defined behavior. No, it doesn't. Look at my edited post. &gt; Can you suggest a solution? A solution to what? This code doesn't do anything useful. What are you trying to "solve"?
Casting a `float` to `int` truncates the number. So if the floating point value is 4.99999999999998, casting to an `int` will give the value of 4. But if we add 0.5, now we're truncating 5.49999999999998, which truncates to 5. Likewise, 4.49999999998 + 0.5 is 4.99999999998, which truncates to 4, and 4.5000000000 + 0.5 is 5.0000000000, which truncates to 5. So we get correct rounding behavior. Well, for positive numbers, at least. If negative numbers are a concern then a different algorithm is called for.
Thanks
"How can I store the memory address of a pointer as a string and use it to read the same memory using the stored address?"
No, I don't think I can, since I have no idea what you're trying to do. I can't solve an ill-specified problem.
OK, so do you realise that "memory address of a pointer", taken literally, actually means "the address of a variable, itself holding the address of some other object"? Is that actually what you want? Why? 
Well, if you can't explain how to store a memory address as a string and then use it to read from memory starting at that address then I thank you for the suggestions on improving my C but I don't thank you for not providing any useful information regarding my question.
I was to be able to use address to look at memory if I lose the reference to the pointer. Is it that hard to understand? If I have something at 0x00000001 and I want to read it regardless of the defined or undefined behaviors how would I do that? Is it impossible?
 #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ const char *s = "Hello world"; printf("orig=%s\n", s); const int n = snprintf(NULL, 0, "%p", s); char addr[n]; sprintf(addr, "%p", s); printf("stringified addr=%s\n", addr); uintptr_t readback = strtoull(addr, NULL, 16); printf("read back address=0x%lx\n", readback); char *readbackaddress = (char*) readback; printf("string from read back address=%s\n", readbackaddress); }
K&amp;R's not really out of date. C hasn't changed that much in the last 30 years.
No idea how to have snprintf() return something else than int short of implementing your own digit counting function (hex digits in output string from uintptr_t).
Wow, you are amazing!
Why are you using sprintf to try to assign the pointer to stringAddress? Why not just do uintptr_t = (uintptr_t)string? Also, your malloc call for sizeof(&amp;string) will allocate 4 or 8 bytes, depending on the size of a pointer. But %p prints a leading "0x" usually, and you also need space for the NULL terminator of the string. You really need to take a step back and think about what's actually happening under the hood here.
&gt; Is it that hard to understand? Yes, it is. Now you've introduced a whole new term, "reference". Do you mean "pointer"? Do you mean something else? _Language matters._ &gt; If I have something at 0x00000001 and I want to read it regardless of the defined or undefined behaviors how would I do that? void *p = 0x00000001; printf("The byte at 0x%08d has value %hhu\n", (unsigned char) *p);
What if 0x00000001 was stored as a char?
&gt; What if 0x00000001 was stored as a char? Again, I don't think you're asking what you think you're asking. 0x00000001 is a 32-bit number. Do you have a system where 32-bit numbers can be stored in a `char`?
&gt; Yeah, I guess I mean pointer instead of reference. Ah, so you said "lose the reference to the pointer", but you really meant "lose the pointer to the pointer". Right? Frankly, I don't think you have any idea what you mean. If you don't, how can I?
A good resource would be to practice with websites that give you problems to solve in a particular language. Hackerrank is relatively decent at this. Solve the various problems in the language you want - it will help you practice using that language. Like with any language, practice is the key to learning it.
If the question was clear enough for someone else to provide the correct answer you’re just being an asshole.
You take things too literally. You should lighten up, maybe get your head out of your ass. You know exactly what I meant.
&gt; If the question was clear enough for someone else to provide the correct answer you’re just being an asshole. Yes, I _am_ being an asshole, but there's a purpose to it all. All through this thread you've been used language very imprecisely. You say "memory address of a pointer", or "reference to a pointer", but taken literally they do not mean what you think they mean. This isn't because I'm trying to be difficult. I'm trying to get you to think carefully about the problem. In doing so you're going to be able to be produce better code. "This is a pointer, that is a pointer to a pointer, they are different things."
Nothing you suggested was related at all to the question. Yes, the code could be better but I didn’t ask for that. In fact my code didn’t work for the purpose but I had the address stored as a string and the last step was using it to read from memory. You didn’t have to go the extra mile to be completely useless and come off as an asshole.
&gt; In fact my code didn’t work for the purpose but I had the address stored as a string As my very first post indicated, the fact you even got that far was purely coincidental. The computer is allowed to [do anything](http://www.catb.org/jargon/html/N/nasal-demons.html) the moment undefined behaviour invoked. You had invoked undefined behaviour.
Regardless of how the string got back in one piece doesn’t change the fact that it was there 100% of the times it ran in full. Coincidentally or not there was a few lines missing that /u/madoromi provided.
We could blame nasal demons for giving me a correct address.
Oh maaaaan I remember running into this problem the first time I used pthreads. What a nuisance.
You are very, very confused. Let's take this one line at a time. &gt; char \*string = "THIS IS A TEST STRING"; OK, this is fine. It's really a **const char\*** but that's not the end of the world. However, you can get this address by just using the string literal again. At this point **string** and **"THIS IS A TEST STRING"** will produce the same pointer address. &gt; char \*stringAddress = malloc(sizeof(&amp;string)); This is nonsensical. You have a char\*, and you're allocating some memory with malloc and assigning it to the pointer. That's OK, but you're allocating **sizeof(&amp;string)** bytes, or the size of a pointer. Why? The char\* value itself is already the size of a pointer, if you want to store a pointer you just need a pointer variable, you don't need to malloc anything. &gt; sprintf(stringAddress, "%p", string); This is also nonsensical. You're writing the textual representation of the address of string to the bytes you just allocated. This will likely crash or clobber some other value in memory. I don't even know what you're trying to do here, this line needs some explanation. &gt; char \*stringCopy = stringAddress; This line defines a new pointer with the same value as stringAddress. In other words, pointing to the same thing you just malloced and write the textual representation of a pointer to. None of this makes any sense. Your title doesn't even make any sense. What is it you're trying to do? If all you're trying to do is copy a string, this is all you need to do. const char* string = "test"; char* stringCopy = strdup(string); stringCopy[0] = 'b'; printf("%s\n", stringCopy); // Prints best printf("%s\n", string); // Prints test
Did you read the rest of the thread? The answer was already provided. Because I’m using C in a way you don’t recognize doesn’t mean it can’t be used that way. I wanted to save the textual or hexadecimal representation and use that to read from memory. It wasn’t that hard for everyone else that didn’t decide to take my code apart and rather just find a solution.
https://stackoverflow.com/questions/15151377/what-exactly-is-a-c-pointer-if-not-a-memory-address I am talking about the address not the pointer itself. You people are thick.
I still have no idea what you're trying to do. You should work on your communication skills and on not insulting people who are trying to help you.
If you’re asking about C++, I suggest asking on r/cpp.
Don't blame other people for your inability to articulate what you're trying to do.
It’s in the answer already provided 30 minutes ago. The entire thread has been people being assholes and tearing the code apart without being useful or answering the question. If you read the thread you would see not only where someone mentioned everything you did but also where the answer was provided and how nothing you suggested actually had anything to do with the problem. At the end of the day, I wanted to save the textual representation of the address stored within a pointer (not the pointer itself because that’s not the address) and use that textual representation to rebuild a valid address in memory which could be used to retrieve bytes in memory at that address. You didn’t read the topic. It’s pretty damn clear.
Well first, this subreddit is for C not C++. For C++, check out /r/cpp_questions and for general programming /r/programminghelp. That being said, the answer to your question is still [The Internet™](https://en.cppreference.com/w/) or A Book™.
Answer is already way above your post.
I'd avoid the -Wpedantic monastic order, though.
I think you found it already, but the problem is: pthread_join(&amp;threads[i], NULL); 
I'm glad this strategy is working for you! You should totally take the advice /u/rro99 posted about using a predicate and a loop (and I should have RTFM 😄)
&gt;The entire thread has been people being assholes and tearing the code apart without being useful or answering the question You came here and asked how to do something contrived that doesn't have any actual use, and when people tried to get you to explain what it was you were after, you berated them for not understanding what you were asking, like it was some kind of subtle trick that requires deep understanding of the language. You said you were looking for input on "improving your C". Improving your skills in *any* language has more to do with clarity of intent than type conversions and string formatting. Converting from a string to a pointer value like you're describing is something you'd basically never do, not because it's not possible, but because there's no point. I occasionally use the %p specifier in printf() for diagnostic output, and I can't think of any other time I've needed to print a pointer value. If you're taking numeric input as strings, it's probably because you're getting it from an outside source - the keyboard, a file, a JSON object, whatever. That outside source would not be expected to have any knowledge of your memory layout (the primary exception to this being a malicious attack on code *accidentally* dereferencing externally-provided pointers) and it doesn't really make any practical sense. And if you're working only locally - *why* would you do a string/pointer conversion? Aside from wanting to burn thousands of clock cycles and a bunch of stack space (I'm an embedded systems guy, we worry about these things) to do something in a way that complicates any sort of portability.
I prefer the [gcc](https://feross.org/gcc-ownage/) approach to undefined behavior.
&gt;If I lose the pointer to the memory space and I want to use the address instead. Does that make things easier? Back up a second... when you say it like this, I'm guessing maybe you've only worked with a language like Javascript that has a concept of references but doesn't explicitly expose pointers? What you're saying doesn't make much sense. All the pointer holds *is* the address. What /u/aioeu showed you is exactly what you asked. That line of code takes an address (namely 0x0001) and casts it to a pointer to an unsigned char, then assigns that to p. p is now a pointer that points to whatever is at 0x0001. You can even skip that assignment. \*(unsigned char *)0x00000001 will give you the contents of that address.
use valgrind. Syntax is `valgrind -valgrindOptions ./program programArgs` And don't ever ignore warnings unless you know exactly what you're being warned about and that it's not a problem, and even then, suppress the warning explicitly and comment why.
What you're trying to do is inane and idiotic. He's asking what you're actually trying to do so he can point you to the right way to do it. But go ahead, spit in the face of someone who actually tried to help you.
&gt; Did you read the rest of the thread? The answer was already provided. In my experience, people like me who hang out in these kinds of forums don't want to help new programmers simply by giving the answers, but instead by instigating understanding. You're doing everything you can to fight that.
Currently, this thread really feels like a classical [YX-Problem](http://xyproblem.info/) occurrence. I'd love to know _why_ you'd want to attempt to stringify a pointer like this. What is the goal you want to archieve? Besides maybe "to see if it can be done", a procedure like this is always a means to some end. Maybe there are other, potentially better ways to reach the desired end?
I understand what you’re trying to say but it didn’t help me get anywhere. I can add some space to the string buffer and understand that the semantics of calling anything a char implies that it’s a value between -127 and +127 and that sizeof(&amp;string) returns the same as sizeof(char *). This is too short to store the string representation of a memory address. This is okay. My code did not crash and returned the correct data via purely coincidence. Does it do what I wanted? No. I wanted to store the address in a string and then retrieve the contents of data stored at that address with the string address. I already achieved getting the address in a string via defined or undefined behavior. It doesn’t matter. I needed the next step more than anything. I needed to find the contents of memory based on a provided memory address. Fixing errors would come after I achieved the solution. Derailing me with useless shit doesn’t help. Buffer overflow, cool. This isn’t production. I’m trying to get something done for fun or for hobby. Your style of teaching via intrigue doesn’t help because it sounds like you’re just putting someone down for the steps they took on the way to the solution to the problem instead of giving them the path to it directly.
I've frequently longed for a particular _perverse_ C implementation that deliberately takes the most annoying, but technically correct, interpretation of the C specification. I reckon it'd shake out a lot of bugs in my code. I've been meaning to try out [`tis-interpreter`](https://trust-in-soft.com/tis-interpreter/) some time.
I like how nobody acknowledged your solution. You are awesome.
&gt; Regardless of how the string got back in one piece doesn’t change the fact that it was there 100% of the times it ran in full. That's a stupid (VERY stupid) argument. When you're invoking undefined behaviour while playing with pointers and arrays, you can *easily* write to memory that you didn't mean to, before, after, or *anywhere* the OS will let you. A piece of code that works as a standalone program can stop suddenly working by adding any code anywhere in the program, for obscure and undebuggable reasons. It can also work one time and not another just because the execution environment and memory layout changed a little bit. It can run on your machine and crash on others and vice versa. If you've ever read stories of programs that stop working when you remove a print statement, this is why. Calling out undefined behaviour is *not* pedantic, it's the sane thing to do, undefined behaviour is not to be invoked, ever. Also, madoromi provided you a solution you don't need for a problem you don't have. Storing a pointer as a string uses more memory, it has to be converted back and forth, if you can "lose" the original pointer, there's no reason you can't lose the string, you can't write the string to disk to allow for reuse because adresses will change from one execution to another. It's an interesting challenge to program for technical reasons but you seem completely uninterested by the technicalities. The reason *everyone* is riding your arse is because you're trying to do a foolish thing and you won't back down or give a straight answer as to why you're trying to do what you're trying to do. So I'll ask you once more, what could you possibly need this for?
I don’t. Someone proposed that you could write a faster hash table by storing keys associated with memory addresses. You would find the key and associate the memory address and go directly to memory and read it. I thought it was dumb but I proposed a challenge online. It’s not that I don’t care about technicalities it’s that I don’t care about about the Stack Overflow logic where my purpose influences your answer. Who cares what I want to do with it? I want to do it.
C is an old language, and it's not a subjective subject, most tutorials or articles on C that you can find on the internet are usually accurate so you can learn anywhere. If you want a book K&amp;R is fine, all it's missing is some of the more recent features of the newer standards (like declaring variables at the start of for loops and designated initializers) but those are just quality of life improvements, you don't *need* them and using them or not won't make you a better or worse C programmer. My advice is this: find a tutorial with a teaching style that suits you, do a lot of exercises, most basic C tutorials will go up to pointers. At that point, since pointers are typically a sticking point for most people, I suggest you try to implement some data structures and functions that rely heavily on pointers to refine your understanding. In particular, a binary tree is a great exercise, and trees are a very important data structure to understand in general regardless of language as they have all sorts of uses. After you get a good grasp of pointers, get some hands on experience with parallelism and thread synchronization, and you should be ready.
&gt; write a faster hash table by storing keys associated with memory addresses. You would find the key and associate the memory address and go directly to memory and read it This doesn't make any sense. That's already how hash tables, work, you hash a key, access the table at the hash value, and the table contains a pointer to the resource. Or I didn't understand what you meant. &gt; the Stack Overflow logic where my purpose influences your answer. This logic is justified: most of the time people asking a very specific question without explaining their problem are trying to solve their problem in the wrong way, if someone is trying to resize a window programmatically and they read somewhere that the window manager reads the values for the window size from a a struct, and they go around asking how to write directly to the struct, it's a good thing that people will tell them it's not how you should do it and you should use API calls instead. Because it solves their *real* problem, in a faster and more stable way.
The broken English is really getting in the way of the information you're trying to convey. 
Thanks for the answers! :) I am looking for things that may cause beginner hours of frustration but can be easily overcomed. Something that may look logical at first sight but is actually wrong/doesn’t do what you would expect. Like in the stackoverflow link. And about thenewboston I have bought an C course on Udemy and plan to watch it, but right now I want to get the basics as fast as possible
Thanks! The the comp.lang.c seems exactly like the thing I am loooking for! :) And about the operator precedence I guess I will have to learn it by heart :/ 
You'll learn it very quickly if you are diligent and force yourself to in your head go over some expression, e.g. `some_int ^= other_int &gt;&gt; X`, and confirm or deny your suspicions by checking the actual rules against what you thought. [This](https://en.cppreference.com/w/c/language/operator_precedence) is the resource I refer to whenever I am unsure.
I think you might find that pointers are a pretty simple concept, and although it may take different people different orders of time for it to "click in to place", once it does you're sorted. Some additional things I'd recommend being aware of before jumping in to C are the type system and how memory is used, having a good understanding of these will save you a lot of headache in the future. I'd really recommend you read [The Descent to C](https://www.chiark.greenend.org.uk/~sgtatham/cdescent/) if you've got some prior programming experience, it covers a lot of vital information and is fairly concise. Some fundamental things I'd recommend you're comfortable with for systems programming: - Endianness - (un)signed integer representation (i.e. [2's complement](https://en.wikipedia.org/wiki/Two%27s_complement))
**Two's complement** Two's complement is a mathematical operation on binary numbers, best known for its role in computing as a method of signed number representation. For this reason, it is the most important example of a radix complement. The two's complement of an N-bit number is defined as its complement with respect to 2N. For instance, for the three-bit number 010, the two's complement is 110, because 010 + 110 = 1000. Two's complement is the most common method of representing signed integers on computers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Another problem is that if raii_lifetime_elem contains a void**, then using it to access other pointer types is not portable because pointer types may have different representations. The automatically freed pointers would all have to be pointers to void. Which would be inconvenient, but would also mean the type isn't required. g_steal_pointer ([which is actually a function and not a macro](https://github.com/GNOME/glib/blob/16c6a735866c63abaef78d5fdb2bad84be5a5a03/glib/gmem.h#L197)) has this problem too: although it it meant to be used with all pointer types, the argument is cast to void**. This isn't portable, but I guess it works on all platforms glib supports.
Oh, you're just looking for exercises. Check out [codewars.com](https://codewars.com), it's a great site with hundreds (thousands?) of exercises, a ranking system, you get to have people comment on your completed code, you can comment on theirs, I think there's a help forum, etc.
Have you tried stepping through this code in a debugger? In particular, you might want to look at what's going on in that last loop.
How does this even compile? I didn’t think you could initialize and array with a non constant..
I run it in ubuntu gcc compiler there is no syntax error may be some logical error. Please correct it.
It compiled. and given output some random big number.
&gt; I run it in ubuntu gcc compiler there is no syntax error may be some logical error. Please correct it. No, I'm not going to do your homework for you. You are correct that there is no syntax error. I've told you what to do to actually _find_ the problem for yourself: step through the code in a debugger. I'm not going to deprive you of that joyous aha! moment when you discover for your very self what the problem is.
okay i will try but correct me if i can't find it.
&gt; How does this even compile? I didn’t think you could initialize and array with a non constant.. C99 introduced variable-length arrays. It also introduced mixing of declarations and code. Both of these are being used here.
what's n stand for? *n*umber of total elements? maybe *n*icely blends into the background, or *n*ot descriptive enough to know what it is wherever it appears. you can help avoid this *very common* issue in the future by naming variables descriptively. try something a little more descriptive like "length" instead of "n" and your code will be more obvious about what's wrong.
Its number of element in array.
And I bet if you actually called it `number_of_elements_in_array` you'd see where the problem is.
No kidding? man, you miss out on all the good stuff when your code has to be compatible with all the standards. Thanks!
Please tell me i am unable to find.
&gt; Please tell me i am unable to find. As I said, I'm not going to do your homework for you. (Put simply, if you can't solve this exercise, then you _should_ get a low mark for it. You're not going to cheat your way out of that by appealing for the answer online.) But I'm quite happy to tell you all about debuggers! Have you used `gdb` before? I don't know of any good tutorial for it, because I've never looked for one before. Maybe you'd like to!
Tell us what you expect the program to do and what it does instead. Otherwise, nobody can tell what is wrong.
Dude, just step through your code (especially the final loop) and maybe use a pencil &amp; paper to track the variables - its an obvious and simple mistake, you'll kick yourself when you see it.
This, just looking through the code on the phone I see what the issue is. Even just stepping through a debugger should make the issue glaringly clear. If the OP isn’t willing to step through their own code with the debugger after receiving generous hints (or taking the initiative to google a free IDE that has a debugger), they deserve low marks on the assignment. 
Thanks for pointing it out. I fixed some with the help of Grammarly. Hopefully it's getting better a little bit. 
Hint: the length or `arr` will be `n` times 4.
This is a brilliant suggestion. Go through the code, replace every occurrence of `n` with `number_of_elements` or something like that. The answer will pop out immediately.
I know this's off topic, but... Which code editor are you using?
Threads are an operating system concept and implemented in the kernel. Implementing a kernel would require implementing threads, a scheduler and lot more. The POSIX threads are built on top of OS provided threads.
Now i Know my Mistake it was in last printf line i.e printf("%d",brr[n]); it should be printf("%d",brr[i]);
&gt; Now i Know my Mistake it was in last printf line i.e printf("%d",brr[n]); it should be printf("%d",brr[i]); I have noticed it just after seeing the code.
Wow. No. Dennis Ritchie and Ken Thompson wrote the first version of Unix in PDP-7 assembler in 1969. It was then ported to the PDP-11 in 1970, and additional software (mostly text processing) was implemented in PDP-11 assembler. Dennis Ritchie wrote the first C compiler, which ran on Unix, in 1972, and Unix was subsequently rewritten in C. The first Unix release written at least partially in C was Version 4 in 1973. Linux was written from scratch starting in 1991 and inherited absolutely nothing from Unix. It was written in C simply because that was the most appropriate language at the time, and the easiest to port to new platforms.
You can look at the implementation details here: * https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/kthread.c?h=v4.17.8 * https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/kthread.h?h=v4.17.8 Its more or less a variation on a process.
What came first, the chicken or the egg?
Maybe. Maybe not. Irrelevant either way.
&gt; most tutorials or articles on C that you can find on the internet are usually accurate hahahahaha *snort* hahahahaha *snort* ohmygawd hahahahahahahahahaha *gasp* hahaha *weep*
Threading and processes are supported by the kernel. They're one of the many abstractions that it provides, and it exposes an API (syscalls) to let developers/users make use of them. When a programming language has support for threads, it means that it includes an abstraction layer on top of those syscalls (it might be a library, or part of the langague) /u/necheffa pointed out the actual implementation of how the kernel creates this abstraction layer. So, the moment you decide 'hey, it would be cool to write a kernel', you don't have threads, processes or anything. You'll be messing with the CPU's own registers to create this abstractions.
Most tutorial on Internet are just plain wrong therfore useless
The newer standards rescind and replace the older. 
I like to fix existent legacy projects as I usually submit to free and open sources projects in my spare time
Royal level bs.
&gt; int cents = (int)(cash * 100.0 + 0.5); This assumes `cash` is always positive. Maybe that makes sense for the particular application, but for /u/KesoHB 's edification, if `cash` is negative, then you should subtract 0.5 to get the correct rounding.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
[removed]
Definitely recommend The Linux Programming Interface (TLPI) by Michael Kerrisk and the Advanced Programming in the UNIX Environment by Richard Stevens. When you talk about learning systems programming, you don’t really need to know about C beyond K&amp;R book &amp; the first 4-5 lectures of Stanford CS107 “Programming Paradigms” lectures (available on youtube). Rather, you want to focus on how the UNIX OS was implemented, and understand the concepts of virtualization, concurrency and persistence.
You left out [the B language](https://en.m.wikipedia.org/wiki/B_(programming_language\)), the [predecessor of C](http://www.bell-labs.com/usr/dmr/www/chist.html).
Good bot.
Meh. Interesting as a predecessor of sorts to C, but played little or no part in the development of Unix.
The OS provides the facilities to create Processes and, usually also, Threads. To say that a "language supports threads" can mean two things (mostly both): 1. There are keywords in the language that aid creating threaded programs (`_Atomic` in C or `synchronized` in Java) and that 2. the standard library has functions to implement thread handling. C, back in the days, had neither. To write a threaded program, replacing keywords like `synchronized` is rather easy, they're basically just telling the compiler to put around the functions body to lock some mutex or similar -- you just write that code yourself. But there still need to be functions to actually implement thread and process creation which need to be provided by the OS (usually in the form of syscalls which are again wrapped in a usually nicer API). In order to write Linux itself, it doesn't matter whether the standard library has functions, since the standard library builds ontop of an OS -- we are coding in a freestanding environment here though. Keywords aren't essentially needed either. So need to implement the concept of threads and processes ourselves. Then we can use those custom threads and processes. Some things here are quite difficult (if not impossible) in C89 to implement, you might need to go down to Assembler in order to use the CPU provided facilities for atomic operations. Usually compilers provided extensions that made that for you though. Some of these are now in the C11 standard and thus there's been some discussion to put Linux on this standard. That's the most rough yet hopefully complete explanation I can think of.
This question does not make much sense, but here is an answer for you: The CPU just executes instructions, it doesn't care at all what programming language the instructions were compiled from.
No
+1 When it comes down to basics you can actually reverse binary on almost any machine code program to show it as Assembly Language. I know you can show Assembly on compiled C with gdb using the “disassemble” command
Its just been 6-7days since i got into C
No man! That worked! He was right! And why would you limit the size to zero? Even the string terminator takes one byte
You used `x = 0` instead of `x == 0`.
haha, wow! Thank you so much! Can't believe I missed that. It works perfectly now!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions. Also, please never ever post pictures of code. Always post code as text.
Interested in this, even though I'm relatively new to C. Where do I find open source legacy projects to contribute to? My open source experience is me basically putting solutions to end of chapter problems problems on git but I'm willing to venture into something like this. 
Okay, I apologize! Thanks!
No need to apologize! Just pick the right subreddit next time.
Please be civil. This is your final warning.
Please be civil, especially towards those who want to help you.
Firstly, I don't see what the problem is with a simple joke. Are you really going to make this subreddit that much censored? You do know this is Reddit right? I won't continue it, but I would like an explanation of what I did wrong. Secondly, "final warning". I have not done anything wrong before or been called out for anything I said on this subreddit either. Please explain to me why this is a "final warning". Unless all you give is one warning then chuck people out. I'd also appreciate if you can lock the votes on my previous comment so I don't have to delete it to prevent the bandwagon downvotes, and it can stay up there as evidence of this discussion. Lastly, I would like to make sure that you and owner of parent comment know what yo mama jokes are and that there is not a miscommunication that I was actually insulting someone's mother.
Doing exercises is definitely one way to get the experience, and I will definitely checkout the codewars and hackerrank, but because I was well... a little lazy I have only about one month to learn C basics and I am afraid that with my attitude doing exercises just won’t be enough. With this question I was trying to “cheat” a little and ask for some tips to pick up most of the upcoming misunderstandings before they will ever happen. And I believe that what I got is more than enough, thanks to all of you! :)
why use an inferior solution when can easily deal with hardware directly?
Linux did not inherit any implementation, but its API is derived from that of Unix, ultimately.
This is the final draft of the recent C standard C17. It doesn't contain any new features over C11 and merely fixes a bunch of defects. Read [this answer](https://stackoverflow.com/a/47530004/417501) for a summary of changes.
tl;dr it's a bug fix for C11
I'd presume it's because you're passing in a value and not an address
Oh, yes! I forgot it! Thank you mate! It works. 
You want to as C++ questions in /r/cpp_questions
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
very good answer ty sir
Even then, the bits that the kernel is in charge of, will not appear in the disassembled code, just the syscalls (and before it, a bunch of function calls inside the standard library) If you disassemble a 'hello world' program, you'll not be able to see the instructions that *actually* write the string to the console. This is a reason because of which executables are not portable across OS's
You do understand that this is a specific subreddit and thus has it's own subculture? The same way I don't "Hey Bro" by boss in an EMail just because "it's the Internet" you don't need to make (bad) Yo Mama jokes in this subreddit. Just compare your comments to everyone else here: It doesn't fit it. And no, not because all the others are censored, but because for them it's obvious that such content is unwanted here. There's r/ProgrammerJokes for low-quality content if you want that, but not this sub. This wasn't bullshit because it was insulting, it was just uncalled for. If you want to keep archive the discussion, just cite the comment. And seriously, "need" to delete it? If you want it as an evidence you shouldn't be so greedy for karma (another good sign, that the comment was uncalled for). Honestly, I was thinking I was in r/ProgrammerJokes for a second when I was reading your comment. Bad impression.
It would be great if they'd deprecate using non-Unicode character sets, but there's absolutely no way that'll happen. :/
Understood, I'm sorry. I'm young and I went overboard. I'm thinking more clearly now, got a bit pissed before. Not totally experienced with reddit so I'm not exactly sure how archiving works. What I meant by evidence was if you guys wanted to keep the comment up (due to our conversation), I'd appreciate if you let me know and if you feel I deserve it, disable the votes. I am not greedy for karma, I have enough to keep my account alive on Reddit. I just didn't want to lose a lot because people just saw downvotes and kept downvoting without reading what was happening. If you think I deserve the downvotes ill take the hit. I won't be cheap and delete.
If you're unfamiliar with it, Codewars is probably not what you're thinking of. In the very beginning, the easiest exercised might as well be examples from a textbook. However, the further you go the more involved the exercises get and are basically entire projects rather than "exercises." When transitioning to a new language once I get the basics down Codewars is the first place that I hit for something to do. I can't recommend it any stronger really, it's great. Though that's a subjective opinion, maybe it's just not what you're looking for.
Older people have the same problems (and I'm not really old either), everyone gets pissed at some point, it's usually a good idea to calm down first -- but everyone slips in a while and goes overboard, all good if one realizes that! I thought about "archiving" as simply quoting the text in the reply and deleting the old comment, this "locks" the votes but makes it clear what we talked about, but I don't think we're mostly done here, so you decide what to do. I think though that the downvotes mostly came not because it's already been downvoted, the comment was short enough for everyone to have read it ;) I'm not on the mod team, I only know fuzxxl and I know what's appreciated here. It's always good to get a feeling for a community before rushing into it and get in trouble. There are communities with a more lax approach but usually they're of less quality or they're more personal, eg. chat, so everyone knows each other and the borders for jokes are thus defined by each person. But I think you've learned your lesson here more than enough, I hope it didn't completely push you away. We're a cool bunch but mostly technical stuff only is appreciated here ;) Good day/night!
Thanks for your response and for putting me straight. I do love this subreddit, and I'm starting to understand the boundaries a bit more (like Posix questions are not taken as well similar to the freenode irc). I'll be more vigilant in the future. 
A language doesn't need to support threading in order for it to use threading as threading is not implemented by the language but by the OS (except for "greenthreads," but that's another topic). So say I invent a language called G (for gaxio, of course) and it has no support for threading but can make system calls. If it can make system calls, it can ask the OS to spawn a thread, which starts up a second thread of execution in the same address space. The language is rather indifferent to threading. However, that's not entirely true. A lot of languages have a kind of shared state between threads, think of this like a bunch of global variables (but in actuality it's a bit more complex than that). Now if the language is written without threading in mind then any time you access this shared state you're risking either race conditions, or corrupting data structures which can lead to all kinds of shenanigans. To alleviate this, most interpreted languages that don't support threading well implement what's called a "global interpreter lock," which is one giant mutex that one thread must lock before accessing this shared state. I think all the major scripting languages went through the "GIL phase" where they just weren't well optimized for threading. C does and does not suffer from this problem. Since there is very little abstraction, there is very little shared state. C can support threading very well without ever needing explicit support for it for this very reason. However, any globals you may have are vulnerable to this as well as any shared state hidden away in the standard library. On many platforms these are "thread locals" though, another thing the OS implements that gives threads their own copy of global or static variables to prevent these synchronization problems from happening. For example, consider errno, which holds an error code of the last standard library function to have failed. If thread A calls a function that fails and sets errno, then thread B wakes up and also calls a library function that fails and sets errno, if thread A then wakes up and reads errno it will get the wrong value. That is, it would get the wrong value if the libc authors hadn't told the linker to put these values into "thread local" spaces that are duplicated on all threads, preventing this from happening. So in that way C does have support for threads, or at least libc does even though it doesn't have the functions to actually create, wait and kill threads.
It looked like a fix for a better and improved C programming
&gt;C17 Its clearly an acronym for City 17, the city where Doctor Breen elected to establish his administration. Welcome to City 17. **It's Safer Here.** Seriously though, thanks for this resource.
&gt; played little or no part in the development of Unix. Perhaps, in one view. But the success in writing software in B like an assembler, dc and yacc on the pdp-7 and honeywell Unices led Ken and Dennis to try B on the pdp-11 platform, where the typeless nature of B, from its BCPL roots, was a problem. So B was evolved into NB and then C. Then the UNIX kernel was rewritten in C, because it could be done. So the desire to write the kernel in a high level language was a factor in developing C from B, via NB.
They have chosen or been chosen...
C and C++ are very different languages so you probably want /r/cpp_questions instead.
Ok
Interesting read. It would be nice to have the C standard move towards the “fat pointer” he mentions.
Spend more time programming and work with someone who is better than you. I felt like I was making a lot of progress while I was in school and doing a good bit of extracurricular programming, but I started learning at a pace that I didn't know was possible when I got an internship. Programming for 40+ hours a week and having someone to learn from is really important. 
Among always writing and refactoring personal projects, never stop reading good code
The second and third accomplish the same thing. Note, you don't need to specify the `5` in the third - it will be deduced from the initial values. The first one declares a pointer to a string. The string itself (i.e. those five chars) is actually part of your program and should not be modified. Because of this, it would be better to use `const char *`. The second and third declare an array of those 5 chars on the stack and initializes them. You could, if you wanted to, modify those chars. Whether you want a pointer to a string vs allocating your own string (array of chars) really depends on what your doing with the string. If you want to modify chars in the string, you'll need the array of chars. If you want to change the string entirely, the pointer might be better as you can assign it to point to an entirely different string. Whereas, if you were using an array of chars you'd have to copy the chars from the different string over and then you'd have to ensure there is enough room for them all. 
It sounds like his main point is that C's greatest mistake is that it did not add syntactic sugar for passing around a pointer to an array and its size together as an abstract type. That is a very silly criticism and I wouldn't even count it as one of C's top 10 or 20 mistakes or flaws. The author doesn't seem to be very familiar with C, because he says "the inability to pass an array to a function as an array, even if it is declared to be an array". That statement doesn't even make sense in the context of C. You can't pass an array, because an array isn't a value. It's a compile time label to a block of memory. You can't pass a compile time label to a function at runtime, you have to pass a pointer. Arrays don't exist at runtime.
&gt; The author doesn't seem to be very familiar with C This smells a lot of trolling, but concerning your other affirmation, I just want to ask you what happens when you pass a struct to a function?
This is a great answer but IIRC your const comment is only half correct. “const char *” is simply a constant pointer to a char meaning the pointer can’t change what it’s pointing to. Because it’s pointing to chars in code, the chars themselves should also be const so “const char * const” is the syntax intended although admittedly hardly ever used in reality. I don’t have a compiler handy to confirm but I believe it to be correct semantically as well as syntactically.
&gt;It sounds like his main point is that C's greatest mistake is that it did not add syntactic sugar for passing around a pointer to an array and its size together as an abstract type. Arrays already have that information though. They're already syntactic sugar for a pointer and size. You just can't pass it without losing the size part.
There is actually a way to do this already. I've seen two implementations of it, one in nothings' [stb stretchy buffers](https://github.com/nothings/stb/blob/e6afb9cbae4064da8c3e69af3ff5c4629579c1d2/stretchy_buffer.h) and the other in antirez's [simple dynamic strings](https://github.com/antirez/sds). As far as I can understand (and I'm not a seasoned C programmer, so YMMV) both those libraries use the heap to allocate space for your arrays (stretchy\_buffer can hold whatever you want, sds just chars) and stores the length of the array in a prefix that resides _before_ the pointer that the allocation function returns. (sds has a nice diagram for you) Basically they allocate more memory than you ask for, just enough to fit an int variable to hold the length, but to the user, they return the offsetted pointer, which represents the begining of array itself. The library internals use the length in subsequent calls to operate on it in a safe way. I would love to see support for this in the actual language, instead of needing special libraries for it. But maybe I'm missing some of the pitfalls. 
The struct gets copied onto the stack, stack pointer is set, execution jumps to the function, ignoring specific architecture and compiler optimizations and the gritty details of the underlying instructions. I guess where you're trying to go with this is, why not copy all of the values in the array onto the stack to pass to the function? Because this adds a ton of complexity and has significant ramifications for performance. Arrays are variable size, unlike structs, which means that without rewriting the C language you're limited to only passing a single array in this fashion at the end of the argument list, like so (a hypothetical implementation of this): void f(size_t n, ...) { /* horrific macro magic to access the elements of the array */ } void main(void) { char x[12] f(x) /* or f(sizeof x, x), or f(x...), pick a syntax */ } Even if you hypothetically implemented this, note that this is very different from what the author is suggesting. I suppose you could call this "passing an array", so I am incorrect in flatly claiming that you cannot pass an array. You can, but it would look very different from passing a "normal value" like an int or a struct or a pointer.
I would look into using `Windows.h` to play audio and then using `libcurl` to download the file. Overall Python would be better suited for this.
Thank you. That's where I was going with my question. And you could pass multiple arrays, I think, if the array memory layout contains also its length (see my other reply in the thread for a method of how this is achievable right now). And I'm not sure how this is different than what Walter suggests. From what I've read he wants the array layout to include at all times its length, which then gets passed to functions, and the compiler knows where it starts and can compute where it ends. Please correct me if I made a wrong inference.
&gt; Arrays already have that information though. They're already syntactic sugar for a pointer and size. No, arrays aren't pointers. Instead of trying to explain myself, here's an article that does a much better job than I can: https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c
Well, POSIX is an OS standard so it's kinda not directly ontopic, but if you're talking about the C Interface (XSH) of standard, all should be good. Unfortunately there's no active POSIX/UNIX subreddit I know since most people here use Linux. But I at least can tell you that fuzxxl and I would probably answer those questions gladly, if we see them. We've both had an internship at some guy in the POSIX committee, so we do have at least some experience there!
That's exactly my point. They're more than just a pointer already.
I think his point is that you can use sizeof(arr) to get the size of an array, but if you convert this to a pointer sizeof(ptr) wont allow you to do the same thing.
&gt;The author doesn't seem to be very familiar with C Heh.
I'd have thought if there really is a "biggest" mistake, it would be the primitive memory management...
If you want to learn programming in general I'd suggest to you start with really basic stuff like learning how to print stuff and then slowly building off that. Pick a course online that you feel comfortable with and stick to it until the end. Start by printing Hello World, and move on to taking a number as user input and printing it back. Once you understand what's going on here move on to addition and subtraction of two numbers and programs that are related to this. At this point you'll have an understanding of variables and data types. If you can successfully make it this far, you'll have come really far ahead even though it seems like you're doing very little. Now, move on to conditional statements and this will open you up to a plethora of new programs. Once you have this figured out, move on to loops and iterative structures. Once again, so many programs await you here. Once you've reached the point where you can do all this successfully (should take you about 2-3 weeks, don't worry if you take longer) go on and learn how to use user defined functions. This one is takes a bit of work to understand and don't worry if you get stuck. Successfully being able to understand recursion to me is a good sign that you've got the hang of user defined functions. Now, you learn how to use Arrays, again start of simple by taking input of the array and printing it back and such. Slowly, as you understand the workings better, learn a couple of searching and sorting algorithms. (To get here takes around 2 months I feel.) After you've come this far, you should check out strings and string manipulation. Reversing them, finding the position of a character in the string and all that. If you've got a good grip on arrays this should take you about 30 minutes to understand. Once you've got all this under your belt, you've essentially learnt programming. What now remains is learning the language. Everything you've learnt up until now is pretty language independent. You can easily write the same programs in any language you like with little modifications to the syntax. Since you're picking up C++, now you start off by learning some Object Oriented concepts and slowly, implement programs that use them. Also, learn some nuances of the language like how C++ treats memory and handles garbage collection and all that. And because C and C++ offer the option if using pointers you should definitely spend a good amount of time understanding them. If you've got the hang of this, you're essentially done with learning programming. Everything beyond this is basically you becoming a better programmer by learning better algorithms and data structures. And more features like handling files and exception handling and such. A good programmer must know all these features. All the best!!
&gt; “const char *” is simply a constant pointer to a char meaning the pointer can’t change what it’s pointing to. Um... no. You're plain wrong. `const char *` means "pointer to constant character". The pointer itself is not constant.
&gt; The second and third declare an array of those 5 chars on the stack and initializes them. They aren't necessarily on any stack. For example, those declarations could be in file scope, in which case they would be initialised, one way or another, prior to `main` being called. (This does not necessarily need any code from the compiler. The data could be loaded pre-initialised from the executable, for instance.)
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
learn book chapter &gt; exercises &gt; revision &gt; program using such features
You can make everything with C. But the word *script* isn't appropriate here. And i wouldn't really advice you to use C for this. It will take time to code. But anyway you can use libraries like CURL to download the MP3. It is better to use Python for these jobs, since it is not a really performance critic task.
On top of the imprecision that floating point errors have, there is another drawback to reading in a number as a float: Inputs like `10e20` and `3.14e-42` are allowed as well. For an application where someone is supposed to enter a monetary amount, this does not make any sense. If you expect the monetary amounts to have a reasonable upper bound, use fixed point arithmetic (representing money as e.g. 'cents', and making sure you convert to- and from cents whenever required). If you do not know, use big number arithmetic. Do _not_ use floats for this. Floats and doubles are super useful in things like complex physics simulations, where speed is important and approximations are good enough, which is why they exist in hardware on our modern computers. But whenever you need precision, they are not the tool to use.
Genuine question - if I'm mainly using one array type (say double[] in scientific computing) would there be any downside to just creating a struct with a size_t which holds the size and a double* which points to the data and then pass these structs around by value? Are there any performance or safety benefits of the author's fat pointers over this?
&gt; So the desire to write the kernel in a high level language was a factor in developing C from B, via NB. So think of it as an early stage in the development of C. I don't see how it matters. C is what matters.
You are passing a pointer to the tree and modifying its contents - there is only one tree. Look up shallow copy vs deep copy. Also, that second argument being passed in is unused and may be adding to your confusion.
As JelloDarkness said, you're passing a copy of a pointer to some `Node` to each successive invocation of `PrintPreorderAddOne`. So while the address of `root` may change, but the address of `*root` is the same. In addition, you mention stack allocation, but.. I can't see any stack allocation here. It's not exactly true that the stack is valid only as long as 'the function call is active', rather, until there is an exit point. Each successive recursive call of `PrintPreorderAddOne` does not make the previous call's stack invalid, but creates a new 'frame' which then becomes the active one. I'm not entirely sure what you're asking.
Yeah, aioeu is correct. For instance: char const * const x; // x is const ptr to const char char const *x; // x is ptr to const char char * const x; // x is const ptr to char This is why when learning I put the const qualifier right wards, and read the statements leftwards; Doing that may help you, but again this qualifier positioning also makes some people's skin crawl.
Sorry about the question not being clear. What my confusion is about is that, I thought that the the function PrintPreorderAddOne runs such that it will add 1 to each node before printing it and since I'm not returning anything from the function, when the control goes back to main, these changes wont stay i.e. they wont be permanent. I can see that this was wrong but I'd like to understand why. I essentially though that each function call is independent from the others, hence why we pass the arguments that we want to work on/use and return any output back from the function. 
I don't get this thread. You can make threads in C with pthread, no?
That is only true if what changes in the function is a scoped locally to that function. However, you're passing a _pointer_, so while the _pointer_ is a copy, dereferencing that still gives the address of whatever you originally passed in. For instance, [see this snippet](http://codepad.org/ZuW0nHc8). Have a play around with it, and you will see that from the `add_one` function, if you do `&amp;num`, the result will be different to `&amp;num` from `main`. This is because you're taking the address of **a copy of a pointer**. Dereferencing the _copy_ (or taking the dereferenced node's address) will still give you whatever it was pointing to. I hope that helps! -- Edit Just to clear up anything else, the `-&gt;` operator dereferences a struct. So if you passed a `Node node` to your function, and replaced the `-&gt;` with a `.`, you would see what you expect, because you would be operating on a _copy of the struct_. However, in your code, you are operating on a _copy of a **pointer** to the struct_.
You have a place in memory that was created. This location in memory holds a value. You are passing the location in memory to this function, accessing the same location and adding one to the value held in that location. If don't want to change the actual value, you could just do printf ("%d", root-&gt;data + 1); Now you are not assigning the location in memory a new value. You are passing printf a value from that location + 1.
I agree that arrays are basically incompletely implemented in C, but I think this problem is best solved by everybody saying fuck arrays and not using them. 
What I like from C is its simplicity with the flexibility to add almost anything yourself. If you don't like it you can choose other languages, or you can provide that functionality yourself or from a library. If C was like D then what's the point on having C anyway? I don't think `struct int_array { size_t length; int values[]; };` (or any variant you may like) is that difficult to write for anyone used to write C. If you want your arrays to keep the size in the type, you can also store it into a structure without the overhead of the size value: `struct five_ints { int values[5]; };`.
Oh perfect. Thank you. I've asked them a few times around Linux and stuff and those guys generally just sent me off to irc. Appreciate it. 
Just pointing out that the history of UNIX, before there *was* C, included other, higher-level, languages. No B means no NB, which means no C. Not saying that C isn't important. It's the second language I ever learnt, after assembler, and one of my favourites.
Great explanation mates, but I still have a question, what does happen with `char *pointer = (char*)malloc(sizeof(char) * 1024);`? (1024 just for example) , I think it should be the same than `char array[1024]`, but I'm not sure, isn't it? In which cases should each one be used? And, Can I use the `[]` operator if I declare it as a pointer? I mean, Can I use `pointer[i]` to access its data?
To be clear: that information is available at compile time, in limited areas. It is not available at run time (I think this is the point /u/bopub2ul8uFoechohM is making when saying an array isn't a value) 
Nope. The first creates a pointer to a string, but this time instead of the string being part of your program (and unmodifiable) it's allocated in the heap and you can modify it. Also, it will continue to take up space in the heap until you `free` it. The second allocates an array of chars on the stack (or, as someone pointed out, if this declaration is at file scope it will be in your global space). In this case the string is garbage until you initialize it. Specifically, the fact that you haven't ensured it contains in a terminating `Nul` means it's not a valid string yet. Find some books/websites with some nice diagrams illustrating how variables are stored in memory along with variable that point to memory. Maybe google for "heap vs stack", "activation records", and "C string literals". These concepts are important for really understanding pointers and how memory is used - which is necessary to be a competent C programmer. In many other popular languages, e.g. Javascript, you can get pretty far without knowing this stuff. That's good when you're starting out because it lets you concentrate on the basics of programming. But, in C you're going to have to master this stuff. It takes a while, you'll have to keep refining your mental model over time till it gets closer to what's actually going on. And, given how modern systems have memory caches, multiple processor's, etc - what's actually going on is quite complicated nowadays... Anyway, keep asking q's. 
You are passing a pointer to the tree and modifying its contents - there is only one tree. Look up shallow copy vs deep copy. Also, that second argument being passed in is unused and may be adding to your confusion. 
libcurl to download the file, [mpg123](https://www.mpg123.de/) to decode the files and [portaudio](http://www.portaudio.com/) handle sending the audio to the right place.
It is the forth edition and current version of the ISO C standard, and has just replaced the third edition known as C11. There are no new features (these will go into the next edition, C2x), just fixes and clarifications. What was changed can be seen in [this list](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm) (i.e. everything marked with "C17") [This is most recent freely accessible draft of the standard](http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf), not sure how much it differs from the published standard.
This could get pretty bad if you want to be able to pass an array that's inside a struct or union. Also there are alignment issues. The fat pointer approach also has the benefit that you can slice arrays.
Not necessarily answering the question, but the first time I saw X macros I thought it was the most brilliant thing in the world
Clever but not beautiful: Duff's Device.
https://en.m.wikipedia.org/wiki/Duff%27s_device is pretty cool
Non-Mobile link: https://en.wikipedia.org/wiki/Duff%27s_device *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^202970
**Duff's device** In the C programming language, Duff's device is a way of manually implementing loop unrolling by interleaving two syntactic constructs of C: the do-while loop and a switch statement. Its discovery is credited to Tom Duff in November 1983, when Duff was working for Lucasfilm and used it to speed up a real-time animation program. Loop unrolling attempts to reduce the overhead of conditional branching needed to check whether a loop is done, by executing a batch of loop bodies per iteration. To handle cases where the number of iterations is not divisible by the unrolled-loop increments, a common technique among assembly language programmers is to jump directly into the middle of the unrolled loop body to handle the remainder. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
ELI5?
Fast inverse square root, always found this impressive. https://en.m.wikipedia.org/wiki/Fast_inverse_square_root
Non-Mobile link: https://en.wikipedia.org/wiki/Fast_inverse_square_root *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^202976
**Fast inverse square root** Fast inverse square root, sometimes referred to as Fast InvSqrt() or by the hexadecimal constant 0x5F3759DF, is an algorithm that estimates 1/√x, the reciprocal (or multiplicative inverse) of the square root of a 32-bit floating-point number x in IEEE 754 floating-point format. This operation is used in digital signal processing to normalize a vector, i.e., scale it to length 1. For example, computer graphics programs use inverse square roots to compute angles of incidence and reflection for lighting and shading. The algorithm is best known for its implementation in 1999 in the source code of Quake III Arena, a first-person shooter video game that made heavy use of 3D graphics. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
That’s the kind of thing people come up with by slipping and hitting their head on the bathroom sink. 
[IOCCC](https://en.m.wikipedia.org/wiki/International_Obfuscated_C_Code_Contest) obfuscated c code contest has a lot of excellent beautiful codes. for example there is a lattice fluid simulation code where the code itself is the simulation. 
Hahaha, nice reference
GREAT SCOTT!
I don't think so. Indeed, the author recommends the same alternative in the compatibility macros near the end of the article. What would be nice though is the conceptual clarity that you get from not having all arrays decay into pointers and tripping up people. In other words, preserving the types makes reasoning about the code easier. 
 int is_prime(int32_t s) { int32_t res = !(s &lt;= 2 || (s &amp; 0x1) != 1); int32_t top = (int32_t) round(sqrt((float) s)); for(int32_t i = 3; res &amp;&amp; i &lt;= top; i += ((res = !(s % i == 0)), 2)) ; return (res || s == 2); } Admittedly blowing my own trumpet slightly, but I wrote this primality test by trial division because I wanted to exercise the comma operator. This code does not live in any maintained software. 
Sorry, I think I implied incorrectly that the stretchy buffer and sds approach is based on proper arrays. Which then led you to make the confusion that they can handle regular C arrays. That's not the case. The values these libraries return are pointers to heap memory that (at least in the case of stretchy buffer) can be used as arrays, but they aren't stored as such. So they can't handle regular arrays from elswhere in the code.
For an actual piece of software the redis software is very reable and high quality.
It is *possible*, but I wouldn't recommend it. Python, batch, or powershell would be much better choices.
I used something like it to implement "generator-like" complex iterators. A `switch`/`goto` at the top of a function, some of the branches of which landed inside `for` loops. (No loop unrolling, though.) I thought it made the code cleaner, but my co-workers disagreed and I rewrote it. A little disappointed I wasn't able to smuggle a `goto` into that codebase...
[Dirty thief!](https://www.reddit.com/r/ProgrammerHumor/comments/5hms76/law_meets_programming/)
I'm always pretty charmed by pointer-advancing `while` loops with no body, but they are fairly common in some codebase. Simple and elegant.
Thank you for the response, it's good to know it hasn't become deprecated! 
Good to know, thank you!
Thank you for the advice, I'll consider this option!
The Descent to C looks like a good resource for someone in my position (having past programming experience, etc.), thank you for linking it! Might you know of any resources to understand GDB? I understand that that's a rather important concept when programming with C.
Duly noted, I'll check out those books for sure! I only have a few weeks of total free time to learn it, so hopefully that'll be sufficient!
Speaking of arrays decaying into pointers, does anyone know why this behaviour was designed in the first place? Is it an artifact of optimising the language for an architecture or something else?
Apologies for the ignorance, but is it the case that most "tutorials" on C are in fact not worthwhile to do?
No, that was clear, but I thought you were suggesting language support like this for all arrays. But I guess you meant general support and not this specific implementation...
Well, yes, because sizeof is resolved at compile time, and the concept of arrays only exist at compile time. A pointer is just an address value, it doesn't have any information about what it's pointing to. Consider the function int foo(char* x) { return sizeof *x } Let's assume that this is supposed to get the size of whatever x is pointing at. How exactly it is supposed to do that at runtime? What if x is the null pointer? What if I did some pointer arithmetic on x? What if x is a malloc'ed pointer? It's fundamentally impossible to "pass" the compile time information about an array to a function call at runtime. You would have to convert it to runtime information, say, a struct containing both the pointer and the size, in which case you are no longer passing an "array", you are passing a pointer and an int.
It's clever but not beautiful, as is exploits undefined behavior.
I think that [KissFFT](https://sourceforge.net/p/kissfft/code/ci/default/tree/kiss_fft.c) is a very good example of beautiful C code. It's easy to read and reasonably fast. It's not really clever unless you count the FFT algorithm itself, which in my opinion is one of the most important and underrated discoveries in CS.
Here's an equally fast, more accurate version that uses different constants: http://rrrola.wz.cz/inv_sqrt.html An interesting paper that explains in detail how it all works: https://cs.uwaterloo.ca/~m32rober/rsqrt.pdf
A clever / obfuscated way to branchless convert an int into a boolean string for printing with -O1 or higher: #define bool_to_str(x) (&amp;"false\0true"[6*!!(x)]) Or a more readable version that optimizes to almost the same assembly: #define bool_to_str(x) (!!(x) ? "true" : "false")
I always thought that using sizeof() as a value in a case statement was pretty clever. That is, switching on the return code of read() and handling errors and the expected number of bytes when reading a struct. 
Yes, I meant general support. This was only an example of what people are doing to work around this specific issue. 
Not off the top of my head, I'll have a look tomorrow and see if I can find something appropriate.
Example? Edit: Oh, wait. I think I get it. switch(read(...)) { case sizeof(struct mystruct): // enough bytes were read default: // something went wrong } Something like that?
Ever seen this beauty: switch (n) { do { case 1: // do some things if (some condition) goto go_on; case 2: // do some things if (some condition) goto go_on; case 3: // do some things if (some condition) goto go_on; } while (1); do { case 4: // do some things if (some condition) goto go_on; case 5: // do some things if (some condition) goto go_on; } while (1); } go_on: This is also related to the Duffs device. Some people think it's scary others consider it clever.
Yep! For some reason I never thought to use sizeof there. 
Suppose you need to make a copy of an array. You could simply use a *for* loop or a *do while* loop to iterate over the original array and copy each element individually into the new array. Depending on your compiler and target architecture, this may get well-optimized, or it may not. In cases where it's poorly optimized, Duff's device is a way to manually speed things up. Instead of making the CPU alternate between adding an element and then checking to see if it should add another, you make it add eight elements (or some other number of elements) and then check to see if it should add more. If checking and adding an element both take the same time, then you've just reduced your runtime to 56.25% of the original. The tricky part is when your array isn't evenly divisible by that number. In that case, you can copy a few elements at the start or end separately from the rest of the list to leave yourself with an evenly-divisible number of elements. This can also be applied to other operations on lists, and is most useful in the case of simple operations where the time to do the check is large compared to the time to do the operation on each element. Again though, depending on compiler optimizations and target architecture (e.g. branch prediction), this method is now not always faster, so you should do benchmarking to see if it's helping or slowing things down.
Rob Pike's example regular expression matching implementation is touted as beautiful: http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
Can you give a brief explanation of it?
It's not UB if you use an union.
My motives here were efficiency first. So we can discard values where they are under 2 or if they are even. Where we set res, we check if it is even with a little bit test. Then we take the not of this result. If we want our code to enter the loop these conditions must be false. If res is 0, it will not enter the loop and go straight to the last line whereby it will evaluate our edge case (s ==2), the only even prime. We take the square root of the number to set an upper limit for our search space. This is well documented in mathematics so I shan't explain that. Entering the loop we test if our number is divisible by our test number with a modulo operation. If it is divisible, res will be set to 0 and next time will not it enters the loop, the expression evaluates to false and will edit the function. We also add two to our counter because we need not test even numbers. I think part of the mystique is in the comma operator, the comma operator is used in assignment and you probably use the rules it depend on implicitly. You can assign a value to this tuple (x, y). Where the first expression, x, is 'calculated' and the second expression, y, is evaluated as the result to assign. res = (1245, 2); In this case two will be assigned. 
C does not speciy the floating point format. Could be ieee 754, could be something else entirely.
If you just Googled, you'll find a million. Why post here? 
Related question: When would you say that using `-Werror -Wall` is appropriate vs just `-Werror`?
Great explanation! I think it is worth noting that modern compilers for common architectures are more likely to get confused by Duff's device, whereas they probably would have ended up generating even more performant code if you'd just written a normal loop.
Yes, I do.
Interesting snippet! :-) I wonder, couldn't you have written the last part of the for-statement as `i += 2, (res = !(s % i == 0))` instead? As for efficiency: - It is possible to check if the current number both is divisible by two or three, and then incrementing by six. This might be faster, since it is possible to take larger steps. - Why not early-return in the case of a too-low value or the base case `2`? - No need to check against the value of the square root itself. If `i` would be equal to `sqrt(s)` then `i*i` would exactly be `s`, and we know for sure that `s` is thus divisible by `i`. - Are you sure that using a rounded square floating-point root is faster in practice than checking if `i * i &lt; s`? Might be worth benchmarking. 
Interestinly I already had the same idea of sds, about that metadata before the pointer. There is some reason for this not beying a good idea in any kind of array implementation? eg. like vector&lt;int&gt; with only a ptr as member and all other relevant data as metadata. Looks like a win-win for me, but I may be missing something here.
I think you are mixing values with storage representations. Since C99 type punning is allowed. It's only unspecified value (not undefined behavior) if the union members are of different size.
I cannot get mine to run
Maybe you should fix it. I don't mean to be a jerk, but this is a subtle hint that you should get better at asking questions. Make the shortest possible example of the problem you're having and post it. Post any compiler errors you're getting, post the output you get from running the program. With what you're posted so far, there's absolutely no way anyone could answer your question.
Well not only compilers, but adding additional branches isn't good for branch prediction.
The witchcraft number. This is the real reason people were worried about these games; obviously had to make a deal with the devil to write an optimization like this. 
According to [Lomont](http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf) this algorithm specifically requires IEEE 754. You can make if work with different floating point implementations but you would have to change the constants. So strictly speaking it's not portable code. edit: But yes, it's not UB.
Why is this better than an if?
 #define ICE_P(x) (sizeof(int) == sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1))) This macro detects if an expression is an Integral Constant Expression (ICE). Linus explains how it works here: https://lkml.org/lkml/2018/3/20/845 &gt;Ok, so I can see that `(void *)((x)*0l))` turns into `NULL` when x is an ICE. Fine. So with a constant, we have &gt; sizeof( 1 ? NULL : (int *) 1) &gt;and the rule is that if one of the sides of a ternary operation with pointers is `NULL`, the end result is the other type `(int *)`. &gt;So yes, the above returns `sizeof(int)`. &gt;And if it is *not* an ICE that first pointer is still of type `(void*)`, but it is not `NULL`. &gt;And yes, the type conversion rules for a ternary op with two non-NULL pointers is different, and it now returns `void *`. &gt;So now the end result is `(sizeof(*(void *)(x))`, which on gcc is generally *different* from `int`. 
I can't say if this is still the case, but, historically the switch was faster because it could generate a jump table and do just one comparison with a known primitive type. Keep in mind that you'd typically check for sizeof, 0, and -1 return codes. This is really up to the compiler, though. I've seen them both generate jump tables and do a binary searches, depending on the situation. 
I have just given it a test and it doesn't work and I think the reason behind this is that you increment two before testing it. I then went and changed i = 1 and then get an out by one error... Will have to think about that. * That is actually a very good point, I'll have to give that a go. * There is in effect an early return statement. I thought that if I were to use a return variable then it makes sense for there to only be one point of exit. Also the early return still has to evaluate whether or not the condition is true or not and so testing it in the for loop doesn't actually add very much overhead. * I always thought that the square-root thing was a bit of a non-issue now since most processors have look up tables for floating point calculations *however* I did go and test it and you are absolutely correct it seems. Counting primes up to 1 Million, I get these results; sitsshprd03 test &gt; time ./sqrt 78498 0.172u 0.000s 0:00.17 100.0% 0+0k 0+0io 0pf+0w sitsshprd03 test &gt; time ./no_sqrt 78498 0.144u 0.004s 0:00.14 100.0% 0+0k 0+0io 0pf+0w However... I did happen to test that again will `-O2` and the sqrt one was faster?? Go figure. [Code for test...](https://gist.github.com/guynan/ce4b6f553728fdab7e3633cea14cdbfa) 
What have you tried? This is such a broad question with such little information, especially without knowing how much C you understand. Probably wouldn't be my first choice for a language to do this with.
+1 on the comment made by /u/gaxio. You need to add some specificity (and do a Google search). I did this for you and here are some results... https://codereview.stackexchange.com/questions/143834/dice-roll-program-in-c https://www.sanfoundry.com/c-program-emulate-n-dice-roller/ https://github.com/NitikaAgarwal/AlgorithmsLibrary/blob/master/Miscellaneous/Dice%20Rolling%20program%20using%20Array.c Try to look at this code and compile it. It’s fine to post an error here but “a compiler error” tells us absolutely *nothing* about what’s going on. Again, key word here is specificity. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [NitikaAgarwal/AlgorithmsLibrary/.../**Dice%20Rolling%20program%20using%20Array.c** (master → 7f7ab93)](https://github.com/NitikaAgarwal/AlgorithmsLibrary/blob/7f7ab932f2a9750081d650e9088031b8a85d82ef/Miscellaneous/Dice%20Rolling%20program%20using%20Array.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2v5i9t.)
The arrays don't have that information, since they don't store it anywhere during runtime.
Sounds like homework
You could just iterate over each column in each row checking for the existence of a 1 and increment a counter on truth. At the end if the counter is even/odd you add the parity bit. You do this for each row until you are done with the array. This is extremely easy and should take no longer than 20 minutes to write.
I'm sure that's fine when they're supplying their own malloc implementation and shit, but really they should just be using a struct.
Belongs on r/ATBGE for sure
You could simply do this ... i * i &lt;= s; ... As a simple multiplication is computationally way faster than a square root.
You could simply do this ... i * i &lt;= s; ... As a simple multiplication is computationally way faster than a square root.
We benchmark this in a later thread. That's not always the case
On a related note, for those who want to actually grasp the math and intuition behind the FFT I can recommend [this visual explanation](https://jackschaedler.github.io/circles-sines-signals/) that I found on [explorabl.es](https://explorabl.es).
Never wait til last day for your hw lol.
Yeah you right
I love the codebase behind the Lua VM. So clean and simple and well written, yet it gives us a very powerful language and VM ...
Sure, I freelance. 5k is my minimum fee and seeing as we don’t have time to put together a contract, I need that in advance.
Thanks man
also totally depends on use case as well. If for instance you didn't read enough and need to read a little more, the switch statement with sizeof is gonna be messy
It's beautiful in a terrifying way. I don't honestly know what I would use it for
Why the "!!" ? 
Compilers nowadays use conditional execution instead of branches for simple code.
To transform "not zero" into 1. The one in the array index is the only one needed.
Ok thank you so much for your advice!
Yeah I do know that now, I have made another one in C++
In the first example it turns a truthy value into 0 or 1, e.g. `!!42 == 1` but `!!0 == 0`. The multiplication then produces the desired offset of 0 or 6. It could also be expressed as #define bool_to_str(x) ("true\0false" + 5*!(x)) with only one *not*. The pointer arithmetic is equivalent to the address of dereferenced element above. In the second example it is not necessary.
I said "usually accurate" when I meant to say "reasonably accurate". Don't trust the details of finer things on random tutorials: that's what the docs are for, but for getting a basic understanding of the language, using the doc is a bad idea.
You seem to be confused about pointers. Let's take the simple example of `scanf("%d", &amp;i)`, it is a function, it doesn't return the value it scanned, yet somehow, the value of i changes. That is because you're not passing a copy of i, you're passing a pointer to i, when you dereference that pointer, you access the original variable, even if you're inside a function. In your case, you're passing a pointer to the root, so when you're doing root-&gt;data you're accessing the original root's data. For some reason you're also passing an int called 'data' that you never use. You don't even call the function correctly from inside itself, looks like you're ignoring a bunch or warnings or your code doesn't even compile at all. The proper way to do what you want to do is simply to replace root-&gt;data++; printf("%d ",root-&gt;data); with printf("%d ",root-&gt;data + 1); And remove the 'int data' from your function declaration. Alternatively, you could always pass a copy of the node's data manually like your prototype suggests, ie: void PrintPreorderAddOne(Node* root, int data){ if(root==NULL) return; data++; // this is not the root's data, it's the copy that was passed printf("%d ", data); PrintPreorderAddOne(root-&gt;left, root-&gt;left-&gt;data); PrintPreorderAddOne(root-&gt;right, root-&gt;right-&gt;data); } but this is worse because you can already access the data from the left or right pointer you're passing, and because in trying to pass that data, you dereference these pointers, so you'd have to add a null check for each.
`while(*(++str) != '\0');` to point to the end of a string. Or replace `\0` by any char to point the the next instance of that char.
For understanding how the Fourier transform works in the first place as well as why and how it's useful, I suggest [this video](https://www.youtube.com/watch?v=spUNpyF58BY) by 3Blue1Brown, it doesn't go into the CS side of things however.
#### [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) ##### 1,219,683 views &amp;nbsp;👍50,645 👎352 *** Description: An animated introduction to the Fourier Transform, winding graphs around circles.Supported by viewers: https://www.patreon.com/3blue1brownSpecial than... *3Blue1Brown, Published on Jan 26, 2018* *** ^(Beep Boop. I'm a bot! This content was auto-generated to provide Youtube details. Respond 'delete' to delete this.) ^(|) [^(Opt Out)](http://np.reddit.com/r/YTubeInfoBot/wiki/index) ^(|) [^(More Info)](http://np.reddit.com/r/YTubeInfoBot/)
The best part of that snippet is &gt; That's not "an idea". &gt;That is either genius, or a seriously diseased mind. &gt;I can't quite tell which. 
What data am I even looking at?
Some of them are good. Some of them are written by people who mean well but don't know the subject well enough. A lot of them are pure content mill fodder. And frankly, even the good stuff can be pretty bad. For instance, The C Book, which is listed in the sidebar, is reasonably well written and does not contain any serious errors that I know of, but it does not follow a logical progression and is therefore (IMO) useless for beginners. Modern C (recent addition?) looks pretty good except for its *nearly* consistent use of `type* var` instead of `type *var`.
The IOCCC is great. For a while now I've been meaning to take part, so now I will finally do it when the next one starts up.
I would guess it was added as syntactic sugar. In general, you don't *want* to pass whole arrays by value, so the implicit decay was added as a convenient shortcut so you don't have to type `&amp;my_array[0]` all the time. It's ironic that so many people complain the C is inconvenient to use and want to add syntactic sugar to it, while at the same time a feature that causes so much confusion is in fact just that.
I would love to see example code of the version with both the `sizeof(...)` check and checking for return codes. 
Sure, but why do you need a specific 1 in the second macro? 
Wow! Really great introduction! If someone has an explanation of how to go from the mathematical 'general' Fourier Transform to the Discrete Fourier Transform to the Fast Fourier Transform, I'd be really happy :-).
I guess it is one of the ways one could write a state-machine in C.
Aand in C20 it's as portable as C is since then ieee754 will be mandated.
I find it sad that an easy "fix" (imho) is not applied although the foundations are already there. C allows you to specify the size of the array when passing it, so you can say: void foo(size_t sz, int arr[sz]) {} But besides being nice to read for the programmer, this serves pretty much no purpose (afaik) although it could help quite some cases if it were disallowed in that case to right on arr[i] with i &gt;= sz. But it's problematic to implement since arr is still not of array-type but simply pointer type which doesn't allow for carrying size info. So either one would need to add the possibility of "pointer with attached 'range'" or make arr an array-type. The latter however is really problematic since then you remove functionality that worked before, because before you could write within the body of such a function: int *p = /* stuff */; arr = p which isn't possible when arr is an array type (which makes sense, because array-type translates to a label in assembly and pointer-type to a variable holding the value of the label). So if we'd make arr an array-type, this code wouldn't be longer legal. If we'd let it be a pointer type the problem of before would still arise and one could just assign arr a new value but the size info would need to be updated accordingly or arr would change its type from "pointer with size attached" to a simple "pointer". Alternatively one would only allow assignments between those size-attached pointers and those who aren't but right now there's no syntactical way to determine this on the type directly but the context of the code changes its type which is problematic. OTOH it would allow the programmer to *explicitly* code in "fat pointers" (but not really fat, they're just passing two separate arguments) when needed. Also it would be a compile-time evaluatable contract. To make it better, one could also add the possibility of the making requirement "size needs to be declared before the usage of it" more lax, s.t. existing standard library functions could also profit from that. Anyway, the result would be that this way of writing main() would be really advantageous: int main(int argc, char argv[argc+1]) {} C with compile-time bounds-checking when needed. Quite nice, but difficult to implement standard-wise, I guess.
No fucking hell, you couldn't really use stuff than that and ISO8859 is so much easier on resources and definitely has its right to exist and is still widely used. And, well, extended ASCII does clash with UTF-8. Additionally, Unicode changes all the time, the length of UTF-8 has changed also. Bad for a standard like this. Also then, one should remove all the mbtowc functions again, since Unicode renders them unusable basically, which sucks. You'd be forced to use libicu or similar to write anything that doesn't use ASCII...
Hm, I preferred the way they wrote the code in the troff version (I suppose) of the standard til C11, just with thick slab-serifs and no grey box, it just seemed more elegant. Otherwise a clean transformation to LaTeX.
You don't need the `!!` in the second example.
I'll try to dig up the source where I first found it today. 
Mike Pall's luajit is a work of art as well. 
Linux's container_of macro is another great one. 
They could deprecate the whole wide character interface as it turned out to be a hot mess. But deprecating anything but Unicode? Not a good idea. People still use quite a few other encodings (for example, Japanese people like Shift-JIS) for very good reasons. Removing the ability to express them would do people a huge disservice.
Couldn't agree more! Absolutely delightful code to spend an afternoon grok'ing.
Interesting! I've also taken a crack at it. Upon closer inspection, I have the suspicion that `i*i &lt;= n` might actually overflow for certain values of `{i, n}`. But instead of using `i*i`, which has the additional drawback that it has to be computed every loop iteration, we can also simply calculate the integer square root. Checking all primes from one up to ten million seems to be slightly faster (at least on my computer) with `-O3` than your original code: [Link to Gist](https://gist.github.com/Qqwy/e4f9d16f96d2595f3b06ab91f8d2a588).
That's actually the perfect solution! I'm somewhat ashamed that I didn't think about an integer square root. I mindlessly just thought look up tables cpu floating point something something comparably fast. I thought that surely something being computed n**0.5 times would be slower than 1. I guess benchmarks never lie! Except for when they do. I have no doubt that the performance of the computer running it was pretty weak... Did it on the University Linux server which is considerably slower than my home computer. Pretty outdated gcc version as well—I should see if that changes anything as well. 
Sounds good, much appreciated! :)
So in your opinion, would Modern C be the best bet for learning C, even if it's just for this class (as in, I don't plan on going into an exhaustive learning of it)?
Discrete Fourier transform is just applying the Fourier transform on a discrete function, so integrals become sums. FFTs are a set of algorithms to calculate the DFT quickly, by factorizing the DFT matrix that emerges from the definition, which reduces the number of operation from O(n^2) to O(n*log(n)), there are many such algorithms however.
An array of pointers to functions is an elegant solution to all sorts of problems. https://stackoverflow.com/questions/252748/how-can-i-use-an-array-of-function-pointers
That is not very difficult to do. Post the code.
I don't know it well enough to recommend it. Also, it depends on your level (do you know any C at all?) and what you want to learn (just C? systems programming? operating system internals? a specific API?)
What by the way is also interesting, is to see what assembly is actually generated when we compile this: [link to the godbolt Compiler Explorer](https://godbolt.org/g/gZCHPT). As you can see, the multiplication-based one is only ~100 lines, your version is ~150, and the version with the integer square root is ~250. There is an alternative way of writing the integer square root function that uses loops rather than recursion; maybe the compiler can optimize that one even more.
A newline does not empty the stack. What makes you say that? Look at the `'\n'` case in `main()`.
&gt; since after every newline is entered, the stack is emptied anyway (provided the inputted expression was valid), I think this is where the confusion starts. The stack isn't emptied on a newline, only the last item in the stack is popped and printed. There could be other items still on the stack. For example, try the following: 1 2 3 * \n 6 + \n This pushes three numbers onto the stack, multiplies the last two, and prints the result of this operation (popping it from the stack). At the end of the first line, 6 is printed, and 1 is still on the stack. The second line puts the 6 back on and adds them to get 7 (which is printed, leaving nothing left on the stack). The next thing you might need to understand is that RPN calculators are very interactive. Much more interactive than other calculators you've probably used, where you enter an expression, hit equals, and let it calculate the result. With RPN it's an interactive process, viewing and using intermediate results as they come up. The commands the exercise is asking for are very commonly used, actually. As you can see, since `'\n'` doesn't clear the stack, it's immediately obvious that we need a command to do that. Swapping elements is common because the user might calculate one thing and leave it on the stack, then calculate something else, and then want to use the previous result. A swap command makes this trivial. Duplicating the top of the stack is very common as well. It lets you reuse a result multiple times, without duplicating the work leading up to it. I'm sure you can imagine plenty of uses for that. The "print without popping" feature is a bit odd, to be honest. Mostly because it's backwards -- with a normal calculator, that would be the default, and what you should have is a pop command to discard the top of the stack (often called "drop" on an RPN calculator, actually). See in my example above how I had to put the 6 back on the stack manually? That would be very frustrating in practice...
Ah, ok. I've never actually used a RPN calculator before, so I was only thinking of expressions of the type a b R c R d R e R ... where R is an operator.
I feel like you should have learned about either you should have learned about floating point representation before this, or the instructions to your assignment should have been clear: don't use "float". Hint: you can have parts of a penny. Just calculate everything in cents. That's how virtually anything dealing with currency should be coded.
Hey, you're right!
CLion look like that, but i might be wrong
Pthread is what the OS offers to program developers. It is not a feature of the langauge, and it is not available when making Linux, because Linux is the OS that provides it.
Calculate everything in the lowest denomination of the currency
Besides ahminus' point, your while conditions, though they work, are a little unusual. It would be more obvious that you are checking if there is more than 0 left after removing the amount (e.g. while (amount - 0.25 &gt;= 0.0)
Yeah I know, I have 5 kyu in Python and thats where the project exercises begin and it quickly gets exhausting and frustrating, I was thinking more about doing the 8/7/6 kyu which are mostly some textbook exercises. I know only 3 sites with programming exercises Codewars/Hackerrank/Codingame However hackerrank is even more newbie unfriendly, and if codewars are more "projects than exercises" than codingame is I dont know what. So I guess I will have to stick with codewars.
!RemindMe tomorrow.
I will be messaging you on [**2018-07-24 09:00:00 UTC**](http://www.wolframalpha.com/input/?i=2018-07-24 09:00:00 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/C_Programming/comments/91870e/object_base_programming_in_c/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/C_Programming/comments/91870e/object_base_programming_in_c/]%0A%0ARemindMe! tomorrow.) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
It can be useful, sometimes in smaller doses. This is asked every once in a while here. Gtk -- one of the major Graphical toolkits on Linux -- uses GObject, an object system in C. The Linux kernel uses an object-oriented design pattern in some cases. See [this LWN](https://lwn.net/Articles/444910/) article, and [Part 2](https://lwn.net/Articles/446317/). I'm sure there are other areas in which it could be useful. Some say that the GObject paradigm is overkill. 
Use those books more like a reference, along with man pages, when solving a problem.
meanwhile some stuff just never goes away : 6.4.6 Punctuators yep .. always a joy seeing cruft from 1981 that uses old DEV vt100 terminal style characters and trying to figure out what? #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(int argc, char *argv&lt;::&gt;) &lt;% uint8_t jar; char *arv&lt;:10:&gt;; if(argc&gt;1)&lt;%for(jar=0;((jar&lt;argc)&amp;&amp;(jar&lt;10));jar++)&lt;% arv&lt;:jar:&gt;=malloc(strlen(argv&lt;:jar:&gt;)+2);strcpy(arv&lt;:jar:&gt;,argv&lt;:jar:&gt;);strcat(arv&lt;:jar:&gt;," "); fprintf(stdout,arv&lt;:jar:&gt;);%&gt;%&gt;else&lt;%fprintf(stderr,"what?\n");return EXIT_FAILURE;%&gt; printf("\n");/*free arv&lt;:?:&gt;*/return EXIT_SUCCESS;%&gt; or just embedded cruft still left hanging around. 
GObject does a lot of things that most C OO frameworks would never bother to do, and it pays off with ridiculously tight language bindings. I can take a GObject class written in C, subclass it in Python, instantiate it, and pass it back into C code that uses it like any other GObject. That said, if I never had to write another GObject class by hand in my life, I would be pretty happy. You can get very far with OO in C without going GObject-level crazy.
printf("%d.%02d", x / 100, x % 100")
just add 0.009 to amount before doing anything with it and it will work lol. next /s as others have said before, using float is a mistake here. what you're entering as nice decimal fractions will most probably end up as a recurring binary fraction and will have to get cut off to fit in the 23-bit mantissa, rounding down. and so the number you're working with is ~0.3599998 instead of 0.36. congratulations, you just fell into the trap that was set by whoever made this exercise. this is also why the awful piece of advice at the beginning actually kinda works (though it will still break if you go beyond 3-digit numbers). the solution is of course to do things the proper way and work on cents using integers. also, replacing "amount/0.1 &gt;= 1.000" with "amount &gt;= 0.1" would really help readability.
That's a wonderful way of expressing what I've read about GObject (I've not done GObject directly, myself). 
The only people who used these were people programming on weird IBM mainframes. DEC terminals speak ASCII, not sure what you want to get at.
As a general rule, you don't want to ever use floats/doubles for any of this and when you do, you should be painfully aware that there might be a rounding error or even multiple binary representations of same number. 
Thanks. I think I was cocky and didn't think I needed to read the directions fully. Lesson learned . 
Ha good point!
Yeah I'm sure the directions mentioned this. I went a little ahead. Bad idea, saved 10 minutes of time but costed me a couple hours. Thanks
Ahh I get it, thank you.
As well as getting away from floats, you should also look at your code a little bit more. None of those loops are necessary, all you're doing is implementing division the hard way. while(amount/0.25 &gt;= 1.000) { amount -= 0.25; coins++; } You already have the number of quarters you need with **amount/0.25**, there's no need to do a loop here. All you need is the standard library function **trunc**, which will keep the integer portion of the float and discard any fractional part after the decimal point. In other words, the number of whole quarters you have. { // Use a block here to limit the scope of quarters int quarters = (int)trunc(amount/0.25f); amount -= quarters * 0.25f; coins += quarters; } Further, you're repeating this code over and over with small variations. Every time you find yourself doing this, you need to consider making a function. Also, it's convention to output a newline at the end of a printf, not at the beginning of the next, things get a bit confusing otherwise. So once you use division and trunc and abstract that into a function, your code is much cleaner. #include &lt;stdio.h&gt; #include &lt;math.h&gt; void count_coins(float coin_value, float* amount, int* coins) { int num_coins = (int)trunc(*amount / coin_value); *coins += num_coins; *amount -= coin_value * num_coins; } int main(void){ float amount = 23.45; int coins = 0; count_coins(0.25f, &amp;amount, &amp;coins); count_coins(0.10f, &amp;amount, &amp;coins); count_coins(0.5f, &amp;amount, &amp;coins); count_coins(0.1f, &amp;amount, &amp;coins); printf("%f\n", amount); printf("%i\n", coins); } Now, this has the same problem your old code had, but let's look at that. If I run this, I get the following output: 0.000001 95 What's left over is a fraction of a cent. Why is this? The #1 thing you have to remember when dealing with floating point numbers (that includes types like double and long double) is that they can't represent all numbers exactly. Skipping some details, they way they work is like binary numbers but instead of adding 2 + 4 + 16 (that is, powers of 2), to represent the fractional part they add 1/2 + 1/4 + 1/16 (that is, reciprocals of powers of 2). If you have a number that can't be represented by a sum of reciprocals of powers of 2 then it can't represent that number accurately. It will get very close to that number, but it won't quite get to that number. So when you're doing calculations you get small errors, and here you get a fraction of a cent left over. As others said, using an integer and just doing everything in cents is a better way to do this, but doing it with floats and having 1/10,000th of a cent left over works mostly OK for this. In actual financial calculations you'd want to remove the ambiguity and not use floating point though.
Happens to everyone. A lesson learned is always good!
I've got a friend who likes to trap new programmers with exactly this sort of problem. Don't feel bad that you didn't know - just make sure you learn your lesson. People likely died because someone didn't understand this, and used a float for a timer value on the Patriot missile system. The longer it was turned on, the less accurate its target lead calculation got. Aside from recognizing that floating point values aren't precise, the other lesson you should take away from this is that many applications don't need floating point at all, even if they're representing something with fractional values. In this example you just change your amounts to be in cents rather than dollars, but you might choose mils (1/10 cent) for interest calculations, or higher precision. If there's not a standard unit that fits, you can make up your own. For example, I have a tone generator that needs to work in fractional Hertz. It takes the frequency in 1/256 Hz units, which means the low 8 bits are the fractional part. Just remember to keep track of what your units are! In this case I'll give the variable a name like 'freq_q8_hz' (see [Q notation](https://en.wikipedia.org/wiki/Q_(number_format\)) so it's obvious. Dealing with fixed point is really common in the embedded systems world because you often don't have an FPU at all.
Such things should be removed entirely from the spec and allowed to be clear errors. That solves the old issue entirely. Also stuff like : #include "//e" That should just be a clear cut syntax error in that is isn't a filepath inside the quotes however maybe it is? It isn't a comment surely? Who knows. It is considered "undefined behavior" and that makes me think that surely something can be done to clear that up. 
Check out this free book by Axel Schreiner on OOP in C http://www.cs.rit.edu/~ats/books/ooc.pdf
Just for fun have a read of this article from the man that is considered the "father" of floating point : https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf That is Professor William Kahan and he really does know what he is talking about. Most of us don't. I sure don't. However I have a handle on some of it. So the lesson to be learned here is that you won't get perfectly precise values from calculations with floating point numbers ALL the time. In fact, you will rarely ever get perfectly precise results. Ever. However if you are okay with an itty bitty teeny little error then you can work with floating point just fine. Don't listen to people telling you that you must use integers. That won't work in the real world doing financial calculations or fluid flow computations. You can also try to use a seriously precise library such as libgmp or libmpfr but that merely compounds the problem in that you need a ton of knowledge to use them. Correctly. Any damn fool can calculate the sine of an angle and then say "ta da!" there it is to twenty digits. Mostly you can't calculate the sine of an angle to twenty digits. Not on this planet or universe anyways unless you use outside math library packages. ( look into infinite Taylor polynomial expansion series and concepts like irrational numbers for fun ) Also look at the man pages for functions like "int isinf(real-floating x)" which asks the question "is this value x an infinity?" and other cool stuff like a value for zero that is negative. Here is a fun and entirely reasonable approach to subtracting some value from a floating point number while looking to hit zero. Don't do that. You should look for a value that is close to zero within some precision or error margin we can call epsilon. That greek letter epsilon gets tossed around a lot in floating point and it looks like this : set some value foo to 1.1 ( one plus one tenth ) set epsilon to a really small positive value close to zero enter a loop subtract one tenth from foo did a floating point exception happen? yes? report that. check to see if the magnitude of foo is greater than epsilon if we are not close to zero by some itty bitty bit epsilon then loop again print out the final value of foo That is worth doing for no other reason than to see floating point exceptions flying : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;math.h&gt; #include &lt;fenv.h&gt; #pragma STDC FENV_ACCESS ON int bin_printf ( uint8_t* f, size_t n ); int main (int argc, char* argv[]) { float foo = 1.100f; /* the suffix letter f means this is a float */ float epsilon = 1.0E-7f; /* this is _about_ 0.000001 */ int fpe; /* this is a flag */ int j; /* clear all possible floating point exceptions */ feclearexcept(FE_ALL_EXCEPT); if (fesetround(FE_TONEAREST)!=0){ fprintf(stderr,"ERROR : can not set floating point rounding!\n"); return EXIT_FAILURE; } printf("starting value of foo = %8.7e\n", foo ); for ( j=0; fabsf(foo)&gt;epsilon; j++ ){ /* do a trivial subtraction */ foo = foo - 0.10f; /* did we just toss an exception? */ fpe = fetestexcept(FE_ALL_EXCEPT); if (fpe!=0){ printf("INFO : Exception raised was"); if(fpe &amp; FE_INEXACT) printf(" FE_INEXACT"); if(fpe &amp; FE_DIVBYZERO) printf(" FE_DIVBYZERO"); if(fpe &amp; FE_UNDERFLOW) printf(" FE_UNDERFLOW"); if(fpe &amp; FE_OVERFLOW) printf(" FE_OVERFLOW"); if(fpe &amp; FE_INVALID) printf(" FE_INVALID"); printf("\n"); } printf("foo = %8.7e\n", foo ); feclearexcept(FE_ALL_EXCEPT); } printf("\nfinal value of foo = %8.7e\n", foo ); bin_printf ( (uint8_t*) &amp;foo, (size_t) sizeof(foo) ); return EXIT_SUCCESS; } compile and link that to libm and run it : $ ./foobarf starting value of foo = 1.1000000e+00 INFO : Exception raised was FE_INEXACT foo = 1.0000000e+00 INFO : Exception raised was FE_INEXACT foo = 8.9999998e-01 INFO : Exception raised was FE_INEXACT foo = 7.9999995e-01 INFO : Exception raised was FE_INEXACT foo = 6.9999993e-01 INFO : Exception raised was FE_INEXACT foo = 5.9999990e-01 INFO : Exception raised was FE_INEXACT foo = 4.9999991e-01 INFO : Exception raised was FE_INEXACT foo = 3.9999992e-01 INFO : Exception raised was FE_INEXACT foo = 2.9999992e-01 INFO : Exception raised was FE_INEXACT foo = 1.9999993e-01 foo = 9.9999927e-02 foo = -7.4505806e-08 final value of foo = -7.4505806e-08 10110011 10100000 00000000 00000000 Okay so that last bit simply dumps out the binary floating point value which is a single precision 32-bit floating point representation for that tiny remainer left over at the end. Note that nearly every single subtraction operation results in a floating point exception being tossed called "FE_INEXACT" which is very true. However when we fell down to around 0.2 the exception went away. Cool huh? 
https://nullprogram.com/blog/2014/10/21/ 
This book taught me how classes work under the hood. The code doesn't work in C11 but someone has made the necessary tweaks and posted them on GitHub (easily googleable, I'm on mobile sorry). Also just in case OP is much newer to programming than we've anticipated, there is a language called C++ which may be of interest.
Can you provide the definition of the structs?
Hi, There isn't really enough code here to say for sure, but have you tried running your program through valgrind to see if it reports any memory errors? You could also try reducing your data set to just a few entries in each table and seeing if you have the same problem. It's just a wild guess, but given that you're initializing `cht-&gt;HT` values to zero, my guess is you've calculated the sizes incorrectly and are somehow writing past the end of that array. The definitions for `column_customer`, and `column_orders` would be very helpful. In fact, if it's a small program posting the entire program is is your best bet.
Thank you for the reply. Definition of the structs added to the post!
Thanks for replying! Well, I don't know how much a debugger would help with those large datasets, and I already shrunk them. It keeps occurring. I'm using the same variable without any modification to allocate and on the loop, I don\`t see how it could gone wrong. But again, I'm completely exhausted right now. Well, it\`s really not a small program, but here is the functions where the problem occurs: inline void generateCHT(column_customer *c_customer, int tamCustomer, CHT * cht) { clock_t init, end; uint32_t ohtOcc=0; uint32_t chtOcc=0; uint32_t ohtOccBMP=0; uint32_t chtOccBMP=0; uint64_t actualPopCounter; uint64_t oldPopCounter; init = clock(); likwid_markerStartRegion("Initialization"); //Allocate CHT cht-&gt;tamHT = 0; //Initialize OHT and bitmap for (int i=0; i&lt;CHT_OHT_SIZE;i++) { cht-&gt;OHT[i]=0; cht-&gt;bitmap[i]=0; } likwid_markerStopRegion("Initialization"); end = clock(); printf("Initialization: %.f ms \n", ((double)(end - init) / (CLOCKS_PER_SEC / 1000))); init = clock(); likwid_markerStartRegion("Generation"); for (int i=0; i&lt;tamCustomer; i++) { switch (chtInsertBitmap(c_customer[i].C_CUSTKEY, tamCustomer, cht)) { case 0: printf("ERROR: Something went wrong while inserting the key %u on the CHT\n", c_customer[i].C_CUSTKEY); break; case 1: chtOccBMP++; break; case 2: ohtOccBMP++; break; } } //count Population actualPopCounter = 0; for (int i=0; i&lt;CHT_BMP_SIZE;i++) { // printf("%d : bitmap %lu oldpopcounter %lu actualPopCounter %lu ", i ,cht-&gt;bitmap[i], oldPopCounter, actualPopCounter); oldPopCounter = popCount(cht-&gt;bitmap[i]&gt;&gt;32); cht-&gt;bitmap[i] = cht-&gt;bitmap[i] | actualPopCounter; actualPopCounter = actualPopCounter + oldPopCounter; } cht-&gt;tamHT = actualPopCounter; cht-&gt;HT = malloc(sizeof(uint32_t)*cht-&gt;tamHT); if (cht-&gt;HT == NULL) printf("deu merda\n"); for (int i=0; i&lt;cht-&gt;tamHT; i++) cht-&gt;HT[i] = 0; for (int i=0; i&lt;tamCustomer; i++) { if (chtInsertConciseTable(c_customer[i].C_CUSTKEY, cht, tamCustomer) == 0) ohtOcc++; else chtOcc++; } likwid_markerStopRegion("Generation"); end = clock(); printf("CHT Generation: %.f ms \n", ((double)(end - init) / (CLOCKS_PER_SEC / 1000))); printf("OHT has %d occupied buckets and %d on the bitmap \n", ohtOcc, ohtOccBMP); printf("CHT has %d occupied buckets and %d on the bitmap \n", chtOcc, chtOccBMP); } I tried printing the c\_orders array before initializing the new array, and its unaltered. Printing after the initialization gives me a nightmare of zeros.
If you want 64bits, why are you also installing i686? Shouldn't it be only: `pacman -S mingw-w64-x86_64-qt mingw-w64-x86_64-qt-creator mingw-w64-x86_64-gdb` 
Can you provide the definition of CHT also?
Thank you for the guide. just one thing, if you want 64bits, why are you also installing i686? Shouldn't it be only: `pacman -S mingw-w64-x86_64-qt mingw-w64-x86_64-qt-creator mingw-w64-x86_64-gdb` 
Thanks to you all! I got an answer on stack overflow that solved the issue. I was in fact walking out of cht-&gt;HT, because the this line: cht-&gt;HT = malloc(sizeof(uint32_t)*cht-&gt;tamHT); Changed from uint32\_t to bucket (which is a type a defined on the header) and everything was fine.
A few months ago, I wrote a poor implementation of OOC when I was making a game. I've used C for a few years and I'm not new to making games but after a several coding sessions I realized I had no idea what I was doing. I suggest newcomers to read the full document and understand the material first. I find this tough very difficult to maintain in your head so be sure to take lots of notes. Or say fuck it and use C++ ... right tool for the right job. 
It was so that B code could be compiled as C without changes. In B an array declaration actually defined a pointer and an array, with the pointer initialized to point to the array's first element. 
&gt; You can't pass an array, because an array isn't a value. It's a compile time label to a block of memory. All variable names could be described as "compile-time label to a block of memory". Arrays certainly do exist at runtime ... they can be created and have values stored in them. You couldn't store a value in something that didn't exist! Furthermore you can pass an array to a function by wrapping it in a struct; which dispels any myth that the arrays "don't exist" or don't have values. 
That's like saying a pumpkin is more than an apple. Arrays and pointers are entirely separate types. An array isn't an augmented pointer. It's a sequence of contiguous elements. There is not also a pointer. (Note - all objects, arrays or not, can have pointers point to them). 
`sizeof` may be resolved at compile-time, e.g.: char x[rand() % 10 + 1]; printf("%d\n", (int) sizeof x); 
A simple way to get some of the benefits of OOP without having to deal with libraries is to use C's file structure to your advantage. Each pair of .c and .h files (you could potentially split stuff into different files if it's too big) represent a class, with the .c file containing the concrete data type (a struct declaration with all the fields) and all the methods, including the constructor and destructor, and the .h file contains the abstract data type (typically just the declaration of the struct without any public fields and a pointer type) and the the class's interface to the outside world. Methods are just functions whose first argument is the instance of the class they were called 'from.' Also, since C doesn't have namespaces, method names from the same class should all have the same (and relatively unique) prefix.
This was actually going to be my guess, that you didn't allocate enough memory for this by getting the type wrong (the size must be right since you use it immediately after in the loop). It's the only thing that really makes sense since it was being overwritten by 0's, not junk data or anything else. I was also going to recommend that you use calloc instead of malloc. Malloc is very old-school, calloc more semantically allocates arrays and return 0-initialized memory.
Yes, C99 and VLA changes things a bit. Keep in mind though that under the covers, this is really just syntactic sugar for something like (depending on the implementation): int _n = rand() % 10 + 1; char* x = alloca(sizeof(char) * _n); printf("%d\n", _n); So sizeof minus the syntactic sugar for VLA support does not resolve at compile time, but you're technically correct (the best kind of correct, I suppose).
C doesn't have templates. I think you meant to post on a C++ sub, like /r/cpp_questions. It will also help a lot if you simplify this down to something I can run through my own compiler, because what you have there is a bit hard to follow at the moment.
Notable points for me from the DR list: * DR423 - rvalues are always unqualified now. `(const int)0` has type `int`. This is consistent with C++ and fixes a problem with using `_Generic` on an rvalue. * DR481 - the controlling expression of `_Generic` undergoes lvalue conversion (dropping qualifiers as per DR423), array-to-pointer conversion, and function-to-pointer conversion, if applicable, and it shall be an error if there is more than one match. * DR451 - indeterminate values (including structure padding bytes) are "wobbly", propagate, and cause UB if passed to library functions. * DR463 - the behaviour of `1 &lt;&lt; 31` (with 32-bit `int`) was NOT changed: it remains undefined behaviour. * DR466 - the scope of `for`-loop control variables was NOT changed (it is still possible to declare a variable inside the loop that shadows the control variable). * DR476 - `int x; *(volatile int *)x = 1;` now counts as a volatile access. * DR491 - the program is allowed to define macro replacement for `_Bool` and any other *keyword* starting with underscore followed by upper case. * DR494 - the operand of `_Alignof` is not evaluated. * DR496 - the intent is that you cannot use `offsetof` on a struct type being defined inside the offsetof call, although the standard wording hasn't been fixed yet because there is an implementation that allows this. * DR497 - the meaning of "white space" in `scanf` family, `strtod` and `strtol` is as defined by `isspace` or `iswspace` now (so the behaviour may change with locale) Also, lol @ the amount of fixes required to Annex K (the Microsoft extensions to stdio.h) . What a clusterf**k that whole saga was/is. 
&gt; You can pass an array to a function by wrapping it in a struct You can wrap a *constant sized* array in a struct. &gt; dispels any myth that the arrays "don't exist" or don't have values. &gt; An object exists, has a constant address, and retains its last-stored value throughout its lifetime. Sorry, I'll try to be more careful in my terminology. The concept of an array object, an object that maintains the information about its own length, does not exist at runtime. There is no runtime array object that keeps its own length. You can pass a struct which embeds a *constant length* array, or you can pass a struct containing a pointer and a size_t. You can't pass an array-with-length because no such object exists at runtime. Constant length array objects do exist at runtime as a well-defined type/object. Variable length arrays do not (insofar as a value that can be copied at runtime without special logic to handle the length, which must be stored separately). This is including VLA support, depending on how you look at it. The way VLA is specified highly suggests that it is implemented using a separate variable to hold the array size, although of course you could implement it as an actual array-with-length object at runtime, just like you could technically implement C on top of Python types. I just thought of a different way of expressing the problem that is hopefully clearer. Arrays with constant length are all different types. The length is part of the type information, not a variable field on an object. Thus, saying that arrays are objects that can somehow be passed to a function without losing the length information is like saying that I could do void foo(number x); int y; foo(y); And somehow be able to know in the call to foo() that the x argument is of type int (rather than of type float, say). That simply doesn't make sense in C.
&gt;just one thing, if you want 64bits, why are you also installing i686? There is no need to install 32-bit version if you only need 64-bit version. I personally do not need 32-bit version, but some people need it and that is why I included it. &gt;Shouldn't it be only: `pacman -S mingw-w64-x86_64-qt mingw-w64-x86_64-qt-creator mingw-w64-x86_64-gdb` I have not tested it but I think it should work fine.
You could say that the entire language is syntactic sugar for a Universal Turing Machine ... I don't think labelling a language construct as "syntactic sugar" is grounds for dismissing its validity or existence. 
I'm asking this because i686 is for 32 bits compiler. I just followed your guide (again, thank you man) and it installed just fine using only w64-x86 packages (which are the actual 64 bits). Disadvantages of your method: it installs *everything*, gets heavier to load and it becomes big in the disk (over 14 GB, before I had only some 5 GIG) and also it complains to install the remaining tools, especially clang which is another +1 GIG. A good thing is that now I have both static and dynamic buildings. Also, you can add the mingw64 to path and use with any other IDE (I use Codeblocks too). ps: just some random tip, if you have problems with the Q*.dll files not being found when you compile dynamic, add their `\bin` directory to PATH, it should look like `C:\msys64\mingw64\bin`. cheers
I quite dislike the OOP style in this book. There is lots of void\* and casting that I think is not necessary or helpful. Using empty structs and typedefs, even just as a type signature, can achieve similar object oriented style while remaining typesafe and letting the compiler help you catch bugs.
&gt;There is no runtime array object that keeps its own length . It is not clear to me what you mean, in the C Standard there is not "runtime" , there is just the translation phase and the execution phase. Arrays have a size during the execution phase just like any other object. An array of 2 ints is exactly the same as a struct of 2 ints with no padding, except for the syntax used to access them. They both have the same size and that size is known during the execution phase. I thought at first you were trying to say that there isn't storage allocated to store the length, but then in your other post about VLAs you contradicted this by saying that you thought they would in fact allocate some storage to store the length. &gt;The length is part of the type information, not a variable field on an object. Nobody has been claiming anything else ... Not sure what you are trying to point out with `void foo(number x)` . You can't write `void foo(struct x)` either (where `x` is the parameter name, not a struct tag) yet you can pass structs to functions. (Without losing information about the size of the struct) 
Use `sizeof(*cht-&gt;HT)` any you will never have this problem with type inconsistency again.
You don't need the `!= '\0'`...
I like your way using only one '!' with an offset of 5, it makes more sense and is shorter. You are right, it's not needed in the second example.
This is trivially optimized away by the compiler and improves readability, it conveys the meaning that we're not checking for 0 or for a null pointer. And as I was saying, you can replace it with a different char to look for the next instance of said char, although you should probably also check for '\0' in that case: while(*(++str) &amp;&amp; *str != c);
Oh, DR476 is useful! 
Agreed. Another thing I dislike about the PDF is the abuse of function pointers. Putting many function pointers in a struct inflates the object sizes and prevents compiler optimizations.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I'm going to give you an entirely different answer because I came from an OOP background, where the language I know best is java. You have three options: 1. Use a database like SQL lite. Store all related objects rows of a table. 2. Get really good with char []. Make your classes encodable to strings. The first 1 or 2 bytes should be the type ID. For each class, you'll need a decoding process. But once you get the hang of this method you basically have a generic type minus preprocessor trickery. This is highly overlooked in the above answers. It's not an oop system if I can't: foreach(object foo, list bar) 3. Make your own table of objects. This one I haven't explored too much but I think you'd be able to introduce new types after compile time. Basically, every object is a struct that points to its self in the table. The table would be divided into two subtables: &gt; Object data &gt; Object methods Obviously objects of the same type would share the same methods. Object data can be written over. Object methods cannot. Say you disregaurd all of that. Just don't put all of an object's methods in its struct. Design your structs this way (I prefer not to typedef): struct obj { unsigned long long hashid; struct obj_fun* methods; } struct obj_fun { &lt;tostring&gt; &lt;equals&gt; &lt;comparto&gt; } Final note: if you like the freedom of C but you also like objects, C++ is not the language you're looking for. Use Rust.
This sub is for c specific content only, hence your post was removed. Best of luck on your survey
I'm always wary of this type of quiz, because in my experience a) the author *always* says they “only take five minutes” but they *always* take significantly longer; b) the questions often reveal the author's ignorance of the subject of the survey, which is frankly insulting (“please take the time to teach me what I can't be bothered to research and learn on my own before sending out the survey”); and c) as a consequence of b), some of the questions assume the premise or (in the case of MCQs) do not offer sufficient alternatives to answer truthfully. In this case, I only got to the bottom of the first page before running into c). Good luck.
I think it was a good idea but a terrible implementation with the side note that it's probably not possible to implement nicely in C and its standard library, so they should've concluded that it should better be scrapped than implemented badly.
Well Atom is created using Electron so if you wanted to make an editor exactly like it your best route would be HTML, CSS, and JS on Electron. However if you want to use C then I would find a graphics library you like and go crazy as you probably won't be needing any web languages. 
Everybody should read [Field Experience with Annex K](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm) to see just how poorly thought out this is. I honestly don't think the idea is salvagable for the reasons lined out within this paper.
I love that trick. Use it everywhere since I first saw someone do it.
What's your experience level? You can basically create anything you want in any language, if you have the patience for it. If you want a fairly simple example of a full-screen editor in C, you might start with [kilo.c](https://github.com/antirez/kilo). It's a console application, but it'll at least give you a peek at what's involved.
Why do you want to do all of this in C?
Yep, that's the exact paper I had in mind -- however I think having bounds checking *in general* is nice, however not in C.
Text editors are hard, no matter what the language. It's possible, yes, but manage your expectations.
yes, everything can be done using C, also an editor like this. but of course you will have to manage by yourself all the things (C always give you a lot of power and also a lot of responsibility)
Indeed it is! But forcing people to specify bounds is no better then letting them do manual bounds checks because they are going to make the same kinds of mistakes. Fat pointers for arrays (like Go's slices) do the trick though.
You are the only one who answered the question.
Yes, you can, but it's not the easiest or most effective way. C isn't ideal for things that involve complex GUI or high level logic. Programming languages are tools, and though you can user a lot of things to drive in nails the best idea is still to use a hammer.
Yes, though it's going to be hard to make it just as slow.
Thank you mate. I got it, but, in which projects are ok to use C and in which projects are not? I mean, I love C! But so far all what I saw have been OS, low level software and something like that. By the way, what do you mean when you say "high level logic"? I don't get it.
Actually I won't do it (although I want, lol). I just wanted to know how can be done a program like that. And if it's possible to mix those technologies (and what do I need to learn in order to do it). 
That was just a question (or even a couple), but I want to learn and improve my C skills as much as possible.
Thanks for the example mate, interesting resource, I'll read it.
Oh bro, it could be fine, I mean, I want to learn how to implement GUIs in C, because the bests GUIs I've seen have been created using some web technologies, instead of the graphic libraries for the language. But as I told you, it could be fine to see good examples and know new libraries. The best graphic library I know until now for C is GTK+.
Are you familiar with Object Oriented Programming? This is a good example of high level logic, where we treat "stuff" in our program like objects (the vague wording here is intentional). On a graphical interface a menu or a button or stuff like this, they are treated like objects. This is what I mean by high level logic, we abstract things in our program and don't deal with them in terms of variables and functions (well, we do too, but this is to illustrate). C isn't objected oriented, and this makes it painful to deal with complex, high level programs. But yeah, C is commonly used to lower level stuff, like embedded systems, OS, softwares where you want to directly manipulate the memory on a byte-level, things like that. If you want to venture to higher level programs you should try learning languages like C++ (syntax similar to C), Java or Python. It's all up to what you want to do.
Yeps, this is definitely a better solution, but needs a deeper surgery language-wise
A good solution might be to introduce parametrised types without introducing template functions or other bullshit at the same time. Haskell has proven that you can do zero cost parametrised types without carrying type information around at runtime by providing a model where all type parameters are resolved at compile time. This way you can build generic structures like slices without having all the code-gen bullshit you get with template functions.
But this would make the C compiler suddenly much more complex, and I'm glad there exists at least one widely-useable language that's so simple.
Check out the IUP framework. Here's an elaborate example of a text editor: http://iup.sourceforge.net/en/tutorial/tutorial3.html
Those add extra overhead. You can no longer just say myarray[index], you have to say get(myarray, index), or ints.values[index].
Sure it can. In fact, the most advanced texteditors on the planet (vim and emacs) are written in c (plus their own scripting language). You don't need to learn html and css, you can instead use a library such as gtk.
Oh, mate, actually, I came from C++ and I know a little of Python and Java, so, I get what you say.
Thanks mate, I didn't know that framework, it seems quite good, I'll look for more material.
Just use ed and sed. Not much else is needed. Maybe vi but not vim. Actual vi is overkill.
Yes, but I have a better question: do you know why it wasn't? You can be honest here.
The process of making it, on the other hand, will be both hard _and_ slow. 
For future readers' sakes: - **never** use floats for money. Rounding errors will mean money will disappear, or might be magically be created out of thin air. Besides this, it allows people to enter ridiculous (if we are talking about money) inputs when using `get_float` or `scanf` or similar (things like `1e2400` or `3.14e-55` are completely valid floats but nonsense when talking about money). - If your language has a BigDecimal type, use that one, because it makes it easy to switch decimal precision, but, in contrast to floats or doubles, _a BigDecimal will always be precise_. - If your language doesn't (like standard C), use a predetermined fixed-point number system; that is, represent your money as e.g. an ints in "cents". It is often smart to keep track of what unit you are representing in in your naming (like `amount_in_cents`) to make sure you do not mix them up. Side note: If you do want to use a full-fledged BigDecimal type in C, there are libraries such as GMP (the GNU Multiple Precision Arithmetic Library) that allow you to work with them, although they come with a learning curve. 
You want to mix technologies? I thought you wanted to write it in C? Atom is mostly a web application running on a stand alone browser. Are you saying you want to create a browser and then write a text editor to run on it? Hope you’ve got plenty of time on your hands.
Another tip: Do you know what the `%` operation does? It might make most of your while-loops superfluous... :-)
Not really, type checking is a rather simple algorithm and I am not advertising for type-generic functions.
Nah, not really much slower than writing a text editor in any other language.
Just pepper a bunch of `sleep(1000);` everywhere. Problem solved.
1st. You probably want /r/cpp or /r/cpp_questions. C is different than C++. 2nd. Read up on: 1. [Arrays](https://en.cppreference.com/w/cpp/language/array) 1. [For loops](https://en.cppreference.com/w/cpp/language/for)
But then it doesn't make my CPU hot. [Children in Africa are going to die!](https://xkcd.com/1172/)
Looks like you posted a wikipedia article, let me summarize it for you... I also respond to comments containing "wikibot what is [topic]?"... Click [here](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) if you'd like me to stop bugging you. ***** **[Shebang (Unix)](https://en.wikipedia.org/wiki/Shebang_(Unix))** &gt;In computing, a shebang is the character sequence consisting of the characters number sign and exclamation mark at the beginning of a script. It is also called sha-bang, hashbang, pound-bang, or hash-pling. ***** **^([)** ^([About](https://www.reddit.com/user/ultimatewikibot/comments/90r969/about/ )) **^(|)** ^([Source code](https://github.com/brrm/ultimatewikibot)) **^(|)** ^(Downvote to remove) **^(])** 
I just went through the DRs on the page linked from the article, and read the Committee Recommendation or whatever it is. It's probably safe to assume that even if something from the list isn't in the C17 text, the committee response does reflect the intent.
The idea is good however the implementation can be improved. 1. Reading the first line of the file could be in a loop with feof() check, break when you find a CR or LF by inserting a trailing NULL. 2. Multiple calls to strcpy() can be replaced with single call to snprintf() 3. Using exec() family avoids having to create another process that happens when you call system() 4. I don't know how calling system() behaves with chaining commands with pipes, using exec() ensures there is a single stdin and stdout - since there is single process and should work 
hello hackworks. thanks for your response. I didnt read until EOF. The loop fgetc() break at the first occurance of CR or LF (for compability to windows/unix/mac). The MAXPATH and exec idea sounds great. I will improve it. thanks! :)
What if the file has only 1 line with no CR or LF? You will not come out of the loop. The following will handle that. while(!feof(fd)) { ... } 
The "char\* a = malloc(100\*sizeof(char));" creates a pointer to an allocated section in memory the size of 100 characters (100\* sizeof(char). The "a==NULL" handles if malloc fails. The "tmp_a = realloc(a, 10000\*sizeof(char));" reallocates the memory that was set aside for a to now be large enough to store 10000 characters.
thanks you so much!!!!!!!!! c:
No problem!
oh my, how could i forgot that LOL! you have very good eyes, hackworks. very appreciated!
That is a terrible idea.
 * `_BUFFER_` and `_HPVERSION_` are reserved names, due to starting with an underscore followed by a capital letter. To avoid clashes I would suggest removing the leading underscore. * If `argc == 0` the code reads out of bounds (`argv[1]`). * The `strcat` loop has a basic buffer overflow. * The `fgetc` loop has a basic buffer overflow, and will be an infinite loop if input fails. As well as the buffer size, you should exit the loop in case of `s[l] == EOF`. [Do not do `while(!feof`](https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong). * `free(f)` causes undefined behaviour, `f` is a closed file handle. * The later `strncpy` / `strcat` series can overflow the buffer. * If the file is not in shebang format, memory is leaked. Although this is not particularly serious given that the code can only run on an operating system that cleans up. It would simplify your code to just use arrays instead of `malloc`. * If the file is not in shebang format then you can exit as soon as you have read the first 2 characters, there's no need to keep going with reading the rest of the line and building the command. When coding in C you must **always** take care not to exceed buffers. Especially if you are publishing code that you intend other people to use, this is just irresponsible from a security perspective. 
wow! for so long i never had so many inputs. thankyou OldWolf2. Very appreciated! Didn't know strcat is an unsafe function in C.
I think it would go in a similar direction as what I described here: https://reddit.com/r/C_Programming/comments/90uq7c/cs_biggest_mistake_by_walter_bright_creator_of/e2vm6rf?context=3 But you talk about a specific new type while I thought about using the existing VLA notation to create a composite "parametrised" types.
Note that `sizeof(char)` is 1 by definition.
If you want all of the configurability of an advanced editor, and especially support for user scripts and extensions, you're better off implementing a minimal core in C, adding a scripting language on top of that, and using the scripting language for everything else.
And you are the only one who only comes here to piss on other people.
Is this a homework problem or something? It seems arbitrarily tedious.
 for (A; B; C) { D; } =&gt; A; while (B) { D; C; }
Just a tip, don't go around calling everybody “mate” or “bro”. Especially the latter. It's vulgar, rude, and to some, even offensive.
something like that
im getting different outcome
In the following code, if (cht-&gt;HT == NULL) printf("deu merda\n"); for (int i=0; i&lt;cht-&gt;tamHT; i++) cht-&gt;HT[i] = 0; if allocation fails, your program will print an error message but will not exit, so the loop invokes undefined behavior. On systems with memory protection, it will most likely terminate, but on others (such as DOS), it might crash the entire machine.
got it thank u very much
&gt; Suppose you need to make a copy of an array. Duff's Device is not an efficient way to copy an array; your compiler's built-in version of `memcpy()` is better than anything you can ever aspire to create on your own. Duff's Device was invented for the specific purpose of writing to or reading from memory-mapped I/O, where one pointer is incremented for every character or integer read or written but the other is constant.
What did you try exactly?
like the example u show
That is true indeed. Lua is supposedly pretty good for that.
ehem... `while(!feof(f))` is [always wrong](https://stackoverflow.com/q/5431941/417501). Don't program like that. Instead, inspect the return value from `fgetc()`. If it is `EOF`, you are either at the end of file or an IO error occured. Right there you can use `feof()` and `ferror()` to distinguish the two conditions.
`strcat` is not an “unsafe functions.” It is a perfectly fine function if used correctly.
This is the type of response you only see on reddit. It has nothing to do with what I said but it makes small people feel big for once in their useless life.
What did you try, *exactly*?
I'm not sure what your question is. There is no such thing as a “string with more characters than a normal string can hold.” Strings can be as long as you want, the only limit is the size of the address space of your system.
&gt; Any ideas on how to resolve this situation ? Sounds like you have an issue in your code. You need to fix that issue. This post has a similar issues, and a few helpful comments: https://stackoverflow.com/questions/9526240/debug-assertion-error-for-c-program Finally, it looks like you're coding in C++, but this is a C programming subreddit. Try /r/cpp_questions
Apologies if you asked these questions rhetorically, but I don't know any C, and only plan on doing so just to learn C in the context of a systems programming college class.
You may have bitten off more than you can chew. I would suggest getting a copy of K&amp;R and trying to teach yourself C before classes begin.
Looks like you're trying to read past the end of the file or something similar. Can't help you without the source code.
@dragon\_wrangler I'm pretty sure I'm using C, its annotated next to the source file called Main (Main.c) @Kwantum These are the functions for options 1 and 2 void HurricaneInformation() { FILE \*fHurricanInformation; fHurricanInformation = fopen("Categories.txt", "r"); char singleLine\[150\]; while (!feof(fHurricanInformation)) { fgets(singleLine, 150, fHurricanInformation); puts(singleLine); } fclose(fHurricanInformation); MainMenu(); return; } void UnCategorizedHurricaneIdentification() { FILE\* fp; char buf\[bufSize\]; if ((fp = fopen("Identification.txt", "r")) == NULL) { perror("fopen source-file"); return 1; } while (fgets(buf, sizeof(buf), fp) != NULL) // file exits and has informaiotn { CheckUnCategoriesWinds(buf); } fclose(fp); // free up memory }
What do you mean, if you don't mind me asking (genuinely curious, not trying to incite an argument)? I'll go ahead and check out K&amp;R!
Couldn't figure out how to put in code, aren't suppose to place 4 spaces in front of each line ? 
Yes, you need to put four spaces in front of every line. Don't use backticks for code blocks, these are just for quoting little snippets of code in line, like `this`. Also, don't use birdtracks (i.e. `&gt; ` at the start of lines). That's for quotations, not for code. 
Systems programming is a fairly complex subject, and I would expect a course on it to assume prior knowledge of C. So focus on that instead of jumping ahead to the systems programming part.
In `HurricaneInformation()`, you call `feof(fHurricanInformation)` before checking if `fHurricanInformation` is non-NULL. That is almost certainly the source of the error message. In `UnCategorizedHurricaneIdentification()`, if the `fopen()` call fails, you `return 1` despite the fact that the return type is `void`.
I do it anyways just for readability, like saying "this is allocating an array of characters." Some might think it's useless, but it just gets compiled out anyways.
you can select it and press the "code" formatting button (looks like this `&lt;&gt;`) instead of adding the spaces on every line. Also, the error message, the debug tool says "feoferr.cpp" so even if the extension of the file is .c you're probably compiling it as c++ without knowing, there should be an option in the project parameters or something. Also, you don't tag people using @ on reddit, they won't get notified, type /u/ then the user name, /u/GhettoBurger996 , then the person gets notified. As /u/FUZxxl was saying, you're not checking whether the file opened successfully before trying to check for the end of the file, so it's likely the file doesn't exist (i.e. you didn't there's a typo in the name of the file, like the capital C, or the path to the file is incorrect or incomplete) If the file pointer is null you can print the error message from `fopen()` with perror, and it will tell you why it failed
Your main problem is probably that Categories.txt failed to open, and you're not checking for this possibility. However, I also wanted to point out that this loop: while (!feof(fHurricanInformation)) { fgets(singleLine, 150, fHurricanInformation); puts(singleLine); } will not do what you hoped. Burn whatever resource told you to write your loop using `feof`. What you actually want to write is: while ( fgets(singleLine, 150, fHurricanInformation) ) puts(singleLine); See [here](https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong) and [here](https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1046476070&amp;id=1043284351) for the reasons.
Thank you for catching it. Two calls will never be atomic and exposes itself to race conditions. Since file locks are usually advisory at best, you cannot depend on locking either. Reading the value and checking the read value is best since we are interested in the content at the time of read.
is't `free(f)` simply a no-op if `f` is currently NULL? Or did you mean `fclose(f)`? Or am I mistaken?
The race condition is a red herring. The actual problem is that `feof` doesn't tell you if the file is at EOF. In fact, `feof()` doesn't inspect the underlying file at all. It just tells you if a previous read attempt has set the EOF flag on the stream. Importantly, this also does not indicate whether the next read is going to yield any data. Any loops of the form while (!feof(f)) { c = fgetc(f); ... } should eventually terminate, but the last `c` you process is valued `EOF` which is not what you want. The correct pattern is something like this: while (c = fgetc(f), c != EOF) { ... }
&gt; the debug tool says "feoferr.cpp" so even if the extension of the file is .c you're probably compiling it as c++ without knowing, there should be an option in the project parameters or something. That's a file from the standard library. I suspect the libc of whatever toolchain OP uses is written in C++. I'm pretty sure OP is not compiling as C++.
you said the first part (not checking for null aka checking the file opened successfully), I'm saying the second part, sorry I didn't make that clear.
No, I didn't. In fact, I didn't post any comments on OPs code at all. In fact, it was /u/a4qbfb who said that.
I have no idea how this happened, I copy pasted your username from the comment, and checking now it appears that it wasn't you who posted it, there is something fucky going on, sorry for bothering you.
Always write code for human beings. The use of "sizeof()" is a good idea to show what you are thinking. The compiler will take care of opcodes for the machine but source code is for humans.
Sure, but you gotta show us the code first...
[In the old version](https://github.com/mrharmonies/hashpling/blob/4a5da133d7a1dc1e3cb34247c2fdea0ca8006933/src/hashpling.c#L97-L98) it just did the following: fclose(f); free(f); So `f`, after `fclose(f)`, is still a pointer pointing to something (which would be undefined when trying to use it), but it's not `NULL` since the pointer didn't get modified after `fopen` (like there is no `f = NULL;`).
It would be helpful to have the entire error message and not just part of it.
My guess is a curly bracket is missing somewhere. Usually the error you get when you don't close a brace. Also it looks like the error line is not in the image...
It would be helpful to have line numbers, I can't tell what's on line 57 just from the picture.
Your first step in debugging an unknown error should always be google. 99 out of 100 times someone has asked about your error and has been answered. 
Truth
I have googled it I just can’t find the error on mine. That’s why I posted it on here so that someone could help see something I can’t 
* You have many `printf` calls for just printing a block of text. You can use something like: printf("This source is free software; you can redistribute it and/or modify it under\n" "the terms of the GNU General Public License as published by the Free\n" "Software Foundation; either version 2 of the License, or (at your option)\n" "any later version.\n\n"); (Note that [C89/C90 has a limit of 509 characters per string literal](http://port70.net/~nsz/c/c89/c89-draft.html#2.2.4.1). AFAIK clang has a warning for going over this limit) * You may also want to print the help when no command line arguments has been used, so it's more user friendly. * `strcpy(optionstr,"");` is basically `optionstr[0] = '\0'`. Note that on [gcc and clang with optimization this is already done for you][godbolt-strcpy]. * `printf("%s: File \"%s\" failed to be opened. Sorry.\n",argv[0],argv[1]);` You might want to use [`perror(argv[1]);`](http://port70.net/~nsz/c/c89/c89-draft.html#4.9.10.4) (it's in `stdio.h`) instead, since it provides more information on why the file couldn't be opened, like: `somefile: File not found` (not exact). * No checks whenever any of the `malloc` calls failed. Also since the buffer capatity is currently hardcoded, you could just have used an array. * `s[l]=='\x0d'||s[l]=='\x0a'||s[l]==EOF` It would be better (for me) if you've used `'\r'` and `'\n'` rather than their ASCII values. Also you don't check whenever it still fits into your buffer. * `snprintf(optionstr,BUFFER,"%s",optionstr);` What is the use of this? It writes to `optionstr` while reading from `optionstr`. Note that the string concat above has, as it already has been mentioned by others, a flaw. (Also does the share-feature in godbolt work for anyone on current Firefox?) [godbolt-strcpy]: https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:___c,source:'%23include%3Cstring.h%3E%0Aint+something(char*+optionstr)+%0A%7B%0A++++strcpy(optionstr,%22%22)%3B%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:49.96643266360043,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cg81,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'1'),lang:___c,libs:!(),options:'-O1',source:1),l:'5',n:'0',o:'x86-64+gcc+8.1+(Editor+%231,+Compiler+%232)+C',t:'0')),k:50.033567336399585,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cclang600,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'0'),lang:___c,libs:!(),options:'-O1',source:1),l:'5',n:'0',o:'x86-64+clang+6.0.0+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:50.033567336399585,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4
It prints the line in the error (`for (pos = 0; pos &lt;= 180; pos += 1) {`), but it isn't anywhere on the picture so it's offscreen.
I would hazard a guess that you have one too many closing braces. Your picture doesn't show any indentation, but I'm assuming you have it - can you copy/paste the text itself and put it in a code block?
Are there any required resources that I may need before trying out the Rust programming language?
But could I just do this for simplicity and less overhead. This is the Player.h file #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "cString.h" //private data members... typedef struct { cString name; unsigned int score; }Player; //publice interface... Player * constructerPlayer( void ); void initWithPlayer( Player * this ); unsigned int playerScore( Player * this ); cString playerName( Player * this ); void destructurePlayer( Player * this ); This is the Player.c file //constructer function Player * constructerPlayer( void ){ Player * newPlayer = (Player*)malloc(sizeof(*newPlayer)); if ( newPlayer != NULL ) { initWithPlayer(newPlayer); } return newPlayer; } //initializer function void initWithPlayer( Player * this ){ this-&gt;name = NULL; this-&gt;score = 0; } //getter funciton unsigned int playerScore( Player * this ){ return this-&gt;score; } //getter function cString playerName( Player * this ){ return this-&gt;name; } //destructor function void destructurePlayer( Player * this ){ if ( this ) { free(this); } } 
The error message: Test:57: error: expected unqualified-id before 'for' ... Indicates that the error is on line 57 of file Test. I don't use arduino, so I don't know for sure, but I would guess that the 139 in the lower left of your pic is telling the current line number of the cursor. This suggests that the error is much higher up in the file than the region you're currently looking at. Take a look at line 57 and whatever precedes it.
My guess is one to many braces.
I'm pretty sure it's a open/close curly bracket. Check them again and another think to help you check faster is to delete them if you have only one instruction after for(). Good luck.. If you need more help put the entire code somewhere and share the link. 
You absolutely could. But in most OO languages it is recommended (depending on who is doing the recommendation) that you make all your class variables private, and have the appropriate getters and setters. I was showing that this is possible to do in C too. Whether that is the best approach (or yours for example) is topic for debate.
What kind of game where you working on?
Nope. Just go to their website, install the compiler, and follow the book (on the site). It covers the whole language from A-z. It's all free and open source.
Oh sorry there was a mix up there, I've removed the `return 1` from the code block, and have also removed `feof(fHurricanInformation)` and replaced it with what /u/boredcircuits recommended. 
I've replaced the while statement with what you've recommend and have briefly gone through both links. I still dont quite understand why my statement is incorrect. I definitely need to study up a bit more. As for the error is still appear even though I've removed the return 1 as /u/a4qbfb suggested and fixed up the while statement. 
After a lot of googling and taking into consideration what /u/Kwantuum and you said, I ended up finding a option in the advance section in c/c++ However, after all the changes made to the code and to the options the issue still persists, I am receiving the same error with a slightly different warning message. [https://imgur.com/a/nqW4fyN](https://imgur.com/a/nqW4fyN)
I will give it a go. Thanks.
The easiest way to understand the problem with `feof` is to trace what would happen if the file is empty. The program first check to see if it's at the end of the file ... *and it's not*. The reason is you haven't tried to read anything yet. Until you do, it's just a file waiting to be read from. Since the file isn't at the end, the program then reads something from it and prints that out unconditionally. This isn't a problem just with empty files: `feof` will only return true after you've attempted to read past the end. So you'll always get an extra iteration of the loop than you wanted. Of course, in this case it won't ready anything and you probably wouldn't see anything wrong. But imagine you had more significant logic inside that loop. Now look at my version: `fgets` will return `NULL` if it tries to read and fails (including at the end of the file). With an empty file, that means it will try to read, but will quit the loop instead of doing that logic. All is right in the world. So, is `feof` bad? Should we never use it? Absolutely not. It's there for a reason. Functions like `fgets` can fail to read from a file for other reasons than end-of-file. `feof` is there so you can tell why it failed. You would use it like: while ( fgets(singleLine, 150, fHurricanInformation) ) puts(singleLine); if ( !feof(fHurricanInformation) ) { fprintf(stderr, "There was an error reading the file\n"); exit(EXIT_FAILURE); } If the read failed for a reason besides end-of-file, the program prints and error and quits. End-of-file is an expected condition, so the program proceeds normally.
How do I put it in a code block? 
Post the whole code please.
I realized thanks to you guys I had an extra curly bracket in my code. Thank you all very much. I appreciate it
If you're self taught you'll breeze through it. Good luck!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
f is not null at the point `free(f)` occurs
Not perfectly sure, tbh. I assumed reddit had a direct facility for that, but maybe not. This should help though: https://www.reddit.com/r/reddit.com/comments/6ewgt/reddit_markdown_primer_or_how_do_you_do_all_that/?utm_source=reddit-android
Glad to be of help!
I cannot reproduce this behaviour on my machine: $ gcc -march=native -Q --help=target | grep -- '-march=' | cut -f3 skylake $ gcc -march=native -Q --help=target | grep -- '-mtune=' | cut -f3 skylake GCC version is 8.1.1 (20180531).
Can you post the code with latest changes you made? The error is from fgets and an assertion failed that says stream.valid(). So you are trying to read an invalid stream..does the txt file exist in the same directory?
I couldn't reproduce it either, neither with GCC 6.3.0 nor 8.1.0.
&gt; free(f) causes undefined behaviour, f is a closed file handle. It is even undefined if `f` is an open file handle as `f` was not obtained by a call to `malloc`.
Ah, I see! Thanks for your replies, @Neui, @OldWolf2 and @FUZxxl ! &lt;3 
I get it on WSL on a windows 10 machine $ gcc -march=native -Q --help=target | grep -- "-march=" | cut -f3 broadwell $ gcc -march=native -Q --help=target | grep -- "-mtune=" | cut -f3 generic gcc Ubuntu 7.3.0-16ubuntu3
Sam here
Do keep in mind that these 100 resp. 10000 characters are including the terminating `\0`-character that your string should contain. So you are actually only free to use the first 99 resp 9999 characters in there.
Hi Sam, how are you?
&gt; The easiest way to understand the problem with feof is to trace what would happen if the file is empty. No, the error message was a `NULL` pointer assertion in `feof()`. The problem is that `fopen()` failed and there is no error check before the loop.
Sure, but then you should use `sizeof(*a)` rather than `sizeof(char)`.
Yes, that's the original problem, as I said in my first comment. But I was also pointing out a second problem OP needs to fix and why it's a problem.
 /* shrug */ sizeof(char) = 1 sizeof( *a ) = 1 sizeof( a ) = 8 
This feels rather overcomplicated. Why not simply limit the main event loop waiting period to &lt;60 seconds, and if nothing has happened during that time you send a ping synchronously?
That would be the easiest option but I do not control the main event loop for the program. The "main thread" I describe here is a sub-module that can be initialized, destroyed, or sent data but it doesn't have any kind of loop. So this continuous pinging is difficult with the way the core program runs because there is no guarantee that the sub-module will be called each minute (though it is still very likely) to keep the socket alive.
Aha. How about instead transparently renegotiating the connection if it has died? If you *really* want to use threads, your second 'simple' solution seems okay to me – assuming you have two threads only, and do it with *pthread_cond_wait* or the like on the networking side.
`a = malloc(n * sizeof(*a))` will be correct no matter the type of `a`. One less thing to remember if, for instance, you're refactoring your code to support multibyte locales.
Sure. Tell them to check `ferror()` as well :)
If you're on Linux, you could use a [timerfd](http://man7.org/linux/man-pages/man2/timerfd_create.2.html) for the periodic ping along with a [eventfd](http://man7.org/linux/man-pages/man2/eventfd.2.html) to signal to the socket thread when there is a request to process. The thread servicing the network connection can then just [select](http://man7.org/linux/man-pages/man2/select.2.html) these two file descriptors so that it gets notified when either there is work to do or the socket needs to be pinged. (remember to open the file descriptors with `O_NONBLOCK`) When submitting something to process, pass a callback function and a `void*` pointer that will be called with the result. This callback can then re-post something to the main event loop. This way you don't have to block the event loop waiting for slow network operations! Submitting a request to the queue will only require three objects: the eventfd, a request queue, and a mutex to protect the queue. The general approach is as follows: 1. Lock the queue mutex 2. Add your request data, including a callback function and a `void*` context pointer, to the queue. 3. Unlock the mutex. 4. Write a byte to the eventfd. This will cause the socket thread which is currently blocked in a call to `select()` to return, and indicate that an event happened on the eventfd. Once the socket thread wakes up from its `select()` call and notices that the eventfd was triggered, it does the following: 1. Lock the mutex 2. Dequeue a request from the queue 3. Send the request, and receive a response. 4. call the callback function, passing the supplied context pointer, along with the response data. 5. Call select() again to wait for either a new request or the timerfd to tick If you want to increase performance by pipelining requests(having multiple requests 'in-flight' on the socket at the same time), then you can also add the socket file descriptor to the select set and wait for data to arrive on it as well. 
Have you considered using a formatter instead?
Nope. Don't use a compiler to enforce coding standards. You want a linter for that. With [splint](http://www.splint.org/), this is the +ifblock (and similarly +forblock, +whileblock)
Try "Location of Functions on Common Input Devices, with New Chapters on Caps Lock and the Uses of Shift (6th Ed)"
&gt; I use a skylake processor with GNU GCC 5.5. It is important to note that this compiler predates skylake processors.
Thanks, I'll check that out. And yeah, I agree that having the compiler enforce it isn't the best route, but if there's a warning available it's 'free' - no added steps, and no fighting to get the IDE to cooperate. For checking a single rule I'd do it with a compiler flag if there was one.
You could just use grep. `grep -rin 'if\s*(.*;'` will look for if statements with a semicolon on the same line with some noise if you have functions ending in `if`. Or you can do `grep -rin 'if\s*([^}]*$'` which will look for if statements without an opening brace on the same line (assuming you use braces on the same line). Grep is a primitive tool, but very useful.
K. N. King. It's just a much better book. The K&amp;R book is great, but it doesn't really take its time explaining anything and it's really written for people with computer science experience that want to know about C.
thank you
That's true. I was hoping for a compiler option mostly because I'm forced into using a specific IDE that's often broken or just clunky and if I want to check every time I compile, it's the easiest way to do it. At least adding a custom build step no longer makes the IDE throw a null pointer exception...
Just note that splint hasn't had a release in over a decade. clang-tidy is a modern, actually maintained, alternative.
Doing good!
While a formatter can ensure consistency across a project, it will _not_ point out pre-existing bugs/oversights that arise from the usage of an unclear style. e.g. a linter will immediately say 'on line 100 you have an if without a block', whereas a formatter will just silently insert an empty block there, and you'll have to spot the empty block yourself afterwards.
 [Y/N]
Manipulating the terminal by hand is always an impressive feat, +1. I haven't looked to much into the code, but I have the feeling things could be more readable by breaking them down into functions. There's a lot happening in functions, with a lot of indenting going about. Comments would be handy as well, even for yourself. Remember that code is read more frequently than written!
More a similar question than an answer, but: This seems like a very common pattern. Isn't there some kind of library that handles the internal communication, synchronisation and timing-logic for you? 
WHY ARE YOU SHOUTING
IMO K&amp;R will not help a beginner. 
In conclusion, it's not more complicated than you thought, GCC is just buggy. Skylake/kabylake had an actual regression with march=native or march=skylake until few months ago, you would have been better off with march=haswell anyway.
This might be the thing. On my (coffee lake) machine with gcc 7.2, I get $ gcc -march=native -Q --help=target | grep -- '-march=' | cut -f3 broadwell $ gcc -march=native -Q --help=target | grep -- '-mtune=' | cut -f3 generic so if march is something that the compiler does not yet know, it might resort to -mtune=generic
Interesting you have given me lots to read up on. I thought a queue might be useful but didn't consider a callback as a way to return data. Thanks for your insight.
Having to renegotiate poses other issues but they might be worth it to avoid the complexity. Thanks for your help.
I concur. Definitely a feat doing it all by hand but it is quite a monolithic beast. There is quite a bit of repetition and especially when you look at the up/down arrow functions, whatever the difference is, maybe you could separate some of the stuff into a common function and have perhaps a function pointer to resolve some of the minor differences between the code. Also when you have void functions, don't forget to put void in the prototype! Leaving it open allows undefined behavior to creep in. There is a lot of checking of the same values in some of the arrow functions. You could perhaps do an initial range check and then a switch statement that covers the particular cases that you wish to address. Stylistically I would like to see some of those numbers to be more descriptive. Ie. instead of just passing in 27 and 97, which ultimately don't mean much to me, if they are ASCII representations of something, use 'a' notation instead or define these as constants with a descriptive name. Admittedly if you defined some constants that would increase your line length, however then that may allow you to reassess your logic. 
Add this line after your `sum = sum + (num * ten);` line: printf("%d %d %d\n", num, sum, ten); Then try to figure out why one of those values looks weird. Hint: What's the value of `10 * 50`?
You won't be able to store a 50-digit number in an `int`. If you just want to print out 50 random digits... just print out 50 random digits. Don't bother "storing" it anywhere.
Your makefile might not work... target reads **defualt** instead of **default**.
Doesn't affect usability, but I'd also recommend renaming the makefile from "makefile" to "Makefile".
Sounds like you have a solution - now promise us you won't ever name a variable after a number again! Having a constant named 'ten' equal to 10 would be slightly offensive. Assigning a value other than 10 is an abomination.
Ah, that makes sense! I'll do just that!
&gt; turned out to be a misplaced semicolon at the end of an if statement. GCC can warn you about that specifically if you use `-Wempty-body` (which is part of `-Wextra`). For example, this code: #include &lt;stdio.h&gt; int main(void) { if (1); printf("Hello\n"); } gives the warning test1c:5:9: warning: suggest braces around empty body in an ‘if’ statement [-Wempty-body] if (1); 
Ok so here's a bunch of issues. 1. `PATH_MAX` is defined in `linux/limits.h`, which you do not include. I was unable to compile without including this. 2. You don't link the `pthreads` library through your makefile. Linking fails without `-pthread`. 3. Compile your code with `-Wall` at the very least. You have a mountain of warnings that should really be cleaned up. A cursory example is `void leftArrow(enteredValue) { ...`. You simply *forgot* the type of `enteredValue`. 4. When I make the necessary changes to get the code to actually compile and run the program... it crashes. I open a file and get a nice segfault. Clearly there are some issues with the code, I would personally recommend running some cursory unit testing and sanity checks before posting a project. I could go on with more issues, but those are (IMO) the most pressing. For those who think I am being a little nasty, so be it. However I have issued a PR on github for the sake of the author to learn.
Ah, that's the one I was looking for, thanks! Amazingly it only found one instance in this project, and that was in the vendor-provided USB stack.
Do not spam.
oh, that's pretty neat. I will need to play with it next time I'm neck deep in C.
Wow, that's a lot of features. It would be helpful if each item in the table of contents had a link to the api documentation for that module, like it's great that it has a regex section, but there's no indication of how to use it.
Do you know about `fclose` ?
using an uninitialised variable is undefined behaviour, and the compilier can do literally anything it wants with that - almost certainly breaking the program in mysterious ways. as you note in the second point, initialising `singlechar` fixes the program. `singlechar` being 'u' is just chance. the reason it doesn't print twice when `singlechar` is not initialised is *likely* because the compiler uses the same location to save the data - and the last thing stored there was `EOF` meaning the loop never executes.
you better off asking on irc
Huh?
So when I call the function a 2nd time, I figure that the variable is initialised because it's a local variable and that it had a value beforehand. But in reality the compiler assigned that arbitrary 'u' value to it, and finished the call once by ending on 'EOF'. So since I didn't initialise it, the value 'EOF' was still in my variable the 2nd time around. Right? So since I didn't initialise the variable in my first obvservation, do you know why that wasn't a problem then?
I've read up on fclose, but when I put it in my programs I don't see how it makes a difference. So I'm not sure what it actually does.
Also note there are tons of sample setups for clang-tidy on the internet making it more or less trivial to set up.
Just a heads up for the future, tag people using the `/u/` syntax so they get pinged. For example, /u/theboxingfoz.
just because a local variable had a value in previous function call doesnt mean it is initialised. the memory the compilier assigns to `singleChar
I see! Thank you! I've edited my earlier post to follow this syntax.
&gt;I figure that the variable is initialised because it's a local variable and that it had a value beforehand You can't make that assumption. In this case it happens to have the value of singleChar from the last invocation of this function, which happens to be EOF so no characters get read. If you'd called another function in between, or if anything happened behind the scenes that you can't see from the source code then it might have any other value in it. Never use an uninitialized variable, your compiler should have warned you about this and it is warning you about this for a reason. Turn on all warnings and insist on your programs compiling with 0 warnings, it will prevent you from making mistakes like this. Here's how I would have written this. Note the for loop, the variable is declared in the for loop and immediately initialized with the initial fgetc. That means the first check (middle of the for loop) runs on an initialized value and this bug won't be repeated here. Also note that I close the file, C won't close the file automatically when you're done with it so you have to make sure you close it when you're finished. #include &lt;stdio.h&gt; void read_file(const char* filename) { FILE* file = fopen(filename, "r"); if(!file) return; for(char c = fgetc(file); c != EOF; c = fgetc(file)) { printf("%c", c); } fclose(file); } int main(int argc, char* argv[]) { read_file(argv[1]); read_file(argv[1]); return 0; } Some people don't like using for loops like that, so here's a while loop. void read\_file(const char\* filename) { char c = fgetc(file); while(c != EOF) { printf("%c", c); c = fgetc(file); } I think this is less clear since the bottom of the loop is also controlling the loop but the initialization and test are at the top of the loop. It's fine here, but as soon as this loop gets big enough that it doesn't fit on the screen then you have a small problem. That's all a matter of taste though. Just note that the char variable is *always always always* initialized before being used. That is never, ever optional. &gt; So since I didn't initialise the variable in my first obvservation, do you know why that wasn't a problem then? Luck. It happened that the value on the stack wasn't equal to EOF. If other code had set that to something equal to EOF then the function would have failed in the first invocation as well.
local variables have a lifetime of the function call. it just so happens that this time, its likely the compiler used the same memory location for the variable data. the variable is NOT initialised in the 2nd call from having a value in it from the first call. i have no idea why the first observation happened. maybe something to do with the return value of `printf()` overwriting the value of where `singleChar` is saved, removing the `EOF` so the loop runs? but i have honestly i dont know. the important point here is UB breaks in strange and mysterious ways, and cannot be relied on. 
The second option does not add any overhead. Just the burden of accessing the member of the struct, but I wouldn't consider that an issue.
Yeah that's what I meant. It clutters your code, not that it's a performance overhead.
The second time you're calling `fopen` on a file that's already open.
You're going to be a little more specific in your question. What part of the server? Backend? The server itself? User interface? Those competitive programming sites will take a specific function (given by the user) as input, and a predetermined test harness, the compile a set of tests. The validity of the program is then determined by running the resulting binary.
Thanks, I'll keep that in mind as these modules definitely need more in depth information. So far, most of modules have an example code written in the `test` directory, but I agree documentation would improve this a lot.
Thanks, I appreciate it!
Firstly there is no such thing as gnu C. No such language exists at all. So whatever "GNU's dialect of C" pretends to be it just isn't C. Probably best to use C99 and pedantic and the pedantic errors and also, just to be really strict, disable the extensions and inline weirdness that GCC can and will do. For a really clear example just try to teach a class to people about C and have them compile "hello world" to assembly. Look at the assembly and there is no call to "printf". That gets replaced with "puts" which just isn't the same thing. However industrial compilers will do exactly what you ask for ( a few strict flags required ) and you get assembly that really really is representative of what the human being wrote in real C.
Well I care for the server backend software the most. A long time ago there was kind of custom testing system (based on shell scripts), but I'm not sure if it can be used now. As for user interface, I'm not sure wether it should be web-interface or terminal-based, well, I think either variant will work... Just, the thing is that it's DEC Alpha, not x86. That's why some programms may work differently there. But I don't know what will be the best way to prepare it for testing students' works...
I prefer the Harvey Deitel C book. Much more comprehensive than the king book imo. 
For the first one about compilers, part of me feels like it matters and part of me says GCC 4.9 was released 4 years ago so if you haven't migrated systems to be compatible with the new compiler that's kinda your problem
Jumping through hoops to support ancient compilers. My least favourite part of programming.
Unfortunately at my work we have to support GCC 4.4. Supporting the government and old Linux distributions is a bitch
The government runs on Linux?
It sounds like you're describing a continuous integration server.
&gt; So when I call the function a 2nd time, I figure that the variable is initialised because it's a local variable and that it had a value beforehand That's only the case if the variable is declared as static.
fclose releases the resource associated with the file, if you don't close it, there's a possibility that you can't open it until the program closes, and since you don't null check fopen you don't even know if it is ever actually opened, although the program would probably crash if it wasn't. It also takes up memory. Close your files.
We roll our own Linux OS as well as support centos and red hat
single headers all the way!
Remove “respectively” from the README.
You don't always get to choose your toolchain. If you're working on embedded systems, process control, military systems, SOLAS etc., especially in a maintenance phase, you are often stuck with the hardware vendor's or original software developer's toolchain, which might be 10 or 20 years old.
Just a casual comment, usually I'd see this one: while((c = fgetc(stdin)) != EOF) { putchar(c); }
Digging all the features, can't wait to try them out. 
Done, thanks.
 while ((c = fgetc(file)) != EOF) { /* ... */ }
That makes no difference. Even Windows doesn't mind as long as the file is only open for reading. The bug is that `singlechar` is uninitialized.
Have fun experimenting with it!
Code I write for university has to compile on their Red Hat 7 systems, which uses GCC 4.8. It's not my university's problem if my code doesn't run on their systems; that's my problem.
Why is it called ZPL? I initially assumed it was related to [Zebra](https://en.wikipedia.org/wiki/Zebra_\(programming_language\))
**Zebra (programming language)** Zebra Programming Language (ZPL and ZPL II) is a page description language from Zebra Technologies. It is used primarily for labeling applications. The original ZPL was advanced to ZPL II, but a full compatibility with the older version is not given. Meanwhile, ZPL II is emulated by many label printers of various producers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
You have to put a label at end of the code and jump to it on every option, sort of like how a switch statement works with having to put `break` after each case: // if ... // if ... take1: printf("Hello\n"); goto done; pet2: printf("Hi\n"); goto done; //... done: }
 printf("Hello\n"); return; etc. Of course, you realize `main()` should return `int`.
Well first of all, your prof allowing goto statements is very strange to me. Literally every institution I've ever come into contact with has been very insistent on never using them. Nevertheless, I'll still help. Currently it's falling through after each label, so you're going to want to provide another label you can jump to after you've executed all the work for any particular label.
After the printf(), goto startmenu. Seriously, what is the professor trying to teach you here? Those are some very specific constraints on how this should be programmed. Unless he's trying to teach you assemly, but using C to do it, I don't understand why you have to use goto, no switches, and only two level deep if statements. Is he trying to show you why the use of goto is bad in *most* situations?
These restrictions are... weird.
Seriously, why they put those shitty professors to teach C for newbies? To learn stuff like this is better not having programming classes at all...
idk whats up with all his limitations, the "only 2-level deep nested if" is especially hard since it means I would have to use alot of goto statements which he have not discussed yet, he just said that we can only use goto and not switch and others. I think im good for now, i just have to add another goto after each label so it wont fall through :/
maybe his thinking was we havent 'discussed' switch and other advanced stuff so no no,, but then again he have not discussed the goto statement too, he just showed us how goto works when he announced the program project :x and for the 2-level deep if restrictions, he was lecturing us that using very deep level nested ifs in your code is inefficient and is bad, so maybe the restriction is for that, yeah, in my research tonight, alot are saying goto statements are bad and should be avoided if possible and cant find an answer to my question so i went here, ill check the C_homework subreddit soon :)
tell me about it, only 2-level nested if is pretty hard when the menu has 3 sublevel deep Options,,
Looking at it again, you should just emulate a 'for' loop with 'if' and 'goto'. Have your 'if mainmenu == ...' just print the values instead of jumping to a label, then have a single goto after that 'if' block to jump back to the start if you didn't select '3'
I also cant use while or loops, since 'we havent discussed it'. im gonna have to make do with if and goto statements and have a very messy code :/
try to always keep goto's to a minimum, preferably you want to not use them at all (since they are way to easy to accidentally misuse) and I would seriously question your proffesor on why he is telling you to use goto at all (I never saw or had to use goto's through my entire university career outside of two classes in which I was writing assembly) something like this might be what you're looking for: startLoop: // mark beggining of input loop // prompt for input .... scanf("%c" &amp;mainmenu); if(mainmenu == '1'){ // do stuff for selection 1 ... } else if (mainmenu == '2') { // do stuff for selection 2 ... } else if (mainmenu == '3') { //print total and stuff like that ... return 0; // this will make the program exit }else { goto startLoop; } if you want fall-through you're going to have to be a bit cleverer. on the other hand you could make what's effectively a switch: startSwitch: // mark begining of input loop // do prompt input stuff if (mainmenu == '3') { // put this on top to test exit first (testing exit first is a good rule of thumb) goto outOfSwitch // effectively same as break } if(mainmenu == '1'){ // do stuff for selection 1 ... goto startSwitch; // effectively same as continue; in a for loop } if (mainmenu == '2') { // do stuff for selection 2 ... // skip a goto for fallthrough } if(mainmenu &lt; '4'){ // some stuff that will be executed if user inputed 2 } goto startSwitch; outOfSwitch: // rest of the code
are you allowed to define your own functions? because the restrictions given (specially due to the three level deep menu) seem specifically designed to generate horrible mess of spaghetti code.
Maybe I’m not fully understanding the restrictions made by your professor, by why not just have function calls within your conditional statements instead of using go to? ie instead of goto take1 you just have a function called take1 and call that function when you need it.
What I'm saying is use if/goto as a replacement for the loop, instead of the mess you have now. You don't need a goto in the body of every 'if' statement just to jump to a printf, just print where you are currently calling 'goto'. You could do this with one goto at the end to jump back to the beginning, which is pretty much a while loop. 
That's a very hasty conclusion. What if OP misunderstood the assignment? What if the professor wants the students to experience the issues of non-structured code?
yea, thats what i plan on doing, right now im stuck in this, im using int for the main menu, but whenever I press anything other than 1,2 or 3, it does an infinite loop of clrscrn and goto startmenu; How do i break this infinite loop? #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "conio.h" #include &lt;windows.h&gt; void main() { int mainmenu; int submenu; startmenu: printf("Main Menu\n"); printf("-----------------------------\n"); printf("[1] Take Orders\n"); printf("[2] Pay Bills\n"); printf("[3] Exit\n"); scanf("%d", &amp;mainmenu); if (mainmenu == 1) { system("cls"); printf("[1] Food\n"); printf("[2] Dessert\n"); scanf("%d", &amp;submenu); if (submenu == 1) { system("cls"); } else if (submenu == 2) { printf("failed"); } } else if (mainmenu == 2) { } else if (mainmenu == 3) { exit(0); } else { system("cls"); goto startmenu; } } 
Hopefully this is an exercise in what *not* to do.
Well from my experience, this is hardly the case. And from your argument, we should teach math with Roman Numerals first so that students understand how great are Arabic Numerals... Hmm, no.
I think you misunderstood the restrictions... specifically the part with: \&gt; And the "if statements" is limited to \*\*2-level nested\*\* ifs only \&gt; We cant use something like switch... 2nd level nesting means that you can go 2 levels deep into an \`if\` statement area. A classic example will be a \`while\` loop (level 1) and a \`switch\` statement (level 2). i.e.: \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; \#include "conio.h" \#include &lt;windows.h&gt; int main(void) { int mainmenu = 1; while (mainmenu) { /\* level 1 nesting \*/ printf("\[1\] Hello\\n"); printf("\[2\] \\n"); printf("\[3\] Exit\\n"); mainmenu = getchar(); switch (mainmenu) { case '1': /\* level 2 nesting \*/ printf("Hello\\n"); break; case '3': /\* level 2 nesting \*/ mainmenu = 0; break; default: /\* do nothing? \*/ break; } /\* clear the rest of the incoming data \*/ while (getchar() != '\\n') ; } } I didn't fill in all the options (option 2 is missing), but this approach is superior to \`goto\` in this case and it conforms to the limit of 2 levels of nesting. I think this is what the professor was actually looking for.
Hi, from what the prof said, this is a 2-level nesting (an if() within an if() ), If i put another if in the 2nd if() that is inside the 1st if() it would be 3rd level, (accdng to my prof) unfortunately i cant do switch and while if((foodchoice == '1') || (foodchoice == '2') || (foodchoice == '3') || (foodchoice == '4')) { printf("\n\nHow many would you like: "); scanf("%d", &amp;foodquantity); if (foodchoice == '1') { foodorder1 = 250*foodquantity; } else if (foodchoice == '2') { foodorder2 = 150*foodquantity; } else if (foodchoice == '3') { foodorder3 = 70*foodquantity; } else if (foodchoice == '4') { foodorder4 = 120*foodquantity; } } else if (foodchoice == '5') { goto takeorder; }
No. That's not my argument. My argument is that you should try to understand the professor's reasoning instead of jumping to the conclusion that they are a shitty professional.
You are telling scanf() to look for an integer number. If you enter anything else, it will fail. Since you are not reinitializing mainmenu each time (or at all), it will have a value of whatever garbage was in it to start. You should be checking the return value of scanf to make sure it succeeded. Another approach would be to change mainmenu to a 'char', change scanf to use %c and change the 'if' statements to compare against the characters '1' through '3', instead of the numbers 1 through 3.
Hi, thanks for patiently answering my questions, I changed all non-equation variable into char and the infinite loops were fixed, Ive also organized the goto labels and added "goto startmenu" after the labels to act as a break so it wont fall through all other labels, Im almost done with code code though I used 6 goto labels and a ton of goto statements f("[1] Take Orders\n"); printf("[2] Pay Bills\n"); printf("[3] Exit\n"); scanf("%c", &amp;mainmenu); if (mainmenu == '1') { system("cls"); goto takeorder; } else if (mainmenu == '2') { system("cls"); goto paybills; } else if (mainmenu == '3') { exit(0); } else { system("cls"); goto startmenu; }
If you are not _proper_ usage of goto then you might be doing it wrong. Goto has yhe potential to make your exception handling code look clean and reduces nesting which improves readability. Just like many other fratures in C it has a potential for programmer to his own leg but that doesn't make it bad. https://stackoverflow.com/questions/788903/valid-use-of-goto-for-error-management-in-c
I think I misunderstood your question... but I also suspect that `while` loops are okay and that `goto` isn't the answer. But to answer your question , the `switch` can be replaced with `if else` and the `while` loop can be replaced with a `goto` statement to achieve the same result (reminds me of assembly, but whatever`). Here's an example with 2 nested menus using a maximum of a single nesting level (1 `if` level) in the code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { char input; main_menu: /* level 1 nesting */ printf("[1] Hello\n"); printf("[2] Hi \n"); printf("[3] Exit\n"); printf("[x] Secret...\n"); scanf(" %c", &amp;input); if (input == '1') { /* level 2 nesting */ printf("Hello\n"); } else if (input == '2') { /* level 2 nesting */ printf("Hi\n"); } else if (input == '3') { goto finish; } else if (input == 'x' || input == 'X') { goto secret_menu; } goto main_menu; finish: return 0; secret_menu: /* level 1 nesting */ printf("[1] Go back to main menu\n"); printf("[2] Quick exit\n"); scanf(" %c", &amp;input); if (input == '1') { /* level 2 nesting */ goto main_menu; } else if (input == '2') { /* level 2 nesting */ goto finish; } goto secret_menu; } Personally, I would probably replace the `goto` statements with functions. Anyway, good luck.
[CSPARSE](https://people.sc.fsu.edu/~jburkardt/c_src/csparse/csparse.html)?
C++ is off topic in this subreddit. Please ask for advise on C++ in /r/cpp_questions.
Moving this to cpp quslestions as suggested, will check csparse, thanks! 
Hi, reproc is my first open source library. I got the idea when looking for cross-platform process libraries to use for implementing CMake support in [https://github.com/cquery-project/cquery](https://github.com/cquery-project/cquery). I didn't find any that fit my needs so I decided to make my own. Any feedback on code or documentation is highly appreciated.
I'm guessing it's beginning an arc into how assembly works?
Well, there's a lot of room for improvement here. First off, you should fix your indentation and formatting. It's kind of all over the place right now and hard to tell what's going on. Don't skip brackets on if() and while(), they will prevent errors when you change things and the consistency of having them is easier to follow. Now, on to logic. Your openfile() function takes an `int[10][6]` as an argument, but the compiler is warning you about an unchecked cast. This is accurate - you're passing it the value of what turns out to be one item past the end of your `grade` array. you should be calling `openfile(grade)`. Next, in `openfile()` - you read the contents of the file, print it to screen, and close the file. you don't actually do anything with the data you're reading in. This is where your program crashes because you passed the wrong thing into openfile. You end up trying to write to some random memory address because that's what you told it to do. Fix (described above) that and you'll see what happens next. At this point, you start to write numbers incrementally into the array, starting at 0, and increasing with every index. presumably what you want to be doing is using `fscanf()` and reading those values into the array. also, your array sizing is strange. There are 10 rows and 5 columns - you should declare the array as grade[10][5] for that many values. these will be indexed 0-9 for rows and 0-4 for columns. you can see where this causes you to have to do things with -1 a couple places in your loops. That should get you started. Good luck.
The text file has a column of 5 pieces of data, I need to include a 6th so I can store an average into that spot. When I am storing the values in the fscanf, should I be using %s, or %d? Thanks for the help.
You're reading an integer, so you should be using "%d". "%s" is used to read a string into a char*, or in printf, to write a char* out as a string. You should get used to reading man pages, they contain a lot of good documentation. e.g.: [man 3 scanf](https://linux.die.net/man/3/scanf)
Is there a way from me to double check if the value has been stored, thanks to your help I got a clean compile other than the exit status. https://repl.it/@ryanw123/project-4 Where i'm at right now
The exit status (-1) is your program crashing. If it were completing successfully, you should If you take a look at your program, you'll notice that you're opening and closing the file here. while((c= getc(grades)) != EOF) putchar(c); fclose(grades); and then later, you're trying to read from the already closed file. That's what's causing your program to crash in this case. You could do a few things to fix it. The easiest thing would be to skip this loop altogether and move fclose() to after you're done reading the file. Another option would be to use fseek() to move back to the beginning of the file. you still need to move the fclose() if you're going to do that. The third, probably worst option, would be to reopen the file before you start calling fscanf(), and again, fclose() at the end.
I didn't harp on it directly in my other reply to this, but seriously, your indentation "style" makes your code hard to understand, and if you ever need to share code (like you're doing right now), people will hate you for it, and not take you or your code seriously. Read up on [indentation style](https://en.wikipedia.org/wiki/Indentation_style). Get used to using *anything* consistent, I suggest either Allman style or a K&amp;R derivitive (I prefer OTBS personally).
I moved the Fclose(grades) to the bottom of the if. I don't think im actually storing and printing the values from the .txt file, since I get counting up to 49 below what I believe is the file being read. https://repl.it/@ryanw123/project-4
Read through my previous comment again. I provided 3 options to make what you want happen. All of them included moving the `fclose()`. All of them also required you to do something else, and you haven't done any of them. What you're seeing is that the `getc()` loop moves where you are in the file - you read the whole file, then you're at the end of the file. Now you're trying to `fscanf()` from the *end* of the file instead of the beginning.
That makes sense should I include a rewind(grades) in my while loop after the getc(), or before I start to build the array from the data?
Yes, `rewind(grades)` would be fine, equivalent to what I was suggesting. You have a couple of other things going on that are a bit off too, and I'll throw them out now because I'm about to head off. * your first set of nested `for()` loops is kind of useless, you just end up overwriting the data when you call `scanf()` later. * your third argument to `scanf` needs to be an address instead of a value - I'm guessing you're not to pointers yet, so I'm just going to give you this one, it should be `scanf(grades, "%d", &amp;grades[i][j])`.
Thanks man I got a clean compile, sorry for all the probably horrible questions(mech engineering major), and just need to pass intro to comp sci. https://repl.it/@ryanw123/project-4
My first reaction was to wonder what the prof was smoking. My second thought, after reading your post, was maybe he's preparing them for assembly language programming (jumps, unconditional branches, etc.).
Firstly, don't use goto statements. Ever. They make your code messy and hard to keep track of. Loops and functions can completely replace them. char menu; int fish = 0; // Rest of the menu do { scanf("%c", &amp;menu); if (menu == '0') fish++; // And the rest... } while (last != '3'); // 3 is exit character you said if (fish &gt; 0) printf("%d fish menus ordered", fish); // And the rest... I'd recommend you re-type the code as I'm using my phone to write this post and some quote characters or something might be wrong. Also, above code guarantees output is printed out at the end.
Firstly, don't use goto statements. Ever. They make your code messy and hard to keep track of. Loops and functions can completely replace them. char menu; int fish = 0; // Rest of the menu do { scanf("%c", &amp;menu); if (menu == '0') fish++; // And the rest... } while (last != '3'); // 3 is exit character you said if (fish &gt; 0) printf("%d fish menus ordered", fish); // And the rest... I'd recommend you re-type the code as I'm using my phone to write this post and some quote characters or something might be wrong. Also, above code guarantees output is printed out at the end.
Ah that explains a lot ;) Yep, they're there now. You really only needed to remove the get loop *or* rewind, but doing both doesn't hurt anything.
Don't use goto
Please do not post images of code! Aleays post all of your code including error messages as text!
You're running on Windows, so your input actually contains a carriage return character before the line feed character. Removing the line feed without removing the carriage return causes subsequent text to overwrite the beginning of the line when printed. You need to remove not only `'\n'` but also `'\r'`.
I am running on Linux. However, your suggestion worked!. you rock!.. thank you so much.
`scanf("%c")` reads exactly one character. You can read an entire line using `fgets`.
value is not initialized
Since you're using numeric options, the easiest fix is to scanf an integer rather than a char, ie: declare mainMenu as an int, use `scanf("%d", &amp;mainMenu)`, and then check against numbers rather than chars (remove the quotes around them). There is a problem with this however in that if the user inputs something that's not a number the program will loop forever because the buffer is not empty but a number can't be read from it, so you could also read two characters and check that the second one is a newline. There's another "problem" with your code for the else case, since you're scanf'ing a single char, it doesn't consume the newline character when the user presses enter, so if you choose 4 and press enter, it clears the terminal, goes to startmenu, and scanf's again, but there is still a '\n' in the buffer so scanf eats that and since it's not 1, 2 or 3 clears the terminal again then goest back to startmenu. You can't really see this and in your current case, it doesn't really matter, but it's generally a good idea to put a space before the %c in scanf to consume all whitespace characters unless you're specifically trying to catch them (ie `scanf(" %c", &amp;mainMenu)`)
&gt; You need to remove not only '\n' but also '\r'. I think this is a bit misleading. `\n` is _not_ a line feed character. It is a _new line_ character. It may or may not have the same integer value as an ASCII line feed character, but it is not required to do so. If the input file is opened in text mode (the standard streams are opened in this mode), the C implementation should automatically translate between the platform's new line character sequence, whatever that might be, and C's new line character, `\n`. So take this example: $ cat example.c #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { int c; while ((c = getc(stdin)) != EOF) { if (c == '\n') printf("\\n "); else if (isprint(c)) printf("%c ", c); else printf("&lt;0x%02x&gt; ", c); } printf("\n"); } If I compile this as a Linux program, it translates Linux's new line sequence &amp;mdash; a single ASCII line feed (`\x0a`) &amp;mdash; to `\n`: $ gcc -Wall -g -o example example.c $ printf '%s\x0a' foo bar | ./example f o o \n b a r \n But if instead I compile it as a Windows program, it translates the Windows newline sequence &amp;mdash; a carriage return followed by a linefeed (`\x0d\x0a`) &amp;mdash; to `\n`: $ i686-w64-mingw32-gcc -Wall -g -o example.exe example.c $ printf '%s\x0d\x0a' foo bar | wine ./example.exe f o o \n b a r \n The same translation happens on `stdout` too, which means the end of this output actually consists of an ASCII CR/LF pair: $ printf '%s\x0d\x0a' foo bar | wine ./example.exe | hexdump -Cv 00000000 66 20 6f 20 6f 20 5c 6e 20 62 20 61 20 72 20 5c |f o o \n b a r \| 00000010 6e 20 0d 0a |n ..| 00000014 So in most cases even Windows programmers need only think of abstract new line characters, not the platform's underlying character sequences. Saying Windows uses `\n\r` as its new line character sequence is quite misleading.
Yes, you will need to allocate memory for whatever you want to put in the `name` of the struct. `malloc(sizeof(Human))` will allocate enough space for a `char` pointer and an `int`, it won't allocate memory for the contents of `name` because it has no idea what the size will be. If you know the upper bound on the size of `name`, or are happy to enforce one, you could change the definition of the struct to: ``` typedef struct { char name[100]; int age; } Human; ``` Then when you call `malloc(sizeof(Human))` you'll get enough space for a 'string' containing up to 100 characters (only 99 usable because of the null terminator) and an `int`.
&gt; My question is, do I need to allocate memory for the char pointer name of the struct or is the assignment of this-&gt;name enough? Depends on what you want to do. If you simply assign to `this-&gt;name`, then the object you've just allocated won't "own" the pointer, or the contents of the string to which it points. That could indeed be useful in some cases... but I suspect it's not what you want. You probably just want to `strdup` the `name` argument to create a completely new string with the same contents. You might want to even want to change `name` to be a `const char *`, to emphasise the fact that the string being passed is simply going to be copied, and not modified.
First of all, thanks for the comprehensive answer. That's definitely a solution that'd fit. But let's say that I never need to modify `this-&gt;name` ever, wouldn't the code I've written in the post be enough? Having an assignment like char *name = "some name"; would automatically allocate memory for the given char array, though it's not modifiable this way (which is not important for me in this case), right? In my case, the this-&gt;name = name; should do the same, right? If I wanted `this-&gt;name` to be modifiable I could also dynamically allocate memory for it by this-&gt;name = (char *) malloc(sizeof(char) * SOME_LEN); and then copy the parameter `name` onto it, right? To be fair, your solution would, in this case, be a lot cleaner.
Okay I think I've learned a lot reading your answer, thanks first of all. So having "borrowing" it means the char array's content isn't "safe"? So by manually allocating memory for it I tell the computer that this memory is " booked" kind of? Man, this is definitely a big thing for me, I'd never have thought about this. Thanks for letting me know! Yea, a destructor would definitely be implemented anyways, this was just a silly example by me :P Oh, I thought I've read somewhere that it's good practice to do this; Didn't know it's unecessary though. Having you in a conversation I'd like to ask you one more question since you seem to be very well informed: Is it good practice/important to assign variables to NULL or 0 when declaring them? I often see functions like void foo(void) { char *arr = NULL; int nmb = 0; } Isn't it enough to declare them if you use/assign them later? void foo(void) { char *arr; int nmb; }
For the numeric option proposed you must change mainmenu variable from char to int. I think to read the whole line will be a better solution.
&gt; So having "borrowing" it means the char array's content isn't "safe"? Well, it's perfectly safe if the string's lifetime is longer than your `Human` object's lifetime. The problem is that you have no way to _enforce_ that. If you think of this `human_new` function as part of some API, the code _using_ that API could simply free the pointer after calling `human_new`, and the `Human` object would now have an unusable pointer as its name. &gt; Man, this is definitely a big thing for me, I'd never have thought about this. Thanks for letting me know! I would say that object ownership is one of the _most important_ things to think about when programming in C. You need to think carefully about who owns which object, and who is merely referring to an object owned by some _other_ x code. In your `human_new` function, for instance, you could for instance have left the assignment as-is, and simply documented the function as _taking ownership_ of that `name` pointer. It is perhaps a little non-standard, but it's not totally out-of-the-ordinary. The C library's `free` function works that way: once you've given it a pointer, you no longer own that pointer. &gt; Is it good practice/important to assign variables to NULL or 0 when declaring them? I don't think anybody would criticise you for doing that. In my experience, C programmers often have a habit of leaving it out when it's not necessary... and to be fair, _most of the time_ they get it right. But only most of the time. There's been lots of vulnerabilities due to them getting it wrong.
The value of a pointer variable is the memory address it points to, not the contents of that memory. If you use `this-&gt;name = name;` then `this-&gt;name` will end up pointing to the same memory as `name`. If the contents of the memory address in `name` is later modified, the contents of the memory address in `this-&gt;name` will also be modified (and vice versa). It would be particularly risky to use something like this: ``` char *name = "some name"; [...] this-&gt;name = name; ``` `char *name` will probably be allocated on the stack, but you are copying it into memory allocated on the heap. If `char *name` falls out of scope before you have finished using the struct returned by `human_new`, and you then try to access the `name` member of the struct, you'll effectively be reading memory which could contain anything. It might work, or you might get a segmentation fault or something worse. Example code for how this can happen (you compiler may warn you, depending on the flags passed in compilation): ``` #include &lt;stdio.h&gt; void assign_char(char *str) { char *my_str = "hello"; str = my_str; } int main(void) { char *main_str; assign_char(main_str); printf("%s\n", main_str); return 0; } ```
&gt; It would be particularly risky to use something like this: &gt; &gt; char *name = "some name"; [...] this-&gt;name = name; Um, that would actually be perfectly safe. The string remains valid for the life of the entire program. You can have as many pointers as you like pointing to that string. Yes, `name` is allocated on the stack, but `this-&gt;name` isn't pointing to `name`, it's pointing to the string.
&gt; It would be particularly risky to use something like this: &gt; &gt; char *name = "some name"; [...] this-&gt;name = name; That's a bit of a complex case. It's quite likely that the string will live in the program's constant data section, and remain in memory for the lifetime of the program. You can't rely on that though.
Oh, that totally makes sense actually. Thanks again for your answer and patience!
Good point. It felt a little off to me even as I wrote it. OP says they're on Linux, so there must be something wrong with their terminal emulator. 
&gt; so there must be something wrong with their terminal emulator. They probably just copied a file from a Windows machine and opened it on Linux.
&gt; If I wanted this-&gt;name to be modifiable I could also dynamically allocate memory for it by &gt; &gt; this-&gt;name = (char *) malloc(sizeof(char) * SOME_LEN); &gt; &gt; and then copy the parameter name onto it, right? Yes, or you could just use `strdup`, which does that for you. :-)
You say that you never need to modify the name string. In that case you could do one of two things. 1) Allocate a buffer just for the name and place that pointer into your new `Human` struct. 2) Place a `char name[1]` field at the end of your `Human` struct and malloc enough space for the `age` field and the length of the `name` string, including the end NULL byte. Copy the name into the `this-&gt;name` buffer. Return `this` as before.
&gt; Human *this = (Human *) malloc(sizeof(Human)); You should not cast the result of malloc (or calloc, or realloc), it's a void pointer, it'll automatically be casted by being assigned. In this case, your Name pointer has already been allocated, either by the user directly, or it's a statically allocated string, either way, it already exists and all you need to do is store the value of the pinter in your variable. That said, you should also verify that your Human type is valid (not NULL) before you start assigning things to it, and you need to make sure your Name string is valid as well.
ooohhh thanks,, so thats why 1111 enters the [1] if() :/
thanks for the tip, yeah I tried going with int first but whenever i enter a non-numerical option, the else with the goto statement gets triggered and it just goes into an infinite loop. How do you 'refresh' or 'reset' the value of mainmenu before going to the goto statement when going int??
due to the else with goto statement if I go with int it will go on an infinite loop :X
For something like that, I'd honestly just write a shell script. just printf the result of /dev/random
if you go with int, you'd have to empty the input buffer before asking for a choice, the most portable way to do this would be char c; while((c = getchar()) != '\n' &amp;&amp; c != EOF); this will just read and discard all chars that are backed up in the input buffer until it finds a newline or reaches the end of input. If you scanf after this you're certain that you've discarded the previous input line. Do this either before the scanf, or before the `goto startmenu;`
&gt; char *name = "some name"; &gt;would automatically allocate memory for the given char array, though it's not modifiable this way (which is not important for me in this case), right? &gt;In my case, the &gt; this-&gt;name = name; Something important to understand here is that those are fundamentally different. The first uses a *string literal*, its value will be compiled into the binary, and assigning a char pointer to that will point to that piece of memory, which should be "read only" like executable code. On the other hand, in the second case, you're assigning a pointer to another pointer, this is commonly called *aliasing*, because then both pointers point to the same location in memory, they just have different names, they're *aliases*. But that also means that the calling code which passed you that pointer still has that pointer and can choose to do anything with it, including freeing it as has been pointed out by others, so you should probably allocate memory and copy the contents.
Right, I assumed they were typing it in.
The second half of your comment is nonsense. When you copy a value it doesn't matter what the storage duration was if the source.
You can rely on a string literal existing for the entire life of the program 
A string literal cannot be freed . There is no danger in having several pointers to the same string literal.
Suggestion 2 causes undefined behaviour, you cannot access outside the bounds of an array (even if it is in a struct)
Best practice with variable definitions is to not define them until you are ready to assign them a meaningful value. 
&gt; A string literal cannot be freed Calling free on a pointer to non-dynamically allocated memory is undefined behaviour. It could be freed, the program could crash, or it could run nethack. I don't understand your point, I was simply clarifying that you can't reason about pointer to pointer assignment the way you can reason about string literal to pointer assignment because they're fundamentally different things.
You can reason about it when the pointer points to a string literal. It is fine
I used the older approach, forgetting that this standard workaround had now been formalized. =================== Draft C99 Standard, 6.7.2.1 Structure and union specifiers, paragraph 16 As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply. However, when a . (or -&gt;) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it. EXAMPLE After the declaration: struct s { int n; double d[]; }; the structure *struct s* has a flexible array member *d*. A typical way to use this is: int m = /* some value */; struct s *p = malloc(sizeof (struct s) + sizeof (double [m])); and assuming that the call to *malloc* succeeds, the object pointed to by *p* behaves, for most purposes, as if *p* had been declared as: struct { int n; double d[m]; } *p; ===================
Variables are not initialized to NULL or 0 by default. you must assign them
The advice about not nesting your if statements too deep is correct. The normal remedy is to make a new function for each of these deeply nested statements. So instead of if (foo) { /* deeply nested code ... */ } else { /* more deeply nested code ... */ } you write if (foo) { do_this(); } else { do_that(); } But it seems like you are not allowed to make your own functions.
If the argument 'name' points to allocated memory, you dont need to allocate new memory you can simply copy the pointer to the existing memory. If you want your struct to have ownership over a copy of that string then you need to allocate memory and point the name member to the allocated memory and then use strcpy from string.h to copy the string you get as an argument to the function. Both are valid options it just depends on whether or not you want your struct to have it's own copy of that string or just point to the existing one. 
&gt; I don't think anybody would criticise you for doing that. Except any decent C compiler. It should give you a warning for initializing a variable without referencing it, and for good reason. There's zero good reason to initialize a variable to a meaningless value, and it can in fact suppress other, more important compiler warnings and errors.
I'd argue the same is true for variable declarations.
Your code formatting is a mess, so I'm going to rewrite it in hopes that this is what you're trying to do: // Chnage the value of whatever is passed in void change (int *p) { *p = 6; } int main (void) { int x; x = 10; // Call change change(&amp;x); // Print out the new value of x printf("number changed %d", x); } When you create the function change(), you want to tell it that you're passing in a pointer to an integer. To do that, you give it `int *p` as a parameter. Inside the function, if you want to actually change the value of the variable you passed in, you have to *dereference* it, and do so with an asterisk, like with `*p = 6`. Then, when you call the function, you give it the address of the variable you want to pass in. You do that like this: `change(&amp;x)`. 
Thank you, I agree, that is how it’s done, but I do not understand why. Ty 
First of all, you should find a source that doesn't teach K&amp;R C. The ANSI C standard was released almost 30 years ago but your code doesn't use that. Don't get confused by the two different uses of `*`. When you declare `p` as `int *p`, the asterisk means that `p` is a pointer to int instead of just a normal int. But when you later say `*p`, it's the dereference operator. Dereferencing means that you want to use the value that `p` is pointing to and not `p` itself. (And this may be a little pedantic, but C doesn't have pass by reference, though using pointers as function parameters is often incorrectly called that. You'll see the difference if you ever use a language like C++ or Rust which have actual references.)
Essentially what you're doing is instead of giving the function a value, you're giving it an address in memory. So let's say `x = 10` and that is stored at say `0x7fff62a8b`. If your function is declared as `void change(int* p);` and you call it with `change(&amp;x)` (passing in the address of x), inside that function `p` is now equal to the address `0x7fff62a8b` which holds the value. Modifying that value will also modify the value of `x`, because the address of `x` has never changed, just the value I'm that memory location.
Yes, exactly, I’m getting confused. I am using a book based upon K&amp;R, what are the philosophical differences between K&amp;R and ANSI - and how could you tell that this was the case ? 
But thank you, explaining that *p is used two different ways is exactly where the confusion crops up. So thank you for flagging that. 
Awesome ty 
No problem. And technically you aren't passing by reference. You're still passing a value, that value just happens to be a memory address
Ty
The differences are not thathuge (ANSI C is based on K&amp;R C after all) so you'll learn them quickly. Probably the biggest difference in syntax is how functions parameters are declared: /* K&amp;R C */ double sum(a, b) double a, b; { /* ... */ } /* ANSI C */ double sum(double a, double b) { /* ... */ } And a few things in ANSI C don't exist at all in K&amp;R C, such as `void` pointers.
int is implicit in K&amp;R C, most modern C compilers will still allow it, but main should have been declared int. change since it is not returning anything should be declared void.
Yeah. If you ask me, it would make much more sense to declare a pointer to an int x as int&amp; x;
Ty exactly 
Awesome ty 
Thanks so much ! Ty !
Ty 
Ty 
&gt; I found that on my machines it took an enourmous number of iterations before inline was measurably faster, and the difference was very small. It is good that you did a micro-benchmark, but the conclusion is not that straightforward. With an access pattern like yours, the computing time is probably dominated by cache misses, not by function calls. In addition, if you switch the order of bsearch and your BinarySearch_int, you may find that bsearch becomes a little slower. This is also caused by the cache behaviors. If you want to see the effect of function calls, a classical example is qsort vs std::sort (or your own quick sort). You often see a big performance gap.
Thanks, this is good information. I agree its not conclusive, I did try alternating the order and didn't notice a significant difference. Is the difference between std::sort and qsort only the function pointer?
Potentially different sorting algorithms too.
EMACS is written in Lisp
That confused me for a long time. I don't get why they don't use &amp; to define a pointer too. 
&gt; I did try alternating the order and didn't notice a significant difference. On my machines, it is a minor but consistent difference. &gt; Is the difference between std::sort and qsort only the function pointer? Primarily. You can roll your own quick sort. Typically, a textbook implementation will be slightly slower than std::sort, but will be a lot faster than qsort.
It's because the declaration syntax of C is *type expression* where *type* is some scalar type and *expression* is an expression involving the variable you want to declare that has *type.* So if you write `int *x` you should understand this as “declare `x` such that `*x` has type `int`.”
That makes sense, but the convention is to write int* x; :(
According to the designers of C the idea is that a variable declaration should look similar to its usage. For example, consider the declaration `int x;`: it means that `x` is an `int` and you can it anywhere where an `int` is expected. Similarly, `int *p;` means that `*p` is an `int` and you can use `*p` when an `int` is expected. I'm not convinced that it's a good idea, but at least it's not completely arbitrary.
&gt; but C doesn't have pass by reference, though using pointers as function parameters is often incorrectly called that I'd say it is correct to call it that. Pointers are references. The question is just if it is correct to say that an object is "passed" to a function when not its value but a pointer to it is passed. But the standard uses the verb "pass" a few times in that sense, for example in 7.11.1.1.3 ("Other implementation-defined strings may be passed as the second argument to setlocale"), or 7.22.5.4 ("When the same objects [...] are passed more than once to the comparison function [...]"). C++ has created the misconception that pointers are not references because it added a language feature also called "references" in addition to "pointers" similar to C's pointers.
Ehem... no? All major style guides for C request you to write `int *x;`. Writing `int* x;` is something C++ programmers who want to pretend that the asterisk is part of the type name write.
That's one way of doing it, but in my experience "int *p;" is the most common convention to avoid people thinking that a declaration like "int* a, b;" is declaring two pointers, when in fact b is just an int.
I like to think of C declarations this way: `int *p` means that the type of `*p` is `int`.
Read Ted Jensen's Tutorial on Pointers 
Thank you !
Thank you 
Thank you 
The difference between pointers and references is that pointers require explicit syntax in order to access what they point to. In other languages, we use the word "reference" to remind ourselves that different variables might refer to the exact same object, and any mutation might be visible in unexpected parts of the program. In C, it's easier to see when values are independent, because any dereference must be explicit. As long as it's not being dereferenced (or passed to a function), a pointer can be thought of as just a scalar, whereas a reference can grant access to anything without any special syntax.
I’m one of those people who would just write `int * x`
What you're confused about is that the star operator is overloaded. When it's used in type declarations, it means pointer, and it's the only pointer "operator". When you're talking about variables, there are two operators, star and ampersand, star goes through a pointer (which we call a dereference) and ampersand gives you a pointer to the variable. It may be clearer to write the stars right next to the type like this: int* var; //pointer to int float** bar; //pointer to pointer to float the problem with that is that when you declare multiple variables, the stars are only applied to one variable, ie int* var1, var2; only the first is actually a pointer, the second is a regular int, if you want do declare two pointers, each needs a star, which is why we usually write it next to the variable name: int *var1, *var2; //actually two pointers so the thing to remember is that when a star is after a type, it means pointer, when it's not it means "access the variable at this address" 
You need to mark message as extern in the assembly as well. ``` extern message message: db etc... ```
You have to let the linker know the symbol is there. Adding `global message` above `message:` will do the trick by telling NASM to store it as something that the linker can use for other object files. Also, string literals should be placed in the `.rodata` section as they are not meant to be modified.
thankyou for your response. I changed my nasm code to this section .rodata global message message: db "hello world" db 0 but i still got the same linking error
thanks for your response. i tried changed my nasm code to this: section .rodata extern message message: db "hello world" db 0 but i still got the same error message. Also tried using "global". also same error
thanks for your response. i tried changed my nasm code to this: section .rodata extern message message: db "hello world" db 0 but i still got the same error message. Also tried using "global". also same error
Well, this seems to work: &gt;section .data global message message: db "hello world", 0 and the C program: ``` #include&lt;stdio.h&gt; extern char* message; int main(){ printf("content is&gt;%s&lt;\n", (char *)&amp;message); return 0; } ``` And combining them: ``` nasm -felf64 -o msg.o msg.s gcc -g3 msg.o test.c ./a.out ``` 
wow! i tried this on ubuntu and it really works! But it seem didn't work on Windows. :(( BTW what is the option "-g3" is for? I never tried it.
On windows you'll probably need an underscore in front of the message symbol in the assembly file, then use/export that.
LOL! It works now! Hahaha! Thankyou very much innocentkrista and other for your help. Very appreciated! :D
I fully agree with this.
I'm not so sure that's correct. In C, an object's lifetime is defined determined by its storage duration. Only objects with static storage duration (and thread storage duration, for a single-threaded program) exist for the lifetime of the program. This object has automatic storage duration, so its lifetime ends at the end of the scope in which it was declared.
Indeed; The name `qsort` is quite a misnomer: There's nothing stating that it has to be implemented as a quicksort.
I put your code in the Compiler Explorer [see here](https://godbolt.org/g/Qhsqmc) and I have the feeling (not entirely sure since I am not that well-versed in x86 assembly, please do check it yourself!) that since you are performing a binary search on a list of numbers that always contains them, that both GCC and Clang are able to optimize away the whole binary search routine, and just copy values over to the `found` array.
And in C++ std::sort()'s complexity requirements mean it *can't* use quicksort.