Proof or you're full of shit.
As I showed above, every implementation of C has a finite limit on its memory size. Now given an implementation of C, pick a Turing machine that writes to more cells on its tape than the memory limit of this C implementation. The tape of this machine does not fit available memory and thus cannot be emulated.
I don't believe that having access to an infinite amount of memory is a requirement for something to be Turing complete. Specifically, a machine only has to emulate a UTM in order to be considered Turing complete, and I do not believe that the definition of "emulate," in the context of computational theory, requires meeting or exceeding the abilities of the original. Even if I'm wrong about that, I would be surprised if the C standard itself requires these limitations. I suspect that they are merely allowances for the constraints of our physical reality. But I don't have a copy of any C standards handy so I can't check. Either way, it would be trivial to purport the existence of a C which is compiled without those limitations, which while silly would make it comply with your requirements. Which, by the way, are silly. A programming language being compiled to run on real physical machines (and having built in limitations as a result) should not be enough to consider it Turing incomplete. The only reason I can see for insisting on using such a definition is to win points through pedantry.
I just checked my C reference book. SIZE_MAX is defined in limits.h and can therefore be changed. I can't say with certainty but I imagine they are therefore not part of the C standard. Either way, if you had a machine with infinite memory you could set SIZE_MAX infinitely high, which would satisfy your requirements which (correct me if I'm wrong) makes you mistaken.
The warning is correct. `scanner` is declared as returning `char*`, but does not return anything.
You don't have a return statement in your scanner() function
Speaking of returns, your function scanner() doesn't return anything. The prototype char * scanner(); suggests that it returns a **char***, but it doesn't. You probably meant to put this at the end of scanner(): return c; Finally, the warning means the following: &gt;control reaches end of non-void function means that it is possible for the function to end without returning any data back to the caller. Since scanner() is non-void, that is, it is declared to return a **char***, it is expected to actually return a value.
I added that but it's stuck after that.
after adding return c, it's stuck. Any ideas? no warnings given.
You can even do: char array[20]; unsigned i = 0; for (; i &lt; 20; array[i++] = 'c');
What is stuck?
You're not nul-terminating the string.
OpenGL doesn't have a "language", I see this type of stuff asked all the time. OpenGL is a cross-language API that provides the ability to render vector graphics. The API has very minimal changes between languages (different versions of OpenGL will have different APIs of course), which means that you can implement anything you see in an OpenGL tutorial in C, or any other language you want that has OpenGL API support. If you don't know how to implement the OpenGL tutorials in C, I wouldn't start with learning C by learning OpenGL at the same time, that's another whole can of worms to open up. Learn the fundamentals and basics of C and then go read the OpenGL tutorials, it will benefit you a lot. I'd recommend the ole reliable [K&amp;R](https://en.wikipedia.org/wiki/The_C_Programming_Language) to learn the fundamentals of C, and then for OpenGL tutorials I'd recommend [https://learnopengl.com/](https://learnopengl.com/) as it explains things quite well and gives some mid-level insight into each topic, and is a good starting point to dive deeper into each topic on your own if you so wish.
I believe that you can say \`sizeof(char\*)\` implies a C can only run on a finite machine. And r/FUZxxl whole point was to use pedantry to show the unrealistic nature of of OP's pedantry. Of course OP pointed out himself that the limit was theoretical, not realistic, so maybe this whole discussion is a big, stupid overreaction.
in header file 'extern &lt;type&gt; prime_number'. and in one c file &lt;type&gt; prime_number. the included files are placed in both c files where both define the symbol prime_number. when these two files are linked together the symbol is there twice... include guards only help against multiple includes in the same compimation unit.
Just take a couple of days to figure out the basics of C++ classes, strings, I/O. Most OpenGL resources that use C++ are really only sticking to the basics of the language. I can recommend [LearnOpenGL](https://learnopengl.com) to that end.
I believe that sizeof reports the size of a specific type (int, long, etc.) on that machine. There's no reason you couldn't have finite variable sizes on a machine with infinite memory. Even so, the existence of sizeof doesn't mean you can't run C on a machine with infinite memory. I don't know that the C standard has a return type to indicate infinity, but that shortcoming seems trivial to overcome.
So constant defines of arrays cannot appear in header files? This same style of compiling has worked on Pelles C which is why I am a bit confused. Is it just the way the GCC toolchain compiles stuff together?
The problem is you've *defined* this array in a header file, when should have *declared* it instead. Headers are copy and pasted wherever they're included, which means the definition is in multiple places. Put the definition in primes.c (or wherever you deem appropriate) and only have a declaration in the header (`extern const uint64_t prime_count[64];`).
yeah it works this way. you have to declare it as extern in the header file which defines the symbol but won't reserve an address for it. it's like declaring functions these are extern implicitly. exter is declaring a variable not extern defines it.
I'm not aware of good resources that restrict themselves to pure C, but is there any specific reason you're avoiding C++? Between library support and resources for help, there's a lot to be said for not swimming against the stream, and C's level of abstraction is going to make dealing with the math more painful than it needs to be.
Thank you for the answer. I have okayish knowledge of c and I have already finished k&amp;r book. For some reason I find c++ and generally objective programming very difficult to grasp. Sorry for poor English.
OpenGL is programmed in C so using OpenGL with C isn't really swimming against the stream. &gt;C's level of abstraction is going to make dealing with the math more painful than it needs to be. I assume by this you mean the fact that there is no operator overloading in C, which doesn't allow you to use the syntax `model * view * projection` and instead you must use `mat4_mulN(dst, matrices[], len)` which is hardly swimming against the stream.
If you're a long-running program and you no longer need certain memory then sure, by all means, free it. But if, for instance, you're `grep`, then you can (and do!) get a significant speed boost by not freeing anything when you exit.
Ya I figured that out from /u/VDRAm's comment from above, it works now. I guess the other C compiler's I use don't care about defined arrays inside headers!
When I enter a string it doesn't stop even after pressing enter.
what does that mean? \0?
That's because you're checking the input against `EOF`s and inputting newlines. Try changing the `EOF` to `'\n'`.
You can't have infinite memory if \`sizeof(char\*)\` is finite.
I forgot to mention that the subset also doesn't define `uintptr_t` nor `intptr_t`--types which are not required to exist. Basically, the Turing-complete subset would exclude programs that try to treat pointers in any fashion as integers. What programs in the Turning-complete subset would behave differently from how they would behave on a more conventional compiler, beyond the fact that neither memory allocations (nor any other operations, for that matter) on the non-Turing-complete implementation would be guaranteed to succeed?
I might have a bit of an unpopular opinion, but I think if you want to really learn and understand object oriented programming you should learn Java. Don't get me wrong, I fucking hate Java and if you learn it well you probably will too. But, there isn't a better language (in my opinion) that offers clear object oriented design and principle better than Java. Once you have the hang of how OOP works, then you ditch Java for way better implementations such as Python or C++.
Of course you can. You can't store an infinite number of char pointers if sizeof(char*) is finite, but that's a very different thing than not having infinite memory. Just like using a limited subset of integers for any purpose doesn't make the set of natural numbers finite.
yes
Yes, [Anton's OpenGL 4 Tutorials](https://www.amazon.com/Antons-OpenGL-Tutorials-Anton-Gerdelan-ebook/dp/B00LAMQYF2/), the book uses C99.
`0xffffffffffffffff`th server. We already have enough communities. Why is yours different? Why should people join it?
&gt; using OpenGL with C isn't really swimming against the stream. Of course you *can* do all of this in C (or your favorite language), but committing yourself to working at the lowest level should probably be done for good reasons. Just because something has a C API doesn't mean C is the best tool for any given project. Nor does it mean C++ is, but the fact that most of the learning materials I'm aware of use C++ code and leverage C++ libraries (including your link?) seem like compelling reason enough to at least spend a day or two to learn the basics.
Why not participate in one of the myriad other Discord servers other “helpful” people set up?
Thank you!
When you see an object in the C++ tutorials, it's pretty trivial to recreate in C. Lets take a little from the [camera class](https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/camera.h) from the learnopengl tutorials and port it to C. First we simply take all the variables declared inside the `public` portion of the `Camera` class and put them inside of a struct. (I recommend [CGLM](https://github.com/recp/cglm) for a C 3D math library by the way) typedef struct { vec3 position; vec3 front; vec3 up; vec3 right; vec3 worldup; // euler angles float yaw; float pitch; // camera options float movementspeed; float mousesensitivity; float zoom; } Camera; Then for all the functions inside of the `Camera` class, we take those and recreate them in a procedural style just like you do anything else in C. So for example, the constructor of the `Camera` would look like: Camera camera_init(vec3 pos, vec3 up, float yaw, float pitch) { Camera cam; glm_vec3_copy(pos, cam.pos); glm_vec3_copy(up, cam.up); cam.yaw = yaw; cam.pitch = pitch; update_camera_vectors(&amp;cam); // initialize rest of the variables, cam.zoom etc return cam; } void update_camera_vectors(Camera *cam) { // Calculate the new Front vector cam-&gt;front[0] = cos(glm_rad(cam-&gt;yaw)) * cos(glm_rad(cam-&gt;pitch)); cam-&gt;front[1] = sin(glm_rad(cam-&gt;pitch)); cam-&gt;front[2] = sin(glm_rad(cam-&gt;yaw)) * cos(glm_rad(cam-&gt;pitch)); glm_normalize(cam-&gt;front); // Also re-calculate the Right and Up vector glm_cross(cam-&gt;front, cam-&gt;world_up, cam-&gt;right); glm_normalize(cam-&gt;right); glm_cross(cam-&gt;right, cam-&gt;front, cam-&gt;up); glm_normalize(cam-&gt;up); } This is pretty basic stuff in my opinion, and this isn't even related to the OpenGL portion of the tutorials, which will work in any language pretty much the same way. Hopefully this helps a little bit, there's not much more I can add I'm afraid.
I have, I was active in a specific one for a long time actually, it was the only normal one out there, and management helped it to shit.
For one, no corrupt management, As you can read below, I've found only a single C++ server which had a good experience for me, and management ruined that, I even met up irl with some of the people from it.
OpenGL Super Bible is great. &amp;#x200B; [http://www.openglsuperbible.com/](http://www.openglsuperbible.com/)
I think what he's getting at is OOP concepts are in the way of learning OpenGL due to their complexity. He is looking to learn OpenGL without that distraction.
K&amp;R is extremely outdated. 21st Century C is good.
This doesn't answer my question. You are not advertising your community, you are merely saying you had bad experiences with other communities. There is no selling point. What I got from your "ad" is that you didn't stick to a server's rules and got so pissed you created yours. **Basically, you went "Whatever, I'll make my own server with blackjack and hookers"**. I don't care if I'm right or not, I'm simply pointing out the flaws with your ad. You should improve it by addressing those flaws ASAP. Good luck.
Bill found the fifo code, but not the pack.lib. He's looking into this all now. He's not sure its possible to go much further without the pack.lib.... :-&lt;
Part of the forms is developing the PHP (or Python, depending on site) back-end to process data and submit it to a database. Theoretically I could do it with Java or C# if those were the preferred languages, so I fail to see how the back-end there is different. While there *is* an element of front-end design, there's still logic in the front end for processing the data before it's submitted, and even more logic in the back-end to process the submission.
i am not sure what your point is here, and how it is related to our earlier conversation. Could you elaborate?
Maybe you should join, participate in some discussions, you'll know why this server is superior to others.
I mean what you describe as "undefined" behavior is exactly how C++ compilers implement object static casts for a wide set of cases (no virtual functions, no multiple inheritance). So, it is not particularly interesting what the standard has to say about type punning. There is a chance of error in the case of compiler optimizations (mostly related to storing the result of a dereference in a register and later dereferencing the same address with a different type; the compiler assumes the value is already in the register), but a pragma, marking the variable as volatile, or a compiler flag will prevent the error.
The compiler don't complain but I would. I would prefer to keep assignment in the body of the while loop.
Linus Torvalds is a freak of nature. Don’t be dense. OP, if you’re hanging around still, implement your own version of the original Unix commands. It’s a good bridge to systems programming. [A subset of these, perhaps. ](http://man.cat-v.org/unix-1st/1/)
FYI this a C subreddit, not C++ , they are very different languages. Use /r/learncpp instead. That being said, your switch statement has only a default case, so it “fails” every time. Look into case statements.
/r/cpp_questions is more active for c++ questions but this kind of question belongs in /r/unrealengine4 though the issue is definitely with your switch :)
Just FYI: You returned a stack variable that will be out of scope for the caller. These kinds of bugs are hard to diagnose for new developers. Camera camera_init(vec3 pos, vec3 up, float yaw, float pitch) { Camera cam; glm_vec3_copy(pos, cam.pos); glm_vec3_copy(up, cam.up); cam.yaw = yaw; cam.pitch = pitch; update_camera_vectors(&amp;cam); // initialize rest of the variables, cam.zoom etc return cam; }
&gt;K&amp;R is extremely outdated. I fully agree. I don't know why anyone would recommend K&amp;R C to a beginner. It's interesting from a historical perspective, but it was literally obsolete 20 years ago when the C99 standard was published.
Sadism.
What do you mean? I think you have a misunderstanding of how the stack works. When the camera is returned, it's returning a copy of that camera, I chose not to use malloc here for demonstration purposes, but nothing "goes out of scope".
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Oh hi mehodin
You’re gonna need to extract information digit by digit using char and fseek functions. And then put them in a variable.
huh I didn't know that good to know
&gt; What do you mean? I think you have a misunderstanding of how the stack works. When the camera is returned, it's returning a copy of that camera, I chose not to use malloc here for demonstration purposes, but nothing "goes out of scope". Either you don't understand how the stack works, or you have a useless init function. Which is it?
The init function is not useless, it's creating a valid camera and returning a copy of it... whatever you choose to do with that copy is up to you. You realize you can create an entire application without ever using dynamically allocated memory, so that means no calls to malloc at all. I'm not so sure why you think you must malloc something to use it.
&gt; I hope you realize that you can create an entire application without ever using dynamically allocated memory, so that means no calls to malloc at all. Only the simplest programs do not require heap memory. Stack space has always been a precious resource, and, even on today's computers, it still is. &gt; I'm not so sure why you think you must malloc something to use it. As I said before, I don't know anything about OpenGL. However, I've been programming in C for over 20 years, and I cannot recall a time when I released production code for a work related project that didn't require dynamically allocated memory. That may also be due to my career field, which is scientific programming. If a useful program can be written without dynamically allocating memory, I say go for it. However, one of the primary reasons for using C is its ability to dynamically allocate and free memory. Although I am very skeptical that there is any widely used graphics framework in existence that doesn't require dynamically allocated memory, I'll take your word for it.
I'm very confused with your comments. How do you think returning a copy of a local variable will go out of scope? Are any of the inputs to the function pointers?
&gt; I'm very confused with your comments. How do you think returning a copy of a local variable will go out of scope? Are any of the inputs to the function pointers? Strictly speaking, C always uses a pass-by-value semantics, even though pass-by-reference is a common term. In the case of pass-by-reference, you're still passing by value, but in that case, the value is a pointer to a memory location. With regards to dynamically allocated memory, how would you know what is happening with this line? update_camera_vectors(&amp;cam); I understand that the commenter was only showing sample code. However, in my experience with C, allocating any custom type on the stack inside a function call and then returning it is just inviting trouble. If any object is complicated enough that you need a custom allocator function, then chances are good that memory is going to be dynamically allocated somewhere in that process. For C, a much more common—and potentially safer—paradigm is to make sure you have a storage structure properly allocated, whether on the stack or the heap, get a pointer to it, and pass that pointer to an initialization function. Anyone who's ever worked with the Windows API is very familiar with this paradigm. I still love programming in C, but I also love C++'s smart pointers.
Who says you'd store it all on the stack? I think you need to read about the [data segment](https://en.wikipedia.org/wiki/Data_segment). OpenGL is most definitely using `malloc` underneath, but that doesn't mean your application has to. The heap isn't useless by any means, and I'm not advocating against it, but not every single thing needs to be malloced.
**Data segment** In computing, a data segment (often denoted .data) is a portion of an object file or the corresponding virtual address space of a program that contains initialized static variables, that is, global variables and static local variables. The size of this segment is determined by the size of the values in the program's source code, and does not change at run time. The data segment is read-write, since the values of variables can be altered at run time. This is in contrast to the read-only data segment (rodata segment or .rodata), which contains static constants rather than variables; it also contrasts to the code segment, also known as the text segment, which is read-only on many architectures. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I don't see the relevance of what you've posted. You don't declare any static or global variables. What is the point of posting this?
First begin with this playlist [https://www.youtube.com/watch?v=W3gAzLwfIP0&amp;list=PLlrATfBNZ98foTJPJ\_Ev03o2oq3-GGOS2](https://www.youtube.com/watch?v=W3gAzLwfIP0&amp;list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2) and along with that you can follow this book form a website [https://learnopengl.com/](https://learnopengl.com/)
Just start with python I was also a student a and i was a in same situation like you are in right now. So One of the most important thing for me in the the programming that i want to automate most of my computing tasks.Which is somewhat a pain taking job in C lang. so i choose python3 as my first programming language . I think today i took a good decision becoz with python i easily get one level up form basic and try out new things and most importantly one you are comfortable and confident with programming then you can try your hand in any language becoz untill then your brain start getting the things whats going on . After spending few months with python your brain start becoming more and more curious in getting the same thing in other language.
Every five seconds, someone asks this on reddit. Every 10 seconds, someone on reddit responds with the same answers.
I agree with you in that, but it's always great if he has the opportunity to make something that he enjoys into a job and get paid for.
&gt;Only the simplest programs do not require heap memory. Stack space has always been a precious resource, and, even on today's computers, it still is. You're implying that a large application couldn't simply have self containing modules that are stored on the data segment, and that the only two available places are the stack and heap.
I never implied any such thing. You never declared any global nor stack variables. Again, I ask, how is this point relevant to this thread?
In bed so I can’t really explain what you are wanting to know, but the spacing &amp; brackets are wrong I both examples
In short, when you have a statement that expects a block, but you omit the curly braces, then only the next immediate statement is captured. So this: ``` if(x &lt; 5) a = 3; b = 5; ``` is equivalent to: ``` if(x &lt; 5) { a = 3; } b = 5; ``` Which is why it's convention to use the indentation to try and signal to the reader what the scoping is. Like so: ``` if(x &lt; 5) a = 3; b = 5; ``` However, in C, the indentation doesn't make a functional difference to your code - it's strictly aesthetic, but that doesn't mean it's not important.
This is how the compiler sees your code with explicit braces added: int main() { int a, b, total = 0; scanf("%d", &amp;a); for (b = 1; b &lt;= a; b++) { if (b % 7 == 0) { total = total + b; } } printf("%d", total); return 0; } int main() { int a, b, total = 0; scanf("%d", &amp;a); for (b = 1; b &lt;= a; b++) { if (b % 7 == 0) { total = total + b; } printf("%d", total); } return 0; }
After replacing EOF with \\n and adding \\0 to end of the string still it doesn't work. Any Ideas?
Help Please!
Modern operating systems don't allow processes to view all of a PC's memory like in the early days of IBM PC's. The memory is in the same place every time in the little virtual world of your application.
These are stack variables in main, so they will have the same addresses every time. When memory is allocated off the heap with malloc(), the variables can be in different locations every time (in theory, in reality a small program like this one might end up allocating off the same slab and get the same addresses every time due to how the virtual memory subsystem and allocator work under the covers). Additionally, stack variables in other called functions can have different addresses every time as well, depending on how deep the stack frames are. If you define a function a() with a variable, call a() from main(), and then call a() from a() again, both invocations of a() will have var at different memory addresses.
I don't believe it should be, and it isn't on this macos computer, I get different addresses every time. OSes do address space layout randomization for security purposes. Your program binary defines the layout of the program in memory, but it's up to the OS to map it into virtual memory.
Every pointer must have a unique numerical representation, thus there is an upper limit on the amount of objects an implementation of the C programming language can support. Given that the size of each object is again bounded by `SIZE_MAX`, C only supports a finite amount of memory.
For some compilers it only does aslr if you enable it. man gcc /pie
I've only been able to find two occurrences of obsolescence in the book (K&amp;R2). Care to share the "extremely" part?
I'm 14, and not that into C, but I've been programming for a couple years now.
If I am the reviewer and see something like that i always imply to write such one-liners in multiple lines. \- it is easier to read \- easier to debug \- easier to maintain Especially since assembly output looks the same. Formulas: int x = a + b \* c, i prefer to split it up x = a + b, x = x \* c for ease of debug and follow complicated calculations. Multiple one line conditions? if ( condition &amp;&amp; condition || condition) When you debug, and it is true, which condition was true? Same assembly you can get by condition1 = a &lt;2 condition2 = x &gt;0 condition3 = c != 10 if (conditoiin1 &amp;&amp; conditon2 || condition 3) Above examples are pretty simple, but in typical commercial code-base complexity rise logarithmly up.
Modern CPUs have security features and a defined hierarchy, both dependant and independant of the OS. For the "bare-metal" security, x86 CPU's have rings, going from -2 to 3: RING 3 Userspace 2 Drivers 1 Drivers 0 Kernel -1 Hypervisor -2 System management mode (SMM) In a nutshell (though there are exceptions) SMM has access to all memory, the Hypervisor has access to all but SMM memory, the kernel has access to all but Hypervisor and SMM memory, etc. Your programs are running in ring 3. Additionally, any decent OS in 2019 will implement memory protection mechanisms, one of them being virtual memory. Basically, if you're running several programs: Address Process 0x0000-0x0fff Virtual memory 0x0000-0x0fff for PID A 0x1000-0x1fff Virtual memory 0x0000-0x0fff for PID B 0x2000-0x2fff Virtual memory 0x000-0x0fff for PID B ... Basically, each program has its own little world where it can use all the memory it wants. It cannot access the rest of the memory. Well, that's what we want anyway, because there are multiple ways to access the rest of the machine's memory.
:wave: who dis
Try /r/cpp for c++ related questions.
You have a lot of questions! Google is excellent at answering a lot of questions!
Unrelated to C and this sub. /r/programming
For some reason r/programming won’t let me add a text post so I came here, sorry for any inconvenience
Thank you! Like I said I’m very new and I’m just trying to ask anywhere, this is my first time around this so thank you for helping
Please someone help me with option 2. Display book information , if it works then I can implement options: 3,4,5,6.
Yes, I have been googling but I also enjoy being able to almost talk and discuss with people about it as I don’t really know anyone who’s into programming, but my research continues! Thank you! And sorry if it was an inconvenience
I have already addressed these points, but again: the limit of SIZE_MAX only exists because it's impossible to physically implement a machine with infinite memory. Given infinite memory, you could have an infinite number of pointers. That should be obvious but since you said "every pointer must have a unique numerical representation" I guess it needs to be explicitly stated? And, again, if we're positing the existence of a machine with infinite memory, it would be trivial to set SIZE_MAX to ∞.
Regarding minecraft (while this is offtopic, please bear with me), the team at Mojang started a while back rewriting minecraft in C++ for perfomance. The game is know as Minecraft: Windows 10 Edition and Pocket Edition. This is one of the reasons why there still isn't feature parity between the two main version (C++ vs Java) and why the Pocket Edition isn't as modable as the Java one.
Ahhh I see, I read that somewhere but I wasn’t sure. So if they wanted to in theory could they make the c++ version “better” the the java edition? And does that go for any game?
Also thank you!
The C++ edition is faster than the Java edition, by miles, especially on lower end hardware. And it does go for a lot of games. But now a days a lot of games are written in C++, especially the big ones. The disadvantage to games similar written in C# like the ones in Unity is the garbage collector. It is unpredictable and you don’t know if it will free memory correctly. This is way managing memory is best for the machine, but not the human.
I see that makes sense, thank you
if you recommend a sub you should chose the right one r/cpp is more about advanced discussions and concepts. They usually send simple questions away just like you do. /r/cpp_questions is the place to go for simple quesitons
Alot of "wrong sub" comments. I get it, it's the wrong sub, but that doesn't help. Educate, then redirect. C is a bare bones low level language, it's extremely simplistic which is why it rules embedded systems for example. Also due to it's simplistic nature, it produces very little overhead. However, C doesn't handle abstraction in a very approachable way. There is alot of reinventing the wheel and memory problems. This is where C++ came in. C++ is a higher level language than C, which is why it's not recommended for embedded systems or driver coding for example. However, C++ extended C into a massive OOP (I'm aware of data driven paradigms, but I won't go into that) world. C++ is close enough (or low level enough) to the machine where it can be highly optimized on a cpu/memory/gpu consumption level for certain hardware, and it is high enough so you can have C# or Java type abstraction. Which helps alot in video game logic. There are more reasons why it is chosen for gaming. Technically, you can build a game in anything. The same way you can hammer in a nail with a spoon if you keep at it. Doesn't mean it's the right tool for the job. This, however, is a more C++ question and the appropriate sub will be able to help more on this :)
This helps a lot! and thank you for being so kind! It really means a lot.
Please someone help on this. I am stuck from 1 weekend on this.
Incidentally, if you really want to know the reason that Minecraft was written in Java is because Notch wanted to learn Java and he did so by writing Minecraft.
ANSI C by dennis ritchie. It's the best book for C on the planet but it's not at all easy. If you cover it completely with exercises you can play with interviewers. I have been trying to complete this book from 1 year that's how much it is difficult but the quality of content is on par in comparison to others.
That’s interesting, way to dive right in
SIZE_MAX is an integer constant that can be used in programs. There are three legal representations for integers in C, all of which only admit finite values. Thus, SIZE_MAX must necessarily be finite.
K n King C programming, a modern approach. Its 700pages of excruciating detail though. You'll definitely finish the book, *knowing* C.
Essentially anything can be written with any language. That said, different languages obviously have strengths and weaknesses. Choosing the wrong language, and the resulting complications, is frequently cited as the root cause of projects going wrong. The actual choice is normally a combination of what languages the developer is familiar with, the perceived advantages of the language, strength of supporting libraries and ecosystem, and what is trendy at the time. C++ is the standard for video games, there are some intrinsic advantages, but I would suggest that the biggest strength is the supporting libraries, ecosystem, guides etc. As for minecraft being written in Java. I suspect it was just what Notch knew so it was what was easiest for him.
Yeah. I am currently going through that book. For me it is much better than k&amp;r in most cases.
Thank you!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Having experienced it first hand, I understand that, I just disagree that this can be the issue here. &amp;#x200B; The code we have in the link is normal old mac code, compiled with an old Think C, that works well in old emulators. It just doesn't handle the files the OP gave, but recompiling it with '32 bits' probably won't change the fact that the code interpret the file wrongly.
when you use block statement like loops or conditions and if there is only one statement inside the block, it is ok if you don't use curly bracket . But if there is more than one line then compiler must know that lines uptill here are under this block so it is necessary to use curly bracket as to show a block .In the first program it wont give the same output as the second because you didnt use the brackets
Quick intro to virtual memory: [What a C programmer should know about memory](https://web.archive.org/web/20150305164701/http://marek.vavrusa.com/c/memory/2015/02/20/memory/)
Your indentation example code doesn't seem to be indented on my phone. I tried fixing it. if(x&lt;5) a=3; b=5;
Memory management can often be made most efficient by having code reuse "temporary" objects rather than constantly allocating storage, using it briefly, and freeing it. Building an object within a persistent space that will get reused, allocating a precisely-sized space for it, and copying it, can avoid the kinds of memory fragmentation that could result from code which tries to avoid holding anything longer than needed. While malloc and free would have the same issues as realloc if used liberally, the benefits of realloc are often not sufficient to make it more efficient than user-code approaches to avoiding memory churn.
Can you paste your code?
Oh iam sorry!! I searched c++ no cpp my very bad
thank you sorry
I thought maybe r/cprogramming was a blanket for all C languages my mistake! thank you
I re - read your comments. the reason I put this up was because this is the code copied directly from the book. the book in the section just before this exercise had us use case statements, though for this script for some reason the book provides this solution that "fails" instead of allowing me to choose a mount. thats where my confusion was. &amp;#x200B; i reposted in the /r/learncpp though! again thank you!
This is kind of platform-dependent. I work mostly with embedded systems with no MMU, which means that the address space is what it is. When I compile a program, I can look at the linker map and see the address allocated to each variable. It's also possible to create relocatable code that doesn't contain any absolute address references and so can be loaded anywhere in memory. And with an MMU, memory can be sliced up and reorganized so that it looks to the program like the same address space every time even when it's physically somewhere else.
Let me turn the question around. Why would they *not* be in the same location every time? By the way, you should use `%p` to print pointers, not `%u`, and you should always end a line of text with a newline, even if it's the last line of your output.
There is absolutely no problem with returning objects allocated on the stack. There is a problem if you return a pointer to an object allocated on the stack. &amp;#x200B; The line: &amp;#x200B; update\_camera\_vectors(&amp;cam); &amp;#x200B; simply calls the function with a pointer to the local cam variable, which makes the function able to change it in some way. No dynamic memory allocation needed.
What is the definition for float_bits?
[https://pastebin.com/5AqTHiWN](https://pastebin.com/5AqTHiWN)
 typedef unsigned float_bits; That's all it is. I could replace every instance of float\_bits with unsigned and, as far as I know, nothing would change at all. &amp;#x200B; Edit: Also, I updated my test to, in addition to doing a bitwise comparison, check if both numbers were NAN. If they were, that also counted as a success, even if the exact bits were not the same. Doing that, I tested on literally every float from 00000000 to ffffffff and it passed, so my code works. It's just this bizarre memcpy error, which apperently only affects numbers with bits that evaluate to NAN?
Note that you are wandering into undefined behavior territory here - sizeof(unsigned int) is not the same on every platform. Since floats are always 32 bits, it's best to use a fixed width type - include &lt;inttypes.h&gt; and use uint32_t to get a guaranteed 32 bit unsigned integer.
The code fails at if(accessionNo!=0 &amp;&amp; (b\[i\].accession\_no == accessionNo)), why? even when correct accession\_no is entered?
Try Computer Systems by R. Bryant and D. O’Hallaron. Most subjects you mentioned are covered in different chapters. Couldn’t find a better book covering so many concepts with such depth. A good C primer would be K&amp;R taking into account the ANSI C standard changes that were established long after the book was written.
This discussion has become circular. The only reason these values are integers (and thus finite) is because all real machines are finite. An infinite machine would have a variable type to express infinity. Additionally, you haven't responded to my claim that being able to address infinite memory is a requirement for Turing completeness. I don't believe that it is because I don't believe that the computer science definition of "emulate" requires it.
It looks like you're still waiting '\0' to break out of the while loop in scanner(). If I change that to '\n' it works as it should for me.
I whipped up a something similar to your sample, but using no typedefs and plain printfs. The memcpy is working fine for me, but one problem I did run into is that ~~if you try to pass a floating-point argument to a variadic function like printf, it gets cast to a `double`~~ on x86_64 (and probably many other platforms), floating-point arguments are passed via floating-point registers, so if you tell a variadic function printf to read an integer argument when you passed it a floating-point argument, it will read from the wrong place and get the contents of the next integer argument, or garbage. I was trying to do `printf("%x\n", float_value);` and kept getting random results. Using `"%a"` is not helpful either, because like `"%f"` it still evaluates the float and prints `nan`. The correct way to use printf to print the hex bits of a float is to do `printf("%x", *(unsigned int*)(&amp;float_value));`. Once I did that, I got `7fb00000` as I expected. (edit: figured out the actual cause of my own problem) Have you tried using a debugger to inspect the contents of memory?
What's your show_float function? AFAIK casting a float to an int is going to convert it instead of giving you the same bits as an int.
You don't have to use a memcpy here. Usage of ```#include &lt;stdint.h&gt;``` is recommended if you are going to be manipulating hardware in any way. #include &lt;stdint.h&gt; float bitwiseEquivalentFloat; uint32_t twiceF; float twiceFloat; // You are manipulating a very specific piece of hardware in a very specific way, so you // need to make sure you are actually running on that hardware... if (sizeof(float) != sizeof(uint32_t) &amp;&amp; sizeof(uint32_t) != 4U) { // On some systems float can be 16-bits. exit(-1); } //for every possible float for (uint32_t f = 0x7fb00000U; f &lt; -1U; f++) { //create an equivalent float memcpy(&amp;bitwiseEquivalentFloat, &amp;f, sizeof(f)); // or *(uint32_t*)&amp;bitwiseEquivalentFloat = f; ... }
That does not appear to have worked. I got the following output: FAILURE Float bits before doubling: 01 00 c0 ff Float bits: 01 00 c0 ff float\_bits bits: 01 00 80 ff Original float\_bits: 01 00 80 ff &amp;#x200B; &amp;#x200B; This one kept tripping the failure, for a similar reason as the previous one. Both should evaluate to NAN, and indeed my code does what it's supposed to do and returns the float\_bits object unchanged. Somehow, though, it ends up being a different form of NAN from the float itself.
It turns on the msbit of significand, making it a quiet NaN... Maybe the memcpy is ok, but the processor flips the bit while passing it into show\_float().
Sorry typing mistake. in while loop it's \\n. Still it doesn't work.
Sorry it's codechef compiler problem. It works on gcc compiler.
show\_float was given by the book, and I didn't create it myself. The code is as follows: &amp;#x200B; typedef unsigned char *byte_pointer; void show_bytes(byte_pointer start, size_t len) { int i; for (i = 0; i &lt; len; i++) printf(" %.2x", start[i]); printf("\n"); } void show_int(int x) { show_bytes((byte_pointer) &amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;x, sizeof(float)); }
Can you also look at this - [https://www.reddit.com/r/C\_Programming/comments/btqdt2/library\_information\_system/](https://www.reddit.com/r/C_Programming/comments/btqdt2/library_information_system/). The problem here is also handling of dynamic string.
Thanks @/u/[blargh4](https://www.reddit.com/user/blargh4/) , @ajak and @dragon\_wrangler. You guys are a saviour.
If it was only while passing it into show\_float(), the test would pass. show\_float() is only called when a test fails, so that I can see which test it was. I added a few more while trying to figure out what was wring here, but if the bit does get quietly flipped it's happening earlier than that, else I'd have never put in the extra show\_float to see the bit get flipped. Regardless, is there a way to tell the processor not to flip said bit? Processor flags and the like aren't until a later chapter than the one this exercise is in, so I feel reasonably confident that whatever the solution is it can't be *too* arcane.
I don't know floating point well. man fenv might contain something. But I suspect this was a false lead :/
Hm. Out of curiousity, which OS/cpu arch/compiler are you using? On x64 Linux with gcc, printing `f` and `bitwiseEquivalentFloat` gives me the same value, which is what I would also expect (but there are some non-portable constructs here - AFAIK int is *usually* 32bits on modern machines but that's implementation dependent).
Ah... that could be it. I'm using a 32-bit Linux OS and compiling with GCC. I don't know the processor archtecture of this one, though, as it was lent to me (it's old, I can say that much). Let me bring this up to my other computer and run it there - 64-bit Linux, GCC, i7 4790k (though I don't know the architecture exactly, that is the model of processor. Sorry, hardware is not my forte.)
Rather than defining `true` and `false`, why not just `#include &lt;stdbool.h&gt;` (and use the `bool` type instead of `int` for Boolean variables)? That's been a standard part of C since 1999, or 9 years before Neo was born.
IIRC, all variables with sizes less than or equal to sizeof(int) passed to variadic functions are promoted to the next respective type in size (float to double, int to long, etc). The reason for this was support for c89's implicit function definitions. These conversations should take place regardless of architecture. Casting the float to a double in the variadic argument should be sufficient. Edit: this is not a response to printing float bytes, just the printf type conversion
Code which relies upon the sizes and representations of types will be non-portable, but implementations are required to specify the sizes and representations of their built-in types. The fact that code would invoke UB on implementations whose numeric types aren't as expected does not even remotely suggest that it would be "wandering into Undefined Behavior" on implementations whose built-in types' sizes and representations are documented as matching the code's requirements.
I wouldn't really expect 64bit and 32bit linux to be different here. Kind of at a loss for why this wouldn't work, based on my understanding of C and x64/x86 linux... Here's the test I'm using with an online compiler, not sure if I omitted some detail of your code: https://repl.it/repls/DryQuarrelsomePhysics
Reformatted for readability: int test_float_twice() { float bitwiseEquivalentFloat; float_bits twiceF; float twiceFloat; //for every possible float for (float_bits f = 0x7fb00000; f &lt; 0xFFFFFFFF; f++) { //create an equivalent float memcpy(&amp;bitwiseEquivalentFloat, &amp;f, sizeof(f)); //use float_twice on f twiceF = float_twice(f); show_int(f); show_int(twiceF); show_float(bitwiseEquivalentFloat); By the way, this would have been a good place for unions: // Assume float is 32 bits typedef union { float f; uint32_t i; } FloatInt; ... FloatInt fi; for (fi.i = 0x7fb00000; fi.i &lt; 0xFFFFFFFF; fi.i++) { // No need for memcpy, your float value is in fi.f ...
They are integers because the C language specification says so. That's why C is not Turing complete. I agree that you could alter the C standard to fix this, but then that is no longer C we are talking about. Also, note that with such a change, integers no longer occupy a fixed amount of storage and thus pretty much the entire language must change to accomodate.
And I define *Turing complete* as: A machine M is Turing complete if there is an always halting algorithm that translates any Turing machine T into a program P for M such that T halts if and only if P halts. This requires infinite memory: if memory of M is finite, we can decide if M halts by simulating it. If it does not halt, it eventually gets into a loop as there are only a finite number of program states and memory configurations. This can be detected. The halting problem is undecidable for Turing machines, so clearly a finite memory machine cannot be as powerful as a Turing machine. Can you give such an algorithm for C?
Thank you for the reply! I'm always really happy when people actually reply with good practices, and information, like you have. I'd also love to hear your opinion on something else, if you don't mind. Do you think that traversing a linked list would ever noticeably impact the performance of a program? I'm actually curious as to how impactful it is to use a linked list, instead of an array. It feels like I have to make a choice between memory, and speed in this situation. Either I malloc what feels like an absurdly wasteful amount, or I store each fd's data on a case-by-case basis, and spend a lot of operations just traversing to the right link.
Multi-threading.
Like any other struct y.mary=15; y.johnny=2; y.papa=0;
Threading.
How do i go about doing that? As i said, pretty new here lol
&gt; Why would they not be in the same location every time? Because other stuff is running on the computer and it's using memory, why would the addresses not change from one run to the other, especially between reboots? (I know the answer is virtual memory, just pointing out that you're not answering the question and only questioning its validity, dick move for a question this common) &gt; you should always end a line of text with a newline, even if it's the last line of your output What? That's so tautological. You should end a line... with the thing that makes a line a line? duh. Also no reasoning here. It's perfectly valid to not use newlines between prints, although you'd generally want to have a newline at the very end of your output so that you don't mess up the shell's interface, it's also not an iron-clad rule.
This question seems confused... is your question about structs? Packed structs? Bitfields? Cause you're mixing all three in this example... What are you trying to accomplish here?
The packed attribute and the bitfields don't really matter for your question. But I'm not totally sure what you mean with your question. There's a few possible interpretations. So I'll show a few things. (First, a quick assumption. I think you meant to do `typedef struct` so that the name of the type is `family` instead of creating an instance of it with that name.) You can initialize the struct like so: family y = { 1, 2, 3 }; Or using designated initializers: family y = { .mary = 1, .johnny = 2, .papa = 3 }; You can initialize using another instance: family z = y; You can modify any given member this way: y.mary = 4; Or assign everything at once with: y = (family){ 1, 2, 3 };
&gt; you can try to read memory from the SMM RAM (also called SMRAM), every byte will return 0xFF as a security measure Wouldn't it segfault? Or does that only happen when you try to write?
Well imagine you have this varibale void* vp; What can you assign to this variable so you can later on by casting (struct family*) into it, access the different fields?
My question is actually about casting.
... &amp;#x200B; I ran it in the online compiler and it worked. I guess this is a lesson about 32 vs 64 bit? Damn me, I am more confused now than when I started.
Type-punning isn't defined behavior in C. Only memcpy is defined.
Wow ... that's not clear at all from your original post. And I'm still not really sure what you're asking. A `void*` is simply a pointer that can point to anything, so you can do: void* vp = &amp;y; Of course, in order to do anything useful with this pointer you'll need to cast it back: family* fp = (family*)vp; fp-&gt;mary = 42; I'm not sure I'm answering your question, though. If not, please include everything about what you're trying to do so we have some context to work with.
Well, I'm not sure why you would, but you could do something like this: typedef struct __attribute__((__packed__)) { uint64_t mary: 4; uint64_t johnny : 4; uint64_t papa : 4; } family; int main () { family f; // create a local family on the stack void * vp1 = &amp;f; void * vp2 = malloc(sizeof(family)); // create a family on the heap ((family*)vp1)-&gt;johnny = 1; ((family*)vp2)-&gt;johnny = 1; } And again, keep in mind that you’ve made a bitfield, not a regular struct.
No problem at all, good luck :)
The set of integers is infinite, and I'm curious if it's actually part of a C standard (there's more than one) or if it's just an implementation detail. Do you have access to a copy of a standard handy? My understanding is that getting one is very expensive. I'll get back to you about the definition of a Turing machine in a bit.
He is doing hardware specific manipulations, so the behavior is defined... since he is the one defining the behavior (that's the whole point of C).
Depends on your platform. On posix-compliant OSes you can use the pthread api. Windows has its own API. OpenMP might be the easiest option if your compiler supports it.
&gt; The set of integers is infinite The C language doesn't use abstract integers. It uses integers represented in a fixed number of bits using one of two's complement, one's complement, and sign/magnitude as their representation. Given that the number of bits for each type is necessarily fixed, integers of each type can only represent a finite number of different integers. Given that `size_t` and `uintptr_t` are integer types, they can only represent a finite number of values, the largest of which is `SIZE_MAX` in case of `size_t`. &gt; Do you have access to a copy of a standard handy? Look for a document called N1570. That's the final draft of C11 which is identical to ISO/IEC 9899:2011 except for the cover sheet.
Platform-specific behavior is called "implementation-defined". "Undefined behavior" won't work if you change anything even if you think it's working now.
&gt; It uses integers represented in a fixed number of bits Yes, and the number of bits it uses to represent integers could be ∞. I found the C standard, thank you for giving me the heads up. I'm looking at http://www.iso-9899.info/n1570.html and under 5.2.4.2.1 [Sizes of integer types ] it says &gt; The values given below **shall be replaced** by constant expressions suitable for use in #if preprocessing directives. Also: &gt; Their implementation-defined values shall be **equal or greater in magnitude** (absolute value) to those shown, with the same sign. Emphasis mine. If I'm reading this correctly, an implementation of C is allowed to have an infinitely large SIZE_MAX, and the values given in the standard are expected to be replaced with values equal or larger to those given. ∞ fits this standard, so creating an implementation of C where SIZE_MAX is set to ∞ would not violate the standard. Obviously you would have to rethink some fundamental parts of the machine architecture to make it capable of handling a variable type whose size is ∞ but that's a question of machine architecture, not (unless I'm missing something) the C standard. I believe -- and again, correct me if I'm missing something -- that there is nothing in the C standard that prevents it from having infinitely large variables, but rather that current implementations of C use finite variable sizes because that's the reality they're being implemented within.
It's a toy example that isn't useful to a beginner. Why even bother with typedef variables at all if all you are doing is working with native types? I have never seen a production framework in C that didn't use pointers and dynamically allocated memory. I seriously doubt that OpenGL is pointer free. Allocating a stack object then trying to reference it after it goes out of scope is such a common rookier mistake. Showing a beginner a non realistic example isn't helpful.
And to add to my previous comment, another rookie mistake is to assume that a line like the following is safe. update_camera_vectors(&amp;cam); How do you know what's happening once you pass the address of that object to another function? Have you reviewed the source code? If you want to assume that the object being referenced by `&amp;cam` isn't being updated, at the very least, verify that the function parameter is type `const` and pass in a `const` object. Of course, the `const` can be easily cast away, but if the framework is well-written, you should be able to trust it. Furthermore, without reviewing the source code, there's no telling what `update_camera_vectors(&amp;cam);` is doing with respect to memory allocation. These rookie mistakes are why Java became so popular in the first place.
Perhaps a clearer example #include &lt;stdio.h&gt; int a() { printf("a"); return 1; } int b() { printf("b"); return 1; } int c() { printf("c"); return 1; } void anyFunction(int,int,int) { printf("-done\n"); } int main() { anyFunction(a(), b(), c() ); } Before calling `anyFunction`, the compiler must perform the calls to `a`, `b` and `c`, but they can occur in any order. So all these, and others, are valid outputs from the program :- abc-done cba-done bac-done
ty
A short linked list shouldn't be a performance issue. When the list is long, and the nodes aren't near each other in memory, cache line misses and even paging can become performance issues. In an application like yours, the performance hit would be pretty much insignificant. A general rule is: are you performing the operation in the inner loop of a computation? That's generally the first (and usually only) place you need to think about optimization. There's a compromise you can use, although it makes your code slightly more complex: you could, for instance, allocate linked list nodes that hold say 8 or 16 file descriptors. Your node would look something like this: #define FDS_PER_NODE 8 typedef struct fd_node { struct fd_node *next; int fds[FDS_PER_NODE]; } FdNode; Now you only need to call malloc() once for every eight file descriptors. There will be 1/8 as many cache misses, and 1/8 as much paging. Your code to open fds and add them to the list might look like this: FdNode *list = NULL; FdNode *tail = NULL; int nFds = 0; // # of fds allocated so far void addFdToList(int fd) { FdNode *node; if (nFds % FDS_PER_NODE == 0) { // Time to start a node node = malloc(sizeof(*node)); // TODO: handle NULL return node-&gt;next = NULL; if (tail == NULL) list = node; else tail-&gt;next = node; tail = node; } else { // Add this fd to the last node in the list node = tail; } node-&gt;fds[nFds % FDS_PER_NODE] = fd; ++nFds; } I'll leave traversing the list, searching it, and removing fds from it as an exercise for the reader.
Not just different compilers but also the same compiler on different machines. I hit this issue years ago porting code from x86 Linux to ppc Darwin with gcc 3.3 on both platforms.
The C compiler does not guarantee that function arguments will be evaluated in any particular order, only that they will all be processed before entering the function body. &gt;In other words, there is no guarantee that each C compiler will process sequential expressions (an expression separated by commas) the same way. This is not the same as the above, and I'm not even entirely sure it is correct.
&gt; Yes, and the number of bits it uses to represent integers could be ∞. That is not possible because the number of bits used to represent a type is bound above by `sizeof` that type times the number of bits in a char (CHAR_BIT). &gt; Emphasis mine. If I'm reading this correctly, an implementation of C is allowed to have an infinitely large SIZE_MAX, and the values given in the standard are expected to be replaced with values equal or larger to those given. ∞ fits this standard, so creating an implementation of C where SIZE_MAX is set to ∞ would not violate the standard. `SIZE_MAX` is the largest value of the type `size_t`. Given that `size_t` has a finite size, `SIZE_MAX` cannot be infinitely large as it would not fit into a `size_t`. That said, note that the preprocessor performs just text substitution. How do you represent an infinite integer in C? There is no syntax for such a thing, so it's not possible to do this in C. Also note that &amp;infty; is not an integer and has no representation in either of one's complement, two's complement, and sign/magnitude. &gt; Obviously you would have to rethink some fundamental parts of the machine architecture to make it capable of handling a variable type whose size is ∞ but that's a question of machine architecture, not (unless I'm missing something) the C standard. Again: the size of every type in the C language is finite as `sizeof` returns the size of that type in bytes, which must be an integer of type `size_t` (i.e. a finite number). The number of bits in a byte is again an integer, `CHAR_BIT`, i.e. cannot be infinite. &gt; I believe -- and again, correct me if I'm missing something -- that there is nothing in the C standard that prevents it from having infinitely large variables, but rather that current implementations of C use finite variable sizes because that's the reality they're being implemented within. There is quite a bit as I have laid out in all my previous arguments which you conveniently decided to ignore.
That argument is wrong on two levels: * there is no such thing as a *sequential expression.* There is a comma operator that indeed evaluates its left argument before its right argument, but enumerating arguments to a function does not make use of this operator. Instead, it's a separate syntax that just happens to use the comma character * there are sequence points before the evaluations of function arguments, but the order in which they are evaluated is not guaranteed. So modifying `x` multiple times, once in each argument, is fine. It is just *unspecified* in which order the modifications happen.
&gt; you're not answering the question and only questioning its validity, dick move I'm not questioning the validity of the question, I'm trying to figure out OP's mental model and perhaps help them arrive at the answer on their own. &gt; you'd generally want to have a newline at the very end of your output [...] it's also not an iron-clad rule It is in Unix. But regardless, do you understand the meaning of the word “should”?
I tried a bit on the route of reading the qls files. Here is the thing: * The files you have on the disk are not compatible with the code. The 52 bytes QLS header, as defined in the code, does not match the file itself. However, there are similarities (a field that is supposed to contain something related to the length of the file is roughly correct, which cannot be a coincidence). The QLS header define a "version" number (type), that seems to be set to "11" by the code, when doing conversions, meaning that this code reads/writes version 11. The files you gave me are type 4 and 7. It is next to impossible to progress further. As I said previously, at minimum, I'd need a QLS file and the corresponding WAV. That way, we *may* be able to reverse engineer the file format.
Good description here: https://en.m.wikipedia.org/wiki/Sequence_point
Desktop link: https://en.wikipedia.org/wiki/Sequence_point *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^260691
**Sequence point** A sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. They are often mentioned in reference to C and C++, because they are a core concept for determining the validity and, if valid, the possible results of expressions. Adding more sequence points is sometimes necessary to make an expression defined and to ensure a single valid order of evaluation. With C++11, usage of the term sequence point has been replaced by sequencing. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
This is what I would do, and it's trivial.
&gt; there are sequence points before the evaluations of function arguments, but the order in which they are evaluated is not guaranteed. So modifying `x` multiple times, once in each argument, is fine. Not in C. There is a sequence point before the function is called, but not between the evaluation of the arguments.
Oh, my bad.
Not just different compilers and different machines. You can hit this with the same compiler on the same machine with different compiler options (e.g. optimized vs. not). And not just with different compiler options. You can hit this with different code nearby (e.g. you edit a line earlier/later in the same function, and just because of that, the compiler decides to pick a different order of evaluation for the arguments of this function call). Theoretically it's possible for you to hit this on Tuesdays because the compiler thinks it should have Tuesdays off and does it to spite you. I don't actually know a real compiler that behaves this way, but it's within the theoretical realm of possibility.
The text you quoted is almost entirely rubbish. The code causes undefined behaviour. The number of possible results is infinite, not 3. Ansi C compliance has nothing to do with this. It's not true that most compilers will do the same thing, let alone "what you would expect" (whatever that is). If you copied this text from something that's meant to be a learning resource, it would be a good idea to blacklist that resource.
There isn't one before the arguments either. `x++ + f(x)` is also undefined
It doesn't seem to have basic refactoring features supported for C, such as renaming a variable. If I'm wrong, can you point me in the right direction?
I mean you can do whatever the fuck you want with macros, but it's not a good idea to do it this way. What you should do is define a macro called NULLCheck, and use regular C to check it. like this: if (Variable == NULLCheck) { // Do whatever }
As long as they're descriptive and used in a consistent, systematic manner within your code, I think error checking macros are fine.
&gt; Would using the MACRO directly above this text be considered too atrocious Personally: yes. That's horrific. You're saving nothing in terms of characters and only diluting your code. &gt; or bad practice in some way? It's a terrible practice. There's no way to standardize this.. imagine hundreds of different codebases with all slightly different macro names, parameters and ordering. It's inane, whereas: (x == NULL) Has only a *single* meaning, and requires no jumping to other files or headers to determine what that meaning is. &gt; while also not allowing you to ever have a function longer than 25 lines. Geez... this is cargo cult programming at it's worst. Take what you can from the course, but as soon as you're through it, forget all this dippy nonsense.
&gt; It's just this bizarre memcpy error, which apperently only affects numbers with bits that evaluate to NAN? `memcpy` works as it should. Your program has a bug elsewhere. If you post a [reproducible example](https://stackoverflow.com/help/minimal-reproducible-example) then someone will be able to say exactly what's going on.
You could put it in a function that checks for a NULL pointer and prints an error message to stderr and calls exit(). You might also be able to find a way to get bigger chunks of memory at a time to cut down the number of checks needed
&gt;Since floats are always 32 bits They can be other sizes although 32-bit is the most common.
Huh, that is weird. Alright, im forwarding you the emails between Alex and Bill I am cc'd on. Theres a lot there, but most importantly: "I have prepared everything for you, please find the files in the attachment. I choose two sounds, the classic „Left-Right“ speech-sound from Sound Designer II and a clean sinus curve (250 Hz, 1,5 seconds, normalised in Sound Designer II). You could see from the file names what you have: sound name (plain are SD-files and the others converted QLS-files with additional info in their file name) bit rate of OS running QLS Convert (24 bit and 32 bit) OS (7.5.3 on a Iici which let you switch in the memory extension between 24 and 32 bit, 8.1 on a Quadra 950 with PPC card)" See the .sit attached, im just checking it out now.....
I believe in C you can not have length of array in variable even if it is constant, such thing works only in C++.
16-bit `float` is not permitted by the standard. `float` must support at least 6 decimal digits of precision. An implementation might have a 16-bit floating point type but it can't be called `float`.
Using `const` isn't enough. The array size must be an integral constant expression, e.g. an expression using only integer literals.
The modulo in isDivisible divides by zero.
You're dividing by zero. Start your factor checking at a higher number.
Inside print\_factors you have for loop which sets i to 0, this i is later send to isDividible where it is named 'iterate'. Then you do 'input % iterate', which is pretty much repeated division. Since you started with i = 0, you divide by 0 and that's why it crashes.
So I should start with i = 1 ?
I think I would frown on your macro, but I don't think I would call it "atrocious". I've certainly seen far worse in my day. However, it doesn't seem like it would save you all that much: NULL_CHECK(str = (char *)malloc(sizeof(char) * length)); vs: if (!(str = (char *)malloc(sizeof(char) * length))) return -1; I agree that the 25-line limit seems silly, but at the same time, I can tell you from experience that trying follow someone else's code that is implemented with 500+ line functions is really a pain in the ass. So I sympathize with the motivation behind it. Unfortunately, any kind of draconian limitation like this is ripe for avoiding the intended lesson/goal and doing something different. In the spirit of trying to improve yourself in the class, I recommend taking a step back and rethinking the code you've produced to see if you couldn't restructure in some other way to meet the 25 line limit rather than playing tricks like this. Not to say you should change your style permanently, but think of it as a challenge to see if you can live productively and in good faith under the limit.
16-bit floats are pretty popular on embedded. Usually there is a compiler option like "treat floats as half-floats" or "16-bit floats". Sometimes there are "treat doubles as floats" too.
`scanf` already gets rid of the end of line char. All you need to do is: int a = 0; while(a &lt; 1) { scanf("%d",&amp;a); } But that's not why your program is crashing. It's crashing because you're trying to do `i % 0` on the first pass of the loop in `print_factors`. Also, there's a logic error in your last function. The modulo operator gives the remainder of integer division. So, if your function would return 1 if you gave it `isDivisible(4,3)` because `4%3 == 1`.
Modulo gives you the remainder of the division. Think about how you're testing if an integer is divisible.
Inside isDivisible you should have condition like this: if (input%iterate == 0){ ... } Modulo for positive numbers calculates remainder after integer division. Numbers are divisible only if this remainder is 0, not 1.
No, you're saving no lines. Just have all your allocations follow this pattern. char *str = malloc(sizeof(char) * length); if(!str) return -1; Replacing that second line with a macro only pollutes the program with a macro, it doesn't help you at all. As for why specifically this is bad, it has a hard-coded return type that's hidden away in a header file. What if this program return a bool and you forget that the macro returns -1 instead? The C compiler will happily compile that and it will return true. If it's a rare failure case, you won't realize anything is wrong until the program is in use. It's an unnecessary complication in something that should be very simple. I'm not sure if I would ever actually use this and it doesn't really help you, but I think this is less harmful and more safe. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ALLOC_(assign, size, fail_label, ...) \ do { \ void *ptr = malloc(size); \ if(!ptr) goto fail_label; \ assign ptr; \ } while(0) #define ALLOC(...) ALLOC_(__VA_ARGS__, alloc_fail) int main() { char *c; ALLOC(c =, sizeof(char) * 10); char *c2; ALLOC(c2 =, sizeof(char) * 100, second_alloc_fail); alloc_fail: return EXIT_FAILURE; second_alloc_fail: return 42; } Calling the ALLOC macro still resembles an assignment, so it's relatively clear from the macro call that an assignment is taking place. It also follows a standard pattern of either `goto alloc_fail` or goto the third macro parameter, which allows you to safely unallocate other resources before returning. This _forces_ you to write the failure condition in the function or else it's a compile error.
I'm sorry, I'm not meaning to ignore what you've said. I thought I was responding to them. As far as I can tell, your arguments consist of naming a constant which is an integer, and claiming that because it's an integer it must be finite. My argument is that nothing in the specification states that these values must be finite. The spec makes it clear that they're implementation-defined. An integer need not be finite, and in fact the set of integers is infinite. None of the constants you listed *must* be finite, it just happens that in all implementations of C they *are* because they are implemented on physical machines in this universe. Nothing in the spec says they cannot have a value of ∞. I agree that ∞ is not an integer and there is currently no method for a machine to handle ∞ as a value, or to enter ∞ in a file such as stddef.h. However, I argue that this is a limitation imposed by our physical universe, and not by the C specification. If we are free to posit a physical universe in which a machine with infinite memory is possible, we must also be free to posit that in this universe it is possible to represent ∞ in binary, and therefore to return ∞ as a value, or to enter the value ∞ in a file when defining a constant.
MSVC has nearly complete support for C99 these days, so it's pretty reasonable for C. The main issue is its crummy C standard library, and the lack of POSIX, so for most things beyond plain old C you'll have to call into the Win32 API. Note: Visual Studio comes with a command line tool chain, `cl.exe` and `link.exe`, so you don't actually have to use the IDE for C development. Use the included `vcvars64.bat` to set up a development console, or use the "x64 Native Tools Command Prompt" item in the start menu.
Visual Studio is just not a C compiler or IDE, Microsoft supports C for the C++ requirements, and that's it. It is a C++ compiler. I wouldn't recommend it for C development.
Xcode is excellent for C development. And macOS is POSIX
I took a quick shower and thought about this more and you don't need a way to represent ∞ in binary to make it work. You just download the GCC source code, write your Turing simulator in C, and after each step check to see whether anything is getting close to its maximum size. If it is, open whichever file in GCC's source code constrains that variable and rewrite it with double the current max size. Recompile GCC, recompile your simulator, and run it. That should run any Turing machine infinitely or until it halts, which satisfies your definition of Turing complete in https://www.reddit.com/r/C_Programming/comments/budall/optimal_way_to_handle_having_an_unknown_amount_of/epien47/
Have you looked at VS Code? Kinda seems like a better option for non- .Net languages imo. Runs on Linux/Mac too.
I don't think MSVC has any kind of *official* modern C standard conformance, but the recent versions works fine as a C99 compiler, I've built some pretty large C projects with it without major issues aside from it whining about some deprecated standard library functions. Developing C on Windows in MSVC isn't my first choice but it's perfectly doable if you don't need C11 features (and you probably don't).
ok great this is what I needed
You could just let the size be determined by the initializer. int main(){ int test[] = {1, 2}; return 0; }
oh... I think the other method is still definitely helpful to know, though I will end up using that in this case.
That's probably not very helpful, OP is asking about Visual Studio and probably isn't using a Mac.
To answer your first question, you are indeed printing random values once you print outside the bounds of an array. Data at any memory location holds an arbitrary value unless explicitly allocated and defined. As for why you are getting 4 from your printf call, remember that the sizeof operator returns the size of the input data type in BYTES. 4 bytes = 32 bits, which is the size of an int in your system.
C is a fast language that is used for hardware programming, and as such, it does not 'monitor' what you or it does at run-time. During compile time, the compiler will check what you are trying to do a bit, maybe give you a warning, but other than that, **C will always do what you tell it to.** This includes reading and writing to any memory address, even if it's invalid, even if it leads to a system crash. &gt; ```printf("%d\n", s);``` seem to only print 4? ```sizeof(arr)``` equals 4 because ```arr``` is a pointer, and on that particular 32-bit system, pointers are always 4 bytes large. On a 64-bit system, pointers will be 8 bytes large.
The first error is that sizeof(arr) does not give you the size of the array. Rather it gives you the size of the pointer that you're passing to printTest(). That pointer points to the array, but it, itself, is just a pointer. If its value is always 4, that's probably because you're compiling for a 32-bit system, on which pointers are 4 bytes in size. Even if you applied sizeof() to the actual array (test), you would not get the number of numbers in the array but rather the number of bytes that the array takes up. That is, you'd get 4 whereas you'd want 1. The normal ways to do what you're trying to do are to either pass a second parameter that is the size of the array to your function. Or use a sentinel value (like 0 or -1) at the end of the array to indicate its end, and then your loop would check for that sentinel value to know when to stop. I generally prefer passing a second parameter. But sentinel values are common - strings are done this way. The random numbers you're getting, I believe are not from running off the end of the array, but rather because printTest() is not printing elements of the array but rather the address of the array (the value of the pointer to the array): printf("%d %d\n", arr, y); I think you meant to have: printf("%d %d\n", arr[y], y); That said, if you were doing the latter, you would, in fact, be printing random stuff off the end of the array. C cannot give you a warning about running off the end of an array because it does no bounds checking. There are other languages that do perform bounds checking - at a runtime cost. C isn't one of them. And because of that C is subject to the classic "buffer overrun" problem. This is one of the basic bugs that something like 80-90% of cyber attacks leverage to break into a computer system. Speaking of which, because "test" has size 1, the line where you explicitly store data at index 7: test[7] = 1234; This effectively clobbers random memory and could lead to you program crashing... or not... It entirely depends on what piece of random memory it happens to clobber.
I think it's great for C development even though it's a c++ compiler. Mostly because it has very simple debugging and it has an amazing code analysis tool that does wonders for writing safe C code.
I am not sure what you mean by typedef variables. Pointers does not require dynamically allocated memory. The object does not go out of scope until the end of the function has been reached, which means any references before that are valid.
`sizeof(char)` is by definition 1. There is no point in multiplying by it.
The function may very well change the value of cam; that's the reason we are passing a pointer to the function after all. There are no problems whatsoever with this
[I give up. You win...](https://i.imgur.com/2wgnrtR.gifv)
Can you send a screenshot of the version types you've described? That might be valuable information to Bill
I think that Java and JavaScript were tailor-made for you.
How's the best way to do that?
[Here ya go.](https://docs.python.org/3/extending/embedding.html)
Thanks!
Save yourself the pain, use mingw64 with MSYS2 instead
It fascinates me how the Microsoft's C compiler has _nearly_ complete support for a standard 20 years old. When they will have C11?
MSVC’s C support is the way it is because they only implemented the stuff that’s also in C++
So, there is nothing actually complicated about it. Essentially, `extern` just declares without defining it. If you define a variable `int x`, that `x` is a variable and it takes up some space on the stack. So it is a fully defined and allocated variable. You can easily do `x = 42` or something else crazy. However, if you do `extern int x`, it just declares that *there exists* variable called x but it *it does not* have physical space allocated for it. So `x = 1` or any other statement involving defining a value would throw a compilation error. Also, you use `extern` all the time with functions. Whenever you make a function prototype, like `int fib(int n);`, you just declared that there is a function, called fib but we don’t have its definition. `extern int fib(int n);` is the same. It’s just implicit. Why do people use it? People usually use it for what it stands for. `extern` means external. So when you are including other source files or header files, they want to reference the variable without actually accessing it. Hope this helps!
What exactly would I search for to learn how "extern" is treated from compiling to linking? I think this is what I need. Thank you for the reply.
Well, for that technical detail you can try to DuckDuckGo some white papers or compiler forums from 2002 that have some graphs on that. Or you can dive deep into compilers. Not gcc, smaller tcc should be fine. Generally, [this page has general info](https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/)
&gt; 4 bytes = 32 bits, which is the size of a pointer in your system. FTFY
&gt; ... and run that machine code on your processor You missed a step: your compiled program is first given to the OS. It puts the machine code into the right blocks of memory, sets up memory permissions (so that you don't accidentally touch other processes' memory). It also provides special services to your program, like file system access, network access, _heap management_ and much more. So, after the OS has put your code into memory, it tells the CPU to execute it. And while being executing, your program calls special "functions" that give access to the system services mentioned above _system calls_. Your code requests heap memory via a system call, the OS decides whether to give it to you and returns the address of the allocated region. As a programmer, you don't have to worry about syscalls too much because they're hidden in the C standard library. For example, `malloc` and `free` use them under the hood.
Memory management for your process is mostly handled by your process itself (which is linked either statically or dynamicaly to a C runtime library like glibc, which provides the heap allocation routines). The OS allocates your process some amount of memory when you launch it. After this, malloc may request big hunks of memory to be mapped into its virtual address space by the operating system kernel by a couple of syscalls.
Doesn't `extern` within a function block also declare access to a unit-scoped variable? Or, is that old C?
What about this: https://www.airs.com/blog/archives/38 It's just the linker side of things and I think _way_ more in-depth than you're asking for, but it's a good read. If you skim it you might find what you need at a glance?
Also, you can use LLVM and Clang on windows and in MSVS. This plugin: https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain Makes is simple to switch to clang if you want to build with that instead of the MSVC.
Replace%s with %c
You are giving a copy of your char when it's expecting a pointer
This looks like what Im searching for. Thank you
Couple of things: 1. https://idownvotedbecau.se/imageofcode 2. Turn your compiler warnings on, and read them. You're trying to read an array of chars in to a char, your compiler will warn you about this with the right flags.
Those few lines on the compiler and linker were really helpful. Thank you for that
I think it's scanf, not printf that's the problem.
Thanks that was a typo
It's got a fantastic debugger. And it runs stuff just fine. There is the ability to target linux in later versions, but even the old stuff is fine. You can't go wrong with [VC6 Ultimate](http://vc6.ultim.pw/), which also incorporates the Visual C++ 2003 Enterprise parallel compiler so you can use all 32 cores in your killer system to build stuff. Even Visual C++ 1.10 for Windows NT still runs on Windows 10 x64, although you need the updated linker, otherwise you end up with 2MB padded executables and other weirdness. Unless someone is using all the GNU ish features, then it's off to MinGW land. I still use the TDM GCC 5.0 stuff. It's been pretty good. And GCC 3.4.5 for things that are old enough that broke with the whole GCC 4 and beyond thing.
You could read the specification of linkage in the C Standard.
`extern int x; x=1;` is perfectly fine so long as there is a definition for x in the program somewhere
I get mad at it for not supporting variable length arrays. But other than that, it is an excellent IDE for old-school C89. I don't know for sure but it seems getting intellicode for C++ just recently which in turn improves the potential error detection for C.
Probably never? To be fair, most project use c99 anyway, so it's not that big of a deal.
You can cast before assignment to make life easier. Setting an exact value requires understanding how the bits are packed and thinking about how to shift them.
Not surprising, different platforms have different calling conventions.
ASLR is a thing though and should be enabled by default on all recent OSes. Not sure why it isn't in OP's case.
It is a good programming habit to write _return 0_ at the end of your code in case the _main_ function is an _int_.
This is true, but when discussing Turing completeness, we don't actually discuss infinite memory. After all, no machine is capable actually has an infinite tape.
A file descriptor is only an integer representing a unique id for a given file. FILE* refers to a structure that maintains info about a file (id, progress in the file, etc).
Aside from the use of offsets as was pointed out, this shouldn't be possible in C. What your talking about is code substitution, a.k.a. macros. C macro expansion takes place before execution begins. If you feel like testing with 2 source files, you could probably run one, where you decide on which field to reference. When you're ready, you exec the other file file and use a macro to substitute in the field you want. This screams of being unnecessarily complicated though. Languages such as Racket allow for runtime macro evaluation. C is far from that.
Video game reference.
That's why I said “in theory.”
oh, it was using arr[y] but I accidentally removed it while preparing the code to post. Thank you for the elegant explanation.
They are saying whether the expression can be evaluated is irrelevant. From a parsing perspective, all we care about is what the parser decides to transform the syntax into. The original question was was why the expression was parsed as a chain of unary positive expressions rather than unary increment.
vim
At the end of the day, the editor you use doesn't matter. Use whatever you feel most comfortable with, and if anyone says that's the wrong choice, they're idiots.
Algorithms in C, by Sedgwick. Chapters 3, 4 and 5 are on Data Structures.
In your first 'scanf()' function, replace '%s' with '%c' and add '&amp;' in front of 'grade'.
JetBrains has CLion. I’ve used it a little bit and it seems fine but I’m not a C developer. You may be able to get a mice workflow with VS Code extensions. It’s lightweight and highly configurable.
You can check out my code which I wrote for college class Data Structures on GitHub: [https://github.com/iivanu/Command\_prompt](https://github.com/iivanu/Command_prompt) &amp;#x200B; I use there linked list and trees. ;)
Thanks. Will check out
Thanks.
I hope it’ll help you a bit.
C interfaces and implementations. The author walks you through how he designed his algorithm and container library
I mentioned that both in the VS C++ uservoice, and here on reddit on /r/programming, and in both occasions, some people from the VC++ team said that while supporting C wasn't on their roadmap a few years ago, in the more recent years that stance changed, and they plan on doing it, but it's still way down the line with regards to prioritization. https://developercommunity.visualstudio.com/idea/387315/add-c11-support.html https://www.reddit.com/r/C_Programming/comments/aotw07/consider_voting_trying_to_convince_microsoft_to/eg5klmy/?context=3
I really liked 'Data Structures using C' by A. Tennenbaum.
Not anymore with WSL around.
The Linux kernel manages memory. There is not a daemon process. A program may directly request memory from the kernel via [system calls](https://en.wikipedia.org/wiki/System_call) such as sbrk() and mmap(). However, such system calls are expensive and fairly inflexible. Most C programs use malloc() et al instead. These are library functions ([manpage section](https://en.wikipedia.org/wiki/Man_page#Manual_sections) 3; system calls are in section 2). They request large chunks of memory and subdivide the chunks for small allocations. You can also implement your own malloc() replacement, but achieving the performance of glibc is non-trivial.
Code examples are in comic sans though 😢
Yeah
It has very little to do with calling conventions. The standard does not define the order of evaluation of function arguments, and the commas between them are not sequence points, so the code in question invokes undefined behavior.
Quick overview: [What a C programmer should know about memory](https://web.archive.org/web/20150305164701/http://marek.vavrusa.com/c/memory/2015/02/20/memory/)
&gt; &gt; In other words, there is no guarantee that each C compiler will process sequential expressions (an expression separated by commas) the same way. &gt; This is not the same as the above, and I'm not even entirely sure it is correct. You're right. It isn't. The commas in a function call are *not* the same as the comma operator. Otherwise, the entire argument list would evaluate to a single value. The comma operator is a sequence point, but the commas between function arguments are not, and modifying the same variable multiple times between with no intervening sequence points invokes undefined behavior.
&gt; `str = (char *)malloc(sizeof(char) * length);` This is bad. You are repeating the same information three times: once when you declared `str`, once in the completely unnecessary cast, and once in the `sizeof`. Use this: str = malloc(length * sizeof(*str)); Some might point out that `sizeof(char)` is 1 by definition, but this version allows you to, say, change `str` from `char` to `wchar_t` without having to modify you `malloc()` call. &gt; `if(!(str = (char *)malloc(sizeof(char) * length)))` This is even worse. In addition to the issues I already mentioned, you are using an assignment expression which evaluates to a pointer as a predicate. Use this: if ((str = malloc(length * sizeof(*str))) == NULL) &gt; `#define NULL_CHECK(x) if (!x) return (-1);` This macro makes the baby Jesus cry. First, *don't use a macro for this*. Second, *if you absolutely must*, at least get it right: #define NULL_CHECK(x) do { if ((x) == NULL) return (-1); } while (0) All that being said... you might as well drop the check entirely, unless your instructor deducts points for doing so. First because `malloc()` will never return `NULL` (unless your program contains a runaway loop or recursion bomb), and second because the consequence of not checking for `NULL` is a segmentation fault immediately after the failed allocation, which is easy to analyze in a debugger, while a `NULL` check will result in some higher level of your program printing out a cryptic error message before exiting, leaving you with very little information about what actually went wrong.
&gt; `NULL_CHECK(str = (char *)malloc(sizeof(char) * length));` This will not compile.
It is *unspecified*, not *undefined* behavior. It has a lot to do with calling conventions, for example a compiler that targets an ABI that requires parameters be passed on the stack in a left-to-right order will almost surely evaluate the params in the same order as to avoid taking up registers and/or redundant stack ops. But goddamit am i tired of the **hurr-durr its undefined, demons flying out of nose amirite** meme. Except for blatant cases of undefined behavior most compilers will behave in a sane manner, and technical arguments can be given as to why it emitted this code and not some other code.
You started off so well, and then you went and did this: &gt; it takes up some space on the stack which is admittedly relatively minor, but you followed up with this double whammy: &gt; So `x = 1` or any other statement involving defining a value would throw a compilation error. which essentially says that you can never access a variable defined in another compilation unit, in addition to talking about “defining a value” which is not something you ever do in C.
&gt; It is unspecified, not undefined behavior. The evaluation order is unspecified, but since there is no sequence points between them, modifying the same value multiple times is undefined behavior. &gt; most compilers will behave in a sane manner Ten years ago, or even five years ago, perhaps. Today, absolutely not. Compilers will aggressively remove or rewrite code that relies on undefined behavior.
I use Eclipse CDT daily for C and C++, but on Linux. I can tell you it's the best free IDE if you are ok with it's Java heaviness. But I believe you may have difficulty on Windows because of the compilers and build tools. If you can manage that (perhaps use WSL?) I think it could be your solution. Other options I hear a lot about are NetBeans and QtCreator.
32 bits is the IEEE standard for "float" and I'd be pretty surprised if my computer did not have them. Having said that, yesterday I tried using an online compiler someone else linked (as opposed to GCC on the 32-bit laptop I'm typing this on), and it worked. This raises further questions but at least my program succeeded, I guess? I think I should also test it with GCC on my 64-bit desktop to see whether that succeeds or fails. I can't think of any reason why that would matter for this particular case - maybe this 32-bit system only uses 24-bit floats or something like that. Thank you for your input!
Have you considered the Community versions of Visual Studio 2017/2019? The debugging tools are amazing for C and C++. I personally use VSCode with CMake and switch to VS when I need to do heavy debugging.
I don't think that the bits are changing when passed to show\_float, and if they are I don't think that's the issue. Here's why: My tests failed for an unknown reason, and show\_float outputted the failed example. If the test had passed, show\_float would never have been called, so if the bits *are* changing it would have had to happen before show\_float did anything to them. Bringing show\_float in earlier in the problem, as I did above, showed some differences, but if the tests had passed I would never have thought to put show\_float earlier. As such, while it's possible show\_float has issues I personally doubt it and it almost certainly isn't the problem at hand. As you saw in a comment I left on another post, the code did work on another compiler with another system, for some reason.
I personally don’t like eclipse. It’s the kind of fiddly, misdesigned mess that gives IDEs a bad rap among the “i code in notepad” crowd. But just stop overthinking it, VS works fine, Eclipse works fine, QT Creator works fine (and would be my pick if I I didn’t get CLion for free); pick one and get to coding.
Still need mingw if you want to produce win32 binaries.
When C++ was created, the intention was that it should essentially be a superset of C. The C Standards Committee subsequently added some features into C99 that had been part of C++ (such as double-slash comments) but also some new features that would have been a nuisance to implement, would likely never be part of C++, and likely wouldn't be used terribly much (such as variable-length arrays). Microsoft took the view that it was more important to focus on features that would be useful for its intended customers (people developing software for use with the Windows(R) brand operating system) than on supporting features that would be of dubious utility for most of those customers. They also, incidentally, took the view that "popular extensions" which had been common to essentially all general-purpose microcomputer-based C compilers in the 1990s should be recognized as useful, and thus supported them rather than denouncing as "broken" any code which made use of them.
As IDEs go, it's pretty typical and pretty good. If you're programming for Windows, it's *the* development environment to use. Now me, I'm a vi-and-make kind of guy, but TBH, I still use VS under Windows simply because it's the standard workflow and it's always best to stick with standard practices. As of VS2015 version 3, they have pretty complete C99 support. I imagine VS2017 does as well, but I've barely used it.
Gonna go against the hive mind and upvote this. Yes, it's embarrassing that µsoft is so far behind the standards, but I prefer not to code to the latest standards anyway. Being cutting-edge is the enemy of portability. I like my code to compile everywhere, and if I don't *need* a language feature, I don't use it until I'm satisfied that it's been universally adopted.
Ah, sure, because I missed a pair of parens. This does compile: NULL_CHECK((str = (char *)malloc(sizeof(char) * length))); Evidence: [https://godbolt.org/z/FseWPL](https://godbolt.org/z/FseWPL) Though, really, the original macro should have the parens: #define NULL_CHECK(x) if (!(x)) return (-1);
There's a known instance of a [bug that depended on the phase of the moon](http://www.catb.org/jargon/html/P/phase-of-the-moon.html)
http://cslibrary.stanford.edu - This is a series of short books on C, pointers, linked list and trees with some problem sets on linked list and trees. It doesn’t have all the data structures so it need to be supplemented with other recommendations in this thread.
IDE is just environment, a good user interface. I highly recommend command line programing(use cmd promt in windows or terminal in linux)for beginners. It'll help you in the future for sure. But you'll need to download compiler for it.
Awesome! Thanks for that!
Cormen introduction to algorithms
No it's explicitly undefined behaviour to do what OP was doing with x, and as mentioned any slight difference might change the order the compiler evaluates the expressions in, hence warnings of nasal demons. Do not write code with UB in it, it's bad code, yes there are reasons a compiler will emit specific code for a given input containg UB, but you don't know what they are and they'll probably change even withing bugfix compiler releases, with minor changes to surrounding code. Compilers can and will do insane seeming things with code containing UB because compiler writers don't care about what you think.it should do with such code because it's UB so they can do whatever. UB is bad mmmm'kay.
Other posters have already identified your problem, but I want to make a couple of code review comments: * Your indentation is inconsistent. You should be using 4 columns for each level of indentation. I don't know what editor you're using, but that ought to be a feature you can specify. Spacing is also inconsistent. Your teacher should have given you a style guide. * **bug**: isDivisible() should be testing `input%iterate == 0` * isDivisible() could be replaced with simply `input % i == 0` in print_factors() * You don't need to try factors &lt;= input. None of your factors can be larger than the square root of your target number, so your limit should be `(int)sqrt(input) + 1` * First test the divisor 2, then start looping from 3, testing only odd numbers. * Yet another optimization: every time you find a factor of input, divide input by that factor. Then you can stop looping once input reaches 1. In fact, you can stop looping once input &lt; i. * **bug**: You're not allowing for duplicated factors. For example, if you tried to factor 9, your program would return 3, not 3*3.
https://www.openbsd.org/papers/bsdcan14-libressl/mgp00025.html
&gt;. I highly recommend command line programing(use cmd promt in windows or terminal in linux)for beginners. It'll help you in the future for sure. How? What is with this strange puritanical bent in the C community? Coding in a text editor is about as helpful to learning C as using your hands and teeth instead of a knife to learn cooking. This isn't the 70s, IDEs are great tools that can significantly improve your productivity. Just last week one of my "im hardcore, i use a text editor" coworkers spent the better part of a day tracking down some dumb brain-fart bug any half-decent IDE or linter would've flagged the second he wrote it.
The most efficient order for the evaluation of function arguments may also depend upon how the arguments are computed. For example, given `foo(bar(), boz())`, with all functions being on type `int`, an 32-bit ARM compiler that knows nothing about `bar` or `boz` and has register R4 available, could best process the code as bl boz ; Subroutine call "branch and link" mov r4,r0 ; Return value from boz is in R0. R4 is temp reg. bl bar ; Return value from bar is in R0, where foo expects 1st arg. mov r1,r4 ; Second argument to foo expected in R1. bl foo On that platform, a called function places an `int` return value in R0 and may leave arbitrary values in R1-R3; R4-R11 are preserved. A function with two `int` arguments will expect the first in `R0` and the second in `R1`. If a compiler can see a definition `int x; int boz(void) { return x; }`, however, the best code would be: bl bar ; Return value from bar is in R0, where foo expects 1st arg. mov r1,=x ; Constant address of x ldr r1,[r1] ; Load r1 (2nd argument to foo) from &amp;x bl foo If `bar` modifies `x`, this would cause such modification to be reflected in the passed argument, whereas the most efficient code when not inlining `boz` would have captured the value of `x` before calling `bar`.
Are you writing code? It's not unusual to forget details until you've put them into practice.
I'm doing some of the exercises. Like I said, I can understand the code, I just can't remember the exact definitions of some of the things. One example would be the book mention external variables. I sort of understand it, but I can't remember the exact details.
Reading a book will only get you so far. The best way to learn a language is to write a real project in it. It's much easier to grok everything when you need to understand some aspect of the language to solve an actual problem you have.
Seriously? How can anyone be interested if they don't know the topic?
big pity :(
Thanks
Please repost this with a proper title and the exact thing you have problems with in the body. This post is useless and doesn't enable anybody to help you with your problem, so please try again with a more descriptive post. Also, use a descriptive title instead of just “HELP”. And do not put tags in the title.
The more you write the more you’ll remember. You will (probably) never remember everything but you will remember what’s important and what you commonly use.
Do all the exercises, not just some of them. Modify the exercises so they do something a bit different.
Everything is in your mail.
The C89 Committee recognized the existence of many "popular extensions" which extended the language with behavioral guarantees beyond those the Standard itself mandated. A common such extension is "integer operations other than division and remainder have no side-effects beyond computing some kind of value and possibly performing indicated accesses to the storage in which associated objects are stored." The Committee saw no need to mandate such things, because they judged that people seeking to write quality implementations would be better placed than the Committee to weigh the costs of support against the benefits to their customers. Perhaps the text should have said that there are at least three sensible ways that compilers could evaluate that code, and that the Standard would also allow compiler writers to process such code in any fashion--sensible or not--that they wish to do so. If it was written in the last decade, it should have mentioned that some compiler writers are prone to use such latitude as justification for jumping the rails completely even in cases where the code in question would otherwise have no side effects, but if it was written more than 15 years ago I wouldn't fault the authors for having failed to imagine that such behavior would become fashionable.
The most important thing is that when you come up against something in “real life” you remember you read something about it, and can go look up the exact information when you need it. Until you’ve practiced the same thing over and over you won’t remember it.
I have been programming 10+ years professionally. Syntax and little details dont matter. Learn the idea behind them. You dont need to and should not memorize anything. Look it up again when you need them. If that's only once in a while that's fine, you dont have to remember because you use it only once in a while. If you use it a lot then after 3rd 4th lookup you will remember it next time. And when you are done with that part of your code, it's fine to re-forget it. Key here is when you need it make sure you just look it up and return do not get sidetracked or get distracted by other stuff, just check it and go back to what you were coding, do not lose your steam/train of thought. I worked with a lot of languages and simultaneously with multiple ones most of the time and continue to do so. I just sorta remember/have a feel of what features a particular language has and it's inner workings. When i need to decide on a language i start from what i know and pick one. Then when i start working with it again everything kind of comes back real quick but with lots of quick lookups like "What was the syntax of that? How was i declaring interfaces on this language? What was the name/params/return value of the function that does this particular thing?" kind of stuff.
&gt; You just download the GCC source code, write your Turing simulator in C, and after each step check to see whether anything is getting close to its maximum size. If it is, open whichever file in GCC's source code constrains that variable and rewrite it with double the current max size. Recompile GCC, recompile your simulator, and run it. The reduction must output a single C program. Not an infinite series of C programs. And again, given that gcc is written in C, there is a point at which you cannot raise the limit without making gcc stop compiling because the size of an integer doesn't fit the RAM of the machine you compile it on. You couldn't even write the program to patch gcc in C because eventually you cannot store the number of bytes of memory you patch gcc to support anymore. And you couldn't execute gcc anyway because there is no portable facility to generate or execute machine code. You could write a C compiler for your hypothetical “infinite memory” machine in a language other than C, but then do you really show that the language is Turing complete?
&gt; As far as I can tell, your arguments consist of naming a constant which is an integer, and claiming that because it's an integer it must be finite. Exactly. You support this argument by saying: &gt; I agree that ∞ is not an integer and there is currently no method for a machine to handle ∞ as a value, or to enter ∞ in a file such as stddef.h. Note that “currently” is very important because if you change the language to support anything like that, it is no longer C and you're just moving the goalposts. C is what ISO/IEC 9899:2011 describes and nothing more. &gt; However, I argue that this is a limitation imposed by our physical universe, and not by the C specification. If we are free to posit a physical universe in which a machine with infinite memory is possible, we must also be free to posit that in this universe it is possible to represent ∞ in binary, and therefore to return ∞ as a value, or to enter the value ∞ in a file when defining a constant. Such a universe cannot exist unless it is contradictory (in which case all theorems are true) because integers are defined to be finite. Also, you argued yourself that all integers are finite and that ∞ is not an integer, so I'm not sure why you now claim that you could make ∞ an integer without changing what C is.
I'm not an expert by any stretch, but I've been programming for decades, and I *still* go back and use the K&amp;R book as a reference. Trying to memorize the material is pointless and counterproductive. You'll learn the parts you use and need now, and when you need a different feature, you'll look it up, just like everyone else. Just keep doing the exercises. Don't skip any, and be experimental. Make changes to better understand how it all works. *That* will get you where you want to be.
IDEs are awesome, but plain Notepad++ and the CMD is indeed great for learning beginners, which is what he said. Personally I'm looking for a high-productivity IDE since I'm not a beginner :)
I've skipped a couple of exercises, but I've done most of them. The problem I find with them is that they're fairly ambiguous. I don't know exactly what some of them want me to do. Some I can think of are entab and detab. I don't know whether I was meant to write a bunch of functions or not. So I just ended up with a small loop that works for individual lines. But I have a feeling it was meant to be much bigger. And some I just lack the motivation to do. But I suppose I can always come back to them.
This. Understanding every single detail, is impossible unless you have an amazing memory. Detail is great, but understanding the intent, and reasoning is better. I.e the why, not the how. Things you use regularly will stay in the front of your memory; and things you don't will fade a bit. It's always good to refresh yourself on things you've not done for a while. But it does all come flooding back,
nice work, looks accurate ! any plans to multi thread it ? out of sheer curiosity why c89 I thought I was a being conservative sticking with c99 but mind I do tend to use a subset just due to habit !
Currently no. I try to keep the code as simple as it can be. So there is no plan to add multi thread or SIMD things to it. It is optimized only by minimizing malloc after initialization, sorting models by distance before drawing, and -O3 with -flto. I use C89 just because I’m familiar with it...
I suggest using the debugger to catch where it segfaults and work back from there.
It doesn't support _Generic or _Atomic or any of that stuff, but it's mostly caught up to C99 now so it's not completely atrocious.
For that you should use Clang which is ABI compatible. hell, use Clang-CL and it's even compatible with the compiler switches.
Absolutely hate it.
Any compiler worth using will generate the same machine instructions.
That works too, I just prefer my sweet sweet Unix userland
Neither is faster and while(1) is my preference.
Well, I've seen a while loop used that way. Can't say I've ever seen a for loop used for that. I don't imagine it would be any faster, so it would probably just be more confusing for a reader to stumble upon it in your code.
It looks very well written. :)
MSVC warns against `while(1)` but not `for(;;)` - that says more about MSVC's arbitrariness than the merits of either construct though.
Wow this is cool!
&gt; C89 -_-
Thanks 🙏
I think `while (1)` is easier to read because `for (;;)` relies on knowing somewhat obscure behavior of the `for` loop; however, I don't have a strong preference, and this is something you can learn once and never really think about again. Stuff like this is why programming shops have style guides.
Do not skip exercises. Repeat exercises. At the beginning, you need to build as much muscle memory as possible, so when you learn new things, you don't need to think about the mechanics. Here's an exercise I recommend to new developers: 1. Fire up your editor/IDE 2. Write a program that prints out 1..100 forwards then backwards. 3. Compile and run the program. 4. Delete the program, close your editor 5. Repeat 1-4 10 times (for speed). No copy/paste or any code reuse allowed. When this becomes second-nature, modify the drill to replace #2 with whatever minimally-demonstrable example of the concept you are learning. You will not learn if you do not practice. I don't mean to be harsh, but if the prospect of doing K&amp;R exercises is something you find yourself actively avoiding, it is a strong indication that software engineering (and computer science, to a lesser degree) may not be right for you.
Use whichever you prefer, unless the codebase already favors one over the other or you have a style guide.
Presumably `prologue` isn't a valid pointer to a `ics_header`. Where did `prologue` get its value?
&gt;(It's not the whole code by the way!) oh shit I thought
Suggestions: * Choose an Open Source license. Currently you have no license, which means nobody can legally use your library. * Don't print from libraries, even when there are errors, and especially don't call `exit(3)`. Report the error to the caller (return value, etc.). Your library doesn't know the correct way to report errors to the user so let the main program handle that. * Embed a PRNG into the library and don't bother with `rand()`. There are lots of choices, but one good option is [PCG](http://www.pcg-random.org/download.html). In this case the quality doesn't matter so much. Also put the PRNG state on the Deck structure. This means you'll get consistent results for the same seed across all platforms, and Decks will be completely independent of one another.
I haven't run this, but I assume your problem is on line 150-151 in which you reassign the pointer for `current-&gt;next` and then you free the printer that you've just assigned. To confirm, I'd recommend sketching out your nodes and pointers, then follow your `remove` code line-by-line.
The name C is used to describe a number of dialects which have diverged greatly since 1999. Prior to 1999, it was widely recognized that compilers should generally be expected to behave as described in the second edition of K&amp;R whenever practical, without regard for whether the C89 Standard actually mandated that behavior. After 1999, however, it became fashionable to pretend that the language had never been defined by anything other than the C Standard, even though it had been in use for 15 years before the first standard was even published.
Show us the full code
As a compiler engineer, the only case I can think of where while(1) is slower than for(;;) is compiling at O0 with a compiler whose engineers *really* believed in literal translation or a early stage JIT compiler which simply translated expressions as-is for speed purposes. O1 and above should sweep away the differences as the notional test in the while(1) conditional can be constant folded away.
Not to be rude, but judging by your question from the other day and the fact that you seem to think this is enough information to diagnose *anything at all*, it's because you're cargo cultishly copy-pasting random code you found on the internet without *any* understanding of what you're doing.
Thanks a lot man, just added the license and will fix other things asap
Compiler explorer says they're the same: https://godbolt.org/z/5CXfGZ
Once i saw something like while("forever") , is that worse than while(1) ?
Works on my machine!
A bit wonky, but all the major compilers seem to optimize it to the same thing.
Yeah, my bad. I didn’t go into the actual uses of it
Thanks so much! I'm sure everyone in the k250 forum will benefit from all the work you've put in if the code gets built. I'm hoping Alex sees your messages and looks at the anon44+anon45 function with you...I think Bill could rebuild it with this information
&gt; I don't mean to be harsh, but if the prospect of doing K&amp;R exercises is something you find yourself actively avoiding, it is a strong indication that software engineering (and computer science, to a lesser degree) may not be right for you. I disagree. I first tried learning programming when I was maybe 13 but bounced off of it for years, and studied something completely non-tech-related for a few years in college before I changed majors and *had* to learn it. At least the way my brain works, it's frustrating and demotivating when getting anything done that's actually *useful* is agonizingly difficult. I don't think having that feeling means you're not mentally suited to be a good programmer, it just means that programming has a steep learning curve and there's a lot to learn up-front.
This looks super cool! Haven't taken a look at the source yet but this seems to be really advanced judgding from the example screenshot. Impressive!
In addition to what was said, I would rename functions to something like deck_create, deck_draw, deck_shuffle etc. I would also organize the repo to include at least a sample program.
About the prints, I would suggest implementing optional logging, with a function to turn it on and set the intended path to it. That's usually a great way to substitute what you're doing with the prints.
Thanks, didn’t think about the deck cleanup :) yes a blackjack sample project was along the way
Thanks, I was actually thinking about doing that... will implement it later on :)
Actually now that im thinking about it, could we just find any Sound Designer 1 file and try to go from there? Or you would absolutely need both the SD1 file and the corresponding QLS file? I can ask the whole yahoo group to see if any user has a pair.
If you’re logging errors, it should be to stderr.
&gt; Shouldn’t I exit even for things like a full heap memory? For a more complex library there's an argument to be made that recovering from OOM is too complicated or even impossible (e.g. correctly freeing a partially constructed data structure requires allocating memory), or that it's not possible to report an error, so the library is justified in exiting the entire program when it happens. To make matters more complicated, Linux systems are typically configured for overcommit, so `malloc(3)` will only fail if you ask for an especially large allocation (e.g. more than the total RAM + swap). However your case is just an initialization function. You could trivially return NULL from `create_deck()` if memory allocations fails and let the caller decide. My suggestion about letting the caller choose how to allocate the struct bypasses this whole problem pretty nicely. Since the caller does the allocation before even talking to your library, it's already their problem. Most likely they'll do something like this and use automatic allocation: Deck deck; deck_init(&amp;deck);
Thanks!
Thanks!
:)
Arduino.
&gt;Save Many people say that Arduino is the so basic and hamper the essence of understanding embedded programming.Therefore , I did not want to start it.
What's your problem with C89? It is more portable and complete and better supported than C99.
Those people are retarded, Arduino is by far the best way to learn embedded programming, systems programming, real time OS, etc. Just because **one of** the compiler+IDE combo's for it is goofy and high-level does not mean they all are. It is still an insanely popular [ATmega328P](http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf) on a durable well-made circuit board designed for first-timers. This commercial 144 laser, 144 laser-collector, 2 scoreboard, 2 button amusement park game room runs off a **single** Arduino MEGA. A processor is a processor, don't let the $20 price and goofy kid IDE fool you. That aforementioned amusement park now has over 100 Arduino's running things around it; they're cheap, consistent, reliable, and easily worked on by lower-tech employee's. They went from a tiny side experiment 4 years ago to being a staple of the business.
&gt; this is basically what I'm trying to do here and I'm mainly stuck on the part for when you have to search for the employee and his info (example you search for him by his name) and want to modify or delete is what I'm stuck on and don't know what to do or if what I'm doing is even possible with what I'm working with. You need to learn more about file I/O and manipulating strings. The way we tackled this problem in my Intro to C course was that basically you want to read the file, store the info in an array of structures, search/compare the strings, edit/delete the info, and write to the file.
Use Valgring, its a life saver. If you use gcc compile with the -g flag and then it can tell you wher eyou make illegal memory accesses!
that much i understand but if you like a link to an example cause it's a bit difficult to understand when trying to figure out how to implement it into the code. thanks again!
Post a reproducible example and we'll be able to make progress on this.
There's a strdup call there, so the function does correctly create a new buffer for each node. One concern would be, when the remove function returns bfr, the node that points to it has been freed - I'd have to look at the code more thoroughly, but anything calling the function to remove the node would need to save that buffer, or a memory leak could result. Also, the while (head-&gt;next-&gt;next) construct is really confusing... if the list is circular, then that should always be true. ... I would add a "tail" pointer that points to the last element added, which might make things less confusing. But I haven't looked at the code very thoroughly, although tracing through the code with gdb should help track down the cause of the segfault.
&gt; `extern int fib(int n);` is the same. It’s just ~~implicit~~ explicit.
Your `printf()` calls may be the problem. `%u` expects an `int`, but you're giving it a pointer. Try: `printf("var1: %p, var: %p\n",(void *) &amp;var1,(void *) &amp;var);` and see what you get.
I’d recommend starting with a Raspberry Pi, or one of its cousins, and start learning how to do things in userspace relating to communications over i2c and SPI, working with GPIO, and then buy some sensors and figure out how to make something useful. A lot of embedded work is done with Linux. You could also pick up a Particle board kit and start hacking away doing similar experiments with that.
Yup yup -- just saw the `strdup` call. I guess I wasn't looking for it, as I didn't see a corresponding `free`.
Not exactly what you asked for, but The Algorithm Design Manual (by Skiena) has C code available here and has several data structure implementations: https://www3.cs.stonybrook.edu/~skiena/algorist/book/programs/ Book: The Algorithm Design Manual https://www.amazon.com/dp/1849967202/ref=cm_sw_r_cp_api_i_dOH8CbQD7R3JM
Check out r/embedded. The wiki has resources about how to get started. &amp;#x200B; I would recommend picking up STM32 or a Tiva C series microcontroller eval board and start programming it.
I think you forgot Space?
Looks really good! I was looking at how you return a drawn card, and it looks like you Don factor in how many cards of a particular suit and value that exists, so that if you have a deck with only three kings and one queen, you will return a king or queen with 50/50 probability?
Best algorithms book
Logging to stderr by default is fine but it's even better to let the user redirect it by injecting a `FILE*` or a set of callbacks.
The code would be much more readable if you wrap your comments up to 80 columns.
As /u/rorschach54 said, /r/embedded is a good place to start. There is also this very useful [video playlist on YouTube](https://www.youtube.com/playlist?list=PLPW8O6W-1chwyTzI3BHwBLbGQoPFxPAPM) that will teach you embedded programming from scratch.
SpaceVim is just a config file of neovim or vim
An Arduino is a great way to start learning embedded programming. When you're just starting, you aren't above the basics.
I think that's about as short as you can go.
Has to be 32 characters or less
What is the full task description?
what are you trying to do, and what are your constraints?
import os, sys, subprocess, shlex, time, hashlib, random, signal, errno from string import * from threading import * from functools import wraps class Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def writelines(self, datas): self.stream.writelines(datas) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr) sys.stdout = Unbuffered(sys.stdout) flag = "$CDDC19${??????????????????????????????}" my_code = open('my_code.c', 'rb').read() class TimeoutError(Exception): pass def timeout(seconds=10, error_message=os.strerror(errno.ETIME)): def decorator(func): def _handle_timeout(signum, frame): raise TimeoutError(error_message) def wrapper(*args, **kwargs): signal.signal(signal.SIGALRM, _handle_timeout) signal.alarm(seconds) try: result = func(*args, **kwargs) finally: signal.alarm(0) return result return wraps(func)(wrapper) return decorator def run(cmd, timeout_sec=5): proc = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE) kill_proc = lambda p: p.kill() timer = Timer(timeout_sec, kill_proc, [proc]) timer.start() stdout, stderr = proc.communicate() timer.cancel() return stdout, stderr def bye(ch): print "You don't need this character: {}".format(ch) print "It makes the code too long, my friend...\n" sys.exit(-1) def check(code): if len(code) &gt; 32: print "Code size is {}! Too long!".format(len(code)) sys.exit(-1) elif len(code) &lt; 20: print "Really? Are you kidding me?" sys.exit(-1) else: bad_func = ["system", "exec", "popen"] for b in bad_func: if b in code: print "Nope! Don't even attempt to pwn this challenge!" sys.exit(-1) for ch in code: if ch not in letters + digits + punctuation: # filter bye(ch) # hint code = list(code) code[2] = 'm'; code[3] = 'a'; code[12] = 'd'; code[15] = 'm'; code[25] = 'a'; code[29] = 'd'; code = ''.join(code) print "Known code : __ma________d__m_________a___d__" print "Curr. code :", code print "(I can reveal some part of the code for you; you're welcome!)\n" return code def randomname(length=32): return ''.join((random.choice(letters + digits) for i in range(length))) def compile_and_run(code): executable = "your_code_" + randomname() source = "{}.c".format(executable) ret = 0 open(source, "wb").write(code) # No need to redo every time below ''' run("gcc -o my_code my_code.c") result1 = run("./my_code") print hashlib.md5(result1).hexdigest() # 75f00cff900c8966fa45a8fecee03ad6 ''' _, err_msg = run("gcc -o {} {} -std=c90".format(executable, source)) if not os.path.exists("./" + executable): print "[FAIL] Executable file does not exist. Maybe there are compilation errors." print err_msg else: result2 = run("./" + executable)[0] if "75f00cff900c8966fa45a8fecee03ad6" == hashlib.md5(result2).hexdigest(): ret = 1 else: print "[FAIL] Results are different : ", hashlib.md5(result2).hexdigest() run("rm {} {}".format(source, executable)) return ret @timeout(10, os.strerror(errno.ETIMEDOUT)) def main(): greeting = '''
Shorten that code to less than or equal to 32 characters
''' import os, sys, subprocess, shlex, time, hashlib, random, signal, errno from string import * from threading import * from functools import wraps class Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def writelines(self, datas): self.stream.writelines(datas) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr) sys.stdout = Unbuffered(sys.stdout) class TimeoutError(Exception): pass def timeout(seconds=10, error_message=os.strerror(errno.ETIME)): def decorator(func): def _handle_timeout(signum, frame): raise TimeoutError(error_message) def wrapper(*args, **kwargs): signal.signal(signal.SIGALRM, _handle_timeout) signal.alarm(seconds) try: result = func(*args, **kwargs) finally: signal.alarm(0) return result return wraps(func)(wrapper) return decorator def run(cmd, timeout_sec=5): proc = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE) kill_proc = lambda p: p.kill() timer = Timer(timeout_sec, kill_proc, [proc]) timer.start() stdout, stderr = proc.communicate() timer.cancel() return stdout, stderr def bye(ch): print "You don't need this character: {}".format(ch) print "It makes the code too long, my friend...\n" sys.exit(-1) def check(code): if len(code) &gt; 32: print "Code size is {}! Too long!".format(len(code)) sys.exit(-1) elif len(code) &lt; 20: print "Really? Are you kidding me?" sys.exit(-1) else: bad_func = ["system", "exec", "popen"] for b in bad_func: if b in code: print "Nope! Don't even attempt to pwn this challenge!" sys.exit(-1) for ch in code: if ch not in letters + digits + punctuation: # filter bye(ch) # hint code = list(code) code[2] = 'm'; code[3] = 'a'; code[12] = 'd'; code[15] = 'm'; code[25] = 'a'; code[29] = 'd'; code = ''.join(code) print "Known code : __ma________d__m_________a___d__" print "Curr. code :", code print "(I can reveal some part of the code for you; you're welcome!)\n" return code def randomname(length=32): return ''.join((random.choice(letters + digits) for i in range(length))) def compile_and_run(code): executable = "your_code_" + randomname() source = "{}.c".format(executable) ret = 0 open(source, "wb").write(code) # No need to redo every time below ''' run("gcc -o my_code my_code.c") result1 = run("./my_code") print hashlib.md5(result1).hexdigest() # 75f00cff900c8966fa45a8fecee03ad6 ''' _, err_msg = run("gcc -o {} {} -std=c90".format(executable, source)) if not os.path.exists("./" + executable): print "[FAIL] Executable file does not exist. Maybe there are compilation errors." print err_msg else: result2 = run("./" + executable)[0] if "75f00cff900c8966fa45a8fecee03ad6" == hashlib.md5(result2).hexdigest(): ret = 1 else: print "[FAIL] Results are different : ", hashlib.md5(result2).hexdigest() run("rm {} {}".format(source, executable)) return ret @timeout(10, os.strerror(errno.ETIMEDOUT)) def main(): greeting = ''' '''
`main(i){return 0;}` done Do you see how ridiculous your request is?
''' import os, sys, subprocess, shlex, time, hashlib, random, signal, errno from string import * from threading import * from functools import wraps class Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def writelines(self, datas): self.stream.writelines(datas) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr) sys.stdout = Unbuffered(sys.stdout) flag = "$CDDC19${??????????????????????????????}" my_code = open('my_code.c', 'rb').read() class TimeoutError(Exception): pass def timeout(seconds=10, error_message=os.strerror(errno.ETIME)): def decorator(func): def _handle_timeout(signum, frame): raise TimeoutError(error_message) def wrapper(*args, **kwargs): signal.signal(signal.SIGALRM, _handle_timeout) signal.alarm(seconds) try: result = func(*args, **kwargs) finally: signal.alarm(0) return result return wraps(func)(wrapper) return decorator def run(cmd, timeout_sec=5): proc = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE) kill_proc = lambda p: p.kill() timer = Timer(timeout_sec, kill_proc, [proc]) timer.start() stdout, stderr = proc.communicate() timer.cancel() return stdout, stderr def bye(ch): print "You don't need this character: {}".format(ch) print "It makes the code too long, my friend...\n" sys.exit(-1) def check(code): if len(code) &gt; 32: print "Code size is {}! Too long!".format(len(code)) sys.exit(-1) elif len(code) &lt; 20: print "Really? Are you kidding me?" sys.exit(-1) else: bad_func = ["system", "exec", "popen"] for b in bad_func: if b in code: print "Nope! Don't even attempt to pwn this challenge!" sys.exit(-1) for ch in code: if ch not in letters + digits + punctuation: # filter bye(ch) # hint code = list(code) code[2] = 'm'; code[3] = 'a'; code[12] = 'd'; code[15] = 'm'; code[25] = 'a'; code[29] = 'd'; code = ''.join(code) print "Known code : __ma________d__m_________a___d__" print "Curr. code :", code print "(I can reveal some part of the code for you; you're welcome!)\n" return code def randomname(length=32): return ''.join((random.choice(letters + digits) for i in range(length))) def compile_and_run(code): executable = "your_code_" + randomname() source = "{}.c".format(executable) ret = 0 open(source, "wb").write(code) # No need to redo every time below ''' run("gcc -o my_code my_code.c") result1 = run("./my_code") print hashlib.md5(result1).hexdigest() # 75f00cff900c8966fa45a8fecee03ad6 ''' _, err_msg = run("gcc -o {} {} -std=c90".format(executable, source)) if not os.path.exists("./" + executable): print "[FAIL] Executable file does not exist. Maybe there are compilation errors." print err_msg else: result2 = run("./" + executable)[0] if "75f00cff900c8966fa45a8fecee03ad6" == hashlib.md5(result2).hexdigest(): ret = 1 else: print "[FAIL] Results are different : ", hashlib.md5(result2).hexdigest() run("rm {} {}".format(source, executable)) return ret @timeout(10, os.strerror(errno.ETIMEDOUT)) def main(): greeting = ''' '''
Shorten https://pastebin.com/YB4hujKM
Haha very funny
https://pastebin.com/YB4hujKM This is the full code
I already have enough muscle memory. Syntax is nothing to me. I can remember parts of the language, just not intricate details, but I suppose the book will go over them more later on. It's hard to explain why I don't want to do some of the exercises. It's pretty much a combination of not being motivated enough, wanting to just read more of the book, and knowing that I probably won't have a good solution. I'm not a complete beginner to programming, I start learning like 2-3 years ago, with C#, and started cycling through different languages, never really getting anywhere. But about a month ago, I started learning C, and I'm enjoying it, so far. I read a small e-book, that introduces you to the basics of C, I've watched all of the lectures of cs50, up until the web programming part, and done all of the problem sets, only "cheating" on a sort of equation for a caesar cypher. It's just that I want to learn more of the language, so exercises that I know will probably take a bit, and that I probably won't have a good solution, just get in my way. Another thing is that the exercises are fairly ambiguous. I sometimes can't tell exactly what they want me to do.
I (and likely others) am losing patience. You keep saying "shorten" over and over as if that's supposed to mean something to us, then you paste a big-ol' snippet without any explanation whatsoever. WHAT IS YOUR (SHORTENED) CODE SUPPOSED TO BLOODY DO, AND WHAT ARE YOUR CONSTRAINTS? Use your words, and stop wasting our time making us try to guess or read through a hundred lines of unrelated code.
"Shorten _this_" means nothing. 1. what the output should be? Maybe there is a way different way to achieve the same goal but we can't know that. 2. No, I'm not going to read a bunch of python code to understand the requirements. _You_ are in charge of explaining us, since _we_ are the one who are giving a favour. 3. how did you arrived to this code snippet? Showing us your train of thought might help us get new ideas 4. What about the input of main or other constraints? Tell us more 5. Be polite. That's gonna help *a lot*
In that case, I sincerely apologise, I do not mean ill intentions Moreover, I’m sorry and I won’t inquire any further
Thanks, I'm will be trying this out this weekend
Unpopular opinion: I didn't like a lot of the exercises in K&amp;R. I think the book itself is excellent and a must read for every computer scientist, but a lot of the exercises were boring and didn't really further my understanding. Writing code is essential, but you can do better than K&amp;R for practice problems. I would advise reading the text, implementing the examples they give, making sure to really understand them, and then do projects on the side to do with the Linux Kernel, which is one of the most significant applications of C.
Hi! I'm a pretty happy user of SpaceVim for C/C++. I would recommend also putting in a point using clangd / the language server, that has been really useful for code completion and linting. Also this is random, but do you know how to make vim's path relative to the currently open file? Right now, it seems to be relative to the directory that has the .git file when you are inside a repo.
Kernighan uses `for (;;)`. It is also the preferred / traditional style in BSD code. The only objective justification I can see for it is that it's one byte shorter.
The `for (;;)` construct used to be very common. Kernighan uses it, and it is the preferred style in BSD code.
&gt; `for (;;)` relies on knowing somewhat obscure behavior of the `for` loop; What's obscure about it? If you don't understand it, you don't know enough C to understand the rest of the code anyway.
Hey thanks for your valiant efforts! I am likely going to take a step back at this point since you Alex and Bill are in way more advanced territory for me.....but if you can continue to cc me on the developments, I can chime in if I have something to offer. It sounds like we are closer than ever before
&gt; `Deck deck;` &gt; `deck_init(&amp;deck);` That exposes the size and layout of `Deck` to the application, which means you can't change it without breaking binary compaitibility in interesting ways.
&gt; What's obscure about it? Why would a missing test default to true instead of just being a syntax error? &gt; If you don't understand it, you don't know enough C to understand the rest of the code anyway. Maybe, maybe not.
The code you posted invokes undefined behavior, so as far as the standard is concerned, it is not *not* equivalent to the following: main(){}
Do you seriously not understand why people are annoyed with you?
I apologise for my unthoughtful action, I don’t know C so I didn’t know what the code is supposed to do But thank you for trying to help me
This has nothing to do with what the code does and everything to do with your inability to communicate.
Sorry for my bad communicative skills. Thank you for your criticism, I will try my best to improve
Or CLion, a proper IDE.
I'm trying to avoid using a tail, hence the circular aspect. I'm building this around the idea that I can add new nodes without needing to keep track of a tail pointer in constant time. This is just for my own challenge :) &amp;#x200B; Are you referring to `current-&gt;next-&gt;next == head`? Basically I'm checking if the next node is the last node, but I can't go to the next node and remove it without having to carry through another pointer. If the node isn't the last in the list, it should be some node other than head, but if it is the last node it will be true.
150/151 may be the problem, I've changed it to this to try to work around it.. if (strncmp(current-&gt;next-&gt;bfr, element, strlen(element)) == 0) { struct node* newNext = current-&gt;next-&gt;next; free(current-&gt;next); // current-&gt;next = NULL; current-&gt;next = newNext; return element; &amp;#x200B; Yeah, I'm used to Java where you can't return a null (I think). I'll change it. &amp;#x200B; I think the add loop is okay... that was working before I added the remove functions. Definitely messy but I think it isn't the problem. Walking through with gdb I don't run into an issue there.
I'll have to work through it with Valgrind. Just been using gdb and that hasn't been sufficient for debugging....
I'm using gdb but I'm not familiar enough with C to know exactly what I should be doing for removing nodes and such :)
This looks better. If you're not using valgrind, you should give it a try -- I didn't look carefully, but you might be leaking data.
PHPStorm in r/vim gets upvotes though. This is interesting.
This is just for my own exploration and learning of the language. I've built many data structures in Java but that's easy thanks to the JRE. &amp;#x200B; I am going to fire up Valgrind to find the leaks that I'm sure are there, I just haven't used it much. &amp;#x200B; Your third point is exactly what I'm trying to find - I want my remove function to handle the memory as well. Would I need to remove the bfr string with free and the next node pointer with free separately? Couldn't you just do something like `free(current-&gt;next-&gt;bfr)` to free the string from the current's next node? These are the things I really don't know about C because I've always had memory management and pointers done for me with Java.
Hey LorenWard, I hope you have a wonderful day.
Is there any way to do a decent watch window or breakpoints?
People in /r/vim know where vim falls short, people here don't.
Could you link the wiki? I can't seem to find it
Check the pinned post. It should have the link.
Source code please.
Paste your code on pastebin and link it here. Nothing we can tell you from what you’ve posted, aside from adding more logging in more places or stepping through the program with a debugger.
Here's the code of the function I'm writing: &amp;#x200B; void masterdoc () { printf ("In masterdoc\n"); _Bool is_date (char [80]); void apply_date (char [80], _Bool); int read_file (char [80], char [1000][1000]); int put_file (char [80], char [1000][1000]); void write_to_file (char [1000], char [1000][1000], int); char filename[80] = "operation\\MasterDoc.txt"; char file[1000][1000]; if (!is_date (filename)) { printf ("Not date\n"); apply_date (filename, 1); read_file (filename, file); write_to_file ("000", file, 1); put_file (filename, file); } else printf ("Is date\n"); } As I said in the post, there are no compiler errors, and each of the functions this function calls has been tested and works.
Set a printf after the function calls, too, and make sure it's not silently crashing. Then check that you have the functions declared and defined properly. And put some code on pastebin or something if you want us to look at it.
Yeah
Cool. Yeah - I've put printf calls at the start of each independent function being used and none of them trigger. The printf call in the if statement of the masterdoc() function is the last thing to display. Here's the pastebin: https://pastebin.com/8TS8Csvt
Edited the post &amp;#x200B; [Here's the pastebin](https://pastebin.com/8TS8Csvt)
Line 25 is overflowing the stack. 1Mb is too much.
Almost every function uses the file[1000][1000] structure and hasn't had an issue so far. I've used it to successfully manipulate .txt files in a number of ways. Because of this, I am not sure that is the issue. Is there a way to confirm that this is it?
Do you understand how the stack works? Every function call is adding another 1MB stack frame. And regardless of whether it "works" it's the wrong way to do it.
The default stack size on Windows in 1Mb. Maybe you can get away with using 1,000,000 of it in a tiny program, but it is very bad practice and in any reasonably sized program it is fatal. Use malloc.
I do not have any knowledge of the stack. I'm working off the knowledge of half of the Programming in C book I got for a class. It does work - however, I've only used it in very small scale functions. I have used it as a duct-tape and spit way to manipulate .txt files, which is necessary for the project I'm working on.
Coincidentally, I stopped reading my C book when I reached the chapter on pointers. When using malloc, this adds only a pointer to the stack of a location in memory which can house lots of data? I appreciate the help.
Check again what the first argument of `fwrite` is supposed to be and what you're actually passing it.
The stack is a first in, last out buffer - there's a single stack per task, and a special register in the CPU tracks the current stack position. Any time you declare an automatic variable (one that's not global or local and static) space is made for it by simply moving the stack pointer down. And any time you call a function, parameters are passed on the stack, along with the return address. That means recursive functions rack up stack usage fast. I mostly work in embedded systems where you're lucky to have a few hundred bytes of stack space. Using malloc() allocates memory from the *heap*. The heap can be implemented in many different ways internally, but regardless of the implementation details, you ask it for a chunk of memory and it either gives you a pointer to a chunk of memory or NULL if it can't. That chunk stays allocated until you call free() with the pointer. It's up to you to make sure it always gets freed or you'll end up with a memory leak. But this is the way you'll normally allocate any large chunks of memory. You've also got a few other things in your code that I would avoid. Don't put function declarations in function scope: _Bool is_date (char filename[80]) { printf ("In is_date\n"); _Bool is_equal (char [80], char [80]); That last line doesn't belong there - it's syntactically valid but I'd consider it very bad form. Move that up toward the start of the file, above all of the function definitions. And give all of your parameters names. I also virtually never see C functions declared with arrays like that - usually it's going to take a char \*. When you're providing functions accessible from other source files, the function declarations will normally go in a .h file with the same name as the .c file where they're implemented. Any file needing those functions will #include the appropriate header. For functions *not* exported and used only in this file, put your declarations above all of the definitions, and get in the habit of declaring them `static`, which will keep them from being linked by anything else accidentally. Declare your functions fully, with all of the parameter names, and make sure the declarations match the definitions. Some of the shortcuts and more terse syntax that might have been more acceptable historically are considered bad form now.
I don't know about it. Is it useful for large number of linked .c?
Thank you :)
breh you made a typo...
From your ``char name[20]`` I assume you've covered arrays. Have you covered pointers, strings and structures yet? Since you want to store info about multiple employees you will need an array of structures. You search the array of structures using a function like [strstr()](https://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm), then edit the string, then write the array of structures to a file.
fopen() will create files if they do not exist, and erase/blank them if they do. What you want is "a" in there for "append". http://man7.org/linux/man-pages/man3/fopen.3.html
Oh thank you!
Nah, I prefer Emacs. j/k, I prefer Atom.
This code is a bit much for me to unpack, but I'm gonna offer some random comments: Putting forward declarations of functions inside other functions is technically valid, but it's not idiomatic C. Put them near the top of the file or in a header. Way too many magic numbers everywhere. `char filename[80] = "MasterDoc.txt";` can be written as `char filename[] = "MasterDoc.txt";` You're not validating operations that may fail, like opening a file. The code segfaults for me here unless I make it point to a empty text file (after which it seems to call a bunch of other functions). FILE *ptr_file; ptr_file = fopen (filename, "r"); fgets (readDate, 1000, ptr_file); If I do make it point to an empty text file, I get the following output on Linux: In masterdoc In is_date In is_equal Not date In apply_date 06/01/2019 In read_file In put_file In read_file In write_to_file In read_line In end_line In put_file The C standard library has a built-in function for testing whether two blocks of data are equal or not: memcmp. If you need a big hunk of data, allocate it on the heap with malloc (don't forget to free it). The stack isn't that large.
1 - you can dive in, but don't expect to understand all the details or make significant contributions. Honestly, for someone that's new I would suggest documentation changes/updates before code. 2 - there's a free book online about Linux kernel programming. Walks through driver development and interrupts and stuff. I used it when working on kernel stuff and it was useful. 3 - IMO, doing it. Especially fucking up while trying to do it.
&gt;Linux kernel programming I'm not talking about Linux specifically, I want to learn kernel development in general.
Sure. It applies in general.
Ok
Ok I'm trying everything I found so far from research but nothing sticks, here is the thing that is bugging and the main source of my problem is how can i store information, and that is in keeping that info that was taken from a user safe in an array of structures and then once we restart the program it does not get lost and i can search for it and be able to edit and then write it into the file again.
It also used to be more efficient than while(1), so you'll definitely see it in older books and code, but nowadays there's no difference from a performance pov.
Head over to https://wiki.osdev.org/Bare_bones
Look into flashcards (anki or just paper) and spaced repetition. It's really helped me with retaining certain core concepts and even code snippets and patterns.
[OSDev Wiki](http://wiki.osdev.org/Main_Page)
https://repl.it/repls/LeafyPointedStructures This exact code fails on the number 0x7F80001 - or 0x7FC0001 on my 32-bit Linux system running on GCC, depending on whether you look at the actual float or float_bits object. It passes without issue on repl.it, where I have shared it. This raises further questions (are floats on my laptop not 32 bits? I highly doubt it...), but that's what is happening, plain and simple. I am willing to agree that memcpy is not bugged - I made some alterations while troubleshooting and one of them is that I switched to unions! memcpy is never invoked in the code but the same error occurs regardless. Sorry for this weirdness. I really wish I had a better idea of what was going on and how to figure out the problem on my own, so that I wouldn't have to bother you with this.
You can always buy a cheap micro and start writing a kernel for it.
Before (or while) jumping into kernel programming, work through Advanced Programming in the Unix Environment. You want to be rock-solid about understanding file descriptors, synchronization, and how system calls work.
I'll give it a read, thanks.
There is nothing obscure about `for (;;)`. It has been the idiomatic form of an infinite loop in C from the very beginning, mentioned even in the first edition of K&amp;R.
C++ is off-topic, but if I had to guess, the 8MB+ of thread_col is blowing through your thread’s stack. Try allocating it on the heap.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
&gt; letting the caller allocate it and, equally important, let the caller free it. I haven't looked at the library but if the lib does the freeing as well, it will cause someone down the line some frustration
You are creating `pixel_col` on the stack. 600×600×3×`sizeof(double)` is typically a bit over 8 MiB, that's way too large for the stack. For 500, it works only because I guess you are running it on 64-bit Linux which has default stack size of 8 MiB; it won't work on Windows or 32-bit Linux. You need to allocate it on the heap using `malloc`.
Oh im sorry I thought the subreddit was for both cpp and c.. but could you just tell me how id do that or just head me in the right direction? Ty
Im sorry I thought this was for both c and cpp
I have tried using malloc I just camt find the way to allocate it I went as far as looping through each value of h and w and couldnt do it.. can you specify the way you'd do it please?
Use the new[] operator, or better yet, wrap the allocation in a std::unique_ptr so it handles releasing the allocation automatically. Can’t remember the syntax off the top of my head.
Thank you Ill definitly try and look those up as soon as I can
Damn im high I replied to a different answer here before sorry lol
No problem! Just post to /r/cpp_questions.
Since you are using C++, I will go for `unique_ptr`: ``` auto pixel_col = std::make_unique&lt;Color[]&gt;(w*h); ``` Then you can access the value at (x,y) with: ``` pixel_col[x*w+y]; ```
This is very nice. Thank you :)
In the first `if` it should be `!= NULL`. The fopen function returns null if opening failed.
Ye I am checking if opening failed, meaning there is no such file. So I write something on it to create it
You actually go on to call `fwrite` though, which doesn't create the file and causes undefined behaviour by passing `fp`, which doesn't correspond to an open file, to `fwrite`
Your example only demonstrates that they're treated the same by that compiler for that particular code
Yeah but my program makes all the array elements 0 at start. So if there is no such file, which returns a NULL, I will write all 0 array on it. If there is a file, I will not reset it to 0 by writing on it and instead I will read the array data from the file. Avoiding to lose data.
Using local function declarations is a bad idea as you will miss out on compiler diagnostics if they are wrong. It would be better to have them all near the top of the file (if the project is all a single file), or correctly placed in header files otherwise.
`b` is required on some operating systems. It's easy enough to write portable code in this case (pressing 1 extra key compared to the non-portable version).
Compiler explorer lets you choose may compilers and options. Is there a compiler at that site which gives different results between "while" and "for"?
&gt; So if there is no such file, which returns a NULL, I will write all 0 array on it. That's not possible. You can't write to a file that doesn't exist. (I am guessing from your comments that maybe you think returning NULL means that it successfully created a file? It actually means that it failed).
Don't know, I haven't tested all possible combinations and programs.
No, I mean when I fopen something but it was not created before, I get a NULL return. If I then attach a file pointer to the file and fwrite data on it, next time when I run the program fopen does not return null. I know it is a bad way to check if the file already exists but I dunno any other way to check.
Ah good to know.
`NULL` return from `fopen` means that no file was opened (and most likely none was created either). Think about it: after `NULL` is returned you are calling `fwrite(&amp;foo, 1, n, NULL);`. How is that supposed to write to whichever file you had in mind? Once you've fixed the parentheses bug I mentioned earlier, you should get a segfault or crash of some sort when that statement is executed.
https://kernelnewbies.org/
If your program is exclusively Unix where the end of line character is simple '\n' then you don't need "b" If you intend to run it on dos/windows (which it seems like since you included conio.h), you need to include "b" or dos/windows will translate their 2 character line ending "\r\n" to just "\n". This could lead to corrupted files should your binary file contain the "\r\n" sequence. When in doubt, use "b" for binary files, if nothing else to show intent.
I don't think this matters at all. They'll both perform the same, and are both common and easy to understand idioms. Use whichever one you want.
If you do get this book, get the latest edition you can. The first edition in particular is full of errors in the code listings.
Redox blogs describe writing a kernel from scratch. Also, see textbooks on Operating Systems for guiding principles.
for s use getline() to insert and malloc to allocate memory
Well, the traditional approach is to get a book on Operating Systems. It will talk about threading and semaphores and stuff. The other part you're going to have to learn about is the microprocessor you're going to run on. I'd start with ARM because it is 1000% times more straightforward than x86. Linux is a huge beast. I'd start by trying to understand something simpler like FreeRTOS. Getting a piece of virtual or real hardware to main() is a good first start. Then you can get a simple superloop going.
https://github.com/sakhnik/nvim-gdb This works fantastically, but I'm not sure if it will work with vanilla Vim, it may use some neovim specific things.
Use getline(fp,buffer) function. pass file pointer as first parameter and string as second parameter.
&gt; I wouldn't have to bother you with this. I asked for the code, it's no bother :P What is a bother is when people report a problem and don't post their code, so anyone trying to help has to make a bunch of guesses. I still suspect the copying by value of `float` to be the problem. In your new code you do this twice now (in the call to `show_float`, and in the line `float bitwiseEquivalentFloat = bitStr.f;`). To test this hypothesis, change: show_float(bitwiseEquivalentFloat); to show_bytes(&amp;bitStr.i, 4); show_bytes(&amp;bitwiseEquivalentFloat, 4); show_float(bitwiseEquivalentFloat); and similarly for the other call to `show_float`, and see if all 3 lines give the same output or not. Also the code `*(int*)&amp;(twiceFloat)` causes undefined behaviour due to violating the strict aliasing rule. Instead the code could be: float_bits x = float_twice(bitstr.i); if ( memcmp(&amp;twiceFloat, &amp;x, sizeof x) != 0 ) { Another thing is that `show_int` should take `uint32_t` rather than `int`, since that's what you pass to it.
I was once told: those who built the kernel are infinitely smarter than you are. And if you don’t believe that, jump in.
Also the positions of EIP and EPB are reversed. The CALL will push EIP first then ENTER ing the frame will push EBP https://en.m.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames
I like it.
Same here. I also am getting started. I also want to get into kernel development. I am currently reading the Linux Kernel Development book by Robert Love. I think it is good read for starters.
I am by no means a kernel programming expert, but I got my start because we needed a kernel driver written for some... let's just say, unique hardware we needed to use at work. My best advice is to learn by doing, and there are some pretty good open source documents out there for learning kernel programming. And, start with kernel modules.
Hmm I will look into it thank you. As I stated, I am super new to coding and especially coding with files. Thank you for advice
Ty for ur advice !
There's two (standard) ways to create a pointer. One is the address of operator, &amp;, which you've used. The other way is to call malloc/realloc. Declaring a pointer variable is not enough, you have to assign to it using one of those methods. Getline calls malloc for you so there you avoid one call to it, but the array itself has to be allocated as well. That's why you're counting the number of lines, so that you can call malloc to allocate the array. Another approach would be to realloc as you read more lines, but you can look at that later perhaps.
Do you have a link to the book you mentioned in your 2nd option
Hmm, apparently the one I'm thinking if us just kernel modules. https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;url=https://www.tldp.org/LDP/lkmpg/2.6/lkmpg.pdf&amp;ved=2ahUKEwiw0dDHscriAhXtzVkKHalrA4UQFjAOegQIAhAB&amp;usg=AOvVaw121JmkrxaZeuigJecIyJwa I've found one for pure kernel Dev before, but the docs in the kernel source are probably good too.
Looks like a good read. Thanks
&gt; where to go next Probably not a subreddit about the C language. Try /r/cplusplus or /r/cpp or /r/cpp_questions.
There is small OS called Xinu and a text book that goes along with it. The OS is open source and I found the book online at some point. It was what we used in my operating systems class. If you work your way through it you will know most of the core kernel dev stuff.
I'd consider learning on a tutorial OS such as [xv6](https://pdos.csail.mit.edu/6.828/2018/xv6.html), [pintos](https://cs.jhu.edu/~huang/cs318/fall17/project/guide.html), and there's a few others. Then I'd tackle learning practical kernel design and programming.
No
It's a book that explains the xinu os( I forgot how it is called but you can search on google, is not that populare and is free). It was the best book I've read, very clear and explicite and with good examples. I highly recommend it!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
NEVERMIND IT WAS THE SCANF FUNCTION
Any recommended beginner-level operating systems books?
Andrew S. Tanenbaum books/courses on Minix, it is how Linus Torvalds started out
Oh sorry, I tried looking for a C++ subreddit and all I saw was this so I thought this was it.
Recently, I got interested in kernel programming and found this git book. I think it is quite interesting :) [https://0xax.gitbooks.io/linux-insides/content/](https://0xax.gitbooks.io/linux-insides/content/)
Recently, I got interested in kernel programming and found this git book. I think it is quite interesting :) [https://0xax.gitbooks.io/linux-insides/content/](https://0xax.gitbooks.io/linux-insides/content/)
Great lib!
Will there be a big difference between the second edition (1997) and the latest, the third edition (2006)?
AFAIK, the third edition deals with Minix 3, while the second edition deals with an older version of Minix.
[OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/) is used for my OS-course and it's open source! It is widely praised for its readability but is a bit light in some respects which require further reading or re-reading.
It occurred to me 20 seconds after posting this: The consumer of the struct may not want to initialize all fields by hand, and they may want to leave some fields zeroed out. C99's designated initializers initialize (zero-out) *all* members of the struct not present in the initialization to `0`. The only way to achieve the same effect in C89 is to use `memset` or the `static struct name Empty;` (file-scope) hack.
quack.
This is one of those pieces of motherhood advice that doesn't really improve the quality of code and just satisfies someone's personal tastes. &amp;#x200B; The link describing memsetting structs as "bad" really only says its bad "because its 2019" and then turns around and links to the following article describing how the proposed alternative to memsetting structs is actually bad but for technical reasons not for "taste" reasons: [https://lwn.net/Articles/417989/](https://lwn.net/Articles/417989/) &amp;#x200B; There is \_nothing\_ technically wrong with memsetting a struct and especially if you are trying to write a secure program it is the preferred method, \_especially\_ when allocating on the stack.
I think the idea of zero-ing out the struct is if the struct was ever extended with other members, that zero can be a safe assumed default value. The author that extended the strict can then assume safe assignment vs stack garbage. In kernel/user-space APIs it would be impossible to track down all users of the API and update with additional initializers. Zeroing prevents sudden incompatibility or non-determinism. There is still the argument of updating struct usage to include explicit initialization of all members vs just the ones it’s interested in using. A code block may only need a subset of the members and it keeps down the level of copy/paste dead code or possibly confusing a maintainer (I know they omit everything here...is it because they want to init or does it have special value meaning?).
OSTEP (Operating Systems, Three Easy Pieces) is an excellent book. It's freely available, you should absolutely read it. When I was learning about kernel modules/kernel programming in general, I bought a Raspberry Pi (which every system dev should own anyways) and wrote some kernel modules/drivers e.g. for a DC motor, ultrasound sensor, servo, ... This helped a lot to feel confident in kernel modules. Also with the RasPi you can *see* what you are doing when you drive a motor, light an LED, etc.y
The STM32 is a great choice! Definitely pick one of those and start with simple functionality like Blinky LED. Later implement e.g. a I²C or SPI connection to a sensor and so on.
It's not available for Linux...
QtCreator is very good. It supports all common platforms, is freely available as community edition and the tools are satisfying
1. You are scanning the input into a String and comparing it to a single char. That doesn't work. 2. Use strcmp() to compare Strings in C
What error messages are you getting from your compiler? What have you done so far to debug?
First you need to open a file for writing using `fopen()`. To write in it, you will probably want to use `fwrite()`. You can't simply shove an array into a file, so you need to come up with some kind of format in which you'll then save the data byte by byte, so you can load it again later and understand that it's supposed to be a matrix of sizes x and y. You could, for example, write the height and width into the file first and then the data.
Yes, you are doing it wrong. First: in the future, please enable compiler warnings and fix them before asking for help. If you're using gcc or clang, use ˋ-Wall -Wextraˋ. If you don't understand a warning, start by checking the documentation for the function you are calling at the point where the warning occurs. If this doesn't help, or the warning does not refer to a function call, try googling. If you still can't figure it out, ask us, but make sure to include the exact text of the warning and the location where it occurs. Now, let's focus on the part of your code where you open and write to the file: if ((fp = fopen("test2.bin","wb+")== NULL)){ fwrite(&amp;array,sizeof(int),30,fp); rewind(fp); printf("create\n"); } else{ fclose(fp); fp = fopen("test2.bin","ab+"); fread(&amp;array,sizeof(int),30,fp); rewind(fp); } On the first line, your intention is to open the file for reading and writing if it exists, and if not, create it and write zeroes to it. This code fails for three reasons: 1. The first of the final two parentheses is misplaced. As it stands, your code says "initialize ˋfpˋ to the result of the comparison between the value returned by ˋfopen()ˋ and ˋNULLˋ". This is 1 if ˋfopen()ˋ returned ˋNULLˋ and 0 otherwise. Neither of these values is a valid file pointer. You need to move this parenthesis to before the equality operator, so the code says "initialize ˋfpˋ to the value returned by ˋfopen()ˋ, then compare this value to ˋNULLˋ". 2. You assume that ˋfopen()ˋ returns ˋNULLˋ if the file does not exist and that ˋNULLˋ is a valid reference to a newly created file. Neither of these is true: ˋfopen()ˋ will return ˋNULLˋ if the file does not exist and could not be created, *or* the file exists but is not writeable. Furthermore, ˋ"wb+"ˋ actually means "open or create the file for reading and writing, and if it exists, truncate it", which is most definitely not what you want. 3. You cannot pass ˋNULLˋ to ˋfread()ˋ, ˋfwrite()ˋ, or any other function that operates on file pointers. If the condition is true, i.e. ˋfpˋ is ˋNULLˋ, your program will crash on the first line of the ˋifˋ block. Let's continue. If the condition is false, meaning that the file exists, your program will enter the ˋelseˋ block. You begin by closing the file, which at this point is empty due to the incorrect mode in the first ˋfopen()ˋ call. You then reopen it in append-only mode, meaning that the file pointer will be at the end of the file. You then try to read from the file. Since you are at the end of the file, this will always fail, even if the file is not empty. What's more, in append-only mode, ˋrewind()ˋ has no effect on writing; anything you write to the file will *always* be appended to the end. What you need to do is: 1. Attempt to open the file in read-write mode without truncating it, using ˋ"rb+"ˋ. If this succeeds, try to read your data from the file, but check the return value from ˋfread()ˋ to make sure that you succeeded (i.e. that the file contained at least as much data as you expected). Then use ˋrewind()ˋ to move back to the beginning of the file. 2. If the first ˋfopen()ˋ failed, open the file in read-write mode with truncation / creation, using ˋ"wb+"ˋ. If and only if either of the above succeeded, you are ready to input data from the user and write it out to the file. Otherwise, you should print an error message (preferably one that says exactly which of the above operations failed) and exit. By the way, ˋ&amp;arrayˋ will appear to work but is incorrect; it has the correct value but the wrong type. The reason is that wherever the name of an array appears alone (without a subscript), it is interpreted as the address of its first element, which is also the address of the entire array. Just use ˋarrayˋ.
I edited my post I think I did not ask my question properly.
 int **matrix_export(FILE *fd, const int **matrix, const size_t size_x, const size_t size_y) { size_t i; size_t ii; for (i=0; i&lt;size_y; ++i) { for (ii=0; ii&lt;size_x; ++ii) if (fprintf(fd, "%d," matrix[ii][i]) &lt;0) return (NULL); if (fprintf(fd, "\n") &lt; 0) return (NULL); } return (matrix); }
Thank you! So I can use `fprintf()` on binary files too? I did not realize that :) Can I do the same method to read data from the binary file?
I made the changes as you suggested, with a couple minor alterations. I decided to make another show function for show_uint32_t rather than change show_int), and I also added one more show_bytes that, while redundant, was my way of making 100% sure. The altered code is now as follows: void show_uint32_t(uint32_t x) { show_bytes((byte_pointer) &amp;x, sizeof(uint32_t)); } //lots of other stuff that stayed the same if (memcmp(&amp;twiceFloat, &amp;x, sizeof x) != 0) { /*if (isnan(twiceFloat) &amp;&amp; floatNan(f)) { continue; }*/ printf("FAILURE\n"); printf("Float bits before doubling:\n"); show_bytes((byte_pointer) &amp;bitStr.i, 4); show_bytes((byte_pointer) &amp;bitStr.f, 4); show_bytes((byte_pointer) &amp;bitwiseEquivalentFloat, 4); show_float(bitwiseEquivalentFloat); printf("Float bits: "); show_float(twiceFloat); printf("float_bits bits: "); show_uint32_t(float_twice(bitStr.i)); printf("Original float_bits: "); show_uint32_t(f); return 0; The message printed out is: Float bits before doubling: 01 00 80 7f 01 00 80 7f 01 00 c0 7f 01 00 c0 7f Float bits: 01 00 c0 7f float_bits bits: 01 00 80 7f Original float_bits: 01 00 80 7f In other words... indeed, something goes on when I copy it to a float. It looks like the bits are failing to be set identically as long as the value is the same, just as you said. Would the best way to ensure bitwise equivalence be bitwiseEquivalentFloat = 0 &amp; bitStr.f; ? On a side note, this sort of thing (dealing with the difference between the C code I write and the underlying architecture, generated assembly, and precise behavior of the program) is the whole point of the book I got this problem from. So it's actually pretty cool that this issue directly pertains to what I'm trying to learn!
You do it in a 2D array the same way you would a 1D array. You can only write one row at a time, so you would just write each row in a loop. The only issue is what order you should be writing in, in other words the format, which is entirely up to you.
What about types where a zero value is not represented by all-zero bits?
so like that?: int i; for(i=0;i&lt;x;i++)fwrite(array,sizeof(int),y,file_pointer);
You have a couple options there; restrict yourself to pointers as members only since the standard guarantees that 0 will always equal a NULL pointer, or more generically, account for that possibility in your design. The bottom line is that the _only_ safe and portable way to wipe the entirety of the address space allocated to a struct is with the memset method or some other "byte shoveling" method. It just isn't possible with individual member access and of course you could play games with pointer arithmetic but padding is entirely implementation defined the standard only guarantees the ordering of the address offsets into the struct match the ordering of the member declarations. I am personally of the "handle it in your design" camp.
void call(int \*a) { \*a = 1; } &amp;#x200B; int main () { int k; call(&amp;k); printf("%d", k); return 0 }
The error are generally in the addnewcontact function It says many variables are not declared i guess its about the function parameters
What to do if I want to return more than one int that way, but a whole array?
Rember that you're giving \`call()\` a copy of *k*. When you call malloc in call(), you're only updating the copy call() has - \`k\` is still unintialized.
You want to fill an array with the function call?
[https://textuploader.com/1dqvc](https://textuploader.com/1dqvc)
It's basically the same: void call(int * p, int size) { for(int c=0;c&lt;size;++c) { p[c] = 1; } } int main() { int a[10]; call(a, 10); } somthing like that.
You do not know size of a before...
&gt;since the standard guarantees that 0 will always equal a NULL pointer The standard does \*not\* guarantee that the NULL pointer bit pattern is all-zeros, which is what memset to zero will set it to. Assigning a zero int to a pointer (via the assignment operator) is not the same as memsetting that pointer's memory to all-zero bits. &amp;#x200B; &gt;surely if a zero value is not all zero bits and you pass a zero literal to memset as the write value, the zero literal would be represented by the same bit sequence as whatever the not-all-zero-bits zero value is Different types can have different bit-patterns for a "zero" type. memset() doesn't know anything about the underlying types it's overwriting. C \*guarantees\* that an int type has all-zero bits for a zero value. Other types (pointer, float) do \*not\* have this guarantee, so the compiler does the work of outputting the correct bit values for that type when assigned to. But that's not what happens with memset; the only type it uses for every byte it overwrites is 'int' (appropriately cast to a char type, typically). ie. all-zero bits. &amp;#x200B; &gt;The bottom line is that the *only* safe and portable way to wipe the entirety of the address space allocated to a struct is with the memset method or some other "byte shoveling" method. And \*I\* say, this isn't portable. But it's often practical. Still, there may need to be proper semantic initialization of some types, even zero values, after memsetting to all zeros.
To be honest i didn't read that, but i suppose that you want to do something like this? &amp;#x200B; void call(int \*k, int i) { \*k=i; } int main () { int a\[5\]; int i; for(i=0; i &lt; 5; i++) { call(&amp;a\[i\],i); printf("%d ", a\[i\]); } return 0; } &amp;#x200B; outpout: 0 1 2 3 4
One way to do it would be to have a get_size() call/define, or maybe `call()` can return the correct size, so the caller can allocate the right amount of memory and try again. Another option is to have `call()` return a struct with a pointer to the allocated data, and a size. Of course, you have to remember to free it, so this is not a great solution in C.
Either: int * call () { int * arr = (int *)malloc(sizeof(int) * n); return are; } Or Void call(int ** part) { *part = (int *)malloc(sizeof(int) * n); } Although when you do that you have to keep track of who owns the memory.
Solution: ... int** a malloc(sizeof(int*)); call(a) ... call(int ** a){ ... (*a)=malloc(ArraySize * sizeof(int)); ... }
You don’t need the first malloc.
Why?
`array[i]`, but other than that, sure.
The pointer to the array: “int *” can live on the stack. You don’t need to dynamically allocate it.
But how does the pointer know, where it is pointing to?
Once you assign it, it knows. ... int * parr; // currently contains garbage ... call(&amp;parr); // You take a reference to parr. ... void call(int ** parr2) { // parr2 - now parr2 has the address on the stack of the parr variable from the calling frame *parr2 is still junk (*parr2) = (int *)malloc(sizeof(int)*n); // the variable on the stack in the caller is now updated to the address returned from malloc }
understood. Thank you.
Is kernel programming for a beginner possible? I always thought that was something way up there
I'm not seeing anything particularly wrong, though your code sample is incomplete. I believe each `write(2)` will appear properly as a single, short `read(2)` on the other side, so I don't know what's causing the deadlock. However, in general you should `close(2)` the pipe ends you're not using in each process.
So I agree I made a couple oversights here regarding internal representation (I'm working off the top of my head). One thing I will mention is that I don't typically find myself allocating a struct on the stack. I generally use calloc on a pointer to a struct and then initialize individual members as needed. My (up till now) implicit intention is that memsetting of the struct is not set-it-and-use-that-value but a literal wipe of memory.
Open the file in a text editor to see what was written.
&gt;My (up till now) implicit intention is that memsetting of the struct is not set-it-and-use-that-value but a literal wipe of memory. Because of protocols using checksumming, etc. (such as networking), it has traditionally required memsetting of some structs to zero in order to ensure proper setting of unused (even unspecified) bits. I think this has lead to some confusion by developers as to the purpose of setting all of a structs bits to zero before use.
The child branch is missing an exit. After the answer is found, there will be two processes continuing rest of the program.
Sure. You're still doing "kernel programming" even if you aren't making additions to an open source distro. I used [this](https://www.amazon.com/Kernel-Projects-Linux-Gary-Nutt/dp/0201612437/) book, which walks you through projects like querying the state of the kernel using /proc, writing a POSIX shell and device drivers, etc, all in lab manual style, which means you will need to learn how to read up on relevant topics yourself. It was honestly a pivotal resource in my journey learning how to write *good* software; starting there also gave me an excellent foundation for when I ultimately decided to move beyond C, because *I had learned how to learn* in the context of computer science.
it wrote 123456
Right, that's a single number, not 6.
yeah but it reads it as 6 integers, because when I input &gt;11 4 55 2 88 9 it outputs &gt;11 4 55 2 88 9 &gt; &gt;\[gibberish\] 4 55 2 88 9 which means it knows where is an integer.
Thanks for the reply. I've tried this sort of thing with random source code (I think FFMPEG), as a beginner I found myself understanding 50% of what was going on and having to switch back and forth from header and .c files through the Github. But largely what I'm asking is what'd you do when you didn't even understand what exactly was happening in the book? If that did occur.
Show how you are reading file, please?
Linux is an easy one because the docs are so comprehensive. It takes a bit of getting used to, with the precise, technical language used, but it's not insurmountable. Consult it as needed and you'll start to build a picture of how all the pieces fit together.
When writing your numbers to the file, you need to separate them with spaces or newlines so they will be seen as separate numbers when reading, rather than just one huge number. Also, why do you start by opening the file in append mode, rewinding it, and closing it? If the file already exists, it has absolutely no effect. If it doesn't, it will crash your program. Also also, why did you delete your previous question, and did you read [my answer](https://www.reddit.com/r/C_Programming/comments/bvmshv/c_binary_files_blanking_out/eptkisj/)?
Here's what happens: 1. You input six numbers from the user into `array`. 2. You write those six numbers to the file without separators, so they look like a single big number. 3. You attempt to read six numbers from the file, but `fscanf()` can only find one. The first call succeeds and attempts to store the big number in the first array element, but it overflows, so you're left with apparent gibberish. The next five calls fail and leave the rest of the array untouched. 4. You print all six elements of the array. The first is the number that was read from the file. The next five are left over from when you first used the array to get input from the user, so they appear to be correct, but if you cleared the array before reading from the file, or used to separate arrays, you would get a different result.
Stop using append mode. You clearly do not understand what it does. Use `"rb+"` to read from and write to an existing file, and `"wb+"` to read from and write to a new file or replace an existing one.
Indeed. In the Linux kernel, it's a sin to not zero out the entire structure (even if every field is being set by hand). Linux changes structs now and then, by adding new fields, and any new field that's added to a struct has to have the behaviour that nothing will break if that field has been initialized to zero. As long as everyone follows the "zero out the whole structure" discipline, things work out.
Also with UNIX/POSIX things more generally, sometimes field names are macros that reference into `union` sub-fields, which makes in-place initialization a little iffier—for example, this shows up with `struct sigaction` where it’s possible (but not guaranteed) that `sa_handler` and `sa_sigaction` are in a union. However, even back to C89 you can generally do `= {0}` for any initialization (even of non-`struct`/`union` IIRC) to zero it out, so `memset` is only really necessary if you’re acting on something outside your scope. Outside of POSIX, `memset`ting things may be iffy if there are pointers involved, because C-per-se doesn’t guarantee that all-zeroes is a valid representation for `NULL`. In that case, designated initializers or `={0}` are more portable than `memset`.
Why not just use `StructType *Name = calloc(1, sizeof StructType);`?
The only way to ensure bitwise equivalence when copying is `memcpy`. And yes, this is a great lesson about C operators generally being value-preserving, not necessarily representation-preserving :) Off the top of my head, some other cases of this principle: * If assigning structs, the padding bits might not be copied over. * `short x = -3; long y = x;` results in `y` being `-3` due to value preservation -- you do not need to know about "sign extension" or negative number formats to understand the result. * In a sign-magnitude system (esoteric now), integer negative zeros might be transformed to non-negative zero. * If the implementation allows `_Bool` to be represented by any non-zero bit pattern (some compilers do this while others force 0x01 or 0xFF), then `void f(_Bool a) { _Bool b = a; // ... }`might result in `a` and `b` having different bit patterns.
The POSIX standard requires the pthread implementation to insert the appropriate memory barriers, AFAIK. Volatile is no good for portably synchronizing threads in a multiprocessor context, since it is not required to prevent instruction reordering/cache coherence/any kind of synchronization between threads.
void call(int **a )
When I tried compiling your program (`$ clang phonebook.c -o phonebook`) these are the errors I got: phonebook.c:37:15: warning: format specifies type 'char *' but the argument has type 'char (*)[20]' [-Wformat] scanf("%s", &amp; new); ~~ ^~~~~ phonebook.c:41:17: error: use of undeclared identifier 'newnumber' scanf("%s", &amp; newnumber); ^ phonebook.c:45:17: error: use of undeclared identifier 'newemail' scanf("%s", &amp; newemail); ^ phonebook.c:51:5: error: use of undeclared identifier 'pr' pr = pr -&gt; next; ^ phonebook.c:51:10: error: use of undeclared identifier 'pr' pr = pr -&gt; next; ^ phonebook.c:53:12: error: use of undeclared identifier 'pr' } while (pr != NULL); ^ phonebook.c:55:21: error: use of undeclared identifier 'pr' if (firstletter = pr) ^ phonebook.c:59:5: warning: implicitly declaring library function 'strcpy' with type 'char *(char *, const char *)' [-Wimplicit-function-declaration] strcpy(new, pc -&gt; name); ^ phonebook.c:59:5: note: include the header &lt;string.h&gt; or explicitly provide a declaration for 'strcpy' phonebook.c:59:17: error: use of undeclared identifier 'pc' strcpy(new, pc -&gt; name); ^ phonebook.c:61:12: error: use of undeclared identifier 'newphone' strcpy(newphone, pc -&gt; number); ^ phonebook.c:61:22: error: use of undeclared identifier 'pc' strcpy(newphone, pc -&gt; number); ^ phonebook.c:63:12: error: use of undeclared identifier 'newemail' strcpy(newemail, pc -&gt; email); ^ phonebook.c:63:22: error: use of undeclared identifier 'pc' strcpy(newemail, pc -&gt; email); ^ phonebook.c:69:5: error: use of undeclared identifier 'E' E = (ptrrep) malloc(sizeof(rep)); ^ phonebook.c:71:25: error: use of undeclared identifier 'pr' strcpy(firstletter, pr -&gt; rep); ^ phonebook.c:73:17: error: use of undeclared identifier 'pc' strcpy(new, pc -&gt; name); ^ phonebook.c:75:12: error: use of undeclared identifier 'newphone' strcpy(newphone, pc -&gt; number); ^ phonebook.c:75:22: error: use of undeclared identifier 'pc' strcpy(newphone, pc -&gt; number); ^ phonebook.c:77:12: error: use of undeclared identifier 'newemail' strcpy(newemail, pc -&gt; email); ^ phonebook.c:77:22: error: use of undeclared identifier 'pc' strcpy(newemail, pc -&gt; email); ^ 2 warnings and 18 errors generated. The compiler is telling you what the error is and where it is located. Just start clearing them one at a time.
Very different though, not everything should be heap allocated.
I don't understand.
Draw it on paper
Write one.
haha
No you do not need volatile in a program with correct synchronization.
not sure why the "haha" response... drawing it on paper is one of the best ways to visualize code...
You can do struct foo s = {0}; s.a = BAR; s.b = BAZ;
If you don't separate the individual numbers on each line somehow, you're going to have a bad time.
They are separated, by a comma: `fprintf(fd, "%d," matrix[ii][i])`
This code has no effect, so the compiler will ignore it.
My apologies, my eyes skipped the comma. See also OP's [other post](https://www.reddit.com/r/C_Programming/comments/bvzsay/fscanf_function/) where he writes numbers to a file without a separator.
I made a few changes to your code to make it work, even though it may be some obscure issues with it still #ifdef __STDC_ALLOC_LIB__ #define __STDC_WANT_LIB_EXT2__ 1 #else #define _POSIX_C_SOURCE 200809L #endif #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; /** * A basic circular single linked list program that creates a head, then adds nodes * to the end of the list with an incrementing string. It then prints the string * contents of the nodes. * Author: Matt Arnold */ struct node { char* bfr; struct node* next; }; struct node* addNodeFront(struct node** list, char* str); struct node* addNodeRear(struct node** list, char* str); void removeLast(struct node** list); void removeOne(struct node** list, struct node* node); void removeElement(struct node** list, char* element); void freeNode(struct node** node); struct node* list = NULL; int main(int argc, char** argv) { /* Setting up the head */ addNodeFront(&amp;list, "test"); /* Adding nodes */ for (int i = 0; i &lt; 10; i++) { char str[256]; sprintf(str, "test%d", i); addNodeRear(&amp;list, str); } removeLast(&amp;list); removeLast(&amp;list); removeLast(&amp;list); removeElement(&amp;list, "test3"); /* Traversing the list */ struct node* current = list; while (current) { printf("%s\n", current-&gt;bfr); current = current-&gt;next; } return 0; } /** * Creates a new node and adds it at the front of the circular linked list. */ struct node* addNodeFront(struct node** list, char* str) { struct node* n; n = (struct node*) malloc(sizeof(struct node)); n-&gt;bfr = strdup(str); n-&gt;next = NULL; if(*list == NULL) { *list = n; } else { n-&gt;next = *list; *list = n; } return n; } /** * Creates a new node and adds it at the back of the circular linked list. */ struct node* addNodeRear(struct node** list, char* str) { struct node* newNode; newNode = (struct node*) malloc(sizeof(struct node)); newNode-&gt;bfr = strdup(str); newNode-&gt;next = NULL; if(*list == NULL) { *list = newNode; return newNode; } struct node* n = *list; while(n-&gt;next) n = n-&gt;next; n-&gt;next = newNode; return newNode; } /** * Removes the last element from the CSLL */ void removeLast(struct node** list) { if (*list == NULL) return; if((*list)-&gt;next == NULL) { freeNode(list); return; } struct node *prev, *curr = *list; while(curr-&gt;next) { prev = curr; curr = curr-&gt;next; } prev-&gt;next = NULL; freeNode(&amp;curr); } /** * Removes a specific node from the list */ void removeOne(struct node** list, struct node* node) { if (*list == NULL) return; if ((*list)-&gt;next == NULL) { if(*list == node) freeNode(list); return; } struct node *prev = NULL, *curr = *list; while(curr) { if(curr == node) { if(prev == NULL) { // remove first node in list struct node* n = *list; *list = (*list)-&gt;next; freeNode(&amp;n); return; } else if(curr-&gt;next == NULL) { // remove last element in list prev-&gt;next = NULL; freeNode(&amp;curr); return; } else { // remove element somewhere in the middle prev-&gt;next = curr-&gt;next; freeNode(&amp;curr); return; } } prev = curr; curr = curr-&gt;next; } } /** * Removes the node containing the given element */ void removeElement(struct node** list, char* element) { if (*list == NULL) { return; } struct node* curr = *list; while (curr) { if(strcmp(curr-&gt;bfr, element) == 0) { removeOne(list, curr); return; } curr = curr-&gt;next; } } /** * Free a list node */ void freeNode(struct node** node) { if(*node == NULL) return; if((*node)-&gt;bfr) free((*node)-&gt;bfr); free(*node); *node = NULL; } Note the following: An empty list == NULL An empty next pointer == NULL I never do this, a-&gt;b-&gt;c First, the . and -&gt; operators are more dangerous than people realize. Most segmentation faults are hiding under invalid use of one of these operators. Second, it is not necessary to dig two levels deep when implementing a list The function removing a node is the most complex one because you have to take several things into consideration: Empty list? Only one element in list? First element in list being removed? Last element in list being removed? On a singly linked list, we need a previous pointer to help us out when inserting removing somwhere in the middle of a list, as you can see. Hope it helps :)
Why
&gt; The POSIX standard requires the pthread implementation to insert the appropriate memory barriers, AFAIK. See section 4.12 for a list of which functions synchronize memory: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html
malloc() ?
Thanks
Well I do not know if this will help at all, but it might be an example how to do something similar ? maybe ? Function sep\_vowels recieves pointer to null terminated character array, allocates memory for new character array and then copies vowels from original text into new array. It will return pointer to new array only once it runs out of original text or once it runs out of allocated memory for new array. The string with just vowels is then printed and memory used for this string is freed. #define newtextsize 100 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; char * sep_vowels(char * text){ char * newtext = (char*)malloc(sizeof(char) * newtextsize); int new_text_iter = 0; for (int i = 0; i &lt; strlen(text); i++){ switch(text[i]){ case 'a': case 'A': case 'e': case 'E': case 'o': case 'O': case 'i': case 'I': case 'u': case 'U': newtext[new_text_iter] = text[i]; new_text_iter++; if (new_text_iter == newtextsize - 1){ newtext[new_text_iter] = '\0'; return newtext; } break; } } newtext[new_text_iter] = '\0'; return newtext; } int main() { char * text = "This is a text containing spaces\nand even newline, let's separate vowels."; char * n = sep_vowels(text); printf("%s", n); free(n); return 0; }
&gt; Why What effect do you think the code has? Alternately, why do you think the compiler would leave it in?
Matrices (and more generally n-dimension arrays). Say I want to store an array of strings. Strings are arrays themselves, so you'll end up with `char** array` (or `char* array[]`, which is the same but makes it clearer that we're dealing with an array of pointers). Another example for a three-dimensional map where each cell is represented by an int : `int*** map`. You can access a cell with `map[x][y][z]`.
`getline(3)` / `getdelim(3)` update the caller's buffer pointer via pointer to pointer: http://man7.org/linux/man-pages/man3/getline.3.html A pointer to a pointer to a pointer is extremely rare and [should probably never be used](https://web.archive.org/web/20190428023828/https://wiki.c2.com/?ThreeStarProgrammer).
The original Mac memory manager relied on them. Old Windows did too. It allowed the OS to compact memory and have userland code have to doubly dereference to fetch data. To prevent to OS from moving stuff out from under you, you'd have to call the OS to "lock" the reference.
What exactly do you want explained? What if-statement does? Main? Have you tried "man strncmp" ? Or google? [http://www.tutorialspoint.com/ansi\_c/c\_strncmp.htm](http://www.tutorialspoint.com/ansi_c/c_strncmp.htm) int argc &lt;-- number of arguments passed to your application from command line char \*argv\[\] &lt;-- pointer to an array of strings which are command line arguments passed to your application if statetment thus obviously check to see if number of arguments is two, and then checks if second argument is word "debug". Why the person who wrote the code wishes to compare 8 characters in string "debug" is unclear to me.
ARM's crappy website damn near killed my web browser just trying to load. Anyway, you could build your own using the `offsetof` macro.
Thank you
I have a embedded comms library which has a function which sends data, this has a bool return type so we can call it and if it returns true we know it succeeded. Sometime we want to review the response to a packet, so in that case we also pass a pointer to a pointer. when the function succeeds, the pointer to a pointer is updated with the response packet. So the calling code has a pointer to the response packet for processing.
`argv` is an array of pointers to chars, containing the name of your executable as it was called followed by any arguments passed to it. `argc` is the number of elements in `argv`. e.g. if your program is called `foo` and someone ran `./foo`, `argc` would be 1 and `argv` would look like this: argv[0] = "./foo" If someone instead ran `./foo debug` then `argc` would be 2, and `argv` would look like this: argv[0] = "./foo" argv[1] = "debug" As `argc` is 2, the first part of the if is true, so it would move on to `!strncmp(argv[1], "debug", 8*sizeof(char))` `!` negates the output, strncmp returns 0 if the string matches so this part of the if statement will be considered true if the string matches, as `!0` is true. This is where it gets a bit weird as `strncmp` is being called against a variable that's not as long as the number passed to it. `sizeof(char)` is always 1, so it's looking to see if the first 8 characters of `argv[1]` matches "debug", but that string is only 5 chars long, so there's no point in looking further. Fortunately they're both NULL terminated strings in this instance so it will work as intended, which is that the `debugmode` variable will be set to 1.
Why would I want to run my machine code in a browser? It runs way faster natively on the hardware itself.
If you want a function to modify a pointer that is passed as an argument (not what it points to, but the pointer itself), you would have to pass it as a pointer to pointer. A typical example would be functions that does operations on linked lists or trees.
it sets debugmode = 1 if the first 'flag' to the program is 'debug'. ``` gcc main.c -o main ./main debug ``` argc == 2 -- checks the number of arguments !strncmp -- strncmp returns 0 if the two strings are identical; 0 is boolean false, so inverse it everyone else posted more thorough answers :)
So many reasons. Here's an easy one. ``` int make_item(struct Item **item, int value) { if(value &lt; 0) { fprintf(stderr, "No negative items allowed in struct Item"); return FALSE; } *item = (struct Item*)malloc(sizeof(struct Item)); if(*item == NULL) { fprintf(stderr, "Error allocating Item: %s", strerror(errno)); return FALSE; } (*item)-&gt;value = value; return TRUE; } ``` Or more generally, some kind of logic verifying an allocation was successful.
Here else part is not required so compiler will optimize as per my understanding. Please correct me if I am wrong.
It is intended to replace JavaScript for very computationally heavy tasks on webpages. Things like 3D rendered graphics, browser based games, physics simulations, etc. It isn't intended for basic interactivity on web pages. That will mostly likely still be done with JavaScript for the foreseeable future. This also give developers another option besides JavaScript when developing a front-end.
The code you posted does absolutely nothing. The controlling expression is an integer constant expression and both blocks are empty. Any half-decent compiler will ignore it completely.
It sets `debugmode` to 1 if the first word on the command line, other than the program name, is `debug`. Badly. The `if` statement should look like this: if (argc == 2 &amp;&amp; strcmp(argv[1], "debug") == 0)
It looks like someone is giving their homework to us...
No problem. I would recommend going through the errors one at a time starting with the easy ones. Also, I find it easier to write a program a little at a time over multiple iterations while testing at each step. It is a lot easier to debug one function or 10-20 lines of code than it is to debug 100+ lines of code. If you get stuck, let me know and I will happy to help you - but I would recommend trying on your own as much as possible because that is how you learn to debug.
Cool. Thanks for the intro.
`volatile` does not create memory barriers and does not imply an ordering visible to other threads. Do not use `volatile` for this purpose.
An array of strings is a perfect example. char Strings[][] = { "String0", "String1", }
 int addRecord (struct record **, int, char[], char[]); For example above is the prototype for a function that adds a new struct called record to a linked list of structs. The int and two char\[\] fields are just record data (number, name, address) What is the point of the double pointer? I know that the last field of the record struct is a pointer to next, but why does the function need a pointer of a pointer? I hope this was enough info
But I don't know what else to do. Do I do nothing then? Is just using the locks fine as is? (Do I need to post more of my code or is that enough to see what I am trying to do?)
Am I using correct synchronization in this case? In my case, I just have 2 or more threads (at most 36 threads) sharing access to one uint64_t variable called ```current_chunk```.
The lock is perfectly sufficient as /u/blargh4 said. Just write job_chunk = current_chunk++; and you are good to go.
Looks ok to me, shared data is only accessed while the lock protecting it is held.
Just save the code and compile to assembly with gcc - then look if it gets ignored or not
Do you have at least something, some idea how to do it ?
My guess is that an empty list is defined as a record pointer pointing to NULL If that is the case, the function has to modify the record pointer itself when the first node is added to the list.
Without the loops i can do it, but with loops it's hard for me. If i use one for loop for test second one for students,but how can i calculate the average grade for test3 and average grade of student5?
Oh so when adding the first record it dereferences the pointer to not be NULL. In that case it probably changed its value to next?
I second [xv6](https://pdos.csail.mit.edu/6.828/2018/xv6.html). It's well documented and small enough for one person to understand it in its entirety. I went through the source line by line to make sure I understood exactly how it worked. I did the same for "[The Lion's Book](https://en.wikipedia.org/wiki/Lions%27_Commentary_on_UNIX_6th_Edition,_with_Source_Code)" on Unix 6 though that's a much older architecture so you are better suited going through the former. It's one thing to go through the source but you also need to write code. For xv6 I picked something I was interested in and improved it. For example, the file system. I added a balanced tree implementation for directory structures. Here's a link to the [code](https://github.com/dillstead/xv6-public/tree/btree_dir). Also, I recommend doing the 4 [Pintos](https://web.stanford.edu/class/cs140/projects/pintos/pintos_1.html) projects. You will grapple with issues such as priority scheduling, timers, user space processes, system calls, virtual memory including swapping, etc. all by writing actual code. My solutions to the first 2 projects are [here](https://github.com/dillstead/pintos/tree/assignment_1) and [here](https://github.com/dillstead/pintos/tree/assignment_2).
Given something like: struct foo {int len; char st[12]; } a,b; void test(void) { struct foo c; c.len = 3; strcpy(c.st, "Hey"); a=c; b=c; } it's unclear what if anything the Standard would guarantee about behavior of `test`, given that the value of `c` is copied at a time when some but not all of it has been written. Even if one assumes a compiler is trying to produce sensible code, it's unclear whether the contents of `a.st` and `b.st` should be guaranteed to match [absent such a guarantee, a compiler could leave the last eight bytes of `a` and `b` holding whatever they held before the function was invoked]. Forcibly initializing structures to zero will avoid such issues, and will also reduce the likelihood that a piece of code will appear to work without working reliably. For many purposes, the consistent(*) behavior resulting from forced initialization is worth the performance cost. (*) While some platforms' representations for pointers or floating-point numbers might interpret all-bits-zero in unusual fashion, any such platforms would have to document such behavior. Code which zeroes all the byte of a structure will behave consistently on any platforms that don't document unusual behavior.
I’ll add [`posix_memalign`](https://linux.die.net/man/3/posix_memalign) as another example. The return value is an error code (as usual for POSIX functions) and the allocated block is passed back via an out-argument pointer.
Part of me thinks there should be some decoy sub(s) where we hand out ridiculous answers, give the teachers/professitatrices that end up seeing them a good laugh or two.
Not 100% sure I understand what you're trying to do here, but `printf("Main Address %p\n", &amp;a);` is printing the address of the pointer variable, not where it points to.
... why allocate a space for the int, then overwrite it with &amp;test? Anyway you're printing out the address of the pointer, not the stored address (i.e the value) of that pointer.
Because of pass by reference. You're essentially passing a copy of the address that is stored somewhere else in memory.
I have a struct which represents a new Memory Block. The last value in this struct is a void pointer. If i call my allocate function the program allocate Memory from the OS and write the start address to the void pointer. The function returns the pointer. So the function provide me the address of my data from the struct. And I need to access the other variable in the struct.
Ok but - test is on the stack, and 'a' is pointing to the stack once you set that reference to it.
Maybe you could have a look at my code https://gist.github.com/mosermartin09/322783e8527a53057758f7e80a7fb05e. I cannot find a solution to access the "used" flag.
I like the dynamic memory allocation: void free(void* p) { // lol } But really, I like the idea of webasm - and requiring 11kb of javascript glue seems counterproductive when the whole point is to cut down and speed up.
You don't seem to set the data pointer when you allocate your block. I assume you want to set it to base+offset where offset is the point of the struct. In terms of getting used/unused from the 'data' pointer, then its a case of winding the pointer back a set offset to be able to read it. \*(int \*) (((void \*)a) - offset) I don't know enough to advise how todo it so that struct padding doesn't cause issues.
It helps to post actual C code. (Neither `Int` nor `If` are things in C unless you explicitly make them things.) But basically: 1. The compiler propagates the value of `a` to its uses, so `a==5` becomes `5==5`, which reduces to `1`. 2. The compiler sees an `if(1)`, so it discards the `else` case entirely along with any compare-and-jump machinery around the `if` part of things. 3. The compiler sees an empty compound statement as the body of the `if`, so it eliminates that entirely. 4. Any of the prologue/epilogue around that section of code will be killed off. If you use the `-S` flag to the compiler or `objdump -d` its output, you’ll see exactly what the compiler decided to output. There’s barely any interesting optimization that can happen here—it’s all very simple transforms after the constant value propagation from `a`’s initialization, and CVP is just shuttling stuff along the dataflow graph.
The GNU C Library Reference Manual will work. You cannot use the C++ std lib in C.
Yeah, consider this record* list = NULL; // new empty list void addNode(record** list, record* newNode) { if(list == NULL) // The list is empty, add the first node *list = newNode; // This modifies the list pointer, so it has to be passed as a pointer to pointer else // The list is not empty ... // Find an existing node to append the new node to someExistingNode-&gt;next = newNode; // This does not modify the list pointer, so here the list pointer could have been passed as a regular pointer } This is just incomplete pseudo code, but you get the idea... There are other and more "clever" ways to implement linked lists, for example, this is how the linux kernel does it https://kernelnewbies.org/FAQ/LinkedLists but for a basic, naive implementation of linked lists, this is typically how it is done.
This smells like a strict aliasing problem.
Do not remove your posts after receiving answers. That's a really shitty thing to do.
You could always read the actual standard (there are a lot of draft PDFs online), but I would recommend [cppreference](https://en.cppreference.com/w/c/header).
Like the other guy said, it's mainly to allow js to be used to run very quickly close to native speed. The main issue with Javascript is that while JS engine are pretty quick. Javascript by itself will make the code inherently slow as it cannot be always optimized for speed. As the programming language isn't strictly typed, it's impossible for the JS engine to optimize correctly a function in which the parameters type may be called with different types for example. So what web assembly changes in that is that it can create a subset of JS that makes it easy for a JS engine to guess the type of the function parameters and allow the JIT compiler to convert the bytecode into native code. In other words, the subset of JS will theoritically run at the same speed as unmanaged code. As the code is being executed in a unmanaged memory space, it allows for basic C memory allocator to allocate the memory in a big array of bytes. As why we want that in the browser? With that kind of power, you don't need native third party plugins or external library to run code quickly. Also as the code runs inside the JS vm, your native code is already running in a sandbox so if a plugin running native code could contain exploit that would allow you to write code that jailbreak out of the plugin's restrictions. Doing the same thing from within JS is technically pretty much already covered.
Thanks! :D
Not a web guy but 11k of javascript seems tiny relative to what I see normally loaded. Your point is valid though.
It's obviously not what OP wants. No one is forced to contribute here, so instead of doing snarky comments, don't comment.
`argv` is a pointer to a pointer!
glibc site
This is really awesome, thank you for share it. I was trying it the last year and I got stuck when try to do animations with RequestAnimationFrame and start the main loop -created in C- of a video game. I will try it again. Thanks for encourage.
I am using pointer to pointer in my xyz_free methods to set object pointer after freeing to NULL.
Firstly this is a syntax error, you must specify the array dimensions except the last one. Secondly this is an array of arrays, there are no pointer-to-pointer here.
using a modicum of formatting or providing a compiler error would help you get an answer
 int n=0,ch; c=(char *) malloc(n*sizeof(char)); n is 0 so n*sizeof(char) will be 0. I'm not sure if the compiler will complain about that but it certainly won't work.
You can pass 0 to malloc, though what happens next is implementation dependent. It may return NULL or it may return a pointer which can be freed. realloc acts like malloc if the pointer passed to it is NULL so this part of the code should work. I'm on my phone right now so can't look at the code more thoroughly to check what might be wrong but it doesn't seem to be this.
What errors/warnings do you get?
I have updated the logic, allocated memory to string dynamically by adding string scanning function. It works reads author name but doesn't read book title. Here' the updated code: [https://pastebin.com/yWuGZCHc](https://pastebin.com/yWuGZCHc) . Any ideas why it doesn't read book title? Please help! This code is tested in [https://www.onlinegdb.com/online\_c\_compiler](https://www.onlinegdb.com/online_c_compiler) using Standard Input: Interactive Console .
Runtime error: SIGTSTP. It works on onlinegdb.com.
at codechef.com/ide
&gt; SIGTSTP http://man7.org/linux/man-pages/man7/signal.7.html SIGTSTP means the terminal sent a stop (on a normal terminal that'd be sent with CTRL-Z). If I had to guess most online compilers don't like getchar()
You malloc one byte, no, two bytes, too little. You provide a buffer of size n, and then stuff something with index n+1. Thus: you need a buffer if at least n+2 bytes.
Yeah, running on CodeChef there's no way to actually give it input once the program is running. The SIGTSTP is a red herring, the real issue is your code is killed because it's sitting there forever waiting for a character to be input.
On line 21 he uses n-1?
Linked lists with strings of different length
You can’t just post twice within an hour when your first post didn’t get the answer you wanted. Be patient, listen to the advice in the first post and post the compiler error that you’re receiving or explain in detail the problem you have. Nobody is here to do your homework for you!
For example, say I had a linked list of structs and one of the fields was name\[\] ... If the user inputed "Jo", how could I print all names in the list that start with "Jo" ... ex: John, Joseph, Joey ? I feel like I would use strcmp() But what else would I need to do to accomplish this?
Recode it. That's how I learned it.
For example, say I had a linked list of structs and one of the fields was name\[\] ... If the user inputed "Jo", how could I print all names in the list that start with "Jo" ... ex: John, Joseph, Joey ? I feel like I would use strcmp() But what else would I need to do to accomplish this?
Here's a simple example with "bad" code #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct node { char *string; struct node *next; }; int main() { struct node *current, *head; head = current = malloc(sizeof(struct node)); // fill the struct loop // head-&gt;next = malloc(sizeof(struct node)); // head = head-&gt;next; // end of loop // head-&gt;next = NULL; // search function input code here // ... while (current-&gt;next) { for (i = 0; i != strlen(buf); i++) { if (current-&gt;string[i] != buf[i]) { i = -1; break; } } if (i != -1) { printf("success\n"); return 0; } current = current-&gt;next; } printf("failed\n"); return 0; }
You need something like strncmp(), strnicmp() or maybe strstr()
Use `fread()` to get a bunch of characters from a file. The rest depends on what combination you want to perform on them.
 It works reads author name but doesn't read book title.
Ah I think strncmp() will be a good idea... I can work well with the function's parameters: strncmp(str1, str2, n); I can get the length of the user-inputed string and pass that in as the n parameter. Then I can go down the linked list and compare the user-inputed characters to the actual names in the structs.
A null pointer can be freed
Well, you can pass NULL to free but it doesn't really get freed ;) I can't find it now but I think I pretty much copied it verbatim from whatever malloc reference I found earlier, and I was on my phone so didn't want to type much. Here's a better description from [POSIX.1-2017](http://pubs.opengroup.org/onlinepubs/9699919799/functions/malloc.html): &gt; If the size of the space requested is 0, the behavior is implementation-defined: either a null pointer shall be returned, or the behavior shall be as if the size were some non-zero value, except that the behavior is undefined if the returned pointer is used to access an object.
What's the problem? Please define an exact question struct book{ int accession_no; char *title,*author,issued[1]; float price; }*b; &amp;#x200B; int main(){ int n=0,flag=1,choice,q,accessionNo=0; char *bt,*an; b = (struct book *)malloc(n * sizeof(struct book)); I'm not sure if that is possible? Don't you need to define a pointer to get information into the struct? &amp;#x200B; ./test7 Choose an option from below menu: 1. Add book information 2. Display book information 3. List all the books of an author 4. List the title of specified book 5. List count of books in library 6. List book ordered by accession number 7. Exit 6 Choose an option from below menu: 1. Add book information 2. Display book information 3. List all the books of an author 4. List the title of specified book 5. List count of books in library 6. List book ordered by accession number 7. Exit 1 Enter accession number 234 Enter Title of the book Enter Book Author 234 Enter price of the book 234 Choose an option from below menu: 1. Add book information 2. Display book information 3. List all the books of an author 4. List the title of specified book 5. List count of books in library 6. List book ordered by accession number 7. Exit 6 Choose an option from below menu: 1. Add book information 2. Display book information 3. List all the books of an author 4. List the title of specified book 5. List count of books in library 6. List book ordered by accession number 7. Exit 7 test7(13514) in free(): chunk is already free 0x1229c7870fe0 Abort trap (core dumped) Here's the first and only run I've done with your tool. A double free shouldn't be that hard to see
You're mixing asm.js and webassembly. asm.js is the subset of JS with type annotations bolted on that allowed an aware JIT to produce extremely good native code. A naive JIT or interpreter could still run the JS for compatibility but the clear target was a JIT that could parse the annotations. webassembly is a bytecode that runs in a special VM inside the browser. It has a text format for debug reasons but the primary output is a binary format. You still need to use JS to bridge the gap between the VM and the DOM and other browser events only exposed to the JS engine but webasm itself is an independent language and runtime. The article shows the raw text instruction format for webasm.
 [https://pastebin.com/5bzbPQjm](https://pastebin.com/5bzbPQjm)
double free = undefined behavior = your compiler does what he wants &amp;#x200B; Fix that problem, compile again and perhaps you'll have your solution
From what I have just verified running with `--mol 1024`, in a call to `vec3d_sub` parameter `v1` is an invalid pointer for some reason. I suggest you run this with gdb, and use `watch` to find out where changes to this may happen. I have seen a case in one of my programs where a call to `free` seemed to have clobbered a value in another structure... I still have to figure out what is going on in my program, but I never would have found out it was happening, if not for gdb. Another thing that may help is compiling the program with a memory sanitizer (`-fsanitize=address`), though I believe that at this point it may be better to try it with a debugger.
Since the problem happens when you pass it a large molecule size, it sounds like you are overflowing something. Start by looking at everything that is affected by that value, directly and indirectly (args-&gt;molecules, universe-&gt;mol_nb, universe-&gt;part_nb, etc). I don't have time to look into this in detail, but start there. Also, your code on github doesn't match what you used when running valgrind to get the output you posted. Line 295 in universe.c couldn't have generated the stacktrace valgrind shows.
&gt;Also, your code on github doesn't match what you used when running valgrind to get the output you posted. Line 295 in universe.c couldn't have generated the stacktrace valgrind shows. Yep, I pushed a small commit 20min ago which removed a line from `universe.c`.
I'd recommend checking our /r/csharp. `C` and `C#` are two completely different languages.
Thanks I searched c# and this was all I found
In https://github.com/Garuda1/ammonium/blob/master/headers/universe.h#L28 you define the particle id as a unit8_t. This seems suspicious to me, in particular because you move this id by a size_t at https://github.com/Garuda1/ammonium/blob/master/sources/universe.c#L205 . I did not execute the code, but that is a pretty big red flag. You overflow the int8_t, then get a negative offset that will point backward to the previous block that is right into the memory freed by the previous fclose.
... That is true, it's likely this is causing the issue. I'll fix it when possible.
&gt; ... That is true, it's likely this is causing the issue. I'll fix it when possible. I'm surprised that is allowed without an warning given your compile flags. It might depend on your gcc version, but try adding: -Wconversion -Wsign-conversion
People are also missing that your while loop reads from ch, which is undefined on the first read: char ch; while(ch != '\n') { // &lt;- undefined behavior
Ah you're right. Technically, webassembly is the logical evolution of asm.js thought.
| I've type casted the macro in every return statement inside function uart_baud_init(). Is this necessary? Generally, I do this if the compiler complains (which is impacted by the flags you have enabled for compilation). It's probably not needed. | How does macros get interpreted by the compiler? As far as I know, it basically replaced the macro definition with the macro value. Run `gcc -E uart.c` to see an 'expanded' version of your file. | Can someone point me to the C standard where this is explained or would I need to refer to the compilers standard or ARM standard if I'm on a arm processor? It's going to be in the C standard. I would look at https://gcc.gnu.org/onlinedocs/cpp/Macros.html, but that's not a standard | Lastly, I've also type casted the parameter to the function uart_baud_init(). I've seen this done in several BSP's I dealt with. Is this necessary and if it depends then please explain both situations where it is and is not needed. I have no idea what uart is, and no idea what a BSP is. Again though, you will have to cast if the compiler complains, but this type of cast doesn't 'add' anything (it'll just tell the compiler to interpret this series of bytes as a uint32_t rather than an int, but it won't change the bits at all). In this specific case, it would make a different if you were doing a comparison for greater/less than 0 and your number was a very big one (like 0xFFFFFFFF, which is around 4 billion uint32_t, and -2 billion int32_t/int)
&gt; How does macros get interpreted by the compiler? They don’t (in fact on some implementations the preprocessor is a separate program that does a pass on your sources before the compiler). The preprocessor mindlessly substitutes the macro for their definitions.
There should be a prototype in view for uart\_baud\_init(), like any function, so casting the argument is unnecessary if the value is a number. If it **isn't** a number, then the cast would hide the error. I feel bad whenever something forces me to use a cast. Feeling like you are not having completely clean flour in your bag. If the failure codes are not directly hw codes, just logical conditions, why not use a plain int or enum for them?
You don’t need the cast on `return`, because the compiler knows it’ll have to coerce to `uint32_t` anyway. You don’t need the cast for the function argument because the compiler sees the prototype requiring a `uint32_t` argument, which it will (hopefully) coerce to. If the prototype were missing or you were using varargs it’d try to pass an `int`. Usually you should avoid casts like that. Alternatively, you could use the `UINT32_C` macro like this: #define DEFAULT_BAUD UINT32_C(9600) which would mean you never need to cast the thing—it has the right type already. Also, don’t wrap single-token (e.g., `0xAA`) in parentheses. ’s some cargo-cult shit, actually easier to misuse/abuse the macro with the parentheses than without it. Alternatively, if you know you’re going to be using a GNU/-compatible compiler, you can do #define FOO (__extension__(0xAA)) to guard it better, but again, totally unnecessary since it’s a single token.
I know this is unhelpful wrt your goal, but you shouldn’t touch VS if you’re a beginner. VS includes a shite C implementation (ekes by on C99 library+syntax support, and the preprocessor has always been a wreckage—), and you'll have to beat the thing over the head to do basic stuff without it complaining.
I'm pulling this out of the Xilinx BSP but yes I agree with using a int or enum. Thanks for the reply.
Visual Studio is a bad C compiler. MSVC doesn’t support C99 let alone C11 or C18 You are better off installing Clang/LLVM and using Visual Studio Code or any other editor
CRUD
Even in single-processor systems, `volatile` will only be useful on compilers that are configured to be suitable for low-level programming without demanding compiler-specific syntax. Given something like: extern volatile uint8_t *data_output_ptr; extern volatile uint32_t data_output_len; void start_outputing_data(void *dat, uint32_t len) { data_output_ptr = dat; data_output_len = len; } void await_output_completion(void) { while(data_output_len) ; } some compilers will recognize that operations on `volatile` objects may trigger side-effects on other objects whose address is exposed to the outside world, but because the authors of the Standard didn't want to require that compilers waste time on such behavior *in cases where it is not useful* and expected that people writing compilers for platforms and purposes where such behavior would often be needed would be better placed than the Committee to judge *the needs of their customers*, compiler writers that are more interested in what the Standard requires than what their customers need cannot support such constructs without requiring compiler-specific extensions or disabling optimizations altogether.
I think you just need the "C++ desktop development" package. Then you can start with the windows console app template. Note that MSVC doesn't have first-class C support (I think it compiles .c files as c++ by default?) but it's probably fine for learning.
Ive been using gcc in Linux and it's been working well. I just wanted to know how to do it in Windows as well. Thanks anyways
Thanks for the reply. Other people said that too. I was just curious a because I only know how to compile in Linux and VS seemed to be the best option for Windows. Guess not haha
You could also use gcc on windows (haven't tried using it from MSVC myself so can't speak for how well it works). https://sourceforge.net/projects/mingw-w64/ https://devblogs.microsoft.com/cppblog/using-mingw-and-cygwin-with-visual-cpp-and-open-folder/
than kyou all
You could look into the Windows Subsystem for Linux (https://docs.microsoft.com/en-us/windows/wsl/about). It allows you to run most Linux tools (including gcc).
Thank you so much! This really helped.
Thanks for the info on wrapping macros. Appreciate the feedback.
When you are writing a BSP you are usually providing routines that the system needs. In this case you need to make your functions match the system's prototypes. If you don't it won't compile cleanly. I suggest you stick with the `typedef`ed types that the system is expecting. While everything will work fine if you use the native type that the `typedef` references, the whole idea behind using the typedef is that those types are system independent. It will potentially make your code non-portable.
&gt; scanf("%d",&amp;limit.limite);
&gt; scanf("%d",&amp;limit.limite); Why are you trying to parse an integer input argument into a float, then feeding it a text string?
&gt; don’t wrap single-token (e.g., 0xAA) in parentheses. ’s some cargo-cult shit, actually easier to misuse/abuse the macro with the parentheses than without it. I know why it's unnecessary, but how is it bad?
Hello, I'm still new to programming language and the problem is he jumping the line.
Complied your program on my system (Ubuntu 19.04) and only got a warning regarding the input specifier for `limit.limite` being `%d` (integer) instead of `%f` (float) . When I run the code, it works and I do not get the problem you are reporting. Looking at your screenshot, it looks like you are trying to input a string ("Verdura") when you are prompted for "Digite o setor do produto:\n" instead of a number. Most likely, `scanf("%d", &amp;limit.limite)` is failing because the input is a string ("Verdura") and the string is left in the buffer. The program then loops and `scanf("%s", name.nome)` reads in the string left in the buffer.
\&gt; - How and what's the best way to load up the proper pages? Should I have a pre made web page (logins.html, main\_page.html, settings.html etc.)? There as tons of solutions, but this one is a very good starting point, pretty easy to create and maintain, just put those files on your webserver. But in this case, the pages will always look the same and not contain changed data. \&gt; - Also, how would I be able to track the changes since the Client is just any browser unlike creating your own clients? It's hard to say without knowing anything about your environment, but as you asked in a c group, let's guess as bare bones as possible, put the changes in a form, make the action of that form call a program which will get all the values as an environment variable \`QUERY\_STRING\` when a user pressed the submit button, with that you know exactly what has been changed on the page. The output of this program should be the new page the user sees. &amp;#x200B; This is called \`cgi\` ([http://www.openroad.org/cgihelp/cgi.html](http://www.openroad.org/cgihelp/cgi.html)), which is the most simple way of getting data from a page. Pretty old-fashioned, but still functional :)
scanf is giving you an error that you're not checking for. The old input remains in the input stream that subsequent calls to scanf try to use.
Hello my friend, thanks for your time. &amp;#x200B; Verdura = vegetable &amp;#x200B; He is asking for how many products i want to add, then the name of the product and then category . After i add the first product, he already send a msg with only a text to add the name of the second product and then to add the category, he is not waiting for a response like the first step. &amp;#x200B; Sorry for my bad english.
You are reading the valgrind wrong. [Here is what I did to find the defect without even downloading the code](https://www.reddit.com/r/C_Programming/comments/bwo97t/possible_buffer_overflow_im_completely_lost_on/epz21ei/) Valgrind says: ==67== Invalid read of size 8 ==67== at 0x10A695: vec3d_sub (vec3d.c:31) ==67== by 0x1094BF: particle_update_frc (particle.c:78) ==67== by 0x10A3B6: universe_iterate (universe.c:272) ==67== by 0x10A53A: universe_simulate (universe.c:295) ==67== by 0x108C8D: main (main.c:31) That means the issue was that vec3d_sub accessed memory that was not allocated. ==67== Address 0x55cb058 is 24 bytes inside a block of size 552 free'd ==67== at 0x4C30D3B: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==67== by 0x52582FD: fclose@@GLIBC_2.2.5 (iofclose.c:77) ==67== by 0x10A1D8: universe_init (universe.c:61) ==67== by 0x108C46: main (main.c:27) This only tells you that the memory was free'd by close ==67== Block was alloc'd at ==67== at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==67== by 0x5258E49: __fopen_internal (iofopen.c:65) ==67== by 0x5258E49: fopen@@GLIBC_2.2.5 (iofopen.c:89) ==67== by 0x10A0EA: universe_init (universe.c:37) ==67== by 0x108C46: main (main.c:27) and allocated by fopen. If you look at the code, it is perfectly logical: [fopen](https://github.com/Garuda1/ammonium/blob/master/sources/universe.c#L37) does allocate data (probably the buffer for reading). [fclose](https://github.com/Garuda1/ammonium/blob/master/sources/universe.c#L61) this releases the buffer The [big allocation](https://github.com/Garuda1/ammonium/blob/master/sources/universe.c#L64) is after. As it is bigger than the file buffer, it does not reuse the memory and is located after. However, later on, [when doing the vec sub](https://github.com/Garuda1/ammonium/blob/master/sources/particle.c#L78) it goes into this now deallocated memory. That was the hint that the code is probably using a *negative* index within that line of code ```vec3d_sub(&amp;(frc_bond_vec[ii]), &amp;((current-&gt;bond[ii])-&gt;pos), &amp;(current-&gt;pos))```. The most plausible culprit is the ```bond[ii]``` pointing to something out of the array. If you look how it is filled, [you'll find](https://github.com/Garuda1/ammonium/blob/master/sources/universe.c#L205), ie: current-&gt;bond_id[iii] = reference-&gt;bond_id[iii] + id_offset; current-&gt;bond[iii] = &amp;(universe-&gt;particle[current-&gt;bond_id[iii]]); Ok, the bond will point outside if ```current-&gt;bond_id[iii]``` is negative. Checking the [definition of ```bond_id```](https://github.com/Garuda1/ammonium/blob/master/headers/universe.h#L28) shows you that it is a uint8_t, so, as soon as it get bigger than 127, it wraps back to negative numbers. As id_offset is a size_t, the issue is crystal clear, This is exactly the path I followed. I had no need to download, compile or run the code.
So what i have to do? where to add fflush(stdin); ?
You don’t need to add it anywhere to fix the bug you’re seeing. Do you understand what the problem with that line and the input you’re feeding it is?
i tried to add &amp;#x200B; scanf(" %s",name.nome); getchar(); scanf("%d",&amp;limit.limite); getchar(); &amp;#x200B; but no sucess
Are you running a separate web browser, or do you need to host the server yourself? If you have a web server (e.g. Apache or [lighttpd](https://www.lighttpd.net/)), then it's simple to write a CGI program (in C or, better, some scripting language) to handle the HTTP requests. If you can use some other language (Python, Perl, PHP, etc.) then you can make it communicate with your C code on the backend (with pipes, sockets, shared RDBMS, etc.). If you don't have a web server and you have to host the service yourself then you should use a library. Something like this, although I don't know anything about this one: https://www.libhttp.org/ As for actually passing information back to the server, you have two basic options: conventional [form submit](https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Sending_and_retrieving_form_data) functionality, or [AJAX](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started). The advantage to form submit is that almost every browser ever created supports it, including text-mode browser that you can run in a console and browsers running extensions like NoScript that disable or hobble Javascript. The advantages of AJAX are that you can submit data in a nicer format (JSON) and that you can receive the response on the same page.
Why are you doing that? Stop shotgun debugging and try to actually understand the problem. &amp;#x200B; You are telling scanf to expect an integer number. You are feeding it a word. You are trying to store the result of the conversion into a floating point number.
I don't want to be a jerk, but it sounds like you're in over your head. What is the goal of this project? Are you trying to write an http server in C? Is this for academic purposes? If you're really interested in low level network programming, check this out: https://beej.us/guide/bgnet/ If you're trying to create an http application with a bit of html, you should be using a legit http server like nginx.
&gt; it is a uint8_t, so, as soon as it get bigger than 127, it wraps back to negative numbers Erm... `uint8_t` is unsigned.
Ohhh got it, thanks man!
It sounds to me like the OP probably wants to add a configuration front-end for some network service.
Unless this is some toy project for learning purpose do yourself a favor and just use a tiny web server and write a (F)CGI script.
Macros can be really, really easy to screw up with and really hard to debug. In general you want to permit as few kinds of misuse of your macro as possible (although sometimes you can’t). This is sort of like static type checking; you want the compiler to notice and complain if the programmer fucks up somehow. If you want the macro to act like a variable, it shouldn’t be able to be used as a function argument list or the condition part of a control statement. E.g., #define SOMETHING (5) … x = f SOMETHING; if SOMETHING break; Those are legal statements there. OTOH, if you omit the parentheses those become illegal statements.
Pretty much, yes. The classes become `struct`s with a (separate) set of functions; usually you prefix the names so it’s clear what they act on. You’ll need to to manual de-/initialization too. E.g., class C { private: int x; public: C() : x(0) {} C(const C &amp;c) : x(c.x) {} C(int xv) : x(xv) {} int getX() const {return x;} }; becomes something like typedef struct C C; struct C { int x; /* If you need to, you can also partition this like struct { int x; } private__; but it’s not like the C compiler will actually enforce privateness. */ }; void C_init_1(C *const inst) {inst-&gt;x = 0;} void C_copy(C *const inst, const C *const c) {inst-&gt;x = c-&gt;x;} void C_init_2(C *const inst, int cv) {inst-&gt;x = cv;} int C_getX(const C *const inst) {return inst-&gt;x;} If `C` extends something, it has to start with a copy of that thing; e.g., class D : public E, public F {…}; becomes typedef struct D D; struct D { E super_E; F super_F; }; so static upcasting from `D` to `E` becomes `&amp;inst-&gt;super_E` and the reverse is something like `(struct D *)((char *)inst - offsetof(D, super_E))`. Virtual stuff gets into a whole other layer of crazy. A class with virtual members (including inherited ones) becomes something like typedef struct V V; struct V__vtable; struct C { const struct V__vtable *vtable__; … }; struct V__vtable { (virtual function pointers here) }; and then you have to figure out a way to do dynamic casting (exercise for the reader:). Templates usually end up as macros, and there’s really no good way to handle that uniformly; you’ll have to manually come up with names for the template instantiations and make sure things get pasted together properly. They might not be as bad if you use a separate header for each template and take macro args (`#undef` at end of file), then `#include` the header whenever you need to instantiate the template. So you can do it, but it’s almost not worth it if you have any way to just shim into the C++ code from C. (E.g., come up with some `extern "C"` functions that let you access the C++ side of things.)
I wonder if there would be any disadvantage to the Standard allowing an implementation to return a not-necessarily-unique non-null pointer which will yield itself when zero is added or subtracted, and will be ignored when passed to `free`. I would think that behavior would be compatible with a wider range of programs than any of the behaviors allowed by the Standard.
Not sure why you're in c_programming because what you're asking for involves a lot more than C. But if you really want to start out with C then I'd say start slow, and check out resources about listen / read / write which are the basic functions of a server
Might I suggest a language that compiles down to C? Unless the task is to learn how to convert, it’d be easier to convert c++ code to something like https://www.kitlang.org/ then compile it down to the c code or run directly
yeah, I suck at that typing thing...
Depending on the reason for this change you might prefer to do this: By writing `extern "C"` in front of a function you can later link it with C code. This will not work for classes or templates, but you might be able to write a wrapper to the stuff you want to use in C from the C++-Code. I know that for old versions of C++ there used to be some sort of transpilers to C, but not for modern C++ and this would generate very ugly C. Sorry that this is not a very good answer to your question, but i hope this still helps.
If you look at your code, it first ask for the product name (a string) then the product sector (a float). You are entering a string, then trying to enter another string: printf("Digite o nome do produto que deseja incluir:\n"); scanf("%s", name.nome); printf("Digite o setor do produto:\n"); scanf("%f", &amp; limit.limite); If you want to enter the product name (a string) then the product category (another string), you need to modify your code accordingly. I fixed the input specifier for `limit.limite` and compiled your program. When I run it I get the following: **************** Sejam Bem Vindos - Mercado Anhanguera: Digite o que deseja fazer: 0 - Sair do programa. 1 - Incluir produto(s). **************** 1 Digite a quantidade de produtos que deseja inserir: 3 Digite o nome do produto que deseja incluir: tomatoes Digite o setor do produto: 1 1 tomatoes 1.00 Digite o nome do produto que deseja incluir: onions Digite o setor do produto: 2 2 onions 2.00 Digite o nome do produto que deseja incluir: carrots Digite o setor do produto: 3 3 carrots 3.00 **************** Sejam Bem Vindos - Mercado Anhanguera: Digite o que deseja fazer: 0 - Sair do programa. 1 - Incluir produto(s). **************** 0 sh: 1: pause: not found The `sh: 1: pause: not found` is because I am running the program on Linux which doesn't have `system(pause)`. &gt; He is not waiting for my response As I explained, this because you are giving `scanf("%d", limit.limite)` a string when it is looking for a number. `scanf()` returns the number of variables that it has read. If you add the following to your code, you will see that `scanf()` is failing (returning 0). retval = scanf("%f", &amp; limit.limite); printf("retval = %d\n", retval); Don't forget that you need to define retval by adding `int retval;` to the top of your main function.
Well, for basic usage of classes, class foo { public: foo(int x_init) { printf("constructing foo!\n"); x = x_init; } ~foo() { printf("destructing foo! nothing to do in this trivial example\n"); } void printx() { printf("%d\n", x); } private: int x; }; int main() { foo f(1); f.printx(); } is basically equivalent to typedef struct cfoo { int x; } cfoo; void foo_init(cfoo * i , int x_init){ printf("constructing foo!\n"); i-&gt;x = x_init; } void foo_deinit(cfoo * i){ printf("destructing foo! nothing to do in this trivial example\n"); } void foo_printx(cfoo * i){ printf("%d\n", i-&gt;x); } int main() { cfoo cf; foo_init(&amp;cf, 1); foo_printx(&amp;cf); foo_deinit(&amp;cf); } But with anything suffienctly complicated, it would be easier to wrap your C++ code in a C api.
Why do you need plain C code? Are you able wrap the C++ code in a lib? &gt;Will I have to do total rewrite of the code ? It depends if you use stl like frameworks. But yes I think you will have to do total rewrite of the code. constructors would be implemented by allocating function and initializing some attributes on structure returning a pointer or reference. destructors would be implemented by free structure and attributes. i.e. ``` typedef struct MyFancyCStruct { char b0,b1,b2,b3; //... }MyFancyCStruct_t; /* ctor */ MyFancyCStruct_t *strMyFancyCStruct_New() { MyFancyCStruct_t *ptr=(MyFancyCStruct_t*)malloc(sizeof(MyFancyCStruct_t)); // initialize the attributes here return ptr; } /* ctor per ref with return error */ uint8_t u8MyFancyCStruct_New1(MyFancyCStruct_t **ptr) { if (ptr == NULL ) { // return here error code return -1; } *ptr=(MyFancyCStruct_t*)malloc(sizeof(MyFancyCStruct_t)); // initialize the attributes here return 0; } /* dtor */ void MyFancyCStruct_Free(MyFancyCStruct_t *ptr) { if (ptr == NULL ) { return; } // destroy the attributes here free(ptr); } uint32_t u32MyFancyCStruct_foobar(MyFancyCStruct_t *ptr,...) { // do foobar return 0; } ```
This sub isn't a programmer shop. Post job offers on corresponding platforms. Lots of people are sharing their projects but you're not even telling us what you're doing. Even if this is not shady or a scam, your post is terrible.
Do you have some more information?
A little more description would give the post more attention. Are you looking for a game, back end, front end, fullstack or infrastructure developer? Also, since this is the C subreddit, I assume you want the work to be done in C?
The first c++ compilers worked by compiling down to C and then running the C compiler to generate code. Are there any reasonably modern C++ compilers that can still emit C output?
Hey guys, can I use the topic to ask for help?
Or he's working on an embedded/low-power device and can't spin up a full-fledged web server. /u/badmuthefoka something like this is totally possible, but you're going to have to essentially implement your own HTTP protocol. Again, not terribly difficult, but easy to make simple mistakes. Normally a web server will, for example, set up a CGI environment and make sure it's sane for your application, but for what it sounds like you're doing, you're going to have to interpret all of the data coming out of the socket manually. Off the top of my head: 1. Open a socket, looking for the terminating character `\r\n`, parsing lines as they come in (to parse the HTTP request) (alternatively allocate a buffer to process the entire header and then loop through it using `\r\n` as a delimiter) 2. Store incoming header lines to a buffer 3. Parse each header line individually and possibly send appropriate responses 4. If the headers look good, prepare a response request, specifying a response code such as 200, and some headers like Content-type, Content-size etc. 5. Send each prepared header, ending with a blank line (two `\r\n`s in a row. 6. If your requested resource lives in a file, for example, open the file and write it out to the socket. This is just a basic dumb file-hosting web server. If you want dynamic content, you're going to need at minimum a templating language of some sort, and that quickly grows to an incredible level of complexity for something like C. Again, doable, but there are a million ways to do it and a lot of ways to do it wrong.
Not sure how well C++ would translate, but [GObject](https://developer.gnome.org/gobject/stable/pr01.html) is a library that supports object oriented programming in C. There is also a free [book](https://www.cs.rit.edu/~ats/books/ooc.pdf) on writing object oriented C.
Email comeaucomputing at gmail and ask them whether they still sell their compiler for $50. It's what you probably want if the code ever needs to be looked at again. However, their website is down because apparently they forgot to renew their domain. [This is the last version in the Wayback Machine.](http://web.archive.org/web/20181111070053/http://comeaucomputing.com/)
Hey I've actually been meaning to read that book. It's older than me though, is it still relevant? Not sure whether C has gone through any big reforms like C++ has.
You re-write it. There's no real automated way to do it (early C++ compilers were C++ to C compilers, but I don't know of anything modern that does that), but even if there were you would still need to go over all that code and clean it up if you have any hope of making it maintainable. By that point, you're almost at the amount of work it would take to just re-write it. This depends on the size of the project, though. The other alternative is to write a C API to the C++ code. This is a thin layer of C code that provides a set of structures and functions you can use to interface with this code. The advantage of this is you compile the C++ code with a C++ compiler, so it doesn't need to be changed. This is how C bindings to C++ libraries are done, it's probably the easiest way to avoid a complete re-write.
Your analysis was spot-on and well-written. The problem is fixed.
What problem? What is even going on here?
Cfront FTW! /s
I appreciate your enthusiasm for sarcasm, but to become a master you mustn't use /s. *I'm a human being, and this action was performed manually.*
You really are the worst bot. As user majds1 once said: &gt; You're an amazing bot /s *I'm a human being too, And this action was performed manually. /s*
Could you give us the whole function including the function signature? ``` i++; execv(shell_path, buf[i-1]); ``` What's the purpose of `i` here? Note that you're incrementing `i` after forking, so the `i` in the parent is *not* going to increment. Not sure if that's intentional or not. ```waitpid(pid, &amp;status, NULL);``` The last argument here should be an `int`, not a pointer. i'm guessing you mean `waitpid(pid, &amp;status, 0);` instead? Out of curiosity, is the intention that the child stops executing immediately, or is there a possibility that the child would exhibit some blocking behavior? If the child blocks, the parent is going to block on `waitpid`. Is this expected behavior? If you want to be able to run multiple child processes concurrently, look into using `WNOHANG` in conjunction with a while loop, and checking for if *any* child has changed state. (actual implementation left as an exercise for the reader)
While I suspect that the book is still relevant, i am by no means a C expert. I have seen the book recommended many times and haven't seen any negative comments against it, so I would guess that it is a solid reference. After I posted my first response, I remembered that many people have recommended looking at the Linux kernel code for good examples of [object oriented C](https://lwn.net/Articles/444910/).
Respectfully, I think you're in over your head... but that said, I hope you prove me wrong. Here's how I'd break down your project (what you want to achieve): 1. (User connects to my server by browser) You want to serve HTML, CSS, JS content over a local network. This means you need a webserver running on some device that has an IP on the local network. Follow-up question: Do you need to build a server yourself? You can probably set up a much more out-of-the-box server using apache or whatnot. If you want to build the server yourself, you need to read up on the sockets API, and HTTP 2. (it will load up a local webpage that has dependencies to bootstrap) You want HTML/CSS/JS content to be sent over HTTP from the server to the client browser. How (precisely) the content is represented server-side is going to depend on what server you use. The fact that it includes bootstrap is entirely trivial to your implementation. 3. (Any changes made on the browser web page will be sent over to the server) Okay, per HTTP best practices, any requests that modify server data should be sent via POST request. You can send POST request with JS &amp; HTML forms, or you can sent the POST request using ajax. Google this stuff -- it's way out of scope of this sub. Once the user has submitted the data, your server needs to interpret it, which means you need to code the logic for the server to accept the request, modify whatever sever-side values you want to modify and save those values to file. Re: your confusions: 1. The best way to "load up proper pages" depends on your webserver, and your back-end framework. If you make simple html pages, you can read those pages, and send the data in the HTTP response. If you have a back-end framework that handles templateing or whatever, then it's going to be a bit more complicated (yet more elegant and scalable) 2. "How would I be able to track the changes since the Client is just any browser unlike creating your own clients?" -- This question makes no sense to me.... but I'll try to unpack it. "How would I be able to track the changes" -- Client sends POST request to server. Server saves values. "Since the Client is just any browser unlike creating your own clients" -- Yeah... I have no idea what you mean..... I can't even try here. :D Hope this helps. Good luck.
There are many examples/[tutorials](https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa) on writing a HTTP server in C. I would recommend starting with one of those, then modifying it to do what you are trying to do, or writing your own based on what you learn. Another possibility is to use an [embeddable](https://www.gnu.org/software/libmicrohttpd/) HTTP server, or a light weight HTTP server like [lighttpd](https://www.lighttpd.net/).
The /s was there to warn people that don't know what cfront was that this is a joke comment, as this is r/c_programming, not r/cpp ...
You're welcome, it was a fun puzzle, and you gave all the needed info, which is not that frequent.
Ah that's actually also a good approach that I hadn't thought of. Thanks
`i/100` is AB. Take any four digit number and divide it by 100, dropping the remainder, and you're left with the first two digits. `i%100` is CD. Do the same division, but this time only looking that the remainder, and you're left with the last two digits. `i/100+i%100` is the sum of these two: AB+CD, and is stored in `sum`. `sum*sum`, therefore, is (AB+CD)\*(AB+CD).
Hi, I have another question. So lets assume i is 1234, so the sum is 12+34=46. 46\*46 is 2116, not 1234. How is that so?
Translating the problem to the code you've provided we get: i = ABCD (our 4 digit number) i/100 = our 1st and 2nd number (1000/100=10 our AB) i %100 = our 3rd and 4th number (1000%100=0 our CD) Test the rule that the sum of i/100 and i%100 = i and print if true. Another example: i = 4593 i/100 = 45 i%100 = 93 45+93 = 138 138 *138 = 19044 != 4593 It's important to note here that this strategy can be used to get placevalues of other numbers such as: (4593 / 10) % 10 = 9 (4593 / 100) % 10 = 5
I'm not sure I understand what you expect. All that means is 1234 doesn't satisfy the condition given by the problem statement. On the other hand, 2025 does: 20+25 = 55, 55*55 = 2025.
Hi, about your example when i=4593, if 19044 doesn't equal 4593, then wouldn't (AB+CD)\*(AB+CD) = ABCD or i wrong?
OP, I'm not sure if you are reading the comments, but there is a right way to do this, and then there are the other comments.
Unless you have a very good reason, don't do that. Write an extern "c" interface on top of it, and use that.
If you want to run them all in parallel, you will need to create an array of PIDs. Like: for (size_t i = 0; i &lt; n; i++) { pid_t pid = fork(); if (pid == 0) { execv(whatever); } else { pids[i] = pid; } } And then have a similar loop afterwards to wait() on them all.
Use either. Honestly, picking a library isn't your biggest concern. Limiting your scope as a beginner is. If you _have_ to have graphics, even for a 2d game if you all really are beginners, you'll be spending all of your time just figuring out that. My recommendation is to pick some sort of classic arcade game, Asteroids is my personal recommendation, and start by just implementing that. If I had to guess, your biggest challenges won't _really_ be completing the game, though that'll be hard. I think you'll run into issues with everyone working on it at the same time, and preventing your (or someone else's) imagination from running wild. You're ***beginners***.
Ok, thanks. The game is (so far) a 2d top down dungeon crawler (like a really ugly really small hyper light drifter). Our teacher said it was small enough for us. Do ye think that it is too hard?(considering his input) And any tips on what not to try to do?
You could always dump to IR or machine code and then hoist it back up into C, although *(visceral shudder)* at the thought.
1. There is no need to cast `malloc`.[^(source)](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc) I can't help but wonder how you (and the majority who make this mistake) miss this, given that you later write `free(ptr)` which of course doesn't use a cast back to `(void *)`... probably something to do with using a C++ compiler to compile C (even though it'd be far fewer keystrokes/complex casts to use a C compiler and then link your C object code into your C++ project using the linker). 2. Always allow the downstream programmer the choice to select their own storage duration. You're probably relying upon allocated storage duration too much. Here's another way to look at it: if you're allocating memory outside of `main` and you ever want to port this code to a system that doesn't have an MMU or you ever run into an allocation-related bottleneck whilst profiling, you're probably going to have to put in a lot more work to refactor that code later... 3. Don't micro-optimise or prematurely optimise. That `uint8_t` choice might seem like a neat optimisation, until you realise it most likely just goes into a 32-bit register *anyway* and then it's a waste of four keystrokes (not to mention it introduces portability issues), the keystrokes which took you far longer to write in person than you ever would've shaved off in computational time. Use a profiler to measure the most significant bottlenecks, and target those. Then once you've made some changes to the most significant bottlenecks, use your profiler to determine whether the changes you made were actually optimisations. This way you can eliminate the waste of your own keystrokes, as well as showing proof that you're actually making the best optimisations you can *for your hardware.* To be clear on this, at times we may make what we assume to be an optimisation, only to find that this optimisation pushes other more significant optimisations further out of reach, or worse yet, isn't an optimisation at all!
I like the suggestion of writing a C wrapper, and the way you're choosing storage durations more appropriate to the task... though there is one thing here I would suggest self-critting on. Don't change `main` to return `void`; this is a premature micro-optimisation. Your most significant bottleneck is going to make this look pale... in fact, the time it takes you to press those extra keys will make the optimisation look ineffective. Not only is it likely ineffective, but it also introduces portability issues[^(source)](http://c-faq.com/ansi/maindecl.html), so on top of that potential ineffectiveness... let me put it this way... this is the premature optimisation that keeps you optimising around in circles, hehe. To frost the turd with icing sugar, our compilers are so good at optimising nowadays they can usually tell you when you have an unreachable branch of code or perform loop-invariant code motion optimisations that most people are unlikely to spot[^(source)](https://ridiculousfish.com/blog/posts/will-it-optimize.html). In short everything here was perfect, aside for that minor nitpick that has you doing extra work for little (if any) gain. I hope for your sake, and for the sake of others who might have to work on your code, that you'll stop doing that...
&gt; The first c++ compilers worked by compiling down to C and then running the C compiler to generate code. That was a long time ago. I'm not sure if you'd call those languages C++ or C, nowadays... you know, language evolves over time. I doubt those compilers would be able to compile code we consider C++ and C respectively, nowadays. &amp;#x200B; &gt; Are there any reasonably modern C++ compilers that can still emit C output? Yes (and you can find more info on that by your own research skills), but since your C++ compiler emits object code that's linker-compatible with the object code produced by your C code, you probably shouldn't bother doing that. Rather, use your C compiler to compile your C code, your C++ compiler to compile your C++ code and then your linker to link the two objects together. Alternatively, you may enjoy maintaining two equivalent codebases in two different languages, pressing more keys, etc... it all depends *how much* ***you like pain*** eh? All you have to do is spend another 2-3 minutes reading manuals about your linker... that and this thing u/looneyaquaah wrote: &gt; Write an extern "c" interface on top of it, and use that. With those latter two points in mind, you can link *nearly any* programming language to *nearly any other* programming language, nowadays... Most (if not all) of this work has probably already been done for you, though, as I can see u/MR2Rick has mentioned in this specific case... it's good to see I'm not the only one who researches and reads rather than guessing and asking others to research and read for us, eh?
C++ is not C Try /r/cpp_questions
okok sorry i dont use reddit and couldn't find any c++ thread
thanks
If that's the thing you're going for, I think the way to make it easier is to make it a rogue-like. This might mean to do things like constrain it to a grid, make it turn based, etc. The state of the program, if you will, gets much simpler and much more procedural if everything looks like "do a, then b, then c, ..." This probably means that your program will be skeletoned like the following: int main(int argc, char **argv) { // ... init code here while (rungame) { handle_input(); handle_player(); handle_monsters(); handle_objects(); // ... etc } // cleanup program return 0; } The while loop is typically called the "game loop", and what's happening in your game all happens within there, until you get some sort of quit condition.
What specifically? “Test if a file can be opened” as separate from “open a file” would imply targeting some specific OS, since C proper doesn’t have anything that can test if a file can be opened without actually trying to open it. Windows might have something to do that—offhand Idunno. But even POSIX is stuck with `access`, which is really that’s only guessing at whether the file can be opened, and of course there’s a timing exploit there—the file can be swapped out between `access` and `open`. So in practice you almost never do that, you just open the file and kvetch appropriately if it fails. “Exit with code” usually means return something from `main`, or iff you’re desperate `exit` (or despondent, `_Exit`). Again, codes other than `EXIT_FAILURE` and `EXIT_SUCCESS` (usually but not necessaily 1 and 0, respectively) are theoretically outside the scope of C per se, but most stuff post-UNIX uses a byte for the exit code so you have 0 through 255. (You should almost never emit anything over like 63 in the real world though. Higher numbers are usually for shell use, like command-not-found or programs shitting themselves to death.)
Pick Raylib. While what the other guy says is true, I would argue picking either is not helpful advice. Raylib is much simpler and easier to use. This means you'll spend less energy trying to understand your graphics API and more energy actually making the game.
https://en.wikipedia.org/wiki/Pseudocode
&gt; Don't change main to return void; this is a premature micro-optimisation. My point isn't that you should do that, but that it's the only semantic difference I'm aware of - if you do, say, `return somefunction()`, I believe that function call would be sequenced *before* the destructor of that object in the C++.
Actually compilers can complain if you don't cast mall of.
https://en.cppreference.com/w/c/io/fwide
Thanks dude.
Why not [gtk](https://gtk.dashgl.com/)?
Ok, thanks
No C compiler will ever complain from a lack of cast due to the implicit conversions of `void *` that exist in C[^(source)](http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3p1)... unless you're missing a `#include` (hintedy hint). You're probably talking about C++ compilers. See my advice on linking C object files into C++ projects.
See also [this source](http://david.tribble.com/text/cdiffs.htm#C99-void-ptr)... you should be able to see from this page a handful of other reasons you should use a C compiler to compile C code, separately from your C++ code, and then link the two together if necessary.
You can use malloc inside C++. Systems coders need to do it all the time.
1. I never claimed to the contrary. What I claimed is that _you shouldn't_. 2. [Don't use `malloc` in C++](https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-vs-new) and [don't cast malloc in C](http://c-faq.com/malloc/mallocnocast.html) (that's a fourth resource in support of my advice). The message ought to be clear. 3. Having said that, **let us not delve too far off-topic without realising, this is r/C_programming**... 4. System coders don't need `malloc` to implement `new` in C++ any more than they need `mmap` to implement `malloc` in C (plenty of hints flying around here huh?)... these can be implemented by other mechanisms. 5. Where is your C++ standard library? I don't mean the one that you use every day; I mean the one that you wrote from scratch, yourself, to demonstrate that you understand the internals of C++ enough to have this discussion. The reason I ask is because it seems like you're flying in territory that is [in spite of advice given by your founding forefather, Bjarne Stroustrup](http://www.stroustrup.com/bs_faq.html#C-is-subset). I have this discussion a lot... look, I get that you want to _know it all_, but the method you're using right now is teaching you techniques that are contrary to a mound of highly credible and authoritative documentation telling you otherwise. In other words, you need to stop doing whatever it is you're doing, and **start reading**.
You are right worse code. Deleted it. But 1. is not true. see "coding conventions" in companies or projects. I forgot to cast on free. 2. thats true but Yury660 does not mention which platform is for ... 3. Thats not true. &gt; Don't micro-optimise or prematurely optimise. That uint8_t choice &gt; might seem like a neat optimisation, ... WYSIWYG on libs - see "coding convertions" as I mention before. Instead of uint8_t I use enums for errors. That is my mistake. But an interface to lib you can/must use types corresponding types which describe the returned value. &gt; it most likely just goes into a 32-bit register anyway That is not true. It depends on platform.
There's no reason not to use malloc in C++. Systems software often needs to interact with hardware or devices directly. You need a buffer but don't always know what that buffer will hold. The article to which you link doesn't even explain why. It simply says "don't do it." How convincing. C++ isn't Bjarne's C++ anymore, so his opinion actually isn't that relevant. And in fact, I'm actually well published in this space. I work at Intel and that's about all the info you'll get from me.
If you want to rewrite everything in C, that's a bit of an undertaking, especially since you're using templates. C doesn't have a concept of full blown generics, so you either have to completely rewrite that logic in a procedural matter or use a mix of void pointers, structs and macros to achieve the same effect. For objects, you would create a base struct and create functions that operate on that. You could also write [OO-style C](https://dmitryfrank.com/articles/oop_in_c), which I'm partial to; especially for game engines. If you just want to *access* your C++ code from C, that's much simpler. You just have to wrap your interface methods with an [extern C](https://embeddedartistry.com/blog/2017/4/4/extern-c) call. Just keep in mind that you can't export the classes themselves, so any OO logic has to stay inside your C++ logic/library.
&gt; There's no reason not to use malloc in C++. You say this in spite of the overwhelming mound of resources I've been giving you... in spite of _the reasons they give_ that _you shouldn't_ use `malloc` in C++. &gt; Systems software often needs to interact with hardware or devices directly. `malloc` rarely (**if ever**) "interacts with hardware or devices directly". I'll touch on paging and virtual memory later on. For now, `malloc` typically wraps: a/ `brk` and `pbrk`, b/ `mmap` (my hint earlier), c/ `RtlHeapAllocate` or d/ some other **OS-defined** function that is embedded into the kernel or the chipset... there are literally _an infinite number_ of ways to expose an MMU, and not all of them involve casting `malloc`... **In fact**... and this is the reason I asked you to show your C++ standard library (which **you didn't do**)... _system programmers in C++ don't cast `malloc`, even when they're using `malloc`, because **they don't need to!**_ You can see an example below. I'd really appreciate if you'd stop talking about rubbish you clearly have never experienced... or else **show me your C++ standard library**. &gt; You need a buffer but don't always know what that buffer will hold. Funnily enough, I bring your attention to the following excerpt from [a history of C++: 1979-1991](http://www.stroustrup.com/hopl2.pdf) written by Stroustrup: &gt; `malloc()` used to implement `new` became the most common performance bottleneck in real systems. This was no real surprise either; the only problem was what to do about it. Having real programs spend 50% or more of their time in `malloc()` wasn’t acceptable. This forms yet another reason to use `new` instead of `malloc`, which I'll let you add to the list near the end of this post. I would suggest that you want your memory to have somewhat _virtual addresses_ as opposed to _physical addresses_. You want it to float (in _pages_) between whichever disk you use for _paging_, and between your physical memory, right? This is partially so that your OS can multitask effectively, for the purpose of consolidating memory fragmentation and ... perhaps a few other minor reasons. Paging is a **very _high-level_ concept**, far from "interact with hardware or devices directly" as you claim... paging is OS-related, not so much hardware-related. You can implement `malloc` or `new` on a per-OS basis by using whatever method the OS gives you to allocate memory... and **no OS kernel that I'm aware of implements `malloc`**; they typically implement one of those that I mentioned above. I hate having these discussions with people who **haven't written their own standard libraries** (such as _arrogant web developers_), because they're typically [not even aware of how to overload `new`](https://en.cppreference.com/w/cpp/memory/new/operator_new)... can you show me where it says it's necessary to cast `malloc` in that manual? There's even an example that _uses `malloc`_! Can you show me where they're _casting_? &gt; The article to which you link doesn't even explain why. [Here](https://www.youtube.com/watch?v=vQhqikWnQCU) is some music to listen to while you observe the citations I pulled from sources I already cited: &gt; ... it will ensure that your type will have its constructor called. The new keyword is also more type-safe whereas malloc is not type-safe at all. -- [StackOverflow: In what cases do I use malloc vs new?](https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-vs-new) &gt; That said, it is a good idea to avoid unsafe code like the plague whenever you don't actually need one of those three features: &gt; - don't use casts &gt; - keep arrays out of interfaces (hide them in the innards of high-performance functions and classes where they are needed and write the rest of the program using proper strings, vectors, etc.) &gt; - avoid `void*` (keep them inside low-level functions and data structures if you really need them and present type safe interfaces, usually templates, to your users) -- [Bjarne Stroustrups F.A.Q.](http://www.stroustrup.com/bs_faq.html) Clearly the implication is that using `malloc` in C++ might be **unsafe**. In that last page you may note he links to [his second F.A.Q. page](http://www.stroustrup.com/bs_faq2.html#void-ptr) on this topic where he adds... &gt; Incidentally, the `new` operator offers additional advantages over `malloc()`: &gt; - `new` can't accidentally allocate the wrong amount of memory, &gt; - `new` implicitly checks for memory exhaustion, and &gt; - `new` provides for initialization ... and on top of that you can add the _performance_ reason I mentioned above. All you had to do was read for fifteen or twenty minutes... what is it you intend to prove... that _you can't read_? What is your end goal here? To be seen as the biggest _know-it-all_ on the internet?
It's hard to see what it is you're disagreeing with. It seems like you're trying to say there's a need to cast `malloc` in C++. For a start, there's generally no need to _use_ `malloc` in C++ to begin with. Even when you need to implement your own `new` operator, note that [this is done without casting](https://en.cppreference.com/w/cpp/memory/new/operator_new). The standard idiom or "coding convention" in C, w.r.t. returning error flags via an integer, is to use `int`. See [`main`](http://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1), [`fgetc`](http://port70.net/~nsz/c/c11/n1570.html#7.21.7.1) and [`fputc`](http://port70.net/~nsz/c/c11/n1570.html#7.21.7.3) for just a few examples. When some non-integer return value is used, it's usually a pointer (such as `FILE *`, `char *` or `void *`)... you won't see `uint8_t` return value in standard C, because that's a rather non-portable type, as you can see from the quote below (extracted from [here](http://port70.net/~nsz/c/c11/n1570.html#7.20.1.1)): &gt; These types are optional. However, if an implementation provides integer types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed types) that have a two's complement representation, it shall define the corresponding typedef names. You seem to have had a problem with my assertion below... &gt; &gt; it most likely just goes into a 32-bit register anyway &gt; That is not true. It depends on platform. I think you're just trying to clutch straws to save some ego, when it really doesn't matter (we're _all_ nerds here, got it?)... or maybe you want the non-portable 8 bit value to go into a 64-bit register, instead?
&gt; You say this in spite of the overwhelming mound of resources I've been giving you... in spite of the reasons they give that you shouldn't use malloc in C++. None of the links you've provided give a good reason, or even really any reason at all. &gt;malloc rarely (if ever) "interacts with hardware or devices directly" malloc isn't either OS or hardware specific, so why would it? You don't need to call a device to allocate memory. The host allocates memory, then shares it with the device. So long as it's a valid user-space pointer, and that's what the driver expects, that's no problem. In fact, even very specific things like xpmem work with malloc or hell, even SmartMap, works with malloc. The rest of your post is a gish-gallop and likely isn't even correct, hence, I will not read it.
&gt; C++ isn't Bjarne's C++ anymore, so his opinion actually isn't that relevant. He most certainly is [on the WG21 committee](https://isocpp.org/wiki/faq/wg21)... where-as I note you are not... so his opinion is more relevant than yours. &gt; And in fact, I'm actually well published in this space. I work at Intel and that's about all the info you'll get from me lol... you're a web developer and salesperson, right? I looked you up earlier. From what I can see you've got _no published code_... another reason I asked _where is your standard C++ library?!_ Hell, you're trying to advocate use of `malloc` to implement `new` in C++ and all you have to show for yourself is some answers on StackOverflow for the ASP.NET tag... do you know your opponent as well as your opponent knows you? You know, you might actually do damage one day while you have this woody playing with technology like it's your sex doll and you have multiple of them. Not that I'd be bothered if you got fired for damaging your employers equipment. While I move on humbling myself to our pioneers and respecting them rather than ignoring their advice, I suggest listening to [this song](https://www.youtube.com/watch?v=d5ab8BOu4LE) for some insight... Always know your opponents. I'm done here.
Hello, what you really did in the first piece of code was that you dereferenced the pointer so that you can use the dot operator. This means that you can translate hist[count] to *(hits + count) which dereferences the hist pointer (look up pointer arithmetic) and use the dot operator. The difference to the second piece of code is that you do not dereference the pointer so you either use the arrow operator or dereference the pointer by writing *(n) in order to use the dot operator. Excuse the lack of formatting since I am only on mobile.
&gt; He most certainly is on the WG21 committee... where-as I note you are not... so his opinion is more relevant than yours. He's not that active. He's mostly an administrator who is responsible for making sure the meeting takes place, and finding new committee members as needed. &gt;lol... you're a web developer and salesperson, right? I looked you up earlier. No, my name is actually doxxing a very (used to be) famous Creationist and evolution denier. &gt;Hell, you're trying to advocate use of malloc to implement new in C++ and all you have to show for yourself is some answers on StackOverflow for the ASP.NET tag... do you know your opponent as well as your opponent knows you? Nope. If you don't understand what I'm talking about, it's likely because you've never worked with any real systems code.
The dot operator is used to identify a particular member of a structure or union. It used when the left-hand side is of structure or union type. The arrow operator does exactly the same thing... except it's used when the left-hand side is a _pointer_ to a structure or union. In your example, `n` is a pointer to `struct node`, which is why it needs an arrow. &gt; This is really confusing And unfortunately there's no fundamental reason for it. C _could_ have allowed the dot operator (or, alternatively, the arrow operator) to work on pointers, structures and unions, since there is no syntactic or semantic ambiguity... but it doesn't. That is unfortunately just the way the language works.
it's been a while since i looked at raylib, but i believe it still doesn't need any dependencies. just plug and play. i'd say go with that one.
&gt; hist[counter].cmd The source of your confusion seems to be that array subscripting does more than you think. Array subscripting contains an implicit dereference and is not simply shifting the `hist` pointer along to yield another pointer. `hist[counter]` is equivalent to `(*(hist + counter))` by definition. These are all equivalent and work: /* 1 */ n-&gt;bfr = str; /* 2 */ (*n).bfr = str; /* 3 */ (*(n + 0)).bfr = str; /* 4 */ n[0].bfr = str; The equivalence between 1 and 2 is a matter of definition: That's how the `-&gt;` operator is defined. The equivalence between 2 and 3 should be obvious. The equivalence between 3 and 4 is also a matter of definition, as mentioned above.
There are few misconceptions here. &gt; I have a memory leak, partially because I'm mallocing the space for the nodes That is not the reason. Memory leak occurs when you allocate some memory and "lose" a pointer to it either by overwriting the value of a pointer variable or going out of scope (which deallocates the pointer variable) without releasing it first. This makes the allocated memory block inaccessible and practically impossible to release. &gt; and also mallocing the space for the string, which I shouldn't have to. There is nothing wrong with allocating memory for a string. Even more - often you have to do it, especially when dealing with linked lists. As long as you have the pointer to it and it's still needed, there is no memory leak. &gt; So basically we could access any Cmd in our array of Cmds and change the string with the dot operator, which would persist and not cause a memory leak. Dot operator does not protect against memory leaks. It was already explained here what it does, so I am not going to repeat it. You can have a structure with dynamically allocated member, that you access using dot operator and still overwrite it without calling `free()` first and create a memory leak. There is a great tool for detecting leaks and problems with accessing memory. It's called Valgrind and every C programmer should be familiar with it.
In summary of this entire thread, you've changed positions multiple times, from saying casting is necessary because C compilers need it (and being proven wrong), then onto claiming how `malloc` is "needed" in C++ (and being proven wrong)... with multiple citations against you from highly credible resources and authoritative people along the way... now you're trying to discredit Bjarne Stroustrups involvement? &gt; Founding member of the C++ Standards committee and have attended almost all meetings. &gt; Chair of the Evolution Working Group. Pushed for the inclusion of the STL, for move semantics, contributed to concepts, initializer lists, constexpr, auto, and much more. It's still his baby, and you look like a sociopath. What _else_ do you have to hide behind the name of someone else? &gt; If you don't understand what I'm talking about, it's likely because you've never worked with any real systems code. Just like my `malloc`, an STL `new` needn't rely upon anything OS-specific... #include &lt;iostream&gt; #include &lt;cstddef&gt; void* operator new(std::size_t sz) { static std::max_align_t store[65535 / sizeof (std::max_align_t)]; static std::size_t offset; sz = sz / sizeof *store + !!(sz % sizeof *store); std::size_t intermediate = offset; std::cout &lt;&lt; "Allocator called" &lt;&lt; std::endl; return offset + sz &gt; sizeof store / sizeof *store ? NULL : store + intermediate; } void operator delete(void *ptr) noexcept { std::cout &lt;&lt; "Deallocator called" &lt;&lt; std::endl; } int main() { int *fubar = new int; delete fubar; return 0; } I guess it depends what you call "real systems code"... I know how to write allocators that don't rely upon `malloc` (let alone casting malloc), and uhh... C compilers... you know, stuff like that? _Where is your C compiler?_
This sub is only for the C programming language; try asking in /r/csharp instead.
&gt; In summary of this entire thread, you've changed positions multiple times, from saying casting is necessary because C compilers need it (and being proven wrong), I never once said C compilers need it. The rest of your post is an irrelevant gish-gallop and isn't worth reading.
My bad thanks!
&gt; Actually compilers can complain if you don't cast malloc. Which subreddit are we in? Tell me what actual context you had to make this remark in this subreddit.
&gt;The rest of your post is an irrelevant gish-gallop and isn't worth reading. I wonder how it is your mother managed to avoid invoking `abort` whilst compiling you... furthermore, you should've been `f??/` `flush`ed along with your first `1.p-e-e-p-e-e`... you're accessing out-of-bounds, here. You managed to test positive from `std\` `in` trying to `get\` `char` from a `fork`, and you think that makes sense?! `ty\` `pedef FILE *you; (you) f??/` `open ("/root", "b")` See, you're not the only one who can use ad hominem. Can you stay on topic, though?
C# is off topic in this subreddit. Please post C# questions to /r/learn_csharp instead.
Job offers are on topic in this subreddit.
I have thanks, do you want me to delete the post?
As you like. I have already removed it.
The template classes especially would be a mess. This really seems like the best answer unless OP is hellbent on doing everything in c.
I made a simple side scrolling 2d level with sound in C using SDL last summer by following this set of tutorials, took me maybe a week. I have no experience with Raylib though so maybe it is easier though SDL was pretty straight forward. [https://www.youtube.com/playlist?list=PLT6WFYYZE6uLMcPGS3qfpYm7T\_gViYMMt](https://www.youtube.com/playlist?list=PLT6WFYYZE6uLMcPGS3qfpYm7T_gViYMMt)
C is the one of the most important languages you will ever learn. It gives you good understanding of high level languages, you will now what will happen under the bridge if you do something. And won't you take classes like OOP in future?
Build a lot of program you want, don't be afraid of making your hands dirty. As you do lots of projects, you get better.
The best way to advance is by doing. And the best way to motivate yourself is to pick a corner that interests you, like games, operating systems, compilers, and hammer away at it. Do modest projects, then incrementally challenge yourself
Experience. Write code, discuss, read books and others' codes.
Definitely take a systems level programming course if you're enjoying C. More than that, try to get away from Windows and start digging into Linux—having the ability to actually see how the operating system is interacting with your code and vise-versa is such a nice perk. Resist the temptation to use an IDE and really high level languages until you know what they're doing for you. Don't feel like you have to memorize syntax on simple things: I DuckDuckGo the most basic of things about languages on an almost daily basis. What is important is to intimately learn how types in languages work and basic program flow (e.g., you need to iterate through something, so use a for loop). Specifically, I would pay extremely close attention to how pointers and structs work in C. That knowledge will serve you for the rest of your development career. Pointers. Structs. Threads and process flow. (And by extension, pthreads) OpenMP. (Once you spend time with pthreads, you'll wonder why you ever had to learn about them, but I promise, it's worth it) Going further down the rabbit hole, how compilers and assemblers work. If you feel like talking some time to learn the RISC-V or MIPS instruction set, you'll get a slightly better idea about how your code is actually being interpreted by the computer, and what can cause inefficiencies. For this stuff, I'd recommend looking into games by Zachtronics on Steam, like MHRD.
If you want to try something quite different from C then you should try Haskell.
IMO being a good programmer is less about knowing languages/frameworks/whatever, and more about being developing a strong mental toolkit for reasoning about the best (efficient, reliable, maintainable, extensible) approaches for solving problems - this is a language agnostic skillset. I think this can only be gained through years of experience, by working on a variety of interesting projects; and your choice of which language to learn should be guided by what kind of things you’re actually interested in working on (and hopefully to a somewhat lesser degree, what is commerically important).
yeah so in other words, you are **wrong.** No where do I say *C* compilers *need* it.
The same way you become an expert at anything. Be interested, learn from others, practice.
[Stack Overflow](https://stackoverflow.com/) is your friend.
Practice, practice, practice. You don't learn to program just by reading books. You learn to program by programming. Get a job programming, even at a low level if you can. The code reviews you'll get in a working environment are invaluable. Otherwise, find some other environment where you'll receive code reviews.
step0:Become a programmer. step1: Advance.
&gt;OpenMP. (Once you spend time with pthreads, you'll wonder why you ever had to learn about them, but I promise, it's worth it) Can you elaborate? I consider myself a someone proficient C programmer and have never come across OpenMP. I am familiar with the pthread library and have some experience using std::thread in C++, although I understand that this last bit isn't relevant to C.
So OpenMP is a native threading macro you can use in your C code to basically automate the threading process in a rather optimized way. For documentation, I recommend looking up the #pragma macro (which is how you actually use it in your code). It is currently supported on all major operating systems and has gotten so efficient and effective that it can pretty much replace pthreads entirely. A good example, let's say you want to process some data in a parallelizable for loop. Instead of manually spinning up threads and worrying about syncing and joining, you can just do `#pragma parallel for ...` then proceed to write your for loop as normal; the compiler will automatically handle thread definitions and all that jazz. It's a pretty magical tool.
"Seven languages in seven weeks" is a great book that will help you understand many different ways of looking at a problem. I wholeheartedly recommend giving it a read.
Learn about everything. Be curious. Practice a lot! Data Oriented Design: https://m.youtube.com/watch?v=rX0ItVEVjHc Functional Programming: https://m.youtube.com/watch?v=E8I19uA-wGY Find something you’re curious about, and learn it. Dissect it. Figure out “why” and “how” ... you are in a fantastic field for the individuals who are hungry for knowledge ... there is always something to learn. Do this and you’ll find yourself being more experienced as your peers because frankly... most people forgot how to be curious and learn. They think that since they get paid to do this stuff that they should only do it during working hours and they don’t need to practice to get better.
Cool, I will definitely look into it then. Thanks. &gt;Though I will say, having a solid grasp of shared memory, variable reductions, and mutual exclusivity goes a long way to properly using OpenMP. Yeah, I'm hoping my experience with threads in C++ will help there. I do intend to learn the thing properly, I just wanted to get a sense of why it is useful. So many libraries exist today that are of no benefit to people who actually know what they are doing, yet are pushed on developers by non-technical [managers who have no idea what's flying](https://www.youtube.com/watch?v=BKorP55Aqvg). Although that's less of a problem in C and C++, seen more in the Python development environment. Perks of being a wizard, I guess.
The `restrict` qualifier essentially says that for some particular pointer, within some certain period of time associated with that pointer, every individual byte of storage throughout the entire universe will have one of three characteristics: 1. The value of that byte will not change within that region of time. 2. No accesses to that byte will be performed using lvalues derived from that pointer. 3. All accesses to that byte will be performed using lvalues derived from that pointer. For this concept to be meaningfully applied to a particular pointer, it is necessary to identify the associated period of time, and be able to identify all lvalues that are derived from that pointer. In most cases where pointers are stored in `restrict`-qualified automatic-duration objects whose address is not taken, neither of these requirements will pose any difficulty. Consider, however, something like: int test(int *restrict p) { int **pp, *q; pp = &amp;p; q = *pp; *p = 1; *q = 2; return *p; } Is `q` derived from `p`? What if the code were: int *temp; int test(int *restrict p, int *pp) { temp = p; q = *pp; *p = 1; *q = 2; return *p; } The pointer in `temp` would clearly be derived from `p`. Does that mean, though, that if `*pp` happens to hold the address of `temp`, `q` would also be derived from `p`? The way the Standard defines the concept of derived pointers would suggest that it is, but that would effectively kill the usefulness of having qualified `p`. The cases where `restrict` is most useful generally don't involve any such complications. Further, the Standard never requires implementations do anything with `restrict` other than issue diagnostics for certain syntax errors or constraint violations. Thus, a practical (and common) way for compilers to deal with such issues is to effectively ignore `restrict` qualifiers in the more complicated cases. While trying to aggressively optimize more complicated cases might be more "fun", responsible people writing quality compilers will treat such cases more cautiously.
That's not a string homie. it's a struct, where the dot operator is defined.
Maybe some printf formatting guru knows a cleaner way, but here's one approach: printf("%02x %02x %02x %02x", value &gt;&gt; 24 &amp; 0xFF, value &gt;&gt; 16 &amp; 0xFF, value &gt;&gt; 8 &amp; 0xFF, value &amp; 0xFF);
step3: afvbug4ssße3fgu7hht step4: ????????????....12345678901234567890 Program received signal SIGSEGV, Segmentation fault.
get a job. write code for years.
Thank you all for your inspiring and helpful answers!
Linux
Some systems have %H for hexdump, two arguments: address and byte count.
May I ask *why* you want to use widechars? A common mistake is thinking you need them without realizing that: * You can do lots of operations without any issue by storing UTF-8 in regular C strings, e.g. `printf("猫");` works just fine. * For the things in which regular *char* doesn't cut it (e.g. string splitting), *wchar_t* won't solve the all the cases either.
Is there possibility for a buffer overrun? If the character encodes into 4 bytes, there's no room for \\0 in MB\[\].
I just like to point out, my edit happened before this comment. so the segfault is someone else's fault. So.. i'm off to work for a startup now. See ya.
Lol
I'm experimenting with a simple compiler that compiles code to C, and I want to have the option to have functions defined with non ASCII names. For example `öööö()` would compile to `call_function("öööö")` which may work with `call_function` accepting `char *`. But in short, I just want to know how it's actually works, and a string with non ASCII characters that wouldn't fit the `char` still represented as a `char *`.
I'm not sure about that, the sanitizer not reporting any issues, and I think `wcstombs` terminates the string.
In all seriousness - Yes, C is the most important language you could possibly learn. Every language in existance derives from it, and most basic functions a a must built-in's. Think stuff like printf, file operations, sockets, etc. You might be new in such a language, but knowing C will give you the opportunity to just get what you want with simple substitution of commands. On a personal level .. becoming better is just practicing more. I'm not the only one to point that out, but CS is a craft more than it's a science - do more. Do things that you need to use. Make your own tools sometimes. If you ever think that your tools will be worse than an already developed one - keep in mind that the more universal a thing is, the less well it'll perform. So it's actually easy to overpower popular programs by just being specific on what you'd target. OOp is something you shouldn't touch on until you have the need for. When you've built systems that are complex enough to even need oop - you might see the need for a shift up in your language. The object oriented thing is more of a style, rather than a language specific thing. You can do oop-styled code in C. That's where it came from in the first place. When you encounter or write up a system complex enough - you'll see the need for oop. Then you're free to explore that. Do not jump into complex solutions when you have a simple task. Do things that you need .. or that anyone needs. programming is a solution, not a problem. Do more. I don't wanna diminish the value of proper algorithms and structures, yes - you absolutely need to know all about those. But more often that that you'll be faced with boring and repetative things. And you need to be comfortable about the environment, the tools you use, and never be afraid to jump into new territory. Do more. Do some 3d stuff. it's really easy and fun. So some CV stuff - it's really ...err.. fun. Do some text search/formatting/editting things. It's useful. Don't limit yourself to one language. People tend to hate on interpreters, but they have their own function - go one step above and implement an interpreter within you own program - you can use Lua, php or perl, they're all easy to implement. Distinguish between high-perfomance and high-reliability tasks, so you'll know what to do when. This will also teach you a lot about how large libraries interact with each other. Do more. Write your own tools. When you've done so, you'll maybe acknowledge what the conventional libraries have done right or wrong. Did i ever say you need to do more? yeah. do that.
[C Primer Plus](https://www.amazon.com/Primer-Plus-6th-Developers-Library/dp/0321928423/ref=sr_1_1?keywords=c+primer+plus&amp;qid=1559766243&amp;s=gateway&amp;sr=8-1) by Stephen Prata is a very good book to learn C with alot of exercises after every chapter. The book does not assume any prior programming knowledge.
&gt; For example `öööö()` would compile to `call_function("öööö")` which may work with `call_function` accepting `char *`. &gt;But in short, I just want to know how it's actually works, and a string with non ASCII characters that wouldn't fit the `char` still represented as a `char *`. That works without multibyte strings, as long as it's UTF-8. "öö" in C will create a string with 5 bytes (0xc3 0xb6 0xc3 0xb6 0x00). The "ö" doesn't fit a single *char*, sure, but as long as you don't need to operate on each character individually that's largely irrelevant.
I think I get it, thank you!
Would also work if you typecast the pointer to a byte and treat it like an array of 4 bytes?
Nice series 👍
No, C99 introduced VLAs (variable length arrays), and it was made optimal in C11, but all the major compilers allow it. The problem here is using a VLA with a compound literal, which the error states in OPs post. Invalid: int size = 4; int *array = (int[size]){0, 0, 0, 0}; Valid: int *array = (int[]){0, 0, 0, 0};
Learn Linux.
Okay, that makes a lot more sense. Thank you very much!
Good points. I'm struggling with how to fix the memory leaks I do have. I've been using Valgrind, here's the output of `valgrind csll --leak-check=full`: $ valgrind csll --leak-check=full ==22905== Memcheck, a memory error detector ==22905== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==22905== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==22905== Command: csll --leak-check=full ==22905== test3 test8 No list! No list! No list! No list!! ==22905== ==22905== HEAP SUMMARY: ==22905== in use at exit: 112 bytes in 19 blocks ==22905== total heap usage: 32 allocs, 13 frees, 299 bytes allocated ==22905== ==22905== LEAK SUMMARY: ==22905== definitely lost: 112 bytes in 19 blocks ==22905== indirectly lost: 0 bytes in 0 blocks ==22905== possibly lost: 0 bytes in 0 blocks ==22905== still reachable: 0 bytes in 0 blocks ==22905== suppressed: 0 bytes in 0 blocks ==22905== Rerun with --leak-check=full to see details of leaked memory ==22905== ==22905== For counts of detected and suppressed errors, rerun with: -v ==22905== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) [Here](https://github.com/RiverMatt/cs253testbed/tree/master/csll) is the code. I have a free() on line 119 that Valgrind says is invalid, but the equivalent (I think) free() on line 105 is not invalid and does reduce the memory leak. From here I really have no idea how to solve the other leaks.. I have to malloc the strings to return them when I remove nodes, but I have no idea where the corresponding free() would be. I'm also certain I'm not freeing memory completely when removing nodes, but I'm not sure how I should be doing that.
This IS really cool but you prove something wrong about your title in your Compilation section: &gt; Until now the compilation was pretty straight forward, the code of the first part was compiled with a simple &gt; &gt;gcc statemanager.c main.c &gt; &gt;, in this case we need something more. We are using SDL now so we have to link the library and include the headers, i’m using MAC, it’s different for every OS. &amp;#x200B; That there is no functional thing as "pure C." :)
Heres a quite general way do this. First, make a function to detect endianness int is_big_endian( void ) { volatile uint32_t i=0x01234567; return ( ( ( uint8_t* ) ( &amp;i ) ) [ 0 ] ) == 0x67; } That way we can print in the human way. Then make a function to print byte-by-byte. To do that, we will take in the value as a void* and then print each byte with a space. void print_a_thing( void* thing, int size ) { if ( thing == NULL || size &lt;= 0 ) { exit( 1 ); } char* tmp = thing; int big_end = is_big_endian(); for ( int i = 0; i &lt; sizeof( size ); i++ ) { printf( "%02x ", ( big_end ? ( tmp[ i ] ) : ( tmp[ size - 1 - i ] ) ) &amp; 0xFF ); } printf( "\n" ); } then main looks like int main() { int32_t a = 0xaabbcc0d; print_a_thing( &amp;a, sizeof( a ) ); return 0; }
I did this
&gt; yeah so in other words, you are wrong. No where do I say C compilers need it. We're in a subreddit about C, and you seem to be missing the point... like... this somehow managed to fly straight over your head: &gt; Can you stay on topic, though? The world doesn't revolve around you and I... get it, my sociopathic tapeworm of a friend? This is /r/C_Programming, and you've been clutching at straws to defend your precious ego the whole time... Unlike you, it doesn't bother me if I misinterpreted your words (which were out of context and irrelevant any which way you look at it). I'll admit that I made a mistake and move on; in this case I'm just as responsible for misinterpreting your words as you are for writing the gibberish. **... but this still misses the point... which is that this subreddit is /r/C_Programming, and not /r/teenage_bitch_psychology. Grow up, and learn to stay on topic.**
you can make a loop to fork each process, then wait for each one and check if its return value is zero. here's an example #define NUM_COMMANDS 3 char* commands [ NUM_COMMANDS ] = { "ls -l", "whoami", "ping -c 1 reddit.com" }; int main() { pid_t PIDS [ NUM_COMMANDS ]; int non_zero_exits = 0; //start the children for ( int i = 0; i &lt; NUM_COMMANDS; i++ ) { pid_t pid = fork(); if ( pid == -1 ) { printf("cant fork, error occured\n"); exit( 1 ); } //child if ( pid == 0 ) { execlp( "/bin/bash", "/bin/bash", "-c", commands[ i ], (char*)NULL ); } //parent else { PIDS[ i ] = pid; } } //collect the children for ( int i = 0; i &lt; NUM_COMMANDS; i++ ) { int retVal; waitpid( PIDS[ i ], &amp;retVal, 0 ); if ( retVal ) { non_zero_exits++; } } printf( "%d of %d had non-zero exits\n", non_zero_exits, NUM_COMMANDS ); return 0; }
Yes, in the future.
Honestly, the internet is probably good enough to get you started on learning C. Try making a simple console calculator as your first mini assignment, and don't copy paste code without understanding what every line in it means. You don't need a book.
The K. N. King book is excellent. It's the book I recommend.
The problem is this: [https://pastebin.com/5bzbPQjm](https://pastebin.com/5bzbPQjm) and code which has this problem is this: [https://pastebin.com/yWuGZCHc](https://pastebin.com/yWuGZCHc) .
I studied on "C ++ Primer" and I felt very satisfied, both for the writing style of the book and also for the concepts expressed. I think that che C version could be the same of the C++ :)
I'm most interested in how you're going to manage the structure here. I usually opt for ECS in my C game engines, but the homebrewed solution I have is...interesting. There are a lot of concessions and concepts that have to be accounted for when lacking generics and OOP.
The time I used linux, I couldn't write a single line in C and the moment I started writing C, I didn't use linux at all. I don't think there's a real benefit in "learning" linux, to get better at C (time invested vs. benefit). I'd recommend to do some things which are bad practice in C, like storing pointer addresses in char arrays to link structs or something like that. The moment you get things like that done, without thinking to much about it, your are ahead of the beginner level
&gt; I have to malloc the strings to return them when I remove nodes No, you don't have to do that :D If you allocated the node contents dynamically, they don't vanish when you deallocate the node. Just return them and free elsewhere, when they are no longer needed. Let me show you: ``` /* strdup() needs _POSIX_C_SOURCE */ #ifndef _POSIX_C_SOURCE #define _POSIX_C_SOURCE 200809L #endif /* !_POSIX_C_SOURCE */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; typedef struct { char *element; } NodeImpostor; static NodeImpostor *make_node(const char *content) { /* Create a new node, allocate memory for element and copy * `content`s there (both with `strdup()`). */ NodeImpostor *node; if ( (node = (NodeImpostor*)malloc(sizeof(NodeImpostor))) == NULL ) return NULL; /* Out of memory */ if ( (node-&gt;element = strdup(content)) == NULL ) { /* Out of memory */ free(node); return NULL; } return node; } static char *free_node(NodeImpostor *node) { /* Free the node and return its element */ char *contents; contents = node-&gt;element; free(node); return contents; } int main(void) { NodeImpostor *node; char *contents; if ( (node = make_node("I am not dead yet!!!")) == NULL ) abort(); /* There's not much we can do with OOM here */ printf("In node: %s (%p)\n", node-&gt;element, node-&gt;element); contents = free_node(node); printf("After freeing the node: %s (%p)\n", contents, contents); free(contents); return 0; } /* vim: set ft=c sw=4 sts=4 et: */ ``` When I run this program on my machine, this is what I get: ``` In node: I am not dead yet!!! (0x55b6e97b3280) After freeing the node: I am not dead yet!!! (0x55b6e97b3280) ``` As you can see, the contents are still alive after deallocating the node and it's the same memory block (the address in parentheses is the same). They are still usable until freed. BTW, `strndup(string, strlen(string))` has exactly the same effect as `strdup(string)`.
I've taken computer architecture (i.e. basic circuit level computer hardware), written some assembly, and taken an operating systems class where we wrote a linux shell, a user-level thread library with protected storage, and a file system/disk manager, and then a basic MIPS assembler on my own time (and play all the Zachtronics games). Some might consider this fairly advanced and ticks most of your boxes, but it only feels like scratching the surface. What do you suggest from here? Write my own kernel? Compiler? Try that dude's crazy idea of writing a DOS game from scratch? I'm more interested in hardware and high performance computation for my physics research and/or video games, but it doesn't seem like there's as clear cut of a path forward from here, did I "win" and now it's just time to apply my experience to real life problems?
I’d recommend formatting code blocks with four spaces instead of the triple-caret syntax, as the latter is supported only by reddit’s terrible redesign.
Oh, sorry. I often work with Markdown syntax and keep forgetting it's only in the new Reddit layout.
Since you will learn new languages in future, if I were you I would focus on my problem solving skills and understanding of the language. You can code simple game like snake for example, it would be interesting experience. I think it is more important to learn deeply than practising some thing over and over again. So I can recommend the book called The C Programming Language -you can skip the UNIX interface section if you didn't take systems programming class-. It is thin book, you can read fairly quick. Of course exercises are important. And coding conventions are important too. Just pick one and follow it. For example I am following NASA's C coding conv. document (1997) but probably you can find shorter and concise ones, it was a bit long. It helps quite a lot. About new languages there are main paradigms -structural, object oriented, functional, logical- and if you learn a language from one paradigm, it is easier to learn other languages have same paradigm. So don't be afraid there are zillions of languages out there.
UNIX-like systems are a native environment for C language and POSIX standard.
Sorry but I didn't understand. Please elaborate.
No problem, it’s more reddit’s fault than yours.
No blog spam.
Yeah but learning "linux" will take a lot of time which won't benefit your C skills in any way directly
What you want does not exist. There aren't even disassemblers which can give you this guarantee and given that C compilers make vastly different choices as to what code they generate depending on a lot of factors, there is in general no way to get a C compiler to emit the exact same series of instructions you found in a binary.
Fine. Not exact binary. But at least the same functionality. The current decompiled does not even compile.
http://boomerang.sourceforge.net/cando.php?hidemenu This seems to be about the best you can get.
Which decompiler did you try? The standard tool is Ida Pro. But keep in mind that decompilation is not an automatic process. It's meant as a starting point for an experienced developer to clean up and refactor the resulting code.
Looking at what is meant by learning Linux. Diving into Linux and POSIX API is a good thing to increase your knowledge not only in C but also in networking, operating system concepts, etc.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { void *p; printf("%p\n", p); p = malloc(sizeof(int)); printf("%p\n", p); free(p); printf("%p\n", p); free(p); printf("%p\n", p); return 0; } Output: ./test 0x7f7ffffe36d8 0x9c24ba8f940 0x9c24ba8f940 test(75980) in free(): chunk canary corrupted 0x9c24ba8f940 0x4@0x4 (double free?) Abort trap (core dumped) p gets an address + memory. The first time I call free, I give the memory back to the OS, but p won't lose the address. The manpage of free() of the OS OpenBSD: The free() function causes the space pointed to by ptr to be either placed on a list of free blocks to make it available for future allocation or, when appropriate, to be returned to the kernel using munmap(2). If ptr is NULL, no action occurs. If ptr was previously freed by free() or a reallocation function, the behavior is undefined and the double free is a security concern. (the last sentence is very important) &amp;#x200B; Your compiler has no defined behavior how it should act if an address gets free'd twice, so it just does something. If the compiler does something which isn't defined, it could do anything which could result in crazy behavior of your programm. &amp;#x200B; My OS checks the memory after free'ing it with a little number behind it, if that number got changed, it's corrupted and results in a seg fault
Every five seconds, someone on reddit asks for book recommendations. Every 10 seconds, someone on reddit replies with the same answers.
You know, that's a load of crap. If you want OOP in C, all you have to do is use the common initial sequence idiom and call function((cast)this, args) instead of this.function(args). If you want polymorphism, implement it yourself by switching on an enum member representing the type of a union, or simply call a wrapper function that resolves the call for you (Digital Mars C++ did this). It's a bit of boiler plate, that's all. Compile time generics are implemented by using the preprocessor like it's lambda calculus. Not terribly nice to look at, but honestly quite sound once you get used to it. On this you have a real point, but there is still a wealth of metaprogramming work done in the preprocessor.
Here's another hint: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void func(void *); int main() { void *p; p = malloc(sizeof(int)); printf("%s: %p\n", __func__, p); func(p); printf("%s: %p\n", __func__, p); return 0; } void func(void *p) { printf("%s: %p\n", __func__, p); p = realloc(p, 1024); printf("%s: %p\n", __func__, p); } Output: main: 0x2642646e2f0 func: 0x2642646e2f0 func: 0x2649ed6d800 main: 0x2642646e2f0 I think you don't understand how pointers act if you give their address to a pointer in a function. Same thing that realloc is allowed to give a new address or stay at it's current location.
The original isn't being maintained anymore since 2013, but an actively maintained [fork](https://github.com/BoomerangDecompiler/boomerang) exists.
To quote Cleveland Brown, "you don't win; you just do a little better each time." This field is literally changing every second humans interact with computers. If you just feel like you're scratching the surface, it's because you kind of... _are_, but at the same time, project suggestions from strangers online and in class can only get you so far, and when it comes to low level stuff, developers with loads of documentation can be hard to come by. Since you mentioned interest in hardware from a highly parallel computation standpoint, I'd say to look into CUDA programming and writing GPU code (NVIDIA has loads of documentation and reference code available for free, you just have to look for it). It is basically C, but with added functionality specific to interacting with the graphics card. If you don't have an NVIDIA GPU, I'd recommend getting one because CUDA programming is as low level as C, but if that's out of the question, you can always use OpenCL to interact with your AMD card. Also, it's such an awesome feeling when you write your GPU code to process like a billion operations, and it gets done in less than half a second, when the same serialized code on the CPU takes about 40 seconds. Honestly, at this point, solid, definitive information on projects and stuff can be hard to come by. You'll have to start reading research papers and textbooks (Programming Massively Parallel Processors by Kirk and Hwu springs to mind) and attending high performance computing conferences and reaching out to researchers and professionals to see what they're doing. If you really like the OS development stuff, the OS Dev wiki is a good place, but it is _not_ a tutorial site.
I guess he expressed himself wrong, the point is if there are different approach that are more procedural based rather than oop and similar. After all most modern architecture are around those concept, and is very hard to find alternative implementations.
Thanks for the follow-up. I posted the old link mainly because it has examples of the output.
Have you tried IDA?
"There are a lot of concessions and concepts that have to be accounted for when lacking generics and OOP" is specifically what I'm calling a load of crap.
Does it work on windows?
Nope. Its a paid software.
Ida is a paid software.
Understood first example you gave but second example went over head.
What has this to do in my program?
It's leaps and bounds ahead of every free tool. There is a reason people are willing to pay the price.
Did you fully read the comment that directed you here? &gt; And make sure to include your existing code, with proper formatting of course.
Your realloc could change the pointer in addbook() and your pointer in main() won't notice that because your function doesn't return the address Try to understand realloc and my second example, I don't know how to explain it any further
Here' an option that doesn't exist yet, but which might be possible in the near future: using [the V programming language](https://vlang.io/). According to the website, it includes a converter to convert C and C++ code to V, which is something that is going to be a much simpler language. And V can, in turn, be compiled to C.
Ghidra gives you similar functionality (if not better) and it's free
Cant understand the problem you want to solve. Write example of what input and output function expect.
Example: How many numbers you want in the array? 5 Then write the numbers: 1, 67, 83, 23, 1. Number 1. (2 times) Number 67 (1 time) Number 83(1 time) Number 23 (1 time) Is it understandable now?
Definitely not going to install something from the nsa.
It's open source...
Key is to use something like map data structure for count. And you can iterate over input array after you remove duplicates from it if it is mandatory to keep order intact. Read a bit about set and map data structures.
Can you try to explain it to me. Or better way use a code as example?
Any time anyone says anything about network programming, especially in the context of C, I immediately think of beej.
Your program doesn't calculate the number of occurrences of a number in a given array. It simply sorts the given array using bubble sort.
I know that because I really don't know how to calculate the number of occurrences of a number in a given array. I'm here for solving this. Can you help me?
according to [https://patchwork.kernel.org/patch/10158257/](https://patchwork.kernel.org/patch/10158257/) , it is deprecated IO library and you should just use &lt;stdio.h&gt; instead.
If this task doesn't have other restrictions using map structure is a bit overkill I think. You could solve it by implementing simple algorithm: &amp;#x200B; 1. For each number in array: 1. check if number occured earlier in array 1. if not, go through array and count every occurence of this number; when you come to the end write number of occurences to output 2. if yes, skip number and go to next one &amp;#x200B; Maybe it isn't the greatest algorithm but it will do the job.
You have a sorted array. If you simply want to print your result you could start from the first element, go through your array until you reach an element that does not equal the current element, incrementing a counter in the process. Then you can simply print your element and the counter and repeat this process until you reach the end.
I think i have to explain why i choose C over better (or easier) suited languages like C++. The main point of the series is not finishing a Game, not even finishing a game engine. The main point id to show up how game engines are built and what they do under the hood. I took C because It has 0 to none imposed style and no standard bullshit, It os imperative and does exactly what you wrote, without obscure functional helpers like other languages (ehem...JS) I think its simplicity makes easier to follow C code base than any other languages, Maybe im wrong, Maybe i just like C.
Thank you it works
This can be done way more efficiently, especially considering that OP has already sorted his list. Yours is O(n^3).
While some things need explanation, this is not one of them. &amp;#x200B; Pick up a book about c++ for beginners or follow a youtube tutorial. This kind of problem is something you should be able to solve yourself, as long as you know the basic language and basic algorithms. &amp;#x200B; I'll give you some help, but no code. &amp;#x200B; Sort the array, and iterate through the sorted array. Keep track of the number you are currently counting, and print the number and count whenever the next number is not the same as the last.
Isn't it O(n\^2)? The both inner loops make n comparisions in worst case scenario.
I've removed your other post so all efforts can concentrate onthis one.
Which operating system are you programming for? What does the source code look like? Generally, all symbols not declared as `static` are global. With ELF, they are automatically visible to other shared objects. Without further details (such as your source code, the exact commands you used to compile it, and the exact operating system you program for), it's not possible to answer this question.
Worst case: n different elements. For each.... O(n) Check... O(n) If not... O(n) If yes O(1)
Can you make a simple code to explain it to me cuz I'm getting mad 😳😳
But like I said the 2 inner loops are always going through full array once: &amp;#x200B; for each (i=0...n-1) for(j=0...i-1) for(j=i+1...n-1) &amp;#x200B; this is one loop split into two so it should be O(n) in total for both
Oh, right. You mean to continue the inner loop from where the outer loop stopped. Yeah then you're right.
It's also the only software that works. There are free versions available of it's older versions but iirc none of them include the Hex Rays Decompiler. Decompiling is a complicated &amp; little-understood process that is rarely studied in academia, there are few publications, so what we're left with is only the Hex Rays team, which is privately funded, studies the problem. What you're looking for, something that decompiles into C that then re-compiles into the **same** exe will never exist. Compiling is a complex process where each compiler makes it's own decisions, and those decisions are further impacted by compiling options, linking options, versions of both compiler &amp; linker, and the purposeful obfuscation developers put into their code to prevent decompilation.
This is for Illumos (https://github.com/illumos/illumos-gate) on Solaris gcc. The functions are not declared static and infact most of the non-static functions are still Local. Am unable to share the code here. Let me see if I can come up with simple C program on this platform which I can share.
Cool!
Ghidra will decompile a C executable. https://github.com/NationalSecurityAgency/ghidra
 --- a/usr/src/cmd/listen/listen.c Fri May 31 16:39:13 2019 -0700 +++ b/usr/src/cmd/listen/listen.c Thu Jun 06 16:49:54 2019 +0000 @@ -1981,7 +1981,13 @@ dbf_t *dbp; { DEBUG((9, "in rpc_unregister")); if (dbp-&gt;dbf_prognum == -1 || dbp-&gt;dbf_version == -1) /* not an rpc service */ return; (void) rpcb_unset(dbp-&gt;dbf_prognum, dbp-&gt;dbf_version, Netconf); } + +void +talk (void) +{ + fprintf (stderr, "talk"); +} The example change is in https://github.com/illumos/illumos-gate/blob/master/usr/src/cmd/listen/listen.c. Output of nm is: nm listen | grep talk [41] | 134556646| 26|FUNC |LOCL |2 |15 |talk
I bet a map file is used to decide symbol visibility for this one. What command is used to link it?
While C may have been created as a language that will always do what you tell it do, "modern" C compilers will try to omit operations that would only be relevant in cases where the Standard imposes requirements. In the language invented by Dennis Ritchie, the syntax `a[b]` means "take an address, add `b` times the size of the pointer's target type, and access the resulting storage as an object of that type". Although the Standard never requires that implementations behave in any other manner, it allows them to behave in arbitrary fashion unless various sometimes-ambiguous restrictions are met.
Thank you very much. Disabling this option - `LDFLAGS += $(MAPFILE.NGB:%=-M%)` made the function `talk` global. What does this do? Is it possible to make this on per file or per function basis without exporting every function to global namespace. Thanks once again; now I might be able to search more on this.
A map file configures the visibility of symbols when creating shared objects. It supports shell globs if I recall correctly, so for a well designed API you can just include the entire namespace of that API. I think you can only have one of these, but nothing stops you from writing a little script to assembly a single map file from multiple snippets. Generally though, just enter the new function into the project's map file and you are good to go. Don't just disable the map file as that makes all symbols visible which is often a bad idea.
Try downloading the OpenCV library.
Yes I installed it and it works but I can't find the cv_mat
How did you install the library? What operating system are you programming for? What is your compiler invocation?
I downloaded the exe file. Im working on Windows 10, Visual Studio 2016. I added the openCv include directory to my project
Yeah, that won't work. You need to link in both the dll and the lib file for the openCV library and then you need to tell the compiler to look for include files in the include directory. Have you checked that a file named `cv_mat.h` is actually in there?
This target is listed first in `TARGETS`: ``` ABCML = abcml.$(O) io.$(O) getcic.$(O) zeroin.$(O) misc.$(O) likelihood.$(O) \ prlike.$(O) chol.$(O) amoeba.$(O) symeig.$(O) unirand.$(O) header.$(O) \ ninfomat.$(O) abcml$(E) : $(ABCML) $(CC) $(CFLAGS) -o $@ $(ABCML) -lm ``` So, it depends, for example, on `abcml.o` and `io.o`. Are these files already present? Cuz they must be already present for this target to build. Did you mean `abcml.c`, `io.c` and so on?
But do I need to compile something? Yes there is no file
I am not the author of this makefile, so I am not sure. However, I tried your changes and it gave a different error stating that it was not the target. I am not sure why it is not working on Windows but will work on WSL.
Apparently the latest release of VS2019 comes with Clang as an optional install, might be worth a try. https://devblogs.microsoft.com/cppblog/clang-llvm-support-in-visual-studio/
Are these `.o` file's present in the directory you run `make` from? What if you _remove_ the `.o` files from this directory _on WSL_ and run `make`? I'm sure you'll get the same error because the rules require that all of these `.o` files be present. I think your rules should look like this: ``` all: executable1 executable2 executable1: source1.c source2.c gcc source1.c source2.c -o executable1 # there are shortcuts to refer to the rule's dependencies and its resulting file, you can look them up in your Makefile ``` So, each executable should be constructed from sources. Or, you could build `.o` file's from sources like: ``` %.o: %.c gcc $&lt; -o $^ # I don't remember the actual shortcuts at the moment, please look them up somewhere ``` So, you generate all the `.o` files and then construct executables from them, in the same vein as in the first example, but replacing `.c` with `.o`.
If there is no `cv_mat.h` file, then it seems like I was wrong and OpenCV is indeed not the correct library. Let me see what library it actually is.
Sorry I am not very well versed in this topic, but I believe the .o files are not present for both. I believe they are the same directory, except when on bash it's something like /mnt/c/ , but the .o files are generated by running `make` from my knowledge. I will attempt your changes though and see how it goes.
You could also try running `make depend` and then `make`
https://opencv.org/releases/ I downloaded the version 3.4.6 from this link for Windows
running `make depend` gave the error: echo "#Automatically generated dependency info" &gt; depend gcc -M *.c &gt;&gt; depend 'gcc' Not an internal or external command, nor a runnable program Or batch file make: *** [Makefile:97: depend] Error 1
Okay, so you won't be able to compile anything until you find out how to run a compiler, and whether you have one to begin with. Try `gcc.exe` (if you have MinGW, for example). Or `cl.exe` or however you normally invoke the compiler.
In the latest Windows release build (4.1.0), there is no cv_mat.h file. The Mat class is defined in build/include/opencv2/core/mat.hpp. The easiest thing to do is include the opencv2/opencv.hpp header and that will pull in everything you need. Stick it in the pch.h file, if you're using precompiled headers.