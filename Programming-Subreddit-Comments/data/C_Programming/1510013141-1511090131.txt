Where would I call the deleteNode and deleteList functions? Thank you for your feedback.
If you wanted to get advanced you could store a linked list of unused nodes, and take from there and return to there, then only free them to the OS when the List itself is no longer needed. In an embedded environment you may actually want to use an array as a backing store with no ability to grow beyond a fixed size. This has obvious pros and cons.. 
I would stick `deleteList` at the end of your `main`, since that's when you're done with the list (after deleting it, it won't be around to use anymore). Then, inside `deleteList`, iterate through all the nodes in the list and call `deleteNode` on them, before finally calling `free` on the list itself. For what it's worth, you might want to make `deleteNode` take a `Node *` as argument, rather than a string, to avoid having to look up a node more than you need to.
A style criticism is pointless, its purely subjective. I find the style you suggest quite hard to read, its just what you are used to and doesn't make the code good or bad.
With all due respect, some of that sent shivers down my spine. Are there other style convention we could check out?
&gt; valgrind is a great tool to use when testing. It lets you know about memory usage and any leaks Valgrind is pretty good to know how to use, GCC and Clang have sanitizers with nice colorful stack traces as well that can help debug memory issues. 
How come you are using `char data[50]` in your node struct? I would use a `void *` and have the consumer be responsible for allocating memory for their data. That way you aren't setting limits on the type (the casting will be nastier than with a `void *`) and size of data that can be stored. If you go this route you'll have to have the consumer also provide a comparison function that is passed in as an argument to your `contains()` function - I personally like the simplicity of the interface used by `strcmp()`. On line 22 you have `node-&gt;prev = node-&gt;next = NULL;` which is syntactically correct but I get very picky about multiple statements on a single line. It makes it very easy to graze past stuff when you've been reading code all day. On line 26 you have `dll-&gt;head == NULL &amp;&amp; dll-&gt;tail == NULL` which is syntactically correct. This is not a big deal but I wanted to point out that `! dll-&gt;head &amp;&amp; ! dll-&gt;tail` is a more typical form. Just be aware of that in your travels as you learn C. On line 101 you have `Node **current = &amp;dll-&gt;head;`. `Node **current` is a pointer to a pointer to a Node. If you drop the address-of operator on the right-hand side you don't need the additional indirection: `Node *current = dll-&gt;head;`. In fact the whole `deleteNode` function is using an additional layer of indirection. `deleteNode` is missing some edge cases such as deleting the head, tail, and/or last node in the list. You should place all your function prototypes and typedefs into a file `dll.h` then create a separate file, `dll.c` which includes `dll.h` and also includes definitions for your structs as well as implements the functions for operating on your structs. Then your `main()` can appear in a separate file that just includes `dll.h` and is linked against the `dll.o` produced from `dll.c`. This does two things - it makes your code into a reusable library and it gives you some encapsulation which without the OOP baggage isn't such a bad thing especially if you are writing a library. 
Depending on the language you are working with "pointer" can have frustratingly subtle differences. In C a pointer is simply a memory address. If the memory address a pointer holds is NULL then it points to nothing, otherwise the expectation is that there is a value stored at the memory address (just make sure to validate this exception). In C this memory address is simply stored as an integer value so you can use arithmetic operators on pointers to manipulate the address they refer to. `*` is the dereference operator (i.e. get me the value stored at the address this pointer refers to) and `&amp;` is the address-of operator (i.e. get me the address of this object).
&gt; `array[i/5][i%5]` That is terrifying.
so what is the "&amp;" thingy for? e.g: v = 152; int *ptr1 = &amp;v;
A pointer holds the address of a memory location. You can have pointers to primitive types or to custom types. In C pointers are the only way to do anything dynamic, like polymorphism or inheritance, but also simpler things like allocating dynamically the memory needed based on user or environmental input. 
`&amp;`, the ampersand, means "address-of" So I could say something like `pointer = &amp;primitive`. Depending on your style of writing, `&amp;` isn't actually used all that often especially if you work with a lot of dynamic memory. Think of `&amp;` as getting a pointer to something that is not already a pointer. For example, if you have a function that takes a pointer as an argument: int foo(int *i) { return *i; } Well if I want to pass '5' as an argument to `foo()` I need to have a pointer to '5'. Rather than getting a pointer to '5' the long way I can just do: `int val = foo(&amp;5);`
You use the address of operator for things allocated on the stack that you need to pass by pointer to a function that will manipulate them.
Bad style guide is Good, glib too.
It‚Äôs certainly not the be-all and end-all, and what constitutes good style is a matter of personal preference; that being said, we are talking about the style used in the arguably most successful open source project in the world. What problems specifically do you have with it? 
You can check against my implementation I wrote a minute ago as an example to see where things differ. https://gist.github.com/anonymous/99f8172611532d65dd100c9606ba4fe8
Nice start. I think a more conventional implementation puts the next (and prev for a double linked list) at the top of the node structure. This makes more sense when looking at memory while debugging/looking at cores. e.g. struct node { struct node *next; struct node *prev; char *data; }; 
Think of a pointer like a street address or locker number. It's information about where something is, but nothing more. When thinking of &amp;, address of, I think that makes a lot of sense. You have an address, the pointer, which simply says "there's something g at this location. When you go to that address, dereference the pointer, you get to see what's there, the data. int a = 10; int *b = &amp;a; a is the house/shop/whatever, b is the street address (address of a). int c = *b; The * in here is the dereference operator, it takes you to the given address. The address b takes you to a. 
Read this article: https://en.wikipedia.org/wiki/Indentation_style Pick one you like and stick with it, or follow your team's style guide. Tabs are not standard. Neither are spaces.
**Indentation style** In computer programming, an indentation style is a convention governing the indentation of blocks of code to convey program structure. This article largely addresses the free-form languages, such as C and its descendants, but can be (and often is) applied to most other programming languages (especially those in the curly bracket family), where whitespace is otherwise insignificant. Indentation style is only one aspect of programming style. Indenting is not a requirement of most programming languages, where it is used as secondary notation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
The `&amp;` operator gives you the *address of* an object. For example, if `x` is some variable, `&amp;x` is the address of `x`, i.e. a pointer that points to `x`. You can take the address of everything you can assign to.
Hehe I know the basics: "Arrays". I have got news for you, that sir is a pointer :) 
Oh, I see, thank you!
Thanks!
A bit hard to grasp at first, I must admit. An array is a pointer to the start of an array and in order to move through the array you have to manually jump through the memory addresses using the initial array address pointer to your array as a start point. The most interesting bit for a noobie would be the fact that arrays (by default) don't indicate where they end, and you can end up accidentally accessing unintended memory space. OPs in for a fun time ;)
Why store your data on HDD? you should opt for more volatile storage such as raw memory, encrypting it on the fly and shuffling it around in real time. You should aware that using char (1 byte) as storage can cause problems with countries where their language uses different standards. 
Yea, learning C is one of the most fun and rewarding things I have done. Sucks that nearly all development jobs are C#, Python or Java. Sometimes there are C++ jobs here though, but it is just not the same
Matrix multiplication is pretty easy to implement (I think). Raising a matrix to a power than should not be too hard. However, this may not be the most efficient way of computing. It's possible there is something more efficient out there. I suppose you could try the log N method for normal powers, but I don't know if that's valid for matrix multiplication.
I originally thought the same but now I love C++. A lot of things are just easier with C++, like IO for example and Vectors which are arrays that "know" their size thereby preventing segfaults. You get all that and can use both C &amp; C++ libraries. C++ adds to C, hence the name C + 1
Clang's one might not work in as many cases, but it has a low performance impact. Valgrind is maybe a factor of 5 slowdown. 
I will make it simple, just think about "value" as money in your wallet and "reference value" as deposit in your bank account; you can't spend your deposit directly, you need credit card for pay any payment instead and that "credit card" is "pointer". int deposit = 500; int* creditcard = &amp;deposit; *creditcard -= 100; // now deposit is 400. int otherdeposit = 800; creditcard = &amp;otherdeposit; // now your credit card is link to other deposit. *creditcard -= 200; // now other deposit is 600 while deposit still 400 as before. int wallet = deposit; //wallet is 400. wallet -= 300; // wallet is 100 but deposit still 400, this is difference between use pointer and not. int* newcard = creditcard; //make new card link to same the bank account as credit card. *newcard -= 100; // other deposit is 500. ps. I know that deposit and other deposit in example isn't reference value but if I use malloc it will be more confuse.
 typedef union { char ch; double d; long long ll; void *ptr; } max_align_t; 
&gt; In C a pointer is simply a memory address stored as an integer. You can't make any assumptions about the representation of a pointer. There are architectures where a pointer is larger than any non-composite integer type, like 32-bit architectures with 36-bit pointers (Pentium Pro) or even [64-bit architectures with 256-bit pointers](https://llvm.org/devmtg/2015-02/slides/chisnall-pointers-not-int.pdf).
While most C implementations use a stack, the language itself does not have that concept, and automatic variables (which is the proper term for what you call ‚Äúthings allocated on the stack‚Äù) are not the only ones you can take the address of. You can also take the address of a static variable, or of an element or member of an array, struct or union regardless of how it was defined or allocated.
Arrays are not pointers. They devolve to pointers in certain situations.
W. Richard Steven's Advanced Programming In The Unix Environment is a great reference. 
There is no need for `temp` in `insertAtHead()`: node-&gt;next = dll-&gt;head; dll-&gt;head = node; There is no need to set `node-&gt;prev` to `NULL` either since `createNode()` has already done so. As a matter of style, you shouldn't use pointers as predicates, but explicitly compare them to NULL. It is also frowned upon to have multiple exit points from a function except for error conditions, so instead of if (one_of_two_cases) { do_something(); return; } do_the_other_thing(); use if (one_of_two_cases) { do_something(); } else { do_the_other_thing(); } 
A small static webserver perhaps? Can always be extended. 
I like GraphicsMagick, but I've only ever used its standalone programs, not its C API.
Do you want image load, low-level access (like your set_pixel example), and save? Or do you want a library of filters and effects? If the former, you might look at SDL2. It does much more than images and pixels, but it does those well and leaves you with a framework to visualize them, build an app around them, etc.
I write JavaScript and Python more than anything and I use spaces because most JS and Python code use spaces. But if tabs are more *common* in C, albeit not standard, I don't have a problem using them. 
Beginning Linux Programming - http://www.wrox.com/WileyCDA/WroxTitle/Beginning-Linux-Programming-4th-Edition.productCd-0470147628.html It's quite old so some parts are likely very outdated/
CImg is my go-to program for quick and dirty image work. 
C Programming: A Modern Approach - K. N. King. Its a book aiming both Unix and Gnu / Linux 
&gt; How come you are using char data[50] in your node struct? ¬Ø\_(„ÉÑ)_/¬Ø I wanted this to be a linked list of strings. Didn't consider other types. &gt; deleteNode is missing some edge cases such as deleting the head, tail, and/or last node in the list. I assure you that it works. I will make the changes your suggested, thank you for your feedback.
I think you are misreading what I wrote. I didn't say `int` (which has specific storage size connotations), I said integer - as in a counting number.
Not totally answering the question, but BMP files are simple enough that you should be able to manipulate them yourself! Look over the spec on [wikipedia ](https://en.wikipedia.org/wiki/BMP_file_format)
**BMP file format** The BMP file format, also known as bitmap image file or device independent bitmap (DIB) file format or simply a bitmap, is a raster graphics image file format used to store bitmap digital images, independently of the display device (such as a graphics adapter), especially on Microsoft Windows and OS/2 operating systems. The BMP file format is capable of storing two-dimensional digital images both monochrome and color, in various color depths, and optionally with data compression, alpha channels, and color profiles. The Windows Metafile (WMF) specification covers the BMP file format. Among others wingdi.h defines BMP constants and structures. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
PRAISE CLANG
I understood that perfectly, and you're wrong. CHERI pointers are closer to structs than to integers. Granted, CHERI is a research project, but there are plenty of real-world examples of platforms where the binary representation of a pointer conveys more information than just the physical location of the object it points to.
Send patches to http://gerrit.openafs.org :)
Kudos pal. Instead of turning this into a dick measuring contest why don't you explain all that in a post to OP who is struggling to grasp basic pointer concepts, even though they are most certainly not using some exotic fringe hardware.
You could easily have answered OP's question without giving them incorrect information. But you chose not to, and then you chose to get offended when I pointed out that your answer was incorrect, and to dismiss widely-used hardware (including some that you probably carry in your pocket every day) that don't fit your incorrect mental model as ‚Äúexotic fringe hardware‚Äù. I have no interest in measuring dicks, but you're clearly trying to compensate for something.
But, `a` and `b` are the pointers. Your code does swap the pointers, not the values. Do you want to swap `m[0]` and `m[1]` instead?
You never alter hrlyRate, so if it is &gt;= 1 from the beginning, it'll stay that way. I would swap the while loop for an if.
Please put four spaces before each line of code in order to make it readable. Also, this is C++ code but you've posted in a C programming subreddit. 
You never alter hrlyRate, so if it is &gt;= 1 from the beginning, it'll stay that way. I'd swap the while for an if.
I think you little confuse between pointer and address, your code is exchange between destination of 2 pointer but if you want to swap m[0] and m[1] then just do it as you do with other value. *a = b; *b = tmp;
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
Check out the BLAS and LINPACK libraries.
Check out the BLAS and LINPACK libraries.
Maybe http://www.buildyourownlisp.com/
This is just one part of it, but you could read [*What a C programmer should know about memory*](http://marek.vavrusa.com/c/memory/2015/02/20/memory/) and learn how these virtual memory concepts map into the POSIX API. Another important topic is file descriptors (open(), read(), select(), poll(), sockets, etc.), then learning how C buffered IO (fopen(), fread(), etc.) sits on top. Learn how to read and navigate your system's man pages that document these APIs.
Read *Elements of Programming Style* by Kernighan and Plauger. Also, try to read well-written programs and write your code in a similar style.
The [Netpbm formats](https://en.wikipedia.org/wiki/Netpbm_format) are supported by most image tools, and it's so simple that [you don't need a library](http://nullprogram.com/blog/2017/11/03/) to manipulate them.
Yes, I need to swap the pointers at m[0] and m[1]. I am now using pointers of pointers and swapping those
Well then, why don't you just write tmp = m[0]; m[0] = m[1]; m[1] = tmp;
I can't use m directly. I have to swap using references to m
What other restrictions exist? Why didn't you mention this restriction in the first place? Why do you have this restriction? Is your C compiler defective?
I mentioned it but I didn't describe it well. The swap I'm showing here is an example of a concept but not the real code. I am implementing a heap of pointers and am iterating along the heap and comparing values so I won't know the index of the pointers until the dereferenced pointers are compared.
Whenever I run this code in cmd, the numbers will be vertically written instead of horizontally. Please advice. Is something wrong?
This is not C.
Suppose you have two pointers `a` and `b` pointing to the things you want to swap. Then it's similarly just tmp = *a; *a = *b; *b = tmp; If you could show a situation were neither of these approaches work, then I might be able to give better help.
This subreddit is about programming in C, not C#. Please post C# questions elsewhere.
1. wrong sub, this is /r/c_programming, you're writing Java. 2. If you're going to paste code, consider using a paste site, like pastebin.com. 3. you're using Console.WriteLine, which I can't find the documentation for at the moment, but clearly adds a newline each time you write something to it. See if you can find a Console.Write or something similar.
Write instead of writeline. And this is c# not c. 
There are no definitive books on Linux Kernel programming. That's the crappy part of the environment.. things change so much that a book written in July is outdated a few weeks later. Best advice is to pick a subsystem you like and crush it. Follow the dev sites and look at the patches. Honestly the kernel itself isn't that exciting... linux is worthless without apps.
&gt; a linked list of strings Well, right now it's a "linked list of strings of less than 50 characters" which is kind of a weird type.
Github? 
[C Interfaces and Implementations](http://amzn.com/0201498413) has some decent advice for designing C programs. This is also a skill which you 'll develop with time (e.g. over your entire career) so don't worry too much about figuring it out immediately; it requires experience. As you work on various projects you'll get a sense for what works and what doesn't so that over time you'll have developed strategies for solving particular types of problems. OOP concepts are still valid even though C may not have ways to necessarily implement them within the language proper. [Object-Oriented Software Construction](http://amzn.com/0136291554) is a fantastic book for learning OOP concepts. As your C experience grows, you'll begin to see ways of implementing some of those design strategies with C, even though it's not an OO language. Knowing when to use what type of data structure can also aid in simplifying your code base. The standard book for this is [CLRS](http://amzn.com/0262033844), but for C specific implementations and advice, see [Algorithms in C](http://amzn.com/0201756080).
üëç
&gt; the log N method for normal powers You mean [binary exponentiation/exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)? Yes that's valid for matrices.
**Exponentiation by squaring** In mathematics and computer programming, exponentiating by squaring is a general method for fast computation of large positive integer powers of a number, or more generally of an element of a semigroup, like a polynomial or a square matrix. Some variants are commonly referred to as square-and-multiply algorithms or binary exponentiation. These can be of quite general use, for example in modular arithmetic or powering of matrices. For semigroups for which additive notation is commonly used, like elliptic curves used in cryptography, this method is also referred to as double-and-add. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
i ask one question... and I get a whole universe of answers... THANK YOU REDDITORS!!!
Wrong subreddit. As for project ideas, maybe a chat or something with a client and a server.
Sorry I'll delete and look for another
Was about to suggest this exact book and suggest reading code. If you search "OOP in C" you will find a lot of resources. This is not the most beautiful document, but it describes the idea well and without extra libraries or macros: https://www.state-machine.com/doc/AN_OOP_in_C.pdf
Ye indeed that's what I meant. It indeed makes sense that it works
"Good judgement comes from experience, and a lotta that comes from bad judgement."
As always, there's always more flags to learn.
You can defitinally do OOP in C, I do it. The only real difference is that it's not all in one class, but one file.
As others have said you will likely get better over time, especially with the attitude that you're showing now. A big help is looking at, and maybe doing some maintenance on, existing quality code. Another help is some self discipline, asking yourself questions: "How hard will this block of code be to modify 3 months from now? How hard will it be to read? How likely is it that this bit of logic will change? What would be the impact of this logic changing but not others?" are some basic ones that drive how I write code. I like to keep things modularized, which generally means separate functions or even separate source files. Sometimes (rarely, but still occasionally) "modularized" means a white space separated block of code inside another. Don't forget that an important part of software design is testability and maintainability. If you suspect that a function is misbehaving, can you use a unit test framework -- or just copy/paste the code if you don't have a unit test framework -- to easily test that function? In other words, how well behaved is the function, and how well defined are the inputs and results? I wouldn't sweat doing true OOP in C just yet unless it's completely needed. It's doable, but it can be complicated. I like to apply some of the *ideas* of OOP, like a clear separation of interface and implementation, in my plain C. You can get by with occasional function pointers to get similar to OO "methods" -- think of the callback functions in GUIs. But really, the biggest thing is to think back on what you've done and ask yourself how it could've been done better and why. Then, try to apply that idea appropriately on your next task (which may be maintaining that same code). 
OOP, smoke an mirrors, if you have a bunch of functions taking a structure as their first parameter, are they really all that different to methods....? extending a "class" the base struct can be a parameter of your extended stuct... and so on...
You could allocate the memory in `get_config_file` and cache the pointer somewhere it can access (since it takes no parameters, I guess it uses some globals, so you probably put it as a global). If you somehow detect you need to return an different value, you could then `realloc` and put the string and return the new value. You might also need some sort of destructor that you'd call before exiting (or not being required anymore) that basically does the `free` on it. TL;DR: Cache the string inside `get_config_file` in some variable
The string has to live somewhere. Your options are the heap, stack, or global/static. The heap is what you're doing now -- it's very flexible since you can just get the data when you want, you can have as many as you want, and you can hold data of any size as long as you have the memory for it. The downside is you have to free this memory when you're done, as you've noted. The stack is commonly used as well: char config_path[MAX_PATH]; get_config_file(config_path); The memory is automatically released at the end of the scope. The problem is that you might not know how big to make the buffer. Too short and `get_config_file` will go off the end. So it's a good idea to pass the buffer's size in as well. And you need some way to know if it wasn't big enough. And what do you do if it's not big enough? A variation on this is to use a variable-length array (VLA). This lets you declare an array on the stack, but with a size determined at runtime. You could then do something like: char config_path(config_file_path_size()); get_config_file(config_path); That first function call is a bit annoying, since you need a separate function to get the size of the thing itself. The required length can't change between the calls. And VLAs have other important caveats (like making sure you don't exceed your stack space). And using the stack has one important drawback: you can't return the string up another level, since it will be removed at the end of the scope. And just for completeness I'll mention static memory (like globals). You could also store the config path in a global variable, especially if it's something that's determined once when your program initializes and then never changes. I've seen this made `static` to the function as well. But there's a ton of drawbacks to this, like function reentrancy, ensuring it's the right size, and more. It's not a path I would normally go down. One last option is to use a compiler extension. I don't generally suggest extensions, as it ties your code directly to a single compiler. Even if you only use one compiler right now, it's not uncommon to change compilers later (when you change OS or something like that), and then porting the code becomes a nightmare. But there is one extension that can help a lot here: GCC's `__cleanup__` attribute. This lets you tell the compiler to automatically call `free` when the variable goes out of scope (basically a simplified RAII paradigm like C++, like `std::unique_ptr`).
just a note of caution ! be sure to read the api docs properly... the returned pointer might not need freeing (you might get a string the library needs to keep) in might point to an area of memory that's a temporary scratch pad (doesn't need freeing but will probably see be over written) lots of different methods...
Thank you. I am in charge of all parts of the API so far, so no worries. :D
Rewrite `get_config_file()` so that it stores the result in a location that you specify: char config_path[1024]; get_config_file(config_path, sizeof config_path); load_from_config_file(&amp;config, config_path); Don't worry about wasting memory on `config_path`. A good compiler (gcc, clang, msvc) will see that it isn't used anywhere else and reuse the space it occupies. By the way, I assume that in your real code, both `get_config_file()` and `load_from_config()` return some sort of success / failure indicator and that you check it before proceeding...
You can't always assume that there will be memory available to allocate. You should check if malloc returns a non NULL pointer. If it doesn't then report an error
Thank you for the complete answer, everything is very informative. :) 
&gt; By the way, I assume that in your real code, both get_config_file() and load_from_config() return some sort of success / failure indicator and that you check it before proceeding... Yest, thank you, I was simplifying the example. 
Impressive. good luck!
&gt; one of the problems I face when designing the program is making the right decisions. That's the *only* problem. ;-) You'll never be rid of that one! :-) [Beej's Guide to C Programming](http://beej.us/guide/bgc/) is something many people enjoy on their C path. Another good book IMO is [21st Century C]( http://shop.oreilly.com/product/0636920025108.do) for a deep dive into C features by a clear-thinking programmer. And this article/book on the [Resurgence of C Programming](https://www.oreilly.com/learning/the-resurgence-of-c-programming) is interesting. Some references to embedded, etc. Good luck. 
The [Unix Programming Environment](https://cs.uwec.edu/~buipj/teaching/cs.388.s14/static/pdf/upe.pdf) is a great (but old) introduction to the basics. Just realize that it is dated in many aspects, but still relevant in more important, underlying ways. 
One realization that I had and that helped me out was realizing that there is a difference between nice looking code and readable code. Nice looking code is not always readable and vice versa. You should prioritize readable code over nice looking code.
Thank you! I have a very good feeling that the thesis is going to be successful.
Im pretty new to C and had kind of an ah ha moment when I realized this the other day.
This question is too generic to be answerable. What are you specifically trying to build? What do you want to do with the 'pixels'? Image loading is separate from displaying is separate from reading/writing/manipulating values in memory is separate from what those values in memory represent. Some frameworks, like SDL, provide plenty of functionality for all of those things, but may not be perfect without knowing what you're trying to do.
&gt;OOP which C not has. Don't confuse built in OOP support with actual OOP design.. I've seen people use java classes and write horrendously wrong and "spaghetti-like" OOP stuff, and I've seen people work OOP design in C. You can do OOP design in C, just search around a bit.
`stdout` is usually line buffered. You may need to print a `'\n'` or call `fflush(stdout)` before your message is displayed.
The documentation is a little thin. What is the input format? What does the output look like? Heck, what does the program even do?
The programs solve 24 puzzles which are like 15 puzzles but played on a 5√ó5 tray. The solved configuration looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Puzzle configurations are specified separated with commas: 24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 The solution is given as a comma separated list of squares to move the empty square to. To run the solver, type pdbsearch -j jobs catalogue.cat where `jobs` is the number of threads to use for PDB generation and `catalogue.cat` is the PDB catalogue to use. Some PDB catalogues are provided in the `catalogues` directory, I recommend the catalogue `small-compound.cat`. The software then generates a bunch of pattern databases (which are used for finding solutions). Once it's done, you can type a configuration to solve. The program always finds the shortest possible solution, this may take a while. You can find some sample instances in `doc/korf.txt`.
I was looking for a site I remembered that had a kernel programming tutorial and found this book: [The Linux Kernel Primer](https://www.amazon.com/Linux-Kernel-Primer-Top-Down-Architectures/dp/0131181637) that looks interesting.
Don't be afraid to rewrite. Get something working, then look at what it does vs. what it needs to do, how it's organized vs how you think about the problem. Sometimes I can rewrite 200 lines of code four times. If your rewrite is making the code significantly bigger, though, you're probably on the wrong track. In my rewriting (aka refactoring), applying the DRY Principle is probably what I do most, followed by grouping like things together, then adjusting them to be more similar. Naming is also very important. Getting just the right name, accurate, descriptive, concise, and unique, is really hard. And always call the same thing by the same name. Most of the time, a function doesn't need to be bigger than 20 lines or so. The exception is functions with big switch statements -- they can go on for hundreds of lines, but each switch case should be small. In any case, the goal is to make a function do exactly one thing at exactly one level of abstraction. Finally, there is no substitute for practice, practice, practice. Source: have been writing C since 1982, *almost* have the hang of it now. :-)
&gt; doc/korf.txt. This file does not exist
There are a few things.. Smoking, swearing a lot, marinating yourself in coffee and using this mantra "I am not a smart person. Whatever inflated ego has made me believe this should go away". 
I think my downfall was one part hubris and one part not working on my coding in my off time. I just couldn't think of any projects and my job at the time was majorly stressful (disability services... why a logical person gets into human services is beyond me but it is a long story)
Is this related to https://en.wikipedia.org/wiki/24_Game ? Sorry haven't heard of 24 puzzles
We won't always be motivated, that's why we have to be disciplined to keep working regardless of emotion. 
I despise emotion... so illogical, but I guess useful in my current line of work. I have to pull myself together, and I think that succeeding where I previously failed will help that.
Anything worth doing is going to be difficult. You just have to grind it out. I dealt with the same thing. K-12 was a joke. Then college comes out and slapped you in the face. I thought academic failure was beneath me. I realized that I had been in little league. I wasn't going to get everything instantly. I had to stay humble, study, and grind. I still don't know everything. That's okay. I get to learn every day. From James Brown: https://www.youtube.com/watch?v=jC2ZY2loo74 Put in the work. You got it.
Video linked by /u/if_then_end_if: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [James Brown - The Boss](https://youtube.com/watch?v=jC2ZY2loo74)|Alf|2011-06-05|0:03:15|34,044+ (97%)|6,096,459 $quote James Brown - The Boss From Album - Black Caeser --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/if_then_end_if ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
One thing that I have learned with all of the reflection is that the quality of education is not necessarily the most important thing in college... I managed to be in the top 1% with a little more than average effort... and when I got into data structures and had to perform... WHAM. I realized my skill wasn't a tenth of what I thought it was.
lmaoooooooooooo
This is /r/C_Programming. /r/psychology is a next door.
fpga's first real good session with them failed, barely made a VGA pattern generator work.... found it way too obtuse, then left it for a while, ended up with a fairly nice home made video card for a z80 system, and you know what it wasn't that hard after all... sometimes you just need a change of perspective 
&gt; how do you as professional programmers deal with running into problems that seem to elude you? More or less in order: 1. Do more research; find existing approaches to this or similar problems. 2. Consult colleagues or friends 3. Transform the problem into a solvable one 4. Tell the customer I can't solve the problem. There is a distinction between professional failure (a project doesn't work out) and person failure (I don't get something I wanted). It can be helpful to distinguish between these, especially because not every project I work on professionally is successful and if I got bent out of shape every time that happens, I'd be a grumpier person. As for failing at learning tasks, I;ve done that too. I tried learning Haskell a while ago and found that I wasn't able to deduce the implementation from a function's type very effectively. Not having a ton of time to put into practicing this skill, or a stockpile of graduated examples to learn from, I've not gone back to it in a while. But this week I'm learning Rust instead. As for data structures, my learning has been completely self-driven, I never took a DS course. I started out not knowing about many. I guess linked lists and arrays I knew about early, binary trees and heaps came later. I read TAOCP, learning a lot from that. But even after, oh, 10 years there were still data structures I'd never heard of. A colleague mentioned they were using a Bloom filter and I'd never heard of it. Later, the same thing with the UNION-FIND method. Even now after about 20 years of professional programming, there are still data structures I don't understand, for example the y-fast trie. For me the key thing is that I'm a lifetime learner; I accept that there are things I don't understand and I prioritise learning things that are relevant to the things I want to achieve. But it helps that there is rarely a built-in time limit.
Thank you for such a well thought out reply. It is good to know that others have been where I am now. I guess I have to just get back on the horse and try again. This is such a refreshing change of pace. StackOverflow... is not a kind place.
Yes but this is specifically related to C Programming. At least, that is the language I was having difficulty with. And I do not think it is necessarily a bad thing to show that every learner begins somewhere.
https://en.wikipedia.org/wiki/15_puzzle only with 24
**15 puzzle** The 15-puzzle (also called Gem Puzzle, Boss Puzzle, Game of Fifteen, Mystic Square and many others) is a sliding puzzle that consists of a frame of numbered square tiles in random order with one tile missing. The puzzle also exists in other sizes, particularly the smaller 8-puzzle. If the size is 3√ó3 tiles, the puzzle is called the 8-puzzle or 9-puzzle, and if 4√ó4 tiles, the puzzle is called the 15-puzzle or 16-puzzle named, respectively, for the number of tiles and the number of spaces. The object of the puzzle is to place the tiles in order by making sliding moves that use the empty space. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Here we go again...
The 24 puzzle is the 15 puzzle, but you use a 5√ó5 tray instead of a 4√ó4 tray.
&gt; doc/korf.txt Yes, [it exists](https://github.com/fuzxxl/24puzzle/blob/master/doc/korf.txt). And note that there is already a README. However, adding more explanation might be a good idea.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [fuzxxl/24puzzle/.../**korf.txt** (master ‚Üí b5ccb39)](https://github.com/fuzxxl/24puzzle/blob/b5ccb39297ccfbdbc0d1aed485aba36bd4fb5802/doc/korf.txt) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Please for the love of god just stop whatever you trying to do.
Please don't post these.
Please don't post these.
I'll not remove this tutorial because it is not actually shitty.
Hmm, you were probably caught off guard. A lot of non computer related majors take the intro to c in my school so that class is, shall I say, made much less difficult than the standard fair. The data structures course will most likely be programming or software engineering majors only so there would have been a higher expectation in that class. You probably were expecting both classes to be about the same pace and that through you. 
This post was removed because it is not about programming in C.
* PDF: https://pdfs.semanticscholar.org/8c2e/d20ed2644a3fd72b8b6639b155c9fe4d9188.pdf * IfdefRevolver: https://github.com/wfenske/IfdefRevolver/, https://wfenske.github.io/IfdefRevolver/ifdefs-vs-changes/
The Linux kernel has some beautifully-designed C code. :)
The Linux kernel has some beautifully-designed C code, if you need some inspiration. Try looking the Linux kernel's coding guidelines.
This appears to be C++ code but you've posted in a C programming subreddit. When you re-post this elsewhere, please put four spaces before each line of code in order to make it readable. Also, "this won't work" is not a proper problem description. You need to describe the behaviour you expect and what's happening instead. 
this isn't even C++ code, it's some other language.
I have one more question, if you don't mind. :) What about array types? If I have let's say `char arr[3]`, how should I align that? Or basically any arrays? 
Looks like botched Java, maybe.
The alignment requirements of an array type will be the same as the alignment requirements of the element type.
 void someFunc (struct Outside *outside) { outside-&gt;one.member1 = 5; } int main(void) { struct Outside out; someFn(&amp;out.one); } Assuming `someFunc` and `someFn` are meant to be the same; `someFunc` wants a pointer to an `Outside`, so it needs to be called as someFunc(&amp;out);
Ah sorry, I was going to delete and repost after fixing some stuff, didn't expect to get a reply this fast. So is it wrong to do something like this?: void someFunc (struct One *one) { one-&gt;member1 = 5; printf("member1 is %d\n", one-&gt;member1); } int main(void) { struct Outside out; someFunc(&amp;out.one); } Seems to be working. someFunc doesn't need to access `struct Two` field in `struct Outside`
Yes, that is the correct way to do it. 
Thank you
No, it's not. this is a work related psychological issue.
c# ?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
I don't mind it because then you don't have to include that logic directly in your function. It can be assessed at compile time and then adds no overhead. I really miss a pre processor when using other languages
&gt; I managed to be in the top 1% with a little more than average effort.. This is pretty typical with kids who coast through high school at the top of their class. Often they have never really had to put much effort in to getting something done. When presented with something really difficult... WHAM as you say. Hard things are hard and they take effort to complete. You need to stretch yourself a bit more so you become used to dealing with difficult problems. As for failure, a life without failure would be a pretty boring one, don't you think?
I think that's a tautology
make it work. then you learn why it sucks. then fix the things that suck
when I clicked on the link only 400-random.out und 400-random.txt were visible.
It is possible that this is a glitch in github's software. The file definitely is there and was there yesterday.
Well, you pretty much answered the question, it's a combination of all of these. You become a better programmer by keeping yourself informed, analyzing your code, reading code of others and comparing, exchanging information with fellow developers, not giving up and setting yourself higher and higher goals. Mostly, however, coding is about experience and exposure. This takes time, devotion, patience and concentration. You will certainly need to get your hands dirty and get a feeling for writing code. I would summarize it as: to become a master of C, work with C.
1. study the theory of computer science to understand algorithm and data structure design 2. read well-written programs and understand their design 3. write a lot of code 4. most importantly: give a crap about the code you write. Force yourself to document everything and to not take shortcuts. Get in the habit of writing good code and it just starts to be a natural thing to do at some point.
I don't think it's truly possible to become a master of C. C was purposefully designed to be a portable language, and as such, being a master of all things C would require you to be a master of all architectures and systems. There are too many corner/edge cases and whenever someone makes a seemingly valid claim - a bearded guy comes out of the woodwork explaining how his embedded platform doesn't work that way. That being said, the people I perceive as being best at C are those who have an understanding of and familiarity with the C standard(s). Many C programmers rewrite functions that are already provided by the standard library, or they implement complicated logic when a language construct already exists for that purpose. Having a command of both the language and the facilities it provides will get you very far. Experience will also help you, but that comes with time. I recommend starting by studying the standards as you work on C projects to gain experience. [This page](http://clc-wiki.net/wiki/The_C_Standard#Obtaining_the_Standard) details how to obtain legitimate copies of the various C standards, as well as links to free draft versions which should be just fine for your purposes.
Late, but I have a story that is relevant. I've been a professional software engineer since around 2007. Just this year I came across a bug that nearly defeated me mentally and physically. This bastard took 3-4 months to find and fix. I've always been good at CS and programming. Just last week, I had an epiphany (due to some customer logs and some other data we'd managed to gather). ONE LINE of code was all it took to fix. Throughout the process, I'd felt like a lesser engineer; rookie level and not deserving of my position. This nearly broke my will I was close to giving up many times. A lot of programming and software engineering comes down to moxie. You have to have the drive and willpower to grind through. All programmers get to a 95% point and want to quit before the make that last leap. The best ones know how to get over that hump and finish it out. When you're going through hell...just keep going. 
Please indent your code with four blanks in front of every line of code so reddit aligns it correctly. Also please tell us what you expect the code to do and what input you provided.
Please put four spaces before each line of code in order to make it readable. Reddit's formatting will mess up all your pointers. One thing I notice is that you appear to be passing an `int *n` to your `maxarray()` function, but in your loop condition you treat `n` as an integer. You may need to use `for(i=;i&lt;*n;i++)` instead. 
You could use an [eventfd](http://man7.org/linux/man-pages/man2/eventfd.2.html) as a condition variable for the queue. All the worker threads listen to it, and part of acquiring the lock to pop a connection off the queue is successfully reading from it.
Thanks, this looks like it will be very useful. And yeah, I'll probably need to do some other cleanup, not just freeing memory.
I went back and updated the original comment. For cleanup, you need some way of notifying the worker threads that it's time to gracefully shut down, and then only exit after joining them all. Another eventfd, or maybe a signalfd, are possible options.
What happens when you run your program through a debugger, or valgrind?
Move `main()` to the bottom of the program so the definition of `maxaray()` is in scope when it is called. Notice that the program no longer compiles. Fix the errors. Also, four spaces in front of each line and turn on compiler warnings.
I already have the worker threads looping over an atomic variable that gets set when the kill signal is received (maybe there is a better method for that, but hey it works). But the issue is that I store the data related to each socket in epoll‚Äôs event.data.ptr field, so I can only access it when epoll gives me an event for that FD. So when I want to clean up I have no way of accessing that data because it‚Äôs all stored by the kernel and there‚Äôs no way of looping over the file descriptors in user space.
Each worker thread should have a list of the connections it is currently managing, with a copy of any relevant data in that.
Also, both those notification ideas have the thundering herd problem. If that's an issue in practice, the accepting thread can pick a single worker from the pool to notify (in round robin order or whatever). Each worker needs a unique eventfd in that case instead of all sharing one.
I was just thinking about that idea. Even better would be a way of selecting whichever thread has the lowest number of active connections, although this might be a little tricky to do and would probably be unnecessary anyway. Something something premature optimization... Thanks for all the help, btw. Nice to talk to someone who actually knows what they‚Äôre doing.
If you're feeling ambitious enough, you can make it modular - have the worker threads always do the the same thing, but have the accepting thread use a config option to pick which notification strategy to use when it starts up - toss it out to everything and let the kernel sort it out, round robin, least-active, etc. That way you can play around and see what works best for your particular use case.
Mastering C is not the same thing as becoming a better programmer. You can know a lot about C without being an expert programmer. To learn about C, read the language standard. Then hang out where C language standard mavens hang out. When I got stuck into this, that was the Usenet newsgroup comp.std.c. The kind of stuff you will learn here is what the legitimate definitions of `errno` or `NULL` might be, how many levels of nested `#iinclude`s are actually allowed in a conforming program, what sequence points are and how they work, what an activation record and an object (in the C, not the C++ sense) are, and why you can't portably loop over all possible values of a `char` with a `while` loop, but you can do it with a `do` loop. All those things are technical things, and they relate to the C language. But I'm pretty sure that almost none of them are relevant to writing good programs that solve useful problems. To become a better programmer, read a lot of code and figure out how it works. Then decide if it's good or bad code (come back to the same code a few months later and decide if you still think the same thing). Learn the difference between clever and smart (code). Learn the difference between code being simple and simplistic. Pick a toy problem, try to solve it in several very different ways. Take some code you wrote previously, make the code simpler without changing the (essential) functionality. Learn the tools: a powerful editor or IDE, debugger, source code analysis tools (for navigating large, new, pieces of code). Learn how to build common open source software (often this might mean editing a Makefile, for example). Learn how to write documentation. I don't mean learn how to use Markdown, I mean also how to present technical information. Learn about KISS, YAGNI, the open/closed principle, cohesion and coupling. Figure out how to write and use automated tests. Figure out how to measure test coverage, how to profile a program, how to analyse a crash dump (core dump). Read around the subject. Especially find people, perhaps experts, who disagree. Compare and contrast. Read some of these books: 1. Programming Pearls (Jon Bentley) 1. More Programming Pearls (Jon Bentley) 1. The Art of Computer Programming (Donald Knuth) 1. Algorithms In C++ (Robert Sedgewick) 1. The Algorithm Design Manual (Steven Skiena) 1. The Practice of Programming (Kernighan and Pike) 1. Elements of Programming (Stepanov) 1. How to Solve It (Polya) 1. Structure and Interpretation of Computer Programs (Abelson and Sussman) 
1. Fix the code formatting so reddit doesn't mess things up. 2. Tell us what you're expecting to get and what you get instead. Don't make us guess. 3. I'm pretty sure you should be getting compile errors. Fix those first. 4. You're never calling your functions inside the loop based on the user's choice. You just ask for input, read it in, and do that over and over again. 5. `fflush(stdin)` is undefined behavior. Don't do this. Also, instead of asking the user to press a key to close the window, you need to set up your IDE to do this for you.
The answer is pretty general, not just for C programming, you can become a better programmer but you just have to spend time reading and writing code. You can trawl through theory all day, but the only way to become a better programmer is actually by doing it.
&gt; How did you all become a master in C? By working with lots of C. &gt; How did you become a better programmer? By working with lots of programs. Starting out I read lots of books, now I mostly skim because I don't have the time. I studied computer science at college, I like to believe I got more out of it by having taught myself to program before I started college. When I was working on projects I always designed first and then wrote code (incidentally, this is what most places want you to do as a professional). If ever I run into code I don't understand, I always take the time to figure it out. Something that isn't often thought about is communication. Usually as a professional you are not getting paid to write software for yourself but for other people. Many times those other people don't understand how computers work and sometimes don't even understand the problems they are trying to solve with software. So being able to communicate with these people is critical. Sometimes you come to find out that features they originally requested are not the best way to address the issues they are facing. You can't write good code if you don't understand what is needed of the code. Soft skills are part of the programmer's tool belt. 
http://en.cppreference.com/w/c/numeric/math/nextafter
&gt;&gt; deleteNode is missing some edge cases such as deleting the head, tail, and/or last node in the list. &gt; I assure you that it works. So it does. Interesting. I will have to fire up the debugger as it is not immediately obvious how `List-&gt;head` and `List-&gt;tail` are updated.
Search for Linus's double pointer problem. 
This looks like code with stub functions that you are expected to complete. For it to work, you need to add your own code to it. Give it a shot. Then let us know what you are having trouble with so we can help you.
Hard to read on mobile but you have a random return 0 at the bottom. The design of your program needs a lot of work. If your functions are just one line print statements. They don't need to be functions. You are slowing your program by a "good" amount making all these functions that do nothing. Please format your post correctly. Also, you don't have any type declarations for choice in your function parameters.
I'm a noob but it looks like OP defined all those functions within main. Also the prototypes don't match the definitions in the number of arguments.
I'm a noob but in addition to everything you just said, it looks like OP redeclared and defined all those functions within main. Also the function signatures don't match the definitions in the number of arguments.
You can have a look at the source code for the [facil.io framework](http://facil.io). The code works both as a single-threaded app and a multi-threaded app, Have a look at [the core code](https://github.com/boazsegev/facil.io/tree/01a4794b434025e27a6563579d4b13595c912568/lib/facil/core) rather than the whole thing. The `defer` code handles task queues. The `evio` acts as an `epoll`/`kqueue` abstraction layer. `facil.c` is the "glue" that runs the server as a machine. The socket layer is also abstracted in order to help manage the on-`close` event as well as add user level buffers. Good luck!
Why are you posting the [same question](https://www.reddit.com/r/C_Programming/comments/7bpmdz/having_trouble_getting_a_result_what_am_i_missing/) twice?
Why are you posting [the same question](https://www.reddit.com/r/C_Programming/comments/7bpmdz/having_trouble_getting_a_result_what_am_i_missing/) twice?
Well now that I work a less stressful job I feel that will be much easier. I have had time to consider it, and I am not sure I will do programming professionally, but for private projects.
Indeed. And I couldn't agree more.
Indeed. I was overworked now that I think back on it. I took too much on and it caught up to me. I am ready to get back at it though.
As in `double`? double precision `float`? or double precision `int`?
Eh? It's a good book, but IIRC it just covers the C language, not POSIX or GNU/Linux cruft.
So for example the actual size of `char arr[3]` size should be something like 3 * aligned_sizeof(char), and same with structs? Or am I confusing something here?
64bit decimal
1. Please insert four spaces at the start of each line. 2. Before asking others to do your homework, you should at least *try* to do it yourself. 3. Get a better instructor and / or textbook, because while this code will work with *some* compilers, it's not valid C.
&gt; Take some code you wrote previously, make the code simpler without changing the (essential) functionality. Suckless haha
Very nice.
So does most of the programming languages books!
One good thing to keep in mind is what dependencies you have at any point in the code (as in any language) and what is essential and what is accidental. By dependency I mean that you have left something undefined in the code that has to be resolved at some later point. In C you have compile time dependencies (code, headers, macros), link time dependencies (libraries, objects), and run time dependencies (input, environment). You can also chose to resolve dependencies at each of those levels. The more you push things towards runtime the more flexible your program becomes, because you can control the meaning of something within your code. For instance, global variables are resolved at link time, which ties all the references in the code to one object, while function parameters are bound dynamically at run time. The more flexible something is, however, the more work it is (and sometimes more complex). Globally visible constant data structures and functions are good candidates to resolve as early as possible, while in other cases you often want to delay the decision until later through parameterization and indirection (pointers and function pointers). Though, the pass-by-value semantics in C forces you to use pointers in many cases anyway already. But thinking in these terms have been helpful to me and makes me understand my code and the implications of my decisions better.
Yeah it's a terrific book. (Arguably) poor wording from my part... What I was actually trying to say is that although "A Modern Approach" is probably the best book for learning C, it does not cover GNU/Linux or POSIX things. Just the C standard and its standard library
Nice. I'll play with that source code later. I remember skip lists were a pretty hot topic for a little while, but I have yet to actually use one (unless they are used in standard libraries and I just don't know.)
The hard limit on number of levels really kills the idea; if you want efficient memory management it gets even worse, as the limit has to be set at compile time. Yet ever since I first heard about them I've had this hunch that the problems could be fixed. Time will tell, but it looks promising from here...
The actual size will of course be `sizeof(arr)` aka `sizeof(char[3])` aka `3 * sizeof(char)` aka `3`. Not sure what you mean by `aligned_sizeof`.
One design mistake I see a lot is failing to offer value semantics, forcing heap allocations on user code; if you're not going to allow optimal memory management, then why bother with C in the first place? Same goes for bending the language to the breaking point to check all OOP boxes; the beauty of C is that it allows you to build exactly what you need.
#include &lt;iostream&gt; #include &lt;stdlib.h&gt; using namespace std; typedef struct node{ int num; node* next; }; node* head =NULL; node* current=NULL; void add(int num){ node* link= (node*) malloc(sizeof(node)); link-&gt;num=num; link-&gt;next=NULL; if(head==NULL){ head=link; head-&gt;next=link; return; } current = head; while(current-&gt;next !=NULL) current = current-&gt;next; current-&gt;next = link; link-&gt;next = head; } void print(){ node* ptr= head; cout&lt;&lt;"head-&gt; "; while(ptr-&gt;next!=head){ cout&lt;&lt;ptr-&gt;num&lt;&lt;" -&gt;"; ptr=ptr-&gt;next;} cout&lt;&lt;ptr-&gt;num&lt;&lt;" -&gt;"; cout&lt;&lt;"[NULL]"&lt;&lt;endl; } int main(){ add(10); add(32); add(5); print(); return 0; } // is there any mistake here help
So, where are you stuck?
Why do you think there is a mistake? Is there a compiler error? Does it crash? Does it give an unexpected output?
Not C. Take it to another subreddit.
Why are you left-shifting cout? 
well I dunno what to do...
Then read your course material. If you haven't paid attention to class, there is little anybody here can do for you. This especially applies as the details of making flow charts are different with every teacher.
Using C++ is the mistake, you're welcome.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
https://cdecl.org/
I must agree! King just briefly say just how to compile with gcc...but that is it! 
If you send me ‚Ç¨100, I can write that program for you. If you try to write it yourself, I can help you with the parts where you are stuck for free.
You should check the name of the subreddit again...
Use `epoll` + a state machine for each client. When `epoll` returns read/write as much as you can without blocking and update the state. There's no need for threads unless the work required in updating the state is considerable. What kind of server are you writing?
 bitmask_t center = (unsigned int)(1ULL &lt;&lt; (move.row * size + move.column)); You're cutting half the board with this cast. It's not really needed there, and if anything, it must be uint64_t not int. With 4x4 board, everything fits into int.
So far i was able to create the window, the object, and i think i will need to create a structure to store the coordinates if it.
So what is the problem? You can create (in C jargon ‚Äúdeclare‚Äù) structures like this: struct my_structure { type1 field1; type2 field2; /* ... */ };
It's going to be a HTTP/2 server. And yeah it's not going to matter much but part of the reason I'm doing this is to familiarize myself with pthreads.
Did that code have tests?
Where do you keep the vector sorted? Looking at [https://github.com/andreas-gone-wild/alang/blob/58c397838117603cb01777ed1b7d4d9ef83186b6/src/alang/vector.c#L30](insert) all i see is that you're appending items to the vector. You're using binary search but the vector isn't sorted.
No blog spam please. Also, C# is off topic in this subreddit.
vector_insert makes space for an item at the specified index (from the search in this case) and returns a pointer that user code may use to set the value; the reason for doing this in two steps is that I need to support value semantics.
In programming, you have 3 basic structures that can be used to solve a problem: 1. sequence - one instruction after another 2. condition - choose between instructions based on a comparison 3. loop - repeat instructions until a condition changes Your task is to figure which of these structures and in what order you need to solve your problem. Read the problem and think about which structure could solve each part of the problem. One other thing that might help. All programs: 1. take input 2. perform some kind of processing to that input 3. generate output Generally, a program will use a main loop to repeat the above 3 steps until all input has been processed into output.
Ah that's an interesting way of implementing a vec. But still where does it sort it? In the performance test you're appending random numbers and do a binary search each time, but nowhere near that do i see the vector being sorted.
The vector is never explicitly sorted, it's kept ordered by each and every element being inserted in the right position relative to the values already in the vector (which is what the search is all about).
Nvm i get it now, i stand corrected.
/r/C_Programming i.e. "I can't google and do basic research myself" the subreddit.
Sure I asked for help on a programmimg subreddit but havent looked for a solution on google yet. 
I am not sure how to change the permissions using Windows 10. I agree that this could be the solution.
To receive help, it is important to show where exactly you are stuck at. I'm still not sure what your problem is. The only question you've asked so far is for someone to do your assignment. How are we supposed to help you if you can't tell us what exactly you need?
To receive help, it is important to show where exactly you are stuck at. I'm still not sure what your problem is. The only question you've asked so far is for someone to do your assignment. How are we supposed to help you if you can't tell us what exactly you need?
...what's a header number?
You want someone do your work for you without saying what you've tried and why you are stuck. I'm sure we would love to help if you honestly tried your best and can't self diagnose your problem. But saying "I would like to make a simple game, but I've never had success with the base moving mechanism" when there are dozens of tutorials on the internet saying how to do exactly that is just lazy.
Right click properties and check the permissions on the folder the executable is in, and check permissions on the executable itself the same way.
The more we learn, the more we win. It's not really optimal for larger numbers of items, but for small stuff it's still the quickest way to get a dynamic set going. Sorting everything at once isn't possible in many scenarios.
If you had turned on compiler warnings, you would have been told that maxaray() would undeclared when you called it from main(). If you had declared maxaray() (or even just moved it to before main()), you would have been told that you're passing the wrong kind of value as **m**. In particular, **max** is a *pointer* to float. When you pass **&amp;max** to maxaray(), you're passing a pointer to **max**, which is to say you're passing a pointer to a pointer to float. Now maxaray() is writing a float value to your pointer to float. That means that your pointer to float has gibberish in it. then when you dereference `*max*`, you're accessing a gibberish pointer and there's your segfault. Get into good programming habits: always declare your functions. Always enable warnings in your compiler. If possible, set the compiler flags so that warnings are fatal.
This is actually the C subreddit. I think what you're looking for is /r/cpp , they can help you out with any of your C++ needs. If you're interested in C though, this is the place for you.
C++: An Active Learning Approach
There is no magic bullet to learning programming, the only way to learn is to sit down and keep making stuff. That and reading other people's code will get you where you need to be in order to make professional software.
3 + 4 + 5. ++ increments 
The output is undefined. a is being altered more than one between sequence points. With a different compiler it prints 15, not 13.
3+4+5 is 12, not 13.
Is this phenomenon explained anywhere? The gcc compiler that I'm using always prints 13 for this particular initial value of a. How, then, is it undefined?
Also, `a++ + a++ + a++` gives expected output (9) even when `a` is being altered more than once.
I made an AI for this game in college. I used a board of two 64 bit integers. Each of the 64 bits would either represent my pieces or the opponent's pieces. It was a bit harder to make, but it reduced memory usage from 64 to 16 bytes.
Oh yeah lmao 
Start with C. C++ is arguably one of the most complicated languages to learn. If you‚Äôre interested in game dev, you‚Äôll need to know the raw C stuff anyway
I highly recommend using a tool like the godbolt compiler explorer, it will generate some asm for c code you put in so that you can check your answer. As for what's wrong with the code, I'm not too sure... my brain isn't working too well this late at night 
Undefined doesn't mean you get a random result. It means the compiler can choose to do what it wants without breaking the standard.
It's explained in the C standard, Wikipedia, or other articles on the internet. search for "sequence point"
You forgot to re-initilize `y` to `temp` before you multiplied it by 2 (alternatively, `y = 2 * temp;` would also work). Also, the entire bottom half of your logic, not including the return, should be in an `else` statement. 
That worked, thank you very much. And I'll be sure to do that next time
90% of game programming is in Lua or some in-house scripting language...
Don't post these please.
Undefined behaviour means that anything can happen, including what you expect. However, you should not rely not this. Turn on the compiler warnings by passing `-Wall` to gcc to see that gcc warns you about this sort of thing.
I would suggest you to explore- 1. Writing variety of programs 2. Learn low level programming with C 3. Interaction with assembly 4. Learn System level/Network programming in C 4. Know Data Structures and algorithms well 5. Know GNU make, Makefile, automake to build 6. Explore open source code of system softwares, tools etc 7. Learn assembly language too if want to work on system side I hope this helps you.
OpenSSL gets a lot of use.
SDL2
-Design with the thought of reuse. -Identify the functionality. -Identify the data structures and algorithms to use -Decide the files to have the functionality -Identify the functions (complete signature) to achieve the functionality -Have the declaration of function and data structures in header file I hope this helps you. 
Great example!
As u/DogBlessThou said, the when and why of those prefix increment operators are explained in terms of *sequence points*. You can read about those in Annex C of [the language standard](http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf). It's a very terse definition there, but if you go back and read the section on evaluation of the prefix increment operator it may become more clear. 
glib and gtk+ and all the X11 libraries it drags in.
Lessons 01 through 04 [here](http://lazyfoo.net/tutorials/SDL/) will go a long way toward you understanding SDL. The nice thing about SDL is the main loop always looks roughly the same in example/tutorial code you'll find. It's event-driven and in your case, the `event.type` you're interested in will likely be an `SDL_KEYDOWN` event. You'll likely modify the `x` and `y` of the object you're moving according to which key was pressed (e.g. `SDLK_DOWN`, `SDLK_RIGHT`, etc.) Good luck!
libsqlite3, libmagic, OpenGL, OpenAL, libuv
Many thanks!
Probably libcurl is right up there with glibc in how much it's used. In my own projects I'm using libdbus for interprocess communication, libevent for some semblance of async programming, libexpat for xml processing, samd.
Guess it depends on what kind of game programming we‚Äôre talking about. The graphics engines are almost entirely C/C++
linux-vdso.so.1 http://man7.org/linux/man-pages/man7/vdso.7.html a small lib, but used by just about everyone....
C++ is the worst way to start...Its fcking complex and boring language! Do yourself a favor: learn Python, C, Ruby....
Destiny 2 are said to be more C than C++
Well, yeah. Graphics engines are built on C APIs like Direct3D, OpenGL, and Vulkan.
++ operator easily make a mess if overly use it many at once, instead (++a) == (a = a + 1), it maybe end up like this. a = 2 (++a) + (++a) //Instead "(a = a + 1), a, (a = a + 1), + a" like stack base language (Ex. CIL/MSIL, assembly) a = a + 1 + 1 a + a 4 + 4 8 8 + (++a) 8 + (1 + 4) 13 It's limit of compile, unlike stack base language, C can't handle "++" very well result maybe 15 because compiler compile code like this. (++a) + (++a) + (++a) a = a + 1 + 1 + 1 a + a + a To be save, don't use ++ operator more then once in 1 line(";").
Graphics engines are a commodity.
I was always conflicted on weather to use sqlite for storing local data. Is there a good resource on when to use sqlite vs a text file or json? 
readline, LibreSSL, libsodium
Libuv is one example. It's fundamental to Nodejs. Libevent used by firefox. Pthreads?
Use SQLite to *store* data, text or JSON or XML or whatnot to *exchange* data.
glibc
Not really sure what the question is, but here goes. Anyway, colors are usually encoded using RGBA (red, green, blue and alpha). The alpha part may or may not be present. Every part (R, G, B and A) tend to fit in 8 bits (or a byte, if you will) so it ranges from `0` to `255`. Or in hex: `0` - `FF`. So if you generate a random value for each RGB component between 0 and 255, you can use bit fiddling to assign it to a single unsigned integer. 
Yea just realised im taking down the post but thanks for the answear
I thought the question was dumb enough but then people answered and the laughs keep comin'!
You use nodejs to do "Linux programming"?
Literally everyone. It's mapped into every single Linux process even if it's a static binary.
Many. The issue was intermittent at best. I'm fully responsible for the codebase and the whole development, test, and deploy cycle. This was a newer version of the product as well, so I knew there were bugs. This one was just especially hard to find because it only showed up in production.
Undefined means nothing in the language says what result you should get. For an arithmetic expression like that, a given compiler will likely give the same answer every time because it will just pick one thing to do (of infinitely many valid options). I get 13 with gcc and 12 with clang. Both are equally correct.
Expat for XML processing.
int main(), I think most of the compilers throw an error when you try to use void main()
Many thanks to all of you guys for the info and recommendations. I really appreciate it!
Neither. The only two acceptable forms are `int main(void)` and `int main(int, char**)` https://stackoverflow.com/questions/2108192/what-are-the-valid-signatures-for-cs-main-function 
`int main()` is the right one, as specified by the standard. I can't remember the details, but I think implementations are allowed to have other signatures for `main` (but only when it's not a "hosted environment" or somesuch, I think?). But really, there's no reason to use `void main()` at all, so don't.
Use SQL when you need to have relational database only. Otherwise, text if it needs to be human-readable, custom format if not. json is format for exchanging data, not storing it.
What if return value for int main() is greater than what can be stored in int data type? 
Then you done fucked up
See the answers to your previous question. https://www.reddit.com/r/C_Programming/comments/7c2hn2/should_we_use_int_main_or_void_main/?st=j9u70i8f&amp;sh=d7d10acf
There isn't a clear answer. 
Yes there is. int main(void); int main(int argc, char **argv); are the only standard forms of main.
There is an implicit cast to int before the value is returned.
zlib is commonly used for data compression.
`int main(void)` and `int main()` are equivalent in this case (see 6.11.6.3 paragraphs 10 and 14).
int is basically signed int. Why can't we go the other way. There is enough room for confusion. Argh! I will just haul my lazy ass and put that shit down the compiler and see what it throws up. 
make the noob understand. 
From the [C99 draft](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1): &gt; The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters: &gt; &gt; int main(void) { /* ... */ } &gt; &gt;or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared): &gt; &gt; int main(int argc, char *argv[]) { /* ... */ } &gt;or equivalent;10) or in some other implementation-defined manner. &gt; &gt; ... snip ... &gt; &gt; **Footnotes** &gt; &gt; 10) Thus, int can be replaced by a typedef name defined as int, or the type of argv can be written as char ** argv, and so on. The standard just says `int` , not `unsigned int` ([6.2.5p4](https://port70.net/~nsz/c/c11/n1570.html#6.2.5p4) says that `int` is signed). It might fall under "implementation-defined manner" (and it might work), but it isn't guaranteed by the standard.
Yep. The fog has lifted. 
`int main(int, char**)` is not technically correct either. It should be `int main(int argc, char *argv[])`. While these declarations are functionally equivalent, the standard specifies the second (in addition to `int main(void)`.
Use void main() if a return statement is unreachable; for example, a main function which contains a while(1) loop would never return.
it's treated as if it were an `int`, usually just truncated. **If you have some knowledge of assembly:** I could *imagine* [I'm shaky about this being allowed, maybe only on highest optimization level?] that the compiler would optimize this truncation away, if `sizeof (int) == 4` but you return in a register of 8 Byte size because it thinks that it could just write the full register instead of writing just the lower 4 Bytes, since -- if the caller only cares about the lower 4 Byte -- it'll be equivalent. So if the caller does actually read the full 8 Byte instead you might even be getting a full-size return code... . But the caller won't so this won't happen.
I get it actually. 
C89 **5.1.2.2.1 Program Startup** The function called at program startup is named **main**. The implementation declares no prototype for this function. It can be defined with no parameters: int main(void) { /*...*/ } or with two parameters (referred to here as **argc** and **argv**, though any names may be used, as they are local to the function in which they are declared): int main(int argc, char *argv[]) { /*...*/ } **6.9.4 Function declarators** The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature. ---- The distinction between `int main()` and `int main(void)` is subtle, but important. A function declaration without a parameter list can be called with any number of arguments and you lose the benefit of compile-time type checking. When you specify a parameter list (e.g. `(void)` or `(int argc, char *argv[])`) then the compiler can validate the arguments passed to that function. This is something leftover from pre-standardized C and the standard even says that it should no longer be used. For example, compiling the following with `gcc arg.c`produces no errors: #include &lt;stdio.h&gt; void func() { printf("Hello, world!\n"); } int main(void) { func(28, 30, "hello"); return 0; } And the string is still printed, but I (as the programmer) have no idea that the function doesn't actually take parameters. Modifying the declaration to: void func(void) { printf("Hello, world!\n"); } Will give the following error: arg.c: In function ‚Äòmain‚Äô: arg.c:12:9: error: too many arguments to function ‚Äòfunc‚Äô func(28, 30, "hello"); ^ arg.c:4:5: note: declared here func(void) ^ Which is very useful. 
&gt; custom format I'd prefer them to just use sqlite than a custom format. Custom formats are hard to get right, if you try to roll your own then you're likely to fuck up something. Can you ensure that your custom file format will pretty much *never* corrupt, even on an improper shutdown when it's being saved (by multiple writers, even)? Because sqlite3 does that. For an incredibly simple file format that *needs* to be human readable, sure, use plaintext. But I'd much rather an application use a known and very standardised format than try to roll their own.
sqlite can also be used as an exchange format just fine. In fact, they [actively advocate this](https://sqlite.org/appfileformat.html).
Please be civil.
Platforms may accept arbitrary other signatures.
I think MSVC will let you get away with if you're making a service. I could be very wrong, it's been many years since I last made a Windows service.
This is not a problem concerning C programming your post has been removed.
Define doesn't work. The only thing really wrong with your code is that you cast Malloy, which you shouldn't technically do.
`intPtr` is not initialized to `NULL`. It will receive whatever data already exists at that location on the stack or whatever is already in the register. Initialize the variable and then it should work appropriately.
Okay, that makes sense, thank you!
Why are you not supposed to cast it? What are should you do instead? Thanks!
I don't think "shouldn't technically do" is the right way of saying this. It's just a good idea to avoid excessive casts, and it's not necessary to cast in this case. On the other hand, C++ would require a cast here.
Have a read of http://c-faq.com/malloc/mallocnocast.html
Thank you, that explained it well!
This is controversial, both sides seem to have valid arguments. In contrast to /u/henry_kr 's link, see [this article](https://www.securecoding.cert.org/confluence/display/c/MEM02-C.+Immediately+cast+the+result+of+a+memory+allocation+function+call+into+a+pointer+to+the+allocated+type) which is in favor of casting. The comments section has some good discussion from both sides.
Using sizeof (int) without a cast is the worst of the 3 options imo.
As you did it at school - go from right to left, borrowing when necessary http://www.dummies.com/education/math/basic-math/how-to-borrow-when-subtracting/
a-b is the same as a+ -b. Negate the second argument and call `add20()`. And if you want to get really fancy, negation could just be `~` on each element if you put a carry in parameter on `add20()`.
~ on each element? Am I missing something or what do you mean with "~"? 
I am doing this for the addition already, I thought changing it for the subtraction should just be the same, but somehow the logic for subtraction just won't come into my mind.. I need dummies for dummies :(.
I posted a link for subtraction, not addition. For addition you go right to left, add the digits, and carry if the result is &gt; 10 For subtraction, you go right to left, see if the top is smaller than the bottom and borrow if it is, then subtract.
I agree and much prefer using `ptr = malloc(sizeof(*ptr));`. I don't cast the results of `malloc` in C, but if you have warnings turned up enough then it seems like a nice safety check.
Ahhh god damn, the comparing part was the one missing bit in my brain, wow can't believe that. One question though still, since you are really helpful already (thanks alot). How can I break this down? `sum = ((first_back &gt; first) ? *(--first_back) : '0') + ((second_back &gt; second) ? *(--second_back) : '0') + carry - '0';` A colleague helped me with this expression and I am confused by the + in this ternary expression. sum = ((first_back &gt; first) ? *(--first_back) : '0') - ((second_back &gt; second) ? *(--second_back) : '0') + carry - '0'; Should equal to: if (first_back &gt; first) { sum = *(--first_back); } else { sum = '0'; } But what about the part after the "+"?
 if(first_back &gt; first) part1 = *(--first_back) else part1 = '0' if(second_back &gt; second) part2 = *(--second_back) else part2 = '0' sum = part1 + part2 + carry - '0' 
`int main ()` also must be accepted. (Anything is acceptable, but some must be accepted by all compilers )
Sorry, I didn't read your code before commenting, so let me explain. First, if you're not familiar with it, read up on two's complement. It's beautiful and wonderful, and how all modern computers use negative numbers. After that, read [this article](https://en.wikipedia.org/wiki/Method_of_complements), which talks about how this is used in other bases. The basic idea here is that if you're trying to do 4235 - 1357, you can instead add the numbers 4235 and 8643 (12878) and only use the last four digits (2878). The way we convert 1357 to 8643 is by subtracting each digit from 9 (1 becomes 8, 3 becomes 6, 5 becomes 4, 7 becomes 2, for 8642) and then adding one. It might seem like magic at first, but this really works, and it's easy and simple. This process of subtracting each digit from nine is more or less what I meant with `~` (but I was thinking base 2 at the time, not base 10). So let me summarize. The easiest way to do this subtraction is to take the "ten's complement" of the second number and add it to the first. For each digit (*including leading zeros!*), subtract it from 9 and that's your new number. So "00012345678900" becomes "99987654321099". Add one to this number (you can use `add20()` to do this) to get "99987654321100". This is the negative form of the number. So now you can just add this to the first number and get your result! As an additional trick, instead of adding one you can use the carry feature that you've already put in `add20` -- instead of initializing `carry` to 0, use a function argument as the initialization. For addition, this parameter should be 0. For subtraction it should be 1. Doing this, you can just add the nine's complement number to do subtraction.
**Method of complements** In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers. This method was commonly used in mechanical calculators and is still used in modern computers. The nines' complement of a number is formed by replacing each digit with nine minus that digit. To subtract a decimal number y (the subtrahend) from another number x (the minuend) two methods may be used: In the first method the nines' complement of x is added to y. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
is truncated, and take only first 32 bits of data is returned
Libuv is a library that offers asynchronous I/O. In and of itself it has nothing to do with node.
Thank you alot, I've got the code working immediatly.. Embarassed on how dumb I replied, lol.
Wrong sub. This is for C, not C++.
This is C++ code and you'd be better served by asking this question on /r/cpp_questions. This subreddit is for C programming, rather than C++. Make sure to add four spaces before your code so that it formats properly when you post there. Good luck!
This is not possible . I guess you mean, "what happens if the expression in the return statement is out of range for int". In that case, if the expression had integer type it is converted to int, which is implementation-defined. If it was floating point the behaviour is undefined. Otherwise it is a constraint violation.
[libcurl](https://curl.haxx.se/docs/companies.html) at work we also use libpthread and librt. 
&gt; Think a bit Good advice, perhaps you should follow it. intPtr isn't initialized, that's the problem. Whatever memory location it's pointing to is something other than NULL. &gt; The only thing really wrong with your code is that you cast Malloc No, see above. And K&amp;R tells you to cast, that might be why he thought it was proper to do so. Being self-taught myself via K&amp;R I made the same mistake until someone kindly explained that the this has long since changed.
As you say, they're functionally equivalent. C99 and C11 contain normative text allowing "equivalent" forms -- with `char ** argv` as a non-normative but indicative example of such an equivalent form.
We might be able to give more helpful answers if you explain the motivation for the question.
* GLib -- contains lots of stuff you would expect from a standard library of a higher level language. Includes a bunch of data structures, (hash tables, n-ary trees, etc) a high level threading library, a polymorphic type system, (!!) serialization of arbitrary types, etc. * ncurses -- for making textual user interfaces. (TUI) * gpm -- for heathens who want to use their mouse in their TUIs. * readline -- for making a single line, console based interface. * curl -- an http client library. (I think it also does ftp and maybe some other protocols? I dunno.) * gumbo -- HTTP parser. * expat -- XML parser. * libaio -- asynchronous networking (and to a limited extent, filesystem operations) library. * sqlite -- local relational database. Use this for non-human readable config files and data persistence. * libyaml -- parse and write YAML. Use this for human readable config files. * getopt(3) -- parse command line arguments. See also getopt(1) for parsing command line arguments to shell scripts. * gtk+ -- GUI. * libpcre -- more powerful regular expressions. * libunistring -- Unicode handling. See also icu.
Gotcha - I'm not as familiar with anything past C95. Thanks for the clarification!
&gt; It will receive whatever data already exists at that location on the stack or whatever is already in the register It's undefined behaviour - anything could happen. Another possibility is that the compiler will optimize out the NULL check.
return x; Is actually return (int) x;
It's not about who is smarter. Just follow your passion. Let it be about the subject and not the competition. Maybe you don't get it now, but you can understand it in the future. Don't define your ego on your smartness. Advice from the old sage: https://www.google.de/search?q=dennis+ritchie+quotes&amp;client=ms-unknown&amp;prmd=inv&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjn_u7korXXAhWEOBoKHZqHBQwQ_AUICSgB&amp;biw=360&amp;bih=559#imgrc=xwdU1j9gtX8YzM:
If you need to read a line of text instead of a single word, use fgets().
Such a good library for both low level and high level C development.
That seems to have fixed the issue, thanks. Though, now in the second scanf, it will never end even after I input a character. 
You have an infinite loop. You need something like ps = strchr(ps, ch). Your loop keeps searching the same string every iteration. 
Post real code and the compilation errors.
My Systems professor frequently says that undefined behavior can make a dragon come out of your nose.
 enum testEnum {A, B, 1, 2, 3}; testEnum array[3] = {A, 1, 3}; for (int i=0; i&gt;3; i++) { cout &lt;&lt; array[i] &lt;&lt; " "; } return 0; Erroring out with: error: expected primary-expression before ‚Äòenum‚Äô enum testEnum {A, B, 1, 2, 3}; error: invalid conversion from ‚Äòint‚Äô to ‚Äòmain()::testEnum‚Äô [-fpermissive] testEnum array[3] = {A, 1, 3}; error: invalid conversion from ‚Äòint‚Äô to ‚Äòmain()::testEnum‚Äô [-fpermissive] error: expected primary-expression before ‚Äòenum‚Äô Hope this sheds light? 
posted above 
There is nothing on the page you linked to that advocates using SQLite databases as a data exchange format.
Enums contain symbols, not letters and numbers. enum { cat, dog, donkey }; cat has a value of 0. dog, 1. and donkey 2. enum { A,B,C,1}; is illegal. It would imply there's a symbol `1` with a value of 3.
If the error say "before something" then you should post the code that is before the line. Ideally post everything.
Usually, I only ever use glibc and ncurses when programming. This is a very limited pallete, which I'm trying to expand, but I don't want to have to use obscure or unnecessary libraries. I want to keep things simple and standard that everyone can read and write. 
I know this, however... all that is before the code I have posted is include &lt;iostream&gt; (with the #, this just makes it huge cause MD) using namespace std; int main() { /code } 
so if I wanted a enumeration for a chess board, but each piece to be labeled with a capital letter OR number... this is impossible? Rook = R Queen = 1 King = 2 Knight = K enum {R, 1, 2, K}; like that? I know youre thinking why not have them all be values but according to an assignment I am able to do both somehow.
I'd do enum { pawn, rook, knight, bishop, queen, king};
I would too, but what if I dont have this choice in the matter, lol.
Then I don't understand what you're asking. You can't have numbers in an enum - it makes no sense.
1. C++ is not C. They are different languages. 2. Enumerations are effectively just shorthands for defining labels with integer values. Enum labels cannot begin with a number
I have instruction to create a 2d array that is filled with values from an enum that I declare. The enum contains PAWN, ROOK, KNIGHT, BISHOP, etc. However when I print out my array, substitute shorthand values have to coincide with those pieces. Chess Board(array): K R B 1 1 1 where 1's are pawns and the K R and B are the knight rook and bishop.
Then you don't need another enum. When you're printing, switch on the piece type switch(piece.type) { case pawn: print('1'); break; case king: print('K'); etc...
ah! Thank you so much my friend 
&gt;An SQLite application file format is a great choice in cases where there is a collection or "federation" of separate programs, often written in different languages and by different development teams. This comes up commonly in research or laboratory environments where one team is responsible for data acquisition and other teams are responsible for various stages of analysis. Each team can use whatever hardware, operating system, programming language and development methodology that they are most comfortable with, and as long as all programs use an SQLite database with a common schema, they can all interoperate.
Oh oops, forgot to add the p to s. Thanks for the help. It's all good now.
[Nasal demons!](http://www.catb.org/jargon/html/N/nasal-demons.html)
Huh TIL. Thank you for the jargon file reference.
Why did you use strchr? Why not while( *ps != NULL ) { if( *ps == ch ) count++; } 
No, I don't use nodejs to do Linux programming but libuv is a central piece of software to node is all what I wanted to say. And as VincentDankGogh rightly pointed it is an excellent library offering asynchronous IO capabilities plus it is cross platform. I work on Embedded Linux and C at my day job.
Wow, thats also a really smart approach, thank you for that buddy!
Sqlite vs a key-value store like GDBM or Tokyo/Kyoto Cabinet is a more interesting choice.
I'm curious, what did he say?
Here intPtr is a pointer variable and It is not assigned any value. Pointer variables are not NULL by default. They just randomly point somewhere in the memory. 
But I don‚Äôt even have a cat?!
In the [HTML draft of C89](http://port70.net/~nsz/c/c89/c89-draft.html), while the [section doesn't state it explicitly](http://port70.net/~nsz/c/c89/c89-draft.html#2.1.2.2), it is stated in [section 3.7.1 Schematics](http://port70.net/~nsz/c/c89/c89-draft.html#3.7.1): (emphasis mine) &gt; On entry to the function the value of each argument expression shall be converted to the type of its corresponding parameter, as if by assignment to the parameter. Array expressions and function designators as arguments are converted to pointers before the call. **A declaration of a parameter as ``array of type '' shall be adjusted to ``pointer to type ,''** and a declaration of a parameter as ``function returning type '' shall be adjusted to ``pointer to function returning type ,'' as in 3.2.2.1 The resulting parameter type shall be an object type. So this means `int main(int argc, char *argv[])` is adjusted to `int main(int argc, char **argv)` anyway. The footnotes in later versions probably just makes it clearer.
Structuring your code into functions is generally considered good programming style. Continue with that! On the other hand, in C it's more common to name your functions in `snake_case` instead of `camelCase`. For example, instead of `bindAddressToSocket()` you should better write `bind_address_to_socket()`. This is easier to read and more idiomatic. Also make sure to do errpr handling. What happens if your `openFile()` function fails? Deal with that case!
Funny. I am learning C and I see a lot of snake case structures and upper camel case functions. 
What library are you programming with?
Oh yes partly why it happened like was because of that openFile function, i didnt want the if-statement error handling in the main function! I never heard of neither snakes nor camels in code, this is a great tip, thank you :)
Snake case is when you separate words in identifiers with underscores: `snake_case_function()`. Camel case is when you use capital letters to separate words: `snakeCaseFunction()`. I recommend you to make error handling explicit. It's much easier to understand your code if the error path is explicit.
Sorry but i dont understand what you mean with explicit error handling :/ Like i did this: FILE *openFile(char fileName[]){ FILE *jobFile = fopen(fileName, "rb"); if(!jobFile){ printf("Cannot open file!\n"); exit(1); } else{ printf("File opened!\n"); } return jobFile; }
http://astyle.sourceforge.net/ this has a very wide range of options, I usually have a makefile target for it...
How is using underscores going to magically make code more idiomatic?
Keep in mind that everybody has their own preference when it comes to naming. A lot of code uses underscores and a lot of code uses camelCase. If you like camelCase, there is nothing wrong with it.
Yeah, that's better! This way, the reader can easily understand what happens in case of error.
The declaration will be something like int input(BOOK_STORE *store, int size); And the call will be something like BOOK_STORE books[M]; int result = input(books, M); Question though ... the struct is for holding a single book, so why is it called "book store"?
Because that's the dominating style in C.
thanks alot for such quick and constructive responses! ill make sure to come back whenever i dereference another null pointer or struggle with casting :)
the program should be able to deal with 300 records of different books.i made a define for 3 to see if it works so later i change it to 300 . correct me if i'm wrong but when i'm making a structure called A, and i create a typedef A array, i can input data to any row of the structure using my array ? 
Functions are generally good, but if they're only ever going to be used once in a small program, you could just write the procedural code out in main. I am suspicious of this function you made for opening files. Opening files is super normal run-of-the-mill stuff so you can just do it w/ the &lt;cstdio.h&gt; functions without wrapping them in your own function unless it somehow does something special - in which case the function name should suggest this. Reading a struct from file warrants its own function because there's potentially lots of things that could go wrong with it, errors to check from and etc. Reading just a character though... you could just write out a call to fscanf to be more clear -- if you're just reading a character, you can very simply check the result without writing a function because it can only fail to read a character if there's no more input in the file stream. But it's preference ig. Just be sure to have your function definitions (not the prototypes, those are just for the compiler) in a sensible human-readable order. So if createSocket() is the first big thing to happen in main, that should be the first function definition below it, so the reader doesn't have to read in a zig-zagging order. 
Truly the file reader does nothing special really, just checks whether a file was properly read then if it wasnt totally terminates everything :/ Ill make sure to properly organize the definitions! atm theyre all over the place under main!
You will if you try to build and run that code.
He means: typedef struct abook { ... } A_BOOK; Your structure is about a single book, not a bookstore. So given the above single book definition, this would work: typedef A_BOOK BOOK_STORE[M]; I'm not a fan of `typedef`, and am even less of a fan when it is used to make arrays and pointers as types.
Your code could be more thorough in checking for failure conditions (including unexpected values of argc) but otherwise, looks good!
main will always[1] have error handling because its return value needs to reflect whether the program was successful or not. [1] Unless all the logic is pushed down into another function, in which case the error handling belongs there.
Better. Improvement: always send error messages to stderr.
&lt;cstdio&gt; (C++ only) or &lt;studio.h&gt; but not &lt;cstdio.h&gt;.
Personally I always define functions before use (this is sometimes called "Pascal order"), so no need for function prototypes.
Using typedefs for arrays can make things confusing. For example, if you have typedef BOOK_STORE array[M]; void function(array store) { } Then there is no information about M. store has the type `BOOK_STORE*` And my point about the names is that the struct itself holds 1 book, but is called BOOK_STORE. The common use of book store is a shop selling hundreds of books. 
I wrote up some pseudo code to illustrate what I would want to read. typedef int my_error_t; typedef int secondst_t; typedef int my_loglevel_t; const my_loglevel_t lvl_unknown = 0; const my_loglevel_t lvl_info = 1 &lt;&lt; 0; const my_loglevel_t lvl_warning = 1 &lt;&lt; 1; const my_loglevel_t lvl_error = 1 &lt;&lt; 2; const my_error_t my_success = 0; typedef struct my_socket my_socket_t; typedef struct my_file my_file_t; typedef struct my_job my_job_t; typedef struct my_logwriter logwriter_t; typedef struct my_system my_system_t; typedef my_error_t(*log_f)(logwriter_t * self, my_loglevel_t loglevel, const char * sender, const char * message); typedef my_error_t(*Socket_CB_Listen)(void * user, const char * message); //// int createSocket(); //// I assume createSocket returns an error type when I read this. //// You expected createSocket to return a socket - what happens when things go south? //// here is my alternative //// strict rule to have an error return value //// when there is a create there is a delte //// be prepared to wirte logmessages - store a logger function //// Start with the structname so you have an easier time when auto comleting //// use self instead of 'this' because 'this' is a keyword in c++ my_error_t Socket_Create(my_socket_t * self, logwriter_t * logger, log_f * log); void Socket_Delete(my_socket_t * self); //// void testSocket(int socket); //// This test loogs like a manual testing function where you write something and you manually check the outcome //// SocketValidate //// this function could be called and would return my_success if validation was ok my_error_t Socket_Validate(my_socket_t * self); //// struct sockaddr_in createServerAddress(char port[]); //// void bindAddressToSocket(struct sockaddr_in server_address, int socket); //// If this is only relevant for the socket you could set this on the socket. //// No need for the caller to know anything about the internals my_error_t Socket_SetServerAddress(my_socket_t * self, const char * address, const char port); //// void listenForConnections(int socket); my_error_t Socket_AddListener(my_socket_t * self, void * user, Socket_CB_Listen * listener); my_error_t Socket_RemoveListener(my_socket_t * self, void * user, Socket_CB_Listen * listener); //// FILE *openFile(char fileName[]); //// If you write your own function, which would not nescessarily make send you can go all the way //// you can apply your error handling and logging thinking here too //// the only thing that matters is consistency my_error_t File_Create(my_file_t * self, const char * filename, logwriter_t * logger, log_f * log); void File_Delete(my_file_t * self); ////unsigned char readCharFromFile(FILE *file); ////unsigned int readIntFromFile(FILE *file); my_error_t File_ReadCharacter(my_file_t * self, char* c); my_error_t File_ReadInteger(my_file_t * self, int* i); //// You can offer several constructors for 'Job' //// Ideally construction does nothing but getting resources. No actual heavy lifting. my_error_t Job_Create(my_job_t * self, logwriter_t * logger, log_f * log); void Job_Delete(my_job_t * self); //// struct job readJobFromFile(FILE *file); my_error_t Job_DeserializeTask(my_job_t * self, my_file_t * source); my_error_t Job_Confuble(my_job_t * self, const char * tcpipmessage); my_error_t NoLogging(logwriter_t * self, my_loglevel_t loglevel, const char * sender, const char * message) { ////intentionally empty for silent mode } my_error_t job_confuble_listener(void * user, const char * message) { return Job_Confuble((my_job_t *) user, message); } my_error_t System_Wait(my_system_t * self, secondst_t seconds); int main(int argc, char * argv[]) { //// some argument checking would not hurt logwriter_t * nowriter; my_job_t * job; my_socket_t * socket; if (Job_Create(job, nowriter, NoLogging)) { //// since 0 is success this is an error; return; } if (Socket_Create(socket, nowriter, NoLogging)) { //// since 0 is success this is an error; //// in C deleting is the programmers responsibility //// delete is not allowed to fail so there is no error return value; Job_Delete(job); return; } my_error_t errors = 0; errors |= Socket_SetServerAddress(socket, "127.0.0.1", argv[2]); errors |= Socket_AddListener(socket, job, job_confuble_listener); //// This is pseudo code anyway so i skip initialising the system errors |= System_Wait(0/*ignore the man behing the curtain*/, 10); Job_Delete(job); Socket_Delete(socket); return errors; } 
None in particular. Just random github projects. If I‚Äôm being totally honest, it is more of a minefield of random stuff than anything. Do you have a coding standards document you like to adhere to that details most cases? I‚Äôm just a beginner. I haven‚Äôt even really looked for a commonly used coding standards. 
I would disagree since the question is explicitly about good style in traditional C. While you are definitely are going to find CamelCase in some code bases, they are definitely not good **traditional** style. As an example from the Linux Kernel style guide: &gt; HOWEVER, while mixed-case names are frowned upon, descriptive names for global variables are a must. To call a global function foo is a shooting offense. While I don't agree with everything they ask for, it's still an amazingly good starting point. https://www.kernel.org/doc/html/v4.10/process/coding-style.html 
I wrote down some example code that xould help you unserstand how to juggle with structures pointers members arrays and passing something to a function. typedef int myint_t; typedef struct name name_t; typedef struct BOOK_STORE { char book_author[20]; char book_publisher[20]; char book_name[20]; int inventory; }BOOK_STORE_T; typedef BOOK_STORE_T BOOK_STORE_ARR10_T[10]; void func_1(BOOK_STORE_T * store); void func_N(BOOK_STORE_T * store); void func_10(BOOK_STORE_ARR10_T * store); int main() { BOOK_STORE_T store1; store1.book_author[0] = 'A'; store1.book_author[1] = '\0'; (&amp;store1)-&gt;book_publisher[0] = 'B'; (&amp;store1)-&gt;book_publisher[1] = '\0'; func_1(&amp;store1); BOOK_STORE_T store2; func_N(&amp;store2, 1); BOOK_STORE_ARR10_T store10; BOOK_STORE_T * store_index0 = store10; func_1(store_index0); BOOK_STORE_T * store_index1 = &amp;store10[1]; func_1(store_index1); func_1(&amp;store10[2]); BOOK_STORE_T * store_index3 = store10 + 3; func_1(store_index3); BOOK_STORE_ARR10_T store10_2; func_10(store10_2); BOOK_STORE_T store12[12]; func_N(store12, 12); BOOK_STORE_T store20[20]; func_N(store20, sizeof(store20) / sizeof(store20[0])); return 0; } void func_1(BOOK_STORE_T * store) { store-&gt;book_name[0] = 'C'; store-&gt;book_name[1] = '\0'; (*store).inventory = 1; } void func_10(BOOK_STORE_ARR10_T * store) { //ARR10 has a known size of 10 //this is a contrived example and virtually never happens in real life int n = sizeof(BOOK_STORE_ARR10_T) / sizeof(BOOK_STORE_T); func_N(store, n); } void func_N(BOOK_STORE_T * store, int N) { for (int i = 0; i &lt; N; ++i) func_1(store + 1); }
Yes, a common convention for structs is to append '_t' to the name, but this is actually reserved for POSIX types (i.e. you shouldn't use it if you want your code to be as portable as possible). Another convention is to capitalize the first letter of typedef: typedef struct Message { int length; char value[MAX_MSG_LEN]; } Message; I've also heard that some people do not like typedefs because it obscures what the underlying *thing* is, and prefer seeing variables declared as `struct message msg;`, rather than `Message msg;`. AFAIK this is just personal preference and there is no best way. 
K&amp;R is the book a lot of people learn from (and is a de-facto standard in most open source project) but on the full program level, I've heard good stories of the CPython source. Also although I disagree with the indentation/code style I do admire the liberal documentation and commenting
Tell us what you want to achieve, not how you're trying to do it.
mbedTLS is a cryptography library written in C, so is LibSodium Download them and check them out.
Ok, I'm looping over argv, and setting "arguments" based off that, the thing is tho an "argument" can constitute multiple strings from argv, therefore I don't know how many arguments there are until I actually read them.
&gt; therefore I don't know how many arguments there are per argv until I actually read them. Yes you do. *int argc* contains the number of arguments.
int main (int argc, char \*\*argv);
Look at each argument, and determine if it is an "option". Otherwise it must be a "value" for the last option, or it's a user error. Use a switch, probably.
That tinypic website is absolutely horrible, it opened a new tab for me after covering 90% of the screen with ads. [imgur](https://www.imgur.com) is pretty nice. If `aBuffer` is an array of data, containing the information shown in your picture, then `aBuffer` is a pointer to that data. If you want to look at that memory as a series of `uint16_t`s, then you would assign your pointer like so: uint16_t *a = aBuffer; Dereferencing that pointer will retrieve a `uint16_t` type. Does that help at all?
I have my own arguments that I'm build from argv.
check out the original [git commit](https://github.com/git/git/tree/e83c5163316f89bfbde7d9ab23ca2e25604af290) by Linus Torvald. Also, the source code of [redis](https://github.com/antirez/redis) is considered by many to be very high quality C code.
Okay so either define a maximum number of arguments per option and statically allocate for that, or count ahead arguments and dynamically allocate. If you consider looping over argv twice a "pain in the ass" you're going to have bad times when you need to solve real problems.
I recommend to follow KNF (kernel normal form). Check out the man page style(9) on various unices for details.
OpenBSD is reputed to have high quality C code, and is routinely professionally audited. There is a group of people reading the OpenBSD source daily called "OpenBSD Daily". 
Apart from being written in C89, I'd say [Jansson](https://github.com/akheron/jansson), a json library, is very clean, with a consistent, well-documented interface. I've been working with [libclang](https://clang.llvm.org/doxygen/group__CINDEX.html) lately, and although the project is gigantic, the C-interface is simple, modular and consistent. 
Angband 
It's usually better to let the caller decide how to report and handle the error. Exiting the program may not be desired, or there might be a different way of reporting errors. Doesn't matter much in this case, but if you ever write a library other people might use, it does.
**Important Sidenote**: I think it's a great practice to structor the code and the flow using functions, but putting `camelCase` aside (which I find distracting): **make sure to keep the global naming scope as clean as possible by using `static` functions**. Unless `int createSocket();` is accessed by other files in your program, make sure to name it `static int createSocket();`, so that the function's scope is limited to the local namespace (rather than the global namespace). This is important as projects grow bigger and helps prevent naming collisions. 
I have doubts about "domination": from a random sample (libs I have recently used) only libuv consistently uses snake; both sqlite and lua(jit) throw some camels in - you have to go no further than zlib.h (deflateEnd). Don't get me wrong, I do prefer snake (in c[++]); but when combining a few libs you likely end up with an inconsistent mix anyway. Imo life is too short, to each their own. I can't help but also point out that camel is not only shorter (higher information density; more efficient encoding?) but also the way the interspersed uppercase "helps the eye" and at the same time resolves ambiguity is (subjectively) quite clever. Or maybe too much Java, can't be sure :-)
https://github.com/memcached/memcached
It's a pleasure to read through Torvalds' code. Everything he writes is concise and clear. And no fancy tricks.
libgit2 is really nice. https://github.com/libgit2/libgit2
&gt; git commit Just randomly clicked on a file, write-tree.c, and noticed a comment: /* If we were anal, we'd check that the sha1 of the contents actually matches */ LOL 
Linux Kernel Gtk Tmux Dwm OpenBSD 
&gt; I didn't see a sub dedicated to C++ How hard did you look? The top 4 results from googling "C++ reddit" returns actual C++ subreddits. There are many better fitting ones in the sidebar of this very page as well; e.g. /r/cplusplus, /r/cpp, and /r/cpp_questions. 
thanks a lot! 
[SQLite](http://sqlite.org/)
 #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { printf("Happy Birthday John!\n"); printf("I love you!\n"); printf("-Jane\n"); return 0; } Or, just a single line: printf("Happy Birthday, John!"); Also, just to be sure, he's studying or knows the C programming language, right? 
thank you very much!i'll give it a look and try it after work 
With regards to what others posted here, Torvalds generally writes idiomatic C, OpenBSD IMO is sort of a crap shoot depending on how much attention the code gets (obsd ksh is a good example), git has sort of become a huge monster. Try reading musl libc, there are a few hairy parts but in general the code is easy to read.
Where is the document or course or authority that has planted this "`void main()`" nonsense into new programmers' heads? I've seen this question asked and debated a few times recently.
If you are on Windows, WINE is great C to read. Much much cleaner than that pirate Win2k source.....
came here to say this. you beat me to it. also shoutout to /u/lilibrillo /u/samsonx /u/happycynic /u/nwmcsween for their input. 
Break the problem down into simpler tasks. Figure out which parts you can code first (because they don't depend on anything else) Get those parts working, and then incrementally add all the bits of functionality you need. For example, choose a way to represent the game arena. Then write the code that displays it. With no game pieces in it. Then decide how you will represent the score. Add that to the display. Figire out how to represent the pieces, the modify the code to display one particular piece on screen. Then make it fall, until it hits the bottom. Then change the code to add a second piece and make it fall until it hits the first piece. Then generalise your code to choose pieces randomly. Then change the game so that it detects when the game arena has been filled up (i.e. the end of the game). Then add detection of when the player has completed a line, and remove it. Then add scoring for the things that need it. Then you can add rotation of the pieces.
 This is nerdy, but I reckon you asked for it. Make sure you write/copy/paste this without any typos. ;-) #include &lt;stdio.h&gt; char *secret = "ziBbeqjAs+cu"; unsigned long message = 10521325414783145265U; int main(void) { while (message) { putchar(secret[message &amp; 15] - 33); message &gt;&gt;= 4; } } This program will simply wish him "HAPPY BIRTHDAY!" but it may not be immediately obvious to him what the message is until he runs it. :-) You're a sweetheart for doing this.
Thanks for your answer. I made two arrays , one is 20x20 (game arena) and one is 5*5 ( it will be the piece that the player choose to use for his turn). But then I need to do rotation and I don't know how to do that since i have pieces of all sizes. So i can't get a general "formula". 
Draw out some grids on squared paper. Number the rows and columns starting at zero. Choose a piece. Draw it out, pixel by pixel, rotated by ninety degrees. Each time you draw a pixel, note how its coordinates relate to the original position. See if you notice a pattern.
Generally: When you're stuck, break things down into simpler parts. Keep doing it until the sub tasks are easy enough to implement directly. If you can't see how to break a task down, do it by hand and watch how you did it. 
[Suggestion] Go for the random function!!
Try using Return 0 at the end of the code when int main () is preferred.
&gt; my variable aBuffer points to a region in memory If I wanted to grab the first address of that region of memory and point to it, what would be the apppropriate way to do this? "The first address of that region of memory" is `aBuffer`. So you point to it with `&amp;aBuffer`.
https://github.com/lua/lua Well regarded for being written in very strict ANSI C
Look over Fabien Sanglard's recent post about Wolfenstein's [Fizzle Fade](http://fabiensanglard.net/fizzlefade/index.php) which sounds similar to what you want.
If you want a simple solution, you could do the array thing you proposed with no actual modification to the array. So you would have an array with 1 or 0 in the element `n`, to represent whether the number `n` has been used already, and a counter with how many numbers are still unused; you generate a number `m` from 0 to that counter, and pick the `m`-th free element. It's not particularly efficient (n^2 to generate all the numbers, as opposed to n if you used an array you actually deleted elements from, assuming that deletion could be done in constant time), but it's not terribly inefficient, and it's easy to understand.
to me your algorithm looks fine, and not that its a particular recommendation but I've implemented the practically the same previously... go for it!
Show your code.
There are no pieces larger than 4x4 in Tetris. And rotation is the same for all‚Äîforget about rotating the piece, rotate the 4x4 grid instead. But remember to disallow a rotation that would cause the piece to overlap with an occupied tile.
This is called a [permutation](https://en.wikipedia.org/wiki/Permutation#Permutations_in_computing).
[CPython](https://github.com/python/cpython).
&gt; sqlite SQLite actually uses snake case for all external interfaces, reserving camel case for internal function. I think that's a good convention. &gt; I can't help but also point out that camel is not only shorter (higher information density; more efficient encoding?) but also the way the interspersed uppercase "helps the eye" and at the same time resolves ambiguity is (subjectively) quite clever. Or maybe too much Java, can't be sure :-) I prefer snake case because it reads just like normal text. It's also much easier to use when case distinction is important. For example, I wrote a Go wrapper for the libnfc. The wrapper has a function named `AppendISO14443aCRC` which is really weird to read. I had to deviate from normal camel case conventions (which would have given the unreadable `AppendISO14443ACrc`) just to get some readability. In snake case, this function is just `append_iso14443a_crc` and much more readable.
There are many open source tetris implementation, but reading their code probably won't help you understand the required concepts.
C++ is off topic in this subreddit. Please post requests for C++ programmers elsewhere. Also consider posting in /r/cjobs.
[Linus talk about typedefs](http://yarchive.net/comp/linux/typedefs.html)
You can put the fields common to each type in their own struct struct Geader { Header *next; int x,y; int hitpoints; } struct player { Header header; int score; } struct monk { Header header; int magicpoints; } The common functions work on a list of Headers.
https://github.com/tcltk/tcl
[suckless.org](https://suckless.org/) also Plan 9 from Bell Labs, or really just anything from Bell Labs
I suggesting reading up on [Fisher-Yates](https://en.wikipedia.org/wiki/Fisher‚ÄìYates_shuffle). Create an array containing the numbers in the ranger, shuffle the array, then use successive elements from the array.
**Fisher‚ÄìYates shuffle** The Fisher‚ÄìYates shuffle is an algorithm for generating a random permutation of a finite sequence‚Äîin plain terms, the algorithm shuffles the sequence. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
So then the Headers make a linked list? If not what is the purpose of the next field?
This is next level
You don't have to place the common position `struct` in the header... you can write macros to access the position struct. i.e. struct Player { int score; Position pos; } #define get_pos( type, pobj) ((Position *)(((uintptr_t)pobj) + ((*type)NULL)-&gt;pos)) This allows more flexibility than headers, but requires that the field name (`pos`) is identical for all `type` structs.
**Sidenote**: Why is the XY position a property of the objects? Isn't the XY position a property of Space? No two objects (I'm assuming) can occupy the same XY position, so the XY positions "belong" to Space rather than the objects. This should speed up a lot of other concerns (such as collision algorithms, movement limitations and monks bumping into trees)...? This XY "Space" collection will contain references to every object (I assume objects have a "type" identifier, such as an `enum` or `vtable`) making this task much easier... 
What have you done so far? You have a big task. You have to break it into smaller tasks. Can you write something that reads a hex number from the user?
#include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #include &lt;conio.h&gt; #define Num_Length 10 int j, n; int hex1[16]; int hex2[16]; int hex_sum[16]; int main() { for(j = 0; j &lt; Num_Length; j++ ){ printf("Enter two hexadecimals to add\n"); scanf("%d %d",&amp;hex1, &amp;hex2); hex_sum[j]=hex1[j] + hex2[j]; printf("Sum of the hexadecimals is %d\n", hex_sum[j ]); } return 0; }
I just realized that i formatted it wrong, but hopefully you can still read it 
 If you start each line with 4 spaces, it'll format it as code.
The code I've managed to figure out so far in case anyone is wondering #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #include &lt;conio.h&gt; #define Num_Length 10 int j, n; int hex1[16]; int hex2[16]; int hex_sum[16]; int main() { for(j = 0; j &lt; Num_Length; j++ ){ printf("Enter two hexadecimals to add\n"); scanf("%d %d",&amp;hex1, &amp;hex2); hex_sum[j]=hex1[j] + hex2[j]; printf("Sum of the hexadecimals is %d\n", hex_sum[j]); } return 0; }
Well in this case the player will die when the Monk and the player have the same X and Y position. Also the player needs to be able to pick up the gold object when the X and Y positions of the player and the gold match. So I need to have overlap. For right now I haven't needed to use any sort of type enum because all objects of a type are put into a list for just that type of object. But I may need to create a type enum in the future.
You said you had a list of players and a list of monks. Are they in a linked list? Or an array? Or some other structure.
Then you have a bunch of hideous macros. And, more importantly, you can't have a generic function to walk either so of list because you still need to know the type when retrieving the field.
Using visual studio on linux can really make your a lot more complex and that might be dangerous. As high complexity leads to bugs and errors that are hard to be detected. There are programs that might help as checkmarx does but I recommend to try and avoid those kind of errors but lowering down the complexity level. Good luck.
As a new to C I'd recommend you to code slowly and try to detect vulnerabilities in the code as quick as possible. Those are hard to be detected later and although there are programs that might help with it, as checkmarx, it is recommended to try and avoid them.
Put four blanks in front of every line of code for the code to appear readable.
It is a dynamic array of void *
Also check out Entity Component Systems, I find them clean when used correctly. See my [entity.h](https://github.com/axelf4/fpsgame/blob/master/entity.h) for an example. Basically players and monks would both have a position component. Searching is simply done by looping through all entities, checking if the position bit is set.
I've commented the formatted version. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [axelf4/fpsgame/.../**entity.h** (master ‚Üí 08761a2)](https://github.com/axelf4/fpsgame/blob/08761a297eb6aaeef667e5b4142f4d722de097a8/entity.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpq1cyi.)^.
It shouldn't be void*. You can have arrays of `header*` and cast when you use them as players or monks. Or an array of `player*` and an array of `monk*` and cast to an array of header* when passing to the generic find position function . The latter is nicer, IMO 
You appear to be shadow banned. Please talk to the admins to rectify this issue.
This remark dates back to a time where *function prototypes* haven't been invented yet. Back then, you had to manually cast every argument to the right type. Nowadays, the compiler can do that for you if a prototype exists.
I have heard of ECS. I attempted to implement something like it in C but based on your example I may have tried to make it too complicated. Not that I am worried about optimization right now, but with the components of the same entity not being next to each other would you lose the cache hit benefit of having all the memory in the same spot?
It's actually meant to be like that. You might have for example a movement system, an enemy AI system, etc. The movement system is gonna act on position and velocity components so you want them to be packed tightly. If your systems only update a specific entity type you lose the benefits of ECSs, where you can compose entities simply by adding components.
if you are on a *nix, you should have sed available. If so , you can put four spaces in your file using this command: $ sed 's/^/ /' source_file.c &gt; file_with _spaces.txt 
Use `offsetof` from `stddef.h`.
I think I might have lost you. If I have position and velocity as components, and they are each in their own array of 250 then those two structures are 250 * x structures apart. So there is a bit of a memory jump that needs to happen to compute values based on those two components. But if they are both in a parent structure than they would be very close or right next to each other.
I'm no expert on this but if you have positions and velocities in two separate arrays the CPU only has to load those two, but if you intermingle them with stuff like transformation matrices and AABBs then the CPU is gonna load that too from RAM which would blow the cache. Might be wrong though.
No offense, but I think you're missing the bigger picture. The same concept can be used to pass an `offset` value to the function, so the function doesn't care about the type and only tests the position according it the data's offset from the root of the type.
Cool! Never knew it was in the standard library :-)
In this case it makes even more sense to have the XY as a property of `Space` rather than a property of `Object` (Player / Monk / Gold). I agree that objects should be aware of their location in space, but I would think that the data should "belong" to the Space itself. For example, `Player` walks to X+1. Here are the two possible ways to test this change: 1. Access `Space` at X+1 and route data to correct event handler... if empty than OK, if Gold than Woohoo and if Monk than f@$k. This is an O(1) operation. This approach requires the knowledge of `Player` position (original X) + an O(1) operation (to access the data in the location X+1) + routing to the correct event (the `if` branches which could be optimized)... ; or 2. Test the location of each and every object in the game to see if it matches X+1. If the objects match, route to the correct event. This approach requires the knowledge of `Player` (original X) + O(n-1) where `n` is the number of objects including the Player + routing to the correct event. This is an O(n) worst case operation (location is empty OR last object tested is at location) and an O(1) best case operation (first object tested fits). Also, the O(n) is more likely than O(1) when using this approach. I hope this example demonstrates how important the `Space` dataset can be and why `pos` doesn't belong to any object... even though objects should be aware of their location, I would recommend, IMHO, that location should be controlled and owned by `Space`. 
Please indent your code with four blanks so it appears readably. Also, please remove the line numbers (or move them as comments to the end of the lines) so we can assemble and run the code.
So how would you get the X and Y of the player? For example to do the X + 1 calculation.
You mean run the C code? I included all my C code in those hastebin links you can copy and paste 
No, I mean run the assembly code. Also, a blank is space, not a `‚ê£`. The `‚ê£` only exists in the submission guide to show you how much space to insert.
Also I can't figure out how to format it, I tried adding ‚ê£‚ê£‚ê£‚ê£ before each line but it doesn't do anything 
Read my other comment. And *READ* the submission guide. Not just blindly copy the example. ‚ê£ is a visualisation of a blank because a blank is hard to see. Instead of `‚ê£` just hit the space bar.
Yeah I did the blank too but it didn't work either, it just leaves it in place 
Ok I put both pieces of assembly into a hastebin https://hastebin.com/picigepuno.erl
Not sure if this is what you mean? https://imgur.com/WHQKQGZ
You need four blanks. Also, the block of code must be separated from the surrounding text with blank lines (one blank line before, one after). So if you tested if this works by just indenting the first line, of course it won't work. In your paste bin, you added the useless extra data from `objdump`. This makes it impossible for me to assemble the code without heavy editing before. Please remove everything but the instructions (and their operands) and translate jump targets into labels as you already did in the post (but there you added line numbers, making it again impossible to assemble).
[Godbolt.org](https://godbolt.org/), a website compiles C/C++ to asm, might help.
Before you removed it, you had copied the assembly code into your post. But yeah, the line numbers in the C code are very annoying, too. I cannot compile and test C code that comes with line numbers. If you want to point out a line, add a comment to that line.
gcc or clang. A compiler that compiled C/C++ to asm might help.
You can use "%x" to receive hex number to int pointer and add it normally then check length then prinf it as hex number by "%x" again.
I'm currently trying to reverse engineer the two functions. Please give me some time to do this.
https://hastebin.com/efezubaxaf.erl https://hastebin.com/taxowocici.pl
The conditions stipulate that you should read the hexadecimal numbers as characters, and store those characters in an array. So it is not correct to try and read integers as you have done by specifying `%d`. You need to read characters and process the characters one at a time. This could either involve `scanf(" %c"` or `getchar()` in a loop; or by reading an entire string with `fgets`, or `scanf("%s"` and then processing each character. The harder part of this assignment is doing the user input and getting the characters stored in memory the way that you want. There are several ways you can store the characters in memory. As a beginner you probably will be feeling lost about how to proceed, but this is normal. You will end up doing *something* for this assignment and once you've finished that you could, as a learning exercise, go back and try doing it another way and compare how you feel about the two approaches. Your array will have 10 entries (or 11), with each entry of the array being one digit in the input. You'll have three of these arrays in total (one each for the input numbers and one for the result). The arrays could either be arrays of `char` holding the characters, or arrays of `int` holding the result of the character converted to a number from 0-15. Once you have got the input working then you basically want to implement the algorithm you would use to add two numbers together with pencil and paper. A possible approach here is to write the program for decimal numbers (base 10), and once it is working, go and modify it to work for base 16. 
Unless you're using C99 VLAs (and you shouldn't) you can't use a variable like `x` for the size of an array. It has to be a compile-time constant. If you want the size to be a variable, you need to allocate the array dynamically (with `malloc()` and friends.) If your function is supposed to populate one struct of an existing array, then it should take a pointer to a struct and fill in the values by dereferencing that pointer. Then you can populate the array by calling the function in a loop, passing it a pointer to each element in the array. Also, you are meant to seed the random number generator once, so seeding it in the function is not going to work. 
Huh. It doesn't work just looping with a `for` loop through the array and assigning directly the result of the function to every member of the array? I think structures can be assigned to directly, so there shouldn't be any problem.
Some useful tips: * write symbolic constants in uppercase * do not use global variables * use %x to read hex from user * you will need &lt;limits.h&gt; to handle integer overflow
You can find my disassembly [here](http://fuz.su/~fuz/files/disassembly). `asm0.c` contains a direct translation of the instructions. Then, I cleaned this up a little and turned goto statements into control structures in `asm1.c`. Last, I removed some noise and introduced a `for` loop replacing the `while` loop in `f2`, yielding `asm2.c`. I hope you can learn from this.
Are you sure there's an exception? `process returned 255` could mean than main is returning 255. 
Show all your code (and not as a screenshot!)
When the program stops responding, if I close it, it will give the crt. If I let it finish them close, it will say 255. Either way, that's not what the output is supposed to look like
is `envp
https://drive.google.com/drive/folders/1s6YwftbBUd0T7xVNej_nuE93sD3c2xLp?usp=sharing
My best guess based on what you've shown is that the assert is failing: assert(list!=NULL); Check to make sure that whatever is being passed to intlist_append hasn't been deleted or freed, and hasn't been set to NULL (or nullptr, or 0). Assuming you're using a debug build, what you describe is I think what will happen. I usually use an IDE and debugger (Visual Studio when using Windows), which will just stop on the actual instruction that has a problem so you can inspect the variables and the call stack and find the problem. 
Pastebin or gist or something else actually intended for code sharing works better.
nah, I don't think that is it. 
you can view the code on google docs
&gt; Edit: I see you have it as part of the player as well. Yes, I think an object should be aware of it's location in space, so it would make sense if the `Space` object and the other objects (`Player`, `Monk`, etc') would all point to the same `position`. I humbly suggest `Space` would be a better candidate to "own" the data and manage it's manipulation, since it would allow `position` to be a "Black Box" controlled by an external module (a Player doesn't usually need to know where they are in the universe, but the "map" should). A Player would say "step forward" and `position` will be aware of it's orientation in space, where "forward" might be and if that move effects an object's position or invokes any event (such as "bump into wall", or "collect gold"). This could get complicated really fast (i.e., where "position" includes "radius" or "shape" etc')... but even on a simplistic XY level it would make sense, IMHO, to move the "position" logic into a separate module that is as object blind as possible. 
&gt; function doesn't care about the type types are good. names are good. Yes, you can dig around in memory and get the data you need. But the power of higher level languages is that you can give names to things and the compiler will check things for you.
take a look at your `intlist_t *intlist_construct(int capacity)` function. Your mallocing multiple lists instead of a list with multiple elements.
What is the output supposed to look like? What does the output look like? The code you linked to is a bunch of unit tests; which one is failing?
@wrelam. Yeah he does know C programming language. Thanks for your advice! 
Thank you @RainbowNowOpen I appreciate the advice! 
Types are great, except when they aren't. In this case, OP doesn't seem to want the function to be type sensitive... so in *this* case, types can be circumvented. I should point out that, IMHO, the design should be reconsidered and objects shouldn't contain the data regarding their position (though they should have a "black box" pointer/handle that connects them to a location in "space". I already wrote this in a different comment, since I think this streamlines interactions in space (such as line of sight, object collisions and space related events).
The first two questions were essentially answered in my main post. The output looks like it is supposed to. It is passing all the checks, but it is 'crashing' That's why I only posted what I did, because I said it was complicated and all bundled together. The one that is failing is the one that it stops on. It is failing when it gets to /* Now attempt to append an integer to a full list.*/ in test_intlist_append(void). What is wrong with sharing it in google docs. Not only is it easy to download and run, you can also just preview it if you don't want to run it. 
Here‚Äôs a little animated cake. `REPS` is the number of flame repetitions; `DELAY` is the spin delay because there‚Äôs no other pure-stdC delay technique‚Äîthis probably needs tweaked, or `hold` can be rewritten for target platform (e.g., `usleep(100)` for Linux). `CLR` is a clear-screen sequence. `LET_THEM_EAT` is a run-length-encoded cake (\1=newline, \2‚Äì\37=space repeated, \177\2‚Äì\37=other repeated, else=literal); `AGNI` is the flame animation; `TAIL` is the final smoke animation. Both of the latter are 3 chars per frame. #include &lt;stdio.h&gt; #ifndef REPS #define REPS 64 #endif #ifndef DELAY #define DELAY 99999999UL #endif #ifdef __unix__ #define CLR "\33[H\33[2J" #else #define CLR "\f" #endif #define R9(x)R8(x)x #define R8(x)R7(x)x #define R7(x)R6(x)x #define R6(x)R5(x)x #define R5(x)R4(x)x #define R4(x)R3(x)x #define R3(x)R2(x)x #define R2(x)x x #define CP1(from, to, i)V((to)[i]=(from)[i]) #define CP3(from, to)do {int z=0;R3((to)[z]=(from)[z];++z;)} while(0) #define V(x)((void)(x)) static const char LET_THEM_EAT[] = R2("\16$ \1")"\16$'_'\1\16.|.\1\16|@|\1\2.\177\13-|@|\177\13-.\1" "./\13:|@|:\13\\.\1|\4HAPPY\4\"^\"\2BIRTHDAY!\2|\1|\\\33/|\1" "| '\177\31-' |\1|x "R4("%\5")"% x|\1| x"R8(" %%")" x |\1" "|"R4("\5%")"\5|\1|+\33+|\1|"R9("\2#")"\2|\1 \\\33/\1\2'\177\31-'\1", AGNI[] = ")\\ )\\\\ )\\ /)//)/) ", TAIL[] = R3(R2("\\ ")"\\ : "R3(" /")" : ")R4(" *")R9(" ")" "; volatile char foo; static void render(char *const *, char *, const char *, unsigned); static void hold(void); int main(void) { static char image[16384]; char *imgref[3], **iq=imgref; char *q=image, c, d; const char *p=LET_THEM_EAT; unsigned long rep=REPS; while(!!(c=*(p++))) { # define qup(x)V(*(q++)=(x)) if(c == 1) qup('\n'); else if(c == '$') *(iq++)=q; else if(c == 127) for(c = *(p++), d = *(p++); c--;) qup(d); else if(c &lt; ' ') while(c--) qup(' '); else qup(c); # undef qup } for(*q='\0', p=AGNI; rep; V(*(p+=3)||((p=AGNI), rep--)), hold()) render(imgref, image, p, 2); CP3(" ", imgref[2]); for(p=TAIL; *p; p+=3, hold()) render(imgref, image, p, 3); return 0; } static void render(char *const *ir, char *i, const char *f, unsigned n) { unsigned m; for(m=0, --n; m &lt; n; m++) CP3(ir[m+1], ir[m]); CP3(f, ir[n]); printf(CLR"%s", i); fflush(stdout); } static void hold(void) { unsigned long delay=DELAY; while(delay--) if(!foo) foo=0; } 
Interesting... I guess C is a tool much in the same way as a hammer is, just meant to handle different tasks... I just need to play around with it I guess and find projects to improve my skills. Truth is I should be thankful in a way this happened as I had to reflect back and reconsider what I wanted out of life.
[removed]
[removed]
Lambda functions are in C++, not C.
I'm on my phone so I can't link to what I'm talking about. The Linux kernel does lists very interestingly, and it might work for you. I think it may be portable C, as well. Look up Linux kernel linked list. Maybe someone else can find a useful link. 
any other suggestions? I'm still pretty stumped
Please don't recommend this as a style to follow. _t is a suffix usually reserved for compiler, the library or the environment to avoid namespace collisions. Using these in your own programs or libraries defeats this purpose. Additionally, typedefs that are masking structs can have nasty implications because the user might miss their size and use them as function parameters/returns, use them with care. The same is true pretty much for the other typefeds as well. If you want to use them as type safeguards it's better to wrap the content in a struct since this will trigger compiler warnings.
C++ is off topic in this subreddit. Please post C++ content elsewhere, e.g. to /r/cpp.
In general? Why? I think when an array size is determined at runtime you simply things with less code. Less opportunity for error IMO. For example, IMO, this is superior: int c = 21; struct S a[c]; To this: int c = 21; struct S *a; a = malloc(c * sizeof(struct S)); ... free(a); No `malloc`. No `free`.
I think I posted it to a wrong place. Sorry. I am new to reddit. I will move it to C++ section soon
The stack is not meant for bulk allocation. It is a limited resource (on the order of a few megabytes, but it could be less depending on OS settings or user preferences), and it's impossible to tell how much you have left; the only way it fails is catastrophically. Letting a runtime variable decide how much stack space to allocate is just asking for trouble.
This is an excellent counter argument. I concede for large array sizes (or poorly constrained/checked sizes, since this is a runtime calc). Solid reminder, thanks.
Skimmed the video briefly. Every single target has a compilation command line written out in full, and lacks a full list of dependencies. So, please don't imitate the style of makefile you see in this video.
Two errors in the code - it should be: char array[1][4]; // #1 array[0][0]='l'; array[0][1]='e'; array[0][2]='x'; array[0][3]='\0'; printf("%s\n",array[0]); // #2 
Ah ok. So what happens if I want to use pointers?
It depends what you mean by "use pointers". Typically pointers are used for dynamically allocated memory.
github.com/bumblebritches57/bitio/commandlineio.c The CommandLineOption struct in particular.
What about: char ***array = malloc(1 * sizeof(char**)); array[0][0]='l'; array[0][1]='e'; array[0][2]='x'; array[0][3]='\0'; printf("%s\n",array[0]); btw thanks so much for helping me dude
No, that's wrong for multiple reasons. Programming by guess-work is not particularly effective - you should really pick [a good introductory C book](http://stackoverflow.com/a/562377/253056) and get a grasp of the basics.
ok thanks
Surely! As long as your tutorial is not an incoherent mess, it won't be removed.
What I was meaning is it okay to have the tutorial on my site, and just a brief introduction and link posted here, I know some sub-reddits are fussy about what they see as "self promotion"...
If it's a good tutorial then I'm pretty sure that's fine. There are a lack of good beginner tutorials for OpenGL aimed at C developers since most tutorials target C++ devs. If you could produce an OpenGL tutorial for C developers I think that would be really useful.
Yes, I understood that intent and my comment applies exactly: As long as your tutorial is not an incoherent mess, it won't be removed.
was this you who wrote this, or were you given an assignment to clean it up?
What your code does is creating a 1x4 matrix of `char**` (pointer to pointer to char), then setting its values on row 0 to... well, definitely not "lex". Remember that char is an integer type, which means that it can be assigned to any other integer type, including, unfortunately, pointers. What is really happening is your character literals are being converted to their ASCII value, which is then interpreted as an address and stored in the array[0][whatever] variable; a pointer to a pointer to a char. So this would mean that, say, cell 108 (ASCII code of 'l') contains a pointer to a char, which is definitely not what you wanted. This is why you shouldn't be using `char **array[1][4]` but only `char array[1][4]`, or actually, `char array[4]`, because having a dimension set to one really makes no sense. Why do you even need that dimension then? Also, I don't see why you are using this syntax to initialize the string. You could just use `char array[] = "lex"`. It will take care of the copy (with every possible optimization) and null-termination for you, and you don't even have to worry about the length.
Turn on compiler warnings :-)
Okay thank you my friend
My apologies for not knowing the jargon, nor am I an experienced programmer, nor is English my primary language. This actually clears up a lot of articles I have read and did not completery understand. Thanks!
Show us what you have and we'll be able to point out where you're going wrong. Put some printf statements between each line and you'll be able to pinpoint where you're going wrong.
A char has a numerical value 'under the hood'. For example, `'A'` has the value of 65. You can test it out by printing it: printf("%d\n", 'A'); // prints 65 printf("%d\n", 'Z'); // prints 90 So using basic maths you can deduct th value of `c` one step at a time.
Have you tried using a debugger? I found this: 0x00007f24f8602935 in test_intlist_append () at main.c:207 // Just before the destroy function is being called (gdb) p list $1 = (intlist_t *) 0x7fffd8f17420 (gdb) p *list $2 = {elems = 0x7fffd8f174d0, capacity = 10, size = 10} // list seems to be valid, values look fine (gdb) s // Step into destroy function intlist_destroy (list=0xd8f17420) at array_list.c:44 (gdb) p list $3 = (intlist_t *) 0xd8f17420 // Where did the 0x7fffd go? (gdb) p *list Cannot access memory at address 0xd8f17420 And when trying to look into the assemby: (from a new debugging session because Windows crashed in the process, so some values are changed, and I am also a bloody noob in x86 assembly) 0x7fec7800292c &lt;test_intlist_append+5598&gt; mov %rbp,%rdi // rdi = rbp // Register dump, AFTER executing the above mov rdi 0xbdc9d5a0 3184121248 // Huh? rbp 0x7fffbdc9d5a0 0x7fffbdc9d5a0 // Looks correct 
Char is essential numbers, and each of the values encapsulated by the '' are also numbers. 1) char c is assigned to the value of 'A', which is the integer 65 2) the value of c (currently 65) is added to the difference of 'Z' - 'A' (90 - 65 = 25) 2a) the value of c is now 90, or 'Z' 3) add the ascii value of a null character to the current value of c. a null character is 0, meaning that c is still equal to 90, or 'Z' 4) subtract the difference between ascii 'z' and 'a' to the current value of c. (122-97 = 35) 4a) the value of char c is 65, or ascii 'A'
Unless you mean that the line `c += ''` is actually meant to be a space, in which the ascii value is 20, and the value of c is 110.
The quiz is telling me 'a' is the answer. Im relieved I had the correct idea in how to get the value of char c, but I'm not ending up at the correct ASCII value for 'a'. Am I misinterpreting a function??
&gt; For a reference you can also check the asciitable site. Or if you're on linux, `man ascii`
To end up with `a`, make sure you're using `c += ' '` and not `c += ''`.
FUCK ME. alright, that makes a lot more sense. Thank you so much!!
TIL... Thanks! 
'a' is the answer because the the line `c += ' '` means that it is adding the numerical value of the ascii space (20). Running through the code onces more: char c; c = 'A'; //c is equal the numerical value of ASCII A, 65 c += ('Z' - 'A'); //take the numerical difference of the two ASCII values (Z and A) and add it to the current value of c // (90 - 65) + 65 = c -----------&gt; c = 90 c += ' '; //similar to the above line, except the value of the space is added to c // 90 + 32 = c -------------------&gt; c = 122 c -= ('z' - 'a') // subtract the value determined by the ascii value of z subtracted from the ascii value of a from c // 122 - (122 - 97) = c ------------&gt; c = 97 
You are a beautiful person! Thank you so much!! 
i like to work in a flatpak environment but you have to check in every change. a better solution is to use git submodules which works quite nicely.
The only thing I edit is the array_list functions
Have tests alongside the library in source control. As you work, build and run the tests as if the tests were a normal application. [Simple example](https://github.com/skeeto/getopt).
Could you elaborate or point to some links?
Assuming you're on Linux have a look at http://man7.org/linux/man-pages/man8/ld.so.8.html There's more than one way load a library, and a few environment variables you can use to load them when they're not in the default library paths.
Don't quite know what to make of this. It's trying to accesss the destroyed list?
I dunno about mac systems... why is this vomit inducting ?
It's just cheeky that Apple is making gcc an alias for clang. It's like, you've been lying to me this whole time, I don't know what to do with my life. 
The (very safe) assumption here is that this code is being run on an ascii machine. For a truly paranoid excercise, you can change `c+=' '` to `c^=' '` to make it both ascii and EBCDIC friendly. 
There's nothing wrong with ‚Äúnot knowing the jargon‚Äù, nor did I mean to imply that there is. I was trying to be helpful by giving you the correct term (which will make it much easier to find what you're looking for) and pointing you to an article that describes several algorithms that do what you want to do.
Generally for debug and release builds during development I have my makefile generate a build directory and direct all output files to there (object files, executable for my unit tests, zipped files, ect.) then just do everything relative to that location. You can see an example of this kind of build process [here](https://github.com/VictorSCushman/EZC/blob/master/makefile) in one of my libraries currently under development. Then generally only when the library is ready for release I build using a target labeled "install" that will require elevated permissions to install in my /usr/local/whatever dirs.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [VictorSCushman/EZC/.../**makefile** (master ‚Üí d34e899)](https://github.com/VictorSCushman/EZC/blob/d34e899c626e12a88d9dd232f615d2529b310698/makefile) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dprut2o.)^.
http://en.cppreference.com/w/c/language/volatile http://en.cppreference.com/w/c/language/restrict A few more type qualifiers you didn't mention: http://en.cppreference.com/w/c/language/atomic http://en.cppreference.com/w/c/language/arithmetic_types#Complex_floating_types (Though I'm not sure if this one actually counts as a qualifier)
There are actually 4; C11 adds `_Atomic`. http://en.cppreference.com/w/c/language/volatile http://en.cppreference.com/w/c/language/restrict http://en.cppreference.com/w/c/language/atomic 
`volatile` means that reads and writes to that variable could have side effects. This is especially useful when interfacing with hardware, where writing to a register might be a command to do something. `volatile` prevents the compiler from reordering or removing reads and writes, otherwise the communication with the hardware would be extremely broken. There are also uses for multithreaded programming. `restrict` means that no other pointer can alias the same memory as this pointer. The easiest example is `memcpy` vs `memmove`. These functions do basically the same thing: take one region of memory and copy it to another region. However, if the two regions overlap, your copy algorithm needs to be chosen very carefully or you can sometimes get surprising results. The parameters to `memcpy` are declared with `restrict`, meaning that there will never be overlap. This lets the implementor choose a faster algorithm and lets the compiler optimize the code better. `memmove` doesn't make this same guarantee (no `restrict` parameters), so it's sometimes slower.
/u/raevnos already told you what's wrong: &gt; Pastebin or gist or something else actually intended for code sharing works better. 
You could try asking in a C++ subreddit.
that isn't telling me what's wrong. I'm asking WHY is looking at code on google docs an issue. It is easier for me to upload the multiple files there. If you don't feel safe downloading the code then you don't have to. I don't understand how pastebin would be more convenient to post multiple files of code. Pastebin is better for text dumps im pretty sure
k
http://flatpak.org/ with Flatpak you can develop in a sandbox environment. There is that thing called flatpak manifest which defines custom libraries and your module to build. So if you have a library in development and stored in a git repository you can define this module as dependency and it get fetched by flatpak-builder automatically. But if you change something in your library you have to check it in. So its not the ideal "write and test" circle. This was my first approach to this problem. Then i thought about it and realized that git submodules is the solution to my problem. I have in an application project my library as a submodule and link statically so i develop library + application independent but use them together. But skeeto already pointed out that you can have both in a directory - works exactly like that. Pro-Tipp: use meson as build system. Its just the best and easiest build system i ever encountered (i wrote automake buildchains in the past)
&gt; Pro-Tipp: use meson as build system. Its just the best and easiest build system i ever encountered (i wrote automake buildchains in the past) How does it compare to CMake+ninja?
way nicer syntax. and its oss. 
So _Complex only works for floating point types, right? I'm going to declare my variables like: float volatile _Atomic const * static restrict volatile const Pointer; People will be confused, I can only try to imagine what the compiler needs to do to make all this happen.
so I should put the keyword restrict into my function declarations whenever possible, to get better optimization by the compiler? This sounds great.
I wouldn't go quite that far. Read and understand [this article](http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html) first. In general, we should probably use `restrict` a lot more than is common. The problem is that this is an extra precondition on the function that users will need to know about: at no point now or in the future can there be aliasing between the given pointers. When this will be natural an obvious, `restrict` should be applied without too much worry. Otherwise, you have to take the specific situation into consideration.
Whenever you see "dynamically allocate an array*, what you *should* be thinking is "use a std::vector". Unfortunately classes like to make things as hard and as bug prone as possible, so don't let you use anything useful.
yeah we've had some discussions with classmates where he states we shouldn't be using vectors (since it will be used in the new course which is object-oriented programming). I was thinking that if I want to copy the first array to another, I want to use pointers, I'm just unsure of where to begin.
Also, another tip: this is a C subreddit, not a C++ one.
thanks, I will go ahead and move it over there and see if I can get assistance.
&gt; yeah we've had some discussions with classmates where he states we shouldn't be using vectors (since it will be used in the new course which is object-oriented programming). C++ -- a language so nice, you have to learn it twice. The first time, doing things the hard way; the second time, what you actually do in the real world. &gt; I was thinking that if I want to copy the first array to another, I want to use pointers, I'm just unsure of where to begin. In C++, pointers can be treated very similarly to arrays. For example, your code has: cin &gt;&gt; *(array_pointer + i); You could have just written: cin &gt;&gt; array_pointer[i]; So take a step back for a second. If you just want to copy two arrays, you can just do something like: for ( int i = 0; i &lt; size; i++ ) array1[i] = array2[i];
If you are interested in getting a job at a AS A developer, C++. Otherwise, C# (for unity) and likely still C++.
Another fantastic video!
Another fantastic video!
oh i thought it was some gcc front end to llvm ! so how does that work don't gcc and clang have different command line options ??
Unfortunately this sub is for questions related to the C language. We don't (necessarily) know anything about C++ exceptions.
I'm not sure about cheeky, just lazy. I think the story goes that some legacy apple code invoked GCC as a compiler directly. Instead of fixing their code, they just made GCC an alias for clang.
errors! errors everywhere! ;) firstly: why u declaring pointer? you r not even using pointers! secondly: array positions start form 0, not 1, therefore, ur code should be like this: printf("%s\n",array[0]); good luck young padawan
Thank you :)
Open a new document in any text editor. Click save as. name.h There you go, you made a header file. Now declare your functions, globals and macros in it. 
Put you .h file in the same directory as your .c file and include it as (note the quotes instead of angle brackets): #include "foo.h"
A header file (.h) is the interface to the functions contained within a source (.c) file. A header file may include something like `int sum(int *list, size_t n);` whereas the source file will contain the actual implementation of the `sum` function. A header file should only contain the things required for a caller to call into the function declared within it. For example, the header file: /* sum.h */ #ifndef SUM_H #define SUM_H #include &lt;stddef.h&gt; /* for size_t used below */ int sum(int *list, size_t n); #endif And a corresponding source file: /* sum.c */ #include "sum.h" int sum(int *list, size_t n) { int sum = 0; while (list &amp;&amp; n--) { sum += *list; list++; } return sum; } Another program may call the sum function, but only if it knows that it exists. It knows about it by including the header file. You must also link the two object files together so that symbol resolution occurs and the final binary actually contains the `sum` function: /* avg.c */ #include &lt;stdio.h&gt; #include "sum.h" int main(void) { int scores[7] = { 90, 100, 84, 79, 83, 93, 97 }; printf("The average score was: %d\n", sum(scores, 7)/7); return 0; } To compile these programs together using gcc and then run them, you would issue the following commands: $ gcc sum.c avg.c -o avg $ ./avg Hopefully that helps demonstrate to you how you would construct a header file as the interface to a function defined in a source file. Let us know if you have more questions.
Just google the answer and compare your code to theirs, you don't have to pay 20 bucks to someone for something this simple.
You really only need `restrict` if you have two or more parameters of the same type to a function. For example: void matrix_mult1(doubie *dest,double *src1,double *src2); void matrix_mult2(double *restrict dest,double *src1,double *src2); The compiler can produce better code for `matrix_multi2()` than for `matrix_mult1()` because the `restrict` keyword in `matrix_mult2()` states that none of the memory pointed to by the pointers overlap with each other, and thus, the compiler can instruction s that reread data. If the types are different: void foo(double *a,int *b); The compiler will assume they memory doesn't overlap. The exception is with `char *` for historical reasons, so: void foobar(char *restrict a,double *restrict b); 
I haven't used clang in a while but iirc clang's UI was designed to be very similar to gcc's UI so the compile flags are very similar.
This is surely an interesting thing to keep my eyes on.
I swear to you if you do this I would love you forever. Well maybe not but you would make me very happy. Especially if you had a fairly simple tutorial on how to do makefiles. Why does the internet have to overcomplicate everything?
&gt; so I should put the keyword restrict into my function declarations whenever possible Don't do it unless you have understood what you are doing. Using `restrict` improperly would open up the gates of hell.
1. I recommend spending some time with [SDL2](https://www.libsdl.org) and some tutorials like [this](http://lazyfoo.net/tutorials/SDL/index.php). You'll be up and 2D-game programming in no time. SDL has all the pieces you need for graphics and sound and input devices and a very nice thing about SDL is it supports many platforms with, essentially, the same C/C++ code: Mac, Windows, Linux, iOS, Android.
HAHAHAHAHH
What did you expect of Apple. But honestly, so many Makefiles etc. hard code gcc as compiler, I can kinda understand this hack. If you want gcc, install it using brew or something like that. Or switch to another OS
&gt; very similar what could possibly go wrong...
Are you implying that cmake or ninja are not open source? They both are.
/u/guynan refer to
No no, wasn't my intention. Meson uses the ninja backend too (because its way faster than make) and can use Visual Studio as backend too. But its got a nice module extension system which leads to extensible syntax additions and everyone can contribute to this. For example the GNOME project uses the gnome module to generate GIR files or compiles Resource files to code.
Thanks for your suggestion @Nerd4code. This sounds really cool! In all honesty, you lost me after "LET THEM EAT" though lol (no coding background) 
Did you do this manually or did you use some tool?
This was done manually.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
That's what you get for teaching people to hardcode gcc in their makefiles.
Thanks for the resource. I've been pushing off learning OpenGL for a while now, and this will give me a good reason to start learning. I'll check out the site in detail when I get home tonight.
&gt; because it shouldn't happen That's not true. If you access memory that has been freed then *anything* can happen. The program might crash immediately, it might crash later, it might appear to be working, it might do something completely different, etc. 
Reading from memory that was freed is undefined behavior. Meaning, there's no guarantee as to what the program will do when you try it. In your case, the computer is still able to access the memory where it used to point -- that memory still exists and still has information in it, and the computer will let you read if you want. As you can imagine, though, this is a bad thing. One technique some people use to guard against this is to always reseat the pointer to `NULL` after freeing, so if you try to access it you'll be dereferencing a null pointer, which usually crashes the program, a better result than reading bad data. (On the other hand, dereferencing a null pointer is also undefined behavior, so this is also a bit dubious.) Also note that if you `free_Animal` sets `a = NULL;`, this only affects the local `a`, not the pointer variable that was passed in. So this technique isn't foolproof at all.
I think you have a misunderstanding about what free() is supposed to do. free() is not guaranteed to destroy the contents of the memory that it freed, although some implementations might do this for debugging purposes. Basically, you have just told your program's memory management subsystem that you are done with that memory and therefore, at some point in the future, it should feel free to recycle it. It has dutifully made a note of that. But then you have violated your agreement and are actually accessing that memory again, you cheater. I'm not 100% sure how valgrind is supposed to behave in this scenario. Are you sure you have configured it to detect using a block of memory after freeing it? See: https://stackoverflow.com/questions/13665076/using-valgrind-to-debug-use-after-free
Thank you. However, please post links as links instead of self posts if possible. This allows users among other things to check for discussions of the same link in other subreddits.
Then how do I NULL it after freeing?
You can pass an `Animal**`, or you can set it in the function that calls `free_Animal`, or you use a macro to free instead of a function. Even after all that, though, this doesn't set any other pointer that points to the same thing. Like I said, it's not foolproof.
Very good. Normally I would suggest to use GLFW, but since you are already making extensive use of the GTK, one viable option is to use GDK (the underlying API of GTK). You won't have to create a OpenGL widget inside the window, you just need to use the `gdk_window_new()`, `gdk_window_create_gl_context()` and companions.
I have had a lot of trouble getting openly running on fedora/windows 10 dual boot. Mainly with my graphics drivers messing up requiring a fresh fedora install. Will running this apt-get screw me over?
Bookmarked
You can use [rand](http://en.cppreference.com/w/c/numeric/random/rand) to get a random number and [switch](http://en.cppreference.com/w/c/language/switch) to decide what to do for each different number
okay would I do that in main or make a function prototype? 
Make a new function for it.
This appears to be an Oregon Trail like game, thus it's probably too much to try to fit into one function that does everything.
Shouldn't the standard be "cc" in Makefiles? Pretty sure Apple did this knowing 99% of Makefiles contain "gcc". I've got a "cc" binary on my High Sierra system, along with faux gcc and clang of course. I'm assuming cc is just a link to clang though. Meh, I use Clang on macOS, Linux, and Windows anyway.
Was trying to give the link some context over the "post and hijack first comment" approach. I'll keep this in mind if I post in any more subreddits. To be honest I posted it as a text thread in r/gtk as well.
Here's a sneak peek of /r/GTK using the [top posts](https://np.reddit.com/r/GTK/top/?sort=top&amp;t=year) of the year! \#1: [Python and GTK+3: How to Create a Right-Click Menu](https://hackeradam17.com/python-and-gtk-3-how-to-create-a-right-click-menu/) | [0 comments](https://np.reddit.com/r/GTK/comments/5ibpvf/python_and_gtk3_how_to_create_a_rightclick_menu/) \#2: [Black window issue](https://np.reddit.com/r/GTK/comments/6nijyd/black_window_issue/) \#3: [Basic question around UI development (Python GTK+ 3)](https://np.reddit.com/r/GTK/comments/6etfh0/basic_question_around_ui_development_python_gtk_3/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Choosing the right window library was the hardest part. Freeglut is simple and works on everything. GLFW is used in the OpenGL Red Book and is the "standard library". And SDL is used in a wide number of games and emulators. GTK offers the option of adding in widgets and sliders which could prove useful later on so I went with that. Ideally it would be great to have some basic rosetta stone examples for all of the libraries. I don't have nearly enough time to tackle something like that.
Fedora uses the yum package library by default, so probably not a good idea to use apt-get. I think the libraries needed for Fedora / Red Hat should look something like this sudo yum install epel-release sudo yum install gtk3-devel mesa-libGL-devel libepoxy-devel libpng-devel This _should_ just install the libraries to your system and not any drivers or anything. But I'm not very familiar with Fedora. So search and ask around if you have any doubts.
RainbowNowOpen, theboxingfox First thanks so much for the info/help ! I think that what you guys told me to do will really help if I do it and I AM motivated ! :D I'm interested in both AAA dev (games like CS:GO or other 3D games that got a scenario and a MORAL &lt;3) BUT especially 2D games like Undertale right now ! So I guess I'll just learn C# and C++ to start off and hopefully become a real and good programmer :D Thanks I won't forget to checkout SDL2 :D !
&gt; GTK offers the option of adding in widgets and sliders which could prove useful later on so I went with that. That's a good point. Beginners could make a good use of that.
Nice. Maybe you could you write a blog or something explaining the basis like starting with assumption of platform abi and how registers and stack maybe used and then deducing the data types and number of locals from that etc. I think many people would be interested in reading that.
You can store your choices into an array and iterate over that to display them. Once displayed, you can prompt the user to choose one and loop until they make a valid choice. The following code is a short example of how you could do this to choose a level like you mentioned: #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; int main(void) { char *options[] = { "Beginner", "Medium", "Advanced" }; size_t nOpts = sizeof(options)/sizeof(options[0]); size_t i = 0; int choice = -1; printf("Choose a level:\n"); for (i = 0; i &lt; nOpts; i++) { printf("[%d] %s\n", i + 1, options[i]); } while (1) { printf("#: "); if (1 != scanf(" %d*", &amp;choice)) { fprintf(stderr, "Please enter a number\n"); scanf("%*s"); continue; } if ((choice &lt; 1) || (choice &gt; nOpts)){ fprintf(stderr, "Invalid choice\n"); continue; } choice--; break; } printf("You chose: %s\n", options[choice]); return 0; } 
Just ran into some thing going wrong trying to package a library...
NULL it before you free, if that's important to you.
X-Post referenced from [/r/programmerhumor](http://np.reddit.com/r/programmerhumor) by /u/Monsaki [Cplusplus is for the weak](http://np.reddit.com/r/ProgrammerHumor/comments/7cye5x/cplusplus_is_for_the_weak/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
To be pedantic it needs to be `(C=C+1,C - 1)`
Also if you have an immutable datructure, it‚Äôs good to use `restrict`, because `const` is not enough proof for a compiler that it won‚Äôt be changed. For instance in int const *ptr = ... int a = ptr[15]; foo(); int b = ptr[15]; the compiler is generally forced to load `ptr[15]` both times because `foo` might have changed the array despite the `const` qualification. If `ptr` was `restrict` and e.g. `a` was a stored in a callee saved register then a single load would suffice because the pointer is not passed to `foo` and it cannot have accessed the pointed to object. And `restrict` qualified pointers *may* alias if none of them are used to write to the underlying object.
I remember this! It's great. I haven't seen a better tutorial for pointers to this day.
&gt; Is there maybe some weird C quirk for return types and void in particular that would cause this setup to function properly? No. It's undefined behavior and you were just lucky. The most likely scenario is that the function put its return value in the designated register and by chance that register was not clobbered in the small gap of time. But again, it's just blind luck. &gt; Furthermore, GCC never warned me about the HandleInput() function's return type difference between the 'int' declaration and the 'void' definition. It can't, because it only sees the header when it compiles the TU containing the call-site, and the header declares it as returning int. It doesn't go looking into a different TU to see the actual definition to double-check. It only considers one TU at a time. 
What is it you don't understand? Linear interpolation or how to implement it?
What most likely happens here is that the return value is passed through function `HandleInput` "by accident". This is possible because x86 and ARM have a clearly defined register which is always used to pass the return value (%rax on x86, and r0 on ARM). The compiler can't complain about the mismatch if you did not include the header file which declares `HandleInput` in FILE 2, and the linker doesn't know about return types (IIRC). minimum example: main.c: #include &lt;stdio.h&gt; #include "test.h" int main(void) { int r = test(); printf("%d\n", r); return 0; } test.h: int test(void); test.c: int internal(void){ return 42; } void test(void) { internal(); } compilation &amp; run output: simon@PHOENIX:~ $ cc -o test.o test.c -c simon@PHOENIX:~ $ cc -o main.o main.c -c simon@PHOENIX:~ $ cc -o main main.o test.o simon@PHOENIX:~ $ ./main 42 Looking at the disassembly of functions test and internal 0000000000400551 &lt;internal&gt;: 400551: 55 push %rbp 400552: 48 89 e5 mov %rsp,%rbp 400555: b8 2a 00 00 00 mov $0x2a,%eax // return 42 in %eax 40055a: 5d pop %rbp 40055b: c3 retq 000000000040055c &lt;test&gt;: 40055c: 55 push %rbp 40055d: 48 89 e5 mov %rsp,%rbp 400560: e8 ec ff ff ff callq 400551 &lt;internal&gt; // after this call %eax is set to 42. 400565: 90 nop 400566: 5d pop %rbp 400567: c3 retq // %eax remains unchanged until function test returns. And function main: 0000000000400526 &lt;main&gt;: 400526: 55 push %rbp 400527: 48 89 e5 mov %rsp,%rbp 40052e: e8 29 00 00 00 callq 40055c &lt;test&gt; // we call test 400539: 89 c6 mov %eax,%esi // we move the return value of test into %esi (2nd argument to printf). 40053b: bf f4 05 40 00 mov $0x4005f4,%edi 400540: b8 00 00 00 00 mov $0x0,%eax 400545: e8 b6 fe ff ff callq 400400 &lt;printf@plt&gt; 40054a: b8 00 00 00 00 mov $0x0,%eax 40054f: c9 leaveq 400550: c3 retq 
Thank you. I see now why I wasn't getting the warnings: I wasn't including that header in the file where it was defined. Had I done so it would have thrown a fit. At any rate, I'd already fixed it before I posted, I just wanted to see if I had accidentally discovered some weird obscure language feature.
I have a rough idea on linear interpolation itself; that is you are assuming that any two distinct points on the data set can be connected with a straight line and then you just use good ol' high school algebra to find the value of f(x) in the x you are interested in. I have absolutely no idea how to implement it in code 'though, especially when the data comes in an array as big as this one.
Damn, I should really add a ‚Äúshitpost‚Äù flair.
Makefiles should just use the `CC` variable. This variable is set by default to some reasonable value, if you don't like this default you can override it. Even CC=gcc is not totally wrong because it can be overridden with `make CC=... foo`. But best would be not to touch `CC` at all in the Makefile.
Assuming that the timepoints in `t` are ordered for a given time `s`, you can find two closest timepoints, i.e. an index `i` such that `t[i]&lt;=s` and `s&lt;t[i+1]`, and than interpolate linearly between `xg[i]` and `xg[i+1]`.
&gt; I wasn't including that header in the file where it was defined. Some coding standards mandate that the _first_ file included in foo.c is foo.h, partly for this reason. It also ensures that everything needed to make foo.h work is itself included in foo.h.
So basically, you want me to write an assembly tutorial? There are so many of these already, I don't see what I can add to them. I don't think a specific text on this subject is needed. If you know how to write assembly programs, this is a reasonably simple task to do. If you don't, it's impossible (except by learning how to program in assembly). I don't see how a separate tutorial would help.
I'm getting an idea of how to code that in my head, but would you be so kind as to give a sample program with those variables so I can imagine it better? Let's say we have ordered pairs (t, xg)= (1, 5), (2, 10), (3, 15), (4, 20) and (5, 25) and I want to find xg at say, 2.2. How would I go about doing that?
If `root` is a pointer, `!root` is the same thing as `root == NULL`. This checks if `root` is a null pointer. If `malloc()` fails, it returns a null pointer, which is why you might think this checks if memory could be allocated (which it does there, but you can use this idiom everywhere).
If `root` is a pointer, `if (root)` passes if `root` *is not `NULL`*, so `if (!root)` means it would execute when `root` *is `NULL`*. It is there to avoid typing `== NULL` or `!= NULL` if you're lazy.
Oh, I finally get it. This was bugging me for a month haha. Thanks!
Well yes, quite some amateur Makefiles are written badly, but the ones of bigger more serious projects usually use CC instead. Even though the Linux kernel does not officially support compilers other than GCC (iirc) uses that so other vendors can try (and do) compile using other compilers. cc is the c compiler by POSIX, it can be a link, a script, whatever but it has to execute the c compiler with some defaults (like c11 for POSIX.2008)
&gt; This is possible because x86 and ARM have a clearly defined register which is always used to pass the return value (%rax on x86, and r0 on ARM). Nitpicking: This is called calling convention and actually is not necessarily specified by the architecture but by the operating system. I don't know any calling convention however that doesn't use the a register family on x86 to return, it just makes sense to use the conventional accumulator register.
so, if as you said the timepoints are at a constant interval, which would be `interval = 1` in your example, the index `i` I mentioned for timepoint `s=2.2` would be calculated by subtracting the first timepoint `t[0]` and dividing by the interval, rounded down: i = (int)((s-t[0])/interval); So in your example `i` is equal to 1. Now the value we want to determine is as far between `xg[i]` and `xg[i+1]` as `s` is between `t[i]` and `t[i+1]`. So to calculate the linear interpolation coefficient we can divide the difference between `s` and `t[i]` by the difference between `t[i+1]` and `t[i]` (which is the interval): c = (s-t[0])/interval and finally the solution from interpolation is as follows: x = xg[i+1]*c + xg[i+1]*(1-c) 
That's true, and I should know that, however because I generally only deal with systems that use the System V ABI, I'm like "yeah x86 return register is %rax" in my mind Looks like ARM has standardized their procedure call conventions at architecture level: the [Procedure Call Standard for the ARM Architecture](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf) specifies r0(and r1-r3) as return registers in section 5.4.
Yep me too, but I'm a TA at our CS department and I'm tutoring courses that deal with assembly and C, so I'm usually that guy to point out things like "a byte ain't guaranteed to be 8 bit" etc. :)
&gt; Furthermore, GCC never warned me about the HandleInput() function's return type difference between the 'int' declaration and the 'void' definition. ~ $ cat blah.c int foo(); void foo() {} ~ $ gcc -c -o blah.o blah.c blah.c:2:6: error: conflicting types for ‚Äòfoo‚Äô void foo() {} ^~~ blah.c:1:5: note: previous declaration of ‚Äòfoo‚Äô was here int foo(); ^~~ Your code shouldn't be compiling at all. Functions ought to be only be declared just once in just one header file. That header ought to be included by the .c file that defines the function as well as by all files that use the function. IMHO the fact that your codebase is structured in a way that doesn't expose bugs like this is, in itself, a bug. In fact, it's a much more serious one, because it results in utterly bizarre behavior that isn't necessarily consistent between environments, including compiler versions, architectures, debug builds, etc. ------------------------ Regarding *why* your code works, it might have something to do with the ABI. (even though it's undefined behavior) Return values in C on x86/x86_64 are put in the eax/rax registers. If `HandleInput()` gets the value it would return from another function and doesn't overwrite it, it might just be left alone in the eax register.
IKR? I flaired the best I could. Sowwy.
1. No, my `interval` will be the step in the data in array `t`. You said that is 0.01s in your case. It has nothing to do with user input. 2. I said that the result of the division needs to be rounded down. Casting to `int`, which is what is happening in this line, accomplishes exactly that. 3. No, not in a sense you are thinking about, see 1. and 4. 4. My `s` will be the current timepoint for a given iteration of the for loop. So assuming `t[0]==0`, `s=i*h`. That's `i` from your code, not from the example from my previous post. I probably should have chosen a better identifier, but hopefully you get the idea.
I don't get it. It's low effort and it's not funny.
It was only declared the one time, I just didn't include the header in the definition file. But yeah, that in itself was an oversight on my part. Otherwise it wouldn't have compiled.
Lesson learned :p
If you pass `-Wmissing-declarations`, GCC will warn you if you provide a function definition without a prototype. That will catch most of these kinds of errors.
Okay.. I guess I'll try to work this out this out tomorrow as I'm sleepy as hell
I've a'ways been fond of Ted Jensen's Tutorial on Pointers and Arrays in C - http://pw1.netcom.com/~tjensen/ptr/
That's not related to programming in C. Please ask this question elsewhere, e.g. on /r/NoStupidQuestions.
&gt; /r/NoStupidQuestions Thanks, wasn't sure where to ask it!
This is nothing to do with function pointers
Just ran this. Cool stuff. Thanks!
Shitpost deleted. :-)
Thanks, I'll add that to my command line.
&gt; I see now why I wasn't getting the warnings: I wasn't including that header in the file where it was defined. There's another warning you can turn on so that any time a definition for an externally visible function is seen without first seeing a prototype or declaration you get a warning. This will flag instances where you forgot to include the header in the implementation file, or when you're accidentally exposing a function that you don't want externally visible. -Wmissing-prototypes Works for clang in both C and C++, and for gcc in C. For C++ gcc uses `-Wmissing-declarations` instead.
Similarly to real life, if you have a pet animal and set it free, then go back to the same place tomorrow, you may find it's still there. But there's also a chance that it's somewhere else.
IRC is such an easy protocol to implement so a library really isn't necessary. Just learn how to use sockets.
Haha nice.
I suggesting reading up on [Fisher-Yates](https://en.wikipedia.org/wiki/Fisher‚ÄìYates_shuffle). Create an array containing the numbers in the range, shuffle the array, then use successive elements from the array.
&gt; Edit: I mean, why negating a struct makes the computer check if there's any memory allocated? The struct is not being negated. The pointer is being negated. There is an important difference between these concepts.
I saw your comment but forgot to thank you aswell. Thanks a lot!
Yeah my pointer and functions basics are still a little green, but I'm beggining to better understand these concepts now. Thanks for the reply!
There is so much wrong with this video. + Why are you using Turbo C++ in 2017? This is a video for absolute beginners and I see no reason to have viewers install legacy software like this. + Why are you writing `void main` with an empty parameter list. **THIS IS WRONG**. The **ONLY** standard way to write the main function is with a return type of int, and a parameter list of void or the usual argc/argv parameters. + Why are you using `clrscr`? I could maybe understand using `getch` for the very first tutorial before introducing a platform independent way to wait for a user keypress, but `clrscr` is not needed. For a first tutorial the viewer (a) should not need to worry about clearing the screen and (b) should not be leaning on platform dependent code. + Why no indenting? There is no reason not to indent the code in main. + In your list of commonly used header files you capitalized the filenames for each header. + Why do you need 7 minutes of video to explain what is essentially a hello world program? This whole video could easily be three to five minutes. How is it that an 8 line program for beginners has 5 (or at least 4 if you don't count the `#include &lt;conio.h&gt;`) lines of errors?
 for(c=0;c&lt;i-1;c++) When you've just written to x[i], which elements does this loop check?
it checks the elements before x[i] to avoid duplicates. for ex if i=5, it goes through i=0 to 4 to check duplicates
What about [klib](https://github.com/attractivechaos/klib)? No C99/C11, no mimics, but type generic and very fast.
Not another one...
&gt; size_t *raw = malloc(2 * sizeof size_t) &gt;... &gt; arr = (void *) &amp;raw[2]; Isn't that almost the definition of undefined behavior? You're dereferencing a unallocated memory. Or did I miss something?
He's relying on sizeof(size_t) being bigger than sizeof(int).
`&amp;raw[2]` is not a dereference. It's is actually okay to create a pointer that points outside allocated memory as well, as long as it's precisely one element past the end of the array; check out *6.5.6/8* from the C11 standard.
Are you sure? Try printing `c` within the loop.
&gt; it goes through i=0 to 4 Does it?
&gt; He's relying on sizeof(size_t) being bigger than sizeof(int). I don't see where in the code that that's true, storage-wise. He is relying on *int* having a lower or identical alignment requirement as *size_t* however, which would cause unaligned stores (and as such undefined behaviour) but a platform where that is true would be very exotic.
What are you expecting to see? What are you actually seeing?
The function printf may choose not to print your string until it fills its buffer, except when it finds a `\n`, in which case it has to print everything it had until then. So, if you want or don't mind having a newline after your string, append an `\n` to the end; if you do, call `fflush(stdout)`.
arr is an `int *`. He's allocating `2 * sizeof(size_t)` bytes to put in it. If int is 4 bytes and size_t is 8, `arr[2]` is within that memory. If they're both the same size, it's not and trying to use that element is undefined.
&gt; He's allocating 2 * sizeof(size_t) bytes for arr to point at. No, he's allocating `2 * sizeof(size_t)` bytes for `size_t *raw` to point at. &gt; If they're both the same size, it's not and trying to use that element is undefined. The code never uses the *arr* pointer without resizing *raw* first.
 raw[2] *is* a dereferencing and then taking the address =&gt; UB. If you do raw + 2 instead, the code becomes valid. However extra care must be taken to ensure proper alignment of the following data.
&gt; `&amp;raw[2]` is dereferencing No, sorry; check out *6.5.3.2* in the C11 standard: The unary &amp; operator yields the address of its operand. [...] If the operand is the result of a unary * operator, neither that operator nor the &amp; operator is evaluated and the result is as if both were omitted 
There are two options: 1. Break the single call to MPI_Gather after the if/else into two separate calls to MPI_Gather within the if and the else. You can pass NULL as the recv_data and related arguments on ranks that are not the master one. 2. You can declare an 'int* ptr;' before the if/else, and within the if/else set it to point to the first element in whatever int array that process will be sending, then call MPI_Gather using 'ptr'. Also, you may want to think about are using MPI_IN_PLACE if the message is large.
Dang. Every time I think I know what I'm talking about, I don't. Dammit C, y u so difficult? I did no know about that If the operand is the result of a unary * operator, neither that operator nor the &amp; operator is evaluated and the result is as if both were omitted part.
What that guy said. Much like any other protocol, you just need to speak over the sockets to the server. You could probably look at popular IRC clients however, to get a grasp on how to responsibly organize your IRC spec related code.
The text at the top says argc is 4, yet you're dereferencing argv[4], which is NULL
Thank you for the response. If I'm going with option 1...would it look something like this if(myid == 0){ //initialize array size and random number range //send data to workers MPI_Gather(some_local_array, N, MPI_INT, big_list, N * world_size, MPI_INT, 0, MPI_COMM_WORLD); } else { MPI_Gather(some_local_array, N, MPI_INT, NULL, 0, NULL, 0, MPI_COMM_WORLD); //workers generate their lists and assign to some_local_array }
VAI CORINTHIANS
What is that?
So, what should I change?
You need to give your program another parameter on the command line. But without seeing the program, input and output, it's impossible to tell whether that's the cause of the crash or whether you have another bug
First, you need to figure out how to break this problem into smaller, more manageable, pieces. It looks like you have a few different pieces of data: * Day * Distance Traveled * Distance to next destination * Supplies (gold, food) * People (name, status) * Actions (fish, rest, continue) You also need a way to modify and present this information. Some pieces of data can be stored in the provided data types (e.g. `int`), while others are a collection of data which can be stored in a structure. You can then use functions to perform specific actions on the data (update the day, calculate distance remaining, introduce random events), in addition to functions which interface with the user (display current traveler status, prompt for an action to take). The following is an example of how you could store and display the status for an individual person: #define MAX_NAME_LEN (50) #define MAX_STAT_LEN (20) struct person { char name[MAX_NAME_LEN]; char status[MAX_STAT_LEN]; }; void displayPerson(struct person p) { printf("%s: %s\n", p.name, p.status); } Go through your other pieces of data and break up your problem into small pieces which you can combine together to achieve your overall result. 
I don't want you to do anything. I'm just suggesting that converting assembly to C manually is something people would be interested in reading. If you know to write assembly you don't necessarily know how to convert assembly to C.
Maybe the C Puzzle Book?
Hi, this is what I added to my code for the linear interpolation: if(fmod(tn, 0.01) != 0) { index = ((tn-t[0])/0.01); a = (tn-t[index])/0.01; xg[i] = xg[i+1]*a + xg[i]*(1-a); } I added it directly below the main for-loop I use for the RK4 part, before the lines solving for k1, l1, and so on. The variable 'tn' is the current timepoint for the nth iteration of the loop, so I just substituted it for s in your sample code. When I tested it the values of all the k and l variables (which are dependent on xg[i]) varied from the original before I added these lines. Can you please tell me if what I did is right? Here's the entire for-loop for analysis: for(i=0; i&lt;=timeinterval/h; i++) { if(fmod(tn, 0.01) != 0) { index = ((tn-t[0])/0.01); a = (tn-t[index])/0.01; xg[i] = xg[i+1]*a + xg[i]*(1-a); } k1= h * (yn); l1= h * (-0.1*yn - 0.3*xn - xg[i]); k2= h * (yn + 0.5*l1); l2= h * (-0.1*(yn + 0.5*l1) - 0.3*(xn + 0.5*k1) - xg[i]); k3= h * (yn + 0.5*l2); l3= h * (-0.1*(yn + 0.5*l2) - 0.3*(xn + 0.5*k2) - xg[i]); k4= h * (yn + l3); l4= h * (-0.1*(yn + l3) - 0.3*(xn + k3) - xg[i]); xnp1= xn + (k1 + 2.0*(k2+k3) + k4)/6.0; ynp1= yn + (l1 + 2.0*(l2+l3) + l4)/6.0; tnp1=tn+h; fprintf(Results, "%d\t%0.3lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t%0.11lf\t\n", i, tn, xn, k1, k2, k3, k4, yn, l1, l2, l3, l4); tn=tnp1; xn=xnp1; yn=ynp1; }
Switches exit as soon as a case is complete. So if ```playerOneCharacter``` is either ```X``` or ```O``` nothing in ```default``` would be executed. If default IS executed the printf should work. 
Sounds like you're looking for [`offsetof`](http://man7.org/linux/man-pages/man3/offsetof.3.html).
Ya that‚Äôs what I thought but once I execute the default the printed does not execute 
??? This is so basic even I can understand it (and even I wouldn't do it this way)
Looks like you forgot to include ```&lt;stdio.h&gt;```
You have to store the return value from the function into store `sum = summ(arr,n,m,sum)` This is because when you pass the variable by value, the function makes its own copy which does not affect `sum` in the main loop. Also this is C++ not C. And most importantly do not use exceptions as flow control.
Raycaster
Um... Have you heard of fopen()?
Are you asking how to write things to a file?
Thanks! I used the exceptions because it was a requirement for the particular question I solved. 
More so how do I take my print function, put it in another file in the project, and then have it print from there? Here's the sample problem I'm following: The printout function should now print out to output-data.txt . Take out all code that prints to screen Write a second program (i.e., NOT a function in the first program!) that reads the data from output-data.txt and prints it out to screen. 
Write a program that opens the file the first one created, reads from it and prints to stdout.
- New function alert: You should be using `reallocarray` to prevent from UB via multiplication overflows. - No error handling? - doubling the capacity might not be optimal.
Have a look at fopen, fprintf and fscanf. Oh and fclose.
1. Whenever you have a problem then try to reduce your program tou the smallest one that shows your problem. Apperently you already checked that that your function did correctly calculate the sum and therefore the array was read in correctly. So you can reduce the program to the following (my C++ knowledge is very limited so I hope I do not make an error): #include &lt;iostream&gt; using namespace std; int summ(int); int main() {sum=0; summ(sum); cout&lt;&lt;sum&lt;&lt;endl; } int summ(int add) { add=1; return add; } I you run this you will see that it does not what you expect. So this is the program that you should analyse. Maybe now it is clear that you have a problem with how functions return values and you should inform you in your C++ material about that. And this is the program you should post here. 2. It is better to post code here and not post a link to the code. You have to put for blanks in front of each code line so that the code is formatted as code. 3. If you compile the program I would assume that you get warnings. You should take these warning seriously then you may be able to find this error without begging for help here. 4. You have defined `int main()` as a function that returns an `in` but you don't. But I think you should (again: my C++ knowledge is very limited os I am not sure about that). Maybe your compiler gives a warning, too
ProjectEuler
Your question needs to be more specific about which part your're having trouble with, and you should cut down your code snippet to demonstrate just the problem you're having. See http://www.catb.org/esr/faqs/smart-questions.html for more tips.
Here's some lists that give you a few ideas on what you can try implementing: http://lsreg.ru/wp-content/uploads/2014/07/1402842485243.png http://liquidthink.net/uploads/2014/12/a6fN92L1.jpg http://i.imgur.com/8yhYqfq.png Note that there are some duplicates here and there.
Thanks
Isn't `reallocarray` OpenBSD specific?
Originally, yes. But it recently landed in [GLIBC 2.26](https://sourceware.org/ml/libc-alpha/2017-08/msg00010.html).
The wifi authentication scheme? There's wpa_supplicant, but I don't know if that has a library interface to go along with the program.
I don't remember much about RK4, but I wouldn't overwrite the value of `xg[i]` inside the if. Instead of I would store the result in some new variable and use it instead of `xg[i]` in all the formulas below.
I'm a little confused by how the term "counting" is used. Are you looking for a Russian Roulette style of elimination, where you look over each person with a random chance for them to die? Or do you only care about the result where one person each round is definitely going to be eliminated? In both cases, it looks like the goal is to have some kind of random chance, so it depends on how you use the ```rand()``` function. The simplest option would likely be ```rand() % n```, where n represents the number of remaining persons left, until you only have one. The next step is then how you track who is where.
Mostly this. Or you could be really dirty and just take advantage of the command line. $ ./a.out &gt; output-data.txt 
This is what I have came up with so far, and I think it's finally working after multiple test runs. However the only way to know for sure is to try to solve for the exact/analytical solution and compare that with the results here //main for-loop for actual solution and printing of results for(i=0; i&lt;=timeinterval/h; i++) { interval = t[i+1] - t[i]; //linear interpolation if((fmod(tn,interval)!=0) &amp;&amp; (fmod(tn,h)!=0)) { int index = (int)floor((tn-t[0])/interval); a = ((tn-t[index])/interval); x = xg[index+1]*a + xg[index]*(1-a); xg[i] = x; } else { xg[i] = xg[i]; } //RK4 k1 = h * (yn); l1 = h * (-0.1*yn - 0.3*xn - xg[i]); k2 = h * (yn + 0.5*l1); l2 = h * (-0.1*(yn + 0.5*l1) - 0.3*(xn + 0.5*k1) - xg[i]); k3 = h * (yn + 0.5*l2); l3 = h * (-0.1*(yn + 0.5*l2) - 0.3*(xn + 0.5*k2) - xg[i]); k4 = h * (yn + l3); l4 = h * (-0.1*(yn + l3) - 0.3*(xn + k3) - xg[i]); xnp1 = xn + (k1 + 2.0*(k2+k3) + k4)/6.0; ynp1 = yn + (l1 + 2.0*(l2+l3) + l4)/6.0; tnp1 = tn+h; //printing of results per iteration fprintf(Results, "%d\t%0.3lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t\n", i, tn, xn, k1, k2, k3, k4, yn, l1, l2, l3, l4); tn = tnp1; xn = xnp1; yn = ynp1; }
The term counting is constant for each round. If you began counting from a then b then c. Then b is eliminated on that round, on the next round you start from a again (if he is alive ofc) but let's assume he's dead that time so you just start from where the next person is (in this case b) And no the game is not a Russian Roulette style of elimination where it is all random. There is a pattern in the algorithm. P.S. Some colleague mentioned this problem a day before and said that it sounds fun until now we haven't come up with a solution yet. I'm just sharing this algorithm/problem to anyone also interested or who wants a bit of challenge
I was thinking about something more along the lines of: for(i=0; i&lt;=timeinterval/h; i++) { interval = t[i+1] - t[i]; //linear interpolation int index = (int)floor((tn-t[0])/interval); a = ((tn-t[index])/interval); x = xg[index+1]*a + xg[index]*(1-a); //RK4 k1 = h * (yn); l1 = h * (-0.1*yn - 0.3*xn - x); k2 = h * (yn + 0.5*l1); l2 = h * (-0.1*(yn + 0.5*l1) - 0.3*(xn + 0.5*k1) - x); k3 = h * (yn + 0.5*l2); l3 = h * (-0.1*(yn + 0.5*l2) - 0.3*(xn + 0.5*k2) - x); k4 = h * (yn + l3); l4 = h * (-0.1*(yn + l3) - 0.3*(xn + k3) - x); xnp1 = xn + (k1 + 2.0*(k2+k3) + k4)/6.0; ynp1 = yn + (l1 + 2.0*(l2+l3) + l4)/6.0; tnp1 = tn+h; //printing of results per iteration fprintf(Results, "%d\t%0.3lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t%0.12lf\t\n", i, tn, xn, k1, k2, k3, k4, yn, l1, l2, l3, l4); tn = tnp1; xn = xnp1; yn = ynp1; } since array `xg` is your data and that probably shouldn't change, as it might be useful in further iterations. Also the if is not really necessary, since the interpolation will work correctly even if `a` exactly 0 or 1.
I think you just want she'll input redirection. ./a.out &gt; myFile
Pick some of the harder challenges from r/dailyprogrammer.
I am trying to write a script to guess all the possible passwords.
Okay, so you're suggesting that I do interpolation on all the data points? Even for xg[i] values with a corresponding t[i] value on the data?
&gt; free(ch); &gt; free(ch); ÔΩïÔΩéÔΩÑÔΩÖÔΩÜÔΩâÔΩéÔΩÖÔΩÑ ÔΩÇÔΩÖÔΩàÔΩÅÔΩñÔΩâÔΩèÔΩïÔΩí If you really want to free a pointer twice, set it to NULL directly after each *free()*. &gt; I'm pretty sure that calling free on already freed pointer should be punished by death *SIGSEGV* is not a "punishment" and is never (in practice) created by purpose; it's a result of a function making decisions based on garbage memory resulting in an access outside of what's mapped into the program. 
Well I really don't want to deallocate memory more than once, this was just minimal example. So is there any option to set, so linux memory managment would by default kill program when he does this?
&gt; Well I really don't want to deallocate memory more than once Then write a data structure that doesn't? If you want it to crash for debugging purposes, run the code with e.g. valgrind. &gt; So is there any option to set, so linux memory managment would by default kill program when he does this? Set the environment variable MALLOC_CHECK_ to 2.
Yes. The results will be the same, the code is simpler, and it might actually be faster than having divergent code execution.
&gt; Set the environment variable MALLOC_CHECK_ to 2. Does perfectly what I need. I'm using valgrind too, but usually just to check if I freed everything what I allocated, so I guess I will have to work on that. Thank you very much.
Maybe something like this. Use a struct array to track name and state. The loop over the array until there is only one person standing. If a person is already dead, step is not incremented. From the people left over, the person that reaches the maximum step number is eliminated, and the 'game' continues to the next round. #include &lt;stdio.h&gt; #define GROUP_SIZE 6 #define STEP_SIZE 7 struct Person { char dead; char name; }; int main() { struct Person people[GROUP_SIZE]; int i, p, step, round; char name, last_person; p = -1; step = 0; round = 0; name = 'a'; for(i = 0; i &lt; GROUP_SIZE; i++) { people[i].dead = 0; people[i].name = name++; } while(round &lt; GROUP_SIZE - 1) { p++; if(p == GROUP_SIZE) { p = 0; } if(people[p].dead) { continue; } if(step == 0) { printf("Starting round: %d\n", round); printf("--------------------\n"); } step++; printf("Person: '%c' Count: %d\n", people[p].name, step); if(step == STEP_SIZE) { printf("Person %c is now dead, starting next round\n\n", people[p].name); people[p].dead = 1; round++; step = 0; } } printf("-----------------\n"); printf("The Nonary game has concluded\n"); for(i = 0; i &lt; GROUP_SIZE; i++) { if(people[i].dead) { continue; } printf("Person %c is the winner.\n", people[i].name); break; } }
Please don't post these.
C++ is off topic in this subreddit. Please post C++ questions elsewhere.
Yes. That's my bad, sorry. I couldn't find the C++ subreddit at the time of posting the question. 
A soccer team that just won the Brazilian national championship cup! haha Ronaldo`s Soccer Team
Both C++ and C# are off topic in this subreddit. Please post this elsewhere.
Try /r/cpp_questions. Don't just post in the wrong subreddit, that's really shitty.
I haven't watched sports since I was 6, so I wouldn't know haha
wow thank you so much. This gave me a new idea on how to tackle it. I'll compare it to my solution when I wake up. Cause it's now very late where I live 
Case of mistaken identity. I assure you it won't happen again. 
haha...
That exists? Thank god! Thanks so much.
Also, since it's undefined behavior, it's possible (and acceptable) that the implementation detects it as double free and simply does nothing.
The binary bomb lab
I tried your suggestion, and wow it actually works. May I ask why exactly it works? 'Cuz I'm having a bit of a hard time understanding it by myself
The code is doing front insertion. If the head is NULL then the code sets the temporary node to the head and makes it point to NULL. Otherwise it makes the temporary node point to the head and then moves the head up one by assigning it to temp. It might help if you draw it out on paper.
This is inserting new nodes to the front of the list, so when temp is created, its next ptr is set to point at the old list (head) and head is set to the new node (temp, which now also includes the rest of the list). Say you want to add the values 1, 2, 3, and 4 to a list. This is what the list will end up like: 4, 3, 2, 1 So head will be 4, 3, 2, 1. Now lets add another value, say 5. Create temp with the value 5, then point temp-&gt;next at the rest of the list (head) and temp will look like 5, 4, 3, 2, 1, while head still points at 4. Adjust head to point at the front of the list (head = temp) and now head is correct.
+1 for setting to NULL after freeing you can always wrap it in a function or macro to save typing...
Your professor made is needlessly complicated. The entire `if` statement isn't needed. You just need the else part: temp-&gt;next = *head; /* Newly created note points to the first node */ *head = temp; /* First node is now the newly created node */ If `*head` is `NULL`, it is assigned to `temp-&gt;next` because `temp-&gt;next` points to the first node, which doesn't exist (`NULL`), so rightfully a `NULL` is put there. Then the `*head` is overwritten to `temp` to make `temp` the first node. (In your professors code (the if block) just swapped the statements and put an explicit `NULL` there than a more implicit `*head`) If `*head` is not `NULL`, it is assigned to `temp-&gt;next` because `temp-&gt;next` points to the first node, which exists (not `NULL`), so rightfully the pointer to the first node is put there. Then the `*head` is overwritten to `temp` to make `temp` the first node.
Any behaviour is plausible under undefined behaviour. Better to hope for a seg fault, but it‚Äôs not certain.
Thanks, I see it now. I thought that's what he was doing, but I just couldn't visualize it in my head.
Glad I could help!
can you share code snippet for which you are getting above error?
That was over 20 days ago and I am fairly sure it was "hello world" or similar. 
I'm not sure I understand your question, but the data you have is a discrete sampling of a function. Array `t` is the sampling of the domain of the function - time - and corresponding elements in `xg` are the values (acceleration). So if you take a look at my MS Paint [drawing](http://i.imgur.com/yQQpAZ9.png) what you have are the red dots. Now if you want to approximate a continuous function based on those points, you need to be able to determine the value of the function at any point on the time axis, not only those that are sampled. We can do that by basically connecting the points with line segments (blue lines on my drawing). That creates a continuous piecewise linear function, which we can use. So for any point on time axis the value of the function is the height of the blue line directly above that point, which we calculate using linear interpolation.
ok 
I think I finally understand now. Thank you so much! I learned so much from you and from figuring out this seemingly little problem
Your professor is complicating things way more than necessary. IMHO, this is how you should front insert a linked list. IMHO, you should always pass the address of your head pointer (so a pointer-to-a-pointer) so that it can be modified by the insertion function. This also makes the case of an empty list (where `head==NULL`) easy to handle without any branches. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct node { void *data; struct node *next; }; void front_insert(struct node **n, void *data) { struct node *newnode = malloc(sizeof(*newnode)); newnode-&gt;next = *n; newnode-&gt;data = data; *n = newnode; } int main(int argc, char *argv[]) { struct node *head = NULL; front_insert(&amp;head, "THIS"); front_insert(&amp;head, "IS"); front_insert(&amp;head, "A"); front_insert(&amp;head, "TEST"); for (struct node *cur = head; cur != NULL; cur = cur-&gt;next) { char *v = cur-&gt;data; printf("%s\n", v); } } 
Line 2... ouch
When you test changes, run your program through valgrind or compile with `-fsanitize=address`. That'll catch memory related errors right away so you don't commit something like this.
Why are you using `exit(-1)` in this place when you `return -1` in other places? if(!ogl_LoadFunctions()) { printf("extention loader fubar\n"); exit(-1); // &lt;------ }
reasons - its code thats not all been written at the same time... both will call the atexit handlers so not really much odds
A complete example, and sample input and expected vs actual output would be useful.
Ok, just edited the original post. Thanks!
By complete example program, I mean something we can compile and run ourselves.
Also, multiplying a 10x5 matrix by its 5x10 transposed version should result in a 10x10 matrix. You're multiplying the transposed one by the original to get 5x5. The order of arguments to your function should probably reflect that. Order matters in matrix multiplication, unlike scalar.
Why are you using CamelCase instead of snake_case in a C environment? 
I think it really comes down to personal preference, but I still prefer snake case. 
Here's a matrix multiplication function with some sanity checks, without that pointless initialization to 0 that yours does, clearer variables names, etc: #include &lt;stdio.h&gt; #include &lt;assert.h&gt; void mat_mul(int res_rows, int res_cols, int res[restrict][res_cols], int a_rows, int a_cols, const int a[][a_cols], int b_rows, int b_cols, const int b[][b_cols]) { assert(a_cols == b_rows); assert(res_rows == a_rows); assert(res_cols == b_cols); for (int i = 0; i &lt; a_rows; i += 1) { for (int j = 0; j &lt; b_cols; j += 1) { int sum = 0; for (int k = 0; k &lt; b_rows; k += 1) sum += a[i][k] * b[k][j]; res[i][j] = sum; } } } int main(void) { int result[5][5]; int a[10][5] = { {1,0,1,0,1}, {0,0,1,1,1}, {1,0,0,0,0}, {0,1,1,0,1}, {0,0,0,0,0}, {1,1,0,0,0}, {0,0,1,0,1}, {0,1,0,1,0}, {1,0,1,0,1}, {0,0,0,1,0} }; int atrans[5][10]; for (int i = 0; i &lt; 10; i += 1) for (int j = 0; j &lt; 5; j += 1) atrans[j][i] = a[i][j]; mat_mul(5, 5, result, 5, 10, atrans, 10, 5, a); for (int i = 0; i &lt; 5; i += 1) { for (int j = 0; j &lt; 5; j += 1) printf("%d ", result[i][j]); putchar('\n'); } return 0; } It produces the correct result. There's one key difference in the logic between it and yours that I already alluded to as being a possible problem. Turns out it was.
try using something like electric fence.
Interesting! This is fine and consistent with C's lack of protection, but upon seeing this macro: #define ARRAY_SIZE(ARR) (*((size_t *) ARR - 2)) My first thought was, oh god, don't ever accidentally use `ARRAY_SIZE` on a regular C array! (Because of the deref of memory two elements *before* the given "array". Personally, I'd prefix your `ARRAY_` macros with something "safer"/unique like `DYNARRAY_` to remind you what you're working with is not your grandfather's array. :-) Still, it's a neat idea and easy-to-read implementation. Thanks!
Is `&amp;raw[2]` guaranteed to have the correct alignment for whatever type you want your array to have?
https://www.reddit.com/r/C_Programming/comments/7d7n7e/c99c11_dynamic_array_that_mimics_cs_stdvector/dpvvn3t/ If you want a more battle tested code I suggest https://github.com/nothings/stb/blob/master/stretchy_buffer.h 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nothings/stb/.../**stretchy_buffer.h** (master ‚Üí 9d9f75e)](https://github.com/nothings/stb/blob/9d9f75eb682dd98b34de08bb5c489c6c561c9fa6/stretchy_buffer.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpy2i9z.)^.
I know `&amp;raw[2]` is not UB. My question is about alignment. The article claims that you can use it with any data type, and uses `&amp;raw[2]` to store the first of the items. I know that `malloc(n * sizeof(some_data_type))` is guaranteed to have the correct alignment for `some_data_type`. But I don't know if `((size_t *) malloc(2 * sizeof(size_t) + n * sizeof(some_data_type))) + 2` does have the same guarantees for `some_data_type`.
wHy wOuLd yOu tHiNk iTs eVeN iMpOrTaNt
&gt; no C++! here, have a gold.
Put 4 spaces in front of each line to format code for Reddit. if (mString[StringLength] =='e'&amp;&amp;'E') This will always be true. Is that what you want? 
thanks for the formatting help
You have more `}` than `{` How is this compiling?
are you sure? I am pretty sure they are equal and close every open braket
I dont change stringLength after it is entered
There's one after `gets` that is matched with the one at the beginning of main. meaning the `while` is outside a function
ah, yes i see. I deleted that and still get no output
 (eCounter = 0; eCounter &lt;= 1000; eCounter++) Is this meant to be a `for` loop? printf("Frequency of e character: %s\n", mString + 'e' Frequency); This won't compile either.
But when it was there the program couldn't compile. And see my other comment. You're getting compilation errors. Whatever you're running, it isn't this program.
oops, the added "+'e' frequency" was meant to be deleted and yes that is supposed to be a for loop as my ecounter is already being initialized to 0
I think he means to put if ((mString[StringLength] =='e') || (mString[StringLength] == 'E')) To increment the e counter 
I like you. I try to use snek case for my personal internal shit, but if it is going to be used with other camel case shit, yeah I'm gonna grab for consistency.
Could you tell us the steps you‚Äôre taking to compile this? Cause, not trying to be a dick, but there‚Äôs many syntax errors so it simply should fail at compilation
AFAIK it should work, try it with a datatype that will (probably) include padding (e.g. a struct of 3 ints and one double, on x86_64 this takes 24 bytes instead of 20 bytes). 
Okay, but it's not. There's no `for` that proceeds it.
Any luck?
/r/DoMyHomework is thataway
I'm kinda curious, why do you need to read the whole input into array? Isn't is sufficient to read input char by char using __getc()__ , compare it with "e" || "E", and have separate counter to have total count of letters?
Note that `exit(-1)` is almost certainly wrong. That's equal to `exit(255)` on most systems which is not idiomatic. Do `exit(EXIT_FAILURE)` in case of error or make up your own convention, but don't just `exit(-1)`. That's against all conventions and indicates that you haven't understood the difference between the system call convention and the exit code convention.
https://www.codewars.com/
&gt; Why are you using CamelCase instead of snake_case in a C environment? &gt; CamelCase &gt; C That isn't camelCase it's PascalCase. 
You can't return an array from a function. Instead, allocate the array in the caller and pass it to the function: void convert(char destination[], int source) { ... } Note that `destination` is actually a pointer here but you can use it as if it was an array. This is one of C's special rules. If you pass an array, a pointer to its first element is passed instead which is the right thing.
If you want to know what you did wrong you have to post code. You can't pass an array or return an array, you can only pass or return a pointer. And you have to be aware of the lifetime of the object that that pointer points to. If a function is going to return a pointer, the thing it points to has to have a lifetime that survives the function; that means you can't return a pointer to a local variable. In practice, that means that either the function dynamically allocates on the heap and returns a pointer (and the caller is responsible for freeing), or the caller passes a pointer to an existing allocation and the function does not allocate anything. The later is almost always preferable, because it moves the responsibility for deciding how to allocate from the callee to the caller, and the caller usually has much better information on what is appropriate. That is why you find very few functions in the standard library that allocate. 
i've edited to include code
You're not passing or returning any pointers. And you're ignoring the return value anyway, so it wouldn't matter. You're only allocating an array of size 10 so the most likely reason for a crash is that you're dealing with a number that is larger than 2^(10) or 1024, which causes you to access the array out of bounds. Also, `NULL` is a pointer value and writing `binary[NULL]` is semantically wrong, but it may compile because `NULL` is sometimes interchangeable with the literal `0`. But returning the zero'th value of the array is still nonsense, particularly since you aren't even using the return value anyway. The function should either print something, and not return anything; or it should return something and not print anything. Doing both is confusing. 
anything none zero.... its really, really not that important... yes its supposed to be 0-255 but so what.... ya don't get so much as a warning for -1...
This is the best way IMHO. But..... If you really want to return an array very badly, then you can malloc the memory inside the function. You must free the memory outside of the function though, or your going to get memory leaks.
The corresponding Bachelor thesis can be found [here](https://opus4.kobv.de/opus4-zib/frontdoor/index/index/docId/6558).
I think it does, but you aren't printing the frequency, but rather the string.
&gt; That isn't camelCase it's PascalCase. üòÇ True... but even worse IMHO.
It looks as if your `StringLength++` is also outside of the while loop so it's never exiting. Also, based on the prompt it looks as if your teacher is expecting output in the from of `12.708%`, so you may want to look at how you can do that (look into the `%f` format specifier for `printf` and it should give you tips on a data type to use to achieve this, and a way of printing it)
There's a couple of problems. First as /u/shinmai_rookie has pointed out, you're not printing out the frequency anywhere in your code. Another (more serious) problem is that `StringLength++` is outside of the `while` loop, so it will loop infinitely. Move it inside the loop and it should work OK (along with changing your `printf` statement to print out the frequency). A more subtle problem is that `StringLength` will end up being not exactly the right length. I'll leave that for you to figure out why.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main () { char mString[1000]; int StringLength=0; //position variable int eCounter=0; //counting variable int Frequency; printf("Enter a string: "); fgets(mString,1000,stdin); while(mString[StringLength] != '\0') { if (mString[StringLength] =='e'|| mString[StringLength]=='E')//OR STATEMENT eCounter++;//eCounter increments inside if statement StringLength++; } Frequency = ((double) eCounter/StringLength) * 100; printf("Frequency of e character: %i\n",Frequency); } so now with this code i can print a frequency but im not able to typecast the frequency equation so int can become a double , is the frequency equation in the wrong location should it be inside brackets or do I need to change the equation itself?
What does it mean to use ‚Äúonly &lt;stdio.h&gt;?‚Äù What exactly are we not allowed to use? Also, what does ‚Äúcollect the numbers‚Äù mean?
Not allowed to use strings or arrays
Also by inputting a string like abc5s3 and it to print 5 3
So, how are you supposed to collect numbers from a string without using strings? That doesn't make any sense.
I think you misunderstand the assignment as assigned by your professor. You can't work on a string without using strings. He almost certainly didn't want you to use the string library (string.h). I suggest you pop into the profs office hours for a clarification. 
 int Frequency; /* ... */ Frequency = ((double) eCounter/StringLength) * 100; You've defined `Frequency` as an integer, and yet you tried to save a `double` onto it, that is implicitly converted to an integer. Just change the type of `Frequency` to `double`. Don't forget to change the `printf` to accept an `float`/`double` using `%f` than `%i`.
Call `fflush(stdout)` between `printf()` and `scanf()`. And for the love of all that's holy, **insert four spaces at the start of each line**.
Ok, so this worked for the supplied input values I provided. For the second inputs, it returns incorrect values again. Those values are: 25 8 1 0 1 0 0 1 0 0 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 0 0 0 0 0 1 0 1 1 1 0 1 0 0 1 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 1 1 0 0 1 1 0 0 1 0 0 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 1 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 1 0 1 1 1 0 0 0 1 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 any ideas? Thank you by the way!
Header file (10P.h): #define MAX_ROW 25 #define MAX_COLUMN 10 void read_data(char filename[], int array[][MAX_COLUMN], int *num_rows, int *num_columns); void print_matrix(int array[][MAX_COLUMN], int num_rows, int num_columns); void compute_transpose_matrix(int array[][MAX_COLUMN], int num_rows, int num_columns, int transpose_array[][MAX_COLUMN]); void matrix_multiply(int array[][MAX_COLUMN], int transpose_array[][MAX_COLUMN], int num_rows, int num_columns, int transpose_columns, int product_matrix[][MAX_COLUMN]); Functions file: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "10P.h" /*=======================================================*/ /* Function read_data reads the data into the integer array for each */ /* input argument. */ /* Input arguments: filename - input file name (char string) */ /* array - 2D array of integers */ /* Output arguments: *num_rows - number of rows in the 2D array */ /* *num_columns - number of columns in the 2D array */ /* Function return value: none */ void read_data(char filename[], int array[][MAX_COLUMN], int *num_rows, int *num_columns) { FILE * infile; int row_count = 0; int col_count = 0; int i = 0; int j = 0; infile = fopen(filename, "r"); if(infile==NULL) { printf("\nUnable to open %s\n", filename); } else { fscanf(infile, "%d%d", &amp;row_count, &amp;col_count); for(j = 0; j &lt; row_count; j++) { for(i = 0; i &lt; col_count; i++) { fscanf(infile, "%d", &amp;array[j][i]); } } } *num_rows = row_count; *num_columns = col_count; fclose(infile); return; } /* Function print_matrix prints the data from the 2D integer array. */ /* Input arguments: array - 2D array of integers */ /* num_rows - number of rows in the 2D array */ /* num_columns - number of columns in the 2D array */ /* Output arguments: none */ /* Function return value: none */ void print_matrix(int array[][MAX_COLUMN], int num_rows, int num_columns) { int i = 0; int j = 0; int k = 0; for(j = 0; j &lt; num_rows; j++) { printf("\n+"); for(k = 0; k &lt; num_columns; k++) { printf("====+"); } printf("\n|"); for(i = 0; i &lt; num_columns; i++) { printf("%3d |", array[j][i]); } } printf("\n+"); for(k = 0; k &lt; num_columns; k++) { printf("====+"); } printf("\n"); return; } /* Function compute_transpose_matrix takes the data from the 2D integer */ /* array and transposes it to print a new 2D integer array where the */ /* rows are the columns from the original, and the columns are the rows */ /* Input arguments: array - 2D array of integers */ /* num_rows - number of rows in the 2D array */ /* num_columns - number of columns in the 2D array */ /* transpose_array - transposed 2D array of integers */ /* Output arguments: none */ /* Function return value: none */ void compute_transpose_matrix(int array[][MAX_COLUMN], int num_rows, int num_columns, int transpose_array[][MAX_COLUMN]) { int new_columns = 0; int new_rows = 0; int i = 0; int j = 0; new_columns = num_rows; new_rows = num_columns; for(i = 0; i &lt; new_rows; i++) { for(j = 0; j &lt; new_columns; j++) { transpose_array[i][j] = array[j][i]; } } return; } /* Function matrix_multiply takes the data from the 2D integer array and the */ /* transposed array, and multiplies them together to create a new 2D integer array */ /* Input arguments: array - 2D array of integers */ /* transpose_array - transposed 2D array of integers */ /* num_rows - number of rows in the 2D array */ /* num_columns - number of columns in the 2D array */ /* transpose_columns - number of columns in transposed 2D array */ /* product_matrix - the new, calculated 2D integer array */ /* Output arguments: none */ /* Function return value: none */ void matrix_multiply(int array[][MAX_COLUMN], int transpose_array[][MAX_COLUMN], int num_rows, int num_columns, int transpose_columns, int product_matrix[][MAX_COLUMN]) { int i = 0; int j = 0; int k = 0; int sum = 0; int transpose_rows = num_columns; for(i = 0; i &lt; transpose_rows; i++) { for(j = 0; j &lt; num_columns; j++) { sum = 0; for(k = 0; k &lt; num_rows; k++) { sum += transpose_array[i][k] * array[k][j]; product_matrix[i][j] = sum; } } } return; } Main Function: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "10P.h" /*=======================================================*/ int main(int argc, char *argv[]) { int count = 0; int i = 1; int j = 0; int k = 1; int array[MAX_ROW][MAX_COLUMN]; int num_rows = 0; int num_columns = 0; int transpose_array[MAX_ROW][MAX_COLUMN]; int transpose_columns = 0; int product_matrix[MAX_COLUMN][MAX_COLUMN]; printf("This program was called with \"%s\".\n", argv[0]); if (argc &gt; 1) { for (count = 1; count &lt; argc; count++) { printf("argv[%d] = %s\n", count, argv[count]); } } else { printf("The command had no other arguments.\n"); } for(i = 1; i &lt; count; i++) { /* Read Data from the current argument into the 2D array */ printf("\nProcessing data from file: %s\n", argv[i]); read_data(argv[i], array, &amp;num_rows, &amp;num_columns); /* Print data table from the current argument from the 2D array */ printf("\nPreference Matrix"); print_matrix(array, num_rows, num_columns); /* Transpose the data table */ compute_transpose_matrix(array, num_rows, num_columns, transpose_array); transpose_columns = num_columns; /* Calculate the product matrix */ matrix_multiply(array, transpose_array, num_rows, num_columns, transpose_columns , product_matrix); /* Print data table from the product 2D array */ printf("\nResulting Matrix"); print_matrix(product_matrix, num_columns, transpose_columns); /* Print Number Participants and Conflicts */ printf("\n\nThere are %d participants and %d Presentations in total", num_rows, num_columns); printf("\nFollowing are the number of participants per presentation"); for(j = 0; j &lt; num_columns; j++) { printf("\nPresentation %d: %d", (j + 1), product_matrix[j][j]); } j = 1; printf("\n\nThe following Presentations should be attempted to be scheduled at different times because of demand:"); for(j = 1; j &lt; num_columns; j++) { for(k = 1; k &lt; (j); k++) { if(product_matrix[j][k] &gt; 3) { printf("\n\t\tPresentations %d &amp; %d (%d Participants)", (j + 1), (k + 1), product_matrix[j][k]); } } } } printf("\n\nGoodbye!"); printf("\n"); return 0; } 
 The input files are supplied above as in1 and in2. the output for in2 should be as follows: This program was called with "a.out". argv[1] = in2 Preference Matrix +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ Resulting Matrix +====+====+====+====+====+====+====+====+ | 7 | 2 | 4 | 1 | 2 | 4 | 4 | 1 | +====+====+====+====+====+====+====+====+ | 2 | 9 | 4 | 1 | 2 | 2 | 3 | 4 | +====+====+====+====+====+====+====+====+ | 4 | 4 | 11 | 1 | 3 | 6 | 4 | 2 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 1 | 5 | 1 | 1 | 4 | 2 | +====+====+====+====+====+====+====+====+ | 2 | 2 | 3 | 1 | 9 | 3 | 5 | 4 | +====+====+====+====+====+====+====+====+ | 4 | 2 | 6 | 1 | 3 | 10 | 2 | 3 | +====+====+====+====+====+====+====+====+ | 4 | 3 | 4 | 4 | 5 | 2 | 13 | 4 | +====+====+====+====+====+====+====+====+ | 1 | 4 | 2 | 2 | 4 | 3 | 4 | 9 | +====+====+====+====+====+====+====+====+ There are 25 Participants and 8 Presentations in total Following are the number of Participants per Presentation Presentation 1: 7 Presentation 2: 9 Presentation 3: 11 Presentation 4: 5 Presentation 5: 9 Presentation 6: 10 Presentation 7: 13 Presentation 8: 9 The following Presentations should be attempted to be scheduled at different times because of demand: Presentations 1 &amp; 3 (4 Participants) Presentations 1 &amp; 6 (4 Participants) Presentations 1 &amp; 7 (4 Participants) Presentations 2 &amp; 3 (4 Participants) Presentations 2 &amp; 8 (4 Participants) Presentations 3 &amp; 6 (6 Participants) Presentations 3 &amp; 7 (4 Participants) Presentations 4 &amp; 7 (4 Participants) Presentations 5 &amp; 7 (5 Participants) Presentations 5 &amp; 8 (4 Participants) Presentations 7 &amp; 8 (4 Participants)
Are you u/MZ1029384756 or [related to him in some way](https://www.reddit.com/r/C_Programming/comments/7dmwmj/how_to_convert_the_following_assembly_into_c_code/)?
I think we might be working from a similar assignment or something
it's a very basic assignment. With stdio.h only, you could use Use 'getc ' Check if the ascii value of the character is a number and display it on screen if it's true 
Where are you stuck? What instruction don't you understand?
Pay close attention to the dimensions of your array and transpose_array variables and the dimensions of the matrixes you're trying to store in them.
 &gt;lets assume 0xc(%rsp) is x. Where do I go from here? Start by going back a step or five. Do you know what all the instructions used in this do, and what the parentheses syntax in their arguments means? Do you know how %eax and %rax are related?
The first input file for this is : 10 5 1 0 1 0 1 0 0 1 1 1 1 0 0 0 0 0 1 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 This is what I'm getting: Preference Matrix +====+====+====+====+====+ | 1 | 0 | 1 | 0 | 1 | +====+====+====+====+====+ | 0 | 0 | 1 | 1 | 1 | +====+====+====+====+====+ | 1 | 0 | 0 | 0 | 0 | +====+====+====+====+====+ | 0 | 1 | 1 | 0 | 1 | +====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | +====+====+====+====+====+ | 1 | 1 | 0 | 0 | 0 | +====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | +====+====+====+====+====+ | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+ | 1 | 0 | 1 | 0 | 1 | +====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+ Resulting Matrix +====+====+====+====+====+ | 4 | 1 | 2 | 0 | 2 | +====+====+====+====+====+ | 1 | 3 | 1 | 1 | 1 | +====+====+====+====+====+ | 2 | 1 | 5 | 1 | 5 | +====+====+====+====+====+ | 0 | 1 | 1 | 3 | 1 | +====+====+====+====+====+ | 2 | 1 | 5 | 1 | 5 | +====+====+====+====+====+ This is the matrix I'm supposed to get. The second input file is: 25 8 1 0 1 0 0 1 0 0 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 0 0 0 0 0 1 0 1 1 1 0 1 0 0 1 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 1 1 0 0 1 1 0 0 1 0 0 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 1 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 1 0 1 1 1 0 0 0 1 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 and i'm supposed to get: This program was called with "a.out". argv[1] = in2 Preference Matrix +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ Resulting Matrix +====+====+====+====+====+====+====+====+ | 7 | 2 | 4 | 1 | 2 | 4 | 4 | 1 | +====+====+====+====+====+====+====+====+ | 2 | 9 | 4 | 1 | 2 | 2 | 3 | 4 | +====+====+====+====+====+====+====+====+ | 4 | 4 | 11 | 1 | 3 | 6 | 4 | 2 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 1 | 5 | 1 | 1 | 4 | 2 | +====+====+====+====+====+====+====+====+ | 2 | 2 | 3 | 1 | 9 | 3 | 5 | 4 | +====+====+====+====+====+====+====+====+ | 4 | 2 | 6 | 1 | 3 | 10 | 2 | 3 | +====+====+====+====+====+====+====+====+ | 4 | 3 | 4 | 4 | 5 | 2 | 13 | 4 | +====+====+====+====+====+====+====+====+ | 1 | 4 | 2 | 2 | 4 | 3 | 4 | 9 | +====+====+====+====+====+====+====+====+ There are 25 Participants and 8 Presentations in total Following are the number of Participants per Presentation Presentation 1: 7 Presentation 2: 9 Presentation 3: 11 Presentation 4: 5 Presentation 5: 9 Presentation 6: 10 Presentation 7: 13 Presentation 8: 9 The following Presentations should be attempted to be scheduled at different times because of demand: Presentations 1 &amp; 3 (4 Participants) Presentations 1 &amp; 6 (4 Participants) Presentations 1 &amp; 7 (4 Participants) Presentations 2 &amp; 3 (4 Participants) Presentations 2 &amp; 8 (4 Participants) Presentations 3 &amp; 6 (6 Participants) Presentations 3 &amp; 7 (4 Participants) Presentations 4 &amp; 7 (4 Participants) Presentations 5 &amp; 7 (5 Participants) Presentations 5 &amp; 8 (4 Participants) Presentations 7 &amp; 8 (4 Participants) 
Compiling and running the second input gives this as an output: This program was called with "a.out". argv[1] = in2 Processing data from file: in2 Preference Matrix +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | +====+====+====+====+====+====+====+====+ | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | +====+====+====+====+====+====+====+====+ | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | +====+====+====+====+====+====+====+====+ Resulting Matrix +====+====+====+====+====+====+====+====+ | 6 | 3 | 5 | 1 | 3 | 5 | 3 | 2 | +====+====+====+====+====+====+====+====+ | 2 | 4 | 1 | 3 | 1 | 3 | 5 | 5 | +====+====+====+====+====+====+====+====+ | 3 | 4 | 8 | 1 | 5 | 5 | 4 | 2 | +====+====+====+====+====+====+====+====+ | 4 | 3 | 3 | 4 | 4 | 2 | 7 | 2 | +====+====+====+====+====+====+====+====+ | 1 | 3 | 4 | 1 | 3 | 5 | 4 | 4 | +====+====+====+====+====+====+====+====+ | 3 | 5 | 7 | 1 | 6 | 6 | 4 | 5 | +====+====+====+====+====+====+====+====+ | 4 | 4 | 5 | 3 | 4 | 3 | 9 | 3 | +====+====+====+====+====+====+====+====+ | 1 | 4 | 2 | 2 | 4 | 3 | 4 | 9 | +====+====+====+====+====+====+====+====+ There are 25 participants and 8 Presentations in total Following are the number of participants per presentation Presentation 1: 6 Presentation 2: 4 Presentation 3: 8 Presentation 4: 4 Presentation 5: 3 Presentation 6: 6 Presentation 7: 9 Presentation 8: 9 The following Presentations should be attempted to be scheduled at different times because of demand: Presentations 3 &amp; 2 (4 Participants) Presentations 5 &amp; 3 (4 Participants) Presentations 6 &amp; 2 (5 Participants) Presentations 6 &amp; 3 (7 Participants) Presentations 6 &amp; 5 (6 Participants) Presentations 7 &amp; 2 (4 Participants) Presentations 7 &amp; 3 (5 Participants) Presentations 7 &amp; 5 (4 Participants) Presentations 8 &amp; 2 (4 Participants) Presentations 8 &amp; 5 (4 Participants) Presentations 8 &amp; 7 (4 Participants) 
No need for a library, as the IRC protocol is fairly simple for clients. * Connect to the server. * Send the username and nickname. * When a line starting with PING is received, replace the `I` with and `O` to form a PONG and send back to server. * Wait to receive a `001` before joining a channel. That's pretty much all you need. If you read the RFC the above should all make sense. To get a feel for the protocol, you can try sending the above manually with `nc` or `telnet` - then it's just a matter of doing the same, but with C.
Yuck. Don't use magic numbers like that. Use isdigit(), or at the very least character literals.
You have any clues on how to solve this?
AHHH!!!! I set MAX_COLUMNS to 10!!! That did it, thank you so much! I've spent at least 3 hours looking up potential solutions and code for why this isn't working. Thanks so much!!!
It's not the pointer that's signed...
`intptr_t` is just the signed type corresponding to `uintptr_t`. One example is when you want to compute the difference between some `uintptr_t` values. From the top of my hat I don't know any compelling application, but it doesn't cost anything to include this type and would be really annoying if you needed it but it wasn't there (as with `ssize_t`).
Nice article, but you should really explain what the Intel FSP is somewhere in the first few paragraphs.
Are you sure that's actually the file's path? Where do you get the ‚Äúfile not found‚Äù error message? Your code is clearly not printing it (you can use `perror()` to make your code actually print the reason for the failed `fopen()`).
Wouldn't you use `ptrdiff_t` when doing pointer subtraction?
`ptrdiff_t` is the right type for pointer subtractions but not for differences of `uintptr_t` or `intptr_t` values. This might seem strange but it makes sense when you consider that taking the difference between pointers pointing to different objects (i.e. not two subobjects within the same object) is undefined behaviour. Using this rule, a C implementation for the 8086 might have a 32 bit `uintptr_t` to properly represent a segment/offset pair but only a 16 bit `ptrdiff_t` as no object is larger than 64 kB. However, `intptr_t` is still a 32 bit type.
 We don't make mistakes. We just have happy accidents. 
&gt; fgetc you don't seem to grasp ONLY STDIO, there is no isdigit().. I did it without looking at the reference, there is no main either... I assume someone could open the man page and supply STDIN.. simple enough.. 
Take a look at the [operator precedence table](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence). Logical-and has higher precedence than assignment, so what you wrote is equivalent to (y != NULL &amp;&amp; x) = y-&gt;right The error is telling you that the thing on the left hand side of an assignment operator has to be a modifiable lvalue, which the above is not. You need to use parentheses.
Your code should open the file, assuming the file path is correct. The printIt() function accepts a pointer to a data_slice as its parameter, but you are passing the actual value. You should change the call in your main function to: printIt(&amp;data) to pass the pointer to your data_slice. The printIt function won't do anything yet, though, because you haven't populated the data_slice struct with any data from your file (I wasn't sure if you had finished this part of your code or not). 
These are integers, not pointers. 
This is pretty enlightening so far, but I don't see how we should use `ptrdiff_t` for pointer subtraction but not for differences of pointers. Can you give many some small code examples? Is the issue just that it shouldn't hold differences of difference pointer types (`uintptr_t` and `intptr_t` for example)?
As a rule of thumb, use `ptrdiff_t` when storing the difference between pointers. Use `intptr_t` when storing the difference between values of type `uintptr_t`. In practice, both are typically the same type.
I think it's for differencing.
If I have a array of int64_t's, shouldn't the type just be int64_t *Name?
If you have GNU sed (if you have Linux you probably do), and have no better alternative, you can use this sed command: s/\([a-z]\+\)\([A-Z]\)/\1_\l\2/g (run `sed -e 's/\([a-z]\+\)\([A-Z]\)/\1_\l\2/g' your_file &gt; your_file_new`) The problem with this is that it replaces every sequence of lowercase[s]+uppercase in the file, whatever its meaning and context, but since you don't usually write those sequences in English, it shouldn't wreck havoc in your comments. Also, it will change any such sequence even in calls to functions from other libraries, so use it with care. Other than that, I know NetBeans can replace variable names (one by one) smartly in Java, so there's probably an IDE that does the same for C. It may take more time, though.
Dealing negative values?
The original function call is correct, your suggestion is wrong
Stackoverflow dude
thanks for the answer, I will try it. I can identify functions because all of them starts with $`INSTANCE_NAME` maybe that can help to don't modify other strings, just functions, but I'm not familiar with regex so will have to investigate a little further.
If you still want to follow this path, this command sed -e ':a; s/\('"$INSTANCE_NAME"'[a-z_]\+\)\([A-Z]\)/\1_\l\2/g; t a' your_file &gt;&gt; your_file_new should work, assuming INSTANCE_NAME is defined in the shell too (you can define it yourself like `INSTANCE_NAME=name` if it isn't).
&gt; differencing That‚Äôs not a word. 
&gt; That‚Äôs not a word. According to who? * [Data differencing](https://en.wikipedia.org/wiki/Data_differencing) * [differencing](https://en.wiktionary.org/wiki/differencing) * [differencing](http://www.dictionary.com/browse/differencing) * [differencing](https://www.thefreedictionary.com/differencing) 
**Data differencing** In computer science and information theory, data differencing or differential compression is producing a technical description of the difference between two sets of data ‚Äì a source and a target. Formally, a data differencing algorithm takes as input source data and target data, and produces difference data such that given the source data and the difference data, one can reconstruct the target data ("patching" the source with the difference to produce the target). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
c++ isn't that language for peeps that can't code in C ?
Most of the peeps doesn't stick to one language though.
&gt; According to who? Well, Merriem Webster and the Oxford dictionary don't have entries for it. You might be right, that ‚Äúdifferencing‚Äù is just a very rare word, and this is probably its first use in the context of pointers. 
You're probably looking for r/cpp.
With `intptr_t` you can use negative numbers to return an error code from a function, like `ssize_t`
Subtracting actual pointers can result in undefined behaviour. Subtracting `uintptr_t`s can not (except overflows)
Dude, diff is short for differencing. It's everywhere.
Unsigned types don't have UB on overflow.
C++ is off topic in this subreddit. Please post C++ content elsewhere.
This is a perfect answer, THANK YOU. Good example, better practice suggestion, clear understanding of the question and appropriate answer. Thanks again :)
&gt; if you have Linux you probably do Or MacOS or BSD for that matter.
&gt; as with `ssize_t` `ssize_t` exists only so functions like `read()` can return -1 on failure. 
https://academo.org/demos/estimating-pi-monte-carlo/ this link may help you for first problem. You must use random numbers to implement this simulation (you can find dozens of documents about this just Google it please) on the other hand for second problem, you can take a look strings.h library in c. 
[strtok](https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm) would be a good way to break your string up into words. [strpbrk](https://www.tutorialspoint.com/c_standard_library/c_function_strpbrk.htm) will let you check a string for a set of characters. Both functions are in the &lt;string.h&gt; library.
can you maybe write the code? 
Why don't you try writing the code, and then maybe someone will help you fix it? Start here. /* * * Filename: whutevs.c * * Description: * * Version: 1.0 * Created: 11/18/2017 13:17:36 * Revision: none * * Author: YOUR NAME (), * */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void){ //Your code here exit(EXIT_SUCCESS); } 
It also exists so you can write loops like this without pulling your hair out: ssize_t i; for (i = n - 1; i &gt;= 0; i++) /* ... */
 If you intend each line by 4 characters, it will format it as code. (Also, in REIS, there is a &lt;&gt;button which will do this for you.) Do you know how to write a `for` loop?
almost triggered me by writing BASIC in the title
If you're in a situation where you need to use a `uintptr_t`, it is probably almost always going to be a horrible idea to use an `intptr_t` to be able to return negative values as failures.
damn i was close then
Try using a loop.
No, sir, I do not.
They printing on separate lines because you're printing newline characters between them
I'm not sure what you're trying to accomplish with a loop that relies on the size and overflow behavior of its counter. And why would you use a `size_t` as a loop counter or array index, anyway? What's wrong with `unsigned long`? 
Why?
No one is going to do your homework for you
Probably silly to care about speed here but would using a bitwise AND be faster than checking the modulo?
You can use a for loop to make the same code run five times.
Yes
Hi, this is my blog. I wrote up an idea for a few OOP features using structs and function pointers in C. I'm by no means an expert at C, so please let me know what considerations and criticisms you have for my post!
if you spin this idea more and more you will land at GObject[0] :) [0] https://developer.gnome.org/gobject/stable/
Ok. Clearly you haven't understood this. If `i` has an unsigned type, it is never negative. Thus, `i &gt;= 0` is never false and my loop won't actually terminate. There are ways to get the code working with an unsigned `i` (e.g. by iterating from 0 to `n-1` and using `n - i - 1` instead of `i` in the loop), but they are all less elegant, motivating the need for a signed type whose size is equal to `size_t`.
Check out this book: https://www.cs.rit.edu/~ats/books/ooc.pdf
good bot
Good User!
Thanks! Ill definitely give it a read!
Depends on the compiler, but as used here the compiler should be smart enough to use a bit check
IMO it's most natural to both pass and return by value, however current compilers are pretty bad at optimizing this The next best option is to provide an out-paeameter. You don't want your function to allocate memory.
Depends on how big the struct is.
how would that affect it?
Why not try inline assembling?
alright fair enough, the way I was thinking about it is that in the method that returns `matrixStruct` is that it can be "compounded" if that's the right word, not sure how to describe it, but something like this: `matrix foo = matrixAdd(matrixAdd(bar, foobar), matrix baz);`
It's not common for an ABI to specify that a struct with a couple of register (or smaller) sized fields to just be returned in registers, while bigger ones require copying that using a pointer argument doesn't involve.
This is also explained in [LCTHW](https://github.com/mwilliams/lcthw-book/blob/master/learn-c-the-hard-waych20.txt). 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mwilliams/lcthw-book/.../**learn-c-the-hard-waych20.txt** (master ‚Üí b5afe69)](https://github.com/mwilliams/lcthw-book/blob/b5afe69aae5cf624607b932f85fe1b292454e91f/learn-c-the-hard-waych20.txt) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq0u7lt.)^.
I've tended to prefer pointers, assuming that it would be faster and more efficient especially if the struct were kb's (as opposed to a handful of int members) - I'm I basically correct in this?
Did... did you put a footnote in a 1 line comment?
I think BSD has its own version of sed, so I limited my comment to what I knew for sure.
The `float` members of a struct are floats, so you can't use them as a pointer to `testing`. What you have to do is pass `&amp;Test` as the argument. Inside the function, you have to access its members with `-&gt;` instead of `.`, because you're not accessing a struct, but rather a pointer to a struct.
Yes, you have to accept matrix by value to use that.
OP probably intended to do the following, which is a (imho better readable) alternative to "normal" links in markdown: [foo bar][foobar] [foobar]: http://example.com/
Probably wrong path.If you are using IDE or something,it maybe creating the output (.o,.exe)file inside Debug or Release folder and trying to run from there. Use absolute path.C:/Username... Or find the output file and change the path according to it.
Thanks!, I wrote a few errors in this code not related to this, but your comment helped lead me to the right direction
Fun fact: "C With Classes" was the working name for C++ from 1979 until 1983. i.e. from conception at Bell until release. (Back then it probably made sense; C++ *started* an extension to C. Now it's just a different language.) Back to OP's ... your casting of `PrivateCat` to `Cat` is an interesting idea for field hiding. Something to consider, though ... I don't believe the C language guarantees that both `PrivateCat` and `Cat` are packed and aligned the same way for the public fields. In practice, I would expect your example to work because I can't think of any optimization reason why the compile *would* pack or align the public fields differently if they started at offset `0` of the struct and were in the same order as the private fields. But lacking such a guarantee, I would be cautious. Remember, each C complier is free to pack and align `struct` fields as it sees fit. I know the C99 spec guarantees there will be no *leading* unnamed bytes at the *start* of a `struct`, but the compiler is free to add alignment bytes between fields. In theory, this *could* vary between two `struct`s that are mostly the same. (I wouldn't *expect* it, but that's not good enough.) You can detect this activity at runtime with `offsetof()` so you could potentially compare and assert if things are not as you expect after compilation. TL;DR: beware undefined behaviour Here's an article you may enjoy on strict aliasing, a related topic in C: http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html
http://en.cppreference.com/w/c/language/operator_incdec
Function pointers inside a struct is occasionally useful but should not be abused. A major problem is that unlike normal C++ methods, function pointers take spaces (compile and run the C++ program at the end). In addition, compilers can automatically inline simple functions, but they can't inline function pointers (for now?). Abusing function pointers may affect performance. #include &lt;stdio.h&gt; struct Test1 { double x; }; struct Test2 { double x; void (*func)(void*); }; struct Test3 { double x; void func(void*); }; struct Test4 { double x; virtual void func(void*); }; int main(void) { printf("sizeof(Test1): %ld\n", sizeof(struct Test1)); printf("sizeof(Test2): %ld\n", sizeof(struct Test2)); printf("sizeof(Test3): %ld\n", sizeof(struct Test3)); printf("sizeof(Test4): %ld\n", sizeof(struct Test4)); return 0; }
Interesting. I'm trying to create an OOP system for C as well. What I've found is that it's impossible to prevent "inheriters" from messing with your private members, since in order for the inheriter struct to be defined, it must know about the size of the inherted struct as well. What I've taken to doing is expose two different headers, one normally-used header for "public" activities and the object struct declaration, and a "protected" header with the struct definition, which inheriters will include. It seems that that's about the best "encapsulation" you can do in C. I also didn't define class/static structs, since you can just pop those into the appropriate header file as global variables and/or function definitions, but that might pollute the global namespace more than your method.
Because `uintptr_t`s are used to represent integer/numerical "versions" of pointers, for comparison/arithmetic/etc. Using an `intrptr_t` (and using the negative values as errors) halves the possible range of addresses you can represent; if you're on a 32-bit system, if one of your pointers just happens to have an address above 2GB, it will be treated as error code with this scheme. In reality, this is just a symptom of a bigger problem, in that "real" return values should never be overridden to be treated as error codes. Actual, dedicated status codes should be used.
Decrements 
It's pretty common practice on hackernews, where you don't get markdown-style inline links like on reddit.
A few notes: * Using the `static` keyword can limit "private" data to the scope of the object's implementation file, allowing a header to expose only the public data/API. Other files will not be able to access the private data (unless they copy implementation details which is unsafe). * I would consider referencing `parent` as a pointer rather than a copy (unless you need dynamic inheritance for script parsing or anything). For that matter, the virtual function table would do better as a pointer than a copy). Creating a copy of the `object` struct and the virtual function table wastes resources since all the function pointers should be copied. * I would recommend that you avoid the `func(void *)` approach, as it diminishes type safety and prevents the compiler from exposing errors in the code. It will be safer to define `int (*GetClawLength)(struct Cat *) ` and type-case to the private type within the function. * CamelCase and pascalCase are often used in Java and Pascal (and Ruby) to indicate classes, so I guess that it would make sense to see it here... However, [snake_case is more common in C](https://en.wikipedia.org/wiki/Snake_case) and should probably be preferred for variable names and method/function names. Consider that the C standard library uses name_case (also the POSIX API is snake_case, in contrast to the Windows specific public API which is C++ oriented to begin with). 
The overhead of the structure for keeping a sorted free list seems like it could be significant. Linking the freed blocks themselves together as a linked list (i.e. cast the freed blocks to nodes) means no additional space is needed per freed block. Then keep separate lists for different sizes. E.g. 8, 16, 32, 64, .... It would be quick to find big enough blocks to hand out - but, yes, it would mean that the blocks you hand out would generally be bigger than requested. 
I would look into using `container_of` to improve this. It would allow you to clean up your code a bit by avoiding some casting, and also would allow your code to work even if you don't put the "parent" object at the top of the `struct`. As a big bonus, this also means you can do something like object composition, where you combine multiple different types of objects together into one, and then use `container_of` to get the containing object of all of them. This works very well for creating intrusive data-structures.
One thing you could do is pre-determine the size of the struct and make the only public declaration as an array of characters of that length and cast to the real object internally. That could be a lot of maintenance work though (especially when first developing the structures).
One thing you might consider (Though it kinda stinks to allocate extra memory) is to put a `struct private_blah *` pointer into your object `struct`, and then forward declare it in the header but only declare the actual `struct private_blah` in whatever file defines the basic behaviour of the object (If you have more then one file, you can throw it in a header obviously). Then when you create the object, you allocate a new `struct private_blah` object and stick it in the pointer. This way, even though objects inheriting from you can see the `struct private_blah *` member, they don't know the format of the `struct private_blah` so they can't use it. They could still attempt something stupid like copying the `struct private_blah` definition into their file, but really there are very few languages that prevent you from accessing private object members via stupid ways if you try hard enough. That said, IMO I generally find a simple naming scheme to be sufficient in most cases where it really matters. For objects completely internal to your program I generally find the `private` vs. `protected` distinction to not be extremely important. I can understand the concern when talking about outward facing things though.
Your comments are valid for C++, but for C using function pointers in `struct`s is extremely useful and can be used to achieve a very high degree of modularity that you can't really achieve otherwise. I would easily argue that for the large majority of code people are writing, the small speed decrease associated with calling a function via a function pointer as well as the slight space the function pointer it takes up simply does not matter in the slightest and shouldn't be something people worry about, especially not in the context of sacrificing code readability/maintainability to avoid them. For the cases that it does actually matter, the programmer is probably already well aware. That said I don't disagree that you should only bother adding a function pointer for something you know you're going to actually being changing the functionality of (In the same way you would decide whether to mark functions `virtual` in C++). If you don't need the option to provide your own functionality for something, then there's no reason not to just use a regular function. Generally speaking it's not *too* hard to change it after-the-fact anyway.
Move/sent between method as pointer(better keep value on heap) but keep it as struct when inside method like you boxing any object when you want to move it between place and unboxing it on your desk/home for use it.
We are using [googletest](https://github.com/google/googletest/tree/master/googletest) along with [Typemock Isolator++](https://www.typemock.com/download/). We have to deal with some legacy code in both C and C++ and had to go commercial.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [google/googletest/.../**googletest** (master ‚Üí d175c8b)](https://github.com/google/googletest/tree/d175c8bf823e709d570772b038757fadf63bc632/googletest) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq1ehxx.)^.
And that is why I will never learn C++, C# and Java...
Learn algorithms, data structures, learn about CPU caches, data locality and let the compiler do its job. 90% of your code speed is going to come from how you avoided a function call by inlinging it, and the compiler is quite skilled at doing it itself. Your speed comes from how you designed your process, not your syntax.
Aside from algorithm choice, passing by reference and choosing an appropriate data structure (32-bit float instead of 64-bit double, implementing heaps and maps) are good ways to start. Also use a profiler to have a better idea of what your code is doing and which lines are the culprits.
Any good book on Algorithm and data structures.... All I searched have some bad reviews on Amazon as that of Robert Sedgewick
CLRS is the classic text
Pretty interesting, and fairly accessible! Reverse engineering isn't really in my field of view, but I would do easy challenges of this for kicks if they were around. Someday I'll work my way down to assembly. I fear that day will be the last of my sanity.
Now, that might not be what you are asking for, but I'll post it anyways: Don't! You are currently at the beginning of your coding journey and you should focus on readability, quality and correctness much more than on performance. I have worked with a lot of younger programmers and students and usually their code is getting significantly worse when they are event thinking about performance. My personal priority list is the following: 1. Readability 2. Correctness 3. Algorithm Complexity 4. Performance You should only progress to the next point when you're happy with the previous one. Now, one of the reasons why I recommending this is simply because you're not going to learn much about coding in point 3 and 4 and it's not really transferable to other languages and environments. Algorithm complexity doesn't really has anything to do with coding itself, it's much more comparable to mathematics than to programming. performance will teach you a lot about your compiler and your CPU, but all of that can go out of the window when you switch to a different language or a different environment.
haha
Loosely speaking, it's not possible to do this perfectly. If the program can recover the password, so can anyone with access to the program. One solution to your question as written is if you XOR the password into bits and deliberately make sure none of the parts contain printable characters then they won't show up in strings. Then XOR it back together at runtime. But remember people trying to hide bluray keys in the memory of their player and who write software like that for a living don't succeed. Can you tell us the larger problem you are trying to solve? There might be a better way to go about it that doesn't involve storing the password.
You could create a function that modifies the (or creates another) string in some way (like changing it to the previous character or something), and then you store the password in such a way that after being modified with that function it becomes the real password. For example, you would have `password = "qbttxpse";`, and when you need the actual password, you could do `newpass = prev(password);` and use `newpass` instead. Making programs resistant to reverse engineering is very difficult (I'd say impossible, because if your program knows the value of the string, a program that monitors it knows it too, but I'm not an expert), but this should help against the most basic use of `strings` (you can use a better formula to modify the string, of course).
I'm just trying to figure out if there are anyways to hide strings 
Very true. Algorithm complexity here of course refers to computational complexity, which we should minimise. It probably doesn't refer to implementation complexity, because we already worked on that as priority 1 - readability.
One thing that I've learned is that high performance is often problem specific. You can try to come with a better implementation of a general purpose sorting algorithm (to be "generally better" than qsort for example), but that might not be an interesting exercise. What is, IMO, is to come up with a better sorting algorithm which works better on a somewhat specific problem that you have. General purpose algorithms and data structures will only be so good: their advantage is not on performance, but on the fact that you can use them in a large collections of scenarios. You could try to pick a kind of problem (like mechanics physics simulations, or building some specific device driver) and stick to it. By working it out, you'll find out real performance improvement needs that are specific to your problem. Besides, a common thing these days is for your performance bottleneck to be not on the CPU or memory, but on IO (disk and networking). Depending on what you'll be doing, CPU/memory performance will be highly irrelevant **in comparison** to IO performance, in the sense that it won't be worth your time to work on CPU/memory performance because there will be more important performance problems on IO. But, of course, that depends on your problem. The idea that you could pick an "area" and try to solve problems there is interesting. It'll give you more perspective on what is really important. People often report that high CPU/memory performance isn't something important enough to worry about. Of course there are cases, and then other kinds of cases =).
I created a class/object model in which the class function pointers are stored in a buffer common for all the objects in the class. It saves a lot of memory when there are many functions in a class. https://github.com/RemyNoulin/objects/blob/master/main.c
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [RemyNoulin/objects/.../**main.c** (master ‚Üí c13ad0f)](https://github.com/RemyNoulin/objects/blob/c13ad0f7746f002b5048fe8eea403c5616c73e4a/main.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
The glibc has `memfrob()` and `strfrob()` for this purpose. However, if you think you need to hide passwords in your program, you have already designed it wrong. Any person with a disassembler can easily figure out how the password was ‚Äúhidden‚Äù and retrieve it. Do not write software that hard-codes passwords.
Where are you stuck?
If you post your code, people could tell you where you made a poor design choice leading to slow code.