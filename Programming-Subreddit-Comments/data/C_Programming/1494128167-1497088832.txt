I tried to simplify the question, it wasn't really smart. The exact line is of the form `struct -&gt;ptr`
You could use fork/exec instead of `popen` and then use `setrlimit` to limit the CPU time in the fork before you execute your program.
For example, if you declare an array of pointers to `char`: char *foo[4]; You can pass it to a function that expects a pointer to a pointer to `char` (`char **param`). However, if you declare an array of arrays of `char`: char foo[4][5]; You can no longer do this because only the topmost array decays to a pointer. Instead, the function parameter has to have type `char (*param)[5]`, i.e. ‚Äúpointer to array of five `char`.‚Äù This is not something you can solve with a cast, `char foo[4][5]` is a continuous four by five array, wheres `char *foo[4]` has an indirection inbetween. Another difference is that while you can assign to pointers, you cannot assign to arrays. Also, applying `sizeof` to an array yields the size of the array, whereas applying `sizeof` to a pointer yields the size of a pointer.
Yes, you get a warning. My point about danger is that thinking abou arrays just being pointers is a wrong mental model that leads to wrong expectations and weird code. That's what is dangerous.
Google is your friend. If you have a Linux machine accessible, use the "man"' command. This also works when offline.
You can get the current working directory of your program using something like this in your program: printf("Working directory: %s\n", _getcwd(NULL, 1024));
Tried that, but still got stuck in an infinite loop. Thanks though!
Most of the lines here are not functions at all: just random c expressions. I'd suggest you read up on [basic C syntax](http://www.cprogramming.com/reference/), because you probably won't get far otherwise.
For program resources used per-install, it's best to locate the files in relation to the executable's current location. Because file systems are by definition platform-dependent, the easiest solution is to use the operating system's file API rather than the C standard library: either POSIX, or in your case, WIN32. For windows, you can get the executable's file location with the [GetModuleFileName](https://msdn.microsoft.com/en-us/library/ms683197(VS.85\).aspx) function: example usage char buff[MAX_PATH]; GetModuleFileNameA(NULL, buff, sizeof(buff) -1); with `#include &lt;windows.h&gt;` and some `#define` for `MAX_PATH` at the top of the source or header file. Unix operating systems store the current executable's path as a file link. You can access the absolute path with `readlink("/proc/self/exe", buff, sizeof(buff) - 1)`, with the link path ("/proc/self/exe") depending on the OS. 
Yes. The simplest approach is to just write structures into the file using `fwrite`. However, this has a number of disadvantages, such as the file nor necessarily being readable on other computers or operating systems. A slightly better approach is to print your data in text form into the file. When you want to read it, you can use something like `scanf` to parse the file into a structure again.
One suggestion that I have is to choose an architecture that lets you keep all of your per-version variables in one place. This will be easier to maintain and extend in the future than hunting down all the places in the code where you're branching by version number. struct VersionData { uint32_t money_offset; uint32_t health_offset; uint32_t mana_offset; }; static const struct VersionData VERSION_DATA[] = { // Version 0 { .money_offset = 0x01010101, .health_offset = 0x02020202, .mana_offset = 0x03030303 }, // Version 1 { .money_offset = 0x04020320, .health_offset = 0x65012032, .mana_offset = 0x05320602 }, ... }; void MaxMoney() { WRITE_U16(VERSION_DATA[gameVer].money_offset, 0xFFFF); } In the future, if you were to make it data-driven (e.g. store the offsets and values in a file and read from that file on initialization) you could even release new updates without recompiling your application at all. If you wanted even more flexibility then you could consider storing function pointers per version number. That would allow you to do things like have v1 of MaxMoney() write a uint16 to address A, but have v2 write a uint16 to address A and another uint16 to address B. But I wouldn't go that approach until you know you need it.
thank you for replying, but do you mean fscanf or scanf? 
`f` cannot be `int`; that needs to be a `float` or better yet a `double`. Your `%d` formatting codes should be `%f` to accept floating-point numbers, not `%d` which takes ints. Your math is wrong: that formula requires Henry and Farad, not milliHenry and milliFarad. Divide both inputs by 1000 to calculate properly. Your math is wrong: those inputs should give a resonant frequency of [1.125Hz](http://www.wolframalpha.com/input/?i=1+%2F+(2+*+pi+*+sqrt(200mH+*+100mF\)\)). Just like in math on paper, a good thing to do is to break your algorithm down into atomic pieces so you can view each step for debugging. 1. 200mH and 100mF are 0.2H and 0.1F 2. sqrt(0.2 &amp;times; 0.1) is 0.1414214 3. &amp;tau; (2 &amp;times; &amp;pi;) &amp;times; that is 0.8886 4. 1 &amp;divide; that is 1.125 Here's my recreated code. #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int c; // get rid of this; you hide this with `double c` in main int l; // get rid of this for the same reason int main(int argc, char** argv) { printf("Welcome to Resonant Frequency Calculator\n"); double l; // double is better than float double c; double f; double m; // get rid of this; you never use it printf("Enter L (mH): "); scanf("%f", &amp;l); // use %f not %d l /= 1000.0; // scale mH to H printf("Enter C (mF): "); scanf("%f", &amp;c); // same c /= 1000.0; // same double s0 = sqrt(l * c); printf("sqrt(%.3e * %.3e) = %e\n", l, c, s0); double s1 = 2 * 3.14159 * s0; printf("tau * ^^^ = %.3e\n", s1); double s2 = 1 / s1; printf("1 / ^^^ = %.3e\n", s2); f = 1 / (6.28318 * sqrt(l * c)); printf("The resonant frequency for a tank circuit with L = %.3f mH and C = %.3f uF is %f\n", l, c, f); } ---- edit: use `%lf` for doubles and also &amp;micro;F means MICRO Farad not MILLI Farad, divide by a million not by a thousand. Devil's in the details, and I missed these SUPER hard. Makes my "your math is wrong" line look pretty fucking stupid, doesn't it. Feel free to throw tomatoes at me for these.
[Tau is love Tau is life](http://tauday.com/tau-manifesto) Your main errors are using int variables, which truncate floating point math, so as soon as you have something less than one, it becomes zero and pollutes everything.
UGH FORMAT CODES Thanks man. I figured I was missing something.
To answer questions like this, always [consult the operator precedence table](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence). The `!=` operator has higher precedence than the `=` operator, so the expression is equivalent to: j = (i != 0); You should also know how each operator works. `!=` performs a comparison and evaluates to either 0 or 1 based on the result. 
Thanks for the comment! The method you suggested where each offset it listed ahead of time and then referred to later on is similar to the first way I went about this, but putting them in structs in order to make it easier to read and combining it with the gameVer variable is a neat idea I did not think of. As for building this cheat plugin to be data-driven, I wish I could but this is not running on x86-64 and the library I'm working with is limited. No reading from external files unfortunately. 
Indeed!
Either can be used depending on what your input is.
I hate to keep bugging you. I emailed my teacher and she said she cannot accept a solution like this because we never covered tau * ^^^ (among other things) in class. i re-worked my original above but i still get 0.000000 for all answers and i cannot figure out why. I do appreciate your help very much. can you explaine why my above example wont work? she said I am close to an answer but am missing a few details. 
This worked a treat! Thanks
I changed the ints all to doubles. but I cannot get the results that she specified for the class. I emailed the teacher and she said i am close. but it has been hours and I can't figure out where I am going wrong. i changed the code above to reflect what i have done up to this point but i keep getting 0.000000 for all the answers. i have been at this all day. where am i going wrong? /u/myrrlyn posted an answer but the teacher says she cant accept it because we never went over tau in class or the %.3e that myrrlyn used. please. i am begging for help. 
makes sense, will try it right now. thanks
i didnt try to use it exactly. thats why i am trying to accomplish it with my code above. I just told her i had help with a similar code that would accomplish the same thing and asked her if i was going in the wrong direction on my own code. I appoligize if you think i was trying to pass your code off as mine. I wouldnt do that. 
You are using `strcmp` incorrectly. Read the documentation of `strcmp` to understand what `strcmp` returns.
I just want to learn. i appreciate your help. i changed my origional code above to reflect my changes that you suggested. i still get zeros for my answers. 
Thank you for your response. I used timeout, which is fine for what I'm doing. I'll take a look at the other suggestions though!
Oh, I see. Thank you.
If you're converting from uF (**micro**farads) to farads, C needs to be divided by `c /= 1000000.0` , not `c /= 1000.0`. That'd be appropriate if you were converting from mF (**milli**farads).
`c /= 1000.0` should be `c /= 1000000.0`, as you are converting from uF (**micro**farads) to F, not mF (**milli**farads) to F.
Sorry to keep annoying you, but can you point me in how to keep it reading from stdin and receiving from the cut command? I'm asking because the pipe can only be used once, so. Should I keep opening pipes? That would imply a limit of use, is there other way? A named pipe?
Thank you, i had missed this! The code still won't work though :/ am I handling the pointers correctly?
"fflush(stdin)" is at best a non-sequitur. It is an input stream and "fflush()" operates on things that are output streams - sometimes. We're not being mean when we say that solving this problem is nontrivial. It just is nontrivial. 
How is `fscanf` dangerous? The only dangerous things are using `%s` without a length modifier and not checking the return value.
is there a better way to do this? again, the tokenizer() function must return a char** and it is only able to receive those two parameters specified. I feel like if I knew how to manipulate char** directly I could possibly avoid using arr entirely
Are you intentionally returning an array of integers as a char pointer? Simultaneously, the 'newTok' and 'arr' arrays only exist within the function they are defined in while it's executing (allocating on the stack), when you return a pointer to them the function receiving the return value will have a pointer that points to invalid memory, or memory for something else in your program. You need to either allocate your arrays once at the beginning of your program (i.e. global arrays) or allocate them in the function using new/malloc() and delete/free() it when you're all done working with it at some point. A good rule of thumb is to just not be allocating new memory all the time if you no longer need previous allocations. Either re-use previous allocations (i.e. allocate at program start global arrays) or free them before allocating more, as long as that doesn't interfere with the design and function of your program.
i understands, most answers resolve to the same conclusion, it understand because it is the answer
For a more classroom-oriented answer: yes, compilers definitely do this. You can see this yourself by looking at the assembly output. On GCC, pass the `-S` flag. Compare the output with and without optimizations turned on, and see how it changes. If the compiler has to emit a bunch of math and a bunch of reads from memory, and there are data dependencies between them, the compiler will often interleave the two when it knows that the read from memory would cause a stall. On MIPS, SPARC, and some other architectures, the assembly code actually takes [delay slots](https://en.wikipedia.org/wiki/Delay_slot) into account. When you write an assembly branch instruction, the instruction *after* it will also get executed. If you're lazy, you'll just put a `nop;` in there, but if you're smart, you can put a useful instruction there like setting the return value. The compiler knows to take advantage of that with optimizations turned on. That confused the hell out of me ‚Äî *how the hell is the instruction* after *the branch executing?!* ‚Äî until I learned what was happening. On other processors, the pipeline stalls are unavoidable. It's simply taken into account as part of executing the instruction. The processor's manual will say "A branch instruction takes 5 cycles to execute" or whatever. On advanced processors like x86, the processor actually looks ahead by several instructions, breaks them down into much smaller mini-instructions, and can then reorder those to avoid some stalls. All of that is invisible to you unless you get into some very careful fine-grained measurements.
Have a look [here](http://stackoverflow.com/questions/617554/override-a-function-call-in-c#617606). Most solutions given are targeted towards GCC. Let me know if this helped, because I'm quite curious myself how (and if) it worked out for you.
So a few things: * I would not label your semaphore `mutex`; it misleadingly makes me expect a mutex instead of a semaphore, but this is somewhat personal preference. * Your semaphore is a pointer to `NULL` at present because you neglected to call `sem_init` to initialize it. As such `sem_wait` and `sem_post` are probably going to throw some errors. * Since `mutex` is a pointer to a `sem_t` already, you need not pass it to `sem_wait` and `sem_post` via `&amp;mutex`. This should be throwing an error since these functions expect a pointer to a semaphore, not a pointer to a pointer to a semaphore. * Since `createArrayList` has a return type of `arraylist *` you should be returning a variable with that type, and not `void *`. Moreover, `ret = arraylist` is confusing, since `arraylist` is a type and not a variable; you probably meant `ret = array` but as I made mention above, you'd do better to forego `ret` and simply return `array`. Assuming you fix all that, this appears to be threadsafe~~, but I'm not sure you need to wrap it with `sem_wait` and `sem_post`. As I understand it, the point of making a function threadsafe is to ensure that shared data between threads is modified in a predictable manner. By contrast, this function is the first instantiation of data and can't be manipulated until after this function returns~~. ~~I could be wrong, and there may be some benefit to wrapping this function; if so please someone correct me~~. Hope this helps. **EDIT:** I redact my previous claim; you should keep `sem_wait` and `sem_post` because a pointer you declare may start out pointing at a garbage address until this function returns. If you have a thread to initialize that `arraylist *` and a thread to manipulate it, the manipulation may occur on a garbage address instead of the proper address you're attempting to initialize.
You could use [dlopen](http://man7.org/linux/man-pages/man3/dlopen.3.html) and [dlsym](http://man7.org/linux/man-pages/man3/dlsym.3.html).
I think you should retract your retraction -- how could another thread manipulate that arraylist before createArrayList() has returned?
You're trying to initialize your struct with an array. Either set every member's value after declaring the struct (`blah.num = 2;`, etc.) or use the C99 style of struct initialization (`sPRIME_THREAD blah = { .num = 2, .current = 1, ... };`).
Thanks, I have tried this the only issue I get when I use this approach is that it doesn't adhere to what is needed by the function `void *prime_search(void *param){` I get the error `incompatible type for argument 1 of prime_search` and `note:expected void *' but argument is of type 'sPRIME_THREAD {aka struct &lt;anonymous&gt;}` 
You need to pass the address of the struct, not the struct itself. Try `prime_search(&amp;blah);`
&gt;calloc() is used to allocate arrays, but you're using it to allocate a single struct. malloc() would be a better choice, and then calloc() when you allocate the base. I suspect the latter is where the size argument is expected to be used, too. I wouldn't necessarily call that out as a problem; I've seen coding standards which say that using calloc should be preferred over the use of malloc because calloc zero-initializes and malloc doesn't have to.
It's undefined. Anything can happen. See this for more information: http://c-faq.com/expr/seqpoints.html
This is 100% correct (assuming malloc is thread safe -- written to ensure any pedantic drive by smart-asses don't derail). You only need to lock a *shared* piece of memory. In that function, nothing is sharing the memory until it is returned. This is why, generally, factory systems don't need to lock outside of the allocator.
Yeah, it's likely it will increment both then multiply, or increment one, multiply, then increment the other - but as undefined behavior, it's also possible it could add 236 to i, or segfault, or reformat your hard drive.
He implies that I claimed that the behavior is defined by the implementation. But I said that the behavior may be defined by the implementation.
By using more brackets.
I did this once and then my computer offered me three marijuanas.
&gt; ++i++ ++ ++i++ Did you put too many plusses? I would have thought that ++i++ + ++i++ would have been correct.
Oh, also, (++i) is not an lvalue, so you cannot call postfix ++ on it. Therefore, it's not syntactically correct.
The context is clear. You are wrong.
I did put too many pluses. I'm misremembering, because I haven't been lectured about C UB in a couple years. `++i+ +i++` will work though.
It is evaluated by walking over to the developer responsible and smacking them in the back of the head.
Lvalue-ness is a semantic property, not a syntax property. The code is syntactically correct but violates a Constraint of postfix-++. 
One way to achieve this is by editing the executable file while running the first time and modifying condition. So your code would look something like this, Int main () { .. if (1 == 1) { Do one time initialization stuff. Open this executable Edit the conditional check and replace one 1 with 0 Close file } Continue with normal operation } You can use objdump, gdb, etc to find offset in file of constant to modify.
I would expect that in the overwhelming majority of cases where the standard specifies behavior as *undefined*, there is no documentation in the compiler explaining what will happen. In fact, for most examples of undefined behavior, I would expect that looking at the source code won't even be much help. This is a perfect example: what part of the GCC (for example) source code would you look at to determine what happens in `++i * ++i`? It will depend on how it's translated to the intermediate representation, how it's optimized, and so much else. It might depend on the register pressure in the area of source code where it appears, for example. Because it's undefined, it will simply be the hard-to-predict interaction of a bunch of different components that didn't care about this corner case because they didn't have to. The reason that certain things are undefined is often because the standard writers decided it was more trouble that it was worth to define behavior. Maybe it's because of hardware difference or optimization opportunities (e.g. signed integer overflow). Maybe it's because it was decided that there wasn't an "obvious" definition for the behavior, so why burden compiler writers if half the people will be disappointed anyway? This is a good example of that, by the way. Would should the values in `y` and `z` be here: int x, y, z; x = 0; y = x++ * ++x; x = 0; z = ++x * x++; It doesn't seem worthwhile to try to enforce a behavior here: it would probably be mildly annoying for the compiler writer, and there's no "intuitive" solution: most people's intuition would say to "read" it left to right, but most people's intuition would also say that integer multiplication is commutative (i.e. `a * b == b * a`). So while I think that the first part of original statement was wrong, the second part wasn't right either.
Write a file somewhere to enable such behavior. If the file doesn't exist, do initialization and write the file. If the file does exist, don't do initialization. 
http://codepad.org/P0aIS9ch gcc gives a result.
Here is a [sample implementation](https://gist.github.com/fuzxxl/77e42dadea6f2c05d532d1871e340a51) of bubble sort on singly linked lists. Pay close attention to the double pointers.
"Basic" challenge!! This looks very hard... A great idea though and I am keen to see what people come up with.
`awk -F: '{ print $2 }' &gt;log.txt`
Your post got caught in our spam filter because you are shadow banned. Please talk to the admins to rectify this issue.
Oh, I thought that C parsing was less straightforward than that. Am I thinking of what happens when C++ constructs get added?
Why not make this a spoiler? [Like this](/s "[Text](/s "ignore this backslash"\)") Also every memory scanning tool is appropriate.
Or `cut -d: -f2`
Ah, I see what you're getting at. That said, the parallel/out-of-order nature of the CPU shouldn't come into play. Even if the CPU were to do the increments in the correct order, the code still results in `i` only being incremented once. My point was that fundamentally this is still the compilers 'fault' - the CPU gives correct results, the code it was given is just flawed (Though it's not really the compilers 'fault' considering the programmer gave it nonsensical code). But seeing your example I don't think that's what you intended to imply with your first comment, just that the compiler may produce code that does both increments together vs. one after another.
Free software meaning open source. Which this, as far as I can tell, isn't. And just checking, you *are* the people that wrote PVS studio, right?
problem wth that solution resides in the rest of the program, because even when redirecting the stdout it needs a EOF to close the pipe for the cut/awk to finish, and if i close the pipe need to create a new one to keep reading from the father stdin.
You're going out of bounds of your array by doing things like `array[-1] = blah;` and overwriting random other memory that happens to be used for another variable. 
That made absolutely no sense.
Not that i would encourage it but gdb can be scripted, which would increase the reproducibility. This sounds like an interesting way to write "readable" self modifying code. "Interesting" in the same way the Obfuscated C Code contest is. 
This is an excellent text. Definitely do all the exercises and programming projects and don't just skim the lessons. Do try to support the author if you can by buying his text. But if you are financially constrained, you can lookup libgen.
Sorry, It is my first comment on Reddit - please tell me how to do it, so I can edit it.
Can you please elaborate why this isn't reproducible?
The version of cuckoo hashing required for Assignment 2 is slightly different to what is described in lectures and may also differ from what is described by online resources. Please read the specification carefully and implement your solution accordingly. For insertion: &gt; You should always begin by inserting key into the first of the two tables, using h1() from inthash.h. Upon a collision, the preexisting key should be moved to the second table using h2(). Upon collisions in the second table, the preexisting key should be moved back to the first table using h1() again, and so forth. For lookup, check the two possible locations. If you are unsure about any aspect of the specification, please post your query to the Discussion Forums or contact your tutor. A reminder that all work is to be done on an individual basis. Where academic misconduct is detected, all parties involved will be referred to the School of Engineering for handling under the University Discipline procedures. Further information is available from the Subject Guide on the LMS, and Part 8 of the [Academic Board Regulation](http://www.unimelb.edu.au/__data/assets/pdf_file/0007/2024548/Academic-Board-Regulation.pdf).
You don't know though. It *may* happen.
Yes! We use it at work! Ask me anything about Frama C. For a good introduction into what is possible and what not, read our publication *ACSL by example.*
Thanks, I will read it. Can you give me a hint for what purposes do you use it? 
Writing a web server in C is fine, but I think it would be a drag because there aren't very many clever ideas that have to be implemented there. It's just trudging along. I think there are more interesting things you could write, such as a bittorrent or bitcoin client or perhaps something like chord. Before tackling that though, I'd actually advise something a bit more constrained. (as an aside, you get more out of doing something like doing bittorrent without using as many libraries. Its interchange language is simple and writing the parser for it is a good on the way exercise). I'm assuming you already know C from your message, so I'd actually suggest that as a next step to read C Interfaces and Implementations by Hanson. The book is focused on the approach to building libraries and appropriate interfaces for them in C. Each chapter discusses a different structure, starting from pretty simple stuff like a stack. If I remember correctly, it discusses the interface first and then goes into the implementation. I think a great exercise would be to look at the interface, implement it yourself without peeking, and then compare your implementation to his. 
Well, UTF-8 would minimize memory requirements compared to char32_t, and char16_t simply does not support all of unicode without having to resort to ugly hacks like surrogate pairs, which entirely defeats the purpose of having a fixed length encoding. Also, UTF-8 is the standard text format these days, last I heard something like 80% of the text transmitted on the internet is in UTF-8. also also, it'd generally be backwards compatible with argv, as it's just an array of bytes, so it could ease the transition. also^3 it could reduce internationalization issues dramatically.
I mean, that's about as efficient as you're going to get. Really, your only other option is to have an if/switch blob, and that's far uglier and just more icky.
Kernigan and Ritchie's book, the founders of the C programming language is a good place to start. Here's a link to a shitty online pdf version, but there are physical copies on amazon for about $20-$30 http://alvand.basu.ac.ir/~dezfoulian/files/Programming/Prentice%20Hall%20-%20The%20C%20Programming%20Language-%20Brian%20W.%20Kernighan,%20Dennis%20M.%20Ritchie,%202nd%20ed.,%20ISBN%20.pdf Another Resource i've used is this http://www.programmingsimplified.com/c-program-examples it's not really a tutorial, but it has a bunch of useful examples (sorting algorithms, printing, implementation of functions and libraries etc), i've found it extremely helpful 
I think you're lost -&gt; /r/cpp or /r/cpp_questions
Line 306 of that doesn't have a fgetc() call... It does have a pointer dereference, so if that's where a crash happens, it's probably a pointer to memory your program doesn't have permission to access. Using valgrind or a debugger would help narrow the source down more.
Sorry. Line 349 is a bit more specific, but it's not where the entire loop starts. Valgrind might be a good idea though, though I'll have to get it working. Thank you!
Libraries such as [libunistring](https://www.gnu.org/software/libunistring/) and [ICU](https://ssl.icu-project.org/apiref/icu4c/) exist for exactly the reasons you want. As for removing internationalization capabilities entirely, I'm not sure that would work well. I may prefer UTF-8 because I live in a country with a character set that is representable using 2 bytes or less in UTF-8, assuming precomposed characters are used, but Unicode code points in CJK locales require 3 bytes or more per glyph, compared with 2 bytes in UTF-16, so I can understand a programmer dealing with character sets used in CJK locales arguing against UTF-8. And that's the beauty of ISO C these days. You're not constrained or guided toward any single character set or encoding. While C originated from the English-speaking world, it has since become something that can be used by people whose character sets are not necessarily representable in a single byte, even when using native encodings such as GB 18030, JIS X 0208, ISO-2022-KR, or EUC-TW. When you investigate things from the perspective of someone dealing with multibyte strings regularly, removing C's various locale independence facilities and standardizing things based upon UTF-8 make a little less sense. On top of that, emoji is now commonplace, and that requires at least 2 bytes in both UTF-8 and UTF-16, sometimes requiring up to 8 bytes in any UTF-encoded form (e.g. U+1F1E9 U+1F1EA = D E, which in emoji form is often represented by a German (Deutsch) flag: üá©üá™). There's no single correct answer to the character encoding/byte-saving tradeoff, and UTF-8 especially is not necessarily a great choice unless the majority of text you process is ASCII compatible.
I wrote a sort of utf8strlen a few years ago which checked the bit patterns and counted valid utf-8 chars. I found that I also had to write a function which first would extract the valid utf-8 chars from the array first and then count them. In this way I ended up with a count function and a utf8clean function that would scrub out bogus chars.
if i initialize it am i not giving a fixed values and will a user be able to enter his or values to get the biggest number and the position of it?
You can write code to initialize a variable from user input, yes.
How would this work on systems where `CHAR_BIT &gt; 8`? How do you convince IBM to convert their mainframes from EBCDIC to Unicode? How do you convince Japanese people to no longer care about Shift JIS? Germans to ignore ISO 8859-1? Taiwanese to drop Big 5?
&gt; Division by zero is a catastrophic fault that you cannot catch. Note that this only applies to integer division and it's fairly easy to catch: signal(SIGFPE, my_handler); or to ignore: signal(SIGFPE, SIG_IGN); for floating point division, you can mess with the floating point environment to alter the way floating point exceptions are dealt with.
I'm not sure how this is helpful. Sorting linked lists generally requires a somewhat different approach as you can't just index into a linked list. Instead you need to carefully traverse the list and keep pointers to interesting spots.
If you haven't initialized your variables, they will be zero to start, your logic will never fire because you can only divide when not zero, and so your marker variables stay zero.
I'm well aware of how uninitialized memory works. In practice, execute this program. Tell me if you get non-zero values.
(That link was for C++, but C [works the same](http://en.cppreference.com/w/c/language/initialization). My bad). Challenge accepted. I ran this: #include &lt;stdio.h&gt; int main(void) { int a[3]; printf("%d %d %d\n", a[0], a[1], a[2]); return 0; } on 3 different operating systems, with 3 different compilers, and got a grand total of two 0's, and many other random garbage numbers. But since you know how uninitialized memory works, you already knew that's something to be expected...
You're not doing anything with the result of `fgetc`. It will return the value `EOF` (which is an `int`, not a `char`) if there is an error or the end of the file is reached, and you're supposed to stop trying to read from the file when that happens. It looks like you're trying to find the size of the file. An easier way to do that would be to use `fseek` to seek to the end of the file and then use `ftell` to get the current position in the file.
So you get some different numbers on your system. Big deal. That's what *indeterminate* means. You can't make any promises or guarantees about what you get. Don't mislead the OP into thinking something is true when it's not. (Also, your a is supposed to be zero, because file scope is treated differently than block scope variables). 
You go out of bounds every time you access elements of `array` in your knapsack() function, so anything can happen... You also never initialize `n` in that same function so who knows how many times that for loop will run, if at all. Looks like you might also be using integer division when you want floating point. 
okay
[Scalable C](https://www.gitbook.com/book/hintjens/scalable-c/details) might interest you. I haven't read it myself.
&gt; it gets complicated fast. Yes .. it does .. sort of. If you stick with a verification based on the basic utf8 bit patterns then it is easy to do. If you need to actually verify that the bit pattern is a valid utf-8 char then is gets messy fast. One does not imply the other as you know.
I wanted to answer the question "Can it be done?", by assuring OP that there's nothing fundamentally "magic" about singly linked lists. It's just another container, along with arrays, b-trees, etc. If you can iterate (you can), compare values (you can), and swap (you can), then you can sort. I've written some code below (I likely should've put this on pastebin or github, but that's troublesome at work) that shows how a simple bubble sort works fine on a single-linked list. In this code, compare `bubble_sort_arr` with `bubble_sort_list` and you'll see that the only real difference is just how to move the iterator and get the value from an iterator. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* support types and functions */ /* irrelevant to 'Can you sort a singly linked list' */ struct list; struct list { int val; struct list *next; }; void lappend (struct list **head, int i) { struct list *h = *head; struct list *new = malloc (sizeof(struct list)); new-&gt;val = i; new-&gt;next = NULL; if (NULL == h) { *head = new; } else { while (NULL != h-&gt;next) { h = h-&gt;next; } h-&gt;next = new; } } void lprint (const char* title, struct list *head) { printf ("%s", title); while (head != NULL) { printf ("%d ", head-&gt;val); head = head-&gt;next; } printf ("\n"); } int compare(const void *aa, const void *bb) { const int *a = aa, *b = bb; return (*a &lt; *b) ? -1 : (*a &gt; *b); } void swap (void *aa, void *bb) { int *a = aa, *b = bb; int t = *a; *a = *b; *b = t; } /* Two bubble sort functions follow */ /* This is where you see the similarities/differences */ void bubble_sort_arr (int* a, const int n) { int s = 1; /* did we swap? */ while (s) { int iter = 0; s = 0; /* assume we won't need to swap */ while (iter &lt; (n-1)) { if ( 0 &lt; compare (&amp;a[iter], &amp;a[iter+1])) { swap (&amp;a[iter], &amp;a[iter+1]); s = 1; } ++iter; } } } void bubble_sort_list (struct list *l) { int s = 1; /* did we swap? */ if (NULL == l) return; while (s) { struct list *iter = l; s = 0; /* assume we won't need to swap */ while (NULL !=iter -&gt; next) { if ( 0 &lt; compare (&amp;(iter-&gt;val), &amp;(iter-&gt;next-&gt;val))) { swap (&amp;(iter-&gt;val), &amp;(iter-&gt;next-&gt;val)); s = 1; } iter = iter-&gt;next; } } } int main() { int nums[5] = {2,4,3,1,2}; struct list* l=NULL; int i=0; for (i=0; i&lt; 5; ++i) { lappend (&amp;l, nums[i]); } bubble_sort_list (l); lprint ("result: ", l); bubble_sort_arr (nums, 5); printf("result: %d %d %d %d %d\n", nums[0], nums[1], nums[2], nums[3], nums[4]); return 0; } 
This warning is caused by `scanf` being defined using the GCC-specific [attribute](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes) `__attribute__ ((warn_unused_result))`, and can be turned off by compiling with the option `-Wno-unused-result`. AFAIK, you can also cast the result to `void` to avoid this warning (void)scanf("%d", &amp;a[i]); This makes it explicit that you don't want the return value, but there are some posts on StackOverflow that claim that this doesn't work anymore on GCC 4.6 (it compiles, of course, but you still get the same warning). You can also use `if` without an expression, like `if(scanf("%d", &amp;a[ i ]);`, so you're technically using the return value, but that's just ugly and confusing, in my opinion. Incidentally, there are cases where the return value of `scanf` is useful: if you press Ctrl+D (on Linux, and maybe Windows) while `scanf` is reading your input, it returns an error, so the return value is not entirely useless.
 &gt;So can we agree that uninitialized variables loaded by an operating system are typically zero, even though this isn't mandated by C? Nope, we can't. When the standard says that auto storage duration variables that aren't explicitly initialized start out with indeterminate unknown values, that doesn't meant 'typically zero'. Trying to project what you're seeing on one particular set up to others is futile and pointless.
This has nothing to do with the C standard; it has to do with the environments where OP is executing his code. On most embedded targets, it will *always* be zero because of the environment -- RAM drains on reset, Flash is zeroed for .data segments. On the desktop, it will *typically* be zero because of how the OS presents memory. The C implementation is, in fact, host agnostic here. This is correct. But the explanation for what is being observed is that logically uninitialized values that aren't the result of wildly stupid behavior like you and I resorted to to demonstrate memory population, are often zeroed by the OS, and the zeroes OP observed were because he didn't initialize.
Your post got caught in our spam filter. I apologize for the inconvenience. I have approved it manually.
It's a little hard to read without indentation (you might try using something like https://pastebin.com/ to preserve formatting). From my quick glance over this, it looks like you're never adjusting your buffer pointer, so each time you are running strstr() in the while loop, it's using the same input. At the end of your loop, try setting the buffer pointer past the '&lt;/span&gt;' tag. Have you tried using GDB to figure out what is causing the segmentation fault? Typically, this is cased by a null pointer dereference.
You have several buffer overflows and other mistakes, any of which could cause a segfault: * `strstr` operates on a string. A string is a sequence of characters followed by a null terminator. You did not supply a string as the first argument to the first `strstr` call. * `strstr(temp, .....)` should not be performed without first checking for `temp` being NULL. * The calculation `temp2 - temp` should not be performed without first checking `temp2` being `NULL`. * You call `strncpy` with a length parameter that might exceed the buffer size. (The third parameter is the buffer size, not the input length). * The `%s` specifier for `printf` expects a null-terminated string, as described above. But the `strncpy` function sometimes does not produce a null-terminated string. In fact, the way you use it here, it *never* produces a null-terminated string. I would recommend not using `strncpy` due to this. One alternative would be `snprintf(buffer, sizeof buffer, "%.*s", len, temp + 21);`. Also, your read loop stores EOF in buffer before breaking. (Rearrange it so you read the character, then test EOF and break, then store the character). 
This is my updated code, I just get infinite loops. Here is the [link](https://pastebin.com/R1q2Qcy7)
This isn't meant to be rude, but I think you have examine why you want to learn C. There is just a lot of C around. You have to pick a corner of how the language is used and understand the domain constraints[1] on that. There are many, many dialects of the language and the domain drives that. [1] kernel, device driver, embedded, legacy, yadda yadda. 
Your main loop, starting line 17, only has one exit condition - when either search string is not found. You're not modifying your buffer pointer, so you get an infinite loop because it will find the same match over and over.
but, the idea was to apply bubble sort though you've used qsort, 
that is in no way rude :). The most benefit I wan't to have from all this is just for learning purposes. I'm not using C at work or will in the coming year(s), just wanted to learn how to write more real life programs in C.
Note that this change also affects people who use a character set incompatible to Unicode, of which there are many. For example, on UNIX, the default locale for German is ISO 8859-1. Japanese people like to use Shift-JIS because Unicode has trouble with Kanji. These people won't be happy if you break C for other character sets.
Why is your loop condition "true"? Move your `feof(file)` call into the while condition so that it is `while(!feof(file))`. Then you don't need the extra if-break in the body of the loop and the `EOF` condition is always checked _before_ you try to read from the file. I see the same dodgy loop construct on line 229-235, FYI. But other than that, I have to agree with /u/PurpleOrangeSkies. Just be mindful that `fseek()` and friends work in *bytes* not necessarily characters (if you are working with something other than ASCII/UTF-8).
There is no header named `wchar` or `uchar` in the C standard. What do you mean?
[Embedded Systems - Shape The World by Jonathan Valvano and Ramesh Yerraballi](http://users.ece.utexas.edu/%7Evalvano/Volume1/E-Book/) This is an e-book for the introductory embedded systems course at my school. It focuses on ARM architecture, and is done starting from the very basics, and moves to fundamentals of microcontroller programming like interrupts, UART, etc. and how you apply them. This e-book has multiple videos for each section, and guided activities that you can program along with. There is also a free online course accompanying the book [here](https://www.edx.org/course/embedded-systems-shape-world-utaustinx-ut-6-10x). I recommend it because the online course gives you access to the labs, and the simulators used to grade the lab activities I believe. That way you can get actual experience with feedback.
Jesus fucking christ you're pedantic. `uchar.h` and `wctype.h` Uchar was added as an extension to C99, and fully included in C11. wctype was included in C Amendment 1, aka C 95, and was fully included in C99.
This is really great. Thank you.
There is no standard way to do that. I recommend you to query what architecture you compile for in your building scripts and then write the result to some header file (conventionally named `config.h`). &gt; and it's not just the architecture, but the family as well, for Intel alone, there are 3 different registers depending on if it supports SSE (and possibly AVX?), Pentium, or 286/386. Typically you use `cpuid` to see what the processor supports at runtime and then configure all appropriate FPUs. On other architectures, like ARM, there might not be a way to find out what floating point unit is available.
If you know more stuff like this, please send it my way.
I think the question in the title is rhetorical, OP realizes it is possible but he/she is frustrated at failing to be able to write the correct code.
God i love this stuff. Keep up the good work op (if you are the one writing it).
If you need to keep a reference to the first character, you will need another pointer (static char *ptr), otherwise you can increment your buffer pointer. Make sure you increment enough to move past the end of your closing tag. Also check that temp &lt; temp2, as I can think of situations where that won't be the case.
Which multi threading library do you use?
No apology needed, and thank you, your answer was infact very helpful, as I had not known about the qsort.
Not trying to be snarky, but what would you have done different? 
I'm sorry, but I'm not the author. You can ask him, he's /u/rwh_casts.
Yes, it is working as intended. You're comparing `0.01f` (a single precision value) against `0.01` (a double precision value.) These are two different approximations of the actual value 0.01, which cannot be represented by the computer using binary floating point. The former happens to be slightly less than the latter, so the condition is true. 0.01f is 0.00999999977648258209228515625 and 0.01 is 0.01000000000000000020816681711721685132943093776702880859375, FYI. It's just random luck that the float is less than the double. It's equally possible that the float is larger than the double, for example `0.08f` is 0.800000011920928955078125 and `0.08` is 0.8000000000000000444089209850062616169452667236328125. 
I don't think his code sucks, but that was kind of weird: do { if (*argv) { } } while(*argv) why not just write: while(*argv) { } Edit: Also the variables declared at 3:50 should be at the top since C90 forbids mixing code with declarations. Nevertheless I think this is an awesome series and I'll definitely look forward to new videos!
First time I see this way to declare function parameters... I always did `int main(int argc, char **argv)`. Is there any reason to do like he did ?
A class in C++ is just a struct with `private` as the default access modifier, `public` is what you're used to, you can access `public` data member freely. C++ is an object oriented language, an important part of an OOP language is information hiding. So you can create a `class`/`struct` which has members (variables/functions) which can only be accessed inside of that class by member functions. the `Shader` class only uses `public`, so you can just change it to a struct and remove the access modifier. &amp;nbsp; Member functions are just functions that operate on a specific instance of an class which is passed as `this`. C doesn't have member functions, instead you just use normal functions which takes a pointer to a struct as parameter. So in C++ you'd just have `void Use()` as a member function. In C it would be a normal function `void Use(Shader* this)`, `this` is passed explicitly. &amp;nbsp; The function `Shader(const GLchar* vertexPath, const GLchar* fragmentPath);` is a constructor which is called whenever an instance of Shader is created. In C you'd just create a function like this `void Shader_init(Shader* this, const GLchar* vertexPath, const GLchar* fragmentPath);` which you need to call *yourself*. `ifstream` is how C++ reads from files, and `string` is an easy to use string class. --- I'm not sure if there's any point in imitating classes in C, you could probably just use the OpenGL API and leave it at that.
How about [MISRA C](https://en.wikipedia.org/wiki/MISRA_C) ?
Rust is good. Some day I will try it.
&gt; The problem with MISRA C is that it is hard to find a free MISRA rules checker That's true. But you don't need it in order to follow the guidelines and you don't need any extensions to the language standard itself. That was your question - is it possible. Obviously it is. There's a caveat always though. In this case, a checker or pdf with the guidelines or both in order to enforce the rules.
What do you mean by safe?
I agree that C is not the right tool if you want safe programming. If you want to use it anyway you way want to follow those guidelines: https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard
You've mentioned Ada, same thing. Wonderful, wonderful language, but everything seems to be tied to one company these days. 
I'm so glad you enjoyed it! I'll be working down through the BSD /usr/bin directory for as long as people are interested. Next one should be out in two weeks! (in the intervening week, I'll be releasing another episode of my paid screencasts, which covers re-writing Git. And thanks /u/nullball for repping my screencast website!)
I guess using floats isn't that good of an idea :P. Thanks for the answer!
Yes, safe C is eminently possible. Just don't exploit undefined behavior, or lean too heavily in implementation defined behavior. There may be constraints on a given project where it's not very feasible nor very easy to write it safely. 
http://floating-point-gui.de/
The TMS570 in specific looks to have an entire smallish "safety" ecosystem surrounding it. 
His code will not close the opened files (except the last one), also, BSD cat doesn't terminate if it couldn't open a file, it just moves to the next one.
No, bugs are not always a result of poor design. For example, sometimes it's just a typo. And yes, you can do much more mistakes in a pure C than in Ada with SPARK. The question is about two languages. No, it's about C - how to make programs written in C safe? My criterion - less bugs per line of code. Also, testing doesn't guarantee that your code is bug-free. It just postulates that a program meet some specification. There are also other methods of proving that code is "bug-free", for example, formal verification (SPARK, Frama-C, Haskell was used for seL4 verification). I use TDD, it's just not possible to avoid all bugs. Even NASA has bugs in there software. In my turn I can recommend googletest framework - it is much easier to use than CppUTest or Unity.
Yes, that's right. But how do you feel is it possible to create programs in C with the same reliability as the ones written in Ada? Because, I have a feeling that it is definitely possible and not so hard.
This is how I did it: https://github.com/ErikWallstrom/API/blob/master/shaderprogram.h https://github.com/ErikWallstrom/API/blob/master/src/shaderprogram.c
&gt; No, bugs are not always a result of poor design. The "[cleanroom method](https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19820016143.pdf)" (the method used by NASA) gets around 1 bug per 1k lines. [DJB](http://cr.yp.to/qmail.html) is around 1 bug per 17k lines. That there exist bugs despite good design does not mean that better process and better up-front design doesn't have the single biggest impact on defect-reduction *when compared to anything else*.
There is no existing case where a platform would do that. Watch the video. Not all bugs are assumed to cause destruction, and this is just a bug. If you believe that every bug you write into a program can cause death and destruction, then there is no way you could write a single line of code.
Ok, let's assume that we already have the ideal design. Program was written in a specification. Now we should implement it. There are two possible ways to do it - with Ada or with C. So, the question is - is it possible for an average C programmer write with modern tools the code which will meet requirements to the same extent as an Ada program written by an average Ada programmer?
I'll just say that you're far from the first one having that feeling and that I have yet to find a non-trivial C program without many C-related bugs.
There are not *that many* rules to follow to ensure safety. Static/dynamic checkers are fine, so far as they go, but they won't make a bad design safe. Nothing can. 
MISRA is fine as far as it goes. 
&gt; Based on what did you make this assumption? if it is possible, then how? Based on the fact that you asked if "it is possible". Of course it is possible because anything is possible. Even winning the lottery. It isn't very likely however. &gt; I want to hear about someone's experience on switching from Ada to C &gt; about experience of utilizing both languages in task with same safety requirements You've defined safe as "[Less bugs per line of code](https://www.reddit.com/r/C_Programming/comments/6b3hkk/safe_c_is_it_possible/dhjl7py/?context=1)" and have ignored the fact that some of the lowest-bug-count programs are written in C. You should study those examples and their history, and learn the authors *process* for developing it. Process is key. &gt; I want to figure out how to achieve such results. Program for a few decades in an environment where your software has to function fit-for-business and you'll figure it out, or you'll starve. 
Ok, process is a key. And design is another key. I fully agree with that. But the question was about two languages. I think the discussion has got stuck. Probably, because I don't want to discuss design and process question. 
Certainly, it just requires some additional effort on part of the Programmer.
Your post got caught in our spam filter. I apologize for the inconvenience.
Yes, I sent you a private message.
It is not a false dilemma, it is called a comparison. if I say "what is the best language: Ada or C", that would be a false dilemma. But I asked: "Is it possible to achieve in C same results as in Ada?". Sorry, I quit this discussion.
About A: You can't exactly argue something is a toy. About B: Yeah. About C: I know. Just wanted to present something by someone who already did it somewhere at least. About D: By trolling I admitted defeat a long time ago (not the best method I know). I'm sorry.
That is an extremely kind offer; the problem is more how to frame the project. What should it be? 
You could start with a smaller data set (5 or 10 integers) and ensure it works correctly for that small set. Then unleash the furry. ;-)
There are a lot of things that are not systematic, for example: a coding standard choice, validation techniques, usage of tools like valgrind and gdb. I think they could be united into the system. Also, I think that there are a lot of similar books. For example, "21st Century –°" tries to review good C programming techniques and patterns and all programming environment like git, makefiles and autotools. But it is harder to find a book which tries to provide user with information how to create more safe programs. So, as for me, it is better to find the goal of such a book.
For anything financial, just store the number of cents as an integer value, and convert to dollars as needed.
&gt; Yes, bug-free code is possible. Until you recognize that fact, you will be fighting a losing battle with debugging. Pretty sure that there have been proofs that zero-bug code is impossible. But part of this becomes because you can't adjust for random errors in the CPU itself.
[This blog post](http://www.thegeekstuff.com/2012/05/c-mutex-examples/?refcom) does a good job of explaining mutex locks and demonstrating the syntax. 
Just want to mention you can't guarantee directly interfacing with a C++ class. If it has any virtuals or is derived it will have an opaque vtable, which is why most libs have C accessor wrappers.
Have you tried using a debugger like GDB? It can show you where exactly the crash happens. Don't guess where the crash is; it's likely that you'll be wrong. Also, `scanf` is returning values that you're ignoring. That means you're doing absolutely no validation for any of the input you're getting whenever you use it, which is certainly part of the problem.
GDB doesn't have to be intergrated into an IDE, but I wasn't thinking about the fact that you may have been using Windows, which makes things complicated. I'm unsure about what the best way to proceed is; I avoid doing any sort of programming on Windows as much as possible. Nonetheless, I'd look into fixing up your `scanf` invocations, as that is probably tripping you up. `scanf` is pretty complicated and may be doing things you don't expect.
That did work, fflush(stdin) did work!! Thank you!! but, I placed the fflush(stdin) very intuitively just before I invoked the while loop(of the problem area) and the code ran. How can this happen when the entire while block does not even use the information in the input buffer?(https://pastebin.com/xCXJek0w)
but, scanf(" %c", &amp;check) would ignore whitespaces right? and not '\n'?
Thanks i figure it out!!! The 2*3 since j will be plus one every time it looping until the multiple more than. 10000 but since there are lots of way to make program for prime number im just wondering is it possible for beginner person to write prime number program with this way of thinking? Its to complicated :/ And printf ("%4d\n",i) seems dont work(?)
Would you mind formatting this to make it more readable?
You're invoking undefined behavior. As you said, if you write `%x` in a format string, the corresponding argument must be type `int` (and not `long`, that's also UB; `char` and `short` are implicitly promoted to `int` so they're acceptable.) You can't just pass a float and expect anything meaningful to happen. The result is just nonsense. I don't know what you're asking here. If you want to print the floating point value as if it was an integer, then you already have that. That's what `valc` is for. If you want the hex-float representation, use `%a` (or `%A` if you want upper case letters.) This is a C99 feature. 
You should really read up on scanf. The space in the format will consume any number of whitespace characters and '\n' is one of the whitespace characters.
So I can print the float value in hex using %a? For some reason this isn't coming up when I search it on google. I need to sleep now so I'll try it out later. Thanks for the info.
Ok, I understand. This reminds me of the toHexString method that java has for its floating point wrapper classes. For my own knowledge, can you think of any other way besides unions to print the hex value of a float? Also, I can't use the same method with double because the frac field of double es too large. Not sure what to do about that.
Do you mean you want to print the hex values of the individual bytes? You don't need to do use a union to do that. #include &lt;stdio.h&gt; void hex_dump(unsigned char *buf, size_t size) { for(size_t i = 0; i &lt; size; i++) { printf("%02hhx ", buf[i]); } printf("\n"); } int main(void) { float g = 6.67408e-11f; double h = 6.626070040e-34; hex_dump((unsigned char *)&amp;g, sizeof(g)); hex_dump((unsigned char *)&amp;h, sizeof(h)); } Note that this will expose the endianness of the system it's running on. And you can dump a region of memory of arbitrary size. Note also that type punning like this usually violates the strict aliasing rules (and consequently invokes undefined behavior) but char is allowed to alias any type, so this usage is specifically allowed. 
sweet, thank you! 
Awesome. I never thought about it like that. thats a really clever way of doing it
its an online class on data structure and algorithm i submit it to the course website.
C++ class = C's struct + internal functions to operate on the struct. You can do all of that in C, the code would just look different.
If that means your code is causing warnings... You should fix it.
&gt;compiles correctly but does not ask for user input.I need guidelines in correctly the C++ code in C correctly. Of course it doesn't, C doesn't do anything for you, at all. You have to do everything yourself, including asking for input. Just include a print statement before scanf(...) like printf( "Enter n: " ); Also, why do you have empty if clauses? Why do you even bother checking those conditions if you don't act on them? And what does knapsack(...) do?
Agree you need the &amp; only if you want the memory adress, which you need for scanf() but not for printf()
Ah I didn't notice the ampersand. Thank you. Why does %f need a double though instead of float?
&gt; Why does %f need a double though instead of float? It's just the way vararg functions work; floats are always promoted to doubles. [more info](http://stackoverflow.com/a/11270603/365496) 
That comment says int is promoted to double as well. I'm probably not understanding correctly, but why would one need to typecast at all if it's going to be promoted anyway? 
Where do you see that? It says &gt; `char` and `short` are promoted to `int` &gt; &gt; `float` is promoted to `double`
As an addendum, a turn-based game like tic-tac-toe (a.k.a. "noughts and crosses") would probably be easier than a more interactive game like pong. Also, if you're on Windows, I think you can use a different library called PDCurses. ncurses is used on Linux distributions.
No, it says, "char and short are promoted to int". Then it says, "float is promoted to double". The comma between separates them as two phrases. Though I could see one misreading the punctuation. Not sure what your question about typecasting is. There's no typecasting going on. If you're confused that "%f" expects a double argument, I think you should divorce yourself from the notion that the 'f' means "float". Rather it just stands for "floating-point". Both float and double are floating-point types. And, the "%f" is really just an indicator of how to print something, not really the type it's expected to print from. Note that there's also "%e" and "%g", which are other ways of printing the same floating-point types.
I don't see anywhere that it says ints are promoted to double and that would be incorrect. It does say char and short are promoted to int, which is correct. &gt; but why would one need to typecast at all if it's going to be promoted anyway? You don't need to typecast anything. I do often see casts used as documentation or just to ensure consistency. E.g: printf("%i", (int)x); Since passing inconsistent types results in undefined behavior, ensuring consistency is very important. The explicit cast above allows a reader to see in a single place that the types are consistent, and may enable extra warnings or errors checking the type conversions. Or perhaps you're asking why the format strings have to specify types; E.g. why there's `%hi` for short. Not all arguments are promoted to the same type, so there is some need to differentiate. `int`, `double`, and `long long`, for example, are (potentially) passed differently, so the function needs to know which in order to get the values correctly. But even when an argument is promoted it could be useful to know the original, un-promoted type, so that the function knows the expected range of values. For example if you say you're passing a short to `printf()` then a value in the range of short will be printed: printf("%hi", 1000000); // prints whatever (short)1000000 produces instead of 1000000 
Sry, misread.
Okay, thanks. That was helpful.
Yes, when you use the value of a `char` to assign to an `int` variable, it gets automatically promoted to `int`, no typecast needed. In your statement `avg = ((float)totalPoints/10);`, the typecast is needed because both `totalPoints` and `10` are of type `int`. If you don't have the typecast to `float`, the operation that will be performed is integer division - that is, the result will have no decimal/fractional part. Usually, you don't want that when you're computing an average, because you want the added precision. So you typecast one of the operands to `float` (or `double`). That will cause the division to be implemented as a floating-point division. The other operand is then promoted to the appropriate floating-point type as well. And you'll get the precision your were looking for.
But if it's `avg = totalPoints/10.0`, would the result be in `int` due to `totalPoints` or `float` due to `10.0`? Basically what I'm trying to ask is how do you know what type you'll end up with if multiple types are present?
&gt; However, the result from my union method seems like it implies big endian. No, it does not. If you print it as an `int`, you do not expose the endianness of the system. That would not be very useful. When printing an integer, you want to know its value, not its underlying representation. In other words, if you have the integer `0x1a2b3c4d` stored in an `int` variable, then printing that value always prints `0x1a2b3c4d`, regardless of whether it's actually stored in memory as `0x1a 0x2b 0x3c 0x4d` or `0x4d 0x3c 0x2b 0x1a`. The endianness of the underlying system is only exposed if you look at individual bytes, not when you look at the integer as a whole. And this is not in any way specific to `printf()`, it's the inherent nature of how integers work. It would be completely insane if it was possible that writing `int foo = 439041101` would result on some systems as `foo` being actually equal to `1295788826`. &gt; what is the difference between %x and %hhx `%hhx` is the format specifier for printing an unsigned char. `%x` is the format specifier for printing an unsigned int. Arguments that are passed as part of the ellipsis part of a variadic function undergo the default argument promotions, which means that passing an unsigned char is promoted to int, so using `%x` will work. However, it's better to have the format string match the argument type, since it makes the intent more clear and it avoids mistakes. Some compilers will also be able to diagnose mistakes if you use the proper format specifier; for example if you used `%hhx` but accidentally passed `int` as the argument, you'll get a warning under clang and possibly gcc. If you used `%x` there's no warning because the compiler cannot see the proper intent. And also the code will potentially print a value wider than a char, causing potentially run-time calamity. With `%hhx` you are only ever printing the least significant byte of the passed int, even if by mistake you pass something that wasn't a char that was promoted to int (and which was not the result of zero-extension or sign-extension.) 
Terminals really are [capable of pretty graphics](http://i.imgur.com/nz906Wc.gif).
Yeah, that game looks cool. Is it similar to dwarf fortress? Edit holy shit youre the dev nice work !
http://imgur.com/a/h1N9T
i think this format is not complete format we must have to add more detail in it ?
Rust ensures robust code?
Purely in C, either have one program produce all the output, or use OS specific routines to adjust the cursor location on your output terminal. On unixy systems you could also use a shell one liner or script that invokes [paste](https://www.gnu.org/software/coreutils/manual/html_node/paste-invocation.html) on the output of the two programs. That would be my first choice. Edit: for bash and zsh: paste &lt;(./prog1) &lt;(./prog2) should do the trick. 
That depends on your operating system. Which operating system do you want to program for?
You can either look up documentation on your OS's sound API (waveOut or XAudio on Windows, ALSA or PulseAudio on Linux and whatever Mac OS uses) or use a portable API, like PortAudio (I personally used it for a small project at work once).
You can also give [Soundio](https://github.com/andrewrk/libsoundio) a try.
In the strings in *the code*, to input some special characters you can't really normally type with an keyboard, you use eg. `'\n'` for an line feed (`0x0A`), `'\r'` for an carriage return (`0x0D`) and `'\0'` for an null-byte (`0x00`). However, now the `\`-character is now being used to "escape" these chars, so you do `'\\'` to get the normal backslash (`0x5C`). So an string `"\t\\\n"` is stored as `09 5C 0A 00` (all hex, with the null-byte). If you read an tab, an backspace and an new line (eg from `stdin`), then your program reads the bytes `09 5C 0A`. This conversation just happens while compiling and not at runtime. [Wikipedia has an table of the ASCII characters](https://en.wikipedia.org/wiki/ASCII#Control_characters). Column [d] represents the way you can insert this character in an string in the code.
I'm not sure I totally understand your question but "\\\" isn't one character, it's just that you have to put \ before \ so the C compiler will recognize it as a backslash just like any other escape sequence. The ASCII hex number is still 5C.
Escaping text in a string or character literal is processed at compile time. When you write "Hello \\\\ World" in the code, the compiler translates that to a single \ . Your compiled program will contain a string "Hello \ World" that contains only one \ When you read a single \ from a terminal, there is no escaping going in. You will read that single \ When you write \\\\ in a string in your source code, that is 2 ASCII character, each with the ascii value of 92. The compiler translates that to a single character when it generates the executable. The escape sequence exists in the source code only. Same if you write a string in your source code of "\n" , that is two characters, ascii value 92 and 110. The compiler handles this escape sequence, it replaces the two characters with one single ascii character with the value 10 (the newline character). You can try e.g. printf("length = %zu\n", strlen("\\\\\\n\t"); , this will be 3, as the compiler replaces the escape sequences with their 3 ascii values.
If you want people to help you, try to cut it down to just the relevant parts. Most people won't spend hours pouring through hundreds of lines of code to help you. Have you tried debugging? 
You should be thinking about strings as sequences of bytes (chars). For example, the string "Hello \\ World" is a number of bytes. The 'H' is internally represented by the number 72 when using Ascii. So your program outputs 72 and the terminal know Ascii and then decides to light up pixels so they form an H. It continues until it hits the famous null byte at the end of the string. To make your shell move the cursor onto a new line, a program has to print the number ten. However, C does not allow line breaks within your string. char str[] = "This does not work"; In order to work around that, C introduced escaped sequences. The '\n' gets turned into just one byte with the value 10 at compile time. Likewise, '\\', even though it consists of two backslashes, it just one byte (92). So this whole escaping business is just a way for programmers to type characters they otherwise couldn't. Check your ascii map via `man ascii` in the terminal.
Ok, but if type `\` into the terminal and if I want to capture my input and check if the next character is `\`, then I have to do this `if(c = '\\')`, so, does the text stream convert `\` to `\\`? 
No conversion happens on text input, just like if you type "\n" into a terminal and read it in you'll get two characters - a backslash and an 'n'. The only conversion is from what you type in the C source file into ASCII. `\\` in a C string (or character) means the ASCII character '\' in all situations. `\\` isn't defined by ASCII, nor are `\n` or `\t`, but they are how C strings represent the ASCII characters at code points `5c`, `0a` and `09` respectively. We tend to use `\n` and `\t` colloquially when talking about them though, because people are generally familiar with how C represents those characters, and it's simpler than typing "the ASCII line feed character" each time. There's no need to use `\\` to mean '\' when typing in English, though.
/u/ratatask just answered your question. To quote an old adage, ‚ÄúI can explain it to you, but I can't understand it for you‚Äù...
oh ok I misunderstood your problem. I just noticed that was the only place in updaterecord where it looked like the file was actually being written. Looking at it in gdb, it's possible "clear" might be causing weirdness. If the first name I use is "franklin", and the second is "K", in updaterecord when the program calls printf("\nThe length of the new record is: %d", (int)strlen(record-&gt;name)); this is what it shows when I print record-&gt;name in the debugger: "K\000\000nklin". Although, it's worth noting that on my system, strlen for the new name looks correct. Then again, I'm running linux and I noticed your filename has a windows pathname, so maybe windows is just acting strange. You might have more luck just zeroing the memory before you store the new name. 
Yeah, and not in a good way. they're trying to chase webdevs wayyy too much.
What is the question?
Thanks brother. it worked. But the problem is that, i cannot editi get_data() function, i was writing dummy code for my code in production. I need to use a new API which will take void* and will pass a pointer to the array of structures. In my function, i need to display the data in the structures to the users. Your comment helped me alot. Hope you help me in identifying the real solution also.. 
How about... no? I answered your question. If this answer is unsatisfactory, explain why.
Is it philosophical!! or mystical!! or comical! i cant categorize your answer. I asked for help in programming. You are telling shit.! (Atleast thats what it sounded)
You asked how to change the code such that it still works if you remove that line. I provided an answer that does that. Is it perhaps something else you want to know? Are there any extra rules you haven't told us? In other words, your question is so vague that it's not possible to give a better answer than the one I gave.
No, I told you that when you read a \ from a terminal, your code gets a single \ . Then I told you that the compiler translates a \\\\ in your source code to a single \ if (c == '\\\\') is your source code, the source code gets compiled, and during compilation the compiler has translated the '\\\\' to a single character '\'. This happens when you compile your code, which is before you run the code. When you run your code and the code reads a \, the c variable will contain a single \ , or if you view it as a number, c contains the ascii code for a \ , which is 92. Thus when you run your code, you are comparing a \ to a \ * Note that if (c == '\\\\') is the same as if (c == 92) * Note that if (c = '\\\\') is an entirely different beast, it assigns 92 to c and the if statement will always evaluate to true. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [AUTplayed/imguralbumbot/.../**README.md** (master ‚Üí 2c20641)](https://github.com/AUTplayed/imguralbumbot/blob/2c20641640311c0e91f44c56943e325755595aa5/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhnmrko.)^.
Meta: don't they teach proper indentation in school? No professional shop would accept this. If you're on a Unix system (MacOS, Linux, BSD, etc.) there's even a program that will do it for you: indent(1). The vi editor will also do it (see the '=' command) for(i=2; i &lt;= 100; i++) { if (prime[i] == 1) { for (j=i; i*j &lt; 10000; j++) { prime[i*j] = 0; } } } There, isn't that nicer?
mentioning every tiny bit seems like a bad idea. For example I did a couple of projects in C#, but adding it to CV would be a bad idea, since I do not really know C#. How can I add something I am not sure about? &gt;Good would be a reference to contributions to open source projects. Good idea will definitely do that. I will start searching/browsing for potential ones today even. Just to get an idea of what I could get myself into. Thank you for advice. It is appreciated. 
I don't know if I agree with your professor in regard to printing, but that does not really matter. One thing to think about though is to always check the return value when using malloc. If for instance the number (read from user input) is very big malloc might fail to allocate the memory and return NULL. That would cause problems in your program later on when you try to use that memory. 
Looks pretty good. If you wanted to you could have the whole thing in one loop, keeping track of the min, max and sum as you loop through. This would mean you dont have to allocate any memory dynamically, which would be nice.
I was just passing by, haven't read/wrote any C in 4-5 months. All I can say is that it's clean AF. I'm no pro but something about the coding style is just so easy to read and understand to me. Good job bro.
This is nuts. 1. Line 82: You are not printing the length of the string. 2. Wtf does clear() do. That code looks like uncompiled insanity. 3. Look at your question, how is anyone supposed to understand what you are asking. Try thinking about what the question you are asking actually is? Not just line numbers and telling us it is being weird? Why is it being weird, what do you think the code in question is supposed to do and what does it actually do? If you can put into english what you want your entire program to do and what the problem you are facing is then we can maybe help you and give you some more pointers along the way.
I second that, I'm still pretty beginner in C but that is beautifully written which is far too uncommon!
Functions that don't modify a buffer should declare it as const, for example `int getMaxNumber(const int numbers[], int size)`. Speaking of that function, it's broken if size == 0, as it will still try to derefence the first element. If you're lazy you could just throw an `assert(size &gt; 0);` in the beginning.
Looks really, really good. Some nitpicks, though: - What happens when the user enters a number less than zero? - You initialize your min and max to the first element of the array in getMinNumber and getMaxNumber, but then the first value you compare it to is also the first element. You could start the loop at 1 instead of 0. - If you were to call getMinNumber and getMaxNumber with an array size of 0 you access and return a value that's not allocated. I think it's acceptable to add a comment that this function should always be called with an array with 1 or more elements, and then add an assert to make sure of this. You'd also have to make sure the user enters a number greater than 0. - You have prototypes of your functions at the start. I try to order my function definitions in such a way that functions are always defined before they are used (which means that main() always ends up at the end). Some people really hate this, though.
I can spot three different ways to crash this program: - Size &lt; 0 leads to malloc failing - Size &gt; X can lead to malloc falling if not enough memory left - Size calculation can overflow, for instance 0x40000001 * sizeof(int) is 4! This results in an out of bounds access. 
The professor didn't say anything about error checking and I am aware it can crash. I should just always program them error safe though; I'll definitely change that. Thanks!
A good rule of thumb is to always initialize your variable upon creation and to create your variables as close to use as possible. Old style C programmers will often put the variables all at the beginning of the code like this guy did, which is perfectly fine. It is also perfectly fine to initialize them if you put them at the beginning. It would be better / faster (or at least more modern style) to create them and initialize them at the same time. int minNum = getMinNumber(numbers, arraySize); But placing them all at the beginning and initializing them sorta helps for understanding the point of the code without having to read much or have any comments. 
congratz!
I liked beginning c by Ivor Horton better Down vote me all you want, beginning c is **far** better
Also in the manual (further down): &gt; **Notes** &gt;By default, Linux f ollows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available. In case it turns out that the system is out of memory, one or more processes will be killed by the OOM killer. For more information, see the description of /proc/sys/vm/overcommit_memory and /proc/sys/vm/oom_adj in proc(5), and the Linux kernel source file Documentation/vm/overcommit-accounting. 
This is one of those terrible half-truths. Even when overcommit is enabled malloc will reutrn NULL when you run out of address space. You'll also find Linux running on systems without MMU. Please, always check for NULL, at the very minimum with an assert. 
This is how I learnt C as well.
See this: http://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo
For each its own.
Ducky represent? :)
Green is the cheap foreign edition printed on thinner paper. It has the exact same content though. 
Real programmers use 1st edition
Nice keeb. Good luck with your programming adventures!
I stand (partially) corrected. Of course if you give it a size of 0, you still get NULL.
Coming from a Swift background, it comes natural. Should I not do it?
I got the next edition... the "++" edition.
I'm asking. Coming from a OO background it is natural but perl and bash and I thought C were not.
Assuming they run the program on a Linux. What if they ran it on a Windows?
The C standard library only supports POSIX regular expressions. If you want Perl-like regular expressions, you'll need to use something like PCRE.
I have been dying to ask somebody about this. I got one from a library but it is really small, like maybe 150 pages. So do I have the real one or is it an abridged version? It seems to me like a programming language book should be pretty bulky
Do you mean [this](http://i.imgur.com/sJDGP0a.jpg) old thing?
You dereference head when you shouldn't, this should not even compile.
Yeah, I suspect that `read_music`s signature should read: void read_music(Node **head, char *string) Given that they tested it, maybe they accidentally deleted it while trying to format the code?
Could you elaborate? What was better about it? I already own K&amp;R, but i love a good excuse to buy more books.
I don't have the book on me but that sounds about the right size. Part of the reason it's so revered is because of its small size.
POSIX regular expressions do not support backreferences and `?:`. Try to rewrite your regular expression without that.
It's a very small book, partially because K&amp;R were very good at brevity, partially because C is not a large language and partially because unlike many programming textbooks, it's not aiming to teach you programming from the ground up.
maybe I dunno.... fflush()
Just got this in the mail last night. 
Old timer here, seems to me that a language book should be a hundred pages long...
[First Editions checking in](http://i.imgur.com/RPBrUGz.jpg) and HHKB humble brag.
If you're just going to assert a non-null result, you might as well not do anything. Your program will segfault on the first attempt to dereference the null pointer. BTW, you don't need to cast the return value from `malloc()` or `calloc()`; you should print error messages to `stderr`, not `stdout`; and the correct spelling of `FUNCTION` and `LINE` is `__func__` and `__LINE__`. Oh, and the third option: #define myalloc(ptr, size) do { \ if (((ptr) = calloc(1, (size))) == NULL) { \ fprintf(stderr, "allocation error at %s:%d\n", __func__, __LINE__); \ exit(EXIT_FAILURE); \ } \ } while (0) Remember, though, that if `calloc()` failed, there is a good chance that `fprintf()` will too, because it usually needs to allocate memory. So you may want to use something like `assert(fprintf(...) &gt; 0)`, or just force a segfault then and there: #define myalloc(ptr, size) do { \ if (((ptr) = calloc(1, (size))) == NULL) \ *(int *)NULL = 0; /* segfault! */ \ } while (0) 
Your my_calloc() won't work if one of its arguments is 0, because calloc can return NULL in that case. Usually malloc() should be more performant than calloc() because it doesn't have to initialize the memory, so unless you really need initialized memory, you might want to use malloc(). calloc() has the feature of checking for wrap-around when multiplying its two arguments, but if you are writing a wrapper anyway, you can do this yourself, i.e. fail if `(size &amp;&amp; nitems &gt; SIZE_MAX / size)`, and `malloc(nitems * size)` otherwise. You shouldn't cast the return value of calloc. I wouldn't use assert() for checking for memory allocation errors. assert() should only be used for checking for programming errors, not for runtime errors due to limited resources. Better either exit the program with `exit(EXIT_FAILURE)` or `abort()`. (And especially in library code, you shouldn't exit at all, but instead somehow report the error to the calling function.)
EDIT: I've gotten it all to work with your strdup() approach, though, I was hoping to take the long road so I got a better nuts-and-bolts understanding. In the effort for completion, I'm moving forward with strdup() and might come back later to try to implement the more hands-on method. Thanks all. Thanks, I've implemented most of what you've recommended (thanks for noticing the bit with the integer values. I knew they weren't working, but that was going to be a question for another day lol). So, I'm still having trouble implementing your thoughts on allocating memory for each string value in the node. My updated code for that section: char *temp; temp = strtok(string, ","); new_node-&gt;data.artist = malloc(strlen(new_node-&gt;data.artist) + 1); strcpy(temp, new_node-&gt;data.artist); temp = strtok(NULL, ","); new_node-&gt;data.album = malloc(strlen(new_node-&gt;data.album) + 1); strcpy(temp, new_node-&gt;data.album); And so forth for each Record field. However, this crashes. Debugging, it appears my error to be at the the first instance of: new_node-&gt;data.artist = malloc(strlen(new_node-&gt;data.artist) + 1); Now, I notice you used malloc(strlen(artist) + 1) whereas I'm subbing in new_node-&gt;data.artist since that's the only place I've defined the artist string as is. Am I misinterpreting your thought process?
Ahh that sucks :(
It's everywhere. It's still viable for writing small- and large-scale projects. It doesn't hide the machine bits from you. It gives you the most control (short of assembler). It's survived since the 70's. Lots of those modern languages have interpreters or compilers written in C...
Nice! Have fun with it, I prefer hardcopy above ecopy most of the time though 
C is not the language for this. Other guy suggested powershell. Python also has what you're looking for
Yes.
Program* Excel since 2010 I think supports exporting to PDF? If nothing else, there's always CSV that they've supported for ages.
I want! Nice :) 
With C, nothing is impossible. If it can be done on a computer, it can be done in C, and it can run as fast as any of them, anywhere. You can't say that about any other language except assembly (ignoring that C++ is an extension of C).
You can say that about any Turing-complete programming language...
&gt; Usually malloc() should be more performant than calloc() because it doesn't have to initialize the memory, so unless you really need initialized memory, you might want to use malloc() Not at all. That's a misconception https://vorpus.org/blog/why-does-calloc-exist/ 
I'm not saying it would be terribly efficient, just that it is possible.
Provide evidence for your claim. Name something that can be done in C but not python.
You can't technically do that in C, either. The "register" keyword does not guarantee you a register. What C function do you use for moving values between registers? 
Turing completeness only dictates the ability to do computation, not interact with the system. Brainfuck is turing complete. You can't do any syscalls in it, other than the equivilent of getchar and putchar.
Many language compilers are written in C (PHP, python, ruby). Many operating systems (pretty much every *nix variant, parts of Windows, OSX, iOS) You can build web apps/REST APIs with it (and I know some places are hiring for that sort of thing). Obviously it's very important in embedded systems which is a growing field with the IoT trend. id Software wrote most of their games in C (but I believe that's not true any more). nginx, apache, curl, postgres, mysql... these 5 tools will be behind an insane amount of the infrastructure that is the world wide web. Most other network protocols have a dominant C implementation as well.
For me, the best reason is that I can build "furniture" in C and arrange that furniture into a working system. I can't often find "furniture" readily available that might fit as well as what I can make by hand. 
&gt; \^C doesn't respond Probably because Python handles SIGINT itself. \^\ should still work.
Can Python run as fast as C? No. Can Python run on any system including embedded? No. Insert any other language above. 
If there aren't any holes, extra padding, or other data you can take the length of the file in bytes and divide by the size of the structure in bytes. fseek() and ftell() will be useful, or various system dependant functions like stat().
thanks a lot
On Windows: Cntrl + p then on the printer section click 'Print To PDF' On Mac: command + p then at the left Botton click the drop down menu and select "Save As PDF" You could also learn about Git and make a C program that reads that file, also in the same repository, and simply have your group run the program to see your current grade. 
&gt; 29: Always validate that malloc returned something reasonable. Nothing fancy, just: if (numbers == NULL) { printf("Can't allocate %d ints\n", arraySize); exit (1); } Using `perror()` from `errno.h` might be a nice touch though.
&gt; threading We had threading in 1987 with Microsoft C on OS/2. In 1991 it was in the public previews on Windows NT. One of the big demos was... Threading.
C still dominates the embedded systems world so thoroughly there's not really another viable option for most platforms. Even if it ever ceases to be used in practice, C will be taught to programming students like Latin is taught to language students.
I hate to be that guy ^(no I don't) ^^Rust:)
I write in C every day. Pays my mortgage.
Look it up on MSDN.
https://msdn.microsoft.com/en-us/library/windows/desktop/ms724295(v=vs.85).aspx
A lot of what has already been said here I agree with. But I would like to add (or stress) that using C really forces you to understand how things work at a basic level, like how variables map to memory, memory management, really how pointers work and reference vs copied values. Most modern languages obfuscate a lot of this, and C is just bare.
I'm wary of dedicating myself to learning Rust simply because it's still a pretty new language and doesn't have a lot of adopters. That's not to say it doesn't have its fair share of advantages.
Arrays are always passed as pointers. So the second evaluation of `sizeof` is really taking the size of `char *`. If you need to know the size of the array, you need to pass it as a separate argument or use a terminator (like a null terminator).
If we are being pedantic, that's enough to interact with the system. Its just you'd interact with it like an actual turing machine instead of a computer.
Yeah. I don't think even that's required of a turing complete system. Practically you do need *some* way to have I/O, maybe setting the contents of some cells to be a value and then reading them out again.
It's actually in stdio.h, but yeah, it's a good idea to use it. 
`int main()` in a definition is equivalent to `int main(void)` and is a valid stylistic choice. 
Go get one!! worth every penny
While I'm currently looking for work, dont think I'd fit the bill. Junior/Mid level ruby dev in the SLC area just picking up C. Aerospace embedded systems sounds like an awesome gig. If it truly is *Entry* level PM me.
Another note: C allows variable length arrays (sort of, they are optional in the newer version of the language). So, unlike C++, you can do this: int foo(unsigned int n) { char data[1 + (n % 256)]; return sizeof(data); } So unlike any other use of `sizeof`, the result of `sizeof(data)` is not known until run time (all other uses are known at compile time). So this is a situation where `sizeof` can return different values. Also, as an aside, variable length arrays can be risky to use, since they can be made too large and cause stack overflow. In the example above, if it had been `char data[1 + n]` and someone passed in `n = 1U &lt;&lt; 30`, my program would crash. The exact value of `n` that would cause a crash can't be predicted and will depend on what else is happening in the program at that time.
I speak both, and even though I won't use Rust at work for *years* it's definitely helping polish my behaviors in C. 
Do you *need* to run as fast as C for 99% of cases?
Not the point. Then, again, if everything ran faster cause it was written in C, you wouldn't need as high powered a computer to do the same work as one written in Python.
Yeah you'd be spending all the saved time actually writing the program because for most cases, programs in Python are quicker to write. Maybe not safer, you just get a different set of issues. Buffer overflows on lists and other memory fuckups fail a lot louder though in Python.
[removed]
Good to meet you then! Don't sweat about it too much, we all have our quirks when we program. Keep up the good work sir and I hope to see more videos from you!
I always appreciate any feedback. So, thanks :)
There's no reason you couldn't compile a python "bootloader". I don't know why you would, but you could.....
You can access DLLs/libraries written in inline assembly in python. I don't know why you would, but you could.
That doesn't sound like a convincing argument to me. Additionally, you're not guaranteed to get a segmentation fault when accessing NULL. That is a feature of POSIX systems, I believe. On windows, it triggers structured exception handling, allowing you to attach a debugger to the process. But because every OS handles this problem differently, it's what the standard calls "undefined behavior", which means anything can happen. When you have no virtual memory, it may just mean that you're writing to address zero. Back in the times of MSDOS, this meant that we had to power cycle our computers, because that's where the interrupt vector table of the 8086 lives, and if you're stomping over those, it's game over. Having to reboot each time you run out of memory was a pain in the butt. Here's how long it took: https://www.youtube.com/watch?v=6MxzRfsR-jA tl;dr: don't write to NULL. 
Well pardon me for assuming a modern, sensible OS on a modern, sensible computer.
I'm not entirely sure what you're trying to say, but it sounds like you're basically trying to reimplement the at_exit function?
That's not true. C has had the asm keyword since at least C99.
In my view you can achive the same effect by using a do{ .. }while(false} loop.
Well, at_exit would be for the whole program if I understand correctly. But, what I mean would be just for the function you're in.
Then why not use `goto`? It shows your intentions and is much clearer
Being able to do inline assembly does not mean you can switch two registers around in C. It means you can use inline assembly, and you'd better make damn sure the compiler knows what registers you're clobbering so it can fix the mess you make when the inline assembly returns. You still don't have any assurances of what values are in what register, without using assembly. 
This was interesting. In theory, for maximum efficiency, if someone were to multi-thread a job that could be threaded a theoretical infinite number of times on a system with an unknown number of cores, would it be best to: * Check the number of cores on the specific machine on the fly, then use an array of thread variables with an array of function pointers to make the threads, or * Use a minimum number of threads? Does it even work that way? Is there a maximum number that can be created?
Like generals, programmers fight the last war. Before functional programming, before object-oriented programming, before top-down programming (we're talking the 1960's here), It wasn't unusual to have an entire program be in a single module with gotos everywhere. A now-famous computer scientist [observed](http://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf) that this style made it difficult to reason about code. He was absolutely right. However, C doesn't provide the control flow mechanism like Go's *defer* or C++/Java/Python's exceptions. So we make due and construct our own cleanup mechanism using goto. Done conservatively, and using the identical pattern every time, we reduce alligator effect and cleanup copy pasta, while still maintaining the ability to reason about our code.
If you were to open more threads than CPUs, you'd be subject to context shifting. 8 threads on a 4 core machine will cause all processes to run at 50% (theoretically) and constantly switch back and forth between each. Regarding the max number of threads, it's dependent per system. On my machine (Xubuntu 16.04) the max is 256,561 as per /proc/sys/kernel/threads-max. For application design, you could count the number of threads. Git does this, for instance. When Git compresses object files, it does so using the max number of cores available on your machine. Sometimes threading is lightweight and keeping track of each individual thread is not your goal. I work on a project where the benefit of threading is simply doing things in parallel, rather than doing a heavy task really really fast by utilizing 100% of the resources the computer has. In the former scenario, opening 100 threads is really not a big deal and any attempt to optimize it would simply be premature optimization with little to no return.
Not really, `do` ‚Ä¶ `while(false)` is a common way to limit nested `if`s where shared code continues after `while(false)`. On the other hand, `goto` is very useful in limiting nested `do` ‚Ä¶ `while(false)` for each resource acquisition. Both have their use.
That's very interesting. Thanks, and thanks for the video as well!
I fail to see how `break;` is better than `goto cleanup;`
Sometimes I have a function do the resource acquisition, then pass the resource handles to a function that has the various faiulre cases. The cleanup can then go in the outer function without any `break`, `goto` etc.
Do you happen to know where in the Linux kernel I could find this? Really curious. I thought atexit() was preferred for these situations and goto was just a design issue that usually has a better solution. My understanding is goto has a bad rep because it's used by mid to novice level programmers that don't know the better solutions. I'd like to see where really good programmers are forced to use it and why. 
With gcc, use the -E option. With MSVC, it's‚Äã -P. If you're using another compiler, read the documentation.
This is why VB6 had On Error GoTo. It actually worked pretty well
Do you use additional plugins for syntax highlighting?
&gt; So, why do people seem to dislike doing things like this? Because you will get it wrong and it will bite you. See [goto fail](http://lmgtfy.com?q=goto+fail).
Pardon me for assuming that those are not what's going to be used inside a modern IoT device. But if you want to put Linux in every fitness tracker and light bulb, be my guest.
Braceless if statements seem more responsible than the gotos for that particular case: [The Apple goto fail vulnerability: lessons learned](https://www.dwheeler.com/essays/apple-goto-fail.html).
Not to mention the lack of *testing*.
If you need more than Sin/Tri/Squ/Saw, ytou can have a look [here](https://github.com/PaulBatchelor/Soundpipe)
Thanks. Still not totally clear. I wrote a comment under the other comment.
To do anything useful you have to do more than glance at code. 
OP here isn't an engineer writing software for embedded devices, they're a newbie doing school assignments or hobby projects on their PC.
The third edition of Volume 1 (covering sockets) was worked on by two other (well qualified) people after Stevens died. It came out in 2003. The errata hasn't been updated since 2004. Nobody's been updating or editing it for well over a decade. Both volumes are still classic works that are very relevant. But bringing out a new edition would be like a new version of K&amp;R. It just wouldn't be the same. Better to leave the classics alone and strive to produce something different and hopefully better if ever needed. 
Unless you are trying to write a database, use a database. Otherwise you'll get to know the joy of locking "records" locking either the entire file or regions, pre-allocating chunks, mutexes and good grief.. so much hell.
~~Trying to mix buffered I/o with threads like that is going to give you a bad time.~~ stdio is fairly thread safe, but you still need to fflush() before reading after writing, or use a few other functions before writing after reading. And is rw+ even a valid mode for fopen()? See http://en.cppreference.com/w/c/io/fopen for details on all that. Also, why not use actual read/write locks? https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032u/index.html Also, you're using sizeof() wrong. 
Now with 100% less thredding!
For C, no. Atom editor is fairly complete when it comes to that kind of stuff. Looking at my packages list, I'm currently using 3 that are noteworthy: - atom-beautify: Helps unify format on more languages - minimap-codeglance: Show a preview of all your code on the right, also acts as a scrollbar. - tabs-to-spaces: Does exactly what it sounds like. Strange it's not part of Atom core.
Please show us your source code, only then it is possible to see what the problem is.
Look into IoT
Thanks.
OK, folks. I'm very grateful for your attention. The code is at https://pastebin.com/d3dUTk0S Thanks!
Immediate readability is important. 
So your saying don't write in c. 
"glance value", don't do anything an imbecile wouldn't instantly understand ergo don't write in c (that means you).
Pelles/LCC is not terribly popular, so you‚Äôre probably going to want to go off-toolchain for something like this, unless all you need is to run the preprocessor standalone. Eclipse CDT has a feature where you can step back and forth through preprocessor expansion; select something with a macro replacement in it and hit Ctrl+= to bring it up. Useful for gnarlier, Boost-ish stuff, although different preprocessor makes vary some in terms of expansion details so it‚Äôs not all encompassing. For GNU/related compilers (e.g., Clang, Intel C), flag `-dM` dumps all defined macros as of the end of preprocessing in lieu of normal output, which comes in especially handy for seeing what the built-in macros are. I don‚Äôt see that for Pelles‚Äîlooks like `-d` does somethiing different if the `lcc` page is right.
I did something like this on an STM32 mcu a while back and just used a lookup table. The DMA shuffled the waveform samples into the DAC register from RAM and was triggered by one of the internal timers. To change the frequency of my signal, I just modified the clock division for the timer to get the desired value. What microcontroller are you using? The actual signal generation part is going to depend on the hardware. 
Might want to post on /r/iot or /r/electronics. Doing lots of networking in C tends to not be fun and makes it really really easy for you to have numerous vulnerabilities. You don't want to be part of that crowd. 
Most vehicles, planes, or equipment with electronic components have some level of embedded program running on them. As it so happens, some of these devices can be quite fun to work on (things that go fast, lift big things, etc.)
You need to put four blanks in front of every line of code so the code is formatted as code. Then you can also input asterisks. Please read the [commenting wiki page](https://www.reddit.com/wiki/commenting) for details. &gt; I've tried: ‚Ä¢mode = maxMode, but it gives me a warning If you receive a warning, please always tell us what the warning is. We are not clairvoyant!
`sizeof` for arrays only work if the compiler can deduce the size. Any array sent as a function parameter will lose that information. Consider this example: #include &lt;stdio.h&gt; void arrsize(int a[]) { printf("%d\n", sizeof(a)); } int main(int argc, char **argv) { int arr[10]; printf("%d\n", sizeof(arr)); arrsize(arr); } It will print: 40 4 Because the compiler can know the size of `arr` in `main()` but not whatever comes into `arrsize()`. After all, who knows where such an array might even come from? It might be dynamically allocated through `malloc` or just be a pointer to something.
just want to use the logic of sizeof
Semantically, although technically the standard doesn't prohibit an implementation from translating VLAs to calls to `malloc` and `free` or equivalent. For instance, after `longjmp` it's not guaranteed that VLAs from *jumped over* stack frames will be released. This is yet another reason to avoid VLAs.
Yes. Traditionally, `sizeof` was a macro defined like this: #define sizeof(x) ((&amp;(x) + 1) - &amp;(x))
&gt; I believe I'm not pointing my char pointer to the address of maxMode, or am I? Yes, you are doing exactly that. However, as the function has its own copy of `mode`, the value of `mode` in the caller is unaffected. Perhaps you could use `memcpy` to overwrite the content of `mode` with `maxMode`?
What operating system are you programming for? Do you want this to be a graphical application?
Im using Windows 10 right now. And no, the more simpler, the better.
I recommend you to program against the libsdl. It can do graphics, sound, and input for you.
Another vote for SDL .. it has what you need.
You declare `cedulas` to be an array of integers. Integers can't have fractional values like `0.50`. For that reason, the compiler discards the fractional part and initialises your array as int cedulas[12] = { 100, 50, 20, 10, 5, 2, 1, 0, 0, 0, 0, 0 }; When you later divide by `cedulas[a]`, you divide by zero, which causes your program to crash as dividing by zero is undefined behaviour. Perhaps you wanted to make `quantia` and `cedulas` arrays of `double` so they can have fractional parts?
I see, but apparently the % operator only works in integers, and without it I can't use for loop for this situation, at least not so simply...is there a way I can use c√©dulas and valor as integers and somehow transform them into floats? Thanks for the answer!
You can use the `fmod()` function from `math.h` to compute modules on floating point numbers. One other possibility is to multiply `valor` and the content of `cedulas` with 100 so you always work with cents. This way, each value is an integer.
BRB, im testing everything you guys said. 
Thank you very much for that. That is the first time I see that. I'm only confused about the NULL in pthread_create and pthread_join and overall it was a little fast for me.
Okay guys I'm back, and it's been a long long ride. First of all my code now looks like this: #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define round(quantia) ((quantia &gt;= floor(quantia) + 0.99) ? (quantia + 0.009) : quantia) int main(){ int a; float valor, quantia[12]; float cedulas[12]={100, 50, 20, 10, 5, 2, 1, 0.50, 0.25, 0.10, 0.05, 0.01}; scanf("%f", &amp;valor); for(a = 0; a &lt;= 11; a++){ quantia[a] = valor / cedulas[a]; valor = round(fmod(valor, cedulas[a])); /*este for armazena os valores das quantias*/ } printf("NOTAS:\n"); for(a = 0; a &lt;= 6; a++){ printf("%d nota(s) de R$ %.2f\n", (int)(quantia[a]), cedulas[a]); } printf("MOEDAS:\n"); for(a = 7; a &lt;= 11; a++){ printf("%d moeda(s) de R$ %.2f\n", (int)round(quantia[a]), cedulas[a]); } return 0; } I've tried what has been suggested here, like multiplying cedulas by 100 but it it didn't work because it wouldn't meet the requirements of URI. I've also tried a lot of other things, including that dubious #define but while the code now compiles (using fmod helped immensely getting the modules of the floats, thus enabling compiling of the code) and is almost right, I still can't seem to do it like I want it to be done. I mean, while I was trying to make this code work (with just these 3 fors, if not less) I've had several other solution that could work, but that would mean a bigger code and less opportunities to learn new stuff (I might say that although I've been toying with this code for about 9 hours now (with several breaks, of course) I still feel challenged, not frustrated, and also rewarded for how much I've learned today), so I'm still trying to make this work, and I feel like I'm so close to it. You see, this code works for some situations, but since it makes a lot of float modules, by the time it hits the coins, the numbers aren't round thus making some inconsistencies in the answer. I've tried rounding it better but to no avail. Ideas anyone? Also thanks everyone for the support, really appreciate it! 
Thanks! fmod helped a lot and I surely will be using it in the future.
Sure thing, but I want to do it with a for loop while also attending to the requirements of URI. I also feel like I should learn to manipulate floats to that extent. Thanks for the encouragement! I know how coding is complex and demanding, but with its complexity comes also possibility! 
The input has to be a float, but it doesn't have to stay a float. $12.67 (12 dollars 67 cents) is the same as 1267 cents. I know that 1000 cents = $10. So you can convert the float to an int right after you get it. You may have to accept a float value, but that doesn't mean it has to stay that way. You first attempt had the right idea, and just needed a couple changes and a couple extra lines after the valor input.
&gt; I'm using float points because I want to do it with a for loop There is absolutely no reason why you couldn't do the exact same thing, except better, with integers.
The input has to be in R$ (or $ in your example), not cents, like 576.73 or 4.00, it's a requirement. Also I would have to separate cedulas into two arrays (one for the cells and one for the coins) and I want to do it with just one array. Isn't it possible?
No, you don't. You can multiply everything by 100 to get integer values. When you are done with all your calculations, you can either convert to a floating point, or keep them as integers and just format the output differently.
Could you please make an example with the code I've written? edit: remember the valor has to be inputed as R$ (like 576.73).
What they're saying is that you read in the user's inputted amount, and split before and after the decimal and store them as integers. so $576.73 becomes 576 in a dollars variable, and .73 becomes 73 in a cents variable.
Yeah, but after you get the input, you can convert it into whatever you want. Then if the output also has to be a float, like $0.50 or something, you can just convert it back. I mean, i don't want to just give you a really straight answer, since its an assignment, but you can definitely use one array of ints if you take a float as input and converting it to an int.
NO ONE IS SAYING TO CHANGE WHAT THE USER INPUTS. Were saying to change the inputted values internally (in your app), then to combine it back together on the output.
You need to declare the function declaration first. Put this at line 2: double Cost(double z); Also, you can't just call Cost(), you need to call Cost(z), since this function requires a double to be passed in. 
You can also just move the function higher in the file.
Sorry I posted in the wrong subreddit, I will delete this.
No, it's better to use integers indeed. Have all the variables count cents, and transform to reais (or whatever the currency is) only when printing the values. int cedulas[12] = { 10000, 5000, 2000, 1000, 500, 200, 100, 50, 25, 10, 5, 1 }; then printf("NOTAS:\n%d nota(s) de R$ %.2f\n", quantia[b], cedulas[b]/100.0); 
You answered your own question. Pass `&amp;data` and access its fields with `data-&gt;field`. Think of `data-&gt;field` as syntax sugar for `(*data).field`, i.e. dereferencing the pointer and accessing its field - just like `array[2]` is `*(array + 2)` (notice. the `+ 2` is "plus 2 elements", or "plus 2 times sizeof type"). Think of a pointer of type X as a variable holding an address to a variable of type X, just like `int` holds an integer. Thus, if your argument is a pointer of type `struct global_data` you need to pass an address of type `struct global_data`, i.e. `&amp;data` (`&amp;` is "address of"). 
Yeah, I gave up and did that in the end. I'm used to just being able to pass a reference from within a structure/record, instead of having to individually pass the indexes of each seperate array within a complex structure chain (I have like 3 array structures within global_data in the actual code). But maybe that's just a pascal thing?
[False sharing](https://en.wikipedia.org/wiki/False_sharing) between count1 and count2. Make sure they're at least 64 bytes apart in memory, eg. by wrapping them in a struct and having an array of 64 chars between them.
It's not slower at all! This is a common confusion. clock() measures CPU time, not the actual amount of time passing in the world. I bet your threaded portion is actually performing as you expect. See discussion here: http://stackoverflow.com/questions/2962785/c-using-clock-to-measure-time-in-multi-threaded-programs
It sounds to me like you might somehow be only running on one core. Can you check out top while you're running and see if the other cores are idling? Also, minor nit: the ++ operator is not atomic so there is a race condition in your code involving sync_flag and your code isn't actually guaranteed to terminate.
First and foremost: https://en.m.wikipedia.org/wiki/Buffer_overflow 
Yeah either way you don't want to be writing much C specifically for IoT unless you *really* know what you're doing.
*After all, who knows where such an array might even come from? It might be dynamically allocated through malloc or just be a pointer to something. when you pass an array in C as an argument it is automatically converted to a pointer to that array. This is because it is significantly more efficient to pass a pointer than to pass an array that could be HUGE. Because that has to be copied onto a stack. And that is because C uses copy by value.
You could write your own % function for double or float. This would be terrible advice though. The reason everyone is telling you to use integer values is that float values are almost never without rounding errors! Internally, they use a representation like scientific notation, but normalised and to base 2. This means that some numbers like 0.1 have infinitely repeating digits like 1/3 in decimal floating point notation (0.3333...) and thus can't be stored exactly. If this interests you, check out the IEEE 754 norm! To observe this all you need is a float initialised to 0, and a for loop that cycles ten times adding 0.1 to the float. Each iteration, printf the entire float and you will see. 
I told you‚Äîdo all your calculations in centavos, not in reals. Multiply everything by 100, and divide (using integer division and modulo, not floating point) before displaying. And if I were you, I would also replace `scanf()` with a hand-written parser (doesn't take many lines of code) and possibly take the amount from the command line instead of as input.
I did try that out, but the execution times still remain similar. I made a data structure like how /u/Garuda1Talisman specified in the other comment. The execution time trends were similar and did not change. EDIT: The solution posted by /u/jokesthathadtobemade did work. I am getting a lower execution time for the parallel execution than the serial. I am receiving around 25%-30% reduction in the execution time. But would you happen to know why parallelizing the program reduced the total time by only so much? What are the overheads involved in multi threading? Thanks
&gt; And I'm not sure about what you meant by the ++operator not being atomic. So I changed that part to sync_flag = sync_flag +1. That makes absolutely no difference. You need to use memory barriers (not portable) or protect it with some sort of lock (I recommend a spin lock). But in your case, it's much simpler to just ditch `sync_flag` entirely and use `pthread_join()` instead.
When I measured my execution times using the clock_gettime() function instead of clock(), I did get a timing value for parallel that was lower than serial. This one worked.
Also sync_flag isn't volatile, so I'm surprised your compiler hasn't generating a non-terminating program via optimisations.
Ah, that makes sense - I haven't quite figured out Calloc and Malloc yet, but that seems to be the answer to a lot of the problems I've been having. Thanks!
My Pascal is a bit rusty, but isn't `GlobalData` just a global variable in this case? And what is the declaration of `DataArray`?
Indeed. It is also the reason why the size is shown to be 4 in my example above, since that happens to be the size of pointers for my platform. &gt;This is because it is significantly more efficient to pass a pointer than to pass an array that could be HUGE. I agree that it all boils down to efficiency, but I am not sure it's because an array is inherently "huge". After all, a `struct` could be as large as an array -- even contain arrays -- and be copied with no problems. I think it has more to do with the design decision to have arrays decay to pointers when passed as function arguments, which in turn is likely because arrays don't contain their own sizes, which I suspect has to do with a desire to have pointers and arrays be as alike as possible in operating the underlying data.
The time complexity of `is_prime(n)` is O(n). Therefore checking the range [0, MAX_VALUE/2) will be faster than [MAX_VALUE/2, MAX_VALUE). Checking the latter range will dominate both the serial and parallel versions. Edit: you could change the function so that they both iterate from 0 to MAX_VALUE, but they would partition the range differently that they check every other prime candidate instead of upper half and lower half.
I'll be doing like that, thanks for the advice!
Find out how to read one character at a time from `stdin`. First, initialize `valor` to 0. Now loop over the input until you get a non-whitespace character (try `man isspace` for information on how to best handle this). Verify that this character is a digit and exit if it isn't. Keep updating `valor` until you hit a non-digit character. If that character is a period, read the next two characters, make sure they are both digits, and update `valor` accordingly. Then figure out how to make sure that you reached the end of the input, and exit if you get something you didn't expect. There are simpler ways to do it, but not if you want to avoid rounding errors and guard against all possible mistakes in the input. You can use `strtoul()` for the integer part, but not for the fractional part since you need to be able to tell the difference between .1 and .01; and to use `strtoul()`, you must first read an entire line, which raises a host of other issues.
It sounds like you just want to pass `&amp;data.albums[a].tracks[t].name` in.
Well, that's what I thought would happen but I kept getting errors saying data the pointer types didn't match up. I was just kinda typing in random stuff trying to get it to work though, since I have a deadline. If it helps I think the one that triggered the error was with a third structure (data.albums[i].tracks). I did notice that some of my functions did still work with the after mentioned formatting though - I think it has something to do with whether or not they were passed in as pointers first?
Yeah, that was the first thing I tried, but it just gave me the same error. I figured you needed to write it in a weird way (like how C doesn't accept *data.albums[a].tracks[t]), but maybe there was something else going on?
I don't know what your structures look like so I'm not sure what the type of name is. If name is an array you would remove the &amp; from the front as name is already a pointer.
Oh, you're right, strings are all arrays in C - maybe that was it.
Calloc and malloc simply create a block of memory for you, and return a void pointer (you're supposed to cast it from void * to the struct's type, but that's more or less a semantic thing that my compiler bitches about, AFAICT it's not absolutely nessicary, it just helps it figure out what's going on)
Yeah, you simply create a deinit function that accepts the pointer to your struct, and deletes everything inside it.
But, does that preclude implementing a `freeThing(Thing* thing)` function? If you think of "types, and operations on those types" then I would expect an answer to follow. Of course, the complexity of the type may make this non-trivial. Perhaps an example would help us understand your problem.
Yea, because say I had a complex usage like: x = add(add(1, 2), add(1, 2)). Then I would have memory leaks because the functions wouldn't know if another non-temp var is passed, meaning freeing it could be dangerous. The functions also can't free it themselves or it won't be able to return them. This is the reason for using globals: so I can do x = dostuff(y) instead of losing ergonomics and doing it OO styled like dostuff(x, y).
That wouldn't work for nested function calls, though.
Well, in C you have to explicitly deallocate data allocated with `malloc()`. Automatic variables are deallocated on function return. You might not be able to get around some deconstruction logic.
Well, you can't really do that in C. Perhaps you want a different language.
Nim does look interesting-- but I think I'll toy around with globals and such first and see if any sort of hack can be done to get what I want.
Yeah, this does look complicated. I had a feeling, based on your questions, that it would be. I think I've seen some solutions to similar problems. where the return value is always structured as a container of sorts (linked list, dynamically allocated array, etc) that knows how many items it contains. Then, the `freeThing` function knows how to walk the container of data, freeing them. I hope this makes sense. I have to leave for a while before I can be more clear. 
&gt; Why do you even have an else clause if you don't need it? Just leave it out. The else is just there so I can play around with it and see when it doesn't butcher the loop. &gt; Why is inst marked volatile? It was an attempt to get the compiler to not optimize it. &gt; You also might want to use fgetc() instead of fscanf() in this case. Good idea, might try that.
&gt; free( out ); *out* is a FILE pointer and shouldn't be freed like that ‚Äì it's possible that your program corrupts the underlying FILE data structure before it has been flushed to disk. You have a ton of other issues as well. Don't cast the return value of malloc, don't give types the "_t" extension, since that's reserved by POSIX. Looping one byte at a time on a stream ‚Äì realloc-ing the output buffer by one byte at a time ‚Äì is pretty bad design, as well.
&gt; free (out); You can't `free()` a file pointer! That's undefined behavior. What did you expect this to do? If I fix this, your program seems to work as expected.
Cool project. Have you considered adding tab completion?
I don't know. I just do. Sorry!
Having the entire file in memory shouldn't be a problem. I hope no one took the time to write GiB's worth of brainfuck code. I might try to read it in chunks though, that way I can take into account large files.
The next project at my school (ft_select) is about termcaps/terminfo, I have to learn this first so I can implement tab completion. Thanks!
Oh yes you're right about what the Norm say about the macro. I always struggle comprehending fully the rules written in those PDF. Thanks for pointing this to me by the way, I'll be more inclined to use macro now. The issue with the compilation was because my distro (NixOS) has been hardened recently; adding the flag -Wno-unused-result solved it. BTW you should try "unsetenv OLDPWD ; cd -" and "unsetenv HOME ; cd" in your minishell
42 student I guess ? ;-) I'm an Epitech and just finished my 42sh yesterday ! Great project, enjoy the rest of the year !
Haha, awesome! I love Unix. Thank you, same to you mate.
 char artist[50] = { '\0' } new_entry-&gt;data.artist = artist; you're pointing at a local variable `artist`. When the function ends, `artist` has gone and any pointers to it are invalid.
That's cool, I didn't know you can split the printf on multiple lines like that. It is several calls right now, but it will be drastically smaller once I finish. Those asm lines are temporary and will become raw binary for the final version.
windows and sorry for answering late
If 42 could be followed online it will be great for a lot of people that can't attend in person (for age reasons or location). Pity they don't offer at least the course notes and projects online for other people to follow. 
This is really cool! It's funny to see some weird things that changed. For example, 7.1.7 and 7.1.8 say that if you have primary_lvalue.member_of_struct and primary_expression-&gt;member_of_struct then `primary_lvalue` and `primary_expression` don't *need* to have type "struct" or "pointer to struct", respectively. So how does the compiler know from which struct to get the declaration of `member_of_struct`? The answer is at the end of section 8.5: &gt; The names of structure members and structure tags may be the same as ordinary variables [...] **The same member name can appear in different structures only if the two members are of the same type and if their origin with respect to the structure is the same**; thus separate structures can share a common initial segment. So it doesn't matter exactly which struct contains `member_of_struct`, the compiler just have to pick any struct containing it. That's really weird, but I guess it explains why some structures in the standard library have members with a unique prefix (e.g., all members of `struct stat` have names starting with `st_`).
Basically, the original C language has one shared name space for structure members, with all structures sharing one name space and type checking wasn't a thing. The compiler only stores type and offset from the beginning of the structure for structure members. This was commonly used for type punning, e.g. if you want to type-pun a floating point number, you could do something like this: struct { float f; }; int x = 123; printf("%f\n", x.f);
Does this mean that `return` required parentheses? And I wonder what they were going to use `entry` for...
Thanks ;)
&gt;`return` requiring parentheses just like `if`, `switch`, `while`, and `for` makes sense. I've always been annoyed at people using parentheses for `return`, but that's actually a very good point.
Why will it never be false? Do I have to give ASCII values?
https://www.bell-labs.com/usr/dmr/www/cman.pdf
Character sets have nothing to do with it (and you're presumably using ASCII or a related one already, unless you're working on an IBM mainframe using EDBIC...) Think about it. What possible character will fail to satisfy `choice != 'q' || choice != 'Q'`? Anything but 'q' will be true for the first clause, and 'q' will be true for the second one, so the whole expression is always going to be true no matter what. You need and, not or. 
thx!
Can you please post the entire program at once?
Wow. How did I miss that, I figured out my problem for the program going skits but I couldn't get it to exit. Obviously this is why. You are a gentleman!
The answer is "any that have a C compiler available", which is basically all of them.
Thank You for the Feedback that makes more sense! 
8051 arm dsp and many cheap ICs
I have in mind building a robotic hand using servos and basically getting analog readings from flex sensors. nothing too complicated mainly inputs/outputs, analog reads etc. I think Arduino UNO may suffice?.
Linked lists [suck](https://www.youtube.com/watch?v=YQs6IC-vgmo) in practice, a decent rule of thumb is to never use them. IMHO you should just stick all cards into a dynamic array; 0 to 1147 cards isn't that many. ... the cards doesn't necessarily need any attributes, no? They only need a card id, and then you could lookup the name, text, etc. in some const array of card types. If a player can only have 1 of each card at once you could even have an array of 1147 bits, where every set bit means that the player has that specific card. That structure will only consume 144 bytes and all your operations on it will be in constant time.
Are you planning to use C or C++? The difference matters.
I recommend gcc-supported microcontrollers like AVR, ARM, or maybe PIC32(MIPS). ARM is simpler than AVR because they are 32-bit and have single 32-bit address space, but they can be a bit overkill if an 8-bit AVR is sufficient, and they can be a bit difficult to solder because there are no DIP packaged ARM (except for very low-end LPC chips). PIC, 8051 and others have c compilers too but their architecture is not suited enough to c to have gcc ported (bank-switching, multiple address space)
I think this really depends on your goals for the project and how familiar are you with C and C++. If you want to dig deeper into C or C++ than the standard Arduino 'language' allows and learn the lower level bit twiddling that goes with using a micro, then I wouldn't recommend the Arduino as-is: [drop the Arduino IDE and use the GCC tool-chain](https://balau82.wordpress.com/arduino-in-c/). This approach involves learning more about the AVR micro-controller and less about programming in general depending on your experience. If you just want to practice your higher(ish) level programming skills and play around with some electronics then work away with the Arduino as-is. You might need the Arduino Mega instead of the Uno depending on how many servos you want to drive. Regardless, I think the Arduino is a good place to start, when the project is finished and working, buy a different micro and start again.
Why overcomplicate it? An array would be just fine for what OP is doing.
You need to start with the fact that some numbers are divisible by both 2 and three and go from there.
I don't know what OP is planning with this project. What does the "searching" operation mean? Search by name? By rarity? By category? Maybe he also wants to add more categories in the future. Hash table is also a valid option not just for card storage, but as a lookup table to search for cards that have a specific effect, OP can decide if it is worth it or not for the project. If only a simple "do you have this card/how many" kind of storage is needed, with a cardID number lookup that is consecutive from 0-numberOfCard, then okay.
Nowadays I think every 8bit+ MCU does support C... But I think, weather it support is the one thing, you do have the knowledge of low level programming is the other thing. You need to know how to start the MCU up, how to configure each peripheral as you needed...
it's possible to build a text editor with C? Interesting. 
Read the rules, pictures of code is unacceptable. Paste the code either here or on pastebin.
nano, vim and the core part of emacs are written in C just to name a few.
I don't disagree with what you are saying. However, hash tables are another viable option for OP's problem. &gt; "Granted the amount of data isn't big to be concerned with lookup/inserting/deleting/search times. At this point I just want to implement the *most efficient data structure* for this scenario **if I was dealing with a large amount** of data/cards."
Why shouldn't it be possible?
The array should be a dynamic array because sizjo e can change depending on user input. 
Just as in C++, an array doesn't encode how long it is in C. Note that a `vector&lt;T&gt;` is a *vector,* not an array. You have to keep track of the array's size manually.
why do you need the JDK for C programming? You shouldn't... unless I've totally missed something here.
Your criticism does not apply to all Arduino variants, and only seems to be directed towards the uno. There are Arduino models capable of doing everything you specified (3.3v, on board wifi, ARM based and higher power, not GPIO limited). But even if we were to only consider the Uno, clones are available for $8. The Uno can be switched to 3.3v in less than 10 minutes, and 2.54mm spacing isn't exactly non standard (especially considering RPI gpio is also the same pitch). Wifi is easily added to the base Uno, whether through a $7 extension or through any of the cheap wifi enabled variants. All of this isn't even considering the biggest strength of all, the dev community. Ease of rapid prototyping is a factor for many developers, especially those less familiar with embedded development. The Arduino framework may not always be the fastest or most space efficient, but it does provide a certain ease of use. And the community support for a variety of devices and peripherals isn't something to sneeze at. I'm not saying Arduino is the perfect choice for everything, far from it. But it seems more than OK for OPs use case. And it certainly isn't a poor choice by default.
It's necessary to implement the type-generic macros required by `&lt;tgmath.h&gt;`. Refer to &amp;sect;7.25 of the standard. You can't introduce function overloading without name mangling, which is far too invasive of a change since it's an ABI break. Type-generic macros are a workaround that allow dealing with the explosion of math functions (e.g. each function has version for: float, double, long double, float complex, double complex, long double complex.) 
Yup. Getting started with C is as easy as sudo yum install gcc echo "int main(void){return 0;}" &gt; foo.c gcc foo.c ./a.out
Unless the pointer has the size value prefixing the actual data, ala [Pascal strings](https://en.wikipedia.org/wiki/String_\(computer_science\)#Length-prefixed)
Write your own filesystem that runs commands instead of reading and writing to a device.
There isn't. You have to keep track of how large you made the array separately. So in C you would do something like: int optimal(const int* weights, const int* values, size_t size) { for(int i = 0;i &lt; size;i++) { // do stuff } return whatever; }
`scanf` won't *assign* EOF, it *returns* EOF, correct code would be: int status; while (status = scanf("%f", &amp;input), status == 1) { ... } if (status == EOF) printf("Done.\n");
These videos are great, thank you!
It's been so long since I learned C that I wouldn't feel competent to tell somebody today what the best way to learn is. I did have an IDE (Borland C++) when I did, and it helped me tremendously, mostly for the integrated help, at a time before the internet made it easy to look up stuff. It's entirely possible that the best way to learn is to remove a lot of friction with an IDE first, then learn to go "bare bones" with an editor and compiler on the command line later. That is, if the IDE isn't an additional source of friction, because it requires you to learn Java first, and nobody in your peer group (or in this case, on reddit) can help you get over the bumps because it's an obscure one :-) Maybe OP has a teacher that suggested this IDE? In which case, their advice should probably count for more than that of a redditor. 
Your read_employee and print_employee functions are defined as not taking arguments. You try to call them with arguments. If you want to do that, you have to change the definitions to have arguments.
Because I only want to exercise and test my knowledge of C language :)
&gt; an esoteric language and another (3rd) try at simple OS Interesting projects, but they are too hard for me!
You're very welcome. More to come!
My guess is that's to avoid warnings about unused variable.
I've never seen this usage but I guess it's for suppressing compiler warnings for unused arguments. I think `(void)p;` is more common though.
&gt; You would get fairly inaccurate results, no? Accuracy has nothing to do with it. There is no rounding or conversion happening here. There are 4 bytes in memory, and you can either choose to interpret them as a float or a 32 bit integer. That is what this code is doing. There isn't even any copying, because the compiler will realize that both values alias the same value. (Technically, this is in violation of the strict aliasing rules, so this is invalid ISO C, but it has traditionally been supported by many implementations, although they are getting stricter.) 
I'm looking at my debugger in visual studio. I passed in a value of 10.5f to a function that does the same thing they are doing. The resulting int I read out comes to 1093140480. Looking at the value at the address of the float, the hex values come out to 0x41280000. The bits don't match to anything that would resemble what the original float was. 
&gt; The bits don't match to anything that would resemble what the original float was. Of course they do. 0x41280000 is 0 10000010 01010000000000000000000 The sign is 0, so it's positive. The exponent is 10000010 or 130, but there's a bias value of -127, so that's really +3. The mantissa is 1.0101 (there is an implicit leading 1.) So the value is 1.0101e3 in base 2. You can de-normalize it to 1010.1, again still in base 2. That's 2^(3) + 2^(1) + 2^(-1) = 8 + 2 + 0.5 = 10.5. 
`p=p` is such a weird, dumb way to do it‚Ä¶ looks like a coding error, and may well cause a different warning about assignment-to-self.
A simple OS is actually pretty fun and easy, after you've set up your environment properly. Check out http://wiki.osdev.org
The only way you're going to overcome that issue is by writing code. You can't learn everything just by reading about it. Some guides (such as the tried and true book 'The C Programming Language') have exercises which you can work through to solidify your understanding. I would highly recommend a book such as this.
Not sure why you're being downvoted as IMO it's a perfectly valid opinion. Many new programmers will indeed find it easier at first to learn by simply clicking a button to run your program and see the output. To this end, I think a better solution would be a minimal makefile or a single command on the command line which you can type to run and compile, hiding the nasty details for you. This has the best of both words - a simple compile-and-run in one action, but without the extra baggage that an IDE gives you. Another thing to consider is that most IDEs are geared towards C++ too, which can complicate some things.
Is there some quirk of C semantics that causes the p being assigned to to refer to a global variable or something? Even if that is the case, it seems pretty poor design since it makes the code difficult to understand. And overall, the function seems poorly thought out. Why is it taking an argument pointer that it doesn't use? And furthermore, the name of the function seems to imply that it's to be used in allocating strings, so why is the unused pointer argument and the return type declared as pointer-to-void? It should be pointer-to-char (or better, pointer-to-pointer-to-char, since if the function DID actually use the pointer argument it would presumably have to modify the pointer-to-char to point to the newly allocated memory).
Since it may be hard to puzzle through problems that are effectively going to mirror the ones you get from a course, it may be worthwhile to check out some programming challenges. I've always loved [Project Euler](https://projecteuler.net/), but I'm also a mathematician. r/dailyprogrammer would probably give you a better variety.
**Here's a sneak peek of [/r/dailyprogrammer](https://np.reddit.com/r/dailyprogrammer) using the [top posts](https://np.reddit.com/r/dailyprogrammer/top/?sort=top&amp;t=year) of the year!** \#1: [\[2016-11-21\] Challenge #293 \[Easy\] Defusing the bomb](https://np.reddit.com/r/dailyprogrammer/comments/5e4mde/20161121_challenge_293_easy_defusing_the_bomb/) \#2: [\[2016-12-19\] Challenge #296 \[Easy\] The Twelve Days of...](https://np.reddit.com/r/dailyprogrammer/comments/5j6ggm/20161219_challenge_296_easy_the_twelve_days_of/) \#3: [\[Weekly #25\] Escape the trolls](https://np.reddit.com/r/dailyprogrammer/comments/4vrb8n/weekly_25_escape_the_trolls/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Modulo causes bias (although small for small numbers) and bitmask only allows 2^k - 1 ranges. That doesnt look like the right way to do it.
There's always https://learncodethehardway.org/c/
How to write C, by writing assembly.
Very informative, thank you.
Ok, since you mentioned OpenBSD there is a libbsd on Linux that provides [arc4random](https://github.com/LuaDist/libbsd/blob/master/src/arc4random.c) You can at least view that code and either adopt libbsd (which contains lots of other good things) or pull in just their arc4random code.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [LuaDist/libbsd/.../**arc4random.c** (master ‚Üí a70385d)](https://github.com/LuaDist/libbsd/blob/a70385d07e690015a3c8eea06b1621a4cb127d00/src/arc4random.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply di1wizn.)^.
I have written command line based games, but, not with GUIs
Also a good intermediate step would be to write a game that's "text graphics." So like (for example) a pac-man game that's just based ASCII characters placed on the screen. 
&gt; Not sure why you're being downvoted as IMO it's a perfectly valid opinion. I wasn't even trying to express an opinion, I was trying to add some nuance to the discussion, and find a possible answer to the "why would you use *this* IDE?" question, which is something that I had been wondering myself when I read the OP. As far as I'm concerned, downvotes can't convince me that I'm wrong.
The function is implenting the struct which has the following definition: typedef struct { void *(*Alloc)(void *p, size_t size); void (*Free)(void *p, void *address); /* address can be 0 */ } ISzAlloc; Since the coder (Igor who also wrote the LZMA library) doesnt need `p` in this example he silences the warning. This is just one implementation of this library, in someone else's they could have used `p`. edit: [Heres the file with the struct declaration](https://github.com/google/omaha/blob/master/third_party/lzma/files/C/Types.h) and heres the rest of the struct initialization: static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); } static void SzFree(void *p, void *address) { p = p; MyFree(address); } static ISzAlloc g_Alloc = { SzAlloc, SzFree };
It should be presumed that you had a reason for learning C. So do that. If you had no reason for learning C, then you only wasted your time.
To give you a few ideas. You could write a basic http/client server. A basic bluetooth client server. Start working with GPIO, buttons and LED's. Use nCurses or write different command line utilities for a hex viewer or file viewer. Try writing utilities to read/write content to a database such as mysql or reddis. If you want to get started with games or UI, Freeglut is a good way to get started for learning OpenGL, or GTK3 for more general UI with widgets. 
These vids are great. make - j 4 Never would have guessed that. I watched 4 vids immediately. Good for Engineer Man. True Computer Engineer.
can you point to a resource for GTK3? I don't know if it is not supposed to be done on windows?
Thank you :) I'm just doing the best I can. Expect more videos often. The -j is for jobs. Very useful. Even on a quad core machine, you can reduce compilation time by 75%.
Don't see any reason why we need to see you in the corner. Also a new mic or better mastering would be more pleasant. Soften the voice a bit. Else than that, cool video :)
that's really interesting, thanks. only started looking through C earlier this week in preparation for the next college year. saw your gtk app video yesterday and now this today. good stuff 
Is this some OS or library specific header, or something you're working on?
Are you programming for the MSP430? What IDE do you use?
how to step by step
Nice videos! It would be great if you made a longer episode dedicated to compilation and another about assembly to machine code. 
This type of content is what I subscribed to this sub for. Although, I'm a total beginner still using the K&amp;R book
Basically, you have a bunch of race conditions. In C, it is verboten to concurrently modify a variable without memory barriers or locking inbetween. So all your accesses to `oddSum`, `evenSum`, and `n` are undefined behaviour as you modify all of them in both threads without any locking. # How to fix this There is a number of possibilities. I recommend you to rewrite your program such that `n` remains unmodified with each thread counting its own counter up to `n`. This way, you do not concurrently modify `n`. Second, do not zero out `evenSum` and `oddSum` in both threads. Each thread should only zero out its own accumulator. This way, only one thread modifies each of `evenSum` and `oddSum`. This should fix your issues. In general, you should use some sort of locking mechanism. However, giving an introduction to concurrent programming would be too much for this comment, I recommend you to read an appropriate introductory text.
The gain is fine. You're doing a quite decent job already in terms of audio quality, but since you're willing to improve, I just listened to the above video with super-revealing in-ear monitors and can give you a few tips: The closer the mic is to your mouth, the easier it is to control the voice track in post. With your current setup, you're picking up a lot of background noise and echo. However, you're not trying to do professional voice acting where you'd do multiple takes of each and every sentence and then spend hours on perfecting every little detail in post. So moving your sensitive condenser mic right in your face would do more harm than good: the tiniest details (swallowing, breathing, etc.) would become annoying and distracting. So I'd suggest this instead: For reducing extraneous sounds: Keep the mic at about the same distance, but suspend it high up from a shock mount. That way it's farther from your mouse and keyboard, and more isolated from the low frequency rumble caused by your hands impacting your desk. For reducing background noise: Put some sound absorbing material on the closest walls to deaden reverb. Move the noisy computer farther away from the mic. Maybe do some noise filtering in post, too. There are filter tools/plug-ins that can be fed a short clip of a part where you aren't speaking and 'learn' the profile of the noise to filter out. Don't go overboard with that, though: A constant background hum sounds way better and is less distracting than a crystal clear professional-sound-booth-level voice track that makes every tiny mistake stand out. Also, too aggressive filtering causes ugly artifacts; reigning those in with manual editing would mean an unreasonable amount of work for your purposes. Finally, add a de-esser to your post effects chain. Maybe play with EQ a bit. (Don't forget to use good headphones or monitor speakers while tweaking the settings). In terms of dynamics, I wouldn't do anything; you're great at speaking at a consistent volume, so any compressing/expanding/gating would just accentuate the background noise. P.S.: When listening through my PC's slightly-above-average speakers, you sound pretty good already. The above was written at a level of pedantry commensurate with the accuracy/clarity of your Blue Yeti.
1) While I started C, I researched a bit, and it seems despite of it's rigidness, it has been #1 choice of language out there, though different languages have their own use. 2) I'm a guy who learnt with failure, all self taught, before C I started python, but after I finished a beginner's book(Richard Halterman's draft), the same thing, I had nowhere to go on, and I wasn't aware of forums back then, and I quit python, forgot completely about it. 3)Not really a rush, but, I've never used linux ever before, and just unsure about windows, I thought windows was good, but now it just stinks. I've got some ideas for GUIs that I'd like to create. 4)I'd like to first create a small application, like a file searching application, using GUI, but don't know where to from.
I have linux on a VM, would it be ok to use it on a VM?
Enum values go onto the global namespace IIRC, which means that even if you define one inside a struct, you can still grab the value from anywhere.
&gt; It says in the book that "C uses unsigned int as the basic layout unit for structures with bit fields". Is that to say that the size of a bit-field structure (in bits) will always be some multiple of the number of bits of an unsigned int? Is there a reason why the basic unit is unsigned int? This is just plain wrong. There is no such thing as a ‚Äúbasic layout unit.‚Äù You can use `int`, `unsigned int` and `_Bool` for bit field members. The implementation might allow further types. `unsigned int` is very popular as you don't have to deal with signedness. The code example looks wrong: double square (double 1.2) {return (x*x)} This just doesn't make any sense. You sure you copied this correctly? Make sure to copy the code exactly as how it is written in the book. &gt; Is there some rule that prevents main() from looking at the double() definition in file2 or file3 or spam() from looking at double() from file3? And what does it mean the compiler can chose to use double() definition from file2 or file3 for the case of c)? Is this undefined behaivior since the two double() function definitions are different? Behaviour is undefined if more than one implementations of an inline function exist and they aren't the same. `main()` uses `square()` in `file1.c` because it sees `square()` being declared as a static function, meaning that it isn't visible anywhere else. The `square()` definition in `file1.c` is independent of the others. `spam()` can only use the definition from `file2.c` because the compiler hasn't seen another definition of `square()`. When compiling `file2.c`, the compiler thinks that `square()` is an ordinary external function. `masp()` can use either definition because it sees an inline implementation and thus knows that an external implementation must exist somewhere.
Interesting. So, `__int20` is probably some sort of 20 bit integer type. The only architecture I know with such a type is MSP430X which has a 20 bit ALU. Perhaps that's where it's from.
Sorry, I don't have any personal experience with gtk or qt so I can't help you with this...
The K&amp;R is an excellent book and is exactly what you want to be learning from as a beginner, so wise choice there!
I'm definitely willing to do that. Perhaps I frame it as a "go deeper" video where the expectation is the 5 minutes rule doesn't apply. So far the most consistent piece of positive feedback I receive is how my videos are the perfect length. I need a way to both satisfy what you're asking for as well as keep everyone engaged.
Sure (https://pastebin.com/rbziVreV) The first mention of `__int20` is on line 39.
Very interesting. As a reference to anyone coming here later, MSP430 Options for GCC are here (https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/MSP430-Options.html). The page mentions the flag `-mlarge` which indicates use of large-model addressing (20-bit pointers, 32-bit `size_t`). 
You could draw sine waves into a buffer and then use something like SDL2 to output the buffer to an audio out device.
Never coded gtk on Windows before but on Linux just install the libgtk3-dev package This might help https://www.gtk.org/download/windows.php
What's this Win32 api? Is it something similar to GTK+?
Thanks a lot for the response! Especially the part about the bit-field struct size, makes more sense to me than what I previously thought.
Sorry, the 1.2 was suppose to be x. Regarding the second question, so if let's say we switch the positions of file2 and file3, then am I right to say that masp() will only use the inline definition while spam() is now the one where the linker chooses which definition to use?
This is up to you. If you look further down on the install page they provide links to explain the use of GTK+ with Visual Studio. If you're not comfortable using the command line that's probably your best bet. Otherwise you'll probably need to write your code in a text editor and compile with `mingw`.
As in the contents of file2.c and file3.c were switched, but I think a better question for me to ask would be what differences there are between a static inline function definition and and extern one. Because from your response you say file2.c has not yet seen another definition of square() even though the definition of square in file3.c is extern. Does that mean that the position of the function calls square() in the code relative to any definitions with the same name determines which definition will be used? Sorry for the trouble and thanks for your help! 
A `static inline` function behaves like a `static` function except that you give a hint to the compiler that you want the function to be inlined. A function declared `inline` is an *inline definition* used for inlining. A separate external definition must be present in some translation unit for when the compiler decides not to inline the function. A function declared `extern inline` is just like an `extern` function with the hint that it should be inlined. &gt; Because from your response you say file2.c has not yet seen another definition of square() even though the definition of square in file3.c is extern. The compiler only sees declarations you type in your source code. When you compile `file2.c`, only the `extern` declaration is visible, the `inline` declaration from `file3.c` is not visible because it's in a different file. In `file3.c`, the compiler knows that `square()` must be an external function in some translation unit because that's what an inline declaration demands to exist. &gt; Does that mean that the position of the function calls square() in the code relative to any definitions with the same name determines which definition will be used? Not really. It means that the compiler only knows about things you write into the file you compile right now (or any file you include).
So, you're looking for an editor?
Sounds like you are looking for an IDE or a text editor. Looking for a UI makes me think you need a library to help you create user interfaces from within your program. Atom and Sublime Text are good choices on OS X. You may need plugins for them to do code highlighting and the like.
Are you asking for an editor?
Go to this site: http://www.msys2.org/ Install your version (x86_64 I assume) After installation, press the windows button and search for msys. Start the program and you will be prompted with a shell. Then copy-paste the `pacman -S ...` commands and you will be good to go.
If you're on Ubuntu, it's `apt-get install libgtk-3-dev`. Otherwise, it's a matter of downloading the libraries and placing them in the proper library folder (where GCC can find them). I'll get instructions for this.
There is a fun thing called Direct Digital Synth - DDS. Basically it's a cheap way to generate arbitrarily pitched sample sequences from a waveform lookup table. The theory is a bit beyond me, feel free to look it up. Basically your lookup table would have a full period of your signal, and based on the desired output frequency and sample rate, you find the next sample by incrementing by X in the sample space for each iteration. The interesting part is that the lookup increment is added to an accumulator that represents the phase of the sample. But - you only use the upper N bits of the accumulator as your index into the sample space, which means that the phase can sweep around at 32 bits even if you only have 8 bits worth of samples. Anyway, here's a GCC-compatible example. No guarantees for correctness. #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; typedef struct dds { int16_t *samples; //!&lt; Sample array uint32_t accumulator; //!&lt; Phase accumulator uint32_t increment; //!&lt; Accumulator increment. uint32_t fs; //!&lt; Sample frequency uint32_t f; //!&lt; Frequency to generate } DDS_State; void DDS_init(DDS_State *state, int16_t *samples, uint32_t fs, uint32_t f) { state-&gt;accumulator = 0; state-&gt;fs = fs; state-&gt;f = f; state-&gt;increment = (uint32_t)((uint64_t)0x100000000 * f / fs); state-&gt;samples = samples; } void DDS_setFreq(DDS_State *state, uint32_t f) { state-&gt;f = f; state-&gt;increment = (uint32_t)((uint64_t)0x100000000 * f / state-&gt;fs); } int16_t DDS_getSample(DDS_State *state) { // Get top 2 bits to determine quadrant uint_fast8_t quadrant = state-&gt;accumulator &gt;&gt; 30; // Get index in sample array from bits 22-30 uint8_t index = (state-&gt;accumulator &gt;&gt; 22) &amp; 0xFF; int16_t sample; // Assuming symmetric signal, mirror // the first quadrant into the other 3 as needed. switch(quadrant) { case 0: sample = state-&gt;samples[index]; break; case 1: sample = state-&gt;samples[255 - index]; break; case 2: sample = -state-&gt;samples[index]; break; case 3: sample = -state-&gt;samples[255 - index]; break; } state-&gt;accumulator += state-&gt;increment; return sample; } int16_t DDS_getSampleFullPeriod(DDS_State *state) { // If the sample array is a full period of the signal; int16_t sample = state-&gt;samples[state-&gt;accumulator &gt;&gt; 24]; state-&gt;accumulator += state-&gt;increment; return sample; } // Only one quadrant of a sine wave. Higher resolution. int16_t sine_samples_1quad[] = { 0x0000, 0x00C9, 0x0193, 0x025D, 0x0327, 0x03F1, 0x04BA, 0x0584, 0x064E, 0x0717, 0x07E1, 0x08AA, 0x0973, 0x0A3D, 0x0B06, 0x0BCF, 0x0C98, 0x0D61, 0x0E29, 0x0EF2, 0x0FBA, 0x1082, 0x114A, 0x1212, 0x12DA, 0x13A2, 0x1469, 0x1530, 0x15F7, 0x16BE, 0x1784, 0x184B, 0x1911, 0x19D7, 0x1A9C, 0x1B61, 0x1C26, 0x1CEB, 0x1DB0, 0x1E74, 0x1F38, 0x1FFB, 0x20BF, 0x2182, 0x2244, 0x2307, 0x23C9, 0x248A, 0x254B, 0x260C, 0x26CD, 0x278D, 0x284D, 0x290C, 0x29CB, 0x2A8A, 0x2B48, 0x2C06, 0x2CC3, 0x2D80, 0x2E3C, 0x2EF8, 0x2FB4, 0x306F, 0x3129, 0x31E4, 0x329D, 0x3356, 0x340F, 0x34C7, 0x357F, 0x3636, 0x36EC, 0x37A3, 0x3858, 0x390D, 0x39C1, 0x3A75, 0x3B29, 0x3BDB, 0x3C8D, 0x3D3F, 0x3DF0, 0x3EA0, 0x3F50, 0x3FFF, 0x40AD, 0x415B, 0x4209, 0x42B5, 0x4361, 0x440C, 0x44B7, 0x4561, 0x460A, 0x46B3, 0x475B, 0x4802, 0x48A8, 0x494E, 0x49F3, 0x4A98, 0x4B3B, 0x4BDE, 0x4C81, 0x4D22, 0x4DC3, 0x4E63, 0x4F02, 0x4FA0, 0x503E, 0x50DB, 0x5177, 0x5212, 0x52AD, 0x5346, 0x53DF, 0x5477, 0x550E, 0x55A5, 0x563A, 0x56CF, 0x5763, 0x57F6, 0x5888, 0x591A, 0x59AA, 0x5A3A, 0x5AC9, 0x5B56, 0x5BE3, 0x5C6F, 0x5CFB, 0x5D85, 0x5E0E, 0x5E97, 0x5F1E, 0x5FA5, 0x602A, 0x60AF, 0x6133, 0x61B6, 0x6238, 0x62B9, 0x6339, 0x63B8, 0x6436, 0x64B3, 0x652F, 0x65AA, 0x6624, 0x669D, 0x6715, 0x678D, 0x6803, 0x6878, 0x68EC, 0x695F, 0x69D1, 0x6A42, 0x6AB2, 0x6B21, 0x6B8F, 0x6BFC, 0x6C68, 0x6CD3, 0x6D3C, 0x6DA5, 0x6E0D, 0x6E73, 0x6ED9, 0x6F3D, 0x6FA0, 0x7002, 0x7064, 0x70C4, 0x7123, 0x7180, 0x71DD, 0x7239, 0x7293, 0x72ED, 0x7345, 0x739C, 0x73F2, 0x7447, 0x749B, 0x74EE, 0x753F, 0x7590, 0x75DF, 0x762D, 0x767A, 0x76C6, 0x7710, 0x775A, 0x77A2, 0x77E9, 0x782F, 0x7874, 0x78B8, 0x78FA, 0x793C, 0x797C, 0x79BB, 0x79F9, 0x7A35, 0x7A71, 0x7AAB, 0x7AE4, 0x7B1C, 0x7B52, 0x7B88, 0x7BBC, 0x7BEF, 0x7C21, 0x7C51, 0x7C81, 0x7CAF, 0x7CDC, 0x7D08, 0x7D32, 0x7D5C, 0x7D84, 0x7DAB, 0x7DD1, 0x7DF5, 0x7E18, 0x7E3A, 0x7E5B, 0x7E7B, 0x7E99, 0x7EB6, 0x7ED2, 0x7EED, 0x7F06, 0x7F1E, 0x7F35, 0x7F4B, 0x7F5F, 0x7F73, 0x7F85, 0x7F95, 0x7FA5, 0x7FB3, 0x7FC0, 0x7FCC, 0x7FD7, 0x7FE0, 0x7FE8, 0x7FEF, 0x7FF5, 0x7FF9, 0x7FFC, 0x7FFE, 0x7FFF }; int main() { FILE *fp; fp = fopen("rawsine.bin", "wb"); DDS_State dds; DDS_init(&amp;dds, sine_samples_1quad, 16000, 440); printf("Writing 16000 samples of a 440Hz sine to rawsine.bin\n"); for (int i = 0; i &lt; 16000; ++i) { int16_t smp = DDS_getSample(&amp;dds); fwrite(&amp;smp, sizeof(int16_t), 1, fp); } printf("Appending 16000 samples of a frequency sweep\n"); DDS_init(&amp;dds, sine_samples_1quad, 16000, 50); for (int i = 0; i &lt; 16000; ++i) { int16_t smp = DDS_getSample(&amp;dds); fwrite(&amp;smp, sizeof(int16_t), 1, fp); if ( i % 4 == 0 ) { DDS_setFreq(&amp;dds, 50 + i/4); } } fclose(fp); return 0; } The resulting `rawsine.bin` can be opened in Audacity via File-&gt;Import-&gt;Raw Data and choosing 1 channel, 16000Hz and (on my machine) little endian. You would then call the getSample function every time you need a sample to output. Either by pre-generating a PCM array that the DAC gets via DMA or simply DAC = getSample(..) based on timer ISR. Note that at 16kHz (which is probably appropriate for an embedded device) the last part of the frequency sweep (4kHz) doesn't look too much like a sine wave any more. The samples have been generated offline, I used python for that. For completeness, here's how you can do that for sine. There are probably better ways. &gt;&gt;&gt; from math import sin, trunc, pi &gt;&gt;&gt; import textwrap &gt;&gt;&gt; def frange(start, stop, step): while start &lt; stop: yield start start += step &gt;&gt;&gt; sine_wf_1q = [trunc((2**15 - 1) * sin(phi)) for phi in frange(0, 0.5*pi, 0.5*pi / 255)] &gt;&gt;&gt; print textwrap.fill('{' + ', '. join(['0x%04X' % x for x in sine_wf_1q]) + '};') This gives you 1/4 waveform since PI/2 is a quarter of 2pi :) If you want a sawtooth you wouldn't really need DDS, but if you do use DDS and the sample array is full period as input instead of 1/4 you could use an arbitrary waveform in place of sine. As a bonus, if you need more resolution than 256 samples, you can for example double it by using the top 9 bits of the accumulator as the index. Re-using the first quadrant for sine gives 10 bits, which is nice.
There are 1 semester classes on writing C compilers. Nothing more extensive than that.
It's the built-in libraries for windows programming. Just #include "windows.h", and you've got access to all of windows functions and types. Assuming you're on Windows. It's not the easiest thing to use, but anything that's making a window of some kind on any Windows OS is using it at some level. QT, GTK, etc are all using windows.h on the Windows platform. They usually make it a bit easier to work with, but the basics aren't too hard, and you'll probably learn a lot by just tinkering with it some.
If I program on linux, then, I most obviously wouldn't have access to these then? How would I make my programs work on windows platform then? 
Haven't used it, but what you are probably looking for is a [software synth library](http://audiokit.io/). [CSound](http://www.csounds.com/) or [Port Audio](http://www.portaudio.com/) are a couple of other possibilities. 
Also check out VS Code. 
Thanks, i appreciate it!
http://www.newitjobs.com you can see plenty of new it jobs 
These toolkits, are they for C++ or C? 
I'm interested more in developing GUI apps for desktop, but, What will C be used for in the future then? Do I just forget it? I thought it had platforms that I could implement to
So you are saying that a function like perror that is defined in stdio.h could include stdlib.h, which contains the definition of errno? Or are you saying that a function in stdio.h could include stdio.h? I am focusing only on functions in stdio.h that work with the errno variable. Since errno is considered global, I would expect that if these functions can use it, then I should be able to use it in my main function. I think I might be misunderstanding what you are saying.
Aren't all external variables visible?
I'm saying there are source files, not header files, that get compiled that contain source that's like this: // stdio.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int fopen(const char* name, yadda) { // mess with errno } This source file is compiled into a library that defines fopen. That library is probably the standard library, so it contains both fopen and errno. The source files both include the header that has errno, and at runtime, the C standard library is linked so that uses of errno all use the same place in memory.
* What do you mean by ‚Äúexternal packages‚Äù? * You don't need `&lt;math.h&gt;`. It is only required for floating-point arithmetic. * You don't need parentheses around `i--`. * The book you're using is almost 30 years old, and the standard has undergone two major revisions since then (and is in the process of being revised again). The precise meaning of `int main()` depends on which language version you're using, which in turn depends on which compiler you're using and how you invoke it. The safest option is to always use either `int main(void)` or `int main(int argc, char *argv[])` depending on whether or not you care about command-line arguments.
Hey thanks for taking some time to giving me some feedback. To answer your points: * What I meant with packages was libraries. Some of the times I've asked for feedback I've had responses like "use this or that library to get access to real booleans" etc. Just wanted to clarify that. I think I've just done too much python development lately, so the jargon of packages and modules sort of stuck to me. :) * You are correct that I don't need math as the one static test I am using will not in any part of the execution require floating-point arithmetic. I think that was just a remnant of previous tests. :) * Good point about the parenthesis! :) * The reason I'm running through that book is because it's still one of the top picks for most universities and classes when teaching introduction to C. I'd be happy for advice on other books, though! :) Other than how I setup main, what would be some **important** points to consider at this point in my learning in regards to the newer versions of C?
C is widely used and I doubt that it is going to go away. It is mostly used for low level programming such as operating systems and for embedded programming. You can write GUI programs; the GNOME desktop and the GIMP graphics program are two examples. Most GUI programming is done with object oriented programming just because it is a good fit. OOP can be done in C but it is easier in a language that has built-in support of it. You don't need to forget about C; most programmers know more than one language. 
SDL and allegro can be used in C or C++. There is a C++ wrapper for GTK+ called gtkmm libui and nuklear are pure C, but could probably be used with C++ if you wrote a wrapper. Qt is C++ GTK+ and C++ both can be used with many other languages. 
Thank you.
So, the best choice would be for me to go for C++ and start with Qt then? One last thing, and it almost settles it, what could I possibly do with the C language, so that I slowly build up in C as well as I learn C++?
That's C++, not C... And unreadable thanks to not being formatted for reddit.
&gt; What I meant with packages was libraries. I think you're confusing headers with libraries. The standard C library had hundreds of functions and variables which are declared in a few dozen different headers. Your program uses two headers (one of them unnecessarily) but only one library. &gt; what would be some important points to consider at this point in my learning in regards to the newer versions of C? There are relatively few changes to the language itself but many new library functions, and some of those described in the book have been deprecated. What's more, you will rarely if ever work in a pure C environment. If you're programming in Linux, BSD or macOS, you will have to learn at least a subset of POSIX (if you're programming in Windows, find out how to install Linux, BSD or macOS instead). The best way to learn is to read and modify existing code, and refer to the documentation or ask for help if you encounter something you don't understand. Also, find out how to turn on compiler warnings (`-Wall -Wextra` for gcc and clang) and fix everything the compiler complains about. The compiler is not always right, but at your level, it is better to assume that it is.
In C, libraries and header files are independent. A header file tells the compiler ‚Äúthese things exist somewhere and have these types.‚Äù Header files are not necessary to use a function‚Äîyou could just declare it yourself. Libraries provide implementations for functions. The C standard library is traditionally split into two parts: The standard library, libc, and the mathematical library, libm. The latter can be linked into your program using the `-lm` operand to the compiler. The libc is always linked in.
C++ is a superset of C, so what you learn in C will be useful in C++. Qt is a nice toolkit and is supported on just about every platform. In addition to its extensive built-in widgets, there are many 3rd party libraries that you can use. If you like programming in C, as I do, take a look at GTK+. GTK+ is not as widely supported on none Unix based platforms (Windows), but it is still widely used and capable toolkit. I found that the docs for Qt are better, so it is probably a better place to start. I have done little OOP and found Qt pretty easy to work with.
&gt; I am especially interested in how I could possibly make the loop a bit more effective as I really don't like that I need to use a second statement to divide number... What's funny is that GCC doesn't generate any division at all (it makes funky bit manipulation and a multiplication to avoid the cost of division). Even with `-O0`, which I find a bit disturbing.
That signal is `SIGWINCH`, ncurses should handle it automatically.
Sounds like I should skip mathgl and be using gnuplot? See that's why I asked :P. 
Bash is a shell, entirely separate from GCC. You can run one without the other.
I think [clang](https://clang.llvm.org/) compiler is available for all major operating systems. I don't know MathGL, but as others have said, GNU plot is one option, and if you are at least superficially familiar with Python, then [Matplotlib](https://matplotlib.org/) is an excellent choice. With some knowledge of Cython, you can even call C functions from Python.
Gnuplot is about as easy to learn and use as GDB, which is to say not very. However, once you get some basic stuff down you can come up with very nice results, and it‚Äôs dirt-easy to script (‚Üíautomatically rebuild graphs if the data changes, stuff like that). In general, it‚Äôs easiest to use it with whitespace-separated columns like most POSIX tools do by default, though it takes a few different input formats and it‚Äôs easy to run (numbers-only) CSV through Awk to get a whitespace-separated file.
&gt; Basically it is a plotting only package? Exactly! Though, GNUplot has basic mathematical functions so you can do coordinate transforms and stuff like that on the data before plotting it.
You might want to buy a better microphone. Also, your doodling on the screen is very hard to read. Writing a script before you talk might help, too.
Oh matplotlib is another thing I didn't consider. 
Right. Gcc is run in the bash though? 
Thanks. Seems like c and gnuplot should work for me I currently use Matlab and a bit of python but I want to learn c more. 
You can run any program from Bash, including GCC. You can also run GCC (or any other command) from cmd.exe or Powershell, or however you‚Äôd like‚Äîspawning a program is spawning a program.
Ahh. Well if I just open cmd and try to run GCC it says that it is not a recognized 
Thanks I just installed minGW-w64
That‚Äôll do it. Have fun!
Thanks. I just got helloworld compiled :D
Regarding the `extern` keyword: are all function declarations `extern` by default?
If you don't qualify a function declaration, it's `extern`, yes.
`_Bool` is the builtin type, `bool` is a typedef for `_Bool` from `stdbool.h`.
Someone has written the code for the perror() or fopen() function, they included the proper header files in their source code when they compiled the code for those functions, so that code can refer to errno. This is a very separate thing from your source code including the header file that declares the perror() or fopen() function. You are not compiling the source code for perror() or fopen(), it's already been done. 
On x86 integer division is the worst instruction a compiler can issue. Multiplying with the inverse is soooooo much faster, that this is enabled even for debug builds. 
Don't know. Just learning it myself.
If I remember correctly, C11 has implicit `void` but C99 does not.
Wellm if you use gtk or some other cross-platform library, you can just use that same lubrary to compile for windows. A library like gtk or qt is basically going to give you a bunch of functions to use to make your ui, and behind the scenes it's saying "ok, this guy is compiling for windows, so use the windows versions of these functions" and when you compile for linux it does the same with linux versions of the functions. It basically is creating generic functions with the same names and useage for you, and internally it's loading whatever versions of those functions it needs for whatever platform you compile for. However, the drawback to it is that there will usualky be features that one platform will be able to do that the others don't do, so if you want to use some obscure little windows or linux feature then you might have to do it yourself. 99.9% of the time it's not really an issue, tho. But if you're on windows anyway and don't *need* to support linux to just make little practice or learning programs, it might be easier to just skip trying to get some cross-platform library to work and instead just use whatever essential things you need to make a window and do something inside it. It boils down to what you think will matter later, i guess. If you plan on writing lots of cross-platform stuff, or if you plan on switching to linux at some point, then it would make sense to use something like gtk. Edit: sorry for typos. Im on my tablet right now, hehe.
When you run a program from Bash, it forks Bash's process; Bash remains the parent process, and your program is the new child process. Bash is just a handy way to create processes by referring to them by name. You could just as easily start GCC by creating the process directly in another program, or by using a different shell such as zsh or fish. The results of compiling by invoking your compiler directly from a command-line or by running it through an IDE should be identical, you'll only have differences in the arguments passed and the environment variables.
This info may be interesting to you for an intrusive linked list https://isis.poly.edu/kulesh/stuff/src/klist/
You probably don't know where you will end up working, but maybe it's a good idea to start using the curly braces after every if/else now. It's also nice to use the constant value in the comparison on the left side: instead of if( myInt == 5) use if ( 5 == myInt). It's pretty easy to get used to it. 
You can also set up gnuplot to use directly CSV, without filtering the data through awk
Yes you need to install the GTK developer software
Because if you forget one "=" by mistake if(myInt = 5) will give you a warning in the best case. The worst case is it will assign the variable without notifying you and since its greater than zero, your if condition will always be evaluated as true. If you put the constant value on the left side, you will always get a compile error, because you can't assign something to a constant. The automobile industry defined many of these rules, I think even NASA applies them. A lot of companies have their own guidelines, but many are based on some of these rules. If you are interested you can Google MISRA C. 
cool, thanks. that makes a lot of sense
Thanks for the advice. As far as the type restriction, I've not yet learned how to make a struct or a function that is type ignorant, so I have to stick with int. As for it being restricted to positive numbers, I figured it would be a good idea to have a case for a node with no value, so I chose negative one. I suppose I didn't really need the valueless case in the end, though. And if I really did need it to be signed as well as having a null case, I could dynamically allocate m_data and, of course, use a null pointer for no value. 
Always been bad about that. On my list of things to work on 
What is confusing for many people is that C++ requires a cast when you call a function like `malloc` (which you shouldn't even be doing in C++ anyway, but that's a whole other argument!), whereas C doesn't. Casts are, in general, a "code smell", so you should always think twice before applying them, and consider whether they are actually necessary.
It's harder to read during the first week when you start doing that. Then you get used to it and it's as fast as before. 
Sure, but I imagine you're in the minority.
You can consider PLplot - it's a C plotting library http://plplot.sourceforge.net/ or, if you're using GTK+, SLOPE might do a good job: https://github.com/bytebrew/slope I have not used this libraries yet, but I want to try them sometime.
You could start using GTK3+ and Cairo to build a 2D game written entirelly in C: http://zetcode.com/gfx/cairo/
And so do I, but I'm still not used to it, whereas I imagine most people who use this reverse syntax are also used to it the way I am used to it. Therefore from a purely pragmatic perspective it would be better to use it with the variable first, since you'll get more people who are familiar with reading it that way. And plus if we are in agreement that the compiler will warn anyway, it's purpose is effectively nullified.
As for your second point, I think it's totally fine. K&amp;R does things just like that, and as a tutorial resource it seems to have done quite well, so it's not the worst way to teach things. It also simplifies the logic required massively.
You might have better luck with GNU Global. Download the source, run "htags" in the root directory and it will generate HTML cross reference documentation. This helps for seeing what functions call what and can help in determining "object" lifetimes. Another option if you have Windows available is to use Visual Studio Express and load the codebase‚Äã in that. Let intellisense parse the code and you can explore it interactivly
mingw is a viable option. Should you ever find it limiting, remember that you can also get bash for windows which is a superset of mingw's functionality.
sorry, forgot the numbers didn't stay. line 12 is "fgets(playerinput1, 100, stdin);
I was going to suggest the same thing but wanted to lookup why people do it and came to [this page from the CERT guide](https://www.securecoding.cert.org/confluence/display/c/MEM02-C.+Immediately+cast+the+result+of+a+memory+allocation+function+call+into+a+pointer+to+the+allocated+type) that actually recommends you cast the value. The exception being when writing C90 compliant code.
should I change fgets or stdin, and if so what should i change them to? 
If you want to retrieve a *line of input,* then you have to provide a buffer of characters to store the input. So change `playerinput1` to an array of `char` (e.g. `char playerinput1[100];`) instead of an `int`. To check if the user types `1` or `2`, you can use `strcmp`. A better way is to use `scanf()` to read a number from input, which seems to be more like what you need. You can also first read a line of input using `fgets()` and then parse numbers from that line using `sscanf()`.
You can still use `int` for a positive integer BST, just add a check anywhere you accept a value: if (0 &gt; value){ return; } You also have the option of using `unsigned int` which makes all the integers positive by default. As far as being "type ignorant" (or typeless), that's usually an indication that you'll be using `void *`. Your struct would become struct BSTree{ struct BSTree *m_left, *m_right; void *m_data; }; Which then means you need to allocate memory for `m_data`, store the data at that location, and free the memory when appropriate (like you mentioned). This is the way to make your code into a BST implementation, rather than a `whatever_type` BST. You would also have to support a function that can compare two pieces of data so that `insert_tree` works properly. See `qsort` for an example. The other style of doing this is intrusive and is what /u/hoople [mentioned here](https://www.reddit.com/r/C_Programming/comments/6dr856/code_review_returning_to_c_after_two_semesters_of/di4t62h/). 
Now I'm getting a warning for my if statement "if (playerinput1 == 100)" that says "caparison between pointer and integer". any ideas?
`playerinput1` is an array of characters, it's not a number. In most circumstances, it behaves like a pointer to its first element. If you try to compare it with an integer, the compiler thus rightly complains. If you want to interpret the user input as a number, you have to manually do that. You can do what I said in my previous comment.
Another option I found years ago... http://toolchainguru.blogspot.com/2011/03/c-calltrees-in-bash-revisited.html http://toolchainguru.blogspot.com/2008/07/bash-c-call-trees-and-graphs.html 
I agree, All the other methods are already mentioned in their next article.. :)
Doxygen is more for knowing what you want to do already. To learn how a project works, really you just need either documentation/a tutorial; or to find the main function and start digging.
I was told you're supposed to cast calloc? Is there a difference between malloc and calloc this way? 
What do you mean by pointer on the other side? 
Mind if I ask another dumb question? I'm thinking about arrays and mathematical functions like sin. In Matlab, I can say y=sin(x) and it works for x as a single value or a vector of any size. In C, I cannot do this right? x must be a single value only. And I have to loop in a for loop to get a whole set or values for the function? 
Instead of fgets(playerinput1,100,stdin); you could use scanf("%d", &amp;playerinput1); Your proplem seems to be reading an integer value from stdin (the standard input) instead of passing a string to a function. Please correct me if I'm wrong on that. Passing a string to a function is something quite different. scanf() reads automatically from stdin. If you want to read from some other stream of data you can use fscanf() and define the stream of data similar to fgets. Since you are reading from stdin you can use gets() instead of fgets() and spare the *stdin,* , since gets() implies you want to read from stdin with it. You can see gets as short version for *get s*tring. Also instead of getchar(); in the end of your programm you could use system("PAUSE"); The next step for you to learn could be simple functions and revisiting the basic input/output functions. Functions are really essential to makeing your programming more powerful and giving you a better overview.
Thanks, just confirming what I thought was the case. 
I know this isn't the answer that you were looking for, but your question made me think to myself "Can't I just do this in Google Sheets?". Turns out that I can. https://docs.google.com/spreadsheets/d/11Y6JVSkVRFutvQsJDkJdhNnjzESzrqJf3mSaZ2gZGag/edit?usp=sharing I know this isn't the real answer for you, but I though it was interesting. I'm trying to use formulas in sheets/excel more. We're all learning! :)
A pointer to a const object guarantees that the object wont be modified through that pointer. A constant pointer on the other hand only guarantees that the pointer can't be made to point elsewhere. You can also combine the two into a const pointer to a const. In which case the object nor the pointer can be modified. const char *ptr; // pointer to const char char *const ptr; // const pointer to a char const char *const ptr; // const pointer to a const char
In pure C there are no mathematical functions. You can include the library math.h which includes them, but they are only scalar (one value to one value). The most similar thing to what you want to do can be accomplished with C++ and its mathematical libraries, for example "Armadillo" handles linear algebra in a way similar to MATLATB and Python.
I might also add there's a spot of implicit shenanigans going on - if it were me I would be more explicit about i, particularly. The test is against 100.0 rather than 100, and the assignment to x[i] calculates the integer i divided by the real 100.0 (and so on). IIRC all that is getting converted to doubles, and then thwacked down to a float at the end. :)
Maybe I'll have to look into that later 
If you use 8 byte types in the struct instead of 4 byte `int`s, then you'll see the differences. [\(example\)](https://ideone.com/8LkIMB)
&gt; Just open the file once, in "w" mode, which will wipe any existing data if the file already exists. No need for that remove() stuff. Thank you. The reason I wasn't using "w" mode was that when I had the open command inside the loop, each lime would be written in 1 iteration and then overwritten in the next iteration. So my final output csv file was 6.28whatever 0.0000000 with none of the other values. But moving the open and close outside the loop fixed that issue. So I made that change. That's also why I used the if the file is there delete it, because I had to use "a" mode instead of "w" and "a" would just add to the end. So that was like 2 birds fixed with 1 stone. And why? Probably because I am just used to writing arrays at this point after using matlab for like 7 years. If I was to do this in matlab x and y would have been arrays. In a real code, it's possible that I would then need those x and y values in an array form to do something like perform the trapezoid rule next to integrate. This is just me learning. Is double better than float? 
I've been using `sizeof(*a)` since I learned it was possible. (Well, that's not technically true; for a while, I did `sizeof *a`, without the parentheses, but now I think that's less clear.) It's more specific, and it means you'll avoid an accidental error if the type of `a` has to change for any reason in the future.
Well, of course, that's what I'm trying to demonstrate here.
It's good you note the ability do drop the parentheses when doing a `sizeof *a`. Some people are unclear if/why parenthesis are used with `sizeof`. Here's the skinny: According to 6.5.3, there are two forms for sizeof: sizeof unary-expression sizeof ( type-name ) Thus, we write `sizeof(int)` but `sizeof *a`. And to your question ... I'd definitely go with `sizeof *a` since it is tied to and survives a change in `a`'s type.
If you do struct Foo \*p = sizeof \*p; you get the size of the type p points to - i.e. the same as sizeof(struct Foo) If you do struct Foo \*p = sizeof p; you get the size of the type of p, which is a pointer, i.e. the same as sizeof(struct Foo*)
The fact that you have been using Matlab for a while is why you're thinking about this a little bit different than most C programmers would. Instead of filling in an array, and then manipulating it through the various points, you would figure out a function for a point, and then hand in the various parameters to get the final results you wanted. So, for example, if you wanted to find a slope at a point: double SlopeNearAPoint(double(*f)(double), double a, double b) { return (f(b)-f(a))/(b-a); } And then you could call that with the function you wanted to make a slope with. I've been doing a lot of Matlab-&gt;C conversion manually (to make it readable and maintainable C code instead of the Matlab garbage), and I totally get the Matlab way of thinking of problems vs. the imperative programming way of thinking about problems. So, think of the final value first, and then work backwards.
Contrary to everyone else, apparently, I prefer to use the explicit type. I've seen WAY more bugs due to taking sizeof a pointer than I have seen due to the type of a variable changing. This is less of an issue in modern c++ where raw pointers and malloc/memcpy are rare, but the places where you still need sizeof still make more sense using the type. 
IMO `a = malloc(sizeof(int));` is poor, and worse than `a = (int *)malloc(sizeof(int));`, because you cannot tell just from looking at this line whether or not it is correct. `a = malloc(sizeof(*a));` is obviously correct.
Thank you. And the only difference as I understand it would be to definite double x instead of float x?
Intersting. Thanks. YEah in matlab I would fill the array and then do the math on the array. But it seems like what you are saying with C is that I would do the math and then fill in the points in a sense. Seems like there is a lot more looping in C than matlab maybe because of all this. 
Hey, we just finished the core war game in C. Here is some more background to the history of the game: https://blog.codinghorror.com/core-war-two-programs-enter-one-program-leaves/ Let us know what you think and if you have any feedback. Thanks! üçª
There's a lot more explicit looping -- Matlab is pretty much doing the same operations, it's only assuming various for-loops ahead of time. This makes common matrix/vector operations in Matlab easier to express, but makes general purpose computing annoying.
This is really cool! I recently ran a Core War tournament at DEF CON, and I'm hoping to use this implementation next time I do!
Command-line + whichever classical-style editor (geany, joe, notepad++, nedit ...).
emacs.
ha, that's awesome. I'm glad you liked it. üôåüèº
Emacs with about a thousand lines of elisp.
Good video. Wrapping one's head around pointers can be difficult. I think giving a practical function that uses pointers might have been better, since the function you use can already be done as a single line. One of the first functions I wrote when I finally understood pointers was something like: void swap_ints(int *x, int *y) { int tmp = *y; *y = *x; *x = tmp; } and I used this function extensively to swap values in arrays (e.g. in sorting): if(x[i] &lt; x[i-1]) swap_ints(&amp;x[i], &amp;x[i-1]); There's something about having practical, useful examples like this that helped me understand why we use would ever need to use pointers in the first place.
Cheers! üéâ Yes, give it a spin and let me know what you think! 
Interesting feedback, thanks!
I rarely use an IDE for C programming. I mostly just use the command line and vim as an editor and that is what I've used for the past 15+ years. Occasionally I'll try out an IDE to see what I'm missing. I tried CLion and Visual Studio within the last year. They aren't bad but I've used vim for so long and I'm just used to it. As an example, I would occasionally type vim commands into those editors without having any vim bindings or integration setup so for me I would have to unlearn some of the vim muscle memory. I write C on basically 3 operating systems and prefer an environment that works similar on all. I use OpenBSD, Ubuntu, and Windows, but mostly I don't write code for Windows directly. When using Windows, I do a lot of C programming on a Windows machine over PuTTY connected to OpenBSD or an Ubuntu machine.
Hey dude! I'm also bsically 100% self taught, like I've read a few chapters in books and read forums and shit, but I have absolutely no real training. Anyway, I generally use a pointer to a string to pass them around, or I'll also just use string literals (I think that's what it's called, where you just type quotes and the literal string).
CLion has a Vim plug-in. I've never used it but, it's there.
yes 0!=1. And I have returned 1 on encountering with 0.
&gt; I have returned 1 on encountering with 0. The [final version of your code](http://i.imgur.com/TUIoh5Y.png) suggests that you are *not* returning `1` for `fact(0)`. Instead, it would appear you return `0*fact(-1)` which is both incorrect and *may* result in a frighteningly unchecked trip through *all* of `int` space.
Sure, but that external declaration of errno is not in stdio.h, it is in errno.h. If you reference errno without including errno.h (or another header that includes errno.h), the compiler doesn't know what errno is when it compiles your code, and will complain. The compiler does not go and look for errno in the compiled library code for a function in stdio.h when it is compiling your code, it only looks at the code you wrote and the text in the header files you have included. The point is that just because the code behind a library function that is declared in stdio.h references errno, does not have any connection to errno being visible to your code by including stdio.h. When linking together your code and the library code though, if everything is done correctly, the linker will tie everything up so you all refer to the same errno variable. 
Visual studio Code. I only recently started to use it, so I have not much to tell you about it right now yet, other than it seems nice, has syntax colouring, code analysis (via Clang I think), autocompletion and there seems to be even visual debugger, which I have not use yet.
That's it. Strictly, you then need to switch over to notate your numbers as floats - again to skip those intermediate casting steps. As /u/raevnos says, if you were to use floats, then it makes sense to use the sinf() function over sin(), as sinf expects a float, and returns a float, whereas sin takes a double and gives one back. If you pass sin a float, let's say: float x, a; a = 10.0; x = sin(a); then under the hood it might do something like: a = (float)10.0; x = (float)sin((double)a); In many senses this isn't a problem at all - it's more an awareness thing! Similarly, if I wanted to avoid the float cast with that assignment, I might do: a = 10.0f; The 'f' suffix says "this real number is a float" (typically single precision) rather than the default double.
Hello there, I can really suggest reading [C Programming Language, 2nd Edition](https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628) for questions related to the *C-programming-language*! Other than that [this interactive tutorial](http://www.learn-c.org/en/) pretty much points out the most important subjects you need to know to master the language.
I started with an Udemy course, but I just managed to get the book, so i will dig in asap. Regarding the tutorial, I have a Linux VM that I open every time I need to learn something. Thank you nonetheless. I will try them out(I did use that for a brief period but moved to a VM, because I thought it might help me more) 
Ok perfect. Thank you for pointing it out.
You need to learn programming in general, then you can easily apply the tool C to your problem.
&gt; a = (int *)malloc(sizeof(int)); How is it worse than this?
I explained that in the post you're quoting. The version with cast will generate a compiler diagnostic if `a` is not `int *` (nor `void *`) , but the "worse" version will silently allocate the wrong amount of space. 
Hm. `result[j] = result[j] + wordstring[i];` might not work as you want it to. You are adding the value of the characters in result and wordstring together. This will only have the desired result if `result[i]` is 0, which is not guaranteed to ever be true. I am unsure what `wordstring[j]&lt;i` is supposed to actually be testing. You are comparing a counter with a character. Why? Also: What must every C string end with?
NULL is not guaranteed to be 0x0 in all implementations. Although, in POSIX implementations, it is.
What is that even supposed to mean? The loop stops when the numerical value of the character at position `j` in `wordstring` is less than the counter. Given that you use regular text, and that the lowest ASCII code is 65 (for 'A'), the loop might go for a while.
Better to initialize, struct node *children[27] = {NULL};
A note on style: it's legal, but really unusual and odd to have a function prototype declared inside another function. They're usually present at top level.
it might work better if instead of two "for" loops you do something like this: int i=0, j=charsource-1; do { result[i] = wordstring[j]; j++; i++; count--; } while (count&gt;0 &amp;&amp; wordstring[j] != '\0'); edit: added check for null byte 
Thank you for clarifying, I guess I'm going to use `calloc` then.
Good to know! So, if I use `calloc`, things like if (ptr-&gt;children[c] == NULL) { return false; } ptr = ptr-&gt;children[c]; could cause troubles in non POSIX implementations?
wikipedia forkbombs, for educational purposes only
No, `if (!my_ptr)` and `if (my_ptr == NULL)` are the same. `my_ptr = 0;` is also guaranteed to set `my_ptr` to `NULL`. What is *not* guaranteed is whether something like memset(&amp;my_ptr, 0, sizeof(my_ptr)); or int zero = 0; void *my_ptr = (void *)zero; works.
The syntax would be more like *root = (node) {0}; or without malloc: node root = {0}; which is guaranteed to zero/null out all the fields.
Badass
So if I declare errno as external in my main source code, then the linker will make the connections for me even if I don't include a header file that includes errno.h?
By extrapolating this idea, would a union of unions be fine too? typedef struct AthleteScreen {} AthleteScreen; typedef struct CoachScreen {} CoachScreen; typedef union PersonScreen { AthleteScreen athleteScreen; CoachScreen coachScreen; } Person Screen; typedef union Screen { PersonScreen personScreen; PeopleScreen peopleScreen; } Screen;
Yes. Provided that your external definition matches the actual real definition used on your platform/compiler. Note that this might not simply be extern int errno; , on many platforms there's stuff going on behind the scenes to make errno a thread local variable or similar. You really, really should not try to declare it yourself, just include errno.h.
Thanks, I think I'm just gonna bite the bullet and follow your advice 
I had a cryptography course last semester and in one of my homeworks, I was asked to brute force a 4 character alpha numeric password. This is what I did. (It's the same logic as /u/tea-drinker stated. I think my problem stated that the password would always be a 4 character value. You can always add an extra case in the mapping function to create a null character.) int map1(int x) //maps a number from 0 to 62 to numbers, lower case letters and upper case in that order { int temp = x; int result; if(temp &lt; 10) result = temp + 48; //these are based on ASCII values. else if(temp &gt;= 10 &amp;&amp; temp &lt; 36) result = temp + 65; else result = temp + 97; return result; } void main() { char pass[4]; int success = 0; for(i=0;i&lt;62;i++) { for(j=0;j&lt;62;j++) { for(k=0;k&lt;62;k++) { for(l=0;l&lt;62;l++) { pass = {(char)map(i),(char)map(j),(char)map(k),(char)map(l)}; success = crack(pass,ciphertext); if(success) goto outside_loop; } } } } outside_loop: // } 
If you read characters (or keystrokes) one at a time then you can allocate and reallocate as you go. You'll find char/key input routines in `&lt;SDL.h&gt;` or `&lt;curses.h&gt;` or whatever platform/framework you're targeting.
I like this method because you can avoid explicit casts (the functions use *person and you pass a reference to the .person), and this way you could have multiple inheritance. 
Thanks for this, however it can be up to four letters for this question! 
C is quite simple, it's just higher level then assembly enough to be portable. In fact I believe you'll find C easier then most people because the hard parts of C (i.e how the machine works, memory layout, pointers, etc) you probably know already.
When I've taken Architecture classes in the past C was usually used as a bridge between higher level languages and assembly. Later on we either only wrote in assembly or used C++ to simulate digital circuitry (because the library we used was written for C++). I personally find C to be an unbelievably versatile language and learning it has been an overwhelmingly fulfilling experience for me, but if you're just looking to pass a class or move onto something lower level (which almost all computer architecture is) being familiar with the language is probably about as far as you need to go.
Hahah probably should've taken a more significant break a while ago but time waits for no man. I'm getting into the next part of this journey if you have more help to give? I created a new values "user_input" and "users_change" for use next. Also, user_input I declared as char since I intend to use letters as the input (not sure if correct?) Anyway this is my idea for the code, not sure if I'm able to combine the conditions with the and statement like I did here. I'd really appreciate your feedback again, and thanks for the help already my friend. printf("Enter A for AirHeads, B for FunDip, or C for GummiBears"); scanf("%c",&amp;user_input); if(user_input =="A") and (user_bank &gt;= air_heads_cost); printf("Dispensing AirHeads..."); if (user_bank &gt; air_heads_cost) users_change = user_bank - air_heads_cost; printf("Your Change is %d", users_change); else if (user_input == "B") and (user_bank &gt;= fun_dips_cost); printf("Dispensing Airheads...") etc.
Thanks for the list :)
&gt; user_input =="A" You're doing well up to here. In C, `"A"` is a string (`char*`) consisting of the character `'A'` and the nul terminator (`'\0'`). In C, you cannot compare a string using `==`, you would use `strcmp()` instead. But in this case, you just want to compare the `user_input` against the character `'A'`, so it's just if(user_input = 'A') &lt;...&gt; Next, if(user_input =="A") and (user_bank &gt;= air_heads_cost); The semicolon you have at the end of the line means that you end up with an empty `if` block. All of the code that comes after will be run regardless of `user_input`. Also, it looks like you have multiple lines inside your conditional block. In order to group all this together, you need braces (`{}`) around the block (like you had with the do/while loop). I think you're soon going to have some issues with your output running together. Like you did before, most of these `printf()` statements should have a new line at the end (`printf("something to print\n")`)
Use strlen if it's an array of bytes. (by byte i mean any type that's an octet aka 8 bits, so `uint8_t`, `char`, `int8_t`, etc)
As a former, real life vending machine hardware designer and programmer, I wish I saw this sooner. Which means absolutely nothing.
In addition, a student of C may want to consider the implementation of some higher level features not readily available in the base language. Not only is it interesting to learn how some interpreted languages may accomplish things (LUA, Python, Perl, etc...) it's also valuable experience in regards to best practices in lower level languages. Once you feel you have a solid grasp on fundamentals, cough [K&amp;R](https://www.amazon.com/dp/0131103628/ref=cm_sw_r_cp_apa_KGIlzbXGHD4BE) cough, I find it's worth checking out [C Interfaces and Implementations by David Hanson](https://www.amazon.com/dp/0201498413/ref=cm_sw_r_cp_apa_-HIlzbFF8T3WG) and [Object Oriented C by AT Schreiner](https://www.cs.rit.edu/~ats/books/ooc.pdf). The latter-most is free. 
I'd say so
Well, you can go forward/backward too in watching videos and well, something is happening live is a kinda different experience. One subtle difference is that some implementations are wee bit difficult to comprehend by reading only books so watching videos might be of help as we can see how they go. In my experience, videos can be of some help when I do something where using menus in serpentine ways is concerned. 
May as well shoot for one more round of help! I feel like I've almost completed this, but I'm still getting errors here that my 'else' statements don't have a previous 'if', and that each 'and' was expecting a ')' beforehand. Again I am stuck. { printf("Enter 1 for AirHeads, 2 for FunDip, 3 for GummiBears or press 0 to quit: \n"); scanf("%d",&amp;user_input); if((user_input ==1 ) and (user_bank &gt;= air_heads_cost)) printf("Dispensing AirHeads... \n"); air_heads--; if (user_bank &gt; air_heads_cost) user_change = user_bank - air_heads_cost; printf("Your change is %d cents \n", user_change); else if ((user_input == 2) and (user_bank &gt;= fun_dips_cost)) printf("Dispensing FunDip... \n"); fun_dips--; if (user_bank &gt; air_heads_cost) user_change = user_bank - fun_dips_cost; printf("Your change is %d cents \n", user_change); else if ((user_input == 3) and (user_bank &gt;= gummi_bears_cost)) printf("Dispensing Gummi Bears... \n"); gummi_bears--; if (user_bank &gt; gummi_bears_cost) user_change = user_bank - gummi_bears_cost; printf("Your change is %d cents \n", user_change); else printf("Not enough funds or improper entry \n"); }
`malloc` does not perform any initialization. Outputting `root-&gt;flag` or `root-&gt;children[i]` causes undefined behaviour. One way to zero-initialize the structure in a portable manner would be: `*root = (node){0};`. 
Bear in mind that using calloc is not guaranteed to work by the C Standard. However this is one of those places where you might decide to strike a balance between super-portability and practicality. It's extremely unlikely that your code will ever be compiled and executed on a system where it doesn't work. 
That's this part: &gt; Also, it looks like you have multiple lines inside your conditional block. In order to group all this together, you need braces ({}) around the block (like you had with the do/while loop). Try: if((user_input ==1 ) and (user_bank &gt;= air_heads_cost)) { printf("Dispensing AirHeads... \n"); air_heads--; if (user_bank &gt; air_heads_cost) { user_change = user_bank - air_heads_cost; printf("Your change is %d cents \n", user_change); } }
I don't think you need that many C books.
&gt;Why would you write 48 instead of '0'? IDK, that's how I've always written it. Just a habit (good or bad?), I guess. &gt;pass = { is not allowed in C You're right. I wrote this post from my phone when I didn't have access to my computer and I didn't remember what exactly I had typed in my code. When I read through my code again, this was what I had written pass[0] = (char)map(i); pass[1] = (char)map(j); pass[2] = (char)map(k); pass[3] = (char)map(l); Sorry for the errors. Cheers.
i bought them from a friend for 200$
If you want to read a line, use fgets().
Yup. straight in to it aswell.
Yeah this was the first language that I learned about, and I've figured out that it offers a lot of ways of doing just one thing, especially ever since I started getting into Python. I'm just trying to see how far I need to go with it considering that I have so much other stuff I wanna learn so I can make my resume look as good as possible for internships.
_CRTIMP is a macro that the authors at Microsoft use(d?) to add various annotations to a function declaration. Those annotations are extensions to C Here's its definition on my machine, from the Visual Studio header files: // The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but // there is a lot of existing code that declares CRT functions using this macro, // and if we remove its definition, we break that existing code. It is thus // defined here only for compatibility. #ifndef _CRTIMP #define _VCRT_DEFINED_CRTIMP #if defined CRTDLL &amp;&amp; defined _CRTBLD #define _CRTIMP __declspec(dllexport) #else #ifdef _DLL #define _CRTIMP __declspec(dllimport) #else #define _CRTIMP #endif #endif #endif So, see e.g. here what __declspec(dllimport) does: https://msdn.microsoft.com/en-us/library/8fskxacy.aspx As you mention in other answer, it is a confusing mess at first sight. You don't really gain a lot by trying to understand this if you are a novice, focus on learning C rather that get tangled into this mess of implementation details. 
Depends on whether or not the weed was included.
PSA: smoking joints rolled with pages from a textbook will not teach you the material therein.
Not as good a deal as the cert company will get as he wastes his money there.
coding and weed dont go together.
oh lol by cert i mean https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard
i appreciate the enthusiasm but almost nobody is answering the questions i am asking lol. 
No time to waste. :)
&gt; in the fscanf part if I remove the \n character after the [\n], the code suddenly doesn't work, and it just reads the first line in the file in my drive: If you don't tell the fscanf to also consume the newline, it stays there. You could tell fscanf to skip leading white space: fscanf(" [^\n]", array); https://stackoverflow.com/questions/26391465/why-is-adding-a-leading-space-in-a-scanf-format-string-recommended You should also probably add in a length limit, so you don't overflow your array if the line is too long. That's left as an exercise to the reader! 
c library
how good are you at programming C? 
[This link](https://en.wikipedia.org/wiki/Newline#In_programming_languages) may be of some help, as well as the section after it regarding "Common Problems".
May I suggest re-writing the entire thing to #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { if (argc &lt; 2) return 1; char *str = argv[1]; while (str &amp;&amp; *str != '\0') { if (!isdigit(*str)) printf("%c", *str); str++; } printf("\n"); return 0; } 
Can you post a complete program that exhbits this problem?
Yes. `_Atomic` provides atomic variables. If you want to protect more than one scalar at a time, you need mutexes.
Thank you. Do you know of a program that can record values received from an ADC. I've been using TeraTermVT to see them. Any idea how to store them? I'm assuming I can use one of the programs you listed to read them back. Real reason for doing this is that I want to collect some data from a sensor and then reuse the same data to test code efficiency.
All of these books probably teach the same basic concepts, you won't gain much insight into the details.
Is my answer not satisfying?
Know that I will grant that request!
Also, printf is massive overkill for printing a single character. Use putchar() or the like.
Show your code.
Wow, thanks!! :) super helpful
[This](https://www.youtube.com/watch?v=nVESQQg-Oiw) is a pretty good video explaining the basics of pthreads.
No need to feel dumb. Everyone needs to start and learn from somewhere. I'm sure setting a uart interface is possible but it also depends on your hardware. Sometimes the usb debugger can act as a virtual com port and is attached to UART pins. Happy to help, feel free to pm me
almost!
a historic classic in paperback?! no way!
You could try [processing](https://processing.org/). In any case, you will have to write some code to get the functionality that you need. If you're interning for this, that's supposed to be part of the job... Assuming you're on windows, you could also use [powershell](https://blogs.msdn.microsoft.com/powershell/2006/08/31/writing-and-reading-info-from-serial-ports/) to just dump the received values to a file for storage. 
You've declared `buffer` as an array of four characters, but you likely try to read more than four characters into it (even the 4-letter password "pswd" results in a string of five characters including the null terminator). This causes your text input to overwrite the variable with arbitrary data. This is also reasoning behind the "Bugs" section of the function [documentation](https://linux.die.net/man/3/gets)
The gets function reads from stdin until it finds a newline (/n) and writes it to the buffer. However your buffer is just a pointer to a certain memory adress. If you input more than 4 letters you will write over the buffer boundaries, which is undefined behaviour. So in case your pass_flag ist stored right behind your buffer in memory you will overwrite it. 
yeah posix is straight forward to find but when you say c standards do you mean the standard library because i already have a book on that in the picture also: https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Dstripbooks&amp;field-keywords=The+Elements+of+Programming+Style which one?
Much appreciated!!
[getline function](http://man7.org/linux/man-pages/man3/getline.3.html) may help 
Good point!
Like the others have said, `gets` is overwriting your integer variable in memory, but nobody has suggested an alternative, so I'll take a whack at it. I think many would agree that the best way here is to use `fgets` instead of `gets`. It's only slightly different, so don't worry. What `fgets` will do for you is stop taking input after a certain number of bytes. That way you're not overwriting random memory addresses. Instead of `gets(buffer)` you should do `fgets(buffer,5,stdin)`, and change `"pswd"` to `"pswd\0"`. The reason 4 must become 5 is because the null terminator char `'\0'` needs to get stored as well so that the computer knows the string is finished. If you leave it as four, the input `"pswd"` would get stored as `"psw\0"` in memory. Edit: I forgot to mention that this does not change the password. The only trouble now is that anything after four input characters gets ignored, so `"pswdasdf"` gets stored as `"pswd\0"` and root privileges would be given. Here it is, fixed: https://repl.it/ITRe/198 Cheers, and good luck on your journey Edit: `char buffer[4];` needs to be `char buffer[5];` now as well. Forgot to mention it. I already changed the link.
Doesn't printf get simplified to putchar by the compiler in situations like these? I just compiled a simple program with only `printf("a");` in one and `putchar('a');` in the other and the executables have the same size down to the byte. Edit: I do agree with you, though, and it probably depends on the compiler. I'm using GCC 5.4.0 for the record Edit 2: They also have the same MD5 sum
Fair enough. I believe I edited my comment before you replied, but yes, I believe that's right.
What is this LF? and CRLF? 
32 bit or 64 bit OS?
The literal `1024` is of type int. Thus, *before* you assign to a `size_t` all operations happen as `int`s. Painfully tricky to spot, disastrous if you should get it wrong.
Thank you too!
Correct thanks, my mobile layout is confusing and I was in a rush ^^
I'm not trying to be racist, but it seems that 90% of C youtube tutorials are made by indian people. Something's wrong with it. Video itself, btw, confused me. IDE (and compiler too, i bet) is ancient, looks like borland. I don't see the point. Code formatting is bad.
Thanks for the valuable advice!
Are you compiling your program as a 32 bit program? In a 32 bit program, you might have only 2^(31) = 2 GB of address space available for your data.
Okay! I see, you already solved your issue. Nice! Good sleuthing.
This is a great opportunity to learn debuggers for your platform on Windows you have the great ollydbg and on linux you have the equally great gdb which i believe is also on mac, get in the habit of using one early and it will save you alot of time and confusion there are numerous great guides for them online so I wont go into detail here.
thank u
i like hardcovers for the timeless classics and used paperbacks for the other stuff
CR stands for Carriage Return ('\r') and LF for Line Feed ('\n'). CRLF is a combination of both ("\r\n")
For a specific goal node you should look at A*, as long as you have huristic that can estimate the distance to the goal node. As for mulrithreading I'm not aware of a way to run a single pair shortest parallel, but A* and related algorithms are really fast, and if you need to find paths to multiple destinations you can always run more than one search at a time.
One way to parallelise A* is by splitting the nodes between threads according to some arbitrary hash function. Note that locking and unlocking have a significant overhead and design may be difficult. If you're working on exponential graphs with a large branching factor (and not grid path planning), you can try to use [IDA*](https://en.wikipedia.org/wiki/Iterative_deepening_A*) which is easy to implement, easy to MT and is blazing fast.
Good question. I need to find the shortest path between two nodes in my graph. My graph isn't really a graph as well its more like an array of struct vertices and each vertex (or element of the array) contains a field that has all the outgoing edges of that vertex. For shortest path, Dijkstra immediately comes to mind. I have trouble implementing this in C let alone parellelising it :/
The Wikipedia code for IDA* is superb, if something is unclear feel free to ask me. Also, I couldn't understand from what you described how it's different from a graph.
On Amazon? 
Straight and to the point, nice. With `realloc`, it's important to note that you need to use a temporary variable so that the memory can be properly free'd if the reallocation fails. This isn't such a big deal for user programs where all the memory is reclaimed anyways, but kernel programming and embedded environments can be a different story.
Yes, you're absolutely right. A user program would also need to decide to continue executing even though it can't allocate memory. I can only think of one reason to do this: if the program already holds a large chunk of memory that can likely be free'd. It could then free it and try the allocation again.
I watched the other video posted the other day and liked it. To the point and easy to follow. Like a good book for teaching programmers a new language.
Yes.
&gt; gets [Nooooo!](https://stackoverflow.com/questions/1694036/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used)
Are we sure calloc has a slight overhead? Wouldn't it just assign the virtual memory to the hard 0 pages of physical memory?
 *(foo + 1)
Struct1-&gt;Struct2[struct1-&gt;num]. Member
Note that you can leave out the parentheses.
&gt; &amp;(Struct1-&gt;Struct2.Member) &gt; &gt; &gt; &gt; is what you're looking for there. Plus, look into `offsetof` if you want an easy way to calculate the different between the start of Struct1 and Struct2.member.
Look up the *ring buffer.*
You need to put forward your own effort before anyone here will help you. Try it, if you get stuck post your code and people here will be more willing to help
A linked list is a perfectly fine implementation. Actually a queue is one of the best applications for a linked list. Just be aware that you'll need to maintain a pointer both to the head and the tail of the list. A ring buffer is great, too, but has a fixed size. The advantage to using a linked list is that the size of your queue can be effectively unbounded, while still maintaining O(1) performance for your operations.
In terms of pitfalls, this link might help you: http://www.andromeda.com/people/ddyer/topten.html
Yeah, that's one way you can do it.
For best practices have a look at the MISRA-C guidelines. 
If you use realloc you shouldn't need to copy the elements.
I don't follow. Why should I need to copy?
C's motto: who cares what it means? I just compile it!
You have an array in case of the queue that is a circular buffer. So you have an index for the head of the queue, an index for the tail, and you access the array with index mod size of the array. You know that your queue is full when head = tail, and so you need grow your array. But this point could be in the middle of the array, and the realloc of grows the array at the end, and you need a space in the middle. So at least you must shift all the elements after head to make space for the new elements in the middle, that means in the average case you need to shift half of the elements of the array. In case of a normal dynamic array implementation, or a stack, there is no problem in realloc because you know that your array is full when you need to insert at the end.
And the array syntax variable[index] is actually *(variable + index).
This comment chain isn't about a circular buffer. Even still you don't need to copy. Just
Yes, if the distance between any two bordering nodes is 1. Otherwise you'll have to increment the distance by whatever the distance between the nodes is.
Just watched all your videos (well except the node.js ones, sorry :P). Great stuff! 
You should learn C11. C99 is 18 years old now ;)
Yeah I don't have any interest in node tbh. Your C videos are excellent though. Well planned and to the point. You have a monster computer. What do you use it for? I guess you need all those cores for Atom.as your editor hah :P joking (kinda). How is Atom for C coding? 
If you're starting, King's Modern Approach is a great book. Steele's C Reference Manual is also awesome. K&amp;R... Read the others first. You'll appreciate it more. 
Yeah so I am storing things in a makeshift queue but those aren't in the order of traversal cause aren't you adding all the nodes on the same level as the target node at the same time?
I have two machines I use primarily. A Dell PowerEdge R620 (32 core) that I use as a server. And then this: https://goo.gl/photos/RJ7reAWMoetE8ZPD6 It's used primarily for work. My job is in Node.js (hence the smattering of Node.js videos) but I've done several projects (some personal, some private) in C. I used to use JetBrains IDEs, but they cost money and I keep having to pay them for the latest version. I'm slowing shifting to something free and open source, and so far Atom is best I've found. Atom is built with Electron, so it's not nearly as fast as it could be. If you're looking for stellar autocomplete, Atom editor is probably not your best bet. Otherwise, Atom editor functions well for most things.
1) (Struct1-&gt;Struct2[Num].Member) is the address of the first char in the string. It is it's own grandpa, so to speak. 2) Arrays and pointers are not precisely identical. The declarations are quite different and results from sizeof() reflect that. To wit: char b[12] = .... ; char *a = b; Both have the same "address"/value but "b" obviously declares 12 bytes of char. This is okay ( so long as c is declared somewhere ): b = (char *c); but this isn't: a = (char *c) because a has no "l-value" - you can't change it. You can, however, mix dereferences between pointer and array notation. Just turn on -Wall and heed the warnings; you'll be fine. 
You never set nsal. Isn't it always going to be 0?
Check what you're printing, what you're multiplying, as well as the parameter types that you pass into scanf function. Try to figure these out before looking at the hints. If after you read hints and still can't figure it out, please let me know and I'll help you out some more. Hints: are you ever actually setting nsal? pointers are normally used with scanf.
Some common book recommendations: [Expert C](https://www.goodreads.com/book/show/198207.Expert_C_Programming) [C Traps and Pitfalls](https://www.goodreads.com/book/show/706807.C_Traps_and_Pitfalls) [No Bugs!](https://www.goodreads.com/book/show/2338849.No_Bugs_)
Thanks for the clarification! 
1. https://stackoverflow.com/a/8185382 Answers it pretty well. Basically, you can cut an object of n items in half log base2(n) times. 2. Not necessarily. You can describe the complexity of an algorithm using any function, really. It's just that those ones you listed are really common, and because of the way big O notation works. A function is, for example, O(n) if you can come up with a function y=kn for some constant k where y is greater than or equal to the number of operations of the algorithm. y does not always have to be greater than or equal to the number of operations in the algorithm as long as it remains greater than or equal to it after some value of n.
This sub is for C, not C++... plus, Turbo C++? Just say no to a compiler that's been obsolete for so long people who were born after it stopped being relevant can now buy alcohol. 
You should at least try the exercises in K&amp;R after you've completed Modern Approach, you'll learn a lot from those.
Check line 11. In your post you say you want to multiply sal by 2 and then assign that value to nsal. Line 11 as you have it written is not doing what you say you want to do. 
When you have two files you need to compile each with -c first, then combine the object files that are produced with -o. So three separate gcc commands. 
Your makefile should be called "Makefile" (with no extension, or quotes obv) Also, make syntax gets pretty complicated fast, so you'll probably struggle with it if you get into advanced features; make sure to read a book on it when the time comes. Assuming all the *.c files are in a single folder, you can use a predefined variable to get all the source files you list as a prerequisite. $@ is the target, and $^ is the prerequisites. So, for your Objects target your CC line should be something like this: TARGETFILE : PREREQUISITE $(CC) $(CFLAGS) -c $^ -o $@ $(LDFLAGS) Where TARGETFILE is an object file, produced by compiling one of the source files in PREREQUISITE (CC, CFLAGS, and LDFLAGS are common variables I've defined in my makefile, you don't have to use them, but they are classic variables to contain the path to the compiler, compiler flags, and linker flags respectively) One more thing I should mention about makefiles, is that they do not scan through your source to find included headers, so you should list those as part of your PREREQUISITE as well. and as a result, the content of your source code and header files do not matter, what we need to know is what exactly your makefile says, and your source tree layout.
 while (x &lt; length &amp;&amp; y &lt; length) { This while loop stops when you reach the end of a1 or a2. With your sample input, that's after 3 iterations. for (x = 0; x &lt; length + length; x++) printf("%d ", a3[x]); This is then printing 6 elements from a3, but you've only written 3. The last 3 are uninitialized garbage 
Basically you're just looking to find a coding style that's readable. For example, I use PascalCase for variable and function names, because it makes it easier to distinguish them to me. Do whatever you find "glanceable" (You shouldn't make people have to focus on reading your code, they should get the gist at just a glance)
I have removed this post as it is off topic. This subreddit is about programming in C only. Please do not post C++ content.
&gt; Also, make syntax gets pretty complicated fast, so you'll probably struggle with it if you get into advanced features; make sure to read a book on it when the time comes. Or, you know, [RTFM](https://www.gnu.org/software/make/manual/html_node/index.html).
That's cause `make` is complicated. I prefer `mk` which was designed to be a better `make` and indeed replaced `make` in Plan 9 (the successor of UNIX). It's refreshingly simple.
Note that the C standard forbids subtracting pointers that point to different objects, so restricting the size of a single allocation to be less than 2 GB is sufficient.
Tip: Try not to use the word "performant", but instead describe what performance characteristics you are looking for. Do you want to optimize for speed, for low memory footprint, for minimal number of allocations, power consumption, cache misses, or something else?
What? there's a seperate book on how to use makes? 
that seems too advanced
Too advanced? Sorry to disappoint you, but this is as easy as a Makefile gets. I even REMOVED the most complex parts so that your `make` implementation does it for you. Just download this template, put all you `.c` files in the `sources` folder (you can even put folders and subfolders and so on) and when inputing `make` in the project root directory, an executable will be produced and moved to the bin folder with a timestamp to indicate when it was built.
What is a ‚Äúbasic level‚Äù for you?
I know nothing. That should give you an idea. 
Okay. In this case, ‚ÄúThe C Programming Language‚Äù might be a bit too difficult. In this case, [The C Book](http://publications.gbdirect.co.uk/c_book/) might be more appropriate. Read it carefully!
I would argue the opposite. K&amp;R is an excellent introductory textbook. The C Book does not follow a logical progression, and while I haven't spotted any outright errors in it, it teaches bad habits.
As someone with a degree in ancient poetry, you've got to take the shot when it comes up! :) Unfortunately, I'm not knowledgeable enough to even begin to prod at the math behind it, but from a practical programming point of view, from O(1) through O(n) seem relatively intuitive. We use them without even knowing it, necessarily. In a more theoretical world, are there programmatic functions that are periodic like sin(n) would be, or is it not only practically infeasible, but theoretically as well?
Your add function should return int not void. 
[Bitwise AND operator](https://en.wikipedia.org/wiki/Bitwise_operation#AND): `x &amp; y` is non-zero if and only if some of the bits that are set in `x` are also set in `y` (or the reverse). So `x &amp; 1` is non-zero if and only if the least significant bit of `x` is set, which makes it odd. Also, if `y` is a power of two, then `x % y == x &amp; (y - 1)`, so `x % 2 == x &amp; (2 - 1) == x &amp; 1`.
It seems like a premature optimisation, and I hope that 'a' is an unsigned integral otherwise you're at the mercy of 'implementation defined'. 
It doesn't necessarily mean that the programmer is interested in whether or not the number is even. The author could be interested in specific bits in the data. If the data is not generally regarded as being numeric in meaning, this is a fitting approach. Furthermore, I see these types of tests frequently: if ( (a &amp; mask) == bits ) ... /* Test specific bits in a word */ if ( a &amp; (1 &lt;&lt; n) ) ... /* Test for the nth bit flag */
lol, yeah for all those non-twos-complement systems around. It isn't unreasonable to assume a twos-complement numeric system, or that sizeof(char) &lt; sizeof(int) or that a NULL pointer casted to an integer evaluates to 0. I've worked on systems where the above were not true. Thankfully, the computing hardware industry has coalesced a bit in the last 30 years. We might as well take advantage of it.
Is this supposed to be a joke? I told you not to post C++ videos to this subreddit. Please enjoy this ban.
Definition would require that we only look at the positive values, so it'd be more like |sin(n)|, but it's worth noting that n is an integer. Let's consider a function with runtime complexity of |sin(PI*n/10)| + 1. We need that + 1 there because otherwise n = 0 and n = 10 would result in a runtime complexity of 0 (meaning the algorithm finishes without doing any work, which is impossible). Normally this is a pointless addition, since we would be analyzing the function for an arbitrarily large value of n, but since it's periodic we can allow it. Since n is an integer we can conclude that this function will have a minimum complexity at n % 10 = 0 (multiples of 10) of 1 and a maximum complexity at n % 10 = 5 (odd multiples of 5) of 2. Now, for the magic. The definition of Big O notation is such that the comparative function needs to be greater than or equal to a multiple of the actual function. Since we know that our sine function will never go beyond 2, we can use 1 as our comparative function with a multiple of 2, therefore giving a sine function a constant runtime complexity of O(1). This can be proven for arbitrary trig functions of arbitrary period and magnitude. If we were to analyze an algorithm with a runtime complexity of a form similar to |n*sin(n)| the variation of the sin(n) would not outpace the growth of n, so this would effectively be O(n). The same can be said of other functions multiplied by a trig function
True as this may be, someone who's starting out with no background and presumably pursuing this as a hobby may not want to ~~drop $40 on~~ pay money for a textbook. There are also less licit methods of acquiring it, but I won't acknowledge them here.
That actually feels rather illustrative. I think I see. So from a very practical standpoint, this is not just a calculation of how many times a system needs to run, but really is a worst possible outcome simulator. |n*sin(n)|'s worst possible outcome is n, so we don't actually care that about the effect of sin(n). This doesn't change based on where I am within a process, nor does it care about where the process actually stops. What needs to be proven to change it is that the situation cannot get any worse than the number I have, not that it could be better. That's a bit deceptive to me, as my inclination is to look at something like a binary search and think of each step as a narrowing of n. While practically that's true, n isn't actually shrinking across the entire system. In reverse, that means that O( n^2 ) code looks something like: for(x=0;x&lt;=n;x++) { for(y=0;y&lt;=n;y++) {} } Right? That's a lot closer to real life than I had assumed. Given two variables, I could just as easily have O(n*m) if I were to change the inner loop above from n to m, then. From that point of view, it's easy to see how one could end up with runaway complexity in a program.
In your first 2 paragraphs: you're describing MISRA being different to non-MISRA coding (which I agree with). Embedded coding without MISRA doesn't have any of those restrictions. There's no difference between `goto` and macro usage in embedded vs. non-embedded (if your embedded code is supporting several different devices for one code base then you end up with a lot of conditional compilation). And yes, there can be processes, threads, IPC, files, permissions and sockets; although sometimes not POSIX-compliant ones. Many embedded devices run Linux.
What, so sizeof(int) == 1, and both a char and int has 16 bits? Because (according to the spec, at least) a char must be at least 8 bits, and an int must be able to represent numbers of a range that you need 16 bits to represent.
However the compiler often can't tell that a variable is always a power of two, so if you have code that's performance critical and doesn't use a compile-time constant for the divisor, then refactoring division into bit-twiddling operations can be worthwhile. 
yes string literal . not lvalue ?
Search for "systems programming" lectures or books. Tons of material available online.
The `&amp; 1` version would fail for systems that use 1's complement for negative numbers
If it runs an OS, it's not really embedded in the usual sense.
On the Texas Instruments C40, it wasn't easily 8-bit addressable, so chars and ints were 32 bits.
I did post the contents of the makefile, The contents of Makefile.txt in the question above 
You can try with a pointer: char *foo; foo = "bar";
It is currently only resulting in 13374335 every time.
[srand() documentation](http://en.cppreference.com/w/c/numeric/random/srand)
What do you expect this function to do? First, only call `srand()` once, not every time you need a random number. Second, `dice` is a function parameter. If you assign to `dice` inside `roll_die`, the assignment isn't visible outside. You should return the result of your dice roll and have the caller assign it to something instead.
It is unquestionably a string literal, cf. ¬ß6.3.2.1 paragraph 3 or the entirety of ¬ß6.4.5. If you don't have a copy of the standard, google ‚Äún1425‚Äù which I believe is the last public draft before ratification of C11.
I understand what a recursive function is; it's a function that calls itself, has a terminating case, and basically takes a problem and breaks it down into the same problem but smaller. I really have trouble trying to solve problems using recursive functions though. For example, I've been trying to figure out how to write a recursive function that takes a number (let's use the number 316 for example) and returns a number which is each digit multiplied together (so for 316 it would return 3 times 1 times 6=18) for a few days now and I don't seem to be making much progress. I'm pretty sure I have to do modulus 10 to get the ones digit, and then to get the 10's digit I would need to subtract what the ones digit is from the original number (so I would do 316-6=310) and then do mod 100 (would would be 10) divided by 10 (giving me 1) and then I would subtract 10 from 310 (so now I have the number 300) and then mod by 1000 (300%1000=300) and then divide by 100 to give me 3. So I guess I've figured out the general pattern, I just have a problem trying to figure out how to write this recursively.
Ok. Let's say you work out the answer to 316 (18). Now what if your number was 3162? What if it was 3168?
It should not have an extension even in Windows
 char foo[4] = "xyz"; char bar[4] = { 'x', 'y', 'z', 0 };
I have no idea what you were trying to say, because this example seems to directly contradict your statement: &gt; **String literals** are also slightly special in that they behave differently when used as initializers, which is **the only case in C where you can assign to an array**, as opposed to an array element.
Well, you figured it better than me, I think. There is more than a single solution, here. You may try to do a mod 10 and integer division by 10 to take the least significant digit away from the number and pass them both separately to the same function that does the same thing, until there is only zero as the number, when then you multiply everything Or you can pass the same number over again and again, only passing an increasing divider of the modulus too, loop-like. You can imagine two functions, too, one that multiplies and one that takes a digit away, and mount an indirect recursion. When I make a recursion, I like to put the operation on the returning value. Like: int power(unsigned int num, unsigned int pow){ if(pow == 0) return 1; return num*power(num, --pow); } It's easier to see the expansion. Just giving ideas.
you can edit your post indent code by four spaces there is a link to the formatting help below the lower right corner of the edit field 
There are two ways to solve this using recursion. One of them is to pass progress + remainder down the stack and result back up: ‚Äúhere's what I've done so far and this is what remains to be done‚Äù. This can trivially be shown to be equivalent to an iterative solution. The other is to ‚Äúpeel off‚Äù a small part of the work at each level, pass the rest down the stack, and then combine the result with the small part that you kept for yourself. Both will do the job, and the former is more efficient, but I suspect that your instructor wants you to pick the latter. The key to this is that your recursive function should never need to know that it is solving a smaller part of a larger problem. Ask yourself: what is a simpler problem than 316? And having answered that, what is a simpler problem than *that*? And so on, until you reach a point where there is no simpler problem. So you start by writing a function that can solve the problem for the very simplest possible input. Then you look at how to split an instance of the second-simplest input into an instance of the simplest possible input and a remainder. You already know how to solve the former (by passing it on to the recursive function), so all that's left is to combine that result with the remainder. Perhaps it would help if you started by writing a program that solves a more obvious problem, like factorials. The factorial function is very similar to the problem you are trying to solve, but easier to reason about when you don't already have a solid grasp of recursion. BTW, I really recommend reading SICP. Chapter 1 is a must and would help you solve this problem; chapter 2 is strongly recommended; chapter 3 is suggested; the rest is of interest only to someone studying programming language theory as opposed to practical programming.
If you take a look at the standard, specifically ¬ß6.7.9 which I referenced earlier, you will see that initializers are defined in terms of assignments. So yes, initializing an array is equivalent to assigning a value to it, except that *for arrays, and arrays alone*, this can only be done in the context of an initialization. ~~(‚Äúbut what about structs,‚Äù you say? In C99 and newer, you can assign a compound literal to an object of struct or union type anywhere, not just as initialization, so arrays are the only special case here.)~~ EDIT: correction, compound literals can be arrays too, so I should have left them out and spoken only of literals with no additional ‚Äúdecoration‚Äù (like the cast required to make a compound literal).
&gt; I understand what a recursive function is; it's a function that calls itself, has a terminating case, and basically takes a problem and breaks it down into the same problem but smaller. This may sond stupid. But go search for some examples online and then examine them with your debugger. It takes you some time, but you'll understand how to write them eventually. (EG: the fibbonacci function) If you are good with math, try looking on an math-y approach (pure math; no programming). This was advice from a haskell programmer. I don't know if it is helpful.
Maybe your problem is that the examples you are trying to do are easier to implement using simple iteration than recursion, and that's fine since iteration is usually more eficient. Try implementing something like quicksort, which is recursive by definition, it may help you understand the point.
You almost certainly wouldn‚Äôt want to do this in C. In fact, pre-C99 it would be nearly impossible to work around; you were only guaranteed to be able to assign compile-time-constants in initializers, and that included local (`auto`) variables, which means that everything being `const` would make it impossible to collect the return value from something, do a `for` loop, set `errno`, any number of things would break. C is very, very imperative. You‚Äôre better off being careful with pointers (i.e., `const foo *x`) than variables (i.e., `const foo x` or `foo *const x`).
Edge condition
&gt; Your original statement, at least in my reading, seemed to indicate that string literals were treated specially compared to initializer lists, No. I never spoke about initializer lists. String literals are treated specially in that they have different semantics in the context of an initializer. This is supported by the passages I referenced. 
calling the function inside the function
Yes, it's guaranteed in all of the systems I'm aware of. [Your process will be loaded at an offset from zero](http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/) and that is the lowest address used in your process's view of memory. Since the zero address doesn't get mapped to your program, NULL pointers will lead to segmentation faults.
Correct (though in theory the could be the same after the first process dies, and it's physical memory is reused). The OS and architecture (x86 for example) have ways to ensure that never happens. Page/seg faults are when you accidentally violate the rules.
If the concept of virtualized memory and protection annoys you, you can always take a look at the embedded side. For microcontrollers, you generally won't have an mmu, and any addresses you see are exactly the physical addresses on the chip. You can even manually wipe the bytes back to the original state on startup (zero fill and copy-down), something your compiler will generate for you when not running on bare metal! All sorts of fun you can have without the protection, but imagine the horror of trying to run two programs at once in those conditions!
Of course, this depends on the embedded system as well. A Pi, for example, is a Linux-based system and supports paging, etc.
I gotta tell you, unless you have a lot of time, don't start.. Building IoT devices with embedded Pi's, Beaglebones, Odroids, et al., is too addictive!
Have you considered using a string; e.g. iterate over chars? Assume you would have to read input from stdin - I would give you a test case with a moderately large prime (a few hundred digits). If you use recursion you will likely blow the stack (‚Ä¶ exploitable?); or you have to add code to prevent that. Nice example because imo there is a lot of teaching mileage from a simple problem; but rather when not to use recursion. Traditional examples are "divide and conquer" types (e.g. sorting). I have seen pairwise recursion in a lot of json implementations; e.g. printing (or parsing) arbitrarily(?) nested arrays / objects. Above concerns apply there as well. You may want a language with proper support. Do some tutorials with a language (Haskell, Lisp/Scheme, ‚Ä¶) you haven't used before and spend a few hours. It will be worth your time - and it might blow your brain out (in a good way!) 
Thank you, your suggestion fixed the problem. I passed a double pointer ( head ) to the `delete` function alongside the desired node to be deleted. Then, in the if statement I also assigned the pointer to `head` to `next_node`. It seems to work just fine now. I'd also appreciate some insight into the implementation, perhaps I could use a more efficient route? Here is the complete function: void delete(dllnode *target, dllnode **head) { if(target == NULL || *head == NULL) return; dllnode *node_prev = target; dllnode *node_next = target; if(target-&gt;prev == NULL &amp;&amp; target-&gt;next == NULL) { free(target); return; } /**&lt; Handles nodes at the end of the list */ if(target-&gt;next == NULL) { // move prev node next pointer to NULL node_prev = node_prev-&gt;prev; node_prev-&gt;next = NULL; free(target); return; } /**&lt; handles nodes at the beginning of the list */ if(target-&gt;prev == NULL) { // move next node prev pointer to NULL node_next = node_next-&gt;next; node_next-&gt;prev = NULL; // move the pointer to head to node_next *head = node_next; free(target); return; } // move prev node pointer to next node pointer node_prev = node_prev-&gt;prev; node_prev-&gt;next = target-&gt;next; // move next node pointer to prev node pointer node_next = node_next-&gt;next; node_next-&gt;prev = node_prev; free(target); } // prints the values of a linked list void print(dllnode *head) { dllnode *node = head; while(node != NULL) { printf("%i ", node-&gt;value); node = node-&gt;next; } printf("\n"); } dllnode *create(VALUE val) { dllnode *node = malloc(sizeof(dllnode)); if(node == NULL) return; node-&gt;value = val; node-&gt;prev = NULL; node-&gt;next = NULL; return node; }
It's not guaranteed in embedded systems. I'm working on a platform at the moment where the flash memory is mapped from 0x0.
How does it handle null pointers?
See u/kvakvs reply- I've not actually checked under the hood tbh, but we have not had any issues yet so I'm guessing the compiler just sorts it all out. It was just something that I noted the other day.
That only applies to recent Linux and only on some systems. As a first example, I have an old a.out-based Linux system which maps binaries to address zero (as UNIX used to do too). Generally, a binary specifies where it is loaded and loading to address zero is definitely legal. However, Linux prohibits this unless the sysctl `mmap_min_addr` is set to zero. As a second example on VAX, dereferencing a NULL pointer always yields zero and some older programs expect this behaviour.
fgets() leaves the newline in the string.
&gt; There's not. Ignore the if-statement. It's just to look for the \n at the end of the strings. There's no previous user input to store. The 'buff' buffer is empty. The for-loop executes the first fgets() call, but just automatically fills it with nothing. The second time thru the for-loop is when fgets() finally prompts the user to input something.
Not exactly a C question. If the OS does protect the address space of a program, how do softwares like cheat engine and game trainers work? They basically change the value of the variable that holds something like the amount of money your character owns in the game right? How do they access the memory used by another program (the game in this case)?
I'm not wrong. The *multiple* passages I referenced do back up my point. Let me spoon-feed it to you: * ¬ß6.4.5 defines string literals; most importantly, paragraph 5 describes how a string literal is actually an unnamed array; see also paragraph 6 which states that repeating the same string literal multiple times may or may not result in multiple identical arrays. * ¬ß6.5.16 defines assignment expressions. * ¬ß6.7.9 defines initialization, showing that an initializer is either an assignment expression or an initializer list (with optional trailing comma) surrounded by braces. This is the basis for my claim that initialization is assignment, which you rejected. * ¬ß6.3.2.1 defines lvalues; the crux here is paragraph 3 which states that in most cases, lvalues of array type are converted to expressions of pointer type, the exceptions being `sizeof`, `&amp;` and **a string literal used to initialize an array**. These four, when taken together, show that using a string literal to initialize an array actually assigns an array (the unnamed array which results from the use of a string literal, cf ¬ß6.4.5) to another array (the one being initialized), and that initialization is the *only* context in which it is possible to assign anything to an array because it is the *only* context in which an array does not devolve into a pointer. I also referenced ¬ß6.5.17, but it is not really useful except for context.
f**get**s() reads a line from a stream. It does no prompting. A minimal complete example is one we can compile and run to see the problem first hand. We can't do that with what you posted. There's too many unknowns. For all we know, the guy who suggested you had a newline as the first character of the stream left over from something else is right. I'll bet he is, actually. But without seeing all your code... 
&gt; Shouldn't fgets() be the prompt? You are doing a horrible job at explaining what you want to do. You said: "Shouldn't fgets() be the prompt?" NO. 
Though I now strongly suspect that you're right about a leftover newline being read, since OP said it worked using scanf().
Chill. I did say in the original post that I didn't have a full understanding of fgets().
And there's your problem! /r/dragon_wrangler was right. If you'd posted the full code the first time it would have saved a lot of time and trouble. You read a number with `scanf("%d", ...)`. To get that number you had to type one in (Let's say 12) and then hit enter, right? So the standard input stream holds `'1', '2', '\n'`. scanf() reads just the number and leaves the newline as the first character in the stream. Then you call fgets(), which sees that newline and gives you a blank line.
What does getchar() do that rectifies this issue? Just calling it by itself fixed my problem
It would read that newline. You'd be better off verifying that the character is a newline and not one you need, though. Something like int ch; for (ch = getchar(); isspace(ch); ch = getchar()); ungetc(ch, stdin); will discard all leading whitespace in standard input. Edit: you might also be able to adjust the scanf() format string for a similar effect. 
Recursion is a meme anyway, like honestly why would you want to waste a bunch of time and memory doing weird infinite calling
Modern computers have a hardware device known as Memory Management Unit (MMU). This knows about the concept of "processes", and it maps addresses ranges to physical RAM on a per-process basis. Multiple concurrent processes might all be given the same address range (from the processes' point of view), which the MMU maps to different parts of the physical RAM. 
If you have an integer and want to print it to a text file, it has to be converted from an integer to a string first. That's the formatting. That's why there's a function named `printf()` that has a 'f' in its name because it takes a format string which tells it what formatting operations you want done, such as `%d` which formats an integer as a string. Unformatted IO on the other hand is just "here's some bytes, write them to the file verbatim." 
Here's a quick example. Both of these snippets will produce the same output, e.g. `42` twice: int i = 42; char c; /* Formatted IO */ printf("%d\n", i); /* Unformatted IO - Excuse my terrible int to ascii conversion */ while (i) { if (i &gt; 10) { c = '0' + (i / 10); i = i % 10; } else { c = '0' + i; i = 0; } write(STDOUT_FILENO, &amp;c, 1); } write(STDOUT_FILENO, "\n", 1); I think the "Unformatted I/O is easier and more efficient" statement is from the point of view of the program rather than the person writing the program.
Programs typically have, depending on the operating system, means to request access to another program's address space, e.g. through a debugging interface. That's what trainers and cheat engines use.
Note that `/dev/shm` is a directory, not a device. You can share memory using the `mmap()` system call, `/dev/shm` is an implementation detail of *POSIX shared memory* which provides a more convenient API.
Recursive functions can be much simpler to implement than linear functions. If you do it properly the compiler can usually convert it into a linear function and not consume extra stack space ( see tail call optimisation ) by replacing the calling parameters and jumping to the start ( GCC -O3 will turn a recursive factorial function, an optimised recursive factorial that carries the result and a linear factorial all into the same assembly )
Well actually in terms of the NULL macro, it always is defined as some form of 0. However, the compiler transforms any zeroes in a pointer context to the actual null pointer address of the hardware, whatever that may be.
The null pointer isn't guaranteed to have an all-zero bit pattern. If you care about portability, you can't get away with something like: struct S { int *p; }; void g(struct S *s) { if ( NULL != s-&gt;p ) { /* ... */ } } void f() { struct S *s = malloc(sizeof *s); memset(s, 0, sizeof *s); g(s); } It will work on quite a few platforms though.
No, you're right. If you notice I hesitate briefly, because I realized I changed that line without fully changing the comment, and it caught me off guard at that moment. It used to be `char *name4 = malloc(128 * sizeof(char));`. Also, you'll notice I don't call it a pointer.
I kinda like seeing who's doing the talking. The internet is largely faceless. 
I took it off temporarily. Sort of an A/B test, I was curious if showing me or not had any effect.
Me, I like it. It's hard to say what stereotypes and prejudices work into whether the look of someone makes a person sense that they are worthwhile listening to. Your set-up, "studio" and self gave me the impression that I would stand to learn something. The fonts you have chosen have also given that impression. So that may be enough to sell the "Engineer Man" brand. All books have covers.
I think, quite often the success is returned via **return**, and the value is passed as pointer to the args of the function 
+1, this is standard practice. For example: uint8_t value = 0; int result = i2c_read(address, register, &amp;value); if (result == ERROR) { // read failed! }
So first thing's first `string.user_strings` is not a `char *` and you could save yourself some headache of figuring out how to pass it back by changing your parameter to a `Strings *` so that changes you make to `strings` will persist beyond `sort`. ~~Second the lines within your `if` block aren't doing what you think they are. `string.user_strings[i][0]` is not a `char *` but a `char` as is `string.user_strings[i + 1][0]`. Instead you'll want to use `string.user_strings[i + 1]` and `string.user_strings[i]` as you do in the temp assignment.~~ Whoops, listen to u/jedwardsol and use `strcpy`. Hope that helps.
Fiddlesticks. I'll probably have to change my storage array method then. I can't use strcpy (it's for an assignment and strcpy is a no go) 
Thanks, I'll try that
Great! The standard method is a bit clunky but that's how it is sometimes in C. thanks everyone. :)
You need to copy all the bytes making up the string from one array to the other. you can either look for the nul byte at the end or just copy all 21 bytes.
Do you know how to pipe? | I can use basics like $cat file.log | less But not much more. Piping seems under used.
He's pointing out a common usage of `cat` when it's not necessary. Another one that shows up a lot is doing `cat file.txt | grep ...` when you can just specify a filename to `grep` directly.
Return a structure containing both :- struct RetVal { int value; int flags; }; struct RetVal my_function() { struct RetVal r; r.value = 123; r.flags = 0x123; return r; } 
The problem is your variable `s`, which is a pointer to nowhere. It's obviously not pointing anywhere valid because you haven't even initialized it. Instead of `char *s`, try `char s[100]`. That will allocate 100 bytes of memory for you (so that you can read a string of size not greater than 100). If you really want to try playing with a pointer, you can do: char str[100]; // allocate the 100 bytes char *s = str; // now s is a pointer to that 100 bytes But it's not necessary to do that. (You should also not use scanf("%s") as it's unsafe. You should be using fgets() instead. But I understand when you're a beginner, there's a lot to take in at once, so just focus on getting it working first)
To the best of my knowledge, clang is the only compiler which performs that type of warning.
[This](https://gcc.gnu.org/c99status.html) says that GCC doesn't use the size information for optimization purposes. I'm guessing it isn't recorded at all by the point warnings get handled and the argument is treated the same as any other pointer. There's the GCC specific [nonnull](https://gcc.gnu.org/onlinedocs/gcc-6.3.0/gcc/Common-Function-Attributes.html#Common-Function-Attributes) attribute if you want the compiler to check for null pointer arguments.
I wouldn't post it here. I always post to the subreddit related to the topic.
I tend to use assertions to declare that a parameter cannot be NULL. As others have said, the nonnull attribute must be used carefully since it can be used by compiler to optimize away any manual non-null checks you have in the code. 
That won't work deterministically
Formatted makes strings from the data, and with that it adds null pointers and other stringy-things. Unformatted is for raw data arrays.
Opening in binary mode solved most of my problems. I went back and messed around for a while and this is the final result. Thank you for your help. int jump(FILE *script,int jump_to_line) { int current_line_number = 0; int current_character_index = 0; char single_line[200]; while(EOF != fscanf(script, "%200[^\n]\n", single_line)) { if(current_line_number == jump_to_line) { break; } current_character_index+= strlen(single_line)+1; current_line_number++; //printf ("line %d cnt %d\r\n", current_line_number, current_character_index); } return current_character_index; }
The "something odd" is that no matter what value you put in, this program always prints `2`? A pointer is not an array. You're not measuring what you think you're measuring.
Okay. So using pointers as arrays is ill-advised then and I should simply use arrays in this case. With that said, I would imagine testing the length of an array would produce the same results as the above code, but I will do that exercise here soon.
You have to store the information yourself. I use the Slice and Vec types in https://github.com/myrrlyn/wyzyrdry-c for these purposes, for instance.
That sizeof trick only works with static arrays, and even then only in the scope in which the array was declared. If you need to keep track of the size of an array, you have to either pass the size separately, or use a struct containing a size variable or a pointer to an array on the heap. Either way, it's up to the programmer to make sure that the size variable is always updated to match the true allocated size of the array.
Any chance you want to learn Python instead?
Why?
It would be easier to use sscanf or fscanf. For example: fscanf(data, "%d:%d:%d,%f,%f,%u,%u,%u,%d", &amp;hours, &amp;minutes, &amp;seconds, &amp;calories, &amp;distance, &amp;floors, &amp;heart_rate, &amp;steps, &amp;sleep_id); 
http://courses.washington.edu/css342/zander/css332/passby.html
`user_data-&gt;distance` notation looks incorrect as it is not a pointer to struct, rather it is declared as array. Try `user_data[x].distance` instead, the only time you use `-&gt;` is for pointer to structs. 
When you call a function, the arguments are copied. If you modify a parameter in a function, this does not affect the value of the argument you passed on the caller side. To illustrate this, consider this code: void foo(int x) { x = 42; } void bar() { int x = 23; foo(x); printf("%d\n", x); } If you call `bar()`, 23 is printed because `foo()` only assigns to its own copy of `x`, not the `x` you passed in. That's why pointers are used. Pointers are also copied when you pass them to function, but they still point to the same place, so you can use them to modify what they point to.
At the end of everything, yes it will be global. Or local to main or whatever. Right now I'm just testing this one function so I don't think I care about the scope of that variable yet
Can't. Class assignment. And everything, aside from the explicit use of strcpy, is actually set as a requirement by the assignment
If you want to use strcpy() to store the values from the file, then everything in the struct has to be character arrays ( aka strings ). You can't BOTH use strcpy/strtok AND store the values as doubles, without using a function to convert the "char *" to a "double". Your compiler is telling you this, but you seem to want to find a way to disagree with it.
Okay, so START by telling us what your rules are. What functions are and aren't you allowed to use? Don't expect people to guess, and happen to know exactly what your assignment was.
I have, ad nauseum. The code in the original post contains the functions. I gave the required format of the .CSV. The intended outcome of the program is stated.
Try Ninja and Meson instead... Much more intuitive and faster. http://mesonbuild.com/Tutorial.html
You said you can't use certain functions. Which ones CAN you use? Seriously, to go from text data that contains a numerical string "0.043" to a "double", you _have_ to use a function like strtod(). You can't just do it some other magical way - you absolutely have to call a function. So, either, your assignment is impossible, or you're interpreting it wrong. 
my question is not about an array of pointers
That's not what he's asking about, reread the title. An array of pointers is `int *array[8]`, `int (*array)[8]` is a whole different thing.
Please don't make new accounts to circumvent a ban. I have reported you to the admins.
This. The C language only supports "pass by value." Your intuition is telling you C uses "pass by reference," but your intuition is wrong in this case. In C, pointers are often used as a pseudo-pass-by-reference.
This is similar to the output of [xxd](http://linuxcommand.org/man_pages/xxd1.html). The output on the left side is hexadecimal and is printed in two byte pairs just for readability. The output on the right is the ASCII character representation of each byte, or a "." if it is a non-printable character (such as '\0').
##Endianness Endianness refers to the sequential order used to numerically interpret a range of bytes in computer memory as a larger, composed word value. It also describes the order of byte transmission over a digital link. Words may be represented in big-endian or little-endian format, depending on whether bits or bytes or other components are numbered from the big end (most significant bit) or the little end (least significant bit). When addressing memory or sending/storing words bytewise, in big-endian format, the most significant byte, which is the byte containing the most significant bit, is sent first (has the lowest address) and the following bytes are sent (or addressed) in decreasing significance order with the least significant byte, which is the byte containing the least significant bit, thus being sent in last place (and having the highest address). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove
Yes.
Pretty much all of them. C and Assembly are the two most common languages used for microcontrollers. 
That worked magically!! thanks, using make seems to do the work however I wonder why is make there, I read something about windows supplying their own version of make called NMAKE. 
I'm not sure if this has anything to do with it as I've never used it, but your calls to `scanf_s` do not specify a buffer size. Is the behavior the same regardless of the operator? Does it occur with `Q`, `C`, or `H`? What is your output like?
As far as I remember, the program crashes with all of the operators :( I will have a look at the buffer thing when I get home, cheers
Wow, so this fixes the loop? I'll give it a go when I get home! Thanks mate
You need to put four blanks in front of every single line of code and a blank line between code and the paragraphs around it. Note that also `#include &lt;stdio.h&gt;` counts as a line of code.
This is certainly a major bug that can cause a crash. You shouldn't be using those _s functions, but if you do, you need to use them with the right number of arguments. 
Your indentation and general code formatting is a bit of a mess. You'll get the hang of it with time, but you may want to read about C coding conventions and follow one. As /u/dragon_wrangler said, you're setting your variables outside the loop, so they keep their "old" values the second time you get a number. You should make sure all your variables have the values they should have (i.e. q = 2, r = 2, w = 0) at the beginning of _each_ iteration of the while loop. I tried making that change and it seems to work fine now. Just in case this is homework, I'll let you find out for yourself how to do that.
##Endianness Endianness refers to the sequential order used to numerically interpret a range of bytes in computer memory as a larger, composed word value. It also describes the order of byte transmission over a digital link. Words may be represented in big-endian or little-endian format, depending on whether bits or bytes or other components are numbered from the big end (most significant bit) or the little end (least significant bit). When addressing memory or sending/storing words bytewise, in big-endian format, the most significant byte, which is the byte containing the most significant bit, is sent first (has the lowest address) and the following bytes are sent (or addressed) in decreasing significance order with the least significant byte, which is the byte containing the least significant bit, thus being sent in last place (and having the highest address). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove
Additional notes on the endianess: array[1] is 234. If you were to print the hex value as in:`printf("0x%08x\n", array[1]);` the output would show `0x000000ea`. The four bytes are 0x00, 0x00, 0x00, and 0xea. Now if you think of array[1] as an array of bytes instead of a 4-byte integer, things change. unsigned char* ptr = (unsigned char*) &amp;array[1]; printf("0x%02x ", *ptr); ptr++; printf("0x%02x ", *ptr); ptr++; printf("0x%02x ", *ptr); ptr++; printf("0x%02x", *ptr); The result is `0xea 0x00 0x00 0x00`. Because your system (or at least the one in the example) is *little endian*, the least significant byte is stored in the lowest memory address. `ptr` points to the start address of `array[1]`. `ptr++` moves `ptr` to the next byte in memory. On a *big endian* system, your bytes would be ordered the same way as when you first printed `array[1]`, but both systems have the same output with `printf("0x%08x\n", array[1]);`. So you do not have to worry about bit-wise operators when acting on a variable (`array[1] &amp; 0xff` will give you `0xea` on both).
maybe this: https://stackoverflow.com/a/7678852
Haha! I saw that example; even pulled down PortAudio. (I promise I wasn't being lazy. Thought there may be better mouse traps out there.) Thank you for your comment. I think I will build PA and then test it out. 
Preprocessor macros are replaced literally. Wrap the definition target in parentheses to avoid order of operations biting you like this.
Asserts are an important debugging tool. The important aspect of assertions is that they are internal-only. Never assert argc==2 or that read() succeeds. Always assert function preconditions and postconditions, and any invariants that need to hold. The more assertions you have, the more likely you'll catch a bug close to the point of error.
That syntax is not supported on reddit. Read the formatting guide for details. Note that you can click ‚Äúedit‚Äù to fix your post.
Follow up: is leaving assertions in the final code a good practice? 
If you want your users be responsible for finding bugs, yes. If you think, it's the job of the software team, disable assertions. I've seen both options in other people's commercial software, but I prefer to trust in my code and test processes. So I release with assertions disabled (`NDEBUG`).
Thank you.
`assert` things that you know should never ever happen, and if they do happen it would be invalid state so you might as well crash out loud
Those same warnings that tell you how to disable them?
I'd much rather have a dump from a field defect that blew up with an assert as soon as things started going wrong than with a segfault after everything has been corrupted. More importantly, misbehaving code needs to be killed before it can do serious damage to customer data.
As a general rule always wrap the all expressions and variables that are inside macros with parentheses. It prevents issues like this
No problem! Glad you figured it out, and best of luck with the rest of your program.
A few tips. This is a pretty common pattern in dynamically growing buffers so it could make sense to learn how to do this efficiently in general. I prefer to encapsulate buffers like this in a struct. So I'd do something like this: struct foo { char **argv; int argc; }; So the function would be `allocate(struct foo *, const char *data)`, except that allocation is not the interesting part of the function, so I'd call it `insert`. Also, it is good practice to prefix functions with something that identifies what they operate on, so it would probably be `foo_insert` (except not "foo", but an actual good struct name, naming is hard). This way you just don't need to deal with triple pointers and stuff. Second, growing the array every 16th insertion might make sense for you when you're dealing with a handful of data, but it would become insanely inefficient with larger amount of data since inserting n elements would take O(n^2 ) time. The text-book solution is to double the array size for every allocation. For that you need to keep track of the current size you have: struct foo { char **argv; unsigned int arg_count; unsigned int arg_size; }; _count is the number of elements in the array, _size is the size of the allocated array. unsigned because we don't expect to deal with negative counts and sizes. Except. You don't want to actually double the size of the array. You want to grow it by around 1.5x on each allocation. This has to do with the behavior of malloc and memory fragmentation. Experience and research has shown that 1.5x is pretty much as efficient as 2x and much nicer to memory management in the long run. It's a complex topic, but either trust me on this or google "memory fragmentation" and related topics. So the `foo_insert` function would look something like this: void foo_insert(struct foo *f, const char *data) { if (f-&gt;arg_count == f-&gt;arg_size) { if (f-&gt;arg_size == 0) f-&gt;arg_size = 16; else f-&gt;arg_size += f-&gt;arg_size / 2; f-&gt;argv = realloc(f-&gt;argv, sizeof(*f-&gt;argv) * f-&gt;arg_size)); // let's pretend that malloc/realloc never fails. } f-&gt;argv[f-&gt;arg_count++] = data; } Notice that I don't do malloc. People very often have two code paths here (like you had), one for the initial allocation and one for the growth of the array. There is no reason to as long as your struct is properly initialized (which it has to be anyway). `realloc(NULL, x)` does exactly the same thing as `malloc(x)` and this way there are fewer code paths to maintain and reason about. Also notice that the sizeof is applied to the actual pointer value we'll be assigning, not a type name, so we don't need to change that if we change the type (it should in fact probably be `const char **` in your example), also it is always wrong to cast the results of `malloc` and `realloc` in C (unless the code needs to be compiled with a C++ compiler for some reason, then we have to grudgingly accept this abomination). Don't forget to initialize the struct before using it: void myfunc(void) { struct foo f = { 0 }; foo_insert(&amp;f, "Some data 1"); foo_insert(&amp;f, "Some data 2"); foo_insert(&amp;f, "Some data 3"); } A note on `malloc` failing. If you're in a constrained environment, you need to deal with. For normal applications that are going to run on a normal machines I generally don't care. If `malloc` fails we're so far out of our comfort zone that either the application has a serious error or the machine it is running on is already struggling very hard so crashing is the fastest way for us to exit and free up some memory. N.B. I really dislike the whole `if (f-&gt;arg_size == 0)` bit, so I usually write: `f-&gt;arg_size += f-&gt;arg_size ? (f-&gt;arg-&gt;size / 2) : 16;` but this can be a bit hard to swallow for some people. You might not want to write code like that as a beginner because you won't understand it next week.
On the other hand, asserts are expensive. It means there's a lot of tests that are very unlikely to fail, and they won't catch all problems anyway. If you assert thoroughly even in often called code (and you should, to catch bugs early during development), this will make the application very slow.
Yes, asserts in performance critical code do get disabled.
&gt; It implies that you don't trust the code to have been tested well enough. The code with asserts enabled was the most tested.
Yes, most of us could do that. Won't, but could.
thank you and the hint.
Right, I use static functions in callbacks all the time. And it's still a function pointer, but if you want to get slightly more esoteric, I also use static functions for auto-start routines in self-contained modules. (This is on embedded devices running on the bare metal.) I'll have a macro called AUTO_START(func, priority) that creates a struct with a section attribute that stores the function pointer and priority. The linker file is set up with a section for the auto start structs so they all end up in a contiguous block of memory and a loop in main() iterates through the list and calls all of the startup functions in priority order. Again, not by name. That's probably not what they were going for in the interview.
Also known as exploding comments.
lmao will steal that
I know. One of my first languages was Simula. Would you have preferred that I said ‚Äúcall it by *its* name‚Äù? BTW, ‚Äúcall by name‚Äù and ‚Äúcall by value‚Äù are misnamed; it should be *pass* by name or value.
Huh, just noticed the lag issue. Messed up setting in OBS. Just fixed it. I used to write all the code out and run it but I kept running short on time. I'll see if I can incorporate your suggestion (which is a good suggestion) in future videos. Thanks :)
Thank you 
Okay
Something I have enjoyed using is the godbolt interactive compiler and the ideone (and similar) compilers. Very soon godbolt will allow for automatic running of code after typing finishe, very nice for these sorts of videos. picoc can also be configured in a similar manner IIRC. Great content as always.
Love you. Learn every language you can. 
Focus dude. Are you staring at his lips or leaning how to code?
Good video. I'm glad you didn't jump to typedefs right in the beginning. Many people don't like to use typedefs with structs just because it makes the code less readable. For example, typedefs are forbidden for structs in Linux kernel development.
&gt; typedefs are forbidden for structs in Linux kernel development As they damn well should be :) typedefs are a fundamental part of C. They aren't, however, a fundamental part of structs. Edit: typo
‚ÄúBeginner‚Äù and ‚Äúintermediate‚Äù mean different things for different people. Could you describe what concepts you understand well and what things you don't get?