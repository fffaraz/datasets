You'll need to do it for each and every symbol you use, of course. You'd also need to get the symbols out of glibc and make sure you're using the correct version each time: the "default version" for a particular symbol as of a particular glibc release may not necessary correspond to that glibc's version number (though I strongly suspect glibc sets things up so that it does). I never said this was a particularly scalable solution. :-)
Ahhhh, thanks!
Heres the prompt: Create a program that will prompt the user for the number of die (between 0 and 3) that the user would like the computer to roll. Based on that input, and using if-else statements output the appropriate number of die values (between 1 and 16, we have fancy dice), and sum up the values appearing on the die. For example, here are a few executions: Please enter the number of die to be rolled: 2 The two die have values of 7 and 12, for a total of 19. Please enter the number of die to be rolled: 5 We can only roll at most 3 dice. Please enter the number of die to be rolled: -2 Number of die to be rolled must be greater than 0. There are three test cases just to get you started, the remaining 7 points will consist of: formatting 2pts, comments 2pts, variable names 1pt, random numbers working properly (should get different die values everytime program is run) 2 points. For a total of 10 points So I need to specify whether the number they input is too low or too high. And the asignment is submited through a website called learn.zybooks which has its own compiler and autogrades it based on our codes output. That accounts for 3/10 points and the rest is based on the TA looking at your code.
The easiest way is to link with `-static` so the compiler generates a static binary: cc -o my_program -static my_program.c
... i simply cannot think of a purer reason to make a program, than to compute some numbers. thats the whole reason computers were invented 
`printf("Commission is %f.2 \n", comision);` `return 0;` &amp;#x200B; By the way, 'commission' is spelt incorrectly.
Glibc isn't fully static, it doesn't have static NSS which means you won't be able to use things like getaddrinfo if you use this option.
Oh yes indeed. Thankfully the FreeBSD people didn't seem to make this kind of braindead decisions.
The shaders in your sample project have version 1.20 declared. Perhaps your graphics card is too old?
Yaiks - I put the wrong link. Thanks for the warning! I fixed my question now! My systems compiles fine the 3.30 shaders, so I do not know why it won't work for Craft!
What do the instructions say about invalid input? It seems to me that they're expecting the program to exit rather than ask the user to enter a different value, so maybe try doing that. Also you might want to look in to `for` loops to handle the different die rolls.
You need to look at craft's opengl initialization code first; check which version it uses
Which of these tutorials did you compile?
as u/thinking_lobster suggests, the code is creating a window without GL "hints" for GLFW, check the documentation on GLFW on how to create the appropriate context for GL 3v3 ... 
If you can't find the function, just copy paste the below code to the line just before window creation function and then compile: glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
When I learn a new language, my favorite project is to build a simple irc server and client
Thanks thinking_lobster. However, it still ouputs: glCompileShader failed: 0:1(10): error: GLSL 3.30 is not supported. Supported versions are: 1.10, 1.20, 1.30, 1.00 ES, 3.00 ES, 3.10 ES, and 3.20 ES 
Do glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE); This can fix the problem (sometimes).
&gt; glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE); do you mean GL_TRUE? If yes, than it still outputs the error!
I mean GLFW_TRUE
then i get **error: ‚ÄòGLFW_TRUE‚Äô undeclared (first use in this function); did you mean ‚ÄòGL_TRUE‚Äô?**
Your friend doesn't know what he's talking about. The compiler will do exactly the same thing your macro would do anyway, so what's the point?
&gt; but my friend said I should always use In Computer Science, the word *always* is *always* wrong. Develop a solution that works, then, if it isn't fast enough, *measure* the performance and optimize the slow parts.
Do you have an array of arrays or rather an array of pointers? What is the size of each array member?
Premature optimization is the root of all evil. Go a direction and make sure your code is good enough that it can be revised later, then optimize it IFF you need to. 
What kind of image?
If you‚Äôre asking whether I want a PNG or JPG, etc. It doesn‚Äôt actually matter. However I can get the array to present the data works.
It matters a lot because that determines what libraries you can use. Or if you're not allowed to, which image format spec you need to spend some quality time reading.
Okay thank you very much.
I'm guessing the point is if you create a multidimensional array using multiple mallocs instead of a single malloc, your array won't be contiguous in memory and that can affect performance. That's not something the compiler can magic away.
True -- but the solution is not to write a macro, but to use an appropriate type: int (*array)[20] = malloc(sizeof(int) * 10 * 20); Though this requires that all dimensions but the first be statically-known. If the dimensions are dynamic then array syntax breaks down. Even then, you should be writing an `inline` function to access it instead of a macro.
&gt; this requires that all dimensions but the first be statically-known this is pretty much never the case in practice if you want your program to be even remotely generic.
First off, if you‚Äôre using some matrix math/linear algebra library you‚Äôll want to use whatever format it uses, although you might need to wrap it up a bit to add on some bookkeeping data of your own. And any time you emulate, you should definitely use a macro or function to wrap it up. (If you can use an inline function, that‚Äôs most preferable, and it gives you the most flexibility.) If you‚Äôre just talking about *n*-dimensional arrays without regard to external API, then there are a few situations where (in C specifically) you‚Äôd want to emulate rather than just use the built-in goop. If you want a column-major array (e.g., for better cache locality or more predictable prefetch) instead of row-major, you either have to swap dimensions (`[i][j]` to `[j][i]`) or emulate it yourself, either way being digested to the same IR and assembly code by the compiler innards. (I.e., there would be no performance difference, even if the compiler isn‚Äôt optimizing.) If the matrix is coming to/from an image on another device (e.g., GPU), or if you‚Äôre dealing with a region within a larger array, then you might need to deal with extra padding between rows/columns. In this case emulation via macro/function would be the easiest, most portable &amp; flexible way to go. (Hide the array type if you can, to stop yourself from accidentally bypassing that.) If the row and padding sizes are fixed, or if you have GNU/full C99\* extns and do this inside a function body, you can also cheat and either make a `struct` struct padded_row { column_t column[NR_COLS]; char padding[COLPAD_SIZE]; }; struct padded_row my_array[NR_ROWS]; ‚Äîthen access `[i][j]` would be `my_array[i].column[j]`‚Äîor if the padding is in units of `sizeof(column_t)`, you can do my_array[NR_ROWS][NR_COLS + NR_COLPAD]; and access it normally. For the usual packed *n*√ó*m* (constant-ish *n* and *m* modulo GNU/C99/etc.) matrices, stick with what the language gives you when you can. At best you‚Äôre doing roughly the same as what the compiler would do with roughly zero performance difference. Using the built-in `[]`isms can be a little more awkward when `malloc`ating or argument-passing, but C lets you do array pointers: int (*array)[4][4] = malloc(sizeof(*array)); if(!array) detonate(); for(unsigned i = 0; i &lt; 8; i++) for(unsigned j = 0; j &lt; 8; j++) (*array)[i][j] = 8 * i + j; ... free(array); etc. If all the `(*)`ing is not to your taste, you can do int (*array)[8][8] = ...; #define in_array (*array) ... in_array[i][j] = ...; ... #undef at_array free(array); and use the macro instead. In other languages like Java, yes, you‚Äôd want to stick with a 1D array for matrices for performance‚Äôs sake; Java has only one-dimensional arrays, so a ‚Äú2D‚Äù array like `int[][]` is an array of (potentially `null`) *pointers to* (arbitrarily long) arrays of `int`. Accessing an *n*-dimensional array of this sort requires a walk of an arbitrarily-short linked list, which imposes a strict sequence on the instructions and may require some branch-based null and/or length checks at each step. A C or reduced-to-1D array access involves exactly one memory access after a nearly-unordered offset calculation, which plays much nicer with CPUs and GPUs. -------- \*I can‚Äôt recall offhand if C99 permits variable-length arrays inside `struct`s. I know GNU does.
It is an image. Shouldn't be too hard to write it as a bitmap or PNG file to disk. 
if you use matrix (no pointer) then it IS a flat array in memory, the compiler take care of the offset for you, at compile time when it can. Do you think you can write a better access code than the compiler?
this is not true, in many field like physics you deal with fixed size matrix, like rotation matrix, transaltion matrix, and many kind of filtering use fixed size matrix. If you need dinamic sized array, i fail to see how you can think to make a more optimized using monodimensional array; what you are writing is basically a custom memory allocator. Good luck
&gt; Do you think you can write a better access code than the compiler? Of course not, but with regular matrix notation (arr[i][j]): * You can't determine the dimension of the matrix at runtime (unless you have &gt;C99, and hence why I was talking about mallocing the array). * You need to know the number of dimensions upfront. With a bit of thinking, my suggestion can be generalised to a variable number of dimensions. And yes, this is useful, properties of physical systems can change as the dimensionality changes. * The row/column major order is fixed, whereas with my suggestion you can easily use either. This can make interoperability with, for example, Fortran libraries easier (which use the opposite order to C). Switching can also be useful if you later find your algorithm is more cache efficient with the other.
A 2-dimensional array is also continuous as specified by the standard. What many people are erroneously referring to as 2-dimensional arrays are actually called Iliffe vectors. Which one is faster depends on a number of factors such as the cost of multiplication for computing the address on your target platform, access pattern (for caching) and so on. A proper 2D-array probably makes loop optimization easier for the compiler too. IIRC the syntax for proper 2D arrays is: `int (*arr)[N] = malloc(sizeof(int)*N*M);` 
That's the kind of nonsense belief that leads to people using incredibly inefficient algorithms, you can't optimise trash.
Also, the absolute easiest format to output (assuming your data is just pixels and you don't need to manually draw shapes or something) is the [PBM family](https://en.m.wikipedia.org/wiki/Netpbm_format) which at their simplest are straight up ASCII text. Many tools can then convert them to other formats.
Non-Mobile link: https://en.wikipedia.org/wiki/Netpbm_format *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^213127
Sounds like open source.
In addition to what others have said, you can compile on an old Linux, for example CentOS6. The resulting binary will work with more recent glibc because glibc ABI is backward compatible.
I don't understand the question. It prints 8byte, which is what you asked for.
Well sizeof returns type size_t, so the format specifier should actually be %zu. It works because size_t is actually an unsigned int (or some form of it), and since 8 (bytes) is well inside the bounds, it'll display no problem.
 [`sizeof()`](https://www.geeksforgeeks.org/sizeof-operator-c/) returns either size_t or a unsigned int depending on the implementation. When you use the int (%d) print format specifier, C will perform [type conversion](https://www.geeksforgeeks.org/type-conversion-c/) to print the correct value.
It is a compile time unary operator which can be used to compute the size of its operand. The result of sizeof is of unsigned integral type which is usually denoted by size_t. When sizeof() is used with the data types such as int, float, char‚Ä¶ etc it simply return amount of memory is allocated to that data types. %d is a format specifier which is what you want for the output of the sizeof() operator. In you example that would be up the integer 8.
* The first point is not true, until you hold the array and not a pointer to it. And would still be a problem with allocated stuff. * I need to think about this. In c++ there are template, in c is a bit more complex but possible, I think you can create in the funtion a matrix... Pointer. As you are not allocating it, is not a VLA and then you work "normally" with it. Crude but should works (some casting maybe required) * one of the possible solution to before is to use the single array and do the math for indentation, that is the original alternative solution.
https://stackoverflow.com/a/2550799/1033027
tl;dr: you got lucky. It just so happens that the size_t returned by sizeof() could be printed as an int. There are various ways this could have happened, but ultimately you got lucky. A better compiler would have warned you that your format didn't match the argument. As /u/cborse pointed out, you should have used %zu instead of %d.
I'm assuming the filenames numtype.c and numtype.h in your post is a typo? The function definitions and numtype.h include go in the .c file. Those are backwards.
Thank you, /u/TonyTwoTits and /u/chimpan_z, it was a combination of both. The file names on reddit were a typo and they are actually correct. The errors were removing the declarations of the two bool functions in main.c (which I forgot to do after I played around with some stuff) and including numtype.h in main.c instead of numtype.c.
Run `glxinfo` and make sure that "OpenGL core profile shading language version string" is &gt;= 3.30 If not, your GPU driver doesn't support 3.30, note that the supported OpenGL version might be different from the supported GLSL version.
There were definitely quite a bit of errors in the exercises when i used this for one of my classes (3rd edition). Besides that, the book is quite helpful. They keep an up to date list of book corrections here: http://csapp.cs.cmu.edu/3e/errata.html
I believe you meant to say suffixes, not prefixes but it's a super minute error and your advice is great. I'm mostly here to also advise OP learn how to use [include guards](https://en.wikipedia.org/wiki/Include_guard) in their header files. It would not have prevented this particular problem, but it can help prevent similar problems in the future. Personally, I tend to use [`#pragma once`](https://en.wikipedia.org/wiki/Pragma_once) instead of include guards, because: 1. It's supported by all major compilers, so it's perfectly safe for small, personal projects where portability isn't a major concern. 2. Although rare, include guard name collisions are unbelievably annoying and can be hard to pinpoint. These points make it a perfect solution for beginners, just never forget that eventually you will likely need to eschew it in favor of include guards when portability is a primary goal, or when you know your code will be run through a compiler that doesn't support `#pragma once` (I believe very few compilers for embedded chips support it for example). P.S. Sorry for continuing to piggyback off your great advice.
The normal 2 or 3 dimensional array access *is* actually the same as computed 1 dimensional array access. So I don't expect that calculating it manually would do any better. 
My computer died on me a couple years ago and I was too broke to buy new hardware so I pulled out my Raspberry Pi I drew some sprites for a game by typing numbers into a text file converting it to a PBM with a script and converting that to the type of image I needed.
&gt; sizeof() returns either size_t or a unsigned int depending on the implementation This is confusingly stated. The sizeof operator *always* evaluates to a size_t. However, depending on the implementation, size_t may be an alias for unsigned int.
You can't just printf a char, it expects a const char* as the first parameter.
The macros are fine, but you are printing incorrectly. Turn the warnings of your compiler up eg for gcc/llvm ‚Äú-Wall -Wextra‚Äù. 
Your boolean stuff is defined correctly, but you are segfaulting on the `printf(a);` line. Change it to `printf("%d\n", a)` and remove the unnecessary following line.
Could you recommend somewhere I might be able to read up on printf? :) I'm still stuck: ``` #include &lt;stdio.h&gt; // Boolean #define BOOL char #define FALSE 0 #define TRUE 1 int main(int argc, char const *argv[]) { BOOL a = TRUE; printf("Hello, world!\n"); printf("%s\n", a); return 0; } ```
Macros are good, but you can also just use an int: FALSE == 0 TRUE == any other value 
Nailed it! I've never understood `printf` implemented in any languages. I'm sure it's easy to learn, I just haven't taken the time. Do you have any good C resources I could learn `printf` at?
#include &lt;stdbool.h&gt;
Perfect!
http://www.cplusplus.com/reference/cstdio/printf/ https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm cpp reference reads like a insurance statistics encyclopedia sometimes, so I‚Äôd suggest tutorialspoint first as it‚Äôs less dry
Declaring a function in multiple files is fine and in fact the only way you can call it correctly. It's only *defining* the function multiple times that's forbidden.
First of all, triple-backtick syntax does not work on reddit. Please don't use it. Second, `printf` takes a different formatting specifier for each type. `s` is for strings, `d` is for decimal integers. When passed as variable arguments, characters are automatically converted to integers, so `d` is the right formatting specifier.
Got it. Thanks! I think the new Reddit takes triple backticks, it‚Äôs formatting properly for me. 
If this is the suggestion of the tutorial, throw it away because it's a pile of garbage. Since C99 you use the header `stdbool.h` for this purpose: #include &lt;stdbool.h&gt; It defines a type `bool` and values `true` and `false`. If you can't use C99, you can write something like this: typedef enum { false, true } bool; to make your own boolean. This is better than macros for debugging as `true` and `false` are identifiers visible to the debugger if you define them like this. Macros on the contrary are resolved during preprocessing and don't generate debugging information. Note that in C, it's rather uncommon to use boolean values. Instead, it's usual to just use an integer with varying conventions. The C language's operators assume 0 is false and everything else is true, but depending on the use case, boolean values may also be encoded differently.
I'm not asking if there is someone in the world that know better (after all compiler get improved day after day); I'm asking if *you* know better.
Instead of triple backticks, indent every line of code with four blanks. If reddit accepts triple backticks anywhere, that's a bug.
This is the most thorough answer here. I‚Äôm copying and writing this down in my notes ‚Äî thank you!
Interesting! I‚Äôll stick to four spaces for the future üëç
`printf` isn't the point of breaking in your understanding here, I think. The point of breaking is your understanding of variables and parameters. In C, everything happens very, very explicitly. In higher level languages like Python, you can `print()` any type because the language does a bunch of fancy stuff to make things nice and abstract. If you look at the [manpage for printf](https://linux.die.net/man/3/printf), you can see that the first parameter is explicitly typed: it's asking for a `char*`, which is a pointer to a section of memory containing chars. A "string" is just a block of memory that contains a bunch of garbage. What's important is that there's a null byte, `0x00`, (`00000000` in binary) at the end of the garbage. The most basic way to output text is like this: #include &lt;stdio.h&gt; int main() { fputs("hello there!\n", stdout); } `fputs()` takes a `const char*` and a file stream. Then, it jumps to the memory indicated by the `char*`, and copies every byte it finds to the stream until it hits that `0x00`. `printf()` is more complicated because it uses the `char*` you give it as a format string: It writes stuff to stdout just like `fputs()`, but occasionally stops to insert some specially formatted stuff. You still have to put your parameters in using a format string though, because if you try to `printf('A')`, it'll attempt to read memory at `0x41`, which isn't a valid memory address and therefore will result in a catastrophic failure which brings your program crashing down. You can read more about strings [here.](https://www.prismnet.com/~mcmahon/Notes/strings.html)
&gt; if you have no know size and working with dynamic memory, you are working also with the allocation of the memory AND its access. Well yeah, when you're allocating an array with size that's unknown before runtime, you also have to do that, you multiply the number of elements by their size in bytes, this just adds one multiplication to the allocation which is hardly a custom allocator. &gt; The algorithm is the same in all dimension Exactly, so why *not* make the algorithm generic? &gt; so there is no need to allocate nothing you say that like allocating memory is somehow a bad practice and scary. And the rest of your point is very muddled and I really don't understand what you're getting at.
&gt;However when you do it again and calculate the factorial of the new number the output is the multiplication of the factorials of two numbers. At which point will `f` be reset back to its initial value? &gt;a=1 That's an assignment, not a comparison. Think about what that will do. 
I haven‚Äôt wrote a lot in C but I did write a basic shell. It supported piping and input/output redirection. It was my ‚Äúfirst‚Äù real c project so I was pretty happy with it. I worked on a lisp like toy language for a bit.
&gt;is hardly a custom allocator If you talk about a flat array I agree. I was understanding you propose a Pinter *alloc() based approach (each row can have different size) &gt; why not [...] Generic It is. &gt; allocating memory is scary Yes, any *alloc() can bring a lot of issue, smart pointer helps but are not a solution. Of course we need those function BUT I think as long as you can you should avoid them. It forces you to think a bit more on the design, but I believe it is all time gained from debugging segfault.
`#include &lt;stdio.h&gt;` `#include &lt;stdlib.h&gt;` &amp;#x200B; `int main(){` `int num,factoriel=1, i;` `char ans;` `do{` `printf("Type a number:\n");` `scanf("%d",&amp;num);` `for(i=1;i &lt;= num; i++){` `factoriel=factoriel * i;` `}` `printf("The factoriel is: %d\n",f);` `f = 1;` `printf("If you want to contuniue type y else type n\n");` `scanf(" %c", &amp;ans);` `if(ans == 'n'){` `break;` `}` `}` `while(1);` &amp;#x200B; `return 0;` `}` &amp;#x200B; Okay so I edited your code a little bit. First of all, I assume you wanted to make an infinite do-while loop that calculates the factoriel until you want it I changed it so it "runs" until you press 'n'. Your problem is that you didn't reset f to it's inital value 1. You need to do that because f stores the value of the previous number. For an example the first number was 2 and it calculated the factoriel as 2, than you type the next number 3 (but f is still 2) so in the for loop it will be f = 2\*1, f = 2\* 2, f = 4 \* 3; that's why you need to reset the value of f. &amp;#x200B; &amp;#x200B;
&gt; The first point is not true, until you hold the array and not a pointer to it. this will happen *as soon as you call a function on the matrix* &gt; some casting maybe required No, you cannot typecast to an array type dynamically, this requires you to know the size of the matrix at compile time. Also you keep talking about writing better access code than the compiler when under the hood it's doing *exactly* what was suggested by /u/thats_interesting : `a[i][j]` is strictly equivalent to `(*(a+i))[j]` which in turn is equivalent to `*((*(a+i))+j)`. Subscript access is syntactic sugar for pointer arithmetic, it is *strictly* equivalent. And when `a` is a pointer or array type, `a+i` actually computes the address with `a + i*sizeof(a)` which is equivalent to `a + i*dim`, and if you just use a flat array and write the arithmetic yourself, the compiler is just as capable of computing it at compile time if it can. If the matrix dimension isn't known at compile time it can't, it doesn't matter if you're using templates in c++, you're just offloading the multiplication to the accessor, which will just be inlined by the compiler and do exactly the same thing. It's as if you think that compiler produced code is somehow magic. You have to compute the offset from the base pointer at some point and that requires a runtime multiplication, whether you put it there or the compiler does it for you has no impact on performance. &gt; one of the possible solution to before is to use the single array and do the math for indentation Wow, weird, that's exactly what was suggested in the first place.
He knows what he is talking about. That is basically what it has been done for the latest 30 years to say the least. That there are other alternatives that have more benefits nowadays but were not practical in the past, that is another thing. In the topic of the question, typical linear algebra libraries use the one dimensional array model to represent matrices. Sometimes they do more complex stuff than putting all the elements in column or row major order. For example they divide the matrix in logical sub blocks and lay the elements of the sub blocks contiguous in memory (technique known as blocking). This is more cache friendly in bigger matrices.
I'm still at University but over the summer I reverse engineered airplay, wrote an implementation of a modified SRP6-a exchange that Apple uses, implemented the pairing / auth process (with some help) and then wrote a module for VLC to stream media to any airplay enabled receiver.
That does not work if you load the matrix dimension from a file. You won't always have a single size for your matrix nor want your operations rely on a fixed size that works for a particular instance of a problem. You basically need to keep 4 values to represent the matrix: - The pointer to the array - Size for each dimension (m , n) - The size of the leading dimension, which is the size of a row/column of the allocated matrix depending wether the matrix is represented in row/column major order. This is useful when working with sub matrices. Optionally a 5th value pointing wether the matrix is in row or column major order, which would be useful for compatibility with Fortran programs.
He means having an array of pointers to arrays. In an M by N this means using M+1 malloc calls.
Sincerely, I have no idea what it means. I had never been this far in C
&gt; If you talk about a flat array I agree. I was understanding you propose a Pinter *alloc() based approach (each row can have different size) We've been talking about single dimension arrays to implement matrices in this entire thread, if you're talking about anything else you haven't been paying attention &gt; It is generic No it's not, you're suggesting to implement a solution for known size matrices, you talked about translation and rotation. And just for those two, if you want to be able to cast them to the appropriate type to use subscripts, you have to write separate functions for each because translations are N+1 in size while rotations are N, or you have to use N+1 matrices for rotations with an extra row and column of zeros and a one on the diagonal, but at that point you're wasting CPU cycles for the comfort of using subscripts, and the author specifically said he was aiming for performance. Regardless, if you now want to do a rotation in N+4 dimensions you need a new function. It's *not* generic. &gt; Yes, any *alloc() can bring a lot of issue, smart pointer helps but are not a solution. Of course we need those function BUT I think as long as you can you should avoid them. It forces you to think a bit more on the design, but I believe it is all time gained from debugging segfault. It seems you would do better to stick to C++ or garbage collected languages if you'd rather avoid any manual memory management. Yes, avoid allocs when you can, but in this case you can't avoid them without a huge trade off, and managing memory is a big part of writing C, if you're going to write any substantial code in C, managing memory properly is something that you have to learn. It seems like you're past the point where you're avoiding allocs when you can, and trying to avoid it even when you shouldn't.
I am not programming in C now but at University, in a group of 3 people, for a course, we had to extend an educational OS that runs on x86-64 CPUs. We implemented a subset of &lt;pthread.h&gt; (the initial version did not support multiple threads per process), fork, exec, shared memory, copy on write pages and swapping pages to disc.
I wrote Feynman, a simple planetary orbit simulator. https://gitlab.com/CrazyBaboon/Feynman
Thank you a lot. I already knew what the problem was but i couldn't find how to reset the value. I am very new in programming. Thank u again , I understand now better how it works.
thanks. I get **OpenGL core profile shading language version string: 4.50**, so that should be ok
&gt; #define GLFW_TRUE 1 Same error again! 
I think sadly is not actively maintained. But then again, probably for a good reason. Craft seems to be a great balance between code simplicity and features.
That's impressive. I'll go and find another occupation now.
&gt; this entire thread Not sure, but in this case the only advantage I can take on the table is better readability and maybe writing since you can use "normal" indexing &gt;know size matrixes It mist be know at the moment of call of the function, like any other method out there; inside the function you just use a matrix pointer, for example. Then the operation inside of the function are generic as much ad you can make them. &gt;you would do better stick I work in the embedded world so I'm more sensible to those issue since normally you can't *alloc() at all by design.
&gt; It's nice creating something that goes from int main() to 2500 lines of code. As long as main itself does not contain all those 2500 lines. ^^
&gt;&gt; this will happen &gt;And this is why is a convention in C to pass array size as parameter. I don't see the point there, and I don't see how you get get around this in C. You're the person who suggested that you could know dimensions as long as you're holding to the multidimensional array and not a pointer to it, I'm just pointing out that this is simply impossible to do in any practical application for various reasons. &gt; No, I can do something (inside of the function) like float (*map)[x][y]; x and y have to be defined at compile time for this to work &gt; you need to sparkle some * around nope, Matrix[i*dim + j]. &gt; The advantage of template There are no templates in C. This is not a subreddit about C and C++, this is C only, stop suggesting solutions in other languages. &gt; not having to pass the size explicitly You don't, you can just declare a matrix type: typedef struct Matrix { float *data; int width, height; } Matrix; and then pass matrices around, you'll always pass the size implicitly, like with templates. And you can even write a macro to access it without having to do the math every time. &gt; float a[X][X] force the matrix to be squared for example Again, this is not valid C syntax if X is not defined at compile time. You're holding so hard onto the double subscript syntax and trying to find workarounds just so you don't have to do `[i*dim + j]`, this is ludicrous. &gt; Yes. Is a possible solution, not the only. It's the only *reasonable* solution in *C*. Unless you have an alternate one that you still haven't mentioned, all you've rambled about are templates which are C++ and fixed size matrices, which is not a solution at all.
Cool project! Here's a simple Makefile: TARGET = feynman SOURCES = Source/*.c HEADERS = Source/*.h CFLAGS += -I/usr/local/include CFLAGS += -I/usr/X11R6/include LDFLAGS += -pthread LDFLAGS += -L/usr/local/lib LDFLAGS += -L/usr/X11R6/lib LDLIBS += -lglut -lGLU -lGL -lm all: $(TARGET) $(TARGET): $(SOURCES) $(HEADERS) $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(SOURCES) $(LDLIBS) clean: rm -f feynman .PHONY: all clean (The include and library paths are suited to my system.)
partial output of glxinfo (less than 1000 lines): name of display: :0 display: :0 screen: 0 direct rendering: Yes server glx vendor string: SGI server glx version string: 1.4 server glx extensions: GLX_ARB_create_context, GLX_ARB_create_context_profile, GLX_ARB_create_context_robustness, GLX_ARB_fbconfig_float, GLX_ARB_framebuffer_sRGB, GLX_ARB_multisample, GLX_EXT_create_context_es2_profile, GLX_EXT_create_context_es_profile, GLX_EXT_fbconfig_packed_float, GLX_EXT_framebuffer_sRGB, GLX_EXT_import_context, GLX_EXT_libglvnd, GLX_EXT_texture_from_pixmap, GLX_EXT_visual_info, GLX_EXT_visual_rating, GLX_INTEL_swap_event, GLX_MESA_copy_sub_buffer, GLX_OML_swap_method, GLX_SGIS_multisample, GLX_SGIX_fbconfig, GLX_SGIX_pbuffer, GLX_SGIX_visual_select_group, GLX_SGI_make_current_read, GLX_SGI_swap_control client glx vendor string: Mesa Project and SGI client glx version string: 1.4 client glx extensions: GLX_ARB_context_flush_control, GLX_ARB_create_context, GLX_ARB_create_context_profile, GLX_ARB_create_context_robustness, GLX_ARB_fbconfig_float, GLX_ARB_framebuffer_sRGB, GLX_ARB_get_proc_address, GLX_ARB_multisample, GLX_EXT_buffer_age, GLX_EXT_create_context_es2_profile, GLX_EXT_create_context_es_profile, GLX_EXT_fbconfig_packed_float, GLX_EXT_framebuffer_sRGB, GLX_EXT_import_context, GLX_EXT_texture_from_pixmap, GLX_EXT_visual_info, GLX_EXT_visual_rating, GLX_INTEL_swap_event, GLX_MESA_copy_sub_buffer, GLX_MESA_multithread_makecurrent, GLX_MESA_query_renderer, GLX_MESA_swap_control, GLX_OML_swap_method, GLX_OML_sync_control, GLX_SGIS_multisample, GLX_SGIX_fbconfig, GLX_SGIX_pbuffer, GLX_SGIX_visual_select_group, GLX_SGI_make_current_read, GLX_SGI_swap_control, GLX_SGI_video_sync GLX version: 1.4 GLX extensions: GLX_ARB_create_context, GLX_ARB_create_context_profile, GLX_ARB_create_context_robustness, GLX_ARB_fbconfig_float, GLX_ARB_framebuffer_sRGB, GLX_ARB_get_proc_address, GLX_ARB_multisample, GLX_EXT_buffer_age, GLX_EXT_create_context_es2_profile, GLX_EXT_create_context_es_profile, GLX_EXT_fbconfig_packed_float, GLX_EXT_framebuffer_sRGB, GLX_EXT_import_context, GLX_EXT_texture_from_pixmap, GLX_EXT_visual_info, GLX_EXT_visual_rating, GLX_INTEL_swap_event, GLX_MESA_copy_sub_buffer, GLX_MESA_multithread_makecurrent, GLX_MESA_query_renderer, GLX_MESA_swap_control, GLX_OML_swap_method, GLX_OML_sync_control, GLX_SGIS_multisample, GLX_SGIX_fbconfig, GLX_SGIX_pbuffer, GLX_SGIX_visual_select_group, GLX_SGI_make_current_read, GLX_SGI_swap_control, GLX_SGI_video_sync Extended renderer info (GLX_MESA_query_renderer): Vendor: Intel Open Source Technology Center (0x8086) Device: Mesa DRI Intel(R) HD Graphics 520 (Skylake GT2) (0x1916) Version: 18.0.5 Accelerated: yes Video memory: 3072MB Unified memory: yes Preferred profile: core (0x1) Max core profile version: 4.5 Max compat profile version: 3.0 Max GLES1 profile version: 1.1 Max GLES[23] profile version: 3.2 OpenGL vendor string: Intel Open Source Technology Center OpenGL renderer string: Mesa DRI Intel(R) HD Graphics 520 (Skylake GT2) OpenGL core profile version string: 4.5 (Core Profile) Mesa 18.0.5 OpenGL core profile shading language version string: 4.50 OpenGL core profile context flags: (none) OpenGL core profile profile mask: core profile OpenGL core profile extensions: GL_3DFX_texture_compression_FXT1, GL_AMD_conservative_depth, GL_AMD_draw_buffers_blend, GL_AMD_seamless_cubemap_per_texture, GL_AMD_shader_stencil_export, GL_AMD_shader_trinary_minmax, GL_AMD_vertex_shader_layer, GL_AMD_vertex_shader_viewport_index, GL_ANGLE_texture_compression_dxt3, GL_ANGLE_texture_compression_dxt5, GL_APPLE_object_purgeable, GL_ARB_ES2_compatibility, GL_ARB_ES3_1_compatibility, GL_ARB_ES3_2_compatibility, GL_ARB_ES3_compatibility, GL_ARB_arrays_of_arrays, GL_ARB_base_instance, GL_ARB_blend_func_extended, GL_ARB_buffer_storage, GL_ARB_clear_buffer_object, GL_ARB_clear_texture, GL_ARB_clip_control, GL_ARB_compressed_texture_pixel_storage, GL_ARB_compute_shader, GL_ARB_conditional_render_inverted, GL_ARB_conservative_depth, GL_ARB_copy_buffer, GL_ARB_copy_image, GL_ARB_cull_distance, GL_ARB_debug_output, GL_ARB_depth_buffer_float, GL_ARB_depth_clamp, GL_ARB_derivative_control, GL_ARB_direct_state_access, GL_ARB_draw_buffers, GL_ARB_draw_buffers_blend, GL_ARB_draw_elements_base_vertex, GL_ARB_draw_indirect, GL_ARB_draw_instanced, GL_ARB_enhanced_layouts, GL_ARB_explicit_attrib_location, GL_ARB_explicit_uniform_location, GL_ARB_fragment_coord_conventions, GL_ARB_fragment_layer_viewport, GL_ARB_fragment_shader, GL_ARB_framebuffer_no_attachments, GL_ARB_framebuffer_object, GL_ARB_framebuffer_sRGB, GL_ARB_get_program_binary, GL_ARB_get_texture_sub_image, GL_ARB_gpu_shader5, GL_ARB_gpu_shader_fp64, GL_ARB_gpu_shader_int64, GL_ARB_half_float_pixel, GL_ARB_half_float_vertex, GL_ARB_indirect_parameters, GL_ARB_instanced_arrays, GL_ARB_internalformat_query, GL_ARB_internalformat_query2, GL_ARB_invalidate_subdata, GL_ARB_map_buffer_alignment, GL_ARB_map_buffer_range, GL_ARB_multi_bind, GL_ARB_multi_draw_indirect, 
nop, it still says GLSL 3.30 is not supported.
It's not fancy but quite useful to me: [nostt](https://github.com/sjmulder/nostt), a command line NOS Teletekst reader. Teletekst is the Dutch teletext system, like BBC's Ceefax.
HelloWorld.
At this point, I can't tell if you don't understand what I'm saying because of the language barrier, if you're disingenuous, or if you're stupid. You're arguing completely besides all of my points and you're not making any point yourself.
Just did a merge request. Had to create a GitLab account first, can't believe I didn't have one yet!
Yeah... well I‚Äôm at university and... and... I just invented the internet... so, yeah, we‚Äôre all doing stuff „ÉΩ( ÔΩÄ0¬¥)Ôæâ 
Since C is my go-to language for most of the work involved, I made a helper library containing various useful tools and features, such as memory allocators, easy-to-use sorting/searching modules, containers (such as buffer, array, ring buffer, ...), JSON5 parser, startup argument processor, threading helpers and so on: [https://github.com/zpl-c/zpl](https://github.com/zpl-c/zpl)
Hello future genetically enhanced me, please build a time machine.
&gt;x and y must be defined at compile time. It works, but maybe if you need c99 (maybe not, as it is just a pointer) &gt;template I'm discussing different technique, if you make comparison with other languages you can sometimes see different and alternative solution you can then eventually backport. &gt;you can just declare the matrix as And then your structure explicitly take size inside, so it is still part of parameter you have to manually set.
Awesome, I have made something similar, but not to the point where I would feel happy about publishing it. Definitely putting together your own tools and utilities is one of the best ways to get an understanding of how things should work and fit together.
I agree, it helps a lot to understand what is going on under the hood and therefore makes development easier. It also makes it easier to contribute to other projects and improve their code since you already get some experience from your own environment, already knowing those pitfalls or strategies involved in their code abstraction.
Thanks - Merged accepted!
I have written lots of C over the years. The best thing I have written lately is a Finite State Machine. Code for using it looks like this: a_fsm fsm; a_fsm_init(&amp;fsm, NULL); a_fsm_transition transitions[] = { /*{{StateName, StateFunction, StateContext}, {TransitionOnReturnCode, CheckAfterSeconds, NextStateName}}*/ {{ "START", (a_fsm_callback)state_1, NULL}, { 1, 10, "NEXT"}}, {{ "START"}, { 2, 10, "NEXT"}}, {{ "NEXT", (a_fsm_callback)state_2, NULL}, { 1, 10, "LAST"}}, {{ "LAST", (a_fsm_callback)state_3, NULL}, { 1, A_FSM_WAIT_IMMEDIATE, "END"}}, }; a_fsm_add_transitions(&amp;fsm, transitions, A_ARRAY_SIZE(transitions)); a_fsm_execute(&amp;fsm, "START"); Using a FSM approach in my code has made a lot of stuff easier to work with as if you can code up how you want something to work in an FSM it is often much easier to think about than having the code wrap the actual functionality and transitions between states and actions. 
Have you contacted devs of craft? After all, when everything fails, they are your only hope 
Thanks I will contact the dev
I could say the same. Float a[x][x] is valid c99, but this is not the solution I use, but instead "a" is a pointer matrix. (Oh, I see, maybe reddit markdown eaten the asterisk away?)
btw you can use `pkg-config --libs --cflags &lt;insertlibraryhere&gt;` instead of hard coding include directories and -l commands
No, sounds like he implemented the collection of userland utilities. No sure why he mentioned the filesystem, nor why it was ext2 (unless it was before 2001).
Cheers. Didn‚Äôt know pkg-config is in OpenBSD base but it does seem to work well, even for the GL stuff from base.
Haha thanks. It was part of GSoC so I had a lot of support but I spent a loooot more time on crypto than either I or my mentor had initially predicted. It should be merged onto the main branch soon‚Ñ¢!
&gt; Code Well, part of it. What about the `PrintCol` function? How are we supposed to test it if you don't actually provide all the code? Why haven't you used any indentation? Isn't writing it like that... hard?
I write and maintain [Simply Fortran](https://simplyfortran.com), an integrated development environment for the Fortran programming language. The environment is primarily written in C (there's a smattering of Lua), using the Win32 API on Windows and GTK+ on Linux and macOS. It was first released in 2010, and it continues to be developed almost entirely in C.
I actually did some of the same a couple of years ago, even through it was the audio part only (old AirTunes). I came to this thread and wanted to say that was mine. You beat me to it. :)
This thread is making me all sad. I've done C for 6 months and wouldn't even be able to begin anything close to as impressive as this stuff
I know that feel. I've used it for some time now and at most I've done with C was some 2D matrix operations, least-squares regressions and a basic heat in a thin plate simulation for a laser cavity. Hard to test and hard to get information out of it. At least the iterations were a bit faster than MATLAB, that's for sure. Sounds fancy but I think it could be done way better.
The compiler will optimize that pointer away easily. There is no performance difference.
I'm a noob, the best thing I did so far is a the horizontal word length frequencies histogram from k&amp;rc first chapter.
HTTP server. I know it doesn‚Äôt sound like a lot but I‚Äôm still leading C so it is a big accomplishment for me. Parsing was the hardest part 
Inverse Kinematics solver for a robotic arm (if you want to move the tip of the arm at a particular velocity, it calculates the joint rates that achieve that).
They probably implemented the utilities to work directly on an ext2 file system image or device file rather than a file system mounted to the VFS. ext2 because it's easier to implement than ext3 and ext4.
Everything on my itch.io page: http://deftware.itch.io/
Pintos? I think they should have taught some bsd / linux though, not heavy for that level.
BTW, I did not get why they teach things like recursion with a recursive algo to calculate n!. The way I was introduced to recursive algo was binary trees. I had a recursive program in my pre-uni cs class (to compute powers), but had thought it was just an proof of concept of recursive function calls.
Thanks, good catch. Changed it up top
I have written a program for an embedded processor whose primary purpose is to monitor the AC voltages and currents in a network protector, and then making decisions when to trip or close the protector. The product also communicates via DNP out of a RS485 or RS232 port, collects information from peripheral devices, gathers data and creates the packets for a PLC system, communicates and controls and FPGA to modulate the PLC data onto the line. It is something that has to run indefinitely without failure, and I've been extremely proud of the fact that, other than a poorly design specification (which caused some issues, and was primarily my fault), the relay processing function has never failed to do what it was designed to do, with over 3500 years of total operation time.
You mentioned this was a part of gsoc right? What year are/were you in? I would love to try for it next summer but am pretty clueless on where to start :(
Wannacry
;(
I'm currently on year 3/4 in Scotland. The way it works here is you get a BSc after 3 years and honours after the fourth. The first year was fairly foundational so for a 3 year course you could probably do it after the first year as long as you are comfortable with the language and program on your own time fairly regularly (speaking from my personal experience). I went into this knowing it was hard. There are plenty of other internships you can take that are less intense than this one though. I applied on a whim and videolan liked my portfolio so they offered me the position. Pick three you like and give it a shot. Thats what I did and I was delightfully surprised to get it.
No it's not Pintos. It's an in house OS, not publicly available.
Do you go to UNT? 
What is the expected result? What is the actual result?
1) You need to learn to use a debugger. DM me if you want to ask questions about GDB or Windbg but being able to debug your programs is the only way you'll learn what mistakes you were making without guessing. 2) You're copying data out of bounds of the string buffer in the first string. You have two char\[\] on the stack and you're attempting to overwrite the null char in the first one and join the second one to the first one by copying it past the bounds of the first one into the second one. This actually should work on some platforms, but you're smashing the boundary between those two arrays and depending on the flags and stack protections that codeblocks is using it may not be cool with that. It's bad practice. You should allocate space for a new string on the heap, merge the strings into that new buffer, and print that buffer, then free that buffer. Easy :)
Thanks, I will add you as a friend. I will DM you if I got some queries. But as I am new to programming my questions may be dummy :). 
yes this seems like homework, so far so good though on OPs part
I spent the past summer writing [a subsystem for shared memory in MATLAB](https://github.com/gharveymn/matshare) through their C MEX API. I think it works pretty well! I was really using the project to learn how to write C, but I also learned a lot about writing cross-platform code, what not to waste my time on, managing backwards compatibility, and basically a lot of project management.
With enough `inline` functions this can be true.
Too bad your project has the Code of Conduct as well. Never going to use it.
While I don't follow the recent news, I believe I had this file created automatically and forgot about it. It's now removed from the repository.
OK. Do you have a starting population of 1?
N years ago I got frustrated with all the existing‚Ä¶ well, status bar *content generators*, or status bar *schedulers*, or how you call it. And wrote this: https://github.com/shdown/luastatus
&gt; #include &lt;stdio.h&gt; &gt; &gt; int main(void) { &gt; printf("The estimated population growth over a 75 year span.\n"); &gt; &gt; int years; &gt; double total_pop1 = 7442000000; &gt; &gt; for (years = 1; years &lt;= 75; years++) &gt; { &gt; printf("Year %d: %lf\n", years, total_pop1); &gt; total_pop1 *= 1.09; &gt; } &gt; &gt; return 0; &gt; } that is what i am looking for but can you explain the equation total_pop1 * = 1.09 and thank you so much for the help 
It's just a short form of total_pop1 = total_pop1 * 1.09 There's no advantage, it's just a habit.
You're most welcome.
Oh so VFS is an abstraction on your filesystem? Interesting
A few mistakes in there. First of all you can't declare char *s = "whatever" and then write to that memory. Not only did you not allocate enough characters to append to this, but this declaration will put a static string into a read-only part of your process. Writing to that will always bomb out. Declare an array with enough room for the eventual content instead. The while() loops you use aren't exactly correct because you jump the \0 in *s and then append; when you print that string, even when it works, the output stops at \0 and it seems like nothing happened. But something happened, you got "Pointer\0Array" in there. Do this: #include &lt;stdio.h&gt; void strcat1(char *, char *); int main() { char s[50] = "Pointer"; char *t = "Array"; strcat1(s,t); printf("\n"); puts(s); printf("\n"); return 0; } void strcat1(char *s, char *t) { while(*s != '\0') s++; while(*t) *s++ = *t++; }
Do you have a github to share? Your profile sounds amazing
I made a [path tracer](https://github.com/VKoskiv/c-ray) from scratch. It‚Äôs my first larger C project I‚Äôve done. It‚Äôs got some scope creep, but I just love it and I really like adding stuff in as I learn it. I‚Äôm taking another break from it to work on my math foundation more. Code quality feedback very welcome!
A g r e e
Linux kernel?
/headdesk no idea why I didn't think of UNIX. I'd say probably UNIX is valuable historically then Linux is valuable currently (very broad strokes)
I made [picoc](https://gitlab.com/zsaleeba/picoc), a small C interpreter. It's quite handy for embedding C scripting into other systems. People are using it for things as varied as robotics and desktop application scripting.
It's hard to argue against Unix on the "overall benefit to humankind" angle, if for no other reason than C and UNIX go hand-in-hand. Without Unix we wouldn't have C at all.
Hello World, simply because it opened us up to endless opportunities. A whole new world!
gcc
But who taught Hello World?
It's a bit of a rough question. What's the most important word in natural language? unix, gcc, linux are all important, but everything is in context. Most of the computers, internet infrastructure, etc are written in C, often with other things on top. There isn't a simple answer.
... based on an operating system called Unix.
&gt; A whole new world! A new fantastic point of view 
no it's not the original unix wasn't even SUS compliant or whatever
meta
Was stuxnet written in C?
partially and c++ too
Printf 
im from israel. it was written in assembly.
No question about it. Most of the computer and electronics industry depends on it.
Stuxnet is unusually large at half a megabyte in size,[51] and written in several different programming languages (including C and C++) which is also irregular for malware.[13][18][48]
The linux kernel is worth literally nothing. It's freeware ffs.
Only valid answer imo. 
TIL. I had assumed it was mostly asm.
I support this, it's the official-unofficial debugger
Well, "monetary value" is somewhat ambiguous. It could mean "what software has cumulatively contributed to the productivity of the world". For example, if I write an application that saves 100 people an hour a month, that's 1,000 man hours a year. You can use that as a unit of measurement, or you can assign an average hourly salary based on what we know about those people (country, education level, etc). This one overlaps with "benefit to humankind", so I'm guessing it's not what you meant. Alternatively, it could mean "what program has the most revenue that can be directly attributed to it?" So if I write an application and sell each license for $20 and sell it to 10,000 people, that's $200,000. For the most productivity improvement, you'd likely have to go with either the OS kernels that most computers today use or the fundamental tools that make computing possible (GCC, binutils), which includes the aforementioned kernels. I'd expect Windows would have the most revenue associated with it (even those it's not entirely written in C). Quite a few people use Windows to increase their productivity, so it could contend in the first category as well (though do we have to subtract what they paid for it?)
Have you looked at SWIG?
Damn, /r/C_Programming, do you just have no sense of humor at all?
https://en.m.wikipedia.org/wiki/Inetd, which is a key piece of the internet.
Non-Mobile link: https://en.wikipedia.org/wiki/Inetd *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^213499
I thought gcc is written in C++ these days...
puts debugging best debugging
printf("here 1\n"); buffer = getAlloc(MEM_SIZE); // printf("here 1b\n"); //*(char*)buffer = 0; printf("here 2\n");
[ctypes](https://docs.python.org/3.7/library/ctypes.html)
That project looks really, really cool. Will check out soon!
Winsock is a library for networking. It used BSD TCP internally til Vista.
Thought it hada different stack internally. I knew NT used bsd sockets though. Thanks
What are you talking about?
stdio.h
This. Didn't matter what your OS or system was, you had a networking stack basically ready to go that just needed to be plugged in.
[removed]
I‚Äôve been testing it, is there a way to use get-py on the NIH version? Or should I use the normal version for now?
Quake, of course
`get-py` is the old download-a-bunch-of-files "package" manager from mainline ToaruOS before 1.2. Had the binaries it downloaded been statically built, they may have still worked in NIH (as they would have embedded newlib), but a quick check indicates they were all dynamic so they're not going to work with the new libc. The package manager introduced in 1.2 (`msk`) won't work under NIH either, for the same reason (and also because you would need a Python built with `zlib` support, which the NIH distribution lacks). So if you want to try out third-party ports, use the [last release of mainline](https://github.com/klange/toaruos/releases/tag/v1.2.3). I'm slowly working to get all the ports back to a functioning state in NIH and will reintroduce the package management system eventually.
[python-cffi](https://cffi.readthedocs.io/en/latest/) is a pretty good library, one that lets you write as little C as possible. It's nice to use it because it'll work with other python implementations too, like pypy.
Thanks. What if i put main program options/functions into a global struct instead of function pointer context handle, which is how i see is usally done.
No, but LLVM is.
Something to multiply unsigned integers beyond 2^64
I'm from Colorado. You are correct.
I mean, you're not wrong
Compiler?
It appears that you got shadow-banned. Please message the reddit admins to resolve this issue.
[removed]
Do you mean Gnu C Compiler or Gnu Compiler Collection? 
generally minimising global variables can help compartmentalise code, potentially making it more reusable, the idea of a "context" struct is not a bad one and indeed some libraries use this idea. people often talk in absolutes with coding practice, I think a pragmatic flexible approach is often better
I'm sure this will be downvoted, but I'm an EE who has been developing embedded code for 40 years. Aside from a minor role in a few projects 15 years ago, no place I've worked has used Linux at all. I had a difficult period from around 2005 to 2012 where I worked a lot of short contract positions all at different companies in a number of states. Not a single one of these places used Linux for anything. They all used Windows for development and those who used an operating system used a commercial embedded OS. Embedded development is different from the majority of development. Also a lot of what is called embedded development today is what I'd consider high-level application development (a lot of "embedded" platforms are basically a single board Linux computer).
We‚Äôve been using SWIG in production for more than 2 years, and we‚Äôve had almost no problems with it. Although, the main advantage for us was the relatively low learning curve required by developers coming into the project. Also plays well with CMake. Hope you give it a try...
GNOME (Linux) and well of course UNIX. Thanks to MULTICS 
UNIX Version 4. Nothing comes close to that one. 
I‚Äôm using the mainline now, and holy crap is this project impressive. I‚Äôm mega-busy this semester, but I‚Äôll try and squeeze in time to explore the codebase and see if I could add stuff. (I‚Äôve never done kernel development before!)
Some parts of it. Lots is still plain C.
99% of it is c++, wtf are you on about?
gcc-8.2.0 gcc/c (C frontend) plain C gcc/cp (preprocessor) pretty much everything plain C, couple of files in C++ gcc/* (common backend) plain C gcc/config/ (target-specific backend) mostly plain C, SH and TilePro have C++ parts libcc1 (plugins support?) C++ libcpp (preprocessor?) plain C libgcc plain C libgomp (OpenMP) plain C libiberty plain C libitm (transactional memory (?)) C++ libquadmath plain C libssp (stack smashing protector) plain C libsanitizer (ASAN) C++ libstdc++ C++ I believe some parts of the optimizer were also in C++ but I cannot locate them now.
Why is this dude getting downvoted? It's a valid answer, certainly more correct than some of the others on this thread.
Use `strlen` to get the length of a string, not sizeof. 
I think you have to use doubles for that to work
The size of enumeration types is implementation defined. If you want to have a `char`, why not try typedef unsigned char MTYPE; and then just enum { A = 1, B = 2, C = 3; }; to define the enumeration constants.
This. Apparently [ITRON, a Japanese OS,](https://www.linuxinsider.com/story/31855.html) is ***far*** more popular than Linux. See #8 on [this article](https://blog.darknedgy.net/technology/2016/01/01/0/) for some other contenders in the embedded world. I'm really surprised at everyone parroting "Linux" on this thread. Linux's monetary value is indirect, at best. Unix was at least a very expensive piece of software used on mainframes at universities and other high-profile places. Lots of things were invented with Unix that have a clearer monetary value than anything in the Linux world. There are many more pieces of software with much more immediate value than Linux.
thanks :\*
If precision is not a concern, even a float should do. Using **int** which has a limited maximum number of ~4 billion just leads to overflow. More information: http://www.cplusplus.com/doc/tutorial/variables/
According to this https://en.wikipedia.org/wiki/Scanf_format_string You have to read the values using %g
unlike `scanf`, **`printf`** takes a actual variable as a parameter, not a pointer to it.
`%le` is valid to read a `double`. ([reference](http://www.cplusplus.com/reference/cstdio/scanf/))
Escape Velocity Calculator Enter the mass (kg): 5.98e24 Segmentation fault (core dumped) $ cat q1fskeleton.c #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { double radius; double mass; double velocity; printf("Escape Velocity Calculator\n"); printf("Enter the mass (kg): "); scanf("%g", mass); printf("Enter the radius (m): "); scanf("%g", radius); printf("mass of Earth: %g\n", mass); printf("radius of Earth: %g\n", radius); double Vesc = pow( (2 * mass * 6.673 * pow(10,-11)/radius), 1/2); printf("Escape Velocity is %g m/s\n", &amp;Vesc); return 0; }
%g is specifically for reading exponential notation
the last `printf` also needs a variable, not a pointer. Change `&amp;Vesc` to `Vesc`
According to [The GNU C Library Reference Manual](https://www.gnu.org/software/libc/manual/html_node/Parsing-of-Floats.html): &gt; All of the `%e`, `%f`, `%g`, `%E`, and `%G` input conversions are **interchangeable**. They all match an optionally signed floating point number, in the same syntax as for the `strtod` function. There is a difference between them in output (e.g. `printf`), but not in input.
Still not work It just interpret huge number to a trillionth number Escape Velocity Calculator Enter the mass (kg): 5.98e+24 Enter the radius (m): 6.38e+6 mass of Earth: 8.67186e-315 radius of Earth: 6.95321e-310 Escape Velocity is 1 m/s $ cat q1fskeleton.c #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { double radius; double mass; double velocity; printf("Escape Velocity Calculator\n"); printf("Enter the mass (kg): "); scanf("%g", &amp;mass); printf("Enter the radius (m): "); scanf("%g", &amp;radius); printf("mass of Earth: %g\n", mass); printf("radius of Earth: %g\n", radius); double Vesc = pow( (2 * mass * 6.673 * pow(10,-11)/radius), 1/2); printf("Escape Velocity is %g m/s\n", Vesc); return 0; }
https://en.wikipedia.org/wiki/Pragma_once
This approach is completely fine. A lot of people do it. But you might also want to have a look at #pragma once. It is not in the C standard but supported by many compilers [https://en.wikipedia.org/wiki/Pragma\_once](https://en.wikipedia.org/wiki/Pragma_once) 
`%g` is for reading `float` `%lg` is for reading `double`
I knew about #pragma once but I've always encountered programs with just the #ifndef statement. I was wondering what the more experienced people used. I will start using it from now on. &amp;#x200B; Thanks for the response.
ez, if the strstr return a NULL how can u do this : if(strncmp(zeiger,search,strlen(search)) == 0)
I've edited my previous reply. Here it is again: - instead of writing `6.673 * pow(10,-11)`, you can use the scientific notation and write that number as `6.673e-11` - instead of using `pow` for the square root, you can just use the function `sqrt` - be careful when dividing integers. The compiler will evaluate `1/2` as `0`! This is because both are integers and the result is an integer. You can fix this by using `1.0/2` (to force the output to be a float) or just use `0.5` directly. Either way, you don't need this value since you'll use `sqrt`
I had no say in this decision, I merely noticed it. Perhaps it is because you insult people when they try to help you.
fun is a function which takes a pointer to a function that has no arguments and returns an integer. 
not much idea whether it is about my compiler or what, but after updating the code, it failed to compile. $ make q1fskeleton make: Warning: File `q1fskeleton.c' has modification time 25181 s in the future cc q1fskeleton.c -o q1fskeleton /tmp/ccorM5tk.o: In function `main': q1fskeleton.c:(.text+0xc6): undefined reference to `pow' collect2: error: ld returned 1 exit status make: *** [q1fskeleton] Error 1 $ cat q1fskeleton.c #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { double radius; double mass; double velocity; prin tf("Escape Velocity Calculator\n"); printf("Enter the mass (kg): "); scanf("%lg", &amp;mass); printf("Enter the radius (m): "); scanf("%lg", &amp;radius); printf("mass of Earth: %lg\n", mass); printf("radius of Earth: %lg\n", radius); double Vesc = pow( (2 * mass * 6.673e-11/radius), 0.5); printf("Escape Velocity is %0.2g m/s\n", Vesc); return 0; } $ gcc q1fskeleton.c -o q1fskeleton /tmp/ccNKULsJ.o: In function `main': q1fskeleton.c:(.text+0xb3): undefined reference to `sqrt' collect2: error: ld returned 1 exit status $ cat q1fskeleton.c #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { double radius; double mass; double velocity; printf("Escape Velocity Calculator\n"); printf("Enter the mass (kg): "); scanf("%lg", &amp;mass); printf("Enter the radius (m): "); scanf("%lg", &amp;radius); printf("mass of Earth: %lg\n", mass); printf("radius of Earth: %lg\n", radius); double Vesc = sqrt(2 * mass * 6.673e-11/radius); printf("Escape Velocity is %0.2g m/s\n", Vesc); return 0; }
&gt; nor is it supported by code analysis tools. Maybe not all of them. We use Coverity which does.
&gt; gcc/* (common backend) plain C Incorrect, just because it has a *.c extension doesn't mean it's actually C, GCC is stupid like that, vec.h and vec.c are both c++ and used extensively.
You use arrays whenever you have more than one of the same thing. This lets you manipulate a collection of things, instead of each thing individually. They're used for ... well ... basically everything. Arrays are one of the fundamental building blocks of computing. Computers need to manipulate collections of items constantly.
Don't use *just* `#pragma one`. Include guards are still very much indispensable. They are much more likely to work across different tool-chains. Particularly in more exotic ones.
Thanks. It worked.
While this is technically correct, I prefer this definition, "enjoyment, amusement, or lighthearted pleasure."
if you're asking what's the point of arrays when compared to other data structures, arrays give the user O(1) access to *any* item in the array. so if you're looking for the 6000th item in a 10000 item array you will be able to get it just as quickly as if you're looking for the 1st item. this is not true of structures like linked (or double linked) lists, trees, etc. but those structures of course have their own advantages. for instance arrays cannot really be resized so adding an element to an array is costly.
Also, to be sure to have properly null-terminated strings, use `snprintf` instead of `strncpy`. It is equally standard and available, and much safer to use. You can also use `strlcpy` if you are on BSD or if you have libbsd installed on your system. Finally, the safest string-copy function that is all the rage currently is `strscpy`, which you can read about [here](https://lwn.net/Articles/659214/).
I wrote an [HTTP/2 server](https://github.com/64/h2) for a school project in my Lower 6th year (equivalent to 11th grade in USA).
Totally fine
&gt; What's with the ransom case() in the third line? Put $10000 in small non-sequential bills in a brown paper bag. Leave it beside the bench in the park.
you can make your framework, welcome to c. [Mine](https://github.com/nihuynh/Chill_unit) [An other one (Way more awesome)](https://github.com/vberlier/unicorn)
Click to see the unicorn of the day:https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR4W3yPERzQ5Mzzq0V7oG1LNaj5mw_HL0Cn03S1Ag8VAAgRmsvq
type on github makefiles ? 
&lt;&gt; is for standard library so it should not be included during compilation.
Or many embedded compilers.
SDL?
No it's not, stop posting crap like this.
its just sample of code, :p
Check out [AudioKit](https://github.com/AudioKit/AudioKit)? It's not C but it's osx
Thx but i'm looking into library that i can incorporate into a C program.
The Mac apis will be in objective c at the least. There might be some cross platform solutions.
&gt;Thx i though it was only about graphics. i'm gonna look into it.
Source? As far as I know the standard reservers identifiers beginning with __ and _[A-Z], but nothing else.
This. Build my magic mirror with this. 
The Jack Audio Connection Kit (JACK) is the _easiest_ way to move audio in and out of a C application. As a bonus, it comes with a fully routable back-end so you can perform computations on audio chains that might otherwise be difficult to access programatically.
I mean C isn't just about pointers.
Magic mirror_
https://www.raspberrypi.org/blog/magic-mirror/
#include&lt;iostream&gt; using namespace std; int main() { double fahrenheit, celsius; cout &lt;&lt; "Enter the Fahrenheit temperature"; cin &gt;&gt; fahrenheit; fahrenheit = ((9.0/5.0) * celsius + 32) cout &lt;&lt; "The temperature in Celsius is: "; return 0; } 
Tell that to my professor. 
An int divided by an int is an int. You should cast it to a float first. 
Oh man. I've been using __ to start all of my identifiers in my guards. Going to have to change that.
What is this line doing? heads = Hcount / 10 \* 100;
I tacked an Infocom interpreter + game onto a boot loader once. I had no idea about the memory layout, but I know that the bootloader loads into ram, so I used a static 1MB array as my dynamic memory pool, and changed the file I/O to just memcpy regions of memory from the data file. I was really surprised to see it work under emulation. I was blown away when I loaded it on actual hardware.
Thanks! that took care of my problem. Can't believe it was such an easy fix
Yes to both 
sqlite deserves a mention as well, as one of the most widely deployed pieces of software.
og dear God I just laughed .. thank you for that. needed a giggle. Yeah .. folks can get a little bent about the whole pointer thing. Often times teaching wrong stuff. Like marching around memory usinf pointer arithmentic into places no one should touch. Like p-n for some n&gt;0 where p is the pointer to the first element in an array. Yikes.
just say NO. Do NOT go there. Stick with the standard headers and the standard portable POSIX way of things and do not wander off the farm. At all. If you want your code to work the same evrywhere and stable then stick with the standards. 
Check out r/cpp_questions - This sub is for the C language Hint for posting code: indent each line by four spaces (adding any necessary indentation from the source itself) so that it renders as a readable snippet of code.
I‚Äôm working on it thank you for the help!
Thank you for the suggestion!
/r/cscareerquestions might be helpful too, good luck!
That's good to know. I do have a couple of degrees in unrelated fields (BA and MA, with some other professional certificates; I've done a lot of college). I was looking into UMUC just because I have in-state tuition there. A coworker though suggested WGU. I'll trying shopping around for a bit and see what I can find. I just find after doing grad-research, I generally know how to teach myself faster than most course will let me progress. But I guess if I have to sit through Programming 101 I will.
c compiler ?
This website is pure cancer.
C++ questions are off topic in this subreddit. Please post them to /r/cpp_questions instead.
[removed]
AudioKit will be using [CoreAudio](https://developer.apple.com/documentation/coreaudio) internally, which is a C library. Chances are SDL and PortAudio will also be using CoreAudio on MacOS. Those are all good choices and something to look at if you want cross-platform support, but CoreAudio might be worth looking at too if you are curious.
Think about what might happen if `pthread_create` fails.
Great books with long titles like "My Reincarnation as a Hot Spring in a different World is Beyond Belief ~ It's not like Being Inside You Feels Good or Anything!?" would not fit in 59 characters. Pass struct pointers to functions, not the struct itself. I'm not sure how much of a good practice this is, but I would use defines for the size of arrays. You can use the name of the define to give a bit more info than "60" would. 
Any program that includes this header and also any standard header may run into the problem though (any standard header include may cause errno.h to become included). Which would be pretty much all programs. Maybe 
readable but ugly , use typedef and separate words in the function name with \_ or capital letter.
You could be just overflowing the stack. I can't actually reproduce the problem on my system, but I can generate a fault for other reasons. Think about what might happen if your `pthread_create` call fails.
What did you try to achieve the wanted result? Currently it's quite unclear what you want to do in the first place. A variable of pointer type T *D, simply holds an address of memory that holds a value of type T. Do you want to modify said address? I'm afraid, that's probably not what you want to do nor are allowed to.
SDL is a great, for more advanced options BASS is the option
I think you're running out of memory due to the stack size allocated for each thread. Check out this [stack overflow question](https://stackoverflow.com/questions/5635362/max-thread-per-process-in-linux) I made these changes and was able to run to completion: //printf("tid_val: %ld\n", tid_val); tds[tid_val].i_thread = i; tds[tid_val].node_thread = tmp; - pthread_create(&amp;tid[tid_val], NULL, change_data, &amp;tds[tid_val]); + pthread_attr_t *tattr = malloc(sizeof(pthread_attr_t)); // probably needs to be free'd somewhere + size_t stacksize = 1024000; + pthread_attr_setstacksize(tattr, stacksize); + pthread_create(&amp;tid[tid_val], tattr, change_data, &amp;tds[tid_val]); + printf("stack size: %d\n", stacksize); ++tid_val; tmp = tmp-&gt;next; }
Option BASS ?
Core Audio (the native OSX C audio APIs) is not that complicated when you dig into it - and it is pretty powerful.
This is theoretically true, but not in reality; consider the code block below: extern char arr[1000]; // some array initialized somewhere else int i; for (i = 0; i &lt; 100; ++i) printf("%c", arr[i]); printf("%c", arr[100]); printf("%c", arr[500]); Here (considering that cpu has 100 byte cache) then due to the process called prefetching arr[100] will be accessed much faster than arr[500]; for the latter will require a cache miss
heres a C program i made that fakes upload amounts to private torrent trackers to help you maintain a good ratio. [https://github.com/flightcrank/ratio-boost](https://github.com/flightcrank/ratio-boost) &amp;#x200B; im reposting this because apparently some asshole mod banned me for no reason so no one saw my post. damn assholes. &amp;#x200B; &amp;#x200B; &amp;#x200B;
http://www.un4seen.com 
He's saying that when you do `struct-&gt;field` where `struct` is a pointer, it's obvious to the compiler that `struct` is a pointer and as such allowing the syntax `struct.field` to access the field, even when struct is a pointer should be relatively easy for the compiler, so he's asking why instead of adding an arrow operator the language standard didn't simply overload the dot operator to access the struct behind the pointer.
I can't answer the historical why but I can give you an idea of why it's currently desirable. If you're accessing a struct through a pointer with a dot, it's not obvious you're dealing with a pointer, and so it can lead to all sort of bugs like using sizeof on the pointer rather than the underlying struct (and sometimes you actually want to know the size of the pointer so you can't just make sizeof 'pass through' like the dot which is always invalid on a pointer). It also makes you have a clearer mental model of structs, ie, if you have a struct in a struct, all data is contiguous, whereas if a struct contains a pointer to one, the data isn't contiguous, and this informs how you would go about copying it for example, or how iterating over an array of those would impact performance. TL;DR: In C it's important to be aware of what's a pointer and what's not, and this syntax enforces that, and the cost is that you have to type one more character when dealing with a pointer.
%ls expects wide chars, not ints. It just happens to work because on your machine ints and wchar_t's are the same size, and you're filling the array like it's an array of wide chars, and reading out of it the same way with printf and scanf. Your book_id should probably be an unsigned int (you probably don't want negative IDs), or a string (and probably not a string of wide chars). 
Ohh ok, now I understand, he¬¥s asking for a change (unnecessary) on the C programming language!
In C++, doing that would be bad, since the -&gt; operator can be overloaded (for example, by a smart pointer). C could probably allow it, but then C programs become even less compatable with C++ programs. 
enjoy [http://crasseux.com/books/ctutorial/argc-and-argv.html](http://crasseux.com/books/ctutorial/argc-and-argv.html)
HelloAmerika.
Yeah mine woke up via wakeword and recognized who was speaking via their voice
Still, this is a very minor issue as most compilers catch macro redefinitions.
Thanks
&gt; I understand that I need to open two pipes at the start then fork the program. The part I don't understand is when to close stdin, stderr and pipe read/write and what to dup2. Thank you in advance. It's probably best if you show us what code you've come up with so far. Generally speaking, after forking you'll want to duplicate the appropriate file descriptors as required and close _both_ ends of _both_ pipes. This applies to both the parent and child processes. The only difference is which file descriptors should be duplicated, and where they should be duplicated to. Maybe drawing a diagram might help? I'd start off with something like this: +--------+ writer -| Pipe 1 |- reader +--------+ +--------+ writer -| Pipe 2 |- reader +--------+ Parent Child +--------+ +--------+ | stdin |- -| stdin | +--------+ +--------+ | stdout |- -| stdout | +--------+ +--------+ | stderr |- -| stderr | +--------+ +--------+ With this you can work out what needs to connect to what, and in which order.
Are you fixed on programming at C? Mastery in C should help you learn other languages. Learn another language syntax and do a coding bootcamp. You might think you‚Äôre a good programmer but without team experience and just personal projects, you‚Äôre not a good fit for a team of developers. 
I think he just followed the logic from the char variables and tried to do a 15 numbers long int..
You just copied the code from https://www.tutorialspoint.com/cprogramming/c_structures.htm and modified it slightly, lol.
Yes i used their code as a reference. Since im new at all this and cant write code organically at the moment, wouldnt taking code and changing it even slightly and asking questions on it be somewhat helpful to learning? 
Probably to escape it for markdown (so it doesn't swallow it and makes the text italics), but it isn't needed when it's inside a code part.
Not necessarily asking for a change, rather, asking for some context on that design decision.
what part of it is confusing you?
Do not post pictures of code please. Always post code as text in a self post!
I can't really understand how it works
The second image is suppose to be where the questions marks are. Thank you very much! 
Thank You.
Thanks for the response, but could you elaborate what you mean by saying "using sizeof on the pointer rather than the underlying struct would cause problems"? I dont really see the problem if the dot operator would only dereference the "thing" on its left hand side. My understanding of the scenario you described would be: struct foo { int x; }; struct bar { struct foo *f; }; int main() { struct bar *b = malloc(sizeof(struct bar)); b-&gt;f = malloc(sizeof(struct foo)); size_t size_bar = sizeof(*b); size_t size_foo_in_bar = sizeof(*(b-&gt;f)); //this would become sizeof(*(b.f)) size_t size_foo_pointer = sizeof(b-&gt;f); //this would become sizeof(b.f) return 0; } &amp;#x200B;
Yeah im trying to figure out if it would be feasible to implement a language that compiles to c and only uses a dot operator. The backstory is that im also thinking about implementing some other operators that need to know if they are dealing with a pointer or value type
Do you know what a pointer is? Do you know what malloc does? Do you know what a struct is? Do you know how a while loop works? Do you understand the syntax?
Among other things, keeping pointer dereferences somewhat explicit allows the programmer to more easily track/avoid undefined behavior, which there is potentially quite a lot of in regards to pointers. E.g., it‚Äôs better to be able to tell exactly where a `NULL` pointer might be used, and using `.` for everything would potentially obscure that. But most of the reason for `-&gt;` is because without it, you need an awkward parenthetical group around the struct pointer‚Äî`a-&gt;b` is `(*a).b`, which is kinda awful to have to deal with frequently.
To be honest, no. At least in my case. When I was learning to code or when I'm learning a language or framework with new logic behind it, in my opinion I learned slower by copying code here and there. And it made some seriously bad spaghetti code most of the time.
High-performance computing, supercomputing, embedded computing, architecture research/codesign, and security would be things I‚Äôd look into if you want to do systems programming with C. There are a lot of problems (especially approaching exascale) that can‚Äôt be solved by stacking existing frameworks awkwardly on top of each other, so if you‚Äôre good at it and understand your OS stuff well (and can apply it to existing things like Linux) you can get into all sorts of interesting things. Outide of embedded or research, not much call for new OSes, I‚Äôm afraid. We desperately need something not based entirely on the idea that everything shall behave as if it were a 1970s-era mainframe, but it‚Äôs unlikely anybody‚Äôs going to pay for that to happen any time in the foreseeable future. OTOH you can put most of the OS concepts to work in userspace qua runtime software, and being able to do that efficiently at a low level can apparently break people‚Äôs minds, which makes someone of mind unbroken in that situation quite valuable.
Most of the GNU (maybe most in general?) compilers can recognize a standard guard sequence and mark the header as include-once internally. The pragma is more useful as a way to direct the compiler to do that if you‚Äôre unsure whether it can tell the header won‚Äôt do anything important if included a second time.
Can you elaborate what you mean with ‚Äútwo arrays are equal?‚Äù Also, what do the elements in the arrays look like? What is their type and value range? 
Another bad: If the system is configured for strict overcommit, `fork()` called from a program using a lot of memory can fail due to OOM issues despite the CoW optimization and the immediate `exec()`. A big, heavy process cannot spin off new, small processes.
Typically it‚Äôs a good idea to include some common project-related prefix on the identifier. I tend to do both the include guard and an ‚Äúam I being `#include`d from within that‚Äù macro pair with something like #ifndef project__header_h__INCLUDED__ #define project__header_h__INCLUDED__ 1 #undef project__header_h__INSIDE__ #define project__header_h__INSIDE__ 1 ... #undef project__header_h__INSIDE__ #endif /* ndef project__header_h__INCLUDED__ */ This is a little more verbose, of course, and some C++izen will surely show up and kvetch lightly about the double underscores, but since most of the C stuff I‚Äôve done has had to be very careful with identifier prefixing, I ended up using something like `project__` as a prefix for private/non-API-component identifiers, and that‚Äôs worked out reasonably well as a quick visual discriminant.
Yep. Solaris implements `posix_spawn()` as its own syscall because of this, for example.
When you say we need things not based on 70s mainframes you're talking about *nix stuff I'm assuming :P I'm a college kid with not much experience in the real world. Could I steal some of your time and ask you to maybe explain some of the shortcomings of current OSes?
&gt; The two types posix_spawn_file_actions_t and posix_spawnattr_t both control various things about the new process. We could save another parameter, and a whole lot of typing, by merging these into one type with a shorter name. In my opinion, this would be a better interface: &gt; &gt; pid_t posix_spawn(const char *file, const posix_spawn_t *attrs, &gt; char *const argv[], char *const envp[]); Yeah, no. If you want to keep `argv` and `envp` out of `attrs`, you should at least also keep the `file` argument out so it's like `execve`. I'm not sure what you expect otherwise; forcing `file = argv[0]` isn't particularly useful in many situations and is just a convention anyway. The `posix_spawnp` variant exists because it's just so damn useful. I don't want to type posix_spawn_setflags(&amp;attrs, POSIX_SPAWN_USEPATH); every time I query the path. Clearly the intent of this interface design is to allow the user to construct one `attrs` structure for many calls instead of having to rebuild it every time, but putting path-searching behaviour in a flag would make this rather inconvenient.
Well, if we flesh out your example struct P { int *p2; }; int main (void) { struct P p, *p1 = &amp;p; int s; p1-&gt;p2 = &amp;s; *(p1-&gt;p2) = 2; } Then the last line involves two layers of indirection, which is kinda like a pointer to a pointer, yes. Bear in mind however, that it's not the same thing in the type system.
Two suggestions. One is the rubber ducky method, buy a rubber duck and out him on your desk and talk to him and tell him what you want to happen or how something should work. Second one is that you can use pseudocode, basically write English code to help you think about the ideas better. Or both together works
type is unsigned int (size\_t) and the size of the array in my use cases are 81.
Okay. That's what I figured. What range of values would you like to admit? If the range is reasonably small, consider building histograms with the number of times each element occurs in the two arrays and check if the two histograms are equal. This runs in O(*n*) time as opposed to O(*n*&amp;nbsp;log&amp;thinsp;*n*) time. There are similar approaches for other data types; you might also just get away with a hash table (or a trie in case of strings) to push down the run time.
Yes, of course.
Fair enough, i can see how itll be bad and hinder my learning. Right now all i have as references to learn it are youtube videos, tutorials point, and Modern C. I like modern C but it seems too advanced for me atm. I need something that starts basic but isnt holding my hand for everything
Much appreciated thank you
True. My justification for this being okay is basically "musl already does it": https://git.musl-libc.org/cgit/musl/tree/src/process/posix_spawn.c#n161 Maybe that's not technically allowed by POSIX though? A quick look at the spec suggests that `ENFILE`/`EMFILE` aren't valid errors to return from `posix_spawn()`, at least if there are no file actions (because neither `fork()` nor `exec()` can return those errors). I find the utility of detecting `exec()` errors in the parent to be pretty high, personally. Maybe just because I've written code to try to recover from `E2BIG`.
Here‚Äôs my guess at what OP is on about. When I write short programs and disassemble in Xcode, the memory addresses it gives for each of the instructions and data variables are all next to each other. E.g. 0x8000AD74, 0x8000AD75. I think OP wants to store 0x8000000 and then add 0xAD74 or 0xAD75 etc. to it to produce the overall value of the pointer variable, in an effort to save memory. You could try producing an array of the data you want to point to and then use pointer arithmetic adding uint_8 numbers to the base pointer. Yes, this would allow you to densely pack an array of relative addresses but uint_8 numbers max out at 255 so you wouldn‚Äôt be able to use it on arrays bigger than 255 variables. You might find hashsets interesting.
Classic data structure called a linked list relies on this \*feature\* of the language.
Isolation and robustness.
Check ANSI escape sequences. Depending on the shell you're using and the platform, you may be able to customize how stdout displays text. Keep in mind that it is not portable.
You need isolation for security and robustness means that if one process crashes the rest of them as well as the parent survive and it can be spawned again gracefully.
I draw out the pointers and objects as they are when going into a function. Helps me see what the outcome is when i return from func. Also if i draw out what i want to happen i can write it out much easier. I cant keep track of many things in my head at once. This allows me to visually see whats going on and find errors. 
You deleted it! Thank you! Why did not you tell?
Absolutely, nesting concepts like that comes up a lot of programming.
In addition to the link u/david2ndaccount provided, [this](https://stackoverflow.com/questions/7414983/how-to-use-the-ansi-escape-code-for-outputting-colored-text-on-console) SO answer has an example of how you can use the sequences. Ncurses uses ANSI escape sequences to implement a lot of its functionality. For a small project it's probably a lot easier to just use the escape sequences directly.
Not necessarily just \*nix‚Äîeverything from top to bottom in a modern computer necessitates a similar approach, and that‚Äôs starting to cause problems now. Sure. For starters, everything‚Äôs synchronous, even if theoretically nonblocking. Synchronous worked great when there was a single CPU with no cache and a single batch of RAM; nowadays, we have chips that can run hundreds of threads in a myriad of different ways, and a single decoupled OS kernel can‚Äôt possibly make good decisions at that scale, with almost no idea of what the software actually wants to do. So in order to make a good asynchronous layer, you have to undo the kernel‚Äôs synchronous layer imposed upon its less-synchronous underpinnings. And of course, it‚Äôs very difficult for software to make good decisions about its own disposition when it can‚Äôt tell when it might be suspended indefinitely or shunted out of some resource it thought was available. This leaves everybody taking the easiest route and dealing with a few unimposing layers of goop between the programming environment and whatever the kernel provides, and by and large once code is written it sticks forever. If you‚Äôve written some important thingummy to target the usual POSIX I/O, process, and (grudgingly) thread model, you‚Äôre going to try to make it run forever without a major (more-expensive-than-doing-nothing) overhaul. That inertia is the real kicker when it comes to everybody‚Äôs choice of OS, language, etc. Companies want adoption of their hardware or system software by industry, so it has to play perfectly nice with whatever dinosaurs stand on it. On top of all that, there‚Äôs the heterogeneity problem. OpenCL/-GL and CUDA are also fairly steeped in the usual synchronous programming model, and while they make it *possible* to deal with things like GPGPUs, it‚Äôs far from pleasant. You‚Äôre stuck either distributing one binary blob per target architecture (and picking exactly what runs where), or distributing source code and compiling it upon use. OpenCL/-GL and CUDA don‚Äôt play along terribly well either; it‚Äôs hard to support both without treading on one‚Äôs own feet. Regardless, these are exactly the sort of problems that the OS kernel is supposed to deal with, but because everything‚Äôs stuck pretending to be a souped-up VAX, it simply can‚Äôt approach it usefully and everything‚Äôs left up to user mode. Because there‚Äôs no unity there, you have to pretty much limit the non-central PUs to run one thing at a time, or things start fighting for resources. There‚Äôs the network problem. There‚Äôs no reason that an application one one computer should have to reside indefinitely on that computer, but because user-mode software is so decoupled from kernel-mode software, networking has to be done explicitly in terms of network sockets or shared memory, neither of which is especially easy to manage without language or OS assistance. For larger systems with multiple NUMA nodes, you have yet *another* sort of transport and locality to consider, on top of the shite APIs‚ÄîLinux‚Äôs is not terribly well documented and Windows‚Äô is a clown-painted turd. Stuff like Infiniband is in a similar state; shite APIs vs. using the usual network stack for overkill. If you want to manage all these things, you end up having to have a fairly specific system architecture in mind, and you end up with some weird networking amalgam; or else you just use MPI or some other nonsense because it‚Äôs there and not your fault if broken. There are problems being looked at for exascale as well, which present-day HPC doesn‚Äôt really have to deal with, especially concerning power and failure. An exascale system will probably have millions of cores, with a huge power ceiling. Because of the limits in heat dissipation, you‚Äôre not going to be able to run all of those cores simultaneously; you‚Äôll have to spread things out and clock-/power-gate things you won‚Äôt need for a while. Programs will have a power budget, and something will need to intelligently schedule and power-manage things so it‚Äôs not chaos and the die doesn‚Äôt start smoking. OSes don‚Äôt touch this right now; power management events are treated systemwide as a great trauma, software has only complicated (sometimes kooky) ways of controlling power, and explicit power control is often at a fairly coarse grain‚Äîentire cores, entire chips, entire cards, etc.‚Äîwhereas it‚Äôll need to be quite fine-grained and not involve six layers of Python/Bash/Perl scripts. Along with the millions of cores comes a higher failure rate, potentially a few minutes on averaage between cores breaking but it depends somewhat on what kinds of error correction/detection there are, what the fab process is, what the clock rate is, etc. etc. On a smaller system, a sysadmin can bring a node down, kill anything on a board, swap it out, and bring it back up. That‚Äôs not going to be possible at exascale; the failure rate will make it impossible to run a normal-sized job through all the way without something breaking. Controlled failures (e.g., `NullPointerException` or `EINVAL`) are already handled kinda poorly by most languages, but uncontrolled failures are not touched at all. There is no provision to say ‚Äúwell shit, lost that half of the results, have to regroup and redo it.‚Äù Moving to a larger, distributed view, there are some common, specialized platforms but OSes really don‚Äôt deal with the mechanics of distribution (replication, untrustworthiness, identity, publishing, etc. etc.) at all; the host under the OS is singular, self-contained, and (theoretically) unimpeachable, as is whatever a process does with respect to itself. A process is in control of whatever distribution mechanism(s) it uses, and it uses the usual network stack to communicate with other, similarly disconnected processes. Most stuff nowadays either requires a special client (requiring you to manually shuffle data between applications) or has to be explicitly and delicately `mount`ed, giving you some unsatisfactory partial-view of the data. Anyway, this is all systems software stuff that needs to be done properly and/or tied together sanely. Most of it involves language, hardware, and software codesign, and a lot of the researchwise pokings in that direction are going to be lost in the churn until industry settles on a set of programming/execution models and so forth. Unfortunately, because this stuff has all been somewhat festering over the years, it‚Äôs going to be an extraordinarily difficult set of requirements to tie together, especially in some way that industry will decisively stand behind.
Unfortunately, no, I mostly cut my teeth on this stuff when PCs were about where a RasPi is today. Most properly embedded stuff (sub-RasPi-scale) gives you some fragment of the C runtime, and the rest of what you need is either accessed through a flimsy chip/family/mfr-specific API or buried in specs and manuals. The RasPi/router level of embedded gives you either a stripped-down OS or a relatively normal Linux, so that‚Äôs an easy place to start.
Note that there are a couple levels of concurrency provided by most computers, processes and threads. Threads can poke each other‚Äôs memory, fiddle with each other‚Äôs I/O, and so forth; process isolation prevents this. The underlying purpose of multitasking/multiprogramming is to prevent any one thread from starving for resources. If you‚Äôre actually doing things concurrently on a single CPU, only one thread will be able to make progress unless it either voluntarily hands off to another thread (=cooperative multitasking/multiprogramming) or uses the CPU for too long‚Äîusually on the order of 1‚Äì10ms. The quantum tends to be sufficiently large that the overhead of thread-/process-switching is negligible, and threads end up making progress if they can, or blocked until they‚Äôre ready again. When you do things like `read`, `write`, `select`, `pthread_yield`, or `wait`, your current thread may block and hand the CPU off to another thread voluntarily, and most stuff that needs process isolation is doing I/O anyway so everything works out in the end. (And of course most modern CPUs have more than one core, possibly each running more than one thread, so you really have to push to tax the system.) You‚Äôd generally prefer threads if you needed more cooperative parallelism.
Using multiple processes is one way for a program to provide services to multiple clients simultaneously. A traditional way to write daemon (Unix service) is to have a process that listens for incoming connections. When a new client connects to the daemon, the daemon uses `fork()` to create new process that will handle the new client while the original process goes back to listening for new clients. 
One example would be extensions on a web browser. Say you have several add-ons. The browser might spawn multiple processes, one to handle each add-on. Since they ate separate processes, they each run for some limited period of time before yielding to another one. So each add-on (ideally) gets a fair show of run time. In addition, if there is a critical failure in one add-on that can cause memory corruption or some other serious condition, it is done in isolation. If that process fails, it can be killed without interfering with other processes. 
Hi, I wasn't aware of the current situation much. While I did remove CoC as I personally don't see any application for it in our community (as we're very small but welcoming group), I wasn't sure if to announce it here in this post. I'd like to stay out of possible conflicts involving CoC discussion, I hope you understand. ;)
Remember the arrow is a shorthand for deferencing a pointer to a struct, then accessing the member of a struct. ptr_to_structure-&gt;member is the same as (*ptr_to_structure).member Once you have that member, you simply treat it based on the type you gave it. If it's a pointer, use it as a pointer. If it's another structure, use it as a structure. 
If your language supports that context, then sure. When it compiles to C, you use the C operator if you have a struct, and the arrow operator if you have a pointer. Your language doesn't need to have the same semantics as C at all. It just needs some way of translation. Have you taken a programming languages course before? If you haven't, it's a good idea for what you're looking for as you'll come to realize you can create languages that seem leagues different, but that can be reduced to languages like C. 
You should have an easy time. Write a program that uses scanf() and printf() in the stdio library to read some variables. Write a program that uses malloc() in the stdlib library to allocate memory from the heap. Look at some of the functions in string library. Write a struct called Rectangle, a function called newRectangle that takes x, y, width, and height, allocates memory for a Rectangle struct, copies the values passed in to the new object and returns a pointer. Put your struct and constructor in its own source file and pretend it's a class. In C++ getting the area would look like this "myRectangle.getArea()" in C it looks like "getArea(myRectangle)".
What are some other toy languages? 
One other big reason for multiple processes -- your computer will be very bored without them. When a program is waiting for a user, or a disk, or the network, it has plenty of time to do other work. Even moreso now -- there are multiple cores on a given computer. We should give them something to do as well. 
i only glazed over this for a few seconds, but i'm guessing some type of stack failure. hopefully, this'll help:
C, C++, assembly, etc.
Nothing's jumping out at me, but it's hard to tell without an idea of what the structures are. I'm surprised to see image data accessed like that... is it an array of pointers, or a single flat array? I'd imagine you'd get a warning if it wasn't an array of pointers. I'm not familiar with p_rand... is it from a library, or part of your code? Unless it generates a negative number, I can't see it being a problem. It's also much easier to debug if you just paste text, rather than images.
I agree, p_rand was a separate function, but not the source of the error. I had my TAs in lab look over it and they couldn't see the problem.
I must be missing something. The two cases seem to have the exact same effect on my performed in reverse order. It seems that if you ran "Encrypt" twice that it would swap all the pixels the first find and then swap them back to the original positions the second time. "decrypt" appears to have the same effect just starting at a different point. What is the issue exactly?
Perhaps you could tell us more about how the image is being loaded, and the definitions of the structures header_t and img_t? Could you run a test on every loop to be sure that data[row] is not a null pointer?
It'll work if the array is declared after elements has been scanned in. 
Besides the point, your points are.
Sorry, I don't see any code.
It's widely deployed, has a huge amount of code, infrastructure and libraries built for it, it's easy and cheap to find people to work on it, and for the most part it just gets the job done.
So which multiprocessor systems without an MMU were you thinking about exactly?
This is great - but would you mind editing this to include a [custom type](https://docs.python.org/3/extending/newtypes_tutorial.html) ?
Oh I see, I totally missed that! Sorry for that.
Node \*\*initializeAdjacencyList(const char\* fileName, int vertexNumber ) { &amp;#x200B; Node \*\*adjacencyList; adjacencyList = (Node\*\*)malloc(sizeof(Node\*) \* vertexNumber); &amp;#x200B; int\* countArray = getNumberOfAdjacent(fileName, vertexNumber); &amp;#x200B; int i = 0; for (i=0; i&lt;vertexNumber; i++) { adjacencyList\[i\] = (Node\*)malloc(countArray\[i\] \* sizeof(Node)); } &amp;#x200B; pushNode(&amp;adjacencyList\[0\], 1); pushNode(&amp;adjacencyList\[0\], 2); return adjacencyList; } &amp;#x200B;
Also note that the musl code still doesn't work correctly :if the child is killed by a signal before it can execute, no error code is generated even though execution failed. 
Your instinct is good. If you care how things work, like any engineer should, Java is awful. There are better VM languages. LLVM for example. Java is where all the mistakes were made. Java could be better, GCJ is the best I've seen but it's not popular or compatible enough. I disliked Java and then I hate to boot strap it for a new platform. It's such a mess. Plus, Java and C# programmers have often shocked me how much they don't know about how things work. Even ones who did CS! C on the other hand delivers a lot of raw power in very little. Programmers who list it as their favourite language have always been good.
Seems a bit rusty. Traits, tuples, rust enums, etc. Like the middle ground between rust and C.
There are no unoccupied spaces in a string. By definition, a C string is a sequence of characters starting at some address, terminated by a nul. Did you mean buffer or array perhaps?
Wow, thanks so much for the detailed info!
&gt; My point is that Java is actually a pretty awful language Java the language is indeed pretty boring and straightforward, which is a bonus in the industry. In my mind, Java is the C of JVM languages, whereas Scala is the C++ of JVM languages :) &gt; and its so god damn slow. JVM startup time is mostly to blame here, but once HotSpot does its job, for the majority of applications, Java is more than fast enough. One source of Java's inefficiency are needless indirections. I predict Project Valhalla ("value types") will be very beneficial in this area. &gt; Can anyone tell me a reason why Java is NOT a terrible language? Because you don't have to worry about undefined behaviour in Java. For example, if you access an array with ten elements at index 10, you predictably get an `ArrayIndexOutOfBoundsException`. Whereas in C, *anything* can happen. Also, truly separate compilation is just so much better than header files.
Legit question, however your manners scream "I am a Troll". &gt; a bunch of degenerate fucking sheep &gt; &gt; While I, the lone wolf, the sheep dog confidently said C! Hmm. &amp;#x200B; &gt; education system that is completely fucking detached from reality. Java is one of the easier languages to learn. Also, there are many job openings for Java programmers. Look for no other reason. I, myself, also refuse to use Java for any reason.
You can also use a single dimensional array. Create a dynamic array with size of \[sum of all elements in row lengths array\] Create a lookup table to get first index for each row.(This step is optional, but it will speed up access time)
&gt; Why is that in the below code even after freeing the memory check-&gt;ar[2] prints 6,while check-&gt;a is 0. The results are undefined the moment you use `check` in that first `printf` statement. The compiler is allowed to produce code that produces behaviour that makes no sense.
Is the undefined behaviour only in case of FAM as in case of having a int \*ptr inside struct it gave the expected result. So even if this is undefined behaviour shouldn't the array values change too or print some garbage? 
`free(check)` means the memory is available for more allocations in the future, *typically* the memory is not zero'd when free'd, and if you access it after, it will *typically* retain its value until it's overridden by some other part of your program that got allocated the same memory later on. Access after free is undefined behavior though, for the compiler, once you access check, the compiler is free to do anything at all, and all hell may break loose, touching free'd memory is *bad* and can result in very strange bugs, don't do it.
&gt; Is the undefined behaviour only in case of FAM No. The use of the freed pointer is itself undefined behaviour.
Thanks i guess i will keep in mind from now of not accessing objects after freeing them.
But if i do check=NULL without actually freeing the memory i guess the errors would still be there.
You would get "read access violation" in both cases. In the latter case, you would also have a memory leak, if you did not free the allocated memory.
Thanks for the advice will keep that in mind. 
If you want to know the exact workings under the hood, you'd have to look at the gcc source code or ask around in the gcc community, there are probably good reasons why in some cases it's zeroes and in others it is not. Is the observed behaviour the same when you compile with optimization flags? (-O3) I would expect all memory to remain unchanged with the highest optimization level, but again, none of what happens to memory after free is defined by the C standard, so the compiler can do whatever it deems best.
&gt; You would get "read access violation" in both cases. To be _utterly_ pedantic, this isn't guaranteed. The C standard is completely silent on the semantics of the `-&gt;` operator when the first operand is not a pointer to a structure or union object. It would however be very strange for an implementation to treat `check-&gt;a` any differently from `(*check).a`. The standard does say that unary `*` yields undefined behaviour on a null pointer. Of course, being undefined, that doesn't mean that it will necessarily generate a "read access violation". But yes, I am just being pedantic here. You'll only be able to dereference null pointers in more esoteric situations: embedded systems, ancient operating systems (e.g. DOS), and the like. (For a time, though, some software [needed the ability to do it](https://wiki.debian.org/mmap_min_addr).)
With the optimazation flag -O3 both the values are 0 now.
This is like the argument in C circles about horrible compile times. So what? It isn't about startup time it is about runtime performance. Java is mostly used in the enterprise where it is the basis of many long running applications and services. The model isn't to start on demand, so 2-3 seconds of startup time is washed out by having the ability to have a long running, stable application. However, if start/stop of Java code is something you want to do there were ways of doing just that. You simple startup a server process running in the background then have it dynamically load and execute additional code as desired.
Huh, maybe the compiler sees that you don't read from check after writing to it and as such the write has no effect, and it's just eliminated completely. Can't say for sure though. This is why I said that this is more of a gcc question than a c question, interesting nonetheless.
Most heap algorithms will overwrite previous "user data" when free is called -- remember a heap chunk is meta data plus area for your user data. The value is usually the forward/backward pointers and maybe even the size of the top chunk. I'm guessing because it's memory aligned the lower byte will always be set to 0. &amp;#x200B; Chunks are also sorted by size or coalesced into to top chunk so the memory from the OS standpoint is still allocated and usable, but since nothing has over written the memory check-&gt;ar\[2\] is not erased. This is C, you do everything manually.
I do.Thank you!
That's sort of an inherent race condition though. Is there much of a difference between being killed one nanosecond before exec() vs. one nanosecond after? In either case the wait status will tell you that it didn't exit normally.
What makes Lua a "toy language"?
What's your definition of a toy language?
There is a lot of good advice on this thread already - I'll try not to repeat any advice I've already seen given... The length of say, `Book.author`, should not be hard coded as an integer literal. Even if you decided to use dynamic memory allocation (and you probably should) the maximum Book.author length should be a named integer constant so that if you need to change it, you change it in one place. Right now you would have to change the code in two places. The way you read user input with `scanf()` and `fgets()` is not particularly robust. Try running the program but entering a subject longer than 20 characters. Run it again but enter non-numeric characters in for the book number. What happens? From the `fgets()` man page: "If a newline is read, it is stored into the buffer." and "reads in at most one less than size characters from stream". This means two things - the newline character when a user presses the return key will be embedded in your string, which you almost certainly don't want. And this also means that input longer than the buffer will be silently truncated. From the `scanf()` man page: "If processing of a directive fails, no further input is read, and scanf()" returns". You are not handling this potential error return. I bet if your program doesn't segfault it will print junk characters. I suggest writing your own function to read user input. Still put upper limits on how many characters can be read (we don't want to fill up memory!) but warn the user when they reach the upper limit you set. And for `Book.book_id`, don't store the user input directly in your struct. Instead, just read the user input as character data first. Then, try to convert the string to an integer and handle any errors that might occur from non-numeric characters appearing in the user input.
Thank you for what you wrote, this is fantatsic help!
Uberspecific but I found lots of cool information by reading the [ARM v7-M Architecture Reference Manual](https://static.docs.arm.com/ddi0403/eb/DDI0403E_B_armv7m_arm.pdf). May be useful if you are working with Cortex-M microcontrollers or ARM in general. 
\`is\_empty\` is a function. \`if(is\_empty)\` checks if the address of is\_empty is NULL, which is never is since it is a defined function. What you want is probably \`if(is\_empty())\`, which means you call the function and check the return value of it
Thank You. That was stupid in my part. I didn't see that. Anyways what about the warnings - 67:1: warning: control may reach end of non-void function [-Wreturn-type] } &amp;#x200B;
In the peek function, if it is not empty it returns a specific value, but if it is empty it returns what? The control (program flow) can reache the end of a non-void (returns something) function without hitting an explicit return. 
What would be appropriate return value or any print statement?
That's up to you to decide
As /u/orangeoliviero said, that's kind of your call. You could define a special value that when returned means "you tried to peek on an empty queue" and handle that at the caller, the problem with that is that the caller needs to know that the special value is not a valid return, and all queue users need to know that they can't store that value... not a great idea here (though sometimes it works, for instance if you're storing pointers in the queue, it might be reasonable to just return `NULL`) Another option would be to make it part of the `peek` contract that callers NEVER call `peek` when the queue might be empty. You would have all callers to `peek` check `is_empty` before calling `peek` and if it is empty they print a relevant error message rather than trying to access the queue. You could further enforce this contract at debug time by `assert`-ing that the queue is non-empty in the `peek` function. Yet another option would be to redefine the peek interface to return whether the queue access was valid or not, and then return the peek-ed value as an argument. i.e., int peek(int *val) { if (!is_empty()) *val = queue[front]; return is_empty(); } These are just some options. Like we said, it's kind of up to you and the spec that you're developing against. 
I tried to implement block splitting so it only uses required space out of total available space of a free block. I think there will be some better ways of achieving than what i wrote.
 else if(is_empty) Presumably the error is on this line? You need to call the function here.
Because I will get biased views... 
Advent of Code was lots of fun to do in C I agree with other person that making a game with ncurses can be really rewarding bc it will run anywhere I started writing a graphics raytracer. There's the business card ray tracer and the book Ray Tracing in One Weekend
The difference is that if the child is killed before `exec()`, this implementation of `posix_spawn` thinks execution was successful whereas the binary was not even touched. This is a problem if you rely on this mechanism to find out if a certain binary can be executed.
If you swap out the address space ten times per second, it's still sufficiently fast if you only have a few kilobytes of memory (as those machines had).
Will look into mmap and locking.
True, is there any way to avoid that race though?
Can you elaborate a little or point me to resources? &amp;#x200B;
yeah they cant... so if its 1, also strings dont match, then it should preform the else statement which is "nothing found" but it doesnt and crashes, how to fix it
Question: How would I learn more about 'such' things? i.e. low level memory management?
If the strstr does not find the substring then it return NULL pointer. You do " if(strncmp(zeiger,search,strlen(search)) == 0)" with zeiger as a NULL pointer this is why it crash.
yes I know, but how do I fix that? I tried to do: `char * zeiger;` `char * zeiger2=0;` `zeiger= strstr(comp,search);` &amp;#x200B; `if(zeiger==NULL)` `{` `zeiger=zeiger2;` `printf("zeiger null\n");` &amp;#x200B; `}` &amp;#x200B; but it doesnt work either..
Use else ? `if(zeiger==NULL)` `printf("Nothing found\n");` `else` `{` `// do thing if the substing is found` `}`
Not really as far as I know. Especially not in a way that avoids allocating resources. The most elegant way in my opinion would be to add a flag to `siginfo_t` that tells you if a process died before or after it executed a command. This way, you wouldn't get an error at `posix_spawn` time, but rather at `waitid` time, but that's good enough for general use cases.
Do not spam.
VirtualAlloc could replace mmap for a windows alternative?
Modern malloc partially stores the heap structure in thread local storage so that frequent use of malloc and free does not require locks
\#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; &amp;#x200B; typedef struct Node { int data; struct Node \*next; } Node; &amp;#x200B; int getNumberOfVertex(const char\* fileName); Node \*\*initializeAdjacencyList(const char\* fileName, int vertexNumber ) ; void pushNode(struct Node\*\* headNode, int newData) ; int \*getNumberOfAdjacent(const char\* fileName, int vertexNumber) ; &amp;#x200B; &amp;#x200B; int main( void ) { &amp;#x200B; const char\* fileName = "myEdgeList.txt"; &amp;#x200B; int vertexNumber = getNumberOfVertex(fileName); &amp;#x200B; int i = 0; for (i=0; i&lt;vertexNumber; i++) { printf("%d ", getNumberOfAdjacent(fileName, vertexNumber)\[i\]); } printf("\\n"); printf("\\n"); &amp;#x200B; initializeAdjacencyList(fileName, vertexNumber); &amp;#x200B; &amp;#x200B; return 0; } &amp;#x200B; int getNumberOfVertex(const char\* fileName) { int maxValue = 0; &amp;#x200B; FILE\* file = fopen (fileName, "r"); &amp;#x200B; int vertex; fscanf (file, "%d", &amp;vertex); if (vertex &gt; maxValue) { maxValue = vertex; } while (!feof (file)) { fscanf (file, "%d", &amp;vertex); if (vertex &gt; maxValue) { maxValue = vertex; } } &amp;#x200B; fclose (file); return maxValue; } &amp;#x200B; int \*getNumberOfAdjacent(const char\* fileName, int vertexNumber) { int\* countArray = (int\*)malloc(vertexNumber \* sizeof(int)); &amp;#x200B; int i = 0; for (i=0; i&lt;vertexNumber; i++) { countArray\[i\] = 0; } &amp;#x200B; FILE\* file = fopen (fileName, "r"); &amp;#x200B; int vertex1, vertex2; fscanf(file, "%d %d", &amp;vertex1, &amp;vertex2); //printf("%d %d\\n", vertex1, vertex2); countArray\[vertex1-1\]++; countArray\[vertex2-1\]++; &amp;#x200B; while (!feof (file)) { &amp;#x200B; fscanf(file, "%d %d", &amp;vertex1, &amp;vertex2); //printf("%d %d\\n", vertex1, vertex2); countArray\[vertex1-1\]++; countArray\[vertex2-1\]++; &amp;#x200B; } &amp;#x200B; fclose (file); &amp;#x200B; return countArray; &amp;#x200B; } &amp;#x200B; void pushNode(struct Node\*\* headNode, int newData) { &amp;#x200B; /\* 1. allocate node \*/ struct Node\* myNode = (struct Node\*) malloc(sizeof(struct Node)); &amp;#x200B; /\* 2. put in the data \*/ myNode-&gt;data = newData; &amp;#x200B; /\* 3. Make next of new node as head \*/ myNode-&gt;next = \*headNode; &amp;#x200B; /\* 4. move the head to point to the new node \*/ \*headNode = myNode; } &amp;#x200B; Node \*\*initializeAdjacencyList(const char\* fileName, int vertexNumber ) { &amp;#x200B; Node \*\*adjacencyList; adjacencyList = (Node\*\*)malloc(sizeof(Node\*) \* vertexNumber); &amp;#x200B; int\* countArray = getNumberOfAdjacent(fileName, vertexNumber); &amp;#x200B; int i = 0; for (i=0; i&lt;vertexNumber; i++) { adjacencyList\[i\] = (Node\*)malloc(countArray\[i\] \* sizeof(Node)); } &amp;#x200B; pushNode(&amp;adjacencyList\[0\], 1); pushNode(&amp;adjacencyList\[0\], 2); &amp;#x200B; printf("%d", adjacencyList\[0\]-&gt;data); adjacencyList\[0\]++; printf("%d", adjacencyList\[0\]-&gt;data); &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; return adjacencyList; }
the links provided by /u/skeeto in their comment are pretty good
it's easy to find each of those things. I mean no offense: try googling for each of them: "advent of code", "game with ncurses", "business card ray tracer", "Ray Tracing in One Weekend" "make images in C" (learning how to find C-only stuff with google is a worthwhile skill, you usually have to add a "-C++" to the search bc there is so much more C++ stuff out there.) and if those resources aren't right for you, there are enough other resources out there so I'm confident you'll find something appropriate for your interest and current expertise.
If you have a specific interest or ability you'd like to develop I could maybe help you find something specific. 
I've finally made the multi-threading. I've keep it simple, i've made horizontal slice of my screen. Each thread compute 4 slices (for load balancing) and then apply the color to my screen buffer from all the thread array. It's working pretty well and since each thread have his data i dont need any mutex. Tho i have one last question : I get an error when i add `-pthread` to my makefile but everything is working ?!? `clang: error: argument unused during compilation: '-pthread' [-Werror,-Wunused-command-line-argument]`
Ah. The ancient rite of passage.
I'm doing a state machine for a game I want to make for older platforms based on a board game from my youth. I'm going to get it working within objective-c and make a simple gui then make ports for macos 6 and maybe other stuff (general magic, amiga, iigs). I'm trying to keep to K&amp;R 2nd addition as 1989 is about my target generally. I actually am learning quite a bit. It should be fully portable with just 2 files (.h, .c). It's been super gratifying.
Suppose you are allocating a million short strings. Your malloc will call sbrk a million times. This can be slow. If you use mmap, which is page-aligned on Linux, it will be more problematic. A better approach is to allocate long blocks and then split these long ones. When you free, you merge adjacent free blocks back into long blocks. K&amp;R implements a better malloc. I have [a version](https://github.com/attractivechaos/klib/blob/master/kalloc.c) adapted from that. Another somewhat different technique is [buddy allocation](https://en.wikipedia.org/wiki/Buddy_memory_allocation). [Here](https://github.com/cloudwu/buddy) is a C implementation. Note that these two examples don't attempt to implement malloc. They are more for flexible buffers and thread-local storage. I have seen quite a few other simple allocator, too.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [attractivechaos/klib/.../**kalloc.c** (master ‚Üí 16d3b11)](https://github.com/attractivechaos/klib/blob/16d3b1189ff794e7f339ef8de995329613f00d18/kalloc.c) ---- 
Glad you got threading figuring out. &gt; I get an error when i add `-pthread` to my makefile but everything is working ?!? Looks like this is just a bug/incompatibility in old versions of Clang. GCC says to use `-pthread` for both compilation and linking ("You should use this option consistently for both compilation and linking."), but Clang produces that error if you use it during linking. I don't know when this was fixed in Clang, but it's not an issue as of Clang 3.8. 
it's seem that is just a warning that pop as an error because i'm using `-Werror` and OSX. I want to add you in my credits, can you PM your git or name you want to see on the credit ? (I can also put skeeto XD)
Yerr that was a bit muddled. Bad night it early morning. I was thinking of the Java byte coding vs LLVM.
My go to project for a new language is to make an IRC server and client
https://www.techopedia.com/definition/22609/toy-language Lua is a full featured (although batteries not included) language that is very popular in embedding and game dev, but also powers Openresty web server which is being used in a ton of top sites and even Cloudfare. I'd say it's well beyond being a "toy language",
If you are printing to the command line, you can `printf("something\r");` and this will reset the cursor at the start of the line, so you can overwrite it. That way you can make a progress bar by, say, keeping track of a percentage and each time it goes up, you print the new percentage, maybe with an ASCII progress bar. Something like [===============&gt; ] [55%] The secret is to print a `'\r'` instead of `'\n'`. This is a low effort solution for the command-line.
But you already have that issue with arrays: int a[10]; int *b = a; a[0] = 1; b[1] = 2; a[3] = 3; b[4] = 4; printf("%zu\n",sizeof(a)); printf("%zu\n",sizeof(b)); The array syntax can be used for both arrays and pointers. 
Nice picture dude. Good luck
hmm could you explain more why you feel lost if you start from scratch? and why tutorials are too much? Could you explain more about what you seek?
"cannot find -ljansson" means you need to put it's parent directory on the library search path, and that's it. The other error is caused because it can't find the library. I'd help you further, but I don't know how to do that in Atmel Studio nor Code::Blocks, but I know how to make it happen with a Makefile on the command line. The good news is that it's a common problem when adding libraries to a project. And it's something you should be able to figure out from the IDE docs. 
Note that you cannot bump threads on reddit. You might get better answers if you gave some more details about your problem.
And that already causes a lot of confusion.
For an embedded application, and such a small library as jansson, it might be simpler to just import the source code into your project. You only need the contents of [src](https://github.com/akheron/jansson/tree/master/src) and the two .h files generated by CMake.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [akheron/jansson/.../**src** (master ‚Üí e65a490)](https://github.com/akheron/jansson/tree/e65a490c4476eb952e5a17509341d788c0880cb2/src) ---- 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/akheron/jansson/tree/master/src) - Previous text "src" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [akheron/jansson/.../**src** (master ‚Üí e65a490)](https://github.com/akheron/jansson/tree/e65a490c4476eb952e5a17509341d788c0880cb2/src) ---- 
AFAIK AudioToolbox was deprecated as part of Carbon.
Please clarify the question if you want an answer. Some pseudocode could help.
The temporary variable should be the same type as your number type. As far as using the array correctly I'm not sure what you mean.
Write a 2 player tictactoe game. Have it figure out who won. Then to step up quite a bit, make the computer play.
If you don't know what type you are going to store in your array at compile time, then you will need to store some data describing the array data at run time. Store at least the length of the array and the size of the elements. You will then need to make functions that enforce updating this meta data while you are using it. Your element swap function can use the element size information to allocate a temporary variable which is appropriately sized for your element type and use memcpy to move the data around.
yes, sizeof enum types is implementation defined but shouldn't it always be known at compile time?
did you point the linker to additional library directories? also the compiler needs to know where the header files are located too. need to add \lib\ to that or so probably. I would look at adding CMAKE into your project, and would be a build system that is worth learning.
You have two ways of stopping loops, either by knowing before hand how many times it needs to iterate or provide it with the ability to break under a certain condition. &amp;#x200B; I'd personally use an infinite while loop and let the user specify with some flag e.g. 'fin' that they are finished, and then calculate the average. I'd also set some upper bound otherwise you'll face an overflow condition.
&gt; I asked my professor and she said "You need to change the maximum counter to be only the number of grades the user needs instead of 100." I asked her what she meant, but still haven't heard back. In your code, you prompt the user for the number of grades that they are going to enter, but never take the user input and instead just loop 100 times (the while loop checks that 1&lt;=counter&lt;=100). Instead, you should prompt the user for the number of grades that they are going to enter and use that as part of the condition for the while (or for) loop. e.g., int i; int grade_cnt; printf("Enter number of grades: "); scanf("%d", &amp;grade_cnt); for (i = 0; i &lt; grade_cnt; ++i) { // Read a grade and update the avg. } 
Your while loop and if conditions are nonsensical. I think you've mistaken the '||' for *logical and* when it means *logical or*. In the way you've written it if `counter &gt;= 1`evaluates true then the loop will run. The other part (`counter &lt;= 100`) will never be evaluated. This is called short-circuit evaluation. You prompt "Enter the number of grades" only once, but then proceed to repeat the scanf to read the value. Go back and consider what part of the task needs to be repeated and what condition needs to be met for it to stop repeating. As it stands your loop condition doesn't meet the requirements you laid out, and doesn't include some things that need to be repeated. 
\- Brainfuck interpretor \- hex dump \- sodoku solver \- Project Euler solutions \- mp3 player \- Graphics
im sorry i mean like int temp; ptr = (int*) malloc(n * sizeof(int)); temp = ptr + 1; ptr + 1 = ptr + 2; ptr + 2 = temp; where n is input given by the user.... and i tried to swap like that the array was filled with integers
So yes, you‚Äôd use `int`, but you need to dereference the pointer. You can do it explicitly as `*(ptr + i)`, but that‚Äôs equivalent to `ptr[i]` so most people go with the latter: int temp; assert(n &lt;= SIZE_MAX / sizeof(int)); ptr = (int *)malloc(n * sizeof(int)); temp = ptr[1]; ptr[1] = ptr[2]; ptr[2] = temp;
Ah I see. Then you want the png standard and then you'll just write a program to read it all in and parse it. Also, a lot of programming is learning from existing code. You'll still learn a lot from reading the most common png libraries. It's often harder to learn someone else's code than writing your own, but i feel it's a more important skill. Most real world work is trying to extend or fix existing code and I still learn tons and tons from reading existing code. 
Also you can often get excellent tips about implementing your own png library if you contact the authors of existing libraries. 
Thank you for your answer. Yeah, it's the part where I have to write the program where I'm stuck, hahaha! Yeah, I understand. I just wanted to do one completely from scratch so then when I go on to do the same for a different file format, I will understand more of how they are generally read and rendered/processed. But yeah, I did read a bit about libpng and that had some great information. 
That actually is a great tip, haven't thought about that. Thank you!
I am curious. I see more posts about people writing malloc than I would expect to see. Is this a thing that most c programmers do? Is it a performance thing?
Set counter to a user entered number of grades. While counter is greater than 0.{. Counter--; add a number to total; }
Leading dimension is when you work with submatrices. For example, if you have a matrix A with N=4 inside a matrix B with N=6, then you have to skip 6 elements every time you jump from a row to the next, instead of 4. Here leading dimension would be 6 for both A and B. float a[6*6]; struct matrix b = { .ptr = a, .n = 6, .ldim = 6 }; struct matrix a { .data = a+2, .n = 4, ldim = 6 };
i wrote a program which can reduce and increase the file size of image by altering its pixels
Don't cast mallocs, this isn't C++ :-)
This post is off topic because it is about Java, not about C. This subreddit is for posts about C, not for trying to reach an audience of C programmers. Please post elsewhere.
Take as much help as you can get. Though when you solve a problem make sure you understand _why_ that was the solution. Especially if someone helped you. Figure out what you were getting wrong before, why it was wrong, and why the solution is right.
I was sure it was another sub when I read this title. I have nothing to contribute in this discussion but it also bothers me. 
Yeah this is pretty annoying. There is no good reason why things are this way, and no one has agreed to go back and fix this -- and if they did it would break things. Just a reminder that we should try to make (preferably good) decisions early on and be as consistent as possible with them. 
Personally, the way I see it is `length` is for things like strings which are contiguous, hence `strlen`, and `size` is for things that are in a collection.
Size became a problem with "sizeof". In that case, you are asking, "How much memory is being used due to this variable's declaration." Looking back, it might have been better called, "memuse" or similar. &amp;#x200B; When 'strings of characters' came to mind, "How long is that string of characters" is a different question than "how much memory is being used by that string of characters." This is really painful when people do stupid trickery like: &amp;#x200B; enum StateType { kEx = 0; kOh = 1; } state; char TicTac[6] = "Ex\0Oh"; puts(TicTac[state*3]); &amp;#x200B; So in this case, the "size" of TicTac is 6. The "length" of TicTac doesn't have as much sense, due to it being two strings stuck together. The "Length" of "TicTac\[0\]" is 2, while the length of "TacTac\[1\]" is also 2. &amp;#x200B;
\&gt; Both strlen and sizeof have been around for decades, so why do people not follow this "convention"? That's just the way it is, but there are more annoying cases of people not following convention. Initialization for example.. some people use direct attribute initialization (or C99 designated initializers), others always create an init function (i.e. constructor) for every struct, others use an inconsistent mixture of both. [Could be much worse though](https://i.imgur.com/3wlxtI0.gifv). 
So would that make it be from 1-100?
Not sure if it makes a difference, but I had &amp;&amp; and it didn't work. 
Pretty sure people considered Python a toy language back then so, definitely agree with your point.
Oh. Didn't read down there before my python comment.
I tend to use them as: * size is the amount of memory consumed by the entire data structure, e.g. `char a[128]` * length is the amount of the data stricture in use, or of interest, e.g. `strlen (a)` 
I've modified your code for discussion purposes (this is not a solution). Let's first consider the tasks that need to be performed in order: 1. get the number of grades 2. get the grades and sum them, ignoring invalid grades 3. calculate the average of the grades 4. print the average unsigned int counter = 1; int grade; int total = 0; int average; // get the number of grades printf("%s", "Enter number of grades: "); scanf("%d", &amp;counter); // get the grades and sum them, ignoring invalid grades while (counter &gt;=1 || counter &lt;=100) { total = total + grade; counter = counter + 1; if (counter &gt;=1 || counter &lt;=100) { printf("%s", "Enter grade: "); scanf("%d", &amp;grade); total = total + grade; counter++; } else{ printf("%s", "Please enter a value between 1 and 100!"); } } // calculate the average of the grades average = total / counter; // print the average printf("Class average is: %d\n", average); I think steps 1, 3, and 4 are pretty clear in this example. Let's break down step 2 more. Each time we get a grade we need to do these things: 1. Prompt user and get input 2. Check if the grade is valid 3. add the grade to our sum OR print an error message 4. repeat until we have enough valid grades The while loop has it's condition at the start so we are going to consider step 4 first. We know that we need the loop to happen `counter` times. I'll give two more or less equivalent examples. Let's start with an iterator variable at 0 and loop `counter` times. It's common to use the short name `i` for iterator variables since they don't actually represent a value associated with an idea or object. int i = 0; while (i &lt; counter) { // prompt user, get input // check if valid // sum grade OR error i++; } This certainly loops `counter` times, but doesn't handle the error correctly (I'll leave it to you since I think you almost had it right in your original code.) Another way to handle it without a iterator variable is to decrement counter each time we have a successful grade input, and stop looping when it reaches 0. while (counter &gt; 0) { // prompt user, get input // check if valid // sum grade OR error counter--; } This still loops counter times (you need to account for errors). It's worth noting this modifies `counter` so if you needed the original value of counter later in the program (say for calculating the average) you should copy it to another variable and use that for the calculation. I'm just going to discuss the check condition. As it stands what you have written is `counter &gt;= 1 || counter &lt;=100`. In english we could say this evaluates true when 'counter is greater than or equal to 1' OR 'counter is less than or equal to 100'. The problem is one of these conditions is true for every possible value of `counter`. To ensure both conditions are true you want logical and (`&amp;&amp;`) instead. Just as a tip you may also want to consider if 0 is a valid grade.
You didn't begin at PHD? Loser
Might as well add "Make a C compiler in assembly".
Right off the bat you argument to scanf is incorrect. You also haven't allocated any memory for you character array. You can do this, although it's dangerous: int num = 0; scanf("%d", &amp;num);
great project
You normally use C or C++ when there is something to be gained by managing your own memory. It helps you write more efficient code because you understand what is going on behind the scenes. You need to understand how it works to write your own compiler or port one to a new platform. There's also probably some rare situation where writing something that works a little like malloc takes less code and performs better than using malloc.
Okay, so basically I want an AND operator. Just curious, is that what's most likely causing the issue?
You may be right. Thanks for the tip. I'll do that for now, but I definitely still want to get the library linked in properly, because a) it's a useful skill to learn and b) this will annoy me forever if I don't sort it out.
So you use your own standard to name your macros in order to avoid name collisions? Like using your name or the date of creation of the file?
&gt; How come this wasn‚Äôt an error? Tell me about it. There's no good answer for that. Do yourself a favour and compile with `-Werror` when you're still getting the hang of things.
https://stackoverflow.com/questions/25004382/excess-elements-in-scalar-initializer-code-compiles-with-gcc-but-not-g Closest I could find to an explanation. Seems like it boils down to the standard doesn't require it.
Can you explain in more detail what you mean? What problem are you trying to solve?
What does it mean to "run to a specific memory"?
You want to fill a specified memory space with the data "Hello World" ? That's actually a surprisingly complex answer. It depends.
No problem!
I just wanted to explore this is possible or not. Out of curiosity.
&gt;"monkey coding" I'm using this from now on. &amp;#x200B; In terms of preventing buffer overflow, a good function to use is fgets(). It would, in this case, look like: fgets(input, 100, stdin), where input is the char pointer with 100 bytes allocated, 100 is the maximum number of bytes that can will be stored in input (including null terminating character), and stdin is the standard input handle (keyboard). This can also be replaced by a FILE\* variable when doing file I/O, but it's not required for this purpose. &amp;#x200B; So, OP, the important difference between scanf() and fgets() in this context is that fgets() will prevent you from reading too many characters into a finite buffer. This makes it the safe option when reading variable length strings from any input, be it keyboard or file. &amp;#x200B; On your use of pointers/arrays which no one directly pointed out: When you declare a variable, say char \*a\[\], this isn't declaring a single string of characters a, but a pointer to a pointer to a character. It's semantically equivalent to char \*\*a and char a\[\]\[\], ie a multidimensional array. What you want for a single string as a simple one dimensional array in the form char \*a, or char a\[\]. In this case, I'd say it's safer and easier to go with a static array in the form: char a\[100\], or char a\[MAX\_LENGTH\] if the maximum string size is defined as a constant. &amp;#x200B; As was pointed out, there is no actual free memory to which the pointer to character points when using a non-static string. For this purpose, you have to rely on memory de/allocation functions such as malloc() and free() for creating and giving memory to the pointers. These have their advantages, but they're trickier to use and prone to runtime errors if not used properly.
On your use of pointers/arrays which no one directly pointed out: When you declare a variable, say char \*a\[\], this isn't declaring a single string of characters a, but a pointer to a pointer to a character. It's semantically equivalent to char \*\*a and char a\[\]\[\], ie a multidimensional array. What you want for a single string is a simple one dimensional array in the form char \*a, or char a\[\]. In this case, I'd say it's safer and easier to go with a static array in the form: char a\[100\], or char a\[MAX\_LENGTH\] if the maximum string size is defined as a constant. ‚Äã As was pointed out in the case of using char \*a, there is no actual free memory to which the pointer to character points when using a non-static string. For this purpose, you have to rely on memory de/allocation functions such as malloc() and free() for creating and giving memory to the pointers. These have their advantages, but they're trickier to use and prone to runtime errors if not used properly.
It's possible, and you'd do exactly what /u/roge- mentioned (except with a real address). However, modern operating systems won't let you just write data wherever - you'll get a segfault (if you don't do something to handle it, your program will abort after printing a message like "Segmentation Fault (core dumped)") And, moreover, modern operating systems don't actually map all addresses to valid memory. You get a virtual address space, where you can pretend that you're the only program in the universe, and that you have one huge block of memory all to yourself - but most of it doesn't represent valid physical memory addresses. So even if it let you 'write' to random addresses in memory, you wouldn't actually affect any real memory most of the time 
yes that is my point. "length" is ambiguous, so when there is a parameter named "len" I can not assume it refers to size even though it seems reasonable and need to check the source/documentation. But if it is named "size" it is less ambiguous. 
Seems like a healthy attitude. I guess C and older languages suffer more from the lack of conventions as there was no/less unification. i.e.. IBM, MIT etc all ad their own conventions.
thanks! I was not familiar with the terms codeunits and codepoints. 
Again: I have not banned you. Nobody in this subreddit has banned you. It's the reddit admins that have banned you for some reason I don't know. The only way to solve this is to write them; it was likely a mistake.
It's unicode specific terminology. Basically a codepoint is a Unicode Scalar Value, aka the actual value that "characters" are assigned to. Unicode Transformation Formats (where UTF-X comes from) split that codepoint/Unicode Scalar Value into a number of "codeunits" where each code unit is the size of the UTF basic type, so short for UTF-16 unsigned char for UTF-8. Unicode's max value is defined to be 0x10FFFF, because back when Unicode first came out it was assumed that 65535 codepoints would be enough. it wasn't. So that's what "UCS-2" comes from, UTF-16 extended UCS-2 with Surrogate Pairs (basically a pair of shorts to hold codepoints above 65535 and there's a whole encoding system around it). The maximum value that can be encoded with UTF-16's Surrogate Pairs is 21 bits hence a max of 0x10FFFF. So UTF-8 was then invented after UTF-16, and it was limited to the same 0x10FFFF limit because it wouldn't make sense otherwise. so, UTF-8 is limited to 4 code units per codepoint, UTF-16 is limited to 2 codeunits per codepoint. tl;dr: Unicode is complicated, and most people that think they get it don't.
Do yourself a favor and compile with all warnings enabled (-Wall compiler flag), and when you get a segfault, if you're on linux, you can save yourself a lot of headaches by using valgrind, it will tell you what's causing the segfault more often than not (invalid read/write at address 0x... by function Y in function Z at line 5:11)
And even more fun -- if you know where your virtual memory was mapped physically, you can use the "row hammer" attack to try to force a change in memory in an adjacent physical row of memory. This has the potential to give you a privilege escalation. 
I always wonder how people figure out that that sort of thing works, because it's freaking awesome that someone did. 
Perhaps I misunderstand you, but I would argue they are not interchangeable. int myarray\[4\]; size\_t array\_length = sizeof(myarray) / sizeof(myarray\[0\]); size\_t array\_size = sizeof(myarray); &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
sizeof on arrays is tricky, but the operator in general isn't really about measuring length of some collection. It's for measuring bytes of memory used. Length is a semantic idea. It's a thing that means something to people. I can ask what the length of a linked list is. There's no useful idea of "size" of that list. You could add up the bytes used to store all the data and next pointers, but there isn't really a reason to do that. sizeof is just a mechanical thing. In the case of an array, you may get the same answer because array storage is defined that way, but the question of sizeof is not generally the same as the question of length, I would say.
Treat all warnings as errors until you fully understand them. Don't even bother running an executable if it doesn't compile cleanly.
You child needs to determine the value of the file descriptor. One way is for the parent to to use [dup2](http://man7.org/linux/man-pages/man2/dup.2.html) to make sure it's a specific value. Another way would be to pass the value of the file descriptor to the child either as a command line argument or in the environment. 
You just do it. Granted, you need some way to know the file descriptor number, but in the child you can just do normal file operations to operate on the file. If you want to use stdio instead of unbuffered IO, use `fdopen()` to create a `FILE` structure for the file.
Okay but let's say I can't modify the original program. The only program I could modify is the one run by execve. This is for a CTF so I have to write privileges on the original program. 
Thanks, I'll do that in the future and I figured out what was wrong, it just took a while.
You're right, they're somewhat ambiguous. I tend to think of length referring to the number of elements in a collection, and size as the actual number of bytes. For example: uint64_t arr[5] = {1, 2, 3, 4, 5}; Has a length of 5, but a size of 5 \* 8 = 40. This is not always correct and as some other posters have mentioned try and do your best to be consistent and choose an option which makes your intent more obvious. 
Just try random file descriptors until you read the data you want. I used a looped write in one CTF to send data to myself over a socket.
Yeah this, if it's a CTF then the smash and grab approach is easiest.
You could pass the file descriptor number to the child process as a command line argument. Better yet, use dup2 so that the input file is on fd 1 (stdin).
it's a CTF, the vulnerability is that execve leaves the file descriptors open. And i have to use that to read the flag. But i found using ls -l /proc/$$/fd that the flag fd is 3. And i try to read from it, but nothing is printed out. So i have no idea what to do 
if anyone likes CTFs and hacking challenges and wants to help me out, maybe we could talk in private or something and try to solve it together :)
I have no experience in CTFs but I'd love to try :D
"CTF" ‚Äî that's Capture The Flag? Some sort of security challenge? The /proc file system is Linux-specific, which is why I didn't bring it up before. If you have it, then you could do a quick ls of /proc/self/fd/ to see what file descriptors are open. That would limit the fds you need to try out. If reading fd 3 didn't return any data (did it return an error, or just EOF?) then it looks like the parent hasn't written anything to it. Are you sure it's meant to be read? Normally, you'd expect the parent to call pipe() to generate two fds, one for reading and one for writing. The parent will write to one, and the child would read from the other. But that means that there should be two fds there for the child to try out, assuming the parent didn't close one of them after the fork. At this point, we'd have to see the source code to the parent to figure out exactly what it's trying to do.
ok here is the source code, https://pastebin.com/3q9v8vgg the "admin/secret" is the flag, i can't read it. I can only modify the "admin/bin" file. Initially "admin/bin" is just empty and its up to us to write it
Attempt to read from file descriptors in a loop until you read the one handing the file you're trying to get. This reminds me of a CTF I did which involved sending stolen data back to yourself over the socket used to perform a shell command. Eventually I wrote back to the file descriptor for the socket habdling my connection.
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¬Ø\\\_(„ÉÑ)_/¬Ø`&amp;#32;or&amp;#32;`¬Ø\\\_(„ÉÑ)\_/¬Ø` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
actually if you notice the program unsets root privileges before the fork. I already solved it right now. Basically what you have to do is find the file descritor, which is 3, use lseek to set the offset at 0 and then read it :)
 return main(); This actually hurt my head a little, and I don't think it does what you think it does. Your main() function is being called again from the very beginning. Then it's taking whatever that function returns, and returning that value from your current context. You aren't returning "to main", you are returning the value main produces when ran.
well, it worked for every other statement! :p how can I replace it so it works the intended way?
guess I fixed it, I asked for input with scanf at beginning of main and then when it looped I guess the input was the same, I typed fflush(stdin) at beginning of main() and it works... for now
Okay, what you're doing is called recursion, and it kind of works... kind of. Sort of. You just have no way to get out of it (I'm guessing). &amp;#x200B; int main() { char c; scanf("%c", &amp;c); switch(c) { case 'E': printf("That's what I was thinking!\n"); return 0; default: printf("Nope. Nt what I was thinking.\n"); return main(); } } &amp;#x200B; So one of your cases needs to not call main().
ye I got exit case
Ya, moderator got mad...it was off topic I guess.... my bad
The printf interprets the u in %du literally and prints is. I would assume that the scanf is also interpreting the u in %du literally, and looking for in in the input string. When it doesn't find it, it gives up.
`du` is not a valid format specifier because `d` is already a conversion specifier. Thus, your `scanf` format string has a literal `u` character. The `scanf` stops after reading the int because it fails to find that literal `u` in the string, but it's already found the rest of the requested values so they get filed in. Meanwhile your `printf` is also printing that literal `u` because it has the same issue, hence why you get `1u` in your output.
Always check the return value of scanf() to help catch stuff like this... Also, what happens if you enter a string longer than 3 characters for foo or bar or baz? If using `%s` with scanf(), always give it a maximum length to prevent buffer overflow badness.
OK, so what this program does is read a secret from a file into a buffer, then fork and exec "admin/bin", wait for it to finish, and then dump the SHA1 of the buffer if the child returned a non-zero exit status. It neither sends nor receives any data from "admin/bin". How do you "win" this challenge? And what's the meaning of the exit status? At any rate, what your program needs to do is guess which fd the secret file was read from (we've already discussed this), call rewind() on that fd, and then read it yourself into your own buffer.
That's an option with `sscanf()` when you can find out the maximum possible length, but not with `fscanf()` or `scanf()`. With them, there is no safe max length (Just like with `gets()`, the function so bad it was removed from the standard). Read the documentation for a way to specify the maximum string length to use with `%s`.
What have you tried, and why do you think it didn't work?
Include string.h, use strlen and remember the string is terminated by \0. That should be all you need. Also it's easier to first make sure the reverse part works and you print it in the function before you get back to the return pointer part. 
If you're coming from other languages into C, you're probably being caught out by what a C string is. All C strings are are a sequence of bytes, and they must be terminated by a NULL character. Other languages hide this under abstractions, but C does not. The most likely cause of seg faults is probably a function reading off the end of a string because it didn't find a terminating NULL character. When the program tries to read inaccessible memory it will throw that error. The rough pseudocode of what you probably want to do is: - Copy the string from the user's input from the argv variable into some kind of char[] array. You could also use char*'s and malloc, if you understand pointers and memory mangement. - Create a function that takes in that char[] as a parameter. It's probably simplest if you modify that parameter in-place, rather than trying to return a new array, as returning a new array from a function does require a malloc'd memory area. So the return type of the function can be 'void'. - Inside that function, copy the input string into a new temporary char[] variable. That could be done by using a for loop iterating backwards over the string. - Copy the temporary variable into the parameter char[]. Look at the strcpy() function as probably the simplest way to do it.
Ok, so I think part of my issue must be compiler-related (I am just using the default gcc compiler on linux), because when I switched from using a for-loop for the reversing to a while loop that did essentially the same thing it went from outputting nothing/occasional random characters to outputting the correct reversed string, but only about 30% of the time, the rest of the time it just throws out nothing still. I thought I was just going insane.
If you're finding different behaviour from different compilers, whatever you are doing is causing Undefined Behaviour (UB). UB means that a compiler may do whatever it wants when it finds that code; anything from unexpected program behaviour to (theoretically) wiping the program's original source code. That one will probably never happen, of course. But what it does mean is that something in your code isn't correct by the standards. C does allow you to shoot yourself in the foot. You might want to try turning on more warnings on the compiler to see if it'll tell you what it thinks is wrong. My best guess from your description is that you're allocating a new variable inside the reverse() function, and attempting to return it directly to main(). That won't work, as the variable and its contents only exists for the lifetime of the function. When the function exits, all of the memory associated with the function is cleaned up. Some compilers may cause that memory to be overwritten, some may leave it alone. This is why I suggested it'd be easiest to end up modifying the input parameter in-place, rather than trying to create a new one.
I haven't even attempted to return anything to main() yet, which is why I'm so confused. At the moment I just have it printing the reversed string after the while loop to reverse completes.
I'll see if I can write your code that is breaking and then use that as a debugging point. Maybe you're doing: &amp;#x200B; char *ReverseString(char *string) { char reversed_string[100]; int length = strlen(string); int pos = 0; while(length) { reversed_string[pos++] = string[length--]; } return reversed_string; } int main(int argc, char *argv[]) { char input[100]; scanf("%s", input); printf("%s", ReverseString(input)); } There are a couple of bugs here, and they hope to handle all of your potential issues at once: \- In this case, I have forgotten to add the nul character to the end of the string after I reversed it. \- Worse, I am using memory on the stack to do my work, and returning a pointer to it -- this will go away when the function returns, leaving who-knows-what. \- I'm also doing everything with a max size of 100, but that's probably not an issue in this case. &amp;#x200B; Typically, you want to go ahead and do an "in-place" reversal, and write the string on-top of itself. Then you don't even have to move the nul character around. &amp;#x200B; &amp;#x200B;
Better stick to the for loop. You start with i = last index of your input string and then i--. For loops are in my opinion a lot easier to work with since you only deal with indices in a string.
You should share your code with us. It's very hard to work out what you mean from words alone. Check the style guide and then edit it into your original post is probably best :)
Thanks for the help, unfortunately the code you sent only returns null values because I don't believe that you can return character arrays through making char functions in C, along with that when attempting just to print the reversed string through the ReverseString() function, it just prints nothing no matter what. Although I'm fairly certain that at least 50% of those issues are related to issues that I am having with my compiler, not the code itself, which seems to be the source of all of my confusion to begin with.
Attempting to post very rough code, this could take a minute `#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; void reverse(char torev[100]){ char reved[100]; int iters = 1; while(iters&lt;strlen(torev)){ reved[strlen(torev)-iters] = torev[iters]; iters++; } reved[100] = '\0'; printf("%s",reved); return; } int main(){ char inital_text[100]; scanf("%s",inital_text); reverse(inital_text); }` 
Another gotcha if you're using functions, is that you can't return stuff from the stack (as it could be overwritten). Say you have the following: char* reverse(char* s) { char buf[256]; char* p = buf; int i = strlen(s); if (i &gt; 255) return NULL; buf[i] = '\0'; while (i--) *p++ = s[i]; return buf; } int main(int argc, char** argv) { if (argc &lt; 2) return 1; char* reversed = reverse(argv[1]); // Now `reversed` points to the stack, and if you call another function it will overwrite it with garbage printf(reversed); // &lt;~ undefined behaviour return 0; } The solution is to have the main function provide a buffer to reverse into, or declare `buf` outside of the function so it will go in your program's data/bss segment. Recent GCC versions will warn you against this (-Wreturn-local-addr).
`reved[100] = '\0'` accesses out of bounds. For an array of dimension `N` the valid indices are `0` through `n-1`. Your loop also seems to start from index `1` rather than `0`. And you want to put the `\0` at the end of the string, not at the end of the array. 
I fixed [100] to be at the end of the part of the array that I am actually using, but I'm confused as to what you mean by putting at the end of the string and not the array. I thought strings in C are just arrays of characters?
&gt;scanf("%s", &amp;initial_text); You need to give scanf the pointer to the variable. A simple printf after scanf, can ensure that the string is read correctly. And further your iters should start at 0, because the index of the first character is at index 0 and not at index 1. Also when you are intitalizing array, you should zero-initialize them, to make sure they are not having some random stuff from the memory in them. &gt;char reved[100] = {0}; It might not always be needed, but its a good habit to properly initialize variables.
Shit. Didn't realize that iters was set to 1 still, it was at 0 originally but I changed it to 1 to see what effect it would have on the already convoluted output. Also thanks for the {0} thing, didn't know you could even do that.
Did you add the &amp; to the scanf? How does your code look now? Also you need to "return reved;"
Not even bothering with returning anything to main() at the moment, just trying to get reverse() to work properly first. Here is the updated code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; void reverse(char torev[100]){ char reved[100] = {0}; int iters = 0; while(iters&lt;strlen(torev)){ reved[strlen(torev)-iters] = torev[iters]; iters++; } reved[iters] = '\0'; printf("%s",reved); return; } int main(){ char inital_text[100]={0}; scanf("%s",&amp;inital_text); reverse(inital_text); } 
"digit = num" &amp;#x200B; Instead, you want "digit = j % 10;" &amp;#x200B;
Arrays are a block of memory. Strings can exist inside arrays. A string is a sequence of characters followed by a null terminator. The string might not occupy all of the array.
No, it doesn't work, cause it prints first value of j
Okay, one more issue that I spot, you are doing reved[strlen(torev) - iters] = torev[iters]; which is the right principle, but, if your string is for example 4 characters long, that means strlen returns 4 and on the initial loop the index would start at 4 - 0 = 4, which should be 3, so you need to substract 1 so it starts at 3. reved[strlen(torev) - iters - 1] = torev[iters]; after that it should print out the correct reversed input.
Holy shit thank you. That was what finally did it, this has been bothering me for days at this point.
Actually, no need for a loop: Digit =( num / (pow(10, position)) % 10; You can do the pow in a loop if that's easier. 
 It shows: error: invalid operands to binary % (have 'double' and 'int') &amp;#x200B;
Just add on to i and invert the for check. E.g.: for(i=0;i&lt;10;i++) { if(!((i+1)&lt;10)) { printf("%d ",i); } }
It will be 10 at the end, just do --i before printing.
Thank you guys you helped me a lot!!! 
I think you could store i in another variable inside the loop and then print that variable afterward. I don‚Äôt know what you are using it for, but it seems strange to use a loop to just print the last number of some sequence.
If you want to do it all inside the loop, check if the next number is 10. If it is, print it. for (i = 0; i &lt; 10; i++) { if (i+1 == 10) { // true only when i==9 printf("%d\n", i); } } 
cast pow() to an int, or build your own. &amp;#x200B; #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(int argc, char*argv[]) { int num, pos; scanf("%d", &amp;num); scanf("%d", &amp;pos); printf("The %dth digit of %d is %d\n", pos, num, (num / ((int)pow(10, pos-1))) % 10); } &amp;#x200B;
You mean, my code is wrong in the ways that I am pointing out, in an attempt to model your non-existent code and debug it for you?
You didn't get the point, I don't need position of num, I need digit position of numbers divisible by 7 (71421283542...)This part of program will get you position of num not numbers divisible by 7
Look, num I use only for total count of digits till that num, I asked only for one line of code where I'm wrong which is digit position
This might be the simplest ( in terms of wrapping one's head around ) solution.
Save your step size in a variable and decrease afterwards by this size. But I think you got another problem you try to describe with this example. You should think of giving us your real problem, if you want real help. 
I vote we reverse golf this one: &amp;#x200B; int i; char number[12]; for (i=0;i&lt;10;i++) { sprintf(number, "%d", i); } printf("%s\n", number); Although I bet I can make it even longer... &amp;#x200B;
You're only using a single format specifier (%d), therefore it is only outputing a single variable (The first, hence -777). Add more specifiers. (Note, the specifiers you should be using is hinted at by the types)
your printf format string only has one output specifier thing (whatever the term is :P) aka the %d part of the string. since there is only one specifier, only the first variable is printed
You're only getting one, cause the %d matches with A. There is no output defined for the rest. In other words, you might need to match a formatting output % to each parameter, or printf will just drop the extra ones. I would google printf examples with multiple arguments. 
Thank you so much, this helped and my program works now.
You need to change your use of ```printf```. You need to specify ```%d``` for every int you want to print and ```%c``` if it is a char. ```printf("Good Morning %d\n, %d\n, %d\n, %d\n, %c\n, %d\n, %d\n",A,B,C,D,F,J,H);``` This still wont compile without errors though. You are trying to declare a floating point number into ints ```C``` and ```D```. You would need to change these to floats to remove the errors you get from that. You can read up on printf and its return values [here](http://www.cplusplus.com/reference/cstdio/printf/) if you'd like to look more into it.
FYI, it's bad form to post screenshots of code. Copy and paste it into your post. The new reddit editor has a code block feature to format it properly, or in markdown you need to add four spaces to each line. The reason for this is that the compiler sees `-1(drag/mass)` as trying to call a function named `1` ... which is obviously wrong so you get an error. You probably intended multiplication, and need a `*` in there.
I did that and what I got was the same error but instead got called object type double
I changed it but instead got object type 'double' error 
Then it isn't the "same error". Also, I can't see a link to your code anymore.
A few comments: \- Your second 'for' loop should start at '(index + 1) % sz'. Since 'index' holds the latest command, 'index + 1' will hold the oldest command. \- In the second 'for' loop you could print only 'if (past\_entries\[i\]\[0\] != 0)'. Since the array will be initialized to 0's it will skip these entries until something is put in them.
/r/cpp_questions for questions. 
Thanks!!
/r/cpp is the main sub for C++. But they try to keep that sub limited to discussions about the language itself, and not things like projects. /r/cpp_questions might suit your needs better, and possibly /r/cplusplus as well.
https://www.reddit.com/r/learnprogramming/comments/9ivlm3/issues_with_random_number_generator_repeating_and/e6mpun0/?st=jmi64fd0&amp;sh=70e7d6f6
= : assignment == : comparision
You are using the wrong operator It should be valid == 0 as opposed to valid = 0 in the if statement
Think of ‚Äú==‚Äú and internally tell yourself ‚ÄúIs equal to‚Äù. Then any time you just see ‚Äú=‚Äú it must be an assignment.
Do not post pictures of code. Instead, post your code as text in a self post. I have removed your post so you can try again with code as text.
Thanks everyone for the responses. Sorry, I'm (clearly) just beginning to code in C.
Never use strncpy , it doesn't write a null terminator sometimes.
You're never passing the values you got from the user into your `calculateVelocity` function. This is masked by having local variables in that function with the same names, but uninitialized. Once you have uninitialized variables, just about anything can happen (including weird results like `NaN`).
`weight` in `calculateVelocity` and `weight` in `main` are unrelated. You need to make `calculateVelocity` take the 4 terms as parameters and pass them to the function from `main`.
lol even i the worst c prorgammer ever, figured out the problem. your only using a single conversion specifier for all of them. LOL.
Method : User inputs a starting value A, step H and the lower limit of function value YM. The following conditions have to be true: H &gt; 0. The function value y will be calculated in the following points: A A + H A + 2H A + 3H ... while the condition y &gt; YM holds true, however not more than 15 times.
Wow that was incredibly helpful. And true, never head of monkey coding before but thats the perfect way to describe it. Thank you! 
Thank you!
* your \`while (h &lt; 0)\` allows \`h\` being \`0\`. Probably this: \`while (h &lt;= 0)\` ? * during the first of 15 iterations, \`y\` starts uninitialized. \`float y, x = 0;\` assigns zero to \`x\` only.
What is the alternative btw? Because strcpy is a very bad idea.
Like you said, it returns the remainder from the division. 4 divided by 8 is 0 with a remainder of 4. An easier way to understand the modulus operator is to think of it like a clock. The hand can spin around and around, and where they point at the end is the result. In this case, imagine a clock with 8 numbers (0 through 7) on its face. Start with the hand at 0 and move it forward the same number of times as the numerator. So if you calculate `22 % 8`, you would step the hand forward 22 times. After 8 steps it will point back at 0, but there's 14 more steps to go. 8 more steps and it'll be back at 0 again. When you finish the 22 steps, it'll stop at the 6 (8+8+6=22). Likewise with `4 % 8`, except the hand never makes a full circle, it just stops on the 4.
On line 26, you declared `Score` there; because you did not initialize it, it contains garbage values. Then you are trying to use that garbage value in line 27.
Yeah, thanks a bunch! Trying to do this fast, so make so simple mistakes :c
Did those solve your issues? :&gt;
https://www.onlinegdb.com/ anything more complicated consider getting a PythonAnywhere account. Gives you access to a simple IDE in a Linux environment. Not just limited to python 
Almost, now there's a problem with counting function(y). For instance, if we substitute a with 1, ym with 2, h with 3. X is counted nice, but if we put it in our function, it counts incorrect. \#include &lt;stdio.h&gt; \#include &lt;math.h&gt; float func(float xx) { return (6\*pow(xx,2)+29\*pow(xx,1)+14)/32-(1\*pow(xx,5)); } int main (void) { float a,h,YM; printf ("Enter a\\n"); scanf ("%f",&amp;a); printf ("Enter YM \\n"); scanf ("%f",&amp;YM); h = -1; while (h &lt;= 0) { printf ("Enter h. Must be greater than 0.\\n"); scanf ("%f", &amp;h); } int i=1; float y,x = a; y=func(x); printf("X\\t\\tY\\n"); while (i &lt;= 15 &amp;&amp; y &lt; YM) { printf("%d",i); printf(": "); printf("%f",x); printf("\\t"); printf("%f",y); printf("\\n"); x = a + i\*h; y = func(x); i++; } &amp;#x200B; return 0; } &amp;#x200B;
There are lots of options. One of them is to check the length of the string before calling `strcpy`. Another is `snprintf`.
I see. How, then, would I got about using the value returned from `getScorePoint` in `main` ?
First, comment line 26 and 27 out. Then revive line 24 only, and change line 23 to this: `int Score = getScore();`. I guess this is what you originally intended?
I completely overlooked that, I guess. Definitely still a beginner lol. I appreciate it!
Yeah, got it. I\`ve found a mistake in function. Thank you again :)
Happy coding!
Good to hear that everything's fine now. Next time, please reformat your post/comment so the entire code is displayed as a single code section; it really helps on reading it. Or, use code sharing services like [GitHub Gist](https://gist.github.com/). Just an FYI.
Wait, I completely overlooked something too. Make sure you declare `Score` to be `float`: `float Score = getScore();`. Or your code will only emit score points of 4, 3, 3, 2, and so on.
My bad. Will post code in a \[self\] post.
Would you share your current code again? As u/boredcircuits said, not image this time. :)
`for (; courseNum &gt; 0; courseNum--)` `{` `getScore();` `float Score = getScore();` `printf("Point = %.2f\n", getScorePoint(Score));` `}` This is the `for` loop causing the issue. I'm just needing it to retrieve the Score then print the Score Point then repeat as defined.
Oh yeah, kill the line that has only `getScore();`. The next line can stay.
Happy coding!
Here's the way I think of it... &amp;#x200B; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; // Ring buffer stuff #define RB_EMPTY(x) (x.writeIdx == x.readIdx) #define BUFF_SIZE 11 #define ENTRY_LENGTH 20 #define NELEMS(n) (sizeof(x) / sizeof(x[0])) typedef struct { unsigned char buff[BUFF_SIZE][ENTRY_LENGTH]; unsigned writeIdx; unsigned readIdx; } rb_t; void addToRB(rb_t *rb, char *entry) { strcpy(rb-&gt;buff[rb-&gt;writeIdx], entry); // Calculate next position unsigned nextIdx = (rb-&gt;writeIdx + 1) % BUFF_SIZE; // If we're going to overwrite data in the buffer if (nextIdx == rb-&gt;readIdx) rb-&gt;readIdx = (rb-&gt;readIdx + 1) % BUFF_SIZE; rb-&gt;writeIdx = (rb-&gt;writeIdx + 1) % BUFF_SIZE; } void readFromRB(rb_t *rb, char *result) { strcpy(result, rb-&gt;buff[rb-&gt;readIdx]); rb-&gt;readIdx = (rb-&gt;readIdx + 1) % BUFF_SIZE; } void InitRB(rb_t *rb) { rb-&gt;writeIdx = 0; rb-&gt;readIdx = 0; } // Driver int main() { char *x[] = { "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve" }; rb_t rb; InitRB(&amp;rb); for (int i = 0; i &lt; NELEMS(x); i++) { addToRB(&amp;rb, x[i]); } for (int i = 0; i &lt; 100; i++) { char result[ENTRY_LENGTH]; if (!RB_EMPTY(rb)) { readFromRB(&amp;rb, result); printf("Got a %s\n", result); } } return 0; } &amp;#x200B;
It's also a popular programming assignment for C programming classes
I think you meant to divide 8 by 4, and this is the source of your confusion? Not sure what the question is.
One way to solve this is to create a result variable and then set result=I as the body of the loop, when you leave the loop the result will be correct. I think many practical problems map out nicely to that pattern.
You also need to check the return value of scanf(). Try typing 'A' when it asks for the score and see what happens (it's probably not what you'd expect).
Wouldn't using strncpy properly also be an option?
I don't know what everyone else does but I usually start my file by writing an integer of how many items are stored in the file and read them all into an array or linked list and then when I am done I write it all back to the file again.
I provided a link to onlinegdb which contains my code. format ‚Äò%d‚Äô expects argument of type ‚Äòint *‚Äô, but argument 2 has type ‚Äòint‚Äô [-Wformat=] scanf("%d", userChoice); Specifically, I am getting this error. I don't know why I am pretty sure that I am using scanf properly. 
`scanf ()` requires a pointer for where you would like the values stored. In this case, you should be passing `&amp;userChoice`. That error message is quite descriptive; it expected a pointer value but you didn't pass one.
there are two main use cases for string copying First is to only copy the string if it can fit inside the destination buffer, i.e., truncating the input is not acceptable. In that case, you check the length and then `strcpy` if it can fit. Presumably if it can't fit you log an error or something. Second is to copy the string regardless of length, and truncate the string if it exceeds the destination buffer size. `strncpy` does *not* do this, and if you're expecting it to then you'll be having fun tracking down out-of-bounds read errors. For truncating there are more appropriate functions like `strlcpy` which is unfortunately not included in the standard library.
If you don't know what to program...then programming isn't for you.
You put common things like prototypes, typedefs, struct definitions, or named constants in there. Then you just include the header instead of copying those things in each source file.
Got it. Why compiler needs prototype ?
To do static type-checking and make sure a function is called with the correct number of arguments, that the arguments are of the correct (possibly converted type), etc. 
The C compiler acts on individual files. Unlike some other languages, when compiling a file, the C compiler knows nothing about the other files. So if you want to call a function in another file, you need to tell the compiler how to call it (parameters, return value, identity of the function i.e name). This is what the prototype does. Then the compiler will create an object file with relative addresses. The linker will act on all object files of the program and fix the addresses. 
What if the file has to be endless?
Thank you so much!
You could have a special entry at the end (like full of zeros or something)
but you need to disclose the code: when you have a .h file you always need a .c file
&gt; but you need to disclose the code: when you have a .h file you always need the corresponding .c file. is this right? No. When compiling a program that uses a library, you may use the (public) header files that come with that library, but you don't need the source code to it.
No. if you're writing a PNG library for example. All you need to expose is the any types the user will use, an init/deinit function for any complicated types, and an encode and decode function. and a few setters and getters. The entire rest of the API can be private.
Because #including a file literally copies its contents into the #including file, if the library or whatever wasn't split into header and source files, you'd have to effectively recompile every library every time you recompile a file that uses it.
Can you show me what u mean?
Good question, and the answer is you technically don't. In early compilers the 'include' directive does literally what it says. It includes the text of the source file into the current position - in some ways it still works that way. Take the following example: // file: main.c // compile: cc main.c -o main #include &lt;stdio.h&gt; int addNumbers(int a,int b) { int result; result = a+b; return result; } int main() { printf("sum = %d", addNumbers(1,2)); return 0; } As projects get bigger you may want to split your file out, so the equivelent programm to the above would be: // file: mymath.c int addNumbers(int a,int b) { int result; result = a+b; return result; } // file: main.c // compile: cc main.c -o main #include &lt;stdio.h&gt; #include "mymath.c" int main() { printf("sum = %d", addNumbers(1,2)); return 0; } Great! That solves the problem right? Yes.. But - you now have to compile the entire source code. Rember all `include somefile.c` gets inserted into `main.c`. Notice how we didn't have to compile `mymath.c` seperately. For small projects this is fine, some projects though can take hours to compile. We also need the entire source tree for any project we want to link into. What if our compiler didnt support header files? Then `&lt;stdio.h&gt;` would become `&lt;stdio.c&gt;` - and this would go on all the way to the kernel source code would need to call public system methods in the kernel to print. That would just be insance. Sort of. Dynamic languages like python do in fact compile all parent imports all the way to the c-layer, if you have run python before you would have seen `*.pyc` files for all source files needed - this is the bytcode cache. The solution is to have a header file that can be compiled on it's own. The idea is to include as little as possible (because this improves compile time) while still including what you depend on. With this method, we can now utilise previously compiled binary, and add our own such as `mymath.c` with the following compilation step: cc -c mymath.c // creates mymath.o We need to create a header file for `mymath.c` which contains the prototype for `addNumbers`. When the header file is included in main.c it registers the function, which will end up being replaced with the function from the compiled and linked library. To finish our example: cc mymath.o main.c -o main Is this a perfect solution? Maybe not, and there are alternatives. But it works, and provides us with a mechanism to hook into previously built libraries. 
This is actually more in line with what /u/MayorOfBubbleTown suggested. Note this isn't tested, just a quick a dirty approach. You first see if the file exists as you are with the size check and if not, prior to writing the first entry, write the number of entries: int32_t entryCount = 0; if( 0 == size ) { entryCount = 1; fwrite(&amp;entryCount, sizeof(int32_t), 1, outfile); fwrite(&amp;entry, sizeof(struct contact), 1, outfile); } else { .... } if it isn't the first entry then you want to find out if there is a duplicate. I would setup a subroutine to do that int isDup(FILE* file, char* name, int size) { int32_t entries; fseek(file, 0, SEEK_SET); fread(&amp;entries, sizeof(int32_t), 1, file); struct contact entry; for(int32_t i = 0; i &lt; entries; i++) { if( fread(&amp;entry, sizeof(struct contact), 1, file) == 0 ) return 0; //hit eof if( strncmp(entry.name, name, size) == 0 ) return 1; } return 0; } Now, modify your code above to be if( 0 == size ) { entryCount = 1; fwrite(&amp;entryCount, sizeof(int32_t), 1, outfile); fwrite(&amp;entry, sizeof(struct contact), 1, outfile); } else { fseek(outfile, 0, SEEK_SET); fread(&amp;entryCount, sizeof(int32_t), 1, outfile); if(!isDup(outfile, tmp, 50) ) { fseek(outfile, 0, SEEK_END); fwrite(&amp;entry, sizeof(struct contact), 1, outfile); entryCount++; fseek(outfile, 0, SEEK_SET); fwrite(&amp;entryCount, sizeof(int32_t), 1, outfile); } } Now when you load your file the first 4 bytes will tell you that the file isn't empty (if value != 0 ) and how many entries expect to have to drive a loop.
Look at the generated assembly. `strcmp` is safer (if you add commands with identical beginnings) and faster here anyway.
It will call strlen() at runtime and incur the cost of strlen(), so it's definitely something to consider. You could always add a struct member 'length' and have an initialization function that then sets all the string lengths. That way you can use 'length' in the strncmp() call. That would help with performance if parse_command2 is called more than once.
Thanks! &gt; gcc -S For some reason I didn't know it was that easy to just generate the assembly, definitely will be using that in the future.
C can call undeclared functions that have no prototype, only if it is defined in another translation unit. It will deduce the signature of the function that is being called and if the deduction is successful(by luck), it can successfully call the function. However this is wrong practice and there should be a concrete prototype for **healthy programming habits**. 
better... now my while loop works , I can type new name and phone but it doesnt save it in the file..
It's a C antipattern to use the "n" versions of string functions, but then call them with strlen() anyway. This pattern indicates the author of the code has heard that the "n" versions are safer, but doesn't understand why. 
If you make 'keyword' 'const', the compiler may be better able to optimize the code. &amp;#x200B; However, even in an embedded system, this optimization is highly unlikely to matter. Unless you're dealing with situations where microsecond and microamps matter, it's probably better to focus your efforts on loops that run more often and take more time. Have you profiled the code? How often is this called? How much time does it take? What functions are called more often and are more intensive? 
`-Wa,-alh` is also nice.
It‚Äôs not never, but it‚Äôs not reliable. See [this](https://godbolt.org/z/g0D_Ou) for instance.
Of course it'll run each time. If speed really matters to you, hard code the lengths and put it in the command\_t struct. This trades off a bit of space for speed, but it also means you have another place to put in bugs. Knowing those trade offs is important as an embedded developer.
There's also [Compiler Explorer](https://c.godbolt.org/z/8dNj-7) (aka Godbolt, after the creator and URL) that's useful for this. It's also great for trying out different compilers. For example, Clang unrolls the loop, which lets it optimize out the `strlen` call and insert a constant specific for each iteration of the loop (which it calculates at compile time). You can probably induce GCC to do the same ... but it's better to just not use `strncmp`, since it's not needed in this case.
I need longer strings to match the shorter keyword, for example `"pwm 70"` should `"pwm"`. 
That's sort of what I ended up doing: #define CMD_KEYWORD_INIT(x) .keyword = x, .length = sizeof(x) - 1 // -1 so we dont include null-terminator const command_t commands[] = { {CMD_KEYWORD_INIT("version"), .func = print_version}, {CMD_KEYWORD_INIT("status"), .func = print_status}, {CMD_KEYWORD_INIT("pwm"), .func = set_pwm}, {CMD_KEYWORD_INIT("rpm"), .func = set_rpm}, {CMD_KEYWORD_INIT("q"), .func = query} };
Whats so bad about it? 
no idea what u mean.. 
The point of the exercise is to encourage you to think about when you should and shouldn't worry about optimization. For example, if you restructure the code, it might not call strlen() as often....but it might have to use a register to store it that was previously unused, or use more memory. Sometimes what we think will improve things will actually make things worse. If you \_really\_ want to optimize it, have the compiler generate assembly, then tweak that manually.....good luck! 
This stinks of a homework dump
I emailed the same thing, they response was I'm not able to modify the array.
I think you should divide the array into n many parts (n being the length of the array), then conquer each one in sequence by checking if they match.
That may be the goal if you're using a new thread, or something like it, for each array chunk.
`strncmp (a,b,strlen (b))` has different behaviour to `strcmp` , it's probably intentional
You probably just want to use `strstr(cs,ct)`, to find the first occurrence of string ct in cs. [http://man7.org/linux/man-pages/man3/strstr.3.html](http://man7.org/linux/man-pages/man3/strstr.3.html)
you absolutely cannot guarantee you'll receive the whole header in one packet (recv) unless you dynamically process the header line by line, the best you can do is keep appending the recvs until you encounter the crlfcrlf
You can't call a macro as you can only call functions. Macros are substituted by the preprocessor, there is no call involved. What output do you get and what output do you expect?
I get 2 and I expect 4
Can you please indent your code with four blanks so it is formatted correctly? Are both `#define` directives on the same line or on different lines?
Done
The code doesn't compile for me. Are you sure this is the real code you are testing?
So I ran your program through `gcc -E`, and this results in the following, formatted for readability int main() { printf("%d", (2&gt;(1&gt;4) ? (1) : (4)) ? (2) : ((1&gt;4) ? (1) : (4)) ); return 0; } With the above output, it should be obvious why your test case is failing. Hint: Operator precedence.
It‚Äôs that (a.) you need to surround *all* instances of `a` and `b` in parentheses, and (b.) you need to surround the entire macro expansion in parentheses. Otherwise it blows out into a mess. You can invoke a macro from within its own argument list, but you can‚Äôt invoke a macro from within its own expansion (i.e., recursively). You‚Äôre fine with the usage here, but if `max` were in its own `#defin`ition the inner `max` would be left as-is (i.e., unexpanded).
True, and I'm afraid that's what they're asking. Which is kinda retarded since the 2 ways to operate on unsorted containers is by either sorting or changing how elements are stored, and this qualifies as neither. I don't see how this even qualifies as a "do wrong to learn right" example. If the point is teaching divide-and-conquer, just do merge sort.
Is it about multiprocessing perhaps?
I can almost guarantee that strlen() won't be computed at compile time unless the compiler can reduce the argument to a string constant. `commands[i].keyword` won't be a constant. I would bet money that the standard doesn't say that strlen() is ever computed at compile time, so you'll have to always assume that it isn't.
&gt; have more fun and check the assembly While I highly recommend this as a way to get to know what the compiler is doing, this will never give you the canonical answer, because a different compiler, or a different version of this compiler, will do something different.
Agreed. But, if you're using a mainstream compiler on a problem like this,either you find out, "yes, it can be optimized away", or you find, "at least one compiler could not optimize it away". And, realistically, the standard doesn't even address what the resultant assembly must look like, nor what an optimization may do. 
A linux computer with gcc and no internet in the middle of nowhere. Nothing but man files and boredom. 
This is kind of off-topic, but I feel that I should point out that these macros are a generally bad idea, even when their precedence bugs are corrected. If they are used with an argument with side-effects, then there is the possibility that the side-effect is applied twice. It's not clear at the location where the macro is being used that this is occurring. It looks like an ordinary function call, but it is _not_ a function call. Some C implementations have extensions that can avoid this problem. For instance, with GCC you could write: #define max(a,b) ({ \ typeof (a) _a = (a); \ typeof (b) _b = (b); \ _a &gt; _b ? _a : _b; \ }) This is using two extensions: a `typeof` operator which given an expression resolves to the type of that extension, and a so-called "statement expression", which allows a compound statement to be evaluated in the middle of an expression.
Running one compiler with one set of flags on one architecture on one OS doesn‚Äôt tell you how C works. Learn what ‚Äúimplementation defined,‚Äù ‚Äúunspecified‚Äù and ‚Äúundefined‚Äù behaviors are and then learn how they apply to each feature of C and you‚Äôll be ahead of most people getting paid to sling code they think is C. Don‚Äôt microoptimize up front. Your code will often be larger, slower, more brittle and more bug riddled if you do. I‚Äôve worked on systems where you could count the words of memory on your thumbs and had to rewrite half the application to free up 5 words to add a new feature but with the first Apple watch having half a gig of RAM this should be a thing of the past for all but the rarest of systems. Speaking of brittle, are you expecting the parameter of ‚Äústatuscalifragilistexpectialidocious‚Äù to be ‚Äúcalifragilistexpectialidocious‚Äù and if so without passing some reference to the keyword how are you going to strip off the prefix?
Why wouldn't you write your own beginswith() function that doesn't need the length, and implements the semantics you desire?
Speaking of patterns it's odd you didn't notice that this usage of `strncmp` is basically `strstartswith` But nice job insulting OPs intelligence
 Sage Sharp claims top Linux kernel developer Theo Ts'o is a rape apologist, citing GeekFeminismWiki https://www.reddit.com/r/linux/comments/9hg9to/sage_sharp_claims_top_linux_kernel_developer_theo/
You're right, but I was hoping to get a general idea of when I can expect a compiler to optimise this. If a command takes a parameter it will parse starting from `&amp;arg[command.length]` in its own function. Any input not following this syntax or with invalid parameters is ignored. Although if I wrote my own `beginswith()` function as someone suggested I could pass a pointer to the inputbuffer at the end of the command which would simplify things. As for microoptimisation, some of my old projects simply have a switch to parse single-character commands only, so I'd consider this a step forward. 
What different behaviour? They look the same to me :S
Ah, gotcha. The alternative with `strncmp` checks if `a` begins with `b`, not if they're equal.
[removed]
You mean like this?: https://stackoverflow.com/questions/6054016/c-program-to-find-day-of-week-given-date 
I believe it would be beneficial to look at the man page for date: http://linuxcommand.org/lc3_man_pages/date1.html
So I decided to help you out. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char *daynames[7] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}; int d = 0; for (d = 0; d &lt; 100; d++) { char date_cmd[50]; sprintf(date_cmd, "date -d \"+%d day\" +'%%A %%d/%%m/%%Y'", d); FILE *date = popen(date_cmd, "r"); char result[100]; fgets(result, 100, date); if (strstr(result, daynames[atoi(argv[1])])) printf("%s\n", result + strlen(daynames[atoi(argv[1])])); pclose(date); } } I think that's pretty close to what you're talking about. This takes input as: $ gcc day.c $ ./a.out 1 01/10/2018 08/10/2018 15/10/2018 ... &amp;#x200B;
Please share your code on some legit platform like git gist or pastebin. Sharing code in image format is not right.
Those macros will expand to: (2&gt;(1&gt;4)?(1):(4))?(2):((1&gt;4)?(1):(4)) You can see the error right there in the first three terms. You're computing `2 &gt; (1&gt;4)`. `1&gt;4` evaluates to false (0), so `2&gt;0` evaluates to true, and it's all downhill from there. That's why every argument to a macro must be surrounded by parens.
# dav1d **dav1d** is a new **AV1** cross-platform **D**ecoder, open-source, and focused on speed and correctness. The canonical repository URL for this repo is [https://code.videolan.org/videolan/dav1d](https://code.videolan.org/videolan/dav1d) # Goal and Features The goal of this project is to provide a decoder for **most platforms**, and achieve the **highest speed** possible to overcome the lack of AV1 hardware decoder. It aims to support all features from AV1, including all subsampling and bit-depth parameters. In the future, this project will host simple tools or simple wrappings (like, for example, an MFT transform). # More information * dav1d contribution guide: [https://code.videolan.org/videolan/dav1d/blob/master/CONTRIBUTING.md](https://code.videolan.org/videolan/dav1d/blob/master/CONTRIBUTING.md) * TODO list: [https://code.videolan.org/videolan/dav1d/wikis/task-list](https://code.videolan.org/videolan/dav1d/wikis/task-list)
Just wanted to comment on here and remind you that a lot of people spent time writing replies to your question and you never once told anyone thanks. Pretty dick move to post a question then ditch it.
Thanks a lot
Thanks, I was not aware of that option.
&gt; loyalty-free That's a rather funny typo
I am really sorry, didn't mean to ditch it. It was just that I had got a detailed answer on stackoverflow so I kind of forgot to respond. Anyways thanks for reminding me, I would keep in mind to respond everywhere I post from next time.
Not really a huge deal. I just know when i post a detailed explanation to someone it feels a little good to get something back ya know? Either way, glad you fixed your issue!
You should have a look at `strftime` and the other functions that use `struct tm`, e.g. `localtime`, `gmtime`, `mktime`. Shelling out to run the date command isn't very C, if you're going to do that you might as well use a shell script to do this task.
Have a look at the documentation for `localtime`, `time` and `strftime`. That and some arithmetic should be all you need.
But where's the fun in that? If I'm doing someone's homework assignment, I'm going to do it in an entertaining way. ;)
It's faster for searches and doing mass adjustments to one field of every struct. Also generally more efficient in memory usage. If you have to iterate through every struct one at a time and do something to each member of that struct, then it probably is going to be slower. If you need to find a specific struct and then do something to it, SOA would probably be faster. Depends on what you're doing with your data.
Downvoted for being not constructive. int functionArray[]() { int array[5]; int i = 0; while(i &lt; 5){ array[i] = i; i++; } return array; } The array lives on the scope of functionArray. You can't return a temporary array in C as it will be automatically cleared after the scope ends. You must create a dynamic array in order to be able to return it, then you would hate to free it after usage. int* array = malloc(sizeof(int)*5) The return value should be int\* as well. like this -&gt; int* functionArray() Or. You could pass an array to the function, as a pointer. void functionArray(int* array) And call it like this -&gt; int array\[5\]; functionArray(array); &amp;#x200B;
Look into microhttpd implementation.
Okay thanks, but when i don't return a array, let's say that i do a small calculation and then i return the result of my addition, it works, why ?
Because C uses **pass by value**. There is no concept of references in C. Though the idea is emulated using pointers. Given you are returning a simple type, C is actually **returning a copy** of the variable defined in the scope of the function. (Not the actual variable.) Returning arrays is achieved using pointers which are basically simple types that hold addresses. Now if you return the address of an temporary array that will go out of scope, you will get an address that points to garbage. You don't want that. You want your pointer to point to something meaningful. 
C works for whomever will pay. 
Obviously you don't care. Spelling mistakes. Bad indentation(due to sloppy copy paste?) So why should we care?
Here is one line of code //TO DO: Your homework
&gt;Copyright ¬© 2018, VideoLAN and dav1d authors All rights reserved. &gt;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: &gt;1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. &gt;2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. &gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
What I liked most was the: "no C++ allowed, whatever the version."
[Image of Code](https://imgur.com/gallery/I4hkhyq)
In your `if` statements the comma `,` doesn't do what you want it to.
is there an equivalent or simpler way to make that work? Our professor wants the TAs to be able to enter both uppercase and lowercase letters. Should I use another method, like something involving numbers? Or am I condemned to making at least 18 long 'else if' statements?
You have to explicitly check `if(input1 == 'r' || input1 == 'R')` What you can do is change them to lowercase beforehand so you don't have to check both every time: if(input1 &lt; 'a'){ input1 += 32; } 
You're using `&amp;&amp;` correctly. With 2 complete statements on either side. Since you want to test whether input1 is one character *or* another then yes, `||` is the correct thing to use. Another solution is to make sure input1 is always uppercase before the if statements so that you only need to look for 'R', 'P' and 'S'
This is gonna look a bit long and messy, plus im not sure how to convert to code like you did, but would this still work?: if((input1 == 'r' || input1 == 'R') &amp;&amp; (input2 == 'r' || input2 == 'R')){ printf("Its a tie");}
Yes that should work, you can post code on reddit by adding four spaces in front of text or for `short bits` by wrapping them in \`backticks\` The other thing I posted simply converts the `input1` to lowercase so you only have to check the lowercase letter each time, you'd add that before the if statements. Look up ASCII to see how/why adding 32 turns 'A' into 'a'. 
Probably \*ok\* to stick with C for relatively small, limited-scope libraries that are basically a collection of a bunch of algorithms and if you are able to use tests and static analysis to capture buffer overflows and memory leaks. If you start reimplementing polymorphism, generics etc. or things like RAII would be nice it's probably time to pick C++.
I think we'll be learning ASCII later this semester, so if i were to include it now they might be flattered, but I don't wanna risk losing points for using knowledge I "shouldn't" know yet, ya know?
&gt; Look up ASCII to see how/why adding 32 turns 'A' into 'a'. [tolower](https://en.cppreference.com/w/c/string/byte/tolower) is better.
The [decode\_b function](https://code.videolan.org/videolan/dav1d/blob/master/src/decode.c#L669) in decode.c is horrible.
This depends on what you are doing. If you process one struct at a time, then an array of structures is better. If you have a vectorized process where you can process a bunch of structs at a time, then a structure of arrays can be faster. When in doubt, measure.
I can use if staements and loops only. What can i do? Thanks
What makes a man turn neutral? Lust for gold? Power? Or were you just born with a heart full of neutrality?
Ummmm, sure. That and a pair of testicles.
I think you'll get more out of your homework if you do it yourself. What kind of help are you looking for?
This is not a homework help sub, nor does your question have anything to do with the C language. Regardless, this sub will help answer questions. What you haven't does is tell us what you have tries, what you don't understand, or what you cannot figure out. Don't just toss us a question and say "have at it". If this is a homework problem, your first and best source of help is your professor. Only come to this subreddit when you absolutely can't figure something out (and even then, go to the homework sub).
You have an array for suits, so add one for card names: &amp;#x200B; char values[13][] = { "Ace", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "None", "Tin", "Queen", "Jack", "King" }; for (i = 0; i &lt; 52; i++) { printf("%s of %s\n", values[i%13], suits[i/13]); } &amp;#x200B;
fuk off u dirty son of a whore. Instead of commenting on this post go look for your mom and sister, thie prolly gettin fuked right now. Stupid fuking autisitic dumb BITCH lol FAGGOT KYS
Not very different to all the decosing libraries I've seen. Perhaps it is a convention?
Wrong language. Also why you prying into some dude's code? He used the obfuscator for a reason. If he wanted to share it he'd stick it on GitHub.
C# is off topic in this subreddit. Please post C# questions to /r/csharp.
Thank you for your reply. I'll check out valgrind when I get some sleep. I've just been using atom to edit and gcc on the command line to compile. I've tried CLion's debugger but it doesn't seem to help. Well I did the double pointer Instruction **instructions because it acts as a 2d array. I wanted a size of [number of states][256 ascii values in terms of int]. Even if I use a regular 2d array, I get the same error. I feels like the allocation is also wrong (hence the segmentation fault: 11) but I'm unsure where. It must be instructions though. Once I get to the (B L 2) part, it just acts as if it wasn't there despite me being able to manually grab instructions[1]['B'] (or 66 if you prefer index number). I appreciate the message though.
I assume the +1 should be inside the round bracket ? You allocate +1 byte and want to allocate (numofstates +1) bytes. 
That sure is a video decoder.
Additional notes beside the seg fault error mentioned in my other comment: &amp;#x200B; 1. [Do not use atoi](http://www.eternallyconfuzzled.com/arts/jsw_art_atoi.aspx) 2. One exmaple is your use of atoi on mutiple occasions. atoi expects a string i. e. a array of chars terminated by a \\0 byte. When you use stuff like atoi(&amp;tape\[0\]) you just pass tape as a string (atoi(tape)). To convert a char to a number check if its in between 48 and 57 and then just use int x = tape\[0\] - '0'; (This limits you to 0-9 states so its better to parse the string with sscanf or make multiple distinct strings and convert them with strtol 3. Use a more efficent data struct. You allocate enough memory for 4\*255 instructions while only using 5 of them, but this could be ok if you want random access and dont care for memory 4. Use valgrind! There are multiple problems with your code 5. Example: You allocate an instruction array of size instructions\[256\]\[5\] and not instructions\[5\]\[256\] as it should be. 6. When you load the File you initzialize your content array to 0. This is a good idea but shouldnt be done via iterating. Just use memset(contents,0,sizeof(contents)); also you just iterate 50\*100 which is to less.
`atoi` is perfectly fine for code that doesn't have to 100% validate user input. It's totally adequate for homework like this.
Sure but for just barely more complex data, it'll be so hard to *really* get it right that I also see no point in not using atoi() in a small homework, as long as you consciously make this decision.
&gt;as long as you consciously make this decision That‚Äôs the point. It is mostly used because it is the first result on stackexchange after googling ‚Äûstring to int c‚Äú. That‚Äôs the reason I advocate for not using it in beginners posts. But you are right it is not inherently evil if you know why it is broken. 
And also, don't rely on the optimizer to generate the correct result, just write good code.
Clang might not be making the optimisation you think it is, even if the end result is the same. You're saying that it should recognise that the second `if` statement is dependent on the first, so the statement should compile into `if (!a) return;`. It probably isn't making this particular optimisation, however. It's probably recognising that `g(*a)` is undefined behaviour if `a == NULL`, so it's allowed to do whatever it likes. Since you're not allowed to dereference a null pointer, the optimiser just avoids that branch if the pointer is null, which it's allowed to do, because if it were otherwise, it would be undefined behaviour. I'm not sure this is really a bug, to be honest. You could potentially try it with something like void g(int); void f(int *a, int *b, unsigned int c) { if (!a) c &amp;= ~0x01; if (c &amp; 0x01) g(*b); } and see what happens. This removes the undefined behaviour that's "caught" by the first `if`.
I understand that mine does invoke undefined behaviour (though obviously it would be simple to remove that), but I'm suggesting a way to test if the compiler is making the optimisation you think it is. If it isn't doing that, then it's not really a bug in the static analyser because the compiler can't make the optimisation either, it's just a path it doesn't know how to check, of which there are many.
I will do another function, something like childfunc() that resolve the fopen, called when you know that the child process is created. I think you are calling from parent
Interesting approach but still has some short comings which are hard to avoid in C. This is a bit awkward for initializing a structure. Foo f; construct(0, f, Foo_ctor); and if (atoi(argv[1]) == 42) { end_scope(1) end_scope(0) return EXIT_FAILURE; } still having to remember how many levels deep of scoping to undo. As long as you can absorb the additional overhead, writing mostly C code while using a C++ compiler lets you take advantage of those capabilities we'd like in C but don't have.
In the meantime: struct _IteratorInternal { void *element; void *container; struct _iterator_vtable *vtable; }; struct _iterator_vtable { Iterator *(*itor_first) (void *); Iterator *(*itor_last) (void *); Iterator *(*itor_next) (Iterator *); /* ... */ }; 
thanks for the heads up, I forgot to switch to markdown when I was writing the post, it's fixed now :)
The code still doesn't render properly; use 4 spaces of indentation instead of triple ticks.
1) I think it will work. I don't know how you would handle deleting elements from the container. Probably just add another vtable function. 2) not sure right now, can you write some demo code of how you would create your iterator and how to loop though it? 3) again not sure. I personally write a lot of loops in c and I have found masking them with an iterator to be difficult to do and it clusters up the code. 
thanks for the feedback I'm not new to Python, but I'm new to Python's source code, thanks for bringing it to my attention.
yeah, sure. but I'm trying to achieve something like polymorphism, where you could switch the container but not the code that uses it. aaand to practice C, lol.
While performance shouldn't generally be your first concern be aware that such custom polymorphism may come at a cost. `iterator_next` dereferences thrice, add `itor_next` and the loop body and you're easily at 6 or 7 dereferences per step ‚Äì vs. zero for a plain old `for` over a flat array.
1. yes, you guessed right, deleting will require a another vtable function. actually there are other vtable functions, but I'm sure if they're all I need, so I'm still exploring my options. 2. example code: Array arr = array_new(4); Iterator *first = iterator_first(arr), *last = iterator_last(arr); // &lt;&lt; C++ like iteration while (iterator_cmp(first, last) &lt; 0) // do something with first-&gt;element // or use a macro to do the typecasting iterator_value(first, int) iterator_done(first, last) // varargs function to free the iterators I'm also considering iterating with one iterator, but I'm still not sure how to implement it. 3. I'm actually trying to write an algorithm library on top of iterators, iteration would be something like: algo_foreach(first, last, { printf("%d\n", iterator_value(first, int); }) algo_sort(first, last) /* ... */
yeah, you're right. I did some thinking about it's cost, but I couldn't find an alternative. I'm trying to write a library of containers, and a library of algorithms, I'm following C++ STL steps, so I'm using iterators to glue them together, rather than writing different version of the same algorithm for every container. and I'm practicing my C skills. if there are other alternatives that accomplish the same goal, I would be glad to hear about them :). thanks for the feed back.
Yes, I understand that. But youre not understanding how optimizers generally work. It's undefined behavior to dereference a null pointer, given the check for a is not null the optimizer can assume that the case can exist and locally it sees a possibility of null dereference.
Why should he have to copy some other implementation? This is a project he's doing, not some new proposed standard. He's asking for feedback on his existing approach, not for how to comply with some other OSS' project's approach to the same problem.
His problem isn't the optimization, his question is why didn't clang static analyzer also realize what the compiler did.
Why not just have the iterator be the vtable struct?
**thank you so much brother!** 
Works for me. Are you viewing it in the browser?
Looks good! I would say you have a start on your algorithm library.
Instead of doing this ... ((_IteratorInternal *)_itor) ... do this: struct IteratorInternal; struct Iterator { void *element; struct IteratorInternal *impl; // No leading underscore, that's a reserved identifier }; Then your macros can look like this: #define iterator_next(_itor) ((_itor)-&gt;impl-&gt;vtable-&gt;itor_next(_itor)) All type-safe, no cast needed. 
The program is \#include &lt;stdio.h&gt; \#include &lt;math.h&gt; \#define s 1086 /\* Function Prototypes \*/ void directions(void); float temp(void); float calc\_speed(float temp); void display(float temp, float calc\_speed); void main() { &amp;#x200B; float speed; float tempy; /\* Calling Functions \*/ directions(); temp(); speed = calc\_speed(tempy); display(tempy, speed); } /\* Sub Program for directions \*/ &amp;#x200B; void directions(void) { printf("Enter the temperature T in farienheit&gt; "); } /\* Sub program for temp \*/ float temp(void) { float t; scanf("%f", &amp;t); return(t); } /\* Calculating speed \*/ float calc\_speed(float temp) { float ss; ss = s \* (sqrt(5\* temp +297)/(247)); return(ss); } /\* Displaying Results \*/ void display(float temp, float calc\_speed) { printf("The speed of sound at %f fareinhiet is : %f", temp, calc\_speed); } &amp;#x200B;
What's the error? Or bug?
The code is in comment &amp;#x200B;
 sqrt(5* temp +297) You're not finding the square root of the right expression 
1. You ignore the result of calling `temp();` 2. You pass an uninitialized `tempy` into `calc_speed`
&gt; // No leading underscore, that's a reserved identifier To be pedantic, this isn't quite true. This is only true for variables with external linkage. If it's only used within the file it's fine. Double underscores and underscores followed by an uppercase letter are definitely reserved though.
Um. Start by turning on compiler warnings (`-Wall -Wextra` for gcc and clang), and pay attention to them.
This... I assume he wanted tempy = temp(); in main instead of just the call to temp as it returns a float :)
You can nicely format your code by indenting 4 spaces per tab/indentation in the code.
Yeah I started it 10 days ago...
It works ! Thanks guyz!
Functions, scope and pointers my friend. It's a little to difficult to explain why exactly it didn't work through Reddit.
\`\`\` isn‚Äôt a thing on Reddit, has to be indented by four spaces.
Ah, I see. What good ideas all around, have these folks at Reddit.
that would be a wast of memory :/ as the virtual table is the same for each group of iterators.
Sorry to hear this. You are pretty near to a working solution. I think your main problem is that you don‚Äôt get the Turing machine stuff. I would recommend to stick with it since tm and especially automatas are important concept which are really easy once you get the idea. The problem with C is that C itself is a very basic language. If you know basic coding stuff as well as structs, pointers and memory in general you know most of the plain language. This makes it hard to teach about C as a language. But stuff like memory management is such an essential concept which runs any computer Programm it is a big advantage to understand it. Understanding memory management even makes you a better java programmer. Just IMHO and it May be more in the long run ;) Anyway. To get TM I always Thought about them as a bunch of if and goto statements (btw. It‚Äôs prooven that goto is equivalent to TM). Your machine has an initial state and a bunch of other states. One of them is the endstate. Now your machine reads from a tape. If it read a symbol from the tape it Checks if it got a transition from its current to a new state. The transitions are the last 5 lines in your text. A transition always says ‚Äûif I am in state x and I read the symbol y from the tape goto state z and move either one left or one right‚Äú also the transition allows to replace the symbol after it was read (that‚Äôs our memory!). The tm does this as long until there is no more matching transition. Then the tm is either in an state which is an endstate and thus returns with success or in a state which is not marked as error state. Then the tm returns with error. Your problem is the following. You reach the last symbol on the tape and are not finished yet since there is a working transition from the last symbol to a new state. Your tm then continues with the next symbol which does not exists in your case and therefore is represented by a NULL pointer. (You initialized it with NULL when you created the last node). Then you try to check what is on the tape and read a NULL pointer which results in a seg fault. What to do now ? Just check if the next node is a NULL pointer and then you know that you read everything from tape and can check if you are either in an endstate or not (and therefore your tm returned with success or without). Don‚Äôt mix up states and transitions. A tm just has a finite number of states. And a finite number of transitions. A transition brings a tm from one state to another but this can happen arbitrary often when you for example build a loop. I hope this was understandable. 
Thanks crest42. If I get it working, I'll give ya some gold love but I think I'll take a break for today and have a go at it tomorrow. I agree that memory management and low level programming concepts definitely help you and force you to be more creative with solutions. It's just that this is my FIRST c assignment and we did not have a tutorial class or lecture on it. We're just placed into it. Same with Clojure and every other language I'm going to learn in this class I assume. I'm not a big fan of this teaching method because what we learn in class doesn't correlate with what we're doing at home. I know this might sound aggravating but I still don't get it I guess. I know I'm going out of bounds with my linked list but once I reach NULL, its read through the whole list so what should it do after that? Just go back to the first or now go in reverse? Thank you for your insight and help. That much at least helped me figure out the linked list of my initial contents tape was going out of bounds. Maybe I should read up more on TM but tonight is a wings and beer kind of night :(
Wrote a simple (IRC bot)[https://github.com/h4r0015k/IRCBot-C]
If the vtbl is in the iterator struct, then user code never needs to see the definition of struct IteratorImpl, only its forward declaration.
\#include &lt;stdio.h&gt; \#include &lt;math.h&gt; float func(float x) { return (6\*pow(x,2)+29\*pow(x,1)+14)/(32-(1\*pow(x,5))); } int main (void) { float a,h,YM; printf ("Enter a\\n"); scanf ("%f",&amp;a); printf ("Enter YM \\n"); scanf ("%f",&amp;YM); h = -1; while (h &lt;= 0) { printf ("Enter h. Must be greater than 0.\\n"); scanf ("%f", &amp;h); } int i=1; float y,x = a; y=func(x); printf("X\\t\\tY\\n"); for (i=1; i &lt;= 15;i++) { if (y &lt; YM) { printf("\\t y &lt; YM\\n"); break; } else if( y &gt; YM) { printf("%d",i); printf(": "); printf("%0.f",x); printf("\\t"); printf("%f",y); printf("\\n"); x = a + i\*h; y = func(x); } } return 0; }
Oh, hell, hope it'll be better to link. [https://gist.github.com/osobennyj/d24819f839be6318967a21c823c5a7d8](https://gist.github.com/osobennyj/d24819f839be6318967a21c823c5a7d8)
Read the instructions in the sidebar which tell you how to post code. Update your post please.
isn't there a typo in the question? condition is probably "less than YM".
I've thought about that, but not sure. I\`ll have an opportunity to ask about typo only the next week, so now I have to try first condition at least &amp;#x200B;
To answer you question. You either make an array with 15 elemnts of a struct with 2 elements ( x and y), and in each step you set the i-th element's x and y, or you make to arrays of ints.
Nah just stop after you reach null. You are done and either successful or failed. It‚Äôs like reaching the end of your main function. But I would prefer wings and beer over TM too ;) I see you reason to drop this class. Had similar experiences but I was always lucky that i know most languages beforehand so I was able to focus on crude homework stuff. Anyway I am not here to talk you to stay in your class. Do what feels right and maybe learn C in another occasion :) 
Oh I confused x and y. Yes, you're right. 
A simple [file watcher][1] for OpenBSD is the only useful C program I‚Äôve ever written, but it works well and was surprisingly easy to write, given C‚Äôs reputation :-) [1]: https://github.com/jocap/kq-watch
So, as I understood correctly, I need to replace loop that asks for ints for array? I\`m a bit confused how it'll look like , tbh.
Ah, okay, I\`ll try that. Thanks a lot! 
Not gonna lie, C is hell too use for bigger projects. You'd definitely be better off using something more high level. If you want to train your C muscles I'd recommend something like a math library, or a similar utility tool. 
Damn there is a lot there. Thanks!
I use Clion, but it doesn't matter. Use what you're comfortable with.
Qtcreator, vscode, visual studio
Where do you type these commands? You might need to duplicate all backslashes due to shell escaping.
Install Cygwin. In the installer, select Nano to be installed as well. Then from Cygwin you can type "nano hello.c" to open a simple text editor and create a file called "hello.c". Type "gcc -o hello.c" to compile "hello.c" to "a.exe". Run with "./a.exe". You don't need to create a project to compile a single source file, you don't need to set any paths in Windows, and you don't need to change windows between your text editor and your terminal window.
That's pretty great. Most resources for C seem to be either for complete beginners or are pretty advanced.
notepad and [RSXNT with GCC 1.40](https://virtuallyfun.com/2016/05/06/gcc-1-40-on-windows/).
Sure. Take whatever numerical algorithm solves this and implement it in C. 
Try a linux distro from the Windows store
Personally, I hate writing C code on Windows. If you can avoid it, you'll be far better off in terms of learning C. &amp;#x200B; I'd use a linux virtual machine. If you MUST program on windows, I'd use a different language, like C#.
Where did you define the function getline?
Emacs
if you are on windows, you need to write your own getline, if you are on *nix you can use standard posix function (it takes 3 arguments tho). https://linux.die.net/man/3/getline
You aren't using [getline()](http://man7.org/linux/man-pages/man3/getline.3.html) correctly. It takes three arguments, not two. 
Try programming for embedded microcontrollers. That's one of the few areas industry that's still mostly C. You could start with the Arduino IDE, then start programming the AVR directly, then move up to a modern micro. I'd recommend a Cortex M series processor from Silabs, ST, or NXP. 
When I go to compile my source file I would open up command prompt and change the directory to the one that holds the source file and then I'd enter the command above. I typed the following now: gcc testsdl.c -o a.exe -IC:\\SDL64bit\\include\\SDL2 -LC:\\SDL64bit\\lib -w -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2 Which resulted in this: c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16' I'm not sure I know what this means though 
I messed around with Arduino in c++ that sounds cool actually getting to program closer to the board. Microcontroller programming sounds like fun will totally check it out. Thanks!
I checked getline() function details. I am aware that it takes three arguments. Not able to understand why everywhere in K&amp;R this function uses only two variables.
Never mind nano, use vim and learn the true power of the force.
I really like Mayor's answer about using Cygwin. However, if you ever anticipate you might be programming Windows for your day job, you're better off learning the programming environment that you'd be using professionally, and that almost certainly means Visual Studio. I believe it's still free for students and hobbyists.
What's your include line for SDL in your C file like?
In new versions of stdio.h in posix the function getline has been redefined. Change the name to getline_mine or something. 
Frankly, this is the best answer. All of my coding is done on a Unix box (a Mac nowadays) and ported to Windows later. I've heard that game development shops typically do the same thing. Put Linux on a spare partition or in a VM on your machine and come to the fresh air.
Try passing `-mwindows` as an option.
Since K&amp;R was written, a `getline` function has been added to the libc which your function collides with. Rename your own `getline` function to work around this. Alternatively compile with `-ansi` so the function is invisible (not guaranteed to work).
Better than Cygwin: MobaXterm
Visual studio works fine.
Just got out of a Big-4 onsite. Guess what the company bakesale never came up
Learning C on Windows does not sound like a good idea to me.
The way you will implement derivatives in code will be similar no matter what language you use. The thing to remember is the definition of a derivative. dy/dx = lim h-&gt; 0 ( ( f( x + h ) + f(x) ) / h ). Now with a discrete data set we can't take h to zero. Say we have an array of int y[] = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]. To take the derivative you'll need to set h to either 1 or - 1, assuming the dx from one index to the next is 1 unit. This equates to bringing the limit of h-&gt;0 in from either the right or the left. This means there's two ways to take the derivative. h = 1 1) X' = ( x[n-1] + x[n] ) / 1 Or 2) X' = ( x[n+1] + x[n] ) / 1 To do the partial derivative of a matrix. Go row by row and the column by column and add the two results together. 
This subreddit is about the C programming language; programming in general is not on topic. I have removed your article as it is off topic.
When the K&amp;R book was written, getline() wasn't a standard function and/or was defined differently. It's since been changed.
https://github.com/cstack/db_tutorial
A project I found interesting and useful for learning about data structures and pointers and file IO is sudoku solver/generator. You can solve it many different ways. Recursive backtracking (with or without heuristics), using arrays (single or multidimensional), trees, linked lists, etc. As a non-recursive state machine. As an exact cover problem (see dancing links.) You can create your solve() method to accept a solve function as a function pointer. You can use this project to learn about project tools like make, cmake, autotools, unit test frameworks, timing tools, gdb, valgrind, git, etc..
&gt; -IC:\[location of SDL files]\include\SDL2 Alright, and now full `-IC:\[location of SDL files]\include\SDL2` ?
I haven't finished it, but so far I'm mightily impressed by the level of detail. It's the most comprehensive book I've read on the subject. Linux System Programming (2nd ed., O'Reilly) by Robert Love covers similar ground but in less detail.
I haven't finished it either yet, but that's one of the greatest technical book I have ever read. Author is very good at explaining hard concepts in an interesting manner and at the same time letting you know all the descreet details about the subject.
I do not recommend this. A lot of shit breaks in weird ways on those. Not good for learning C.
The tone of the post suggests to me that he just wants to learn C, and is planning on doing it in Windows because that's the operating system he's familiar with using day to day.
Either define [WinMain](https://msdn.microsoft.com/en-us/library/windows/desktop/ms633559(v=vs.85\).aspx) entrypoint instead of main, or try `-m console`
I specifically mention nano when the keystrokes needed to save a file and exit exceed 5% of the total keystrokes. You probably shouldn't use nano if your source code is more than 180 characters.
Alright thanks for the effort anyway
I'm not using windows, but I use gcc and mingw on a regular basis, and I don't use SDL anymore (but I used to). If compiler is really complaining that it can't find SDL.h, judging only from what I've seen so far from you... Try following: You've said your compile line is: `gcc hello.c -IC:\[location of SDL files]\include\SDL2 -LC:[location of SDL files]\lib -w -Wl, -subsystem,windows -lmingw32 -lSDL2main -lSDL2 -o hello.exe` First, try changing this: `-Wl, -subsystem,windows` to this: `-Wl,-subsystem,windows` in your compile line. Notice the space betweek -Wl and , - get rid of that. Then, if compile is still pissing itself, in your unpacked SDL directory, there are two directories: `i686-w64-mingw32` and `x86_64-w64-mingw32` which each has an include directory. One is for 32-bit and one for 64-bit programs. Thus, I presume you're 64-bit, make your -I flag as -IC:\SDL\x86_64-w64-mingw32\include\SDL2 and don't forget to do the same for -L flag as well. If compile is still borking, add trailing / to the -I and -L locations - maybe windows version wants that for whatever reason. If that fails as well, in your unpacked mingw SDL directory, in each of those 32 and 64 bit dirs, there's a bin directory and inside is sdl2-config. If that can be run on windows with `sdl2-config --cflags` it should give you the path that you can type into -I, and there's also `sdl2-config --libs` for -L. On a side note, not that it matters much, people tend to put only ...\include directory on a search path and `#include &lt;SDL2/whateverFromSDL.h&gt;`
Alright so I just decided to re extract the SDL libraries so now the path is `C:\SDL2-2.0.8\x86_64-w64-mingw32` and this holds the include, bin, lib, and share folders. I then ran the following in command prompt: gcc testsdl.c -o a.exe -IC:\\SDL2-2.0.8\\x86_64-w64-mingw32\\include\\SDL2 -LC:\\SDL2-2.0.8\x86_64-w64-mingw32\\lib -w -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2 (Let me know if I didn't do this correctly btw) This still gave me the error I had above: c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16' collect2.exe: error: ld returned 1 exit status As far as the last part goes I couldn't find a way to run the sdl2-config file, but FUZxxl stated it probably was a fact that there is something wrong with defining a WinMain function. 
I've been meaning to make a start with Bullet for a while now, and I primarily work in C, so I'm definitely going to keep an eye on this.
Alright I tried adding -luser32 and -lgdi32 and still got nothing and I was going to give up for the day but found [this](https://stackoverflow.com/questions/17048072/sdl-2-undefined-reference-to-winmain16-and-several-sdl-functions) which said to put `#define SDL_MAIN_HANDLED` before anything and it actually worked. I'm still not sure why it worked and I'm probably just side stepping the problem here so I should figure this out at some point but right now I'm just happy it compiled. I appreciate all the help thus far though so thank you for that.
I've read a good chunk of Understanding the Linux Kernel from OReilly, but it was just a tough read; really dry. Is this one written less like a manual?
That's because SDL defines main (or WinMain) somewhere in it's depths. 
Exactly. If you just want to learn C, then learn it on Unix, in a real Posix environment. If you need to learn C *on Windows*, then learn it under Visual Studio, since that's the industry standard. That's what I said in my [other post](https://www.reddit.com/r/C_Programming/comments/9jxoac/how_to_practice_c_programming_on_windows_which/e6v5oau/).
I would recommend the book. It is very detailed and comprehensive. I use it quite often as a book that I consult while programming, but I guess it could be a little bit dry if you want to read it cover to cover. As a side note Kerrisk also offers training courses that I would very much recommend if you have that opportunity. I have taken the 5 day Linux/UNIX System Programming course, and it was the best training I have ever had.
Please be civil.
Try the GNU Scientific library: https://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html
On Linux?? Or however the Window subsystem thing works?
I'd stick with Code Blocks for now. 
&gt;C code on Windows Does this include C++? Or for some reason is C++ more pleasant than C to work with on Windows?
Chess
On Window's linux subsystem.
Codelite + MSYS2
I don't see where 'a' is defined (so I'm not sure how this compiles in the first place). And normally you wouldn't be able to assign 'string' using = like that - You'd normally have to use strcpy().
This book seems great, but at $75 for something written roughly 8 years ago targeting something changing as fast as the Linux kernel, I am worried it isn't as good as it should be. For example, I do not see any mention of eBPF, kernel name spaces, the various async polling API's like [this](https://lwn.net/Articles/743714/), spectre/meltdown, and btrfs. 
Good reference for system programming fundamentals, but missing "2.0" features. 
When you declare a sting like this char *string = "test test"; You are actually making a pointer to a string literal. String literals cannot be modified. It causes undefined behavior. In your specific case, when you do *string = 'j'; you get a segmentation fault. Declare the string as a local array and use the literal only to help initialization: char string[] = "test test";
If it doesn't return anything then what happens? I've seen situations in C++ where a function is declared to return something but it doesn't (programmer forgot to add a return) and the compiler compiled it (probably a compiler bug), and when it ran, bad things happened. In C99 does it return some default value?
In both C99 and C++, specifically for main functions (and, in case of C, there‚Äôs an additional requirement on the return type), that default value would be 0. Here‚Äôs [a post](https://stackoverflow.com/questions/13545291/can-i-omit-return-from-main-in-c) covering it. 
Write a trivial web app in JS with text entry. Write a service in C which acts as a back end to give the app predictive text completion.
Do not spam.
Please indent any and all code by 4 extra spaces to make it readable.
No blog spam please.
What do spectre/meltdown have to do with the Linux programming interface?
Now try making them generic.
Waste of time. There's just no good way to do generics in C, the approaches are all messy and error-prone. Also, people probably won't use this library anyway and roll their own implementations for basic algorithms and data structures like this, as is the C way. I think the library served its purpose for the author as a way to understand algorithms and practice implementing them.
You're inverting cause and effect here. I said to make it generic exactly for learning purposes.
How you can close that in single macro like [STAILQ\_FOREACH](https://www.freebsd.org/cgi/man.cgi?queue) one?
Try implementation a hash/dictionary. AB Tree, BFS and DFS
It isnt
and integer variables
This subreddit is about programming in C, your post is off topic. Please don't post content that is off topic.
It's kind of manual like, but I enjoy reading it anyway. That, I think, is because Kerrisk has really good writing skills. It's a book you'll find yourself coming back to as it has great code examples.
Depends on the data structure. Intrusive data structures actually work pretty well for most things (linux kernel uses them).
Uhh preprocessor
Why no headers? I'm genuinely curious.
Most people on here could write the problem, and I've included the pseudo code below for you to look at. But, first, try something else. Imagine that the problem was for \*you\* to do it, not the computer. You are going to sit at a table, and first graders are going to walk by and say a number to you. Your job, after they have all walked by, is to say what the biggest and smallest numbers stated were. &amp;#x200B; Would you need to record every number? How many values would you have to keep track of? If it's not clear, imagine instead that you are told to keep track of the largest number only -- could you do it for an entire school's worth of children without writing anything down? &amp;#x200B; Ask for the first number Set the minimum and maximum value to this number. while the number isn't -99 ask for another number if the maximum value is smaller than the number, set maximum to the value if the minimum value is larger than the number, set the minimum to the value &amp;#x200B;
Do Dynamic Programming algos next!
 P0: flag[0] = true; \\CONTEXT SWITCH P0_gate: turn = 1; while (flag[1] == true &amp;&amp; turn == 1) { // busy wait } // critical section ... // end of critical section flag[0] = false; ------------------------------------------------------------------- P1: flag[1] = true; P1_gate: turn = 0; while (flag[0] == true &amp;&amp; turn == 0) { // busy wait } // critical section ... // end of critical section flag[1] = false;
@ u/PopeThistleBottomII It should work with the latest GIT version, although I'm not actively working on it, I'm happy to update / bug zap / add missing functions as required - just pm me....
Do people typically reimplement data structures for every type they need it for? The last project I did in C I tried making a generic hashmap and it worked out ok but it was a small project. I‚Äôve always wondered this though. One of the biggest criticisms of the go language is the lack of genetics but go seems to have more in common with c than it does with languages like python or something like that. What is the typical solution for generic logic? 
Not OP, but I usually don‚Äôt have many headers cause I usually do unity-builds 
`void*`
I know, my comment was meant to be commiserating. Other people had already answered the question when I showed up.
bad practice to not have headers
I was planning on attempting a data structure / algs project like the authors post here, do you really believe it is worth it to try and make them generic? Just for learning purposes, I guess. 
thanks
Why can't anyone say thank you? 
(You will need to move your definition of `struct freq` outside of the function, in global scope) You can use the qsort function to do this: qsort(s, sizeof s / sizeof *s, sizeof *s, compare_freq); Those 4 arguments are: a pointer to the beginning of the array, the number of elements in the array (6), the size of each element in the array, and a function that compares two elements in the array. That doesn't work yet because you need a `compare_freq` function, which you have to define yourself. That comparison function must look like: int compare_freq(void const *a_, void const *b) { struct freq const *a = a_; struct freq const *b = b_; // ... return negative if a &lt; b, 0 if a == b, positive if a &gt; b } Because of how the qsort function is written, the parameters to `compare_freq` *must* be of type `void const *', even though you know their actual type. Let me know if that helps, I'm glossing over a few details and I don't know what level you're at with C.
 static int compare_freq(void const *a_, void const *b_) { struct freq const *a = a_; struct freq const *b = b_; } void calculate_and_display( int *array, int num) { int i, j; int frequency[6] = {0}; for(i = 0; i &lt; num; i++) { for(j = 0; j &lt; 6; j++) if(array[i] == j+1) frequency[j]++; } for(i = 0; i &lt; 6; i++) { s[i].roll=i+1; s[i].result = (double)frequency[i]/num; qsort(s, sizeof s / sizeof *s, sizeof *s, compare_freq); printf("\nYour Roll: %d, %f\n", s[i].roll, s[i].result); } } Okay, I wrote it like this and its displaying the results but they're not in decreasing order. I moved the function definition outside too. What am I doing wrong?
1. You wont your qsort to come *after* the loop. It won't work unless *all* of the results are calculated already. Make one loop to set the `.result` field, then do the qsort(), then make a separate loop after that to print them all out. 2. Your compare_freq must return something! `return (int)(a-&gt;result - b-&gt;result);` is probably the simplest logic for a return. That will return positive of a-&gt;result &gt; b-&gt;result and negative if a-&gt;result &lt; b-&gt;result, which is what you want.
 static int compare_freq(void const *a_, void const *b_) { struct freq const *a = a_; struct freq const *b = b_; return (int)(a-&gt;result - b-&gt;result); } void calculate_and_display( int *array, int num) { int i, j; int frequency[6] = {0}; for(i = 0; i &lt; num; i++) { for(j = 0; j &lt; 6; j++) if(array[i] == j+1) frequency[j]++; } for(i = 0; i &lt; 6; i++) { s[i].roll=i+1; s[i].result = (double)frequency[i]/num; } qsort(s, sizeof s / sizeof *s, sizeof *s, compare_freq); for(i = 0; i &lt; 6; i++) { printf("\nYour Rolls: %d, %f\n", s[i].roll, s[i].result); } } Okay I changed it to this but its still not working.. Thanks for helping me this far tho
This seems like a parsing problem -- you likely can do it as a recursive desent parse, so take it one character at a time through a state machine. 
Whoops! I didn't factor in the fact that the `.result` values are doubles (and all less than 1)! The compare function is always returning 0, saying they're equal! You could change your comparison function to use an if statement, or change it to something like: return (int)((a-&gt;result - b-&gt;result) * 1000000); It's kind of ugly, but it works.
Design. Will this scale? Is this easily understandable or expandable? How efficient or inefficient is the design? Design impacts the occurrence of bugs and the quality of contributions to a codebase.
Are you reading it to review it from a functionnal point of view, to understand a specific part, to discover it, or to find security issues? To discover a piece of code my method is to focus on a feature and follow it from start to finish. For example if I were to read a web browser I'd choose to see what happens when I click on a link up until the page is displayed and follow the flow of the code that way, ignoring all edge cases (for the moment). I'd also focus more on headers, struct definitions and interfaces since those (should) allow a raw understanding of what's going on without all the messy details that you don't want if you're just wondering how things work. Also you'll want to have a look at any kind of "utils.c" file since those are likely to be functions and structs that are commonly used throughout the code. If you're looking for bugs I'd recommand focusing on loops. This is generally where the scary stuff is present. Also if you're passing through code and notice that you decided not to read a section because it looks boring, come back and read it with attention because it's likely that you or your coworkers didn't read it well either which means that it's more likely to have bugs. For security issues I'd start by common mistakes such as misuse of known bad functions, then list entry points, exit points, notice anything that comes from the user or could end up badly and "link the dots" between entry points and exit points to make sure that there are security checks along the way.
A good single malt scotch? Glenfiddich would be my choice. Then, you go and distill all the comments. Tools like cflow and doxygen are a huge help if you're cleaning up an "Italian Job". 
do they mix camel case with snake case!!
What do you mean?
Type of that initialize function is a structure and i want to know how that works because that doesn't make any sense to me
The type is of pointer to BSTree, the function simply returns the null pointer because an empty tree should have no nodes. 
The thing here is that the initialise function's return type is "pointer to BSTnode". And a pointer in C and C++ can always be NULL. Thus this function just returns an empty (NULL) pointer. Mind you, you can't do anything with the NULL pointer returned by this function, because if you were to dereference it, you would get a segmentation fault.
Am I the only one who's irrarionally bothered by the 2 different spellings for 'initialize'? For OP, the return type of the function is not a struct, it's a pointer. And even if it was a struct, it would be perfectly valid, a struct is a value, functions return values (unless they're of type `void`). Really gonna have to explain what you need here.
&gt; Am I the only one who's irrarionally bothered by the 2 different spellings for 'initialize'? I can't speak for everyone else, but as an English-speaking non-American, I often switch between my native English dialect for writing documentation, and American English for code. E.g., "to change the colour, use the set_color() function". If you use non-American English in code, you can end up with weird clashes and inconsistencies when you use other people's libraries.
Comments in the code, code layout and code efficiency.
Well that'd be one thing, but it's written one way in the section title and another in the section title, and back to the first in the code.
Get used to formulate your definitions precisely, that will help you immensely in future, when problems become more complicated. Right now, according to your definition of the valid expression all the expressions above are valid.
Sounds dangerous. I recommend rewriting everything from scratch, it's the only way to make sure you understand it.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/graphicsprogramming] [First time using C for something like this, hoping someone could review my library that uses ffmpeg](https://www.reddit.com/r/GraphicsProgramming/comments/9kelrc/first_time_using_c_for_something_like_this_hoping/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Consistency. 
I prefer a Pappy Van Winkle. If I'm really bottom barreling it and don't wanna remember what I did to the code I'll go cutty sark or j&amp;b. 
 function compare_freq(struct freq *a, struct freq *b){ return (a-&gt;result &gt; b-&gt;result ? 1 : (a-&gt;result &lt; b-&gt;result ? -1 : 0)); } this is more robust and I wouldn't say it's less readable, especially if context makes it clear that it's a comparison function. The better approach imo, would be to not divide the frequency by `num`, since it's the same accross the board, sort them by frequency and only do the division when displaying to avoid all the floating point problems you may get by comparing floating point numbers.
I'm more bothered by `return(NULL);` instead of `return NULL;`. Does the textbook author realize it's not a function?
Because the block size is 64 bytes and the data is 8 bytes (64bits). In practice if the CPU has a good prefetcher you won't get any cache misses at all on the inner loop.
This
Said every one of us with the purest of intentions!!
&gt;Do people typically reimplement data structures for every type they need it for? That is one way to do it. The downsides are obvious. I personally like to use the `void *` approach, where you store a `void *` as the data type in the `struct` and add a `size_t` attribute for the amount of bytes the actual data type, that you want to put in, requires. Downsides are that after initialization, C allows you to store a different type (since `void *` is implicitly casted) so it's unsafe. Another downside is that C doesn't have the `vector&lt;SomeObject&gt;` syntax of C++ so you would end up with `vector` and have to keep track of the data type you have stored in that vector. Also, it has the run-time memory cost of another `size_t` field, if that is an issue. The macro approach has poor readability and maintainability. Another way is using an external tool that takes a C file, generates a version of a data struct for every type you need, and puts out another C file. So, basically another preprocessor and a manual version of C++ templates. So, in C you pick your poison. It's a matter of trade-offs (and it is in C++ too because templates are convenient but very complex).
Also, think a bit like a historian -- why is the code this way? &amp;#x200B; * Did the writer learn "on the job"? * Did the specifications change while he was writing it? * Was the original design simple and elegant, but reality hit and it had to grow a bunch of warts to deal with corner cases? * Was it a team that wrote it, with each designer doing everything he could to have his own area to write in, making integration clumsy? * Did the writer know for a fact he would not be involved in maintaining it? Or, more importantly, did he think he'd get paid more later to maintain it? &amp;#x200B; And, less historically, "Is it tested? Are there tests?" &amp;#x200B;
is there a worse brand of scotch out there? im not being sarcastic. i literally cant think of a cheaper low quality bottle of single malt. 
I don't think your question should be read as "how dare you read someone elses code" or "why bother reading code?" But rather "What is your main reason for examining the code?" For example, reading code to see how someone used an API is different than reading code for how someone solved a hard problem, and different from reading code that you are now responsible for. 
Yes. There's at least 3 ways in which this can be done, all 3 put the preprocessor in a spotlight, and you'll learn valuable lessons.
to understand what they were trying to do.
&gt;camel case with snake case You need to mix that with the Hungarian notation for maximum obfuscation power
dromedarisCase for the win!
Intent and clarity of this intent. You want the computer to do something, and it should be IMMEDIATELY obvious: - What it is that should happen (the 'observable effect' of the code). - Why the given approach to make this happen was chosen. (functional constraints? operational constraints? maintainability constraints? which ones, and why are they important here?) - How the code might evolve in the face of time.
I did that to good effect on the last project I led. We used a vendor library that was all Camel, and all our code was snake. It was instantly visible where we called the vendor.
Looks cool. How would I use this?
Why would doing unity builds result in less headers?
&gt;A good whiskey? [Tullamore Dew](https://www.tullamoredew.com/en-gb/our-range/12-years-old-special-reserve/) would be my choice. FTFY 
Some preliminary questions: do you know what printf("%4d") truly does? The way you used it is not quite right. %d will print an integer number, and the 4 indicates the 'width' you want it to print. If your desired output is '4', then you only want the width to be 1 right? Do you know the difference in behaviour of the "/" and "%" operators? I.e. if you have 4716/1000 and 4716%1000, what will be the result in each case? 
Why not just continue the way you are? print("%d%d is issuer.\n", a%1000, b);
Not a bad suggestion. You may not actually have to finish rewriting everything to gain enough understanding to start working with someone else's code.
BactrianCase for types, dromedaryCase for variables.
Because if I‚Äôm including .c files directly, there are less occasions where I would need a header file. And if I don‚Äôt need a header file, I won‚Äôt make one. Therefore I have less header files then I would with an incremental build 
It turns out that yes, you can use a preprocessor command while inside a macro function invocation. That's nice to know. But along the way, I found out a *much* worse problem: you lose debugging info! Obviously it will depend on your compiler, but GCC (even in the bleeding edge 8.2) connects all operations done by a macro function to the line where the macro function was first invoked. When you define a function like this, you don't get line-by-line stepping information; the entirety of the function is considered to be part of the same line. It's blatantly apparent in the [Compiler Explorer](http://www.godbolt.org/) because everything comes out the same color. Yet another reason to *never* use this horrible idea.
readability
My favorite code is code where, no matter how difficult the code is, because of the way it's been broken up, it is absolutely clear what the author thought it did. Because you look at code when you're debugging.
Passwords, API keys, private keys and other secrets that should never be in a code repository in plaintext!
modify the code so that the printing of the suit and the printing of the face of a card are each handled by a function. Write the functions so that everything for printing is contained inside the function.
You still haven't followed the rules of the subreddit. Tell us what you've tried and what you don't understand, and then maybe you'll get an answer. Nobody is going to do your homework for you. You have to show us that you want to understand rather than be spoon-fed answers. If you really have no clue where to start, I strongly suggest speaking to your professor before making any more posts on this subreddit. If not that, tell us specifically what you can't figure out and then you'll get an answer.
Everybody is joking about tabs vs. spaces, which was predictable, but the deeper question is: Are they following the code standard? I hope your organization has one, and that it sets more important rules than tabs vs. spaces. If the author doesn't follow the code standard, then he probably doesn't follow many other rules, either. Also, he's asking you to read something that's unnecessarily hard to read. Because readability is what your code standard emphasizes, right? Next, make sure it passes all the tests you have, and static analysis tools. If it fails any of those, you need to look no further, and can send it back.
The first step here is to define what the interface to this function needs to be. What parameters does it take, what does it do, and what does it return? For example, is it supposed to receive a rank and suit as parameters, print out the card, and return nothing? Is it supposed to receive those same parameters, build a string with what should be printed, and return that string? Is it supposed to take no parameters, print the name of all the cards, and return nothing? Or something else -- your description is pretty vague so far. Once you define these three things, you might consider writing some pseudocode for what the function should do. And then, you're ready to write the function. Write a prototype based on what you determined above, and then write the function body according to the pseudocode you sketched out. Write code to test your function, and then modify your program to use it appropriately.
This is how we did code reviews at my old job. We'd have the author present the code on a projector in front of a group of senior devs (make sure that somebody who has a passing knowledge of the affected area of code is also present), and would ask them to walk us through an example feature, and how it handles a certain input (like a request), then watch for possible edge cases while they show the code, take note of code smells, and ask questions about edge cases when we felt it was useful to do so. At the end, we'd check that necessary test coverage was in place, and compile a list of changes that still needed to be made to get this code accepted (or decide that it was good enough).
I agree that you need to look for those, but FIRST?
It's `const char *node`, not `const char node`! &gt; The function `getaddrinfo()` takes a string describing the node and the service each for which it shall return a linked list of structures describing available addresses to bind to in `res`, based on the passed `hints`. More or less, but this obviously takes knowledge of the function which I got through reading the manpage and beej.us' Guide. Without prior knowledge all one can do is to describe the parameters it gets which are two strings (probably) and a pointer to a structure, all of which are not to be modified. And then a pointer to another point which will probably be filled by the function based on the other parameters provided. Given also the argument names it's rather clear that node specifies some general point in a graph or network and service something this node can provide [which can be "HTTP" or equivalently "80", etc.]. Hints is also rather clear that it shall help the function to determine what to fill into `res`.
Have you confirmed args.buffer-&gt;size is getting incremented and decremented correctly? I didn't look too closely, but you might be passing something by value instead of by reference and things are getting out of whack.
&gt; since you're accessing an integer on most modern platforms that access is already atomic. "Most modern platforms" the key phrase that makes this problem. In portable C you're not allowed access that variable without synchronization, even if there's only a single writer. And even if you're on a modern platform, the compiler may *still* exploit the lack of synchronization to make unintended optimizations, just like what's happened with OP.
&gt; In portable C you're not allowed access that variable without synchronization, even if there's only a single writer. I'm pretty sure that's not actually defined as such in the C specification, if it is please point it out to me. In fact, this asynchronous use is specifically listed as an acceptable case for volatile. &gt; And even if you're on a modern platform, the compiler may still exploit the lack of synchronization (e.g. undefined behavior) to make unintended optimizations, just like what's happened with OP. Which is why you use volatile, but are not _required_ to use either mutexes or atomic intrinsics... and there are very few platforms where you would need intrinsics to operate on a 32bit value.
ISO/IEC 9899:2011 5.1.2.4-25: &gt; The execution of a program contains a data race if it contains two &gt; conflicting actions in different threads, at least one of which is not &gt; atomic, and neither happens before the other. Any such data race &gt; results in undefined behavior. Even with `volatile` it's still a data race, and therefore undefined behavior. Being undefined behavior is why the compiler is allowed to turn OP's code into an infinite loop despite the underlying platform.
You should multiply by 100 and work with an integer number of cents/pennies. Doing money in floating point is doomed to failure. https://0.30000000000000004.com/
Oh, that makes sense. I wasn't using my brain there.
 return (a-&gt;result &lt; b-&gt;result) - (a-&gt;result &gt; b-&gt;result); avoids all issues with scaling and overflow and whatnot. `return a - b;` and its variants are all way more difficult to get right.
Concur. Do everything with pennies and integers. Comparing for exact values on floats is mission fraught with peril. Peril I say!
You should generally avoid floats unless you absolutely need them. You must be especially careful when comparing floats. Often times they will not hold the value you believe they do. $0.26 in memory might actually be more like 0.26000000000456. 0.26 != 0.26000000000456 so the comparison will return false and you'll be left scratching your head as to why. These problems compound and snowball and you lose more and more accuracy. [Read about fixed point arithmetic](https://en.wikipedia.org/wiki/Fixed-point_arithmetic). Instead of using dollars and fractions of dollars, use all pennies. So instead of giving someone a dollar fifty, give them 150 pennies. Now you can work purely in integers and avoid all the nasty problems that come with floating point math. \* \*Fixed point arithmetic has its own set of problems that you should also read about. You have to be especially careful that your value is large enough to hold the scaled up numbers. You won't need to worry about this for your particular program here, though. 
**Fixed-point arithmetic** In computing, a fixed-point number representation is a real data type for a number that has a fixed number of digits after (and sometimes also before) the radix point (after the decimal point '.' in English decimal notation). Fixed-point number representation can be compared to the more complicated (and more computationally demanding) floating-point number representation. Fixed-point numbers are useful for representing fractional values, usually in base 2 or base 10, when the executing processor has no floating point unit (FPU) or if fixed-point provides improved performance or accuracy for the application at hand. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Self documented?
I fear you're being too lenient here.
Most businesses don't have the resources to have their code base rewritten everytime they hire a new developer.
Concur: My first paying job in computers ‚Äî a summer internship ‚Äî we wrote a loan management system that used floating-point dollars everywhere. I can't begin to tell you what a nightmare that was.
Say it's a web server, you can write a simple web server in a couple of hours even if you have never written a web server before then you can take the ideas you have about how you might implement more advanced features and sit down and look at the code you were assigned to work on.
A few thoughts: 1. You are asking for the value again if it's negative. Probably just `abs` the value, print the informational, "I owe you," and continue. 2. As others have said: floating point sucks. Convert to integer "cents" and work on that. If not, always round the value when working with it. Always think of floating point values as being prefixed by "approximately..." 3. When the only difference between several steps in your program is a constant, consider consolidating. Here's an example to get you thinking in the right direction: Program: /* UNTESTED PSEUDOCODE!!! */ int coin_values[] = [25, 10, 5, 1, -1]; int amount_int = int(get_float("How many coins?")*100 + 0.5); for(int *value = coin_values; *value &gt; 0; value++) { if (amount_int &gt;= *value) { int count = amount_int / *value; amount_int -= *value * count; coins += count; } } Good luck! 
From which header are they including all these diabolical macros?
Reddit ate the *, that's why the rest of the text is in italics. If only the OP had put it in backticks.
&gt; Why should I be concerned with atomicity when all I have are readers? Because the standard says it's a data race and is therefore undefined behavior. Invoking undefined behavior means your program may not produce the correct results. Even if it *currently* produces the correct results regardless of this, it may not do so with different inputs, different compilers, or even different versions of the same compiler. Don't rely on it. Compilers [use undefined behavior to reason about optimizations](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html). In particular, they assume undefined behavior simply doesn't happen, and use this to prove its optimizations. This is probably the source of your issues. For example, the compiler might cache the value of `thread_bit` or `buffer-&gt;size` since, by not synchronizing, you've communicated that it's not expected to change. Even more subtly, since you aren't synchronizing, the stores to `thread_bit` and `buffer-&gt;size` may be reordered, both by the compiler [*and* by the CPU](https://preshing.com/20120515/memory-reordering-caught-in-the-act/). That is, threads might be terminating early because `thread_bit` is *actually* being cleared before `buffer-&gt;size == 0`. Proper synchronization fixes this. &gt; Read-Writes to buffer_t b are synchronized. The load of `buffer-&gt;size` in the `while` condition is not synchronized and is the source of another data race ‚Äî more undefined behavior. 
@skeeto You are absolutely right and I hadn't even considered that. I have modified the consumer thread to reflect your insight, please pardon the somewhat sloppy syntax I just wanted to confirm it even works. &amp;#x200B; /* consumer thread */ void *consumer(void *param) { // dereference param into thread_id thread_args_t args = *(thread_args_t*)param; buffer_item item; while(TRUE) { /* acquire full lock */ sem_wait(&amp;full); /* acquire mutex lock */ pthread_mutex_lock(&amp;mutex); if(thread_bit || args.buffer-&gt;size &gt; 0) { /* critical section */ /* remove item */ if(remove_item(args.buffer, &amp;item)) { fprintf(stderr, "Buffer empty...\n"); fflush(stderr); } else { printf("CONS #%d: --- %d consumed\n", args.id, item); fflush(stdout); } } else { /* release mutex lock */ pthread_mutex_unlock(&amp;mutex); /* signal empty */ sem_post(&amp;empty); return NULL; } /* release mutex lock */ pthread_mutex_unlock(&amp;mutex); /* signal empty */ sem_post(&amp;empty); } } And the output shows expected results. ... PROD #1: produced 8 --- PROD #0: produced 9 --- CONS #0: --- 6 consumed CONS #2: --- 7 consumed PROD #4: produced 10 --- CONS #3: --- 8 consumed ~&gt; Killing PROD thread 0 ~&gt; Killing PROD thread 1 CONS #3: --- 9 consumed CONS #1: --- 10 consumed PROD #2: produced 11 --- CONS #0: --- 11 consumed ~&gt; Killing PROD thread 2 ~&gt; Killing PROD thread 3 ~&gt; Killing PROD thread 4 Why don't my consumer threads get cleand up though?
Here, you dropped these: \*\* I think that it looks pretty simple. I don't see where visualization is really necessary for something like this. 4 parameters: 2 strings, one struct pointer, and one struct double pointer. Looks like it's asking you to supply a name and a service, optional hints, and then the results go wherever res is pointing.
If you‚Äôre using a distro SDL, you should be able to fetch just the debug symbols for it. Otherwise, can you breakpoint on printing the leak message and do `up` in `gdb`? If you can get a specific [ER]IP, you should be able to use /proc/PID/maps to find the specific module, probably also the function if you get a map of the symbols in the DLL and offset things properly.
I can see why they put the intern on that...
For anyone who is interested, [here](https://pastebin.com/aPyWjhWi) is my final solution. `./main.out 7 2 2` produces the following output. I've tested it and it works pretty consistently. PROD #0: produced 1 --- PROD #1: produced 2 --- PROD #1: produced 3 --- PROD #1: produced 4 --- PROD #1: produced 5 --- CONS #1: --- 1 consumed CONS #0: --- 2 consumed CONS #0: --- 3 consumed CONS #0: --- 4 consumed PROD #0: produced 6 --- PROD #0: produced 7 --- Exiting .. CONS #1: --- 5 consumed CONS #1: --- 6 consumed CONS #1: --- 7 consumed ~&gt; Killing PROD thread 0 ~&gt; Killing PROD thread 1 ~&gt; Buffer contains 0 items ~&gt; Killing CONS thread 0 ~&gt; Killing CONS thread 1 Destroying mutex: Done Destroying semaphores: Done END &amp;#x200B;
You should consider creating a function that takes the coin value; 0.25, 0.10... and your current x value. That way you only have the logic once, the function is easy to test, and you can add support for new coin denominations.
Wow! This is awesome! Tons of thanks.
array 2 meaning an array with 2 elements containing pointers to arrays with 3 elements? array 3 meaning an array with 3 elements containing pointers to ints? Why doesn't array 3 have a name? Is it some kind of anonymous array? 
You have to explicitly check `if (input1 == 'r' || input1 == 'R')` Yup. Funny side note, back when I first started programming I thought `if (input1 == ('r'||'R'))` would work, lol.
These declarations are quite rare. It's okay to be puzzled by them.
UpperCamelCase for types, dromedarisCase for functions, snake_case for variables.
will be taken care next time by me.
The problem is that the compiler is allowed to assume the absence of unsynchronised concurrent access to objects, thus allowing it to abstain from reloading the variable. This can be fixed by declaring the variable as `_Atomic` or `volatile`.
If you want a general type, C follows an inside-out right-to-left rule for reading types. Start at the name of the variable ("a"). That's the "inside". Now work your way out, first looking right. 1. To the right of "a" is [2], which means "array of size 2". "a is an array of 2 somethings" 2. We can't get out of the parentheses without looking to the left first, and we see a \*, which means "pointer". "a is an array of 2 pointers to something". 3. Now we're outside the parentheses. First look right. We see a [3], which means "array of size 3". "a is an array of 2 pointers to arrays of 3 somethings". 4. Now look to the left. We see a \*. "a is an array of 2 pointers to arrays of 3 pointers to something". 5. The only place left to look is the "int" all the way to the left. "a is an array of 3 pointers to arrays of 3 pointers to ints". Or just use cdecl
&gt; Listed below is the code I have written, when I enter any number of a/b/c, the function calculate_discriminant sees them as 0 and gives 0 back. What specific inputs have you tried? I just threw a few random number in there, and I didn't get zero. Also, how do you plan on calculating the square root function?
I tried: 1, 3, 2 3, 4.5, 9 5, 5, 5 4, 1, 25 &amp;#x200B; All return 0 to me, still working on it, but for calculating the squareroot and the solutions I wrote this up untill now: &amp;#x200B; int Real, Imaginary; &amp;#x200B; /\* Real different roots \*/ if (D &gt; 0){ &amp;#x200B; x1 = (-b+sqrt(D))/(2\*a); x2 = (-b-sqrt(D))/(2\*a); printf ("%lf\\n%lf\\n", x1,x2); &amp;#x200B; } &amp;#x200B; /\* Real equal roots \*/ else if (D == 0){ x1 = x2 = -b/(2\*a); printf ("%lf\\n", x1); } &amp;#x200B; /\* Imaginary roots \*/ else if (D &lt; 0) { &amp;#x200B; Real = -b/(2\*a); Imaginary = sqrt(-D)/(2\*a); printf("root1 = %lf+%lfi and root2 = %lf-%lfi", Real, Imaginary, Real, Imaginary); } &amp;#x200B;
&gt; 1, 3, 2 So think about what `scanf` is going to do when it gets to the comma. Can a floating-point number contain a comma? No, it can't. That means `scanf` is going to give up right there.
Not what I meant, sorry for that. I put in: a=1 b=3 c=2 &amp;#x200B; No commas or anything, just 1 &lt;enter&gt; 2 &lt;enter&gt; 3 &lt;enter&gt; Same applies to the other values listed above