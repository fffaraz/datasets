this is usually the point where i resort to unit tests
Print out each step and compare it to what you calculate in your head. &amp;#x200B;
I've tried out the leap year with many different dates yesterday and they were all working as they should be
How does one do that? I'm new
oh, well, you must be smarter than me then.
Look for "CSharp"
Okay, get a pen. and a piece of paper. Write down every part of the calculation as you calculate it. Now edit your program. Add printf as you go through each stage. For example, printf("The cardinal day is %d\n", cardinal_day); Now figure out where it's messing up. Keep adding more and more prints until you find it. 
Then your understanding of it is wrong, because the code is wrong.
/r/csharp
Day of the week is right because it only calculates it for the 1st of January for every year, so the day or month isn't needed, and only the year. Calculate ordinal day works fine (preparing to get downvoted). It'll be fed off to another function which I havent yet created as i'm stuck on this one.
Because it prints a value between 0 and 6. 0 is Sunday, 6 is Saturday and the numbers inbetween are Mon-Fri. That's how the algorithm works. Literally right [here](https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Gauss.27s_algorithm) if you don't believe me.
goodbye.
xD
Yeah the way you've written is how i've got it now.
 ".............., I would consider if it would be better to have several global variables or to put them all in a struct and if I choose a struct I would consider if I should make my struct a global variable or declare it in, say, the main function and pass it as an argument to the different functions that read and write to your file......... " This is a good point. I would declare a struct as global variable. Passing it as an argument to different functions seems to be a good approach but declaring it global seems easy (as modification in existing code). Which one is better? Also, I will need to write to file continuously as user can call an API to read this file at any point of time i.e. during download or after. &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt; Day of the week is right You need more parentheses to convert the Guass's algorithm to C form. The algorithm is: R(1 + 5*R(year - 1, 4) + ... where *R(y, m)* is equivalent to *y%m*, and you've translated this to: ((1 + 5 * (year - 1) % 4 ... But the correct translation would be ((1 + 5 * ((year - 1) % 4) ... This is because \* and % have the same precedence, so are evaluated left-to-right. So your code multiples the year by 5, *then* does the modulo. But you need to do the modulo first, *then* multiply by 5.
I've done network scripts in C (sockets) since I wanted to learn how they work. Now that I know that, I'd feel more comfortable doing it in Python or something else.
Yeah by it being right I meant that the way I've done it is, but not necessarily the output/algorithm. Also, thank you so much. I added the extra parentheses and the output is what it should be!
use an if, or something like that: `case 1:` `case 2:` `case 25:` `printf("range 1-25\n");` `break;`
**Sieve of Eratosthenes** In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially test each candidate number for divisibility by each prime.The earliest known reference to the sieve (Ancient Greek: κόσκινον Ἐρατοσθένους, kóskinon Eratosthénous) is in Nicomachus of Gerasa's Introduction to Arithmetic, which describes it and attributes it to Eratosthenes of Cyrene, a Greek mathematician. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I always write them first. Helps me map out the code and where it needs better refactoring. By the time they all pass my code is complete.
Definitely, Beej's C Guide is the bomb! However, most people wouldn't do that regularly ;) I have a soft spot for C because it's my first language, but I wouldn't write things in it particularly regularly if there are better options. 
You probably want `((Y)%(M))` or something. Otherwise you have the same issue. Or just write an inline function instead of a macro.
Our data structures class forces us to make our own in C from scratch. I love C so it isn't a big deal but god fucking damn, it really starts getting to your head after a while. Just let me use literally anything else with an inbuilt data structure and I'll be fine damnit 
Our Data Structures class uses C++, though I haven't gotten to the class yet.
In is\_leap\_year, you should have used ` else if`. Now you're overwriting previous results.
The book says * and ++ has same precedence so i think the thing in parentheses should be doing firstly.
Thanks, so the parentheses just make sure the addition of 1 is on pointer but not on the value, and ++ of the pointer is after the whole expression, right?
use a test image, some image that you know whats will be the results before apply the algorithm
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
(Pseudocode) If x == 1, then print(x++) will print "1" and print(++x) will print "2". In both cases x will be 2 at the end. 
`$ man operator`
The prefix ++ has the same precedence as *, so that might be the source of their confusion
Print the value of `operator` right after reading it.
Ahh makes sense. I wish I had knew about them before I started then :P I'd change it now but I don't want to mess it up even more. Quick question, I'm now trying to use the day of the week to calculate the ISO week date, but it seems to give me the wrong day of the week and I've got no idea why. I'm trying to get the day of the week for the date 26th September 2008, and it is a Friday, so I should be given a 5 as the output, but instead, I get 2, which also makes it calculate the week wrong. Any idea how to fix it? [My code is here](https://ideone.com/VXuUqx)
Line 42.
What about it?
Should be else if
[https://wikicoding.org/wiki/c/Tomohiko\_Sakamoto%27s\_Algorithm/](https://wikicoding.org/wiki/c/Tomohiko_Sakamoto%27s_Algorithm/) may help
Oh yeah, not sure why it's like that. I'll change it, thanks. Will this affect my answer at all for the ISO weekday?
Debugging tip : start simple and work your way up. Create a 2x2 grid. Set all cells alive. X X X X step through the code which calculates the next generation. You know the result should be . . . . so see where it goes wrong.
Thanks guys, now i understand.
Debugging tip : start simple and work your way up. Create a 2x4 grid. Set all cells alive. X X X X X X X X step through the code which calculates the next generation (`liveOrDie()`) You know the result should be X . . X X . . X so see where it goes wrong.
Can't really tell through the god awful formatting but I'd suspect you're iterating through garbage in memory
Thanks for the quick response, I'll look into more malloc tutorials, also sorry about the formatting, I just edited it with better spacing but for some reason it just reverted back to the current formatting I have. 
Okay thanks I'll make sure to do that next time, would you mind editing my code so that it prints out the stored result please, the answer is right, I just need it to print :/. 
OK, now that I can read it, a few minor code review points: You don't need to cast the return value of malloc() using standard C; malloc() returns `void *` which doesn't need a cast. If you're using Visual C, you have my condolences, and please upgrade to VS2015 release C or later. Likewise, `sizeof(char)` is always 1, so you don't need it. If your answer could be as long as the input, then you need to malloc one extra character for the terminating '\\0'. `char *answer = malloc(strlen(word)+1);` You're not initializing `counter`. I'm surprised your compiler didn't complain about that. Always compile with -Wall (dunno the Microsoft equivalent; sorry). Note that `tolower(word[i]) == tolower(word[j])` will be comparing word[0] to itself, word[1] to itself, and so forth. Is that what you wanted? It will also compare word[0] to word[1] *and* word[1] to word[0]. I.e. each pair of letters will be compared twice; is that what you wanted? In fact, given that every character will be compared to itself, and other possible dupes will be tested twice, I can guarantee that this will overflow the space you allocated. All bets are off once you do that. Finally, your final loop is searching answer for a terminating '\\0', but you never added one, so this loop will keep prancing through memory until it gets lucky and hits a zero. I would manually add a nul at the end `answer[index] = '\0';`. And once you've done that, you don't need to loop through the characters in answer at all, but simply do `printf("%s\n", answer);`
1) Turn on warnings on your compiler. If you're using gcc try adding `-Wall -pedantic`. 2) Read those warnings and take action. 
char *a = (char *) malloc(sizeof(char) * SIZEOFARRAY); //do stuff with the dynamic memory free(a); It's really that simple. And for other base data types, just replace all instances of 'char' with whatever base type it is. malloc(size_t size) returns a pointer to size many bytes of contiguous memory.
I'm not sure how you got this to compile, because gcc won't do it. Always compile with `-Wall`. Here's the issues that pop out to me: - You didn't include `stdlib.h`, so `malloc()` is undeclared and won't work properly. - You called `DuplicateEncoder()` before declaring it. You either need to put a declaration before `main()` or place the entire function above it. C compilers read code from top to bottom. - You're using double quotes when referring to a single `char` in an array. `"("` is a string literal of 2 characters, `(` and `\0` (the null byte). You need to use single quotes to refer to a `char`. The assignment of a string literal to a char is undefined behavior. - You're also not calling `free()` on `answer`, so you're causing a memory leak. - There's no need to loop through a `char` array and print each character. Replace the `printf()` loop at the end with a simple `printf("%s\n", answer);`
&gt;If you're using Visual C, you have my condolences, and please upgrade to VS2015 release C or later. &gt; &gt;Likewise, sizeof(char) is always 1, so you don't need it. &gt; &gt;If your answer could be as long as the input, then you need to malloc one extra character for the terminating '\\0'. char \*answer = malloc(strlen(word)+1); &gt; &gt;You're not initializing counter. I'm surprised your compiler didn't complain about that. Always compile with -Wall (dunno the Microsoft equivalent; sorry). &gt; &gt;Note that tolower(word\[i\]) == tolower(word\[j\]) will be comparing word\[0\] to itself, word\[1\] to itself, and so forth. Is that what you wanted? It will also compare word\[0\] to word\[1\] and word\[1\] to word\[0\]. I.e. each pair of letters will be compared twice; is that what you wanted? &gt; &gt;In fact, given that every characte As for comparing each character, I absolved that issue by reseting the counter to 0 on every run of the outer loop. This is a coding challenge and the answer is correct, everything is right I just need to correctly store the answer my pointer. If I replace answer\[i\] = ")" and answer\[i\] = "(" with print statements I get the below outputs for the below inputs which is exactly what the challenge requests. Examples: "din" =&gt; "(((" "recede" =&gt; "()()()" "Success" =&gt; ")())())" "(( @" =&gt; "))((" &amp;#x200B; Thanks your answer it has been extremely helpful, I'm new to c and in python memory management isn't as important so this has been tuff, my teacher hasn't went over malloc yet but I'm trying to just figure it out prior as I want to get better at programming. 
The result is not right, I guarantee it. You simply didn't allocate enough space for the answer. Oh, I just caught one more error: `for (int j =0; j &lt;=strlen(word);j++)` loops one too many times. You want '&lt;', not '&lt;=' Assuming you *don't* want to compare characters against themselves, or compare them twice, then code your inner loop like this: for (int i = 0; i &lt; len; i++) { for (int j = i+1; j &lt; len; j++) { // Yadayada, not gonna do your homework for you } } answer[index] = '\0'; printf("Answer is: %s\n", answer);
Okay thanks for the response, I'm going to take a break from this and come back. Really appreciate you sharing the time. 
I tried that and found some errors (like putting c and r in the wrong places and putting + when it should have been -). Now it just repeats itself everytime and I can't figure it out. &amp;#x200B; `void liveOrDie(const int rows, const int cols, cell field[rows][cols]) {` `int aliveNeighbours = countNeighbours(rows, cols, field);` `for (int r = 0; r &lt; rows; r++) {` `for (int c = 0; c &lt; cols; c++) {` `if (field[r][c].current == ALIVE &amp;&amp; (aliveNeighbours == 2 || 3)) {` `field[r][c].next = ALIVE;` `}` `else if (field[r][c].current == DEAD &amp;&amp; aliveNeighbours == 3) {` `field[r][c].next = ALIVE;` `}` `else {` `field[r][c].next = DEAD;` `}` `}` `}` `updateField(rows, cols, field);` `}`
answer\[index\] = "()"; // THIS IS WRONG &amp;#x200B; answer\[index\] = '('; // THIS Puts '(' at answer\[index\] &amp;#x200B;
have you tried printf("%s\n", x.name); ?
Yes, you're using malloc/free correctly (though if malloc fails you will get a seg fault with the strcpy). 4 - Is printing the decimal value of ascii P, the first char in x.name 5 - Would print the address of x.name if you omitted the &amp;.
Ok, you are using `malloc()` and `free()` correctly, but I suggest to cast the pointer returned by `malloc()`: `x.name = (char *) malloc(15 * sizeof(char));` Now for 4 and 5: 4) You need to understand how strings are represented in C ([https://www.geeksforgeeks.org/strings-in-c-2/](https://www.geeksforgeeks.org/strings-in-c-2/)). Basically you are printing the decimal value ASCII code of the first character of your string, pointed by [`x.name`](https://x.name), that is P == 80 (look at the ascii table to lookup each character with the corresponding integer rapresentation [http://www.asciitable.com/](http://www.asciitable.com/)) 5) Here you are printing the address (in hexadecimal) of the [`x.name`](https://x.name) variable (using the &amp; operator)
Put 4 spaces before each line before pasting it here so it formats as code &lt;-- 4 spaces = code
&gt; Now what I'm unsure of is what (4.) and (5.) are printing. 4 is printing the ASCII value of the `'P'` character in "Player" as an unsigned integer (80). 5 is printing the address of `x.name`. Note, this is different from the address stored in `x.name` which you got from `malloc`. &gt; Also have I used malloc and free correctly? Yup. Specifying `sizeof(char)` is redundant, but it's not a problem to be explicit about what you're allocating, so that's just fine. You allocated more room than you needed ("Player" is only 6+1 characters), but that's not incorrect per-se. In this simple example you could have gotten away without using `malloc` at all (just have `name` be a pointer to the "Player" string literal), but I don't have a problem with it. &gt; And when is the correct time to use malloc? There's not really "correct time," only the times when it's the best tool for the job. That would be whenever you need to use dynamic memory: when you don't know the size of something until runtime, or when you don't know how many of something until runtime, or when you do know the size of something, but it would be inappropriate to be a local or global variable because it's too big. &gt; PS. what am I really doing with char *name ? What is it pointing at? `malloc` is providing you with a chunk of memory that's 15 bytes in size. `name` points to this place in memory, letting you access it.
Okay hold up, so 5. has a separate adress from what it is storing? I get the second part of storing an adress in x.name using malloc (assuming that's the 15 bytes provided by malloc.)? Also, since 4. is already printing the adress of x.name how do I print the adress within x.name? 
the function of (char \*) is to cast the pointer type, from void\* to char\*. this means that when you dereference the pointer, you read sizeof(char) byte in the memory address pointed by the pointer, and when you increment the pointer, you move the pointer sizeof(char) byte forward. For example, in your case you have [x.name](https://x.name) pointing to "Player", so: \- \*[x.name](https://x.name) == 'P' \- \*(x.name+1) == 'l' \- \*(x.name+2) == 'a' \- \*(x.name+3) == 'y' \- \*(x.name+4) == 'e' \- \*(x.name+5) == 'r' To explain the concept, if you cast the returned pointer to int \* type (assuming [x.name](https://x.name) is an int \* pointer) x.name = (int \*) malloc(15 \* sizeof(char)); you get 4 bytes when you dereference the pointer, so: \- \*[x.name](https://x.name) == "Play" \- \*x.name+1 == "er\\0" and the 4th byte is a random byte. If you want to understand more read this great answer on SO: [https://stackoverflow.com/questions/17260527/what-are-the-rules-for-casting-pointers-in-c](https://stackoverflow.com/questions/17260527/what-are-the-rules-for-casting-pointers-in-c)
The algorithm goes from 0-6 with 0 being Sunday, 1 being Monday and so on, but the ISO week date goes from 1-7, with 1 being Monday and 7 being Sunday, not sure if i've done it right
&gt; I would still do: &gt; &gt;x.name = (char\*)malloc(15 \* sizeof(char)); &gt; &gt;instead of just &gt; &gt;x.name = malloc(15 \* sizeof(char)); In C, casting malloc() is not necessarily considered good practice: [http://c-faq.com/malloc/mallocnocast.html](http://c-faq.com/malloc/mallocnocast.html) [http://c-faq.com/malloc/cast.html](http://c-faq.com/malloc/cast.html)
Cheers man! Great explanation!
&gt; Okay hold up, so 5. has a separate adress from what it is storing? Yup! Every variable has an address^(\*). A variable stores a value, and that has to be *somewhere*, right? So, you can run code like this: int i; char c; double d; struct S { long l; float f; } s; printf("%p\n", &amp;i); printf("%p\n", &amp;c); printf("%p\n", &amp;d); printf("%p\n", &amp;s); printf("%p\n", &amp;s.l); printf("%p\n", &amp;s.f); Now you can see where each thing lives in memory. Notice that they're all close by -- the compiler is putting them all on the stack -- a region in memory specifically for local variables. If you make them global variables then they'll be in a different place entirely, which will show in the address. You can also see that the address of `s` is the same as `s.l` -- that's because `s` includes both `s.l` and `s.f`, and `s.l` is at the very start of that memory, so the address is the same. A pointer is a variable like any other, and so has an address itself. But instead of storing an `int` value or whatever, it's able to store the address of some other pointer. Try this: int* pi = &amp;i; char* pc = &amp;c; double* pd = &amp;d; struct S* ps = &amp;s; printf("%p\n", &amp;pi); printf("%p\n", &amp;pc); printf("%p\n", &amp;pd); printf("%p\n", &amp;ps); printf("%p\n", pi); printf("%p\n", pc); printf("%p\n", pd); printf("%p\n", ps); You can see that each of those pointers has a different address from those we printed before. We can also print the address that they hold, which should be the same as when we printed the addresses directly. And just to blow your mind a little bit, we can even do: int** ppi = &amp;pi; int*** pppi = &amp;ppi; int**** ppppi = &amp;pppi; printf("%p\n", &amp;ppi); printf("%p\n", &amp;pppi); printf("%p\n", &amp;pppi); printf("%p\n", ppi); printf("%p\n", pppi); printf("%p\n", pppi); &gt; Also, since 4. is already printing the adress of x.name how do I print the adress within x.name? You should be able to piece that together from the above examples, but if you're still confused: printf("%p\n", x.name); ^(\*) I'm simplifying here; there are exceptions. A variable could be put into a register or optimized out completely, for example.
TIL ! thanks
This was above and beyond man, you've cleared up so much confusion for me. Cheers and happy coding!
Welcome :) if you want give me a vote up!
You no longer need to cast the void pointer returned from the malloc() call nor is,it considered best practice.
/r/csharp
Exactly. In fact I said "I suggest"; if he switches the version of std to an old one he have a compilation error 
You appear to be counting your neighbors and then looping through all cells, which makes no sense. Everything ends up dead because aliveNeighbours is probably much larger than 3. For each cell, count only that cells neighbours. Write tests.
&gt;The function of (char \*) is to cast the pointer type, from void\* to char\* Note that in C, no cast is required to convert void\* to another pointer type, and that (generally) casting malloc is not considered good practice (in C), on the DRY principle among other reasons. Since x.name is type char\*, the compiler will do the proper implicit conversion.
How do I do that? 
&gt;Okay hold up, so 5. has a separate address from what it is storing? boredcircuits already gave a comprehensive example, but in your code notice you printed `*`[`x.name`](https://x.name), and `&amp;`[`x.name`](https://x.name), but not [`x.name`](https://x.name) as a pointer. [`x.name`](https://x.name) is the value of the pointer returned from malloc(). &amp;#x200B; Try adding : `printf("\n6. %p\n",` [`x.name`](https://x.name)`);` and notice the pointer value is different from `&amp;x.name`
Sorry didn't know about that until now. Sorry
Downvoted for not formatting the code. It's NOT HARD. If you want others to help you do the bare minimum.
&gt; I'm supposed to use the day of the week for the 1st of January for that year and the ordinal day to calculate the day of the week for the specific date using modulo 7 arithmetic. Not entirely sure how though. I think just sum them, then modulo-7. Ordinal day is just 0-364, right? Add that to your Jan-1 value, then mod 7. Skip the weeks part, it don't matter. int DayOfJan1 = day_of_the_week(year); int OrdinalDay = calculate_ordinal_day(...); int WeekDay = (DayOfJan1 + OrdinalDay) % 7; // WeekDay shall be 0-6, so correct to 1-7 if you like 
I put it in like: ISOWeekDay = (week_day + ordinal_day) % 7; And now it's returning 5 every single time. 
If you're using `cin` you're not programming in C, you're using C++. This community exists to discuss the C programming language, please redirect C++ related questions to r/cpp_questions. In particular it sounds like your problem stems from gdb, or potentially netbeans debug console, which are also off topic here, but there's not really a subreddit for gdb, and you make it sound like netbeans's issue with `cin` is well known, so r/netbeans probably won't help much either. A quick googling of the warning you're receiving led me [here](https://stackoverflow.com/questions/29219666/codeblocks-warning-gdb-failed-to-set-controlling-terminal-operation-not-p) and while I recognize that's a post about Code::Blocks the warning is likely caused by the same problem: your terminal interface is not properly configured, but at the end of the day it's just a warning and unless it's not performing properly it can be ignored. In the future please spend more time googling your problem, along with proper subreddits, before posing questions to arbitrary internet communities. It would also save us all some hassle if you formulated a proper question; I'm not sure based on your post what you want from us, but I hope I've been helpful.
From my reading, while there were earlier versions of the C language where the cast was necessary (K&amp;R C didn't have a void* type), those versions were never standard. C89 (the first standardized version) required that malloc return void* and that void* be implicitly convertible. 
This isn't C++, please don't cast the result of `malloc()`.
Your syntax is really weird. To make links, just write [link text](http://domain.name/path/to/file)
Don't ignore the return value of scanf.
Also, sizeof(char) is 1 by definition.
https://ideone.com/WShEKO I've also been talking to someone on SO regarding this, and it seems like he's done it but I don't quite get how. I'm pretty sure its the same as the approach you gave me earlier, [here](https://imgur.com/a/f8vE7GI) is what he did that seemed to work.
i'm using a windows and rpi. i could've just continued to go with the flow and use VS community, but i had no control over things, so i decided to find a better way of doing things
First some general notes: * Lines 3-15 declare your function prototypes in an obsolete manner. * Never declare a function using empty arguments - e.g. int calculate_iso_week_day() * Your function declarations should exactly match their definitions later in the code - e.g. int calculate_iso_week_day(int ordinal_day, int week_day, int year) * This is cause of a major error that the compiler could catch on your behalf, but you neuter the compiler's ability to do so by using this obsolete style of declaration: in line 28 you call this function with no arguments, *yet it requires three arguments* to do anything useful. * If you declare it correctly at the start (matching the definition) then you'll find your compiler raises an error. *Compiler errors are good. Compiler warnings are (usually) also good*. * p.s. if you ever need a function that legitimately takes no arguments, the correct form is *int function(void)*, not *int function()* * Lines 27-30 you're doing a bunch of calculations, but not using the return value. It is here that you should be doing the calculation that you're doing at line 124. This is more a consequence of randomly throwing more code at the problem without slowing down and doing it methodically. e.g. all the code to calculate the week number just isn't relevant. But anyway, since you have the useful code around line 124, I'll address that code. * line 124: use *plus* here instead of *minus* * line 28: provide arguments to calculate_weeks_in_year(). fixing the earlier declaration of calculate_iso_week_day() 
Zork used items and such for many of its events but there is something easier. For a very basic rpg game I would have a general integer, major_state and set it to a number for any major changes that are required to be performed in order. Then a room_state for anything that needs to happen in a room (and resets to 0 when moving room to room). That way you can have room puzzles and a major state that effects the game as a whole without having to juggle a dozen boolean values.
`void initField(const int rows, const int cols, cell field[rows][cols])` When dependent types leak into C.
Hey bro I'm sorry, I tried to edit the code after I initially posted it and for some reason it didn't save I actually did 4 spaces not sure why it didn't save. &amp;#x200B; But on another note I want to ask you personally. Do you forgive me ? I love you man and I'd hate to see this relationship hindered over this minor hick up. I believe we can overcome this issue together. Struggle allows us to grow in our relationship. &amp;#x200B; Pressure creates diamonds &amp;#x200B; Fire creates gold &amp;#x200B; Together you and I will make it through this &lt;3&lt;3 XOXOXO. 
Thanks appreciate your points I'll make sure to fix those issues. 
&gt; the same applies to C to if you try to use gdb Sorry to give the impression that you couldn't post this question here, I meant to indicate that there are probably communities with less specific focuses, or larger user bases, that would know more about your specific issue. I also wasn't sure from your original post if you had eschewed netbeans altogether for the debugging process or if you had jerry-rigged a gdb call using an interface with which I am not familiar through netbeans. &gt; now i prefer attaching a debugger because the input is not shown, even though i'm gonna loose the head start of the software. Not sure what you mean by this. If you're still having trouble could you detail your process and continued issues? &gt; yea i'm receiving a warning, but what the warning says is weird It's not that weird. Check out my [second link from above](https://github.com/Microsoft/vscode-cpptools/issues/264#issuecomment-250220570). It appears to be a bug with gdb routing output via tty; I suspect that this use case is rare enough that the devs didn't feel it necessary to implement a full feature set for it, so when gdb tries to do certain things that it normally could on standard output it throws this error to let you know that the output you're receiving likely isn't what it normally would be. If I'm being totally honest I think you would probably do better with a slightly different setup, but I'm not totally sure what your needs are or what your current setup is. It just feels wrong to have gdb send output over tty, when I feel like there are better options. For instance, based on [this post](https://www.reddit.com/r/eclipse/comments/9qrmi2/what_the_hell_is_up_with_rdt/) it seems like you're trying to configure an ide for remote development, and as useful as netbeans can be I'm not sure it would be the best option for this. You may want to consider using emacs to connect your client to a remote host since it is a full-featured IDE, with excellent gdb integration, which can support this functionality in a number of ways. Or you could use git to version control software that you develop on your client and then push to your remote host for testing. And that's just the two that come most readily to my heavily biased mind, there are loads of options.
You sir are wonderful. Thanks!
`a-&gt;data + a-&gt;element_size * idx` is an error, you can not do pointer arithmetic on `void *`. (Some compilers offer an extension where it behaves like pointer arithmetic on `char *`). You could have `map_get` return a pointer into the array if you want, instead of copying the result out of the array. 
Thanks, how I do I do that? I can't do `return data[idx]`: ` error: returning 'void' from a function with incompatible result type 'void *'`
Use the "new " reddit. It has a button you can press to format your code for you, down in the formatting help section. Sorry, I hadn't had my coffee and I've been dealing with a few other people that just won't put any effort into helping those who they're asking help from. Pet peeve I guess. Maybe I should stick to the lighter subreddits until my caffeine based mood stabilizers kick in.
You can use macros for generic dynamic arrays, e.g. like so: #define vector( TYPE ) \ struct \ { \ int len; \ int cap; \ TYPE * data; \ } Then you can declare new ones like this: vector( int ) my_vector; And just access data directly: my_vector.data[123] = 456; 
That results in more code and larger binary size. I'm going to have a lot of types. Besides, how do I implement all the functions like array_push, map_set, etc?
With macros that define functions. Example: https://github.com/freebsd/freebsd/blob/master/sys/sys/tree.h
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [freebsd/freebsd/.../**tree.h** (master → afd6d3e)](https://github.com/freebsd/freebsd/blob/afd6d3e2d4d693631ca0133d3c18717a6ee1cc99/sys/sys/tree.h) ---- 
&gt; #define vector( TYPE ) \ struct \ { \ int len; \ int cap; \ TYPE * data; \ } I can't decide if it ends up being cleaner if you make `data` a zero length array or not. #include &lt;stdio.h&gt; #define vector( TYPE ) \ struct \ { \ int len; \ int cap; \ TYPE data[0]; \ } int main() { vector(int) *vint; int i = 0; vint = malloc(1024); for (i=0; i &lt; 512; i++) vint-&gt;data[i] = i; for (i=0; i &lt; 512; i++) printf("%i\n", vint-&gt;data[i]); return 0; } 
&gt;Sobel Operator Sorry man, I never used, but, if you have in the matrix a 2 element, sure you will get some other element with value over 255. The last calculation imply that again you have a sqrt2 of the sum of two to the power of two, that again can give you values over 255, because of the sum of the operands. I do dsp on c, if you multiply two variables with max value permited of 255, then its important to rationalize the results, `acc = a * b; acc = acc / 255; or acc &gt;&gt;= 8;`
Are you trying to avoid memcpy completely for some reason or just having to do it everywhere? If it's the latter then put it in an add_item function, maybe even hide the list structure entirely.
to implement his suggestion (or even my variation on it above) you just continue to use macros and let the compiler generate the code for you. You aren't going to get away from extra code. You need to sacrafice efficiency somewhere to do what you want. Something will have it give and it may be in clean code, simple code, speed, etc...
I think this can help [https://www.youtube.com/watch?v=uihBwtPIBxM](https://www.youtube.com/watch?v=uihBwtPIBxM)
yeah. That would be what I put in the code in my post. I am aware that they exist.
I ended up normalizing my values by a constant which seems to do the trick, though I'm a bit suspicious cause I'm not entirely sure how it worked. I was getting a pair of rings around borders, now with normalization I just get the one border like I should.
Excelent!!!
No, you have a zero-length array. That's not even valid C (Though some compilers might support it as as a pre-C99 extension).
Instead of using a `void *` you could use a `char *` since you already have the arithmetic for indexing based in the different element sizes.
That’s not exactly how C++ works, but whatever. Just have a macro for each type access and return a void* instead. #define GET_INT(map, key) (int*)whatever_your_function_is_called(map, key) Your backend is still one “implementation” and your front end has helpers for all your types.
&gt;For example, I would love to have a void* map_get function that returns the result directly. void* map_get (...) { return (void*) (m.data + m.element_size * hash) } X *p = map_get(...) X x = *(X*) map_get(...) *p = x // *p is the obj from map_get if you want to update it like this I have no clue how recommend or correct this is.
Sounds good. How do I return a `void*` element though? `return data[idx]`: `error: returning 'void' from a function with incompatible result type 'void *'`
Ok I well fix it thanks.
Yes. Like I said, I tried `return data[idx]` and I got `error: returning 'void' from a function `
no problem.
data is a void *. You can’t do built in pointer arithmetic on a void * array. You can convert it to some size type with a cast then return that castes to void *. E.g. char *c = (char*)data; return c + (idx * sizeof_the_type);
Never mind, I got it: `return (void*)(data + idx * elm_size);`
Yep, that’s correct. Array[i]; is equivalent to * (Array + i * sizeof(array_element)); void has no size, so you can’t index into it.
If you want it to be standards compliant, do it my way. A strict compiler won’t convert void* to char* for you.
Also where can I read about how C++ templates are different? I was sure it was just codegen for every type basically.
You'll have to show me in the spec where it says that. The C99 drafts floating online certainly don't. The do say that if an array is declared with a constant value it shall be greater than zero, but it doesn't say how to handle it if it is zero or if there is no expression (ignoring `*` which is discussed) (Section 6.7.5.2). And in Section 6.2.5 they really don't say how to declare flexible types other than "if the size is unknown" &gt; An array type of unknown size is an incomplete type. ... A structure type containing a flexible array member is an incomplete type that cannot be completed. The 2011 draft just says that the flexible array member is an incomplete array type (Section 6.7.2.1) &gt;As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member Until you pass `-pedantic` gcc won't complain a bit. And even then it will just give you a warning that ISO C forbids it and move on with life like nothing happened. `-Wall` and `Wextra` both don't care. Mostly the same with Clang, but its warning says that zero length arrays are an extension. MSVC throws an error saying that it's a non-standard extension (and is the only one that complains without `-pedantic`). ICC simply doesn't care at all (unless there are flags I'm missing other than `-Wall -Wextra -pedantic`). 
Thanks, this is precisely what I wanted. I came up with it a couple of minutes before your answer :)
If you read all that and don't understand that `int foo[0]` isn't valid, I really don't know what to say. C11 draft quotes: &gt; the expression shall have an integer type. If the expression is a constant expression, it **shall** have a value greater than zero. Look up what shall means to the standard in section 4. Incomplete array definition: &gt; If the size is not present, the array type is an incomplete type. gcc is one of those compilers I mentioned that does support 0-length arrays as a non-standard extension dating from the mid 90's (Or even earlier) before C99 added flexible array members. It doesn't warn about a lot of extensions without -pedantic, no.
Got it, thanks.
Interesting. Thanks. I wish C++ stdlib and clang/g++ sources were readable :)
And if the expression is not a constant expression greater than zero then the size of the array is not defined. As an array without a defined size is an incomplete type i'm not following your confusion here.
As others said in regard to this comment, that's not what i mean. You don't get to have your cake and eat it too... fast execution may require a lot of code or binary size. Or you get to have a small, fast binary but the code will be convoluted and ugly. In the end, you'll have to give up something most likely. Plus, your performance test is completely meaningless for what you are trying to do.
Haha, they’re not easily readable because they do the kind of shit I’m talking about. Once you have more experience in those areas, it makes perfect sense. It’s definitely a lot to take in if you’re not used to it, though. There’s a reason you only do that kind of thing for code that needs to be really fast and small. In general, you shouldn’t write code like that: it’s much more prone to errors and harder to read. You want to optimize the inner loop, so to speak, not the outside. Any meaningful work is on the inside. If incrementing your index is your performance problem, you’re probably doing something wrong. Or you’ve got some esoteric case.
I see. Thanks for clarifying. I'm a fan of simplicity, and if I can avoid macros and have just one type, then I'm happy :) Even if it's a bit less efficient. I was motivated by how dynamic arrays (slices) and maps are implemented in Go: https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics I really liked their approach. They also prefer simplicity to top performance.
Yeah I wanted to avoid memcpy. I managed to do it in the getter (I've updated the post), but looks like it's unavoidable in the setter.
Yeah I wanted to avoid memcpy. I managed to do it in the getter (I've updated the post), but looks like it's unavoidable in the setter.
The problem is, with your approach, you’ve offloaded the complexity to the user of your library. If you used macros to generate functions, the user sees things happen transparently. With your virtualized implementation, the user has to use macros and learn how to use your API in a way that doesn’t match other API’s. With the macro’d implementation, once they define the type in a macro, all the functions just exist and can be used the same as everything else they’re used to. Generally, you write your library once and use it many times. Why would you make using it more complex to use when that’s what you’re going to do more often?
Why do you want to avoid memcpy entirely? There's also realloc (https://linux.die.net/man/3/malloc) which may or may not call memcpy internally.
Doesn't calculate_weeks_in_year already have arguments? As it has (year) within the parentheses.
`memcpy` will work fine so long as client data is not self referential. A struct that contains a pointer to another field will be copied wrong. 
As others have pointed out, don't cast the return value from malloc, because the compiler will do an implicit conversion : https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc 
[ foo ](http://fuz.su)
It still looks rather weird. Have you really literally typed [ SqdUTest C framework ](https://github.com/squidfarts/SqdUTest-C) [ SqdUTest C++ class ](https://github.com/squidfarts/SqdUTest-CXX) Because the you should get [ SqdUTest C framework ](https://github.com/squidfarts/SqdUTest-C) [ SqdUTest C++ class ](https://github.com/squidfarts/SqdUTest-CXX) but actually you get something else.
Now you know why nobody really uses generic dynamic arrays in C. If you want a dynamic array, implement it in line where you need it.
&gt; Doesn't calculate_weeks_in_year already have arguments? As it has (year) within the parentheses. The *definition* later in the file shows the arguments, but not the declaration (lines 3-17 are the declaration). The compiler starts at the top and works down. By the time you actually call the functions (lines 27-30), the compiler has only seen the declarations. The compiler refers to these declarations to know whether you're calling the functions correctly. The empty-parentheses form of declaration that you've used merely identifies these as being functions, but *not* what arguments are required. Therefore when it reaches line 28, it can't tell you that you've failed to provide the necessary arguments to * calculate_iso_week_day*. If at line 17 you declared this function using the exact same prototype used in the definition (line 121) then at line 28 the compiler would know that you're trying to call this function with invalid arguments.
What would I need to do to fix it? Not sure if you caught my edit or not
You could start the process from within your program and then wait for it to finish. Or if you want to start it from outside your program, you have to get more creative. Your OS may have a function for that in it's API or you could repeatedly poll a list of all processes and check if the process you are watching is still in it. 
Be more specific. Are you using a UNIX-like operating system (macOS, Linux)? Which application is it? Who is launching the application?
I've managed to fix it and it now compiles. The answer isn't what I was expecting, but at least it is constant now and doesn't change every time despite putting in the same date. \[My code currently\]([https://ideone.com/ZQZuaX](https://ideone.com/ZQZuaX)) I think I need to minus 1 from somewhere, but i'm not exactly sure where.
That would be where the compilers appear to have drawn the line.
I'm sure if they were not on Windows they'd already know they could use pipes.
Assuming a linux environment, the easiest way is the system command: &amp;#x200B; int main(int argc, char*argv[]) { struct timespec start,stop; clock_gettime(CLOCK_MONOTONIC_RAW, &amp;start); system(argv[1]); clock_gettime(CLOCK_MONOTONIC_RAW, &amp;stop); printf("%d seconds\n", stop.tv_sec - start.tv_sec); } &amp;#x200B;
system() also spawns a shell process, which would lead to a relatively big timing overhead/uncertainty. fork() + execve() + wait() is probably a bettery way.
Needs more vowels.
for sure
Is the 'b' silent?
What are people's general stance on using char rather than uint8_t in modern C code? Ever since I started using c99 it drives me increasingly crazy when I see char, int, long, etc when dealing with integer values that are expected to be a particular size. I don't mean this as a criticism but rather to see if other people feel the same way as I do, or if it's just too engrained in our collective C culture to change.
I'm getting a segfault trying to run examples
I use `char` when it's OK to assume it's one byte. I'll use `uintX_t` when I need to be sure that it's a specific width.
&gt;Philosophy of Euboea includes following rules: &gt; &gt; * Fast language compiled to machine code. &gt; * Use JIT compilation. &gt; * Include minimal usable set of keywords and control structures. &gt; * Allow simplistic cooperation with C. &gt; * No access to files on physical drive. &gt; * Access only to stream I/O. &gt; * Focus on targeting UNIX-like operating system. &gt; * Intended to be used with shell scripts. &gt; * Focus on low level programming. &gt; * **Confusing name nobody knows how to pronounce or spell, thus ensuring the project will remain in obscurity** FTFY
A couple of constructive criticisms: All the machine code generation is hand-crafted via magic bytes (calls to `emit()`). It's clever, but — speaking from experience — this is a nightmare to maintain and debug. There are essentially no hints about what instructions are being produced, so they must be disassembled manually by the reader. It may not seem so bad when this code is fresh in your mind, but try revisiting this in a year. I expect this to cause problems in the future when W\^X becomes the norm: if (mprotect(ntvCode, memsz, PROT_READ | PROT_WRITE | PROT_EXEC)) It already won't work on OpenBSD, for example. 
Prior to the ratification of C89, the authors of gcc included a number of capabilities that could usefully have been part of C89 but weren't. Some of them were incorporated into C99 with the same syntax (e.g. // comments), some were added to C99 with different syntax (e.g. zero-length trailing element versus empty brackets), some were added to C11 (anonymous struct/union members), and some of which never got added (e.g. statement expressions). Back then, the authors of gcc sought to maximize the useful range of semantics available to the programmer, and gcc embodied the Spirit of C which the authors of the Standard would later describe in the Rationale, including the principle "Don’t prevent the programmer from doing what needs to be done." &amp;#x200B; Unfortunately, in the years since the ratification of the Standard, gcc has come to embody the opposite principle: code which relies upon any behaviors that aren't explicitly allowed is 'broken', unless the behaviors are so obviously necessary that failure to support them would be indefensible. For example, the "strict aliasing rule" (N1570 6.5p7) makes no provision for accessing a struct or union using an lvalue of a non-character member type \[even if the lvalue is of the form someStruct.member\], but would instead relies upon quality implementations intended for various purposes to recognize access patterns appropriate to those purposes. &amp;#x200B; It's too bad the old versions of gcc don't support modern microcontrollers, since for many embedded-programming tasks the only way to make modern gcc yield semantics appropriate to such systems is to block most optimizations. &amp;#x200B;
Do you mean `strtol()`? Did you read its documentation?
This post is long, but goes into great detail about how to check for all the different errors: https://stackoverflow.com/questions/26080829/detecting-strtol-failure
I've tried using the C api that is used for pybullet, but I can't seem to do half of what I'm supposed to be able to make. Do you have info on why's that? For example, I can't create springs.
Yes the second argument points to where it stopped reading. Correct? 
I believe I already read this post. It does not cover what I am talking about 
Yes it does. The last if else checks for the very condition you describe: a string that can be converted to a number using the chars att the start, but there are invalid characters afterwards. 
Im going to add explaination for emits soon. I'm going to appreciate PR helping me with this W^X problem too. 
[ˈevia] is correct pronounciation. 
Are you on x86? 
Yes. Is there not any easier way of doing this? It seems a little over complicated 
I highly doubt this has anything to do with C.
I find this way very easy. Just check if `endptr` points to a `\0` afterwards. If it does, the whole string was parsed as a number.
The functions that take no parameters should have this expressed with `void`in the prototype to avoid a swath of issues
How it is better then Lua?
The fix is to swap between writable and executable as necessary such that it's never both at the same time. All three of your examples still work on OpenBSD where W\^X is now law. There's no practical impact to dynamic linkers, and its a really easy fix for executable compressors (one extra `mprotect()` call when it's done). JIT compilers are trickier since it can be non-trivial to fix this issue, especially without a performance hit. 
It will not create an integer variable. It merely lets the compiler know that at some point, it may need to store the content of a pointer. Depending on the compiler and optimization, it could for instance just hold the pointer in a CPU register when the pointer is only needed temporarily. Or it could store it somewhere in memory. In the assignment you do (int *test = 0) you actually tell the pointer variable that IT is zero. So, if you tried to write to that (i.e. "*test = 5;"), you would get a segmentation fault (process will crash) because you're trying to write to address "0", which you don't have access to. Note that "int *test = 0" initializes 'test', and "*test = 5" assigns a value to the address stored in pointer 'test'. For printf(), there's a format character special for pointers, either %x or %p, I forget. That is good to use because you don't always know the size of a pointer if you compile on different platforms. Your first printf() would (if %d was correct, but it's not see above) print out the content of the pointer variable. That is, the address that is being pointed at. I think you're correct there. The second printf() would crash in this instance because 'pointer' is 0 and you're trying to read from address 0 (with the * operator), which you're not going to be allowed to. Last statement: &amp;pointer would be the address at which the content of the pointer is stored. Above I said the compiler might store the pointer in a CPU register. Once the compiler sees that you want the address of the pointer, I suppose you force it not to use registers but to allocate memory somewhere. 
i think you need to do something like this for all of the if tests. &amp;#x200B; if ((strcmp(mossa\_p\_uno,"c") == 0 ) || (strcmp(mossa\_p\_uno,"C") == 0 ))
This line, and the other if statements with similar construct, are wrong: if (mossa_p_uno == 'c' || 'C') It should be: if (mossa_p_uno == 'c' || mossa_p_uno == 'C') But I would suggest doing something like this instead: mossa_p_uno = tolower(mossa_p_uno); if (mossa_p_uno == 'c') &amp;#x200B;
Just use isDigit and cglheck for a '.' If you need a float.
yeah, I ended up using my own function, I just like to get used to built in functions
How would I do that? 
Sometimes the built ins suprise me. Like how the is_white from ctype counts \n as whitespace. Although I do understand why, I just didn't expect it and that caused plenty of bugs for ny reader program.
I got Execvp() failed.erno=2
hmmm I can't seem to find this constant
Four spaces in front of every line of code, please. And don't put code on the same line as the opening bracket of its enclosing block. 
Try writing some code and see where you get?
Noted, thanks for advice! 
The N2278 proposal misses the mark. What would be fundamentally necessary, absent a complete reworking of much of the Standard, would be something like the following: "Note that because C implementations are intended for many different conflicting purposes, \*this Standard makes no attempt to define all of the behavioral requirements necessary to make an implementation be suitable for any particular purpose\*. The failure of the Standard to mandate any particular behavioral guarantees does not imply any judgement as to whether quality implementations intended for various purposes should be expected to uphold them anyway, nor whether failure to uphold such guarantees so would render implementations unsuitable for various purposes." &amp;#x200B; Reading the published Rationale for the C Standard, it's clear that the authors intended the above from the get-go, but somewhere since then the language has lost its way. &amp;#x200B; I think it would be useful to have the Standard recognize various purposes for which C implementations are often used, specify some requirements implementations intended for such purposes should meet when practical, and recognize a distinction between "full-featured" and "limited" implementations independent of the hosted/freestanding divide. Limited implementations would not be required to process any programs usefully, but would be required to process programs as defined by the Standard unless or until they indicate, via implementation-defined means, a refusal to do so. Something like &amp;#x200B; \#!/bin/sh echo Sorry. I can't process that program. &amp;#x200B; would be a conforming, limited, implementation. Adding the notion that implementations would not be expected to run all programs, and programs would not be expected to run on all implementations, but that incompatible combinations of programs and implementations should be recognizable as such would hugely increase the value of the Standard. &amp;#x200B;
First tokenize the string (e.g. using `strtok`), then parse each number. Or use `endptr` to skip the separator following the number and then parse the next one. Or use a proper lexer/parser.
Please click “edit” and fix your post.
It's better now, hopefully. 
No, it's not. Indent your code properly, and then add four more spaces in front of every line. 
Not really. Try four spaces in front of every line of code and a blank line between code and surrounding text.
No, `array.x` is an array. 
I gotta say. Half the things you’re saying is gibberish to me. I am a beginner. But I will look them up. Thanks for the help!
It's the name of the array. So it points to array.x[0]. 
There is no reason to `memset` a file scope variable to zero, since it already is set to zero by default. `array.x` is an array (`char[4]`). `&amp;random_array_name == random_array_name`
Yes
Oh damn I didn't know that. I assumed it was an address to the pointer to the beginning of the array. 
Thank you very much! Sorry for my formatting of the post, this is the first post I've ever made. Cheers!
Then it still points to a nondigit.
Or map both at once in different areas.
why you getting downvoted lol
Please show a benchmark against LuaJIT.
fullstep was right, but you can also nest `switch` statements, which is probably the thing to do here.
I think you've got what you need from the answer above but this question reminded me of a similar thread from a few days back where I added a quick pointer intro. Hopefully you find it useful! https://www.reddit.com/r/c_programming/comments/9pfdpm/_/e81ig4u?context=1000
Actually it's pronounced "buttercup".
Thanks I'll check it out!
I didn't think that would work when W\^X was being enforced, but it seems to work just fine: #include &lt;errno.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; void memory_alias_unmap(size_t size, size_t naddr, void **addrs) { for (size_t i = 0; i &lt; naddr; i++) munmap(addrs[i], size); } int memory_alias_map(size_t size, size_t naddr, void **addrs) { char *path = "w-xor-r"; int fd = shm_open(path, O_RDWR | O_CREAT | O_EXCL, 0600); if (fd == -1) return -1; shm_unlink(path); ftruncate(fd, size); for (size_t i = 0; i &lt; naddr; i++) { int prot = PROT_READ | PROT_WRITE; addrs[i] = mmap(addrs[i], size, prot, MAP_SHARED, fd, 0); if (addrs[i] == MAP_FAILED) { memory_alias_unmap(size, i, addrs); close(fd); return -1; } } close(fd); return 0; } int main(void) { size_t len = 2 * 1024 * 1024; void *ptr[2]; memory_alias_map(len, 2, ptr); int r = mprotect(ptr[1], len, PROT_READ | PROT_EXEC); if (r &lt; 0) { printf("%d %s\n", errno, strerror(errno)); printf("failure"); } else { *(unsigned char *)ptr[0] = 0xc3; /* ret */ void (*f)(void) = ptr[1]; f(); printf("success\n"); } } 
Palaiologos, nice low-level work. So, are you from Euboea?
are you adding the &amp; operator to the variable that stores the number in scanf?
Is this an IOCCC entry?
C++ for example allows empty paranthesis, I'd want to keep it this way now 
It's smaller and very probably has lower memory footprint. Also I have to make benchmark to test speed of this 
Solely searching web and bashing with nasm, nothing special
Can you open issue please? 
Nope, just Byzantine history passionate
If it was, I could fit all the code in 10 kilos. I need to add descriptions for emits
You are passing argv[0] instead of argv[1].
Hah, cool, I assume then that you know about ``crazy waters''. Anyway, at some point you might want to check bison or yacc for parsing, etc.
I made pretty simple microbenchmark for this against unmodified Lua 5.3; with script there: r/https://github.com/KrzysztofSzewczyk/Euboea/blob/master/benchmarks/benchmark &amp;#x200B; My results: [https://pastebin.com/hF5XVAx7](https://pastebin.com/hF5XVAx7) Euboea is at least 3 times faster &amp;#x200B;
Of course, I'm going to accept PR's adding more complex benchmarks.
yep, used them in the past but this project was aimed at size, memory footprint and speed so I thought about bison+yacc like an overkill.
Beginner in C. I have been programming in C++ for close to a year now 
Fair enough, I liked your project because is small and tight. Kudos for that.
That was the problem! I didn't know about "tolower", thank you very much!
it was my first code with 'switch', next time i'll try to nest it!
JIT overall is highly dependant on the Intel x86 ISA and Linux style calling convention. 
Yes, you're right.
Those variables are single chars not arrays of chars, so strcmp is not appropriate.
I think its because strtok changes the passed string and in the second example you cant change the string. 
why does it change the passing string? and why can't it be changed in the second example?
 I don't know C deeply myself, but those two ss are not handled the same way by the compiler. The first: mov DWORD PTR [rbp-15], 745895781 mov WORD PTR [rbp-11], 30564 mov BYTE PTR [rbp-9], 0 The second: mov QWORD PTR [rbp-8], OFFSET FLAT:.LC1 Not sure what this is tho: .LC1: .string "ewu,dw" The former declaration treats your string....like a proper string, one that ends with a null terminating character. But that LC0? Maybe it doesn't have /0??
Yeah. If it doesn’t have “/0” that might explain the behavior
I know that in c that the first lines in each case have different meanings. Each of them will have different addresses. The first one will have an address that holds the value e while the second will have an address for a pointer that points to the memory address holding the e. Could be wrong but maybe that is the issue?
I don’t get why strtok would even need to change the given string 
well in the man page on strtok, under the bugs section they say it changes the string. i guess it is the way it is implemented. 
Change it how and to what? 
https://stackoverflow.com/a/21097376
\#include "Week 5-7.h" \#include &lt;stdio.h&gt; **int** main () { **int** num1\[20\]; printf("Enter a number: "); scanf("%d", &amp;num1); printf("Here: %d\\n", num1); **return** 0; }
Look at the source code
Yup. Thanks for the help
Please read your vendor's documentation of `strtok`. There it should say where clearly how `strtok` works. It modifies the string it is operating on by design.
I know. Cmd1 ; cmd2 would be sequential execution. And with &amp; I would like to execute first command in the background and second cmd like usual. I'm lacking the idea how to break down the problem? 
First of all thank you. So what you are saying is that I should have two independent forks. To first fork pass command, and when her parent processes finishes, than immediately call fork 2 passing second command. Yeah prbly would be much easier to use strtok. 
It is on windows. I’m launching the target app. Ideally, by starting the computer my program will be executed. It will stay executing till i shot my PC down. The target app, the one that i want to calculate how much time i spend on it, its actually a game. So my program will be hearing when i execute the game, and also when i closed it. Then calculate the time and write it into a txt file.
Yeah, like that. Note that you still want to get rid of the global variables because otherwise you have a nice race condition when you omit step 2.
- https://softwareengineering.stackexchange.com/questions/216289/is-it-reasonable-to-null-guard-every-single-dereferenced-pointer - https://softwareengineering.stackexchange.com/questions/147480/should-one-check-for-null-if-he-does-not-expect-null - https://softwareengineering.stackexchange.com/questions/186036/when-should-pointers-be-checked-for-null-in-c
Also -- is there a description of the language somewhere? What is the theory of memory management? Are functions called by value, reference, or name? Etc.
&gt; Should I check for NULL whenever I accept a pointer as an argument? If this is a publicly exposed function that anyone linking against your code can call - yes. If this is a static function - maybe, depends on how you are calling it, but since it is static you have a lot more control over that. See, with the publicly exposed function, we don't know what people will pass in. And its just plain sloppy not to handle an obvious case like a NULL pointer. But with a static function, there is a lot more control over what is passed in due to the scope of the call, presumably any external data has been sanitized by this point.
Thanks for the answer. I'm using windows for the target environment of this program though. I'll check the clock:gettime() function
thanks, you are talking about linux, right ?
 Thanks for the answer. I'm using windows for the target environment of this program though. I'll check the clock:gettime() function
no documentation currently exists, you may have to deduct it from code :/
You’re printing out the total seconds and not the seconds after you calculate the minutes. Recalculate your seconds after you calculate min, you need to get the remainder of seconds when divided by 60. Use mod % to find that out. 
Assuming you DON'T want it to be NULL, I guard against this with a simple assert(): assert(ptr\_arg);
I used to do this too, but for "debug" builds using gcc/clang I tend to use use -fsanitize=undefined which implies -fstanitize=null and gives you a nice stack trace and pretty console colors when you do a null dereference in your tests.
This can be way too heavy handed, especially if you are writing a library. Just check for error conditions and return an error status that callers can check and decide how to handle.
Oh TIL thank you :) 
Really, you should nave have to look this up. Use `strerror` to get an error message for the error code or directly go with the `perror` function to print an error message with the error indicated by `errno`.
I generally agree with you, but in my experience once you start writing or reading from a NULL pointer you're already past the point of checking for an error condition. So what conditions would you check for that wouldn't amount to basically the same as what my assert() solution does?
personal experience, its always always ended badly when I have not done this
Suppose you have written a string handling library with a function prototype: `char *doTheThing(char *str);` Callers are able to pass in a string to be manipulated and a pointer to that string is returned or NULL on error. The implementation might look like: char *doTheThing(char *str) { if (!str) { return str; } // magic happens to str here return str; } Now, someone calling this function can do a call like: if (!(doTheThing(s))) { // do some cleanup and take a different path } // or the call succeeded and we can continue With an `assert` the code aborts. With my solution, we let the caller know something happened. And the caller can decide, based on the needs of their application, to either abort or maybe just skip over a piece of the code but keep going. Just imagine how annoying it would be if everything always aborted over the littlest error?
&gt; I use assert() for unrecoverable errors that should never happen This is the distinction I think was missing from your OP.
int mins = secs / 60; secs = secs % 60;
Yes, it was missing. I clarified. No worries.
This is the best answer of that bunch: &gt; It depends on the 'contract': &gt; &gt; If PowerManager MUST have a valid IMsgSender, never check for null, &gt; let it die sooner. &gt; &gt; If on the other hand, it MAY have a IMsgSender, then you need to check &gt; every time you use, as simple as that. 
You can pass the pointer around as much as you want. The problem is you need to call free on what the pointer points to. So pass the pointer around, and when you're done with the maze, free it.
Why are you using an array of 20 ints if you only want to scan one int? Replace `int num1[20];` with `int num1;` and it should work.
For C++ help you should go to /r/cpp_questions - this subreddit is only for C. But in this case the answer happens to be the same: use `log()` from the C math library `&lt;cmath&gt;`.
ok thank you
In next version of Euboea, there will be \q escape sequence translated to '"'.
Thanks. Wouldn’t 20 put a limit on the amount of numbers it would accept
`printf` is a convenience function that is like `fprintf(stdout, ...)`. It is not a good idea to make `printf` print output to anything but `stdout` (though there are ways to do so). Yes, you need to replace all your calls to `printf` with calls to `fprintf` and an appropriate file.
scanf is only called once, so it'll always accept only one integer. 
So I'd have to write a additional fprintf after every printf and also after every scanf? So that it'd be perfect duplicate of the commandline screen.
oh that's what you want. It seems I misunderstood you. What operating system are you programming for?
Windows. Basically what I want is for everything that's on the commandline screen i.e the ones I print out to it and the things that used inputs to be recorded or printed on to a file in a way so it's a replica of the commandline screen
I'll look into it. Thank you so much for everything !!
The Standard uses the term "object" to refer to a few related but similar concepts, most notably: 1. A window with which to view some particular range of bytes as a particular type. This is what a pointer encapsulates. 2. An exclusive ownership interest in a sequence of bytes which a user program may use, and which is disjoint from any such other exclusive interest. This is what malloc supplies. 3. A combination of #1 and #2. This is what is produced by an object declaration of static, thread, or automatic duration. 4. The actual sequence of bytes identified by one or more of the above. The Standard isn't quite clear which of the above is being referred to in all of the places where it uses the term "object", and the rules cannot be sensibly applied without knowing what is meant in each case. I don't think there's any way to apply such usages in a way that would not either block many optimizations that should be perfectly reasonable, or cause some perfectly sensible programs to yield UB. The most literal reading of the rules would cause many programs to invoke UB *unless* one interprets the footnote to N1570 6.5p7 as indicating that the rules therein are only meant to indicate when compilers must allow for the possibility of aliasing between seemingly-unrelated "objects" (using definition #1). If the authors of the Standard expected compilers to uphold the Spirit of C they described in the Rationale, including the principle "Don't prevent the programmer from doing what needs to be done", the footnote would imply that they would expect compilers to avoid "enforcing" the rule in cases where things don't alias without regard for whether the footnote is normative. Unfortunately, "modern" compiler writers seek to interpret the Standard as narrowly as possible without being totally absurd, without regard for the Spirit of C. I think the clear intention of the Standard as written is that your code have defined behavior, and I don't really see any excuse for a compiler to process it in any weird way if `malloc()` yields a non-null pointer [obviously if `malloc()` yields null, all bets are off]. The lvalue `*a` is clearly of type `int`, and the Effective Type rule can only really apply to a sequence of bytes (definition #4 above). The only slight "technicality" would be that an lvalue is defined as an *expression*, and within an assignment expression statement, the only expressions that write to the storage are not lvalues. I doubt any compiler writer who wants to be taken seriously would suggest that all assignment expressions should be regarded as UB (inviting arbitrary behavior) but I see nothing in the Standard's definitions that would make assignment statements conform to the requirements of 6.5p7. Of course, if 6.5p7 only applies in cases involving actual aliasing that really wouldn't matter. In your code as written, all operations upon `a`, and then `b`, and then `c`, all occur within the context where each created from a `void*`. If the code were changed to read `*c` rather than `*a`, there would be no aliasing since the last use `&amp;*a` [the pointer value held by object `a`] would precedes the creation of `&amp;*b`, and the last use of `&amp;*b` predates the creation of `&amp;*c`. As it is, `&amp;*a` is used to access data written using `&amp;*c`, which was created after `&amp;*a` but not derived from it. This implies aliasing, but the Standard explicitly allows objects of type `int` to alias an object of type `int`. Note that if `&amp;*c` had been created before the assignment to `*b`, then `*b` would have aliased `*c`. The way the Effective Type rule is written would require compilers to handle that case, but this impedes useful optimization and relatively little code would rely upon or otherwise benefit from it. Consider, for example: void test(int *p1, float *p2, int mode) { *p1 = 1; *p2 = 1.0f; if (mode &amp; 1) *p1 = 1; } In the absence of aliasing, a compiler could omit the `if` and any use of `mode`. This could in turn allow a compiler to omit any side-effect free calculations involved in the calculation of `mode`. Under the Effective Type rule, however, such an optimization would not be allowed. I think it is fanciful to assume that the authors of C99 would have concocted a set of rules that would be a good fit for all the ways that the language is being used in 2018, or that there would be any particular value in trying to follow their rules as precisely and narrowly as possible without regard for the semantics programs actually need. The notion that violations of 6.5p7 should invoke UB would force programmers to include otherwise-unnecessary operations which could be avoided if the Standard instead specified that reading an object which has been or will be written in a fashion that involves illegitimate aliasing may yield Indeterminate Value. with semantics are at least partially defined for some types (e.g. copying a structure with members holding Indeterminate Value will at worst yield a copy with members holding Indeterminate Value). Otherwise, consider the following code: typedef struct {uint32_t x,y; } someStruct; someStruct copy1,copy2; someStruct test(int index1, int index2, void *p) { someStruct *p1 = p; p1[0].x = 1; p1[0].y = 2; // Perhaps code does something else useful with *p1 here float *p2 = p1; // Reusing storage p2[index1] = 1.0f; // Perhaps code does something else useful with *p2 here someStruct *p3 = p; // Reusing storage p3[0].x = 0; // Should code have to write p3[0].y here to avoid UB below even if nothing ever // examines copy1.y or copy2.y? copy2 = p3[index2]; copy1 = p3[0]; } It would hardly seem implausible that a compiler might unconditionally store `{1,2}` into `copy1` (ignoring the write to `p2[1]`). If `index1` is 1 and `index2` is zero, the write to `copy2` would likely show that the write to `p2[1]` had occurred. Since there is no defined means by which `copy1` and `copy2` could receive different values when `index` is zero, the Standard would view the writes to `copy1` and `copy2` as invoking UB if if code doesn't write `p3[0].y` first. If nothing ever happens to examine `copy1.y` or `copy2.y` however, requiring that a programmer zero out `p3[0].y` would seem contrary to the goal of producing optimal code. Treating the write to p2[1] as setting `p1[0].y` to Indeterminate Value, however, would avoid this iss Note that the code in the form above is highly contrived, but the sequence of operations could plausibly occur if a compiler recognizes that a sequence like `releaseThing(qx); qy = createThing();` could be replaced with `qy = (void*)qx;`. I think quality compilers intended for most purposes should recognize that `p3` is derived from `p2`, and `p2` is derived from `p1`, and thus the code does not actually involve aliasing, but even if a compiler would be allowed to unconditionally store `{1,2}` that should not justify completely jumping the rails if code never examines `copy1.y` nor `copy2.y`.
You use pointers for any data structure whose size or number you don't know at compile time.
Classic exercise with pointers: uni- and bidirectional lists with functions to add, remove replace, reverse, sort elements and splitting, joining, comparison. Add to that ring buffer made on a list of arbitrary length with functions to push and pull elements and ring resize. You should get a grasp of like 60% of C, which is pointers and memory management. 
The authors of the Standard expect (naively, IMHO) that compiler writers seeking to produce quality implementations will attempt to follow the intended spirit of the standard, including non-normative parts, whether or not they are actually required to do so. IMHO, the Standard could do with a lot more specifications of things that quality implementations aren't 100% required to do, but *should do when practical*, along with a means by which code can detect implementations whose semantics differ from the common norms. Such macros wouldn't be relevant for branch hinting, but would be relevant in many other situations, such as those involving integer overflow. There are a variety of ways integer overflow could be handled, and many programs would work just fine if an implementation chose among some of them (or even from all of the common ones) in Unspecified Fashion. If code which evaluates `x+2 &gt; y` would work equally well if it were processed as `x+2LL &gt; y` or `(int)(x+2u) &gt; y`, having a means by which a compiler could promise that behavior would be limited to the above choices would allow programmers to let compilers choose whichever implementation would be more efficient in any given scenario.
Nope, it isn't
Whenever I start a new language I like to write a csv parser and a tic tac toe game. The first is a use case that I almost always need at some point, and the latter is a good opportunity to play with different ways of doing the same thing.
Your problem has been solved, so I will only add one thing: my snail is named "ConstantineTheMightyWindBreakerJunior2014" and crashes your program. Can you see why? Try to diagnose this bug by yourself and figure out the best fix. We can help if you get stuck.
You never initialize `i`. You never set a `\0` either, which is needed to terminate the string. while (nextChar = getchar() != '\n') is getting interpreted as while (nextChar = (getchar() != '\n')) . `Use while ((nextChar = getchar()) != '\n')` instead.
I think N2280, whose essence is "A conforming implementation may not change semantics of a program as an "optimization” except as described in 5.1.2.3.4." is misguided. The Standard could be made much cleaner if instead of trying to characterize all individual operations as having behavior that is either defined or undefined, it instead described a more solid behavioral model but recognized particular ways an implementation might deviate from it. The clause about endless loops, for example, could be made clearer if it simply said that the length of time required to execute a piece of code, *even if infinite*, is not in and of itself considered an observable side-effect which compilers are required to maintain. Further, there are many situations involving overflow, indeterminate values, and so-called "aliasing" rules, where programs could tolerate a fairly broad but not unlimited range of behaviors. Having an optional memory model which would specify that compilers are not required to treat as observable any behavioral changes that result from certain optimizations would be simpler, cleaner, and more useful than trying to categorize as UB all situations where such optimizations might have observable consequences. If a applying a particular optimization would result in a program outputting `1` in a situation where it would otherwise have output `2`, but both outputs would be equally acceptable, defining the behavior of the program as "output 1 or 2" would be more useful than requiring that the code be written to block the optimization. 
This is smart but a bit scary.
Sounds like this might be a good use for the `__COUNTER__` preprocessor macro. But you'd have to be a bit careful to make sure it starts at 0 somehow, or offset `switch_step` accordingly.
Maybe try to program a software that reads an unknown amount of characters from stdin. You don’t know how many characters will be inputted and you have to cover all eventualities, e.g. Someone inputs an infinite amount of characters (hypothetically speaking)
A solver for the Game of 24 that prints all solutions that you can end up with at 24 using +, -, *, / and parentheses using the four numbers given as input. This task is a rite of passage at our university, and I liked it as an exercise especially because it is easy to understand the problem but somewhat tricky to solve. Solving it elegantly will probably involve using pointers, container structures and recursion. 
A solver for the Game of 24 that prints all solutions that you can end up with at 24 using +, -, *, / and parentheses using the four numbers given as input. This task is a rite of passage at our university, and I liked it as an exercise especially because it is easy to understand the problem but somewhat tricky to solve. Solving it elegantly will probably involve using pointers, container structures and recursion. 
You could store everything to an array of arrays and save that to a file but the printf/scanf/fprintf wrapper mentioned seems cleaner to me.
What about instead making an array of function candidates and iterating through them, with the index being static so the loop only iterates the first time it is called? 
The character limit is 20? Can I set it to max or a higher number? 
You mean the static index? The implementation here has the same issue
Heh, I've done basically the same thing at work. There are a number of channels through which we can obtain some data, and there is no way of knowing at compile time which channel will be available in the system where the application will be deployed, and they can fail albeit being available in the past, hence the same `switch` logic.
What is max? :) You could prepare larger array, but that allocates memory. There's no point in reserving excessive amounts of memory, that will stay mostly unused. Instead, you can limit the maximum length of a string while reading or find a way to automatically allocate required amount of memory (there's at least two automagick solutions, but one of them is specific to one standard C library implementation and should not be used). Keep looking :)
The strcat() call takes two pointers, and the source point doesn't need to always be pointing to the very beginning of the string you are building...
1. strcat() leads to O(N^2) inefficiencies with an invariant destination string because it has to find the end of the destination string each time. This means, for instance, that when you concatenate the 1,000th string, strcat() effectively has to revisit the 999 previous strings, all because it lacks information *you don't have to lack*. 2. You're getting the valgrind errors because your memory management is all wrong, the main problem for now being that there's no meaningful relationship between `iterator` and `len-1` on which to base a reallocation decision. Think about what happens if, say, the first three strings are each 200 bytes long. 
7.21.6.2#5: "A directive composed of white-space character(s) is executed by reading input up to the first non-white-space character (which remains unread), or until no more characters can be read. The directive never fails." 7.21.6.2#8: "Input white-space characters (as specified by the **isspace** function) are skipped, unless the specification includes a **[**, **c**, or **n** specifier." If you post the nonworking code somewhere, it'll be easier to tell you what's happening.
It's for a college homework assignment, so I probably ought to wait until the due date passes before posting my fully functioning solution to the Internet so i don't get accused of some bs on the off chance someone finds my reddit and copys my work. Basically, I had a file that contained an int representing the number of subsequent lines and each line had an int, a char, and 5 more ints in that order that I had to read into a struct. I had 7 fscanf() calls and going from "fscanf(ifp, "%d", &amp;var);" to "fscanf(ifp, " %d", &amp;var);" made it work.
implement the classic data structures: List, queue, stack, hashtable, tree, etc... As a bonus, testing is easy because there are existing libraries.
This explains why the whole thing isn't just a compile time test.
Thanks!
end-of-line is whitespace, and adding the space told scanf to consume the newline; or at least that's what I guess without seeing all the scanfs. I'm guessing the one you added the space to is parsing the first number on each line? Whitespace handling with scanf can be very tricky, as you discovered. BTW, consider using 1 scanf call for the lines with 7 values, instead of 7 scanf calls.
Using _static_ causes a race condition, rather than the usage of a loop over a switch.
dunno didn't want the kitchen sink so wrapped the functionality I wanted....
I must be missing something here, switch falls through anyway unless you implicitly break ???
Now I'm using DynASM. 
It does fall through by default, but when you actually intend it to do so then it is very good practice to add a comment stating this, lest some other developer presumes you made an error in omitting *break*. 
C supports procedural programming paradigm for code development but C++ supports both procedural and object oriented programming paradigms; therefore C++ is also called a hybrid language. **There are other key differences between C and C++.** * C uses functions for input and output, whereas C++ uses objects for input and output. * C++ supports reference variables, which C does not. A reference variable is an alias for an already existing variable, used to create a short-hand notation for faster coding. * C does not provide error or exception handling, but C++ does. 
Your loop to read a line is wrong on so many levels. `while(str!="\n")` this will never stop the loop when a new line is encountered, you are comparing to pointers. Here `str2[i]=str[20];` I did not understand what you are trying to do. I'm not a big fan of `scanf()`. I suggest you to read a line from `stdin` in this way: - use a char array to store the line and an index to keep track of the number of character stored; - read from `stdin` a character (`getchar()`, if you don't know this function, read its documentation); - store the just read char in the array and increment the index; - repeat the last two steps (`while`) until you encounter `\n`, `EOF` or the space in the array is finished (remember the space for `\0` at the next step); - when the loop ends, add `\0` in the line array at the current index position so you can treat your stored characters as a string. If you manage to write all this in a function, you can use it to read both, word to search for ("he" in the example) and the line of words ("The northern hemisphere" in the example). Then for the actual searching, look for the function `strstr()`, or write your own, if the assignment requires so.
I just woke up! thanks a lot. I don't really understand what your code does (I'm way too newbie yet) but I will definetly follow it to create my own, thanks again!
Input from the keyboard is a "stream" of characters. It's not like "user types in a line of text, hits enter, then enters an entirely different line of text". It's *actually* like "user enters in a long stream of text which coincidentally has some newlines characters peppered throughout, and sometimes the operating system has to wait a while to get the next character in the stream". So, let's say you hypothetically have a C program which accepts two inputs, an integer and a character: scanf("%d", &amp;x); scanf("%c", &amp;y); You might think to yourself "those are two separate inputs". Those are *not* two separate inputs. It is only ever possible to have one continuous *stream* of input. So if the user enters in "3" for the first number and the character "b" for the second input, what is actually present in the *stream* of input is 4 characters: '3' '\n' 'b' '\n'. At the first scanf("%d", &amp;x), scanf will see the first character ('3') and consume it. It will then see the next character in the stream ('\n'), see that it is *not* part of an integer, and leave it unconsumed on the stream. The second scanf("%c", &amp;x) comes along then, and scanf takes the first character in the stream ('\n') and returns it. At that point, your program probably stops reading in input, so you're left with an integer (3), and a character ('\n'), which is not what you intended, at all. Putting a space before the '%c' in the second scanf tells scanf "if there are any whitespace characters left unconsumed at the beginning of the stream, consume them before doing the %c scan".
He actually wrote an article explaining how to use that trick to [implement coroutines in C](https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html) 
Show us the code.
Basically, running the test executable with the --gdb option runs it under GDB, and once it encounters a failing test, it causes GDB to break and re-runs the test. If you step through the code and encounter a failing assert, it will break again, and print a stack trace, allowing you to look at the program's state where it failed. 
Worked, thank you. 
Brilliant, thank you!
You are passing a pointer to pointer. `myList` is a pointer, then `&amp;myList` makes a pointer to that pointer. Then memoryAllocation operates on a pointer to pointer. Your prototypes should look like this to clear things up: ``` void addProductToCart(struct list **myList); void memoryAllocation(struct list **myList); ``` 
I declare myList as struct list myList; Does this really make it a pointer in that regard? Isn't it just a variable that I then send its adress by &amp;myList into my addProduct function where I receive as a pointer? 
Damn, sorry. I read your code on a phone and misread `myList-&gt;items` for `myList`. Sorry again. 
I love it! Any plans to extend this to C++?
Yes, there is, if you implement getters for the fields of `struct date` which you want to expose to the world. int date_get_year(Date *date) { return date-&gt;year; } in date.c and printf("%d\n", date_get_year(date)); in main.c
It is working not because it is a workaround. That is how things are done. First you declare a struct on stack. struct list myList; Here you pass the address of myList to addProductToCart. addProductToCart(&amp;myList); addProductToCart expects a pointer value. An address is a valid pointer value for this case. So the address that you pass gets copied to the local argument that is `struct list *myList` `myList` now hold the address. memoryAllocation(myList); Then you make a call to memoryAllocation, and pass `myList.` &amp;#x200B;
Excellent, thank you.
If you move the definition of the function to the top you would not need **forward declaration**. That may not happen all the time. So you may have to forward declare functions that you are using. However I suggest that you use the same signature. void memoryAllocation(); Signature does not match. void memoryAllocation(struct list*); This looks correct to me. If you don't forward declare, compiler will have to make assumptions and give you warnings.
When I try to change my declaration from void memoryAllocation(); to void memoryAllocation(struct list*); I get these warnings: warning: 'struct list' declared inside parameter list| warning: its scope is only this definition or declaration, which is probably not what you want error: conflicting types for 'memoryAllocation' I also get errors when doing: void memoryAllocation(struct list*); 
warning: conflicting types for 'memoryAllocation' \&gt;Your forward declaration is wrong. implicit declaration of function 'memoryAllocation' \[-Wimplicit-function-declaration\] \&gt;So compiler is implicitly declaring one for you. &amp;#x200B;
Yeah, hard to guess where those functions are declared without seeing the full code.
Make sure that the file opens properly. You are assuming it does. Add if(file == NULL){ printf("error opening file\n"); exit(1); }
Is there a reason for keeping the definition in date.c and the typedef in date.h?
We know that the file exists. I tried this just in case though, didn't fix my issue. Tnx anyways :D
It could just be environment's fault. I have encountered such situation that everything is ok on my laptop but goes wrong on school's windows. Relax and do more checks. Good luck to you. 
i never thought reddit got some mean people to! thnx for your comment!
and btw the picture attached with it it's my code it doesn't come's up with The Question! &amp;#x200B;
Yes, as pointed out by ThatGuyFromOhio, you need to check fopen return value. Also, you don't check that brstud is less than or equal to 100, which is how large your std[100] array is. What happens if brstud is 1000?
I'm not sure what the reasoning is for it, but it's part of an assignment so I'm not allowed to change it.
Yeah, I would like to eventually support C++. Most of the code is mostly C++ compatible (except for silly things like C++ not allowing implicit casts from void* to other pointer types), but asserteq and assertneq heavily relies on C's `_Generic`, which C++ doesn't have.
hrmm check if the file is reasonable ? 1 2 #include &lt;stdio.h&gt; 3 #include &lt;ctype.h&gt; 4 #include &lt;string.h&gt; 5 #include &lt;errno.h&gt; 6 #include &lt;stdlib.h&gt; 7 8 struct Student { 9 char ime[8]; 10 float prosek; 11 }; 12 13 int main(int argc, char *argv[]) 14 { 15 16 FILE *file = fopen("somefile.txt", "r"); 17 if (file==NULL) { 18 fprintf(stderr,"%s : no file somefile.txt\n", argv[0]); 19 return EXIT_FAILURE; 20 } 21 22 float prosek = 0, maksp = 0; 23 int brstud, i, j, pom, makspi = 0; 24 25 fscanf(file, "%d", &amp;brstud); 26 27 struct Student std[100]; 28 29 for (i = 0; i &lt; brstud; i++) { 30 fscanf(file, "%s", std[i].ime); 31 for (j = 0; j &lt; 5; j++) { 32 fscanf(file, "%d", &amp;pom); 33 prosek += pom; 34 } 35 36 prosek /= 5; 37 38 std[i].prosek = prosek; 39 40 if (prosek &gt; maksp) { 41 maksp = prosek; 42 makspi = i; 43 } 44 prosek = 0; 45 } 46 47 printf("korisnicko ime: %s, prosek ocena: %.2f\n", 48 std[makspi].ime, std[makspi].prosek); 49 50 fclose(file); 51 52 return EXIT_SUCCESS; 53 54 } 55 However ... a segfault is a serious issue. 
&gt; multidimensional dynamic array Have you learned about `malloc` in class?
Get rid of the `&amp;` When passing an array to a function a &amp; is not needed.
You should be checking all the errors and returns of each system call. And print out all your intermediate values. You'll soon find it. Your code assumes things about the input it should not. 
Hi, have you considered using a switch statement? Set each case to a function, and you can easily choose which block you want executed.
Because there are 2 different types involved. You have char snailname[25]; If you do func(snailname); then the array decays to a pointer to it's first element. The argument has type `char*` and 99.99% of the time this is what you want. If you do func(&amp;snailname); then you're passing a pointer to the array which, as the error said, has type `char (*)[25]`
Because an array in C is actually just a pointer to the first element in the array, and so the value is already the address that the scanf() function need.
Okay, first off, you are talking about functions. This will make it easier to understand and research. Functions are pieces of code that only run when you call them (and you call a function by typing its name followed by the arguments on the parenthesis). By researching functions you’ll understand better what you want to do.
I think what you're referring to is functions. You need a function prototype before the main() function, then the function definition after.
Have you tried printing out the value?
&gt; an array in C is actually just a pointer to the first element No, but it devolves to one in many cases, including this one.
no! i think i've to solve this problem only using Multidimensional array.. &amp;#x200B;
oh okay the way to declare multi-dimensional arrays in C is `char myWordArray[10][30]`, which would allow you to store 10 words, each with a maximum length of 29 + the null character 
can u write the whole code in a note pad or something ? 
Hey, if it was readily understandable, they wouldn't call it *code*, right? :D
Ok this time I fixed it.
It sounds like this is a homework assignment. While we can definitely help you out, please don’t ask for the solution verbatim, as that’s what the professor wants you to do :)
A major catch-22 with C is that there are many necessary constructs the authors of the Standard didn't think they needed to explicitly define because compilers were supporting them anyway, but today's compiler writers treat the Standard's lack of a mandate as implying a judgment that they shouldn't need to support those constructs. It is hardly rare for programs to need to pass information between separately-published APIs that declare different structures with identical representations. While it might have been convenient to have a syntax specifying that the structures should be treated as compatible, such a feature wasn't really necessary since compilers would unanimously allow an object to have its address cast into a pointer of another type with the same representation and then accessed by that latter type, at least in cases where all uses of the resulting pointer would precede the next operation that accessed or addressed the object via other means. I really doubt that most of the authors of C89 would have ratified it if they realized how "modern" compilers which take pride in their inability to recognize, given something like: void test1(T1 *p) { p-&gt;member = something; } void test2(T2 *p) { test1( (T1*)p; } that a call to `test2()` might result in a `T2` being accessed. Unfortunately, it would be politically difficult for the authors of the Standard to recognize that certain behavior was always supposed to be supported after compiler writers have spent so long coming up with "optimization" approaches that can't handle it. Perhaps the Standard could officially recognize four distinct dialects with different type access rules: * one of which would regard as legitimate the current gcc/clang behavior, and also eliminate the ability of objects' effective types to change once established (support for which is complicated, buggy, and probably unworkable). * one of which would regard as legitimate all use of cross-type accesses that satisfy underlying platform requirements. * one of which would support most of the optimizations of the first while requiring that compilers accommodate the most common cross-type access patterns, * one of which would allow compilers to recognize fewer cross-type access patterns by default but would include directives to force recognition when needed. Such an approach would avoid requiring the authors of gcc/clang to abandon optimization algorithms that could only handle the first approach, since that approach would be officially recognized as legitimate. On the other hand, they would lose the ability to claim that code which requires the second approach is "broken", since that would also be recognized as legitimate. Whether a program is compatible only with the second dialect, or could also be safely processed with the third and/or fourth would be a Quality of Implementation choice, but if a program specifies that it requires #2, and its behavior would be specified in that dialect, then its behavior should be defined under the Standard.
Please don't use images. Use markdown to format your code here or paste a link to pastebin etc.
Changed to pastebin link.
like a cat with a toy I can not stop playing with this : p9$ cat foobar.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;values.h&gt; int main(int argc,char *argv[]){ /* note the use of the capital L */ double epsilon = 0.0000000001L; /* damn small number near zero */ #ifdef M_PIl double angle = M_PIl; #else #if defined(_IEEE_754) double angle = M_PI; #else double angle = 3.141592653589793238462643383279502884L; /* pi */ #endif #endif double result = sinl(angle); /* should be zero right? */ double neg_one = -1.0L; /* this actually is negative one */ /* a really offensively big number */ #if defined(_IEEE_754) double big_num = MAXDOUBLE; #else double big_num = 1.79769313486231570e+308L; #endif printf("sine of pi should be zero\n but we have %20.19Ge\n", result); if (fabsl(result) == 0L ) printf("\n even worse ... that isn't zero.\n"); if (fabsl(result) &lt; epsilon) printf("\n however it is close enough to zero.\n"); printf("\n\n big_num = %20.19Ge\n", big_num); result = neg_one / big_num; /* this will throw a numerical error */ printf(" negative one divided by big_num = %20.19Ge\n", result); result = neg_one / ( big_num * big_num ); printf(" negative one divided by big_num^2 = %20.19Ge\n", result); printf("Questions : \n is that result zero ? "); printf("%s\n", ((result==0L) ? "YES" : "NO")); printf(" is that result less than zero ? "); printf("%s\n", ((result&lt;0L) ? "YES" : "NO")); printf(" is that result negative ? "); printf("%s\n", ((signbit(result)!=0) ? "YES" : "NO")); return EXIT_SUCCESS; } which does : p9$ ./foobar sine of pi should be zero but we have 1.224646799147353207E-16e however it is close enough to zero. big_num = 1.797693134862315708E+308e negative one divided by big_num = -5.562684646268003458E-309e negative one divided by big_num^2 = -0e Questions : is that result zero ? YES is that result less than zero ? NO is that result negative ? YES p9$ 
I’m sure your class has teacher assistants or dedicated office hours for these difficult questions. Those are often very helpful.
Am I correct to assume that you want your variables "snailname, minutes and legtotal" from main and into your function? Either you simply send them as is to your function. Qualify(snailname, minutes, legtotal); and then in your function you need to receive as Qualify(char snailname, int minutes, int legtotal) This allows you to do calculations inside your function and return one value at the end of it. If you want to "send" variables into your function and manipulate their values and have them persist once your function is done you need to use pointers. In that case you want to send the *adress* of your variable instead of the entire variable in your function call. You do this like this: Qualify(&amp;minutes, &amp;legtotal); Qualify(int *minutes, int *legtotal) { //code } 
If you want a function to use variables from outside they need to either be global variables or passed as arguments. 
I worry that I made matters worse. 
The scope of the variable you call minutes in your main, does not go into the scope of the function. You will either have to declare minutes as a global variable or pass the variable value as an argument to the function. 
This was my first guess... that OP was writing outside the bounds of the student array.
I want an r/c++
No problem. I do a lot of time calculations, so this is a pattern I use pretty often. You can cascade it, if for instance you wanted to figure out hours, or video frames, etc. On a tangent, a while back I got curious what the compiler was actually doing. As it turns out, GCC (and others, I'm sure) will optimize a \`X / N; X % N;\` into a single assembly instruction on architectures that support putting both the quotient and remainder in separate registers (EAX and EDX for x86 32bit DIV instruction). Of course, if the architecture doesn't have such a fancy divide (or no divide instruction at all) it won't do this.
Nonsense. There are no silly things associated with c++
OP this is not at all how arrays work at all. Arrays are static and for their entire lifetime they will be exactly the length you define them to be when they are declared. You can't just declare them to have a size of 0 (I'm honestly surprised that even compiles) and then get a length from the user later and call that your array length. If you want dynamic arrays then you need to use pointers and memory allocation.
I’m a bit newbie with arrays, so trying to make a code with my thoughts. Going to read something about pointers and memory allocation, thanks!
Honestly if you're a newbie then I'd save that stuff for a bit later on unless you really need this program to work exactly as you describe it. Why not just make your array longer than you're likely to need (say 1024 elements) and then let the user enter up to 1024 elements for your program to sort?
Thanks man! I made my life harder, It works now.
You just have a function that's not main... where's the rest of it?
Nice!
you have to check the malloc function.
doot.... doot....
Great job. This is nice, clean, thorough C code. Here's some nitpicking to help improve it further: Programs intended to run specifically on POSIX systems are expected to define a *feature test macro* before including any headers. This declares to the implementation what version of the standard it wants to use. This is required, for example, in order to access `getopt(3)` from `unistd.h`. You're getting away without it because you're using GCC and it defaults to "GNU C" (e.g. `-std=gnu99`) rather than standard C (e.g. `-std=c99`). It's defining the `_GNU_SOURCE` feature test macro implicitly, which is POSIX + GNU extensions. In your case, you can make your program more portable, not relying on GNU extensions, without giving anything up or changing anything except for defining the appropriate feature test macro. On the `getopt(3)` man page it says you need `_POSIX_C_SOURCE &gt;= 2`. Since you're using C99, you might as well just go all the way for `200112L` (e.g. the standard published in December 2001). Put this before any `#include` directives: #define _POSIX_C_SOURCE 200112L Now your program will work on any POSIX system using any terminal that supports ANSI escapes. The names `_gcd2` and `_lcm2` (underscore followed by lowercase) are reserved in external linkage, so you should avoid using these names for your functions, especially if they're not `static`. IMHO, assigning `optarg` (i.e. when parsing `-d`) is a little sloppy. It seems to be technically permitted, but I wouldn't do it. Use your own, local pointer variable instead. Your Makefile could be a whole lot better: * Have a `metronome` target and don't have any commands on your `all`. As-is, you're preventing `make` from any meaningful dependency tracking. You can still haven an `all` target, but just have it depend on your `metronome` target. * Use conventional Makefile variables for compiler and compiler options. This lets the user control these values without modifying any files. It makes for a much nicer interface to your build system. * The default install prefix should be `/usr/local` not `/usr`, and it should also be controlled by a variable. Unfortunately there are two conventions for this variable, `PREFIX` and `prefix`. I prefer the former, but it's possible to support both if you wanted. Also consider supporting the `DESTDIR` convention, which is used for packaging. So here's my suggested POSIX Makefile: CC = cc CFLAGS = -std=c99 -Wall -Wextra -Os LDFLAGS = LDLIBS = PREFIX = /usr/local all: metronome metronome: metronome.c $(CC) $(LDFLAGS) $(CFLAGS) -o $@ metronome.c $(LDLIBS) clean: rm -f metronome install: metronome mkdir -p $(DESTDIR)$(PREFIX)/bin install -m 755 metronome $(DESTDIR)$(PREFIX)/bin uninstall: rm -f $(DESTDIR)$(PREFIX)/bin/metronome This will use the system's default C compiler (`cc`) set to C99 mode, GNU extensions disabled by default so you don't accidentally use them. I've turned on compiler warnings, and enabled optimization, which actually enables even more warnings since otherwise it doesn't do a complete analysis. 
While I wouldn't normally just point you to a website, the [wiki page](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation) on dynamic memory management explains the details (take a look at the translation from static to dynamic arrays [here](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Usage_example))
Ahh I see, what is the error the compiler gives you? 
At array 5 it just craps out random numbers.
Double check that the size of you array is correct. Lemme see your whole code. 
Here's the full code: #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int n, p, i, j; printf("Input N = "); scanf("%d", &amp;n); printf("Input P = "); scanf("%d", &amp;p); printf("Your set N = %d, P = %d\n", n, p); int ans[p]; int count = 0; for(;;) { printf("ans: "); for(i = 0; i&lt;p; ++i) { scanf("%d", &amp;ans[i]); if (ans[i] &lt;= 0 || ans[i] &gt; n) { count++; } } if (count &gt; 0) { printf("The answer is illegal, please reset the answer.\n"); count = 0; } else break; } int H = 0; int guess[p]; int ans_count[n], guess_count[n], this_number; int H_X, X = 0; X = H_X - H; for(;;) { printf("guess: "); for (i = 0; i &lt; p; ++i) { scanf("%d", &amp;guess[i]); if (guess[i] == ans[i]) { H++; } } for (i = 0; i &lt; p; ++i) { ans_count[i] = 0; } for (i = 0; i &lt; p; ++i) { this_number = ans[i]; ans_count[this_number - 1] += 1; } for (i = 0; i &lt; n; ++i) { guess_count[i] = 0; } for (i = 0; i &lt; p; ++i) { this_number = guess[i]; if (this_number&gt;0 &amp;&amp; this_number&lt;=n) { guess_count[this_number-1] += 1; } } printf("%dH %dX\n", H, X); if (H != p) { H = 0; X = 0; } else break; } return 0; } &amp;#x200B;
THE BUG IS FIXED. THANKS!
`date.c` and `main.c` are compiled entirely separately. The code in `main.c` has no way of even knowing that `struct date` even has a member named `year`.
&gt; If the tempo is too fast and the beeps are no longer distinct, try setting the beep length as follows: xset b 100 500 10 This works because many X terminal emulators process the bell character by invoking XBell() or a variant, and then X invokes the actual buzzer ioctl() using any xset settings. The xset settings themselves are registered via XChangeKeyboardControl(). If you care about only X systems (or if you're happy to detect X systems), you can try some light Xlib programming by calling XBell() yourself -- and optionally XChangeKeyboardControl() yourself. Then you know the X terminal emulator isn't going to ignore the bell character or reroute it through a "visual bell" mechanism. 
More confusing than a macro you can only call as often as it is defined? And why would it be slower? I think that assumes too much knowledge about what the compiler will and won't do.
3 BILLION DEVICES
Wow, thanks for the suggestions! I'll implement these changes when I have the time
Thanks! I've been looking for a way to dynamically change the bell settings without resorting to system()
&gt; The actual build rule for metronome is also obsolete as a wildcard target is already predefined Good point, I forgot about that. I'm used to writing it out since there's no predefined rule for linking object files. Also, the predefined rule for building an executable from a .c file doesn't include `$(LDLIBS)`. That convention unfortunately isn't documented or used in [the make specification](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) despite it often being necessary. 
&gt; The actual build rule for metronome is also obsolete as a wildcard target is already predefined Good point, I forgot about that. I'm used to writing it out since there's no predefined rule for linking object files. Also, the predefined rule for building an executable from a .c file doesn't include `$(LDLIBS)`. That convention unfortunately isn't documented or used in [the make specification](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) despite it often being necessary. 
Subtract str from fnd to get an integer index 
this is really great. 
Thanks guys Reddit is great well sometimes 
Great read! I wish my professors in college would have taught like this. 
im working at a technical university at an engineering faculty and i am happy if the students understand the basic concepts of loops and functions after they had a programming course... that means they have a pretty long way to go until they reach the level this article wants to achieve in what is basically 12 hours of time.
Thank you, that's very helpful! &amp;#x200B; Currently, it will only search for full words, do you know how to find a partial word? 
Is the problem that you're only getting a single space? It's likely that the tab stop is one space away
so that the tab doesn't starts from where the text alignment ends, but doesn't count it in, and that's why starting from %4d (a tab distance) I get extra space? 
strstr finds a substring. It knows nothing about words.
Are you in favor of hard-coding "sqrt()" function each time it comes up? I mean - multiple lines is better than one, right? What do you have against having one line for one thing? Seems you've ossified, old man.
I like my editor more, it's way easier to use :D
The "value" of an array is a pointer to its first element. getthis(line,MAXLINE); does *not* pass a copy of all 1000 characters to the function, only a pointer to the 1st one. 
I completely forgot about this... Thank you for your help! 
&gt; On the other hand, even if we were in a position where no new projects should be written in C (that day is coming, but slowly — probably at least a decade off) I'll give up C when you pry it from my cold, dead hands.
You hear this a lot, “C will be finally be replaced”, with what? Assembly? 
Do you mean as an input to the function? If so then you would want to pass the array as a pointer and pass the int size of the array, and you would able to add/remove elements within the function. Then you would want to create another function that prints the values of the array. 
Why doesn't this work? [https://pastebin.com/8DZ0M7g3](https://pastebin.com/8DZ0M7g3) &amp;#x200B; I get no output
&gt; they'll have to clone the repo, then go and manually install every single dependency, possibly modifying the makefile to point to their own directories. Nope, the makefile should just use -l&lt;libname&gt;. This means that the library resides in /usr/lib. In addition to this being a huge pain, doesn't this create inconsistent build environments? What I'm using SDL and the version on my machine is different than the version on someone else's? Isn't that begging for bugs and compatibility issues to creep in? Only begs for bugs when the lib you use is not well tested and there are breaking changes between api versions. No it's generally a very bad idea to include everything because often, you'd have to update said library, mainly for security reasons. Statically linked binaries without up to date libs can be a security concern - here you could say that system wide libs can be a security concern - but for somebody to have installed a compromised lib as system wide they need root access and if they have, security isn't a concern anymore; this assumes libs are installed by vendor/a package manager. However; statically linked binaries are subject to exploitation exactly because they are not uptodate and can result in root accesses; data leaks and whatnot.
It doesn't matter if you install library system-wide or put it in your source tree as long as preprocessor and linker can find those files. From Unix perspective, build process should detect system libraries **and** allow users to pass specific location (i.e. '--with' options to 'configure' and via '*FLAGS' variables). This may be different on Windows... I have no idea how this process looks there. Sorry. 
I love seeing new tools for low level work! Thanks for sharing 
This thing runs a thread that redraws the screen **one million times per second**
Okay. Makes sense. But what about building for multiple platforms? Do I include Windows binaries in the source?
Line 7. `[]` has higher precedence than `*`
Welp, i'm going to decrease refresh rate. Really i was so stupid that i done million times per second :D? 
I'm going to share a few more soon
yes
What about this one then? [https://pastebin.com/9an6LVH3](https://pastebin.com/9an6LVH3) It's supposed to merge the two arrays and put it into the array called "newArray" in main, and then I want to print it from main. But somehow the function doesn't affect the variable "newArray" in main, but it does work inside the function if I print it. Why? 
Features like time need to be redrawn, but not that often :D
Your input format isn't very friendly. If you have the ability to change the format, I would highly recommend you do so. For example, if you put the title at the end you can use `fscanf` to get the code, date, and price, and then use `fgets` to get the title. Or you can require quotation marks around the title. Or put every field on its own line. Or use a CSV format. There's lots of options. If you can't change the format, you'll need to get creative. I recommend reading the whole line into a string, and then parsing the string itself. I'd probably use `strchr` and `strrchr` to do some rudimentary tokenization, telling you where the first space is and where the penultimate space is. Your title will be between these two, and you can get the other values from there. It's not crazy hard, just annoying.
Maybe you should poll stdin with a 1 second timeout and redraw and eliminate threading altogether. When the timeout occurs you could redraw only the time, as well.
Ideally the data file would have some kind of special delimiter or escape characters encapsulating the Title string, such as quotes, commas, brackets, etc. If you are in control of the data file, consider formatting it as a CSV, for instance. If we can't modify the format of the data file, it gets harder to have a robust solution. If we are talking about any arbitrary movie, we have no guarantee about the number or format of tokens that make up the title. We could in theory read characters until we hit a number, but there are titles like "Fahrenheit 9/11" which are exceptions to that rule. There could even be a movie named "14/08/2001 39.99". The most robust solution I can think of, given this flawed data format, would be to read the Code number, then skip to the end of the line and read (in reverse) the Price and ReleaseDate. Keep track of where each search ended, and take what is between those pointers/indices as the Title, stripping whitespace as needed.
TIL how to check for control keys: #define CTRL_KEY(k) ((k) &amp; 0x1f) Nice project.
I can imagine in a distant, maybe even post-x86 future, there is a C-like language that offers the user greater control over the memory hierarchy and perhaps builtin support for parallel and/or "safe" datatypes, and otherwise being light on features.
Thanks dude.I will try this format: code, date, price with fscanf and title with fgets.Also i will do tokenization just for "fun".
Huge mistake on my part, I was on mobile, read the title wrong, and thought you were asking what pre-existing editor to embed into something. Don't know what the fuck I was on, but oops. 
I like r/adventofcode. Ive used python in the past, and it helped improve my skills with it. There was a guy last year that did a different language each day. Food for thought.
There's a better explanation of this in the [code that OP lifted 90% of his editor from, which you can check out here](https://viewsourcecode.org/snaptoken/kilo/03.rawInputAndOutput.html)
You should probably credit the source code that you lifted most of this from: https://github.com/antirez/kilo/blob/master/kilo.c
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [antirez/kilo/.../**kilo.c** (master → 62b099a)](https://github.com/antirez/kilo/blob/62b099af00b542bdb08471058d527af258a349cf/kilo.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e8or6w5.)
Oh.. that's strange, in my program it works for certain strings but not others. It will find the 'he' example but if I type "never odd or even" "eve" it just returns null. [https://pastebin.com/Gxfj4p8Q](https://pastebin.com/Gxfj4p8Q)
&gt; Add half-precision floating point. It's useful sometimes in graphics programming, but its absence in C makes it a pain to use. A C++ proposal is in the works to make `short float` a thing. I can totally see WG14 adopting something very similar. &gt; Remove fallthrough on switch cases unless explicitly desired. We won't see this, of course, but there's a high likelihood of getting the next best thing: C++'s `[[fallthrough]]` attribute. Then the compiler can be told to warn (and possibly error) when you fall through without the attribute.
fgets leaves the `\n` at the end of the string so in that case you're looking for "eve\n" in "never odd or even\n" and it isn't there.
Yes. Okay, I\`m going to try that, thanks! &amp;#x200B;
That makes sense. How would I fix this?
sqrt is a function that everyone understands. *DotheThing()* which is a single intractable lambda expression isn't. You'll see.
Sounds like a rather bad API design to me. Anyway, you can create a pipe and use the input end as fd for dialog's output. Then you can read what dialog wrote from the output end.
Look at the last character of the string. If it is `'\n'` change it to `'\0'`
Confession: I program about equally in C++ and C. Don't hold that against me. But C++ has added several new features that I think deserve to be in C as well, and it looks like the standards committee is accepting of that idea. In addition to those already proposed, here's a few at the top of my wish list: * Digit separators. Several other language have this, and it's time C did as well. The idea is that long literals like `1234567890` should be broken up to be more readable: `1'234'567'890`. The controversial part: every other language went with underscores (`1_234_567_890`), and that would make sense for C as well. It was also the initial proposal for C++, but it conflicted with another feature (user defined literals), so they had to do something ... different. This puts C in a bind, but I think the best solution is to ensure C++ compatibility (otherwise they can't be used in any potentially shared header). * Binary literals. We have hexadecimal, octal, and decimal, but not binary. Several other languages do, and it makes sense for C to as well. The syntax would be `0b1011'0100`. (Digit separators are a must with binary literals, IMO.) Maybe add a `%b` format specifier to `printf` and `scanf` for good measure. * Inline variables. This was controversial for C++, so it's probably a pipe dream to get it into C. `inline` can be applied to variables as well as functions, with the same semantics (reminder: `inline` is about linkage, not actually inlining functions). * Additional literal suffixes. C++ is currently flirting with adding some literal suffixes that don't exist yet (for `size_t`, for example), so we might as well just go whole-hog and add a suffix for all built-in types. I'm thinking we should use the `printf` format specifiers as a guide. * A feature to remove: K&amp;R-style function declarations (including empty parameter lists). The standard has had a notice that this feature is obsolete and might be removed for almost 30 years (see 6.11.6, 6.11.7). That should be enough notice that it can be removed now, right? Right???
Perfect, thank you!
To make things worse, C has diverged into two dialects, one of which is totally unusable for low-level programming, and one of which forbids many optimizations that would be useful in most cases. The authors of the Standard have as yet made no effort to specify a language that can do everything the latter language can do, while allowing most of the optimizations of the former. It may be reasonable to say that code which wants to access an object at different times using pointers of different types should include some directive to warn the compiler about that, and to deprecate the use of type punning without such a directive. Before something can be properly deprecated, however, it must first be acknowledged, and a usable replacement must be provided. As yet, however, the authors of the C Standard have instead chosen to take the attitude "compilers are free to define useful behaviors if they want" while compiler writers take the attitude "since the Standard doesn't define this behavior, there's no need to support it". &amp;#x200B;
Nope.
Just do the loop from nln-1 to zero (inclusive) and don't forget the null at the end of nstr.
Maybe it returns null, because the last byte in cstring is a null byte. When you move it to the first element, it won't matter what's behind it. For cstring functions it will be an empty string. To mitigate this, do not move the last byte, as it is a terminator byte, marking end of cstring.
I guess maybe it's because dialog was made with Bash in mind instead of C, since you can redirect easily like `2&gt;&amp;1`, then the library came after that. Plus it's based on ncurses which uses stdout for display, so maybe it's made like that to avoid conflict. Either way, I'll try piping it then, thanks for the feedback.
Yesssss thank you. I was so confused, I was trying so many different things having no idea why it wasn't working.
Remember the null byte! A cstring `"Foo"` is in fact an array `{'F', 'o', 'o', '\0'}`. That is why you don't have to pass a string length to functions operating on cstrings. Since you solved the problem, here is a working example for comparison: ``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(int argc, char * const argv[]) { size_t idx, len; char *str, *res; if ( argc == 1 ) { /* We need a string to reverse */ fprintf(stderr, "Usage: %s STRING\n", argv[0]); return 1; }; str = argv[1]; len = strlen(str); /* Allocate space for result, with the same size as the length of input string (plus null byte) */ if ( (res = (char*)malloc(len + 1)) == NULL ) { perror("malloc()"); } else { /* malloc() does not zero allocated space. We need to add a terminator ourselves... or use slower calloc() */ res[len] = '\0'; } /* The whole reversing logic */ for ( idx = 0; idx &lt; len; idx++ ) res[idx] = str[len - idx - 1]; printf("%s\n", res); /* We don't need `res` anymore */ free(res); return 0; } ``` Don't copy it blindly.
It's more than a little disingenuous to not have it clearly stated that your work is derivative of Kilo. You didn't create a new codebase and use some parts of Kilo, you modified Kilo.
The ability to see the overflow bit, but not all CPUs support this. 
* I want to reduce the number of undefined areas in the specification. Make things like bitfield structs consistently map to memory so you can use them portably. * A lint tool which supported C11 (or eventually I'll have to do it myself) I have in a past project implemented a M4 macro preprocessing pass to compilation, it is fairly easy to add the extra step. M4 preprocessor -&gt; C preprocessor -&gt; C compiler. I'm not sure I would choose M4 again though. Also worth mentioning, as it hasn't gotten much press, the C18 standard has been finalised. Mostly clarifications and bug fixes from C11, particularly in the thread and atomic areas. Detailed writeups https://gustedt.wordpress.com/
You should really check out Rust.
You think Rust can replace C?
Yes. There is even an OS being written with it: https://github.com/redox-os/redox. There are a few things still needed for it to be a full replacement, but I believe it is the closest we'll have in the near future.
Here's what the article says: &gt; \- Using variable-length arrays can add some minor run-time overhead to the code due to needing to determine the size of the array at run-time. &gt; &gt;\- VLAs within structures is not supported by the LLVM Clang compiler and thus an issue for those wanting to build the kernel outside of GCC, Clang only supports the C99-style VLAs. &gt; &gt;\- Arguably most importantly is there can be security implications from VLAs around the kernel's stack usage. &amp;#x200B;
Is there a reason why it’s better than C? 
Think modern language features (generics, real macros, RAII) with zero overhead. Yeah you head that from C++ but while C++ decided to keep source code compatibility (well, kind of) with C, Rust doesn't, and instead provides an FFI to interface with C. Also modules/packages, package manager, integrated build system (no more Makefiles), etc.
* a standardized countof() operator * declarative meta-language to help with contract definition and automated static correctness analysis * a way to show sizeof() during compilation
Why?
typeof being standard, as well as a version that returns a string typename instead. Struct initial values. functions inside structs with a concept of self (just passes a pointer to the calling struct as the 1st arg or smth) maybe. (Would be nice instead of manual vtables, where you still have to reference the struct you are calling the function from.)
Why didn't these languages just use whitespace for separators?
I haven't run into a lot of the cases that you're referencing, but the first point - reversing the endianness of a variable would be absolutely wonderful. Efficient packing of structs would be cool too.
So just leave the method void?
* A nod to reality that the vast majority of machines are 2's complement and signed integers can wrap. Any architecture that can't handle that can stay with C89/C99/C11. That alone would do wonders to remove quite a bit of undefined behavior and reign in some of the crazier optimizations that break real code. * Another nod to reality---make the all-0 bit pattern the NULL pointer, end of story. Any architecture that can't handle that can stay with C89/C99/C11. That way, `memset(p,0,sizeof(*p))` will initialize any pointers in the structure to a proper NULL. * Can we get rid of '-&gt;' and use use '.' for structures? There's no reason for the syntax difference between an instance and a pointer, much like there's no syntax difference between an array and a pointer. * Much like we can do structure assignments struct foo a; struct foo b; a = b; Can we get some form of array assigment? int x[100]; int y[100]; y[0..49] = x[0..49]; y[51..99] = x[50..98]; y[50] = -1; 
I suspect that doesn't play well with tokenization.
I would think any statement with a number, space, and then a number would be an invalid statement unless this was implemented, or am I wrong?
I wish there were functions for add/sub, mul/div &amp; mod that detected overflows and either raised an error or gave a direct return that indicated whether overflow occured or not.
I'm not sure why, but using something like this led me to experience some very strange bugs before, where this works most of the time, but other times it leads to a crash. No idea why.
&gt; 0 is success, otherwise it's an error code. Spotted the shell scripter.
Regarding two's complement, there's work being done on exactly this! [N2218](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2218.htm) was proposed to the C standards committee, and received very favorably. However, wrap behavior is still undefined. Compiler writers just really want to assume `n+1&gt;n`, I guess.
I've been hunting for food C/low level programming blogs, just bookmarked this one. Very good read. 
Hexadecimal literals provide an interesting case: `0xabcd ef01` ... This still isn't valid code (at least, not in C or C++), but it's not clear that the second token is even a number. You'd normally expect that to be an identifier. I wouldn't be surprised if this is doable, but using `_` is trivial to implement in comparison.
Yeah as someone who is primarily interested in C for learning programming the hard way* this blog is a gold mine. ^*At this point I’m competent in Swift but there’s still so much to learn.
Makes sense, Actually, if ef01 was an identifier,that eould be invalid as well, wouldn't it? So couldn't the compiler, instead of immediately erroring, check if a (hex) number could be made with subsequent characters, using the first token as a number format reference? I just think spaces look way nicer without making it generally harder to identify or lex.
I would like to see something similar to C++ enum classes.
&gt; Binary literals Is this really not part of C? I've been writing them as `0b01010101` for the past few days while writing a CPU simulator and assembler. Did I stumble in a GCC extension or something?
Network code is the main use case I'd imagine (at least the one I always see). I feel like every TCP parser has to throw some macro's in to figure out the endian-ness of the system before it does anything.
&gt; Make things like bitfield structs consistently map to memory so you can use them port Making bitfield behavior consistent between compilers first would be a huge step. Once debugged an issue when we were overflowing a 3byte value stored in a 4byte int and then compared it against an incoming value. Switching compiler versions broke it because GCC changed when it masked off the unused byte.
- Standardized typeof operator. - Tagged unions. - Standardized local functions (something akin to the gcc compiler extensions). That said, even without these features, I prefer C to any language that happens to have them (along with a huge heap of other garbage that facilitates mediocre software developers making a giant mess).
making the standards free and publicly available would be a start.
&gt; Can we get rid of '-&gt;' ... ? Not sure how I'd live with my self .. so many habits over so many years. Syntactic sugar diet is what you suggest there I guess. 
As the post said, this is not for the 2nd or 3rd language the students learn. I'd imagine this would be something more like a 3000 level course.
There you have to use `#ifdef` and whatnot, such that your system calls the proper libraries between your target builds.
Well, a few ideas were used but my editor is way imoroved version
&gt; a replacement for the primitive macro preprocessor if you're hinting c++ templates then no
That scheme is actually quite common in C.
Can't you just use (n)curses? 
There are easy, portable ways to test for overflow. I guess "if (thatOverflowed)" would be nice, but it's not too hard to get the same results inside the language.
Read tokens, first one is a code, last two are release date and price, everything between is a title. 
I really liked the look of rust, but it's gotten big, and the syntax takes a while to pick up... C has its simplicity going for it
- Less UB, especially for things like pointer aliasing - Modules / removal of header files - Top level items are independent from their order of appearance (functions high in a source can call functions low in a source, without prototypes) - Removal of prototypes - Removal of the concept of compilation units / object files - Sum types / first class tagged unions - Namespaces - A Zig-style defer keyword, for automatic exit-out-of-scope cleanup. - Keywords like u8, i32 as aliases for uint8_t, int32_t, etc. - New pointer-like type: slice. Basically a pointer plus a length. - Obsoletion of c-strings in favour of char-slices. - Slicing syntax
- Parametric polymorphism, so that casting to- and from `void*` or having macros for every structure-variant, which both greatly increase the mental complexity of the code, is no longer necessary. - First-class functions and closures: The possibility to define functions inside your code rather than only at the top-level. - (Far-fetched:) An Hindley-Milner-like type system so the compiler can bark at you whenever you try to use something written by another developer in a way that is unexpected. - Standardize that an `union`'s other fields are allowed to be accessed when they are not the active field. (I did not know it for a long time, since GCC and Clang both allow this, but this is undefined behaviour territory). - Removal of the post-increment and post-decrement operators since they make code harder to read. - Built-in support for Statement Expressions.
Yes C is simple, but that's an illusion because it simply transfer the burden to the programmer. Think how many times you got a segmentation fault because you used a pointer after freeing it. Even simple programs require huge discipline from the programmer to control lifetimes and avoid mistakes.
Do not spam.
errno.h
safeC substandard similar to safeD but actually supported by compilers on all platforms
I can't believe I had to get this far down before seeing namespaces. 
I was actually using it before but I was struggling a bit with its lack of abstraction. It's really low-level so I thought having a more abstracted library would help. I guess I'll go back to it though if things don't work as expected.
A cleaner way to do it is to return a struct. But it will work only if you know the size of your array beforehand. You could define struct wrapper {unsigned char data[8]}; And use it as a return type.
Endianness wouldn't be enough though, structs can have implementation-defined padding as well
I've used namespaces in C++, and they can be very useful. Did you see where GCC now compiles D? Maybe it's not dead yet.
&gt; Trash the cruft, like the ugly _Generic, _Atomic etc. keywords and just use the lowercase variant, add u8/u16/i32/f64 (etc) Mandated to have it be like that because macros are a bitch. &gt;Pretend the various pointless bits of C (Annex K, threads.h...) never happened. threads.h is actually a good thing, it's there to keep compatibility with c++, the issue is that people weren't implementing it (minus david lindaur and pelle orinius) until recently (glibc just added it, musl has it, etc.). Having a standard way to declare threads is infinitely more preferable to me than having to declare 13 different ways to do the same thing. in fact, a good addition in relation to threads would be semaphores, for job tasking, linux, windows, BSDs, etc. all already support it and it makes perfect sense to have if you have threads anyways.
No idea why are you so negative to this project :/.
It's worth looking into, but I haven't seen many projects in D. 
One very simple way would be to change the functions to: int sum2(int a, int b,...){ return a+b; } Which then allows you to call the smallest of them with all of the arguments. &amp;#x200B;
It is silly to start teaching in C. You must first learn assembler and then you understand the godsend that C is. When you write C, you should be thiking what happens in assembler, and then writing it beautifylly in C. In parallel to this low-level thread of learning, you have to learn other high-level languages, of course.
Think about the question you are asking. You are not asking to remove elements from the array, you are asking how to not have the computer select pre-selected Pokemon, or to not allow the user to select pre-selected Pokemon. The first case (Computer selects after user)-you have a randomizer function that can choose any number in the array except those that are already in use. Sounds a bit like an if/else pair. Same thing for the user-the user is effectively a random number generator that needs feedback if a pre-chosen value is selected. Also if/else, plus maybe a printf or two.
The issue here is that there is no function signature for the “fn” argument, since you don’t know the number of arguments. This isn’t allowed since the compiler needs to know how to set up the stack+registers etc for each call. So you cannot accept both “void f(int)” and “void g(int,int)” the way you think (you can if you only use a fixed number of function types, but I’m assuming you want a generic answer) Another problem is that in c, you don’t know the number of variable arguments. That value needs to be passed as the first parameter (like printf) or all values need to be non-null pointers, except for the last (known as sigils, like execve). I can’t think of an idiomatic way to do this, other than requiring all function pointers to be “void f(va_list)” and also pass in the number of expected parameters.
oh could that be done in C? sorry for that noob question I’m a beginner programmer ahaha but I’ll try to look that up. Thanks!
hmm come to think of it, this does make more sense. I’ll try to look up if I can exclude the chosen indices in the random selection. Thanks!
There are a couple of methods I can think of off the top of my head. The first requires you to remove elements as they are chosen by the user. To do this, after the user chooses an element, you would shift every element "down" the array and then call `realloc()` for the new array size. So let's say I choose element 3 (from available slots 0 to 8), before asking me to choose again the array should move element 4 to slot 3, 5 to 4, 6 to 5, 7 to 6, and 8 to 7 before calling `realloc()` to resize the array down by one element. This assumes that you're copying by value the elements from the array into a new array where the player's Pokemon are listed. The second would be to keep elements in the array and add a member variable to the Pokemon struct that indicates whether that Pokemon has already been chosen or not, and by whom. I would use an `enum` for that purpose with a value for not being chosen, one for the player, and one for the opponent. From there you don't need to `realloc()` or even create a new array, you would just only list those that have not been chosen for the selection process. If say the player chooses element 3 as before, then the selection list can show element 4 in slot 3, and so on. If they player chooses the element in slot 3, obviously you can't have them "reselect" element 3, so you'd have to instantiate a check to see if that element is already chosen and if so increment their selection number to choose the correct one. Both have their merits. The former relies less heavily on `if` statements while the latter performs less memory manipulation. I would opt for the latter because memory manipulation tends to be an expensive operation, and the numbers are small enough here that I don't think I need to worry about overhead from cycling through the whole array. Your mileage may vary. If I've been unclear or misleading on anything please ask questions or let me know. I hope you find this helpful.
Not sure how Dlang did it, but I think I would want something like [this](https://dlang.org/articles/pretod.html).
I think others have done a good job explaining why you don't need to remove elements, but something I think should be mentioned is that generally when you want middle insertions and deletions you should be considering a linked list instead of an array.
The problem with using whitespace for separators is that the Standard defines parsing behavior in various corner cases by having the preprocessor regard numbers as single tokens, so something like 1.2E+34 is regarded as a single token by the preprocessor. If number tokens could contain spaces, then the same rules that say that \`0x1E+4\` is an invalid numeric token would say the same about \`0x1E + 4\`. I personally think the sensible solution would be to recognize a token type for \`E-suffixed numeric literal\` which can then be followed by a \`+\` or \`-\` and an integer literal, but that would require reworking a fair number of parsing rules. &amp;#x200B; Another issue from a practical standpoint is that if there are any preprocessor macros that start with a-f or A-F and consist entirely of \[0-9a-fA-F\] and such a macro appears within a number, there could be ambiguity as to whether it should expand. Personally I think the Standard should simply say that if separated by whitespaces, such macros would expand like any other, so given \`#define cab 456\`, the statement \`x = 0x123 cab;\` would set x to 0x123456, but again that would require a total revisit of the concept of a pp-number.
Trying to expose the CPU's overflow flag would be a major impediment to optimization, and the result would be far less useful than having a thread-global "has any overflow occurred" flag with relatively loose semantics. Generally, what programs need to know is whether any computation within a chunk of code might have yielded incorrect results. Giving a compiler the freedom to do things like skip computations whose numerical result is ignored along with associated overflow checks (rather than having to perform the computations purely to see if they would overflow), perform a sequence of computations on on a longer type than requested to as to prevent overflow and validate the final result, etc. would allow code to be more efficient than would be possible without defined overflow semantics.
Theoretically you could call the function from assembly but that only works if you know the calling convention and number of arguments. 
the simplest solution i can think of, which no-one else seems to have mentioned, is to set the array entries that are chosen to some special value (like -1 or NULL) and then in the routine that chooses for the computer, try again if it hits one of those values.
Rather than looking it up, I'd suggest thinking of how you'd approach the problem yourself first.
You could use lists instead of arrays
I haven't used it personally, but maybe slang will be more interesting for you. Midnight Commander is/was using it and many people preferred it over ncurses.
Ummm... You could use 'if'... (?) 
Namespaces...
It will vary depending on your end goal, but based on your description I think it would be safer to use a function pointer and create a function that accepts a flag and that function pointer. Based on the flag you pass it can set the function pointer to point to whatever function you want. If you want to be able to flip between two and only have a boolean value for your flag then you'll also need some way to determine the state of the function pointer, either by a static variable or by passing a struct that contains a member variable for state as well as the function pointer.
 *string = *string + *password; If this ever results in *string being 0 then subsequent passes will stop at that point.
Or just a function that takes a function pointer and call it within the if statement with whatever function pointer you need. IE If (var = 0){func (pointer_to_func_A)} Else {func (pointer_to_func_B)} Sorry for formatting... on phone...
I was under the assumption OP needed to be able to call the function outside of their flip-flop function and that its state needed to remain persistent after calling the flip-flop. But yeah, making a wrapper like that could also work so long as it fits OP's use case.
Lol, you're right, but what's the best way to swap the functions? Whether it's macros or function pointers, I've never used either before.
does it really? is it bad practice to do macros inside a function call? it certainly feels like it. Maybe function pointers are possible? Though I've never used them before.
The usual way to do this is with binary exclusive or (`^`), not addition and subtraction. It has the advantage of being a) involutory and b) unaffected by issues of signedness and arithmetic over- or undeflow.
While this is an assignment and I have to do it this way, thank you for the tip! It helps a lot!
Macros are evaluated during preprocessing stage only, so they won't work in runtime. Function pointers work in runtime. Choose depending on when you want to swap.
That helps a ton, thank you.
&gt; I was under the assumption OP needed to be able to call the function outside of their flip-flop function and that its state needed to remain persistent after calling the flip-flop. This is correct, it's for a shell. That's why you offered up the state flag, I presume?
&gt; if I created the function pointer IN my "define" function, would the scope terminate it after the function returns? Not necessarily. It will cease to exist if it's allocated on the stack. If you use `malloc()` it will exist until it is freed. &gt; Is this so the program knows if the functions are swapped or not? Yes.
No single kind of pointer semantics will be suitable for all purposes. For an implementation to support systems programming, it must allow programmers to form programmers out of nothing. For an implementation to support reliable garbage collection, it must forbid programmers from forming and using pointers to objects that they know existed, but which the garbage collector had no way of knowing they might try to access. Rather than trying to formulate a "compromise" set of semantics which will end up not being suitable for much of anything, the Standard should explicitly recognize a few different memory models, including: 1. An "everything is bytes" model, essentially analogous to `-fno-strict-aliasing`. 2. A "no storage reuse" model in which any storage which has ever been used as a given type will accessed with any other in its lifetime, except that `memcpy` and `memmove` may be used to copy entire objects [even though its behavior is described in terms of bytes], and `fread`/`fwrite` may be used to read and write objects of any types that do not contain pointers. This would not only allow optimizations, but would also allow for "sandboxing" implementations that would trap on all operations that might otherwise have unbounded consequences. 3. A general-purpose model which treats storage as typeless bytes, but would allow a compiler to treat operations on lvalues of different types as *generally* unordered, provided that it recognizes certain actions as implying sequencing. Much of the conflict surrounding things like "strict aliasing" stem from an inability to recognize that different kinds of programs have different needs, and should thus be processed with different semantics. The situation is analogous to two people going to a restaurant when one wants a small sausage pizza and the other wants a small pepperoni pizza, and then--instead of simply ordering one pizza of each type--getting stuck in an endless argument about whether they should order two small sausage pizzas or two small pepperoni pizzas. If each could simply recognize that there's more than one legitimate pizza topping, there would be no need for "compromise" because each could get exactly what he wants.
In this case, as the order of the array doesn't matter, it would be better to just swap the pre-selected pokemon with the last pokemon in the array and decrement the upper bound of the randomizer, as in Richard Durstenfields implementation of the Fisher-Yates shuffle.
That's not needed. The endianess of the system is not something the programmer has to worry about unless they are poking at individual bytes of integers. You can use shifts and ors to create a number and it will work the same in every endianness. In fact, gcc and clang converts these to bswap or nop these days so there is no performance cost compared to doing it using macros. 
The GNU linker has support for this sort of thing through *overlays*. Read the manual for details. This is going to involve writing custom linker scripts.
I love it!
Except when you run into UB. C is not a portable assembler anymore.
Overlays...got it. Thanks! I'll read up on that. 
Yes, you can. However, the linker only takes care of managing the memory addresses. You still have to manually copy the data segment of the relevant process from flash to RAM and jump to it.
Lot of weird things happening in this program. First, string and password are defined as unsigned char pointers. They are not really character strings and your check for the '\\0' string terminator doesn't really make sense in this context. If you want to treat them and strings, define then as signed character pointer. These lines (below) assume that the length of the password is at least as long as the string, which I doubt is a safe assumption. The result is that you could be incrementing past the end of password and dereferencing garbage data and possibly crashing with a segfault. You should protect that you don't go past the end of password. *string = *string + *password; string++; password++; Your getting non-ASCII characters in your output because when you add the two characters together above, the result is outside the range of ASCII characters. You need to add some method to keep the result below 128, perhaps with a modulo operation. And if you only want printable ASCII characters, you need to restrict the result even further.
Seems like it. Please read the manual as that is going to make you more familiar with how to do this than I am.
In order for an inner function to accept a variable number of arguments passed to an outer function, the inner function must accept an argument of type `va_list`. This is the pattern used by functions like `fprintf`/`vfprintf`, and it's a good one. If the inner function accepts an argument of type `va_list`, there can be an arbitrary number of wrapping layers between it and the outer function that accepts a variable number of arguments.
Line 34: `printf(" %d ", calculate_factorial(i)/calculate_factorial(j)*calculate_factorial(i-j));` Should read: `printf(" %d ", calculate_factorial(i)/(calculate_factorial(j)*calculate_factorial(i-j))); Multiplication and division operators hold the same precedence and are associative left to right, so the multiplication occurs on the quotient from division instead of creating a larger denominator for your fraction. I'll update if I see anything else.
Can you provide any examples (GCC is fine) on how the compilation/linking process would look for two entirely separate programs, each with their own `main()` and such, linking into one object file? I'm still confused on how to ensure the linker won't get confused on multiple identical symbols. I also suspect I'll have to throw any automatic build process that Code Composer Studio provides out the window with this...oh, well.
No, I cannot. I have never used this feature. I think there is an example in the GNU ld manual.
More options: &amp;#x200B; 1. Linked Lists 2. Bitmaps 3. do-while with the condition check based on the whether the Pokemon has already been selected.
Have any betting code that does that? Every piece of TCP code I've seen just overlays the struct over memory to access the fields directly
I do believe N1570 states in `6.2.6.1.7`: &gt; When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values. which, while not _undefined behaviour_ as I thought when writing my post (and indeed I was confused with the C++ standard), means that accessing the other variants of a `union` cannot be done in a standardized way, because compilers might lay the variants out in whichever way they like.
Then byte swap later? I'm just saying byte swapping doesn't need macros with `#if LITTLE_ENDIAN` etc because the compilers are smart enough to optimize normal shifts and ors. 
I second Newt. Add a member in your Pokemon struct (assuming that's what you're using) that denotes whether it has been selected or not b
But I'm not talking about that. I'm talking about when raw data is read off of the wire and you need to passed the data at the byte and bit level.
Another approach is just to generate the number, then throw it away and try again if the number is the one value that isn't allowed. 
Thanks so much for the reply! Sorry to ask, but how would I 'reset' the string and password? Sorry, but I am an amateur at C still, so I am sorry if it is a stupid question. Again thanks! 
Thank you! This helps a lot!
I've done this on HC08, Coldfire, and Cortex M4 in various ways. Most often I'll link the bootloader and main program entirely separately, with their linker scripts set to keep them segregated in their own flash space. The outputs are then combined into one flash image, either using binary utilities or by having the production flash programmer load selected portions from each ELF file. One of the HC08 bootloaders was implemented as a ROM library, which was an easy thing to do with that linker but I don't remember how to do the equivalent with the GNU linker. If your application has one object that's at least as big as your buffer needs to be, you could get away with linking the bootloader with the application and casting the object's address to the type you need for your buffer. If you go that route, I strongly suggest leaving yourself a custom error pragma that checks the object size and reminds you about the minimum size requirement in case you forget you reused that space for the buffer. I once made a seemingly-innocuous change to one of my projects and spent a few seconds scratching my head at the weird error message that came up, before I realized I'd put it there years before because I knew one day I'd forget. Thanks, past me. My Cortex bootloader is linked separately but can be launched by the main application and it works from external SPI flash with a FAT filesystem. It's definitely the heaviest bootloader I've written. The application communicates with it by writing commands to a reserved flash block and then jumping to a vector. If the bootloader is interrupted, it's able to resume because the first thing it writes is the vector table, with a temporary version that redirects to the bootloader, and the command table still holds the location of the update file (and the decryption keys) so it can try again. Return to the application is by reset, after the vector table has been updated to the final version. The Coldfire bootloader was the gnarliest. It had to allow for a full firmware upgrade via USB with no external storage, with 128 kB of flash to be updated but only 16 kB of RAM. That one was linked in as part of the application. It had to maintain the USB stack's state *while* the USB stack was being replaced, so the linker script had to be manipulated to always keep critical pieces like the endpoint descriptor table in the same location. I'd have to check the code, but I *think* the way it worked was that it'd load the top half of flash (which didn't have the USB stack) first with the contents of the bottom half, then step out to RAM and swap it back to the bottom, and return via a vector to resume with the new bottom-half bootloader and USB stack (because the return address may have changed if the stack was updated), and then load the top half with its actual contents as they were received via USB. That one was not so robust when it came to interrupted updates.
Why? Just use separate functions that are all accessible to each other. Are you asking if C has classes? Because that’s what you’re describing. If I were you I would just use separate functions so that it’s simpler, readable, and easier to maintain.
That makes a lot more sense. Thanks
ye
You call functions from other functions. Iteratively and recursively if need be.
He talked about using individual functions that refer to other functions outside of each other instead of having a function-cepiton
So by using main() as a sort of “index” for my functions, I could define all the functions I need outside of main and achieve what I’m looking for?
You can do this: void main (){ println (Multiply (3,4)); println (Multiply (Add(1,2),Multiply (5,6)); } int Add (int x, int y){ return x+y; } int Multiply (int x, int y){ int r = 0; for (int i =0;i&lt;x;i++) r+=Add (r,y); return r; } 
Misleading function names are bad.
What did I do wrong this time....
I think it should be `r=Add (r,y);`
Ah.. thanks!
Do you mean using a function's return value as an argument to another function? Like if you had a function called "getInteger" that returns an integer and another function that takes an integer as an argument like "usesInteger(getInteger())"? Are you asking about using a ternary operator as an argument to a function? Like "usesInteger ( (a &gt; b) ? a : b )" to pass value "a" to the function "usesInteger" if (a &gt; b) or pass the value "b" otherwise?
I believe gcc allows this for C
You can, in fact, define local functions inside other functions, but that's not something you see everyday (I haven't seen it used anywhere really).
array name can't be l-value. use dynamic arrays
&gt; Add some linear algebra, like the vector/matrix multiplication features of FORTRAN. There's a proposal for that: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2081.htm
Not the return of the function itself but using scanf to get local variables that can be passed to other functions, which I believe the answer is yes I just was thinking about it in the most complicated way possible
If one part of the Standard defines the behavior of some action, and another parts says an overlapping class of action invokes UB, the Standard imposes no requirements upon any actions of the latter class. According to the Spirit of C as described in the rationale, quality implementations should not "prevent a programmer from doing what needs to be done", but the Standard doesn't mandate quality behavior. The way N1570 6.5p7 is written does not give blanket permission to access a union object using any non-character member type. For a compiler to be incapable of handling something like `someUnion.member[index]` would be Just Plain Dumb, but the same would be true of `doSomethingWithMember(&amp;someUnion.member)` or even `*(someUnion.member+index)`, but gcc and clang are too primitive to handle either of the latter constructs properly. 
The use of += and an Add() function makes the result a little more like exponentiation, but not quite. Looks like you found that and edited the code. It doesn't work for negative numbers, but accepts and returns signed types.
C is perfectly sane language to develop a game, either 3d (opengl and vulkan are C apis) or 2d. If you are going to 2d only, look SDL or ALLEGRO libraries as start point. Good look
Easy, use SDL its basically a cross platform API that gives you a video, sound and input.
Thats 2 points for SDL I will look into it!
SDL2 might not be the best framework, but it is the most widely used one. I used it for a 3d FPS game a while back.
**Archon: The Light and the Dark** Archon: The Light and the Dark is a 1983 video game developed by Free Fall Associates and one of the first five games published by Electronic Arts. It is similar in concept to chess, in that it takes place on a board with squares, but, instead of fixed rules when landing on another player's piece, an arcade-style fight takes place to determine the victor. Also unlike chess, each side has different pieces with ranging abilities. These abilities are enhanced when landing on a square of one's own color. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Would SDL still be the best option if I wanted to make the game as lightweight as possible?
Generally speaking, it's fine. You can always make things lighter and faster, making them work in the first place is the hard part.
Just to strictly give some kind of proof to the "is it feasible" question, here's an old (and abandoned) project of mine made with C (and only a little bit of C++, and DX11): https://www.youtube.com/watch?v=sUiRsvsqmOE 
That is the conventional wisdom, it has rarely been my experience though. Maybe someone with more experience could give a different perspective. I've only been working as a developer for 40 years.
Well OK, technically choosing the right framework and program structure from the start can save you a great deal of time and effort down the road. But considering the context I didn't think a few megabytes in binary size was important.
Any specification that would make the existing bitfield syntax behave consistently on all compilers would require that some existing implementations break existing code. More helpful would be a syntax that would specify that within a particular context (which could be, but need be, within a struct or union) that would specify that an identifier should be treated as accessing some specified combination of bits or bytes from other identifiers in the same context. For example, one could declare a structure with an array of two `uint16_t` values and then declare that `foo` should behave as a 20-bit value whose upper 12 bits are taken from combines bits 11:0 of the first `uint16_t` value and whose lower 8 bits are taken from bits 15:8 of the second. One could also declare freestanding identifiers that behaved likewise with respect to other freestanding identifiers. Such a construct would facilitate code that needs to parse different kinds of data on machines with different endianness or even word sizes. If, for example, one declared a struct with a "16-bit big-endian" member formed from the lower 8 bits of each of two `char` values, one could use that to decode network packets received as a sequence of octets even on a PDP-8 with its 12-bit word size.
I would like to start with the most efficient option and a personal challenge would be to make the game as lightweight as possible. I want to use clever sprite mapping in order to safe space and do all kinds of optimization as the project unravels but it would be a shame if halfway in I would realize another library would have been more efficient.
You will love SDL2, it works great with C/C++ and it is easy to use. It has all the basic features as well as extra libraries for things like sounds, fonts, image loading.
To allow generation of optimal machine code, the Standard should define categories of implementation that offer various guarantees about overflow behavior, as described in my other comment. Allowing a compiler to perform signed integers computations using larger temporary types, or behave as though it is doing so, facilitates many useful optimizations, and any code which would be broken by such treatment could and should be written in a way that would make its intentions clear. The authors of the Standard had said in the published Rationale that they expected commonplace implementations to treat `(unsigned)(x+1)` as equivalent to `(unsigned)(x+1u)`, so if--as is typical--an implementation treats `(int)valueBiggerThanInt` in wrapping two's-complement fashion equivalent to `(int)(unsigned)valueBiggerThanInt`, that would suggest that they expected `(int)(x+1) &gt; y` to behave in wrapping two's-complement fashion on such implementations. If wrapping is expected, I would regard the latter expression as a much clearer indication of intent than `x+1 &gt; y`, so allowing a compiler to at its leisure treat the expression as `x+1L &gt; y` shouldn't break anything. 
I totally agree! 
boi, Fast karachi?
The authors of the Standard expected that implementations would try to behave usefully when practical, whether or not the Standard required it, and made no attempt to forbid all of the things implementations might do that might render them unsuitable for various purposes. From their perspective, if it would be easier for almost all implementations to process some marginally-useful corner case in useful fashion than to do anything else, but there could be some implementations where that would be expensive, it should be UB. That would let people writing implementations where the common treatment would be unusually expensive judge whether it would be best to: 1. Assume customers might need the behavior, and implement it despite the cost. 2. Assume customers won't need the behavior, and do something cheaper. 3. Allow customers to indicate whether they want to tolerate the execution-time cost of demanding the commonplace behavior, or tolerate the effort require to work around its absence. In most cases where corner-cases behavioral guarantees would offer any benefit at all to a programmer, programs that exploit such guarantees would be easier to write and essentially as efficient, if not more efficient, than code which must work around their absence. If, however, a particular program would receive zero benefit from a corner-case guarantee, the cost of working around its absence would be zero, and thus any benefit a compiler could receive by doing something else would be a net win. What's needed is a way by which programmers can waive the guarantees they don't need while demanding the ones they do, so as to allow optimal code generation both for programs where the guarantees are useful as well as for those where they are. 
There would be considerable value in either having the preprocessor be able to access semantic information about the program, or having a form of "static if" that could adjust how things are declared, e.g. if static (sizeof (bucket_entry_type) * MAX_ITEMS &gt; UINT32_MAX) { __stdc_expose typedef bucket_offset_type uint64_t; } else if static (sizeof (bucket_entry_type) * MAX_ITEMS &gt; UINT16_MAX) { __stdc_expose typedef bucket_offset_type uint32_t; } else if static (sizeof (bucket_entry_type) * MAX_ITEMS &gt; UINT8_MAX) { __stdc_expose typedef bucket_offset_type uint16_t; } else { __stdc_expose typedef bucket_offset_type uint8_t; } The hypothetical `__stdc_expose typedef` syntax would indicate that the symbols declared by the `typedef` should be treated as part of the enclosing block (since the scopes would otherwise be limited to the braced expressions, making the declarations rather useless. Compilation should definitely not be made Turing Complete nor even NP-hard, but there are many situations where the current design isn't really adequate. 
How would you suggest someone write a function compatible with: void uses2dArray(array, rows, columns) unsigned rows; unsigned columns; double array[rows][columns]; { ... code goes here ... } without using old-style syntax? Requiring that programmers violate the convention of specifying an array followed by a size, or requiring that programmers add an extra level of wrapping to call a function that does so, seems rather icky.
From personal experience, I'd say it is really lightweight. It also allows you to use GPU rendering, which I believe allegro lacks.
Cool game. Is the source code something you can share?
Honestly, that doesn't bother me much. If K&amp;R-style declarations didn't exist to begin with, would anybody be proposing that as the mechanism to support writing arguments in a different order? No, we'd either accept a different convention or wrap it with a simple macro and be done with it. It's nice that the pre-standardization declaration style makes C99's variable-length arrays slightly nicer, but I'm not convinced it's enough justification to keep them around.
Aah, sorry, not the 100% of the code is mine and I'm also not very proud of it haha. Also, nothing really interesting in the code really!
Here's a Sokoban implementation in SDL I did some time ago: https://github.com/bor0/soko
you'll need opengl (that means glsl ) or directx anyway
No, it can't be done in less than O(M\^N) complexity because there is M\^N ways to place N balls in M buckets. I'd suggest you start with a recursive way to approach the problem of enumerating them: To place N balls in M buckets: enumerate all subsets of the set of N balls, this is the content of the first bucket. For each subset, place the remaining balls of the complement of that set in the remaining M-1 buckets. When you have a single bucket left, there is only one way to place the balls in that bucket. https://en.wikipedia.org/wiki/Combinatorial_number_system#Applications
&gt; I'm pretty sure that this is due to integer overflow. I've changed all of my variables to long unsigned ints but my calculation still expects an integer, so I'm not entirely sure what i'm supposed to change to make it work. You haven't changed one of them, the return type of `calculate_factorial`. Instead of just using `long`, I would highly recommend using `uint64_t` from `&lt;stdint.h&gt;` (on some platforms, `long` and `int` are the same size, so it's better to be explicit about things). `uintmax_t` is even better. Another thing that will help is to consider the intermediate values in calculations. For example, these two expressions are equivalent: calculate_factorial(i)/(calculate_factorial(j)*calculate_factorial(i-j))) calculate_factorial(i)/calculate_factorial(j)/calculate_factorial(i-j)) But the second one doesn't need a large intermediate value. And a last tip: factorials get very large very quickly. Think carefully about what x!/y! means and see if you can bypass calculating the full value &gt; Also, off-top question, does anyone have any tips on how I could turn the triangle around when it is printed? So it prints the last row first and the first row and creates an upside down triangle instead? Since your computation of each row is independent, all you need to do is reverse your first `for` loop.
So add a general mechanism for supplying a recipe by which identifiers may be assembled or exported to arbitrary combinations of bits of objects in the same context (struct, union, block, or compilation unit). This would simply be a generalization of logic compilers already need to handle bit fields. Having compilers recognize opportunities to exploit bit-field instructions, unaligned loads, etc. given such declarations would be much simpler than having them try to find such opportunities in "manually-written" code that uses masks and shifts.
How does the calculation bit work exactly? I've just changed it to a divide from the times and it is indeed giving me the same answers as the previous one, kinda interested as to why. How do I change the return type of calculate_factorial? Also, by reversing my first for loop, what do you mean by reversing? I've tried changing it to for (i=20; i &gt; rows; i--) But it kinda broke everything :D
How does the calculation bit work exactly? I've just changed it to a divide from the times and it is indeed giving me the same answers as the previous one, kinda interested as to why. How do I change the return type of calculate_factorial? Also, by reversing my first for loop, what do you mean by reversing? I've tried changing it to for(i=20; i &gt; rows; i--) But it kinda broke everything :D
&gt; How does the calculation bit work exactly? I've just changed it to a divide from the times and it is indeed giving me the same answers as the previous one, kinda interested as to why. `a/(b*c)` is the same as `(a/b)/c`, basic mathematics. Thinking about it a bit more, that won't actually fix anything in your case (`b*c` will only overflow if `a` overflows), but it's the kind of thing you need to watch out for when dealing with these sorts of problems. But it does lead to a better way instead of computing the full factorial. For example, let's say you're calculating 9!/6!. The answer is `(9*8*7*6*5*4*3*2*1)/(6*5*4*3*2*1)`. Notice the common factors can be canceled out, simplifying to just `9*8*7`. This is divided by 3! (6) to get 84. You can see how this technique can prevent needing very large factorials (though you'll need to be a bit more clever, as sometimes you'll want to cancel the factors with (i-j)! instead). &gt; How do I change the return type of calculate_factorial? Just change the prototype and definition to: long unsigned int calculate_factorial(int rows); &gt; Also, by reversing my first for loop, what do you mean by reversing? Right now, `i` starts at 0 and ends at `rows-1` (inclusive). To reverse it, you want it to start at `rows-1` and end at 0. What you wrote starts at 20 and ends at `rows+1`, which is completely different.
wrong statement .flat rate will be (n+1)^M . 1 here fo no-ball 
red - r ans so on. no-ball - n ryg yrg gyr nnn
C was the default programming language for game development until the late 1990s. For both 2D \*and\* 3D. AFAIK, for example almost all PlayStation 1 games were written using C and Assembly. I think this was more due to C++ being rather immature back then though (C++ was standardized in 1998) than for technical benefits. I can imagine that C programming starts to be a bitch for large software projects with large teams, especially with differing skill levels. In our student project we had 13 people working on the same code base and I'm glad it wasn't C. There would have been buffer overflow (and resulting data corruption) bugs and countless code smells left and right. Encapsulation is pretty easy to do in C++. We had some polymorphism which would be really nasty to do in C (virtual tables). Also, modern C++ is often touted as being much more productive than C. I'm not experienced enough to assess whether this is really significant in practice. Using something like std::vector is definitely more convenient than rolling your own data structures all the time though. RAII is also pretty nice sometimes. You don't have to worry about rewriting standard algorithms in C++. Biggest downside of C++ is its complexity. For hobby projects like what you are intending to do, I don't think it matters. C is perfectly fine for that... perhaps even Python would do if performance isn't too crappy. I would also pick C, just because I like it. I need some C++ experience for my CV though.
Is there a special reason why you chose C?
Alright thanks a lot I got it, one problem with the reversed loop though, the triangle does get turned upside down, but it seems like my program doesn't end and still waits for input even though the triangle has been printed already, so I have to quit the terminal to run it again. Any idea as to why this may be happening?
Because I wanted to put into practice the concepts of Data Oriented Design, i.e. programming caring about cache perf, data structures and avoiding common OOP pitfalls. To do this I had to un-learn some bad practices which, imo, are more prominent in C++, so I went with C (although I ended using a little bit of C++).
I'd recommend raylib, very easy to use with c programming. [https://www.raylib.com/](https://www.raylib.com/)
Thats exactly what I'd want to do. Program a game using only C and assembly. But I have no clue where to start. I dont even know of using a graphics library in C counts as being pure assembly and C
You have to use a graphics library. Things aren't as simple as writing a DOS game anymore where you just write to certain adresses and colors magically appear on screen. That is, unless you are planning to write a DOS game... I wouldn't bother with Assembly. It's a pain in the ass beyond implementing single algorithms and modern compilers are good enough. Although you can still do it, if you insist on doing so. Just use gas or nasm and call C libraries (e.g. SDL2) from Assembly and write all the logic in Assembly.
The amount of work required to handle two-pass signature scanning is trivial compared with everything else a compiler must do to support VLA types. I'll admit that using old-style declarations as a workaround for the lack of two-pass signature scanning is a bit icky, and I only discovered that possibility a few years ago. Another issue is the lack of a "pointer to some kind of function" type which would be analogous to `void*`, but of proper size to handle function pointers even on e.g. medium-model 8086 (where `void*` is two bytes, but function pointers are four bytes). One could simply cast function pointers to and from some arbitrary function type, but using e.g. `void (*)() getFunction(char const *name)` seems cleaner than having it return a `void (*)(void)` in cases where the actual returned functions will have arguments that will be known to the code that ends up using the pointer. Here again, the right approach would be to define a usable replacement before removing the old syntax. 
Another solution could be to give every item some sort of `selected` tag so it could pick another one if it hits one with `selected` set.
Sure, do it. It’s an exercise. You can do it with much success. But then: look at Lua. Lua is C on acid.
Closures should have a lifetime limited to the calling context, but could be very practically implemented given that constraint. Specify a syntax which, given a chunk of code within a function, would yield a double-indirect pointer to a function which accepts a `void*`. If the pointer is named `pf`, invoking `(*pf)(pf)` would cause the code within the block to execute, using any desired variables from the outer function. Typical implementation would be for the compiler to store the address of the generated function somewhere on the current frame and pass a pointer to that. Since the passed pointer would only be used by the generated function, the compiler would know the offset between the start of the stack frame and the address of the passed function, and could thus calculate the offsets between that and any objects of automatic duration that are used within the closure. 
`void (*)()` is just as arbitrary of a function pointer type for casting as `void (*)(void)`. Arguing that the latter suggests that the function won't take parameters is like arguing the former won't have a return value. A "usable replacement" for this usage (literally any other function pointer type) has been available for all 30 years this feature has been deprecated. You don't even have to change the type. The way I envision this, the syntax would be brought in line with C++. `void foo()` and `void foo(void)` would mean the same thing, and passing arguments to such a function would result in an error. Code that uses `void (*)()` for arbitrary function pointers isn't really impacted at all unless it actually tries to call the function pointer without casting (a bug waiting to happen, in my experience). Though it's not a bad idea to have a `void*` equivalent for function pointers. Maybe one could be added, with similar semantics as `void*` regarding implicit casting. It also couldn't be used except for casting back to a different function pointer (so you can't call it directly). This is not a prerequisite for removing empty parameter lists, but there's definitely benefit there. I also don't think the feature would go away entirely: C++ allows for `void foo(...)`, which means the same thing as C11's `void foo()`, which is there for compatibility reasons. I'd imagine C2x would allow this as well. Any code that breaks (which will happen at compile time) can have `...` added to the parameter list to restore prior functionality. But, speaking from experience, adding a proper parameter list is a much better solution, and that's what would be advertised. There's a good chance a bug due to the default argument promotion rules is just waiting to be found.
I would think the logical thing to do with the old syntax would be to say that implementations may, at their leisure, treat calls to functions with old-style declarations as equivalent to calls to prototyped functions, process them as using a different calling convention, or reject them altogether. I've seen some not-quite-conforming implementations where old-style function definitions would produce a symbol with a different name from new-style ones and would use a different calling convention. IMHO, such treatment should have been allowed on platforms where it would make sense, and where it may be necessary to interface with outside modules using both conventions. Incidentally, another feature that many compilers offered before C89 which I think should not have been lost was the ability to have optional arguments. If a function will either use or ignore its later parameters based upon the value of earlier ones, requiring the caller to pass meaningless values will often compel the generation of sub-optimal code. If there had been a syntax to specify that a `foo(int x, __optional int y)` could be invoked with one or two arguments, there should have been no difficulty implementing that on any platform. In most cases, call-side efficiency could have been improved and, at worst, a compiler could have simply passed a meaningless default value. 
The range of thread semantics an implementation will support will generally depend upon the environment where it is run. IMHO, the Standard should focus on defining the intrinsics necessary to allow a freestanding implementation to exploit whatever threading features a programmer knows about in the environment, rather than worrying about having the language provides the features itself. For example, many embedded operating systems provide for only a single thread-local object of pointer type. It would be useful for a compiler that might be used to target such an OS to provide a means of specifying that all thread-duration objects in the program should behave as though declared in a single structure whose size would be a link-time constant, and all accesses to that structure should be done using a certain pointer as a base. The programmer would be responsible for ensuring that space gets allocated for each thread's objects, but the compiler would automatically accesses to `threadDurationObject` into `currentThreadInfo-&gt;threadDurationObject`. Such a design would allow a programmer to use an implementation with an embedded OS of his choice, without the implementation having to know or care about the details of how the embedded OS works beyond the identity of its "current thread info" pointer. 
SFML!
Yep, exactly. That and using a little bit of templatized functions in a very specific part of the code. No classes though, nor news, constructors, etc on my part.
&gt;sscanf(argv[1], "%s", level_name); Buffer overflow vulnerability
As is the C way...
&gt;40 years of experience Wouldn't that give you a big leg up on doing things right from the beginning? OP is just starting, I think it's important to make some mistakes first so there's proper groundwork. Once you have that experience, I do think it's better to do things right from the beginning. It would also help avoid parroting common paradigms without really understanding why they're needed, and to know what to take away from them to accomplish your goals.
Please consider making a link post next time.
SDL2 is wonderful. It does have sound support too. It's very easy to use, and you can do anything with it. I think you should give it a try first.
I've used it since back when it was mostly DOS focused. It's grown quite a bit but it's still the same, easy to use library. I fully recommend trying it. 
Support for the mechanisms necessary to support thread-duration objects should be independent from built-in interfaces to threading mechanisms the compiler knows about, since--especially with freestanding implementations--a programmer will know things about the environment the compiler doesn't. The ability to specify that objects with a certain qualifier should behave as though they are members of a structure accessed through a pointer with a designated name is something that some linkers may be unable to support, but which should be supportable in consistent fashion when available. Rather than classifying things as "implementation-defined", the Standard should recognize a category of implementations where actions are defined in terms of interactions with the environment; what the environment does with those actions should be recognized as outside the responsibility of the implementation. For example, if directives were included specifying that it requires such an implementation, a program like: void main(void) // Never exits { (unsigned char volatile*)0x85 = 0xFE; while(1) { (unsigned char volatile*)0x05 = 1; (unsigned char volatile*)0x05 = 0; } } would have behavior defined as writing 0xFE to byte address 0x85, and then alternately writing zeroes and ones to byte address 0x05; the C implementation wouldn't need to know or care about the fact that on the microcontrollers upon which such code would most likely be run, the first write sets port pin A0 to output and the remaining writes alternately set it high and low. If one specifies things in such fashion, there isn't really a need for many things to have Implementation-Defined behavior other than traits such as the number of bits in various types, and even those wouldn't need to be Implementation-Defined if there were a directive to specify "Either treat `int` as a 16-bit type, or refuse compilation".
&gt;the Standard should recognize a category of implementations where actions are defined in terms of interactions with the environment; what the environment does with those actions should be recognized as outside the responsibility of the implementation. That's *IMPLEMENTATION DEFINED BEHAVIOR*, LITERALLY that's behavior, defined by the implementation of the compiler &amp; CPU, and is well documented, THAT'S IT. The C standard is *PLATFORM AGNOSTIC*, stop trying to force it to stop being as such.
You want to print M^N permutations. And do it that less M^N times. I'm not sure I understand the question.
I'm not trying to be mean to you. This is psychosis.
This a game I built during a game jam using libSDL and straight C. It's called Broad Sword of Justice. Gameplay video: https://www.youtube.com/watch?v=A3bp7EPcRcg Horrible hackathon sourcecode: https://github.com/amirrajan/broad-sword-of-justice
yeah oder doesnt matter so "get rid of waste" expression should be added. I've done this early with success and you'll have smth simple(some sort of) in the end. 
With C and OpenGL, you have a few options. OpenGL is just a set of instructions that can be understood by the graphics card, and needs a library for managing windows to go with it. Three such libraries are FreeGlut, GTK and SDL. FreeGlut is definitely one of the easiest to pick up. They have come really good examples that are written in C++, but provide good experience for translating back into C: https://en.wikibooks.org/wiki/OpenGL_Programming, I made a translated version here: https://github.com/kion-dgl/3D-Cube. SDL is pretty much the de-facto standard, but the problem is there aren't as many resources in C as you might expect. This is what I've managed to put together: https://github.com/kion-dgl/Hello_SDL. GTK is an overlooked library. Most of the resources are for GTK2, but GTK3 provides an OpenGL widget that can be used with other widgets to create applications. I have three examples for Brickout, Invaders, Astroids in C here: https://gtk.dashgl.com/. 
YEh boi
You explicitly said “distinguishable” in your post and now you explain that the balls aren't distinguished at all. What exactly do you want?
`strncpy(level_name, argv[1], LEVELNAMESZ-1);` then?
boi 5 pm take hai. Kar diya? I'm able to sort the array, but don't know how to take input and store it in 2d array? like scanf doesn't include spaces.. but if user writes word by word then it great. I'm stuck. 
boi 5 pm take hai. Kar diya? I'm able to sort the array, but don't know how to take input and store it in 2d array? like scanf doesn't include spaces.. but if user writes word by word then it great. I'm stuck. 
If you're interested in embedded systems and C and assembly game development, you might want to consider homebrew gameboy development. There are several great homebrew development kits and many great and accurate emulators, the programming feels 'close to the metal', but the hardware is simple enough to be fun to program, yet capable enough to handle some fairly complex 2D games and effects. But it's not so simply that you don't get to learn anything! GBA development is ARM-based, so still somewhat relevant to modern systems, and it's a reasonably powerful system for 2D games. Plus, it's not too expensive to get hold of actual hardware and flash your code to a cart and see it running on real gameboy hardware. It's pretty fun environment to learn in.
This seems like what I want to do. I love my GBA. The idea that I could make a game for it makes me tingly on the inside. How do I get started???
You can create an array of n+1 elements, waste the first 2 elements and use the integer directly as an index in the array array[integer] = bla. Or you can map the 2-n range (integers) to 0-(n-2) ( array indexes ), by just subtracting 2.
2 to n is n-1 numbers bool* array = malloc((n-1) * sizeof(bool)) - 2; The minus two at the end is a little trick to map the indeces [0,n-2] to [2,n], just remember that it's invalid to access the elements 0 or 1 now.
Nope, that won't null-terminate the output if the input is too long (leading to a read buffer overflow)
But... why? Just allocate `n+1`. Does it matter if the first two are never used?
I'm showing him how to properly shift the range of an index, it would matter if you wanted an array in the range 1,000,000 to 1,000,010. You wouldn't want to allocate an extra 1,000,000 unused bytes.
Have you tried translating the Python algorithm to C? That said, something like this should work: #define POLY 0x31 int crc8(char buf[], size_t len) { unsigned short accum = 0; size_t i, j; if (len == 0) return (0); else if (len == 1) return (buf[0] &amp; 0xff); else accum = buf &lt;&lt; 8 &amp; 0xff00; for (i = 1; i &lt; len; i++) { accum |= buf[i] &amp; 0xff; for (j = 0; j &lt; 8; j++) { if (accum &amp; 0x8000) accum = accum &lt;&lt; 1 ^ POLY &lt;&lt; 8; else accum = accum &lt;&lt; 1; } } return (accum &gt;&gt; 8 &amp; 0xff); }
Of course it has to be distinguishable, if not how will you know which ball is in which bucket? Alright according to what you are implying, can you tell me in which bucket a specific ball is located when you have no means to identify that specific ball?
You said that it doesn't matter which ball is in which bucket, only which bucket is filled matters. But perhaps I have again not quite understood what you mean. It might be easier to think about your problem like this: you want to assign one of *M* buckets to each of the *N* balls. There are *M*^*N* ways to do this and its quite easy to enumerate all methods.
In the above deleted comment [u/alexeyneu](https://www.reddit.com/user/alexeyneu/) mentioned rgy, yrg, gyr(red, green and yellow balls) as three different combinations even though they are in the same bucket(bucket count M = 1, balls = 3). So I said that the order you place them doesn't matter. Hence here there is only one possible combination all three balls in the same bucket, here I also know that green, red and the yellow ball is in bucket number 1. If you take N = 3(red, green and blue) and M = 2(1, 2) the possible combinations would be M = 1 2 rgb 0 0 rgb r gb g rb b gr gb r rb g gr b 8 possible combinations, which is 2\^3(M\^N).
 &gt;tmp = divident[0 : pick] &gt;.... &gt; else: it's not c/c++ Doesn't openssl have smth on this?
It's a few years since I seriously played around with it, so I'm a bit out of touch, but the scene looks bigger now than ever, with way more tools and documentation than back in the day. Lots of links to tools and emulators can be found at [gbadev](http://www.gbadev.org/) and [GBA Development/Resources wikibook](https://en.wikibooks.org/wiki/GBA_Development/Resources). From recent discussions, people seem to like the [Tonc tutorial](http://www.coranac.com/tonc/text/toc.htm) as an introduction to GBA development. For flashing to a real device, you'll need to get hold of a flashcart + driver software (I used to use EZFlash II, I think it was, but I don't know what the modern equivalent is, I'm afraid). Have fun!
You are absolutely right! Thanks for the feedback. And thanks for the extra info about the nuances of the char types. I had not considered the use of `unsigned char` for UTF-8 strings. &amp;#x200B;
&gt;but i'm getting confused with how to index the integers from 2 to n into the array. I agree, it's weird wording. Just create an array of n+1 values. Set them all equal to true. In all your subsequent interactions with the array, always ignore the first two values (indexes 0 and 1). The point being that the value of the array element at any given index indicates whether or not that index is a prime number, and 0 and 1 are never prime numbers, so just ignore them.
Yes, that was my plan for tomorrow, but this is something so standard I'm sure it's already implemented in many ways and all of them better than what I can achieve myself. &amp;#x200B; Thanks for your code!
So will the array of n+1 create an array and fill it up with numbers going from 2 and adding 1 onto the previous number each time, so 2,3,4,5,6,7 etc? How do I set them all to equal true? Also, would this be any different if the number that the user will input will be a range, ie, in my program, the user will input a range of numbers, e.g. from 50 to 100, and the program is supposed to print all the prime numbers between 50 and 100.
How do I waste the first 2 elements? The second option you mentioned and the one that /u/Crysis456 explained seem a bit too complex for me at the moment and I don't understand much from them, meanwhile, n+1 makes more sense (if my understanding of them is correct)
Though I do recommend you to use a lookup table as a lookup table just performs significantly better.
There are a few traits of an implementation where a program could ensure that they work a certain exact way. For example, if a program leads off with: #include &lt;limits.h&gt; #if INT_MIN+1 != -0x7FFFFFF || CHAR_BIT != 8 #error "Sorry. This program requires 4-byte 'int'" #endif then the balance of the program could assume that "int" is a 32-bit two's-complement value stored in some permutation of the bits in four consecutive 8-bit bytes. For the remainder of the program, the integer storage format--aside from the particular choice of permutation--would effectively cease to be "implementation defined". Unfortunately, the Standard uses the same terminology for traits that programs can effectively demand as it does for things where an implementation could do just about anything provided it is documented in some form (with no requirement that users have any realistic likelihood of noticing it). There is no way, for example, that a programmer could guard against a capricious implementation which decided to almost always use two's-complement reduction when converting values in the range INT_MAX+1u to UINT_MAX to "int", but which would do something else if the value was coerced for an object declared as `volatile int larry;`. IMHO, the Standard should recognize a category of implementations where the only "Implementation-Defined" aspects would be those a program could validate, along with a category of programs whose behavior would be fully defined on all implementations that would be allowed to process them. The question of *whether* a particular program would be usable on a particular implementation should depend upon the traits of that implementation, but it should be possible to perform a wide range of tasks using programs whose behavior would be fully defined on all implementations where they run at all. 
If I do something like bol A[n+1] and then create a For loop to fill the array, will the array then be filled up starting at 2 and going up in 1,so A[n+1] = {2,3,4,5,6 etc...} ?
[This page](http://www.ross.net/crc/download/crc_v3.txt) contains not only how CRCs work, but a non-table driven CRC generator in C that can be configured for the size and polynomial. There's also [the universal_crc](http://www.mcgougan.se/universal_crc/), a C program to generate C code to calculate CRCs, either bit-by-bit or table driven.
&gt; then the balance of the program could assume that "int" is a 32-bit two's-complement value stored in some permutation of the bits in four consecutive 8-bit bytes. For the remainder of the program, the integer storage format--aside from the particular choice of permutation--would effectively cease to be "implementation defined". This is platform behavior, which is also implementation defined behavior according to the standard. &gt;IMHO, the Standard should recognize a category of implementations where the only "Implementation-Defined" aspects would be those a program could validate, along with a category of programs whose behavior would be fully defined on all implementations that would be allowed to process them. The question of whether a particular program would be usable on a particular implementation should depend upon the traits of that implementation, but it should be possible to perform a wide range of tasks using programs whose behavior would be fully defined on all implementations where they run at all. Stop trying to create a special class of implementation defined behavior, implementation defined behavior includes platform irregularities and other such things, there's implementations where CHAR_BIT == 9, https://news.ycombinator.com/item?id=3112704 trust me, there's a TON of things that are implementation defined, just not the library itsself (USUALLY!)
I've written a TCP/IP stack on a conforming implementation where CHAR_BIT==16, but all conforming implementations that process code that appears in a source file below the fragment above will have 8-bit characters. I think there should be a distinction between programs that might be processed with different meanings on different systems, versus programs that may be rejected by some systems, but will have the same meaning on all systems that process them. While the question of whether a program in the latter category is accepted or rejected may depend upon implementation-specific criteria, the *meaning* of such a program would not. 
I could use a million bucks. What do they want exactly?
If the array contains only Boolean types then it can not contain anything other than true or false (1 or 0).
clear math rule for finding n-th prime i guess
I wouldn't waste your time, some of these problems are literally thousands of years old and still have no solution, prob not gonna come up with one randomly
The below is legal as far as i know: void uses2dArray(unsigned rows, unsigned columns; double array[rows][columns], unsigned rows, unsigned columns) { ... code goes here ... } 
This code reads \\n characters as well. How to fix that?
If your target can efficiently test individual bits, I'd suggest: uint8_t result = CONST00; if (source &amp; 0x01) result ^= (CONST01 ^ CONST00); if (source &amp; 0x02) result ^= (CONST02 ^ CONST00); if (source &amp; 0x04) result ^= (CONST04 ^ CONST00); if (source &amp; 0x08) result ^= (CONST08 ^ CONST00); if (source &amp; 0x10) result ^= (CONST10 ^ CONST00); if (source &amp; 0x20) result ^= (CONST20 ^ CONST00); if (source &amp; 0x40) result ^= (CONST40 ^ CONST00); if (source &amp; 0x80) result ^= (CONST80 ^ CONST00); Define each named constant as the value the CRC should have when given the specified value as input. An alternative approach, which might be more efficient on some targets, would be to initialize `result` to the source, and then test bits of `result` rather than bits of `source`, but the calculation of constants for that is harder to describe. 
Yeah true, so where would all of the values for n+1 go? Sorry for the stupid questions but im confused :/
I can see **two** problems here. *) Greedy newline If we look at the [documentation for *scanf*](https://en.cppreference.com/w/c/io/fscanf) we can see a description for the %c format specifier that says: &gt; matches a character or a sequence of characters so the problem is that when you press enter (or return, if that's what you might call it) your input character along with a new line character (usually that is a 0x0a byte, or a **L**ine **F**eed character) are actually passed on. So then scanf reads your character, is happy with it, and then in the next round reads the dangling new line character still in the buffer. The simplest way to get around that is to change your scanf to look like this: scanf("%c%*c", &amp; A[ j ] ); And that should solve your problem. *) Ill-terminated string If you want to print your character array later, you are missing the trailing 0 byte (or the '\0' character). Hope this helps!
I guess I am not sure what values other than true and false you are expecting. Can you elaborate more on what you're confused about? The array `A[n+1]` only contains true and false values. The array indices represent all numbers between 2 and `n`. After the algorithm runs, the value at `A[i]` is true or false depending on whether `i` is a prime number. So if `i = 13` then `A[i]` should equal false because 13 is not prime.
Ahh that makes sense now, thank you!
Maybe try using intptr_t for v1 and v2? Maybe on your system int* and int are not the same size? I wonder what you're trying to do with this code though...
Prior to C99, there was a long-standing convention of passing pointers to variable-sized objects, followed by the size. As I noted, throwing convention out the window for the sake of limitations which are only present when using newer syntax, seems rather icky.
&gt;int result = printf(g3); printf's first argument is a format string! https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm Also, your g3 char array does not end with a '\0' byte. Thats what denotes the end of a string in C. &gt;*(int *)(v2 - 4) = 0; no wonder the compiler complains: int is not of same size as pointer presumably. So that cast is not good. &gt;*(int *)(v2 - 8) = (int)"%d...\n"; That line looks really bogus to me. What do you expect to happen? It will probably take the adress of the first element of the static string in memory... &gt;printf((char *)&amp;v3); again wrong use of printf, and you are trying to print the address on the stack of v3. BTW, %x is used for pointer formatting. &gt;result2 = v1 + 1; &gt;v1 = result2; why not just ++v1? Please don't take it personally, but this piece of code seems very random to me. What is the purpose? And, out of curiosity: what is your background? Are you an assembly programmer, or working on a random code generator(just kidding)? I'd suggest going through a few basic C tutorials first, just to get a feel for pointers and the standard functions and types and so on.
So I added your suggestions to my code and everything seems to be running fine now, but I am getting an exit status of -1. Is this indicating something went wrong? I am not longer receiving any errors with this code. 
The only linguistic reason programmers would ever need to use C-style strings for anything is that a string literal is the only kind of static object that can be defined at the place in the source where it is used. Even in C89, one could write a macro and library that would allow code to say, e.g. small_string_buffer(foo, 20); // Buffer for up to 20 characters [taking 21 bytes] med_string_buffer(bar, 4000); // Buffer for up to 4000 characters [taking 4002 bytes] small_const_string(boz, "Hello there!"); to declare low-overhead length-prefixed string objects called "foo", "bar", and "boz", any of which could be passed interchangeably to functions expecting a string, but having to create named objects for all the string literals used in a program would be rather painful. One could write macros to wrap string literals in C99, but the decision to guarantee that compound literals whose address is taken will behave as automatic objects would make it necessary for compilers to generate code that would make a redundant copy of those string literals every time they were used. 
I have no possible way to tell you if something went wrong. You haven't provided any details about what you are trying to accomplish, how am I supposed to tell you if a result of -1 is good or bad? Also, it's pretty clear that this chunk of code is decompiled out of some other program and I don't know how much of the original decompilation you have altered. When I see ecx used in 32bit disassembled code, I immediate think it is c++ and that ecx typically holds the 'this' pointer for a class instance. If I had to guess, I'd say that you decompiled some code and tried to manually incorporate a decompiled function into your program... but you've mixed up some of the variables/registers and now it is a mess. The lines with "\*(int \*)(v2 - x) = " are either setting a class variable (if v2 is supposed to be ecx) or modifying stack space (if v2 is supposed to be ebp)... but either way, line "v2 = 8" makes no sense and would cause access violations in later lines. &amp;#x200B;
&gt; Also, your g3 char array does not end with a '\0' byte. Thats what denotes the end of a string in C. Sure it does. It's initialized with a string literal and it's big enough to hold the terminating nul.
Oh true, sorry
Yeah I figured out that it takes the newline as an input. I somehow managed to solve my problem, cant even remember how tbh as I'm on my phone rn. But your solution is definitely better and I'll be sure to update my code when I get on PC. Thanks for taking your your time to explain it for me, cheers!
I'm not quite familiar with the malloc function yet, but I'll be sure to look more depth into it. Thanks.
Not sure, I'll check when I get on my PC. Thanks!
I still do that to this day, and i too want my size after my pointer! Rarely do i use the above syntax for it though, and i havent seen the compiler do anything particularly clever with it either, except maybe give `sizeof` some runtime effects...
So basically what malloc does is it tells OS "Hey DADDY can I have some M E M O R Y ?" And if it says ok, you get a valid address returned, where you are allowed to modify at least the size you asked for. If it says no, you get a NULL pointer and no actual memory, and if you don't check for it (do check pls and give error or smthing) and try to modify it or reference the Null pointer's contents, your program should crash. If you access outside the bounds you are allowed, hopefully your program crashes, because nothing that can happen after is good (don't do it). HOWEVER, when OS gives you memory it also says "BORTHER PLS RETURN MY MEMORY I NEED IT" "TO STAY ALIVE?" "YEE" ACTUALLY NEEDS IT TO STAY ALIVE LIKE A BOSS And you obviously agree because you want those sweet bytes. If you don't free(void*) and give back the address you borrowed from the OS after you are done with it because you are a greedy little vagrant, it stays in the program until it either ends, or until your filthy little fingers hoard enough memory to strain your house and then Daddy OS comes and spanks your hiney and crashes your program, taking as much of the stolen memory with him as he can find. But sadly some of it cannot be recovered until oh yes Daddy OS takes a quick nap with BORTHER CPU AND SITSER PSU AND MOTHER BOARD(Restart the compooter). Was this helpful?
&gt;int N=4, j=0; &gt;char A[N]; where did you try that?
Thats a weird way of explaining but I think I got it what it does yes! I just need to start using it now and get more familiar and comfortable with it.
You're going to need to provide way more detail to get any kind of meaningful answer to this. What platform, OS, etc? Unless you're working on bare metal, there's basically no such thing as a way to access any kind of hardware interface with no "functions or library".
Sorry, I got bored while I was writing the explanation so I threw in some stupid memes. Glad I could help.
Thankyou all for the replies. I really appreciated. I tried this and it works. tho got many warnings. I tried to mimic the goalseek function in Ms Excel. `#include &lt;stdio.h&gt;` `#include &lt;stdarg.h&gt;` `#include &lt;math.h&gt;` &amp;#x200B; `double sum(double a, double b, double c)` `{` `return a + b + c;` `}` &amp;#x200B; `double minu(double a, double b)` `{` `return a - b;` `}` &amp;#x200B; `double avg(double a, double b, double c)` `{` `return (a + b + c) / 3;` `}` &amp;#x200B; `double nliner(double x, double a, double b)` `{` `return pow(a, 2) + (a - 6);` `}` &amp;#x200B; `double goalseek(double* pf, int argn, int warg, double goal, ...)` `{` `double (*gn)(double, ...) = pf;` `double a[5], t1 = 0, t2 = 0, op = 0;` `int i;` `va_list ap;` `va_start(ap, goal);` `for(i = 0; i &lt; argn; i++)` `a[i] = va_arg(ap, double);` &amp;#x200B; `#define FARG (*gn)(a[0], a[1], a[2], a[3], a[4], a[5])` &amp;#x200B; `t1 = FARG;` `a[warg] = a[warg] + 1;` `t2 = FARG;` `op = (t2 &gt; t1) ? 0.001 : -0.001;` `while(1) {` `if(FARG &gt; goal) a[warg] = a[warg] - op;` `if(FARG &lt; goal) a[warg] = a[warg] + op;` `if(fabs(FARG - goal) &lt; 0.0001) return a[warg];` `}` `}` &amp;#x200B; `int main()` `{` `double goalseek(double*pf, int argn, int warg, double goal, ...);` `double ans = 0;` `printf("average of is 234, 456 and 876 is %lf\n", avg(234, 456, 876));` `ans = goalseek(&amp;avg, 3, 2, 900.0, 234.0, 456.0, 876.0);` `printf("If you want average to 900, C should be %lf\n", ans);` `return (0);` `}`
i didn't know its os specifiec ok can u provide me with function or library all possiblke ways
You might be able to use [non-canonical mode](https://www.gnu.org/software/libc/manual/html_node/Noncanon-Example.html). If this is for a real-time game and you don't want to use a game framework like [Allegro](https://liballeg.org/) or [libSDL](https://www.libsdl.org/), you will most likely need to use interrupts or polling. 
&gt; non-canonical mode what is non-canonical mode 
Try putting all of your password validation checks in one loop.
Look up INADDR_ANY.
Use INNADDR_ANY to listen on all local ips. https://stackoverflow.com/a/16510000 
There is no OS flow control, e.g. no input buffering. But because you purport to be developing a game, you are likely handling direct input or talking to Xinput/Linux/NT. More or less, keyboards that can support variable pressure input would fall in to two camps. The first "camp" is that which would send key input at a rate which is relative to the key pressure. The second "camp" would use extended HID commands or present a joystick/gamepad device with analog inputs. If it is the case that you do in fact have a keyboard which supports variable key pressure (and I have heard of such a thing on at least one occasion), you will most likely need to have the player set the keys up as joystick inputs. However, based on the wording of your original post and the responses you have provided, it seems unlikely that you have such a keyboard, as I can only imagine that the group of people that have such a keyboard would overlap pretty heavily with the group of people that know how to support such a keyboard. So, in shorter terms, it is _not possible_ to get this information from your keyboard because _keyboards do not register pressure_.
`fopen()` can fail even if a file exists. 
It's not "simulating" an array, it is an array. When you create an array, like this: char buf[64]; Here's what happens in your compiled code. Stack space is allocated for 64 `char`s, and the variable `buf` is assigned a pointer to this stack space. An `array` is space in memory, and the actual variable you use to refer to the array is a pointer to that memory. In other words, you can do this int main(int argc, char *argv[]) or this int main(int argc, char **argv) And `argv` *will be the same type either way.* The reason some people use the first one, with `[]`, is because it's more clear to the eye that you're expecting a pointer to an array, not just a pointer in general.
I may have interpreted wrong. Read the irc transcript for more detail. Do you possibly know any links that show this--the more graphical the better. I don't know how to visualize the ** or if I even should. 
char **x What's the type? char ** What is the type at char **? It's char *. What is the type at Char *? It's a char.
char ... a character char \* ... a pointer to a character. If you had an array of characters, one right after the other, your "pointer to character" could point to any one of those. You can use your pointer to visit each member in the array, one after the other. Okay, now a char \*\* ... a pointer to (a pointer to a character). If you had an array of (pointer to characters), one right after other, your "pointer to (a pointer to a character)" could point to any one of those. You can use your pointer to visit each member in the array, one after the other.
Thanks. I still can't see how this is anything like an array. There has to be a graphical representation for this somewhere out there.
It is a pointer to an array of pointers of type char. In main() it is the command line arguments which are strings. So an array of strings or more accurately, an array of arrays of chars. Each array ending in '\0'
https://imgur.com/TRFGG9R Does that help?
[removed]
You can also write the parameter as `char* argv[]`
I think that guy was explaining it badly. You can have arrays in C that aren't statically sized. As for links I don't have any off the top of my head, I just know how it works I guess. I'll try and explain it graphically. Let's say that you name your program `apple`, and you run it with the arg `banana`. This is what's in part of the program's memory. These memory addresses aren't real ones, but you should get the concept: 0xffffd000: a 0xffffd001: p 0xffffd002: p 0xffffd003: l 0xffffd004: e 0xffffd005: NULL 0xffffd006: b 0xffffd007: a 0xffffd008: n 0xffffd009: a 0xffffd00a: n 0xffffd00b: a 0xffffd00c: NULL So, you've got two *areas* of memory that your args are stored in. These areas are different sizes. One area lives at `0xffffd000`, and one lives at `0xffffd006`. Notice that `0xffffd000` and `0xffffd006` are the same size. Even though your args, which are arrays of `char`s are different sizes, these pointers are the same size. It's cumbersome to deal with multiple things of different sizes, but dealing with multiple things of the same size is a breeze. So, this array gets created at a different spot in memory: 0xffffd010: 0xffffd000 0xffffd014: 0xffffd006 `0xffffd010` is `argv`. It doesn't matter whether you call it `char *argv[]` or `char **argv`. `argv` is equal to the value `0xffffd010`. `argv[0]` is just an easy way of saying "whatever's at the memory address argv", and `argv[1]` is just an easy way of saying "whatever's at the memory address 4 bytes after argv." `argv[2]` is whatever's 8 bytes after argv, and so on and so forth. It's an array of pointers because it's an area of memory that has pointers in it. It's also a pointer, because this area of memory has its own memory address.
True, there are compiler enforced safeties to help make sure you know what you're doing.
https://i.stack.imgur.com/64Tgw.png on the right are character arrays (6 of them) On the left is an array, where each element is a pointer to one of the character arrays. thus, ptr is of type char *ptr[], or char **ptr
Question: If your program *does* need the memory, but the OS doesn't provide it (returns null from malloc), shouldn't the program crash? If you try to use that pointer, you'll get a seg fault, so it seems like expected behavior to me. Or maybe you'd want to notify the user of what actually happened?
Your outer loop should be the number of correct entries, `while (correct_entries &lt; 2)` then, you only increment correct_entries if they type a valid password now, the other trick is to use `continue` statements any time the entered password doesn't match the requirements. Continue statements will just stop the loop and go back to the top. So if doesn't pass the Capitol check, it just starts back up at the loop.
`char **argv` is a pointer, not an array. Pointers and arrays are different. You can use the same syntax to access them but that does not make them the same. Saying they are the same is confusing as well as wrong. 
At the bare metal they're both a memory address. You can dereference the memory address and copy or modify the content there either way.
This has to be the laziest response I’ve seen here in a long time. Go do your homework and come back when you have a real question.
In your example how is argv a pointer to pointer to char? I can't see that. 
&gt; If you had an array of (pointer to characters), one right after other, your "pointer to (a pointer to a character)" could point to any one of those. You can use your pointer to visit each member in the array, one after the other. I don't understand.
I can’t believe you actually wasted your time explaining to this OP. 
&gt; Looking at this argv looks like an array of pointers to char to me. You're not wrong. It is that. &gt; I can't see how argv can be a char ** Look at the memory again. `argv` is equal to `0xffffd010`. In the example, the variable's content is that 4 byte value, exactly. No more and no less. `argv` is those 4 bytes, `0xffffd010`. Those 4 bytes are a memory address. A pointer holds the memory address of something. `argv` is holding the memory address of something. The memory address argv is *holding* is `0xffffd000`. `0xffffd000` is a `char *`. Therefore, `argv` is a pointer to a `char *`. That makes `argv` a `char **`.
If you still don't see it, compile this and run it. #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { char **ptrptr = argv; // I'm allowed to do this because down at the bare metal, these are no different. printf("char *argv[] is equal to 0x%p\n", argv); printf("char **ptrptr is equal to 0x%p\n\n", ptrptr); printf("argv[0] is located in memory at 0x%p\n", &amp;argv[0]); puts("notice how its memory address is equal to argv[]."); puts("that means that argv is pointing at it.\n"); printf("argv[0] is 0x%p. notice that this is a pointer.\n", argv[0]); printf("*ptrptr is 0x%p. notice that this is a pointer.\n\n", *ptrptr); printf("argv[0] is pointing at %s.\n", argv[0]); printf("*ptrptr is pointing at %s.\n\n", *ptrptr); puts("because argv and ptrptr are equal, you can use them the same way"); puts("even though they're declared differently.\n"); // notice that from here downward, I've swapped the way I use argv and ptrptr. printf("ptrptr[0] is located in memory at 0x%p\n\n", &amp;ptrptr[0]); printf("ptrptr[0] is 0x%p. notice that this is a pointer.\n", ptrptr[0]); printf("*argv is 0x%p. notice that this is a pointer.\n\n", *argv); printf("ptrptr[0] is pointing at %s\n", ptrptr[0]); printf("*argv is pointing at %s\n", *argv); return 0; }
Someone told me it should look like this: https://hastebin.com/yakicoteqe.md
Someone told me it should look like this: https://hastebin.com/yakicoteqe.md
It's not a pointer to char. It's a pointer to char*. I literally don't see how you don't see it unless you're looking at different memory than I am.
In that pastebin link, *argv lives at* 0xffffd01c. argv *is equal to* 0xffffd010. 0xffffd010 (argv) *is pointing at* 0xffffd000, and 0xffffd000 is pointing at the letter `'a'`. That means 0xffffd000 is a `char` pointer, and 0xffffd010 (argv) is *pointing at* a `char` pointer. That makes it a char pointer pointer, `char **`.
C++ has a complex number type already...
Wrong sub, as this one is for C, not C++. Try /r/cpp_questions.
https://pastebin.com/MYxd3nRH sup dawg, I herd u liek comments so I added comments to that person's comments so you can have comments on your comments.
Thank you very much. I haven't watched it yet but, let's hope for the best. 
How do you visualize a `*char`?
Thanks for all your help. Is anything different in this one vs the one I posted?
Godspeed
Oh I see what you did. Thanks for all your effort. YOU'RE THE MOTHER FLIPPIN MAN!
Tnx for the reply. I talked to the proffesor responsible for the website and there were a few errors, missspelling in a test examle and on of the test files was missspelled. To answer your qustion. The assignment gave us assurance that we wont get fed a wrong file, maximum number of inputs is set to 100, we are not using command line the code itself has to contain the name, as for the for loop they told us to declare i outside even tho i dont like it for(int i) is much simpler and better
I believe you’ve misrepresented the Python 2.7 example: nowhere do the authors of the documentation linked elevate the one-liner over the multiliner. In any case, Python 2.7.x is just over a year from [planned obsolescence](https://python3statement.org/), so many of the patterns historically and currently advocated may change in the future. It’s a shame that topics like this often encourage language bigotry, and sometimes the reification of one’s favoured language over all others. I regard these examples, which are observations at the ‘surface details’ level, as icing on a cake: in fact, this is very close to lending undue weight to ‘implementation details’. The observed differences between these languages are a reflexion of the trade-offs, constraints, influences and optimisations that shaped the design and implementation of each language from the period of their births, up to the present day. Languages are also, for the most part, a reflexion of the kinds of problems they were designed to solve. This is an important point, since no language ‘gets it right’ on the first go; but because path dependency in any established language constrains large-scale change in response to continued developments in the application domains (e.g. software engineering) applicable to these languages, much like evolutionary adaptation each has to ‘work with what it has’. While implementation details are obviously very important, concepts are arguably just as much, or even moreso.
You can listen on one, multiple or all IP addresses. I assume you know how to listen on one. To listen on multiple (but not all) addresses, you just open ports on each of them and then poll for events. Listening on all addresses is simplier - open port on address 0.0.0.0 and operating system will do multiplexing for you.
If anyone is having the same issue, the Universal CRC generator solved my problem. Thanks a lot spc476!
Decided to do some digging and I found a problem. I am running Gentoo on my main machines and I see that I cannot get the necessary development libraries through portage. So I will have to see if there is a way to bypass this problem because this seems like a golden place to start.
Hey man I was trying to write a program with main that took apple and banana as arguments and showed the memory addresses as this does starting with argv (basically working backwards). I am making no headway. If this is super simple for you, can you do that to show me the consistency between what is in the pastebin. I figured like I could see this: 0xffffd01c: 0xffffd010 // argv and then this: 0xffffd010: 0xffffd000 // argv[0], AKA *argv 0xffffd014: 0xffffd006 // argv[1], AKA *(argv + 1) 0xffffd018: 0x00000000 // argv[2], AKA *(argv + 2) then this: xffffd000: a // argv[0][0], AKA **argv 0xffffd001: p // argv[0][1], AKA *(*argv + 1) 0xffffd002: p 0xffffd003: l 0xffffd004: e 0xffffd005: NUL 0xffffd006: b // argv[1][0], AKA **(argv + 1) 0xffffd007: a 0xffffd008: n 0xffffd009: a 0xffffd00a: n 0xffffd00b: a 0xffffd00c: NUL I know the memory addresses won't be the same but they should be consistent like they are here.
Banana fiber is used in the production of banana paper. Banana paper is made from two different parts: the bark of the banana plant, mainly used for artistic purposes, or from the fibers of the stem and non-usable fruits. *** ^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Unsubscribe**](https://np.reddit.com/message/compose?to=BananaFactBot&amp;subject=I%20hate%20potassium&amp;message=If%20you%20would%20like%20to%20unsubscribe%20from%20banana%20facts%2C%20send%20this%20private%20message%20with%20the%20subject%20%27I%20hate%20potassium%27.%20)&amp;#32;|&amp;#32;[**🍌**](https://np.reddit.com/r/BananaFactBot/comments/8acmq6/banana/?st=jfof9k8d&amp;sh=acd80944)
Nobody is going to do that effort as there are too many platforms to list all ways. Pick one.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Think about how you would do this by hand. You would look at the password one letter at a time. Then when you saw each element that made the password valid you would remember it. When you were done looking at the password you would check that it had all of the required elements. I would do this by using a loop to iterate over the password, then use flag variables to store whether or not each element is present. What I find helps when I am struggling to write a program is to take it one step at a time. 
Why should they?
Because you are using 3 different types of accessing it
`&amp;argv` is the address of the variable `argv`. `*argv` is the value stored at the location referenced by `argv`. `&amp;argv[0]` is the address of the first element of the array referenced by `argv`, and is equal to `argv`. If `argv` is an array, it is also equal to `&amp;argv`, but not if `argv` is a pointer. This particular example is misleading because `*argv[]` is not an array, despite looking like one. A function parameter declared as an array is actually a pointer to an array. It will behave the same in most respects but, as you can see, not all.
ubuntu
Are you writing a terminal application or a graphical application?
gui
ok. Are you using a Framework like SDL to develop your application? If not, then you need to look into how X11 does events; X11 (the thing that does graphics on UNIX-like systems) sends you a message for every key pressed and you can handle these.
keyword for search about the x11 graphics? cuz am unix user
I really like this guy, short, well edited videos and always to the point. It's a shame it has so few subscribers and views...
I was lucky enough to have him as my professor for Operating Systems, he was really good at teaching the low-level OS concepts in a way that was easy to digest. I’m sure his channel will pick up some steam, it looks like a relatively new thing.
What's wrong with a small amount of people viewing something as specific as systems? When did the amount of views/subscriptions become a deciding factor for quality? And what's with this generation's obsession with quantity over quality? Why can't the guy have a small but dedicated number of folks who enjoy his content?
It’s a shame because he isn’t receiving the recognition/monetary gain that other content creators have for videos that are often times not as informative or well made. I’m amazed at how hard you’re trying to find a reason to disagree with someone. Pull that stick out of your ass.
Again why does it always have to be for money sake? Maybe the prof is doing it in his free hours just because he enjoys it. He is already a freaking professor. Not everyone is out for recognition or fame or money. Other less quality content creators maybe raking in the moolah but may not have anything better to do than create loads of attractive content with lesser quality just to keep churning the pot and money. I think it has to do with the audience than the content creators themselves in this case, that better content has lesser viewership and vice versa. I didn't intend to disagree with the parent but was only emphasising the need to disregard quantity and appreciate good content, even if viewership is a tad lesser than what one would generally expect.
Looks interesting, thanks for sharing
I don't think OP used "pressure" to mean pressure-sensitive keys. I think they used it incorrectly as the noun form of "to press", as in "the action of pressing a key".
Yes, agreed. I could add that a certain topic can only be pertained to or elicit a section of the audience, that could be a small community or a few people who are interested in such niche topics or such. If one intends to tend a content to a large section of people, the content would accordingly be suited to that. Not all topics warrant a large section of an audience, and to each his own. On the last point, that is true that a positive and accepting audience generally reinforces that belief to the creator and the content is kept to a high standard by such environments. 
1. Your writing is *atrocious*. I absolutely cannot understand what you're trying to say with this jumble of words. 2. You're misunderstanding the problem. A bucket can remain empty, but every ball *must* be placed in a bucket. (To be fair, I didn't understand it either at first, but I figured it out after examining why N=2, M=3 yields 8.) So we can reformulate the solution as such: For each ball, it must be placed in one of M buckets. That means ball 1 has M choices, ball 2 has M choices, ..., and ball N has M choices. That gives us M \* M \* ... \* M, repeated N times, which is M^N.
Because of operator precedence. https://en.cppreference.com/w/c/language/operator_precedence `[]` is higher than `*` But you don't need to pass a pointer to `elements` at all, just pass `elements`.
It looks to me you are trying to dereference value stored in `elements[*top_index]`. Try `*(elements)[*top_index]`
(*elements)[*top_index]
Yes, that one. Sorry, it is hard to type special characters on the phone :) 
Trying to accomplish this. https://www.reddit.com/r/C_Programming/comments/9tfxhb/can_someone_help_me_understand_char_argv/e8wf35f/
I was trying to accomplish this: https://www.reddit.com/r/C_Programming/comments/9tfxhb/can_someone_help_me_understand_char_argv/e8wf35f/ I still can't see why they should be different.
Do you know why this didn't work? https://www.reddit.com/r/C_Programming/comments/9tixqb/why_dont_the_second_and_third_printf_print_the
That's ok. Someone else will help me. Thanks.
In canonical mode, terminal input is buffered. This means that input is not passed to your program until the user hits enter. In canonical mode, the input is echoed to the terminal and the text scrolls up after the enter key is pressed. In non-canonical mode, you read the input one character at a time, the input is not echoed to the terminal and the output does not scroll up. This is why I think non-canonical mode would be useful if you wish to write a 2D game in C without using any additional libraries or game frameworks. Most likey, you will also want to use [VT 100 escape sequences](http://www.cse.psu.edu/~kxc104/class/cmpen472/11f/hw/hw7/vt100ansi.htm) to position the cursor and allow you to "draw" on the screen.
I was trying to accomplish this: https://www.reddit.com/r/C_Programming/comments/9tfxhb/can_someone_help_me_understand_char_argv/e8wf35f/ I still can't see why they should be different.
&gt; &amp;argv is the address of the variable argv. Which is what I expect. &gt;*argv is the value stored at the location referenced by argv. Which should be the memory address of argv[0]. &gt;&amp;argv[0] is the address of the first element of the array referenced by argv Which should be exactly what *argv returned previously. https://www.reddit.com/r/C_Programming/comments/9tfxhb/can_someone_help_me_understand_char_argv/e8wf35f 
I left off a comma by accident in one spot, but when I fixed the comma and compiled with GCC I received no warnings or errors. Fixed version: #include &lt;stdio.h&gt; int main(int argc, char **argv) { if (argc != 3) { puts("pls give 2 args :(\n"); return 1; } printf( "0x%p: 0x%p // argv\n" "\n" "0x%p: 0x%p // argv[0]\n" "0x%p: 0x%p // argv[1]\n" "0x%p: 0x%p // argv[2]\n" "\n" "0x%p: %c // argv[1][0]\n" "0x%p: %c // argv[1][1]\n" "0x%p: %c // argv[2][0]\n" "0x%p: %c // argv[2][1]\n" "\n" "0x%p: %s // everything at argv[0]\n" "0x%p: %s // everything at argv[1]\n" "0x%p: %s // everything at argv[2]\n", &amp;argv, argv, argv, argv[0], argv + 1, argv[1], argv + 2, argv[2], argv[1], argv[1][0], argv[1] + 1, argv[1][1], argv[2], argv[2][0], argv[2] + 1, argv[2][1], argv, argv[0], argv + 1, argv[1], argv + 2, argv[2] ); return 0; } Are you on windows or Linux? `printf` for me is implemented in glibc, which Windows wouldn't have. Format strings on windows may be implemented differently.
&gt;it’s a shame that this quality content goes unnoticed. Yep, I meant exactly this! Thank you for trying to explain it to the other user. Anyway I hope professor Sorber will not be discouraged by the low numbers and keeps producing its contents which I really enjoy.
scanf leaves the `'\n'` in the input buffer. fgets happily reads this as an empty string. http://c-faq.com/stdio/stdinflush2.html
if he do not wanna functions it's not an assembler channel . But windows hooks're built-in so you're not right on that 
okay so this fixed it and I think I understand why but how do I approach similar tasks in the future? switch (choice) { case 1: while((choice = getchar()) != '\n' &amp;&amp; choice != EOF) /* discard */ ; for (int i = 0; i &lt; 5; i++) { printf("Enter book title: "); memset(booktitle, 0, MAX_LEN_BOOK); fgets(booktitle, MAX_LEN_BOOK, stdin); insert(&amp;head, newbook(booktitle)); printf("\n"); } break; 
Windows hooks are built into what? C is a general purpose language, it doesn’t have any non-CPU functionality built in.
&gt; \*argv --value of what's in argv which is a memory address which should be the memory address of argv[0] This is wrong. `x[y]` is short for `*(x + y)`, so `argv[0]` is actually `*(argv + 0)` and adding 0 doesn't do anything so `*argv` is the same as `argv[0]`, not as `&amp;argv[0]` as you thought. This is because an array, if used as anything but the operand to `sizeof` or the `&amp;` prefix operator is implicitly converted to a pointer to its first item. Note that since an arrays first items is always located right at the beginning of the array, it is always `&amp;argv == argv` and `argv == &amp;argv[0]`. I hope this helps.
no i means that u can do that with the help of functions of standard library
&gt; how do I approach similar tasks in the future? The FAQ gives the advice &gt; either use scanf to read everything or nothing. Since fget's way of avoiding overflow is easy and necessary, you could always use fgets and then then use sscanf to parse data from the read string
Why are you using `if` blocks and not `if..else if... else..` ? And you are incrementing `k` at way too many places. Why are you doing that? if (array[index] &gt; array[k + 1]){ k++; // &lt;----------- Why this? } ... ... if (array[index] == array[k]){ k++; // &lt;----------- Why this? } Your `for` loop is incrementing `k` already, isn't it?
You never initialize the values in `sarri` and `sarrj` to 0. Also, there's no reason for your arrays to be slightly bigger by 1 in each dimension.
into kernel . you'll not have without os
First thing I noticed is the array sizes. You are using 6 and 11 while you mention matrix to be 5x10 (and from the loops , that seems to be the case). I would recommend using macros at top for ROWS and COLUMNS to be used throughout code in case you are testing for 11 and 6 instead of 10 and 5. #define ROWS 5 #define COLS 10 Then, use ROWS and COLS in for loops and array initialization, etc. &amp;#x200B; Secondly, What do you see printed when you run the code for an example matrix? (You have a lot of printfs. can you share the output?) I ask this because it might be helpful to see what exact values you are seeing for your inputs. Can you try changing floats to doubles to see if it improves your output? &amp;#x200B; Thirdly, please check error codes and return values for all file functions and return/display errors appropriately. It will help you in debugging in the future. Lastly, it is good practice to close the file handle after use at the very end. (Use [fclose()](http://man7.org/linux/man-pages/man3/fclose.3.html))
Nope. You'll need to use something beyond the basic libraries that define C. You can do this, for example, with the `curses` library (which can be used if you are writing a text only game on a Unix or Unix-like system). If you are writing a graphical game, the graphics engine that you are using will probably provide a way to capture keypresses, but the standard C library does not.
 &amp;argv == argv is wrong. it's not an array it's char \*\*argv not char \*argv\[\].
&gt; It's so weird that it only affected [0] and [8], or that it sometimes worked. The errors C encounters when you don't do things correctly baffle me Since you didn't initialize those arrays, they're populated with whatever happens to be in that spot of memory at the time. Very often this value is 0 by chance, but sometimes it's not. Even that's an oversimplification: reading an uninitialized variable is called "undefined behavior" -- what I described is just one way that this manifests, but UB can cause all sorts of strange things to happen. (This isn't limited to C, BTW -- lots of languages will do strange things when reading uninitialized variables.)
[https://github.com/d3x0r/C-Examples/blob/master/c-argv.md](https://github.com/d3x0r/C-Examples/blob/master/c-argv.md)(reformatted pastebins into tables)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [d3x0r/C-Examples/.../**c-argv.md** (master → c47113a)](https://github.com/d3x0r/C-Examples/blob/c47113aa20e82f569b586360d5860cea62315fc0/c-argv.md) ---- 
I remember watching these when I first started. You'll have to look through to see if there are any advanced topics. [C Programming Tutorials](https://www.youtube.com/playlist?list=PL0170B6E7DD6D8810)
 ./average &gt; table.txt
Thanks, but that just printed it in one long line
What? I use C without an OS all the time. Many OS are even written largely in C. If your making syscalls into a kernel then you’re most definitely using a library.
Forget YouTube. Read source code. Do your own projects or participate in open source projects.
While I do have two C projects that I work on, I want to increase my knowledge on the subject. I want to know good practices, what not to do, etc. Kinda hard when simply just reading source code.
Thanks, but I know everything that he teaches in the playlist you provided.
 #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { printf("0x%p\n", argv); } There is a distinct construct of memory which exists that contains the argument strings. Unix puts them in a stack. This construct of memory is the true array. `argv` is not this construct. `argv` is an 8 byte value that is equal to the memory address where the construct begins. It is literally a memory address. You can print it in any debugging tool and dereference it.
Besides some conferences I can not think of any other instance where "experts" show how they code for the masses. Your only option is to read more books or read source code from projects you are interested in. 
Er, fprintf() and fputc() instead of printf().
Standford CS107 lectures are awesome. They helped me learn how to think more like a programmer and to make v generic functions in pure C.
Oh yes indeed, in OPs case that's correct.
&gt; Kinda hard when simply just reading source code. Read the documentation and design rationale in addition. Forget about videos. Except for the odd conference talk, there is almost no advanced material in video form. Videos just aren't a good medium for this kind of stuff.
You're going out of bounds and getting a random number from memory. int max; int start; int index; //get input printf("Where do you want to start in the list?: "); scanf("%d", &amp;start); //set max max = array[start] //loop for(index = start + 1; index &lt; 10; index++) { if (array[index] &gt; max) max = array[index] } 
Try changing `\n` to `\r\n`.
Nearly all video programming tutorials are awful. It's mostly the blind leading the blind, riddled with mistakes and bad practices. You're better off reading code, books, and articles. One exception is [Handmade Hero](https://www.youtube.com/channel/UCaTznQhurW5AaiYPbhEA-KA), where he's livestreaming writing a complete game. It's technically C++, but he mostly codes like it's plain old C.
I'm subscribed to him for a while now. Great videos.
No. argv is a variable. You can print its address with `&amp;argv`. It is a pointer variable which means its stored value is an address. The stored value is the address of the first element in an unnamed array of pointers which point to the argument strings.
https://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298 Expert C Programming
Thank you, but I'm currently reading the book you suggested.
Good find. Lots of good tidbits of information, well-presented too.
Nice. Then you already know how awesome it is. You'll learn a lot.
It seems like *you* are confused about what I'm saying. I understand that argv has a fucking address. I got over my fear of pointers in about 10 seconds flat. I don't consider pointers an even remotely difficult concept.
&amp; gets the *location* of a variable. * gets the thing pointed at by a pointer. if you have int x = 5; int y; int *intptr = &amp;x; y = *intptr + 1; Then you have an `int` variable, `x`, which is equal to 5 an `int` variable, `y` an `int` *pointer*, which is equal to the *location* of `x` and is therefore said to be *pointing at* `x` an assignment to `y`. `*intptr` gets the thing stored where `intptr` is pointing. Since `intptr` is pointing at `x` and `x` is 5, `*intptr` is therefore 5. `*intptr + 1` is 6, because 5 + 1 is 6. So, `y` is assigned the value 6. 
One of the most underrated Lego Moria video as well lol.
You claimed `argv` was an array. That is completely wrong. It is a pointer. Pointers and arrays are different. Since you fail to understand this elementary concept I assume you are a beginner, and I explained it to you accordingly. More importantly, other people read this chain; OP might have seen your post and been sucked in by your misinformation so I felt the need to present actual correct information. 
fprintf or fwprintf would be enough
I don't know of any channels that does advanced C and even talks are very hard to find. Off the top of my head I remember watching and appreciating these: - [21:Everything u need 2 know about pointers -Richard Buckland](https://www.youtube.com/watch?v=Rxvv9krECNw) when I was learning pointers, not that advanced - [Standford CS107](https://www.youtube.com/playlist?list=PLD28639E2FFC4B86A) already mentioned here, great series of lectures - [Advanced C Coding For Fun!](https://www.youtube.com/watch?v=BEQ3sRakIs0) networking stuff by Rusty Russell, that guy is really funny - [How I program C](https://www.youtube.com/watch?v=443UNeGrFoM) by Eskil Steenberg. This guy does graphics and game related things and it seems he really knows his stuff
Better than most other example code but someone should tell him that * `bzero()` is legacy * You can mix declarations and code and thus make use of struct initialization syntax that implicitly sets everything else to zero, removing the need for `bzero()`/`memset()` at all * You don't need to `memset()` a buffer prior to receiving (socket programming), you just need to set the NUL-Terminator behind the last received byte. * However even this is wrong, because the file you are downloading might *contain* NUL-Bytes, so a `write()` is much more applicable, hence no NUL-Terminator needed. Also he explains too less. It's just shoving okay-ish code out and that's all. He clearly has experience, but he's not gotten reviews much, lately, or he wouldn't make these mistakes.
Yeah, he compiles as C++ because he does like (judicious use of) operator and function overloading, but those are pretty much the only C++ features he uses. No inheritance, no templates, no constructors, etc.
Practice, Practice, Practice!
Not exactly c coding, but pretty awesome channel: https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN https://www.reddit.com/r/LiveOverflow/
In general, yes. Using fgets and sscanf gives you more control over the parsing and allows for easier error reporting. Personally I think it's a mistake to even teach scanf. 
That depends on what you want to do. For interactivity, I'd say that that's a good idea. For bulk data processing, there is no point in doing so.
Mmm, globals are a hot topic. Some people want to ban them altogether. I'm not that extreme, I think e.g. command line flags a suitable to keep in globals. They're suitable when something is written once and then kept around as long as the program lives (there a few other cases for them as well). But buffers do not belong there, they're by nature temporary objects. Stick it main to keep your sanity when the program becomes more complex. In a pure technical way, there's hardly any difference between a global and a local in main. The major difference is that the former is zero initialized while the latter is not. The local also takes up stack space but that's normally not a concern. 
&gt; The dangers of pointers and explicit memory management are overrated &gt; Less Boilerplate Code &gt; Less Language Feature ‘Anxiety’ It's kinda funny how this guy raises exactly the same points I commonly make when explaining my choice of C over other languages. Though, his wording and reasoning is much clearer than mine.
Thanks for the tip. I recreated some command line tools, but I have not yet dived in in drivers
Me using windows notepad on a linux file is precisely what happened. Thanks :)
Start by porting your old projects from high-level languages to C. You may not fully succeed (especially with objective-heavy things), but you will have a reason to write in C and only practice will make your skills better. 
Most of my stuff are REST-ful APIs or web stuff. I will certainly find something else to port, though. Thanks for the idea
&gt;The dangers of pointers and explicit memory management are overrated I don't know about this one. While I think I can manage to not have bugs like these in every other line by now (and my C projects are just unimportant hobby stuff anyway), I wouldn't be comfortable with e.g. writing a server application that needs to be secure in C. Static analysis might help with that but I'm not sure how good these tools really are in practice. That reason (and also productivity and regulatory requirements) is also why safety-critical embedded systems in cars, planes, nuclear power plants etc. aren't written directly in C but have their code generated from Matlab-Simulink models or other proprietary model-driven software engineering tools. C99 designated initializers (what the author uses in the code example for illustrating the point) are also a bit limited in functionality. For example, I can't initialize an attribute with the value of another attribute I just initialized a line before that. I thought this was annoying. I had this in the following code of a game project I wrote once: struct player player = { .width = 20, .height = 50, .x = screen.width / 2, .y = screen.height - player.height, }; The code doesn't work correctly, I would have to replace player.height by the constant 50 to make it work as intended.
That last sentence was on point dude! Great metaphor :)
&gt; The dangers of pointers and explicit memory management are overrated overstated* sorry that was killing me for some reason. the reason C has such a bitter taste to me is because I did a lot of my intro to programming and data structures in C/++, and for some reason the professor assumed we had a working knowledge of memory management. at that point "good API design" is just jargon that basically means, "do it good." but that's the part that gets the hate. it's unapproachable for beginners just grasping manual memory management because it allows you to make those mistakes. I undoubtedly leaked memory all over the place in those years. now that I'm learning rust, I've taken a closer look at C. I know it can be done well, but I also know it can go really wrong if you don't know what you're doing. 
&gt; The dangers of pointers and explicit memory management are overrated overstated* sorry that was killing me for some reason. the reason C has such a bitter taste to me is because I did a lot of my intro to programming and data structures in C/++, and for some reason the professor assumed we had a working knowledge of memory management. at that point "good API design" is just jargon that basically means, "do it good." but that's the part that gets the hate. it's unapproachable for beginners just grasping manual memory management because it allows you to make those mistakes. I undoubtedly leaked memory all over the place in those years. now that I'm learning rust, I've taken a closer look at C. I know it can be done well, but I also know it can go really wrong if you don't know what you're doing. 
I recently stumbled upon https://learnbchs.org/ 
Assembly instructions aren't entirely just for adding 1 and 2 together. For example, some architectures have instructions for computing square roots which have no corresponding C construct other than hoping the compiler is smart enough. There inline ASM or compiler intrinsics (which I prefer) can help.
But in that case using inline ASM would cost you portability and for what? Computing a square root in a couple less cycles? 
I use inline assembly to do things that I can't do in C. For example, touching core registers that aren't visible in C (such as the MPU registers) or to take advantage of instructions that aren't accessible to C (such as invalidating the L1 data cache).
I needed to read this. My first introduction to programming was C and I loved it. Been doing Node at work and I'm starting to get sick of it lol. Need to find some good excuses to write in C again. 
pstr in that diagram is of type `char *pstr[]`, not `char **pstr`. If it was `char **pstr` then the diagram would have another box and an arrow, since pstr would be a pointer to the start of the series of pointers denoted there as pstr.
Well you'd always use conditional compilation when your target platform isn't fix. And square roots were just an example. I remember watching a presentation of Google's new hashmaps where they used SIMD and more to achieve a 1% reduction in fleetwide-wide RAM usage.
It's a string array, or an array of strings. Example: argv[0]="programname" argv[1]="argument1" etc.
C has generics lmao. go back to rust shill.
You're calling `scanf_s` twice, so it expects you to write a number, twice. Just remove either the first call OR save the return value of the first call into a variable and check the variable.
On micro controllers with fixed time instructions you can create very precise timings. On i686/x64 the only common use I've had is for checking whether an integer operation overflowed in the quickest way. Most architectures have this, but C doesn't have a method for doing this, whereas most status register has an overflow bit. 
Do you mean where the `.c` files for `stdio.h` are? On a normal system, they are in compiled form and you just link with that compiled form (something like `libc.so`), so you don't need the `.c` files. The `.h` files just describe what functions and variables there are so the compiler knows what exists. glibc is open source, so [you can just look online for the source code](https://www.gnu.org/software/libc/sources.html).
I've removed the first scanf_s() but the issue remains.
I've removed the first scanf_s() but the issue remains.
So in other words the full "logic" for stdio and all its functions are NOT bundled in the executable, its up to the system that executes the file to link to the proper shared object (in this case libc.so). Or did I get it wrong
Rather the linker puts in the information for the operating system (or at least for the "runner") that it needs `libc.so`, which is then then loaded for you when the program is being executed. Also, some applications/systems might statically link the standard library for a reason or an another, so the standard library is part of the executable rather than a seperate file, but this is rather unusal for normal GNU/linux.
&gt; Pick the right language for a problem Good thing you said that. If you're writing something where you need to manipulate strings, you better not do it in C lmao
there are things you cannot really do \*well\* in C, like fully implement a preemptive scheduler. (one task is being suspended while another takes its place in execution)
Last I checked no, it doesn't. Unless you mean the _Generic thing that still forces you to implement the same fscking thing for all the types you care about, and all it does is tell explicitly to the compiler something the compiler is able to find for itself most of the time (it probably warns you). Don't even get me started on preprocessor macros.....
&gt; By the way where did you learn all that. Mostly reading bits and articles. I am reading pretty often on e. g. breaks and such, but I don't remember each article exactly (or from whom or where). From a quick web searching the web page ["Beginner's Guide to Linkers"](http://www.lurklurk.org/linkers/linkers.html) talks about linking and a bit about libraries (shared and static), which might be useful for you. Also maybe try adding "explaination" or similar for your searches.
In the old days we dropped to ASM when we needed it to go faster- usually graphics.
Consider writing an [interpreter](https://gitlab.com/sifoo/snigl) from scratch, it'll stretch your brain like nothing else.
I disagree with some of the comments here. I don't think porting old projects will be a good use of your time. I don't think working on old Linux kernel drivers is either, usually there is a reason why they haven't been updated and many require deeper knowledge of the devices. I would recommend you to find a couple somewhat active open-source projects on github and help them out. You can start out with something basic like improving the documentation. Slowly you will get a feel for the codebase and you can join in regular development. It will teach you a lot, many projects are grateful for people helping out, and it'll be a team effort rather than a solo effort. Another thing I personally like to do is to find challenges like Project Euler and just work on some of these. It not only helps you improve your math-jitsu, but also teaches you a bit about the language as you take it to places you wouldn't normally take it to.
One case is instructions that implement something for the processor that can't be done in any other way: lidt/lgdt, cpuid, in/out, etc.
Let's say you're writing a standard library. On architectures that support it, you'd want to use those instructions to speed up your square root function, so you'd do something like #ifdef __X86_64__ __asm__(whatever); #else /* Cross-platform square root implementation */ #endif
Really in that case I'd just make separate assembly functions and link them in. Inline assembly can get messy
Since when does having Generics means the compiler creates the code for you?
Don’t worry about “simplest” yet. Simple is HARD. If you are asking what is the easiest way for you to get to working code you are on the right track. First you want to understand what algorithm you want to implement. Diagrams are a good place to start. Next try writing pseudocode. Human language sentences wrapped in coding constructs. Get that code to a point where you can understand what is going on. It will help later if you can split it into functions here. Then start replacing your pseudocode with real C code. one function at a time. (this is also a good time to add unit testing) Once all of your code is converted it is time to do the final testing as debugging. 
1- Learn how lexers and parsers work 2- Write your own implementation to parse arithmetic 3- Read user input from command line 4- Process it 5- Return value 6- Profit. &amp;#x200B; Your end goal is for users to be able to enter `10 + 20 * 50` and get a valid result. To get you started you can discard operation hierarchy and parenthesis and once you get that working without operation hierarchy you can try to make it work with it.
You wouldn't. I've been a professional computer programmer for a very long time. I've written device drivers for video cards and many other devices. I've written the core kernel of an operating system, which took a fair amount of machine language programming. In all that time, I've only ever once done inline assembly in C (I needed to execute a 64-bit write in a driver without letting the compiler optimize it into something else.) The C language was *invented* to replace assembly language. For the most part, the only time you want to use inline assembly is to execute special machine instructions or access special registers. Normally only the core kernel folks need to do this. On some rare occasions, where extreme optimization is required, you might switch to assembly for the inner loop of something.
Perhaps the following table will help. The first column is the name of the variable, and there are only two, `argc` and `argv`. The type follows, then the address of said variable, and then the contents at that memory location. All the addresses are made up for this example. |name|type|address|contents| |-:|-:|-:|-:| |argc|int|0xa0000000|3| |argv|char **|0xa0000004|0xa0001000| ||||| ||char *|0xa0001000|0xa0002000| ||char *|0xa0001004|0xa0003000| ||char *|0xa0001008|NULL| ||||| ||char|0xa0002000|'a'| ||char|0xa0002001|'p'| ||char|0xa0002002|'p'| ||char|0xa0002003|'l'| ||char|0xa0002004|'e'| ||char|0xa0002005|NUL| ||||| ||char|0xa0003000|'b'| ||char|0xa0003001|'a'| ||char|0xa0003002|'n'| ||char|0xa0003003|'a'| ||char|0xa0003004|'n'| ||char|0xa0003005|'a'| ||char|0xa0003006|NUL| You can see that `argv`, at address `0xa0000004`, contains the value `0xa0001000`. That value is an address to an array of addresses. The address `0xa0001000` has a type of `char *`, and contains the address `0xa0002000`. The address `0xa0002000` has a type of `char` and contains a single character. Does this make sense?
 A simple flow would be: 1. read input 2. is input a number? if no, goto 1 3. convert input to number and store in accumulator 4. read input 5. is input an operator? If not, goto 4 6. store operator 7. read input 8. is input anumber? if no, goto 7 9. convert input to number and store in tmp 10. (here's where you'll be using a switch statement) a. if operator is +, accumulator = accumulator + tmp b. if oeprator is -, accumulator = accumulator - tmp c. if operator is *, accumulator = accumulator * tmp d. if operator is /, accumulator = accumulator / tmp e. (add other operators as fit) 11. print accumulator 12. goto 4 
There is already a tool to figure this out ;) https://gcc.godbolt.org/z/ZkQ19e
If you care about performance, you shouldn't be using linked lists at all. The performance of them are going to be abysmally bad for the vast majority of usage scenarios due to the constant cache misses during iteration. You might want to check out [this talk](https://www.youtube.com/watch?v=YQs6IC-vgmo) by Bjarne Stroustrup about it. 
Those are templates, not generics friend. seriously, that's the reason they're called a "template", they're a copy and paste structure for how to do X.
Again, templates are **one** possible implementation of generics. Java has generics too, and doesn't use templates. Rust also has them and they are also not templates. Haskell, lisp, all of them have generics. Tell me, how would you implement a generic hashmap on C? Using void*? How isn't there already a great C library of generic containers that everyone uses? Perhaps because C doesn't have generics.
Programs should generally wrap up inline assembly in (at least inline, if not actual) functions or macros, and not use any `asm` statements directly code that third parties are expected to read or bugfix. However, inline assembly is useful for more than just assembly code. For example, certain idioms like __asm__ __volatile__("" ::: "memory"); (GNUish) can—without a single inline assembly instruction—directly affect the compiler’s view of memory, use of registers, and interaction with the ABI. The above fragment tells the compiler that memory (i.e., pretty much anything whose address can be taken) may have been altered unexpectedly during the (empty) `asm` statement; values cached in registers must be spilled beforehand and if necessary, reloaded afterwards. Similarly, you can force the compiler to treat a specific object as modified with __asm__("" : "+X"(thing)); or to ensure a specific object hits memory by some point with __asm__("" :: "m"(thing)); etc. etc. Because of this, inline assembly can give you ways to work around compiler bugs (which we sometimes just have to shut up and deal with) by ensuring that operands end up in specific registers at specific times, or by preventing code motion or (mis-)prediction of a subexpression’s value. You can also implement intrinsic functions (e.g., `__builtin_`- or `__atomic_`- or `__sync_`-) that older compilers lack, allowing you to back-/crossport to older/incompatible compilers. Especially when dealing with older compilers or newer/peculiar architectures, it’s quite possible that the programmer knows better than the compiler what kind of code should be generated for specific sections, or needs some specific instruction sequence to be generated (e.g., for testing or hacking purposes). Doing that sort of thing in pure assembly usually means setting up/dealing with a full ABI calling sequence, which almost always requires a bunch of extra instructions around the call/return spilling/killing/filling/shuttling things even if there’re only a few instructions within the call. Inline assembly lets the compiler clone, move, reassign, etc. because it can better analyze the effects of the assembly statement and which operands belong where. Some compilers (Intel C, newer Clang) will extract inline assembly code and, if possible, analyze and optimize that like it’s normal C code. This is usually a good thing—it can let the compiler work around lazy operand assignment (e.g., just throwing literal register/memory operands in there vs. using the outputs/inputs/clobbers) or rearrange sub-optimal jump/jcc pairs. You can usually force the compiler not to analyze inline assembly by using dummy directives like `.if 1`/`.endif`, which will make it generate actual assembly code and run that through an actual assembler. This is useful for forcibly affecting value predictability/eliminability or marking something defined/used.
sure, plenty. why?
It's passed as a stack variable (typically), and is implementation specific. It can also be passed in a register. You can look at the result of gcc -S file.c for an example. 
Thank you; that was very educational. Key take-aways: * Traversing a linked list is much, much slower than traversing a vector. Each pointer you follow results in a cache miss. Traversing a vector goes linearly through memory and has fewer cache misses. * A linked list uses more memory than a vector, simply because you need forward and back pointers. * Following pointers is very bad for performance. I don't think it's practical to convert my application to use arrays instead of linked lists, but I'll definitely keep this in mind for future development. Luckily, I'm not traversing the list, just adding to the back and removing from the front.
There are, but that is the simplest and best implementation. 
 //This assumes m1 is larger than m1_len m1[m1_len] = 0; printf("%s", m1)
Not-at-all-quick but nowhere-near-detailed run-down on some of the stuff you asked: GCC pulls its headers from a few places; there’s one place for the “unhosted” or per-ABI/-target core set of headers like `limits.h`, `stddef.h`, or `stdint.h` (or `xmmintrin.h` etc.), which is usually under one of the lib directories (e.g., /usr/lib/gcc/TARGET/VER/include). The rest of the headers come from default system install locations, which are used for more general platform-specific and installed-library stuff like stdio.h and unistd.h. The compiler command line can also add to the include path (e.g., option `-I`), and there’s usually an environment variable (e.g., `CPATH`) that adds to the include path. Headers tell the compiler how to interface with code outside whichever compilation unit you’re compiling, and may give actual code for some (preferably smaller) things as macros and inline functions. Anything else would be unnecessarily duplicated if it were compiled explicitly into each compilation unit (e.g., all references to stdio.h require a stdio.c to be lumped in), and come link time the definitions in different object files would compete with each other. (If each object includes a `printf` definition, which one is the “official” one?) The linker by and large has no idea what a header file is, since it may be mixing together objects from languages with no preprocessor whatsoever. The only reference to header files left in object or executable files should be in debugging information (e.g., this file is declared in such-and-such file on so-and-so line), if you instruct the compiler to include that. For system built-ins, an extra wrinkle is that standard built-ins like `printf` may not actually route directly to external `printf` functions; e.g., on GCC, `printf` may be `#define`d to `__builtin_printf`, which may allow the compiler to reduce things like `printf("%u\n",3)` to `puts("3")`, or which may just fall back to an actual call/reference to the (actual) external `printf`. If `printf` is declared as a function by the header, it’s usually declared with some extra stuff nowadays that lets the compiler at least run basic checks on format strings (e.g., `__attribute__((__format__(__printf__…)))`). References to external symbols are left in two places in .o (object; .obj on DOS/Win) files, as zero or some offset in generated binary code, and as a record in a special table section that tells the linker the missing symbol, what kind of reference is needed (e.g., offset from register, absolute memory reference, pc/ip-relative, thread-local) and where to stick the final symbol value in the binary. References into DLLs are usually a little more complicated, and may require routing through one or more tables constructed at load time. If you run `objdump -r` (`-R` for dynamic) on a .o file, that shows you what relocations (i.e., values of external symbols in the binary code) are needed and what kind each is. Option `-t` (`-T` for dynamic) shows all symbols used or defined. By default, your C compiler links with a few things without being told to; there’re usually one or two `crt*.o` (C RunTime) objects that provide for certain runtime constructs that need to be inserted in every executable (e.g., initial process setup and final process teardown), and libc.so or libc.a will be linked in for the core of the standard-C + POSIX library. libc.so is usually selected by default, but libc.a will be selected if `-static` is passed to the compiler/linker command-line. .a files are basically archives (hence the A) of .o files, which will cause any .o from which at least one symbol is referenced to be copied into the executable binary—this is the linker version of a preprocessor header file. (.so = .dll on Windows; .a = .lib on DOS/Win.) Core libraries like libc often break their .os up as roughly one function per .o, so no extra unreferenced code needs to be included; if they don’t do that, then either entire compilation units will be added in (e.g., you’re referencing `printf` and get anything adjacent to it), or the ISA+ABI+tooling need to support snipping out unnecessary bits (rare). Nowadays compilers support link-time optimization (LTO), which if you ask for it (`-flto`) will get tacked into the .o file along with debugging info, file comments, ABI extras, etc. The LTO extras give the linker an abstract representation of the binary code to work with, so it can do things like inlining and CSE that would otherwise require code to be lumped into a single compilation unit. This is a new-ish role for most linkers, which formerly stayed out of code generation almost entirely, and stuck to shuffling around large binary blobs. Libraries added with the `-l` command-line option are chosen from available lib*.a and lib*.so according to `-static` (→.a) and other link options; `LIBDIR` or `-L` can be used to change where these things are found, just like `CPATH` and `-I` change where headers are found. At run time, statically linked executables can pretty much be loaded directly into memory and jumped into; dynamically linked things typically run via a loader process that sets up the DLL parts of things, then calls ctors and `main`. That loader is what you call into post-load with `dlopen` etc., and the `-ldl` flag makes sure the public-facing API to that loader is available. Linux dynamically-linked binaries generally reference some ld-linux.so.VVV, which constitutes the dynamic linker+loader part of things. They may also reference a VDSO section provided directly by the kernel, which allows certain operations to be performed directly on memory when they’d otherwise require a system call. E.g., you might be able to get the current seconds-since-epoch value or twiddle the process signal mask with a single `mov` or `or` instruction that way, instead of imposing a bunch of extra syscall overhead. `dlopen` is what you use if you aren’t sure what library/-ies specifically you’ll need at run time. This is mostly useful for plugins or trickery, and the easiest way to use it is to set up explicit function pointers that you initialize by `dlsym`ming each manually. If this were done automatically, the dynamic loader would set up tables of pointers and automatically route you into them; since it’s not, you need to do all the symbol-referencing manually. So if you were referencing the `sin` and `cos` functions from `libm.so` manually (no good reason for this, but pretend) you’d usually do something like struct math_functions { … double (*sin_fn)(double); double (*cos_fn)(double); … }; … struct math_functions math; … void *handle = dlopen("libm.so", RTLD_NOW | RTLD_LOCAL); … math.sin_fn = dlsym(handle, "sin"); math.cos_fn = dlsym(handle, "cos"); … y = math.sin_fn(x); whereas normally you throw `-lm` on the command-line and just reference the functions from your code. `dlopen` usually prevents you from statically linking your executable, so it may reduce portability to barer-metal ABIs—you’ve got to include the basic DLL linker+loader infrastructure to enable `dlopen` to work.
What do you mean m1 is larger than m1_len? Wouldn't m1 be an array of m1_len size?
Here's a very good resource: &amp;#x200B; [http://www.delorie.com/djgpp/doc/ug/asm/calling.html](http://www.delorie.com/djgpp/doc/ug/asm/calling.html) &amp;#x200B; However, the trick is that the return value (if a pointer) being passed with a register. So, if you know what's about to be returned (like 'return a'), you could grab that address and mangle it. &amp;#x200B; char *DangerWillRobinson(char *unchecked_string) { char user_lookup[10]; char *permission = malloc(3); // Users always end with a :, and aren't ever greater than 10 characters. int p ; for (p=0;unchecked_string[p] != ':';p++) { user_lookup[p] = unchecked_string[p];} if (strcmp(user_lookup, "root") == 0) strcpy(permission, "777"); return permission; } This is a poor example made up by me as I'm tired, but hopefully this points you towards an interesting direction.
that C\_programming topic channel is for autists?
Thank you so much! You are the best! 
Thank you so much! You are the best! 
Nothing provided so far proves that. For instance char[] m1 = "abc"; Will result in m1 being of size 4. 
Not sure what you're talking about?
If m1 is not nul terminated, would this still work? Sorry just trying to learn. I appreciate the help.
Not sure what you're talking about?
To me that was explicit enough... but ok i'm offtopic, sry.
Write more code in C. Pick something you've never tried before and just do it. The only way to improve ANYTHING IN LIFE is to practice it. Coding, Cooking, Sex, etc. No amount of watching videos is a replacement for DOING IT.
&gt; Again, templates are one possible implementation of generics. YOU are the one saying that C's _Generic doesn't count, so thanks for making my argument for me...
What's wrong with memset and memcpy?
Yeah, use the standard functions. Between your compiler and standard library they're going to be doing things that are best suited for the size of data being copied and your platform. 
Are you trying to determine this from a binary or can you modify the source code? If you just have the binary that is going to be really tough unless you are doing this with un hosted C. Most modern operating systems randomize where bits of code get loaded into the process's memory space, and also randomize the layout of the stack. Especially if it's an exe or elf image. This is one of the reasons stack smashing attacks are so much harder than they used to be to pull off. 
I am not trying to be clever and make better than the std functions, rather try to get used to use of pointer and coding in C. I don't think it's so bad to try to implement them again. Also, I wonder if I define them by myself, where I should take a look at for preventing side effects.
https://www.tutorialspoint.com/c_standard_library/c_function_fgetc.htm Maybe that is what you are looking for?
`string.h` is great imho and actually it is pretty programmer friendly you just need to get the numbers correct most of the time but thats it. funcs in there can split, join, concatenate etc pretty much what you do with "high level" languages. Btw have you ever seen rust `String`s and `str`s ? 
What C_programming topic channel and are you calling me an autist? It's cool if you are. I'm not. Just not very bright.
Jut put break after your line 12.
And how that will help me to create exactly 10 workers spawned from the initial parent ? it'll just run once and thats all in that case.
From first hand experience, if you are working on a legacy embedded C application, the old C compilers were primitive and often did very little optimization. Using ASM in a few routines could make noticeable differences.
No it will run once in the child and 10 times in the parent. The child gets a 0 PID and the parent the PID of the child, that way you know which bit of code you're in. That's why you have an if statement.
Oh i see that makes sense now 
in memory unsigned chars are same as signed
SIMD.
As i have understood it, in 32-Bit Systems its always passed as a Stack Variable and in 64-Bit Systems it is typically passed in a register.
Return value is stored in eax in x86 and rax in x86_64 in both unix and windows. . 
Oh okay i might have mixed up something there. Its been a while since i needed this. And I seem to remember that there was a difference between passing on different systems.
That's passing the parameters. In stack in x86 (usually) and registers + stack in x86_64. 
&gt; I am not sure how 2 empty spaces got into the value for key2[0]. You pressed Enter in between your two input lines. That was received by your program as a new line character, immediately after your first 5-digit key.
That is incorrect.
Note that I know not a single system where return values are on the stack. Can you name any?
Please do not post pictures of code.
Nope. Experts usually try to avoid as much trickery as possible as tricky code is code that is hard to maintain and likely to be wrong.
Please be civil.
Have you tried using `fwrite()`? fwrite(m1, sizeof (char), m1_len, stdout);
My trick for making string manipulation easier is to use `open_memstream` to get a `FILE` backed by an auto-resizing buffer. Then you can just use `fprintf` to build a string inside this buffer.
One reason to use linked lists is when you need to store pointers to the objects somewhere, you can't store pointers to the array because they are invalidated on relocation and element insertion/removal.
Imma rebel not civil...
&gt; One reason to use linked lists is when you need to store pointers to the objects At that point you probably have an architecture problem, because you're accessing the same object from two different places. Don't get me wrong, linked lists are definitely useful because they're simple to use and think about, but they're terrible for performance in most cases (or rather in all cases, but I can't be certain that there are no cases where despite being bad linked lists are still the best). That being said, premature optimization is the root of all evil and you can always come back and think about how to replace your linked lists with more optimized data structure when you hit a performance problem. Linked lists are perfectly fine for things that are not on the hot code path and/or for prototyping and/or applications for which performance is a secondary concern.
Yeah, I agree. I mentioned that because one time I tried to replace a linked list with a vector and the program worked fine up to N elements, then the vector reallocated and everything crashed.
In that particular case you can just replace pointers with indices into the vector,because those stay valid across relocations. 
You need can't have only one sides array. You need 'number' of them. Since you don't know the 'number' at compile time you should allocate all you arrays at runtime with malloc
I was given the task of finding where system calls like gettoken() or getprocess() gets its returm value before it is stores in rsgister ex
for char vs unsigned car: printf don’t care. for the size, see the comment. 
If performance is a concern, I would avoid both zeroing and copying arrays if possible. It would be faster to pass the array as pointer. And instead of zeroing the array, I would make the array part of a struct that has a field to indicate length of the data in the array. When the array needs to be zeroed, I would just set the length field to zero. 
meet us half way and show us the code that's not working....
Neither are system calls as far as I know and system calls are not tge same thing as functions. In fact, I've never heard of either name.
Yeah ok, but not for scalar values.
Totally agreed. I should have said "normally in a register.". I misled with my earlier statement. I blame trying to answer this question while tired. 
If you don't have a code segment to share, can you share a state diagram or a truth table you're after? I know you think you've specified the problem, but there are about a dozen ways to do what you're currently describing, but most of those will likely be wrong due to a hidden condition you aren't telling us about. 
I don't really understand so is this equivilent to arr[number][sides]? why do we need a pointer to a pointer? could you explain the code a bit? thank you in advance
You can just treat a 1d array as 2d with math the formula to get the element at x,y is array[y*width+x] 
Possibly when compiling to bytecode for a stack machine but even though the bytecode describes putting the return value on the stack, the virtual machine that runs it probably stores it in a register instead.
One other thought. When I'm met with a "state"-problem, I now immediately just go to a state-based system, instead of a series of if statements. &amp;#x200B; enum StateType { kRed, kGreen, kBlue }; enum StateType updateColor(int x, int y, int z, enum StateType current_state) { switch(current_state) { case kRed: if (x == y) return kGreen; return kRed; case kGreen: if (x == y) return kBlue; return kGreen; case kBlue: if (x == y) return kGreen; return kBlue; }; } &amp;#x200B; A few things -- yes, there are many ways to "simplify" the code -- making various mod operations, collapsing if statements/cases/etc. However, using this framework, whatever conditions you need to add to the system is now easy. "When the light is blue, only change when x, y, and z are the same" is now a simple statement, instead of trying to weave it through all of the states. &amp;#x200B; &amp;#x200B; &amp;#x200B;
[https://godbolt.org/z/YgbN8b](https://godbolt.org/z/YgbN8b) Here is how it should be written. arr\[number\]\[sides\] is wrong. It doesn't compile and error message is very clear. Array size must be integer type. Sides is float \*. You should really read more about C arrays and pointers.
The typical representation is allocating the whole matrix in a single `malloc` call, and then interpret the contiguous memory as a 2D matrix (exactly how /u/youaresecretbanned explained). struct matrix_2d { float* elems; int rows, columns; }; struct matrix_2d allocate_matrix( int rows, int columns ) { return (struct matrix_2d) { malloc( rows * columns * sizeof(float) ), rows, columns }; } And then you just access the elements depending on how you want them laid down. In C is typically elements of the same row are close to each other (row major): float* elem_row_major( struct matrix_2d* matrix, int row, int column ) { return matrix-&gt;elems + row * matrix-&gt;columns + column; } There are multiple posts about this in this subreddit. I suggest you to look for them.
From CppCon just a couple days ago: [Return Value Optimization: Harder Than It Looks](https://www.youtube.com/watch?v=hA1WNtNyNbo). It's mostly about C++ but the earlier parts of the presentation apply just as much to C.
You can't use the array notation to allocate arrays if you don't know number at compile time. Use something like: ```C float* arr = malloc(sizeof(float)*number*sides); if (are == NULL) { // Catch memory error } // Use arr // Eventually... free(arr); ```
Do not spam.
&gt; Shouldn't it run concurrently? I know I miss a point but what is it? Well, the operating system makes the programs run "concurrently", but it doesn't always has to be the case. It seems that the OS decided to run the parent first before the child. &gt; After that,my second question is when I define pid2 and wants to print its pid,it prints its pid in else if block even if there is no print function in parent to print it. Why is it? Can you tell us what you wanted to do and what the result is? Also, usually you would use pthreads rather than fork to do concurrency because pthreads creates threads which are cheaper than processes (and automatically share memory).
thank you all for your help. I thought I could solve this task without the heap but it's not possible. My uni suggested that I solve it without heap thats why I was confused.
If I run it multiple times,then Linux may decide to run child first,right? I just wanted to see what will be the process id of second fork and print it within first forked process.However,it shows it to me after parent process(or pid2 process) done. &gt;Also, usually you would use pthreads rather than fork to do concurrency because pthreads creates threads which are cheaper than processes (and automatically share memory). Oh,I see. I will practice pthread,too but one step at a time :) 
Actually you can avoid the heap using VLA (Variable Length Array) which is part of C99. [https://godbolt.org/z/drBgti](https://godbolt.org/z/drBgti) This doesn't compile in MSVC though.
Yup! In the game industry its not uncommon to be fighting for microseconds to guarantee the target framerate. Writing multiple, low-level solutions for each hardware target isn't uncommon. This especially happens in the console space, where the target specs are much lower than a desktop.
This will depend of the [Application Binary Interface (often shortened to ABI)](https://en.wikipedia.org/wiki/Application_binary_interface).
Updated
updated
No, it does not. Remember that the OS is free run whatever it wants. Maybe the OS paused the child before printing the pid2 and ran the parent till it ended. However, it looks like it is only getting outputted (written to terminal) when it tries to write an `\n`. In the parent, you don't do that, so it gets dumped to terminal after exiting. So both processes waits 10 seconds and the parents exits (and prints it in the terminal) where the child tries to print the PID which might take longer than exiting.
Here's how I typically do it: ``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct node { void *data; struct node *next; }; void * dequeue(struct node **root) { if (*root == NULL) return NULL; void *rc = (*root)-&gt;data; struct node *old = *root; *root = (*root)-&gt;next; free(old); return rc; } struct node * insert(struct node **root, void *data) { struct node **cur = root; for (; *cur != NULL; cur = &amp;(*cur)-&gt;next) ; *cur = malloc(sizeof(struct node)); (*cur)-&gt;data = data; (*cur)-&gt;next = NULL; return *cur; } struct node * enqueue(struct node **root, void *data) { return insert(root, data); } int main(int argc, char *argv[]) { struct node *mylist = NULL; insert(&amp;mylist, "HELLO"); insert(&amp;mylist, "ONE"); insert(&amp;mylist, "ONE"); insert(&amp;mylist, "TWO"); insert(&amp;mylist, "TWO"); insert(&amp;mylist, "THREE"); insert(&amp;mylist, "THREE"); insert(&amp;mylist, "THREE"); insert(&amp;mylist, "THREE"); insert(&amp;mylist, "THREE"); for (struct node *cur = mylist; cur != NULL; cur = cur-&gt;next) { printf("&gt; %s\n", cur-&gt;data); } for (void *n = dequeue(&amp;mylist); n != NULL; n = dequeue(&amp;mylist)) { printf("&gt;&gt; %s\n", n); } } ```
Thank you for your cooperation.
I add \n now and it seems more concurrent to me :) If I may ask, is second fork belong to the child process because it comes after first fork? Or after parent process spawns first child process and continue to run, do both parent and first child fork another one and we have 4 process including parent?
Unfortunately, the formatting got mangled, and I'm having trouble reading it. For example, the asterisks were consumed turning some of the text into italic. Could you try indenting everything by four columns and try again? Backquotes don't work for block formatting.
&gt; do both parent and first child fork another one and we have 4 process including parent? Yep. Here is an visualization: (needs a monospace font) +-----------+ +-----------+ |parent | |pid2 | |pid=[pid]) +----&gt;+(pid=[pid])| |pid2=[pid])| |(pid2=0) | +-----+------ +-----------+ | | [pid] = some PID V +-----+------+ +--------+ |pid | |pid2 | |(pid=0) +---&gt;+(pid=0) | |(pid2=[pid])| |(pid2=0)| +------------+ +--------+
Thank you for your answer,I appreciate it!
Loop through the count array and find the largest element and its position. Then set the count at that position to zero. Process the cipher and repeat. The next time you loop through the count array, the element that has the greatest value is the char that appears with the second highest frequency. Set the count for that element to zero and process the cipher. Next pass through gets you the char with third highest frequency. There is a potential problem with your 'decrypt' method. You are changing the text. Make sure you restore it before trying the next shift. 
First find and print the most frequent character _(bonus points if you create a function for that)_. Then use that character to decrypt the text _(more bonus points if you create a function for that)_. Now set this character's frequency to zero and repeat the first step. This way you will find the second most frequent character. It's fine if you copy-paste the code three times, but once you have it working try to replace it with a for loop.
Check out Duff's Device for something similar (but no, it's not used anymore). https://en.m.wikipedia.org/wiki/Duff%27s_device
The only kind of linked lists I use these days is the embedded double linked [kind](https://gitlab.com/sifoo/snigl/blob/master/src/snigl/link.h), preferably in combination with [pool](https://gitlab.com/sifoo/snigl/blob/master/src/snigl/pool.h) allocated values which fixes most of the downsides compared to vectors while supporting stable pointers.
This is C++. Try r/cpp
Lower case c on cout
thanks a lot :)
/r/cpp_questions for c++ related questions 
If I remember correctly this relies on a compiler extension GCC started to provide. It precisely avoids heap allocation (kind of using [`alloca`](http://man7.org/linux/man-pages/man3/alloca.3.html)), but can cause stack overflow if you don't keep an eye on how big `number` is (the user can just enter the value of `INT_MAX` and you are done).
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I agree with you. I was on the phone and that was the first thing that crosses my mind. I think OP can learn from both approaches.
They are extension in C90 but part of ISO C99. MSVC doesn't support this, though.
Something that can make the `||` slightly easier to understand is comparing it to spoken language; when we say "X or Y" we mean "*either* X or Y". However, a boolean or means "X *and/or* Y". So it's enough that one of the statements is true for the entire statement to be true.
Look up shift based division by 2. 
If I wasn't allowed to use the modulo operator, I would probably logical AND the number with ((type) + 1) eg:((int) +1) and check if thats true. If it is, it's odd(given that the first binary digit holds 1) if it's not, it's even.
you'd need bitwise AND, not logical
depends on the architecture, abi, calling convention and what you are returning for the most common trivial cases (like returning a pointer or an integer) on windows/linux it's gonna be in eax for x86 and rax on x86\_64 [https://godbolt.org/z/wKABoO](https://godbolt.org/z/wKABoO) for non-trivial cases, it depends. and different compilers might do it differently too. just check the disassembly if you really care that much
yep. if (number &amp; 1) return Odd
Just for completeness sake, you can do it by continual subtraction (although this is a silly way to do it, other answers explain how to do it much more efficeintly). Just have a loop of some kind that counts down from the given number to 0. Keep an "is even" flag around, and on each iteration of the loop flip the value. The only benefit to this approach is that it doesn't need to do anything with bitwise logic, only loops and subtraction. 
the secret is that there is no secret, just write more C. challenge yourself with projects that you enjoy and above all think about making cool things and having fun developing your own coding style rather than improving. improvement will come gradually with experience as C's quirks become second nature. some of the stuff i enjoyed doing over the years: \* implementing a subset of the standard c library from scratch and compiling programs without the stdlib \* 3d software renderer \* gameboy emulator \* http server \* interpreter for a simple language like lisp \* bots/cheats/mods for MMORPGs or other another thing i love doing is watching uncut live coding streams/videos (for example handmade hero and bitwise) where you really see other people's workflow, thought process and style and sometimes pick up some tricks and develop new opinions on certain aspects of the language
there's a bit of a quirk with pointers to arrays vs the actual array, kinda difficult to explain but i'll try. if you have a normal array like \`\`\`int x\[64\];\`\`\` : \* \`\`\`sizeof(x)\`\`\` is the actual size of the array (256 bytes in this case) \* \`\`\`x == &amp;x == &amp;x\[0\]\`\`\` if you have a pointer to an array, for example \`\`\`int\* y = x;\`\`\` , it's gonna behave the same as any other pointer \* \`\`\`sizeof(y)\`\`\` is the size of a pointer, 8 bytes on x86\_64. this is a very common source of bugs as some people tend to use sizeof on stuff that has decayed to a pointer after being passed to a function and stuff like that \* \`\`\`y == &amp;y\[0\]\`\`\` \* \`\`\`y != &amp;y\`\`\` , because \`\`\`&amp;y\`\`\` just get you a pointer to the pointer \`\`\`int\*\* z = &amp;y\`\`\` this quirk is necessary because in the first case you don't actually have a pointer to begin with so \`\`\`&amp;x\`\`\` can't possibly give you a pointer to pointer and at the same time you would never wanna pass the array by value to a function without explicitly creating a copy yourself so they just have this syntax sugar where you can just pass x and it'll take the address
This guy nailed it
it doesn't make much sense to return the array, you are already passing a reference to the array's memory to the function, so any modification scrambleArray does to p effectively writes to your original \`\`\`p\[8\]\`\`\` so the simplest interface would be something like \`\`\` unsigned char p\[8\]; scrambleArray(p); /\* scrambles p in place \*/ /\* p is now scrambled \*/ \`\`\` if you really want it to return a copy for whatever reason you can have it take 2 pointers \`\`\` unsigned char p\[8\], done\[8\]; scrambleArray(p, done); /\* scrambleArray reads from p and writes to done \*/ /\* done now contains p scrambled \*/ \`\`\`
Another option is `((x&gt;&gt;1)&lt;&lt;1) == x`. Same as `x &amp; 1`.
No reason. 0x1 is another way of writing 1.
There is a lot going on here. What is this program supposed to do?
The lowest value bit must always be on for the number to be odd. So you could use a mask to see if that bit is on or not.
Note: Doesn't work for negative numbers on a 1's-complement architecture
I dont know how vfprintf is programmed, but i think it count all the format string (eg %d %s %lf) and use the counts to repeat the va_arg() and get all the var data. I might be wrong tho. Its really satisfying be able to use the variadic argument like this. Thanks for the reply :)
Thank you again for all the responses. I am sorry i have been so vague on the matter. I am currently going though the examples and resources you guys have dropped. &amp;#x200B; Just as a clarification, I am trying to figure out the buffer location of the pointers of windows C functions like getprocess() or getpid() so I can hopefully use it for malware profiling and make an ida plugin to return the addresses of return values for functions. hopefully that makes sense. Thanks again for all the feedback :) 
If you want to be complete, you should also discuss using a lookup table. A lookup table realizes your goal of avoiding bitwise logic and it's still an O(1) solution ... instead of iterative subtraction, which is always worse than O(1) time. But I have to ask: in what case would it be beneficial to avoid bitwise logic for a constant-time solution in favor of a slower solution?
And if you were worried about that, you could change it into a macro that picked a more complicated test if necessary: ISODD(x) (x&gt;0&amp;&amp;(x&amp;1))||(x&lt;0&amp;&amp;!x&amp;1)) (Untested, of course, but should work for ones complement)
A few questions to answer: * Does the function use variables besides parameters and those defined within the scope of the function? * Does the function write past memory given to it via a pointer (i.e. a buffer overflow)? * Does the function do input or output? If you answer "yes" to any of those questions, you have side effects. They may be intended (input or output) or not (buffer overflow) but those are the questions to ask if just looking for side effects.
As FUZxxl stated, professional C programmers will use `memset()` and `memcpy()` (and `memmove()`) if at all possible. And to expand upon what raevnos said, `memset()` &amp; co. are standard C functions, and when a translation unit contains `#include &lt;string.h&gt;` the compiler is free to optimize the calls right out and inline code that could do it more efficiently. Also, the second story of [Two Stories of Simplicity](https://prog21.dadgum.com/9.html) explicitly talk about setting memory to a fixed value.
At line 65, you return from add\_key with the pointer to some random place in the middle of the linked list if there is a match. However you use the return value of add\_key to update the list in the outer scope unconditionally, causing at this point the variable list in the outer scope to point some random place in the middle of the linked list. You might want to pass *a pointer to a pointer to keys\_t* (keys\_t \*\*list) to add\_key and assign to this if a new item is added. But generally speaking, you should avoid coding linked lists in C unless it is a school assignment. There are good libraries anywhere within 5 minutes of Google search.
Number xor 1
&gt;At line 65, you return from add_key with the pointer to some random place in the middle of the linked list if there is a match. How? I specifically use a local variable *tmp to point to the address list is pointing to. Unless, there is something else going on here? In add_key(): *list should be a reference to the address of the first node in the list. *tmp will then point to that first node and traverse until either the NULL address is reached (in which, we add a new key,) or we find a matching hand state and increment uc[up_card] within the matching key.
It's supposed to be a poker/Eucher program. My teacher wanted us to add just ACE, 9, 10, J, Q, K which I did then use a function with pointers to determine if the hand of 5 cards contains a Jack.
The way I had it is the way my teacher wants it.
Oh sorry, you are right. But I think the second half of my comment is still correct. I think you should use key\_t \*\* instead of key\_t \* so that the update is correctly propagated to the outer scope. When you assign to whatever key\_t \* variable in dealer\_num or in add\_key, it only updates the local variable so the variables in the outer scope that are supposed to hold the pointer to the head of the linked list are not updated.