This part I wasn't sure about, I knew most embedded projects in production used musl or dietlibc etc.. but just wasn't sure how many actually completely used it. Also, it isn't part of librini unless you specify it to be by the NO_LIBC macro. As I said below though, I think I'll remove it in the next release.
Technically, a freestanding environment indeed doesn't need to have a libc, but you can bet all but the most exotic ones do have a large subset of the standard library functions.
Iam using qt creator, Iam just setting up everything as told in a video tutorial. Since I have no experience with Qt, I want to do exactly as told so that I might not make grave mistakes which could leave me without a clue what I have done wrong.
Your quotes are fancy ones, not the simple `"` http://www.fileformat.info/info/unicode/char/201C/index.htm The 3 weird characters are because the characters is encoded in 3 bytes in UTF8. Your options are to save your text as a real text file, or to interpret the data as UTF8.
The syntax isn't really important, the concepts are. Try to understand them instead of learning syntax.
any good sites to help with concepts? good sites or youtube channels? the syntax is pretty simple but yeah its the concepts and when to use what
Feel free to spam the sub with good questions (not "can you do my homework for me", or "I NEED HALPPP!111!111" but "I'm trying to do X, and I don't get why Y isn't working" or theoretical ones) That's how I learned. I must've posted here a dozen times while learning.
/r/TechSupport
No, N is an array of 10 characters... and in your for loop initalize the variable like this `for (int J = 0; J &lt; 10; J++)` Why did you even create the variable I? it's never used... Dude what are the results of this code? printf'ing in a loop is totally normal and your code there is fine...
I don't know. Try to program a lot and read well-written programs.
okay I was worried that might annoy regulars in this sub but thanks I will!
Boy, I recommend you reading K&amp;R book and King book while having class! 
Comments are needed -- reading through the code I understood most of it, but some sections have me scratching my head wondering what's actually going on (such as `rini_get_node`), or wondering why you do something. You should *really* do doxygen documentation for all the functions.
I don't think this is so bad and could be desirable in some cases. For example, SDL implements their own C library replacement for some platforms, and one of those platforms is for Windows. Visual Studio is such a PITA with their C support, that removing the dependency on the MSVCRT.dll simplified a lot of things for binary distribution. For example, Visual Studio changes the MSVCRT dependency dll every version (e.g. MSVCRT120.dll, MSVCRT140.dll, and more recently a whole bunch of new crap like api-ms-win*.dll and VCRUNTIME140.dll.) So you have to track all this when you ship an app, and if you use a pre-built binary that was built with a different version of VC, you have to ship both versions of everything. There there the subtle issues of whether the single-threaded or mulitthreaded versions of the lib should be linked (and also the debug/release variants.) Looking at your code, I think you managed to avoid these functions, but also, only recently did Visual Studio get C99 functions like strncpy. So if you used these, you typically had to reimplement them any way for VS. That all said, platforms with a sane and decent standard C library that people can depend on, the compiler often has built-in knowledge for many of these functions and may optimize them aggressively using intrinsics. 
What is your definition of &gt; the syntax and your definition of &gt; the logic and give some examples of &gt; certain purposes
As an aside, it's pretty well considered to be bad practice to make typedefs of pointer types. There really aren't any advantages to it, and it can cause some confusion (as you've seen). Not that trying to change the mind of your instructor will help at all ... and it's very likely you'll come across code like this at some point in your career, so you might as well learn how to deal with it. All you really need to know is that `PCB_p` and `*PCB_s` are the exact same thing. You can drop one in for the other whenever you want. So this function: int assign_pid(PCB_s* pcb); is the exact same thing as: int assign_pid(PCB_p pcb); And you use the variable `pcb` inside the function the exact same, including dereferencing it (which feels strange since the `*` isn't visible in the type).
You should really write a simple testcase. You can answer questions like this yourself in 30 seconds that way. The declaration `PCB_p *foo` is declaring a pointer to a pointer to a PCB_s. That's not what you want. The typedef already contains the fact that it's a pointer. `PCB_p foo` declares a pointer to `PCB_s`, the same as writing `PCB_s *foo`. These names are terrible by the way. And hiding pointers behind typedefs is generally a bad idea, although it is valid in certain limited circumstances (such as when using opaque pointers as handles.) 
Thanks, I'm working on a test case now. But I appreciate the feedback. And yes, I'm not very taken with the names either, but they're instructor-provided, so there's not a lot I can do there!
Great, thank you for the help! The pointer typedef definitely did obfuscate things a bit; I would have guessed I still needed the `*` when passing the `PCB_p`, but obviously I was wrong! Good to know this isn't the standard, but also glad to know that it's not so rare that I'll never see it and have to deal with it.
Thanks! Looking over it you're right; it's probably better to modify the pointer to the original hashtable.
Wow, I think you really went the roundabout way in reading that file. Remember: strings are just character arrays, so `%s` would have done most of the work for you. But we'll leave that alone since you think you have it working. The way I'd write the search algorithm is the same way I do the search by hand: I look through the entire grid for the first letter in the word. Once I find it, I start searching in all directions to make sure the word matches. Up, down, forwards, backwards, and four diagonal directions. As long as each letter from that point matches, I keep going. If I get a full match on the word, I'm done. If anything mismatches or if I run out of letters (hitting the edge of the grid), then I resume searching the grid for the next time that first letter appears. Breaking this into a couple functions will probably help simplify the logic into more manageable pieces.
Yeah, my programming assignment forces me to scan each character one by one. It's a little silly. Thanks for the help with the idea for a search algorithm. How can I access just a single character from a string in my words array? I've tried several different things like tokenizing but I can't seem to find a way to get a single character out of the string. Thanks again for the help!
Please submit links as links instead of self-posts.
GCC in freestanding mode at least mandates `memset`, `memcmp` and a couple of other `mem*` functions.
There are 2 things I definitely noticed: 1) you are making speed claims because "it is just c"/doing everything by hand.however there are no measurements and no offense but if only I had 1e every time I or someone else thought they wrote "fast / performant" code just because it is in C. 2) a)when using one of several implementations of a function depending on a compile time option, it is better to put this option at one place and not everywhere,eg #ifdef NO_LIBC #define strtok rini_strtok #endif And just use strtok as you do when lib is present. b) even better: why name your own strtok "rini_strtok" and not just "strtok"? It is only used when lib is not available.
OpenBSD code is really good to learn C, start with ‘ls’ ‘cat’ and stuff like that.
the [gnu scientific library](https://www.gnu.org/software/gsl/) will do the job. i assume you don't want to implement your own library.. because if you do.. oh man. 
Like I said, strings are just arrays of characters, and you need an array of strings. So `words[a][b]` is all you need. That said, right now `words` is an array of 2500 pointers to `char`, which would work if you were doing dynamic memory allocation, but you probably want a 2D array.
Okay.. words is char**, so words[i] is char*. string is char* as well, so the assignment words[i] = string is valid. the problem is that string, which is a pointer, always points to the same location. And then you overwrite that location with zeroes with the memset. i recommend dropping string, and define words as words[2500][51] and writing each character directly to that array. then you just access word i, character j with words[i][j]
I would actually recommend scratch. It is an easy drag and drop programming language that teaches you logic. Yes, of course every language has its syntax, but the logic is pretty much the same. Learning it's in a drag and drop for may be more helpful to you
The following flag character is useful ("%-3.2f"). &gt; `-` The converted value is to be left adjusted on the field boundary. (The default is right justification.) The converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A - overrides a 0 if both are given.
is there a way to do it with it being right aligned instead of left aligned?
You can try something like `printf("$%7.2f\n",1234.5);`. The first digit is for the total number of characters including the decimal, while the second is for the amount after the decimal. So: printf("$%7.2f\n",1234.5); printf("$%7.2f\n",12.3); should output as: $1234.50 $ 12.30
&gt; so there's no way to make it so the dollar sign will go up against the amount then for the shorter one? edit: keeping them both right aligned i mean
Not easily as far as I know. You could write a function to figure out how many characters long your float is, then output the appropriate number of spaces before the dollar sign. I am probably overthinking it.
alright, i suppose almost perfectly aligned will do until i can figure out more complicated things, thanks
This subreddit is neither about C# nor about assembly, so your submission is off topic. Please ask elsewhere.
I think I've read that some libraries allow the caller to specify the memory management routines, so that the library could easily use an embedded project's custom routines. 
Pick a grade, 90% say, and step through each of your if statements in turn. Which ones execute? What happens when they do?
Just from looking at it, it looks like u did the math before the while loop. U should probably do after the loop when the values are in the variables. 
Thats how I had it originally and still doesnt work. I just put it back. 
Total percentage is not a function so it's calculating it's value based on the initial values of validPassing and validGrade. I'm pretty sure you've gotten confused with your valid* variables. I would probably name them `grade_count` and `pass_count`. You only need these two variables, although having the percentage as a separate variable is fine, just make sure you cast one of the integers to a floating point before the division or you'll get integer division. You have two redundant variables anyway. You can use floats instead of doubles since you're precision is so low depending on your teacher. The `||` symbol is a logical OR. It only returns false if BOTH of its arguments are false. Only one of your comparisons does what you want it to do. To only execute when both statements are true, use AND (`&amp;&amp;`).
I could use the &amp;&amp; on the last if but not the 3rd one and the 1st one right? That fixes my Total Pass amount and I see why but why is my average still coming as zero? ``` int main(int argc, const char * argv[]) { int grade, pass_count = 0, validGrade = 0; double totalPercentage = 0; while (grade != -1) { printf("Please enter a grade (-1 to exit):\n"); scanf("%i", &amp;grade); if (grade &gt;= 70 &amp;&amp; grade &lt;= 100) { pass_count = pass_count + 1; } if (grade == -1){ break; } if (grade &lt; 0 || grade &gt; 100) { printf("You have entered an invalid grade.\n"); } if (grade &gt;= 0 &amp;&amp; grade &lt;= 100) { validGrade = validGrade + 1; } } totalPercentage = (pass_count / validGrade) * 100; printf("Total amount of passing grades: %i\n", pass_count); printf("%.2lf of the valid grades entered are passing grade.\n", totalPercentage); return 0; ```
Try looking up some books in the school library if your class doesn't use a book. I find that programming books are generally structured pretty well. The two books I've read are Pointers on C and The C Programming Language 2nd Edition. Also, be aware that you may need to read much slower than a normal book to get all of the information. There should be no ambiguities in the information within the text, so there is only one way to interpret it. 
Your pass_count and validGrade variables are both int. This division will always result in a less than 1, which will be rounded to 0 in an integer operation. You need to either use doubles or just cast them both to doubles for the division operation. 
You are not initializing 'validPassing' yet using it to calculate 'totalPercentage'. Also why is 'totalPercentage' calculated at the top, that's not gonna work, it needs to be calculated after the while loop. Also 'validPassing' should be int, not double. You can cast to double in the calculation if you have to, but you should not have to anyway.
But they are whole numbers or integers in the equation so would that effect it?
Ya that was just something I was testing to see if it would fix it. Its back to the bottom now. This is the new code ``` #include &lt;stdio.h&gt; int main(int argc, const char * argv[]) { int grade, pass_count = 0, validGrade = 0; double totalPercentage = 0; while (grade != -1) { printf("Please enter a grade (-1 to exit):\n"); scanf("%i", &amp;grade); if (grade &gt;= 70 &amp;&amp; grade &lt;= 100) { pass_count = pass_count + 1; } if (grade == -1){ break; } if (grade &lt; 0 || grade &gt; 100) { printf("You have entered an invalid grade.\n"); } if (grade &gt;= 0 &amp;&amp; grade &lt;= 100) { validGrade = validGrade + 1; } } totalPercentage = (pass_count / validGrade) * 100; printf("Total amount of passing grades: %i\n", pass_count); printf("%.2lf of the valid grades entered are passing grade.\n", totalPercentage); return 0; ```
The result of the division is not a whole number, but since ints are used for the calculation, the program will round that operation to an int. Try (double) in front of both variables in the division operation. I think it will fix your problem. 
C is as close as you can get to the nuts and bolts of a computer without using assembly language. It's almost by definition the most efficient and compact language there is. If you dig into them, you'll find that all the other languages are (or were originally) written in C or C++.
When you calc 'totalPercentage' it's all int and will get cropped. You have to hint that you want float/double calculation so typecast pass_count and validGrade as double, and mutliply with a double representation of 100: totalPercentage = ((double)pass_count / (double)validGrade) * 100.0;
* Any place where performance and/or code size is critical.
Wow that fixed it! Thank you so much!! I tried putting that double in front of the two ints but it didnt work because I didn't have a set of (). I also didnt know that if the answer will be a double than the equation has to be too. I appreciate it man!
&gt; meaning they just ignore most new features There's new features?
No problem. Glad to help. Happy coding. 
&gt; We also enforce comparing all "booleans" to false (0). May I ask why? This sounds very unidiomatic.
Your [implementation](https://github.com/LloydLabs/librini/blob/38a140c9d14bd657ea31083e2b1bdd3dd31c3385/src/lib.c#L32) of `strncmp` is broken, this: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { printf("libc: %d\n", strncmp("a", "a", 1)); printf("rini: %d\n", rini_strncmp("a", "a", 1)); return 0; } prints libc: 0 rini: -1 Also, if you *really must* re-implement functions from libc, consider keeping their signature (in this case, use `size_t` for the size).
Ah, yes code size is often overlooked. The binary size of test projects I've made (C vs C++) is ridiculously different. For some tests I've done the C was 6x - 8x smaller.
We're not allowed to use libraries except a few basic ones like &lt;math.h&gt; and as a 2nd-year university student, I don't think i can write a library for it in a week. It's impossible. Thanks for the help, though. 
You would have to pad it yourself. You could use sprintf to print a string, then determine it's length, then pad accordingly
No tests = won't touch this with a 10ft pole. You should add unit tests that cover 100% of the code, and run them in CI as part of every commit cycle. It would also be wonderful if you could add a fuzzing environment, such as a simple [AFL](http://lcamtuf.coredump.cx/afl/) setup. You will find bugs that way, quickly. Without any of that, this is a hard pass.
&gt; How do I get my library 'out there', was wondering about submitting to have it as a Debian package but apparently it's hard. I was wondering about this myself for my application. Haven't looked into Debian packaging/approval much, but what makes it hard? 
 #include &lt;stdio.h&gt; #define WIDTH 12 int main(void) { int i, n; float fa[] = {1.24, 505.122, 3.7875, 7.1, 42.42}; for (i = 0; i &lt; sizeof fa / sizeof fa[0]; i++) { n = snprintf(NULL, 0, "$%.2f", fa[i]); printf("%*s$%.2f\n", WIDTH - n, "", fa[i]); } return 0; } 
Yes, I'm going to go for the caller to handle the memory management - I should take the same kind of approach when it comes to the libc implementations in here. Going to remove them today.
I believe your question has already been answered but I thought I'd just let you know that to format code properly here you need to put four spaces at the start of it. Reddit doesn't support the three backticks method.
The really basic library functions like memset and memcpy are optimized with unrolled versions when the size is known at compile time so I'd be most wary of doing something to defeat that. A wrapping macro or inline function that just calls the standard one is safe though.
Yes, I'm going to remove them today.
Added doxygen, thanks for the help.
Note: The syntax with three backticks doesn't work on reddit. You need to put four blanks in front of every line of code.
Yesterday's reply was from my cell phone. I just had a second look. 0) type casting the returned address of malloc is a c++ requirement. C compilers accept it of course but it is not required. 1) Other comments also mention documentation and comments. At the very beginning of your code I see this: seeks to the location of the start of the [parent] @param parent The name of the parent @param config_buf The configuration @param size The size of the confuration @return Returns an address to where the [parent] starts For me this is text book "bad comments": an input variable named "parent" is " the name of the parent"? isn't this obvious? the parent of what however? Documenting your code is about writeing staff that you had in your mind when writing the code that are helpful for new developers or yourself when you no longer remember what you did. 2) Where is your API header? Why aren't there function prototypes? 3) How am I supposed to use this library? If I saw correctly all of the functions in rini.c are static exept for one, is this the only function that users are expected to use? Aren't there any function arguments that should be const? 4) Expanding on my first comment: I guarantee you that most (if not all) of your hand written libc replacements will be at best equally fast on (at least) most platforms, dont take it personally: it is amazing what the people in glibc etc can do! 5) I find the name lib.h very poor! why not libc_utils.c or rini_libc.c or libc_replacement.c ? 6) Again expanding my 1st comment about libc replacement implementation, I would rewrite lib.h like this: #ifndef RINI_LIB_H #define RINI_LIB_H #ifdef __STDC_HOSTED__ void *memset(void *s, int c, size_t n); unsigned strnlen(const char* str, unsigned max); void* memset(void* dest, char set, unsigned size); int strncmp(const char* first, const char* second, unsigned max); int rini_memcmp(void* first, void* second, unsigned size); void* rini_memcpy(const void* dest, const void* src, unsigned size); #else #include &lt;string.h&gt; #endif #endif // LIB_H I would then name all the libc functions in lib.c with the same name as libc does and simply use the same guard to choose whether to compile them or not: #include "lib.h" #ifdef __STDC_HOSTED__ unsigned strnlen(const char* str, unsigned max) { bla; } etc etc #endif 
&gt; if the answer will be a double than the equation has to be too It's an expression, not an equation. But never mind. The exact rules are quite complicated, but you can think of it as “bumping up” from a smaller integer type to a larger integer type or from an integer type to a floating-point type. You could write the expression as `100.0 * pass_count / validGrade` and not need any casts, because `100.0` is a floating-point literal and forces the rest of the term to be “bumped up”, while `100.0 * (pass_count / validGrade)` wouldn't work because the fraction would be computed first (and rounded down to zero) before being “bumped up” for the multiplication.
Please don't declare pointers as `foo* bar`. The correct style is `foo *bar`. If you don't understand why, try explaining to a newbie what `foo* bar, baz` means.
We have coding requirements called MISRA C (It's an automotive standard for safe coding practices). It requires if statements are the result of comparisons, this means that we can't just do if(x) or if(!x). The point of this is to make things explicit i guess, but by comparing to false, we are effectively getting the same code. Plus, most micros have a not zero flag, which is often already set without a comparison operation.
Note that due to associativity that is the same as: double totalPercentage = 100.0 * pass_count / validGrade; since a double times an int is a double.
You are correct, and I was just being lazy :)
 first[a[c]-'a']++ `c` is your loop counter, iterating through the letters of the string `a` `a[c]` is a letter of the string `a[c]-'a'` converts that into a 0-based index. a=0, b=1, c=2 etc `first[a[c]-'a']` is the array element corresponding to the letter. `first[0]` is the element for `'a'` etc `first[a[c]-'a']++` increments that element. So when the 1^st `'d'` in the string is found `first[3]` changes from 0 to 1 So `first` ends up containing the counts of the letters in the string. "food" will result in `first` looking like 0 0 0 1 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 And this is why proper variable naming is important. `first` is pretty meaningless, as are `a` and `c`.
It looks like it is just counting the (lowercase) characters of `a`. Probably they used the post-increment operator because it is shorter than `+= 1`. The algorithm seems to be that it counts the letters for both strings and just compares the 2 arrays if they're the same (aka they've got the same amount of same letters) 
It's most definitely not. Look up an algorithm (just the steps) for how to find the eigenvalues, then implement it in C. Post back here if you have more specific questions 
This guy’s thing is the right solution. Something along these lines: char buffer[128]; sprintf(buffer, "$%3.2f"); printf("%8s\n", buffer);
For more general programming there is also /r/learnprogramming It’s really helpful, but be warned: there are a lot of “anti C” people over there.
The most likely outcome on Intel architectures is that the amount you shift left by will be masked down to its least significant 5 or 6 bits. [Standard disclaimer about UB killing your cat.]
here is the link I got the code from: http://www.programmingsimplified.com/c/source-code/c-anagram-program Ha. I didn't see it on the original code, but I did add it in the function when I saw that it would still attempt to compare the strings regardless of their length. I added an additional variable d if(c!=d) { printf("\nNumber of characters does not match\n"); return(0); } I guess my real question is why they have to post increment? What does it accomplish? Also, thanks for mentioning lower case, because I tried comparing 'Google' with 'glasses' and immediately got an error because of the case 
&gt; I guess my real question is why they have to post increment? What does it accomplish? Probably because it is shorter and increments the counter by one. &gt; Probably they used the post-increment operator because it is shorter than `+= 1`. 
I was gonna reccommend /r/AskProgramming too, but it's mostly webdevs, and my later, more nuanced problems didn't even get answers.
**Here's a sneak peek of /r/AskProgramming using the [top posts](https://np.reddit.com/r/AskProgramming/top/?sort=top&amp;t=year) of the year!** \#1: [Am I crazy for believing we should form a trade union or guild?](https://np.reddit.com/r/AskProgramming/comments/5hqkw5/am_i_crazy_for_believing_we_should_form_a_trade/) \#2: [Good Programming Youtubers?](https://np.reddit.com/r/AskProgramming/comments/6mpbg3/good_programming_youtubers/) \#3: [What's the best README file you've seen for an open source project?](https://np.reddit.com/r/AskProgramming/comments/6r6e7a/whats_the_best_readme_file_youve_seen_for_an_open/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [OOQQ/C_Programming_A_Modern_Approach_2Ed/.../**097_prgPrj016.c** (master → 72b7c76)](https://github.com/OOQQ/C_Programming_A_Modern_Approach_2Ed/blob/72b7c76dbe8733ef9a303f561c82afdb6726dd0d/08_arrays/097_prgPrj016.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnv2naz.)^.
Nothing. It's a built-in keyword.
thx. I defind the var outside of the for loop and it worked. thx
It's pigeonholed, unless you're making a pun on getting stuck using a language and I'm just too unfunny.
Look at C++11 and everything since.
I would warn you against using floating-point numbers for currency as it has rounding that is often unexpected by those that use it, e.g. `0.1 + 0.2 &gt; 0.3`. The recommended way for currencies is to use fixed-point integral numbers, typically counting in cents. Then you can print it with something like: `printf("$%3d.%02d", value / 100, value % 100)`.
Oh, right, those. I was ignoring them.
Probably because of the libraries that got sucked in.
I've gotten by with just having all the files named "*.c" I not sure what you're doing but something is wrong.
Use gcc (compiler) and gdb (debugger) . They can be accessed using Cygwin or MinGW. Or write C code in .cpp files in Visual Studio, which is a much richer IDE 
What's your step by step to starting a new file if you don't mind? 
Make a new file like you normally would but make the extension .c, if you add an extension inside the new file dialogue, it will not add .cpp so you're good to go. Or you could just rename files.
Not really what you're looking for, but, really, if you're on windows, it's worth considering doing C++ instead of C, even if you stick to C style C++ programming. C Programming on windows sort of sucks. (Besides, you'll have the other C++ features at your disposal as well.) However, for C programming on windows, I know the C++ compiler that comes with Visual C++ has a C mode in it. It, however, supports an old C standard. It doesn't support C99 as far as I'm aware of. I'm not exactly sure how you'd go about using the IDE for C programming, but I know the command line compiler has a C option. I guess that Visual Studio will identify that a file extension is .c and treat the file as a C source file (and not as a C++ source file). There is probably an option "New C Project" somewhere.
&gt; I was a promising programmer like you once, then I started writing Javascript --- *McDonald's cashier*
Thanks for the idea FatBabyBrother! Quick question about kernel patches... do simpler whitespace, documentation, style patches contribute to your kernel development street cred? Or do you have to make major contributions for your patches to mean something?
Wow, definitely wouldn't have expected that, but tbf I don't know a thing about the world of professional C. What field do you think has the best-written C code?
When sending out my resume, will my work experience doing backend and mobile stuff hurt my shot at embedded work? If so, I'll get some nice embedded side projects going to counter that. The question is, what side projects Q.Q
Thanks for the advice MrToolBelt. Should I try to place less emphasis on my backend and mobile work, and try to shift the attention to embedded side projects?
Thanks for the motivation CookBladeBakeAndCode, and congrats on making it! What tips do you have on getting interviews once your portfolio is set up? And how involved would you say your projects should be before being portfolio worthy?
I mean yes. It’s the standard library. In general though, c++ executables bloat quickly because it’s easy to lose track of what gets generated from what you write.
Definitely ramp up your side projects, and float your resume to jobs you’d want ASAP. Most hiring managers will overlook a few months to a year of CRUD development if you’re right out of college. The longer you wait, the harder it will get though. 
You’re mostly correct. Yes programming on windows sucks. No, MSVC isn’t completely C11 or C99 compliant. There is some good news though: it supports all of C99 and C11 that is needed to be fully c++11/14/17 compliant... which is a lot. I’ve found the best way to use VS (for me) is through Cmake. It will generate solutions for you, and set them up to compile as C. This also works if you want to use clang on windows, which has much better C support.
This dogma of using not using post increment assumes the code of the overloaded post increment operator is unavailable to read or that the developer is not competent enough to read it (in reasonable amount of time) and thus the retard (puny developer) must learn by-heart all these tricks that upper echelon have stated. If you don't know these tricks by-heart at any interview you're trash. The issue with C++ isn't their ideas but the dogma that comes out of them.
Please avoid using C/C++.
You can't do if (value1, value2 &lt;= value3) Instead you need to do if (value1 &lt;= value3 &amp;&amp; value2 &lt;= value3) For both expressions requiring to be true (and), or use || in place of &amp;&amp; if either need to be true (or). EDIT - Now that I've actually had a chance to look at the code, what you've done is incorrect, but worse than that, you've attempted to do things in a terribly inefficient way. Regardless, you'll need to get your hands a bit dirty to find out why you're wrong. One thing you should start with doing though is that you can merge all of your temperature checks into one if statement: if (value1 &gt; 40) { .... } else if (value1 &lt; -40 || value11 &lt; -40) { .... } else if (value1 &lt; value11) { .... } Can all be merged into if (value1 &lt; value11 || value1 &gt; 40 || value11 &lt; -40) { .... } See if you can make sense of this one. What's great about this is that you won't need to use the same printf statement 3 times, cleaning up much of your code.
`strlen` returns a `size_t` which is unsigned. This means the right hand side of your conditional is getting promoted to unsigned, which is why it's never negative as you're expecting.
Is there a way for me to make the result signed somehow?
No! `int` is a smaller type than `size_t`, leading to overflow problems. Consider using `ssize_t`.
also all condition path need to return a value ( put "return 0" at the end before the last curly brace )
What's the purpose of the *for* loops? I don't think there's a reason to have them, and they won't work anyway because they all share the same variable. The "comma" operator is a bit obscure. With *if(A, B)* the expression *A* is evaluated and the result discarded, and then expression *B* is evaluated and returned. (It's most common use is inside a *for* loop where you want to iterate through 2 or more variables simultaneously.) In your usage *if(value1, value11 &lt; -40)* what's happening is that value1 is evaluated but ignored, and then value11 is compared against -40 and this result is returned. Your expression therefore reduces to simply *if(value11 &lt; -40)* hence the warning that the left operand (*"value1"*) has no effect. The final warning (control reaches end of non-void function) means your function potentially could end without "return" ever being called. You could achieve this by entering invalid values 40 times, after which the final loop ("day 3") would expire having never reached its *else* case, therefore execution exits the loop and reaches the final brace. It's mostly harmless for a main() function to do this, but I think any other function doing this could result in a stack corruption, and probably a crash.
Can't speak to that book as I haven't read it myself. I assume C isn't the first language you're trying to learn, so I'd recommend [this book.](https://www.amazon.com/Programming-C-4th-Developers-Library/dp/0321776410) Used it myself to learn and it covers all the basics well.
King was my first book. I still reference it today. It is a great book. 
What error are you getting back? You forgot to add before the last closing bracket the return statement. 'return 0;' By the way which book?
Better ask at CPP subreddit. They know better how not to program! haha
It definately should work. What error message have you been getting? Also, I believe you missed a `\` before `n` there.
That's not needed in C++.
None at all. If you are a total beginner, King`s book is ideal. K&amp;R is somewhat too fast for a beginner. But if you have a minimal programming language knowledge K&amp;R is ideal! Oh, don't forget about C reference manual haha
The Definitive C Book Guide and List: https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
Add \n or std::endl at the end. The output was not flushed. 
to somewhat contradict myself, the linux kernel is really well-written (although sometimes not easy to understand) C. As a networking programmer, I've only been involved in networking projects, so I can't say in general. 
C++ is off topic in this subreddit. Please ask elsewhere, e.g. in /r/cpp_questions.
Yeah indeed! Memory management is one of the cases where giving the user the choice is generally not a bad idea. `malloc()` is a complicated function and wastes a lot of space, so giving the user the choice not to use it is often useful.
Their quality standards and the fact that you need a maintainer.
Bait and switch title :|
Ok so my process is: New Project &gt;&gt; Visual C++ &gt;&gt; Console Application And then at this point I can change the name and where it is located before it's created. However, if I try to make the name something like program.c and then start the project, I get program.c.cpp instead of program.c. I don't understand how to save it a c source file from the beginning. If I rename it to program.c I can run/debug it but the console will just be blank every time I run it, and i've tested it with extremely simple outputs so it's not a coding error. Do you see anywhere I'm going wrong?
This is an error I have never experienced. C should just work like C++ does. Can you post the code just to be safe?
[From cppReference](https://i.imgur.com/nKoNyqN.png) Make sure you have the library mentioned defined. And even then, it's not guaranteed if the system doesn't have it.
#include &lt;stdio.h&gt; int main( ) { printf("Test"); return 0; } Ive tested it with plenty of code that I copy and paste into a compiler online and it runs fine, but in VS it's nothing.
Thank you very much. That last part was what I was having trouble understanding. I didn't realize it was basically a counter for the letters of the alphabet.
Or this nice collection of open source C books: https://www.ossblog.org/learn-c-programming-with-9-excellent-open-source-books/
You need to follow the published standards. https://01.org/linuxgraphics/gfx-docs/drm/process/coding-style.html 
Yeah, either you're doing something wrong somewhere else or your visual studio is somehow broken. I can't give anymore advice because this works on my computer. The only thing I can say is just code in C++ with a C style syntax or try something else.
So you also go to new project &gt; c++ &gt; console app and rename it as a c source and it works?
&gt; First, what does "if (out&amp;1)" mean? Read it as: so the following if the least significant bit of `out` is 1. &gt; how to get the program to display the pi digits on my Fedora system? The `out` variable is set from a command line parameter. My guess is you're not specifying any arguments or the arguments you're giving it aren't right to tell it to output what you want.
`out&amp;1` checks if the least significant bit of `out` is set. `out` is set from the second command line argument in line 602. So if you pass an odd number as the second command line argument, you get statistics.
&gt; -First, what does "if (out&amp;1)" mean? It's a flag initialized to zero and optionally set by the second command line argument: if (argc&gt;2) out = atoi(argv[2]); If you provide 1 as the second argument then `out &amp; 1` will be true. It's just a simple bitwise check of the least significant bit, so any odd value will evaluate to true. The intent is that this program does not print the actual digits unless you request it by providing that extra argument. Different compiler versions should have nothing at all to do with different program behavior. We'd need to have more information to debug that, such as how you're invoking the program. 
A lot of people, on first being burned by unsigned promotion, take a vow to _never_ use unsigned types thinking this means they don't have to worry about this issue ever again. I think this is a mistake. If you're coding in C you're going to encounter unsigned types and no amount on contortions on your part can change this. It's best to bite the bullet - take the time to understand what's going on and be vigilant to avoid errors like this in the future. One rule of thumb is that expressions involving unsigned types and subtraction need to be protected by a test (or some convincing argument/assert that the right hand side &lt;= left hand side). Also, instead of creating long expressions, especially inside other constructs like for-loops, consider computing the intermediate values and storing them in local variables. * It makes your code easier to read - large expressions can be hard to parse by humans. * Using good names for the local variables gives you a chance to make your code more legible / self-documenting. * They make it easier to debug your code - i.e. why the expression isn't evaluating to what you expect. * The local variables don't _cost_ you anything. In fact, they improve the efficiency of your code in cases where the compiler is not able to perform common subexpression elimination. I would suggest changing: for (i=0; i&lt;(di-&gt;col_width[current_col]) - (strlen(dirbuf[row*current_col+current_row])+2) + additional_spaces; i++) To something like: int available_width = di-&gt;col_width[current_col] + additional_spaces; size_t buf_width = strlen(dirbuf[row*current_col+current_row]); if (available_width &gt; buf_width) { size_t spaces = available_width - buf_width; for (i=0; i&lt; available_width; i++) putchar(' '); }
Thanks! For future reference, if the program is invoked as: gmp-gnudnovsky 500 1 then the first 500 digits of pi are shown. If it is invoked as gmp-gnudnovsky 500 the program calculates the digits but does not display them on the terminal. 
You can use networking (TCP, UDP or HTTP) or stdin/stdout. 
If you mean renaming the source code files, yes. Not the project file itself.
I hadn't thought of that actually, good tip! So how would i implement stdout to a java program? Let's say i just wanted to pass an integer to the java program from my C program.
Does your C program start the Java program?
strerror_s() is a C11 Annex K function. The only vendor that supports those is Microsoft in their C compiler. Don't use them in code intended to be portable. 
No, they run separately in a tmux environment but i don't see why the C program couldn't start it. Would it simply be a case of running it like i would any other console program? *system(java Main)*
If on Linux: a named pipe (`mkfifo`) is probably the easiest. You can just write to it, as if it's a file. Then the other program can read from it continuously. Otherwise, using networking as suggested by Ajpennster would always work. Perhaps some more effort, since (server) socket programming isn't that straightforward in C, compared to Java.
Is there any thread safe alternative? Using a lock before calling `strerror()` is very... foolish. To say the least :) 
I'm still interested in what the most common causes of undefined behavior are if anyone has an answer. I'm glad that this problem was solved though. Now I'll be more likely to spot this kind of error in the future.
strerror_r() on posix-like systems. 
And for windows?
If the C program started the other one, you could arrange for the second program's standard input and output to be pipes connected to the parent, but that won't work if they're unrelated. Sockets would be a better option given that. Edit: you wouldn't use system() for this. pipe(), fork(), dup2() and an exec would be the relevant syscalls. 
Thanks for your feedback. Your code does look a lot simpler and less intimidating than what I wrote. I also changed the name of the variables "row" and "col" to "num_row" and "num_col", which I thought would add some clarity to what those values represent. I'm not sure if it is a problem that these variables share the same name as the struct dispinfo num_col value. I know it isn't a syntax problem, but I'm curious if this is a practice I should avoid in general. Also, I think you made a small mistake in the for loop condition. It should be "spaces", not "available_width". I also replaced that "2" that appears in my code often with a preprocessor defined value called MIN_PAD. I see that it isn't necessary in this code though because that information is contained in the di-&gt;col_width[current_col] value. This for loop is simply responsible for printing more spaces than the one that I had. 
Hi! I'm borrowing the thread a little. Does anyone know a good book on windows system programing in C? The most i find that are recommended are pretty old (updated for windows vista lol). 
I don't know if strerror_s is reentrant or not. If it is, you could write a wrapper function that calls the appropriate function depending on OS.
I don't know about _most_ common (I'd guess uninitialized variables has to be near the top), but a couple that arise while writing seemingly simple code: - signed integer overflow - shifting a value by its width If you really want to learn about errors like this checkout "C Traps and Pitfalls" and if you're still not sated, then "Expert C Programming." You can download the [paper](http://www.literateprogramming.com/ctraps.pdf) on which "C Traps and Pitfalls" is based, but the book is better and covers more info. Looks like you can get it used on Amazon for less than $10 - definitely worthwhile.
I'm on my school's campus right now. I'll go check out the school library to see if they have it. Thanks.
Why are the code examples pictures? Do you hate blind people?
Taught myself to program from the first edition of that book. I think almost 30 years ago. Great book.
That sounds like a tasty idea. Never knew about this. Thanks! From what i can research it says that both ends need to be open from each program at the same time. If one side goes down for example, will this just close the file?
You can freely start learning C programming and general programming concepts with "modern approach" since it starts from zero and builds from there. Im halfway thro. and I fully recommend it. "pointers on C" is another very good general programming book using C as language, but I have to say, the very reason to read this book is for the BEST pointers explanation I've ever came across studying C, the book worths its tag for the pointers chapter alone
Fixed the issue. Sorry, we were lazy before.
Thank you for your consideration.
Reading a fifo blocks until someone writes to it. Likewise writing blocks until someone reads. Or they fail if you’re using non-blocking I/O. I see below you can maybe use stdio instead. The function you want in that case is popen. It’s like system but gives you a FILE* to read from. 
Or just use popen. 
I assume that at some point OP is going to need two way communication.
&gt; K&amp;R is somewhat too fast for a beginner. I disagree. It shouldn't be taken quickly to begin with. Readers should take their time with each chapter *carefully* and do the exercises at the end of each chapter. 
 else if (value2, value22 &lt; -40) This will compute the value of `value2` and do nothing with it, and then compute the value of `value22 &lt; -40` and use this as your condition. That's probably not what you wanted, and the compiler is warning you about that. You probably wanted else if (value2 &lt; -40 &amp;&amp; value22 &lt; -40) or perhaps it was just a typo? The final warning is telling you that `int main() { ... }` isn't returning a value even though you defined it as returning int. You should probably just wrap up the program with `return 0;`
Put 4 spaces in front of every line. Or post the code on a code sharing site If you have errors from the compiler, then include them in your post.
Yeah, it's immediately prettier ! 
I found the Linux subsystem for Windows to be much more straightforward than just mingw - for example being able to apt-get dev libraries makes things much easier I'd stick however to libraries that are cross platform and avoid any direct OS interaction entirely take a look at http://bedroomcoders.co.uk/c99-on-linux-and-windows/ feel free to contact me via the contact form (not comments) if you're really struggling...
Apart from perhaps the implicit declaration function, the errors should be clear. The first 4 say that size_t is an undefined type. &lt;http://en.cppreference.com/w/c/types/size_t&gt; The 1st warning says that board_int hasn't been declared before you're trying to use it. And the 2nd warning means you've declared board_score as returning something, but then not returned anything.
 ../include/board.h:19:4: error: unknown type name ‘size_t’ You need `#include &lt;stdlib.h&gt;` in the header file board.c:166:3: warning: implicit declaration of function ‘board_int’ You meant `board_init` I think. board.c:149:1: warning: control reaches end of non-void function `board_score` needs to return something.
Thanks, my biggest problem was that size_t is an undefined type. I didn't konw we could put #include in a header file.
heyyy
You mean colon. Splitting isn't hard but remember to copy the string first, then you can replace each colon with a '\0'.
malloc and strtok will help.
Oh gosh I do mean colon. But how would I go about doing that? I've tried a couple different ways but for some reason I cannot seem to get it working. Thanks!
You can also use strtok on the copy as someone else mentioned. 
what do you mean by 'simulate'?
I'm supposed to interpret the instruction pipeline in a C program. For instance, registers will be represented by structures in C, code memory as a structure etc. 
The number of cells in your matrix is 'ROWS * COLUMNS' Your argument to malloc is 'ROWS * COLUMNS' But how many bytes are required for your matrix.
Thank you for pointing that out. What it should be is: malloc(ROWS * COLUMNS * sizeof(int))?
Looks good to me.
This is written in C, C doesn't support overloading.
Is there a way to download the checkers and not have to upload proprietary code to a company's servers? 
So you want to emulate a CPU? And then walk your code through it? 
Please contact at info __At__ openrefactory __d0t com for discussing options.
Yes, sort of
Which linters are used to identify the security problems, for those who prefer to manually address them? splint?
Ah, kids these days.
Instead, you could provide it a list (Linked List or an array even) and let the function traverse the list.
I made the adjustment and it seems like I'm not getting as many of those strange values but I'm still getting some. 
I'm far from a C guru. I just like C and like using when I can. Where I can. That said, the reason would most likely be the purpose of this library, 2D and 3D programming. Which requires high optimization and speed. By using a list or something similar you would have to iterate said list O(N). Also, if I'm not mistaken this is how the OpenGL and SDL libraries handle it. So, it's not a new concept. It's just how it's been handled in other libraries dealing with related purposes. OP can correct me on any of this as they probably know more and can comment such. 
The tools detect and fix the problems. You can use splint of course, but there may be too many false positives.
If you're using C11 (didn't see any build files in your repo) you could wrap it in a macro along with _Generic. Obviously there's no reason you need to do that if you're disinclined.
 do { balance = (loan_amt - month_pay) + (loan_amt * month_interest); scanf("%f", &amp;balance); } while (balance &gt; 0); You probably wanted that `scanf` to be a `printf` (and take out the `&amp;`)
What have you done so far?
&gt; printf("%d\t", *matrixArg[i][j]); &gt; *matrixArg[i][j] = rand() % 12; Change to (*matrixArg)[i][j]. The version you have writes outside the allocated memory area, and then some of your values are getting overwritten with malloc() bookkeeping information during subsequent calls to malloc(). If you're wondering how it's possible that your second matrix's values get overwritten in this manner, it's because glibc stdio calls malloc() internally. 
This does not do what you think it does: *matrixArg[i][j] Lastly, I'm not sure if this is intentional, but you'll get the same random values every time. 
Thank you I have found the error and corrected it. Yes, I'm aware of seed producing the same values and how you can use the clock to make it "more" random. I appreciate you taking the time to look at this though. 
That's interesting but I only understand some of it. Where/how did you learn this stuff? 
It's a common practice to do something like this: int *p; p = malloc(SIZE * sizeof(*p)); /* SIZE is some value declared elsewhere */ By dereferencing the pointer itself in sizeof -- instead of `sizeof(int)` -- if you end up changing the variable type (e.g. changing from int to uint64_t), you won't have to change this line. Note that it's `sizeof(*p)` not `sizeof(p)` - the second one would give you the size in bytes of the pointer.
In addition to the scanf() problem, you've written a non-terminating loop. Do you see why? Also, this looks like an exercise from King's book. It's a good book, but he skimps on some nuances of the language to facilitate learning. Just file away in the back of your mind the good advice to call fflush(stdout) after printf() prompts without terminating newline characters. There's some more information here: https://stackoverflow.com/questions/1716296/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-strin But the top answers are technically incorrect (again, you're better off just filing this away for later): &gt;The stdout stream is buffered For an interactive device, it can be either unbuffered or line-buffered. &gt;so will only display what's in the buffer after it reaches a newline (or when it's told to). You have a few options to print immediately: The complete picture (from the C standard) explains why what you have will nevertheless work on many systems: "When a stream is line buffered, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encountered. Furthermore, characters are intended to be transmitted as a block to the host environment when a buffer is filled, when input is requested on an unbuffered stream, or when input is requested on a line buffered stream that requires the transmission of characters from the host environment. Support for these characteristics is implementation-defined, and may be affected via the setbuf and setvbuf functions." &gt; Print to stderr instead using fprintf The standard guarantees that stderr is not fully buffered, but it may still be line-buffered. &gt;Standard output is line buffered if it can be detected to refer to an interactive device As noted above, it can be either unbuffered or line-buffered for an interactive device. &gt; otherwise it's fully buffered. The standard says that stdout is fully buffered "if and only if the stream can be determined not to refer to an interactive device." The subtlety here is that not being detected as an interactive device doesn't imply being detected as a non-interactive device. No detection either way may be possible, in which case stdout would again be either unbuffered or line-buffered. known non-interactive device = fully buffered known interactive device = unbuffered or line-buffered unknown device = unbuffered or line-buffered (i.e., you can't say "otherwise it's fully buffered" if you don't have a known interactive device)
Well done, nice clean code. Good stuff.
Same here, only much more recently. It explains the basics really clearly, and with good examples and exercises. Very readable too.
&gt; That's interesting but I only understand some of it. Where/how did you learn this stuff? Which part? The problem with your code was a precedence issue, i.e., [] has higher precedence than \*. You might find the book *Pointers on C* valuable for stuff like this. As for malloc() internals, you get DS&amp;A folks who are interested in that sort of thing as an end in itself, but many people who study memory allocators (maybe even most people) are more security-minded and want to be able to exploit cases of heap corruption. This started around the late '90s with glibc's old dlmalloc and spread from there, with countless papers being written. It's hard to separate the two perspectives nowadays, given that you need a good deal of DS&amp;A knowledge to dissect an allocator like jemalloc.
&gt; Before code: &gt; &gt; s = tcp_recv(s, length - 4); &gt; &gt; After code: &gt; &gt; s = tcp_recv(s, ui2us(subui(length, 4))); I can't shake the feeling that the code after transformation is much worse than before. It is now using two functions for which I have no idea what they are doing and they hide the actual semantics. So I now have to spend *more time* figuring out whether there is a bug here. And I would like to argue that this line does not have a bug! The issue is that this line gets executed with violated side constraints (`length &lt; 4`). So instead of fixing this line and making some arbitrary choices on `length &lt; 4`, one should handle the case **explicitly before** this line. if (length &lt; 4) err(EINVAL, "panic!"); s = tcp_recv(s, length - 4);
This sub is focused on C. Do you have a specific problem in implementing this in C? Or are you stuck? Have you made a start? If you're having trouble getting started, try /r/programminghelp, which is more likely to be helpful for the conceptual stuff.
**Here's a sneak peek of /r/programminghelp using the [top posts](https://np.reddit.com/r/programminghelp/top/?sort=top&amp;t=year) of the year!** \#1: [who knows arm assembly](https://np.reddit.com/r/programminghelp/comments/5wev6k/who_knows_arm_assembly/) \#2: [Unity: Going Back TO The Menu](https://np.reddit.com/r/programminghelp/comments/70m2vi/unity_going_back_to_the_menu/) \#3: [Can I figure a way to learn coding at my job?](https://np.reddit.com/r/programminghelp/comments/6iv6oy/can_i_figure_a_way_to_learn_coding_at_my_job/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I saw similar stuff that use anonymous unions for the property names. This allows you to use the same struct in different contexts, as a quaternion, or a as color struct. Eg: struct i4 { union { int elem[4]; union { int x; int r; }; union { int y; int g; }; union { int z; int b; }; union { int w; int a; }; }; }; struct i4 m = {.0,.0,.0,.0}; m.elem[0] == m.x == m.r; m.elem[1] == m.y == m.g; A real world example you can see in the [HandMade math library](https://github.com/StrangeZak/Handmade-Math/blob/master/HandmadeMath.h).
I haven't tried if you can move the first union on the outside to skip the need for the `elem` property.
20 years in and I didn't know about anonymous unions. Hot damn.
Glad to have helped. I never "discovered" them on my own though, I watched Case Muratory's Handmade Hero where he uses them extensively. PS. There's also anonymous structs. ;)
You don't need to use floating point to compute the number of rows required. Just use `rows = (num_entries + columns - 1) / columns`. As for the most common causes of UB... playing stupid games with pointers.
Right. But C is not strongly abstracted from the details of the computer! * How wide is an int? It depends on the machine. * Are ints big-endian, little-endian, or mddle-endian? It depends on the machine. * It char the same width as int? It depends on the machine. * What does `volatile` do? The existence of `volatile` more or less tells us that the language is not far abstracted from the details of the computer. * Does `int x = foo(); if (++x &gt; y) bar(x);` work? It depends on the value returned by `foo()` and on the details of the computer (i.e. the range of `int`). Memory management is called out as one of the key areas a high-level language might automate/simplify. C doesn't really do this (that is, malloc and free are not that mich abstracted from the details of the memory architecture). 
Almost all the core system utilities in Linux systems are written in C. For example, coreutils (and gnulib), findutils, and the shell. Also systemd. Not to mention the kernel itself I'm sure that when I last looked at them (though TBH it was a long time ago) Apache, much of Gnome, X, Bind were all written in C.
Please don't spam.
What have you tried?
Header files aren't special. You can put anything there you want. However, if you put definitions into a header file (declarations are fine), interesting errors can occur if you don't know what you are doing.
Anonymous unions were only standardised in C11 though.
Looks good, but there some suggestions, mainly with style: The ternary operator could improve some readability in some places, like in [`vector4_min`](https://github.com/ferreiradaselva/mathc/blob/master/mathc.c#L617) and similar functions: result.x = (a.x &lt; b.x ? a.x : b.x); result.y = (a.y &lt; b.y ? a.y : b.y); result.z = (a.z &lt; b.z ? a.z : b.z); result.w = (a.w &lt; b.w ? a.w : b.w); In [`vector4_normalize`]( https://github.com/ferreiradaselva/mathc/blob/master/mathc.c#L658) and some others similar functions: First, I think you mean `0.0f`. Also, couldn't you just use directly use a return in the else statement? You could also do this, improves a bit of readability, at least for me: if (length == 0.0f) return a; length = sqrtf(length); /* Set results... */ return result; Same with the return thing in [`quadratic_ease_in_out`](https://github.com/ferreiradaselva/mathc/blob/master/mathc.c#L1328) For the `struct cmatrix`, couldn't you just used an array? Like: struct cmatrix { float m[4 * 4]; } /* Later */ m.m[4 * y + x] = 0; Also what about pointer versions of the functions? This way you would directly write to the target location without copying much, but I don't think so that it would make a big difference.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ferreiradaselva/mathc/.../**mathc.c#L617** (master → 627a83f)](https://github.com/ferreiradaselva/mathc/blob/627a83fd54b8c50b97bda3fce9a97a5799975cf3/mathc.c#L617) * [ferreiradaselva/mathc/.../**mathc.c#L1328** (master → 627a83f)](https://github.com/ferreiradaselva/mathc/blob/627a83fd54b8c50b97bda3fce9a97a5799975cf3/mathc.c#L1328) * [ferreiradaselva/mathc/.../**mathc.c#L658** (master → 627a83f)](https://github.com/ferreiradaselva/mathc/blob/627a83fd54b8c50b97bda3fce9a97a5799975cf3/mathc.c#L658) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnxthkv.)^.
Thanks :)
This is really good! I will make the change soon.
You're right, but GCC cooperates just fine for me without any extra argument switches. I use an older version that's been repackaged into an installation for MinGWStudio, I believe it's running 3.4.5, and it lets me use anonymized unions.
&gt; The ternary operator could improve some readability in some places, like in vector4_min and similar functions: Good catch. That was meant to be `0.0f`. About `vector4_min()` I found out last night that, while `min()` doesn't exist in `&lt;math.h&gt;`, the function `fminf()` actually does, so I might use it. (I've been programming for years and I never knew about this function) &gt; In vector4_normalize and some others similar functions: First, I think you mean 0.0f. Also, couldn't you just use directly use a return in the else statement? You could also do this, improves a bit of readability, at least for me: That one I like the way it is, having only one return statement per function. &gt; For the struct cmatrix, couldn't you just used an array? My reason to use the members is because I used their names as a way to easily translate matrix operations I saw on internet (math-oriented material use the same convention `a1x1` for the element on matrix `A`). However, as another user pointed out in the thread, I can use unions to make the `cmatrix` usable as an array, too. &gt; Also what about pointer versions of the functions? This way you would directly write to the target location without copying much, but I don't think so that it would make a big difference. That's a good point. I will make a version of each function using pointers. Probably adding a prefix `p` to each will suffice. Thanks for all the feedback ;)
Holy cow! Anything that's OpenGL and C related always uses GLM. It's nice to finally have a C library for vertices and matrices.
I quite like kazmath, usually compile just the bits I want into a static library for my projects, might just save you re-inventing the wheel, or might even inspire some ideas https://github.com/Kazade/kazmath
There's linmath.h as alternative. But I decided to make my own, because linmath.h is missing some functions and I don't like the style much (use macros extensively). But, it's a option, too, if you want to take a look.
Still a nice feature I didn't know that existed. :)
This won't work as expected struct i4 m; m.x = 10; m.y = 6; m.z = 12; printf("%i, %i, %i\n", m.x, m.y, m.z); 
Thanks, some of that went over my head but I do see the loop is an infinite one and I’ll try a new approach. Will return when it’s working how I want. 
K&amp;R is way too concise about general concepts that new programmer are not aware of its function and meaning! There is yet, no one will advise them to what is not being used anymore in C99/11 So, I would not recommend it! . King`s book is way more complete and, ofc, up to date
1989 Edit: Finished reading. A lot of his advice and preferences differ greatly from what I would consider best practice in 2017, e.g. no capitalization or underscores, meaning validsize() is better than ValidSize() or valid_size()
Careful: the value of a union member other than the last one your wrote to is unspecified, so it's unspecified behavior. It's not as bad undefined behavior, but still the result can vary depending on compiler and the compiler options. I don't know why it is unspecified, it'd expect it to be implementation-defined because of the endianness, perhaps someone can shed a light on this.
Upvote from me. Very beginner friendly, relaxed pace.
Yeah, I tend to err on the side of being too verbose in my naming, especially on a first pass. Later on you can go back and find/replace more graceful names and clean things up.
Yes thank you. I think I got a bit over excited by the possibilities, and added the top union besides the example I saw containing just the inner ones. :)
We agree with your observation. The specific fixer in question handles subtraction among other arithmetic operations. That is why we opted to use the safe int library. However, we can easily modify the tool to generate the modification you suggested. We are actually going towards that as a future improvement. What is interesting however is that the tool does not change all arithmetic operations (that will surely be ugly). It identifies a (small) subset of arithmetic operations that are potentially buggy. The tool will get better at zeroing in on the problem area as we go ahead. And then it will also introduce the check that you suggested. That is the future goal. Thanks for your comment. 
Yeah, I recently read through the Plan 9 kernel source (on which Pike worked), and names like that were really hard to parse some times. As were the one- and two-letter variable names he also recommend in this article. Also, his claim that: &gt; pretty printers mechanically produce pretty output that accentuates irrelevant detail in the program, which is as sensible as putting all the prepositions in English text in bold font Is a completely false equivalency. One, the structure of an English sentence isn't inherent to its meaning, and two, prepositions aren't central to the meaning of a sentence. In English, we capitalize proper nouns to clarify meanings of sentences, and in languages like German, *all* nouns are capitalized. That's not wholly necessary to understand it, but it does immediately help clarify the structure of the sentence. Edit: accidentally typed adjective when I meant preposition.
What architecture is this for? I have some sample code from when I wrote an instruction parser for LC-3 if you want that?
&gt; One, the structure of an English sentence isn't inherent to its meaning, and two, adjectives aren't central to the meaning of a sentence. Very nice joke!
&gt; safe int lib I have never heard of this library. But among the top google hits for `"ui2us" c function` is a paper Z. Coker (2012) with the exact same examples you used for your blog post.
 The Safe Int library was created by CERT. Z Coker was a student of the co-founder of OpenRefactory
You can significantly rearrange an English sentence and still convey the same information; you can't do that with formal grammars and programming languages. And prepositions serve to enhance the meaning of a sentence. For example: &gt; One, the structure of an English sentence isn't inherent, and two, prepositions aren't central. Given context, this still conveys the gist of what I was trying to say before, despite having no prepositional phrases. You can also often swap out one preposition for another and have it still mean the same exact thing (at least in English), which also is part of what I meant.
Let's remove all particles and adjectives from your comment. Can the meaning still be understood? &gt; You can rearrange sentence convey information; you can't do that grammars programming languages. prepositions serve enhance meaning sentence. example: 
Look into QEmu. Maybe that can help? 
That's removing significantly more than prepositions, which is what I had originally meant. Here is the sentence without prepositions/prepositional phrases: &gt; You can significantly rearrange an English sentence and still convey the same information; you can't do that [...]. And prepositions serve to enhance the meaning [...] The first cut, in this case, is the only one to significantly downgrade the meaning of what I said. In any case, maybe I should have said "prepositions and prepositional phrases don't dictate the structure and meaning of a sentence," because you can usually put them in many different places within a single sentence. You can't arbitrarily rearrange the keywords in programs.
Alright, I will.
Congrats, I remember your submittal post :D
fuck yeah!
Nice! Congratulations :)
Thank you! It was a lot of fun and I learned quite a bit about how the POSIX terminal API works.
Summary: There will be two new functions in `&lt;termios.h&gt;`. The function `int tcgetsize(int fd, struct winsize *ws)` returns the size (number of rows, columns) in the terminal `fd` by setting `ws`. Similarly, `int tcsetsize(int fd, const struct winsize *ws)` sets the terminal size of `fd` to `ws`. Both functions are designed to be implemented as thin wrappers over the `TIOCGWINSZ` and `TIOCSWINSZ` system calls available on many Unix-like systems. This is needed because POSIX does not contain `ioctl` calls beyond the STREAMS interface.
Soon as in a decade or so until the new implementation will be widespread :D ?
Woah, that's really quite an impressive feat. Congratulations.
Yeah, probably. I'm already writing the patch for FreeBSD (so FreeBSD and macOS are going to have this soon). Let's see if I get a glibc patch going, too.
Explain For a not so technical person?
See the summary in my other comment. Basically, these functions allow you to get and set the number of rows and columns in a terminal window, something that wasn't possibly in POSIX before. The new functions wrap an old ioctl call from the 80s that is widely available but unstandardised and are easy to implement if the ioctl call is available.
It‘s just that I do not know so much about Unix yet 😂🙈
Congratulations!
This isn't exactly what you need, but I've made some information videos which might help. The first is a series on how to build a simple virtual machine (which simulates a cpu) from scratch in c++. It's stack-based, but could be modified to be register-based. Later in the series I cover how to build an assembler for the vm. https://www.youtube.com/watch?v=BNXP0w4Ppto The second is a video I made about x86_64 assembly programming. It's a video that explains a bit about registers, memory and the control unit of the processor. https://www.youtube.com/watch?v=ysSFXxLzhpM
Thanks !
That is impressive, nice job.
I did read it a few days ago! haha Still worthy! 
C++....facepalm
What have you tried? What feature will you need to store the words you are reading? 
Good job! Very useful to have a feature like this portable.
Please post your code, properly formatted for reddit, or a link to it on gist, pastebin, etc. We can't copy &amp; paste an image of text to try it out.
In *initializeArray* (line 49) you are looping from 0 to *y* (which is the value returned from *rngMax*). You should instead use *x* which is the actual length of the array. Also, in line 50 you set the random number to be between 1 and 100 instead of 0 and 100. Don't know if that is intended, but a way to fix that is: Array1[i] = rand() + (y + 1); This will give you a value between 0 and *y* (which is the intended max value for the array).
I am unable to do so for some reason.
I changed both of those and whenever I use ./a.out, it doesn't ask for the two integers and automatically sums up numbers (even made a negative number). 
Try adding parenthesis in line 41 and 42: int x = getInput(); int y = rngMax();
What is your definition of "elements" ( words or lines ) ? maybe first try to implement it in a script language you know and port it to C. 
Quite nice, I will follow it when I am doing system Linux programming. Saved for future reference. But in embedded C, function pointers are frowned upon especially when it comes to safety-critical code. If you're following [JPL's rules](http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf)
It looks like your two output lines are not formatted correctly on reddit. Maybe if we knew what it was supposed to look like we might me able to better help? Just a guess, is it supposed to look like [this](https://i.imgur.com/ayXEbEl.png)?
&gt; in languages like German, all nouns are capitalized. That's not wholly necessary to understand it It isn't necessary at all. Which is why we don't *say* "Kindergarten mit einem großem 'k'", just "Kindergarten." The only time I find pretty printers helpful is when I have to work with a mess. And sometimes I think maybe the author would've shied away from producing it in the first place if the pretty printer hadn't simulated structure.
Just remember C has no "strings". You'll need either an array of char arrays (eg: char array[100][20] where you can have up to 100 "strings" each with up to 19 characters) or an array of pointers (char \*array[100] where you can have up to 100 pointers each pointing to some memory you need to manage manually) ... or even just a pointer to pointer (char \*\*array where you can have as many or as few "strings" as you need, each capable of holding as many or as few characters as you need; of course you need to manage everything manually). [edited to add elided asterisks]
Please reindent your code, it hurts my brain.
Next step, standardize a reference terminal capabilities and codes to enable them such as termcap &amp; co would be eventually useless under one kind of terminal.
You could rewrite it in C... or ask a C++ subreddit like /r/cpp_questions.
ok thanks
gj OP I will be using this because it’s so straightforward 
Says they are both not a function or function pointer
This already exists. Look up ANSI escape codes.
This would be great as a vim plugin or something like that.
Ah great idea, thanks! 
To my knowledge, they are only a subset or a superset of the set supported by random terminal. And you have to use termcap to know which part are supported. My idea would be to have a blessed terminal which has a complete and exhaustive set of capabilities that programs and terminal emulator can rely on it.
This is so inspirational. I hope one day to have such vision. PS: This might sound sarcastic. But it is not; it's hard to convey warmness over the internet. Good job, excellent stuff.
Congrats OP! That's so cool!
And it's not portable because you want to support older versions.
You may want to include `-Wl,--no-undefined` when linking if you want to detect undefined references at build time. 
When compiling to an object file (first command), it only *references* the symbols (like function names) of the library though header files (eg. `int mylibfunc(void);`, `mylibfunc` is the symbol being referenced and is in a library). When linking (second command), these symbols needs to be *resolved* and the libraries are needed to get the symbols.
Wooooo. Finally!
Is it because the linker is assuming if it doesn't find something you're probably going for run-time dynamic linking?
Made some new changes, took on all of the advice below.
 read(fd, &amp;buffer, 127); What memory are you writing to here? (Hint : it's not the 128 bytes you received from malloc)
ok embarrassing thank you
Don’t `return -1` from `main` or `exit(-1)` or anything else like that—on most platforms you’ll ever touch, acceptable exit codes run from 0 through 255, and anything else is just `mod`ded into that range, so `-1` will become `255`. `1` is the usual “general failure” return code, with higher numbers assigned for more specific things. (Tradition dictates you stay below 64 if you can help it, because around 64 are some BSD standardized codes, and 127+ tend to be used for shell- or crash-related things.)
&gt; I know this technique was common before, but is there a better way these days Yup. It's called C++! &lt;ducks&gt; More seriously, there are a couple caveats I'm aware of. C99 made this feature more official, but you're already compiling against that standard (or better, C11), right? Also, the official syntax is now to leave the size unspecified: `char str[];` which makes this a "flexible array member." Google that term for more information. This should be the last member of the structure, and there should be at least one other member (which is already the case in your code). The size of the flexible array member is 0 when calculating the size of the structure itself (though I believe there can still be padding before it.)
One thing stands out at once: That 0 element array at the end of your structure. That's not part of the standard. Instead, you want a flexible array member. Details [here](http://en.cppreference.com/w/c/language/struct).
This shall be upvoted. Congrats! You have earned +1 nerd credit. If you also collect a check for a hexadecimal dollar from Donald E. Knuth, you may advance to Hall of Fame status and high-five Dennis Ritchie when you die.
I do have three Knuth checks!
&gt; More seriously, there are a couple caveats I'm aware of. C99 made this feature more official, but you're already compiling against that standard (or better, C11), right? Yes, I'm using a modern compiler. And that's why I'm asking, because modern compilers seems to be a bit aggressive and assuming compared to the more "1:1" back in the 80's and 90's. What is the term for including a base struct like this, and do the type casts to lie a bit to the outside world? I don't know what to Google for. :-/ 
Oh right, do either of these two: double initializeArray(int x, int y) { ... } int main(void) { printf("The sum ... %1f\n", initializeArray(getInput(), rngMax())); return 0; } OR double initializeArray(void) { int x = getInput(); int y = rngMax(); ... } int main(void) { printf("The sum ... %1f\n", initializeArray()); return 0; }
Thanks, I've actually used flexible array member before. I recently discovered it doesn't work as the last member inside a union. Perhaps understandable why it doesn't. :) 
Every member of a union has to be a complete type. Of course, you're not using unions in your example so it doesn't matter...
How about using gobject (part of Gtk+)?
This is more an exercise in reinvention and recreational programming than a serious project. :) It's a great way to refresh old knowledge to code things from the ground up even if there are better implementations out there already.
I'm pretty confident casting a `string_value*` to a `value_base*` is legit, but it seems like you're going to be going the other way. I.e. mk_*() functions returning a `value_base*` that you'll cast to `string_value*`, etc. Are you sure that's legal? Have you considered an approach using unions, something like: struct value { enum value_kind kind; int ref_count; union { struct string_data; struct float_data; ... } data; } 
Well, looking at how gobject does it can probably give you some good ideas.
"Flexible Array Member" is your best term for google. It's not the term for the base struct, but since this is the main use case for flexible array members, it'll point you in the right direction. Are casts lying? I suppose so, out of necessity. Mostly because the `sizeof` is not really correct, as it doesn't include other sizes. I'd also be a bit cautious with type punning, now that I think about it. But this is an official feature now, you're not hacking around the type system or anything like that.
This is what I previously did. But I'll implement a value that is quite big(persistent vector á la Clojure vectors) and don't want every value to be the size of a vector with 32 pointers. Yes, I want all my mk-functions to return value_t* and will typecast back to the correct type using the enum-value in various functions.
Consider uclibc-ng too for us embedded folks! :) Great work.
&gt; [I] don't want every value to be the size of a vector with 32 pointers. Is that really a concern? Do you have a billion of these structs or something? The union-based approach seems very natural.
I'm coding a lisp interpreter, and even though this is a toy project it doesn't feel right to blatantly pick an implementation strategy that is far from what a less naive implementation would pick. Every value inside the language will be of type value_t and derivates.
That's awesome. You just went up another couple of notches in my book.
This is so incredibly useful, I cannot believe it's not in POSIX already. Thank you for taking your time to write a detailed proposal.
To avoid the overhead, you can make some (or all) of the data, pointers to structs. Of course, that means you'll want to implement a free_value() fn instead of just using free on values. As I previously mentioned, I don't think the "typecast back to the correct type" is actually legit. Though, it will likely work on most C implementations.
The omission was probably an oversight since the underlying ioctl has been tgere for decades now.
I'm not sure about C++, but in C you can compile with the -Os flag (optimize for size) (though this reduces program size only) EDIT: also don't use int if you don't need up to 64k, use short, int8_t, uint8_t etc... EDIT2: you could use direct system calls instead of iostream (cin/count) to reduce the overhead.
I write my comments like this: /* * This is a * multi line comment. */ I don't see how this tool would help.
Where are you stuck?
String literals are special.
it's not a problem with the compilation.. it's the linker (ld) that's failing. you need to add -L options to point to the location of your libraries (.o files).
Haha I was worried the answer was going to be something like this.
Ok I just updated it, try the style "classic"
Technically, if you have a C99 compiler, you can do this: int *foo = (int[]) {1, 2, 3, 4}; I'm not sure why you'd _want_ to, but you can.
This sub is for C, not C++.
I just learned about this going through the Linux kernel's network code. `struct tcp_sock` has a first member `struct inet_connection_sock`, which has `struct inet` which has `struct sock`. I'm only a dabbler in C, but I find this inheritance really elegant.
Typedef the substruct and you can just say `BaseValue *Base;` btw, you forgot to include the pointer in `Base`.
Variadic arrays are a C11 thing IIRC, and generally, they're a pain in the ass to get the compiler to support. I always just make a pointer, and allocate it from the heap, but there may be micro penalties for doing that? idk.
What is the term for including a base struct like this It's a sub, or child struct.
It is incredibly elegant, just be careful with how deep you go, IMO `tcp_sock-&gt;inet_connection_sock-&gt;inet-&gt;sock` is pushing it
Shit, if you're gonna go that far, just tell him about the macros `EXIT_FAILURE`and `EXIT_SUCCESS`. Idr which header it's part of tho. Edit: it's in stdlib.h
So your question is, should you link existing objects, or objects you just created? I don't see how it really matters, but I'd go with existing objects just to be safe.
Yup.
I use doxygen style comments in my header, and self describing variable names in the code.
Found the solution for anyone who is interested. Thanks
Variadic arrays and flexible array members are two different things. Both are C99, though variadic arrays were made optional in C11 (with an unsure future beyond that, honestly).
It's not a totally crazy thing to do. `int foo[] = { 1, 2, 3, 4 };` has performance implications (not a big deal for only 4 elements) because `foo` has automatic storage. Realistically, it's not possible for the compiler to implement that without doing a memory copy at initialization-time. `int *foo = (int []) { 1, 2, 3, 4 };`, however, gives you a pointer into static storage (probably .data or .rodata), so there's no memory copy operation that needs to take place. So long as you're not going to be changing that data (should probably throw a `const` in there to be explicit), I think it's a totally sensible thing to do.
For read-only data that's only initialized once, it's probably more idiomatic to use `static`: static const int foo[] = {1, 2, 3, 4};
Please post plain text as plain text. I can't explain the order behavior your experiencing based off what you've shared, but I'm willing to bet that it's a problem with the manner by which you've stored some of the information into your array of structs. It also looks like you're struggling with the format strings. For those first three spaces I'd just put three spaces at the beginning of the format string. For everything else determine the maximum length of that substring and mark it for each string, preceded by a `-`. For instance, if the Title is meant to be no more than 50 characters you can mark its place in the format string with `%-50s`. The `-` will ensure the string is left justified while still using at least 50 characters; using the number without the minus will right justify the string. It is worth noting that if a string's length exceeds this limit the full string will still be printed, most likely ruining your spacing. Hope that helps. If you have further problems or questions feel free to ask, but please provide additional code.
What did you change? How did you change it? What compiler does the remote server use? Please post plain text as plain text.
I found it and IMHO it's not what I'm looking for. It's a much more generic object system with support for introspection and so on. https://code.woboq.org/qt5/include/glib-2.0/gobject/gobject.h.html But still, thank you for the idea. :)
How are you compiling your source code on the school server?
Not quite correct: The last line must be indented by one, too.
the problem with int * foo = { 1, 2, 3, 4 }; that that you are declaring a pointer and initialising that pointer to an array of values which it cannot hold. an array name is just a pointer and this is how string literals are held so "bar" will be put in a string table but in your assignment the foo will contain the address. like raevnos said, string literals are special. 
1) Yes. 2) Years ago, switched to nginx from apache. Just recently started using h2o and nghttp2. 3) fastCGI
That was the setup I had in mind. Do you use any library for your FastCGI? Or something you have made yourself?
nginx with uWSGI works pretty well in my experience. uWSGI was designed for python applications originally, but [the protocol](http://uwsgi-docs.readthedocs.io/en/latest/Protocol.html) is fairly simple so writing a backend in C isn't much of a problem. 
Hey thanks for that. I was actually looking at kore io, but I think this looks pretty promising.
Why not use Kore? Somebody has invented the wheel and tested it too!
I've been using C as a backend also, using nginx and FastCGI, and I managed to create a basic blog with AWS EC2 and TLS thanks to Let's Encrypt. But throughout I was finding it difficult to debug because I was using spawn-fcgi and fcgi_stdio.h. I've also somewhat struggled with basic things like file io because fcgi_stdio.h provides its own versions of libc file io functions and I struggled to find clear explanation or examples of how things could be done. I'm thinking to move forward I would remove my dependency on the fcgi library and implement it myself. I'm doing this as a learning exercise and don't particularly want to resort to using something that does everything for me, since understanding how all that stuff works is my primary goal. But at the same time I don't want to spend months implementing FastCGI if that's what it will take me. Any advice on how I could proceed? I saw that /u/Aransentin suggested using uWSGI -- I might try that.
Many years ago: apache, and cgi programs written in C. I'd rather have used perl because of the added security of taint mode, but...
Yeah I realize that, that's why I'm confused. There are no libraries, everything is in headers that get included in one file.
As far as I can tell, this is perfectly valid, see: http://en.cppreference.com/w/c/language/cast
I’ve created something like Kore a long time ago using FastCGI and Apache. I used flex and bison for creating a http parser that can parse various request types. It had support for sessions, files, cookies, and various utilities. 
We use fcgi_stdio
uWSGI doesn't have a C interface, iirc. Looking at the docs linked to, I see it communicates via TCP but fastCGI can use sockets which will be faster.
okay, it should work now. Thanks for the feedback!
&gt; I see it communicates via TCP Not necessarily; uWSGI can be setup to communicate over a Unix socket. I'm not sure how having a C interface would be possible as well, since it's just a protocol; somewhat like asking if HTTP has a C interface.
The style classic just outputs "undefined" for me, not matter the input.
I liked 'Expert C Programming' by Peter van der Linden
I still don't see how this would help anyone. Every texteditor does that automatically.
Years back, when I was tasked with web development in C, we used CGI with a library called cgic. https://www.boutell.com/cgic/
Read the C standard and the POSIX standard. There isn't anything else that is really C specific, learn data structures, algorithms, and general data structures to advance.
Sorry you are getting undefined. I will look into this asap. Also I wanted to offer most customizable headers that some text editors dont have. 
I couldn’t recall offhand if they were POSIX or stdc, standards-wise, and I’ve rarely seen them used in practice. (Most programs either use 0 or 1 directly, or define their own `enum`/macro set. The latter is preferable if you’re doing anything remotely complicated, making `EXIT_`etc somewhat useless in those cases.) I have, however, seen shit-tons of people modding −1 out into their program’s exit status, and more than a few cases where the poor sods tried to test it in the shell afterwards. Seems like it starts with tenured professors who saw it once in 1978 (it was a boog then too, but it burrowed in) and then they transmit it to their students, most of whom don’t know any better or care to.
Also known as "Deep C Secrets", and I second the call for this one - it is excellent and should be a standard on every C programmers bookshelf.
We use lighttpd and fcgi, with a framework clearly marked as DEPRECATED in its own readme called raphters. I don't know why, love to change it.
Okay excellent, i've started working on it today so hopefully i can post the code here to help anyone else that need something like this. Out of curiosity, if the java program and c program see it as a file, will there be efficiency problems of reading this file continuously for weeks at a time? My c program will be reading this file and splitting it to set variables in the program. These values will ultimately be changed by the java service through the network
I mean sure it's a fun little project but realistically I don't see anyone using it as it takes for too long to copy and paste everything multiple times.
At some point your C knowledge will bleed into knowing how compilers and CPUs work. It won't be enough to know how to write a nested for loop that iterated over a buffer. You will need to know what's the optimal way to iterate over said buffer so that the compiler can generate optimal code. This is important if you're heading into the embedded world. For this, I'd recommend reading about systems and architecture. Take a look at [this doc](http://futuretech.blinkenlights.nl/misc/cpumemory.pdf) - what every programmer should know about memory. Then move into Agner Fog's blog. 
Thanks for your feedback. I am looking into making a vim plugin or possibly a sublime extension so you wont have to "copy and paste" each time:) 
I can’t answer for what java will do, but normally it wouldn’t be problem. The fifo is not seekable so any data already read would normally be discarded. 
learnbchs.org &gt; Do you use a common web server (Apache, nginx, etc.) or something else to handle HTTP requests? openbsd httpd &gt;Which web server do you use? openbsd httpd &gt;In combination with a web server, do you use FastCGI? Or CGI? Or something else? Which library, if any? kgci from bsd.lv in slowcgi mode (also see ksql+sqlite, kwebapp, pledge and libressl)
I'm currently using nginx plus fastcgi but I am moving towards websockets and am looking into something like [facil.io](https://github.com/boazsegev/facil.io). I haven't switched yet though.
Alright, thanks @TraylaParks and @ibisum
Depending on your compiler, `wchar_t` might be `int`, in which case you can initialize an `int *` from `L"string"` also.
How exactly is it newbie friendly? 
ok thanks
Very helpful, much thanks.
How is this related to the C programming language? I have removed your post as it is off topic.
No blog spam please.
The C backend development I'm doing is on a very tiny scale. My code sits behind a lwIP HTTP server on an external Wi-Fi module which has its own API that makes a very thin layer between the C code and the client. The host is a 120 MHz ARM Cortex-M4. Embedded web development is a little like all web development was 20 years ago. Very lean and all DIY. Except now you can count on the client to be able to do a whole lot more. You just have to deal with the fact that no one knows anymore how to write client side code without pulling in hundreds of kB of Javascript from someone else's CDN.
If I may sound like the devils advocate. With the world moving to JavaScript it depends on the application. For large production projects I use nginx + php-fpm. For small to personal projects I use Node + express.js and nginx as a proxy for production.
'Expert C programming' is brilliant, and fun to read. Although I think you might find it a bit outdated in places (still very much worth getting a copy!). I would also suggest looking at '21st century C' by Ben Klemens.
Please show me your full program.
The result is 0 because `p` doesn't point to `a` and distinct objects have distinct addresses. Note that since strings are NUL terminated, adding 3 makes both point to the NUL terminator (not out of bounds).
I work on an old C message based system that needed a web front end added. I wrote a web socket interface and a routine that could convert JSON to binary and back again based on information derived from C header files. This allowed a javascript front end to inject and receive messages from the back end. The back end isn't aware it's now talking to a web based application and remained basically unchanged. 
That's not what the question is but, yes, a lot of people have moved to javascript cause the libraries and frameworks are easier to plug in and use but those of us who create high performance web sites only use such things in small doses where it either doesn't matter, it spins something up quickly till we can write our own, or we're stuck with it cause it's the only interface a third party or client provides us.
The C Language by K&amp;R is the classic by one of the guys who created C. I learned C from the first edition in 1985, dragged kicking and screaming from my beloved assembly language by our engineering manager. That book still sits in an honored place on my book shelf.
Correct me if I'm wrong, but surrounding that in quotes would give you the ascii representation of the character '0'. You want to compare with the value 0, so what you did would work. 
`0` and `'\0'` are equivalent. Which one you use is mostly a matter of personal preference and coding style. I like the latter because it's a visual reminder you're dealing with characters and not another integer type. `'0'` is a different character, with a value that is *not* 0. 
For the first part, you have a logic error. In each `if` case, including the final `else` case which is run when all previous `if`s were false, returns something (exits the function), however, your check with `m == 4` comes *after* the final else, but this code is never reached, because it exited the function before because of your final `else`. if (m == 1) return d; else if (m == 2) return d + 31; else if ( /*blah*/) return /*blah*/; else /* #### This is run when all previous if's were false #### */ return /*blah*/; /* #### Because of this, from this point on the code is unreachable #### */ if ( m == 4 &amp;&amp; a % 4 == 0 &amp;&amp; a % 100 != 0 || a % 400 == 0) return /*blah*/; else return /*blah*/; 
So how do I fix this? Also is there anyway to simplify this using **for**?
I don't really understand the algorithm behind it and what the variables should be (probably date) and what the output should be, so it is hard to fix for me without context. Also, from what it looks like, you might not even need a loop at all.
&gt; What this code does is calculating the total amount of days in the inserted date (european format days/month/year).
Well, I oversaw that, but still, what "total amount of days"? Days since the start of the year? To the logic, what should be the purpose of the final `else` statement in your algorithm/function? What do you expect when that return statement in the final `else` should be run? If it is the days since the start of the year, there is an simpler algorithm that can use a loop: Have an array with the days in each month. You take the sum of the days of the months before, then add the current day (`d` variable), and if the month is higher than `3` (it surpassed February), check if it is a leap year and add one to the total days if it is.
The C Programming Language by Harbison &amp; Steele is an excellent reference.
There is also C faq, collected from comp.lang.c over the years: http://c-faq.com/ also available in book format. And also I agree with /u/TraylaParks about Experrt C Programming.
Yes, they a+3 and p+3 are different addresses. The difference between pointers and arrays can be rather easily seen in pseudo-assembly (but I think it aides understanding): a: 0x30 0x31 0x32 0x00 p: 0xf00ba 0xf00ba: 0x30 0x31 0x32 0x00 a and p we use as labels here and 0xf00ba is obviously an address. For an array you set aside fixed memory and the "variable" a equates directly to the memory location, ie. is a *constant*. You cannot reassign a, it's a label. You cannot make it point somewhere else. For the pointer you set aside memory to hold an address and for the actual values and put the address of the latter as the value for the former. So you can reassign the p, and make it point somewhere else.
Are you sure 0 == '\0' per standard?
0 is an int, '0' is a char and "0" is a string constant { '0', '\0' }. Usually the char '\0' has the value 0 so *(a+3) == '\0' == 0
I would suggest you rewrite that function to have just a single return at the end;
Yes.
It took me a good time but I figured it out: https://pastebin.com/e9wm0wiT
It took me a good time but I figured it out: https://pastebin.com/e9wm0wiT
I don't think there is any C conference (which rules out any videos). The C language is just not changing as often as C++ (which probably means there is less chance to make money on books, conferences, or proprietary software). There are BSD conferences that have some focus on system development (and that development is often in C) so that avenue may be worth exploring. There are links of people using C to work on specific projects. Here's some links: Sean Barrett, he's the guy responsible for nothing's.org and the general stb based libraries. He has a series of C programming videos based on building a Minecraft like game (for example [Open world block building game part 1](https://youtu.be/TA67N3QKZv8) ) Bisqwit's, who does most videos in C++, did actually create a video about making a Doom like engine in C: https://youtu.be/HQYsFshbkYw Assembly Assembly has an NES speed coding series: https://youtu.be/GNAMQr5x-Hw Everyone always links Handmade Hero so I'll let someone else comment on that. 
If you just need sock access you cast back to struct sock * and use sock-&gt;member
Seconded! Kore is excellent. Hopefully be shipping some Kore-based services soon. 
This still could use some work. I would suggest something like this: int mtoa(int m, int a) { if (m == 2) { if ((a%4 == 0 &amp;&amp; a % 100 != 0) || (a % 400 == 0)) return 29; return 28; } if (m % 2 == 1) return 31; return 30 } I don't know if the logic is correct but it at least matches the logic of your code but with fewer comparisons and branches. eta: if you want to play even more code golf: int mtoa(int m, int a) { if (m == 2) return 28 + ((a%4 == 0 &amp;&amp; a % 100 != 0) || (a % 400 == 0)); return 30 + m % 2 } Which leads to this one liner: int mtoa(int m, int a) { return m == 2 ? 28 + ((a%4 == 0 &amp;&amp; a % 100 != 0) || (a % 400 == 0)) : 30 + m % 2; } I haven't tested this and I've been writing a lot of Go code so please forgive any mistakes.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
oh sorry about that
I know the technical reason, but the reasoning behind the reason is more difficult. String literals, such as "bar", are arrays of type 'char'. Arrays 'decay' or 'are implicitly convertible' to pointers of the same type. So "bar" can be both an array and a pointer. A group of items in curly brackets be can't because their type can't be implicitly discerned. Is it a int array, a long array, an unsigned int array etc.
Your algorithm contains a lot of duplicate code and is thus more error-prone. Here's my solution: https://pastebin.com/keM3Snz7
I still can't do uint16_t *foo = {3, 4}; Accessing foo[0] causes a seg fault and I'd say here their type can be implicitly discerned.
[21st Century C](http://shop.oreilly.com/product/0636920033677.do) by Ben Klemens. Some good deep dives. 
Prepare yourself for hilarious puns and jokes.
&gt; uint16_t *foo = {3, 4}; It wouldn't cause a seg fault as it wouldn't compile. It's like saying scratching my third knee is difficult. And no, without the compiler checking each and every item, the compiler can't discern the type.
one way to approach this might be to learn some C++ first, and get to know the standard library for programming applications. then maybe later you could dive into C and all the systems programming details found there. for a C++ intro, I think Allen Downey's [How to Think Like a Computer Scientist](http://greenteapress.com/thinkcpp/index.html) is pretty good. it's brief, straight-forward, and it's free. he has other similar books for other languages too (Python, Java). see section 8.7 about the reference operator "&amp;"
That's kind of what I feared. Coming from C++ and Python it is a bit sad to not have the same resources that I'm used to. It seems impossible to even find a good paid course (at least not on the level of something like Kate Gregory's C++ Fundamentals series). But as you've said, there's probably not enough money in it. It looks like searching for the usual application areas of C (embedded, etc.) is the way to go. I did find a couple university course recordings that use C, though that's usually not their focus (more introductory compsci). The BSD conferences are an unexpected goldmine and Sean Barrett's youtube channel is fantastic as well. Thank you so much for your suggestions!
Kochan's programming in c is really nice and gentle.
Edit the post and add four spaces before every line in the code.
Thank you, That worked!
so `Shrink` returns an `int`. make it a `double` like this: double Shrink(int value) { return value / 2; } Think about what the function does when it is an `int` function as opposed to a `double` function. EDIT: Just noticed this as well, you will have to modify your `printf` call on `menuSelect ==3`. Currently, you have this: `printf("Half of %d is %d\n",intValue,Results);` You want this: `printf("Half of %d is %f\n",intValue,(float) Results);` Why do you think we should do `%f` instead of `%d`?
I tried that when I change it to double it tells me conflicting types for Shrink. If I change the shrink to double shrink every where and have a %f in the “half of %d is %f\n” it give me a crazy output of a huge number that doesn’t make sense at all.
Can you post the code you have when you make those changes? I want to see what you are doing :) 
 #include &lt;stdio.h&gt; int Square(int value); int Cube(int value); double Shrink(int value); int main () { /* variable definition: */ int intValue, menuSelect,Results; intValue = 1; // While a positive number while (intValue &gt; 0) { printf ("Enter a positive Integer\n: "); scanf("%d", &amp;intValue); if (intValue &gt; 0) { printf ("Enter 1 to calculate Square, 2 to Calculate Cube, 3 to calculate half \n: "); scanf("%d", &amp;menuSelect); if (menuSelect == 1) { // Call the Square Function Results = Square(intValue); printf("Square of %d is %d\n",intValue,Results); } if (menuSelect == 2) { // Call the Cube function Results = Cube(intValue); printf("Cube of %d is %d\n",intValue,Results); } else if (menuSelect == 3) { // Call the Shrink Function Results = Shrink(intValue); printf("Half of %d is %f\n",intValue,Results); } else printf("Invalid menu item, only 1, 2, or 3 is accepted\n"); } } return 0; } /* function returning the Square of a number */ int Square(int value) { return value*value; } /* function returning the Cube of a number */ int Cube(int value) { return value*value*value; } /* function dividing a number by 2 */ double Shrink(int value) { return value/2; }
EDIT: Float to double. I need sleep :) Okay, here is something I noticed. `Results` is an `int`. Which is fine, but since dividing in C will not automatically cast it to a `double`, we should really be defining `Results` in each body of the `if`/`else`. So, try something like this. I moved the declaration of `Results` to within each `if` block. This means we have the correct data type for the function type we are expecting. EDIT Again: Alternatively, just say to hell with `Results` and have `printf()`call it directly. `printf("Half of %d is %f\n", intValue, Shrink(intValue));` #include &lt;stdio.h&gt; int Square(int value); int Cube(int value); double Shrink(int value); int main () { /* variable definition: */ int intValue, menuSelect; intValue = 1; // While a positive number while (intValue &gt; 0) { printf ("Enter a positive Integer\n: "); scanf("%d", &amp;intValue); if (intValue &gt; 0) { printf ("Enter 1 to calculate Square, 2 to Calculate Cube, 3 to calculate half \n: "); scanf("%d", &amp;menuSelect); if (menuSelect == 1) { // Call the Square Function int Results; Results = Square(intValue); printf("Square of %d is %d\n",intValue,Results); } if (menuSelect == 2) { // Call the Cube function int Results; Results = Cube(intValue); printf("Cube of %d is %d\n",intValue,Results); } else if (menuSelect == 3) { // Call the Shrink Function double Results; Results = Shrink(intValue); printf("Half of %d is %f\n",intValue,Results); } else printf("Invalid menu item, only 1, 2, or 3 is accepted\n"); } } return 0; } /* function returning the Square of a number */ int Square(int value) { return value*value; } /* function returning the Cube of a number */ int Cube(int value) { return value*value*value; } /* function dividing a number by 2 */ double Shrink(int value) { return value / 2; }
That is a really great document. Thanks. 
It seem's to be getting there. When I implement that it gives me say I give it 11. It should say 5.5 but it just gives me 5.00000 instead.
sorry..I missed something copying and pasting your code and merging mine. try this for `Shrink()` double Shrink(int value) { return value / 2.0; } Just to explain what is going on here, you are passing an `int` to the function. Which is fine, but now we are doing this. `int \ int`. We need to divide by a double. `return double / 2.0`.
Leaving it blank made it mad at me I changed it to double Shrink(double vale); And it is now working! Thank you very much for your help good sir. 
I "*loved* "Lion's commentry". I always recommend it. It's maybe one of my favourite books, let alone computer books. But I'll never get to read from fresh again. :-( The book even has it's own story of being underground, passed around by photocopies. https://en.m.wikipedia.org/wiki/Lions%27_Commentary_on_UNIX_6th_Edition,_with_Source_Code
**Lions' Commentary on UNIX 6th Edition, with Source Code** Lions' Commentary on UNIX 6th Edition, with Source Code by John Lions (1976) contains source code of the 6th Edition Unix kernel plus a commentary. It is commonly referred to as the Lions book. Despite its age, it is still considered an excellent commentary on simple but high quality code. For many years, the Lions Book was the only Unix kernel documentation available outside Bell Labs. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
No, it should not be a pointer to base, it should include base. The goal is to make the memory layouts compatible so I can typecast a pointer to/from base and a derivate struct and read the same data in a safe and correct way.
Don't you mean "." instead of "-&gt;"?
Why tho?! xD
"Advanced programming in the Unix environment" is great read for POSIX.
Welcome to the brotherhood.
So i've had a go at writing and reading a fifo which works, however i'm finding it a bit tricky to read in certain elements. For example, my java program would write **Mode:3,** and i want the C program to read in this value, split by **,** and check each section against constants- So mode would be set to 3 in this case. I've added in some **strcmp** code but it's not working correctly. I feel as if the buffer is different and i'm a bit stuck on how i can effectively pull it out. *(The options class is simply just a struct with some values)* //-- Setup Options static int fd; static char * myfifo = "options"; static int MAX_BUF = 1024; static char buf[1024]; static Options options; static Options readOptions() { //-- Clear Buffer memset(buf, 0, sizeof(buf)); //fprintf(stderr, "Reading Options File...\n"); /* open, read, and display the message from the FIFO */ fd = open(myfifo, O_RDONLY); read(fd, buf, MAX_BUF); //-- Read File //-- Data From Service Found //-- Check for Mode Data if(strcmp(buf,"Mode") == 0) { fprintf(stderr,"Mode Data Found!\n"); //-- Split Buffer char* something = strtok(buf, ","); fprintf(stderr,"Mode Data: %s\n",something); } close(fd); return options; } Thanks in advance :)
Actually i only really need the java program to talk to the c program. Think of the c program as a wrapper for java to give comma separated commands to and the c program will adjust accordingly
The author took a lot of artistic liberty with the book and makes a lot of fish puns. The cover of the book has a fish on it too.
I'm quite comfortable with the Java side. I'm more having issues with the c side of things
Never heard of it. Check the sidebar for the most common resources for learning C.
I will have to check a few of these my self. My suspicion is not that there is a lack of information, it's just a lack of new information. Since c doesn't change much there hasn't been a real push to reteach anything in video form. So I'd say the info is out there it's where you look. Videos specifically though I would say it's lacking compared to many others though. Are you looking for something specific or more of a general approach?
I really like the essential c- it's perfect if you already know other languages. It's from Stamford. It's not in our list!
Nothing in particular, really. I'm just hoping to pick up a bit of knowledge here and there. So if it's not a series that starts with hello world and ends with pointers I'm probably interested in it. I usually binge watch talks covering my currently favoured language, I'm not picky about topics. Handmade Hero seems really fantastic. I used to do gamedev in C++ so a C only perspective is really valuable to me.
Haven't looked into the formula, but C uses radians for angles. Maybe you were expecting degrees, if so, you need to convert it into degrees.
Aside from being a little awkward to read I don't think there's anything wrong with your code... Consider a triangle with the points (0, 0) (2, 0) (2, 4) This would make (area - b) = 0 which would make alpha and gamma = zero and beta = -inf... Perhaps the problem is with the question or your implementation of the formula?
Although it doesn't say so in the problem statement, the p in the half-angle formulas stands for the semi-perimeter, not area, i.e., p in problem 4 is s in problem 3. 
What answers do you get? When I enter 10,10 10,20 and 20,10 to your program, I get: distance: a=10.000 b=14.142 c=10.000 perimeter: 34.142 s=17.071 area of triangle: 50.000 gamma: 1.405 beta: 1.514 alpha: 1.405
Handmade hero is good but pretty long. The handmade.network community has other programmers doing c things as well if you want to just watch people code. I don't have anything more specific beyond that direction at this point tho. I'll be watching this thread to see what others comment though. 
It compiles on my system, albeit with warnings. Arch Linux 4.13.4 gcc 7.2.0 with -std=c99
I know I can use: for ( int j = 0; j &lt; argc; j++ ) { argv--; } To bring me back to my original location, but I am wondering if I can do this in one line?
Use the same type as the argv's int main(int argc, char **argv) { char **temp = argv; But it is bad form to modify argv - everyone knows it as the array of command line arguments, modifying it is confusing
Thank you this worked!
The best way to learn anythink, in my opinion, is in class. If you don't want to to college, the 2nd best way to learn is reading books. And the best book to learn C is, in my opinion, C in a Nutshell by Peter Prinz and Tony Crawford, from O'Reilly.
I enjoyed this: https://www.youtube.com/watch?v=443UNeGrFoM
Video linked by /u/BaffledKing93: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [How I program C](https://youtube.com/watch?v=443UNeGrFoM)|Eskil Steenberg|2016-11-21|2:11:32|356+ (89%)|22,412 $quote This is a talk I gave in Seattle in October of 2016. I... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/BaffledKing93 ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
It's good practice not to modify or reassign the argv pointer. If you'd like to loop over argv multiple times to print out the arguments, why not just use a for-loop over the range (0, argc] and index into argv instead of reassigning it? for (int i = 0; i &lt; argc; ++i) { printf("%s\n", argv[i]); } 
It’s much more easy to just alter `temp` or what have you— char **argp = argv; const char *arg; for(; !!(arg = *argp); argp++) { Use `arg` } It’s altogether too easy to lose or otherwise bork `argv`/contents otherwise.
Sorry, you are quite right. It does compile. The two warnings I get are : warning: initialization makes pointer from integer without a cast warning: excess elements in scalar initializer So the pointer isn't initialized to point at the number 3, but is initialized *with* the number 3. And the second initializer is lost. Seeing as the memory at address 3 is not valid, it would seg fault. It is an odd design feature / flaw isn't it.
How is this related to the C programming language?
You're right. Printing printf("%p\n", foo); Results in 0x3 It is a weird feature but it actually helped a lot in my understanding of arrays vs pointers. I guess the best way to learn sometimes is to break things.
use fgetsc(fp) != EOF and read that into a char buffer.
I just skimmed the C portion of that site. I wouldn't recommend it to anyone. Looks like lecture notes from a first semester college student — not so awful that I'd surround it with stern warning signs, but kind of pointless in the presence of much better texts. In addition to the resources listed in the side-bar, check out [The Definitive C Book Guide and List](https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list). It isn't actually all that definitive; don't take it as solid shopping advice, but a starting point from where you can look up some reviews, then do some try-before-you-buy (libraries etc.). As a rule of thumb, stick to books/sites that have at least a few exercises for every chapter (and actually do them!), and avoid everything from the 'Learn X in Y days' and 'Z for dummies' genres.
I recommend you to look for a book called "pointers in c" although is a general C programming book, the chapter on pointers is totally pure gold. You won't find any better. That's if you want to learn C. If you just want to pass tests, just ignore me.
I've certainly seen a lot worse, but it contains egregious stuff such as this: char c; fr = fopen("prog.txt", "r"); while( c != EOF) { c = fgetc(fr); Many C programmers will out of habit wince immediately at the wrong data type, but the familiar bad patterns here are so ingrained that it may be easy to miss the fact that the variable isn't even initialized before use. In the next section, we see this: address = (char*)malloc( 50 * sizeof(char) ); I've never really cared about malloc() casts, but that `sizeof(char)` is pretty much unforgivable for someone who's teaching the language.
use sprintf. Works the same as fprintf but it takes a char* instead of a file descriptor
Print it to a char array of suitable length with snprintf.
Thank you! I have been googling for the past hour with phrases such as: "memory address to string c"
 /* your code goes here.*/ It does whatever you wrote it to do
LOL I know right, so this is suppose to read some data which from an array of pixels and look for some specific sequence of pixels. I know there is some masking done here I know how that works with binary but I am confused about the hex part and how is that AND ed with array values since they are not in hex but look like this: 5932: 185207051 5936: 151587081 5940: 151587082 5944: 151718154 5948: 168430345...... 
A number's just a number. It may be decimal in the file but you can do any operation on it. Since they're pixels, I expect the masks are getting the 8-bit R, G, B, and A values from the 32-bit pixel value 
there not RGB values thats what I thought initially, there are 4 pixels packed in a byte, if you unpack each pixel corresponds to a number but I still don't understand what this fcker does whats up with the shifting. I need to take this line by line and justify what it does
So you want us to do your homework for you? What do YOU think it does?
What's the difference? honest question.
Maybe I'm weird, but I couldn't learn from tutorials because I just didn't care about the example programs we were building. Maybe just finding something you wanna make and learning everything you need for that would be a better way to go?
 char x = 502; char * y; y = &amp;x; 1. Make a variable called "x", assign its value to 502 2. Make a char pointer called "y" 3. Assign "y" to the address of x Address of "x" is whatever is available in memory at runtime, let's say it is 0xffff0000 then Value of &amp;x would be 0xffff0000 Value of y would be 0xffff0000 Value of *y would be 502 Value of &amp;y would be arbitrary memory address
 &gt;Value of &amp;x would be 502 Correct &gt;Value of y would be 502 Correct &gt;Value of *y would be 502 Correct &gt;Value of &amp;y would be 10,000 Correct &gt;Value of \*(\*y) would be NULL Wrong: it wouldn't compile (`*y` is a `char`, you can't dereference that). However, assuming you assign the value of `y` to a `char**` pointer, and then dereferenced that twice, you would get 502 (because the value of `*y`, 502, is interpreted as an address, so the address 502, which contains the value 502, is read).
Look at the code. OP meant `*(*y)`, but the formatting made it `(y)`.
Could you expand a little on why you don't care for malloc casts? I thought it was necessary to cast the call because malloc returns a void pointer
Ah, thank you. I don't mess with reddit formatting too much =]
This is more x-86 based, right? If he is going into embedded software then he'll be more likely to work on ARM-based microcontrollers. Unless of course, he ends up working with embedded Linux. Regardless, that doc is pretty amazing. Can you please provide to Dr. Fog's blog!!!
The void pointer was introduced in C89/C90 as a generic pointer type. It can be implicitly converted to any object pointer type without an explicit cast. It's why examples such as these appear in the standard: struct s *p = malloc(sizeof (struct s) + sizeof (double [m])); t.v = malloc(n * sizeof (float)); So the cast isn't necessary, but does that mean it's harmful? Before C99 removed implicit function declarations, some argued that the cast was harmful because it might inhibit a compiler warning triggered by a missing stdlib.h inclusion. I never found that argument all that persuasive and have always considered the presence of malloc() casts a matter of style. That's why I don't care about them.
One comment. When you say these two things, together: &gt; Value of y would be 502 &gt; &gt; Value of (y) would be NULL Then it suggests you need deeper study. (Or it was a typo?) Unless you're talking about macro expansion (i.e. not here) then there's no situation where we should expect the value of any expression `y` to be different than `(y)`.
Divide and conquer! When the problem doesn't seem tractable, break it up into smaller parts. Here's how I would have approached the research: Step one: look up what type the `&amp;` operator returns: aha, it's a pointer. What does that mean? It means my lazy ass chose one of the first search results and ended up at a site for noobs who are in too much of a hurry to learn this properly. What else can I find ... oh, check this out: "a pointer type derived from the type of the operand". Bingo! That means we're getting a `char*` in this case. I figured that out as follows: [cdecl](https://cdecl.org/) deciphers `char *argv[]` as "declare argv as array of pointer to char". Since we're getting that as a function parameter, the array 'decays' to a pointer. Therefore, the type of `argv` is actually `char**`, so the type of `**argv` is `char`, which makes the type of `&amp;(**argv)` `char*`. (Bonus question: what's the difference between `*argv` and `&amp;(**argv)`?) Step two: When using a format string to convert that value to a string, what's the correct ... uh ... `%` thingy? What is that called? Step one-and-a-half: Oh, right, the magic words are *format specifier*. Step two 2: Google Harder: Turns out we can use `%p` to stringify a `void*`. The compiler knows how to turn a `char*` into a `void*`, so we're done! *** One more thing: It looks like your compiler let you get away with `printf("%x\n", &amp;(**argv));`, so I guess you now have something like `sprintf(address_str, "%x", &amp;**argv);`. That's the kind of thing that seems to work fine, until it doesn't, at which point you're in for a debugging session that'll probably be a lot more work than going through the kind of geekery on display above. You should turn on more warnings! For example: $ gcc -Werror -Wall -Wextra -pedantic -std=c99 argv.c cc1: warnings being treated as errors argv.c: In function 'main': argv.c:6: warning: format '%x' expects type 'unsigned int', but argument 3 has type 'char *' Thanks, gcc! By the way, clang shows that warning even without any compiler flags (though you'd still need `-Werror` to turn it into an error): $ clang -std=c99 argv.c argv.c:6:32: warning: format specifies type 'unsigned int' but the argument has type 'char *' [-Wformat] sprintf(address_str, "%x", &amp;**argv); ~~ ^~~~~~~ %s Good bot!
 char x = 502; [...] Value of *y would be 502 Is this part of some test you're taking? A typical machine won't be able to represent the value 502 in a char. If char has the same range, representation, and behavior as unsigned char, the value that winds up in the variable will be the result of a modular reduction. If char has the same range, representation, and behavior as signed char, then 6.3.1.3#3 from the standard applies: "Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised." This effectively means that any documented behavior can occur. 
Correction: `fprintf` takes a stream, `dprintf` takes a descriptor. 
Sorry, Reddit formatting removed what I wanted to add to the last line for some reason. Last line is supposed to be a pointer to a pointer, or * ( * y)
OK, here are some thoughts: 1. `read()` returns once it has read some contents from the fifo, so you'll probably have to loop to continuously read from the fd. 1. You should not do a `strcmp() == 0` if you want to compare a prefix. You could do something like `strncmp(buf, "Mode", strlen("Mode"))` - this will compare the first four characters of `buf` against `"Mode"` 1. Check the manpage on `strtok`, it behaves differently than you probably think. Example program (I usually do a short `main()` to test behaviour of function calls I don't yet fully understand): #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; int main(int argc, char* argv[]) { char opt[] = "Mode:3,5,6,7"; printf("strncmp: %d\n", strncmp(opt, "Mode:", strlen("Mode:"))); char* t = strtok(opt + strlen("Mode:"), ","); while (t != NULL) { printf("t = %s\n", t); t = strtok(NULL, ","); } } 
I'm in class now but it does look the same as what I've been getting
What were I thinking? I'm in class now. I'm going to implement it later today and come back with the result
I think you're right with 'p' but I can't confirm it until I get back home today. Will come back to report.
Do not use `%x` to print pointers! That's undefined behavior! Instead, use `%p` and cast the pointer to `void*` before: printf("%p\n", (void*)*argv); Note how `&amp;` and `*` cancel each other.
Where are you stuck?
I encounter way to many of these formatting errors on daily basis, one can get very weird bugs when misusing format specifiers. People should code more careful, especially with C.
At the beginning "^^
Okay, makes sense. I'll give this a go when I'm back from work. I don't suppose there is an easy json library for c that could simply parse data in from the FIFO? Would make it a lot easier to define objects. Thanks for the help though :) 
&gt; *"I've tried nothing and I am all out of ideas!"* You cannot expect to get any help like this. There are too many open questions. Help us to help you! It doesn't work like this in face to face communication either, does it? 
Oh there are JSON libraries for C if you search the internet. I don't have any experience with those though, but their APIs seem to be OK. My approach is usually to keep it simple at first. If you require more sophisticated data structures I would settle for something like JSON. It usually depends on: 1. Who's writing to the FIFO - want to make it developer friendly? 1. Hierarchical data? 1. Not much data, but easy to tokenize? etc. Just because you can, doesn't mean you should :) Btw: now that I think of it: there's one downside for the FIFO, and that's that you can't easily figure out in the *sending* program whether the specified string is properly formatted or not (it's no request-reply).
The FIFO file is only being written to by a Java service that's hosting a json based rest service. Some of the data will be hierarchical and will eventually contain quite a lot of data. I understand your point of keeping it simple at first, but if I can get the program to read a single key/value pair from the file, it'll handle a lot of them. Just a case of expanding and adding in new logic to set variables accordingly. Surely with a json library, I could check the format and print an error? That way it would stop the options being set if something goes wrong to stop it falling over in a heap haha 
Try this: http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf
&gt; if I can get the program to read a single key/value pair from the file, it'll handle a lot of them. Just a case of expanding and adding in new logic to set variables accordingly. Yeah, if you can make it in such a way that it can handle one `Mode:x,y,z,...` formatted string, it's pretty trivial to write logic for other option names I suppose. &gt; Surely with a json library, I could check the format and print an error? Like I said I don't have any experience with JSON libs, but surely enough there is some kind of error handling available, no doubt in that :) Also: you could also use `sscanf()` instead of tokenizing: int firstMode, secondMode, thirdMode, fourthMode; char* bla = "Mode:1,2,3,4,5"; int x = sscanf(bla, "Mode:%d,%d,%d,%d", &amp;firstMode, &amp;secondMode, &amp;thirdMode, &amp;fourthMode); printf("Read %d elements\n", x); printf("First: %d\n", firstMode); printf("Second: %d\n", secondMode); printf("Third: %d\n", thirdMode); printf("Fourth: %d\n", fourthMode); This is probably easier than tokenizing if you know the order of elements beforehand.
I know but i dont know how to starts, like i know how to programming C but i dont know how can make a menu using arrow keys. 
Are you writing a console (terminal) application? Are you able to use a GUI toolkit such as GTK? Are you able to use external dependencies?
You're just complicating it for yourself - had you had chosen 502 for the address of y as well all of the answers would have been 502 - there you go, simple ;)
no I don't want you to do my homework that is not what I have asked. I am trying to debug may code and see why is it not working with the given template; thanks for trying anyways 
can I ask what exactly is the issue with `sizeof(char)`? I realize most systems have char as one byte but it can be more no? so why wouldn't you ensure compatibility with a system that uses, say, 2 bytes for a char?
get a book...a famous one as K&amp;R or King`s books. You have to learn a lot and those sites aint exactly high quality resources! Go safe go well
Red Hat haha
They're definitely similar concepts. Two ways of making a more convenient dynamically-sized array. But the way they work is very different. Variadic arrays (Variable-Length Array or VLA is the proper term, I believe) are allocated on the stack: int main(int argc, char **argv) { int array[argc]; } You could replace this with a pointer: int main(int argc, char **argv) { int *array = malloc(sizeof(int) * argc); free(array); } VLAs offer a more convenient syntax, less chance you get the size wrong, and being on the stack the memory is automatically freed. On the other hand, it's on the stack where there's often less space than the heap ... and what happens when your system scales up and you overflow the stack? Oops. In terms of performance, this is one of those things that has to be measured. For small arrays I suspect VLAs are slightly faster (very quick allocation and deallocation compared to the heap), but for larger arrays you might be losing important locality on the stack. In general, I'd say that if you know the data is small then a VLA is fine. Flexible array members are always part of a structure: struct flexible_array { int size; int array[]; }; You then allocate memory for the entire thing with `malloc`: int main(int argc, char **argv) { struct flexible_array *flex_array = malloc(sizeof(flexible_array) + sizeof(int) * argc); free(array); } Ok, that looks ugly. Why do this? The main benefit is that the array is embedded directly into the structure. It's as if we declared `int array[argc];` like we would have with a VLA ... but every instance of this structure can be of a different size (which is why I put the size field in there as well). But this doesn't live on the stack, so we have to use `malloc` and remember to `free` later. Had we gone with a more traditional method: struct dynamic_array { int size; int *array; }; Now the memory for `array` lives elsewhere, so accessing it requires an extra pointer dereference each time, and you usually get worse cache locality. (Caveat: none of the above code went through a compiler, there might be syntax errors).
[Agner Fog's optimization resources](http://www.agner.org/optimize/) Yes, the RedHat paper is x86 focused, but there are some things that apply to ARM. 
Yes i am using console terminal. Yes and Yes ahah 
Excellent, i'll look into this. Just trying to test some JSON stuff now I've managed to find a JSON library that seems straight forward but i've pulling my hair out with this pissing makefile. Just doesn't seem to want to locate it and i'm not sure what's wrong. The library is called **cJSON** and is located in the folder */cjson/cjson.c* Any ideas? CXXFLAGS=-Wall -O3 -g -fno-strict-aliasing BINARIES=Neon rgbmatrix.so # Where our library resides. It is split between includes and the binary # library in lib RGB_INCDIR=include RGB_LIBDIR=lib RGB_LIBRARY_NAME=rgbmatrix CJSON_LIBDIR=cjson CJSON_LIBRARY_NAME=cjson WIRINGPI_LIBRARY_NAME=wiringPi RGB_LIBRARY=$(RGB_LIBDIR)/lib$(RGB_LIBRARY_NAME).a LDFLAGS+=-L $(RGB_LIBDIR) -l $(RGB_LIBRARY_NAME) -l $(WIRINGPI_LIBRARY_NAME) -L $(CJSON_LIBDIR) -l $(CJSON_LIBRARY_NAME) -lrt -lm -lpthread all : $(BINARIES) $(RGB_LIBRARY): $(MAKE) -C $(RGB_LIBDIR) Neon : Neon.o $(RGB_LIBRARY) $(CXX) $(CXXFLAGS) Neon.o -o $@ $(LDFLAGS) # Python module rgbmatrix.so: rgbmatrix.o $(RGB_LIBRARY) $(CXX) -s -shared -lstdc++ -Wl,-soname,librgbmatrix.so -o $@ $&lt; $(LDFLAGS) %.o : %.cc $(CXX) -I$(RGB_INCDIR) -I$(CJSON_LIBDIR) $(CXXFLAGS) -DADAFRUIT_RGBMATRIX_HAT -c -o $@ $&lt; clean: rm -f *.o $(OBJECTS) $(BINARIES) $(MAKE) -C lib clean 
Aside from the issues already mentioned; you should check the return value of malloc, memory allocation is not guaranteed to succeed, especially in low mem environments. Sizeof(char) is always defined as 1 in C, no matter the target architecture. 
So below 64 is free to use user defined return codes? 
I'm aware about malloc but I am just experimenting and my program is really tiny. Thanks for the sizeof tip!
Generally speaking and short answer, yes. Longer answer: Different platforms handle this differently, and my advice tends towards POSIX/UNIX with an eye to portability. AFAIK per C standard you’re guaranteed nothing beyond ~zero/~nonzero (or `EXIT_SUCCESS`/`EXIT_FAIL`, but good luck finding somewhere those aren’t zero and one), if indeed anything’s able to receive an exit status at all. [Here’re](http://www.retro11.de/ouxr/211bsd/usr/include/sysexits.h.html) the old standby BSD exit codes, which is what I was referring to in reference to 64 being the whatever-goes boundary—it’s useful for OS utilities to share a common set of error codes like that, so that things like `ls` and `cc` give vaguely useful output when they break, and IIRC old BSDs explicitly reserved the sub-64 range for application use so it sorta stuck. If you’re not on BSD and/or don’t GAF about BSD compatibility, round ’bout 120 is where otherwise useful error codes start getting mixed in more universally. E.g., your program can return 127, but that might confuse something with the shell’s return code for “command/program not found”. DOS/Windows has ~no rules that I know of in terms of what exit code you return beyond fitting into a byte, though the usual zero=success/nonzero=fail dichotomy tends to hold, and AFAIK Windows basically gives no fucks in practice except in rather rare occasions where one program’s actually waiting for another to exit. (So… orchestration scripts and installers care mostly.)
You need to compile the cjson library and then put it into an archive file (`libcjson.a`) using `ar`. Then, pass a `-L` option to the linker invocation to specify the directory containing this archive and `-lcjson` as before. The commands should look like this: cc ... -c cjson.c ar -crsv libcjson.a cjson.o cc -o Neon -L... Neon.o -lcjson where ... is filled in as needed. Note that this subreddit is about C only. Please post future C++ questions elsewhere.
Thanks for the information, i'll have a look and whacking this in now. :D This makefile is for a c program, where are you getting the idea that it's c++? I compile it using g++ When the makefile is ran it shows g++ -Wall -O3 -g -fno-strict-aliasing Neon.o -o Neon -L lib -l rgbmatrix -l wiringPi -L cjson -l /cjson/cjson.c -lrt -lm -lpthread 
g++ is the C++ compiler, using it to compile C code is deprecated. Invoke gcc if you want to compile C code. Also note that all options (`-l` operands aren't options) go *before* operands, so the `-o Neon` is misplaced in your Makefile. As I tried to say before, you cannot link to a source file (`/cjson/cjson.c`). You have to compile it into an object and make it a library with `ar` before you can use it as a library. You could also compile it and then link it by listing `cjson.o` in the linker invocation.
Ahhhh okay, i see what you are saying. My bad haha Perhaps this was why eclipse was showing loads of strange problems. Would it have detected it as a C++ project? Appreciate the info sir/madam :D I have now fixed it (he says) and on to other things yusssss Cheers :D
&gt; Ahhhh okay, i see what you are saying. My bad haha Perhaps this was why eclipse was showing loads of strange problems. Would it have detected it as a C++ project? Most certainly. Always place C code in `.c` files and C++ code in `.cc` files and use the right compiler! That means, g++ for C++ code and gcc for C code. I'm happy that you were able to resolve your problem.
Do not post pictures of code. Always post code as text. And put four blanks before every line of code so your code appears readable. I have removed your post so you can try again with the code posted as text.
**Oh but wait there's more (-_-) haha** So the makefile is working nicely but i'm getting undefined reference to `rgb_matrix::DrawText(rgb_matrix::Canvas*, rgb_matrix::Font const&amp;, int, int, rgb_matrix::Color const&amp;, char const*)' I still don't think i've grasped the namespace stuff that C has haha Something wrong with my namespace? //-- Namespaces using namespace rgb_matrix; using namespace CellularAutomata; using namespace AntAutomata; using namespace DateTime; using namespace Helper; using rgb_matrix::GPIO; using rgb_matrix::RGBMatrix; using rgb_matrix::Canvas; using rgb_matrix::Font;
C doesn't have name spaces. You are programming in C++. Please ask C++ questions elsewhere, e.g. in /r/cpp_questions.
Thank you for reposting your code as text!
Okay fair enough, thanks though
No problem :)
Are there any include directives before your this code? Things like `#include &lt;stdlib.h&gt;`?
Yes, #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt;
Thank you! Please edit this in so others are not confused.b
1. This is a C sub, not C++ 2. Do your own homework.
Okay. And no, just that.
In C, arrays with n elements go from index 0 to index n &amp;minus; 1. In the loop for(int j = i*i; j &lt;= num; j += i) array[j] = 0; You potentially access item `num` of `array`. To fix this issue, change `j &lt;= num` to `j &lt; num`.
i'm trying to do it myself and i've gotten to a point where i don't know what to do that's why i asked, not because i'm lazy
Thank you! See my other comment for the resolution of your problem.
Oh, that was it. The program works now, without that printf line after malloc. Now I don't understand why it worked before, with printf.
Thank you for that!
I don't see the point in manually using [https://github.com/VictorSCushman/darray/blob/ae395dbbfc731ca7f352a04fe70923adcb95382a/darray.h#L297](offsets). That's what structs were invented for.Let the compiler deal with the packing and offsets of structs members. What you basically have is: struct darr{ size_t elemsz; size_t len, cap; alignas(alignof(max_align_t)) char data[]; } To the client you only pass the `data` pointer, to get back the structure in internal functions use `*(struct darr *)((char *)data - offsetof(struct darr,data))`. I see that's essentially what you're doing now, but by hand for each struct member.
You overwrote data after the array. This data was used by `malloc` for bookkeeping and trashing it freaked out `malloc` when it was called by `printf` later on. By calling `printf` first, `malloc` is invoked before you trash its bookkeeping, avoiding this effect.
This subreddit is about programming in C only. As seen from your file extension `cpp`, you are programming in C++. If you want to program in C, this is the first error you need to fix. If not, please ask in /r/cpp_questions instead of here.
Correct, the reason for manual offsets is that when you are dealing with a pointer directly to data, the handle you give a user would either have to be to the parent struct, or a double pointer to the .data member. That's what libraries like rxi/vec do, which is fine, but the goal of this library is to remove the extra layer of indirection. Having bracket operator syntax and reference-like semantics that just work out of the box make dynamic arrays more pleasent to work with. Or at least that's the intention.
I think you missed the point: you can pass `data` to the user, and it can be used with `[]`. And given a valid `data` pointer you can get back the struct as described above.
Ya I know what you mean, but to get back to the struct you have to have the address of the actual pointer to data. Correct me if I'm wrong but to get the address of the parent struct from the `data` member you would either need to hand the user `&amp;foo.data` thereby basing library operations off of a double pointer to the element type, or you would have to give a user to the struct itself.
You hand the user `foo.data`, which is a flexible array member right after the header, i don't get what you're saying about double pointers. This is the same as what you have now, but doesn't use offsets computed by hand and uses a struct instead.
Say I have created one of these structs, `foo` somewhere in memory, and the data member points to an `int` array. Somewhere at some point in time `foo` was created and instantiated, and the user needs to get the handle to the data. As a user if I want an array of int I'll create a variable `int* bar` to hold my array. Since `bar` is an array I can access elements with `bar[some_index]`. The user is given `foo.data` and they now have a pointer to int implicitly converted from pointer to char. Without knowing the context from which I am accessing my data, there is no reliable way to access `foo.elemsz`. `bar` only holds the location of the first element, and `&amp;bar` is a pointer to the address of `bar`, not the address of `foo.data`. So in order to always have access to `foo` I would need to know the address of `foo.data` thus the user would need to handle `&amp;foo.data` so that the location of `foo` could be calculated. This the user would need to hold an `int**` as a reference, i.e. a double pointer. It's similar to the way `list_head` in the Linux kernel works.
With the darray, the header is literally adjacent to the data, not adjacent to a reference to the first element of the data. That's the key difference between the way this library works and the way the struct approach works.
That's how flexible array members work, the data is literally after the member before it in the struct (+padding space for alignment).
So you're using your own magical hiding of stuff in a blob of memory instead of a struct, then you have this massively overdesigned interface for what in a normal program is a few lines of code with realloc. Why?
Oh. I did not know that. I totally thought they worked differently than that. Thanks you.
Glad we're on the same page.
Ya well shit my mind's just been blown.
Yep. Gonna do some redesigns today.
There are a few restriction to the way a struct flexible array data member can be used: * You can not include one in another struct * You can not create an array that contains structs of this type. See https://www.securecoding.cert.org/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member for more restrictions. 
Before redesigning your Darray read about the restrictions that a structs with a flexible data member must obey: https://www.reddit.com/r/C_Programming/comments/75a5uk/a_while_ago_i_posted_on_this_sub_about_my_c/do55j97/ https://www.securecoding.cert.org/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member 
That's common sense: you can't do those things because they have variable length.
True, but it is not obvious to the unsuspecting user.
It has nothing to do with the approach, even if he doesn't use flexible array members for the implementations: he can't create a dynamic array of dynamic arrays. It simply requires a different data structure.
I like the approach from the stb libraries https://github.com/nothings/stb/blob/master/stretchy_buffer.h clear design , portable to all C compilers and (hopefully) bug free.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nothings/stb/.../**stretchy_buffer.h** (master → 9d9f75e)](https://github.com/nothings/stb/blob/9d9f75eb682dd98b34de08bb5c489c6c561c9fa6/stretchy_buffer.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply do56fm0.)^.
That's fine. I'm just gonna walk of shame back to my repo and do some fixing.
But it's just an arraylist?
Okay, why do you need to 'take it line by line and justify what it does'?
I needed to figure out exactly what happens so I could identify if the error I was getting was due to my part of the code or the provided template. I had figured out eventually what the problem was after hours of looking at the code...I just needed an experienced person input but I think I am good now. Thanks for checking 
Use semicolons for your loops, the fuck is wrong with you?
To add to this: The range of `signed char` only has to be −127 to 127 and `unsigned char` 0 to 255. “A typical machine” gives you down to −128 and that’s it. The “value of `*y`” question is unanswerable without a specific compiler and/or ABI and/or list of options set out beforehand. No clue why the question didn’t just use `int` like everybody else.
AFAIK per standard the last one *might not* compile, depending on the compiler, though no self-respecting modern compiler should permit it. (It’s supposed to issue a diagnostic since `char` doesn’t have a pointer type, but the compiler could just poot quietly and generate code treating it as `anything *`. Multiple unanswerable things in these questions.)
I'm not sure what the practical side of this project is all about. If it's something for your own use, than as long as you're comfortable with it and it works, that's great. If it's something for public use, than a clear API and simple approach is better than hiding the data structure. On the note of performance, removing the indirection layer can be done using macros and inline functions. The compiler will optimize the rest just fine. Also, by hiding the data structure, you're sacrificing possible features, such as `shift` (pushing data to the head of the array), negative lookups (seeking from the end of an array), array nesting, and perhaps dynamic typing. Thank again, [my code](https://github.com/boazsegev/facil.io/blob/2de5f288ccb855a64ddab8840dff919566d7719c/lib/facil/core/types/fiobj.h#L416-L493) isn't as beautifully commented as yours, so you probably shouldn't trust me ;-)
The number is whatever you interpret it to be, signed, unsigned, ascii.... The raw bits are the same, so it's pointless to compare them. That said from an "interpretation" point of view we should be dealing with at least 8 bits, not 4 (it makes a difference with signed numbers)
Right, so then whether or not the number is interpreted as signed or unsigned, the hexadecimal representation will be different correct?
Try thinking of it this way. 10 is A in hex and 1010 in binary. Similarly -10 is -A in hex and -1010 in binary. This would be the pure mathematical representation. Now the problem is, how do you represent a negative number in computer memory? By far the most common method is to use the two's compliment. This is obtained by "flipping" each digit and then adding one (eg 0000 1010 "flipped" is 1111 0101 plus one is 1111 0110. Note I used 8 bits or 1 byte here) The reason two's compliment is used is because addition doesn't change! Consider 11 + (-10) 11 = 0000 1011 -10 = 1111 0110 1 = 0000 0001 (Note there should technically be a leading 1 in the 9th digit, but because we only use 8 digits it looks like 1!) 
I get all of this as well, but what about just looking at it from a standpoint of 1010 in binary to hex is A, so -1010 in binary to hex is -A? I guess the question I'm trying to ask is does the hexadecimal presentation depend on whether the number is signed or unsigned?
No the presentation should not change (-A is valid) The hex representation is a mathematical construct used to "decipher" a binary string (4 binary digits = 1 hex digit so it's a lot easier to read) Computers don't use hex to operate so there is no need for alternative representations.
You're confusing its representation vs it's value. The hex representation is just shorthand for how the bits are set, in other words it's never -0xA, it's just 0xA. That's a representation of how the specific bits are set and has nothing to do with its numerical value. This goes for every single type from numbers to strings to flags etc etc. The numerical value is how you interpret those bits and is highly dependent on architecture and format. For instance you may use 1s complement instead of 2s complement and 0xA4 would be -91, but in 2s complement would be -92. in either case those numbers *in* hexadecimal wouldn't be 0xA4, they would be -0x5b and -0x5c respectively. Just to hammer the point I also assumed an 8bit value here, if we were talking about a 16 bit value then the representation would be 0x00A4 and would not be a negative value in either 1s comp or 2s comp.
Probably a couple of ways. Create your custom byte buffer (for example, see [mine here](https://github.com/krpors/hx/blob/e3bfe50abf04dda2e245735e3360ecf59ba28663/charbuf.c)). It's essentially a dynamic array which grows as needed (but does not shrink, though), and implements a very common technique through many languages. This may or may not be overkill for what you require. Use `snprintf` to write the complete thing. One tiny bit of a drawback is that the char array needs to have plenty of size to include everything. Ex.: int size = 1024; // bytes char* contents = calloc(size, 1); snprintf(contents, size, "%s%s%s", command, delimiter, victim_string); printf("Contents: %s\n", contents); free(contents); With many arguments to `snprintf` it may look a bit ugly but it works. If you write more than `size` bytes though, it won't overflow, but you get truncated data.
Notice how you're repeating the same code over and over again? You should write a helper function, `append_msg`, that takes a `uv_buf_t*` and appends a string to its `buf`. A simple approach would be to always `realloc` buf to create enough space for the appended chars. I'd start here just to get things working. If that's not performant enough, you could try to reduce the amount of `realloc`ing with some strategy like always adding a reasonable amount to buf, like 512 bytes, or always doubling the size of buf. A more complex, but possibly even more efficient approach would be to delay copying/concatenating characters to the very end. E.g. use an array of `char*`s to which you add elements for each piece of the message. Then, at the end, go through all the `char*`s to determine how much space you need to alloc for the message, then go through all the `char*`s appending them to create the final message.
So in essence, the value of a hexadecimal representation is dependent on how the machine interprets it? And not the other way around?
Yes but that statement is true for all representations, whether hexadecimal, or binary, or decimal. Hex is just very useful shorthand when we talk about what the memory looks like, it's a representation that works *very well* for describing bits because the base is just a multiple of 2. Every hex number represents 4 bits. This makes looking at memory addresses or describing the content or a memory address much less verbose. The value on the other hand is just what you said, an interpretation of what is sitting in memory. You can obvs describe certain types in hex, but they won't necessarily be the same as what is sitting in memory because you may or may not be describing two different things. Your confusion is prob coming from the fact that unsigned integer values and hex representations are the exact same, but they're wholly different for every other type of value. i.e. I can describe a real number such as 10.5 in decimal as 0xA.8 in hex, but that has absolutely nothing to do with how a fixed point or floating point number is represented in memory, and in fact there are many ways to describe said number using different fixed/floating point standards. 
&gt; can I ask what exactly is the issue with sizeof(char)? I realize most systems have char as one byte but it can be more no? so why wouldn't you ensure compatibility with a system that uses, say, 2 bytes for a char? sizeof(char) will always be 1, by definition. From the standard (6.5.3.4#4): "When **sizeof** is applied to an operand that has type **char**, **unsigned char**, or **signed char**, (or a qualified version thereof) the result is 1." Even on a DSP system or whatever with a larger character "size," sizeof(char) will still return 1. This may be confusing because the standard also says "The **sizeof** operator yields the size (in bytes) of its operand" (6.5.3.4#2). The trick is that the standard uses the historical definition of a byte as simply an "addressable unit of data storage." This historical byte may have more than 8 bits (which is why many networking standards and whatnot use the term "octet" instead of "byte" -- it makes it clear that an 8-bit unit is being considered). So think of sizeof() as counting storage units rather than bytes in the modern sense. A character is one storage unit. 
In C you can use `qsort` to sort arbitrary types of data. You have to pass in a comparison function which knows what that type is.
A nifty trick is to use `open_memstream()` from `stdio`. This gives you a `FILE*` stream backed by an array reallocated on the fly, allowing you to use normal `stdio` functions to build the string. Read the manual for details.
For the next time: please do not delete your post after receiving an answer! That's a shitty thing to do because it removes any chance for future readers to learn something from your post. I do not help you just for you, I help you so every future reader can profit from my answer. You just deprived those readers from this resource.
&gt;For example, 1010 unsigned, which is 10 in decimal, would have A as its hexadecimal representation. 1010 signed would be -6 in decimal, so would that also have A as its hexadecimal representation or something different? It's interesting that you say "1010 unsigned" and "1010 signed", but not "0xA signed" or "0xA unsigned" :)
`1010` in binary is `A` in hex. Always. What that *represents* to you depends on your CPU and/or programming language and/or application logic. 
Eh, something fishy here. Are you using [this library](https://github.com/DaveGamble/cJSON)? I think you've got things mixed up a lot in your makefile :/ Simply including the .h and .c file would be sufficient, then include it in your build sequence. In its simplest form: gcc cjson.c main.c -o main or with a different include path: gcc -I./cjson/ cjson.c main.c The `-l` option you specified in the LDFLAGS requires a shared library (`libcjson.so`), but I don't see that library being built anywhere? Or was it built manually by you? Your include path is also specified as a CJSON_LIBDIR, which is a bit confusing IMO. Also, `LDFLAGS` is used for flags to `ld`. Libraries should be specified with the `LDLIBS`. Check [this page about Implicit Variables](https://www.gnu.org/software/make/manual/make.html#Implicit-Variables) for more information, it helped me out too. In any case, I don't have a solution, but I hope this somewhat helps. Maybe you can check my [Makefile](https://github.com/krpors/hx/blob/957707b2a1764e68020e7f4398b125b4dbe60ec7/Makefile) for inspiration or some help.
Yeah I think I've goofed up. So it turns out I was developing a system in c but using other libraries in c++. I based it all off a rgbmatrix library and once it was working I never got to clean the makefile and sort the actual program out. So essentially I've made it waaaay more work for myself haha I had other issues so I redownloaded the latest version of the library and things are falling into place. People of Reddit (including yourself) have pointed out key issues with it and it explains a lot haha so I thank you all I think now is the time for me to git branch off and fix what's going on. I also happens that I needed to compile the cjson library into an object file before the makefile can actually use it. 
Please put four blanks in front of every line of code so the code appears readable.
Done :)
What architecture are you compiling for? Note that x86 is a little endian architecture, which would explain the result you get. `fread()` reads bytes, it doesn't know the structure of the data you are reading and couldn't change any endianess even if it tried.
Thank you for your cooperation.
I'm compiling on x64
x86-64 is a variant of x86 and is a little-endian architecture, too.
The funny thing is that while doing that in C++ in a slightly different way (using classes) I actually need to change endianness, on the same machine.
Ehem... I believe you have confused little endian and big endian here. Little endian is if the least-significant byte is first, big endian is if the most significant byte is first. Your `u16toBigEndian` function actually interprets a and b in little endian, not big endian.
These toBigEndian() functions look like LilEndian to me, because the first byte is the LSB. They are doing exactly what LSB does with bytes in memory. Little-endian means the the first byte is the least significant byte.
No magic happens with C. If you ran your program on a big-endian machine, you would find the printf()s in wave/main.c printing the wrong values. The magic happens at the processor level during memory fetches. The WAV format is a little-endian format, which means a little-endian machine doesn't have to do any special conversion. On the other hand, many network protocols use network byte order, which is big-endian, so on a little-endian machine you need to call conversion functions -- htonl()/htons() for sending and ntohl()/ntohs() for receiving. Such functions would be optional on a big-endian machine, where they'd just be no-ops, but you'd use the functions anyway for portability. Your C++ version has a different pattern of access. If your C version were to use the same pattern of access and grab individual bytes of the WAV fields, then you'd be bypassing the processor magic and have to manipulate those bytes yourself.
*complement
 int pos = 0; pos += snprintf(buf-&gt;base + pos, buf-&gt;len - pos, "%s", foo); if (pos &lt; buf-&gt;len) pos += snprintf(buf-&gt;base + pos, buf-&gt;len - pos, "%s", bar); if (pos &lt; buf-&gt;len) pos += snprintf(buf-&gt;base + pos, buf-&gt;len - pos, "%s", baz); /* etc. */ if (pos &gt;= buf-&gt;len) pos = buf-&gt;len - 1; buf-&gt;base[pos] = '\0'; Those `if`s are required because `snprintf()` returns the number of characters it would have written if it could, not the number it actually wrote, so `pos` can overflow.
that makes sense, thank you. Though I guess I have a lot of code I need to change now.
Can you describe the problem? There is a warning, but it shouldn't change the behaviour. warning: passing argument 1 of ‘swap’ from incompatible pointer type [-Wincompatible-pointer-types] swap(&amp;array, elements); ^ note: expected ‘int *’ but argument is of type ‘int (*)[(sizetype)(elements)]’ void swap(int *ptr, int e); 
Here's the output of my code: http://prntscr.com/gvq9li I think the problem lies with the swap function, more specifically the swapping itself. I believe I'm swapping the array in the correct order, but I could be wrong.
&gt; if I were to put the array {1, 2, 3} , it would swap to {2, 3, 1} What output do you expect? What does it mean to "swap an array"?
I want it to swap 1,2,3 to 3,2,1
c++? lame 
No more, please. 
Your loop is swapping adjacent elements. Swapping 0 and 1. Then 1 and 2, then 2 and 3, etc. The net effect is to move the 1st element to the end. You want to swap the 1st element with the last, then the 2nd with the penultimate, etc.
The technique you are describing is termed 'reversing' an array, you might get better answers from using this term. Your code doesn't do what you want it to, what it does do is 'bubble' (look up bubble sort to get the gist of this term) the first element to the last element, leaving all in between elements in place. That's a good first step, but with this in mind, what can you do with the new first element in the array to get it to it's rightful position? (Hint: what did you do with the original first element, and where are you trying to get the original second element?) Also, compiler warning are there for a reason, pay attention to what it says...(Hint: when you declare an array with 10 elements: a[10] , what does the a on its own mean?) 
Your dynamic array approach seems like it would fit my use case quite well. Only there are only the len and base fields in uv_buf_t. How would I be able to keep track of the current capacity? One solution I can think of is make a byte buffer like yours and then just write a function that creates a uv_buf_t then sets its base to the custom byte buffer base and its len to the custom byte buffers len. Then free the custom byte buffer, write the uv_buf_t then free the uv_buf_t base and uv_buf_t in the write callback. Does that seem like an alright approach to you? 
Semicolons for loops of a single line add too much clutter.
Please excuse my late reply, /u/penguinworshipper, I don't know how I've missed your question, I'm still new to Reddit... I still haven't quite made it, I'm searching and applying, but I already got the ball rolling for 1 position and they will most probably send me a contact. My total time into the process is 1,5 months which is not much. My project is quite involved, but mainly because I developed it for myself. It also happens to be suited for a portfolio, but I think employers tend to be impressed by quantity, diversity and also devotion. I got asked about contributions to the Linux kernel. I think 3-4 small projects should give the impression of a polished portfolio. But my advise is also to radiate confidence. The most important thing is you've made the conscious decision.
So you want to procrastinate as those C++ and Python boy wasting valuable time watching lame conferences that could take at most 10 minutes reading... 
Actually just broke c++ compatibility today. Looking to support it again in the future purely for compatibility.
`pointer_struct-&gt;member` returns `member` from a pointer to a struct (`pointer_struct`). It is essentially `(*pointer_struct).member`. (Reference `pointer_struct` and get the member `member`) So to get the `head` pointer from your structure, you use `list-&gt;head`.
I don't understand the question. You need to read and then modify a pointer to the head node. You're given the struct that contains that pointer. So the problem is ... ? You should fix the broken formatting btw. You can escape the asterisks by putting backslashes before them, or mark up the problematic terms as `code` by surrounding them with backticks. And please don't put code in an image again; you can use a pastebin (e.g. [gist](https://gist.github.com/)) for that.
Why do these terrible tutorials always go over pattern printing?
Thanks for the quick response. So if that's the case how would i refer to or access the pointer to the next or previous of the current head node. Would it be list-&gt; next or head -&gt; next? 
Yeah sorry first time posting will do in the future. Thanks 
Woops!
What do you mean? If you've got an `List` (`struct listHead`), there is no "next" or "previous" node, just the first (member `head`) and the last node (member `tail`). If you've got an `Node` (`struct listNode`), you can access the next or the previous node by `mynode-&gt;next` or `mynode-&gt;previous`, where `mynode` is a pointer to a `Node` (eg. from `mylist-&gt;head`).
So essentially if I wanted to make new node as my head newNode -&gt; next = head
As the program you develop in your video is clearly written in C++ (and you don't even seem to be able to differentiate between C and C++), I have removed your video. C++ is off topic in this subreddit.
Depends what you have. Got `head`? Then why not use it? But got `list-&gt;head` instead? Why not use it? Try it out. Also please note you also have to change an another variable to change the head node. I'm letting you to figure it out.
Try `popen("ifconfig wlan0 list scan");`. It's a bit tricky to do this directly.
Exactly. Seeing as you're on reddit I'm sure you're all about procrastination too! Know of a good talk?
If the input is too long, `fgets()` won't have space to store the newline character. By checking if there is a newline character in the string `fgets()` read, you can check if the input was too long. Another method is to use `getline()` instead.
Please describe in much more detail what you are trying to achieve, 1 because I can't tell for sure what you are trying to accomplish 1 because if you can specify in exact detail what you want to do, you should easily be able to convert that into a C program. 
I work on a reversi project, i would like to create a list of moves that i will call later like "play A3" and move my stone on A3. A move needs to take 2 elements, the row (1-8) and the column (A-H). So i would like to know if is it possible to create a list with one row like list = {A1, A2, A3, ..., B1, B2, ...} ?
Nope, I just use Reddit to aid noobies or know some good libraries/projects as this one: https://www.reddit.com/r/C_Programming/comments/75a5uk/a_while_ago_i_posted_on_this_sub_about_my_c/
It does not cut off anything. It reads and extracts at most 39 characters from the stream, or until it finds a newline, whichever comes first. If there were more characters, they remain in the stream and will be read the next time any stream read operation is performed. As FUZxxl says, you can tell which terminating condition was the case by seeing if the newline was read and extracted from the stream. 
You forgot about your shitposting habbits.
Make your possible moves constants that are essentially just integers. Then you can easily create an array. Or you could make an array of structs if you want to represent more data
This isn't really trivial to do strictly in C, even if you have a moderate working knowledge. (As far as I know, would love for someone to show me something I've missed :) ).
Except it declutters it.
glib has hash tables and binary trees.
arr is 10 elements long. You're writing to elements 0, 10, 20, etc. "crashing" and "runs as expected" are 2 of the many possible consequences of undefined behaviour.
In chess it is common to use a bitboard. They work great since 64 squares is the size of an 64 bit processor word. uint64_t a0 = 1; uint64_t h7 = 1 &lt;&lt; 63; One sides pieces is just a bitwise or of all their pieces. uint64_t bdark_b = 1 &lt;&lt; 12; .... uint64_t black_bishops = bdark_b | blight_b;
so does this mean that I have to set my array to [100] to get it to run properly? I thought the [] refered to how many elements the array would hold. Also, I made an error. That should be the set up until 90, and (i =0;i&lt;100;i+=10), that is, run to less than 100 not less than or equal.
Since you want your array to hold 10 values then it should be 10 elements long. `arr[10]` is fine. The problem is arr[i] = i; This is setting the 11^th element to 10. But you want the 2^nd element to be 10. You could change your loop to go from 0 to 9 and do arr[i] = i*10 
Your function is declared and defined as taking 3 arguments. You must call it with 3 arguments.
Thank you 
Ok, I think I understand just by what you just said. I guess I have more then just that problem. This is a pre-written program for my C class and it has a built in self test written in python. My guess, the self test passes arguments to the program during the test. In fact, that is exactly what it does. ```printf("Test6:area_box:3,4,5:%f\n", area_box(3, 4, 5));``` In this case, I'm at a loss and will need to consult my professor on how she wants this written.
You could add your own function which takes no parameters, allows the user to input data, and then call area_box with those.
Maybe libcurl can help in this regard? As others have said, this isn't a simple task. I barely have any knowledge of BSD sockets but maybe that's where you could start looking?
If your environment is Windows you'll want to look over this: https://msdn.microsoft.com/en-us/library/windows/desktop/aa816369%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396 linux... the NetworkManager approach mentioned here might work if it's available https://stackoverflow.com/questions/8434918/find-available-network-interfaces-in-c-c or dig through the wicd source and find an example: http://wicd.sourceforge.net/development.php
Have another look inside your do loop. Is the sum variable necessary at all? 
Your suggestion is a strict aliasing violation (`uint16_t` lvalue can not be used to access an array of chars, in Standard C++) 
You should be comparing num to your max and min...not sum. That way you’re always comparing the current value to whatever the current max/min is. By the time the loop is done it will hold the correct value of max/min
Do you mean you want to reverse the order?
I guess not since it still gave the same output, I removed it.
Yes I removed it but I still get the wrong output, I updated the post.
still wasting time dont ya boy? well, there is some things one cant unlearn... lame! 
do { if(num &gt; max) { max = num; } if(num &lt; min) { min = num; } count++; }while(count &lt; 15); 
You Genius! :0 Thank you so much I can finally go to sleep in peace.
If you don't mind, could you tell me what was the mistake you saw in my code? 
Go through your code manually. What happens to the variable `min` when the first number you entered is, say, 0?
Looks like it.
&gt; [If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.](https://stackoverflow.com/questions/6400637/whats-the-standard-definition-of-printf-in-c)
Thank you
When you compile your programe you should be getting lots of errors/warnings about undeclared variables and type mismatches. Start by trying to understand and fix them. Also, it looks like you're redefining `malloc`? 
Jesus didn't die for our sins so we could just post code without indentation.
Yes I'm making a memory allocator. I compile with all flags going off so that's not an issue. I am just giving as a simple example of what I'm doing to make the reading easier for everyone trying to help. There's a lot more in the code and this is definitely not my base code or naming convention but this demonstrates perfectly what's happening in a method I made for splitting large blocks because this is similar to what I'm doing in my code before this error. I have two pointers, one im using that will be modified to change free list location, since the original value is now pointing to a value I malloced, and now I need to adjust the head value to the head of the remaining free block. Then I have another ptr with the base address of the start of the head/block to return to user. For some reason when I reassign the new head into the free list, it also changes the values in the malloced variable. 
Happy to help! Also: &gt; I needed to compile the cjson library into an object file before the makefile can actually use it. I can only say that it's very helpful to read up on how Make actually works. I don't know everything either, but a more in depth view explains things a lot. This also applied to those Implicit Rules I linked earlier: you don't write the whole cruft, but instead you define: 1. `CPPFLAGS` - C Pre Processor flags 1. `CFLAGS` - the flags passed to the compiler (`cc`) 1. `LDFLAGS`- flags passed to the linker 1. `LDLIBS` - libraries (`libxxx.so`), like `-lxxx` In my own previously linked Makefile, it only has this target which builds the binary: objects := hx.o editor.o charbuf.o util.o undo.o hx: $(objects) Thanks to the implicit rules, it will run: $(CC) -c $(CFLAGS) $(CPPFLAGS) for every `.o` file dependency, and then the linker runs to link all `.o` files together: $(CC) $(LDFLAGS) $(objects) -o hx So it's a bit of magic, but it prevents a lot of boilerplate in a Makefile.
&gt; I compile with all flags going off so that's not an issue. I'm not sure what you mean by "all flags going off." Here's a couple of problems the compiler should be complaining about: Your code uses a variable named `header` in several spots. You never declare a variable named `header`. There is a `typedef` defining header, but no variable. header *headPtr = free_list.head; Here you assign a struct to a struct*. This is a type mismatch. I'm confused as to how this code compiles, let alone runs. Perhaps you are not posting the version you're actually compiling? 
While it’s true that it’s undefined behavior, I would assume in this instance that it’s just reading garbage from the stack, where the parameters should be.
The `wireless-tools`package contains source code for `iwlist` and friends for Linux: https://hewlettpackard.github.io/wireless-tools/Tools.html . It's not really trivial code, but it may help you out.
&gt; How would I be able to keep track of the current capacity? My `charbuf` has a `contents` (the actual contents), `len` (the current amount of bytes) and `cap` (capacity - when len &gt; cap the array is resized) member. You could use those member to adjust your `uv_buf_t` like you said. You can also reimplement the `charbuf` to make it applicable for the `uv_buf_t` of course (unless you can't change `uv_buf_t` to contain an extra `cap` member).
Cool videos there mate. What's the name of the terminal emulator you're using in them?
That depends on the calling convention. For example, on amd64 Linux, the first few arguments are drawn from registers instead.
Use the `open_memstream` approach I mentioned. The `FILE *` abstraction keeps track of these details for you.
It is usually better for compilers and readability to use for loops instead of whiles where you know the number of iterations in advance.
 header *headPtr = free_list.head; ........ free_list.head = *header; //THIS IS WHERE MY ERROR OCCURS One of these is not like the other. You don't need to dereference 'header' here. free_list.head = header; // YOUR COMPILER SHOULD TELL YOU THIS
Where are you stuck?
we havent studied about arrays and i pull variant 26 out of all project which is about arrays.
That sucks. Reading a tutorial on arrays is a good start, arrays aren't very difficult.
thanks everyone your watching this video 
serialization?
No that is not what I am looking for. Thanks for taking a shot at it.
This is a forum in English. Content in Hindi is generally off topic. I recommend to stop posting these videos, this kind of content has never been received well in this subreddit.
buy a zentri board and do it over serial. :D
There's a missing trailing curly brace before the while() statement. You have the else if followed by an opening brace {, and then the closing brace you must've thought was for both the else if and the do while.. 
I drive it somewhere else, this isn't the full code. But I did man's a mistake you are right, anything that said best I changed to headPtr. No this isn't this is a fake program I made some typing this up,. There are no flags going off because im coming with - Wall. 
It should have said headPtr sorry
How? It's unnecessary.
[removed]
Why are you making a 1 bit bit field out of a 64 bit int instead of a bool? just curious.
Good point! That always trips me up 
Here's the pseudo for you, just turn it into tcode now. Good luck! 1. count number of evens in original array 2. keep track of min as you're counting evens 3. allocate enough memory for evens elements 4. copy over elements and sort or copy elements in ascending order 5. loop through array and printf element
If you need help, you should post your full code. The problem may not be where you think it is, and we can't just guess about everything else. Either create a working program that exhibits the same behavior, or share more of the code.
What is your code exactly, because that code won’t even compile.
So there’s no actual telling because of the way this was asked, but one thing you can often do is, if you’re splitting strings at position `i`: char c = array[i]; array[i] = '\0'; puts(array); array[i] = c; puts(array + i);
`strtoull()`
Hah! Thanks! Didn't even know that existed. I would have expected it to be listed somewhere in the man page for strtoll. Guess not!
Well yeah none of the variables are initialized. I don't have that code anymore as I've changed it since then. Just wrote some pseudo code to demonstrate where I was starting at. The char array has 600 characters in it after every 40 characters it will start printing to a new line. 
The char array has 600 characters in it. After every 40 characters a new line will start to be printed, which will have 40 characters in that line and so on until the end of the array is reached. That's the only way I can explain it. 
Being pedantic... A `uint64_t` and an `unsigned long long` can be different types and sizes. The most portable approach is using the appropriate macro from [&lt;inttypes.h&gt;(http://en.cppreference.com/w/c/types/integer) with sscanf(). if (sscanf(mystr, "%" SCNx64, &amp;mynum) != 1) { // Couldn't convert the string! }
If you have a for loop that does something with each character in turn, modulo (%) will be very useful for doing something else every X times through the loop.
You've had your question answered (i.e. use `strtoull()`) but I find it's usually educational or interesting to read the source for such common utility routines to see how the OS/lib gurus coded it. Here one way to implement `strtoull`: unsigned long long strtoull(nptr, endptr, base) const char *nptr; char **endptr; register int base; { register const char *s = nptr; register unsigned long long acc; register unsigned char c; register unsigned long long qbase, cutoff; register int neg, any, cutlim; /* * See strtoq for comments as to the logic used. */ s = nptr; do { c = *s++; } while (isspace(c)); if (c == '-') { neg = 1; c = *s++; } else { neg = 0; if (c == '+') c = *s++; } if ((base == 0 || base == 16) &amp;&amp; c == '0' &amp;&amp; (*s == 'x' || *s == 'X')) { c = s[1]; s += 2; base = 16; } if (base == 0) base = c == '0' ? 8 : 10; qbase = (unsigned)base; cutoff = (unsigned long long)ULLONG_MAX / qbase; cutlim = (unsigned long long)ULLONG_MAX % qbase; for (acc = 0, any = 0;; c = *s++) { if (!isascii(c)) break; if (isdigit(c)) c -= '0'; else if (isalpha(c)) c -= isupper(c) ? 'A' - 10 : 'a' - 10; else break; if (c &gt;= base) break; if (any &lt; 0 || acc &gt; cutoff || (acc == cutoff &amp;&amp; c &gt; cutlim)) any = -1; else { any = 1; acc *= qbase; acc += c; } } if (any &lt; 0) { acc = ULLONG_MAX; errno = ERANGE; } else if (neg) acc = -acc; if (endptr != 0) *endptr = (char *)(any ? s - 1 : nptr); return (acc); } [[Source]](https://opensource.apple.com/source/Libc/Libc-262/stdlib/strtoull.c.auto.html).
If it’s guaranteed to have 600 chars in it, then you can just bump `i` up in increments of 40 and do `fwrite(array + i, 40, 1, stdout)` followed by `putchar('\n')`, or `printf("%.40s\n", array + i)`.
I don't know if I'd use that as a good example... Haven't seen a pre-c89 function definition like that in many years.
Thanks for this. I agree with you and will change my code to use this method of conversion.
`strtoul` is mentioned on the `strtol` and `strtoll` page on my system, from there it's not a long shot :-) NAME strtol, strtoll, strtoq - convert a string to a long integer SEE ALSO atof(3), atoi(3), atol(3), strtod(3), strtoul(3) COLOPHON This page is part of release 4.09 of the Linux man-pages project.
So I tried what you posted: for (i = 0; i&lt;=39; i++){ fwrite(origintext + i, 40, 1, stdout); printf("%.40c\n", origintext + i); } When it printed each line moved over one char, and added a random symbol at the end of each line. [like this](https://imgur.com/a/4kUDA) What needs to happen is that after characters 0-39 are displayed on the first line, line 2 will display characters 40 through 79 and so on until the end.
Unfortunately this is unreliable. If the input is too large to fit in a `uint64_t` then the behavior is undefined (7.19.6.2-10). On the other hand `unsigned long long` is guaranteed to be large enough to store a `uint64_t`, so `strtoull()` is sufficient, as is `strtoumax()`. Though to be absolutely portable you'd have to compare the result against `UINT64_MAX` to make sure the second conversion doesn't overflow.
I’m seeing a lot of weird stuff here. You have to be extraordinarily careful about not breaking aliasing/pointer rules here—this is something that bit even the GNU guys in the ass a while back. You can’t just add pointers and expect it to work, because you’re working outside the bounds of whatever the compiler considers an “object” until/unless you return from `malloc`. (Pointers are not the same as their numeric value, from standards/compiler standpoint.) This means the compiler is pretty much allowed to come up with whatever (possibly bogus or trap-represented) pointers it wants as a result. You’ll need to incorporate `uintptr_t` (not `char *`!) into your size/alignment/limit calculations or `volatile` up a buncha stuff that shouldn’t be `volatile`d to prevent the compiler from optimizing. E.g., the compiler’s within its rights to give you garbage from `(ptr + headPtr-&gt;block_size - 8)` both because of the possibility of overflow near the end of the addx space and because of the involvement of actual pointers in this. By the time you get down to `free_list.head =` anything, there’s no telling what pointer the compiler will decide to produce, and any diagnosis you get on this will be a guess at best. Another thing: You reallyreally shouldn’t be just using literal 8s and 16s andsoforth in reference to anything here. Without reference to a specific ABI (sometimes not even then) you have no idea how big a header/footer actually is, how big a pointer is, what the minimum alignment is, etc. etc. The C standards give you very little to work with in terms of hard architectural details, *especially* when it comes to the implementation of bitfields, where sometimes even within the same formal ABI you’ll have compilers disagreeing on layout. Also, `uint64_t` isn’t guaranteed to exist, and you’re using it on bitfield types of all things, even though none of your bitfields is more than 30 bits (i.e., within the guaranteed span of an `unsigned long`), and of course there’s zero guarantee that bitfields will actually pack so you should probably either throw the biggest ones up top or set them so that if they *are* packed, they’re aligned with the bottom portions of power-of-two-aligned fields. Bitfields probably aren’t worth the trouble for something like this, especially for stuff like this where you’re just using them as aligned values + flags. Put the full `uintptr_t` or whatever in the `struct` and make flag/mask `#define`s; it’s awful, but it’s worked since time immemorial and it’s frequently necessary for innards like `malloc`.
You’re incrementing `i` by one. You need to increment it by 40, like I said.
Ahh right thanks for the tips. Could you clear something up for me though cause i think i'm getting confused? In C, you put *using cJSON* but in C++ you use *using namespace cJSON*? I'm getting very muddled up with what's c code and what's c++ haha
Maybe you have a big un-initialized array and you are going out of the scope where it was set (although) the array size could be within limit. If you need to split the array at certain indices and add the new line char to array then you could create a bigger array and insert the new line char. I don't know why you don't want to use string printing. int N = strlen(arrary); int k = 0; char[] newarr = new char[N*2]; for (int i = 0; i &lt; N; i++) { if (i % 40 == 0) { newarr[k++] = '\n'; } newarr[k++] = array[i]; } printf("%s", newarr); If you just want to print without any other processing, you even don't need the new array int main() { int N = strlen(arrary); int k = 0; for (int i = 0; i &lt; N; i++) { if (i % 40 == 0) printf("\n"); printf("%c", array[i]); } printf("\n"); } 
Huh. Good to know.
No, the `using` keyword is C++ only. C is a very small language, with not many keywords or constructs. If you check out C++, you'll start to notice there's a heap of cruft added which is certainly not in C. In that regard, those two languages are vastly different (therefore, I truly hate the conjunction "C/C++" I frequently see). In C++ you have namespaces, which are pretty much equivalent to Java's packages. In C, you don't have this, so people usually prefix functions, e.g. * `cJSON_CreateRaw()`, `cJSON_CreateNumber()` * `SDL_Init()`, `SDL_GetDisplayDPI()` * `glMatrixMode()`, `glBegin()`, `glEnd()` That way it's easier to determine what function you're using from what library.
Right okay, thanks. I'm quite new to C and this program i'm building has started to become quite large so i've spent a long time trying to break it out. Pain in the ass haha So let me see if i understand, so in C, if you want to break other static functions into different files and access them from other files, you have to include them as a header file at the top using #include "../include/Helper.h" then use int i = Helper::GetRandomNumber(); to actually hit the static function from the file?
Ha, yeah I hear you. We would *not* write it that way today! Yet knowing that the code of standard libraries we do still rely on today (BSD/MacOS in the above case) were coded like that is instructive IMO. Because of C's dominance in OS and library and embedded systems for 40+ years ... I think C programmers (more than most) should be comfortable with seeing stuff like this. :-)
To be honest I sorta like that definition style, especially if your function takes lots of parameters.
Because the requirement is not using string functions. I would use them normally, but not being able to use them is what threw me off. I ended up getting it to work though. 
Note that `open_memstream` is a POSIX function and may not be available on Windows. There is some discussion of alternatives [here on Stackoverflow](https://stackoverflow.com/questions/10305095/can-i-replace-a-call-to-open-memstream-with-a-malloc-and-an-implicit-cast#10341073).
Modern C by Jens Gustedt, He's French so his english isn't perfect, and you may struggle with that a bit more than native speakers, but it's free, and very, very in depth. http://icube-icps.unistra.fr/index.php/File:ModernC.pdf 
Sure, but the modern C version looks like this which has all the readability benefit but less typing/redundancy. Old: (as above) &gt; unsigned long long strtoull(nptr, endptr, base) &gt; const char *nptr; &gt; char **endptr; &gt; register int base; &gt; { ... New: &gt; unsigned long long strtoull( &gt; const char *nptr, &gt; char **endptr, &gt; register int base) { ... Good, either way. :-)
Can you use `getc()` or `getchar()`? Then you can read until you reach your limit or see `\n` which is the Enter key being pressed.
yes.. a single space in the format specifier matches all whitespace.
So would that work?
should.. but make sure to throw '\n' on the end of your format to consume the newline.
The second one won't even compile. But, to answer your question. The first loop accesses the elements in memory sequentially, so, in principle, it should make better use of the cache. If this is not clear to you, you should look into how arrays are [laid out](https://en.wikipedia.org/wiki/Array_data_structure#Compact_layouts) in memory use of memory and note that C uses "row major order."
Looks like you have a good start. In the end, you'll need to allow the user to enter m and n, but using your values will help you figure out the logic. I would start by just doing the steps manually, no loops or conditions. Then think about how you would explain those a steps to someone. You're likely to use phrases like "I'm pouring from this to that because..." and "I can stop because...". Those explanations become your if and looping (`for`, `while`, etc) constructs. If you're not comfortable yet with loops and conditions, you might consider a side task to get a better understanding. Something like adding numbers and getting their average, stopping if the average is in a range. 
&gt; to answer your question. The first loop accesses the elements in memory sequentially, so, in principle, it should make better use of the cache. fixed it
very good
Yes
Does the job but looks slightly less pleasant. That said, it is less redundant.
How is this related to programming in C?
And in MacOS: `popen("/System/Library/PrivateFrameworks/Apple80211.framework/Resources/airport -s");`
Oh, this is kinda disappointing. It would be kinda cool if there'd just be an error converting...
Not to be blunt or anything, but a book can probably explain it far better than I do - if you want to get more proficient I recommend [C Programming: A modern approach](http://www.knking.com/books/c2/index.html). I used that book this year too to crank up my knowledge. Anyway: a header file is (**USUALLY!**) just the specification of the interface: function declarations, struct declarations, enums. No implementation! Very much like a `public interface Node` in Java for instance. A C file (or multiple... if you're insane) can actually implement these functions. In another `.c` file, you can then `#include` the header like you said... but the compiler still needs to find the actual implementation! That is done through the linker: it finds the `.o` file or `libbla.so` or whatever file, containing the implementation of the declarations. This is the reason you can just do `#include &lt;stdio.h&gt;`: this file just contains declarations. The implementation is in `libc.so`. Example: if you use a `#include &lt;SDL/SDL.h&gt;`, with a function call `SDL_Bleh();`, and JUST COMPILE, it will probably work since the headers are installed in the default, system wide include path. HOWEVER, when you want to make an executable out of it, the linker is attempting to find the implementation of `SDL_Bleh()`. Then it will fail with something like: main.c: undefined reference to `SDL_Bleh()` This is a hint that it can't find any actual implementation. This is where the `-l` flag helps out with GCC. Furthermore, the syntax `Helper::GetRandomNumber()` is C++: `Helper` is the namespace, and `GetRandomNumber()` exists in that namespace. So that will not work in C.
In this case, OP could just build his own abstraction.
These should help you start // array declaration // type identifier[elementCount]; int intArray[100]; // setting value in the array // array[index] = value; intArray[0] = 1; intArray[3] = 1; // reading value from the array // value = array[index] int first = intArray[0]; C arrays are *0-index based*, meaning the first element is at index 0 for the rest: * [scanf](https://linux.die.net/man/3/scanf) (check the return value ) * [qsort](https://linux.die.net/man/3/qsort) 
Yeah to be honest I think you are right, I think I'll probably just sit down and properly go over how make files and header files work. Might be a bit easier to get it to work properly. I've been pulling my testicles off trying to figure out why it's not working haha Out of curiosity, what ide do you use? Cause I'm having trouble with eclipse throwing massive warnings all over the place 
Yeah, just "jumping in" and expecting things to work out can be a difficult approach :) For my everyday Java cruft I use IntelliJ IDEA. For almost everything else I use vim. It really helped me out into figuring out how C, GCC and make actually work together. An IDE tends to try to shield you away from details, and I don't really like that 'magic' when I'm not sure what the hell it's doing.
If you know for certain that this is a Hex string, than it might be faster to build your own parsing function. Here is an adaptation of code I used in a JSON parser I wrote (it could be optimized further, either using two maps or switching the map to use bit flags): #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; static const uint8_t is_hex[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0, 0, 0, 11, 12, 13, 14, 15, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 13, 14, 15, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; static inline uint64_t hex2i(const char *s) { uint64_t val = 0; if (s == NULL || s[0] == 0) return 0; if (s[1] == 'x') s += 2; else if (*s == 'x') s++; while (is_hex[*s]) val = (val &lt;&lt; 4) | (is_hex[*(s++)] - 1); return val; } /* testing? */ int main(void) { printf("test for 0xff: %llu\n", hex2i("0xff")); return 0; } 
The answer really depends on the hardware and the nature of “`whatever`.” If `whatever` takes enough time, then that’s what will dominate performance and the access pattern won’t much matter. Otherwise, since M/N are on the order of 1000, you’re looking at a total array size of 8 MiB, which *may* fit in some L2 or L3 caches, and which would fit in a handful of pages (2–4 big pages, if you’re using them), so cache effects will dominate. The first loop will probably run faster because adjacent iterations write to adjacent chunks of memory, reusing prior cache lines in most cases. Some architectures may be able to do nontemporal writes on the second loop, which will prevent unpleasant side-effects of normal writes—normal procedure is to load the cache line, alter it, and then eventually discard it, but nontemporal writes may be able to skip the load and discard. Some architectures will detect the strided access in the second loop and prefetch cache lines, which would help if `whatever` is hefty enough. If the target supports SIMD instructions, the first loop is probably more vectorizable, raising the peak performance to `sizeof(vector)/sizeof(double)`× that of the second. The second loop would require scattering and/or streaming, which aren’t always supported. If `whatever` isn’t readily vectorized, SIMD won’t factor in. If you’re just doing a simple fill (i.e., `whatever` is at most some function of `i` and `j`), the two loops are equivalent, and an optimizing compiler *should* be able to detect that and invert the second loop, in which case the performance should be roughly the same. If you’re doing a mostly-/single-value fill, it’s a glorified `memset` and many architectures (incl. x86) have optimized ways of doing that beyond just using stores in a loop.
What's wrong with the second one?
[Don’t return −1 from `main`, or `exit(-1)`.](https://www.reddit.com/r/C_Programming/comments/74p166/why_does_my_code_segfault/do05mh5/)
They just said. The second one access locations in memory that are not sequential which may have implications on the cache.
That won't affect how it compiles.
Yeah, because cache is runtime problems and the compiler doesn't care about that. So again, why does OP' say the second one won't compile?
Oh snap sorry I misread. I have no idea why they are claiming it won’t compile!
The second one, when I originally read it, had i's and j's mixed up in places. I assume you edited it to fix it?
What you lack in GPA you must make up for in relevant experience (projects, work)
Experience. It's a terrible catch 22; I hated being on the candidate side of it and now I hate being on the company side. There are (probably) perfectly good candidates we won't consider because this would be their first job, and as a small company we literally can't afford to hire someone who turns out to be incompetent or lacking in the basics. Of course this is different for someone like Amazon/Google who can afford to make mistakes like that, but they still don't *want* to take chances. Schooling &amp; internships are a good fallback if you don't have experience. A non CS/Engineering major means you should have some significant personal projects to show you're solid on your CS basics. You're a complete and total stranger to me as an candidate. If you have a business major (even with the cyber security minor, which varies wildly in it's technicality from program to program) how do I, as an employer, know you've ever written a single line of code if you can't show me some projects? Having a computer related major shows an employeer you've mastered some fundamentals. Although you learn most of what you need on the job, you can't learn on the job until you have the basics down. I'm not usually concerned with GPA so long as it's not abysmal (like a 2.1 or something) which tells me you barely passed most classes and may not be suited for what you're trying to do. I wasn't a straight A student myself, so I'm certainly never going to expect someone else to be. 
Okay this is an awesome response thanks a lot! I definitely have tons of labwork but I could probably do something creative to show someone, thanks again!
What about those of us that are self taught
Riiiiigiht, i've finally figured out what was wrong with it. So it turns out my makefile was okay and all my headers were also fine. The problem was as follows... One of the header files had a slightly changed function that was looking for a standard char in the arguments, but the one that was included in my header had exactly the same...BUUUT it was looking for a *const char* instead. This completely threw me off as it didn't look much different but it was. Once i fixed this everything was good. Euurghh what a pain. Finally got things functional now! Thanks for the help Reddit people, appreciate it.
Nice write-up. Good to know devs still try to optimize their code.
Yes, this is true, I'm in this boat just now. Coming from enterprise Java and trying to switch to embedded programming. I actually have a lot of C/C++ and ASM experience, but no professional one. So I fear my resume is immediately discarded, although I am 100% sure I can become fully functional with employer's tasks in a matter of days. But it's important not to give up.
We need to address a few things related to reading in strings. I don't think this is causing your problem, but I thought I'd bring it up anyway. Your goal is to read in a string of 6 characters, but don't forget you need storage for one more character, the null terminator: char str[7]; This next part is confusing for beginners, but you *don't* want the `&amp;` when reading in a string with `scanf`. The reason is strings are arrays, and arrays decay into pointers, so no address is needed: scanf("%s", str); Now, there's still a problem. If the user types in *more* than 6 characters, where's it going to be stored? So we have to restrict `scanf` from doing this in some way. This is how: scanf("%6s", str); Ok, now we're guaranteed that `str` will only have 6 characters or less, and be null terminated properly. You can check that the user didn't enter in *less* than 6 characters with `strlen`, but how do you know if they entered *more*? Well, we have to see what the next character is: char ch; scanf("%6s%c", str, &amp;c); If `ch` is `'\n'`, then the user entered 6 characters or less. But if it isn't, now there's garbage left in the buffer. We don't want that to be the next thing to be read in instead of the user's input. Some people will tell you to do `fflush(stdin);` ... but that's not portable. The correct magical line of code is: while((ch = getchar()) != '\n' &amp;&amp; ch != EOF); Basically, clear everything until the `'\n'` at the end of the input. Yeah ... getting a string from the user without overwriting memory is *hard*. Alternatively: just declare `char str[256];` and hope the user doesn't try entering anything larger than 256 characters. Honestly, that's what most programmers end up doing (and then I have to fix the problem later.) -------------- Ok, so now we have correct user input. We still need to look at the logic for how you're detecting the pattern. You're comparing the character at `pntr` to the character at `lStr-pntr-1`. If we make a table, this is what that does: 0 | 5 1 | 4 2 | 3 3 | 2 4 | 1 5 | 0 This suggests you're looking for the pattern `abccba`. There's also how you're breaking out of the loop: right now you quit when any single pair *matches*, so you never actually compare any others. This, combined with the above, results in the behavior you reported. I would rewrite that loop so it instead compares `pntr` to `pntr+2` (two characters later) and makes sure they're the same. If any aren't, you can `break` out of the loop immediately. Be sure to alter the loop bounds so you don't go beyond the length of the string (though the null terminator will help you there, every string will fail if you don't do this).
Yeah definitely! Are you looking specifically to develop in C or are you looking for other programming jobs, as well?
Nothing wrong with that. One of the best people I've ever worked with is mostly self taught. You'll need to have a more impressive personal portfolio, though. Without a degree the only thing I have to gauge you is what you've done on your own. Anyone can apply as a "self-taught" programmer without showing anything and if you bomb the interview then we've both wasted half a day. Even if you do well on the interview what guarantee do I have that you didn't just get lucky (i.e. worked with those problems recently, read an interview question book, etc.)? I'm not trying to be cynical but a business has to act like a business and make safe(er) decisions. Between two equally qualified candidates the only difference being one has a related degree I'm going to take that one because economically speaking it's a lower risk. 
Yeah tenacity is a valuable trait when job hunting.
I'm really open to anything, I may even do a masters degree, I like programming but don't know if I'll wanna do it for a career, I might though
You have to use recv and send instead of read and write iirc, but Winsock generally supports the posix socket api...
I've interviewed a lot of people in exactly your position: an initial undergraduate education in some non-engineering, non-CS field, then an abrupt switch to cybersecurity. There are basically two things I'm looking for from a resume and interview: 1. Actual technical chops. A lot of these cybersecurity degrees are just glorified IT degrees that, at some point, gave the student a brief tutorial in Wireshark. You have to prove that you're more than this. For cybersecurity, I want a candidate that knows how things actually work, with a strong grasp of the fundamentals: protocols, operating systems, networking, encryption, etc. To stand out from your peers, this means spending lots of time learning and practicing outside the classroom (which also builds up a portfolio). Most of your competition doesn't learn beyond the classroom, so this is a relatively easy way to stand out. 2. Honesty. Lots of people lie about and exaggerate their skills on their resume. If I'm even slightly familiar with the skill in question then it's quick and easy to spot the liars. This is the quickest way to eliminate any chances you had. Being honest about not knowing something will get you further than pretending that you do. Unfortunately for an entry level position, your GPA is going to be a major barrier, particularly for larger employers. Once you've got your foot in the door and have built up some experience, then your GPA won't matter much. Until then, lots of HR drones are going to automatically toss your resume due to the GPA bring below a policy-set threshold before any technical folks would even get a chance to veto that decision.
What do you think is the cutoff for GPA? I've been asking around about this quite a bit lately. I'm a 5th year computer engineering undergrad with a 2.7, and even though I have 4 graduate level classes and a couple internships, it seems like I'm still getting turned down left and right from various companies. I only ask because I still have another semester and a half, so I want to be able to poll professionals who know about this and set a goal for myself by the time I graduate.
man this is awesome, thanks for your input, it's great to see this kind of thing from your perspective
Does libuv offer networking? I know that lib was intended to bridge the *nix/Windows divide for Node.js.
It's really arbitrary and I can't give you a solid answer. I'd say I wouldn't even look at anything below a 2.5 unless you had something else really good going on. Any chance your in-major GPA is better? For reasons that'd take a long time to explain I was on the tightest schedule possible to graduate in 4 years. This meant a lot of engineering classes every semester. I poured all my effort into them and would consistently blow off non-major electives and required classes. They sucked my GPA down to like a 2.9. However since I focused on my CSE classes, my GPA there was a 3.2. So on my resume I'd list "Major GPA: 3.2". Just be honest when people ask about it, and they will. It'll often help you get past any automatic parsers that are looking for a GPA field and tossing them before they even get to a recruiter. 
I want to see the source code of projects you wrote. I want to see well designed, well commented projects that are mostly free of bugs. I want to see that you care about quality in all programs you write and that you understand the problems you solve in your programs.
You need an actual parser, not just a `strtok` invocation. The book “lex and yacc” (O'Reilly) or its updated version “flex and bison” is a good start.
It probably does, but it uses the MIT license which requires its notice to be included with the binary. If it wasn't for that libuv might be a good option.
&gt; while((ch = getchar()) != '\n' &amp;&amp; ch != EOF); Sorry for my noob questions, and I'm very grateful for your response, if I can make a couple of questions, where exactly I would have to put that while, and after modifying the for loop and the if it always give me KO for(pntr=0 ;pntr &lt; lStr ;pntr++){ if (str[pntr] != str[pntr+2]){ flag = 1; break; } } 
The goal of that line is to clear any extra characters the user may have entered. So you only want it to happen if the user entered more than 6 characters (meaning the length of `str` is 6 and `ch` is `'\n'`), and you want to do it before doing the `scanf` to request more input. As for why it's still failing, see what I already wrote: &gt; Be sure to alter the loop bounds so you don't go beyond the length of the string (though the null terminator will help you there, every string will fail if you don't do this).
I'm not sure what you mean by an "actual" parser? What would be the difference ?
A lexer/parser combination as implemented by lex and yacc does two things for you: * recognize tokens in the input * understand the structure these tokens form For example, the lexer picks up that the token in `ls &gt; foo.txt` are `ls`, `&gt;`, and `foo.txt` while the parser picks up that `&gt;` and `foo.txt` form a redirection clause. Explaining how this works is too complicated for the scope of this project, but it's an extremely useful concept.
I've got like half a dozen projects on my github, my problem is i apply to the wrong places or something, because i've only had 1 phone interview and it was for a contractor, where should i be focusing on where i apply to? Are there any job sites more specific to this?
Why not just put the license notice in your source code? How much can it hurt?
Pretty cool! However, isn't this a bit overkill for typical predicates found in the real world?
Probably! I should try some benchmarks with real-world `find` commands from other projects. I suspect that the only one that makes any real difference is the cost-based optimizer, since it may save you some I/O. The rest of them are admittedly for fun. One thing other optimizations could enable is helpful warnings for common mistakes, e.g.: $ bfs -print -name '*.txt' warning: -name *.txt is ignored; did you mean -name *.txt -print? $ bfs -type f -type d -type l -print warning: -type d is always false here; did you mean -type f -o -type d? or something. Haven't gotten around to implementing that yet though.
You can do your own tokenizing/etc. pretty easily. Come up with an enumeration of token types (easiest to build a macro table with type and text all in one place for non-variadic types), come up with a function to piece them out from some `FILE *input` with `fgetc` and `ungetc`, come up with some ways to buffer and make lists of tokens, and come up with a [recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser).
**Recursive descent parser** In computer science, a recursive descent parser is a kind of top-down parser built from a set of mutually recursive procedures (or a non-recursive equivalent) where each such procedure usually implements one of the productions of the grammar. Thus the structure of the resulting program closely mirrors that of the grammar it recognizes. A predictive parser is a recursive descent parser that does not require backtracking. Predictive parsing is possible only for the class of LL(k) grammars, which are the context-free grammars for which there exists some positive integer k that allows a recursive descent parser to decide which production to use by examining only the next k tokens of input. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Especially in your position I'd recommend staying open to relocation and not limiting your search to one specific area. If you're already applying all across the country (I've just assumed you're in the US here, I am and my advice may vary in its usefulness outside the country) then keep doing so. Something that helped me was to dig deeper past the generic "apply here" pages on company sites. Those applications are often fed through a parser (which could throw away your resume for any variety of reasons before it's even seen by human eyes) and then they're given to on overworked, stressed-out, tired, overly caffeinated recruiter who's paging through hundreds of these things. Your resume is the 83rd application they've looked at that day and it doesn't stand out in a meaningful way so it goes in the wastebin, before a developer even has a chance to look at your github. You probably see a theme here. You can often cut out the middlemen by applying through other channels. Apply to that generic application portal. Then go on LinkedIn. Find someone (preferably higher up) in the engineering or recruiting department. Message them directly on LinkedIn. "Hey &lt;X&gt; I'm very interested in &lt;Company&gt; and while I applied formally through the site, I always like to get in direct contact with someone, if possible. &lt;Insert something personalized about why they're interesting to you.&gt; If you have any more resources on job details, I'd love to hear about them." etc... This shows you're genuinely interested, you've taken the initiative to research the company, and now someone who has the power to veto all the walls that might otherwise block you is at least aware of your name. Another good trick is that many recruiters have an email like johndoe@company.name. You can email them directly and BCC jdoe@company.name, j.doe@company.name, johnd@company.name, etc... One of them is likely to hit and then you've got a direct line of communication open. I'd stick to smaller companies for the time being. Once you get something that sticks put a lot of effort in and work hard. Then you'll have a year or two of experience on your resume and hopefully a good recommendation if you ever need one. Good luck!
This is very helpful, thank you. I'm a computer engineering student and I'll be honest I feel quite unremarkable because I have no coding or programming experience from before college and I'm feeling a bit behind everyone as of right now. I'm still learning the basics of my first language (C++) as a second year student, so I try to look for ways to beef up my resume and things I can do that will make up for my sort of false start.
Just curious, how are you gonna get into a master's program if you have a shit gpa? My school had minimum gpa requirements, I genuinely don't know the standards at other schools. Also I would never recommend getting a master's in CS. Seems like most people I've talked to (certainly not everyone but more people than not) now think of it as a waste of their time and money.
This sub is for C, not C++. /r/cpp_questions is a much better place for a post like this.
Thank you, I searched for a thread dedicated to C++ but only found this one
No problem, it's a common mistake. I should also mention /r/learnprogramming, which takes learners of all languages.
bjarne`s books are way better than those two. Programming -- Principles and Practice Using C++ (Second Edition) http://www.informit.com/store/programming-principles-and-practice-using-c-plus-plus-9780321992789?ranMID=24808 
I have removed this post because it asks a C++ question. As /u/boredcircuits said, this is a subreddit about C, not C++.
The warnings are definitely cool!
Not sure what you actually need help with, but 0\. Initialize your counter to zero. 1\. Read the first number `n` (&amp; make sure you actually get it; should be `unsigned`, read with format `"%u "`). 2\. `while(n--)`: 2.a. Read the next number (&amp; check you got it; should be `float`, read with format `"%f "`). 2.b. If it’s in the range, add one to your counter. 3\. Profit.
Do you think if i simply do something like asking the user for the amount of gallons needed and putting in the numbers manually [(0 + 7 =7) (4+3=7) (0+3 =3) etc.] and somehow getting to say" it takes x amount of times to get t amount of gallons of water" it would be a valid code? 
I can see where you're going with this but it didn't solve my problem. It's hard for me to describe what it is that I have to do in the program. I can link the project rubric if that helps you understand?
The comment above contains the solution to your problem. It is your job to implement it. If you are unable to code any of those steps, post what you've attempted.
AFAICT the pseudocode matches your description of the problem; you can either pick a step and inquire further, or better describe what it is you want your program to do, what it is you’ve already tried/got working, and what it is you’re unable to do. Otherwise I’m pretty much doing your homework for you. (And I don’t do that for proto-engineers because there’s enough havoc being wrought in the world as it is.) (And I *certainly* don’t do third-party homework without getting paid.)
I can't quite visualize the pseudocode you're describing, but it sounds like a good next step. Try it and see! 
One other thing you could do is pruning subtrees when a certain condition cannot hold inside the subtree. For example, in the search command find . -path foo???/bar/baz if the first directory already doesn't match, there is no need to recurse. This is probably possible with other predicates as well.
I've posted this before: Rob Pike gave an interesting talk on [Lexical Scanning in Go](https://www.youtube.com/watch?v=HxaD_trXwRE). Even though it's ostensibly about GO, it's close enough to C that you can use the ideas directly.
Testing it on Arch...so far promising...
That's a really good idea! At `-O4`, the optimizer could transform that into something like -path 'foo???/bar/baz' -o \( -not -path 'foo???/*' -prune -false \) Similarly, things like `-not -path '*/.git*'` can become -not -path '*/.git*' -o -prune -false Quite a few complaints about `find` are due to how awkward it is to prune subtrees ([example](https://github.com/tavianator/bfs/issues/8)), so this auto-pruning seems like it would be a very nice feature. Thanks for the inspiration!
A debugger is really helpful when debugging seg faults. Try one, for example gdb.
It's not a bad idea if you can get research that'll pay for most or all your tuition. My partner did that and was able to get the same job but negotiate an extra 10k because of the masters. 
Literally the exact same thing. I came from a small town with a crappy public high school and didn't know anyone that had touched a line of code until college. No computer classes offered in HS. If you haven't already, learn to use Linux. Buy a book about it even. It'll teach you a lot about how an operating system works. Also take a crack at doing some personal projects in Python. C++ will teach you all kinds of nitty gritty stuff that's majorly important but Python let's you get ideas off the ground in a small fraction of the time.
Thank you! I'll get on that ASAP
It's starting to look more and more like you're right. Haven't been able to find anything satisfactory in my research. So recv and send are consistent between winsock and POSIX sockets, yea? Are there any other important functions besides those? (Not too familiar with the socket API yet.) Gonna go look into some POSIX socket tutorials.
Seg faults are usually caused when you try to access memoru that you are not allowed to access. In this case, I think the seg fault is due to the fact that you are declaring `struct clip *hp` in `build_a_list()`. When you try to return this pointer from `build_a_lst()`, the variable *hp goes out of scope. You need to dynamically allocate memory for your struct. To test this, just change `return hp;` to `return NULL;`. If the seg fault goes away, then this is your problem.
Do you need the `\n` as a delimiter? It reaches the end of the string, so it will try to read past it if you're trying to delimit after the newline character.
Stick in some debugging printf's to see where the segfault happens. That will give you insight into what's going wrong.
There's lots of things that are wrong and could be crashing. Use a debugger. The 1st potential crash is in fopen because you're not checking argc before using argv[2] The 2nd is using getline without checking fopen succeeded
Although you're right - this isn't the crash since the returned value is never used.
what is happenning when you reach the end of one row ? * strtok return NULL * this NULL is stored in field[i] * what is the value of i at that point ? 
What's going wrong? There's syntax and logical errors .. what are you stuck on?
Pseudo code: * read input count ( [scanf](https://linux.die.net/man/3/scanf) ) * read numbers ( [scanf](https://linux.die.net/man/3/scanf) again, but in loop) * if read number is in range keep count * print count of number in range 
The program is compiling but it doesn't initially respond when I input a number. It responds when I input a second number but only responds with "The number is greater than your guess." This is my first time using the rand, if, and do/while functions. I'm still pretty new at this.
The lines ending in $ must be a copy-paste error. You need 2 inputs because of the `\n` in the `scanf` format string. Remove it; it isn't necessary.
That definitely helped! The program is immediately accepting the input now and printing an output each time I enter a number. But the only output that it's printing is "The number is greater than..." even when I input 32 which is meant to be the upper bound. I'm also trying to figure out how to get it to stop after the count hits 0, right now it's continuing into negative numbers
[\n in scanf format string](https://stackoverflow.com/questions/15443483/using-n-in-scanf-in-c) 
If you enter `32` then the `input &gt; r" case will be true. Your messages are the wrong way around. Secondly one of the 1st 3 cases *must* be true ( input = r, input &lt; r , input &gt; r ). Which is why it never checks the counter. The counter check should be on its own,
I agree that the code above should check `argc` before using the argument, and `fp` after opening the file for NULL if opening the file failed.
If you enter `32` then the `input &gt; r" case will be true. Your messages are the wrong way around. Secondly one of the 1st 3 cases *must* be true ( input = r, input &lt; r , input &gt; r ). Which is why it never checks the counter. The counter check should be on its own,
* where is `randomNumber` used ? * `srand` only need to be called once (start of the program ) * use `break` when `counter` is zero
&gt;Also I would never recommend getting a master's in CS. Seems like most people I've talked to (certainly not everyone but more people than not) now think of it as a waste of their time and money. I think it's more nuanced than that. If you have a BS in a typical computing major (CS, CE, EE, whatever) and have a fairly typical career trajectory in mind, then yeah an MS is probably a waste of time. But there are several situations where it isn't. If you want to get into a particularly specialized subfield or something vaguely research oriented (if you want to do full on research you do a PhD) then an MS can be helpful. Many foreign nationals use a US MS program as a stepping stone into the the US job market. And most interestingly for OP, another common use of an MS is to try to make a career field switch to CS is their bachelors wasn't technical/computing-related. There are pretty good justifications for any of those three cases.
You're absolutely right, wow. It's late and I didn't even consider that kind of error. I updated the code in my post, what I'm trying to do now is to get the code to end with "You Lost!..." but I think I can figure that out. How would I fix my count function so that it will say "You won in x tries?" 
Would this be the correct format for that? else if (counter == 0){ break; }
Pointers are memory locations. Setting delim to some ASCII value makes it point to some weird point in memory. Passing some weird point in memory to strtok(), which expects a pointer to a valid C string is gonna make you have a bad time.
I just noticed you said you're using UDP, so you'd be using send() and recv() anyways. There's a few other differences, I think -- it's been a while. You have to use a closesocket() function instead of close(), and a few other odds and ends. Most differences are because on Windows, unlike unix or linux, socket file descriptors are completely different from file ones and can't use the same functions. The MSDN documentation for Winsock is pretty good.
thank you very much! this helped me solve the issue!
your loop should read like this: 1. read input 2. if input is correct, win 3. otherwise count the failed attempt an tell the if more or less 4. if number of failed attempt reached the limit, lost and exit the program your loop read like: 1. read input 2. if input correct, win 3. otherwise if input more that answer, count failure, **tell answer is more than input** 4. otherwise if input less that answer, count failure, **tell answer is less than input** 5. **otherwise** if counter as reached the limit, lose parts that are in bold, look suspicious to me 
Can you post a gist / pastebin of the code? Head has all the same info as tmp because you're using tmp to traverse through head and append new nodes to the end. Isn't that what you're trying to do?
in most of the case he would see where the segfault happens, but not what has caused it.
are you trying to use your linked list as a stack or as a queue ? instead of looking the end of the list each time ( which get longer each time ), you could keep a reference somewhere head = createNode(x,y,data); tail = head; // adding a node at the end tail-&gt;next = createNode(x,y,data); tail = tail-&gt;next; also your pseudo code look correct although we have no idea of the exact code, perhaps encapsulating the node creation in a function would help clarify where you go wrong.
&gt; How would I fix my count function so that it will say "You won in x tries?" I guess by subtracting counter from 5. But you shouldn't use "magic numbers" so you should save 5 in a variable (or use a macro) for clarity. You could also count from 0 upwards instead of down from 5 and then check if counter &gt;= maxAttempts. Then you can calculate the remaining attempts by subtracting counter from maxAttempts. One smaller note: You decrement the counter in all the branches. You can decrement it before the if statement.
You're trying to modify a const value. That causes undefined behavior; neither compiler is wrong. Your code is. You didn't get any warnings or errors with that? http://en.cppreference.com/w/c/language/const
I maybe should have clarified, I just did this to try and understand the way the pointer referencing works, I wasn't sure what to expect and ran it, now I'm even less sure. Xcode did give me a warning but I was expecting a full on compiling error. The online compiler didn't seem to mind though.
Your code contains what is known as *undefined behaviour.* By writing to a const variable you do something that is not allowed. The C standard does not define what happens in this case and what exactly happens can be hard to predict. In this concrete of situation, there are three general possibilities: * `n` is assigned to and now has a new value. This value might not be used everywhere as the register allocator might not reload `n` from memory if it is still in RAM. * the program crashes when you try to assign a new value to `n` (unlikely with automatic variables) * the compiler sees that behaviour is undefined and removes the offending code or replaces it with a call to `abort()` or similar. This is because the compiler assumes that your program is well-behaved. If some section of your code does something undefined, the compiler assumes that it won't ever be reached and is allowed to just remove the code.
I would upvote with my sockpuppet accounts if the possibilities included : * invoking **the Great Old One** * running the Large Hadron Collider 
Nasal dæmons aren't quite off the cards.
C files are compilation unit, header ( `.h` ) files are public interface where you put prototype of your function, use `cc -c input.c -o input.o` to compile then `cc input1.o input2.o` to link them, you better use a makefile and `make` to build with 'one' command 
*C Interfaces and Implementations* by David Hanson.
keep watching and sharing 
Stop posting these. This is your final warning.
keep watching 
If it isn't that, then the next thing I would check is: void split_line(char **fields,char *line) { int i=0; char *token, *delim; delim = ",\n"; fields[i] = strtok(line, delim); while ( fields[++i] = strtok(NULL, delim) ); } You are probably going past the end of `fields[]`. Put a `printf("i = %d\n", i);` and I bet that you will see that you are going out of the bounds of your array.
I told you to stop. Please enjoy your ban.
The backtrace can be posted here.
&gt; Any libraries need to have a license that allows me to statically link them into my binary without having to include an extra license file. Why? &gt; Obviously straight-up public domain is preferred, There is no such thing (ask a lawyer for details).
&gt; Why? Don't like having to ship cluttery files with my binary. Having just a single binary file is much cleaner. &gt; There is no such thing (ask a lawyer for details). Depends on who you ask and what country you ask them in. Lots of libraries also dual-license with something else for this exact reason. There's also CC0, which is a proper license version of "public domain".
&gt; Don't like having to ship cluttery files with my binary. Having just a single binary file is much cleaner. So, no documentation?
When run, it spits out a default config file and help file, plus games usually have some form of in-game instructions.
Place each logical unit of source code into one file. Place groups of source files into directories. Place groups of directories into directories. Iterate until satisfied. The only exception is when you are writing a library where you often want to put every external function into a file on its own so the linker can exclude dead code when linking the library statically.
2k LOC...lmaaaaaaaaaoo
I usually like to have a central header where I will declare every (or most) of the structures and functions, but the definition of the functions are in separate sources, sorted by what structure they manipulate or subject. For example, if I was coding a database-like program, I would do this: /* Header "handlers.h" */ struct entry { uint32_t id; uint32_t type; char name[MAX_NAME]; char value[MAX_VALUE] }; struct database { uint32_t next_id; uint32_t size; entry *e_pool; }; /* declares here, but definition goes in entry.c */ void free_entry(struct entry *e); struct entry *new_entry(struct database *db, uint32_t type, char *name, char *value); /* declares here, but definition goes in database.c */ void clear_database(struct database *db); void expand_database(struct database *db, uint32_t count); void shrink_database(struct database *db); void init_database(struct database *db, size); This way, I can include this single header on every source, but their definitions will still be organized. I do this with every project (big or small).
I did this solution but it gives me 5/10 
Unfortunately, you've asked your question in the wrong subreddit. This subreddit is about C (and not C++) programming. You can try asking in /r/cpp_questions or otherwise just look at example wxwidgets programs or wxwidgets tutorials and see how they solved this.
Adding onto /u/MyIlokunmingia's great comment, things that target a particular job posting within a resume. This is where having the project portfolio (s)he mentions can be powerful if it has some breadth. Like if a posting is for embedded design for example, relevant projects to have on the resume would be of course embedded projects in general, probably kernel drivers, and maybe something to show off experience with the ISA the posting talks about (like ARM, maybe MIPS if some of those are still hanging around). While you may have a great Client-Server project completed in your past, and from a programming point of view it can be impressive, it will carry less impact than if you have a more germane project that might be a bit more modest. The long and short of this, when you apply to a job req, don't be afraid to tailor your resume a bit for it if you can. If a small change to make more salient experience more prominent can be done, it can be to your advantage.
Is there no circumstance in which a *const* variable can be modified without invoking undefined behavior? It sounds strange, since the whole point of *const* is basically to mean "can't be modified", however I know that C (in contrast to C++) doesn't allow *const* integers to be used as integer constant expressions (e.g. to declare the size of global arrays), and it is my understanding that this is because of the possibility of a *const* integer being modified through type punning or something along those lines. But if modifying a *const* is ALWAYS illegal, what reason is there to disallow them being used as an integer constant expression?
As a new to C I recommend you to work slowly at first. In C you've got to stay focused while writing because there are a lot of vulnerabilities. That's my recommendation for you. If you're having problems detecting those kind of vulnerabilities you can try using any program to help you, I've heard of one called Checkmarx so you can try.. Good luck.
Nothing. Why can't you simply include the licenses in the program and add a command to display them?
`const` basically just means read only. It's quite common to declare a `const volatile` variable that gets modified by another thread. As for your question about arrays, you're correct that a `const int` is not a compile time expression. You could have something like `const int x = rand()` and that's perfectly fine, yet unusable for declaring the size of an array.
May God have mercy on your soul.
You may find some of what I wrote in regards to a [similar question](https://www.reddit.com/r/C_Programming/comments/6k4iik/question_how_to_pass_a_nonconstant_array_to_a/) useful. Examines some of how this may work under the hood.
Just a command might be too hidden to count, not sure how easily visible these licenses have to be. Something I have been considering is having it spit out an additional "credits.txt" file that has a list of libraries used with their respective licenses. Would also give me another place to put credits for the other libraries/resources I'm using.
&gt; Just a command might be too hidden to count, not sure how easily visible these licenses have to be. Swipe down → cog wheel → System → About Phone → Legal Information → Third-Party Licenses
If Android can get away with hiding them away deep in a menu I'd probably be fine. Definitely an option if I find an MIT-licensed library I really want.
I tried it and it would work but i forgot i have to get the program to ask the user to input the size of the gallons, thus there is no set size of the jugs. Thus far , I have the program ask the user for the size and if the m jug is larger than the n than it ask them to enter n as the bigger size. From there I have it set to input the total amount needed and if the total is larger than the sum of n and m, then it has it tell the user to use a number between n and m but it loops the whole program to where it ask the user for the size of the jugs again. Ill upload what i have in a bit to show you
delim is initialised to point at a string. This is correct.
If you have such a specific task and performance is important, you should read a bunch of bytes into a buffer, count the newlines in that buffer and continue that until the file ended. However, if performance does not matter, just call `fgets()` or `fgetc()` a bunch of times.
You can do it both ways, whichever you prefer. Reading a single character at a time is probably the easiest method. Grabbing a fixed-size buffer at a time *might* have performance advantages if that's important to you, though this is the sort of thing that you have to measure to know for sure, and then tune the size of the buffer appropriately.
I'm assuming that "I want to use fopen" is part of your problem statement, so I won't delve into alternatives like memory-mapped files, but keep in mind that there are alternatives that may be appropriate for certain use cases. What kind of hardware are we on? What kind of OS? Are the "newlines" a single '\n' or are they the DOS-style '\r\n' sequence? The answers to some or all of those questions may potentially change the best way to "want" to do this. Generally, fgetc on every character, while having the advantage that it is brilliantly simple and has no scalability concerns (in terms of memory footprint) will be *slooooooowww*. This is because every fgetc is a system call, and has to go through a ton of work to switch between usermode and kernel mode execution and copy a bunch of data around, and sanitize other data, etc. One of the common rules for good performance is "try to minimize the number of system calls you need to make". Depending on the hardware (I'll assume for a moment you can't streaming read data off the disks faster than a single CPU can scan it), your best bet is probably to pick some reasonably large buffer size, ideally page-size aligned (adjusted for system memory, if need be) to malloc within, and then issue a series of fgets calls to read data into that memory and then scan forward to the memory with a pointer looking for your '\n' and incrementing a counter. This could get *way* fancier though, with multiple processes depending on number of cores and spindles in a RAID array or various other things. Hand coding vectorized intrinsics would also help a lot here, but that's a big rabbit hole to go down.
Yes I'm aware but I like to experiment and rewriting things is a good way to learn, I think!
`fseek` isn't really going to help you unless you somehow magically know where all the paragraphs start and end *a priori*. If we pretend for a second that a paragraph is defined by a single newline, then the answer is pretty simple: read in the file character-by-character and write out that character. When the character is a `'\n'`, print this additional single character as well. You might start by writing this simple program. Of course, this isn't what you're going for: a paragraph is two sequential newlines. This should be a relatively simple modification of the above, but now you'll need to buffer the last character you read in so you can compare them. Be careful of edge conditions. The first character you read can't be compared to the previous, of course. Make sure you output both the first and last characters. Should the final paragraph get this additional character, even if it's not followed by newlines? And you haven't said what needs to happen if there more than two newlines in a row (you might need to keep track of this). Test these and modify your program as appropriate.
&gt; This is because every fgetc is a system call, and has to go through a ton of work to switch between usermode and kernel mode execution and copy a bunch of data around, and sanitize other data, etc. One of the common rules for good performance is "try to minimize the number of system calls you need to make". Eh.... `fgetc()` is *not* a system call. `fgetc()` fetches the next character from the `FILE*` buffer. Only if this buffer is empty a system call is performed to fill it again. This doesn't mean that `fgetc()` is fast: Due to `stdio` buffering, `fgetc()` is actually pretty slow for the little work it performs unless you call `flockfile()` before to remove the locking overhead or use `getc_unlocked()`.
I am practicing on my own and while I was familiar with open/read I never used fopen before so I decided to try that now. The newlines are a single character '\n' But yes this is what I wanted confirmation on, I was not sure how impactful calling the same function so many times compared to allocating a buffer was. I would rather write slightly more advanced code if it means I am keeping better habits, should I not? This is how I did it with open() #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; int main(int argc, char **argv) { int fd; char buf[4092]; int i; int linecount; int errsv; linecount = 0; if (argc &lt; 2) { printf("Path to filename required\n"); return (1); } fd = open(argv[1], O_RDONLY); errsv = errno; if (fd &lt; 0) { printf("%s\n", strerror(errsv)); return (1); } memset(buf, 0, 4092); while (read(fd, buf, 4092) &amp;&amp; errno != EISDIR) for (i = 0; buf[i]; i++) if (buf[i] == '\n') linecount++; errsv = errno; if (errsv == EISDIR) printf("%s\n", strerror(errsv)); else printf("File contains %d lines\n", linecount); close(fd); return (0); } 
Derp. Thanks. Brain was elsewhere when I said that.
Broadly speaking, you should probably read at least a line at a time for any non-trivially sized file. But there are very few absolutes here. So many things depend on your use case. Some projects do a *lot* of work to get fast I/O, others not so much. It depends on what's needed.
The gist ( no pun intended ) of the code is that I am using inner all over the place and I have found that I have a need to keep an ordered representation of the various inner nodes. I have, in another location, an array that has all of the information that eventually becomes these inner nodes, but that array could be 5000 items long and I only end up making 300 valid inner nodes out of that information. Much later in the processing, I need to be able to recall how that inner node was used, and the order in which it appeared. 90% of this recollection is going to be in order of arrival, so a linked list ( the simplest data structure in the world and somehow the damn thing wont work!! ) is ideal. After creation of the outer node, the inner node only ever has a 2 ints changed and the next added to it ( or not added it it happens to be the last one ). My problem is that when I do this outer * temp = head; do{ //Do things with the node //Change the ints to this or that to indicate forking needs //Read stuff from outer-&gt; temp = temp-&gt; next; }while( NULL != temp);
Rough version (doesn't handle more than two or three newlines in a row sensibly). #include &lt;stdio.h&gt; int main() { int c; while((c = getchar()) != EOF) { if (c == '\n') { int n = getchar(); if (n == '\n' || n == EOF) { putchar('$'); if (n == '\n') { putchar('\n'); } } else { ungetc(n, stdin); } } putchar(c); } }
 The gist ( no pun intended ) of the code is that I am using inner all over the place and I have found that I have a need to keep an ordered representation of the various inner nodes. I have, in another location, an array that has all of the information that eventually becomes these inner nodes, but that array could be 5000 items long and I only end up making 300 valid inner nodes out of that information. Much later in the processing, I need to be able to recall how that inner node was used, and the order in which it appeared. 90% of this recollection is going to be in order of arrival, so a linked list ( the simplest data structure in the world and somehow the damn thing wont work!! ) is ideal. After creation of the outer node, the inner node only ever has a 2 ints changed and the next added to it ( or not added it it happens to be the last one ). My problem is that when I do this: outer * temp = head; do{ //Do things with the node //Change the ints to this or that to indicate forking needs //Read stuff from outer-&gt;data-&gt;thing or use outer-&gt;data-&gt;other_thing temp = temp-&gt; next; }while( NULL != temp); In fact, when I do this void some_func ( inner * inptr ){ outer *node; if ( NULL == head ) { head = malloc (sizeof(outer)); head-&gt;x = 1; head-&gt;y = 1; head-&gt;data = inptr; head-&gt; = NULL node = head; } else { node = head; do{ node = node-&gt; next; }while( NULL != temp); node-&gt;next = malloc (sizeof(outer)); node-&gt;next-&gt;x = node-&gt;x + local_var_1; node-&gt;next-&gt;y = node-&gt;y + local_var_2; node-&gt;next-&gt;data = inptr; node-next-next = NULL; node-&gt;next; printf ("%s in head. %s in node.\n", head-&gt;data-&gt;thing, node-&gt;data-&gt;thing); } //read stuff from node here, modify x, y } Although I know my expected results from the print statement above should be: foo in head. bar in node. I see: bar in head. bar in node. All of the data I see is from the last node that I added. I currently traverse the list because my references weren't working as expected so I have tried to pare down the "moving pieces" in the code to try and understand what the hell is going on. There is only one time in all of the code that I say: head = malloc (sizeof(outer)); Everything else is done through another reference. Once head is set, I literally never want it to change. Once a next is set to not NULL in an outer, I literally never want it to change. The only thing I would change would be a reference to the final node, which I removed because I was getting annoyed at the data. I have done this a thousand times and suddenly I am unsure why it's not working. Perhaps I can post more details later with an actual pastebin, I am just confused as to why head would ever reference anything besides head. 
I hadn't thought about using `ungetc` to enable lookahead instead of buffering the previous character. That might make handing all-whitespace lines easier, if that's a requirement for OP.
Thats a good idea, I'll give that a try. I responded above with a bit more detail above, maybe that will help. I thought my reference to head would never change so that is why I am confused when head isn't the same from the moment I set it to the moment I free it.
Thats a good idea, I'll give that a try. I responded above with a bit more detail above, maybe that will help. I thought my reference to head would never change so that is why I am confused when head isn't the same from the moment I set it to the moment I free it.
There's a lot to work on here. First I noticed you say to enter in a number in a range but there's no actual logic preventing numbers outside the range. Second, you should look into allocating dynamic arrays properly. The biggest thing that will help you is going to be creating a struct for this data handling it that way. 
Thank you. 
Like someone said use a queue if you need to keep order. You can create one queue for the 5000 items then dequeue valid ones. Queue valid items into a second queue for further processing. Also modularizing some pieces into functions would be helpful like `createNode`, `nodeAppend`, `findItem` etc. From looking at what you've posted whatever is created in `some_func` is lost since you only pass in `inner*` and no return. 
This function had no return because anything I would have to return would be appended to the global linked list. Am I incorrect in thinking that? I am honestly puzzled as to why all the nodes would become the same node. My output for all nodes will be identical to the final node I added, there will be the correct number of them, they will all just be the newest node.
When you enter a number and press return, `scanf` leaves the new line character in the buffer. The first first call to `scanf` reads `num`. The first time through the loop `fgets` reads `"\n"` into `first_name`, `fgets` reads the first name into `last_name` (including the `\n`), `scanf` reads the last name into `grades[i]`. Oops. Things just deteriorate after that. The simplest and most robust way to mix `scanf()` with `fgets()`, especially if you're also going to be using `printf()` to interact with the user at the terminal, is to do something like this: char buf[BUFSIZ]; ... fgets(buf, sizeof buf, stdin); sscanf(buf, "%d", &amp;num); and fgets(buf, sizeof buf, stdin); sscanf(buf, "%f", &amp;grades[i]); 
4092? Like almost 4096, but not quite? Also, read() is a system call. Going to the OS to read 4K, is very very very slow. If you use a buffer, make that a few megabytes at least. Your solution is probably slower than a loop with fgetc().
Hmmm I have no experience with global variables as I've been taught to avoid them. Unless you really need the list to be global maybe make it local. Also I don't know if the `temp-&gt;next` in the while loop is a typo or actual code. I assume head is the ptr to the global list, the I would attempt to organzie it. https://pastebin.com/H9hk1hZQ
Okay so this is what i have: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int m; int t; int true; while(true) { //Ask user for gallon size printf("Enter the size of n: "); scanf("%d", &amp;n); printf("Enter the size of m: "); scanf("%d", &amp;m); //Makes the user enter n as the greater number of m and n if( m &gt; n) { printf("Invalid. Please make sure n is greater than m.\n"); } //User enters the total number of gallons needed else{ printf("Enter the number of gallons needed: "); scanf("%d", &amp;t); //User must enter an amount that is not over the total of n + m }if ( t &gt; n + m) { printf("Invalid number. Please try again.\n"); } } return 0; What would i need to do to get it to only repeat me to enter the gallon total if the gallon total is over the sum of n and m? Also, how would i go about next to help me solve how many times it would take to get to t amount of water?
two blank lines or 2 consecutive '\n' ?
Thank you for explaining! 
&gt; node = head; &gt; while( NULL != temp-&gt;next ){ &gt; node = node-&gt; next; &gt; } This loop looks wrong. You're checking for temp-&gt;next but advancing node inside the loop. 
Thats because I am trying to find the last time in the node, I dont want a null node when the loop breaks, I want the node before it is null. I think I found the issue. I was passing the struct inner from an array of them. The passing from the array caused the address in memory to always be the same, so I ended up duping the strings i needed. It is a waste of memory, I am sure, but it's not a critical program and I will revisit it if I ever have time. Super annoying 
I get what you're looking for in the **while** but inside that loop when does **temp** get changed? How are **node** and **temp** related such that changing **node** changes **temp**?
It's perfectly fine to declare a local array with runtime size.
That's a VLA. I'm talking about fixed length arrays.
So your original intent was to say that fixed length arrays must have fixed length? That's a tautology 
I was explaining why using a `const` variable to specify the size of a fixed length array is not possible.
What kind of performance requirements are there? What’s the target platform? Must it be in C or is this just a learning thing?
[Here](https://pastebin.com/ugW58K31) is a program that when it detects 2 or more consecutive newlines adds a character to the end of a paragraph. I haven't tested it beyond proof of concept. 
If you're running Unix (including MacOS or Linux), the "wc" command will do this for you nicely. If you want to code this yourself, then just use getc() or fgetc(). You don't need to use a buffer because stdio does that for you under the hood. If performance really is going to be critical, then use fread() to read large blocks into a buffer and scan the buffer for newlines. fgets() will read one line at a time, so you could just keep calling it until it reaches EOF, but you're stuck with confirming that there's actually a newline at the end of the buffer, so you're back to scanning again. At that point, might as well use fread().
Here's a nifty pattern I encountered: outer *head = NULL; outer **tail = &amp;head; void appendNode(outer *node) { node-&gt;next = NULL; *tail = node; tail = &amp;node-&gt;next; } In terms of coding style, you should treat allocating a node, filling it in, and adding it to the list as three distinct operations. The way you coded it, jumbling those things together, is confusing to read and an invitation to errors. outer *node = malloc(sizeof(*node)); // allocate node-&gt;x = … // fill it in node-&gt;y = … node-&gt;data = … appendNode(node); // add to list
"You won in %d attempts" will show the user how many attempts they had left, not how many they made. "the number is less than your guess" should have been "your guess is less than the number", and vice versa … try again:\n"$ is a syntax error; the compiler should have balked at that. No need to re-seed the random number generator every time. But since you don't call randomNumber() anyway, it doesn't make a difference. There are technical reasons why `rand() % limit` is bad practice, but since your limit was a power of 2, you're ok there. I don't understand the `+ 0`, though. Perhaps you meant `+ 1`? Did you really mean 0-32, or 0-31? `rand() % 32` gives you numbers in the range 0-31. Over all, it's not terrible. Fix the syntax errors and the less/greater confusion, and it should work.
It does, and it's pretty good.
&gt; It probably does, but it uses the MIT license which requires its notice to be included with the binary. I prefer ZLIB, but I don't see much problem with MIT. One can simply place the notice in the "--help" message. Some people just add the message in the documentation: "this software used XYZ under the MIT license: ......"
If you’re asking this question almost certainly no. To leverage multiple cores you need to write your code to do so.
Ok thank you. Don't know why it's downvoted but whatever just wonderif
You mean to develop on? If you're writing concurrent code (with the potential for race conditions), an SMP system might expose bugs in that code more easily. Also your code will build faster haha.
So more core will expose bugs quicker?
Only bugs related to concurrency. If you're not doing any concurrency (e.g., no multi-threaded locking code) then more cores won't help you discover bugs.
I wanna optimize for multiple threads so it's best to pick a CPU that's enough threads that I want my code to use?
Try to compile big source codes at once, boy! My ThinkPad's CPU always go full horsepower...(i5)
hehe yes I meant 4096... Doesn't it just read up to 4092 bytes with a null character and then returns 0 on the next call? Because I had no trouble running the code on a few sample files
Using this type of programming is pretty hard for bugs detection as you need to pass it all through in order to find those. There are programs that can help doing that, as checkmarx for example, but it's still nor recommended programming this way. Good luck!
How about "We don't know the difference between C and C++" 
This subreddit is about C only, please post C++ content elsewhere, e.g. to /r/cpp.
Yes, that's generally a good idea. If the CPU has less threads than your program wants to run at the same time, CPU time has to be shared between threads.
Changing a const var is impossible and not defined. Those errors must be recognized fast as they come a lot. My advice is to concentrate on those and how to detect them. There programs that might help with it, such as checkmarx, but it'd important to notice them by yourself as well. Good luck.
Wouldn't the number of threads you can run concurrently be up to the OS scheduler? Even if you have more cores than threads in your program, I don't think that you would be guaranteed to have each of your threads assigned to its own core. 
Modern operating systems assigns threads to cores dynamically. Whenever a core has nothing to do, one thread that wants to run is picked and executed on that core. So if your program uses n threads and you have n cores, then unless your system does other CPU bound things at the same time, you can be reasonably sure that it's going to run all your threads at the same time for almost all the time.
Your question has already been answered, however I would recommend a few things... first of all, stay away from those online compilers, they are garbage most of the time.... secondly, compile your files with -Wall -Wextra -Werror ... It adds extra warnings, and turns all warnings into errors so it won't compile... might seem annoying at first, but it will save you from bad practices in your learning. Never ignore warnings.
Why do you use char* instead of int* ? Yes, atoi() could work.
If you want to refer to the whole array, it would be `sa`, but since you probably want to access the elements independently, you'd have to use `sa[i]` (assuming a for variable or equivalent called `i`).
If you want to see how the dereference operator works, remove the const
Not sure, this was pre written code we have to edit for my course. But how would I actually refer to the arguments using atoi?
One thing that might help you, the const char sa[] parameters to are strings. Strings in C are a sequence of characters terminated with a NULL such as: "Hello, World!" Given that the function takes 3 strings as parameters and you need 3 numbers, you will need to convert the strings to numbers. The atoi() function would work, and if you have already learned scanf() you could use sscanf().
But what name would I use for the arguments, so would it be atoi(sa) or like atoi(const char sa) or atio(sa[]) etc.
&gt;But what name would I use for the arguments, so would it be atoi(sa) or like atoi(const char sa) or atio(sa[]) etc. You would use atoi (sa). All the other info around the variable in your function definition is only used when declaring the variable. When you and to use the variable you only type out the identifier.
Perfect thank you very much 
`atoi(sa)`: the others words and symbol describe the type, and `sa` is the 'variable' name.
`atoi` converts a string to an integer, so you'd just do `atoi(sa)` to get the side length. What /u/SuperLutin asks is why you can't just pass the side lengths as integers to `triangle`.
more cores, build will faster for a big project like Qt
MightyFunkster is probably doing an assignment on writing functions where he's not able to change the format of the function. They're pretty common in CSE classes. 
See if the program below helps clear things up: #include &lt;stdio.h&gt; // include standard input/output functions #include &lt;stdlib.h&gt; // include atoi() function // function prototype - helps compiler check your program int func(const char sa[]); int main(int argc, char *argv[]) { char str[3] = "42"; int return_value = 0; printf("Starting main()\n"); printf("str[] = %s return_value = %d\n", str, return_value); printf("Calling func(char sa[])\n"); return_value = func(str); printf("Returned from func()\n"); printf("str[] = %s return_value = %d\n", str, return_value); printf("Leaving main()\n"); return 0; } int func(const char sa[]) { int a; a = atoi(sa); printf("Entering func()\n"); printf("sa[] = %s\n", sa); a = atoi(sa); a = a + 5; printf("a = %d\n", a); printf("Leaving func()\n"); return a; } 
A slightly different approach: #include &lt;stdio.h&gt; int main(int argc, char* argv[]) { int inchar, nlines = 0; do { inchar = getchar(); if (inchar == '\n') { nlines++; continue; } else if (inchar == EOF &amp;&amp; nlines) { putchar('$'); } else if (nlines &gt;= 2) { putchar('$'); } while(nlines) { nlines--; putchar('\n'); }; putchar(inchar); } while(inchar != EOF); return 0; }
The function atoi assumes there is a null terminator at the end of the string, I don't see how you can assume that here though.
Your board_set function returns an error in some situations. When you call it, you must check the return code instead of blindly assuming it succeeded.
Of course ... I fixed the problem. 
Sometimes when reading the newspaper I happen to read a long article about a match, names of people who scored and otherwise did amazing feats but the author fails to mention what sport it was. It's a bit like this question.
If you're going to use system calls, you could use mmap
The K&amp;R style definition doesn't form a prototype, and it will be undefined behaviour to call it if any of the parameters are `float`, `char`, `short` etc. It's pretty hard to make any argument against using function prototypes.
Spanish 21, based on his link. It's a blackjack variant where the 10's are removed from the decks.
A single core can process one instruction at a time, it may seem like more but it is just because the cpu is time-sharing faster than we can process. A multi-core processor has n multiple cores, each can perform one instruction, so for a quad core, 4 instructions at the same time. For most code, single instruction is fine, but there are benefits to multiple cores, speed of compilation, and running multiple threads.
What happens if it's programmed for 4 cores but the user only has two? Any downside?
That would depend on the cpu, if it has hyperthreading it can still handle 4 instructions at a time, if not it would only be able to handle 2 instructions at a time, as far as I know there is no way around that. I am not sure if that would cause the program to crash, I think it is more likely that it would have to do 2 instructions then the next 2.
That's what I was wondering. Wanted to know if it would cause any issues.
Maybe I can be of some assistance. If I may: Spanish 21 is like standard 21 (aka Blackjack), in that the mechanics are similar to 21 play. Hit, stand, double, split. In Spanish 21, the casino changes the composition of the deck from the traditional French pack (2-10 w/ JKQ and A) to a Spanish deck (2-9 w/ JKQ and A). With that, the casino sees an improvement in their expected value. The shift is measured at 2.54% per round, resulting in a house advantage floating around 2.9-3.1 % AGAINST the player. To accommodate the player for such an atrocious -EV game, the casino offers new 'perks' to lower the house advantage: 1.) All player naturals (commonly known as 'blackjacks', a 2-card 21 consisting of an Ace and a Face card) automatically pay 3-2 for the player, regardless if the dealer also possesses a natural. The 3-2 bonus is voided on splitting face cards and aces. If you split any of the face/ace cards a draw a 2-card 21, it is considered bonus number 2 below. 2.) All player 21's are automatic winners. They pay even money or 1-1 odds. 3.) 5/6/7-Card 21's automatically pay 3-2, 2-1, and 3-1 odds when the player draws. These bonuses are voided when doubling. Valid when splitting. 4.) 678 rank bonus is the sum of the 6, 7, and 8 rank card being drawn on a single hand. The sum is a 21. If the 678 cards are drawn as a mixed suit, they pay 3-2, if they are all the same suit (not including spades), they pay 2-1, if they are all spades, they pay 3-1. Doubling voids the bonus and follows rule 2 above. The bonus is valid under splitting. 5.) 777 rank bonus is the same as 4, except all ranks are 7. Mixed suit pays 3-2, suited non-spade pays 2-1, and spaded pays 3-1. Void on doubles and follows rule 2 if doubled. Valid under splits. 6.) The player can surrender any 2-card hand after the dealer checks for a natural. The expected value of surrendering is -0.5000 units. 7.) The player can double after doubling, this is called double-double. The player can DD up to three times, making a final wager 8x the initial bet at that round. The player can surrender half of their double at any time. Player cannot hit after double; only double, surrender, or stand. All doubled cards leading to 21 results in a payout of 1-1 odds. With this in mind, my intent is to prove the correct Optimal Strategy of the given chart as a personal academic exercise. I want to be able to re-create the charts as seen using the C programming language. If I can successfully reproduce the above charts, them my mastery of the C language has moved me from beginner to novice. If you or anyone else here has any questions, please feel free to either post here or message me privately. I am also willing to work with someone on this project. I am not looking to make money here, just adding to my programming repertoire...if I may.
As posted above, you are correct.
well isn't it same to assume that there are other programs running on the user (and developer's computer) that will take cpu time, hence not guaranteeing that your threads will be mapped to individual cores.
1. Show me a portfolio of examples. Working sites/apps or articles/blogs or repositories. Even finished works outside of computer science or programming are helpful. TL;DR: show me you can *finish* something non-trivial (hours + problem solving + creativity). 2. Show me your motivation. This is why school projects and, to some degree, work projects aren't the best examples for a portfolio. Those were usually extrinsically-motivated works. I know this is difficult for some to do, but if you can show me you spend some of your free, *personal* time reading or writing or coding about things that really interest you or you are compelled to do. And hopefully those things somewhat overlap with the role I'm hiring for.
What OS? Can you screenshot your terminal window when you run it and share that? The output string you describe obviously isn't from your program, so it's OS/environment/runtime-libary/etc.
https://ibb.co/kNhq6G Here is the picture, thanks for the help!
I find it difficult to believe line 16 isn't giving you a compile-time error. (See my above #2.) You see what I mean? What C compiler or environment is this?
Thanks! Could you explain to me what changing it to "int argc, char **argv" does to the function? It compiled and produced the correct outputs, it just said "RUN FAILED (exit value 23) every time
This is Netbeans
There are two standard C signatures for main: int main(void) int main(int argc, char **argv) You can neglect an explicit `return` from `main`, which is the same as a final `return(0)`. But you *must* declare `main` as returning an `int` to its calling environment. e.g. typically a terminal shell (executive `echo $?` to see this return value from your shell, BTW). `argc` is how many strings you'll find in the `argv`array. This contains the program name (`argv[0]`) followed by any command-line arguments passed (`if argc &gt; 1`). Hope this helps.
Have you tried using return 0 instead of with parentheses?
Did you change your `main` to `int main(int argc, char **argv) { ...` ?
Yes I changed it, and it is working correctly now! Thank you!
Change your %i to %d. 
The integer value returned by `main` is generally taken to be an error code. 0 indicates no errors, and any other value indicates an error. It looks like your program is returning a non-zero value because you've declared `main` to return `void`, as other people have pointed out. `main` should always be declared as `int main(...)`. One thing to point out is that the RUN FAILED is coming from the program running your program. It must be checking the return value and reporting an error if it's non-zero. If you just ran your program from a terminal, you wouldn't get that.
There are no strict performance requirements as such. I'll we handling a text file with about 4.2k lines. It can be in any language though I would prefer to write it in C.
If your preference is C, there are a lot of approaches to take. The brute force approach would be to allocate a “sufficiently large” buffer, e.g. char buffer[0x80000000], and loop through the input one character at a time, copying each read character to your buffer. You could have a simple state variable, e.g. bool sawNewLine. If you read/copy a new-line, check sawNewLine. If it’s true, set it to false and write your special character, else set it to true. After the input hits EOF, write your buffer to disk. That said, this could be done in a few lines of C# or even PowerShell (File.ReadAllText, string.Replace, File.WriteAllText), and with an input that small, the performance difference should be hardly noticeable.
Both %d and %i work in printf formats to print an int.
&gt; With this in mind, my intent is to prove the correct Optimal Strategy of the given chart as a personal academic exercise. I want to be able to re-create the charts Awesome. This is the core of the actual question then. I would start by suspecting randomness. To begin with, `rand` isn't actually random[1]. Then, `rand() % x` does not generate a value that is uniformly distributed. Third, when you have a good randomness it is still very hard to generate a good shuffle. My recommendation would be to start there. Find [LibreSSL](https://www.libressl.org/), use their `arc4random`. It's a CSPRNG, but it's fast enough, in some cases even faster than standard PRNGs of standard libraries[2]. And specifically use their `arc4random_uniform` function to generate uniformly distributed numbers for avoiding the modulo bias that your code has. Then implement the shuffle with the proven [Fisher-Yates](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) shuffle algorithm. footnote 1: `rand` is something I call "computer science random" which is pretty much the opposite of what a reasonable person would mean when they say "random", it's repeatable, trivially predictable, most likely badly distributed, etc. `srand` doesn't help much and it's very unclear how to seed it well which always leads to people who want better randomness to do weird gymnastics, like you did, which often makes it worse. Unfortunately all programming language standardization committees are filled with people who seem to be in a conspiracy to make sure that all RNGs are shit.[3] footnote 2: Just to see if the argument "we can't have good random in our standard library, it would be too slow" actually is true, I have [implemented](https://github.com/art4711/unpredictable) the same algorithm as arc4random in Go and compared it to the Go standard library math.Rand. The result is that good random is faster in certain cases than the shit random the standard library has. So that argument is bullshit. When OpenBSD (the source of `arc4random`) went through packages in their ports tree to see how system `rand` and `random` were used, out of a few thousand ports they found 2 that actually wanted repeatable and predictable sequences (so that argument doesn't work either, it's baffling that everything is still so shit). footnote 3: You might think that this doesn't matter and it's all just a conspiracy theory and `rand` should be good enough for a simple simulation. Back around 20 years ago the University of Alberta had a rock-paper-scissors competition between bots. The benchmark was the fully random bot. A fully random bot is unbeatable and will tie on average against every other bot. When using the function `rand` from most standard C libraries, most good bots were winning 90+% of the games against it. When I replaced `rand` with `arc4random` the results went back to the expected 50/50.
**Fisher–Yates shuffle** The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite sequence—in plain terms, the algorithm shuffles the sequence. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
They have different meanings in `scanf` though; `%i` is unlikely to be what OP intends
Add `return 0;` or `exit(0);` at the end of your program. The program runs fine, but then returns some random garbage value as the exit code, which is why the operating system says it failed.
Someone needs to write a 'bot for this forum that reformats submitted code correctly. I almost missed the `return 0;` and started to write about how that was your problem. #include &lt;stdio.h&gt; int square(int c); void main() { int a; int b; printf("Enter a number to be squared: "); scanf("%i", &amp;a); b = square(a); printf("\nThe square of %i is: %i", a, b); return (0); } int square(int c) { c = c * c; return (c); } That said, RainbowNowOpen probably has the correct answer.
Multiple cores are great for playing video games. They make your computer run faster in general, I think, because the operating system and window system can take advantage of it. Your build system and compiler quite possibly take advantage of it. But if you're a newbie, then you're not writing multi-threaded applications, so the multiple cores don't do *you* any good. Unless you actually *are* writing multi-threaded (or multi-process) applications, then yes, multiple cores will make your apps run faster and make bugs more apparent.
That's why I said “most of the time.” Note that typical programs actually sleep most of the time, so even if you have 100 programs running on your computer, it is very likely that they don't consume much CPU time at all.
[removed]
Please indent your code with four blanks in every line of code so it appears readable.
 int count, values = 5, arr[values], range, freq[range], currentv, num = 0; I could be wrong here, but I don't think most compilers will let you use a non-constant value to declare an array. You also don't initialize "range" to have any value, so even if it did work what would the size of freq[] be?
What do you mean "Windows can't run my program" - what happens when you try to run it? Does it run and crash, indicating a problem with your code, or does it fail to even load and run, not even getting to your code?
&gt; but I don't think most compilers will let you use a non-constant value to declare an array. That is actually allowed with C99, and it is called variable length arrays. Your observation about `freq[range]` is correct though, that is very likely undefined behavior.
The latter. It compiles but doesn't run upon execution of code.
&gt; why is teh stnode made the first node if the new node So, the way your linked list works, you have a bunch of nodes, and each node is linked to another node, just like a chain. If you know a node, then you can find any node that comes after it by following `nextptr`s. But note that you can only move in one direction, you can look at `nextptr` to see which node comes after this one but you can't check which node comes before this one. Since you can only move forward on the linked list, how are you going to keep track of all the nodes? The solution is to keep track of the first node in the list. If you know the first node, you can go forward to find the rest of the list. And the fact that you can't go backwards is fine, because there is nothing at the back of the first node. In your code, the first node is kept track of with the variable `stnode`. Since `NodeInsertatBegin` inserts a new node the beginning of the list, it changes the first node to be the new node.
&gt; In your code, the first node is kept track of with the variable stnode. Since NodeInsertatBegin inserts a new node the beginning of the list, it changes the first node to be the new node. oh,got it so basically the stnode is still there,but the original stnode is converted into or rather labelled as the new node. Thanks for the detailed explanation . :) 
If it never gets to your main() then posting your code here is no help, as execution never gets that far; you need to post how you're building your app.
Why does your convert function take n as an argument? If your input is a null-terminated string you can just do int a = atoi(sa);
Tbh I don't really know, I copied it from an old program that was written for us for our course.
It should also be noted that the above link solved the Optimal Strategy using what is called an "Infinite Deck" model. The results should follow that as if the deck were in a fixed-state regardless of what card has come out of the shoe. This flies in the face of our realistic world where the shoe biases when cards are removed. Thus, the chart I listed in the OP suggests that using the "Finite Deck" model, accounting for all biases in an even distribution after n-trials, should produce the same results in the OP.