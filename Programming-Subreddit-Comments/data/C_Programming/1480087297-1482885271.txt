I actually just released this on github: [here it is](https://github.com/htmk/Fat-Array), I commented on every part of the implementation, if you have any questions feel free to ask. I welcome contributions! :)
You are right that using `void*` for simple arrays is a very bad idea. It hurts locality, adds significant memory overhead and is clumsy to work with. On the macro route, there are two typical approaches: with or without token concatenation. For complex data structures such as hash table and tree, it is usually necessary to use token concatenation. For arrays, token concatenation is overkilling. I would advise to use plain macros. [Here](https://github.com/attractivechaos/klib/blob/master/kvec.h) gives an implementation. It does not do error checking, but you get the basic idea. The following is an example about how to use the header: #include "kvec.h" int main(void) { kvec_t(int) array; kv_init(array); kv_push(int, array, 10); // append kv_a(int, array, 20) = 5; // dynamically expand the array kv_A(array, 20) = 4; kv_destroy(array); return 0; }
I can't quite figure out what you mean. [Here](http://www.asciitable.com/) is an ascii table with with hex and decimal. Does that help? 
http://de.tinypic.com/r/1iiz9t/9 This is how it is supposed to look like.
There's a smart suggestion here to use a transform matrix. If you don't go that way, think about this ... Translate the original circle to the origin. (i.e. translate each node by an [x,y] offset) Now scale each node (i.e. multiply its x or y or both) by the amount required to achieve the desired ellipse. (i.e. same scale applied to each node) Now translate the (new) ellipse centre back to the original location of the circle. (i.e. translate each node by [-x,-y] from the first step) Done? Okay, now use a matrix transform instead like you should! ;-)
So, C is definitely mainly procedural. Among the major "high level languages", it is probably the most procedural of them all. C++ has some declarative, probably even functional aspects (as per, I think, C++14, it even has lambdas). With a little snark, one can claim that C is basically assembler with some syntactic sugar. I truly would not know about the Windows API. I never looked into that at all. Maybe have a little look at https://en.wikipedia.org/wiki/Programming_paradigm, you'll see why I'm a bit hesitant about assigning one language strictly to one paradigm, and one paradigm to one category of paradigms. You can do functional programming in C (it would just be an awful lot of work I suppose, and you'd probably end up writing a poor man's Lisp), and you can do compeletely un-OOP stuff in C++. You can even do purely declarative programming in C++, by only using templates. C is still mainly procedural though.
What platform are you programming on?
How about #define VECTOR_INIT(type, size) \ do { \ int sz = (size); \ if (sz &lt; 0 || sz &gt; 1000) \ /* ... */ \ } while (0) Also, with void pointers you got no type safety.
And I recommend you to start doing , not reading or watching tutorials. http://www.learn-c.org/ ... this is the best for a beginner. It helped me a lot , it even has it's own compiler. And compile everything , try to modify values... anything and compile. You'll see what changes and how. 
Oh by no means is the `void*` method perfect. I just find that it allows for a truly generic option. With the macro approach it is impossible to have a container of generic containers unless you auto generate a specific implementation file for types required (aka reimplement C++ templates with the preprocessor). However, if I have a linked list of `void*` pointers then I can easily use the same structure to create a matrix of those elements. The top answer of [this](http://stackoverflow.com/questions/9401975/type-safe-generic-containers-with-macros) post explains the issue really well. There are a few other SO answers that say similar things too. 
Viewing them as file extensions is slightly incorrect even if it is useful. There's no .out file, only libraries and executables. A library can be static (the .a you mention) or dynamic (the .so), as can an executable be statically linked and dynamically linked to one or more libraries. Just a slight clarification. 
The thing is, your post didn't describe any additional constraints. Anyways, I explained one method to transform nodes on a circle onto an ellipse, per your post. Consider a post edit. 
Windows 10
Yo thats how I was learning XD
Especially for leaning C on Windows, Pelles C is nice, simple, and easy to install IDE: http://www.smorgasbordet.com/pellesc/
Then get yourself Visual Studio. Even the express edition has a C compiler.
That program is written in B, not in C. In fact, it's one of the [sample programs](https://www.bell-labs.com/usr/dmr/www/btut.html) Dennis Ritchie gives for the B programming language. Note that B is the predecessor of C, thus the similarity.
Not necessarily. You can handle strings however you want. You can store a length explicitly, for example if you're working with arbitrary data that might contain nulls, such as UTF-16 data. 
In the C Standard, "string" is defined a a null-terminated series of characters. I assume that is what the parent poster was referring to. 
From what I read about how a linker works, an object file begins with a list of symbols that define what they are and where they are in memory. So if I looked at an object file, and set a pointer to whatever is listed for the function's symbol, and jump to that pointer, can I incorporate that function into a program without having linked the object to my program?
You can handle "a sequence of characters" however you want, but when discussing C *string* the definition is **very** specific. For example, from the man page for strlen: "The strlen() function computes the length of the string s." and goes on to state "The strlen() function returns the number of characters that precede the terminating NUL character". The ISO standard explains this in detail. There is no reference in the ISO standard to any other definition of "string" what-so-ever. In the C language "string" means EXACTLY a character array that is null-terminated. 
Yes, no reference whatsoever, except of course for defining `string.h` as containing functions that take lengths and don't operate on null terminated strings, and the authors of the language referring to these as "string functions", and for the machine instructions used to implement them being referred to as string instructions. But yeah, it must be a complete mystery why that would be, because a string couldn't possibly be anything other than a null terminated string. 
Ahh, thank you for the link! Due to the font, I thought it was an 'L' not '!' :)
*memcpy* and family deal with sequences of bytes. *strcpy* and family also deal with C defined strings. The reference to "strings" in the mem man pages are lazy, stupid and create confusion. They should NOT be in the same library (but must be to be ISO compliant). Its dumb. Even worse is reference to these "sequences of bytes" as strings. They are NOT C-strings. Note that these man pages are NOT the ISO specification, the specification just says these functions should be contained in "string.h". Just because there are lazy programmers and document writers out there does not mean we should follow the confusion instead of clearing it up. &gt;"The C standard library is not a model of consistent design" &gt; – Keith Thompson. Edit: Just to clear - I was agreeing with you! It's a complete mystery! 
Do you know anywhere I could read up on this online, rather than a book?
Probably Ian Lance Taylor's essays on linkers.
Wow. Just browsed the B tutorial a bit. Weirdly interesting, and interestingly weird.
.so contains the machine code, the .o files are not used when linking to one. The runtime linking is between the executable and the .so files. a.out is just the default output filename for executables, it doesn't really mean anything and usually you'll pick another name with -o &lt;filename&gt;
You've pretty much described all of the logic you need to write in. It doesn't sound very complicated. Make a struct for the level, or use a file. `#define` a width and use that as a divisor to determine X,Y. Use modulo off rand() to determine which character you want to write out, but set a poison_count int that can't exceed POISON_MAX, and so on. Loop back through if the one is too much.
What have you written so far? You have to show some code so that we know what goes wrong.
Well the first paragraph sounds like he wants you to use command line arguments to pass your parameters but you are using scanf/getchar which is not allowed. I'm not sure about the second paragraph, I'd need to see the code he's talking about
Editing my post to include more code. I was actually wondering if it were possible my threads interact with the request queue in a bad way.
Local static variables are generally discouraged for the same reasons global variables are discouraged: they can easily create hidden dependencies between different parts of your program.
If you've been struggling all class, then you should have talked to your professor/teacher a few weeks ago, instead of waiting until the last second to reach out for help.
I hate to ask, but can I get an example that illustrates how this is bad? I personally don't use either, but I'd like a nice explanation that I could use to show people why to not.
For things like accessing a hardware device, or something else other than memory. Reading a register from a NIC, for instance, may yield different values for each read even though nothing in the current program changed any memory.
Is there a max size for an item? A max size for a request or response? Is this using tcp, udp, pipes or what? What is the protocol? The LRU could just be a circular buffer, but it would be more complicated with variable sized objects. Also how are you serializing the objects... is it binary or textual? Lot's of information needed. And I am unsure what you need help with specifically.
Also, you would have to devise a cache invalidation mechanism if the sever data is not static.
I just noticed I had misplaced the brace in thread_start() for the while loop that handles spurious wake ups. Is it better now? Also, could I get an example of a thread safe queue? Or get you to point out a few things that makes this queue not thread safe?
Oh yeah I forgot to implicate a size... 1024 bytes, also just to clarify I'm an applications developer and not a systems developer this is confusing to me. You're right about the invalidation mechanism as the thing I'm looking at mentions Design and implement a simple IR-based cache invalidation scheme for mobile environments by using CSIM20. In the IR-based technique, a base station (BS) broadcasts an invalidation report (IR) periodically (e.g. every L second). Then nodes can answer a query only after receiving the IR for validity check. It ensures a strong consistency but an unavoidable query delay (L/2 in average) is expected. The strong consistency guarantees accessing the most updated data items, but it increases the consistency maintenance cost. Note that we do not consider the updated IR (UIR) The specs it specifies are as follows: Number of clients -&gt; 100 ; Database size -&gt; 1000 items ; Data item size -&gt; 1024 bytes ; Broadcast interval (L) -&gt; 20 seconds ; Broadcast bandwidth -&gt; 10000 bits/s ; Cache size -&gt; 50 items ; Mean query generate time (Tquery) -&gt; 25s ; Broadcast window (w) -&gt; 10 intervals ; UIR replicate times (m-1) -&gt; 4 (5 - 1) ; Hot data items -&gt; 50 ; Cold data items -&gt; remainder of DB ; Hot data access prob. -&gt; 0.8 ; Mean update arrival time (Tupdate) -&gt; 100s ; Hot data update prob. -&gt; 0.33 I don't exactly need 100 clients I just wanna figure out how just 1 client can do this
I would add, with an L time of 10 seconds, and a bamdwidth limitation of 1 sec. You could set the tics at 1 sec and send 1/10th of the report. And on average, a client would then have a time of L/2 to find out if the item is invalidated Though, that is if my assumptions are correct.
Here's something I've seen in practice. Consider a function that returns a static buffer. const char * base36(unsigned long x) { static char buffer[64]; char *p = buffer + sizeof(buffer) - 1; *p-- = 0; while (x) { *p-- = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[x % 36]; x /= 36; } return p + 1; } It's convenient for the caller since it doesn't need to be tracked or freed. printf("base36 = %s\n", base36(1000)); So far so good. But someone might be tempted to use it like this: printf("%s != %s\n", base36(1000), base36(2000)); Oops! While I'm yapping, here's how I like to work around this particular problem, though it still involves a static variable: const char * base36(unsigned long x) { static unsigned i = 0; static char buffer[8][64]; char *p = buffer[i++ % 8] + sizeof(buffer) - 1; /* ... */ } 
For reading and writing memory-mapped hardware.
alright so the csim library is not necessary, arrays can be used. I think the only libraries to include are stdio.h and stdlib.h. 
I'm not going to code it for you. Come up with something and maybe I'll give you another pointer or two.
I'm not sure I follow. Before you write some code, I'd try and work out the higher level concepts. Which IR techniques have you read about? What does an object look like? 50 x 1024 is the minimum size, as that is the 50 count times 1024 byte max size of object. An int array of 50 x 1024 is sizeof(int)xs larger than necessary. Perhaps a struct array would be best. How do you mark invalidated cached objects, a separate list or metadata? What is the report data going to look like? Is the data unique, can you use some sort of hashing tables? How long is the tic going to be? How do you sync? struct Entry { int valid; // validation? int tic; // timestamp? uint64_t id; // hash of obj? unsigned char obj[1024]; }; struct Entry cache[50]; cache[i].valid = TRUE; cache[i].timestamp = this_tic; memcpy (&amp;cache[i].obj, object, 1024); cache[i].id = hash_obj (Object); // basic idea for searching cache // if missed request from server for (int i = 0; i &lt; 50; i++) { if (cache[i].id == id) if (cache[i].valid) // heres the entries address return &amp;cache[i]; } // cache missed return request (object); Lot's of stuff to be worked out.
OMG THANK YOU!!! You saved my life!
[See here](http://stackoverflow.com/a/2485177/1505939)
OK tldr; it works on read, but not guaranteed for writes 
For Linux some really strong GUI IDEs for C/C++ are [Codeblocks](http://www.codeblocks.org/), [Codelite](https://codelite.org/) and [Eclipse](https://eclipse.org/). If you're a beginner I'd recommend you not to start with an IDE like the ones I mentioned above but rather familiarize yourself with the compiler and the language structure first. You'll find that after you have become more comfortable with using the compiler through the command line, you could easily get used to using any IDE as well. Another thing is that technically you can turn Vim and Emacs into modern IDEs if you tweak them enough.
You can use something like a [tiling window manager](http://orig14.deviantart.net/a070/f/2015/051/8/9/windows_8_2015___custom_tiling_window_manager_by_math0ne-d8isqcr.png) to organize your tools into your own custom ide. 
Use autotools (or cmake if you really hate autotools) instead of any IDE's build system. With that, you don't absolutely need an IDE but could use a normal editor like vim or geany. Using an IDE is still helpful especially for larger projects, because it gives you better refactoring, code navigation, an integrated debugger GUI etc. I found that Netbeans works reasonably well with C/autotools projects, at least it isn't too bloated and doesn't get in the way too much.
I've used awesomewm before, I'm currently using xfce4. I don't want fancy shit, I just want it to work and be reliable. Do you have one you would recommend? I'm using tmux and it can split things up pretty nicely, but it's obviously not on the level of a wm
I tried this a few years ago, but it didn't play nice with autotools and therefore couldn't properly understand the code. I think it wanted to use its own IDE-style project or whatever (using Cmake, iirc). Do you know if it's still tightly coupled to a particular build system?
Vim with all the [bells and whistles](https://github.com/xmementoit/vim-ide). Let the flame wars begin.
I am going to go make some popcorn and watch this thread. Should be interesting. Also, yes, vim. With a trivial desktop like LXDE works just fine. Even more spartan for the true masocist would be TWM.
No, I'm not required to do so, but it was my starting point so I stuck with it. I've found the solution using 3 loops. Out of curiosity, how would you do it in 2? 
Not totally sure how to do this, but isn't the first for loop supposed to be &lt;=23 or &lt;24? Because &lt;23 will only get you to the 22nd index in the array, and you'll only have 23 elements total in the array because 23 won't actually be assigned a value. Edit: I am also pretty new to C.
Well first, it's generally bad practice to make a #define statement for a simple variable like that. Just declare it with the rest of your variables. Secondly, you're going to need to compare every value in the array to every other value in the array (except itself) and use a counter to see how many times you come across that value. Maybe you can use a separate integer array to store how many times each value is seen. So the value of the index of the number array would the number of times the value in the input array at that same index was seen. You'll need this kind of structure. I don't want to give the whole thing away, but try playing with this structure. for(i = 0; i &lt; 10; i++) { for(j = 0; j &lt; 10; j++) { if( j == i ) continue; } }
Not necessarily on reads either, non-volatile read may be reordered before a volatile read that was supposed to be protecting it
&gt; a "proper" IDE Most of the software you use was written by people using a programmer's editor like Vim.
I recommend looking into both Vim and Emacs.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int v1[ 10 ]; int i; int v2[ 10 ]; int j; int v3[ 10 ]; int k = 0; printf("Insert data\n"); for (i=0;i&lt;10;i++) { scanf("%d",&amp;v1[i]); } for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 10 ; j++) { if ( v1[ i ] == v1[ j ]); { v2[ k ] = v1[ i ]; } } } return 0; } This is what I've tried so far, I'll try to finish tomorrow
You want to define two integers, not two pointers to integers. A pointer by itself is useless, without something to actually point to. You then pass the address of those integers to your function, in effect creating temporary single-use pointers. 
min and max should be integers, not pointers to integers. Get rid of the `*`s. Then pass their addresses to the function (`&amp;`)
No need for nested loops. #include &lt;stdio.h&gt; #define ARRAY_LEN 24 int main(void) { int wm[] = { 0, 1, 2, 3, 4, 5 }, array[ARRAY_LEN], repetitions = ARRAY_LEN / (sizeof(wm) / sizeof(wm[0])), i; for (i = 0; i &lt; ARRAY_LEN; i++) array[i] = wm[i / repetitions]; return 0; } This program calculates the amount of repetitions by dividing the array length with the length of the wm array (sizeof(wm) / sizeof(wm[0])) means the size of wm divided by the size of the first element of wm. That way we can get the length. i / repetitions will return the desired index. The remainder is lost as we're dealing with ints. 0 / 4 = 0 1 / 4 = 0 etc... 4 / 4 = 1 5 / 4 = 1 etc... 8 / 4 = 2 9 / 4 = 2 and so on.
Idk, I'm not a fan of the "automagic" that comes with IDEs, hunting down an issue with auto generated code can be a nightmare, I have to use VS for work and the amount of time I spend dealing with nuget/VS specific issues is INSANE. I agree that IDEs have significant advantages, but I prefer to have more control than IDEs generally lend. I use Unix as an IDES for most personal projects I work on and I think it works incredibly well. There are command line tools for handling a lot of the things you're talking about
Using an ide does not require you to auto generate any code. 
I use /bin/cat
I use qtcreator
What does and IDE prevent you from doing? Nothing. What does having to manually chew through a dozen make files in mutiple dirs get you? How do you pass those to other devs? For educational purposes a shell/vim might work.. but of a project of any size you WANT to standardize and automate. 
Of course it doesn't prevent me from doing things. At the end of the day, an IDE is just a set of bundled development tools combined into one environment, UNIX fits that description, and I know many developers that use it as such. If you prefer not having to manually mess with things under the hood that's absolutely fine, but it's also fine to do it differently. And standardization and automation can absolutely be done via unix, I'm not sure if you've spent much time on the command line lately, but most of what you're criticizing isn't an actual issue for good unix developers
That's my point though, wouldn't it be better if companies only relied on universal build tools and didn't have to standardize IDEs, so that all developers could pick whatever IDE/editor they want, rather than being forced into a specific one?
This is not my experience. Any auto generated code I've seen in an ide is asked for not given by default. And in those cases it's generally pretty clear what it's doing and why. There is no magic. EDIT: What a bunch of kooks are on the c and cpp subreddits. Inventing shit to complain about and then avoiding any situation in which they might have to explain their kooky ideas.
That's not true, Visual Studio 2015 supports almost all of C99.
Are you telling me int N = 10; int arry[N]; won't work?
Geany is pretty lightweight and has enough features.
The webkit browser is in 25.1, but last I used it, was more proof-of-concept then anything really usable IMO
LaTeX, our lord and saviour. 
you could try atom editor.
dear god why.
Looks impressive by the TOC and rather readable when skimming thorugh. What are your further plans with it? Publishing? 
I don't think OP is Jens Gustedt of INRIA. OP is merely noting that his worthy project, which has been in development for quite a while (last big release came out two-ish years ago), is now in a state where the author is merely tweaking.
In minMax inside the if statements you forgot to dereference (a+count). It should be: if (*min &lt; *(a + count))
Use calloc, it'll be a fuck ton faster.
I dunno man, I'm just a cat person
"c" is different from 'c'. 'c' is a char; it works like a number, and it's what you want in this case. "c" works as an address to where the string itself is.
This only works if your compiler and your standard of choice has VLA support, which has some overhead and is not preferred in this situation.
didnt understand what you mean exacly, i need the " " so i can use the strings, ' ' is for 1 letter char for ascii use no?
your variable's name is `state`, not `state[10]`. it's type is `char[10]`, which is an array of 10 characters. What you want is a `const char *` (a pointer to a constant memory location containing the first of several characters). In other words, your variable declaration should be: const char *state; And any assignments should be changed to look like this: state = "composite number"; "Strings" in C are difficult stuff.
vim is great, and if you're sticking with unix, you'll do well to learn it. If you feel that you need an IDE, geany looks pretty nice to me, but I haven't really stressed it much yet. Some people like Code::Blocks, too. I'm afraid that nothing I've seen works as well out-of-the-box, or even after a few hours of plugin installation, as Visual Studio does on Windows :-(
I believe that the most important thing any new C programmer has to learn is to read and understand what the compiler tells them. In your case, what do you think these warnings are trying to tell you? $ gcc -Wall reddit.c reddit.c:10:13: warning: ordered comparison between pointer and integer ('int' and 'int *') if (*max&lt;(a+count)) ~~~~^~~~~~~~~~ [...snip...] reddit.c:29:16: warning: variable 'min' is uninitialized when used here [-Wuninitialized] maxMin(tarr,10,min,max); ^~~ reddit.c:27:47: note: initialize the variable 'min' to silence this warning int tarr[10]= {1,2,3,4,5,6,7,8,9,10},*max,*min; ^ = 0 
Ha! I subscribed this sub for 10min ago because after 15 years without C and just [this book ](https://hassanolity.files.wordpress.com/2013/11/the_c_programming_language_2.pdf) in my library, I wanted a new book for the new standards and found this awesome book. Thank you and congratulations for using LaTex, making reading much easier. 
&gt; So I'm on codeblocks, how can I turn on all the warnings? What compiler are you using, and do you know where to set the compiler options in your IDE? If it's gcc or clang, you may have to add -Wall, and -Wextra for even more warnings. &gt; how exactly do I initialize it? Your main function is passing two uninitialized (i.e. holding a random memory location) int * values to the minMax function. That isn't what you want at all. You want to have two int variables on the stack, and pass a pointer to those variables, so that minMax writes the values it calculates into those variables. Right now, it's writing them to a random location in memory, which is why your code crashes. The way to do this looks somewhat like this: int a[10] = {0,1,2,3,4,5,6,7,8,9}; int minVal, maxVal; minMax(a, 10, &amp;minVal, &amp;maxVal); With the &amp; operator, you pass the address of the variable (a pointer to the variable), instead of the value of it, to the function. The reverse of the &amp; operator is the * operator, which you use to get from the pointer to the value that it is pointing to.
hash map is good at word count
Indeed, I am not. I went through the draft of this book back in August and found it pretty useful for writing my C/C++ project at the time. I am just happy that it is reaching completion.
&gt; This problem is probably more appropriate for a different subreddit as this is an algorithmic and language independent problem, not specifically a C programming problem. Unless your problem is "how do I express this algorithm in C", because you haven't learned about structures and pointers yet. In which case this subreddit is probably still the wrong place, and a good book is the solution. It's hard to tell from the question, though, where the problem lies, but since OP says he's struggling with "create the graph", I assume the problem is too advanced for his skills? 
I don't want to sound rude but, man fix the English in that readme. If people can't understand what your project is about, you'll get no users and even less contributors. 
&gt; "Strings" in C are difficult stuff. They aren't really. In fact, they are very simple. A string is an array of characters terminated with a `\0` byte, string literals cannot be written to. That's all. No magic, no weird behaviour.
I'm just saying they are difficult for beginners. I see so many people on this subreddit who struggle with strings. Compare what you just described to an integer or even a float. You can just use it, and you don't need to know how it is laid out in memory, you don't need to know the difference between const or non-const, you don't need to know about pointers. My impression is that education doesn't go into enough detail for students to understand exactly what strings are, and as a result, we see all these variations on a theme come up here, day after day. 
&gt; be sure that every number appears one single time in this print. In this part of the question, what does "every number" mean? Can we have an example of inputs with expected outputs ? 
&gt; My impression is that education doesn't go into enough detail for students to understand exactly what strings are That's the real point, not that strings are difficult. If you remember what strings are and always visualize what actually happens when you perform operations on strings, it's super easy to work with them.
vim is overrated. If you want `vim` without all the feature creep, use `ed(1)`, as the prophets intended (incidentally, my IDE of choice).
&gt; Well first, it's generally bad practice to make a #define statement for a simple variable like that. This is wrong. It is very common in C to use `#define` where C++ would use `static const`. The former guarantees const propagation. Additionally, you should absolutely be using `#define` for things like array sizes since VLAs (arrays initialized using normal variables that may be determined at runtime) are generally considered bad practice (since it is all too easy to blow the stack) and are not supported by all compiler's. In fact VLAs are only an optional feature in C11.
But a backslash in front of the carets for this to work.
I have two words: fuck that. &gt; File and project management — ls, find, grep/ack, bash Oh *hell* no. That's neither integrated, nor suitable for development. It might be okay if you're working with a few dozen files, but anything larger is just impossible. My projects at work have on the order of 4000+ files just in one of the small builds. All the repos together have on the order of 100,000 files and around 1 million SLOC. `grep` and `find` are *not* suitable tools at that scale. Hell, they left out the single most valuable tool: `ctags` and family. Finding the definition and uses of a variable or function is, more than anything else, the most valuable feature an IDE can give me. I can live without autocompletion, I can live with miserable file and project management, but I cannot do my job without the ability to quickly navigate through code with a "go to definition" feature.
Ah, I didn't realize. The machines we use at my uni allow this sort of thing so I tend to use it. As well, no professors have made a point to make this kind of distinction. Thanks for the info! 
This author really doesn't have a very firm grasp on the word "*integrated*". Just because a *nix system has all the various components installed, doesn't mean they're at all integrated to work together out of the box. That's what an IDE is. It's a tool that pulls disparate components into a new tool that is greater than the sum of it's parts.
Okay, I'm sorry I really wasn't aware of how much information would be sufficient, so I just tried to explain the "context" so to say in the text. I did get in contact with a friend of mine, who was able to help me with my problem. I basically wasn't able to to add the last footballmatch in the round in the way i compared. If I'm going to post here again I'll remember to post more/all of my code for it to be understandable. I see it was a bit of a long shot :) 
&gt; Ah, I see I missed where that's described in one of the subsequent posts. The blog I posted is merely an introduction to the idea, not a step by step guide. &gt; For that matter, what happened to autocompletion [Autocomplete is built into vim](http://vim.wikia.com/wiki/Any_word_completion) &gt; In full disclosure, no I haven't... not to to this degree, anyway I think this is really the root of your thinking that unix is an inept tool for development, as I said to the OP using unix as a development enviroment has a very steep learning curve, being able to right complicated grep/find searches that will get you exactly what you're looking for takes practice and experience, but once you have that experience they are incredibly powerful tools. &gt; And I think that a traditional IDE scales much better I would argue the opposite, but since thats really just a matter of opinion, I suppose theres no point arguing it Everyone is entitled to their own development preferences and I do understand why so many people choose to use an IDE, I use one at work and its worked fairly well for me (once I installed a vim emulator into it), but left to my own devices I'd much prefer programming in a unix enviroment. That doesn't mean that Unix is better or worse than an IDE, it just means that thats what I prefer.
There is a typo in your first link. This works: https://raw.githubusercontent.com/junjiemars/kit/master/ul/setup-bash.sh Also want to comment on ul/.vimrc after seeing the commit about expandtab. If you have ftplugin, noexpandtab will be set if vim detects that you are editing a Makefile. See /usr/share/vim/vim*/ftplugin/make.vim. If not, you can do something like: if expand("%:t") ==# "Makefile" set noexpandtab else set expandtab endif
It seems that the book is getting some criticism on HN: https://news.ycombinator.com/item?id=13054705
here i get "error in reading characters of string" in locals and it prints me some wirde character in the run ╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠ int x = 0, i; const char *state[10]; printf("input number\n"); scanf("%d", &amp;x); for (i = 2; i &lt;= i / 2; i++){ if (x%i == 0){ state[10] = "composite"; break; } else state[10] = " prime"; } printf("%d is %s \n", x, state); 
Anything about use of C in current times will get criticism on HN. The hive there is out of touch of the needs of some specific niche, that are actually critical to either Internet, the web, high performance computing or media stacks. They are mostly web programmers who think that system programming consists in writing scripts to admin a server.
So why didn't you implement /u/ennorehling's suggestion and change the type of `state` to `const char*`? Note that `const char *[10]` (array of ten pointers to constant char) is not the same type as `const char*` (pointer to constant char). Also, your assignments state[10] = "composite"; state[10] = " prime"; Are still wrong. Arrays in C begin at index 0, so an array of ten elements has elements 0 to 9; element 10 is past the end of the array, assigning to it causes *undefined* behaviour.
If you find yourself frustrated with the feature-bloat of `/bin/cat`, there's always $ gcc -xc - &lt;&lt;'EOF' void main() { puts("hello world!\n"); } EOF
`calloc()` is an allocate and zero-initialize array function. Zeroing or NULL'ing member variables of structures allocated using said function isn't necessary. Cause that's the entire purpose of `calloc()` else only `malloc()` would exist. 
1. Fixed url's typo, thanks. 2. I'll commit the code about expandtab. Thanks. 
&gt; Alternatively, am I doing this in a convoluted way? Here's an alternative way to view iterating through a list. You remember how in Java, you can do an enhanced-for loop, or 'for each' loop? Try something like this... `for (ListNode *src = list-&gt;first; src != NULL; src = src-&gt;next)` Or better with shorter and more concise naming... `for (Node *src = list-&gt;head; src; src = src-&gt;next)` Now you can treat it kind of like an 'for each' loop. It works for lists of any size, too. As well, you can do something like this (although its up to style really)... for (Node *src = list-&gt;head, *dest = new_list-&gt;head; src; src = src-&gt;next, dest = dest-&gt;next) Of course you have to ensure that `dest-&gt;next` is setup inside of the loop if `src-&gt;next`. `new_list-&gt;first` should also be created above. Also, you don't have to compare `src != NULL` because if `src == NULL`, then it evaluates to false.
i tried adding const char and used [12], still the wired charcter and error reading character of string.
A constant is not a variable. Variables have an address and a value, constants are just that - a value. This sounds like an XY problem, so what is it you really want to do? 
an integer literal 
Why do you need to use `[12]`? That doesn't make any sense. You don't even need an array. Just use a pointer: const char *state; ... state = "composite";
Thank you! Yes I meant this question to be an entirely C question. As in, when I am writing C code (not C++), should I be using strictly a C compiler/extension or is it OK to write pure C from within CPP files and a CPP compiler. The emphasis is on C here as that is my main focus right now.
&gt;edit distance between two words must be 1 and the words must be the same length. I didn't know what edit distance mean, but when I searched, discovered that Hamming Distance is the right one since I can only substitute letters, not add or remove. &gt; If the distance is 1, then they share a graph edge. Ok, so this was my problem: identifying witch words shared a edge in the graph, explained myself wrong... But in my problem i can substitute more that one letter at a time, it just costs more (n² , being n the number of letter i substitute). So for example abuse -&gt; above costs 4. Doesn't this mean abuse and above share an edge also? Also, thanks for your answer, this help me a lot. 
Now I know this is definitely the wrong subreddit. I learned pointers and structures already. This shouldn't be too advanced since it's a final project. I just couldn't figure it out witch words should share an edge in the graph. And also, thanks for your answer.
I now have the arrays sorted but I don't know where to go from here 
Try to visualize the problem by writing down what the arrays may look like and trace how the indices should move with your fingers. Re-read my previous comment to understand what I want you to implement.
The arrays might look like: array1: e1 e1 e1 e1 e2 e2 e3 e3 e4 e4 e5 e6 e7 e8 e9 array2: e1 e1 e1 e2 e3 e4 e4 e4 e4 e5 e5 e6 e7 I know how to iterate through them, but I don't know to iterate through them with seperate counters at the same time, and I don't know how to pause the iteration of the first array in case array2 has less elements. I also don't know how to count the number of times one element appears in one of the arrays. Thanks for being so patient by the way.
&gt; I don't know to iterate through them with seperate counters at the same time Use a loop that looks like this: size_t i1, i2; for (;;) { /* infinite loop */ if (i1 needs to be incremented) { i1++; process array1[i1]; } if (i2 needs to be incremented) { i2++; process array2[i2]; } if (neither counter was incremented) break; } &gt; I don't know how to pause the iteration of the first array in case array2 has less elements. If `array2` has ended, you won't increment the counter for `array2` anymore. Same for `array1`. Thus, eventually both counters won't increment anymore, causing the loop to terminate. &gt; I also don't know how to count the number of times one element appears in one of the arrays. All elements of the same type are in adjacent indices. Count how often you can increment the index without reaching a different element to find out how often that element occurs.
I am sorry for being so dense, but I am very confused right now, this is what I got from your comment: size_t j, k; for (;;){ /* infinite loop */ if (hometeam_victorious[j] == awayteam_victorious[k]){ j++; process hometeam_victorious[j]; } if (hometeam_victorious[j] == awayteam_victorious[k]){ k++; process awayteam_victorious[k]; } // If none of them incrimented they must have the same value if (j == k) break; } I don't really know what you mean by process the array. I figured the variables need to be incrimented as long as they are of the same type, and if they aren't incrimented j must have the same value as k.
&gt; hometeam_victorious[j] == awayteam_victorious[k] Don't use `==` to compare strings. Use `strcmp` from `string.h`. Read the documentation for how to use that function. &gt; I don't really know what you mean by process the array. “Process” means “do whatever you need to do with that array entry.” Note that I want you to process `array1[i1]` (i.e. one array entry), not the whole array `array1`. &gt; I figured the variables need to be incrimented as long as they are of the same type That's not correct. Remember what I wrote in my previous comment: &gt; You use two counters, one for each array. Basically, the idea is to make both counters be at the same group of elements at the same time. You always increment the counter that points to the lexically lower element. If both counters point to the same kind of element, then you have found a group of elements present in both arrays. Think about what that means with respect to which counter you want to increment. Lexical ordering (i.e. dictionary order) is the ordering determined by `strcmp`. If `strcmp(foo, bar)` returns a negative value, then `foo` is lexically lower than `bar`. &gt; If none of them incrimented they must have the same value That's not right. What makes you think that's the case? The specific values of `j` and `k` do not really matter and are more of a red herring. Try to think about this and find a solution. If you still can't, I can try to give you more specific hints.
Figured it out
You're almost there. Some things you have missed: * You always seem to increment the index of the array with the *larger* entry. This is just the wrong way round. Read my comment from before again. * If both entries have the same value, you have reached a goup of entries that is present in both arrays. You aren't done yet: Now you need to count how many entries there are of this kind in both arrays (this is what I meant with *processing*) and store the result (because that's what you are interested in if I understood your problem correctly) * You still need to check if you reached the end of either array and think about how to deal with that scenario.
I think I need to explain the assignment a little more. I need to find the teams that win more games when their don't have the home field advantage. So I need to count if teamA appears more in awayteam_victorious and if it does it has to be saved in another array, which I still have no idea how to do. When I reach the end of awayteam_victorious, the loop should stop I guess.
That list of differences is from 2001... Lots more that can be added to it these days since C had a standards update and C++ something like 3 since then. 
So this will end up being "Writing C software using *your own* standard library". Seems fun though.
Please don't send screenshots of text. Instead, use a paste service of choice. So, to dissolve the tension, let me give you pseudocode for the algorithm I meant: j = 0; k = 0; while (neither j nor k have reached the end of their arrays) { compare hometeam_victorious[j] with awayteam_victorious[k]. if (both are equal) { j++; k++; } else if (hometeam_victorious[j] is larger) { add awayteam_victorious[k] to the output list; increment k until awateam_victorius[k] changes; } else /* awayteam_victorious[k] is larger */ { j++: } } if (k has not yet reached the end of awayteam_victorius) { add all remaining entries in awayteam_victorius to the output list; }
The “heap” in memory management is unrelated to the datastructure called “heap.” That said, the main use of heaps is to implement *priority queues,* which is an abstract datastructure used wherever you have a number of tasks and you want to find the best order to execute them in.
This is almost complete. You forgot this part: &gt; increment k until awayteam_victorius[k] changes; If you don't do this, then teams my be added multiple times to the lists. Note further that you need to allocate memory for the string before you can use `strcpy`. You might want to use `strdup` instead.
I'm not sure how to do the increment k until awayteam_victorius[k] changes; part.
Heap the data structure has multiple use cases. Here is an example. Say you are reading a file with millions of lines. You want to find the longest 1000 lines efficiently in terms of both speed and space. Heap would be a convenient choice here. Heap is also the basis of heapsort. Heapsort is practically slower than quicksort/mergesort, but it has a nice property of only using O(1) working space. Sometimes, we combine heapsort and quicksort to avoid worse-case performance of quicksort.
Completely agree. It is too interesting to stop reading and it provided great insight into how the author thought through these problems and did his research.
You should write C programs in .c and compile with a C compiler. It is a plus if you can compile your .c files also with a C++ compiler. As to why, here is my story. I developed a C library 7 years ago. Most Windows developers complained they could not compile because VC++ only supported C89, while my library used some C99 features. Changing to C89 involves a lot of works. The relatively easy solution was actually to make all .c files compilable in the C++ mode. VC++ has improved, but even nowadays, I believe VC++ still recommends to compile .c files with its C++ compiler as it is more feature complete. Another scenario where compiling .c files with C++ compilers is when C++ users copy paste your C code into their C++ programs. This has happened several times to me. In practice, it is not hard to make you .c files compiled with C++ compilers. The top two issues are: 1) don't use C++ keywords and 2) explicitly cast void pointers. You may use -Wc++-compat and compile with make CC=g++ from time to time. These are minor annoyances, but may help some of your users.
You could use the regular struct that contains the next value etc. , I don't see any problems with that
When writing UTF-8 applications, always deal with strings, never individual characters. So instead of `putchar('╭')` write `printf("%s", "╭")` and everything should be fine. Of course you also need to make sure that your source code is UTF-8 encoded.
Let's back up a bit. All a pointer is, is a token to represent another value. Sometimes it's because the real value is too cumbersome to manipulate directly, sometimes it's so that you can have multiple tokens to represent the same value, and sometimes it's because the location of the real value isn't known soon enough. There are other uses, but these are very common. Let's look at the first case: representing large values. Imagine copying a very large file, say 1GB. That can take a very long time. But, if you only copy a *pointer* to the file (a shortcut, in Windows terminology), it's very fast. In code, copying large blocks of memory -- large strings, images, audio clips, etc. -- can take a long time, whereas copying a pointer to the data is much faster. Let's look at the second case: multiple pointers pointing the same object. Consider a file URL. There's a file on a server that several people need access to, and any one can change that file. The URL is essentially a pointer -- if you update the file (change what the pointer points to), everyone else will automatically be able to see that change. Without the "pointer" (URL), you or someone would have to know every copy to update, and whether it is OK to update it. Many computer data structures work the same way. One piece of code can modify data without having to worry about how many other pieces of code (the number may vary frequently) are using it. Let's look at the third case: not knowing soon enough where the real value is. This is likely the most common use in C. Most values you'll see in C are on "the stack", which grows and shrinks every time you enter a function or declare a variable. If you have an `int i` declared in function `foo`, it can't be seen (at compile time) from another function `bar`. If you want `foo` to call `bar` to change the value of `i`, then you have to tell `bar` where in memory `i` is located. That has to be done by a pointer, unless all variables are global, but that is a horrible mess. 
[removed]
I agree that they are not the same thing, but many memory allocation algorithms use a heap data structure as a mean to sort the free nodes by size, so that policies such as best fit or worst fit can be applied.
Just a thought, I can store my C code in a .cpp file and run a C compiler over it, and store my CPP code in a .c file, and run a CPP compiler over it. The extensions are only for you, just keep that in mind.
You can get NULL for any of the reasons in the fopen man page... the most common would probably be that you don't have permission to open the file, or there's no space on the disk.
That character is 3 bytes in UTF-8: `"\xE2\x95\xAD"`. It won't fit in a single `char`. 
It would be interesting to see this on a Pi 
 - portability: "standard" libraries do not necessarily behave the same on all platforms - smaller and possibly leaner/faster executables, without overhead - Learning experience! "Black boxes" are not good when you want to learn *everything*. The standard library is such a black box. By bypassing it, you learn what it actually does, apart from what it says on the tin.
It would be little awkward but something like struct that contains the value and the same struct. Struct{name; struct;};
I think OP means the exam is to be done on paper, as opposed to on a computer
Note that a structure cannot contain itself. A structure is a bundle of objects, it's size is the sum of all objects it contains plus some padding. If you tried to have a structure member of the same type as the surrounding structure, that would be like trying to put a crate into itself, and would result in an infinitely large structure, which is obviously not possible.
Yup.
If we're taking about normal stuff like Input/Output, loops, functions, files etc, my advice would be to write your c exercise as normal but to never compile it as you are programming instead try to imagine what the output would be. When you think you are done compile it and see if the output it's what you expected. Good luck!
You're welcome, and I'm glad you asked. It took me a bit to understand pointers. 
If you don't want define a variable and need a pointer to an object with a constant value and automatic extent, then since C99 you can use compound array literals such as int *p = (int []) { 5 };
Practice. Write your next homework on paper first and then see how close it is when you build it for real. Look where you went wrong and then keep track of that for next assignment. 
&gt; As a result, the conclusion for using pointers would be just historical reasons wtf
Read a book on C?
If fopen fails for whatever reason, it returns NULL. This can be failure to allocate memory, failure to open existing file or failure to create a new file. After all, you can't assume the creation of a file will always succeed (lack of permissions, drive full, read-only media, the OS having a fit, etc.).
There are many good comments already. I think you mean output of compiled code rather than compile on paper. When taking coding exams, they usually have you write high level code and/or predict the output but not "compile" code. Semantics but good to know the terminology. I suggest to write more small/simple code snippets and compile them. See what they do. Practice will show you what code "works" and how it behaves. Usually on exams, they want to know you can think logically even if your syntax isn't 100% correct and they usually want to see that you can think of code that handles inputs and have correct outputs and what would possibly break code. I'd say while taking the exam you should keep the code you write as simple as possible so that you can use logic to predict an expected output. Even if it isn't 100% it'll be easier to get partial credit if you write comments to explain your code and explain your answer. Good luck!
Am I the only one who is excited to not only read a nice article but also that it is just plain old text file?
Please put four blanks in front of every line of code or upload the code to a paste service of choice, otherwise it's not readable and might be garbled.
&gt; That's simply not true! There is a great amount of situations where the caller &gt; does not readily know how large the memory region is, for example, consider strdup. strdup duplicates a string. First it needs to know its length with strlen. So in this case, the caller known the length with strlen.
&gt; That's simply not true! There is a great amount of situations where the caller &gt; does not readily know how large the memory region is, for example, consider strdup. strdup duplicates a string. First it needs to know its length with strlen. So in this case, the caller known the length with strlen.
Here is a pastebin link that might be more readable: http://pastebin.com/Ai3hqAdA
Thank you. I'll get back to you in an hour.
alright.
Title sounds like clickbait...
I could have probably better titled points 3 and 4. They are somewhat related. My point was to illustrate that a switch statement is just a generic compound statement where the case values act as goto labels, and if you can see it in that way, you can better understand it's quirks.
Have you figured it out? 
I think I'll have to make a new pastebin for you then. 
TL;DR: the article is more factually accurate than not, but fails to make a lot of particularly interesting points. The author appears to suggest that the `switch` construct is not particularly valuable, but doesn't provide what I feel to be compelling evidence to support these claims. Below are my responses to the article on a point-by-point basis. Note that I am using [ISO/IEC 9899:TC2](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf) as my source for any claims about the specification. The OP did not include any reference materials, for the record. # 1. The minimum number of cases a compiler must permit is 256. The minimum is actually higher. From the spec, section 5.2.4.1: &gt; The implementation shall be able to translate and execute at least one program that contains at least one instance of every one of the following limits:... 1023 case labels for a switch statement (excluding those for any nested switch statements). # 2. You can declare local storage by following the switch’s open curly brace with a declaration. I don't see any reason why this is helpful. If you are using an implementation of C that requires that variable declarations appear at the beginning of a new scope and you need local storage for an `if/else` block, you can simply wrap that block with curly braces. If you're not using such an implementation, then no scope is necessary. # 3. Execution starts at the matching case and continues until a break or curly. The point about execution not occurring in the normal fashion is interesting, especially when considering the fact that a new local variable will not be assigned (`int b = a`). This is backed up very concretely the spec in section 6.8.4.2.2: &gt; A switch statement causes control to jump to, into, or past the statement that is the switch body, depending on the value of a controlling expression, and on the presence of a default label and the values of any case labels on or in the switch body. # 4. The default case can appear anywhere in the list of cases. Also backed up by the spec, section 6.8.4.2.3: &gt; There may be at most one default label in a switch statement. There is no discussion elsewhere about the placement of the `default` label within the `switch` body. # 5. The switch statement is almost never used as originally intended. This seems like a really awfully stated point. The article in general, and this point in particular, reads as if the author is essentially saying that the `switch` statement should not be used, though I find that they are extremely useful for a few reasons: 1. They use a single selection statement. When I read a switch statement, I know for a fact that only one thing is being evaluated. With `if/else if/else`, there are as many selection statements as there are `if` statements, and there is no guarantee that the selection statements consider the same things. This can lead to subtle bugs. 2. Though the `switch` and `if/else if/else` constructs offer the same semantics, I find that `switch` statements are often substantially easier to read, specifically when dealing with `enum`s. 3. Though the author quotes the statistic that &gt; [Peter Van Der Linden] further analyzed the Sun C compiler to see how often fall-through was used. Of 244 switch statements, each with 7 cases on average, fall-through occurred in 3% of cases I am extremely wary of this statistic, and of its value to the discussion at hand. First off, different programs will make very different use of the `switch` statement. If the codebase analyzed had little need for the fall-through feature, that doesn't mean that other codebases don't-- those codebases could be in an entirely different domain from the analyzed codebase. Given the extremely wide range of applications for C, it's hard to overstate this point-- the particular applications examined is extremely important when considering how well-used the feature is. Second, we hadn't ought to evaluate the value that the `switch` construct provides with respect only to its "original intent". Regardless of whether the fall-through feature is well-used, there are other ways that the construct offers value to a codebase, and those appear to be completely ignored by this article.
Hey Thank you for you comment i did understand all what you say so i'll correct it and send it back , and thank you for you comment :D .
Any updates my dude?
The main benefit in my opinion is readability. It helps keep large handler functions neat. Getopt for instance, or a query for a large lookup table. 
Thanks for this. I don't think I've ever used calloc in such a fashion but didn't know about this characteristic of null pointers. 
No it was a temporary, as this is an assignment I don't want to be busted for plagirism because i pasted part of the program into pase bin. Here is a new paste bin http://pastebin.com/LSgd0805
I see. Though, please do me a favour and don't delete your post. I absolutely hate that as a deleted post means that I did work nobody can profit off in the future. And also, please do not change all your comments to "Figured it out." How are future readers supposed to understand what we talked about if they have the same issue? Please be considerate. I am at the brink of stopping to help you because you immediately erase my work after profiting from it.
The code in this paste bin doesn't compile, it seems to be incomplete. What is your question about that code? I don't recall and you have since erased your comment about it.
Can you provide an example of this?
Author here. One of the advantages of writing about programming is not only to spread knowledge, but to learn from feedback when I misrepresent something. You're not the only one to criticize me about the indirect suggestion the switch statement has no particular value. I meant to provoke the reader to think why he is choosing to use a switch statement, but not send a strong signal that there is no use. Clearly I did. The true intent of the article was to list some odd facts and quirky behaviors, but it was lost in the overtone. To that end, I've made some edits that hopefully tone down any questioning of the switch's value, and instead focus on the list provided in the article. Thanks again.
The solution can be sudo-code on a whiteboard or even explained verbally. The understanding of CPU and RAM utilization along with what the compiler is going to generate is more important than seeing that someone has memorized C syntax and can write it free-hand without an IDE or help from Google &amp; Stack Overflow.
Switch(a){case 1:; int a;}
I am alrdy reading C book,this kind question required more MAtrial
Your push function just stores the address it's passed, instead of copying the string. You pass it the address of the same chunk of memory each time you call it. Every element of the stack thus points to the same string. (Lots of other issues too).
For anybody wondering, a (case) label identifies a statement, for instance the empty statement. A declaration is not a statement so you cannot label and `goto` or `switch` to one, but since C99 you can mix declarations and statements to achieve the same effect like the example.
When allocating a pointer-to-pointer array you should specify that the storage needed will be of sizeof(char *) length (since it's char pointers that will be stored on the stack). Also, you have forgotten to use 'maxSize' in that malloc call. So, change: s-&gt;item=(char**)malloc(sizeof(char)*5); //To create the flexible array into s-&gt;item=(char**)malloc(sizeof(char *)*maxSize); //To create the flexible array Side note: You should Not cast return values from malloc functions. Read this: http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc
Pay attention to the ; after the : bit before the declaration; I'm quite sure this trick make it work in pre-c99 but I'm not 100% sure
Thank you for you comment , i did correct the code now. thank again for your advice
If your system has it, the non standard strdup() function is the easy way. Otherwise something like: size_t len = strlen(orig) + 1; char *copy = malloc(len); // No cast! if (copy) { memcpy(copy, orig, len); } else { // Handle the error case of malloc failing } 
Thank you for the advice!
Do you really want to push a string onto the stack, or do you want to push a pointer to a string? The last one would be far easier. Pushing strings of variable length onto the stack doesn't sound like a good idea at all.
1. As /u/SoraFirestorm said, you're asking strangers to do your homework for you. This is not likely to happen, and your teacher is likely to see that you're asking. 2. This isn't the right sub for C#, it's for C. 
Iterate through _todolist_ with for loop and print the current element.
But like rolling your own crypto, it's a good leaning experience, but you probably shouldn't use it in production unless you really know what you're doing.
&gt; If your system has it, the non standard strdup() function is the easy way. 
Generally when somebody's talking about adding a string to a data structure you can assume they mean they're working with a pointer. Especially when it's a beginner.
(First of all, don't cast the value returned from malloc. It's a dangerous practice) `sizeof(buffer)` tells you the size of buffer, not the size of what buffer is pointing to. buffer is a pointer, which is 8 bytes in size on a 64-bit architecture, which is why it prints out 8. It is not possible in C to determine how big an object in memory is. If you need that information for some reason, you must keep track of it yourself in a separate variable.
Ok, great. And could you expand on why you shouldn't cast the return of malloc? Does this apply to calloc as well? Because I can use malloc without the cast, but if I try changing to use buffer = calloc(4*BUFFER_LEN,sizeof(float); I get an error without the (float*)
You shouldn't cast either malloc or calloc. Casting can hide the fact that you forgot to include stdlib.h. For instance, if you have: int *x = (int *)malloc(sizeof *x); *x = 5; If you've forgotten to include stdlib.h, then the compiler doesn't know the return type of malloc. Due to C's long (and sometimes bad) history, the compiler will introduce a default prototype for malloc with a return type of int. On a 64-bit architecture, int might be only 32 bits, but malloc was returning a 64-bit value. It's possible (depending on the platform, compiler, etc.) that the cast will cause the top 32 bits to not get assigned, and thus the variable x has a bad value which will lead to bad things. If you leave out the cast, compilation will fail with an error if you've forgotten to include stdlib.h. (Plus it looks better, I think)
What's the error?
Without looking too deep into your code i would say put all your globals in a context struct, and use it in every call. .. also the two space indentation looks weird to me, but that's a personal preference.
Minor point: s = malloc( sizeof( Stack ) ); Is better written: s = malloc( sizeof *s ); Also, `sizeof( char )` is always 1 
Are you writing C or C++?
You can disassemble an executable with a debugger (like gdb), but it'll still be quite the task to reverse engineer it unless it's a really simple program.
Oh, C++ works a bit differently than C does here. C++ requires a cast on malloc and calloc. C++ programmers will often tell you not to use malloc/calloc at all and rely solely on `new` to allocate objects in the heap.
You'll never get the original code, because it's compiled into assembly and then assembled into actual CPU instruction opcodes. People have attempted to create decompilers, but they are far from perfect. The closest you can get is a disassembler, which will show you the raw assembly code for an executable.
This doesn't look right. The inner loop will only iterate once, because then i will be == n, and the outer loop will loop until z == n, but the inner loop will no longer do anything. Also, this could be optimized by having the outer loop only loop as long as there's any sorting still happening in the inner loop (ie: if the comparison is never true and a swap never occurs, the sort is complete).
Something else to be aware of is that almost every modern compiler will make many optimizations when compiling code. So even if you manage to convert the assembly you see back into C code, it will likely look very different than how it was originally written, even if it is functionally equivalent. As others have stated there's no way to get the original source code (you could try contacting the creator though?). 
Maybe google for C projects of the game. I had a quick look and found some results. It would be **much** simpler. I am assuming you want to do this to get a sens of how its coded/structured. Do that with a project where you can see how it was written with comets and sensible variables names. 
The obfuscated c-code contests are my favorite thing about this language. So hilarious and clever!
No. There's nothing left.
&gt; non standard strdup() strdup() conforms to SVr4, 4.3BSD, POSIX.1-2001. These are standards, although they are not the ISO C standards. Just clarifying.
Thanks!
We are all out of C, may I interest you in some Java?
Thanks for the help :)
no need to spend money but thanks anway :)
If you cast the return value of `malloc` and you don't `#include &lt;stdio.h&gt;`, you can mask a potential error in the casting of an `int` (what the complier assumes `malloc` returns in the absence of `stdio.h`) to a `float *` (in this case). The compiler sees a cast and assumes you know what you're doing and doesn't warn you and then casts on a flawed assumption. So it's an unnecessary and, occasionally, dangerous habit that might be hard to debug when it happens. So it's better to *not* cast and risk receiving a warning (only when you don't `#include &lt;stdio.h&gt;`) along the lines of: "assignment of pointer from integer lacks a cast". That's your cue to `#include &lt;stdio.h&gt;` and I'm sure I've seen modern compilers that actually include that suggestion since it's a common mistake.
divide by 10 in base 10 and your number loses a place. The char array whose most significant digit gets lopped off, is filled with the first of the least significant numbers. 100 / 10 = 10 10 % 10 = 0 and the first value of the char array is now not needed, so array[0] = '0'; // least significant digit
The OP uses a C++ compiler (see his other comments) so in his case he *must* cast or the compiler will throw an error.
Lol. Oh well. Over to a `cpp_*` subreddit he can go! :-) 
In the do { } while () loop: line 9: (n % 10) gives you the remainder of n divided by 10. which is the last digit of the number. line 11: n /= 10 is equivalent to (n = n / 10), meaning, n gets its last digit chopped off. And the loop continutes if n&gt;0. (The sign is handled separately, so n will always be greater than zero or zero here. so on each iteration of the do {} while () loop, you are: - put the last digit at the end of s. - chop off the last digit from the number Since you are starting at the last digit and working your way up, you need to reverse the digits at the end to get them in the order we expect them.
Thanks alot.
&gt; Without looking too deep into your code i would say put all your globals in a context struct, and use it in every call. .. also the two space indentation looks weird to me, but that's a personal preference. There are two instances of global structures =text= and =Catch=, are the same for all functions, must be initialized in the main function (regexp3). If they were local, each function would need two extra parameters &gt; two space indentation looks weird to me, but that's a personal preference Four spaces seems excessive, I guess 4 spaces are due to visual problems,Or insecure
It's a shame that this trick has to be used in the c language... I imagine with some careful consideration, it could be avoided entirely. 
If you don't have the stl, you almost certainly don't have a kernel...
he doesnt explain very well, and we only got to graphics like in the last hour of the last class.
You'll get much more help if you at least give us what you've tried so far. As it is, it looks like you're asking us to do your homework for you. Especially when you start talking about graphics, you really need to say what library you're using to display, as there are a few different ones it could be and your professor probably wants a specific one. What I will say is, for that second one, you need to use the tolower() and toupper() functions while iterating along the given string. 
This subreddit is about programming in C, not C#. I have removed your submission as it is off topic.
Don't ask if you can ask, just ask your question directly.
&gt; can anyone help me with segmentation fault for C programming? Yep, probably. If you provide your code and what you've done so far to track down the issue, somebody might be willing to take a look
MVC might help. Create an internal model. Create the view or display. And create an interface between the two. Each of these steps would need to be broken down as well. But it's a start. A text interface may be the controller, as am I'm sure there is some annotations for those games. So it could act as a game viewer as well.
K&amp;R describes all language features with simple programs. Actually, most part of good programming books include example programs in some way. As another example you can try buildyourownlisp.com
It took me several years from my first look at C to my first independently tackled and solved (larger) problem. I had some precognition from graphical kid's programming but as for you, C was my first "real" programming language. *By programming you become a programmer.* Literally. If you want to split a problem into smaller ones, try to think this way: * 1. "What do I need to solve my problem" * 2. "How can I implement this." * 3. make it you new problem and go to 1 For example for Reversi an answer to 1 could be "Draw a board and place disks on specific coordinates".
This subreddit isn't going to do your homework for you.
I'm in a similar position to you OP. I am also a new to coding in general, (I had a little experience making basic programs on my TI84) and C is the first programming language I've learned more about. I just made a 2 player tic tac toe game and the code isn't very pretty, but it works fine. I can probably help you out if you need any help, making an Othello game sounds like a fun challenge! Right now I'm thinking that 2D arrays will probably have to be used.
you're not obligated to help so leave...
What if you want to care adjustments IERS or similar publish, is there a good reference to integrate in my program?
&gt; MVC might help MVC tends to work quite badly for games. Games tend to use a pipeline structure. It's quite hard to fit a game, even a simple one, into MVC. The OP might end up frustrated. Still, as it's a turn based game, it might just about work.
Have a look at [Handmade Hero](https://www.youtube.com/user/handmadeheroarchive). It shows the entire development of a real world program developed from scratch.
Google Schaums Guide to C Programming - its a free pdf and really in depth and easy to use. Good luck!
Biggest thing for me was learning how to effectively us git and build iteratively. Get something working, commit it, then add a new feature. The hardest thing for me in moving from toy projects to real world ones was trying to code too much in one go, and then having to wade through a ton of bugs to find my one mistake.
Is there a question here somewhere?
I'm going to guess that the purpose of the assignment is to implement a clone of Reversi. You've probably got some sort of assignment sheet telling you some requirements for that program and for your grade you need to implement those requirements. The .EXE is probably only there as a reference implementation. That is, it's something to check your code against to see if your code is doing the right thing. You *should not* be trying to disassemble the code, because for anything decently complicated (as in more than Hello World) it will start getting very nightmarish very quickly. Someone of your skill level should not be worrying about calling conventions and registers and stuff like that *quite* yet. Just do the assignment, and make sure the program you've created acts the same as the given EXE.
Feel free to give it a try. If you get stuck anywhere I'd be happy to help.
Don't forget to flush the stdin buffer. On Windows `fflush(stdin);` does the job, but thats not ISO conform. A portable solution would be: while ((c = getchar()) != '\n' &amp;&amp; c != EOF); A small working example could look like this: #include &lt;stdio.h&gt; int main() { while (1) { // The game lives here. // restart query: printf("Do you want to build a snowman? y/n: "); char c = getchar(); // read a single character if (c == 'n') { // no printf("ok, bye :(\n"); break; } else if (c == 'y') { // yes printf("yay :D \n"); } else { // wrong input printf("wat.\n"); // (should do something more useful) } // discard the remaining input while ((c = getchar()) != '\n' &amp;&amp; c != EOF); } return 0; }
Good point, will take a look.
This is one of the most important things when it comes to building the "programmer" mindset -- being able to generate your own list of comprehensive questions about a system, and answering them with code.
Find beginning of the word (this is first letter of the string that is non-space, or a letter following a space). Call toupper on it (from &lt;ctype.h&gt; or &lt;cctype&gt;). Toupper just checks if a character is lowercase in range 'a'..'z' and changes it to 'A'..'Z'. All the following letters to a non-letter, or to the end of string, call tolower on them.
Break it down into mathematical chunks.
I'm no math genius so I'd have to get out a piece of paper and work it out step by step (and hope floating point precision didn't screw anything up). Off-topic, who writes braces like that?! OP, please don't copy this 'style'.
I see one obvious problem in main.c - see [this question on StackOverflow](http://stackoverflow.com/q/5431941/253056) for all the gory details.
&gt; Off-topic, who writes braces like that?! Probably just to save some space on the paper.
Question is how to solve that quickly? Because doing 55 loops is fatal.
Is the error message printed by one of your `perror()` calls? FILE *in = fopen(inName, READMODE), *tmp; /* ... */ if(!in || !(tmp = fopen(tmpName, WRITEMODE)) || errno) { perror(MSG_PERROR); return errno; } The problem with testing `errno` this way is that it may be set by any of the 2 `fopen()` (or any such function called earlier) despite the `fopen()` having both succeeded. So we cannot know if `perror()` will show a real error or not. You should: 1. Test the return value of the function call right after it is called (no other system call in between). Does it indicate an error? 2. Test `errno` if needed. 3. Print an error message with `perror()`. Maybe adding a more specific error message rather than always just `MSG_PERROR` would help seeing where the error happened. Like: . if(!in) { perror(MSG_PERROR " opening inName for reading in p_addFn(): "); return errno; } if(!(tmp = fopen(tmpName, WRITEMODE)) { perror(MSG_PERROR " opening tmpName for writing in p_addFn(): "); return errno; } (you might want to build more dynamic error message with the filename, too)
Start with the innermost loop: `a` is reset to 1 at the beginning of the loop, moreover a+=a*l; gives us a recurrence relation for the values of `a` in terms of the iteration number 'l'. We know on each iteration that a(l+1)=a(l)+a(l)*l &lt;=&gt; a(l+1)=(l+1)*a(l) And that a(0)=1 At once we recognize that a(l)=l! [l factorial] Now g is a bit harder because it doesn't get reset at the start of the loop so it depends on both 'k' and 'l': We write `g(k,l)` for the value of `g` at the k-th iteration of the outer loop and l-th of the inner one. We have that: g(k,l+1)=g(k,l)+k+(m-k)/a(l+1) But we know that a(l)=l! Therefore g(k,l+1)=g(k,l)+k+(m-k)/(l+1)! By summation (from l=0 to l=k) the value of g at the end of the inner loop is: g(k,k+1)=g(k,0)+k*k+(m-k)*(1/1!+...+1/(k+1)!) Now right after the innermost `for` we have: (a--)+(++g); g++; Both statements are expressions with side effects whose result isn't used anywhere, so we should focus only on the side effects: a gets decreased by 1, g is increased by 2. Therefore `a` is `(k+1)!-1`. A number that will always be &gt;=0 so the `do while` loop always executes once. Now we know the value of g(k+1,0)=g(k,k+1)+2=g(k,0)+k*k+2+(m-k)*(1/1!+...+1/(k+1)!) So we have the recurrence: g(k+1,0)=g(k,0)+k*k+2+(m-k)*(1/1!+...+1/(k+1)!) We can find the value of g(m+1,0), once again by summation. This time from k=0 to k=m : g(m+1,0)=g(0,0)+(m*(2*m+1)*(m+1))/6+2*(m+1)+(Sum from k=0 to m of (m-k)*(1/1!+...+1/(K+1)!)) So `g` at the end of the day is the expression on the RHS: [pretty latex version](http://latex2png.com/output//latex_dadd74ea784a26d79cb95633c3e54ac5.png). I have no clue how to easily compute that sum, maybe some else has an answer. And also i don't see what this has to do at all with programming/C, it is mostly math.
Did you look in the "Resources" section of the sidebar?
How did you start the program? Your 2^nd screenshot shows only 1 breakpoint, at the bottom of the loop. So if you ran, and then stepped, the 1^st division has happened and the display is correct. I've tried your program in VS2015, and it does display n correctly
That kind of thing can happen when you're trying to debug code that's been optimized. When you enable optimizations, the compiler rewrites the program to one that is equivalent, but faster. That usually involves things like reordering operations and such. It looks like you're using the 'Debug' configuration which usually should not have optimization enabled, but it could still be enabled in the project settings. Also, are you sure this is really the first iteration of the loop? Instead of using the debugger you can also just put a printf() statement at the top of the loop to print the value of 'n'. 
I figured it out guys! I had my breakpoint on the loop end brace. Look at the last line of the loop. So it runs the full loop once before it hits the breakpoint. That explains why it wasn't get the right size number This was mainly due to my inexperience with Visual Studio and how to position the breakpoint. I re-placed the breakpoint at the top of the loop and it works great now Pic below http://i.cubeupload.com/SPQEOL.jpg
Notice the semicolon at the end of your if statement. There is no branch, thus the rest of your program will always execute.
I can hear /u/TheOnlyRealTodd 's hand slapping his forehead right now I've been there man. 
This is an important lesson to always question your assumptions. When something doesn't behave the way you expect it to, don't let anything slip by un-scrutinized. The problem always hides in the place where you just gloss right over it, like the case with this stray semicolon.
So you suggest a line-by-line analysis in cases like this?
This kind of mistake is why we prefer to use open brace on the same line as the `if` (or `while`, etc). if(dump_me == NULL); { do_some_stuff(); } Is more visibly wrong than: if(dump_me == NULL); { do_some_stuff(); } 
Please don't suggest a toolkit that does not have native C bindings as a solution here
IMHO Always compile with: -Wall
I'd like to mention the [Head First C](http://shop.oreilly.com/product/0636920015482.do) book. It's not a complete reference on C, but It has a practical approach. And, K&amp;R's C book is also a great book to learn about C
Besides, JUCE is much better than Qt :P
and -Wextra as well... maybe also specify -Wpedantic and -std=c99 (since gcc defaults to gnu99).
For Windows, you can always use the Win32 API (or the Windows API as Microsoft calls it right now). Of course, the application would need WINE or winelib to run on Linux. EDIT: Thanks for the downvotes!
I don't know how feature complete it is but other than GTK+ it might be worth having a look at [libui](https://github.com/andlabs/libui) as well.
My thought process went along the lines of: "Wait. I know darn well that I'm not going to do any successful file operations on NULL. Something is screwy here. I'm going to find out what. I could fire up a debugger, or just go old school and start dropping some print statements in. dump_me = fopen("bin\\Debug\\FileIO.exe","r"); printf("dump_me = %X\n", dump_me) // WTF if(dump_me == NULL); { perror("Error: "); exit(1); } $ gcc x1.c $ ./a.out dump_me = 0x55c8c0228010 Error: : Success Okay, so I'm not somehow pulling off using NULL as a valid file descriptor, my world-view gets to remain intact. So... where is this code goofing up? Clearly dump_me != NULL, so let's put the hairy eyeball on that if block... DOH!" 
I found [IUP](http://webserver2.tecgraf.puc-rio.br/iup/) to be a good toolkit for C based widget/gui toolkit. It is written in ANSI C so it has good compatibility with C and supports Windows and Linux. Plus it can be statically linked so you need only a single executable for your GUI application. It is pretty small so you will not end up with a 10 mb executable or something. It also binds well with Lua, so you can use that as a scripting language if you like. 
 #include &lt;stdio.h&gt; #define N 10 #define MAX 80 void func(char arr[N][MAX], int n) { int i = 0; for (;i &lt; n; i++) { printf("%s\n", arr[i]); } } int main() { char strings[N][MAX]; strcpy(strings[0], "Hello"); strcpy(strings[1], "World"); strcpy(strings[2], "Here"); strcpy(strings[3], "I"); strcpy(strings[4], "come!"); func(strings, 5); return 0; } works, for instance. sh-4.2$ gcc -Wall -o main *.c sh-4.2$ main Hello World Here I come! 
You've already found the error, so I'll give a couple of tricks i use to catch stuff like that: * auto code formating, in the editor preferred. The structure should match what you're thinking * syntax highlighting editor. This helps catch when a string or comment block isn't terminated as expected * compiler warnings turned way up * debugger * if your editor supports folding, that can give hints about your code structure I used to use an editor that drew lines in the left margin to show blocks. I forget which. Another note, unrelated to your question. It looks like you're running in Windows, reading an executable. Look at "r" verses "rb" in `fopen`. 
but it's also c++, and you need pay for commercial use(only free for open source projects). for C you can look into libui https://github.com/andlabs/libui
Sure. There's more than one way of doing it.
Maybe -Werror as well, just to be sure you don't ignore them.
 int n = 0 , j = 0; float values[n]; printf("Write the size of the array : "); scanf("%d",&amp;n); This code will create a array of zero elements. I think it's not what you want. if (*(values + i) &gt; *(values + i + 1)) { temp = *(values + i); *(values + i) = *(values + i + 1); *(values + i + 1) = temp; } Why don't you use the array subscripting operator (*array[index]*)? while (i &lt; n) { if (*(values + i) &gt; *(values + i + 1)) {} As others have already mentioned it, when *i = n-1*, then *values + i + 1* will be out of the array. And you don't set the variable *i* to zero before the inner loop. 
Last I checked, but I may be a little behind, there is no getInt function in the standard library. It'll be hard for anyone to give specific answers unless we know what you mean. Printf is output, not input. Scanf and friends do input, and have the advantage of allowing for slightly more complex parsing. Take note of scanf's return value when you read the documentation about it, in particular. 
yeah. I dont see it in my C book, but they are telling me to use it in this cs50 class. 
[Harvard's CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x) *(a free online course that teaches C from scratch) (Also teaches scratch, no pun intended)* has an assignment where you make a small simple video game in C. It's a good start if you're absolutely new to GUI programming. in C /r/cs50
Actually, in some cases not: the reason is that compilers tend to introduce new warnings under -W or simply change the set of warnings enabled by it. This could potentially mean that your program compiles with one version of a compiler but not the next. This is a pain for Linux distribution packagers and you shouldn't do that if your code is part of an open source project. Also, not to mention differences between compilers.
What do u mean by allocate the char*? Assuming realloc is successful, do its content still stay at the same place? Is the new list+2 the same as list+2 in the new one. If it does not, how can I access the thing previously on list+2? 
Maybe an example will help. char **ptr = malloc(sizeof(char *)*7); *ptr[0] = "Hello"; *ptr[1] = "World"; ptr[2] = malloc(sizeof(char)*10); strcpy( ptr[2], "foobar"); ........ ptr = realloc( ptr , sizeof( char*)*10); "ptr" might change after the realloc, it might not. ptr[1], ptr[2], ptr[....] will all remain the same. It only reallocated the space for the double pointer. Does that make sense? If realloc moves the block, it copies everything. That's the difference between realloc() and just calling malloc() to get a bigger block and then copying with memcmp() and calling free().
dude thank you so much !!!!!!!!!!!!!!! :D
The list or char\*\* just holds pointers, so no, it can hold the value of any pointer. char *temp = list[2]; list[2] = list[3]; list[3] = temp; and on reallocations char **tmplist = realloc (list, sizeof (char*) * new_count); if (!(tmplist)) { // list is still valid, but failed to make it larger } else { // tmplist is the larger list, resize was successful // the old addresses of list may no longer be valid, but maybe they are list = tmplist;
oops must have accidentally deleted that bracket. What I'm trying to do is make a copy of the array and then sort that copy. But when I sort the copy the original gets sorted as well
Is there anyway to realloc, but calloc the new memory? I used calloc at first because I want to check if list+I ==NULL, I want to do something to it
Do you usually use a script file to do this or do you just type whatever args you want each time? I'm on Win so I was thinking of making a .BAT file.
You can ask what row and what seat they want. Row 0, seat 0 being 1 in the following &gt; [[1, 0], [0,0]]. If they ask for 0, 0, arr[0][0] = 1. Edit: wait so are you asking how exactly to ask for and receive the user input? Or how to access and change the value of the "seats"?
Your mutex isn't [initialised](http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_mutex_init.html)
Love that it scales up and down with window size, nice touch
Thanks!
Cool. I love it 👍 PS: I'm the first person to star the repo 
I'm away from home for the week, but I'm excited to have a play when I get back to my real life. 
Haven't played it, but I just skimmed through the code. If I were giving a code review, I'd probably suggest being a bit more liberal and consistent with comments, and also using a typedef on those struct definitions to avoid needing "struct" all over the place through the rest of the code. But your overall layout and organisation of the code and formatting looks good to me. I mean it's pong and it works, so that's awesome. Nice one!
Nice use of ncurses. Good use of spacing. Perhaps add a bit more commenting could help, but you do a good job of making the "code that does the work" easy to find, so don't sacrifice that for comments unless the comments explain something not obvious. Typedefs would be cool, too. Will download and play 9/10. 
May I ask you why chose that style of comments for your functions? Thanks
The code looks pretty clean. I have a few observations, some of which might be insignificant, or even incorrect. So don't take this all as a gospel: * From what I can tell if the user presses a key, your kbdhit() (keyboard hit?) function will getch(), then ungetch() it, then the while(run) loop will getch() the character again. This seems unnecessary. A better way might be something like: while ((keypress = getch()) != ERR) There might even be a better-er way ;) * The run loop also seems to work a bit odd. When there's a wall collision, run is set to 0, but you don't immediately exit the run loop. In fact, if the user times it right, they can pause the game between the time wall collision happens and the subsequent keypress = getch() call. I don't think you need two nested loops for this logic. I think you can do it in a single loop. A few other less useful comments: * We don't "return;" from void functions anymore. Waste of space. * Why is the paddle initialized at (5, 11) regardless of the screen dimensions? * Most of your functions should be declared static. * In paddle_pos, is this math necessary: if (pddl-&gt;paddle_y - 1 &gt;= 0) Why not: if (pddl-&gt;paddle_y &gt;= 1) Or even better: if (pddl-&gt;paddle_y != 0) /* top border */ pddl-&gt;paddle_y--; * There are a few other cosmetic things like sometimes you use the += operator (good - lines 172, 179) but sometimes you write out the whole thing (lines 94, 95). * You might need to have minimum max_x, max_y for the terminal. Some of your math might produce weird things if the screen is too small in one dimension. For example, the draw_score function.
That's C++, not C. Try /r/cpp_questions
Thanks!
Because it's good practice, and the compiler can do better optimizations for him.
&gt; And read a lot of source code. 20 years later and I still learn new stuff like this. Read, read, read.
What it's doing is filling the array with the initial value. The second loop looks at each value in the array and replaces it with a new value based on the interest rate. The reason the program doesn't work without the first loop is because the array won't have anything in it for the second loop to calculate with.
Thanks for info : - )
Trying to be more standard, you could use time.h instead of unistd.h
Yes, as far as I know, you have to put 4 spaces in front
Reddit uses [markdown formatting](https://daringfireball.net/projects/markdown/basics) instead of HTML or BBCode.
I tried running this on my Macbook Pro and had some errors, could anyone help explain why? $ gcc pong.c Undefined symbols for architecture x86_64: "_curs_set", referenced from: _main in pong-8c637d.o "_endwin", referenced from: _main in pong-8c637d.o "_getmaxx", referenced from: _main in pong-8c637d.o "_getmaxy", referenced from: _main in pong-8c637d.o "_initscr", referenced from: _main in pong-8c637d.o "_mvprintw", referenced from: _main in pong-8c637d.o _draw_ball in pong-8c637d.o _draw_paddle in pong-8c637d.o _draw_score in pong-8c637d.o "_nodelay", referenced from: _main in pong-8c637d.o "_noecho", referenced from: _main in pong-8c637d.o "_scrollok", referenced from: _main in pong-8c637d.o "_stdscr", referenced from: _main in pong-8c637d.o _kbdhit in pong-8c637d.o "_ungetch", referenced from: _kbdhit in pong-8c637d.o "_wclear", referenced from: _main in pong-8c637d.o "_wgetch", referenced from: _main in pong-8c637d.o _kbdhit in pong-8c637d.o "_wrefresh", referenced from: _main in pong-8c637d.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 
I have been learning how git works and have also been going through the exercises of my own copy of kernighan &amp; ritchie *The C Programming Language* second edition. Figuring I would put my solutions on github to help bolster my profile for job-searching (I'm a EE student), I quickly found out I wasn't the first dummy to do so. Sure enough, there are full solutions with the questions as comments on github. For this I am especially thankful, as I have been stuck on one of the exercises for weeks...
The compiler cannot resolve those symbols because you're not telling it, where to find them from. You need to link to ncurses library. If you look at the Makefile from the repo, there's a '-lncurses' at the end, that's what's missing for you. Of course, you need to have the ncurses library installed in your MacBook.
&gt; If I use malloc outside of main, can I use free in main? Yes. &gt; but I am having a SIGSEGV error when compiling. You're doing something else wrong. Maybe passing the wrong pointer, or maybe your variable is out of scope. If you'd like help, you can post your code. Also, you can't get a SIGSEGV while compiling (at least in most circumstances). That's a run-time error.
Looks very easy to follow and sensible code. I don't if it's just me but I'd shorten the identifiers in of the ball/paddle structs to just "x" "y" "len" "max_vel" etc. because the struct identifier itself tells what's going on. I feel this would make it even more readable. 
&gt; Yes, you can do this. Whether it's a good practice or not depends on the situation (often, it's not). &gt; I would strongly disagree with you there. There is absolutely no reason not to call free() whenever you are done with the allocated memory. If that happens to be within the main() function, great. 
Yes I was asking for receive the user input into arrays, because the code I had written gave me an error and after struggling for like 2 hours I started to think that was not the way to do it, because of being an array. Today after a sleep I looked it over again and it was just a simple bracket that made everything wrong. Well. 
And that is generally within the same function. In program design, it's easier to do mental accounting when malloc and free are matched inside a function. Of course, it's not always bad and there are cases where a library function's primary goal is to allocate memory to be used and free'd later by a separate library function. I have seen too many examples where people write code as they go along and instead of allocating memory and passing it to a function whose primary goal is not object allocation, they do the allocation inside the function and free it after the return after the memory is used. Or as possibly in the OP's case, they use a global to get around those pesky restrictions of local scope, so where the memory is allocated and freed is fairly chaotic.
&gt; And that is generally within the same function. In program design, it's easier to do mental accounting when malloc and free are matched inside a function. &gt; That's more often untrue than true. The whole point of malloc() and free() is that you can create memory that remains after your function returns....and you're telling OP that this is wrong and they should only be used when a variable's scope is within the execution of a single function. You are incorrect. malloc() should be used to allocate memory, and free() should be used to deallocate it. There is no reason both of those should always be in the same function. If a function call allocates memory with malloc(), it should be documented that the memory should be deallocated with free(). Beyond that, do what you want with it. 
Thank you so much!
What documentation did you use for ncurses? I have a slot game I wrote. I was going to use ncurses originally for the color I could not find the documentation on the gnu's site. The closest thing I could find was the 6.0 release notes. Am I looking in the wrong place?
I'll keep that in mind for future games! Thanks! EDIT: I have changed the variables as per your suggestion.
Ooo... That's true.
Just another thought, you might have some trouble because I include unistd.h, which probably isn't on your macbook.
Most of my style inspiration comes from the linux kernel's syntax requirements. I like to use multi-line comments everywhere because that's what K&amp;R does, and in my opinion, that's what looks the cleanest. I have a vim macro that makes a line a single line comment, but I really only use that functionality for testing and quick iterations.
The reason I chose to not use typedefs was because I think it obscures what you're really doing. Maybe it isn't that big of a deal in ~200 line projects, but as it grows, I think it's useful to have the `struct x *` where it's used.
Thanks!
That is correct, runtime error. I have been up with this for close to 30 hours now. I will post my code if I cannot get it to work with the tutors. Thank you!
Yes, I apologize. When running the code in debug mode it gives me the error. In run mode it does not return all of the correct values from my struct array.
Thanks so much! I'll consider/change everything that you suggested when I get a chance later tonight!
If an array of structs is created in the first function call out of main, and this is where malloc is called, why is it in bad practice to keep that memory allocated until the structure is no longer needed?
Macs are POSIX compliant UNIX, they most definitely have `unistd.h`.
Use typedefs to get rid of the keyword `struct`, not to hide the fact that the type is a pointer. typedef struct Person { char *name; int birth_year; } Person; Now instead of using `struct Person p;` or `struct Person *p` you can use `Person p` and `Person *p`, much nicer.
There's also a good wiki with the solutions, more complete than that repo: http://clc-wiki.net/wiki/K%26R2_solutions
Ok, printf to ask the question and scanf to receive user input. 
More explicit than 0 that it was successful. Easy for newbies to think that since 0 is false returning it means failure.
I'm looking forward to your feedback!
Should be changed on the master.
Part of this is also that I don't get vim syntax highlighting for typedefs, but I'm trying to figure that out. EDIT: Looks like I just had to close and reopen vim a couple of times for the typedef coloring syntax stuff to work, and use of typedefs are included within the source.
Most of what I've used in this program has come from this amazing resource: [http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html](http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html)
There should probably be more comments (I haven't added any thus far), but I have changed from using structs all over the place to using typedefs.
I had to look this up, since I've never noticed EXIT_SUCCESS before. I think one person said that it has to do with portability, the Vax was given as an example. It might have been that EXIT_FAILURE, and "if EXIT_FAILURE, then use EXIT_SUCCESS for symmetry."
Thanks for your reply. My main curiosity was related to the function comments like: /* * function : paddle_pos * purpose : have a function that will return a proper 'y' value for the paddle * input : paddle_t *inpt_paddle, dimensions_t *wall, char dir * output : void */ In any case, if you don't mind to use vim plugins, you may find useful: - [DoxygenToolkit](http://www.vim.org/scripts/script.php?script_id=987) - [vim-commentary](https://github.com/tpope/vim-commentary) I generally prefer to comment my functions with Doxygen style, even when doxygen is not used, because I found it clear to explain the function usage. In any case, thanks to share your work, I may use it to start to play a bit with ncurses libraries. EDIT: I can't get reddit markdown rigth :/
You tried runnin this with a debugger? It's just as the sayin goes: "Debugger does wonders" or something like that.
Preliminary: I know nothing about HC-05, Trinket, Arduino IDE, or Arduino. * Why do you have 2 `bluetooth.begin()`? * Why does the first one happen before you configure the pins? * Did you configure `MotorPin` with `pinMode()` somewhere? * Don't you wish to stop the motor after 5 seconds by putting its pin `LOW` again after the delay? 
You assume that kek = 1, ek = 1, and mek = 0 and the output is ek=1, mek=0, kek=1, which is the same thing just in a different order. So what's your question? 
 void* buf = malloc(huge * huge); if (errno) perror("malloc failed"); printf("malloc(huge * huge) returned: %p\n", buf); free(buf); buf = calloc(huge, huge); if (errno) perror("calloc failed"); *Cringe...* Don't use `errno` like this. If `malloc()` sets it, it will stay set even if `calloc()` succeeds, and you will print that "calloc failed" even though it didn't.
I'm a newbie to C, but could it be that whatever bluetooth.available is checking isn't labeled "volatile"?
It's because you want to avoid "[magic constants](https://en.wikipedia.org/wiki/Magic_number_(programming\)#Unnamed_numerical_constants)". The other replies give good examples for why this is so. `EXIT_SUCCESS` is a lot more explicit than a bare `0`, and it means you can easily port your code to a platform where a success return code is not zero.
"Embedded" doesn't really have a formal definition, so it means different things to different people. I'd bet this is an "embedded" system in that it's probably running on custom hardware, likely isn't self-hosting, and probably has at best shell access or maybe just whatever front panel or web GUI the system implements.
Yep. Custom hardware, this particular subsystem is highly restricted in terms of resource access. 
why cant we use void while declaring something; as in int a=1; what happens when we take void a; ? i'm newb to programming , go easy on me
void is not a data type like int or char. the void keyword is used to declare a function that does not return a value: "void myFunc() {...}" and it is used for void pointers: "void* a;" void pointers don't actually point to a "void" object, void pointers are generic pointers that can point to anything. so you cannot declare a void variable like "void a;"
You can declare an object as typ void, but only if it has a function declarator or if it is qualified either `volatile` or `const`. So const void foo; is valid, though, it makes some compilers crash (notably SUN studio).
Ok, scratch my char *-hypothesis. I'll leave it there for others to see. What is the name you are entering? Is it longer than 19 characters?
Edit2: Okay so there's a lot of detailed explanation to stuff I've not learned about yet. I'm using fgets without knowing how it works and what stdin is, I assumed it has the parameters of variable,length of var, and a default stdin in the third var. The reason for using this is because I attempted to scan a string using scanf %s but it only recieved the first name, ignoring what's after the space. I googled this and found out that this might work, but it got me caught up in different problems I'm not familiar with. In such situation, how can I scan a string even if there's a space in between of 2 separate words? Edit3: Well I leave that to my professor, I just assume there's no name bigger that 20 for convenience. Could really make it bigger it it doesn't matter much to me.
So you don't know the input to the program? The point is, I believe that if a name longer than 19 characters is entered, the behavior you have described may be a possible outcome.
Well I mean it's not that I don't know what name exactly, the input should be a name, basically a string, followed by a number. And then the program asks if you're done to stop the loop, and you keep adding till you hit 10 or stop it yourself. I also limit the phonebook to 10 for convenience. I will try to input a shorter name or make the array longer, but that doesn't explain why does both my printf()s print at the same time without waiting for my input between each other, it just pops out "Enter name: Enter number:" and then waits for an input. 
Okay, so I believe there are a few errors in your code. First, in the loop condition check, you probably want "i &lt; 10 &amp;&amp; cond == 1" instead of what you have now. Second, I am able to reproduce your problems when entering long names, but not with short names. Increasing the size of name fixes the issue. Third, the scanf that reads the condition (y or Y, etc), should probably be scanf("\n%c", &amp;d); this is because the previous scanf reads an integer, and \n cannot be part of an integer. An alternative (and one which maybe makes more sense), is to change the first scanf to scanf("%d\n", &amp;acc[i].number); (I have not verified that that change works). Also, I don't know how long phone numbers are in your country, but I would take care to ensure that int is able to store the longest possible phone number. Oh and, a tip: For stopping loops (applies to do...while, while and for-loops), you can use the break-statement. So, instead of: if (d=='Y' || d=='y') cond=0; you can do if (d=='Y' || d=='y') break; This way the last increment of i won't happen, however, so you need to change the last printf to printf("You've entered %d phonenumbers.",i+1);
I have no come across a \n in a scanf before, or a \anything in scanf really, what does it imply? I have changed why you advised to do, I also increased the size of the array to 50 just in case, revised the condition and as for the numbers, I did think about it but I always used int and float so I need to double check on the long and double variables before using them so I was planning on trying out int first and if it worked, I just let it as is. I still, however, have the problem of it printing both printf()s at the same time as such: http://i.imgur.com/v0H2svr.png What I would it like it to do is to wait for my entry of the name, then pop the other print and then wait for my entry for the number. Edit: I believe my problem lies in the fgets part of the code. I wish I could use an alternative until I'm taught how to use it in uni, but I doubt they will anyway, haha. Edit2: thanks for the last tip, will use it, seems much easier.
Yes, you are correct. Whatever the standard library does, you can do yourself, and manually talk to the kernel with syscalls - it's just that most of the time it will be very inconvenient. I can, however, imagine it is totally possible to make a wicked kernel which treats the standard library in a special way, giving it extra communication mechanisms or higher privileges. I doubt such operating system exists, though.
Because your function (`main()`) takes a parameter (`argc`) which is not referenced within the function. This is often a programmatic error, so your compiler emits a warning about potentially unintended behaviour. Normally with a function like this you would want to ensure that the user actually provided an argument, otherwise you could end up with a segmentation fault. if( argc &gt; 1 ) { printf("%s", argv[1]); }
To add to your comment: If you are sure that the argument is intentionally unused, write (void)argc; to inform the compiler of that fact.
Yeah, maybe I should clarify that in the post... what I meant is, this is why you can't build `calloc` on *top of* the `malloc` API. Of course you can implement `calloc` yourself, if you also implement `malloc` yourself.
I'm using gcc 5.2.1 on x86_64 processor. This is the program I wrote. Return address for f() is at rbp+0x8, so I write 24 A's + return address for call printf("\nFail") into the buffer. Edit: Forgot to say, starting address for the buffer is rbp-0x10 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int f(char *pass) { int ch = 0; char buffer[8]; strcpy(buffer, pass); if (strcmp(buffer, "pass")==0) { ch = 1; } return ch; } int main(int argc, char *argv[]) { if (f(argv[1])) { printf("\nSuccess!\n"); } else { printf("\nFail\n"); } }
As u/_simu_ says, this program has undefined behavior.
It already does but seeing as you don't loop over the printf/scanf/switch the program will just exit. To be more precise: it will continue the `main` routine from where you left, i.e. the `break` after the `convert_lengths()` call in the switch.
Why does this article have a link to a site about holocaust history...... I fucking hate the internet... 
Nice, just some comments: - Don't die if realloc returns NULL on shrinking. The old vector is still valid. - Don't grow by a factor of two. Use something slightly smaller. - Don't memset(,0,) after malloc. See https://www.reddit.com/r/C_Programming/comments/5grwep/why_does_calloc_exist/
OP again. Thanks to everyone that helped me out. Very helpful. I get the purpose of the array initializer now. Would it be reasonable to conclude that the author put the array initializer in the same loop as the interest rate labels for presentation purposes/to conserve space on the page? It seems he was trying to cram as much in as little space as possible. If this was production code, wouldn't it be better to put the array initializer and the interest rates in separate functions with For Loops? Or why not just initalize the array at the top by saying this at the top? **float value[5] = { 100 };** I guess the effect of that would be less flexibility to modify the array since you lose the macro? That decision to conserve real estate space didn't seem logical to me at first, and that's partially where I lost my train of thought. Now I understand his motives 
Which factor should suffice? What's the reasoning?
Growing a vector by 2 will make your program use much more memory than you expected, because it will leave holes. See [this post](http://stackoverflow.com/questions/1100311/what-is-the-ideal-growth-rate-for-a-dynamically-allocated-array/1100426#1100426) for a good explanation.
If you grow by a factor that is greater than the golden ratio, and all the allocations are adjacent, the “hole” you leave behind will never be large enough to fit the reallocated vector, so not only will the end of the vector grow indefinitely, so will its beginning. If you limit yourself to something less than the golden ratio, it is theoretically possible to eventually reuse the “hole” to fit the whole vector, although depending on how long the vector will be and how the system decides to allocate, that may or may not happen. http://stackoverflow.com/a/1100426
Good point, thanks! Fixed.
If all 3 processes are linked to the same exact DLL, that DLL gets loaded only once in memory and the processes refer to it through the DLL's virtual addresses. Taken from MSDN as one of the advantages of using DLLs: &gt; Saves memory and reduces swapping. Many processes can use a single DLL simultaneously, sharing a single copy of the DLL in memory. In contrast, Windows must load a copy of the library code into memory for each application that is built with a static link library. https://msdn.microsoft.com/en-us/library/dtba4t8b.aspx Edit: I assume that you meant File1.exe, File2.exe and File3.exe are separate processes in your diagram
None of the three cases contains a single comment, so …
https://beej.us/guide/bgipc/output/html/singlepage/bgipc.html for inter process communication and for threads just google "pthread tutorial".
Yes.
These are all good ideas, thanks. I will update the header when I get a chance later
You are not a magician
Apologies for the formatting! I'm still trying to figure out how to format the code so it's in a single box. The four spaces thing isn't working... don't think I'm doing it correctly...
Thanks. I saw that one before. I was concern it was out of date, but I found the gnu documentation I was looking for. I will use both.
The natural language way of reading that would be "if the suit and rank is not in hand (presence being indicated by 1 or TRUE), do whatever follows within the curly brackets". In other words, it's better to read inside out. Of course, it helps that the 2-D array is named "in_hand". If it had been named something like arr, the interpretation would still be the same. In this case, it would have been something like "if the value of of the cell at row "suit" and column "rank" is not 1 (or TRUE), proceed with the code within the parentheses". See how the context of the domain makes the first interpretation read much better even though they're both logically equivalent? This is the power of good naming to suit the domain of the problem.
You need 4 spaces on every line (before any text) ---- Correct: #define TRUE 1 #define FALSE 0 typedef int Bool; int num_cards; int rank; int suit; main() { printf("Enter number of cards in hand: "); scanf_s("%d", &amp;num_cards); /*user input */ ---- Copy this into your post to get the same result: #define TRUE 1 #define FALSE 0 typedef int Bool; int num_cards; int rank; int suit; main() { printf("Enter number of cards in hand: "); scanf_s("%d", &amp;num_cards); /*user input */
That's probably more for performance, but it's one way to deal with the issue. Here's [musl's memmove()](https://git.musl-libc.org/cgit/musl/tree/src/string/memmove.c?h=v1.1.15). It invokes undefined behavior by comparing pointers to different objects with `&lt;`, relying on the compiler to do the obvious thing as a sort of compiler extension. Being a libc for Linux — it will only ever be compiled for Linux — it's a fairly safe bet. 
&gt; Your records are 40 bytes. How do you figure that? I read it as a record has a `uint32_t` and a `char[128]`, in which case each record would be 132 bytes.
Whoops. Massive brain fart. gdbm or the like it is, then.
Mental accounting is important in programming. You have to think about how you can reduce the chances of incorrect implementations. For example, let's say you are tasked with writing a function to reverse a string while preserving the original string. There are two ways this can be written. The first one: char *reverse_str(char *in, char *out, unsigned int sz) This enforces that the user of the function allocates the buffer and sz matches the in and out buffers. The second way would be: /* Dear user: you free() the memory I return to you! */ char *reverse_str(char *in, unsigned int sz) In this case, our programmer malloc's the memory and tells the user (who hopefully reads the comments...) to free the returned pointer. There are many library functions that allocate memory without freeing it, but we usually design these functions to have matching pairs. For example: map_alloc(...) map_free(...) On the other side, let's say someone else is writing a function that consumes these reversed strings (whatever that means). Since the string is consumed in this other function, should the author also go ahead and free it? In other words: void consume_str (char *str) { do_stuff(str); free(str); } "There is absolutely no reason not to call free() whenever you are done with the allocated memory." is what this function is doing. But is it what it is supposed to be doing? Does it even know if str is on the heap vs. stack? Well, let's fix that using the "comment" : /* User: str must be on the heap! NOT on the stack! */ void consume_str (char *str) Do you think this will work? Meanwhile any caller to reverse_str and consume_str must check the comments to see if they're supposed to malloc or free the memory after calling these functions. If there is a memory leak, we can't go to the person who wrote reverse_str and ask if his code has a memory leak. If there are dangling pointers, we can't go to the person who wrote consume_str and ask if he free's memory prematurely. What I am advocating is not a strict "who mallocs it shall free it" regime. But it is putting thought in the design, allow for mental accounting as well as enforce better correctness by explicit (not implicit) requirements around memory management. So the user of these two functions should do: out = malloc (sz); reverse_str(in, out, sz); consume_str(out); free(out); out = NULL; This design also gives us the flexibility to do: char out[SZ] = { 0 }; reverse_str(in, out, SZ); consume_str(out); and reclaim the memory automatically after out goes out of scope. But sure, not everyone apparently agrees and you're free (pardon the pun) to follow whichever advice makes more sense to you. I've chased slow memory leaks in millions of lines of code and it gets quite difficult when malloc and free of a certain piece of memory are done in seemingly unrelated modules.
No big differences... If I was forced to classify them, I'd say: B (function) &gt; A (goto) &gt; C (flags) A (goto) &gt; C (flags) because I don't like having an extra test in the test expression of a `for` loop. But well, just my opinion of the moment. B (function) &gt; others because it avoids having to emulate the double break or deep break that C language doesn't provide, and I don't find any of the workarounds very pretty.
Plenty wrong with the code. Did you even try to compile it? My suggestion is to compile it first, look at the error messages, and fix them. That should do it. The overall logic is fine, but you have messed up with the argument types to the "read" and "average" functions and also some variable types.
That's actually a school project, he's a student at 42 : 1. is required as part of the subject, not having it is not an option (at the very least to define the function and BUFF_SIZE, plus include guards) 2. yep 3. MALLCHECK() is explicitly forbidden by the coding rules he's supposed to be following, he should have had a 0 or cheat as a grade just for that (no macros defining code). 4. he got lazy and reused a linked list implemented in an earlier project, repurposing a field of one of the links which is supposed to hold the size malloc'd for the content of that particular link : struct s_list { void *content; size_t content_size; struct s_list *next; } 5. school coding rules 6. libft is the early project, it's not supposed to be efficient, it just needs to provide basic functions because appart from a few syscalls, libc is banned for most projects
thanks for your detailed reply!
Haha, woops I meant to say *pointers for arrays. I understand multidimensional arrays, pointers for variables, and FILE pointers, but I was having trouble with passing struct arrays to functions and my teacher said something about using a pointer to a function to pass an array. I'm still working on learning more about it, but I was lucky and pointers weren't on the test.
Depends on what the operation is. Some operations essentially require creating a new 'instance' of what was passed in, while other operations may only really make sense in the context of modifying the original. For a function that simply acts on an `int` and creates a new `int`, it generally makes sense to just return it - it's just an `int` after all, there's no real reason to force the caller to trash the original value when you don't have to. That said, passing a pointer to an `int` can still make sense if you have multiple things to return - in that case, the pointers are basically just extra return values. That's a fairly common technique in C (and other languages). Now, while C doesn't technically have 'Objects' in the Java or C++ sense, it does have `struct`s which serve a similar function of combining related pieces of data. For such things, it generally makes sense to modify the original rather then make a whole new copy for some new state (Though not *always*, you should always consider operations within the context of their data). So generally for a `struct` I'd do something like this: struct network_state { /* blah */ }; int network_state_connect(struct network_state *); int network_state_disconnect(struct network_state *); /* etc... */ The OOP similarities may be somewhat obvious. The above convention is fairly widely used (though the naming scheme and such tend to vary from programmer to programmer and project to project - my preference is above). In this case, you create a single `struct network_state` object, and then pass a pointer to that object to the various functions which modify and act on that state. The big advantage with this technique is that you don't force any allocation requirements on the user - they can allocate their `struct network_state` on the stack, as a global/static variable, or `malloc` them at runtime - these functions don't care. That kind of flexibility generally helps in simplifying code and memory management (For example, you could embed a `struct network_state` directly inside of another `struct` with ease). In addition, passing as a pointer is generally a good advantage because such `struct`s can get big, which increases the cost associated with passing them by-value to functions. On that, functions can declare `const` pointers to guarantee they won't modify the contents of your object that you're passing a pointer too, so you can still get some of the guarantees of directly passing by-value while still passing a pointer instead.
Wow, thanks for this explanation! It is very thorough and informative. It's these types of sorta general questions that can sometimes make it tough to transition between languages at first since most books focus on syntax. I just wanted to make sure that what I was doing was "safe" or not going to cause UB or whatever. I wasn't sure if modifying external (to the current function) variables via pointers was frowned upon or "dangerous" or anything. But after thinking about it, I suppose the only risk would be of accidentally passing in the wrong pointer, but you provided an excellent solution for that which is using a const pointer when necessary!
Great, thanks. Yeah so I'm speaking of when I *do* want to change the original variable. If I did not want to change the original variable, I would pass it in by value so that a copy is made in the called function. It's just that pointers open up a door to even be able to modify data in this fashion. Of course in other languages such as C# that does not have pointers, you could still modify global variables and class member variables from within a member method/function (or even pass an object in as an argument and mess with its state), however, the concept of passing a memory address itself in, which essentially would modify the variable *directly* (ignoring any sort of business rules or encapsulation on it) by accessing its memory location is new to me and I was wondering the inherent pros and cons of doing that. I would assume that the "best practice" would be to still try to use return values when possible rather than by "returning" values via pointers because if code gets modified down the road, I would assume having a lot of functions which modify variables via pointers would create nasty bugs that are more difficult to locate/detect than if say I am assigning return values to the variables instead. However, that is a lot of assumption and was looking for some more experienced people to chime in. Thanks again!
What you seem to miss is that I never talked about the particular program in the OP, but just the line kek = ++ek || ++mek &amp;&amp; ++kek; Which potentially exhibits undefined behavior (cf. GCC 5.4's warning).
Your original post said: &gt; the second line is actually undefined behavior which seems like a whole different claim to "the second line, if put into a different program without the first line, might cause undefined behaviour" as you appear to be suggesting in your last post. OP's snippet is well-defined. You can't consider a line of code without the context. 
Have you tested this? Because as the function is written now, it's not going to do anything. In fact, I got a compiler error when I [tried it](https://ideone.com/Uk3ATy)
No, I haven't I struggle how to do this correctly. I knew it may not work, but since I don't know how to write it, I left testing out.
Oh, I'm so stupid, thank you! Now you have written it I perfectly see what I was missing. 
I also like the option b, But the empty return is similar to a goto, and requires calling another function... but goto is not advisable... but in this case it seems a reasonable use I prefer to keep the code "together", because it is easier to modify the syntax. How could I do it nice?
Personally I would prefer circular_permutation Autocomplete means I just have to type it once anyways
Well, little too late, but i figured out it was just terminal error. Everything working fine with compilator. Thanks for replies guys ;)
You can do better than that. Like the guy in here a while back who named all of his variables mm or nnn.
I would prefer a shorter name like *circperm*. Variable names should just be long enough to be easily recognizable and distinguishable from other variables in the same scope. They don't need to fully explain what a variable is for; for that you should add a comment when declaring or setting the variable.
In all honesty your job will have coding standards that you will follow. So reality is you have no choice, you'll do what you're told. Most places I've seen usually require and type indicator along with a function and use. Like [b|bool]TestLoginValid There is only the illusion of choice.
half of java if I read correcttly
C doesn't seem to be a go-to (no pun intended) language anymore outside of embedded systems and some kernel programming. I still like it for portable libs. I **am** surprised to see C# drop while VB .NET rose. [edit] grammar
[Here](http://unix.stackexchange.com/questions/43520/how-can-i-print-well-formatted-code) is a brief discussion of the topic and a solution.
Dennis Ritchie didn't die for this.
Yes. The basic idea is to reverse the process recursively. For example, if the "forward" direction is (x,y) -&gt; (x+y,y), in reverse it is (x-y,x) &lt;- (x,y). So, in the body of the function, try each direction in reverse. Do: x = c-d, y = d. If (x == a &amp;&amp; y == b), all done, return true. If (x &lt; a || y &lt; b), return false. Else call isitpossible(a,b,x,y). If that returns true, return true. If it returns false, then on to the next direction. The next direction in the body of the function would be to try (x,y-x) &lt;- (x,y). In this case though, if isitpossible() is called, just return its result directly as there are no other directions to test. The above returns true or false if there is a solution. You can do step counting by having isitpossible() return a count if possible or -1 if not. The count is the number of steps done so far. For a valid solution, return 1 if isitpossible() is not recursively called or the recursive call's return value +1 if it is.
Thanks a lot !
Thanks a lot !
:(
Can you give an example where they don't behave the same way? What is the type of your variable? I'm not sure of any situation where these statements would react differently, so I'd be interested to see an example. Edit: Wait, as written, they're opposites. var is the same as var != NULL !var is the same as var == NULL
Yeah not sure if OP is asking the question properly here. That being said, `!var` and `var == NULL` should always give you the same result. That being said, I think the latter is a little easier to read when quickly scanning through code. 
You could do this with pandoc. Create a small script that crawls your project directory and prepends and appends each file with the markdown notation for code blocks (triple back-tic+c and a newline to start, newline and triple back-tic to end) and write the files either in place or to a new directory as 'filename.md'. Then just execute pandoc on the files to output a pdf. You can set the order of the files to have a table of contents, do anything you can do with LaTeX, etc. and you'll have syntax highlighting and a monospace font (which you can change out for whatever you want should that be something you want to do). Sorry I'm not including any examples but I'm on mobile. Google has plenty of info and examples though!
&gt; #include "test.c" Also, this should be "test.h". You should not `#include` a `.c` file.
It's the same unless you use this silly cpp macro. Some consider it good style to test pointers for their value ptr == NULL instead of !ptr. It's a matter of taste.
#define sizeof(x) rand()
printf doesn't have a binary format specifier. You have to do it "manually". You can easily find a solution on google or you can give it a try on your own (which will be more educational and more fun)
&gt; unsigned int mask=1&lt;&lt;((sizeof(int)&lt;&lt;3)-1); Better write unsigned int mask = 1 &lt;&lt; sizeof (int) * CHAR_BIT - 1;
Work IDE is MS VisualStudio or vim. Home only vim with ctags.
Vi, Visual Studio Code, SlickEdit and Notepad++. I suppose the only actual IDE there is SlickEdit, the rest are just editors I suppose. 
Depending on the project, one or multiple from the following list: * Keil uVision (embedded uController) * Eclipse (embedded Linux, mostly C++) * MS Visual Studio (Test tooling) * A bunch of editors like vi, nano, notepad++, XMLSpy 
I've got the Second Edition of this and it's a fantastic book. Probably the best-written technical book I've ever read.
If you are developing in UNIX the shell is your IDE.
Thank you, also I heard that one of the best ways to learn is to read code, do you know any sites with simple codes to begin with?
CLion is really good for C/C++.
Here's one way to do it in shell script: sort -s -m -k1n &lt;(nl -ba -nln file1) &lt;(nl -ba -nln file2) | sed -e 's/^[0-9]*.//'
Vim / emacs and CLI tools most likely
I did all of my work for my C class in Unix and let me tell you I will take a real IDE over the shell every time I have to write something longer than 10-20 lines
The compiler should be able to compile multiple files to create an executable. For example, with gcc, I can simply do: `gcc driver.c test.c`. Also please copy-paste the code here, instead of typing it.
That looks generally correct. If you want to see it in action, just add some more print statements to your program. void change(int* t) { printf("t: %p-&gt;%p-&gt;%d\n", &amp;t, t, *t); *t = 5; printf("t: %p-&gt;%p-&gt;%d\n", &amp;t, t, *t); } int main(void) { int *p = malloc(sizeof(int)); printf("p: %p-&gt;%p-&gt;%d\n", &amp;p, p, *p); *p = 2; printf("p: %p-&gt;%p-&gt;%d\n", &amp;p, p, *p); change(p); printf("p: %p-&gt;%p-&gt;%d\n", &amp;p, p, *p); printf("p is now:%d\n",*p); free(p); return 0; } https://ideone.com/aqQYBR and void change(int** t) { printf("t: %p-&gt;%p-&gt;%p-&gt;%s\n", &amp;t, t, *t, "&lt;INVALID&gt;"); //Don't deref a NULL pointer *t = malloc(sizeof(int)); printf("t: %p-&gt;%p-&gt;%p-&gt;%d\n", &amp;t, t, *t, **t); **t = 5; printf("t: %p-&gt;%p-&gt;%p-&gt;%d\n", &amp;t, t, *t, **t); } int main(void) { int *p = NULL; printf("p: %p-&gt;%p-&gt;%s\n", &amp;p, p, "&lt;INVALID&gt;"); //Don't deref a NULL pointer change(&amp;p); printf("p: %p-&gt;%p-&gt;%d\n", &amp;p, p, *p); printf("p is now:%d\n",*p); free(p); return 0; } https://ideone.com/Yoz2NF
So I had that exact printf statement after the code as well as everything above. I was just typing from memory on my laptop and did not have access to my desktop for a hot minute. The printf, when sectioned out, seems to be the cause of the segmentation fault. I am using emacs and gcc to compile the code. In the driver I " M-x compile" then driver.c then I "M-x shell" and ./a.out ( not sure why everything is going into this, but it was what I was using to print out my "Hello world" type stuff. That is where I get the segmentation fault. Like I said, I am sure it is something super simple, I just am missing the forest for the trees on this one. Thanks for the help BTW EDIT : So I was looking closer, and I had slightly different syntax. I had changed it to just return strtol(foo...) and when I changed it back to the int variable cast as an int, then returned the int, everything worked fine. I would have beet a thousand dollars that was what I had done before, but it was not working for some reason. Either way, I think I get it now. I don't know what I was doing wrong though. I must have added something/removed something in my editing that I didnt notice. 
&gt; Probably the best-written technical book I've ever read. Absolutely agreed. If I ever write a book, I hope to be able to follow that style and approach. Nothing wasted, nothing compressed. Just one programmer talking to another programmer.
Yap, that's exactly what I was hinting at. I probably should have written it as "there's no promises that `NULL`'s value is actually `0`" rather than use shorthand. Thanks for clarifying :-)
In my experience, CodeLite has been a pretty decent IDE for C. there are a few things i don't like about it, mainly that the autocomplete could be better, but otherwise it does its job well. It's also cross-platform and has a built in git interface, which is nice. As the others have pointed out though, you can use the linux terminal instead of an IDE. This will help you learn how compiling and linking is done, among other things. I recommend using vim for editing, personally.
I have wasted so much time reverse engineering IDE s to fix bugs. I hate them.1
Ugly nested bitshifting?? Nested ifs? Some weird !! instruction??? No no no no... let's just hack in some printf translation fuckery: #include &lt;stdio.h&gt; #include &lt;string.h&gt; char lookup[16][5] = { "0000", "0001", "0010", "0011", \ "0100", "0101", "0110", "0111", \ "1000", "1001", "1010", "1011", \ "1100", "1101", "1110", "1111" }; int main(int argc, char* argv[]) { char output[32]; int input = 24601; sprintf(output, "%X", input); int len = strlen(output); printf("%d = 0x%x = ", input, input); for(int i=0; i&lt;len; i++) { if (output[i] &gt; '9') output[i] = output[i] - 'A' + 10; else output[i] = output[i] - '0'; // ASCII fuckery printf("%s", lookup[output[i]]); } printf("\n"); return 0; } 
&gt; thanks me &gt; doesn't upvote ಠ_ಠ
I have owned two copies of the first edition. I "fondled with intent" enough that the cover came off the first copy. Somehow it never occurred to me to look on Stackoverflow in 1983. (-:
I used two questions one to scanf "i" and another to scanf "j" for my array[i][j], then used an if statement to change value of array[i][j] to 1 if it was already 0, and if it was 1 my program says ticked is sold already. That was my way to sell tickets. Well I've done my first program! (almost, I need to change colors of my arrays in terminal and still struggling), but everything is functional I'm quite happy I did this on my own.
What is your question?
We have not covered struct in our class. And yes i've been in class all semester haha. However, we really didn't go over array but like once in class. Since then all we've been doing is the assignments we have been assigned to do. 
there are 15 grades we must enter and 11 students
Ok, I'm a bit confused on what you're asking. Do you have a copy of what the assignment that I can look at?
These are the directions for the assignment: "I would like a program that will calculate each student’s average grade for a class of 11 students. The program should be able calculate the class average of all 11 students. I should be able to print the students’ numerical and letter grade; their average; the overall class average from all students. I want to know how many students’ grades were above 70% and how many were above or equal to the class average." Here is the test data: " Name GRADES Jack Benimble 87 56 68 85 78 55 60 79 82 84 90 63 71 76 82 Jack Hill 92 33 87 68 98 100 72 62 58 87 89 95 78 65 75 Jill Hill 72 48 86 98 56 92 86 71 94 62 99 75 87 56 85 Mary Lamb 78 89 75 82 89 97 77 68 85 78 80 89 76 85 97 Humpty Dumpty 92 58 87 68 98 87 72 62 68 87 92 95 80 67 90 Rose Wood 89 73 63 78 100 67 82 78 60 92 97 85 71 78 89 Red Ridinghood 86 63 87 68 98 100 72 62 58 87 89 95 78 65 0 Goldy Locks 95 78 100 85 72 63 96 87 94 68 92 75 90 72 83 Bad Wolf 92 46 87 68 98 100 72 62 58 87 89 95 78 65 95 Peter Rabit 83 72 68 92 83 78 0 58 53 46 72 50 63 58 71 Mother Goose 85 83 92 72 91 78 89 94 83 68 82 78 87 93 100 "
I wanted to try it on code of my own, but sadly the website doesn't seem to be very responsive. Hindley-Milner type inference is a glorious thing, but I'm very sceptical how this applies to C. C is weakly typed, has a *lot* of type synonyms, and the distinction between those type synonyms often only exists in the programmer's brain rather than being apparent in the code. Just doing inference from uses in the code, I think there would be a lot of ambiguous situations where the programmer could have meant to use any of int, long, int32_t, size_t, ptrdiff_t, int_least32_t, int_fast16_t, etc., etc. Well okay the tool only works with C89, so the stdint family isn't in consideration, but the others still are.
&gt; Otherwise, M(P,i) is not of type T This is not true. Given the definition of M, it is impossible for M to not have a return type of T. Just because a function doesn't return, doesn't mean it doesn't have a return type. Consider: double foo(void) { while (1) { } return 0.0; } This function never returns, but it clearly still has a return type of double. Hindley-Milner has nothing to do with simulating code or guessing what *values* a function might return (or if it returns at all). It only cares about the types, which are very easy to collect and unify (collecting type equations is O(n) in the size of the program and unification is O(n^2 ))
Maybe it would work reliably if your program is able to accept only one integral type `int`?
I'm guessing they probably designated some default type for where ambiguous situations pop up. But then doesn't that limit the usefulness of it if it's just always going to assume your integral types are int? I'll have to play around with the tool when it starts responding again.
In general you need to store the length of arrays separately. You could also use what is called a "fat pointer", where you dedicate one of your array slots (probably the first), to hold the size of the array instead of real data.
Functions get a new temporary stack. The int array new_array holds 30 ints, and has an address... but the address and the space is no longer addressable or owned after the function scope ends. So assigning the global variable arr to point to an invalid address after fill_array ends is bad. I have no idea what you expect the char str[] to be. And as mentioned, no idea what pows is declared as or defined.
We all know the most fucked up is when you do something with __line__ 
So how would you reference a valid array within the scope of that function in a manner that would be accessible by another function? In MIPS or something I could save the pointer to the stack then pull it out when I adjust the stack pointer walking into the function . I am just trying or learn how to use C there is no particular purpose to passing the string and converting it to an int. Technically, if the array worked, I would know the minimal amount of bytes necessary to convert the int to two's complement, but I am just trying to understand how to initialize and pass arrays/pointers in this language so I can try and grasp the bigger concepts. The char str[] works just fine and become the appropriate int as needed. I only included it in case it caused an interaction I didn't understand since it appeared in that place in the code. How can I make the pointer point to a valid array after making the new array? EDIT : Using the verbiage you used to point out the problem, I was able to possibly Google an answer. I will try out using malloc(n * sizeof(int)) to declare the array and see if that works. I had no idea the array only lived in the scope of the function even if I saved a pointer to it, but that makes perfect sense now that you have said it. I'll try this out tomorrow and see how it works out 
I am just trying out various things in C to understand how they work. I am just using char [] 8 then changing it to an int to make sure I understand how to interact with that particular thing. I edited the doc. It was arr not pows, sorry 
Nice. If the preprocessor can evaluate simple expressions then `#define NULL (!(__LINE__%100))` could remain unnoticed and hard-to-debug for a while.
Thank you for the feedback! It's even more clear now!
Manually inputted 
You could also do it like the strings: Allocate one element more and store `NULL` at `c[last]`. The `NULL` is your terminator. If you want the length, later on, you have to count the array.
what do you think this is doing? P1&gt;=50.00; P1&lt;=300.00; Q1&gt;=100.00; Q1&lt;=50000.00; v1&gt;=20.00; v1&lt;=1500.00; FC1&gt;=3000.00; FC1&lt;=50000.00; P2&gt;=50.00; P2&lt;=300.00; Q2&gt;=100.00; Q2&lt;=50000.00; v2&gt;=20.00; v2&lt;=1500.00; FC2&gt;=3000.00; FC2&lt;=50000.00; 
I have the first edition which I bought new in 1985 sitting on my book shelf right next to me. Back then, I was dragged kicking and screaming into learning C instead of using assembly for the system I was designing as an electronic engineer. But until maybe 10 years ago, I still referred to that book when there was a basic concept I had forgotten how to do in the extremely simple method that is C.
OT: Not understanding pointers is one big advantage of having been an electronic engineer, or at least a hobbyist, who understands how the flow of electronics works inside the CPU and motherboard. Pointers and their usage is always an obvious thing and, when I'm writing C or assembly, I still picture in my mind the bits of the address flowing toward ram which returns the flow of data bits.
The professor told me that the inputs should be between those numbers. "You will be given four inputs P, Q, v, FC for each factory. Where 50.00&lt;=P&lt;=300.00, 100&lt;=Q&lt;=50000, 20.00&lt;=v&lt;=1500.00, 3000.00=&lt; FC&lt;= 50000.00".
I got the same value as you when I ran the code, but my professor told me that the sum should be that. He also gave me the formulae. Is there any change I should do to the code, or should I leave it at that?
Can you show us the formulae?
they don't do anything at all. They all return a boolean that isn't assigned to any variable.
new_arr is memory that's local to the execution of fill_array(), meaning that once the function is done executing the memory is freed up. Even though you set a pointer to it, that pointer will be stale when execution returns to the code that called fill_array(). Alternatively, you could allocate the array as such (edit: and have it exist outside the function it was allocated from so other code can use it): int *new_arr = (int *)malloc(30 * sizeof(int)); arr = new_arr; Just don't leave that memory allocated forever if you plan on allocating more arrays in the future. You could do something simple like initializing arr to zero and checking it each time you call fill_array() before doing the malloc() call. If it's non-zero that means you need to free() whatever arr points to before calling malloc() again, otherwise you'd have a memory leak. The simplest thing to do, though, is to just have the array be global, then you won't have to worry about allocation or memory leaks.
If you wanna be extra sure, you could catch SIGSEGV and clean up in your signal handler.
Nice. I've been using this same approach for vectors in C for the past 10 years. See [buf.h](https://github.com/skaslev/catmull-clark/blob/master/buf.h) for my take. Also don't miss the original public domain stretchy buffer single-file implementation by Sean Barett at [stretchy_buffer](https://github.com/nothings/stb/blob/master/stretchy_buffer.h)
Excellent point, and one I completely over-looked.
Alright, so you're going to want to modify the original code a bit then. Since there is always going to be 11 students, you don't need the program to ask how many students there are going to be. Same with the "press -1" thing when entering the grades, because according to your test data, each student has 15 grades. I'm working on this program right now, but I can tell you right now that you're going to have to use an array of structs to sort all of this information, and then use a while loop to make it so that you can enter in the first name, last name, and grades for each student.
Welcome to the rabbit hole
It will be a lot easier for people to help you if you include a link to your code.
The point of the code I wrote is to use the knowledge and the information I learned in the lessons my professor taught me. I just started programming so I don't know alot about it, but I appriciate all of the tips. Thank you very much! PS: I did use spacing but it doesn't show here in the post.
Is `free(NULL)` implementation dependent or standard across the board?
Thanks for the explanation. I *THINK* I get it now, we'll see if I'm right soon enough though. I had no idea that the array "disappeared" once you left the function and thought malloc was used for some other purpose altogether
Dynamic memory has costs. It is slower, and has to be managed. So if you had a known size, it would be faster, and easier to use an array. typedef struct person { char *name; uint64_t id; int age; ... }person; If we knew we would only need a 100 person array for the lifetime of the program we are writing. void initialize_people (person *list, size_t max_count); person* match_person (person *list, size_t list_count, uint64_t id); void print_person (person *p); int main (void) person person_list[100] = {0}; // Decay's into a pointer initialize_people (person_list, 100); // id being some number declared somewhere else person *match = match_person (person_list, 100, id); if (match) { print_person (match); return 0; } return 1; } So for the lifetime of the whole program, the array holds valid address. And we can use pointers... and now, the functions that act on the pointers, do not care if the memory is automatic of dynamic. So later, we could rewrite the array as a dynamic memory pointer.... aka person \*list = malloc (n \* sizeof (person)); 
Ahh, cool. I guess I never realized how much hand-holding Java did for you before. The garbage collector does quite a bit more than I ever thought. Why wouldn't you want to typecast the value of a malloc return? I suppose I'll have to go look up what exactly typecasting means in C
And another fair point. I didn't really think this through, did I? Live and learn.
The first 5 lines on my pastebin are at the begining of the code, then, I have a while(continue) where verything is happening. Inside this while, i have the "case SDLK_SPACE:" I need to put "positionM.x = positionvaisseau.x + 35; positionM.y = positionvaisseau.y + 35;" inside the for and do like you said : positionM[i].x = positionvaisseau.x + 35; positionM[i].y = positionvaisseau.y + 35; What do you think? Plus, I'm using alot of positionM.x &amp; positionM.y, I need to remplace this by something like this :positionM[i].y But "i" is inside the for, do you want my code to check it out ? :/
I actually disagree. I think it makes sense for APIs that are going to be interfaced outside of the program and thus can't reasonably ever be changed without breaking compatibility. For all others, not making the `struct` opaque gives lots of advantages. More-over, it's still possible to declare the `struct` in the header, but only access the members through macros/functions. Normally I follow the Linux convention in `typedef`ing such `stuct`s, and I find it to be fairly effective - it's obvious that you shouldn't be accessing it directly, but you don't lose being able to directly declare an instance of that `struct`.
Two possible solutions to this problem. 1. Let the last element be NULL. This way you can easily determine it's length by iterating over it. 2. Create a struct which holds the amount of elements in the array. Easier to figure out how many elements there are and whether the element you want to acces is still part of your array. You "only" get to hold a maximum amount of items though and after that an integer overflow. ```struct string_array { size_t amount; char **strings; }```
Awesome, thanks for bringing up the swapping. I hadn't thought of that, but it definitely sounds like I should always try to free up memory when done with it.
Congratulations new C programmer, you've just found your first pointer! I'll try to explain in simple terms: Say I have a float called `F` F has two things: data and an address F's data is what it holds, for example: `3.14` F's Address is where F's data is located in memory, for example: `0x3141592` So, say we declare a float pointer called `FP` by using `float *FP;`. We can then set it's data equal to F's address by using `FP = &amp;F;` Because of this, FP's data 'points' to F's location. If you still don't get it, don't worry, pointers are some of the hardest concepts for new programmers to grasp.
There are three tools I would consider using to reverse the contents of a txt file: * Linked lists * Finding the length of the file by scanning through it once and using malloc to get an appropriately sized array to store it in. * Recursion I don't really want to go into any detail about how any of these would work for solving this problem, because figuring it out is where you learn the most, but if you're very new... well, I didn't list them in order of ease of use.
I think there is some way to make it so that you can have a space in a string, but when you assign a string to char name[35], it will give only print out everything before the space. So if you try to store "Joe Smith" into name[35] and you do: printf("%s", name); It will only print out "Joe".
I suggest you just play around with the code for a bit and see what does and doesn't work. It's really the best way to learn!
it is confusing like you said haha. But it does make a bit more sense However, may i say a bit more information that could help with this issue. All we have looked at in class were if and if..else, counter control iteration, while, for, switch, do..while, functions, and arrays(barely) 
Try this: int *p = NULL;
If someone is telling you that this code must segfault, they are completely and utterly wrong. There is *no* such requirement; invoking undefined behavior means that you have *no* guarantees of what will happen. The code appearing to work properly is just as valid an outcome as a segfault, in that *any* behavior is valid. 
Thanks :) 
If they compiled with optimizations enabled, I wouldn't be surprised if the pointer was optimized away entirely and the call to `printf()` changed to `printf("%d", 5)`. That's allowed under the premise that once you invoke undefined behavior, all bets are off, so any transformation is valid; the compiler could have optimized the function to a no-op that doesn't print anything if it wanted to. 
Reading it backwards seems like a lot of extra work from my cursory glance at how one might go about doing it (iterate fseek going backwards), plus you have to read the contents of the file twice, which you don't have to do with (some) techniques involving reading it into the program memory.
wouldn't you need to dynamically resize the data structure you're using to hold the file contents in memory? That seems like more work to me than something like void writeBackwards(FILE *original, FILE *out){ /* int pos = 0 int cur_char = 0; while fgetpos != 0{ fseek(original, -1*pos, SEEK_END ); fseek(out, pos, SEEK_SET); cur_char = fgets(original); fputc(cur_char, out); } */ } but I suppose that comes down to preference. Although reading from CPU memory is faster once you've read the file into program memory the first time, I don't know if this extra time is going to be too noticable from a human prespective unless the files are very large(in which case the argument for not reading the whole file in to memory may hold as much weight as not reading from disk memory twice). EDIT: I realize you could have an easier implementation of this problem by simply reading the chars sequentially on to a stack and then popping the bytes off the stack and in to the destination file. However, assuming OP isn't allowed to use 3rd party libraries that include implementations for a stack or linked list, implementing one would probably be overcomplicating this problem.
Dumb question. On Linux systems you have &lt;sys/stat.h&gt;, and I guess an equivalent for Windows in &lt;Windows.h&gt;. If you know the file name, then cant you just query that for the file size? This may be quicker for massive files given that the file size data is stored in the FAT, or at least, the number of blocks taken is stored. Also, if you did use this method, could you use GNU extensions so that you can just use the size_t value from stat.h to declare a char array?
I would do something like this: /* Tested and works on AARCH32 ARMv7 compiled under CLang on Android 6 with -Wall -Wextra -Werror -Wpedantic -std=c11 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /** * Given an integer, return an array of the * bits in the integer, with most significant * bit first. The array will be of size * sizeof(int) and will be allocated on the * heap, so ensure to free it! */ int *int_to_bin(int val) { size_t bytes = sizeof(int); size_t bits = bytes &lt;&lt; 3; int *bit_array = (int*)malloc(bits); for(size_t i = 0; i &lt; bits; ++i) { // If we are at i = 12, get bit no. // bits - i - 1 using bitwise and. int bit = val &amp; (1 &lt;&lt; (bits - i - 1)); // if non zero, make it 1, else keep as zero bit = bit ? 1 : 0; bit_array[i] = bit; } return bit_array; } /** * Test method */ int main(int argc, char *argv[]) { if(argc != 2) { fprintf(stderr, "Expected 1 argument. Got %d.\n", argc -1); return 1; } else { int val = atoi(argv[1]); int *bits = int_to_bin(val); for(size_t i = 0; i &lt; sizeof(int) &lt;&lt; 3; ++i) printf("%d", bits[i]); putchar('\n'); free(bits); return 0; } } It depends on whether you use int or unsigned int as to whether you get twos compliment or unsigned binary representation. This example is two's compilment. To get unsigned, if there is not a function like atou (havent ever had to do it) you could always grab input using sscanf instead of atoi.
~~Yes~~No, that's (edit: not) allowed.
Actually, after looking through the standard, I believe I'm mistaken. The compatibility of structs with a "common initial sequence" (which is what you're describing here) is only guaranteed for structs that are contained within a union (and that union has to be in scope). If you have the C11 standard in front of you, it's 6.5.2.3.6 (and also see Example 3 in 6.5.2.3). The standard guarantees that the fields of a struct (with the exception of bit-fields) are laid out in memory in order. Since compilers have to satisfy the common initial sequence guarantee for structs in unions, they're *likely* going to align them the same way, as well, meaning your code will probably work on (almost) all compilers, but the standard does not guarantee it. (At least from my reading)
The absolute simplest and least efficient way to do this would be recursion. It's dreadfully inefficient. Once you do have the length though, I still think using malloc to get an array of the file size and reading into that would be more straightforward. Then you can just iterate over the file.
Both approaches are okay. Often, a datastructure is so lightweight (e.g. in case of a stack), that putting its metadata into a structure is too much effort. In such cases, it can be a good idea to just pass its bits and pieces directly.
This is definitely possible, especially since the socket API makes use of exactly this pattern: `connect()` is declared to receive a `struct sockaddr`, but actually e.g. a `struct sockaddr_in` is passed which shares its first few members with `struct sockaddr`.
Thank you for the answer. Well, the object in my stacks are very simple: just integers. So I put them in an array (an array of integers instead of an array of structures). So my question was: is it a good idea to pack all these informations (the pointer to the top item of the stack, how many objects are in the stack and the max size of the stack) in a structure so I can pass the function this structure (or a pointer to this structure) and modify it in the function. My main problem was that I want a function that read the last item of the stack and change the pointer in order that it points to the item below. So I have two informations that I want available at the exit of the function: the value of the element and the new pointer. But reading your answer, I am thinking I can have a function that read the top element and another function that change the pointer. I not sure I make any more sense. I am learning all that by my own and I can't find a ressource that tell me how data structures are normally implemented in C. I have good books on data structures and good books on C and I have to make the junction. (Also english is not my first language, as you may have noticed.) Thanks again.
If you compile in gcc with -O3 you won't get a segfault but compiling without optimizations you will get a segfault. The reason you won't is because p gets optimized out.
Yeah. Just do what is most suitable for the context in which you use it.
It's used so often, I wonder if POSIX allows for it, even if the C standard doesn't.
You've never done any type of coding and you're going straight into algorithms and data structures? Usually those have some intro CSC courses as prerequisites. I'm finishing up my second semester of C and while I only skimmed, this looks pretty decent: http://www.learn-c.org/
I threw this in there for now to cover it, but I'm sure there's a more elegant solution: if (choice == '\n'){ fgets(inputLine,102,stdin); sscanf(inputLine,"%c",&amp;choice); }
I'd also consider using an index into the array instead of a pointer, as it makes neater what would otherwise be messy looking pointer math to find how many items are on the stack. e.g.: struct stack { int idx; #define MAX 5 void *values[MAX]; }; #define StackCount(s) (s)-&gt;idx #define StackHasFreeSpace(s) (s)-&gt;idx &lt; MAX In pointers: struct stack { struct stack *top; void *values[MAX]; }; #define StackCount(s) (&amp;(s)-&gt;values - (s)-&gt;top) #define StackHasFreeSpace(s) ((s)-&gt;top &lt; &amp;(s)-&gt;values[MAX])
I would personally ague for always making a `struct` whenever you have some data that is meant to work together. It makes it clear what is going on by giving the entire thing a name, and makes it easy to make additions later. It's much easier to reason about code when you see a `struct stack` vs. an array and a pointer that you're passing around everywhere. Now that said, it does become a question of what is the best way to design the `struct`. For this, you might consider a FAM (Flexable-Array member). Unfortunately, you can't declare FAM's on the stack, so if you do this then you get stuck having to `malloc` data (or otherwise allocate) every-time you want a `struct stack`. The other options which I like is putting a pointer to your array in the `struct`, and then assigning it with an array before use. Something like this: struct stack { int *top; int *array; }; int main() { int stack_array[20]; struct stack stack = { .array = stack_array }; } This is very similar to the FAM approach, but you can declare it on the stack (By declaring a separate array and then assigning the pointer in `stack` to it). And of course, if you want to avoid all that complexity you could just hard-code a maximum number of members in the stack (Or move to a linked-list-based stack instead).
Being able to compile incomplete code is interesting for testing, debugging, and static analysis purposes. The typical situation in which you end up with missing parts of code is on cross-platform development and when trying to reproduce bugs from snippets.
I can give you further details on the project, I'm working on it. You're right, C being weakly typed brings interesting challenges. But in the end, the program still has typing constraints, although though they can be a bit loose. Think of conversions between integers and pointers. Even when the declaration a variable named `x` is missing, you can assume it has scalar type (an arithmetic or a pointer) whenever you see `x = 0`. In addition, if the syntax `*x` is encountered, then `x` is certainly a pointer (because dereferencing an integer is not allowed). Furthermore, if you also see `*x = 9.9`, you finally conclude that `x` is a pointer to double. In regards to int, int32_t, size, etc, this is indeed problematic. Currently, our goal is to make the code compilable. But although we frequently get the semantics correct, we cannot yet guarantee it. That's an ongoing research.
That doesn't work, it halts after entering the number. I assume it's breaking since that's trying to put a newline char into an int. I could do a separate scanf to pick up the newline into a garbage char, but that's about as elegant as my extra input grab to counter the newline in the comment below. You did point out where the /n is coming from and that led me to use the same buffer as earlier in the program: fgets(inputLine,102,stdin); sscanf(inputLine,"%d",&amp;num); This fixed it in what I believe to be the best way possible, thanks!
Don't know. Low level languages provide insight to how stuff works internally - ~~adresses~~ ~~aaddresses~~ addresses (finally), pointers, meomeomory...
imo those should be for later on... He should be able to learn how things on the higher level work first (loops, if statements, recursion) before going to the low level stuff
HA HA as I've mentioned I am not an expert. But I've worked in software developement 10+ years. In my opinion, you should have at least some basic understanding of how a computer works. Of course, it depends on the specific field you work in. If you're a web developer, you probably don't have to know how gcc places structures in memory. But still, basic knowledge isn't a fault.
Or right the opposite. Low-level enough to learn how a computer works, but it's still not assembler. Plus, it doesn't teach you bad programming practices.
Harvard an University of Illinois Urbana-Champaign both start with C. Stanford and Michigan both start with C++.
Just out of curiosity, how would that work? I believe you that it will, I'm just not entirely understanding what's happening there. Again, I really do appreciate your help - you showed me exactly where my problem was coming from and I was able to deal with it the way my professor recommends.
Harvard is a great school for CS, but it's not considered to be the top. Also I think Stanford starts with Java (CS106A). Here's a shortlist of intro programming languages I found for top CS schools: MIT: Python CMU: Python Stanford: Java Berkeley: Python, Scheme UW: Python, Java UIUC: Choices between Python (103), Java(125), Matlab(101) and C(101) Michigan: Python(EECS182), C++(EECS182, 183) Waterloo: Scheme Also note the following article: http://cacm.acm.org/blogs/blog-cacm/176450-python-is-now-the-most-popular-introductory-teaching-language-at-top-u-s-universities/fulltext &gt; Specifically, eight of the top 10 CS departments (80%), and 27 of the top 39 (69%), teach Python in introductory CS0 or CS1 courses. 
not claiming that I am an expert either. Just saying that stuff like how gcc places structures in memory can be learned in a more advanced course, not an intro class.
C is a tough language to learn coming from 0 computer knowledge. The language is deceptively small. But being a language developed for systems programming, it's difficult to become comfortable with it without knowing it's background and history. Despite this, I think it's definitely the language to learn first if your goal is to learn programming and computers in general. Once you learn to program in C and understand what you're doing with the hardware, you really appreciate the abstractions available in higher level languages and they end up seeming super easy by comparison. 
I like C for a first language as well. It's so plain, and you don't get bogged down looking at how to make a slick GUI or a huge library of functions like Java, C#, Python...
The compiler is free to pack members in different structures differently, as long as it does it consistently within the same structure type. (E.g., it may impose a different alignment requirement on `struct base` than on the `char *` member at the beginning of `struct user`, in which case you could fault on some processors after upcasting from `user` to `base`.) That means can only cast freely between things if you explicitly start the derived structures with an instance of the base structure, so that it knows to identify the two layouts, unless the base structure only comprises a single member and you cast through *its* type instead… which you don’t want to have to do. E.g., do this: struct base { char *name; ... }; struct user { struct base super; int id; ... }; and then the compiler should let you case between `struct base *` and `struct user *` without complaining—thought it might still, which you should take as a warning that the optimizer is overoptimizing or ya done screwed up somewhere. Although this scheme requires you to use `x.base.name` any time you reference the base structure instead of just `x.name`, it also gives you an easy way to upcast from a `struct user` no matter where you end up putting the `struct base` inside it, just by doing `&amp;user.super`—no need to cast at all! Downcasting from `base` has to be explicit, but you can do that in a general-purpose fashion with `union`s or `offsetof` twiddling via macro. In general, it’s safest not to rely upon strict positioning of members in a structure since somebody might come along later and “fix” it by helpfully reordering fields around `super`. Also, you might decide you want more than one base structure per derived structure, in which case your starts-with rule goes out the window. If you’re feeling neurotic, you can run explicit casts through an extra `(void *)` layer or (probably less of a good idea) `(uintptr_t)` cast, which should be explicit enough that the compiler can’t over-/under-alias things during optimization. `union`s will offer you very limited insulation from aliasing mixups, so don’t rely on them for the most part. Note also that some nonstandard C extensions (Microsoft IIRC, and Clang/GCC in Microsoft-compatible modes) let you do struct user { struct base; ... }; which is halfway between explicitly including a named field at the beginning of `struct user` and just pasting in the members from `struct base`. (In C++, this would be roughly the same as extending `user` from a POD class/struct `base`.) You can cast freely and safely between `struct user` and `struct base`, but IMO this doesn’t offer enough of an advantage vs. the portability limitation to make it worthwhile, and because it’s outside the standard it might not keep up with later standards changes around alias analysis. It also doesn’t let you do offset-based upcasting as easily.
the first main got Segmentation fault in gcc
Trt using fflush(stdin) after dequeue returns. It should empty keyboard buffer.
Yeah, may be. When I studied communication electronics some twenty years ago, we started with assembler and Borland c++. But it's not Cs.
EDIT: nvm i guess Integers cannot have fractional parts, doubles can. double x = 3.5; int y = 7; You cannot assign 3.5 to your, because you lose the fractional. You CAN assign 7 to x because the fractional will be 0. Sure, if x was just 3 there's no fractional but that doesn't matter. What matters is that the type has fractionals that need to be accounted for, even if the value doesn't use them. 
Expectations of a reader depend on his/her background. This handle style is used, for example, in Hanson's book on C interfaces and Aho-Ullman's CS book. References have their own accepted semantics: They are small complete types, their copying doesn't affect identity of the underlying objects and they can be checked against `NULL`. The argument about missing warnings for conversion of pointers to incompatible types arises only because of the use of the generic pointer type, `void *`, to provide data abstraction. If declarations `Stack p; void f(int *);` are in effect, then `f(p)` should trigger a compilation warning, because it implies a conversion "as if by assignment" and the pointers are to incompatible types. The standard doesn't permit such conversion with or without type aliases. Type definitions are an extremely weak data abstraction mechanism in C. From the compiler perspective, they hide exactly nothing and just pollute the namespace for ordinary identifiers. But for humans, it helps to deal with the declaration syntax and use simple identifiers to refer to a certain type. The bulk of data abstraction rests in this case on a incomplete structure type declaration. You aren't allowed to use the member access operators, or the indirection operator, or to define the underlying structure object, not because `Stack` is a type alias for "pointer to `struct stack"` — the type definition declares `struct stack` and you can use it in your declarations, but *because `struct stack` is an incomplete type throughout a translation unit-user.* Programmers are supplied with two headers in this case: one that just declares the structure type and another that defines it. Anywhere he/she wants to work without encapsulation, he/she just includes the private interface header. In the normal case, one should never define and initialize the underlying structure object, use `memset` or `memcpy` on it, or access the implementation in any way, as it can break invariants of the data structure and hinder maintenance in the future. But if somebody wants, there is this possibility. The performance issues of non-algorithmic nature can usually be disregarded. Some of them, like possible non-locality of structure objects, can be fixed by crafting the constructor/destructor pair better. PS. Programmers shouldn't use `_t` ending identifiers — they are reserved by POSIX. &gt;If I see somebody cast a Thing to a uintptr_t and back, I’m either going to assume there’s a semantic error or Thing is already an integer, not that Thing is hiding a pointer. That's strange, because `uintptr_t` exists for the sole reason of hiding pointer values, so they can be retrieved back. Also, casts are superfluous for conversion arithmetic types without the variable argument function call setting. 
Show us what you think the opposite version of the code is. To print x out, you'd need to change the printf format specifier to %f, and well as make sure that you're initialising y before x.
`double` denotes a type of floating point numbers. Such numbers consist of a sign, a fraction and an exponent. Different values of the exponent let you numbers that are very small (0.0000000001) or numbers that are very big (10e300 - 1 with 300 zeros). How do you convert the last one into an integer?
No blog spam please.
The C11 standard :) It has examples on compound literals and their behavior (e.g. what happens after `goto`, how many instances, how often is it initialized, and so on).
This is really interesting, I'll have to give it a shot. Thanks!
The string is allocated in read only memory. You need to allocate an array, or allocate dynamic memory, for writable space... malloc etc.
When you do `char *hi = "Hello";` you're actually creating a pointer to a read-only part of the memory. When you later try to change the first element of that memory you get a segfault. What you need to do is assign some memory that your program can write to. The easiest way is to declare variable as an array of char. Then you need to pass a pointer to your function so it can use this writeable memory. An example would be like: void changeCharArray(char *str) { str[0] = 'B'; } /* note: no colon at the end of a function declaration */ int main (int argc, char **argv) { char hi[] = "Hello"; changeCharArray((char *) &amp;hi); printf("%s\n", hi); return 0; } 
Literally no other answer is even comparable. I think I've recommended this guide like 5 times in the past for different network programming issues. It's always the right source.
interesting, I stand corrected. CMU is ranked #24 and Michigan is ranked #47 on your link, really questionable... imo this would be more accurate representation: http://grad-schools.usnews.rankingsandreviews.com/best-graduate-schools/top-science-schools/computer-science-rankings
1: Create a project in your IDE of choice. 2: Think up absolutely any idea for a program that would be useful for you. 3: Start working on this idea. 4: Everytime you don't understand it, google it.
It also helps to imagine the address space (where different pieces of information lie) as a really really long number line. So address 0x3141592 contains 3.14. address 0x3141596 contains 0xFFFFFFFE etc.
It looks like you're trying to use a `for` loop instead of a `while` loop
#include &lt;stdio.h&gt; #include &lt;cs50.h&gt; #include &lt;math.h&gt; int main (void) { float changeback; printf("How much change is needed?"); changeback = GetFloat(); int back = round(changeback * 100); int coinsback = 0; while (back &gt;= 25) { back = back - 25; coinsback++; } while (back &gt;= 10) { back = back - 10; coinsback++; } while (back &gt;= 5) { back = back - 5; coinsback++; } while (back &gt;= 1) { back = back - 1; coinsback++; } printf("%d", coinsback); return 0; } --I can write the same thing in a for loop? 
&gt; Possibility 1). It is peering into the main loop, and paying attention to the following line, which declares element 0 to be "low" and element N-1 to be "high." (In this case, 7 minus 1 is 6) &gt; &gt; quicksort(a, 0, N - 1); No, there's no "peering". That line is calling `quicksort()`, passing 0 and N - 1 for the two arguments `low` and `high` respectively. Then `quicksort()` calls `split()`, passing on those same values: middle = split(a, low, high); The values flow from `main()` to `quicksort()` to `split()` because they are passed as arguments at each call site; there is no special behavior required to explain that. 
You just love pi don't you :) I know what pointers are, as I have some friends who go to a university for programming, but I don't get the point of them (no pun intended). Why can't you reference variables through their name?
Thanks for the clarification!
That's a nice example, I like it, thanks!
Header files have nothing to do with linker errors. Those errors indicate that you need to link against the libraries that provide those functions, which is `secur32.dll` in this case. It means you need to add `-lsecur32` to the link command. (And note that the position where you add `-l` matters; if you're unsure, add it to the end.) 
By their very nature, real numbers (floatS and doubleS) cannot be compared in absolute terms (like you can with intS). They are only approximate in real life. Do something like so: (In C) #define EPS 1e-9 (In C++) const double EPS = 1e-9; And then check if the absolute difference between two double values is within this constant double d1, d2; // ... if (fabs(d1-d2) &lt;= EPS) { // they're equal } You can adjust the value of the EPS constant to suit your precision needs. 
C++ is off topic in this subreddit. Please post C++ content elsewhere.
&gt; But when I use strlen, I am getting something different. strlen returns the length of a zero-terminated array of char (bytes), while you have an array of char * (pointers).
I think you meant to write: while (back&gt;=25) { back -= 25; coinsback++; } Take another look at the syntax of for and while loops.
From the [documentation](https://msdn.microsoft.com/en-us/library/windows/desktop/aa374712(v=vs.85\).aspx). 
FYI for further reading, the EPS he's referring to is the machine epsilon which determines the precision of floating point calculations. https://en.wikipedia.org/wiki/Machine_epsilon
It sounds like you may need to learn how to use a debugger to step through your code. With a good debugger, you can execute your program line by line and see where it is deviating from what you expect. This is an essential tool if you are going to do any programming. Further reading: [How to debug small programs](https://ericlippert.com/2014/03/05/how-to-debug-small-programs/). 
Two important things: if you want to do anything real-time with TCP you'll want to disable Nagle's algorithm (which is on by default) to prevent smaller packets from being queued until enough packets when combined reach a certain threshold. Also, be advised that TCP doesn't handle individual packets like UDP, it will fragment an outgoing packet into multiple packets on the other side, or clump multiple outgoing packets into a single packet on the receiving side. Those are my two cents.
That was just something I was messing around with it should be deleted. The code is still doing the same thing with or without that line. 
 int total_words=11; No, you increment it later when you read each word, so it should be `0` at init. --------- `fgets()` keeps the newline character, `strtok()` keeps it too, so it will end up in your dictionary for each last word of your dictiionary file lines. You need to scrap it at some point. --------- Your `compare_array()` function is very wrong, you don't even loop over the array elements. 
So pointers are just for compatibility? 
They're also for ease of use (init a struct once, you're good for the life of the program). ...which is a form of efficiency, come to think of it...
psudocode, sorry. Here: struct S{ unsigned v1:3; } x={-1} int main(){ int i = x.v1; printf("This is i: %d\n", i); } when printing this i get 7 however if i change v1 to signed or int i get -1. 
[Two's complement](https://en.wikipedia.org/wiki/Two's_complement)
No i didn't get the warning, but thank you so much. I will a post better questions if I post again, thanks you.
You should probably always use flags to tell your compiler to show you all warnings and whatnot. If you use `gcc` you can use `gcc -Wall ...` to show you those things.
Hi! 1) The first thing I see is that you compare fscanf return value with -999. Don't really understand where you've got this value, but fscanf returns the number of successfully got input items (1 in your case). If the end of input is reached or a read error occured, it returns EOF. So your while cycle should look like this: while (input_status != EOF) { ... } 2) Another mistake is that you are trying to print the nums to the same file Scores.txt, which is opened only for reading. I guess you wanted to print it to stdin or to the output file, which you should also open at first.
You are not calling `initArray()`. (plenty of other issues too, but that should fix it.)
Sorry but this phenomenon has nothing to do with 2s Complement. See http://stackoverflow.com/a/2760612/1345960
And also -Wextra (and -pedantic depending on what you're doing) . Make sure to have no warnings ever, it will help a great deal
The difficult part about C is not learning the language, but rather getting familiar with the tools the language provide. If you understand how to use pointers effectively and how to manage your memory, learning C is an easy task. If you don't, you are going to struggle a little. Take your time to learn these concepts, they are very important; not only do they allow you to write in C but they also make you write better programs in other languages because you understand what actually happens when executing the code you wrote.
"The C Programming Language: 2nd Addition" is 189 pages without the appendixes, so **learning** the language isn't hard at all, IMO. However, **understanding** the intricacies like [how pointers work](https://grisha.org/blog/2013/04/02/linus-on-understanding-pointers/) can take a lifetime. Read the linked article and see how long it takes to wrap your head around what Linus says. Blew me away when I first read it; I had to work it out on paper just so I could visualize what was being described.
Learning the language syntax it's very easy, learning how to use it correctly and efficiently not so easy... the difference between C and modern programming languages, like for example Java, C#, Python, ..., is that in C you have to deal with low level stuff, like pointers, memory allocation, all thing that in modern programming languages are abstracted and managed behind the scenes by the language itself, also C have a very small standard library, you have only the basic things, the rest, like advanced data structures like liked lists, hashmaps, trees, you have to implement it yourself, also C lacks of most error checking, the compiler let's you do basically all you want, and most of the errors are silent, you don't have exceptions, your program in the best case will crash, in the worst case will have an unpredictable behavior 
Hmm, this is weird. How do you run your program?
I compile, build then run without debugging. 
Okay, thanks man. Im not sure im a complete beginner. i kept seeing error and it told me to use scanf_s. I will try that :)
OK. And where do you code? CodeBlocks, Visual Studio, CLion, etc?
Yes I do!
Always check the documentation for what the standard library functions return, it's usually useful to check for errors. They also usually set `errno` to an error code if they fail, and then you can use the `perror` function to print out an error message. For `fprintf`, it returns the number of bytes written if it succeeds or a negative number if it fails, and it sets `errno` on failure. So, you can do this: int status; errno = 0; // clear any old error status = fprintf(inp, "%d\n", Scores); if (status &lt; 0) { perror("Printing score"); // prints "Printing score: &lt;error message&gt;" to stderr } For `fscanf`, things are a little more complicated. It returns the number of variables it successfully read. It returns 0 or a positive number less than the number of variables you specified if it can read the file but the file doesn't match the kind of data you told it to look for. Finally, it returns `EOF` if it either reaches the end of the file or encounters an error. It sets `errno` if there was an error. So, full error checking code would look like this: errno = 0; // clear any old error input_status = fscanf(inp, "%d", &amp;Scores); if (input_status &lt; 1) // we didn't successfully read the 'Scores' variable { if (input_status == EOF) // end of file or error { if (errno != 0) // error { perror("Reading score"); // prints "Reading score: &lt;error message&gt; to stderr } else // end of file { fprintf(stderr, "Reading score: end of file\n); } } else // there's something in the file that's not an 'int' { fprintf(stderr, "Reading score: bad data in file\n); } } else // 'Scores' contains valid data read from the file { // use 'Scores' } If you check all the conditions that could happen if a function fails and print something out when they happen, you'll have a much easier time debugging.
&gt; const size_t NAME_LEN = 20; &gt; char name[NAME_LEN + 1]; &gt; int score; &gt; interesting, this might be the hangup thank you, let me try this 
Thanks for the explanation!
Try to use Ctrl + F5 combinaton to run your program from Visual Studio.
[Microsoft's documentation](https://msdn.microsoft.com/en-us/library/w40768et.aspx)
I've hacked out snippets of C code over the years, but only after I followed "The Go Programming Language" and "21st Century C", taking the time to learn about pointers, multiple ways to compile code, and to think in terms of assembly-level data structure implementation, did I begin to understand what the heck I'm doing in C. It might take a while to get better at C, but you'll be a much programmer (in any language) for it.
Honestly the thing that helped me the most was thinking very intently about the fact that "&amp;" means "address of", and "*" means "the contents of an address". I keep editing this trying to eliminate explaining irrelevant aspects. Hopefully it's clear and concise. Let's say `int *mynumber`'s **value** is `0x5932849F`, which is where mynumber actually is. Printing `mynumber` would return `0x5932849F`, printing `*mynumber` would return `4`. `mynumber`, the pointer itself, is located at a completely different location, `0x3842594D`, which could be obtained with `&amp;mynumber`, "address of the pointer `mynumber`". This address is irrelevant. The real value of pointers is that they're like shortcuts. If I had an int called `myuptokes` with the value `13` and an int called `dj2kuptokes` with value `24`, I could easily take a `int *uptokes` and assign it `&amp;myuptokes` and then later on decide to reassign it `&amp;dj2kuptokes`. The value of `myuptokes` might now be `0x5345968D` I'm changing the address contained within `myuptokes`, not creating a completely new int. If I you got another uptoke, I wouldn't be required to modify `dj2kuptokes` directly, I could just set `*uptokes = 24`, which would change the contents of `0x5345968D`, not the address `uptokes` refers to. 
So, it looks like you have a student ID, a first and last name, and some scores terminated with -999. The first part of that is pretty easy. const size_t NAME_LEN = 20; // max number of chars for first and last names int status; int student_id; char first_name[NAME_LEN + 1]; char last_name[NAME_LEN + 1]; status = fscanf(inp, "%d", &amp;student_id); // read an 'int' // handle status status = fscanf(inp, "%20s %20s", first_name, last_name); // read 2 strings separated by whitespace // handle status Now, the scores will be a little more complicated. You'll have to read them one at a time so you don't accidentally read the next student ID when you get to the -999. Depending on what you need to do with them, you might want to put them in an array. const size_t MAX_SCORES = 20; // max number of scores to read int scores[MAX_SCORES + 1]; // + 1 for the -999 if there are MAX_SCORES scores size_t num_scores = 0; // number of scores read so far for (size_t i = 0; i &lt; MAX_SCORES + 1; ++i) // loop through to fill the array { status = fscanf(inp, "%d", &amp;(scores[i])); // read an 'int' if (status &lt; 1) { // handle error } else { if (scores[i] == -999) { break; // done reading scores } ++num_scores; } } After that, `scores[0]` through `scores[num_scores - 1]` will have the scores in it. --- EDIT: Missing comma. Also, thanks for the gold.
I jumped straight from javascript to C and pointers aren't a concept so hard to grasp, i dunno.
The line status = fscanf(inp, "%d" &amp;student_id); gave me an error invalid operator to binary expresson
It's not really a difficult transition since you'll likely be starting with simple programs to acclimate. The most striking difference is the lack of objects but those are just abstractions that can be implemented manually to an extent. Memory management is another large change but you don't need to know anything about it until you actually need to use it. This will likely come when you learn pointers. The only thing I suggest you do to prepare for this is really understand "pass-by-value" vs "pass-by-reference". Also take a peek at memory layout on PCs. How RAM works on a surface level should be sufficient help you understand the concepts you will learn in class. C isn't really scary, don't treat it as such. It's just another programming tool to help you accomplish your goals.
You're absolutely right, C has already made me a better C# and JavaScript programmer without even trying!
My best guess: Learn the basic syntax: A couple days to a week Know most C syntax by memory: A couple months to a year Know good C convention and ¨safe¨ C programming, make code that the industry would begin to deem acceptable: 2-5 years Master the C languge: 10 years to a lifetime Also, a word of advice: pointers are way easier than people make them sound. A good way to assist your C programming is to study computer architecture. Learn about registers, conditional branching, memory, and assembly. It will make understanding C immensely less difficult. 
Which brings up a good point. Do this on Linux. OSX is passable but some libraries are slightly different causing confusion and weirdness when comparing programs against Linux versions.
One of the main thrusts in functional programming is limiting the use of mutable data, because an object graph full of mutable objects can have so many different states that it makes our programs hard to reason about. In C this effect is compounded many times over because these data structures are often represented as collections of mutable pointers to mutable variables, along with various functions that work on that data without any implicit visibility rules. But the basics of memory management, pointers, and arrays in C is dirt simple. It can easily be learned in a matter of days by an intelligent person. Learning the discipline to use them effectively in successively complicated patterns takes much longer, regardless of your understanding memory management.
It depends. Do you want a perfectly repeatable "random" sequence? Then you need to seed random with a known value. If you just want random numbers, then seeding it with the current time is a perfectly fine practice. However, if you are writing software the requires a high level of security then you probably don't want to use rand() at all. There are known attacks that allow someone to predict which seed you used and then know ahead of time which random number will be selected next. If you are seeding rand() with the current time that greatly reduces the search space if they know approximately when your process started.
plus any padding your compiler adds.
I see vim and Atom have been mentioned, so I'm going to also suggest my favorite ~~operating system~~ editor, Emacs. It takes a while to get used to and is a bit byzantine, but there's a lot of cool stuff you can do with it and it's very easy to modify by writing code in Emacs LISP if there's some functionality you'd like that you can't find in an extension made by someone else.
Both versions of create_game() should have the same practical effect; either way you're using a pointer, which means you'll need to manually initialize all of the game struct members. If you're worried about "garbage values", use calloc() instead of malloc() and the returned memory will be initialized to all zeros. You can then continue with initializing the game struct members accordingly. 
First, a minor correction: unless you're returning a subclass of game or reusing an object, these are regular *constructor* functions, not "factory" functions. Your second option won't work because create_game(game); has nowhere to return your new pointer. Perhaps you meant Game game; (no asterisk) to declare the variable. One of the problems with learning C is the sky's the limit in terms of memory management, and there aren't strong conventions. The two general conventions for pointer allocation for functions are *caller*-allocated and *callee*-allocated. (You also need a policy about who frees it). The advantage of callee allocated, like your first example, is that your object pointer can be an opaque type, you can do custom allocation schemes, or you could return a subclass or existing object (for example, to return a singleton). The disadvantage is that there's one more pointer to keep track of. The advantage of caller allocated is that you can allocate these objects on the stack or as a global variable, and then you don't have to worry about freeing. You let the compiler do the work of finding a place for the memory. (You do have to worry if you put the variable on the stack and you go out of scope). Especially in C-land, people can be sensitive about overuse (or use at all) of the heap, and the less you use it, the fewer mistakes you'll make about it. You might even combine these techniques, for example, by having create_game be callee-allocated, but its components be caller-allocated, so you can allocate space for them all at a time. I use a naming convention so I can keep these straight: create/destroy for *callee*-allocated, init/fini for *caller* allocated. As to your other questions, I'm not sure of what you mean by "pointer clashes" or "garbage value of zero".
yar you are right.
&gt; ask them to write a "Hello World" program without using the standard library. I mean, it's not hard to do without the standard library on Linux, but it requires assembly to access system calls. It's impossible (Probably? Prove me wrong.) to write Hello World in pure C, without a C standard library, on Linux, without assembly. I mean, I guess you could encode the instructions in an array, and copy them into a memory mapped page that's writable and executable, then assign the address of the function to a pointer and execute it. Doesn't count if you use an assembler at any point though. Instruction set documentation/references are okay, as long as each instruction is encoded by hand.
We are talking about someone learning C and you use - "Its not hard to do, just use assembly". I think you made my point. The C language is quite massive - the are hundreds of functions in the standard library and the standard library is part of the specification. These libraries make C practical, useful and most importantly, extremely portable. And here is a link to [Hello world without libraries or asm](http://gynvael.coldwind.pl/?id=477) translated from a Polish blog I believe.
Like so many thing in life, C can be learned relatively quickly, but takes a lifetime to master. C was my first language, started roughly 20 years ago at this point, and I'm still learning things.
&gt; Anyone who says this, ask them to write a "Hello World" program without using the standard library. This is a problem in any programming language. Not sure what kind of point you want to make about C.
Actually the C standard library is comparably small. The latest C standard has 701 pages, 278 of which are dedicated to describing the standard library in excruciating detail. That is, there is about half a page per function. Now compare that to the standard library of any modern language, say, [Go](http://golang.org/pkg) and you see just how little that is.
No blog spam please.
&gt; the are hundreds of functions in the standard library and the standard library is part of the specification Yeah, but to print a string to a terminal on Linux, all you need is the write() system call. Hell, a lot of the standard library is pretty easy to implement, given a reasonable kernel.
If your post would do that, that would be fine. However, it's so bad, it's not even wrong. I have no idea what your blog post is trying to say. And please, stop posting these. If you continue doing so, I am going to ban you.
Not all heroes wear capes !!! Beej is an example.
Make sure to learn malloc and free at the same time. :)
This is pure bullshit. If pointers are a problem you should quit programming. Pointers are so easy I can explain it to a five-year-old: a pointer is like the address to your house, inside the house is the actual value. Also, pointers are a FEATURE. They are the greatest thing about C. 
It's not the actual language that takes a long time before it's like second nature; but understanding exactly how each CPU you work with works, which optimizations you should do, which optimizations the compiler you use does, and how to work with the compiler and not ruin its chance to properly do those optimizations. It's knowing that you should use PODs for best optimizations and arranging your struct members in the correct order according to word size because of memory alignment, etc, etc, etc. Then there are all the little quirks of the language, and trust me there are many. 
BTW: Are you in a hurry to learn C for some reason? Pick Python if you just need to write something quickly, right now. 
Did you ask your instructor?
Your algorithm seems fine to me, except that you should only print the valid data portion of the buffer (which is dependent of the length of the input rather than index 19 specifically). Also asking the user if they want to enter more data before outputting the reversed input doesn't seem to be part of the question.
I didnt really understand the first part of your comment with the valid data portion of the buffer. As for the reverse output i just assumed that because it said "up to 20 characters" the user could want to enter 5 and then just not enter anymore.
Syntactically, they are quite similar, so that should be an easier transition. A few character types in Java do not exist in C, notably String. So that might take a while to get used to. Array declarations are a bit different too, and the **new** keyword doesn't exist in C. The C language comes with fewer standard libraries, but on the other hand, there is a rich ecosystem of third party libraries. For coursework, expect to reinvent the wheel a lot (which can be good for learning purposes.) As for the high level view, C is what we used to call a procedural language, while as you know Java is object-oriented. Despite the fancy names, a C program can be fairly object-oriented, and a Java program can be very procedural. It really depends on the use case and the design. There will be new concepts to learn, such as pointer arithmetic, and the preprocessor macros might sound like a weird quirk but I think you'll get used to them. I'd say the biggest thing would be to control your programming reflexes and follow the best practices and conventions for the language you're using. In other words, don't try to force your Java mindset into C. It's tough to explain but hopefully you'll understand what I mean as you get more experienced with C.
All behaviour of pointers is obvious if you stick to the "address of a house" metaphor. People that talk about mysterious "intricacies of pointer usage" are often people who are scared of pointers because of stories they heard but who haven't ever programmed with pointers before.
It is never a good idea to post a picture of code. Always paste your code into the question. Put four spaces in front of every line of code so the code comes out readable.
As I understand it, a character sequence is just a string. So, in this case, just : * reserve room for a 20-character string (20+1 for terminal zero) * read a string limited to 20(+1) characters with `fgets()` from the user * loop the way you like, to print the character at `strlen()-1`, then the character at `strlen()-2`, ... until the character at `0`.
for sure, next i don't share here but you have just misunderstood the content thanks for you moderation dear :)
i'm reading hacking - the art of exploitation right now and I feel he does a really good job of explaining pointers and how they work. walking through the assembly in gdb and everything(memory size of variables and pointers, what casting really does, etc). if you follow along and do it with him on your own computer, even though the asm and memory sizes is slightly different it really helped me understand how they work
You are thinking about this the wrong way. Instead of not wanting to invoke `nextWord()` (which doesn't make any sense), you want to store the value of `nextWord()` the first time you call it and reuse that value for the second usage. Something like this: char *word; while (word = nextWord(), word != NULL) { addWordToTree(firstWord, word); } Note the use of the comma operator which evaluates first its left argument (calling `nextWord()` and assigning the result to `word` for future usage) and then its right argument, finally returning its right argument.
Ok I think I figured it out right before you commented lol. char * word; while(NULL != (word = nextWord())) { addWordToTree(firstWord,word); } It looks very similar to yours and I think does the same thing. What do you think?
When you run a function, the code of that function runs and it eventually returns a value. You can't get the value without running the function, because the function makes the value. (As an aside, you have nothing preventing scanf from putting more than 256 bytes into your word variable, causing a buffer overflow that might be exploitable to allow arbitrary code execution.) What you probably want to do is have a new variable, char *tmpNextWord; And then do "while ((tmpNextWord = nextWord()) != NULL) {", and then use that variable in the body of the while instead of calling the function again.
Sure. I don't have 100% knowledge about why this decision was made but I can describe a use case for this. Suppose you are writing a command line script for some UNIX (Linux or OSX or whatever) system. When writing that script you would want to know when a program that is supposed to run fails for some reason right? That way your script can be smart and do other stuff. Well, when developing in C for UNIX, you can have main return some integer to denote it's status after running. For example, say you try to open a file in your program. If some error occurs that is irrecoverable and you want to program to close, you can just return some negative number. That way any program monitoring your program's status can tell what happens when it closes. Conventionally, returning a negative number means some error occured. It is up to you to document what your return values mean to the user. Typically 0 means your program executed successfully. You could just return 0 every time your program is done but that wouldn't be very useful for other people who want to use it.
Hey man, would you be willing to help me a little more? I now have to make a binary search tree that takes the alphabetically ordered tree I just made and orders it by count. I didn't show before but each word in the binary tree is actually a struct that is made of a count(number of times it appears in the text), the word itself, and a pointer to it's left and right sub tree. That information is out of the scope of my previous question so I didnt bother including it, but I think to be able to help me with the new question you'd need to see my full code. I already made the function to do this. The problem I'm having is how to loop through my new "addWordToTreeByCount" function, since I no longer will have a simple NULL comparison to end the loop. I want the loop to end after all the words are ordered by count, but I don't know how to tell when everything has been ordered. Are you free to take a look at my code and help me out? I think I commented it really well so hopefully it is easy to understand. 
Ok thank you
fscanf() and scanf() are unsafe and should be avoided as to not overflow the input buffer. In this example, you also don't leave room for a null termination of your string, so if the string is 20 characters long, strlen() will not behave well, it will look for the next termination byte past the entire input buffer.
I made a new question, [here](https://www.reddit.com/r/C_Programming/comments/5ikdd9/i_have_a_function_that_takes_a_word_that_has_a/). Hopefully it doesn't seem too overwhelming.
Also officially I would recommend using something like pastebin to make your code more legible if you feel the need to include it in your question. It makes it much easier to read. Because as it stands now, at least on mobile I would not even look at your code, and in fact didn't.
Huch? Why did you delete your question?
Yeah this is what was actually happening
Hey I'm sorry for wasting your time. I talked to my professor and realized I was completely misunderstanding the way he wanted the algorithm to be. So the question I asked was irrelevant because my function was not correct.
You can actually get rid of the NULL comparison in the loop condition. The assignment operator evaluates to the assigned value, and a NULL pointer is "false" for conditionals, so you can do `while((word = nextWord()))` (The extra parens are there because most compilers will warn on this construct because it is a common mistake to use = instead of ==, and the extra parens signal that it is intentional) Any comparison with NULL or 0 can be safely removed. `if(x != NULL)` is the same as `if(x)`
At work so I can't give you step-by-step directions, but search on Google for 'xcode build directory' and you should be able to find help.
You can still do `while ((word = nextWord()))` it's just a bit more clunky 
Store nextWord output in a variable
Can't tell without seeing your code. Best guess is that you're modifying a copy of the variable, not the original.
The code is very long and I don't really have time to make a short one to show my point. Also, isn't the point of structures that you modify it directly, rather than just a copy? That's why I used one.
No, the point of a structure is grouping related data together.
Oooh I suck then. Thanks for the clarification, very appreciated :)
&gt; (I'm going to use c instead of char, since char is an awful variable name choice in C!) In fact, you [shouldn't be able to](http://ideone.com/Bwe2M3) http://www.ibm.com/support/knowledgecenter/SSQ2R2_9.5.1/com.ibm.ent.dbt.zos.doc/ugdita/rcppres.html
I got your point but beginner search as print statement not print function.
you also have to this, they also teach in the same way https://www.cis.upenn.edu/~matuszek/General/JavaSyntax/print-statements.html and this is the university content. https://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output
Okay. Thanks a lot for realizing!
If you do not have enough time to prepare a proper question (that includes posting enough code to reproduce the problem), then please don't ask here. Nobody is getting anything out of the guesswork and insufficiently asked question invariably results in.
Why did you delete this question? Please do not delete questions after receiving an answer! That's really shitty behaviour. How are future visitors with the same problem as you supposed to find this question and its answers when it has been deleted?
I have no idea what you are trying to do. Can you be more specific? What kind of output do you expect? What kind of input do you have? If you have a floating point number you want to print out, consider using `printf`: float f = 123.456; printf("%f\n", f);
`puts()` can only print ready-made strings.
Are there any reasons to do it with puts?
Yes, it is possible. You have to convert the floating point number to a string by some other mean (e.g. `sprintf` or the former POSIX function `ecvt`) and then you can print it with `puts`. You can also try to write your own routine to convert floating point numbers to string but keep in mind that doing so correctly is rather difficult.
&gt; The house is the object the pointer points to. That metaphor works for structs, but not for something like an int * where the dereferenced value is itself the only value. But point taken. &gt; I have never heard the word handle for a pointer to pointer. Might be out-dated terminology at this point, and it seems to have a different usage when it come to Windows programming. Either way, I hold to my assertion that there's a difference between understanding the concept of a pointer as opposed to understanding proper usage.
Neat. :)
I will check on it when i have the time thanks man!!
In this particular use case, `snprintf` is no improvement as the output size of `%f` is already bounded.
&gt; That metaphor works for structs, but not for something like an int * where the dereferenced value is itself the only value. But point taken. Even an `int` is an object. Since you apparently don't know, let me cite the definition of *object* from the C standard (ISO/IEC 9899:2011 §3.15): &gt; ##3.15 object &gt; region of data storage in the execution environment, the contents of which can represent values # &gt; Might be out-dated terminology at this point, and it seems to have a different usage when it come to Windows programming. A handle is a token that refers to some thing. A handle can be a pointer, but it can also be something else, like a string or a number. &gt; Either way, I hold to my assertion that there's a difference between understanding the concept of a pointer as opposed to understanding proper usage. This is a subtly different statement than what you originally stated and I actually agree with that.
Is this a C book or a C++ book?
Your problem is having a `char[5]` which is clearly too small. To solve the problem, increase the buffer to a sufficient size, say 512 characters (a double can be quite large) and/or use `%g` instead of `%f`.
You are right, but my opinion is that it's just a bad manner to use functions that don't check buffer overflow like `gets`, `sprintf`, `scanf("%s", ...)` and others. 
&gt; Even an int is an object. Since you apparently don't know, let me cite the definition of object from the C standard (ISO/IEC 9899:2011 §3.15) Thank you for the clarification. &gt; A handle is a token that refers to some thing. A handle can be a pointer, but it can also be something else, like a string or a number. Not in the context in which I'm familiar with it, which is [classic Mac OS programming](https://news.ycombinator.com/item?id=9602611). As I mentioned, Windows terminology is different. Chaulk it up to different experiences. &gt; This is a subtly different statement than what you originally stated and I actually agree with that. Then I wasn't clear, and that falls on me.
C. buildyourownlisp.com
If you know that there can't be overflow, using a function without overflow check is fine and in fact, using a function that does check for overflow doesn't help much, may create additional errors (e.g. in case of the dreaded `strncpy`, unterminated strings) and adds noise to the code.
It's defined to be 7 in a .h file that I included . Wouldn't that mean that it's taken to be 7?
It doesn't matter what the value is. If you have array[N] then valid indices are 0 -&gt; N-1
do you have any idea on how I can find the shortest path?
I thought I got pointers but I tried following Stanfords CS107 and got totally lost when they write generic data structures, passing around void* around and casting all kind of things to char*... definitely got a new appreciation for the difficulty of pointers.
Ah... Thanks for that info... That last bit you said sounds a lot like when I had to use a interlocked-exchange and interlocked-compare-exchange before on threads waiting for work. Only, that application had nothing to do with file IO so I wasn't sure how that worked! Thanks again!
How does this mesh with the C preprocessor?
Disappointed with the macro example. It looks like a mashed together C and Common Lisp, not a lispy version of C.
The macros are written in common lisp generating the sxc language. It's meant to be a Lisp syntax version of C, not a 'lispy' version of C, so that the cognitive load of learning the syntax is lessened. I wrote the 'syntax' over time as I went through the K&amp;R C Book and codified the examples. It's not perfect, but it's familiar and straight forward for those that know both Common Lisp and C.
It's a good start! Ideally, you want to avoid the use of global variables as much as possible. Global variables are those variables which appear outside of functions and can be accessed from every function which generally makes them unsafe to use. What you should look into is passing variables between functions so that certain variables can only be used by certain functions. The two ways to pass variables in C is "Passing by Value" and "Passing a reference". Do a little research in passing variables (called parameters or arguments) by both of those methods and see which would be best for use in your program.
Nice! Try to use `double` instead of `float` where possible to get better precision.
Thanks everyone for the suggestions! I love this way of programming, which involves a discussion in order to write better code. Right now I'm reading the comments, and I will improve the program researching about the things you linked me to. Thanks again :) x
&gt; Your functions return floats but you display them as doubless (with "%.3lf"); That is not wrong. When passing floats to variable-argument functions, they are implicitly converted to doubles anyway. 
&gt; If speed isn't too much of a concern You can have both by using inline functions for those little accessors and defining them in an appropriate header file.
Global variables cause sheer havoc with concurrency, which is not a niche concern in the modern age. Your "advice" is dangerously short-sighted, imo.
If you concurrently modify and read variables, then you have trouble in concurrent programs, that's true. However, that's true for all kinds of variables, not sure why you single out global variables and somehow pretend that's a special property of them.
Well I'd think its just like declaring the a struct var and it was just a coincidence that I'd think it's the same name as the structure? Maybe I'll look again through it, I feel like I just missed your point. Also I have no been taught debugging so I don't think I can check but I named the statement as x and printed it as an int, it returns a -1 at every trial. Edit: I think the name being an array of 50 is logically not what I'm looking for. Thanks for pointing that out!
&gt; Also I have no been taught debugging so I don't think I can check but I named the statement as x and printed it as an int, it returns a -1 at every trial. This means that there is some sort of error going on. Can you do me a favour and check if `f` was actually opened succesfully? You can do so by comparing `f` with `NULL` after calling `fopen`. If it is `NULL`, the file was not opened. You can find out the reason by calling `perror(NULL)`.
C:\Computer Programmaing\Phonebook is where the program is, and telephonenumbers.txt has the same directory, since I've created the file right next to the C file. As for the commands I use to execute my program, are you referring to what I input to the program? If so, then this is the function for the operations: int operation(int op) { int y; char key[20]; switch (op) { case 1: printf("Who are you searching for?\n"); scanf("%s",key); search(key); break; case 2: store(); break; case 3: printf("Number of phone numbers: %d\n",count); break; case 4: printall(); break; case 0: return 0; default: printf("Invalid input. Please try again.\n"); } return 1; }
&gt; not sure why you single out global variables The 'errno' variable is a famous example of the problems that arise from the advice to "make important variables all functions use global", and which required some tricky mitigation to fix. Granted, you specifically mentioned "self-contained" in that context, but I do think it's fair to at least *warn* new-comers of this problem when discussing what they "need to know about global variables".
Why would you expect to have to enter something twice? Btw, getchar() is a better choice when you're just reading a character at a time.
Wow, thanks for all that info! That was amazingly helpful and insightful! If I could give 100 upvotes, I would.
&gt; Nor is it the default Which is a good thing as thread-local variables are a) slower and b) have to be allocated for each thread. &gt; In general, I feel global state designs using global C variables are more likely to need a large refactor down the line If you plan your global state carefully and your program doesn't change what it's supposed to do, then no large-scale refactor is needed. If you don't plan carefully or decide that your program should now be a library to be instantiated multiple times in the same program, then yes, large-scale refactor might be needed. Nothing else is what I said in my original comment. &gt; That is why I "singled out" globals in a concurrency context as being problematic. It's not globals that are problematic, it's shared memory in general. (That's why I am a huge fan of CSP's *share memory by communicating* paradigm.) Global variables are just a tool that do exactly what it says on the tin. They are not inherently unsafe, they are not inherently wrong, they are not inherently a bad thing. they can however be misused in a number of ways. Global variables don't make bad programs, bad programmers do. 
Really nice game! Especially for someone who's in their first college year! I managed to get it to run on FreeBSD by fixing `getWorkingDirectory` to query `/proc/curproc/file` instead of `/proc/self/exec`. The FreeBSD interface is a little bit different. The standard function to get the working directory is to run `getcwd()`. However, it seems that you do not actually want the working directory but rather the directory where your program is installed. This is tricky to do portably as different operating systems have different methods to do that. The most portable method is to install a little script instead of your program. This script sets an environment variable to the path of your program and then runs your program. You generate the script as you install the program to fill it with appropriate parameters. Something like this: In `/usr/bin/spaceinvaders`: #!/bin/sh SPACEINVADERS_SFX=/usr/share/spaceinvaders/sfx export SPACEINVADERS_SFX exec /usr/libexec/spaceinvaders and then your actual binary goes into `/usr/libexec/spaceinvaders` and fills `WORKING_DIR` from that environment variable.
You should put a **huge** disclaimer in front that your examples use non-standard gcc extensions (i.e. `({ ... })`).
Congrats! =D I would love to play. 
My friend and I ...
How much Portuguese do you know? 
Enough to know not to use reddit as a source for proper sentence construction.
You never call your get_coins and get_type functions.
[removed]
oh well guess what buddy this is gonna blow your mind - this isn't a goddamn interview or a job or anything you limp cock I'm not applying to your company, ya lil' "this guy's uneducated because he used ME instead of I" wienerboy. Also, how effin dense are you to compare English and programming languages? That's the whole goddamn point of spoken languages, outside of super formal fields, if you get the meaning across, it works. Let me know the last time you compiled English, you fuckin' poser. suck jo mama titty you bitchboy
Lines 19 and 31 don't do what you think they do. Look up "how to call a function in C."
In `main.c`: int main() { Valid prototypes are of the kind of: int main(void) { or int main(int argc, char **argv) { 
`double constant = 8.31; //if you need to use the 0.0821 one, change this line` Since the value of `constant` is not going to be changing at runtime, you can just use `#define` in the preprocessor to take care of it. pression = (numberMoles * constant * temperature) / volume; return pression; You probably don't need to bother with making a `pression` variable at all. You can combine the two: return (numberMoles * constant * temperature) / volume; Now, look at the below block of code. if (choiceFunc == 'p') printf("\nPression is equal to %.3lf Pascal.\n\n", calcPression()); else if (choiceFunc == 'v') printf("\nVolume is equal to %.3lf cube metres.\n\n", calcVolume()); else if (choiceFunc == 'n') printf("\nNumber of Moles is equal to %.3lf mol.\n\n", calcNumberMoles()); else if (choiceFunc == 't') printf("\nTemperature is equal to %.3lf Kelvin.\n\n", calcTemperature()); Do you notice something? At the start of every single `printf()`, you print a newline. What may be more efficient (and will definitely make the code simpler) is to use `putchar()` once before even starting the `if()` to print a new line, then you can do something similar to print the last newline.
You need to assign the proper variables to the functions you've declared; what you've done is basically declare your 2 functions twice. Line 19 should read something like count = get_coins() ; and line 31 should read something like calltype = get_type() ; 
Not exactly, he uses global variables (it seems that there is an epidemic of these lately). But he's confused about it, he prototyped his functions as if they should return values. Hint for OP: do not use global variables, use functions in a functional way, not as procedures, and things will get clearer. For example: int get_coins(void) { int coin_select; printf("Enter a coin [10c, 20c or 50c]. Enter 0 when done: "); scanf("%d", &amp;coin_select); return coin_select; } int main() { int coin; /* ... */ do { coin=get_coins(); /* ... */
Good eye, I obviously didn't read it closely enough, only paid attention to the function prototypes. Open mouth insert foot...
Functions like fputs() and fprintf().
`int main() {` is compatible to `int main(void) {` and valid.
sure thing, sweet soul brother
Thank you.
I have never, ever, seen a reddit mod say such a thing on reddit before.
readv/writev, memory mapped i/o, maybe even exploring different filesystem types or getting into the kernel. you're going to be a systems programmer when you're done.
On line 16, you're missing [] between Hero1 and the equals sign. char Hero1 [] = "Batman";
Thanks, when I compile it however the (11db) still shows up any ideas?
Ok figured out what was wrong, thanks for your help!
Floating point to integer conversions always round down. If you want an integer result, keep everything as a double, then round at the end.
Note that `8` is an integer and so is `100`. Thus, `8/100` uses integer division and results in `0`. If you want the compiler to use floating point division, instead write `8.0/100` or similar. As `8.0` is a floating point constant, `8.0/100` is evaluated using floating point division.
See [beej socket guide](http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html) - specifically the question titled: **How do I change or shorten the timeout on a call to connect()?**
Still no luck...I think there's something sneaky in the code that's screwing it all up.
What integer do you think 20/100 is equal to?
int main() { /* Enter your code here. Read input from STDIN. Print output to STDOUT */ double mealCost; double tip; double tax; double totalCost; scanf("%d",&amp;mealCost); printf("%d\n", mealCost); tip = (20.0/100)*mealCost; printf("%.2f\n", tip); tax = (8.0/100)*mealCost; printf("%.2f\n", tax); totalCost = mealCost+tip+tax; printf("The total meal cost is %i dollars", totalCost); return 0; } Tried it... The values going in are 12 for the mealCost, then 20 percent tip and 8 percent tax then the total cost at the end but none of those numbers are being computed.
On typical systems with IEEE 754 floating point numbers (that is, almost all systems), a float (single-precision floating point number) is a 32 bit floating point number and a double (double-precision floating point number) is a 64 bit floating point number. Due to its larger size, a double both has more precision than a float and unless doubles are not fast enough or too large to store you should always use doubles. There are also extended precision floating point numbers (`long double`) which have 80 bit on x86 and varying sizes on other platforms but you shouldn't use them unless you need that extra precision.
It is not the variable, it is the constant: 20 is an int litteral 100 is an int litteral So, 20/100 is an int, and equal to 0. If you use 20.0, then it is a double litteral, which, when mixed with an int gives a double. Hence: 20.0/100 =&gt; 0.2 20/100.0 =&gt; 0.2 20.0/100.0 =&gt; 0.2 20/100 =&gt; 0 The type of the variable is not the issue. int x = 20.0/100; x will be 0, of course, but due to the conversion of 0.2 into int. float x = 20/100; X will be 0.0, but due to the convesion of 0 into float. Makes sense?
%d in scanf does NOT mean double.
Yeah. Speed-wise, single precision floating point numbers are some times faster, but that depends on what architecture you use. For example, on i386 with the i387 FPU, intermediate results are always computed as extended precision unless you set the internal precision to something else but nobody does that, making single-precision floats not actually any faster. There is a size argument, if at all.
It's still giving a massive number. Think I'm going to leave this program for now and come back to it later it's just frustrating right now and sorry will keep that in mind next time!
For next time, make sure mealCost is what you think it is. Add in a `printf("mealCost = %f\n", mealCost);` after the `scanf` and see if it's right. If it's not, then make sure the `scanf` is right.
I'm a mod on SO. I know how you feel but my problems are not as bad as yours. 
Actually it's rather easy to moderate this subreddit. The most annoying thing is to explain to all these Indian blog spammers that their shitty C tutorials are not welcome here. The second most annoying thing is to remind people that they should not delete their threads after receiving an answer. A close third is telling people to actually read the damn markdown tutorial so their code is not all garbled.
This line in the link: if(connect(sock,(struct sockaddr *)&amp;address,sizeof(address))==false) stands out as something wrong. The `connect` function returns an `int`; so, comparing it to `false` isn't the correct thing to do. I'd do something more like this: #ifndef _WIN32 # define POSIX_SOCKETS #endif #ifdef POSIX_SOCKETS typedef int socket_type; #else typedef SOCKET socket_type; #endif socket_type ConnectToHost(const char* host, uint16_t port, time_t timeout_secs) { // CREATE SOCKET socket_type sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (sock &lt; 0) { perror("socket()"); return -1; } // SET NON-BLOCKING MODE #ifdef POSIX_SOCKETS int sockopts = fcntl(sock, F_GETFL); sockopts |= O_NONBLOCK; if (fcntl(sock, F_SETFL, sockopts) &lt; 0) { perror("fcntl()"); return -1; } #else unsigned long mode = 1; int result = NO_ERROR; if ((result = ioctlsocket(sock, FIONBIO, &amp;mode)) != NO_ERROR) { fprintf(stderr, "ioctlsocket(): error %d\n", result); return -1; } #endif // START CONNECTING SOCKET struct sockaddr_in addr = { 0 }; addr.sin_addr.s_addr = inet_addr(host); addr.sin_port = htons(port); addr.sin_family = AF_INET; if (connect(sock, (struct sockaddr*)(&amp;addr), sizeof(addr)) &lt; 0) { if (errno != EINPROGRESS) { perror("connect()"); return -1; } } // WAIT FOR TIMEOUT fd_set set_write, set_error; FD_ZERO(&amp;set_write); FD_ZERO(&amp;set_error) FD_SET(sock, &amp;set_write); FD_SET(sock, &amp;set_error); struct timeval timeout = { .tv_sec = timeout_secs, .tv_usec = 0 }; if (select(sock + 1, NULL, &amp;set_write, &amp;set_error, &amp;timeout) &lt; 0) { perror("select()"); return -1; } if (FD_ISSET(sock, &amp;set_error)) { #ifdef POSIX_SOCKETS close(sock); #else closesocket(sock); #endif return -1; } // SET BACK TO BLOCKING MODE #ifdef POSIX_SOCKETS sockopts &amp;= ~O_NONBLOCK; if (fcntl(sock, F_SETFL, sockopts) &lt; 0) { perror("fcntl()"); close(sock); return -1; } #else mode = 0; if ((result = ioctlsocket(sock, FIONBIO, &amp;mode)) != NO_ERROR) { fprintf(stderr, "ioctlsocket(): error %d\n", result); closesocket(sock); return -1; } #endif return sock; } I think I got all the differences between POSIX sockets and Winsock covered in there, but you'll have to test it yourself.
Look at the conditions on the loops. The first loop is: while (input_char == '\n') The `input_char` variable is initialized to `'\n'`; so, it's going to execute at least once. The only way it's going to repeat is if the first thing the user types is a newline character, i.e., they press enter without typing anything. It will keep looping if they keep pressing enter, but as soon as they type any character, it will read that into `input_char` and go out of the loop. The next loop's condition is: while (input_char != '\n') The last loop left us with this condition being true. So, it's going to loop until the user presses enter. The first thing that happens inside of the loop is the `input_char` gets stored at the location pointed to by `name_ptr`; so, the first time through, the character the other `scanf` read is going to be saved. The last character read by the second `scanf` isn't going to be saved, but we don't want that because it's a newline character, and we just want the name.
I thought the denom needed to be a float
This is pretty cool! You must have spent almost as much time on the documentation as the code itself. I really like how you did the interface. I'm imaging a user could add all of the indicators to their project with only a few lines of code. Is the "part of a larger project" you mention Tulip Charts? Any idea when it'll be released?
I'm glad you like it. Yes, the documentation took a lot of work. I'm far from done with it though. The code is much more 'done' than the documentation. But it's all a work in progress that I plan to support for at least the next few years. Yes, Tulip Charts is the other project. Not sure when it'll release. Probably at least a couple months from today. Hopefully not much more. I did the interface in a generic/abstract way very much on purpose. Tulip Charts uses Lua, and the Lua binding to Tulip Indicators are only 170 lines of C code (including setup, error checking, reflection, etc). The best part is, every time I update Tulip Indicators with new functions, I only need to recompile and they're available in Lua. Having the generic interface has made my life much easier.
That website is horrible on mobile...
Bits from bytes* And you use a mask and shift. Take a look at my library [BitIO](github.com/bumblebritches57/bitio) on github if you want. (The code still needs some serious cleanup and reorganization, but take a look at ReadBits in BitIO.c)
Does c4lib depend on gcc extensions? I thought `typeof` was non-standard, and I'm certain that nesting functions, like in the example, are non-standard. 
Assertions area much simpler than people should make them out to be. It tests an expression for a zero value and if so terminates the program - with some descriptive information of where the failure occurs. #include &lt;assert.h&gt; int main() { int x = 10*200; assert(x == 200); /* if x is not 200 then terminate */ } When run, the assert will terminate the program and will indicate exactly where the assert failed. Assertion failed: (x == 200), function main, file t.c, line 5. It can be used for doing quick unit tests, or ensuring run-time consistency, and usually can be disabled by defining `NDEBUG` in the preprocessor. I'm not sure how or if assert is implemented on embedded systems and how, but it is a pretty versatile. It is part of the standard and is required to be implemented as a macro.
aka exploding comments. 
They work fine in Clang as well. I'm prepared to do whatever it takes to help the rest of the world catch up :)
Typically, libraries installed by the operating system's package manager go in `/usr/lib`, and libraries installed manually go in `/usr/local/lib`. However, some users might want to install your library in a different place; for example, a user without root access on a shared machine might use `$HOME/.local/lib`. The best way to handle this is to allow the user to specify a prefix directory when they install the library. Then, you install your library to `$PREFIX/lib`, your headers to `$PREFIX/include`, and so on. If no prefix is specified, the usual default is `/usr/local`.
There is nothing to “catch up.” These extensions are not in the standard for a good reason (very complicated to implement, impossible on some platforms, and some cause security issues by requiring an executable stack) and I don't want to use non-standard features in my projects. You know, just because you've never used anything but Linux as a development platform doesn't mean that everything else (and especially every other compiler) is irrelevant.
It does, but they work just as fine in clang. Writing C without them when you don't absolutely have to is madness.
`difftime` just does a subtraction, you don't really need this function nowadays. Plus, you are using the wrong formatting specifier for a `time_t`. You should manually cast the result of `difftime` to `double`.
The 1st one is zero because you get the 1st value of current_time immediately after getting the value of start_time (there's just the start of the while loop inbetween). Do you see 10 seconds elapse between printing the 1st line and the 2nd?
That is expected, but the 2nd and 3rd reading should not be 0. 
The only thing I'm asking you to do is to inform the reader that you are using non-portable gcc extensions as a courtesy to the reader. If you don't want to do that, that's fine but frustrating for readers who only find out afterwards.
gcc and clang are not the entire world.
Those look like useful features, and if you can guarantee that code will only be in those environments then cool. However, would that work in VC, or Intel's compilers? 
Arrays can be on the stack or the heap. But, yes, the address and the index are used to calculate the address of the element being accessed.
&gt;Arrays can be stack or heap allocated. There are other options too.
Yes, I wasn't trying to be exhaustive and I was only trying to cover run-time allocation. I didn't want to go deeper than that as I don't think it's needed for the target audience, but maybe I should make that clearer in my post.
You are gonna have to internet the hell out of it then. What kinda database is it? SQL? Flat? Other? plenty of example code out there. provide your code so far and you may get more help. 
(speaking x86) The stack can be used with `PUSH` and `POP` instructions, but since it is in fact just a memory space that the stack pointer (SP/BP) references, you can access anything the stack contains with a normal indexed addressing mode (stuff like`mov AX, [BP-offset]`), without modiying the stack pointer itself, without adding or removing elements from the stack. 
No thank you. To borrow [a quote from Raymond Chen](https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783), "When I fire up an editor on a file whose name ends in ".c" I expect that what I see will be C and not some strange dialect that strongly resembles C except in the places where it doesn't." (His actual quote is about C++, but I think this is true for any language.) In general, his whole *Rant against flow control macros* sums up how I feel about this. Macros where one of the parameters must be a block? Yuck. Code where you have to return from a function using `C4CORET` rather than `return`? Yuck. (If that's even what `C4CORET` does; I couldn't find sufficient documentation to understand how to use this weird language that isn't C.)
This subreddit is about C, not C++. Please post C++ content elsewhere.
Yeah I was confused because I'm used to pushing and poping single elements to the stack, and that would be very inefficient and weird to implement here! 
The traditional location is `/usr/local/*`, but that's a bit messy so I usually install my stuff to `/usr/local/Packages/PackageName/*`
Read the damn sidebar dude. Is it really that hard to not start freaking out for 30 seconds to read the damn sidebar? you'd get better answers that way. As it stands, no one knows what the hell you need help with, and this may not even be the sub you're looking for (databases are generally not something you'd ask C devs about...)
That’s the way Java does “multidimensional” arrays, but C has actual multidimensional arrays and doesn’t need to pointer-chase. (The above array would work if declared as `foo_t *array[n]`, but `foo_t array[n][m]` describes an array of `n` arrays of `m` elements directly.) C is row-major, so given base address `arr` (not a pointer, just an address), row index `n` and column index `m`, column dimension `c`, and element size `s`, you’d have *(arr + (m + n*c) * s) for `arr[n][m]`. As you increase in number of dimensions, say for an array declared as `arr[c3][c2][c1]` with accessed indices `[i3][i2][i1]`, you just bump up the order of the polynomial: *(arr + (i1 + (i2 + i3 * c2) * c1) * s) 
a[i] is essentially exactly equivalent to *(a + i), which is to say the address at a, plus i * sizeof(*a), dereferenced, and that's your value. Arrays have slightly special handling in the compiler, because their types are slightly funky, but if you pass them or do any math with them, they turn into pointers. Even a+0 is a different type from a, because a+0 is a pointer, and of course a+0 == a, and anything you might do with a+0 you can do with a, except sizeof(a) == 10*sizeof(int), the size of the space taken up by the array, and sizeof(a+0) == sizeof(int *), the size of the space needed to store the pointer. 
I wanted to learn a bit of C so I wrote an implementation of the Arduino library to interpret it on my computer. For the moment, it only supports the basics options. I hope you will like it.
Actually, you're subtly wrong. arr[n][m] == \*(\*(arr + n) + m). They're exactly equivalent. Suppose, for sake of argument, that `char arr[10][10]` is the definition of arr. The type of arr is char [10][10]. This means that sizeof(arr) == 100. When you add something to an array, it changes type to a pointer, so it becomes type char\* [10]. sizeof(\*(arr + 0)) == 10. sizeof(arr+10) == sizeof(char(\*)[10]) which is probably sizeof(char\*). Therefore, \*(arr + n) == \*arr + 10\*n, because sizeof(\*arr) = 10. When you do arr+n, it has type char\*[10]. You dereference, and you get type char[10], which has size 10. When you add to this type, first it turns into type char\*, and then you add m to it, and you get another char\*. So, when you dereference that, you get the equivalent of \*(\*arr + 10\*n + m), yes, but you also get the equivalent of \*(\*(arr + n) + m), because of how the C type system works. 
Clearly you've never been to /r/politics ;)
I can barely tell what you’re saying because of formatting—`*` makes things italic—but I’ll guess. I think there’s some confusion from the fact that we had two different overloads of the C syntax; I was using `*` as an assembly-level dereference because the `arr[n]` operation is really only pointer math (no non-theoretical dereference involved); the parent comment, however, used the `a[n] == *(a+n)` equivalence to oversimplify and make it seem like there are multiple dereference operations, and while the language lets you do it syntactically with no difference from the Java array-of-pointers approach, it’s certainly not what’s happening under the hood. I’ve seen enough people confused in just that fashion that I wanted to point it out. Also, `arr+n` has type `char (*)[10]`, not `char *[10]`, and therefore `sizeof(arr + 10) == sizeof(char(*)[])`, which is ususally the same as but conceptually distinct from `sizeof(char *)` and certainly not 10 unless you’re dealing with some really weird architecture/ABI. Again, the syntax for going through a `char **` is the same as the syntax for going through a `char *[]` or `char[][]`, but the last one involves a very different set of underlying operations and those were what I was addressing primarily.
The Arduino implementation is in C++ but the Arduino language itself is more C than C++. As I wanted to learn C, I implemented the Arduino library in C but I could have done it in C++ if I wanted. 
I don't think this is the best approach for people without any programming knowledge (at least not for everyone), as they don't know how a computer program looks, or how exactly to start.
Oh, screw everything. I hate the plethora of backslashes I need on technical subreddits. Please revisit what I said, now that it's readable. In particular, note that I had originally typed `sizeof(*(arr+0)) == 10`. In a conceptual, under-the-hood C-theoretic world, not an assembly world, the syntax tree (or equivalent partially-evaluated structure) generated by parsing the C is first to evaluate the type of `arr[n]` as being `*(arr + n)` which is to say the same address as `*arr + n*sizeof(*arr)`, but with type `char[10]` instead of `char*`, and then it does the second round of dereferencing with m, leading to `*(*(arr + n) + m)` being evaluated as `**arr + n*sizeof(*arr) + m*sizeof(**arr)` with type `char`, which does work. The evaluation of `arr[n][m]` is therefore pretty much identical to that of `*(*(arr + n) + m)`. This is not an oversimplification at all, because of the way the type system works, as you clearly understand.
Yup you're right I might have to migrate the project to C++ or have C and C++ combined in some way for some extended feature. I will think about it. Thanks for your feedback! 
So yeah, we’re just going at it from different angles. Same parse tree so the C language sorta treats them the same—though the object/alias/nullness/definedness analyses do come out a bit different—but under the hood, the first “indirections” are just MACs and only the final one actually induces a load/store. This is one area where C really pisses me off TBH—I get why they did what they did w.r.t. the pointer-array relationship and all the exceptions around arrays, but it doesn’t seem worth the semantic or analytical costs to me, when the worst-case otherwise would be having to cast occasionally. I’ve seen so much confusion about C arrays (and strings, ye gods the shit I’ve seen) and the linguistic haze that surrounds them, especially when somebody’s coming from Java, Python, Javascript, etc. where everything is a pointer-value alternation, and shit would be so much cleaner if arrays behaved like indexable `struct`s.
Is this for a C programming class? If so you need to talk to your teacher and get some specifics. Like what kind of database are you supposed to use? Should you be hashing and salting your passwords? Are you using ncurses for the user interface (which seems implied by the language "menu with selectable options")? if this is not for a C programming class, then implementing it as a web application would probably be easier.
I for one like to use `'\0'` for memset if I'm zeroing a `char*`. It's kind of implicit documentation.
Why would you want to put it into a C string? Just `sendfile` it.
Everyone has explained pointers. I just wanted to mention why `*` can be incredibly confusing. There are 3 uses of `*` in C: 1. multiplying: `a * b` 2. specify a pointer type: `float *` or `int *` 3. dereference a pointer value: `int y = 10; int *x = &amp;y; *x = 20; /* sets y to 20 */`
Note that `'\0'` has type `int`, just as `0` has, so it's not the only correct constant to use. However, as /u/Azzk1kr said, there is a very good semantic argument to be made.
You can either write your own tool for the task or use one of the many existing tools like those mentioned by the other users.
https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator https://en.wikipedia.org/wiki/Memory_protection
A cryptographically secure PRNG has the property that an attacker can observe an arbitrary number of outputs without being able to derive the internal state of the generator and thus predict future outputs. Simple algorithms like the [linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator) typically used by standard libraries for `rand()` do not have this property, because the output is directly taken from the internal state, possibly with a bitmask. That makes it very easy to be able to predict the entire sequence having only seen a couple of outputs. Even more advanced schemes the like Mersenne Twister which has a huge amount of internal state (over 2KB) are not cryptographically secure, because they still expose parts of that state in the output, so you just need to observe more of the outputs before you can recover the complete internal state. It's pretty hard for a mortal to judge whether an arbitrary PRNG is cryptographically secure, so basically you can only assume a PRNG is safe for cryptography if it was designed by a cryptographer for that explicit purpose and has undergone peer review by other cryptographers worldwide. The problem with storing passwords in memory is that you have to fight against compiler optimizers. For example: bool is_authorized(void) { bool auth; char buf[256]; puts("enter your password:"); fgets(buf, sizeof(buf), stdin); // ... bool auth = ... // verify password somehow // ... memset(buf, 0, sizeof(buf)); return auth; } To the compiler, that `memset()` is dead code, because once `buf` goes out of scope, no well-formed C program can access it, so it doesn't matter what it contains. (Anything that would expose its contents, such as reading outside of bounds, or reading the contents of an uninitialized variable, are undefined behavior.) An optimizing compiler is very likely to simply remove that statement, and the sensitive information will continue to live on in memory, possibly leading to a disclosure. The issue is the conflict between the C standard's abstract machine model and the real world. To do this properly is kind of tricky because it requires extra cooperation between the standard library and compiler. On windows there's `SecureZeroMemory()`, on OpenBSD there's `explicit_bzero()`, and C11 defines `memset_s()` but there's been little adoption AFAIK. Most of the time you have to play games with volatile if you want a portable way of doing this, or write it in direct asm. And that's not even the whole problem, because the compiler is allowed to copy data into arbitrary places, e.g. there could be register spill slots on the stack that contain portions of the sensitive data. The problem is that there's really no conception of "don't leak data" at the C level, so all of the things the compiler is trying to do to make your code faster are in opposition to this. 
Jesus christ, that's SO wasteful! That's 16 bytes of just padding! that's more than double the size smh.
I used to use `'\0'` whenever I called memset\*. But about five years ago I got tired of typing the three extra characters. \* (if zero was the desired value)
I would try to use SDL_Mixer, [https://www.libsdl.org/projects/SDL_mixer/](https://www.libsdl.org/projects/SDL_mixer/). I'm currently working on a synth, entirely in C, and there are some fun audio functions that will basically let SDL do all of the hard work, and you can use mathematics to make waveforms, and everything else.
Having gone through [the GNU Make manual](https://www.gnu.org/software/make/manual/), I've come up with the following rules: prefix = /usr/local sysconfdir = $(prefix)/etc sharedstatedir = $(prefix)/com includedir = $(prefix)/include oldincludedir = /usr/include localstatedir = $(prefix)/var runstatedir = $(localstatedir)/run datarootdir = $(prefix)/share datadir = $(datarootdir) docdir = $(datarootdir)/doc htmldir = $(docdir) dvidir = $(docdir) pdfdir = $(docdir) psdir = $(docdir) infodir = $(datarootdir)/info lispdir = $(datarootdir)/emacs/site-lisp localedir = $(datarootdir)/locale mandir = $(datarootdir)/man man1dir = $(mandir)/man1 man2dir = $(mandir)/man2 manext = .1 man1ext = .1 man2ext = .2 exec_prefix = $(prefix) bindir = $(exec_prefix)/bin sbindir = $(exec_prefix)/sbin libexecdir = $(exec_prefix)/libexec libdir = $(exec_prefix)/lib And for the install target, I do something like: install: $(INSTALL) -d $(DESTDIR)$(bindir) $(INSTALL_PROGRAM) foo $(DESTDIR)$(bindir) The reason for the $(DESTDIR) (which is not defined in the Makefile) is for making a package (tarball, RPM, Debian package, etc). You do a "make DESTDIR=/tmp/foo install" and everything will be installed relative to /tmp/foo (also useful for testing to make sure everything goes in the proper place without cluttering up the filesystem). 
What are you trying to do here? Faster than what?
In this case with buf never being read from again, would the compiler optimize out any code at the end that only does writes to location? Or, does it just have knowledge of what memset does? Is it enough just to write your own function that does the zeroing, or just using arbitrary meaningless data? Could you read like one byte from buf right after zeroing it to get the compiler to leave it alone?
If you want to play a MIDI file, Fluidsynth is probably what you want. You'll need to load a soundfont. http://fluidsynth.sourceforge.net/api/index.html#MIDIPlayer
If the compiler doesn't know what memset() is, then you'd probably be in the clear, but modern compilers know about memcpy(), memset(), etc. Might be as simple as writing your own version of memset(), compiling it separately, and providing it as only an object file. The compiler won't know what your function does, so can't optimize it away. Edit: actually, it might be as simple as declaring your pointer to memory to be volatile. memset((volatile void *)buf, 0, sizeof(buf));
Does the language explicitly say that '\0' is zero? Or is it just the appropriate string terminator for the architecture? If it's the latter case, then I could imagine that using '\0' actually makes a difference where strings are concerned.
There are multiple options depending on how low-level you want to go and if you care which audio formats you use. If you just want to play background music, SDL+SDL_mixer or OpenAL+ALmixer are really easy ways to go. (I've been a long time user/sometimes contributor to SDL, and am the author of ALmixer and been involved with the history of OpenAL.) Basically just convert the audio to a WAV or some other codec that these libraries handle and it is pretty easy. It's 3 lines of code (Init, Load, Play). If you want to use MIDI, things are a little different. The others deal with raw PCM data and the goal is to get it to your audio hardware. MIDI doesn't contain any of this. It is a simple description file of what notes play at what time with attributes like duration, velocity (how hard the note is played), what kind of music instrument should be used, and a bunch of other stuff. An analogy is a text transcript of a speech vs. the audio recording of the speech you can playback. Once upon a time, people had hardware sound cards that could understand and playback MIDI. Those days are mostly gone and they are done through software emulation, which means you need a layer that can convert a MIDI to PCM. PortAudio is probably the most popular library I know of that has support for MIDI, though I haven't touched it in years (and I still had a MIDI sound card then). I had also seen simpler ones, but can't remember any off hand. If you want to go very low level, Linux audio is actually pretty crazy. http://0pointer.de/blog/projects/guide-to-sound-apis.html 
Opinions are like assholes, we all have our own and precious few are very interested in yours. Macros are meant to be used to simplify code; fear of using them means doing manual machine work, I prefer macros. If you actually bothered to read the code you'd see that I'm not trying to replace anything that's already provided, I'm just filling in the gaps.
Oh geez, I did that in Borland Turbo C++ 20+ years ago. I think it used Amiga MOD files. Would probably at least work in DOSBOX. 
&gt; Opinions are like assholes, we all have our own and precious few are very interested in yours. Thank you for being one of those few interested in my opinion and even taking the time to respond. Just out of curiosity, does that apply to you as well or is it something you only go around telling others? I do feel sorry about my previous comment though, it seems you worked hard on that and I am in no place to judge you, but I am in a place to say that this should not be used in important projects or in production, it looks like nothing more than an experiment: An interesting one though it may bring more pain than gain if used in a serious project. &gt; Macros are meant to be used to simplify code; fear of using them means doing manual machine work Quite true and I completely agree except for one thing: clarity goes down the drain (clarity being the equivalent of answering the question "how much can you tell about what is happening just from looking at the code at the calling site and nothing else?"). When I started learning C, I hated the C preprocessor because I didn't understand it. When I started playing around with macros I liked them, and just like you, started replacing repetitive work with them, until I was bitten by them a few times more than I wanted, which is when I realized that yes, it's a powerful tool so it should stay well tucked away and hidden. I pride myself on avoiding repetitiveness by design without a single line of preprocessor directives (except `#pragma once`). &gt; If you actually bothered to read the code you'd see that I'm not trying to replace anything that's already provided, I'm just filling in the gaps. I did, and I hope this comment gets the message across better than the previous one. Please continue posting your blog posts and code! Despite my opinion, they definitely are interesting! Cheers.
&gt; Does the language explicitly say that '\0' is zero? Yes. `\0` is "the null character" and the language spec tells us: *"A byte with all bits set to 0, called the null character, shall exist in the basic execution character set; it is used to terminate a character string."* ^[[5.2.1]](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf) &gt; Or is it just the appropriate string terminator for the architecture? No. When coding in C (or coding to libraries/APIs/etc. that conform to C string representation), this is true on any architecture.
If you're really in for a challenge, you could try to use [gstreamer](https://gstreamer.freedesktop.org/documentation/). If not, SDL_Mixer will suffice.
Wait -- here's another issue: You're setting current_time **before** reading the data from the frequency counter. This means you're measuring the time intervals of when you ask the counter for more data, not of when the counter provides it.
You can reduce the character modulo 96 to get the desired result: c = (c - 32) % 96 + 32; We subtract `32` before to avoid generating control characters. Note that `c` should be an unsigned variable for this to work correctly.
*GUI* and *simple* are two words you rarely hear in the same sentence when talking about C, except if *simple* is preceded by *not.*
https://github.com/ocornut/imgui &amp; https://github.com/vurtun/nuklear come to my mind...
`nuklear` is not really suitable as it needs to be embedded into an existing GUI framework (e.g. SDL) and the effort to do so is quite high. `imgui` might be suitable (if using the C bindings), but isn't a very orthodox choice.
If you really want or have to stick with C for this, you could take a look at GTK+. Its far from simple, but manageable thanks to Galde. There are [tutorial](http://prognotes.net/2015/06/gtk-3-c-program-using-glade-3/)s for this. As you seperate GUI from logic anyways, you can also use different languages for them, which gives you a lot more options. A popular choice is tk used from tcl or python. 
That was done intentionally, this is the time that the measurement is started. Well sort of, since there is going to be some unsertanty between when fprintf(stream,"STRT;*WAI;XAVG?\n"); executes and the counter actually starts a measurement. *WAI; causes the counter stop executing commands until the current measurement to complete. Next command XAVG? will print the result. getline() should block until a line of data is received... Thinking about it now, the loop is pretty tight and whether it is done when order is given or when the data is returned it probably dose not mater. 
The only thing I might add is a guard against `127`. It's an ASCII `DEL` (unprintable/control). e.g. If `c` going into that expression was, say, `127` then it will still be `127` after the math. But you're exactly right to use the modulo math to keep it in a desired range. Perhaps `% 95`, if that works for OP. 
hmmmmmm, It would have to be in the counter, by default the counter will not output any serial data unless it is queried. On program start I issue a *RST, that is suppose reset the counter to power on defaults but It'm sot sure what happens to the buffer.
You don't have to protect against a process reading your memory. If another process has permission to do that, then either that process is root/administrator or is owned by you. In either case, the person running that process has the full capability to do anything that you can do, including debug your process, trace its syscalls, etc. The game is up at that point. 
strcmp doesn't return true/false. It returns 0 if the strings are identical, a negative number if the 1st string is 'less than' the 2nd string, and a positive number is the 1st string is 'greater than' than the 2nd string. If it is never returning 0, then your `key` isn't in your `contact` array.
I understand, my initial condition was strcmp()==0, which I just re-tried, but it still doesn't work. I'm certain the string is present. 
Some possibilities 1. strcmp is broken. 2. It's not present. 3. It is present, but you're not getting to it because `count` is wrong. And I bet it isn't [1]. 
Try putting a space at the beginning of fscanf's format string, that'll make it swallow whitespace (the newline) fscanf(f," %...
Thank you!
The point is that there is no way you can defend against something that has equal or higher privilege than you do. Anything you can do, they can undo. If you are up against a malicious process that has root, then forget it, the game is already lost. There is nothing you can do in that scenario. 
Take a look at this app, it is made with C and it have a nice GUI. The cool part about is that it uses a Brazilian GUI library (I'm Brazilian too!). Repo: https://github.com/jagt/clumsy LIbrary: http://webserver2.tecgraf.puc-rio.br/iup/
I don't have to, I can use any language I want and could run the C executable with a python script. The problem being the C code is slightly complex and would mean having to add in the use or arguments. If I stuck with C, in GTK+ could I link a button to run a certain method? Sorry if this is obvious, I just don't want to start and get the GUI going and realise this is a bigger task! 
the "C how to program" (deitel &amp; deitel) takes you by the hand, I still do not know an advanced C book, but you could follow the golang oop way (Although not so "elegantly")
thanks, I will look those up. I also found [this post about API design](https://www.reddit.com/r/C_Programming/comments/4xs3oc/design_library_for_api_concepts/d6k8bd3/)
There's always Motif which is actually not that bad compared to Gtk+. If you want to go more portable give IUP a shot (which targets Gtk+/Motif on Linux/Unix and Win32 API on Windows). I recently spent some time building an app in GTK+ but it ended up just looking terrible on Windows.
Future reference: it's much better to cut/paste your code here (indented by four columns so it formats correctly) than to make a screenshot.
I personally prefer to do this: s_struct.h: typedef struct s_struct t_struct; struct s_struct { /* blabla */ }; t_struct *new_struct(); int *del_struct(); s_struct.c: #include &lt;s_struct.h&gt; /* Your function implementations */ This approach is great, as you can make your private members static to the file, and the public members can be prototyped in the corresponding header. Use tge new_struct function as the constructor: add parameters if you need them, make it initialize the struct, etc. 
Just took a look this IS excellent documentation, I may choose GTK+ for this reason alone Too long have I had problems with lack of documentation (xercesc-c) 
MSVC has quite poor support after C89, i believe they didn't even do C99 properly. So consider Clang or GCC, moreover Clang support is being added to MSVStudio 2017.
Personally I would work in a POSIX environment, like [Cygwin](http://cygwin.com/)
If you want to write native Windows programs, use Visual Studio. If you want to have a UNIX-like environment, use something based on MinGW or Cygwin or even Microoft's [WSL](https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux).
Good luck!
Everything's in terms of bytes at least, a `bool` variable will use at least 1 byte of storage. (Unless you explicitly use bitfields)
Here's [a survey of four different options](http://nullprogram.com/blog/2016/06/13/): Mingw-w64, Clang, Visual Studio, and Pelles C.
Thanks Mirnor this is exactly what I needed and I've followed the tutorial and it's gone smoothly and looks simple.
You could also make the struct opaque. Also, due to autocomplete, I think struct_function is a better naming convention, as you get functionality discovery. And typically I capitalize the first letter of the struct object. Also I use Object_new for returning a heap initialized pointer and Object_init (Object\*) for an unmanaged initialization. Meaning the caller is responsible for creating the space for the struct.
VS2015 has almost complete C99 coverage.
I think the program is trying to run ot look for a VB file instead of a simple C file. No worries, I got it through the c1 / cl command. 
Agreed. This is the distro that I use - https://nuwen.net/mingw.html. Works beautifully!
After your program is done reading the multiplier (`scanf("%d",&amp;w);`) the character next to be read is the return key you just hit! Thus `v` gets assigned `'\n'` and the program breaks out of the loop. To skip white space, do `scanf(" %c",&amp;v);` (note the extra blank).
&gt; Why not represent the empty list with head pointing to NULL? Might be easier. I want to be able to add a new node easily: node-&gt;next = head-&gt;next; node-&gt;prev = head; Even when the list is empty this works without checking for NULL (assuming head's members both point to itself). It also makes iterating over it easier with `for (Node* it = head-&gt;next; it != head; it = it-&gt;next)`. The blog post is very interesting. I think in my case I can deal with the lack of type safety in option 2 but it seems you are assuming that two identical structs will always have the same memory layout. I have been unable to confirm or deny this anywhere.
&gt; I think in my case I can deal with the lack of type safety in option 2 but it seems you are assuming that two identical structs will always have the same memory layout. I have been unable to confirm or deny this anywhere. You are indeed correct. Two structs may be incompatible even if they have the same definition. An unnamed field as in Option 3 fixes that. I should fix that in the blog post.
If you have enough RAM I think it wouldn't hurt to have a linux distro in a virtual machine (lubuntu in virtualbox?) and test your software there as well so you can make sure you're writing portable code (if that is important to you) and you learn that for reach gui compiler option there's also a gcc/clang flag.
If I had a nickel for every time scanf() was the culprit...
Fair enough but it could also help since getting trapped by GUIs that you don't understand and wizard code you never check can be as much of a pain as facing a linux install in vbox. 
If i recall correctly, mingw and cygwin have different approaches. Cygwin attempts to compile Linux code with minimal changes, not necessarily compiling Windows-specific code. Mingw is for using a gcc variant to compile Windows code. The above is based on possibly flawed memories from years ago. Please correct me where i may be wrong. 
You'd have $0 because you tried to read the value with %d
Thank you very much for your help :)
Or just install Virtualbox and run proper Linux.
Ok, i did just install MinGW-w64 and I liked it. This has popular GUI tools and such? And I did see a little of Code Blocks. Liked it much more than Visual Studio. downloading and installing now.
Both Cygwin and MinGW provide a POSIX programming environment on Windows. Cygwin tries to act closer to a Linux system. Programs compiled under Cygwin are linked against cygwin1.dll, which implements the POSIX API entirely in terms of Windows API calls. (It does not depend on the Microsoft CRT.) You can use the Windows API in programs compiled under Cygwin through a wrapper header `&lt;w32api/windows.h&gt;`, although you have to be careful about some things to make sure the ABI is compatible. MinGW uses the Microsoft CRT. I think it statically links in some wrapper functions for the POSIX functions that Microsoft doesn't implement. It has a wrapper for the Windows API that makes it look like a regular Windows environment. So, you can use it to compile programs that use either the Windows or POSIX API without changes, or you can mix the APIs.
I gave it an honest try and it just seems way too bloated. I couldn't figure out how to get Hello World to run in an hour. And after downloading an insane amount of data, I still had to set variables up manually.
thank you
I just finished a class in c-coding and they recomended scanf_s as a much safer function.
I thought stuff like Valrgrind didn't run on that?
Depends on the device. CPUs are fast as shit these days, memory is generally more constrained.
Why don't you rewrite your tail recursion into a loop instead?
gcc does tail call optimization sometimes. Works the same as any other language... Often you need another argument to the function to use as an accumulator for intermediate values. Not entirely sure what you're describing but it sounds unnecessarily over complicated. 
Codeblocks works quite well for my needs. Lightweight installation and nice editor features. Was recommended by my CSC-150 professor. http://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/codeblocks-16.01mingw-setup.exe
I'm not following your description really well. A concrete example might help. Are you talking about memoization?
I'm talking about tail recursion the way that Haskell does it. Maybe I wasn't clear enough in my description—generally in C tail recursion reverts to copying the function over and over again into memory, leading to obvious memory problems. That's wha I'm trying to avoid. I wasn't aware of any compiler optimizations that dealt specifically with tail recursion. I will look into them. Thanks.
I don't have an example C snippet on hand. This came up as a thought experiment since I was almost certain that C doesn't optimize tail calls. I co-teach (or tutor, really) an introductory programming class at the college I go to and I know from looking at the stack that python just hogs memory with copies of the same function when you call it from within itself. Of course, this isn't something I'd bring up in that class, but I was wondering for myself how I could optimize this in C for my own musings.
So, I recommend reading through the Wikipedia entry as that goes through exactly what the optimization is. Specifically, it can simply move the stack pointer back to the beginning and rerun the function rather then creating a new stack frame. I'm not sure that the python interpreter is making this optimization, but I don't know what you're looking at. The reason I ask "are you sure it's tail recursion" is that often people "think" what they have is tail recursive and, it mostly might be, but it has boundary cases or some sort of complexity that makes it non-trivial. It's also possible to make something like Fibonacci, which isn't perfectly tail recursive, effectively tail recursive using a small lookup table. Or just rewrite the damn thing iteratively (the iterative version is basically storing your old values in variables .. i.e. A small lookup table).
Any decent C compiler will have no trouble optimizing tail recursion. It's just a matter of using a jump (and not creating a new stack frame) instead of a call (pushing a return pointer on the stack). It's not something to rely on for correctness, though, since, for example, it's often disabled for debugging (TCO would otherwise hide important stack frames). Modern compilers are so good at this stuff that they'll optimize *non-tail calls* into loops. For example, GCC compiles this, unsigned long factorial(unsigned long x) { if (x) return x * factorial(x - 1); else return 1; } [To this x86-64](https://godbolt.org/g/FWstSD): factorial(unsigned long): mov eax, 1 .L3: test rdi, rdi je .L1 imul rax, rdi dec rdi jmp .L3 .L1: ret It gets turned into a straight loop. Here's some contrived mutual recursion instead (where I forget about the bottom-out condition, but it doesn't matter): long collatz_even(long x); long collatz_odd(long x); long collatz(long x) { if (x % 2) return collatz_odd(x); else return collatz_even(x); } long collatz_even(long x) { return collatz(x / 2); } long collatz_odd(long x) { return collatz(3 * x + 1); } [Compiling to](https://godbolt.org/g/18vuNv): collatz_odd(long): lea rdi, [rdi+rdi*2] inc rdi jmp collatz(long) collatz(long): test dil, 1 je .L3 jmp collatz_odd(long) .L3: jmp collatz_even(long) collatz_even(long): mov rax, rdi mov ecx, 2 cqo idiv rcx mov rdi, rax jmp collatz(long) Notice all those `jmp`? That's GCC doing TCO. Simple. This will never blow the stack, but it will loop infinitely. 
[removed]
This is how I would do a tree but the same principle can be used for dll. Define this in your .h file: typedef struct bstnode *bst; Then implement it as : struct bstnode { char *key; bst left; bst right; }; 
Just a small stupid question, but does using mingw (or gcc for that matter) mean that your code has to be open source? or is that only if you use the gnu libraries?
Sounds like he's conflating loop unwinding and tail recursion.
It's swapping two variables without using temp variable.
haha got it; btw you can escape the \^ with a \\ so the \^ is actually shown and the following character isn't superscripted :\^)
Doesn't work for a=b
It does not. it depends on the license of the libraries you use (whether they're a part of GNU or not is irrelevant)
Now I wonder if GCC can combine the two optimizations.
It is for the fun of programming. The solution is in a solution single expression.
Has anyone watched this series? Is it any good?
I pushed a new commit. It didn't seem to fix the issue :/ 
Well, it teaches bad coding habits.
Perhaps, but that would increase the binary, and not the stack growth. So it wouldn't create a dynamic stack overflow. As in, it wouldn't continue to get larger as it runs. And I'm sure there is a cutoff on what they'll unroll. So fib (9999) would never get unrolled I'd imagine.
I think he's joking - the channel name is 'bad programming habits'
I see. Thank you so much for clarifying that for me!
Just wondering, whhat about now? I didn't change some things on purpose, like heap string allocations (for lesser number of allocations in nested function calls) or aruments reading (I do not see the point, it's pretty much comfortable for me right now).
If Windows is the only platform you care about, you could just call directly into Win32 for graphics (GDI, OpenGL context creation, DirectX), sound (DirectSound), input (User32, XInput), and networking (Winsock). Otherwise [SDL](https://www.libsdl.org/) is a very popular choice that covers everything under the sun, including partially solving some nasty cross-platform filename issues. I personally like [GLFW](http://www.glfw.org/) for portable OpenGL context creation and mouse+keyboard input. I have [my own library](https://github.com/skeeto/optparse) for portable option parsing.
This article is missing rules for the comparison of pointers. But I guess they are not really of interest until you try to implement your own `memmove`. (`memmove` cannot be implemented in C)
I think you mean *implemented efficiently*, don't you? Example: [memmove.c](https://opensource.apple.com/source/BerkeleyDB/BerkeleyDB-6/db/clib/memmove.c) from BerkeleyDB
&gt;(memmove cannot be implemented in C) I'm curious about this - can you expand on that a little bit?
It is an restriction on pointers coming from some old architectures. You can't do `a &lt; b` on pointers if they point to two separately allocated things. But you need that comparison for memmove. For details, check out [this paper](http://www.complang.tuwien.ac.at/kps2015/proceedings/KPS_2015_submission_29.pdf).
&gt; int* Array; &gt; printf("%i", sizeof(Array)); The `sizeof(Array)` is just the size of an `int *`, i.e. the size of a pointer to an integer, i.e. the size of pointer (supposing all pointers are the same), i.e. in general 64 bits (8 bytes) on a 64-bit system and 32 bits (4 bytes) on a 32-bit system Thus it is 8 (or 4) and doesn't change, no matter what the pointer may point to.
Ah ok thank you, I feel kind of dumb now but good to know! Just a question though, why can I still access the data that was removed? If I call printf to output Array[3] it still works for some reason.
Ah ok thank you! That explains a lot actually.
When you invoke undefined behavior, anything can happen. The fact that the program does not immediately crash does not mean that accessing `Array[3]` is valid. "Anything" sometimes includes appearing to work, by sheer luck. 
not undefined but rather *implementation defined* behaviour.
I watched the first two videos. This is essentially a walkthrough of how to use ncurses to build a roguelike in a single file. He does mention that he's not doing a whole lot of game design and the point is just to build the game so I can't entirely blame him for that. When he calls `malloc()` he calls it like this: Player *newPlayer; newPlayer = malloc(sizeof(Player)); instead of Player *newPlayer = malloc(sizeOf(*newPlayer)); The second example is a good practice to use because it avoids potential dereference issues, and if player ever becomes a different type, you don't have to update the `malloc()` call, you only need to update the type definition. He also never calls `free()` on that player, but the player exists for the lifetime of the game so far. It is my personal opinion that, especially since this looks targeted towards beginners, that it should teach better memory management up front and have a corresponding call to `free()` for every `malloc()` It is possible he addresses that later but I only watched the first two. Pros: * Simple * Fast and straightforward (this is probably the point) * Teaches basic game design elements * Teaches ncurses Cons: * Potentially actually bad coding habits * No project structure I hope this is helpful and if anyone or the creator would like to let me know if the things I've mentioned change, I'm happy to edit this post.
&gt; this paper Ah, interesting! Thanks for the link, will check it out.
 You can still memcpy for defined behavior. memcpy (ptr, &amp;ulong, sizeof (ulong)); 
No, you didn't imply otherwise, but op mentioned python copying the function over and over, which I assume is not an optimization python makes...
Yes, I agree ... an article claiming to share "everything" about pointers did miss this aspect of how/why they may or may not work as an ordinal value. Merry Christmas.
Let me reiterate: It is very complicated to decompress mp3 audio files. Just look at [lame](https://github.com/rbrito/lame/tree/origin/libmp3lame), an open-source mp3 codec and see how complicated that is.
The correct type to use is `uintptr_t`.
Maybe you as a C-guru know: Casting a pointer to an integer seems like a cheap trick to get around the undefined behaviour here. Is the cast itself *implementation defined* or is there still some pointer-ishness left in the values?
Thanks, that really helps. I guess, I should start ~~rtfm~~ rtf-standard.
This is a good introduction to pointers, but it's not even close to "everything you need to know about pointers in C". 
Definitely is. The Linux Kernel source uses `long` for this though, so you can be sure that on Linux a `long` fits a pointer for that architecture. `uintptr_t` is still the better way to go though.
I get what you mean now, there is a lot to learn first. So, I've started with pulse code modulation. Sorry, for the brushing off your first answer.
Hm, yeah. Might be worth including. Thanks for pointing it out!
I do know what they are, but I think I've simply declared them as `int **a`. That's a really good suggestion—it would help bridge the gap to function pointers. (Which is a section I've been thinking about recently, in the context of warnings of weirdness potentially scaring people away.) Thanks!
Have a look at [gstreamer](https://gstreamer.freedesktop.org/)
The common way to implement a linked list in C is to represent your head as a self-referential struct: struct node { int data; /* this could be any type */ struct node *next; /* we're self-referencing the type "struct node" */ }; 
&gt; This style is called "intrusive lists" and along with "intrusive trees" and "intrusive hash tables" lets you re-use generic implementations of data structures in more situations and more optimally. Yeah, I learned this style from reviewing the kernel linked list implementation. I didn't know it had a name called intrusive list/trees. That's pretty cool.
I will let you mull over this, but the C for-loop construct provides a nice idiomatic way to loop over a linked list: for (n = head; n != NULL; n = n-&gt;next) { /* do stuff */ } Bonus question: with respect to the linked list what is n pointing to after the loop terminates?
Hand draw a linked list with the `-&gt;`. Manually go through the for loop above.
According to my colleague, this restriction was lobbied for by Intel because on the 8086, a full pointer comparison (i.e. including segments) requires two compares and possibly two jumps whereas if you are allowed to assume that both pointers point to the same object, it's sufficient to only compare the offsets, which is frankly sufficient for most cases. 
is not readable, dont want to see it
&gt; I could just pass first node to the function, but that feels like cheating. It's not. The "head" of a 1-node list, is the list's only node. Simple. The edge case, then, would be an empty list; think about how to represent an empty list using this technique...
I'm almost certain intrusive lists rely on undefined implementation-defined behavior to extract data. (At least, implementation-defined after checking with the standard and if the implementation of the data structure is right.)
[removed]
What behavior? The only suspect part is containerof, which uses offsetof, subtraction, and a cast. offsetof is standard. Subtracting it should be fine?
Yes, it's containerof, but it looks like I was wrong. If you use integer types capable of holding a pointer, everything looks kind of implementation-defined. I thought, subtracting from a value of a type pointer-to-character was undefined for the following reasons. Let's assume `struct s { int a, b; } a;`, then `(unsigned char *)&amp;a + offsetof(struct s, b)` is a valid pointer value, because it's derived from the representation of the object `a` (which is an array of type `unsigned char[sizeof(struct s)]`) so, that the result is still inside that array. `(unsigned char *)&amp;a.b - offsetof(struct s, b)` is undefined, because it's derived from the array-representation of the object `a.b` by pointing far outside of it. On the other hand, there exists an array object that includes the pointed elements.
I'm not really sure if it's illegal but even if it were problematic on some remote platform, somewhere, the fix would only require defining a "containerof" for that platform that works.
doh! I may be on to the answer. I completely missed that the man page for wcwidth() says to define _XOPEN_SOURCE before any header files. I did that and it seems to have worked for wcwidth(), but now index() and nanosleep() are undeclared. Working on it...
Thanks! Yep, got it working by placing the following at the top of my header file: #define _XOPEN_SOURCE 700 This produced the side-benefit undeclaring index() which I was using to find a character in a string, and which research has told me is depreciated. So I replaced it with strchr() and I am good to go. 
If you are on Linux, you can define `_GNU_SOURCE` to get all symbols.
it's some windows only crap. Don't bother trying to find it
 #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; int main(void) { char buf[20]; size_t i; memset(buf, '\0', sizeof(buf) * sizeof(char)); if ((read(STDIN_FILENO, buf, sizeof(buf) * sizeof(char))) == -1) return (EXIT_FAILURE); i = strlen(buf) * sizeof(char); while(i &gt;= 0) write(STDOUT_FILENO, buf[i--], sizeof(char)); return (EXIT_SUCCESS); }
It depends on how (over?) architected you want your solution to be. The most straightforward solution is simply to link in an object file from the other directory. Like, in the glade directory's Makefile: OBJS= main.o ../whatever.o Where `whatever.o` is the object file that contains the implementation of the function you want. There are two problems with this solution: 1. From a technical standpoint, the Makefile in the glade directory may have the wrong idea on how to build `whatever.o`. That's no problem if the file is already built, but if it's not already built, it may fail to build or may build it with the wrong flags. What that means is that you have to be careful to ensure that the src directory is built before the src/glade directory (and that the object files are not removed after building). 1. From a software engineering standpoint, it won't be obvious to someone reading the source code that `whatever.c` is going to end up being linked into two separate executables. C is relatively weak on de facto software engineering principles, so it's mostly a matter of personal preference as to whether that bothers you or not. A more structured way is to break files that are common between two projects (two executables) out into a *library*, which would mean compiling it separately into an .a file (if you're on a non-Apple Unix system), and then linking in that library to the two executables. It's common and makes the structure between all the files more explicit.
That sounds like a beautifully simple solution that I could use in the future, thanks for that! However this time around I'll be using the arrays in them files in which the data will be passed around some of the other functions. It sounds like a shared object file is needed, how would this be done?
In its current state I am creating 2 executables, I want to have only one executable. I have two currently because I created all of the functionality first which is controlled via terminal input. This is './tom/MyApplication/src/TempControlSystem' I then later added in a GUI to display these outputs in a better way via glade. This is './tom/MyApplication/src/glade/gladewin' executable I only want one executable inside src ideally, I should have explained this but wasn't sure it was relevant 
I think you're right, I'm thinking that they have to be compiled together. From what you've said am I right in saying that I could compile my /src/glade files first in one makefile1, then compile my src/ files in makefile2 and also inside makefile2 I could link the object files created from makefile1. Then would this allow me to use the functions in an include file? *hopefully you get my thought process here* Edit: .. Basically they can be compiled separately but as long as the .o files are linked the data can flow between them.
Good to know! I was hoping it could stay since it wasn't posted to this sub. :)
No they are not. They are pretty clear about what they are offering: a C++ compiler. The C99 features they support are mainly because A) the C++ standard requires them and B) some customers want to compile popular C projects like FFMPEG.
 &gt; myStudents seems to only be getting 8 bytes. You're doing `sizeof(myStudents)`? That will always be 8 - before or after the call to malloc - because it is telling you the size of the pointer not the size of the memory block it is pointing to. If you ask for X bytes and malloc does not return NULL then you can trust that you can fit X bytes in the buffer.
I've ended up doing a similar thing with just 2 different folders, one creating a shared object file and the other linking with that file to create an executable which runs the GUI. I've learnt quite a bit about makefiles today! Cheers!
Thank you for your response. It makes sense. I still don't understand how I could ask the computer to allocate X bytes for the struct.
No, it is not correct. It is returning the wrong value.
It might seem strange to look at the: &amp;arr + 1; And see the address increase by 20 but its the same idea as: arr + 1; Where the pointer arithmetic is stepping through addresses by the sizeof the object pointed to. With the former it happens to be of type array of 5 ints.
First, you don't need to cast the return value of malloc in modern C implementations (it returns void *) myStudents = malloc(sizeof(struct student) * userSize); Second, what do you mean "myStudents seems to only be getting 8 bytes"? Your code looks correct as written. How do you know how many bytes it's getting? Did you execute `sizeof(myStudents)`? That just tells you the size of a pointer in your architecture. I'm guessing 64 bits in this case. Don't worry about it. Like I said, your code looks correct as written.
You learn where to download the library functions to do it for you.
These topics are varied and sometimes large. Do you have specific questions so that we can do more than post not you to Google?
Great post. Thank you! edit with a question: How does the operator+ know to get to the end of arr when operating on &amp;arr? 
I know that the semantic is the meaning of what you have written done in fact 
Compile-time type size awareness. Pointer math has an implicit multiplication by sizeof(type) when you step forward or backwards.
&gt;Pointer math has an implicit multiplication by sizeof(type) Only if you think in terms of bytes. If you make an adjustment to think of pointers in terms of what they are pointing to, then there's no mysteries or implicit operations. Adding 1 to a pointer makes it point to the next one of whatever it was points to. 
I'm not getting the correct answer with clang... but I was trying to pass it into a function.
A semantic error is where the program works correctly (syntax passed) but produces the wrong answer or does an action it's not meant to. There's a third type (logical) but it's a subset of semantic. Logical bugs are things like off-by-one errors, poor use of parentheses so the math in an expression is off, etc.
The original article was named "To become a C God programmer" 😅
I'm very impressed about his engine game, it 's totally written by c.
That's fair. My view is colored by my work, where I I work on byte streams.
I think your use case is niche, as well as portability it would also completely break arrays in c decaying to pointers. &gt; int my_strncpy(char *from, char *to, size_t len); Would now not be able to get away with using pointer increment, it would now have to manually add on sizeof(char), but that also wouldn't work in your system - as it would add on sizeof(char) * arch addressing atom. I really can't see how this would work nicely and generally without breaking a lot of useful cases.
Just get the The C Programming Language book by Ritchie and work through it, will easily be enough for undergrad university courses. Most C stuff is pretty easy, the biggest hurdle students have are understanding pointers and memory management
When you pass an array to a function you pass the address of the first element (the so called array to pointer decay). The sizeof method of getting the array size will also fail after you've passed the array to a function.
K. N king
It's a short book, but use your whole nine days. Try to solve all the sample problems yourself.
What do you mean by define every test function? Sorry I'm really noob at this 
Yes, along with hat i wil also take the cs50 course.
The good news is that MinGW/Mingw-w64 doesn't need export libraries or any of that (outdated) crap that Visual Studio requires. Just add `-lwinhttp` to the command line when you link. example.c: #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;winhttp.h&gt; int main(void) { printf("%p\n", (void *)WinHttpConnect); return 0; } The build: $ x86_64-w64-mingw32-gcc -Wall -Wextra -Os example.c -lwinhttp And testing it (which I did on Linux): $ wine64 ./a.exe 0000000000401530 
Just tested on GCC 6.2, both produce the same asm. In fact neither do the computation at all, the compiler realizes that both are trying to fetch the size of the array and just uses the values directly.
You don't. You aren't actually passing an array, you're passing a pointer to the first element. char c, a[10]; foo( &amp;c ); foo( a ); The function `foo` would take either as a valid argument.
It looks like you need to set up include paths (and maybe link paths). If you're using an IDE, I would expect a GUI option to set those paths. Otherwise, I think (not in that environment right now) the include path is set on the command line with -I/path/to/library/headers, likewise I think the link path is set on the command line with -L/path/to/library/libraries
I'm trying to just use a text editor and cmd line. Where would I find these headers?
I know. That's why the article isn't as useful as its title seems to imply.
You'll probably need the platform SDK, or find some alternative include/lib set that includes winhttp.h .. I've never used it, so I really don't know off hand. 
I have removed your post as it is off topic. This subreddit is about C programming only, please only post content about C programming.
Curiously enough I cannot run the program if I try "return != 0" ; "error: expected expression before != token". I guess it's much more useful if you write "return x;" where x is some returned value from the main function.
Try tdm gcc 
Thank you all guys, I realized all of this experimenting some more. I'm realizing this return value thing is quite powerful =) 
The problem is that the floats always gives me 0's.
I'm going to suggest, as a 20+ year C software engineer, that C is not the future. Look at Rust, or Go. I'm sure there are other languages capable of going low and high too. It doesn't help that the linux kernel is almost entirely written in C. We've got to move forward. 
Yes it is, but the only "standard" value is 0, meaning success. The "error" values will vary between programs. In some cases (rare, and I can't recall which), a non-zero may even mean "success, but with warnings". As an example, if you're on Linux look at the documentation for "grep -q". This tells grep to not output anything, but use the return value to indicate whether it found something (0 == found it, not 0 means didn't find it). 
If you want to be portable to different terminals, use the `termcap` or `terminfo` libraries (the latter is more portable nowadays). Generally though, most people use ANSI-compatible terminals; the ANSI control sequences are essentially what the VT100 supports, so using these should be mostly fine.
Do not post code as images. Please always post text.
Just be careful to strip any codes going to log files. Might sound obvious but I've actually seen instances of this happening :)
The only thing I'd add is: "The only way to learn how to code, is to code". By all means, read a book (like The C Programming Language by our guru Ritchie (RIP)). But my recommendation is also: code, code, code, code.. Doesn't matter what it is, just code :)
&gt; (This should be taken carefully, as sprintf(...) would translate to just s and give a compiler error.) Not really, preprocessor macros aren't *that* brittle. The preprocessor doesn't do mere string substitution. It actually works with "preprocessing tokens". If you *\#define printf*, then the substring *printf* in the token *sprintf* won't be affected by that define. Similarly, if you *\#define g f*, the token *printg* won't be expanded into *printf*.
Wow thank you, I tried out tdm and used the -lwinhttp flag that skeeto had posted and it worked. I had to use g++, gcc gave an error. https://gist.github.com/anonymous/97d8d952e1cadaefc83c170998bcf2e5 is this not valid c code? I had to use g++ instead of gcc to compile. I guess "new" is a c++ thing?
Yeah I think keeping most of the functions in one header file was for simplicity and time. Rightly or wrongly, the series is already an incredibly long affair. Often on YouTube you will see creators doing "new" series after learning from mistakes made in older ones. This series for me would definitely be a candidate for that! But I'd rather finish this up and start on something new. Also, the structure of programs is something I'm always unsure of for best practices. Something I've struggled with in a project I've done for my prof. When you start getting a large code base, how do you organize it together? The 'toy projects' that I've had to complete during university have certainly not prepared me for that. I don't really understand the structure of libraries and shared libraries and how they are to be implemented effectively. More things to study. Which is good. I think the more I realize how much my coding is lacking in specific areas the more I want to learn, pick up a reference book, etc. That's what I've enjoyed about making these videos, feedback like yours keeps it interesting.