Yes I am using those for other things, but for this particular script it wouldn't really work. If I'd just have the right libraries I'd rather spend the time to get the real 100% performance with C rather than the 80% with a more complex Python cross-over script.
If you're writing new code there's no reason to emulate a foreign API, just use native Win32 threads. 
Are you sure you need multiprocessing? Anyways if you are doing it on a MS platform the easiest thing to do is probably just to use C++11: #include &lt;thread&gt; void func(int id) { cout &lt;&lt; "id" &lt;&lt; id &lt;&lt; endl; } int main() { thread t; for (int i = 0; i &lt; 10; ++i) { t = thread(func,i); } t.join(); return 0; }
You can call C code from a Python thread or process. I recommend using Python to handle your threading and just calling out to your computational routine as usual.
If you are on windows you could consider using SDL as it provides a basic cross platform threading layer.
Oh, yes, of course -- Windows has its own threading API. [This](http://msdn.microsoft.com/en-us/library/windows/desktop/ms684841%28v=vs.85%29.aspx) looks like a reasonable place to start.
Maybe have a look at how other python libraries do it. For instance, I believe numpy code can be executed in parallel. I don't know a lot about it, but I suspect it works by just using pythons threads, which can run in parallel as long as no python code is executed in them (hence you need to write the performance critical/parallel part in C). If you want to thread manually, It's probably best to do the work in a process external to the interpreter, I suspect CPython will not be cool with you just spawning a bunch of (p/win32-)threads from some CPython thread -- it probably gives you a bunch of special functions &amp; macros you need to dance around first (in particular to safely access python objects, which you will need to do to communicate with the python part, and to release the GIL with PyBEGIN_ALLOW_THREADS etc). I'd advise asking your local python guru on how that works. 
Are you sure you don't mean OpenMP? Edit: I say this because MPI doesn't make much sense on a single machine, and OpenMP is much more natural for these sorts of problems.
I'm not up on my C++11 yet (stupid Snow Leopard), but wouldn't your above code snippet only join() on the last thread created?
Did Python resolve the global interpreter lock issue while I wasn't looking? Or is that not really a concern if you're aiming to spend long stretches of time in single invocations of C calls?
Yes it would but seeing as how that is the last thread that gets created my assumption here is that it will be a sufficient amount of time for all the other threads to have executed. That might not actually hold in real life, but since this was merely an example I thought it best to forego the vector creation stuff.
17/20, but I learned a few things from that, thanks.
I don't know much about networks, how much time do you think I would need to start understanding what's going on with this project?
One day in COBOL class I laid a fart so loud it woke me up. 
That's actually why I was asking. I'm trying to keep practicing programming over the summer, so I thought that ideas from other people might help me get ideas of my own as to what I can do.
x &lt;&lt; 32 is undefined on x86/amd64. (and rightfully so, forcing the generated code to check the range on every shift would be terrible, and no sensible instruction encoding will have a way of representing a shift of 32 bits on a 32-bit value.)
interesting project. I'm guessing you read "art of exploitation"? Are there any other books you would recommend that helped you? Maybe something on threads?
Actually, I have not. I learned everything from google, man pages, and wiki. lol
Did you mean to link [here](http://c.learncodethehardway.org/book/)?
I'm interested on working on C project too, what about to start a new one? 
I imagine that's like learning kung-fu with Bruce Lee... the hard way is the better way, *in the long run*.
I took a look at the video lecture and it was done very, very well. I would recommend it for anyone wanting to learn or brush up on C (the hard way).
It's not meant, I don't think, to necessarily literally mean "hard" as in hard to get. I think it's more about "learning by thinking and solving issues yourself" type of thing. Which, if you read the online 'book', you'd see that.
Sometimes learning things the hard way gives you appreciation for the easy ways :)
I agree, but I guess he's just trying to go the opposite way of all those "Learn C the easy way" books where you do everything half-assed and actually learn nothing.
You're assuming he's [Zed Shaw](http://www.reddit.com/r/programming/comments/ut0rh/zed_a_shaw_the_web_will_die_when_oop_dies/)? No, believe me, *you'd know* Q. How do you know if a person is Zed Shaw? A. He'll tell you. ^((amidst a stream of obscenities)^)
"Actually doing code" is sometimes referred to as "the hard way", as well. Many people like to just sit, read a bit of the theoric part and think they are OK to go a level up.
Check out the [Sphere Online Judge](http://www.spoj.pl/): a problemset archive, online judge and contest hosting service accepting solutions in many languages. [UVa Online Judge](http://uva.onlinejudge.org/) is another Online Judge, "Here you will find hundreds of problems. They are like the ones used during programming contests, and are available in HTML and PDF formats." Originally learned of UVa from xmichelo's [comment](http://www.reddit.com/r/cpp/comments/un5zz/are_there_any_free_websites_with_c_problems/c4wtyel) about it. Meh, just noticed that doesn't quite answer your question, but I'll leave it in anyway. I wrote a Tetris clone that ran on the Nintendo DS, that was fun.
Great link! I was actually starting to learn C with Learn C The Hard Way. Which one do you prefer?
I bought an [R4DS](http://www.r4ds.me/), which lets me run code on the Nintendo DS. I wrote the clone in C using [DevKitPro](http://devkitpro.org/). Note: I bought it back in around 2007 or so, maybe earlier, I don't recall. The clone was written in '07. **Edit**: forgot devkitpro link/mention.
Thats my backup plan. I was kinda hoping to be able to address the pixels as a 2d array of structs. 
I am both short on memory (The microcontroller has only 4KB) and I need the bytes to have a specific formatting in the memory (tightly packed no "holes" between color data) because I will be using a "dumb" DMA to shift data from the microcontroller to the LED matrix.
Each struct is still going to fill out to a byte boundary. That's the reason for the 2880 bytes. The first two 12-bit fields pack to 3 bytes. Then the next rounds to 2 bytes. (5)(24)(24) = 2880 bytes. If it's that important for space reasons, double the number of fields (blue2:12, green2:12, red2:12), and use [12][24], or the reverse depending on how you are keeping track of x and y, and just work with two characters at a time. Should pack to (9)(12)(24) = 2592 bytes. You can write something in your character set/get function to automatically use the first or second fields depending on even/odd place in the array. Hope this helps.
That did the trick! It packs into 2592 bytes as expected and I still can address it as a 2d matrix. Thank you very much!
You could use interleaved bit-planes, as they were used with some old graphics hardware, where first 3 bytes would represent the first (0) bit of all 24 horizontal pixels, then the next 3 bytes would be the bit 1 for each pixel, and so on, up to 35th bit. You'll pack things tightly, at the expense of slightly more complex code to encode/decode individual pixels.
Hi, sorry for the delay: I didn't realize someone commented here. I haven't used either, I have my trusty copy of K&amp;R (ANSI C) at arms length. I do intend to go through this course, [The C Book](http://publications.gbdirect.co.uk/c_book/), and a few other resources (someday), so I can give more tanigble advice on which ones are worthwhile. Don't forget the [C FAQ](http://c-faq.com/), and the cardinal rule of programming: read code, write code. Look at the source for well established projects: the Linux Kernel, Ruby, Python, OpenBSD, et cetera. The best thing you can do, though, is write code: fork a small project and just hack away at it, and start a new project from scratch. Something I've been meaning to pursue is prototyping in scripted languages, like Python or Ruby, and reimplementing the proven areas as they solidify: I'm expecting this to be a spectacular learning experience for test-driven development, portability, and the languages themselves. Again, sorry for the delay.
Thank you for the suggestion, however it will not work in my case: I need the data to have a specific formatting in memory so it can be shifted out without the CPU interaction using DMA.
Bash is the language I use, by far, the most often. &lt;3 the CLI one liner. : ) I decided to start learning Python a few years ago since my distribution's package management software is written in Python. I have only half-heartedly approached the language, which is an oversight I intend to correct. 
&gt; ... I wanted to learn a language like C. If you really wan't to know C, then pick up a copy of [The C Programming Language by Dennis M. Ritchie and Brian W. Kernighan, second edition, ANSI C](http://cm.bell-labs.com/cm/cs/cbook/). It was written by the language author, R.I.P. **Edit**: of course, all the free resources will do a lot of good for the interim.
That's pretty awesome. I didn't know things like that existed.
This helps, that way I do not need to enable packing globally. Thanks!
I need to maintain about 60 FPS all while doing some math with the micro controller (effects, geometry and so on). Having an interrupt fire every couple of cycles to shift the next 8 bits would eat a lot of CPU. That is why I will be using an DMA for it. It will output the data with maximum possible frequency without needing any cpu attention. I will be using a STM32F100 micro (24Mhz). 
Some code somewhere (differs quite a bit between Unix and Windows) parses your command line and figures out how many arguments you've specified. For Posix, the shell parses the command line to decide how many arguments you've specified. When it asks the kernel to execute the "foo" command, it includes the vector of arguments to pass from which the kernel can determine how many arguments there are.
Yes! Magic pixie dust!
My question was basically, "Why don't I need to pass ./foo **2** Hello Reddit!" for the for loop to only know to run twice. I never thought that the OS its self would count arguments and pass argc automatically for me. 
You've created the Struct Array properly, so no issues there. It just seems to be that you are using strcpy backasswards. :)
I'm curious, have you read the C bible, K&amp;Rs "The C Programming Language"? It is a fairly small book, but it's still what I recommend people read to grasp the concepts. I'm not trying to be a dick or anything, but one pass through this book really will make a lot of things, including arrays, make more sense. If you want a simple use case, here it is. Think of a pointer to a section of memory. Lets say you have a file on a disk, and you want to read it all into memory, and manipulate it. You would create something called a pointer, and when you allocate memory to hold all that file data, the pointer now points to the beginning of that place in memory. You read the data from that file into the memory at the location of that pointer. That pointer is how you know where that memory is. It points to it. Now, if your program needs to let another function work with that data, instead of passing all that data to the function, you are just going to pass the pointer. Now, that function knows exactly where in memory all that data is, and can work with it. They can also be a source of memory leaks in your program, because people will forget to free() the pointer when they are finished with it, so the memory can't be used by another process. That gets into a whole other thing though. I hope that gives you the basic idea. I tried to explain it as simple as I can.
The memory of your computer is like lots and lots of boxes lined up one after another. A variable you declare is one of these boxes with your own special label on it - the variable name. When you assign a value to your variable, you are putting that value in the box with that label. // Label a box 'x' which can hold a number int x; // Put the number 10 in a box labelled x x = 10; Different boxes are different sizes, built to hold different things. The box labelled 'x' in the example above is the right size to hold a number (an int). As I said, the boxes in your memory are lined up one after another. Imagine numbering these boxes from start to finish. The first box is 1, the second is 2, and so on. These numbers are the addresses of the boxes. Every box in memory has an address. The box labelled 'x' might have the address 1234. // You can get the address of variable 'x' with an ampersand &amp;x Now that you've got this address, you'll want to put it in another box for safe keeping, so you can use it later. So we'll need to label another box, and put the address in it. However, what will the box be built to hold? Not a number, like x. It needs to hold an address! This is what pointers are for. // Let's label another box 'p' which can hold an address int* p; // We can now put the address of 'x' in to this box p = &amp;x; Notice that we describe the new box, 'p', as `int*`. This means that it holds an address of an int - or in other words, a pointer to an int. *The address in box 'p'* **points** *to box 'x'.* Now we know how to get the address of a box and put it in another box. But what if we want to do the opposite? If we already have an address, how do we find out what the value is in the box that it points to? This is known as dereferencing: // Dereference 'p' to get the value that it points to. That is, // the value in box 'x'. We do this with an asterisk. *p You can go ahead and store this value (which is 10) in another box if you like: int y = *p; So in summary: - To get the address of a box, use &amp;. (It looks like an 'a' for 'address'!) - Store addresses in pointers. - To get the value that an address points to, use *. Make sure you understand that the asterisk (*) in `int*` is different to the asterisk in `*p`. The first is part of the type, saying "this is a pointer to an int", and the second is the dereferencing operator. When you create an array, what you're doing is asking for a bunch of boxes that are all next to each other in memory. You say "I want 5 boxes that can holds numbers" and then you have them. The label you get is for the group of boxes as a whole. To access each box, you can say "I want the value in the 2nd box" or "I want to set the value in the 4th box." // We ask for 5 boxes that can holds ints int a[5]; // We set the value in the first box to 10 x[0] = 10; Notice that the boxes are numbered from 0 onwards. So the first box is 0, the second is 1, etc. This series of five boxes will end with box 4. I hope this helps.
Pointers are like the difference between giving people the address of your home, and bringing your home to them. It's often a lot faster and often takes up less space. There's also a variety of structures and algorithms that require the use of them.
The pointer is the address on the letter envelope. The value of the pointer is the house number. Pointers' values are locations; to call them values is inherently confusing because generally one uses that word to distinguish the thing they're pointing at. If you choose to use the phrasing "the pointers' target addresses," things become much easier to think over.
I can relate to your first sentence. I like the article because it gives you the knowledge beyond pure necessity, but I definitely don't like the second par of your assessment. The C is the best and the greatest language on the planet and therefore C programers are the brightest and smartest people out there. Can't be any different. ;)
It's much of an article. Conveying the insight that undefined behaviour can truly explode the language's semantics in such a brutal manner makes it way more educational than a gazillion of "XYZ results in undefined behaviour" in some C book. It conveys the *reason* to do what you say way better than you did. You didn't even attempt to, aside from calling to authority: "It's what *experienced* programmers do".
Wow. You're sensitive. I would normally think that most programmers run into an uninitialized bug the first time they write a program of any length. Falls into the same category as newbie mistakes like 'n=3' in a conditional statement instead of '3==n'. Glad the article helped you. 
If you don't like C programmers, maybe don't hang out in /r/C_Programming?
casting to (char*) does the same thing, no?
Why are you expecting it to not be fine? Why would a variadic function be any different than any other function in this respect? 
Jesus. 
 char* var_b = strdup(var_a + 3);
No worries, Apple actually uses variadic function pointers in the Objective C runtime. See http://www.opensource.apple.com/source/objc4/objc4-371.2/runtime/objc.h , especially the line typedef id (*IMP) (id, SEL, ...);
It's perfectly fine to use in production code, it acts like a regular variadic function, just with the usual indirection from looking up the pointer value before the jump.
They are exactly the same.
I am also finding C Programming: A Modern Approach to be quite good, although I'm sure I'll go through K&amp;R at some point in the future
If you eventually go the K&amp;R route, make sure you pick up an ANSI C version.
Yes this is a homework problem and should not have been asked in this forum, but misleading people with the malloc() advice is just wrong. Zero out the last byte. 
Well first of all your function prototype is inside main which is completely wrong move that out. To fix the swapping you want to change your swap call to use the reference operator instead of passing the values and you want your swap function to accept int * x, int * y to accept pointers. Then you swap the pointers locations. I really recommend reading up on your pointers and what they actually mean before continuing on though.
While it is unusual, there is nothing illegal about a prototype inside a function. It just limits the visibility of the prototype to that one method
Properly formatted and commented code is *very* important. It makes everything more readable and understandable. #include &lt;stdio.h&gt; /* Local function prototype. * Note that the function accepts pointers to ints, not * the ints themselves. */ void swap (int *x, int *y); /* Program Entry * */ int main (int argc, char *argv[]) { /* Local declared variables * Variables declared here only exist during the lifetime of * main(). They are only usable within the main() function * unless they are passed to another function as an * argument. */ int first_num = 10, second_num = 50; printf("Before swap - first_num:%d second_num:%d\n", first_num, second_num); /* Don't send the value of the variables (10, 50), * to the swap function, send the locations where * the value is stored. */ swap (&amp;first_num, &amp;second_num); printf("After swap - first_num:%d second_num:%d\n", first_num, second_num); /* Exit, no error */ return 0; } /* Swap the value stored at location x with the value * stored at location y. */ void swap (int *x, int *y) { /* Temporary storage */ int local_int; /* Assign the value stored at x in the local_int. * Assign the value stored at y to the location x. * Assign the value stored the local_int to the location y. */ local_int = *x; *x = *y; *y = local_int; return; } 
Ill give you an upvote, yes you are correct. I probably should have been more clear than i was or explained the difference. I figured since he was posting a question like this that he is fairly new and most likely he never even knew that local prototypes were a thing and therefore for the case that he wanted it was wrong. But again I concede that you are technically correct
Prof's also teaching you `void main` instead of the proper `int main`.
I was just modifing OP's example, stressing commenting and formatting. There are many ways to do this (XOR swap, Add-Subtract swap). I missed the "swap in the main program", though.
Whoops, I missed that. I think I'll leave that up to OP, though.
This needs more upvotes. Why wouldn't they teach this properly from the beginning?
I've been doing int main (void). Is that not proper either?
That is standard.
Everything is called from main, directly or indirectly.
And their pension.
Professors are generally not pensioned. Most commonly they are held in a non-teaching research role under tenure until either the end of their lives or the end of their ability to travel reasonably, at which point they are given emeritus. Professors which do not achieve tenure are rarely kept more than a few years, and tenure covers more than pension does. The concept of pension is meaningless in the upper academic community; it's a shibboleth, in the way that someone who comes from a country with highway passes, and wants to know where they can buy access to American highways, would get stared at blankly. Tenure is not generally revokable without serious fraud, so the idea that a professor is trying to protect a life-long protection they already have shows a fair failure to grasp how the university system works. The entire purpose of tenure is to free the professor from that kind of bullshit, and allow them to focus entirely on teaching and research. You're criticizing what you imagine is the nature of a system which was actually built specifically to not work that way.
There are two legal signatures for main. That is one of them. The other is `int main(int argc, char** argv)` (or any equivalent notation, like `char[][] argv`, or `char *argv[]`, which say the same thing in a less readable way.)
Absolutely. I find other people's code becomes significantly easier to understand if it were uncommented, rather than me being able to fit about 3 lines of actual code on my screen between the hundreds of lines of comments. I'll rarely make comments more than a line long between blocks of code, and tend to only make comments 3 lines or longer when I've done something a bit quirky for the sake of optimization, something that makes that block of code difficult to understand at a glance.
I tried this once, the cards overriding the rules broke it for me.
I like [the spiral method](http://c-faq.com/decl/spiral.anderson.html) for reading C declarations.
I sometimes mistakenly think of C as a verbose language. It's not, not when you're able to get clever and willing to get tricky. 
The source to the A+ dialect of APL is even more insane than this, which was also [originally by Arthur Whitney](http://www.aplusdev.org/Develop/devTeam.html). He now runs the company Kx Systems which he cofounded where he developed the K programming language and the new Q programming language, along with the kdb+ column oriented database. [Kona](https://github.com/kevinlawler/kona/) is an open source project that is a clone of K, written in the same APL-style of C that K was. I think you all will find [this discussion](https://groups.google.com/forum/?fromgroups#!topic/sayeret-lambda/Oxffk3aeUP4) about the J Incunabulum, A+'s source, APL and K/Kona and Q on the Sayeret Lambda discussion group very, very interesting and enlightening. Join us in /r/apljk for more links about APL, A+, J, K, Q, and related.
Yup. But then everyone hates that guy that interrupts lectures. If you're going to disagree with the teacher, do it after some consideration at home in case you missed something.
Behind the scenes, ELF binaries usually start with a hidden entry point called "_main" - then this function does some startup, including preparing the stack for the actual "main()" function in a way that argc and argv are set as they are, ready to be used. http://linuxgazette.net/issue84/hawk.html
All that effort and they'll only ever be a single thing actually being called by the client/server. Why not introduce more pointer deferences to try and hide something that'll be the same for 50 years? The kernel will use function pointers when it needs them and explicit references when not. 
+1 for linked lists. Using a binary search if n is under a few hundred will take longer because of the additional overhead and the lack of branch prediction you can take advantage of with a linear search. Hash tables can incur even more overhead for small values of n, and you might just end up using a linked list in the hash table (depending on your keys, hash function, etc). Like you said, wait until you get something working before overengineering it. 
Basically abstract away the implementation so you can do it a stupid simple way first, but leave the ability to add a faster and more complex implementation available. Often times we optimize parts of the code that don't really matter. Doing a linear search on 10k rooms isn't going to be noticeable on a modern system. Bugs are way more noticeable. 
While your implementation is fast, what is going to suck is actually adding rooms. Say you split a room in half, you have to visualize all the rooms and update other rooms to connect to yours. You can also have the three left's don't make a right kind of problem (which may or may not be a feature). You'll likely spend a good amount of your time fixing broken links. What you really will likely need is a simple map editor, since probably 90% of the development is going to be adding and/or changing maps. This could be a simple double array, which you could keep a pointer to on the map and use that to create the connections during run time.
&gt; For me, harder equals more fun, but is implementing a hash map even worth it? I [found this])[1] http://attractivechaos.awardspace.com/khash.h.html) implementation of a hash map. I am looking for something that would be easy on the memory(easy as in not bogging up memory). Sounds like Google-SparseHash would be a good fit for you here: https://code.google.com/p/sparsehash/
Hey, thanks. You really helped me out. [Check out this](http://pastebin.com/qESkUPzr) I have a typedef struct, called Test, and in it I have cols, rows, and 2d array called map. Where there is a 1, that means there is a room there. 0 means there's no room. This isn't my final implementation. I just needed to see if I could get the 2D array correct within the struct.
What you are looking for is a good way to represent a graph. Adjacency lists and adjacency matrices come to mind. Google graph representation. 
I think i'm close enough to the answer where I can probably just figure it out myself now, thanks to the commentors in this thread. Thanks for the suggestion though. I don't know why I didn't think of that in the first place.
Most likely.
Yep, as long as each cell is a single room, you can easily replace the 1s with pointers to the final rooms where you can keep room specific actions/information. It should makes the code very simple, and even allows you to have some "generic" rooms in multiple locations in the grid. I know it kind of defeats the point of your question, but on the plus side navigating through the rooms is going to be super fast.
&gt; Using a binary search if n is under a few hundred will take longer because of the additional overhead and the lack of branch prediction you can take advantage of with a linear search. Read [this article](http://www.pvk.ca/Blog/2012/07/03/binary-search-star-eliminates-star-branch-mispredictions/) ([discussion on Reddit](http://www.pvk.ca/Blog/2012/07/03/binary-search-star-eliminates-star-branch-mispredictions/)). They concluded that binary searches win over linear searches at all array lengths on a modern processor. Of course, I'd still suggest a linear search unless you know they're causing performance problems.
Interesting, I'll need to take a closer look at that at some point. At first glance it doesn't really line up with my experience, but I could always be wrong.
I was thinking of something else also. I still have a struct Room. Now the rooms will never know what rooms are around it but in each room there is array of pointers to a Door class. Each door has two pointers. One to room1 and the other to room2: typedef struct Door { Room* room1; Room* room2; } Door; typedef struct Room { Door* doors[7]; //by default these will all be pointing at walls } Room; so to create a new link I would will need the two rooms and what direction for room1 to put the door, then I need to add a pointer to the door to the opposite side in room2... 0 = N, 1 = NE, 2 = E, 3 = SE, 4 = S, etc.. 7 0 1 6 + 2 5 4 3 if the direction is less than, or is, 3 then you add 4 to it to get the opposite direction(0+4=4; 3+4=7) otherwise subtract 4 to get opposite direction(7-4=3; 5-4=1; etc...) And use these numbers as the index for the array of doors within the rooms void new_Door(Room* room1, Room* room2, unsigned int direction) { //direction = 0 1 2 3 4 5 6 or 7 Door self = malloc(sizeof(door)); self.room1 = room1; self.room2 = room2; room1[direction] = *door; if (direction &lt;= 3) room2[direction+4] = *door else room2[direction-4] = *door; } //by default Do you think this is too costly performance wise or isn't a good way to implement this? I would probably have a function that ran before the dungeon loaded and linked all of the rooms to the doors, which would make adding new rooms easier...I think. edit: I am trying to think of a quick way to switch to the opposite direction. How do you think this implementation would work out... edit2: I could also make each direction a binary number. ex: N W S E...N = 8, W = 4, S = 2, E = 1 and or NW I would just add N to W...NW=12, SE = 3, NE=9, SW=6. From here I could get the opposite direction by shifting all the bits to the left 2 spots. Here is a couple examples: N = 1000 &lt;&lt; 2 = 0010 = S S = 0010 &lt;&lt; 2 = 1000 = N SW = 0110 &lt;&lt; 2 = 1001 =NE or i could just do if (direction = north), else if (direction = south), else if (direction = northeast) but I want it to be smooth like butter.
I am using UTHash in a C project. It is a macro library so it is just a header you include, though the macro expansions can be a bit annoying when debugging. You can pretty much hash on arbitrary bytes, even certain or multiple fields within structs, though it has convenience calls for ints, pointers, and strings.
Well, using indexing as in your first example seems like a good enough choise, it is easy and fast to implement turning and reversing direction using that. The bit mask stuff seems a bit more complex as you have to take care of correctly rotating the bits. It doesn't matter much what kind of indexing you use because you are probably going to use it only in a few helper functions (unsigned reverse_direction(unsigned d){return (d+4)%8;} etc.) so you can change it later if you want. Performance wise you need to think how the dungeon is used. In the case of a text adventure it is almost impossible to create any visible slowdown so just use whatever way you feel the most confortable with. Of course if you are doing something complicated like calculating some complex attack plans for AIs moving in a huge dungeon then you might to worry about things like data layout but most likely you won't have any performance issues.
SparseHash is nice but isn't it a C++-only library though? I didn't see a C version on the page you linked.
Why in calculate() do you pass a pointer to an int for total? The object is never modified.
Looks pretty good! My thoughts: * The instructions state that the function return the structure, but you fill it by pointer instead. * As snappywan said, why pass the total with a pointer? Why have two separate variables, total and amount, that basically mean the same thing, but with different names? * If you want to exit by typing -1, your routine is run (and the result printed) once before exiting. * Why pause before exiting? * If you're feeling fancy, you can replace remainder = remainder % 50 with remainder %= 50 * Of course, the logic in the last two statements in calculate aren't necessary (but you might want to keep them for symmetry).
Pointers are one of those things that I was having trouble with. My main problem is trying to know when to use them and how the syntax works. When I'm done with this term, I'm definitely focusing on pointers, arrays, and strings. Those things hurt my brain at the moment.
&gt;Pointers are one of those things that I was having trouble with. My main problem is trying to know when to use them and how the syntax works. When I'm done with this term, I'm definitely focusing on pointers, arrays, and strings. Those things hurt my brain at the moment. Pointers in function arguments are used either when you intend to return a value though that pointer (multiple return values from a single function) AND/OR when the value being passed in is larger than the size of a pointer and copying it would be expensive. This is a situation where you need to use good names for your function arguments so you can remember more easily what might happen to each of them. Prefixing variable names with 'in', 'out' or 'inout' can help if its not obvious.
So, take a look at the function "calculate." You can make a big improvement there by pulling two lines of that repetition out, making that a function, and then calling it with different arguments. I realize that probably seems minor. However, that's going to turn into a big theme as you program; one of the most common sources of maintenance problems comes in deciding that calculation should change, and missing one. Repetition is a chance for error. Try to destroy it when you're able to.
Just do a little research on passing arguments by reference and by value. Pointers can help if you want to pass the argument by reference. The lessons you learn from this research should help you with *any* language.
You should initialize `amount` to some value other than `-1` before the `while` loop. Otherwise, it could randomly be `-1` and the loop would never be entered.
I updated my code for anyone who's still interested.
I'll be honest, it's gonna take me a while to make a habit out of your style suggestions. I'm so used to using Visual Studio's auto align for that. But what you said does make a lot of sense. In response to 1, I was told it was better to typedef structs. But if you think it's better to leave struct in there, then I'll try that out at some point. I just have to get used to using them with functions. In response to 3, I figured both styles of commenting were C appropriate. The first comment was for a block and the remaining comments were for a line. I didn't see a reason to block comment out a line. But again, if that's the wrong way to go, please let me know.
I initialized it to 0. Does that help? And how do you format the comments here to look like code?
AFAIK, you can configure visual studio to follow the style you prefer. I am not saying you should do everything I do. I tried to explain why I do the things I do. Whoever told you it's better to hide structs away better have a reason. As I explained, the main benefit you get from not typedef'ing a struct is clarity and readability. This is especially important when you read assignments (i.e. a = b), copying (memcpy(&amp;a, &amp;b, sizeof(a))) and passing arguments to functions. C99 does allow both C-style and C++-style comments, but most seasoned programmers usually stick to one. As someone who started C a long time ago, I prefer C-style comments. This is a line comment using C-style: /* comment */ If you want to mix both, sure you can. Nobody is going to stop you. Sticking to one format usually makes using regular expressions a bit easier. Let me clarify there is no one true right way in C in terms of style. My style is mainly based on the linux kernel, partially because that's what I usually work on. However, I also think the linux kernel is the most consistently written C project I have ever seen. Style is a big part of it. I believe making a consistent style a habit will pay off immensely in future. **TL;DR** - Style *is* substance.
Yes, 0 is ok. You can write inline code by enclosing it with backticks (`). You can write blocks of code by indenting it by at least four spaces.
Sorry about the formatting, but that should work. swap(&amp;first_num, &amp;second_num); The &amp; symbol means that instead of sending the value of the integers it sends the address of the integers to the function. void swap(int *x, int *y) This sets the function up to receive pointers to ints instead of just ints. *x = *y; If you did this without the stars it would effectively be "the memory address stored in x is equal to the memory address stored in y". With the stars it's more like "the int value stored at the memory address x is equal to the int value stored at the memory address y". Hope that helps.
Oh I misunderstood your problem. The threaded version _is_ faster, it's just not as fast as you thought it would be. Here are some guesses: * Thread creation, synchronization, tear down overhead * DDR access contention. Although you're running on 4 different cores, they all need to access memory. The memory requests are queued up and served by the memory controller. If your do_work function is memory heavy, I wouldn't be surprised if you start saturating the bus. This is assuming your dataset is large enough that the L2 cache is not enough. * Floating point. I don't know what kind of CPU you use, but on some architectures (granted, old ones) FPUs are shared between cores. That would be a bottleneck.
The workers only uses the kernel during initialization, doing some IO. They spend most of their time in OpenSSL crypto routines. There should be no calls to kernel or synchronization whatsoever. I'll try to make the output data page aligned. But if that is the problem, shouldn't that effect only the part of the data share cache lines but belongs to different threads? If that is the case, it should not have that much of an impact, since the output data items are 32 bytes each and each thread produces 600 outputs. I have tried to allocate private input/output for each thread, but that had no impact on the performance.
Perhaps the work is already IO bound? Otherwise my guess would be on cache thrashing if some read/write data is on the same cache line across threads.
How many threads spawn during a single program execution? How much physical memory is the program residing in? Are you accessing disk at all? 
If you're really seeing 400% CPU usage but performance is only 25% faster than single threaded, then you're being limited by bandwidth to main memory (stalling for memory still registers as CPU activity). You probably need to start thinking about how big the blocks are that you're working on and how to work on the smallest units that you can. Also, make sure you have exactly the same number of threads running as CPUs so that you're not playing musical chairs between cores and further increasing memory usage. Remember: total bandwidth to main memory (all cores) for a typical CPUs is about 5-10GB/s but if you're spending your whole time waiting on memory, you're not spending it *using* the memory. You ideally want your total memory bandwidth to be in the 2GB/s range or lower.
The total workset for each thread is about 300KiB, so everything *should* fit nicely in the cache. I can't change the block size really, since the performance of another pass in the program heavily depends on the block size (and that part takes approximately 3.5 times longer to complete).
Have you tried running this on another machine? Same results? Sorry but without the code, this is basically looking for a needle in a haystack. Maybe you can run some profiling and see what comes out.
Does OpenSSL use any shared resource, though? (/dev/urandom comes to mind). There also maybe some shared data (IIRC you have to call global initialization function before you can use the library).
No random during decryption. I don't use the EVP-interface, so no global initialization. I have skimmed through some of the code for OpenSSL, and I am pretty sure it just crunches data, at least the parts I use.
Yeah, I could try to get hold of another machine with a different setup and benchmark. I understand that it's hard to give any advice without looking at the code. I appreciate your effort though.
You can place 4 spaces in front of your code to turn it into the courier new font (and you can remove the empty lines in between your code lines).
I'd just like to voice my support for bit_inquisition's suggestions. Particularly about not type-def'ing structs. The extra layer of indirection can be a real pain for someone trying to understand your code (or even yourself in a year from now). Also, the Linux kernel style of writing C is very popular. If you adopt it, chances are, it will make editing and reading others' code easier. (Coding style is one area where it is almost universally better to adopt the popular style ipso facto.)
&gt; and it was the way the professor had it written. If it's a CS course and the professor wasn't trying to make a particular point with local scope declarations, there's really no excuse for such a thing.
&gt; Big-O time complexity For that he'd want a balanced binary tree. O(1) find-median, O(log n) insert and delete. Nothing like that in the C standard library, though (afaik). Some constant-factor improvements: Don't use `qsort`, do your inserts like you do your delete: Binary search to where the number should be inserted, move everything past that point to the right by one space, then insert the number into the gap. I haven't checked for bugs, but are you sure you're doing the right thing when you remove the last element? At the moment you're printing "Wrong!" and removing the element, maybe you're meant to print "Wrong!" and *not* remove it? Probably not, but I didn't see anything in the problem statement. Also: make use of %g in format strings if you've got it. I'll probably make your life easier.
Signed, - Some guy who doesn't understand that tenure can be revoked by a board of teachers, and believes anything he reads about a system he's never participated in
I'm as sure as I can be that removing the last element is the correct behavior. There is this line from the site that I failed to copy, sorry, &gt;"Note: As evident from the last line of the input, if after remove operation the list becomes empty you have to print "Wrong!" ( quotes are for clarity ). " So yes. I'll switch to a bsearch for insert and see if I can start failing more and stop exceeding the time limit.
Ah, OK. I misread that printf statement. Though I am confused as to what they mean by "output *{this result}* in a single line". Their example output is *all* on *one* line. Make sure you have good test data of your own, that isn't missing any strange case (if this is in ACM ICP style, they really do try to throw every odd-but-valid case at you for correctness, and of course make sure you're in the correct Big-O category). Perhaps you would temporarily add debugging print statements, such as printing the list of numbers after every insert and delete. Confirm the ordering, count, and individual items are correct, and check the computed median versus what you see in the list.
&gt; Some guy who doesn't understand that tenure can be revoked by a board of teachers Tenure revocation needs a serious reason to happen, and a lack of research or a decreasing quality in one's classes typically aren't those reasons. Thus, my point stands. In general, *very few* professors have their tenure revoked. Since you seem to be involved in the system, I'm quite shocked that a fellow academic would be so disingenuous. Do you sincerely believe that there are no negatives to tenure? Yikes. &gt; and believes anything he reads about a system he's never participated in Lol. I'm a Ph.D. student. So no points for you.
&gt; getopt (and related functions) aren't for getting command-line arguments, they're for manipulating their formatting so you can get them yourself. I see. I certainly didn't have that understanding. If that's true, then my library definitely has a different aim. I am still unsure of any scenario in which I'd willingly subject myself to the mercy of getopt though. &gt; I'm not sure the difference is worth including an extra library for. The difference is that my library provides a single point of truth (a single function call) for the following attributes for each flag: 1) the flag name, 2) the default value, 3) the variable the value is stored in and 4) a short "help" string. I toyed with just parsing my arguments as you have done, but I lose that single point of truth and the process of adding an additional flag is full of pitfalls (requires changes to several pieces of code if I want usage strings, default values, etc.). Finally, if the parser detects an error (like missing an argument to a flag that requires one), then a useful error message is printed along with the usage. This alone adds enough boiler plate to your example to justify some layer of abstraction IMO.
&gt; Tenure revocation needs a serious reason to happen And? . &gt; and a lack of research or a decreasing quality in one's classes typically aren't those reasons You have no idea what you're talking about. . &gt; Thus, my point stands. "I made something wrong up and downvoted you; thus my point stands." . &gt; In general, very few professors have their tenure revoked. Also, assigned in the first place. What's that? The best of the best, who have already survived half a dozen rounds of not being removed, rarely have to be removed? SHOCKER. Next tell me how jurisprudence is broken because Supreme Court justices never get removed. See, without a null hypothesis or a complete look at context, you end up not being taken seriously. . &gt; I'm quite shocked that a fellow academic would be so disingenuous. I'm not an academic, and that's not what the word disingenuous means. I have in no way lacked candor with you; to be disingenuous is to pretend that you're less angry with someone than you actually are. I suspect you meant "dishonest," and fapped a big word into place to create a seeming of intellectual authority. However, there's nothing dishonest on calling a Redditor on their false claims about tenure. But, of course, your claim that I'm being dishonest lies on the following system: 1) You claim that getting tenure leads to "doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers," and that "You can go to most departments and find tenured professors fitting that bill. They aren't hard to spot." 2) I laugh at you, because this is not correct, and you have no data to support your position of any kind. 3) You decide that you actually meant it was rare, and that somehow, for laughing at you for taking a position you've already backed away from, that *I'm* the one being disingenuous. Le cough. Truly, hard to sort out. . &gt; Do you sincerely believe that there are no negatives to tenure? I did not say this. Please do not invent positions for me in the desperation to have something to feel correct about. To be clear, it seems very likely to me that this behavioral tendency of yours, to sarcastically jump to conclusions despite that the facts suggest the opposite of your new claim, while dusting your old errors under the rug, and calling other people dishonest without a legitimate reason, is why you interpret so many teachers to be poor teachers who are disinterested. I wouldn't invest any effort in you either. . &gt; &gt; and believes anything he reads about a system he's never participated in &gt; Lol. I'm a Ph.D. student. Oh, did you think that a PhD student was a college professor who had been through the tenure system? You aren't very smart when you're trying to be correct. More than two thirds of PhD students fail to get a degree. Whereas I cannot speak for all universities, at Rutgers, the ones who failed out or quit were almost always the ones who couldn't admit mistakes, and felt no shame calling other people liars without being able to point to an actual lie. I'm sure you'll pretend "disingenuous" should be read more softly, in the way that people who say you've knowingly and intentionally told a falsehood, then insist "but I never said liar," also fail to understand why their behavior leaves them isolated and on the outside. The best part? There is a group that I'm describing, and yes, I've pigeonholed (based on observed behavior, it's not a stereotype) you into being one of them. They're called Dunning-Kruegers, and smart people from Reddit fly off the handle when you say that to them, because Reddit is confused about what that paper actually says. Try reading it. It's called "Unskilled and unaware of it." I'm sure you're very skilled in a lot of ways. Understanding university and lecturer structure is not one of them. Your facts are in error, and you're holding up your personal experience as a dataset.
&gt; And? Revocation of tenure is therefore not an apt response to balancing the cons of tenure (that I described) in the first place. &gt; You have no idea what you're talking about. Ditto. &gt; "I made something wrong up and downvoted you; thus my point stands." Ditto. &gt; Also, assigned in the first place. What's that? The best of the best, who have already survived half a dozen rounds of not being removed, rarely have to be removed? SHOCKER. Firstly, you assume tenure actually distinguishes professors accurately that are the "best of the best." I'd agree that this is generally true. However, the process of attaining tenure says ***nothing*** about how one will maintain tenure. Which is my point, and therefore makes your observation a red herring. &gt; I'm not an academic, and that's not what the word disingenuous means. I have in no way lacked candor with you; to be disingenuous is to pretend that you're less angry with someone than you actually are. Being disingenuous has nothing to do with 'anger' (wtf?). *If* you were an academic, you were disingenuous by being deceptive: a lack of rigor toward the study of an idea. &gt; I suspect you meant "dishonest," and fapped a big word into place to create a seeming of intellectual authority. However, there's nothing dishonest on calling a Redditor on their false claims about tenure. Yeah... disingenuous... That's a big word. It took a lot of mental effort to dig that one out of the old wood work. And nice straw man, I didn't call you disingenuous for claiming I made a false claim. That's rubbish. &gt; You claim that getting tenure leads to "doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers," and that "You can go to most departments and find tenured professors fitting that bill. They aren't hard to spot." I did not claim that getting tenure *leads* to that. Stop purposefully misrepresenting my argument, or else I might have to call you another big word that only us intellectually superior folk would understand. &gt; I laugh at you, because this is not correct, and you have no data to support your position of any kind. I laugh at you laughing at me, because I made no claim of the sort. I agree that I did not present evidence to show that tenure *leads* to a lack of research or worse teaching. I simply used *a priori* reasoning to deduce that a world with tenure (as it is instituted now) allows such things to happen more readily than a world without tenure. &gt; You decide that you actually meant it was rare, and that somehow, for laughing at you for taking a position you've already backed away from, that I'm the one being disingenuous. What? Is your reading comprehension okay buddy? The only thing I said was rare was tenure revocation. &gt; I did not say this. Please do not invent positions for me in the desperation to have something to feel correct about. Ditto. And I didn't invent anything. I *asked* a question. I asked it because it certainly *appears* that you do not see any negatives to tenure (since you have so blindly argued in its favor without any consideration for trade-offs). But I asked the question in case I was wrong. Giving you an opportunity to appear rational instead of blindly favoring a position without balancing trade-offs. &gt; To be clear, it seems very likely to me that this behavioral tendency of yours, to sarcastically jump to conclusions despite that the facts suggest the opposite of your new claim, while dusting your old errors under the rug, and calling other people dishonest without a legitimate reason, is why you interpret so many teachers to be poor teachers who are disinterested. Your reading comprehension is suffering so badly that it borders on delusion. I've never interpreted "so many teachers to be poor teachers who are disinterested." My initial, off the cuff remark was: "You can go to most departments and find tenured professors fitting that bill. They aren't hard to spot." Which certainly does not imply "so many teachers." It implies that you might find one or two in each department. &gt; I wouldn't invest any effort in you either. [phew] That was a close one. I was really hoping you wouldn't. &gt; Oh, did you think that a PhD student was a college professor who had been through the tenure system? Nope. But as a Ph.D. student, I've participated in academia and been in an excellent position to observe the tenure system. I absolutely consider that I've participated in the system. &gt; You aren't very smart when you're trying to be correct. Owch. You're a really mean person, aren't you? You seem to have a lot of hate bottled up. &gt; More than two thirds of PhD students fail to get a degree. Whereas I cannot speak for all universities, at Rutgers, the ones who failed out or quit were almost always the ones who couldn't admit mistakes, and felt no shame calling other people liars without being able to point to an actual lie. If your assessment was correct, I suppose I'd be doomed to failure. I've pointed to several of your misrepresentations in this comment though. And I didn't call you a liar; I said you were disingenuous. Or have you already forgotten the meaning of the word? (I mean, it being an intellectually superior word and all.) &gt; I'm sure you'll pretend "disingenuous" should be read more softly, in the way that people who say you've knowingly and intentionally told a falsehood, then insist "but I never said liar," also fail to understand why their behavior leaves them isolated and on the outside. Well, disingenuous doesn't mean "liar." It means "fake." They are two different things. As someone who has lectured me on the meaning of the word "disingenous", I'm quite surprised that you would make this mistake. &gt; The best part? There is a group that I'm describing, and yes, I've pigeonholed (based on observed behavior, it's not a stereotype) you into being one of them. They're called Dunning-Kruegers, and smart people from Reddit fly off the handle when you say that to them, because Reddit is confused about what that paper actually says. Try reading it. It's called "Unskilled and unaware of it." I'm sure you're very skilled in a lot of ways. Understanding university and lecturer structure is not one of them. Your facts are in error, and you're holding up your personal experience as a dataset. The best part, is that you've done nothing to convince me that my initial observation is incorrect. All you've done is pranced about and accused my experience as being unworthy. (And been quite a jackass about it, mind you.) And I've read "Unskilled and Unaware of It." I'm very much aware, thank you very much.
Ah, derp. Forgot about that. [WTFPL](https://github.com/BurntSushi/clibs/blob/master/COPYING).
&gt; Revocation of tenure is therefore not an apt response "Based on the false thing I said, I continue to insist on my position, while declining to address the actual lack of evidence for my claims." . &gt; Firstly, you assume tenure actually distinguishes professors accurately that are the "best of the best." It's not an assumption. It's knowledge of the purpose of the system and the meaning of the word. I do get that you want to reply to everything with a heaping helping of personal skepticism. Try to keep up: I have associated your doubt with that your behavior excludes you from the system that works so well for everyone else. . &gt; However, the process of attaining tenure says nothing about how one will maintain tenure. This is factually inaccurate, even with all the big scary bold italics. . &gt; Being disingenuous has nothing to do with 'anger' (wtf?). You sure do like to cut away context and remove most of what was actually said, to try to create a seeming of error. It doesn't succeed. It makes you look dishonest. The error comment had to do with that I was in the process of you quoting me as claiming being angry. The actual definition given was about honesty regarding emotions. If you can't even be honest about what the person you're speaking to is saying during a discussion, I fail to see why you think people should take seriously your criticisms of them. . &gt; If you were an academic I made it through the system you're trying to make it through. I successfully exited and moved on. Stop guessing at various reasons to look down on me. You haven't been correct so far. . &gt; you were disingenuous by being deceptive: a lack of rigor toward the study of an idea. One, I haven't studied any ideas. Two, I have applied far more rigor than have you. Three, I'm not making claims; I'm laughing at your claims. Your claims come without evidence. Four, there is no deception involved in saying "the things you said are incorrect." Five, this is the second time you have called me a liar without an actual example. My opinion of you is in decline. &gt; &gt; You claim that getting tenure leads to "doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers," and that "You can go to most departments and find tenured professors fitting that bill. They aren't hard to spot." &gt; I did not claim that getting tenure leads to that. Your words: &gt; &gt; &gt; &gt; And it also gives rise to different forms of bullshit: like professors doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers. I have not purposefully misrepresented anything; what I said was a literal quote of yours. You are merely repeating the data-backed criticisms of you back to the person who gave them to evade feelings of guilt. You will not admit to being caught having made this claim falsely. You will claim that I have been caught mis-representing you, even though I have not. `:/` What I find saddest is that I actually predicted, to your face, that you would do this, and it didn't stop you. . &gt; Stop purposefully misrepresenting my argument I have not done this. I said this to you with actual examples; you merely ignored what was said to you, and repeated the claim back to me. You claim a literal quote is a purposeful misrepresentation, inbetween made up condescention to someone who first you imagined was like you, and now you imagine is beneath you (both incorrect.) This leads to great doubt in your veracity. . &gt; Yeah... disingenuous... That's a big word. Apparently for you, given that you got it wrong. . &gt; It took a lot of mental effort to dig that one out of the old wood work. Are you actually bragging about how little work it took you to mis-use a word? . &gt; &gt; I suspect you meant "dishonest," and fapped a big word into place to create a seeming of intellectual authority. However, there's nothing dishonest on calling a Redditor on their false claims about tenure. &gt; And nice straw man, I didn't call you disingenuous for claiming I made a false claim. That's rubbish. It is particularly bizarre to engage in a straw man while claiming falsely that the other person has. At no point in that quotation did I attempt to evaluate the reason for you mis-using the word "disingenuous" as being based on that you made a false claim. There is nothing there of cause. I merely pointed out what you claimed, what I actually said, and how the two have no sensible overlap. In your desperation to show me incorrect, you have whole-cloth invented my saying "and this is why," when I did not, and then gone on to tell me ... that I should stop making up things you said? I mean. How is one to react? You are pairing criticism of text I did not write with the claim that the absent text is me ... criticizing you for things you did not write. Take a bow; it's an endearing fiction. . &gt; I laugh at you laughing at me What a surprise. . &gt; &gt; I laugh at you, because this is not correct, and you have no data to support your position of any kind. &gt; I laugh at you laughing at me, because I made no claim of the sort. As is pattern, you've cut away context, so that it's not painfully obvious how false this is. Let me re-address it for you. &gt; &gt; &gt; You claim that getting tenure leads to "doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers," and that "You can go to most departments and find tenured professors fitting that bill. They aren't hard to spot." And yes, you said you didn't make that claim, so here, I'll show you your own quote again. &gt; &gt; &gt; &gt; And it also gives rise to different forms of bullshit: like professors doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers. Of course you made no claim, of the sort of what turns out to be a cut and paste verbatim copy of your own text. (rolls eyes) I kind of expect to see the edited asterisk appear on that post soon. . &gt; I simply used a priori reasoning Yes, italicizing latin makes you look smart, really. A priori reasoning: knowledge independant of experience. But there's no reasoning there. At all. You just made a bold-faced claim, and asserted it as fact. A priori reasoning is stuff like "if we start with the assumption X, then rule A and B lead us to the conclusion Y." You didn't do that. You started with an affirmative claim of fact, then stopped. There was no attempt to reason, and you were not speaking in the hypothetical, which is a categorical requirement of a priori reasoning. This is what you really did, outside the fantasy world where you imagine you did all these intellectually rigorous things that you can't actually give examples of you doing, but are happy to assert are there if someone goes to look, because that isn't falsifiable: &gt; &gt; &gt; &gt; And it also gives rise to different forms of bullshit: like professors doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers. That is not a priori reasoning. You're just throwing around words to look smart, again. And, again, you're either getting them wrong or trying to smoke screen me with something you think will confuse a person you imagine to be a plebe. I really can't tell whether it's that you don't know what these words mean, or that you think I don't and you can just dash them out there. . &gt; &gt; I did not say this. Please do not invent positions for me in the desperation to have something to feel correct about. &gt; Ditto. And I didn't invent anything. I asked a question Nonsense. Here's the quote you're again stripping to create the false appearance of dishonesty. &gt; &gt; &gt; Do you sincerely believe that there are no negatives to tenure? That is you inventing a position for me. Even though you want to remove the example then pretend you didn't do it. Please stop doing that. It isn't going to work. It's *deeply* dishonest. . &gt; I asked it because it certainly appears that you do not see any negatives to tenure Are you seriously claiming that, because I told you that your claims about tenure are factually in error, that it seems I see no problems with tenure of any kind? The logic underlying that will be delightful. I request an explanation. . &gt; (since you have so blindly argued in its favor Another thing you're pretending I did, without examples, over my protest. What a highly honest surprise. . &gt; without any consideration for trade-offs). It is not necessary, in observing that you have made claims factually in error, to continue by weighing the upsides and downsides of a system. It is sufficient to point out that you are making claims, factually in error, with no evidence, and asserting your personal experience to be fact, despite that the Razor of William of Ockham prefers "you're unpleasant" to "the entire system is corrupt and there are lazy teachers in every school and everybody knows it." . &gt; But I asked the question in case I was wrong. DO YOU REALLY BELIEVE THAT RAPE IS THE BEST WAY TO BUILD A FAMILY Oh I'm not making up positions for you, I'm just asking questions. It really seemed that you thought that. But I asked the question in case I was wrong. I see you watch Fox News. (Continued; too long)
(continued from prior; too long) &gt; Giving you an opportunity to appear rational Do you honestly believe that my appearing rational in criticizing you for data-absent factual error in assertive claims is something you deign to hand out? My, my, someone thinks they're important. I'm curious why you think accusing someone of a position they've never taken, in question form, is a case of you being kind enough to permit someone else to appear rational. . &gt; instead of blindly favoring a position Again, something I have not done, because you prefer arguing with things you imagine, then complaining that you haven't made anything up. . &gt; Your reading comprehension is suffering so badly I'm sure the guy who claims literal quotations are falsehoods is in a position to complain about someone else's reading comprehension, when the primary thing they're telling you is "you are making up positions for me; stop it." . &gt; I've never interpreted "so many teachers to be poor teachers who are disinterested." &gt; &gt; &gt; &gt; And it also gives rise to different forms of bullshit: like professors doing hardly any research or just generally not trying at all. It removes incentives to become better teachers and researchers. . &gt; My initial, off the cuff remark was: Yes, that's the only thing you ever said. Clearly I couldn't be talking about a different thing, of which I just provided you a direct quote. . &gt; Which certainly does not imply "so many teachers." It implies that you might find one or two in each department. I find that to be an unlikely high number. Try to argue less and understand more. . &gt; Nope. But as a Ph.D. student, I've participated in academia So have I. I've also completed it successfully and exited it. Please stop masturbating to your not-germane accomplishments. Being a student does not qualify you to discuss tenure. . &gt; and been in an excellent position to observe the tenure system. Yes, I've already told you - several messages ago, predictively - that I disagree with you on this. To wit, I've had more experience than you in that role, but I guess that only applies to you, and nobody else. . &gt; You seem to have a lot of hate bottled up. Ah yes, more personal observations by a stranger. Clearly, if someone tells you you aren't smart when trying to be correct, after observing you making a long series of errors, it couldn't be them laughing at you, like they've been saying; it *surely* must actually be hate instead. This is, of course, a case example of your sarcastic jumping to fact-absent wrong conclusions in a way that distances you from people. I don't have to hate you to laugh at you for saying stupid things, guy. . &gt; If your assessment was correct, I suppose I'd be doomed to failure. Not really. People can change their behavior. But that takes admission and effort. . &gt; &gt; "that's not what the word disingenuous means." ... &gt; &gt; "I suspect you meant "dishonest," ... &gt; &gt; in the way that people who say you've knowingly and intentionally told a falsehood, then insist "but I never said liar," &gt; And I didn't call you a liar; I said you were disingenuous. Mmm hmm. So, either you were saying I was hiding my emotions, or you're failing to remember what I said and cherry-picking pieces to construct what appears to be another error. Which makes that the next words are these all the better: &gt; Or have you already forgotten (rolls eyes) Literally everything you're saying I predicted you would say. Doesn't that bother you? Do you not realize what that means? . &gt; (I mean, it being an intellectually superior word and all.) Oh look, more made up stuff. What I actually said was that the word was too big for you, because you got its meaning wrong. It isn't intellectually superior; words like that are generally used by people who have a serious desire to be seen as smart, but don't realize that that comes from having a discussion based on honest representations of what the other person said, and when called on it, not just saying the same thing back without examples. You know, the kind of people who brag about being a PhD student every single post. . &gt; Well, disingenuous doesn't mean "liar." It means "fake." It doesn't mean either of those things. You were already handed a definition. Notably, it was a dictionary cut and paste. You're now arguing with it, without reference. What a surprise. . &gt; As someone who has lectured me on the meaning of the word "disingenous", I'm quite surprised that you would make this mistake. Are you really so desperate that you're pretending that someone saying "you thought it meant liar" themselves thinks that, for cutting and pasting what you yourself said? Try to keep up. 1) In your earlier post, you used the word disingenuous in a way that only makes sense if you think it means liar. 2) I said "it does not mean liar, and I don't appreciate your saying that." 3) Now you're claiming I ... think it means liar? This ... is just sort of depressingly obviously manufactured. . &gt; The best part, is that you've done nothing to convince me that my initial observation is incorrect. Dunning Kruegers generally cannot be convinced. And by definition, they do not self recognize. . &gt; All you've done is pranced about and accused my experience as being unworthy. Another false accusation. I have done no such thing. I have merely asked you to stop repeating it. I did, actually, say "I'm sure you're very skilled in a lot of ways." At no point have I attempted to judge the value of your experience. It is disappointing that you must invent so many falsehoods by which to feel an aggrieved victim. . &gt; (And been quite a jackass about it, mind you.) Uh huh. . &gt; And I've read "Unskilled and Unaware of It." I'm very much aware, thank you very much. Maybe you didn't realize it, but "being aware" would mean accepting that you have low skill. `:/` Please calm down and think harder before your next reply, if it must happen (which I'm sure it must.)
&gt; The first thing I checked for was support for --, to stop argument parsing, and you do it right. Good! Totally accidental :P Basically, if an argument is length at least 3 and starts with '--', then it is consider a flag. Otherwise, it and all subsequent arguments are considered non-flag arguments. So in this case, '--' will show up as the first non-flag argument. &gt; My only comment is about your Makefile, since you mentioned it. Generally libraries (just -lopt in this case) are listed in LDLIBS (sometimes LOADLIBES), which is appended last, and not in LDFLAGS. Nice find! Thanks for the tip. I've updated my rule to: ex-%: libopt.so examples/%.c $(CC) $(LDFLAGS) -o ex-$* $(CFLAGS) examples/$*.c $(LDLIBS) With LDFLAGS= LDLIBS=-I. -L. -lopt
Well, `-I` goes in `CFLAGS`. This is important because `LDFLAGS` isn't used outside of linking and you'll need `-I` in normal object file compilation. `-L` goes in `LDFLAGS` (flags for the linker) and `-l` arguments go in `LDLIBS` (libraries to be linked). CFLAGS = -I. LDFLAGS = -L. LDLIBS = -lopt When you're using GNU make, it knows how to use all these implicitly and it's really nice. So this rule is entirely sufficient without any explicit commands (literally as I wrote it below): my-program : my-program.o foo.o somelib.o somelib.h This will compile all the object files separately automatically. 
You probably want to at least include a nonliability clause... Otherwise people might sue you
Mentioning this for the sake of completeness - You *could* use DLLs / SOs. For example, on Windows, you'd need the LoadLibrary and [GetProcAddress](http://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx) functions. Of course then you'll have to export the function properly. And if you really want to do this on the compile level, you'll need to use the preprocessor. Just put a "#define METHOD_EXISTS" on top of your Module-B-Function. EDIT: Oh, of course Synthos already said pretty much the same thing
The usual route is to look up the symbols at runtime, either with `dlopen()`/`dlsym()` on POSIX or `LoadLibrary()`/`GetProcAddress()` on Win32. You can also define the functions as weak symbols, which makes it not a link error if they aren't found. But in that case the symbol will resolve to 0, so you have to check its value before calling it, otherwise it's a null pointer dereference. 
This, probably, but not exactly as the parent post. I'm not entirely sure what's going on here but something with stubs would probably work. Don't have them print an error message, though, have them return an "unimplemented" condition. That way you could just have C code like your psuedocode struct foo record; if(moduleB_initFoo(&amp;record) == FOO_UNIMPLEMENTED) { if(moduleA_initFoo(&amp;record) == FOO_UNIMPLEMENTED) fooError("No initializer implemented."); } but that's kind of clumsy. It kind of seems like you should be looking for a library organization of these modules? You could have static libraries if you need everything actually compiled together into a monolith for some reason, but why not go with a .so/DLL? You can load from them dynamically at runtime, the Unix-style is I think dlopen() etc..., don't know Windows off the top of my head.
Thanks to all the replies. My inclination beforehand was to go down the .dll route, but some of the suggestions look interesting and warrant further investigation. Thanks, again.
I did, actually... I use group the programming subreddits together like so: http://www.reddit.com/r/compsci+programming+embedded+coding+c_programming+cpp
You suddenly start taking about states, it would be nice if you explained what a traversal state is before analyzing iterative solutions. Good article overall.
So, it turns out that you can iterate over an n-ary tree with parent pointers without the use of extra stack/heap space. (i.e. in constant space) I implemented an iterative version of this, found here: http://codepad.org/HLp2pTVU Shown below: /// do a tail-recursive postorder traversal of a binary tree void traverse_iterative(Node *node, void (*visit)(Node *)) { Node *parent = NULL, *prev = NULL; // base case: the tree never had nodes if(!node) { return; } for(;;) { // base case: *parent is a lead node if(!node) { node = parent; parent = NULL; // we just finished visiting the right child, visit the current node } else if(prev == node-&gt;right) { visit(node); // termination case: we have returned to the root node if(!node-&gt;parent) { return; // ascend the tree, we've visited our parent's right child } else { prev = node; node = node-&gt;parent; } // we just finished visiting the left child, visit the right right } else if(prev == node-&gt;left) { parent = node; node = node-&gt;right; prev = NULL; // we need to go visit the left child } else { parent = node; node = node-&gt;left; prev = NULL; } } }
I usually don't use gotos much at all to be honest, have a bit of an inner conflict of what to think of them. Care to convince me either way?
I hope you can still fix this because the article really interests me. :)
&gt; Veracity? VERACITY? What does that word even mean? (sigh) Best of luck to you, champ. There's no purpose in continuing this.
Ignore StoneCypher. He's a pathetic cunt and a troll with delusions of grandeur. He seems to thing that he's very intelligent and well-versed in the English language, but in reality he's a sad, lonely, fat piece of shit with a shitty life and no personal successes. The only way he can make himself feel adequate is by talking big and being a douche on the internet. Take a look at [this thread](http://www.reddit.com/r/PHP/comments/iu7xw/stonecypher_can_you_tell_us_about_your/) and the very last post on [this user's](http://www.reddit.com/user/StoneCypherIsACunt) page. Notice how he already downvoted you? I bet he's already whined and whimpered like the little bitch he is for being downvoted. He's a huge hypocrite; he'll bitch about being downvoted, but will do the same. Then he'll say he doesn't care about karma. What else can you expect from a whiny cunt?
Cunt.
Now thats interesting.
Hello! Free open source software is a good way to go. Arduinos are cheap and easy to work with, the only annoying part about them is everything else [soldering and such]. You can also build your own project, with SDL or openGL [look at the sidebar of [/r/gamedev](http://www.reddit.com/r/gamedev/)]; you can make a terrain or voxel engine, or do something else entirely. You can make a programming language, which can be fun.
Being a CS major isn't a requirement. I'm a CE major, and worked as a software engineer for many years. The hump is going to be getting that first job, since you don't have any experience you can demonstrate. Can you actually sit down and code up a useful program from start to finish? I ask, because even my best friend that got a CS degree was lost when faced with this. He really had no idea how to put together the whole program, start to finish. He was more into what he could do with little pieces in the middle of it all. Think of something you want to do, and write it. Programming is one skill that develops with practice. I know when I first started for fun, there was rarely free time I wasn't coding, or thinking in code, and I spent many, many all nighters working on projects. When you get an interview, a smart manager will be the one that asks you to code something. You need to be able to do the task. When I was hiring at one of my older companies, there were tons of people that came in that could talk up a storm, but when you asked them to do something simple, they were baffled. I think it will be easier for you to start off doing something like Linux or Windows development than getting into embedded stuff, but if that is your passion, then go for it. Lots of work in that area. You could also start off in testing. It's not glamorous, but every one of those new boards/chips being developed by someone needs people to write test cases and automated testing procedures. This is often work for junior engineers, and if you're smart, you'll pick up a lot of knowledge from it instead of considering it a grind. Good luck.
Go contribute code to an open source project.
I've been looking. If you know of any interesting ones one could realistically contribute to (ie. not the linux kernel) I'm all ears!
Eventually doing something where I can combine my background in mathematics and my interest for programming would be great and I feel like doing analysis for data sets would fit right in. As far as I know (going by the course description) most of the classes given at my university are using Java or Python by now but I think I might have a look at the department's professors and see if they have any research/projects going on using C and try to meet them. Thanks!
Hey! The double major my university is offering ends up being too much of a split in credits. I'm having enough trouble as it is fitting all the classes I want to take in 90 credits (only for math) if I had to bring it down to 60 (double major here is 2x 60) I'd miss out on a lot of good stuff. What I might do is see if minoring in CS would let me take interesting classes. A minor is only ~10 classes but my degree also includes a few math-related CS courses that'd go on top of that. I've also been running GNU/Linux based OS as my main system for the past 7 or 8 years and using almost inclusively FOSS for the past couple of years as well. One thing I'm noticing now that I'm actually searching for projects to contribute to is that I don't actually use that many applications in my day-to-day life. I suffer from the emacs curse: I use it for pretty much every thing. I actually found a class from the Illinois Institute of Technology online that has a lab assignment to write a basic unix shell emulator. The class' site has a lot of the theory behind it so that might be my project for the next couple of weeks. Thanks!
&gt; The double major my university is offering ends up being too much of a split in credits. I'm having enough trouble as it is fitting all the classes I want to take in 90 credits (only for math) if I had to bring it down to 60 (double major here is 2x 60) I'd miss out on a lot of good stuff. What I might do is see if minoring in CS would let me take interesting classes. A minor is only ~10 classes but my degree also includes a few math-related CS courses that'd go on top of that. I'm sorry to hear that---that really blows. It sounds like your university really doesn't want people to double major. Usually in closely connected fields like CS &amp; Math, you can double dip. I know I did :-) &gt; I've also been running GNU/Linux based OS as my main system for the past 7 or 8 years and using almost inclusively FOSS for the past couple of years as well. One thing I'm noticing now that I'm actually searching for projects to contribute to is that I don't actually use that many applications in my day-to-day life. I suffer from the emacs curse: I use it for pretty much every thing. Ah, I see. I'm not an emacs user (I belong to the Church of Vim), but does it by any chance use any external dependencies when you're pushing it to the extreme? (i.e., farming out work to other commands.) Maybe that'd be a good place to look? It can be tough to get up and working on your first project. Usually the best thing to do is to just solve a problem for yourself and publish your solution. The best projects come from real use cases: do you use any tools (or combination of tools) for your math courses? Maybe you could look into automated theorem proving or developing a better way to search for math theorems/proofs. (Unfortunately, both of those problems are probably extraordinarily difficult.) Also, I'm betting some other folks recommended Haskell since you're interested in math. It might be an interesting thing to checkout (it will twist your brain in fun and interesting ways), but it doesn't directly help your OP. &gt; I actually found a class from the Illinois Institute of Technology online that has a lab assignment to write a basic unix shell emulator. The class' site has a lot of the theory behind it so that might be my project for the next couple of weeks. Thanks! Nice! Good luck :-)
I'll probably heed your advice, thanks.
&gt; I've just discovered that you're such a jackass, that you've attracted your own troll. Yeah, be sure to keep trying nine days later, and not to consider what that means. &gt; (I was ever so courteously alerted by the troll himself.) Yes, that speaks well of your judgement. &gt; I have no desire to wish you luck Hooray (tm)
Cunt.
Oh noeh, what will Bjarne say now? :-)
Looks good on first sight. [sampletest.c has a typo on line 54](https://github.com/Tordek/cheat/blob/master/sampletest.c#L54). I like how it is so simple. I avoid large testsuites because I sometimes cannot maintain a codebase larger than a few megabytes and I don't want to put code in my assets. This is excellent, 10K code that performs great!
&gt; sampletest.c has a typo on line 54. Thanks, fixed! &gt; I like how it is so simple. My main gripe with other testing frameworks is how they demand a certain order, or that you write your own `main`, or at the very least, that you list your tests again. This involves some macro magic, which isn't the prettiest solution, but it was fun to write. It does have some unfortunate downsides, not the least being that when an assert fails, it points to the line where the test is defined, instead of where the assert is. My idea of a testing suite (especially for someone not used to one) is that it should be very easy to write tests in it. In this case, you use a single macro and everything else is taken care of for you.
Its likely due to cache coherency being fired off a lot of times, even though each one has a separate section of the memory to look out for each processor is probably loading up parts of the other processors work set in the cache line, and whenever one is updated the other processor that also has that line loaded has to be updated. To try to see if this is the case, find out how big the cache line is on the system, and then pad parts of the array with null to try and keep the items of dif processors on dif cache lines.
Why not use a profiler? You can't provide us any source-code or any substantial details, so I don't expect anything productive by any party. See "oprofile" or "perf" if you're on Linux. If you want more granularity, check "PAPI" out. Make sure shared data is read-mostly/read-only.
In the [roadmap](http://concurrencykit.org/roadmap.html) section I'm guessing MIPS means MIPS64, right? And I also see SBCL bindings... sweet! Awesome project!
Frankly, it seems likely I will be dropping MIPS/MIPS64 support from the roadmap unless a contributor steps up to give me access to a multi-core MIPS64 machine or decides to maintain the port! For now, MIPS/MIPS64 can actually get a heavier-weight version built using GCC intrinsics (which is the default fallback). They can use --profile to hack this.
Okay, nice try, but there are several problems here. I'll start with your error message. You can't typically add pointers, usually you only add a pointer and an integer for example. Adding the addresses of two variables doesn't make much sense. (Note, subtracting them can be useful, however.) Now, in C, there is no such thing as a "string" type like there is in other languages. So, strings are instead represented as pointers to the first character in a string. In this case, you are adding the result of `meta`, which is a string, to "\n", which is also a string. The result is that you are adding the locations of the first character returned by `meta`, and the location of the '\n' character in the string "\n", which consists of two bytes, '\n' and 0. So, another problem here is that you are creating a string pointer `upcoming`, and pointing it at an empty string, and then writing to that empty string. Beyond the intricacies of pointer handling, it seems that fundamentally what you are not understanding here is how memory works in C. So here's a brief tutorial on memory for handling strings in C: When you have a string literal, like "No tracks in queue.", "\n", or even "", this data goes into the _text_ segment of your program. That memory is always available, (i.e. global, not allocated or freed), and cannot be modified. So you can't point a `char*` at "" and then write to it. Secondly, you must have enough memory to write to! Even if you could write to that memory, you have a string "" which is only 1 byte long, consisting of the 0 delimiter. (All strings must have space for a 0 at the end to mark their end.) So, at the very least, you must have `upcoming` point to a larger block of memory. Secondly, this block of memory must be writeable. This will not work: char *upcoming = "123456789"; upcoming[0] = 'A'; You get a segfault if you try this. But using a pointer here is similar to using an array, the difference being that the array is allocated on the stack and *initialized* to the contents of the string: char upcoming[] = "123456789"; upcoming[0] = 'A'; Now there is no segfault! You can modify the array, which happens to be a string. If we want to start with a blank string, but make sure it is large enough to hold something, we can just give it a size: char upcoming[1024] = ""; This implicitly sets upcoming[0] to 0, but upcoming is actually a 1024-byte array on the stack. So, how do we append data to it? Well, one way is to keep a pointer to the end of the string, and update it as we add information. This seems to be what you tried to do. Another way, perhaps a bit less efficient, but kind of easier: We need some routine which will find the end of the string, copy new data to it, and replace the delimiter. Fortunately, there is one available called `strcat`, ("concatenate strings"). It's in `string.h`: char upcoming[1024] = ""; strcat(upcoming, meta(format, M_COLORED, &amp;node-&gt;track)); strcat(upcoming, "\n"); Okay, so far so good. I should mention that technically this is not safe, because if `upcoming` is not long enough to handle the final string, then it'll overwrite the end of the stack and crash (or expose a security hole.) You should instead use `strncat`, which allows you to specify the maximum length of `upcoming`: char upcoming[1024] = ""; strncat(upcoming, meta(format, M_COLORED, &amp;node-&gt;track), 1024); strncat(upcoming, "\n", 1024); Finally though, we can't actually return this string. If you do, return upcoming; then you are returning data that is on the stack! This is bad, because the stack is increased when you call `previewstr`, but it is unwound after `return`, meaning you've returned a pointer to memory that is no longer valid. Instead, you have to make a copy of the final string on the heap. The caller of `previewstr` will have to be sure to free it. You could count the final length and `malloc` those bytes, then copy the string, but there is a function that does all this in one shot, called `strdup`: return strdup(upcoming); Now the caller of `previewstr` should save this pointer and free it, char *previewupcoming = previewstr(somelist); if (previewupcoming) { printf("upcoming: %s\n", previewupcoming); free(previewupcoming); } That's it! Notice that `strdup` can potentially return 0, though it's not likely, but it's still necessary to check for that condition and do something logical. In this case I just don't try to print the string or free it.
Thank you, that's very thorough and educational for me. Unfortunately, I have concluded that, for the time being, it's a terrible idea for me to do this at all, given the immensity of my C ignorance, and tolerance. I don't know how people work in C and stay sane. I will surely read this post at least a few more times, however.
I use utstring to do all of my string manipulations while in straight C. http://uthash.sourceforge.net/utstring.html
Ha, well C is just more low-level, it doesn't have abstract concepts like "strings", rather, it just has structures that are a bunch of bytes, and pointers to them. In that sense it's quite simple, if you can keep straight what points to what. But yes, probably something like Python is a better place to start unless you strictly want to learn more about C. Even C++ has a "string" class that you can use the "+" operator with.
Personally I would do something like this: char* someFunctionReturningString() { // Create a char buffer in static memory (stays for the entire lifecycle of the app). static char buffer[256]; // Clear the memory before using it memset(buffer, 0, 256); // Print into the buffer using usual format. Ideally use snprintf as pointed out below. sprintf(buffer, "Usual format stuff in here, %s", "blah"); // Return the pointer to this char buffer return buffer; } This might be used in your program like so: printf("The retured value was: %s\n", someFunctionReturningString()); This way you don't have to deal with malloc/free, but rather pay the small penalty of having the static buffer sticking around.
Yes this is certainly an issue and thanks for pointing it out (for OP if not myself). The main way I personally use it is by inserting it directly as an argument to printf, so I don't run into this issue. A lot of API's that I've seen (Lua comes to mind) mention that you should strdup the string if you want to continue using it later as it could become invalid at any point, and the same applies here.
There is definitely an error in line 88: 1. In lines 77, 78 you have already read markers and file cursor has been moved 2 bytes forward, but in 88 you try to read whole structure and you will get wrong data. 2. You try to read wrong amount of bytes (variable 'file' is FILEHEADER type, but you read sizeof(INFOHEADER) bytes) If you try to read whole structure from a file, you need to pack bytes in structure. Here is my example. It is in C++, but it shouldn't be a problem: [http://pastebin.com/1tTEEYb1](http://pastebin.com/1tTEEYb1)
Yeah, originally i had it like this- http://pastebin.com/EYvWLuSr but i got off values for width and height, so a friend said to write that which didn't seem right, unfortunately i can't read c++, it looks very foreign to me, can you explain how to do line 92/93 correctly? (in this linked one)
1. In 92/93 you're passing wrong size to fread function: height and width are int, but you pass sizeof(INFOHEADER). Here is [fread doc](http://www.cplusplus.com/reference/clibrary/cstdio/fread/). 2. You need to read all the data **in the certain order** defined in BMP specification, but you try to read image dimensions after file markers. And take a look at my code, it's quite simple to understand.
I know I've written code to do this more than once, but can't find any of it. From memory, basically you have BITMAPFILEHEADER, a BITMAPINFO block, then an array of bytes. The second isn't always the same size (depends on type of bitmap, you get that info from the first block). Look at the references (some linked at the bottom). Use the standard field names, if only so you can google better for problems. It isn't clear how much you're doing with the image other than getting information, but it would likely be easiest (not necessarily efficient) to just load the entire file into memory to begin with. You can do this basic C binary file operations (though a mmap would be more elegant). Then you just have the file as an array of bytes and you don't have confuse yourself with file i/o and file format. Looking a little at your code, it may be helpful to dump the header structures in a readable format for debugging to make sure you getting sensible information for them. For copying the pixels, basic idea (avoiding structure, passing array for simplicity): int number_of pixels; //(height*width, set before hand //RGB that you have loaded uint8_t red[number_of_pixels]; uint8_t blue[number_of_pixels]; uintt8_t green[number_of_pixels]; //create BGR arrays: uint8_t b_bgr[] = malloc(number_of_pixels * sizeof(uint8_t)); uint8_t g_bgr[] = malloc(number_of_pixels * sizeof(uint8_t)); uint8_t r_bgr[] = malloc(number_of_pixels * sizeof(uint8_t)); //assume you have functions convert_b_bgr(uint8_t r, uint8_t b, uint8_t g) for each BGR that return the converted version int i; for(i=0; i &lt; number_of_pixels; i++) { b_bgr[i] = convert_b_bgr(red[i],blue[i],green[i]); g_bgr[i] = convert_g_bgr(red[i],blue[i],green[i]); r_bgr[i] = convert_r_bgr(red[i],blue[i],green[i]); } A little searching around, popped up some useful links (from wikipedia, stackoverflow mainly): [A selection of BMP files of different types for test](http://vaxa.wvnet.edu/vmswww/bmp.html) [Nice article from Dr. Dobb's that lays out all the data structure in C, explains them, and gives you the prototypes for the routines you'll likely need](http://www.drdobbs.com/architecture-and-design/the-bmp-file-format-part-1/184409517) [Microsoft's Reference on BMP, if you really get desperate] (http://msdn.microsoft.com/en-us/library/dd183386%28v=vs.85%29.aspx) 
There are two big portability issues with the code you have. To get portability across different endiannesses, you shouldn't read directly into an int, you should read an array of bytes and then pack those bytes into an int using bitshifts. Also, since the fields in the header have fixed width, you should use fixed width integers in `stdint.h` like `int32_t` instead of things like int or short which are different sizes on different platforms.
Good comments all, but .. what's wrong with camelCase? I was a Java developer for years and that was standard at the time. It also helps reduce the length of variable names. 
Good comment on the &lt;stdint.h&gt; usage. As for the endian stuff, in C you can read data into a structure with fixed width types and proper manual alignment and padding regardless of endian and byte swap the individual fields. While using horrible naming conventions and misusing types, the likes of ntohs, ntohl, etc... from the socket world are examples of this. Some architectures including the x86 can byte swap a 32-bit word with one instruction. I've seen far too much code where these endian transforms are written out longhand for each use and it's a huge waste in every sense.
You can do that, but it relies on detecting endianness. If you do it with bitshifts it will work on any platform, even the really weird ones that aren't big or little endian. A good compiler can optimize away the bitshifting into byteswap instructions on platforms that support it. &gt; I've seen far too much code where these endian transforms are written out longhand for each use and it's a huge waste in every sense. That doesn't have anything to do with how you're correcting for endianness. Obviously, with either method, you only do it at serialization and deserialization.
mostly a C de facto standard
Are you in UOW by any chance? The assignment sounds exactly like the one we're doing in CSCI192 right now. I'm doing private tutoring for 15$ per hour, let me know if you're interested. Do note that I will help you out with questions/explain concepts and give you guidance, but will not write your assignment for you.
Been brushing up on C myself the last few months using the K&amp;R book, and I see they just use run on var names, no underscores or camelCase. This approach in my opinion just seems to make variable names a little harder to read, with the camelCase easier on the eyes. But hey - if it's convention then so be it. Sticking to convention for the sake of it and refusing to change is a bit dogmatic when it could be evolving.
What the hell is going on with Dr Dobbs? Why does it start by screaming at me, and why is half of it underlined?
Indeed, camelCase and Java go hand in hand. I'd never consider writing Java in anything else **other** than camelCase. C# uses its own MethodNameStyle (which I abhor, but stick to when writing C#). C tends to always fall in the all-lowercase with underscores territory. Usually. Perfect examples: C code for git, apr-*, httpd, Linux kernel, any BSD kernel, ZFS, almost all UNIX userland code, etc. Stick with the language convention.
It was written in '95. Perhaps a few changes to the formatting/layout code just messed up older articles.
&gt;helps reduce the length of variable names Why does the length of variable names matter?
Yeah, i go UoW, sorry for the down votes, i managed to fix my errors, i didn't include pragma pack into the structures, as for reading the colours, used a fseek statement, read the values from imagedataoffset onwards into a buffer, wrote an algorithm to seperate the values from a buffer into 3 arrays, implemented counters, divided each array by its counters and got it working right. I'll update my final code after submission closes for others, i'll PM you if i ever need help though, thanks.
My opinions, after sprinting trough the example pdf: * There is no short description of the pattern, which helps the reader to find the right pattern for his situation. * Why should I use this pattern? * When should I use this pattern? * Are their alternatives who are better in situation X? * Author seems to repeat itself often.
(x&gt;&gt;31) + !(x&gt;&gt;31)*(!!x)
Different redditor posted this on /r/tinycode...?
(x&gt;&gt;31) | (!!x) implementation defined though, depends on sign extension and 2s compliment but that is usually the case. Works for GCC. The other solution also assumes this. edit: i would like to know why the downvote, is this incorrect? Edit 2: op *,+,! Are not bitwise operators are you sure they can be used?
Is this an intellectual exercise, or a real life problem?
Logical not. 
Good point. For future readers: My post asked something about whether or not ! was a logical or bitwise not but then I remembered that ~ is bitwise not.
signed negatives start with a 1 right? Wouldn't a right shift just fill in another 1 on the MSB? So wouldn't you technically be able to check after right shift if MSB = 1 =&gt; negative, MSB=0 &amp;&amp; exists bits != 0 =&gt; positive otherwise zero? Or am I wrong in thinking this representation is universal? 
Forget about anything having to do with code for a moment. You need to be able to explain in words (or possibly pseudocode) what each of those programs would do. If you can't do that, you shouldn't even be thinking about things like `#include &lt;stdio.h&gt;`. 
I don't think its possible to negate a 2s complement integer using only bitwise operators (the real set, not the one in the question). And I'm certain this problem is not possible using only a single reference to X. All in all, a very good question. Change it to allow only bitwise operators and so far I haven't seen an answer for it.
Thinking about it I guess it makes sense you can't create one for reading. I'm still kinda new to file reading/writing in C, I just had done something similar for school.
Check out this StackOverflow: http://stackoverflow.com/questions/2950931/for-vs-while-in-c-programming
This is one reason: the 'while' version increments in the body of the loop, whereas the 'for' version increments in the 'for'. Some argue that it's easy to lose the increment in the while version, and sometimes, worse, you accidentally 'continue' or something mid-body and you fail to increment, introducing a bug or an infinite loop. That can make a substantial difference in maintainability when you introduce STL with iterators and large loop bodies. 
&gt;and sometimes, worse, you accidentally 'continue' or something mid-body and you fail to increment, introducing a bug or an infinite loop. I've actually made that exact mistake.
They're sugar for the same underlying control construct so it doesn't matter from a correctness standpoint. The `for` loop is useful for more clearly presenting the most common looping pattern. Note that when taking advantage of variable declarations within C99's `for` loop initialization your code is much more concise than the equivalent `while` loop. for (int i = 0; i &lt; 10; i++) { ...; } Because `i` is limited to the scope of the loop *and* is accessible to the conditional statement, the equivalent `while` loop looks like this, { int i = 0; while (i &lt; 10) { ...; i++; } } 
Excellent, I need to explore C99 a little more thoroughly. 
This is demonstrably not true - everyone here is already reading it. 
But that's not my *real* code, just an example.
&gt; I just find &gt; while(*word) &gt; more readable than &gt; for( ; ( c=*word )!='\0' ; word++) That's cause it is more readable....BUT you could have written the conditional for the for loop to be identical to the while loop. for (; *word; word++) { h ^= ( (h &lt;&lt; 5) + *word + (h &gt;&gt; 2) ); } 
Fair enough, but sometimes the stranger who will be reading your code is the YOU of next year. I can't count the times I've thought "what the hell is this guy doing here?" only to realize I'd written the code a year or two before.
Basically, semantics. "for" is for when you wish to execute the loop for a specified number of iterations (whether hard-coded or determined at run-time). "while" is when you want to continue executing the code as long as a given condition remains true, and the specific number of iterations is irrelevant. While obviously either can be expressed in terms of the other, and in many cases (given a sufficiently capable optimizer) they will compile to the same result, using one rather than the other in a given situation can help better express your intentions and reasoning to someone reading your code.
team_t somefunc()? and do you really need to pass it an array of structures? Why not one structure and just iterate the func?
Depending upon the size of the struct, whether its just one of the structs in the array, and what you want to do with the returned struc, you want to do either team_t your_function(team_t *league, size_t league_sz); or team_t *your_function(team_t *league, size_t league_sz); Since you have what is apparently a preprocessor value defined for the number of leagues, you could drop the league_sz parameter, of course. I prefer not to have that sort of value implicitly passed. For that matter, I tend not to use a preprocessor define for that purpose, either. Personally, I'd define the data structures a bit differently: struct team { ... }; struct league { size_t teams_len; struct team *teams; }; struct team your_function(struct league leagues); or struct team *your_function(struct league leagues); 
The book I have says you can do exactly what I did. Maybe it is outdated? 
Your book and your compiler please. Maybe you confused assignment and initialisation. It has to do with how you declare your variable. `char a[10] = "bar"` works just fine, as `a` will just be statically initialised. `char b[10]; b = "foo"` won't work because you're assigning a pointer to the `'f'` to `b` which simply won't work - the length of a string pointed to by `char *` is unknown and thus the compiler can't guarantee that your `char[10]` will stay a `char[10]`.
Are you sure you're not confusing initialization with assignment? This is perfectly fine: char foo[16] = "bar"; This is completely illegal: char foo[16]; foo = "bar"; 
That looks like C++ code (whats with the "new"?). You might want to use the POSIX regular expressions library ([docs](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/regex.h.html)). Example: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;regex.h&gt; int main() { int err; regex_t regex; regmatch_t matches[2]; char input[] = "URL='www.google.com'"; err = regcomp(&amp;regex, "'\\(.*\\)'", 0); if (err) { printf("error compiling regex!\n"); return 1; } err = regexec(&amp;regex, input, 2, matches, 0); if (!err) { /* print eo-so bytes of input starting at so */ printf("match: |%.*s|\n", matches[1].rm_eo - matches[1].rm_so, input + matches[1].rm_so); } regfree(&amp;regex); return 0; } Edit: Thanks to skeeto (below) for spotting a bug with strncpy! It's now fixed above.
Cool, thank you. I will look into this some more.
Well, it looks quite a bit more like that than the actual regexp.h API, anyway. It is probably from something else I am not familiar with (Java?). My point was, it's clearly not derived from any examples or documentation of the actual API being included whatsoever, and I am morbidly curious how this, ahem, "code" came to be.
Aren't you relying on `match_text` being initialized with 0's? Or is there a guarantee I'm unaware of? 
You're copying right out of `input` stopping before the second quote, so your source string is providing no null terminator. According to the `strncpy()` man page, &gt; If there is no null byte among the first `n` bytes of `src`, the string placed in `dest` will not be null-terminated. I can confirm this by intentionally putting garbage in `match_text` and seeing the printout overflow. 
You're absolutely right! Thanks for setting me straight (-: It's fixed above.
I complete agree it looks nothing like the regexp.h code. Java might actually be a good guess, or maybe something like C# or .Net (I don't know either so I'm just guessing). Then again, I think Java's RegExp library is different and humorously limited in comparison to regexp.h
Well done. Lucky guess on my part.
Essentially, yes. Each operating system will have a different way of conveying the environment to a newly created process. `main()` is not the actual entry point of the process. The libc and/or compiler startup support routines run before `main()` and receive that information, making it available to `getenv()` and other functions. On some systems the environment is exposed through a global variable (`extern char **environ`, or possibly with an underscore) and `getenv()` just accesses that to look for the desired value, but this is not a requirement. 
I think env is just some data bind with each process.
I think in most UNIX-y OS's its located in the Group Descriptor block if you really wanted to dig it out.
This is also available on the Microsoft platform with the Visual Studio compiler, but definitely non-standard.
But with `getenv()` you can't examine all the environment variables, only the ones you know the key for.
On UNIX-y systems, there is a symbol called 'environ' in the C library which is a NULL-terminated list of them. Where _that_ comes from is very, very system specific and is best left to the C library and kernel talking to each other. See, e.g., http://www.opensource.apple.com/source/shell_cmds/shell_cmds-170/env/env.c
Cool, I never got around to the application interface in OS design back in college. I never quite understood how the control was handed from OS into subprocess. I assumed there was some form of function call embedded in the C library that took a pointer to the programs main and did a few magic things but never got much further.
Thank you. So newp and oldp are local only to the function in the file coordtrans.c? And they will still modify the things which are at the addresses of the global variables in the structure array[N] and array_old[N]?
The compiler option you're probably looking for is `-I`. 
except I have to refer to specific elements of the array of structures array[i]. For example: Say I choose particle 300 with index i, I need to be able to edit sw[3], i.e. sw[0], sw[1] and sw[2] that belong to only that particle i. Like newp[i]-&gt;sw[0]= some value; But this doesn't work.
Pass &amp;(array[300]) to your function. Then newp is a pointer to that element. You don't need to reference an index in it? Or am I misunderstanding? (On my phone, so that is possible)
Error using gcc In file included from swsm.c:5:0: coordtrans.h:1:33: error: unknown type name particle coordtrans.h:1:50: error: unknown type name particle swsm.c: In function volume_move: swsm.c:114:2: error: implicit declaration of function coordtrans [-Werror=implicit-function-declaration] cc1: all warnings being treated as errors make: *** [swsm.o] Error 1
ok. move your struct particle def to a h file so that more of your code files "know about" the struct. keep the array and arrayold instances where they are. you can change their declarations to just: #define MAXPARTICLES 1000 struct particle array[MAXPARTICLES], array_old[MAXPARTICLES]; /* two arrays of structures */ your main functioN: int ip; _Bool reset = 0; for (ip=0;ip&lt;N;ip++) { coordtrans(N, ip, &amp;(array[N]), &amp;(array_old[N]), Lbox, Lbox_old, reset); } in coordtrans.h double coordtrans(int N, int i, struct particle *newp, struct particle *oldp, long double Lbox, long double Lbox_old, _Bool reset); in coordtrans.c double coordtrans(int N, int i, struct particle *newp, struct particle *oldp, long double Lbox, long double Lbox_old, _Bool reset) { if (!reset){ oldp-&gt;sw[0] = newp-&gt;sw[0]; oldp-&gt;sw[1] = newp-&gt;sw[1]; oldp-&gt;sw[2] = newp-&gt;sw[2]; newp-&gt;sw[0] = newp-&gt;sw[0]*Lbox/Lbox_old; newp-&gt;sw[1] = newp-&gt;sw[1]*Lbox/Lbox_old; newp-&gt;sw[2] = newp-&gt;sw[2]*Lbox/Lbox_old; } if (reset){ newp-&gt;sw[0] = oldp-&gt;sw[0]; newp-&gt;sw[1] = oldp-&gt;sw[1]; newp-&gt;sw[2] = oldp-&gt;sw[2]; } } 
That's a build issue with make. I don't know how your build environment is set up. You could probably resolve it with a hack by making an empty partstruct.c file.
I got rid of the .o reference in OBJS, I now get an error: swsm.c:(.text+0x34f): undefined reference to `coordtrans' I am calling coordtrans like this: coordtrans(N, ip, &amp;(array[N]), &amp;(array_old[N]), Lbox, Lbox_old, reset);
Thanks for replying. This is what I'm looking for. A few follow up questions to this, if I may, 1&gt; How does the compiler know it has to look for the definitions in foo.c and bar.c? 2&gt; Does api.h, foo.c and bar.c have to be compiled and converted to object file before use in main.c? 3&gt; Is there any change in this procedure if I have an api.c instead of foo and bar? I'm assuming when using foo and bar you need to specify to the compiler to look in those files, so if you have a header and source with the same name, can I get away with skipping that?
Just the prototypes.
Okay. As Nimbal pointed out the definitions can go into another file(s). 1&gt; So when I include api.h in main.c how does the compiler know where to look for the definitions? Do I have to specify it explicitly? 2&gt; If I do have to mention it to the compiler, is it because the source isn't titles api.c? In other words, does the compiler automatically look for api.c when it encounters api.h? Can I get away with not mentioning the source files explicitly in this case? 3&gt; To confirm what you said in your very first reply, the header file and its source don't have to be compiled before it can be used, right?
I'll probably have to read it a couple more times to digest all of this but I think you answered all my questions, thank you.
&gt; So when I include api.h in main.c how does the compiler know where to look for the definitions? Do I have to specify it explicitly? Erm... you specify the location explicitly after the \#include, in quotes (**Edit:** or angle brackets depending on whether you want the current directory to be in the search path). I may have misunderstood your question here. &gt; If I do have to mention it to the compiler, is it because the source isn't titles api.c? In other words, does the compiler automatically look for api.c when it encounters api.h? No the compiler doesn't even see api.h. The pre-processor replaces the \#include "api.h" with the contents of api.h. As far as the compiler is concerned it only ever sees one file: the output from the pre-processor. You keep seeming to miss the point: \#include is literally only concerned with text-processing. The pre-processor sees \#include "api.h" and literally just cut-and-pastes the file contents there. That is it. Just that. No 'does the compiler automatically...', no 'will it then do...'. The text just gets pasted there. Like if you selected the contents of api.h, hit Ctrl-C, selected \#include "api.h" and hit Ctrl-V and saved the file. Just that. Nothing more. OK? &gt; To confirm what you said in your very first reply, the header file and its source don't have to be compiled before it can be used, right? The use of a header file is different to the use of 'its source'. The latter does need to be compiled because its 'use' is the compiled functions within it. The former does also need to be compiled but only in so much as every translation unit which is going to call a function should have an explicit prototype for it. More correctly, the header file is intended to be compiled as part of every .c file which will use the functions. The 'header source file' as you call it is compiled once and contains the *implementation* of the functions. **Edit:** and again, to be explicit, you can literally copy-and-paste the header files where the \#include is and then delete them from the disk. The program will still compile. The entire point of header files is just to stop you hvaing to repeat yourself everywhere.
The answer to the question I was asking was more or less what is contained in the last paragraph of your reply (before the edit). The rest of it was not a problem I had. Maybe it was the way I wrote it that it wasn't clear, I don't know. But that is what I was asking. Thank you for your time and patience.
&gt;Maybe it was the way I wrote it that it wasn't clear, I don't know. But that is what I was asking. Thank you for your time and patience. I think it was just an over abundance of caution that you understood. Header files are an area which are notoriously misunderstood. They date from a simpler time when compilers were less smart and so nowadays it's quite hard to believe that the C compiler is, in some ways, so dumb.
Much more clearer, thank you again. No more questions. :D
haha, I'm new! :(
int main ( ) { int grade = 0; int totalGrade = 0; double average = 0; int count = 0; do { count += 1; cout&lt;&lt;"Please enter grades. Type -1 when finished."&lt;&lt;endl; cin &gt;&gt; grade; if (grade == -1) break; if (grade &lt; -1 || grade &gt; 100) {totalGrade = totalGrade - grade; count -= count; cout &lt;&lt; "You have entered an invalid number."; } totalGrade += grade; } while (count != -1); average = totalGrade / count; cout&lt;&lt;average; system("pause"); return 0; } 
You're incrementing 'count' too early -- wait until you've verified the grade is valid. Otherwise, when you exit the loop, 'count' is one higher than it should be and will give an incorrect value to 'average'.
I redid my code, and now im back to getting weird numbers, it works, until i put in an incorrect number such as 101 or -4, then its way off. :-( #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int main ( ) { int grade = 0; double totalGrade = 0; double average = 0; int count = 0; do{ cout&lt;&lt;"Please enter grades. Type -1 when finished."&lt;&lt;endl; cin &gt;&gt; grade; if (grade == -1) {break;} else if (grade &lt; -1) {cout &lt;&lt;"You have entered an incorrect number";} else if (grade &gt;100) {cout &lt;&lt;"You have entered an incorrect number";} else {totalGrade += grade; count += 1;} }while (count != -1); average = totalGrade / count; cout&lt;&lt;average; system("pause"); return 0; } 
count -= count; is really just a slightly obfuscated way of saying count = 0; Kind of reminds me of x86 assembly language, where we would xor a register with itself to zero it (it was faster than copying a 0 from memory) Also, your code is actually C++, not C.
Are you using something that has a debugger? That would be a useful skill to learn in general. Linux has "gdb", Visual Studio has a "start with debugging" or some such. Basically, you would put a "breakpoint" at the start of your function (or wherever you want to pause) so that you can look at the values that your variables have at that time. While it's running, but paused. And from then you can do "next" to advance through your code roughly one statement at a time. And by looking at the values of variables (in gdb, for example: "print count", figure out where it's doing something different from what you intended.
you should probably show your compiler errors. as someone has already mentioned the fact that you you're using the keyword 'new' raises some redflags. you're apparently trying to use the glibc regex library....but you're just not using it. my recommendation: 'man regex'
i'll try that. thank you!! also - can you please explain your username??
it worked!! thank you very much!!
Thanks for the reply! But there is no file called partstruct.c therefore no need to include a dummy .c file, it was sufficient to use an .h file so that, in the words above, more of my program 'knows about' the structure.
What do you mean by "off lattice networks"? http://www.ocf.berkeley.edu/~fricke/projects/hoshenkopelman/hoshenkopelman.html https://gist.github.com/909424
Ooh, nice. I'd been looking around recently for some coherent stuff that goes beyond the days of K&amp;R, seems like this is it.
BTW, from-the-C-books-that-aren't-K&amp;R there's also "Learn C The Hard Way" -- http://c.learncodethehardway.org/book/ -- although it seems more like an intro book and so it hasn't been a priority for me to acquaint myself with this one, given the always too limited spare time :[ (so can't comment on the upsides/downsides).
Since we're dropping names now, I was quite satisfied with King's [C Programming, A Modern Approach](http://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504/ref=la_B000APEOAW_1_1?ie=UTF8&amp;qid=1352550025&amp;sr=1-1). Comprehensive, also with regard to c99 (but unfortunately no new edition to cover c11 yet).
I'm frustrated that this is still unfinished - the Virtual Machine part (and onward) has been blank for months. 
Very good book indeed. Very readable yet very comprehensive. Also covers C99 and C99 features are clearly marked as such. The exercises are also good.
 printf("%s", &amp;array[i]);
Correct me if I am wrong, but I don't believe this is safe: for(i = 0; b[i] != NULL; i++){ printf("%s\n", b[i]); } b[i] just crunches down to an offset in memory. What if the byte right after the array contains garbage rather than NULL?
If each element in the array is a pointer to type character, which it is, then yes. Otherwise, if you had instead declared char b[5]; An assignment like b[0] = "one"; wouldn't make any sense at all.
yeap, you are right.
http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298
Embedded programming. When you have to write device drivers on bare metal then you quickly get used to pointers. Just grab a cheap microcontroller board from a chip vendor (like, TI that sells some for $5) and try to blink an LED with I/O and a timer.
This was the same for me. I'd programmed in C without really understanding pointers. Then when I started working with assembly languages, it all hit home. Specifically, it was the different types of addressing modes that drove it home. 
I understood them pretty much right away, but I had written a fair amount of assembly in the years before I picked up C. &gt; However, whenever I write code, I can't use them without either just testing three cases, &amp;, *, or just the variable. Same goes when using structs, to use -&gt; or ".". So do you not understand the syntax? When looking at "&amp;" vs "*", it's really just a matter of thinking about whether you want to reference or dereference a variable. With "-&gt;" or "." it's about whether you want to "follow" the variable to the contained address or not.
I'm guessing a few weeks to a month or two. Do some embedded work with a small stack and you'll be forced to learn pointers fast.
I wrote assembly programs and that's how I got used to pointers.
When I took an graduate operating systems class for the first time, and had to write a ton of C-code. In that class they just assumed you knew C, and there wasn't any hand holding on it. Similarly, algebra became second nature for me I took calculus, and doing complicated algebraic manipulations was the "easy first step". What can you absorb from this? Just write a lot of C code, it will sink in and become effortless soon enough
I think you and many people might be extra confused thanks to C++ and references (the &amp; used in arguments). If you use simple C it is clear: - variable - value of variable - &amp;variable - address in the memory where variable is stored - *variable - value under the address in the variable variable-&gt;element is just a syntactic sugar for (*variable).element 
The problem is something with where i declare the pointer and set it equal to array 
There's a big difference between forming a hypothesis and writing a testcase to confirm or deny it and randomly trying things until something seems to work. The former is a very good exercise, the latter not so much. 
I do want to state, that yes, this is one of the problems. I believe this is why I actually like C more than C++, and some how I understand C a bit more syntax wise. Didn't know this was the case though. Thanks for some clarification.
C++ tried to make things simpler, but I too do think it actually makes it harder to understand for new programmers. What &amp;argument in C++ is simply passing object by a reference. It is very similar to how newer programming languages like Java do this. To explain it better, imagine you have a single program in C that simply increases value of a variable. This is only an example, if possible, avoid coding this way, because it makes your code more confusing: // Take pointer to a variable, and increase variable's value void incr(int *obj) { (*obj)++; } void main() { int a = 1; incr(&amp;a); // it should return a = 2 printf("a = %d\n", a); } In C++ you can make it a bit nicer looking by using references instead of pointers: // Take a reference to a variable, and increase variable's value void incr(int &amp;obj) { obj++; } void main() { int a = 1; incr(a); // it should return a = 2 printf("a = %d\n", a); } So simply, it allows you to pass the same exact object/variable without having to use pointers. You no longer need to use * in front of variable to access its value, but you lose some flexibility that pointers give you. For example a reference cannot be NULL if I remember correctly. Using &amp; (reference) in many cases can make code a little bit cleaner (otherwise no one would use it), but it can get more confusing to new programmers, because &amp; in front of an argument has a completely different meaning that &amp; used in front of a variable. 
If you're not thinking about pointers when you're using them you're doing it wrong and your code is going to blow up and/or have bad security holes.
I feel people get confused because you can write (and c/c++ will allow you to do): int *integer_pointer; or int* integer_pointer; Which while being the same symbol in some ways means something different.
&gt;In those two cases they're exactly the same thing and mean exactly the same thing :) Yeah, I know they're the same thing, but if you looked at them you would think they might not be. One is putting the * with the type, but the other is putting the * with the variable name -- semantically it's confusing, and gets further confusing when you got to the next part which was what I was hinting at: //declare int* integer_pointer; //use *integer_pointer = blah; Is what I meant. However I think it would be handled more neatly if c/c++ didn't allow int *integer_pointer; As the * is really a modifier to the type in this case. But when you have int *integer_pointer; then *integer_pointer = 2339; There are definitely two meanings which helps further complicate the issue.
 scanf("%d", &amp;binary); This. You are reading base-2 number as base-10 (%d). Read as a string (fgets()), then parse. Your alghorithm doesn't look right, though.
For me it was when I started paying attention (*really* paying attention) to the types of expressions in my programs. Each of the operators is basically a function, and therefore has a type. *: (T*) -&gt; T &amp;amp;: T -&gt; (T*) (Here `T` is any type, including pointer types.) Dealing with pointers now becomes a matter of knowing which type you need. The `*` operator removes a level of indirection (it dereferences) and the `&amp;amp;` operator adds a level of indirection (it references). Now you can treat pointers as opaque types; they're just objects that exist, and you can use those operators on them to turn them into other objects. You should always be aware of types when writing C code, because it's a quick mental check to see if your code makes sense. The `-&gt;` operator is, as stated in other comments, simple syntactic sugar. The expressions `p-&gt;x` and `(*p).x` are equivalent. So you should use `-&gt;` when you have a *pointer to* a struct object, and `.` (dot) when you have a proper struct object. The only trick is when declaring a pointer. You only ever use `*` for this, never `&amp;amp;`. When you declare a pointer as: int *p; you are saying that, when you dereference `p`, you get something that is an `int`. So `p` is a *pointer to* an `int`. That's why the `*` is used in declarations to add levels of indirection -- in C, declaration mimics usage.
The problem clearly states you should take an integer containing only 1s and 0s, though.
http://developer.gnome.org/gnome-devel-demos/unstable/c.html.en
Try `inttypes.h`, it gives you the type `int64_t` that will be able to hold such a long value. 
I've done quite a bit with SDL in the past, but I would say its more graphics oriented than traditional "GUI" oriented. It's great if you want to draw, but doesn't really provide buttons and other completed GUI elements like gnome does.
QT is only for C++ not C
http://www.winprog.org/tutorial/
Oh so since you CANT divide 5/11 you get the hole 5 as remainder? I thought it would be divided and THEN the remainder will be shown, like in: 11/5 where 5 gets divide by 10 and 1 is the remainder. 
Your method of counting is wrong. You need to increment each counter variable by one, not by x. Also, since you never seed the generator, this will always produce the same sequence. Functions like `rand()` are pseudo-random number generators. Given a seed value, they always return the same sequence. There is nothing even remotely random about it, it's 100% deterministic. There *are* ways of getting true randomness, both by utilizing specialized hardware and by gathering randomness by measuring external processes like interrupt latencies and other stochastic processes. But that's far beyond the scope of `rand()`, which is a modest [linear congruential generator](http://en.wikipedia.org/wiki/Linear_congruential_generator) with a very simple algorithm. When you need higher quality randomness, you need to turn elsewhere. 
As Rhomboid said, you're adding x to the count, massively biasing towards higher numbers - exactly the distribution you're seeing. Once you fix that, note that 6 cannot exactly divide 2^n (by the fundamental theorem of arithmetic), so there will be a bias on the lower 2^32 %6 =4 numbers (1-4 in your version). To avoid this bias, make the modulus a power of 2. And a note on style: use arrays. int i; int modulus = 8; int count[modulus]; memset(count, 0, sizeof(count)); for (i = 1; i &lt;= 100000000; i ++) { int x = (rand() % modulus); count[x]++; } for (i = 0; i &lt; modulus; ++i) { printf("%i: %i\n", i, count[i]); }
yes sir, I finally figure out what I did wrong as well. I'm actually glad that you replied before I had to chance to correct myself here because what you're telling me is something new. Funny how you mention: &gt; Given a seed value, they always return the same sequence. Because the next page in the book states, "To show that these numbers occur approximately with equal likelihood, lets simulate 6000 rolls of a die with the program of Fig. 5.8. Each integer from 1 to 6 should appear approximately 1000 times." I interpret that as predictable randomness, a contradictory. Hence, 100% deterministic. From the link you gave, I still have a lot to learn and a long way to go... 
Thanks for this new info as well. Honestly: &gt; note that 6 cannot exactly divide 2n (by the fundamental theorem of arithmetic), so there will be a bias on the lower (232)%6 =4 numbers (1-4 in your version). To avoid this bias, make the modulus a power of 2. that went over my head. I still have a lot to learn. Ya I know array would be great but the book didn't cover that subject yet. I have the bases of array's fundamental down but I choose to stick with what the book have shown so far up to whatever program problem the book present. I really want to grasp the concept of C down and to learn the in's and out's. Thanks you for your reply.
Yeah, try reading the sentence that follows the one you quoted. &gt; That's a bit of a fudge - [s]he's actually talking about size within size The germane point was to bring into focus that sub-ranges don't always fit ranges, so I gave him an intuitive example with background he'd have experience in. You gave him an "explanation" that most people who already knew the thing you were talking about wouldn't be able to follow, mostly due to phrasing and approach, so I fixed it. But don't worry, after you threw an example out there that the guy couldn't understand, and someone else explained it for you, explaining it to the person who filled in for you, and ignoring the signal sentence they put in **for the sole reason of saving you this response** will make you feel better. Maybe if you had given that explanation to the other guy, etc.
Anyway, here are the real take-aways here. 1) The next time you think there's a bug in the language, just remember: if there was a bug that simple, someone else would already have found it. 2) Same goes for the compiler, except even moreso. (Unless you're using some weird niche compiler, at which point this becomes a very valid concern.) 3) And oh boy, is this the rule for the computer itself. Separately and distinctly, though this here had nothing to do with it, you are by coincidence correct that no current style computer will ever generate truly random numbers. Pretty much no matter what, what a current style computer does has to be based on math, and math doesn't have a randomness source. 'Course, a computer can act on randomness that it receives from the outside; witness things like LavaRand. But maybe more important is how close a computer can *get* to true randomness, and the answer is "closer than you even begin to care about." We can get close enough to true random to support large scale simulations, gambling machines, et cetera; the likelihood that that won't be good enough for you is vanishingly small. But yes, they're strictly called "pseudo-random number generators" for exactly this reason, and the reason people get all weird about testing random number generators (boy have we gone past chi square tests) is to find out how close to truly random any given PRNG gets. This is also why the Mersenne Twister people say things like "random in 623 dimensions" - if you have a randomizer that needs to be random along more than that many axes, then MT begins to be a bad choice (and what are you even building?) But, seriously, there's a lot of more practical problems. Like, for example, C doesn't define what random number generator is in use, so, if you compile your app on two different machines, you're going to see two different degrees of randomness (though this test won't be able to see the difference.) Look, if you're doing gambling, if you're doing simulations, worry about this. If you're learning how things work, worry about this. If you're making a shooting game? The hell with it; nobody's going to notice if the enemies go north a half a percent more often than south.
I did not miss your point. What I wrote to you was "yes, the thing you said to me was already in the message you were responding to." You missed mine, honey. And you got the math wrong in so doing. Just because you can't admit you're wrong, etc. Have a nice day.
Yes, keep arguing with a sentence that was taken out of context, when the very previous sentence explains why that's a fudge. It's not like I just explained this to you in private, to help you save face, or anything. &gt; Point me to where I'm wrong. Already did, but &gt; &gt; &gt; &gt; That's a bit of a fudge - [s]he's actually talking about size within size Please find something better to do with your time. After the cursing fit you had in private, I don't really want to be asked to explain to you what you misunderstand, in order to get the privilege of you stopping arguing with me and announcing that my point was something other than what I think it was. I'm sure there's another thread you can go enjoy politely somewhere.
If you thought about it even a tiny bit, you'd realize that what you're trying to chastize me over can very easily, given your own example of dungeons and dragons dice, be referred to as "size within size." If you had read what I wrote to you in private to let you save face, you'd know that I've already explained that phrase. . &gt; Can you explain what 'size within size' is, please? I already did. Twice. You aren't reading what I have to say to you, so I have nothing else to say to you. I've asked you now repeatedly to find something better to do with your time.
Please find something better to do with your time than to repeatedly ask a question to someone who is saying "I am not going to answer you after your temper tantrum."
You're right, you don't understand what you're missing. If you are actually genuinely sorry, please stop bothering me now. But I confess I don't believe that you are.
I did not have a tantrum. I responded to your insulting message in what I thought was an appropriate way, although I did want to learn more, by asking what I had apparently missed that caused your tantrum. I now realise that you are just a troll.
Please stop bothering me. You are escalating. I don't know why you keep swearing at me, making insults and personal attacks, then complaining about how rude I am. All you're doing is repeating the factually based criticisms made to you back to the speaker. You accused me of being a gender bigot. If you think that's appropriate, in response to "I don't think this was a good explanation of code," then I just don't know what to say. Go away now please. That's all I've said to you for your last 11 contacts, 5 in public, 6 in private. Find someone else to talk to.
Horrible code, nobody in their right mind would write this stuff, but as an exercise I'm sure it's instructive. I'll work through it for you: First of all, let's parse the offending line: a-=--a-a--; is the same as a -= --a - a--; Ah. You *instantly* have undefined behaviour, there's really little more you can properly understand. Let me explain. In this statement `a` is modified three times (by `a -= ...`, by `--a`, and by `a--`) ... and the language quite specifically says that if you do this all bets are off, the compiler can do what the hell it pleases. I can't remember the precise rules, I expect someone else will pipe up. Actually, things are even worse. You're hoping that `--a - a--` would evaluate to zero, but as both sides of the subtraction modify `a` the result is again undefined. So in brief, don't do this!
Welcome to undefined behaviour. The C programming language doesn't define the order in which these get executed. The C compiler can choose any order. Firstly, you should understand pre and post decrement: printf("%d\n", --a); // decrements a and prints the new value. printf("%d\n", a--); // decrements a and prints the old value. Now, on to these horrible examples. All you need to know to write good C is never to do this. If you want to understand what's going on, however, I'll explain. This interpretation explains some what might be happening: int a=8; 1) a = 8 a -= --a - a--; 1) --a is 7 (call this x), a = 7 2) a-- is 7 (call this y), a = 6 3) x - y is 0 4) a -= 0 so a is still 6. Technically, the second decrement may happen after the "a -= 0". Externally, there's no way to tell. Your last example is more tricky. Looking at the assembly: Variable a is in [rbp-0x8] mov eax, [rbp-0x8] sub eax, 0x1 mov [rbp-0x8], eax ; a -= 1 mov [rbp-0x8], 0x0 ; a = 0 mov eax, [rbp-0x8] sub eax, 0x1 mov [rbp-0x8], eax ; a -= 1 It seems to be performing it as follows: 1) --a, the new value of a doesn't matter because of step 2 2) The value of the post-decrement will be "a", so we now perform a = a - a, or a = 0 3) now we perform the post-decrement: a--, so a = -1 It's important to understand that "undefined behaviour" means that these lines are meaningless: different compilers, different optimisation levels will change the behaviour drastically and unpredictably, so it should never be used in real C code, but it's good to understand.
Hmm, makes sense. But the same book says associativity for increment and decrement operators is from right to left, and not left to right like you just described. ^^^Why ^^^is ^^^this ^^^so ^^^hard? ^^^:(
Ah. Thanks for explaining that. So all depends upon the compiler that we are using.
Associativity determines how operators bind and how sub-expressions depend on each other ... but doesn't necessarily determine execution order. The compiler has free choice over execution order, for example: void f(void) { printf("f"); return 0; } void g(void) { printf("g"); return 0; } int test(void) { return f() + g(); } When you call `test()` you can see either `fg` or `gf` printed out, entirely at the choice of the compiler. The question of associativity deals with questions about where to put the brackets (or, to be more precise, how to construct the parse tree). So for instance: a - b - c parses as ((a - b) - c)
Thanks! I could, definitely - as it is pointer arithmetic is a bit of an afterthought, possibly because I haven't had to deal with it much yet myself. As for the book: I haven't, but that definitely sounds like one I'd like to read. 
It is well worth learning. If you understand pointer arithmetic, you definitely understand pointers and how they work with contiguous memory. The extra-credit bonus is to use pointer arithmetic to make a 1-d array into a 2-d array. (it is doable)
I mention that later, actually - but putting that in with a forward reference to the relevant section might not be a terrible idea. Thanks!
It is absolutely undefined behavior. Any attempt to modify the same variable more than once in the same sequence point is undefined behavior. 
I havent gotten past the first page yet, but your footnote on page 1 is not something that should be in document thats supposed to make something simple. Their are so many concepts in there that anyone looking for help on pointers wont have any clue what you are talking about :)
This is really nice! I'll have to keep a link to your repo so I can send it to people if and when they start getting into C and C++.
What, not `&lt;stdbool.h&gt;`?
Holy crap you could do this for a living. Really clear and to the point(er).
You kinda dive right in there, in 2.1, and just gloss over some important principles. I think you're assuming that the reader knows what things like memory is, variables are, addresses are, etc. It wouldn't hurt to start with the basics, and build on it step by step. What is computer memory? What are addresses? What are variables? How are variables stored in memory? What is a pointer? Why are pointers important? What are structs? What are pointers to structs? What are arrays? What are pointers to arrays? What is the stack? What is the heap? Pointers to pointers. I also think that you're far too conversational about it. Too many rhetorical questions. One or two is cute. More than that is annoying. I feel kind of a dick for basically trashing everything you wrote, but .. you asked for feedback. As someone who has been consuming technical documentation for years (and writing it), I feel it's important to a) assume nothing about the reader's knowledge of the subject if you're covering a basic topic. b) be direct and to the point - too much fluff can make a reader skip important things because it appears you've not written anything important. c) build on a basic principle with the next.
Don't worry! I did ask for feedback, and this is exactly what I hoped for. Praise is neat, but in the end constructive criticism is way more useful. Thanks :) I have some limited background in education, but it's been a year and a half since I bothered to write anything remotely like this. While I don't want to assume *nothing* - this isn't a C intro - I did forget to make my assumptions of pre-existing knowledge explicit to myself, which is pretty essential. As for the tone - I'm inclined to disagree, but I'm not a native speaker of the language and most of my experience with English is essentially conversation, so I may concede that. I could definitely cut down on the fluff a little. I'll probably end up rewriting or at the very least restructuring much of this, especially when I want to add in more basics.
Thanks, good catch :)
It kind of needs to be broken up into two separate parts. Theory and practical application. The problem you have is you're dealing with actually a low level topic, and people who don't understand pointers, probably just read several C intro's and didn't understand those either. People are really good at copying what you do without truly understanding what's going on under the hood, but then when something doesn't work, they're frustrated. Other comments; please use int *foo; not int * foo; Nobody really writes it like that. Yeah, I know, it's not really that sensible, but pretty much all the C code I've read over the past 20 years uses the former for pointer declarations. Please use %p for printing pointers. Maybe go over hexadecimal notation. Printing the pointer in decimal is bad form; we don't want newbies leaning things the wrong way then relearning to use %p later on, right? I'd note that many libraries use typedef to hide pointers. I consider this bad form, myself, but it's a trap for the unwary. Some libraries helpfully tell you in documentation that typedef you're using is actually a pointer to a struct ... some don't. I personally think it's bad form to allocate and assign in the declaration. I personally feel you should always declare and assign to NULL, and only allocate when you need to. It's probably worth noting to the reader that it is not guaranteed that any memory allocated anywhere is likely to be initialized. You mention the heap, but the stack is the same. Most compilers will helpfully initialise variables on the stack to 0 when the code is not optimised, but then when you add optimisation flags, the code breaks because it's assuming the variables on the stack are initialised and they're not. Its funny. I've wrote a similar article, after I saw a post on reddit a few weeks ago about "ELI5, pointers", or something, then I just left it half finished. New shiny distracted me. Have fun ;)
^ This, ladies and gentleman, is how a true engineer comports himself when his work is criticized by a peer. Well done sir, I like the cut of your jib.
try 32.0/14.0.
32.0f/14.0f even.
It prints decimals, right? Only just zeroes instead of the right ones? The problem is that it's doing integer division and truncating the result. From _The C Programming Language_, page 12: &gt; If an arithmetic operator has integer operands, an integer operation is performed. If an arithmetic operator has one floating-point operand and one integer operand, however, the integer will be converted to floating point before the operation is done. I highly recommend picking up a copy :)
Thanks, I actually do have a copy but at the moment i'm reading C How to program. A lot of the material in The C Programming Language went over my head when I first started reading it without haven't much experiences in C programming. As of right now because I'm practicing C programming daily, the concepts are becoming more understandable to me.
That worked! New lesson learn, whenever doing any kind of calculation that need a decimal return always make sure to have at least .0 even if it's a whole number. 
Excellent, good luck!
 return ((f - 32.0) * (5/9)); Clue: what is (int) 5/9?
Thanks everyone for the help. reddit is awesome.
Good, good. Actually, I think there's a bigger lesson to be learnt here. Figure out how to do very simple debugging using printf statements. Use temporary variables if necessary, or just print each component of the return statement separately to see what's going on. You have two very small functions that are misbehaving  learning how to figure out what is going wrong will be extremely valuable going forward. Getting other people to tell you what's wrong is good, but being able to figure out what's wrong yourself is great :)
Thanks for the advice. I was debugging it by picking it apart piece by piece by I can't seem to figure out what's wrong, until the people of reddit including yourself point it out. I still have a lot to improved on debugging and a lot of learning of the basic syntax of C. Once I get the basic down then I can move on to the more complex stuff. I think it's about time for me to dive into the book, *The C Programming Language*
C does not have any native graphics datatypes, so you have to bring them in via a library. I *highly* recommend you find a library that's adequate and/or use loseless datatypes. One thing you might want to try is SDL since SDL can handle bitmaps natively and there's plenty of information on setting it up.
something i feel that most pointer literature misses is multiple indirect referencing. I FUCKing understand char \*argv[], but do people ever be on some int ******wtf type shit ? thanks
Hold on, that array is going to be statically allocated in the readonly .text section (for elf, the analogous for other formats), and a pointer to const char returned. That array is not going away for the life of the program. **There is no allocation.** This is the same as if the array had been declared as a static const int global. It may be the spec frowns on it, I don't know, but that is not actually dangerous in the instant code, although you should at least get warnings for returning a const int * as just an int *. Nothing is clobbering that area of memory, barring corruption from a different, actually unsafe piece of code.
But that would happen in any programming language?
No. Most modern* languages will check array bounds for you and not let you do that. But, there is a slight runtime penalty for the check on every access, which is probably why C doesn't do it. See [this wikipedia article for some info](http://en.wikipedia.org/wiki/Bounds_checking) * By modern, I mean most languages created since ~'90. Ex, Java, C#, Python, Ruby, etc. I know not all languages will do array bounds checking. But it is fairly common in many lanugages.
Maybe I misunderstood your point (or you, mine), but there will be some sort of error in any language if you try to access an index that is out of range. Sure, C will not return an exception, your code might produce an undefined behavior, but that is the whole point of C: to design code in a similar way the computer works. I don't use C daily for the same reasons you do, but saying you don't care for C is, in my opinion, not the right attitude. C has its uses even today and I also believe it's a good pedagogic language (not the first to learn, though).
I'd much rather the program generate an error, or exception, than to give a wrong result silently. That can cause some really hard to find bugs. Yes, C does have it's place, but that doesn't mean the language doesn't have some serious faults. Remember that it was designed over 40 years ago. We've learned a LOT about software development since then. There are more modern languages that have learned these lessons and still produce tight/fast code.
&gt; I'd much rather the program generate an error, or exception, than to give a wrong result silently. Of course, and so do I. And I completely agree with you that most of the time, a newer, more high-level language is a better solution than C. I don't want to give you the impression I think C is the best language around and that it should be used every time. But a language that survived through the ages and is still widely used cannot be as flawed as you pretend. My point is that C is excellent at what it does. I don't think it has serious faults (and I'm open to whatever you have to say), but it has pitfalls. As you do, I don't consider C an option when I write high level applications because I believe the performance (memory-wise and speed-wise) are not as important as readable code and abstractions. However, I will not dismiss C for everything and I will "care for it".
This conversation reminds me of http://c.learncodethehardway.org/book/learn-c-the-hard-waych55.html
&gt;Anything not malloc'd can't be used once you exit a function. You can return pointers to const string literals since they are pointers to the data segment. Aside from that, you are absolutely correct.
&gt;This is one of the reasons I don't care for C. It loads the gun, cocks the hammer and points it at your foot. Too easy to do the wrong thing. Actually, this is precisely what I love about C. It lets the programmer do whatever he damned well pleases, even if that means doing something stupid. It's like how with UNIX I can just open a terminal, type 8 characters, and erase every file on my computer. I just like to have the power to do whatever I want, whether or not it seems like a good idea.
Yes, it is unsafe to leave a large, inconsistent number of spaces around parentheses.
You wold appear to be correct sir, and I incorrect. I am chastened. I really should have taken 5 minutes to compile and check before responding. i'm always on people about making assumptions about code instead of testing, also. I feel doubly stupid. EDIT: Sir or madam. There I go with the assumptions again.
Is this a good idea to do in production code, or just an interesting novelty?
Bitmap images can store data in a number of different bit depths, but most are 24 or 32bpp; if you don't require a fully comprehensive method and really want to do it yourself rather than having to set up a third-party library, I have [some code here](https://github.com/klange/osdev/blob/master/userspace/lib/graphics.c#L215) that loads bitmaps (24bpp and 32bpp only) into a 32bpp ARGB-formatted, row/column-indexable, array of 32-bit integers, formatted as AARRGGBB (with [bitmasks here](https://github.com/klange/osdev/blob/master/userspace/lib/graphics.h#L16)). You can then address a specific pixel as follows: int x = 0, y = 0; sprite_t sprite; load_sprite(&amp;sprite, "path/to/some/image.bmp"); uint32_t color = sprite.bitmap[y * sprite.width + x]; char red = _RED(color); char blue = _BLU(color); char green = _GRE(color); free(sprite.bitmap); printf("(%d,%d) = #%02X%02X%02X\n", x, y, red, blue, green); Note, however, that this is very crude, single-purpose code that skips over a lot of the extra data stored in the bitmap file.
Thanks for your help. I tried to run your code exactly as it is, and i get this error:" C:\Dev-Cpp\Makefile.win [Build Error] ["Final] Error 1 "
You need the functions and struct definitions from the code I linked, particularly all of `load_sprite` from the first link, and then the `sprite_t` definition from [the other link](https://github.com/klange/osdev/blob/master/userspace/lib/graphics.h#L28), as well as the macros to extract color components. They're both from the native graphics library for my operating system. Also, the error message you provided is entirely unhelpful.
I copy pasted your code from both tabs. Also, the error lists only that and I have never seen this error before. What operating system are you running?
It's clear that you don't really know what you're doing, so [here](https://gist.github.com/4187021) is just the code you need (copying anything else out of the files I linked would be bad, as much of the rest of that library depends on other libraries and system-specific behavior). [As for what operating system I'm running...](http://toaruos.org)
You are right, I have only had a couple months of programming experience. Where are you getting the variables that you are imputing into your main routine?
You need a primer on C/C++. `main()` is the entry point of the program and its arguments come from the command line that launched the application. Ie., if compiled with `cc -o bitmap bitmap.c`, this would be executed as `./bitmap /path/to/some/image.bmp` on a Unix-like system, or since you're on Windows, `bitmap C:\Path\To\Some\image.bmp` should suffice. Alternatively, you could replace the `argv[1]` with the path to a bitmap image and recompile.
Thank you so much for all of your help. I greatly appreciate you taking the time to answer all of my questions.
Check out getline(3).
He is taking a book which is still recommended to people after twenty odd years, which is arguably full of "bugs" by modern standards. That's similar to the "widely used so can't be flawed" argument above. The bugs he complains about near the start of the chapter amount to the difficulty of bounds checking for character array buffers when using null terminated strings. His solution is to not use C style strings, which is a weaker form of sheepdog's rejection of the whole language. His argument therefore overlaps yours too, since he clearly does care about the language, otherwise I doubt he would have written a book about how to teach it to others. 
I understand your point now, but I think it's a different story. As I already said, I'm not pretending the C language is perfect, and I think it was a mistake from my part to use the argument that since it's so used, it cannot be flawed. I won't repeat everything I said earlier, but what I meant is that we still consider an old language the best tool for some jobs even today, because it was designed to be close to the machine it runs on. Sure, as sheepdog69 said, we gained knowledge and we can now use better environments for day to day programming, but it's no reason to dismiss C because of that.
 #include &lt;stdio.h&gt; int main(void) { char buf[1024]; char temp = 0, temp2 = 0; int i = 0; while ((temp = getchar()) != EOF) { if (temp == 10) { temp2 = getc(stdin); buf[i++] = temp; if (temp2 == 10) break; else ungetc(temp2, stdin); } else { buf[i++] = temp; } } buf[i] = 0; printf("string: %s\n", buf); } 
 int main(void) { char buf[1024]; char temp = 0, temp2 = 0; int i = 0; while (scanf("%c", &amp;temp) != -1) { //((temp = getchar()) != EOF) { if (temp == 10) { //temp2 = getc(stdin); scanf("%c", &amp;temp2); buf[i++] = temp; if (temp2 == 10) break; else ungetc(temp2, stdin); } else { buf[i++] = temp; } } buf[i] = 0; printf("string:\n%s\n", buf); } 
I don't think bar.c needs to include api.h. 
Because bar.c is defining pow, it doesn't need the pow prototype. Because bar.c never uses the name seventh_power, the seventh_power prototype is not needed. Those two prototypes are not needed, therefore the header is not needed. Or am I brain dead because it's 5am here? 
When enabling `-Wmissing-prototypes`, gcc requires a separate declaration and definition, so it does need that prototype contained in api.h, despite defining the function. If that flag is not enabled, you're right, though.
Yep. That's C. However, if you define a function like that, chances are that you only use it in the current source file. Then, you can define the function as `static` and you don't need the prototype: static float pow(float input, int power) { ... } Using `static` also has the advantage that the function is not visible outside the compilation unit, reducing potential name collisions.
One thing I would like to note is the readability of a for loop over a while loop. for(i = 0; i &lt;= 10; i++) give the reader a clear understanding of everything that is going on in regards to that loop. There is no guessing or peeking ahead of code later on, especially with large code blocks. That's just my 2 cents.
Please don't use "void main": * http://c-faq.com/ansi/maindecl.html * http://c-faq.com/ansi/voidmain.html * http://c-faq.com/ansi/voidmain.pjp.html 
Ah, good point. At the time I was (and still am) mostly coding for a robot where there's no use for a return value, and I think most of the example code uses `void main()` there as well. Good idea to forget that bad habit asap.
Related: * http://c2.com/cgi/wiki?ThreeStarProgrammer * http://c2.com/cgi/wiki?YouMightBeaThreeStarProgrammer * http://c2.com/cgi/wiki?ThreeStarProgrammerExamples "Just to be clear: Being called a ThreeStarProgrammer is usually *not* a compliment." ;-)
Has anyone had much of a chance to use setjmp/longjmp? I'm always aware of the possibility, but usually go some other way.
A long time ago, I actually wrote a preemptive multithreading library for DOS using the djgpp compiler called LWP. I was unaware of setjmp/longjmp when I first wrote it, so I rolled my own versions in assembly language using the gnu assembler. When I discovered setjmp.h, I rewrote that part of the system. It was also preemptive, using a timer interrupt handler to periodically setjmp the old task and longjmp to the new one. The downside is that the task code had to be thread safe. The solution to the 'you can't jump forward' he talks about is to give each thread it's own heap allocated stack. 
kickerPtr is laid out sequentially in memory so when you say (kickerPtr + (x*4) + j) you are getting the memory location of kickerPtr[x][j]. When you dereference that you get the contents of kickerPtr[x][j], which is an integer. This is why the second dereference operator gives an error, you're treating the contents of kickerPtr[x][j] as a pointer. I think the best solution would be to use the [] operator for accessing the array.
What was he programming on that didn't throw segfaults for that?
It could be any of a million things. There's no way to know without seeing the code. 
Goto's great for function cleanup...
Learning time for me, why did you use divide in the bitmasks instead of a direct bitshift?
The logic is easier to follow in the code, and the compiler will produce the same output.
A tip I've always used to help with pointers is to prefix each name with a "p". So I would have a variable named pSomePointer or whatever. This doesn't help with understanding pointers of course, but it does help me understand to be on the lookout for pointer related issues for that particular variable.
By the jollies, dear sir, look at your jimmies! They appear most rustled! ...it is indeed an interesting phenomenon.
I was really looking forward to a book describing modern C programming and was a bit disappointed. In my opinion it focuses too much on the toolchain (Autotools, git, etc.) instead of C programming. The actual code examples also contained a few constructs that I find problematic for code maintainability and readability, e.g. large function-like macros. And I expected a bit more of the chapter about different C libraries. But all in all it was an entertaining and informative read.
*team function() works just fine with a typedef.
I think a nice way to contribute to open source projects is to keep scratching your own itch. You might come across a small bug in a program you're using. Since it's open source, you can try to locate the bug and fix it, then submit a patch. If you can't find a bug on your own, you could have a look at bug trackers. You might come across something that's easy enough to fix. That way you made a valuable contribution (everybody hates bugs, right?) without too much effort (depending on the bug). About finding "easy" projects. Well, C is a rather small and simple language. It has just a couple of keywords and not too many idioms. To understand the code of behind some more complex FOSS, you don't necessarily need to be an expert C programmer, rather than an experienced programmer in general. Understanding software is more about design than about actual code. To gain experience I'd suggest to read code. Nobody in their right mind tries to write obfuscated production code. Most C code in open source projects I've seen so far was actually rather clean (surprisingly, the Linux kernel is one of the cleanest code bases I've seen in a while - it's just bloody huge). So bottom line, you'd best chose something you actually use and start contributing in small steps. 
Find a project that has a lot of bugs filed. Preferably a project that is easy to build. See what bugs you can replicate, and see if you can fix bugs. If you can't fix it, still document your attempts at replication and what you tried to do to fix the bug in the bug report. This is valuable assistance to a grateful developer, as you can rule out lines of thinking and show them corroborative evidence. If you find a reproducible bug but the original report was flimsy, attempt to aid the developers by doing stack traces with GDB, debugging the code yourself, possibly coming up with a fix. Again you're not going to be able to fix every bug but you can at least shed some light on a murky report.
Up vote for the blog link 
You may like their tools or not, but I found http://suckless.org a nice place. Their code is short and clean, not too hard to understand, and while they aren't really people who will accept patches just because someone added a new feature, the patches are often gathererd and kept for everyone to use (like in http://dwm.suckless.org/patches/)
Maybe they won't accept new features unless they're *really* good, but they're happy to accept bug fixes.
Program a lot. Read code. Read good books. One of my favorites is [Expert C Programming: Deep C Secrets](http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298).
More like s/they're really good/they fit their silly SLOC requirements/ :P But yes, you're right.
Could you give examples of *expert, beautifully elegant* code that you've seen around?
And in what ways is it more elegant than the linux kernel source tree, in your opinion?
The next step is really to go beyond the language. Learn more about how the hardware works and how the compiler produces machine code. Then there is stuff like the structure of the kernel. 
Do difficult exercises. If you want to do Systems work (drivers, kernel work) you have to get your feet wet. Some exercises I'd try: 1. Write a file system using FUSE. People have done some really fun stuff with it (like make their gmail account into a file system). 1. Write a driver that returns a random number when you read from the device. 1. Write your own version of malloc with different memory management schemes. (First fit/best fit/next fit...) All of these are throw away projects, but you get closer to what you want to be doing.
Well, I guess my point was not to highlight Linux over BSD. I am a fan of the cathedral over the bazaar, yes, and of *BSD over Linux. But ultimately, the BSD internals are just what I know fit your question. I don't have as much experience with the Linux kernel-land. I would say that one of the things BSD promotes is careful, cautious, thoughtful, dare-I-say "neck bearded" engineering. That's not to say Linux isn't, but BSD definitely is if anything is. I think the style(9) man page is a great way to learn how to code better C - not just because it tells you what to do, but what not to do, and how not to be too clever. Yes, it's mostly style. But a lot of C is style; appreciating the simplicity of the language and thereby embracing it.
Thank you for good suggestions. I was going buy more books (although I couldn't find any good), but I will start to read code instead and learn from that
It seems to be a good book. My only concern is that it is a bit dated. Is it still " valid" by today's standard?
Thanks. I would like to learn that. I have been thinking of buying an arduino but I'm not sure which one to buy. Which one would you choose? Also do you know where can I find good resources for leaning make?
I think the arduino leonardo is probably a good pick, since it's cheap, and the 32u4 chip has quite a few capabilities, the most important of which is, for you, the built-in usb client device. That means that you are able to use it -- really easily -- to implement any sort of usb-device you want to, which you can then interface with the PC. You can program it to be a mouse, keyboard, joystick, midi input device, whatever. Those will already be taken care of by standard-drivers that the kernel has per default (and also on the arduino-side -- so you can just write "Mouse.move(10, 10) and that'll work). Later on, you can use a framework like LUFA (lightweight USB stack for AVR) to implement your own, totally random/crazy USB devices that can do whatever you want. You can then use libusb/libusbx on the linux-side to communicate with the device via usb. This is super-convenient, since 1) talking to usb devices via libusb(x) is basically like having a bunch of glorified sockets/pipes, so it's very intuitive and easy -- but you'll still learn a lot about the USB protocol, how the communication with devices works, et cetera. 2) it's all in user-land, not in the kernel yet -- so everything is super-easy to debug and errors won't have annoying repercussions. 3) you can use wireshark to conveniently sniff all USB traffic and look at what exactly is going on. Later on, you can have a look at some of the in-kernel standard usb drivers, like the ones for ACM devices, joysticks/keyboards/et cetera -- then you'll get a feel for what writing usb drivers in the kernel-land is (it's still really nice and abstract compared to some other interfaces) I really recommend to go down this route of "userland usb (libusb(x))" -&gt; "kernel-land usb" -&gt; other stuff, since going right to complicated interfaces like PCI that use icky things like MMUIOs et cetera is rather difficult. At any rate, you first want to be comfortable with programming the AVR chip on the arduino/whatever itself, since that'll teach you a lot of things as well. Don't use their abstractions (Serial.write("hello there")) but download the datasheet for the Atmega 32u4 chip and implement these kind of things yourself by registering interrupts, setting up DMA channels, et cetera. Other alternatives are for instance the teensy or teensy++, which have the same chip (roughly) or, if you want to go for something 32-bit ARM-based, for instance the launchpad stellaris (very powerful chip 32-bit chip with floating-point unit for 12$ for the whole devboard). ARM is a very wide-spread architecture and rapidly growing, so in term of market-value, knowing ARM is probably worth more than AVR. But the arduinos are definitely the easiest to get started with. I don't know any particular resources for learning make (I mostly just learned it by looking at other peoples makefiles and experimenting), but I'm sure you'll find things on the web.
http://blip.tv/linuxconfau/advanced-c-coding-for-fun-4742990 Watch this video. Then watch it again. And thrice. When you understand it completely only then are you are ready, my son.
Yes. Still valid.
Yes, definitely. The parts that it focuses on haven't changed since C89. There might be room for a new book that covers the new stuff added in C99 and C11, but for the most part C is a very mature language that hasn't changed much for a long time.
Thanks a lot for taking time to explain! It looks interesting. I will buy the Leonardo and try these things. 
A fuse filesystem? That sounds like a fun project. How did they manage gmail? Think it would be possible to do that with dropbox?
Wow, cool site, and they [even have project suggestions](http://suckless.org/project_ideas). Definitely worth looking into.
I can't type a long response right now, but basically you have to write the implementations of "write()" and "read()," which will be called by the kernel. For the gmail app, after "write()" was called, they'd store the data as an email attachment and send an email to your account. "read()" worked just the opposite, it checks your email for the specific requested block and downloads the attachment. That was a huge over simplification, but that's the basic idea. Will it work with dropbox? Without a doubt. It's even possible that the official dropbox distribution uses FUSE. Anyway, google "fuse dropbox" and you see lots of FUSE filesystems that work with dropbox. Gotta run. 
Another nice microcontroller is the msp430g series. You can pick up a launchpad kit for $4.30 from TI which gives everything you need to start playing with uc's on the cheap(2 uc's, programming interface and board to work on prototyping with). It's a great chip that is underrated and has a lot of potential. For around $12 I believe, you can get the stellaris launchpad which is a arm cortex-m4 chip built onto the lp board and programmer. In either option, you get a lot of bang for the buck. Check out 43oh.com for some projects that people have worked on. 
I don't know why you would have gotten even one downvote for that. Djikstra's complaint about GOTO wasn't even related to the way it's used in C, IMO. In C, you can't "goto" a label beyond the top-level scope you are currently in, which makes it a lot more safe and useful, and indeed, there are many, many, C code-bases that use it to good end. It's not akin to setjmp/longjmp, which are, in fact, like the GOTO that Djisktra thought was so terrible. 
GCC
Install Cygwin and gcc/gdb. 
gcc and clang.
I'm not doing embedded code but I do have an Intel CPU on my laptop which I use to code. Would this ICC work for me?
Sure, it's just a C compiler after all. I'm not sure right now whether it's available with the non-commercial license for Windows though. However, there's still gcc and clang, both of which work on Windows and are free.
You're question doesn't seem to be about which C compiler is better (They all implement the standard and are relatively similar) but about what debugger and/or IDE to use. I can recommend gdb (use the visual mode) for debugging, and vim to write code, since that has decent syntax highlighting. However, if you don't like vim, just make sure to use any text editor with syntax highlighting, as it removes a lot of compile-time errors.
Are you not allowed to use an IDE or are you choosing not to use one? Since you seem to be using Windows, I can't recommend Visual Studio Express enough since it comes with a visual debugger that allows for memory, register, call stack, thread, and any other type of inspection you could possibly want while debugging your program.
Why do you have to use the command prompt, and why does that make debugging a pain ? I've run and debugged command line apps in Visual Studio for years and years. Has something changed in VS2012, or the Express versions ? 
gcc or clang. If you want a complete programming environment then install a Unix-like operating system (FreeBSD, Linux, etc.).
Why not just MinGW? 
If you're on Windows use Notepad++. 
gcc sucks, can't compile for shit. Does anyone actually use this thing? Eclipse is my personal favorite but it's not free.
There's nothing more to say.
Works for me.
I'm sorry to break it to you, but Visual Studio's debugger is by far the easiest debugger to use. You are not going to find anything easier. 
Why not. Good point. 
Eclipse itself doesn't contain a C compiler. And it is free. So, I don't know WTF you're talking about. 
I can't stand IDEs personally. I just use Notepad++. Everything else I just wind up fighting with. I can't ever get anything that isn't Notepad++ to work in the way I want without getting frustrated every other minute by its attempts to be "*intelligent*". &lt;_&gt;
"Embedded code" is a loaded phrase. What is your target platform? Are you cross-compiling? ICC doesn't have cross-compiling support but gcc does for most target architectures.
Last I looked, the non-commercial license only covered the Linux version.
I am a student of a electrical engineering who has finished his first class in C and wants to continue to self study but can't seem to get the version of visual studio the school used to work so I'm looking for alternatives. When he said Intel C compiler I assumed that he was talking about programming chips on a board whereas I am simply look for how make program that will run on my PC.
uh, yes it does. I use it at work everyday man, I know.
seriously? Last time I tried it didn't even have a gui. Did they get around to that yet? Maybe I should give it another try.
A compiler doesn't need a GUI. Eclipse can do the IDE thing for you, but a compiler is a compiler, and as such it only needs a CLI or a Makefile.
I think you might be an IDE, not a compiler. You might want to try the eclipse CDT, or codeblocks. If you're *really* looking for a compiler, use clang. 
I was in your position a decade and a half ago. I just installed Linux, which comes with GCC and all header files for libraries already in the software repository. This decision changed my life. It's easier to learn about computers when all source code is available.
And you use it every day, and still don't know that. And when I tell people, "50% of people who bill themselves as software developers or programmers can't actually program", they are surprised. Here you go: "Eclipse IDE for C/C++ Developers does not contain a compiler or debugger; if your system does not have one, you need to download and install one." http://www.eclipse.org/downloads/moreinfo/c.php Wrong about that, and really, really wrong about Eclipse not being free. Laughably wrong. 
C itself can be considered "dated", and is still very relevant today. The standard that is most widely used is C89, which is more than 20 years old! The newer standards haven't changed much either. That's why even older versions of K&amp;R are still relevant. So, bottom line: In C, you usually won't go wrong with older literature.
But.. Eclipse is open-source too.
I doubt we use the open source eclipse.
Ah sorry I misread your previous comment. You're saying you're **NOT** doing embedded. I thought you were. So cygwin + gcc + eclipse would definitely work for you. I would also recommend you try virtualbox + ubuntu vm and use gcc there from the command line. Getting started with C in Linux is as easy as it gets.
In addition to what everyone else said, I also recommend: * C Frequently Asked Questions: http://c-faq.com/ * C Infrequently Asked Questions: http://www.seebs.net/faqs/c-iaq.html Both are very good resources to learn the language.
Ok Thank you for all the advice!
That would be difficult being is that there is only one Eclipse and it's open source.
You can also access a fourth argument in programs compiled for Mac OS X, but as everyone else has pointed out, this is all non-standard.
Nothing said in this entire document is anything beyond simple code styling and modern C coding practices. If you're not already doing most of this, your codebase is probably in trouble. You can quibble whether they should use the word "delete" if you're trying to be compatible with C++ compilers, you can argue whether destructors should be passed a pointer to a pointer and nullify when it's most likely to be a dead store anyway, but those are bikeshedding points. There's nothing here that makes your C especially scalable, just clean and maintainable.
I suspect the sense is "scaling to large codebases worked on by many developers" rather than "scaling to high volumes of traffic". IMHO it's a good style guide however you interpret "scale".
Yes, it's meant to be "scalable" in terms of codebase size (cheaper to write correct code) and community size (cheaper to share code between more people). Since all our projects use ZeroMQ for multi-threading they're also scalable in terms of performance but that's kind of beside the point here.
&gt;A project prefix used to prefix all method names, which MAY be the same as the project abbreviation. This would be used in source code and its API. The prefix SHOULD end with an underscore. In this Specification we will use myp_ as the example. Stopped reading right there. Underscores are for constants and preprocessor stuff, and nothing else.
It's the standard library naming convention, and though I've tried other variations over the years, seems to be the most readable because it matches normal_writing_most_closely.
I think you got it wrong. It doesn't say "end the name in _" but "end the *prefix* in _" which results in method names like myp_fubar() which is perfectly acceptable by any means, even encouraged in most standards as well as text books.
[_t is reserved by posix](http://www.cs.utah.edu/dept/old/texinfo/glibc-manual-0.02/library_1.html#SEC11)
So, do you think it's clean to simply drop the _t on module types? It seems to open the door to confusion, e.g. node *node; node = (node *) zmalloc (sizeof (node)); Which is ambiguous, whereas: node_t *node; node = (node_t *) zmalloc (sizeof (node_t)); Is clear. Either we need a suffix for types, or we forbid variables from being named after their type. 
I have no easy answers. I've personally used _t in libraries I've written, then I was made aware of the posix naming convention. I thought it good to make others aware. I don't think a suffix of _t is the *only* choice, though. Also, I kind of feel typedef everything just because to be a bit of a minefield. [I kind of agree with Linux on this point.](http://yarchive.net/comp/linux/typedefs.html)
Or you can use case. E.g. GLib uses "GWhatever" to distinguish a type definition from a name. Node *node; node = (Node *) zmalloc (sizeof (Node)); is perfectly fine and self documenting, if not slightly uglier. whatever_t became standard because POSIX popularized it. In most domains, it's perfectly fine to keep using whatever_t and you'll never hit an issue looking backwards or forwards.
Re List Navigation: I heavily prefer callbacks of the form: typedef int(*myp_mymod_cb)(item_t*, void*); void myp_foreach(myp_mymod_t* self, myp_mymod_cb cb, void* data) Where the callback function returns 0 if it's happy to continue and not-0 if it would like to stop iterating. This makes it troublesome to iterate over multiple structures, but it's generally not an issue if your module is managing those structures. And the number of bugs I've gotten rid of by not managing my own loops and being able to write tests for the callback functions has been a pretty big win for me. &gt;Application programs SHOULD use the heap only through constructors and the library strdup () function. Should be just `dup` function here since I believe it's referring to the general duplication functions and not specifically `strdup`. &gt;This is the general template for a method comment header: The code that follows has no return type. &gt;Code generation SHALL be done manually, and all generated code SHALL be committed into the project as for hand-written files. In my experience, code generation is a build target and build targets should hence not be checked into the repository. What's the reasoning behind committing generated code? &gt;The heavy reliance on heap memory makes CLASS unsuitable for embedded systems where all memory use must be static. This can be worked around by making a function which returns the size of the opaque data and then using `alloca` or whatever to make your memory. Obviously it might be nice to do this using a macro since it's tedious to code out the call to `alloca` and you can't wrap it in a function since it will eat your stack when it returns. :) Maybe I'm just bikeshedding. Thanks for the write up Pieter!
Clearly a troll. AFAIK Eclipse is usually set up with gcc.
And they have been in the game for a while, it's not a brand new style guide. I prefer it too.
Your first example is confusing because the variable name is not descriptive. It should be something like: node *next_leaf; node *laptop; node *ipv6_info; If "node" determines the type (like node_t), your variable should not be named "node". This is true whether you use node or node_t as the type. Edit: Think about it this way. Does this declaration make any sense: uint32_t *uint32; To answer your original question, you should definitely not used _t that is reserved for posix. It confuses programmers like me more because I automatically think the type is specified by the POSIX spec and not by your program.
Thanks for clearing that up with me and suggestion GDB. I'm still learning as much as I can. 
Easy to say, hard to do for novices. The Microcontrollers class I was in had a single lab with only 2 programmers, so unless you wanted to literally camp there while debugging you had to use the simulator. On the plus side, my debugging skills increased exponentially during that class. 
I welcome any kind of feedback, that's the only way to learn and grow. wanted or unwanted. programming is so beautiful. 
Neither. You should *never* cast the return value of malloc(), and you should *always* do sizeof() on a dereferenced pointer and not the type. This means: node *node; node = zmalloc(sizeof(*node)); Which is unambiguous with a lot less clutter. Besides, ambiguousness in these cases doesn't matter as the compiler will tell you if you're doing it wrong. The widespread Hungarian notation in the Win32 world is braindead (and count the foo_t notation to that), don't do the compilers work manually.
use pcre #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pcre.h&gt; #include &lt;string.h&gt; int main(){ pcre *re; int rc; int ovector[30]; //must be multiple of 3 .. contains info for captured substring const char *err; int erroffset; re = pcre_compile("(i suck cock)", PCRE_CASELESS, &amp;err, &amp;erroffset, NULL); int rc = pcre_exec(re, NULL, "here thee here thee i suck cock", strlen("here thee here thee i suck cock"), 0, 0, ovector, 30); // if match is captured.. the ovector[2] contains the start and ovector[3] contains the end of the captured substring .. if you want to capture more than one perform pcre_exec while it doesn't equal -1 .... and in the param where you set the startoffset start on 0 and then use ovector[1] for start offset ... use man pcreapi for the functions ..., im on ubuntu so i just apt-get install libpcre whatever and libpcre-dev whatever version }
I'm still bad at reading source code. Could you explain how you've implemented this? Is your code pointing to a memory address, and mapping n-bits to n binary values in 1-bit wide * n address locations? Or, are you mapping a bit to a byte? Does my question make sense?
Just the header will do fine.
thanks!
Not exactly a new idea. Programmers have employed similar techniques for multidimensional arrays since the dawn of computing.
I had encoding and decoding of image formats in mind. No reason to go all snarky over a friendly comment. 
I'm only a novice programmer but won't this make it more difficult to debug? If you start using more space in the row than you actually have, then you leak into the next row, rather than geting a seg fault.
What common programming idiom will be next? Stay tuned!
Your project has a huge number of functions! I think you should look at my favorite bit mangling/twiddling book (and that's just the first chapter). Hopefully it's inspiring to you: [Fxtbook/Matters Computational](http://www.jjj.de/fxt/#fxtbook) (It's a free PDF).
I see. Thanks.
Or just create a word of size_t and use that as a bit array, now you have word-at-a-time vectorized code without issue.
Thanks - I'll take a look. I've browsed several resources on optimisations / useful bit functions to try to create something that is closer to a complete resource (hence all the functions). Shifting, cycling etc. are very useful are are a pain to constantly re-implement. I found this very useful: http://graphics.stanford.edu/~seander/bithacks.html Let me know if there's a function you'd like to see implemented. 
The point of the library is to provide some of the more exotic functions e.g. cycling an array of 1003 bits (slightly tricky as you're not using whole words). Or shifting in the same case. Also provides to/from hex, decimal etc. (requires dividing bit arrays, also complicated). Saves people re-inventing. 
I find the ternary ? operator really useful for assignment and return statements, for example: variable = condition ? SUCCESS : FAILURE; or: return(condition ? SUCCESS : FAILURE); But in the case of simple if/then statements, I don't know that using the operator makes the code more readable or more maintainable. That's just my opinion, though. 
Poddster is right. The basic setup of a bit array like this is very common. I made a library to provide the more complex functions (resize, cycle, shift, to/from hex/decimal, multiply/divide). It also allowed me to just drop the library into other projects without having to re-invent and re-test code. 
It's exactly the same*. It doesn't matter if you initialize your array like this int C[N][N] or like this int *C[N*N] In both cases you get a chunk of contiguous chunk of memory that you can manipulate as you want. So, if you try to access C[0][N], you won't get a segmentation fault; you are really accessing C[1][0] because it is the next address. I wrote the following small program for you to check, if you want. Feel free to try it or to ask anything relevant. https://gist.github.com/4635669 *Disclaimer: I'm not C guru. This is true for GCC and for any other sane C compiler I have come across.
this. that entire array only exists in the stack frame for that specific function, and as soon as that function ends that pointer could be pointing to the same place on the RTS, but as soon as the stack frame is popped all of that data becomes extremely volitile. the advantages of malloc are that all of this temp data is stored on the runtime heap, which will only get fucked up if you decide to fuck it up
pointer arithmetic in a nutshell: you have your different pointer types eg char *, int *, long *, etc.. each of these data types has a different max / min value. For example a char data type is only one byte, versus int's 4 bytes, etc. So if you take a character pointer (not dereferenced) like say you have char *c; when you do c++ (or c = c + 1), it increments the pointer by the NUMBER OF BYTES of the data type. so if you did an int* and incremented it it would physically point to a place in memory 4 bytes ahead, and so on. The weird part is when you get to shit like void pointers, which are technically 0 bytes in size. These are interesting because you can cast them to various other pointer types, even function ptrs, and then the arithmetic is the same as if you pretended that casted void ptr really was say an int ptr. mouth diareah. i cant spell diahreah diahhrea, whatever im a computer scientist, dgaf.
so much precedence table man *edit - link tossed your way http://www2.its.strath.ac.uk/courses/c/_7193_tabular246.gif
You can return a struct instead: #include &lt;stdio.h&gt; struct result_s { int elts[5]; }; struct result_s Return_Integer_Array() { return (struct result_s) { .elts = { 0, 1, 2, 3, 4 }}; } int main( int argc, char* argv[] ) { printf( "Number 4: %d\n", (Return_Integer_Array()).elts[4] ); return ( 0 ); } 
I thought that you were programming in a new programming language called "C--". Boy was I disappointed. 
I'm sure this is a terrible idea. My experience with inline C function closures is disappointingly brief ... the real killer is the need for an executable stack, which is seriously unclever. Cute idea, but C has got to be the wrong language for this. Don't get me wrong, I'm very fond of C, but it comes third in my hierarchy of languages (`bash`, `python`, `C`), because it's more work to do simple things. I do frequently find myself longing for functional features in C ... but I'm convinced this wish is misguided.
Your best bet is to either use Notepad++, or set yourself up a nice Linux/Unix VM and just code in that. If you're using Linux/Unix then just use gcc. I code in the OSX terminal when I'm on the go, or through Putty (still on my Mac) on my PC. Works like a charm. 
Oh the horror of it all.
Nice lib, but I think there are too less comments how things work! 
To put things simply I would say that you want to start by creating your own projects. If you have issues thinking of ideas, like I do, then grab programming books and do their programming projects.
http://www.cminusminus.org/
I don't what compiler options you have turned on but I always have the following on so that I get a more detailed output on what I'm doing wrong: -std=c99 -pedantic -Wall -O2 Syntax wise you need to change 'remainder=10' to '(remainder==10)' because you want a comparison between remainder and 10, not an assignment. Also the brackets are needed to stop the compiler moaning at you. You also have incorrect curly braces around your if statement. You need a closing bracket before the else, and an opening bracket after the else. Lastly you have an extra curly bracket hanging around before the 'return 0'. Remove that. Also I presume you have hashes before your include and define. You also need to initialise 'sum' as 0. Just a final note, one line for loops are BAD! It makes the code quite unreadable. I suggest separating that out into it's different lines. The same applies to initialising your variables on the same line as the function declaration. Put those on separate lines as well. Hope this helps :)
If syntax: &gt; if (remainder == 10) {
In addition to what other comments have said: * You are using "sum" uninitialized. You add values to "sum" but you never set it to anything initially. As a result of this, the entire program's behaviour is undefined. To fix it, you need to assign 0 to sum first. * You need to print a newline ("\n") after printing the remainder. * There's no point in computing the remainder after each iteration, since you only use it once after the loop. So either compute the remainder after the loop, or just do away with the remainder variable entirely (the compiler does this for you anyway) and replace the conditional with if (sum % 11 == 10). * Your first loop starts at 1 instead of zero. * Your second loop ends at 9 (instead of before ISBN_LENGTH,) and accesses isbn[9], which is past the end of the isbn array. So the output of the program is undefined.
I ran it on my machine and it appeared to me that the check digit was 1, not 4.
You're still accessing isbn[9], which is past the end of the array (the indices range from 0 to 8.)
you also have a rogue } at the end of your for loop line
This works on MSVC? That's the troublesome platform; to get the useful bits of C99 you need to compile as C++...
I tried working with QT and c++, and found it too hard, so I've regressed back to GTK and c - I'm starting to get my head around this combination and finally starting to get some results. Hardest if finding examples in GTK+-3.0 that will compile with no errors as lots of functions depreciated from 2.0 to 3.0. Today finally got working menu, now just need to conquer dialog boxes and then can start on the sql coding with SQLITE.
On a side note, check out Pelles C if you want full C11 support.
And slibc performs C11 bounds checking if needed http://code.google.com/p/slibc
... In the installer you select "gcc" from the options. 
When in the setup, under the Devel section select gcc. Also select 'make' while you're at it.
I'm taking a programming course where we have to use Cygwin for C programming. If you can run the Cygwin terminal then you are half way there. Simply re-run the set-up file, Setup.exe that you used to install the terminal, and there is a certain point in the set up that you can select add-ons, search for gcc and click bin or binary check box for it, and Cygwin will add it to your terminal. After that launch the terminal and type "gcc -v" to make sure it has been installed.
I wouldn't suggest using a different compiler, however I would consider using a virtual machine and run a linux distro inside. Virutalbox is free and easy to use and you can get Ubuntu up and running quite quickly. And you will be able to get a lot better community support. 
Think of the install as a package manager. By default it installs the shell and a few libs. Run it again and browse/search for the packages you need.
This. There should be a very strong reason not to run a VirtualBox instance when studying C programming.
When you read it backwards you have to compare it to something, what are you comparing it to when you read it backwards, to make sure it is a palindrome? Edit: write the word to test (first try it on a palindrome) on paper and see if it is a palindrome it does not even have to be a real word. Edit 2: generate a palindrome using random letters (does not actually form a real word), how do you do it?
I'd avoid using scanf() as you're setting yourself up for a buffer overflow and problems if the user inputs something longer than 99 characters.
Loop from the front to the back, comparing the frontmost character to the rearmost; then the frontmost plus one to the rearmost minus one, then two, et cetera. You'll need to do a little extra juggling to make sure the string isn't empty first. If at any time there is a mismatch (and you should consider whether you care about upper case,) bail immediately with a no. If there is not, return a yes. The thing you're doing right now, `strcmp`, is sort of not the right direction; strcmp is for comparing strings. You just want to compare a single character at each step. Remember that technically, characters are just numbers. You can treat each letter as if it was a number.
It's probably a little early in his development for that sort of thing. Crawl before you walk, et cetera. I'm glad you're watching out for people's safety, but remember, when they're really early on, they won't have any idea what this means.
There's no point in starting out with bad habits.
You're certainly correct. But an admonition that isn't understood also doesn't land, and one can worry about scaring the guy off. `:)` Listen, I respect what you said, and I'm glad you're saying it. You're correct, and we need more helpful people here. 
I'd like to explain a little bit about what the guy said to you. It's probably too early for you to be worrying about stuff like this, but as long as the blood's in the water, etc. Generally speaking, the issue is this: when your teacher allocated space for the string to live in, they allocated a fixed amount - enough space for 100 characters, of which the last must be the null terminator, meaning enough practical space for 99 characters. Your teacher left a security bug in the base code. Namely, it just asks for a string input, and plops it down in the buffer. That's bad because if the string is too big, it will be written past the end of the buffer, over-writing whatever follows. There are lots of classes of attack around this, some of the ugliest of which involve using this sort of thing to overwrite the letters which form a pointer, because that pointer could then get followed to something else, ostensibly even more of the attack data, and interpret it as ***code*** instead of a string, letting Commander Evil do whatever they want with your system. Like I said, it's really much too early for you to care about crap like this. But, as long as it's been brought up, you might as well know what's being said to you.
 #include &lt;string.h&gt; static int is_palindrome(char *str) { int start, end; for (start = 0, end = strlen(str) - 1; start &lt;= end; start++, end--) { if (str[start] != str[end]) { return 0; } } return 1; } There is an implicit loop in the call to `strlen` however, so it's technically two loops. Also, your input read is unsafe...
Thanks, that makes some sense, but to be honest when it comes to C, I have no fucking clue what I am doing. I didn't think I'd have to do computer programming course when I signed up for a Civil Engineering degree.
You can just use strcmp() and reverse() (I think you'll have to write the latter, if using C).
First off, don't put a "#include" line inside a function definition. That will break a lot of things. Second, the "#define _CRT_SECURE_NO_DEPRECATE" is specific to Visual C++ and should be in the project settings not in your file. EDIT: Also, you're using 'input' in IsPalindrome. It should be 'word'. And you need to include &lt;string.h&gt; and strrev isn't available on some platforms as a C library function.
I did this years ago in so unknown ancient language. I believe it was a recursive technique. It involved keeping a stack (for the left side of the palindrome) and looking first for the center of a palindrome by scanning a long string. A center was either a double letter or 3 letters with the same on each each end. If a center was found then further testing was done until the test failed or spaces were found on each end (a palindrome).
no, not at all.
 that will work but is overly complicated for this person.
&gt; also you might as well pull the strlen out of the loop and just test it once Even with no optimisation, the strlen *is* only called once, in loop initialisation. &gt; also does one really have to do the last comparison. Indeed. One doesn't.
xor the end bytes, move inward, xor the end bytes, move inward, xor the end bytes, move forward. Do this till you hit a middle or empty position. If the value is 0, you have a palindrome. edit: [wrote this to demonstrate the idea.](http://www.pastebin.com/KZyyu5gg)
oops, looked too quickly indeed that is in the init.
Are we doing kids homework now?
this is a "I have coded this, take a look" post.. I hate those.. It would be better if he explained what he does, how he traverses trough the files in the directory and that..
And %90 of the code is just copied from `man 3 stat`. 
Post output, compiler options and output next time please.
You haven't given us more than a single function. What does your program do with the function's returned value? I'd say Windows is correct because you've reached the end of the program and it stops there. Or maybe you have an infinite loop. Too hard to say with what you have told us.
I simply have a Int main(){ Int x,y; printf("enter value for x"); scanf("%d",x); Printf("enter value for y\n"); scanf("%d",y); Printf("gcd is %d: ", gcd(x,y)); } Sorry I didn't think the problem occurred within the main that's why I didn't include it. I would've understood if I had a for loop and it was infinitely running but I just have it running once for now. 
scanf expects pointers. 
You can debug your program with gdb and check the algorithm manually for small inputs.. You don't need gdb for that, you can just call printf in each function call and see what happens under the hood!
Shh! *I* know that, but obviously the OP didn't.
Yup. Didn't even realize I had forgotten the pointers. Just started C so still getting used to it. I probably would've looked over that the entire time so thanks!
Why do you have a `while` loop if you're just returning in the first iteration anyways? Use `if`/`else`. Or, better yet, keep the while loop and remove the recursion: int gcd(int x, int y) { int tmp; while(y != 0) { tmp = x; x = y; y = tmp%y; } return x; }
I had an if/else to begin with, not sure why I switched. But it works with either, ill probably just stick with the if/else. 
Not necessarily. Another way of looking at it is the difference between "Which one of these houses will I live in?" and "Which addresses will I put on these letters?" 
The latter is a pointer to a pointer to a `struct person`, and the former is a pointer to a `struct person`. Neither is better than the other; they have different uses. They can both be used to point to multiple objects, but how you do that depends on the exact circumstances and how you want those objects arranged in memory. 
 printf("%d", mySum); //you don't need the &amp; &amp; gives you the direction of the variable (the strange number you are seeing). Next time try /r/learnprogramming 
As fcibarbourou says, you don't use the '&amp;' in this case. Why? Because '&amp;' means 'the address of'. You don't want the *address* of MySum, you want the *value* of MySum.
&gt; gives you the direction of the variable Since a beginner might be reading this, the usual usage in English is 'gives a pointer to' although 'the direction of' has a pleasing similarity with '*' being the indirection operator.
or %p
That's one of the most disgusting things I've ever seen. Brilliant.
&gt; the real killer is the need for an executable stack, which is seriously unclever. I'm a bit confused by this. Are you saying that stacks should be executable, and that the OS people are unclever for having non-executable stacks, or are you saying that executable stacks are needed, but it's unclever to have executable stacks, despite their necessity?
I now understand, thank you!
I've seen it before, still funny, though. "What's the *auto* keyword good for?" Declaring vehicles. (I would also have accepted "to avoid *int*")
There isn't any loss of performance when using int_fastN_t, and you still get specified bit width. The only downside is you can't rely on overflow, the way you can when using intN_t.
`int_fastN_t` isn't exact-width, it is only guaranteed to have *at least* the number of bits specified. Relevant excerpt: &gt; **7.18.1.3 (paragraph 2):** &gt; ---- &gt; The typedef name `int_fast`*N*`_t` designates the fastest signed integer type with a width of at least *N*. The typedef name `uint_fast`*N*`_t` designates the fastest unsigned integer type with a width of at least *N*.
Although it's probably insanely rare, the exact-width integer types are only provided where the implementation already provides 8, 16, 32, and 64 bit integers in two's complement. They are optional on platforms that don't provide integers with exactly that number of bits or not in two's complement. So if you use `uint8_t` instead of `unsigned char` it will break on platforms where `CHAR_BIT &gt; 8` or if the implementation doesn't use two's complement (and chose also not to opt in on these types).
You can't rely on overflow of signed types at all anyway.
TIL: int_fastN_t Thanks :D
Actually, using fixed sizes makes your code more platform dependent, not less. For example, when porting from a 32 bit system to a 64 bit system, it's important to make sure that integers used to measure sizes or offsets change from 32 bit to 64 bit. Otherwise you run into all kinds of issues. This naturally works fine if you use `size_t` and `ptrdiff_t` consistently in your code; if you do that you don't have anything to worry about. Those types are automatically correct for the platform. If you used `uint32_t` instead, you're going to be in a world of hurt when you try porting to a 64 bit platform. 
I think you are missing the point.. If you want to measure some variable that depends on the platform, then yes, you should use the tools that the language give you for that.. If you use anything but size_t then you are doing it wrong..
&gt; Wouldn't it be better to always specify width, so behavior is well defined and isn't platform dependent? No. Integer size variability permitted portability. Remember that in the era of BCPL, bytes were between 6 and 10 bits; without the ability to map to the local machine, you had to start over every time.
Basically they exist because we don't have a time machine to go back 30 years and uninvent them. It's pretty fair to consider long and short as being pointless (except perhaps to save a couple of keystrokes) and using the correct sized integer where appropriate in newly written code. Then again, C89 is still a thing (Thanks, Microsoft), so you still see a lot of "typedef signed short int16_t;" in portable codebases...
A bit late, but it's hard to go wrong with VS Express on windows, but if you can't then using Eclipse (with CDT installed) and mingw is hard to beat. You can build from the command line. If you are strictly command line then use make, gcc (or clang), and vim, the way our ancestors did it, after walking uphill both ways to the compsci lab.
Post is eight days old, but I'll respond anyway. [Here's](http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html) a list of various options for warnings in GCC. Many potential simple bugs can be found at compile-time, so it's often a good idea to have some warnings turned on. For memory errors, it's often a good idea to run through Valgrind or similar. For many other bugs, try setting some breakpoints and stepping through in a debugger (such as GDB).
Things like that make it so hard for me to learn C. My whole programming life I have programmed in higher level languages (like python and java). Some time ago I started learning C. Very often I stumble upon a problem and when looking for solutions i'm always like "WTF? It can't be **that** complicated to do X". But.. in C it usually is :( I really like the language so far but there are just so many questions that don't have *simple* answer, like "what do I do when I need a *list*", makefiles, an easy to do easy unit testing. I mean seriously?! Write the tests, convert the tests to a valid c file, compile the test, adjust the makefile...
You seem to read into signed char variable, and then writing it as unsigned int. That way everything above value of 127 is messed up. Edit: Quick fix would be to read fgetc into "unsigned char" or "int". I would recommend the second option, since fgetc() will return EOF (it usually is -1) when it reaches end of file.
I was reading it into a "char", which I'm guessing is signed by default. When I change it to an int, nothing happens, and when I change it to an unsigned char, there's a seg fault... (After fgetc is read into the char, the char gets put into an array of chars, or rather, a space in memory for which I've declared a char pointer)
Show us some code, please :)
Here's the main function of the code, the one that copies the info over #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void mirror(char *, int); int main(int argc, char *argv[]) { FILE *input; // the input file that is the original bmp char *buf; // the pointer to a buffer that stores the bmp in memory int bufs; // the size of the buffer char c; // a single character of the bmp int i; // counter if (argc &lt; 2) { printf("This program requires a bmp file to run.\n"); exit(0); } if ((input = fopen(argv[1], "r")) == NULL) { printf("An error occurred opening the file.\n"); exit(0); } fseek(input, 0L, SEEK_END); bufs = ftell(input); if ((buf = (char *)malloc(bufs + 1)) == NULL) { printf("Unable to allocate sufficient memory for bmp.\n"); exit(0); } rewind(input); i = 0; while ((c = fgetc(input)) != EOF) { buf[i++] = c; } mirror(buf, bufs); // create mirror image of bmp return 0; } 
While most of the time you will see char being signed by default, this is not always true. There seem to be platforms where it is defined as unsigned. If I remember correctly ARM is one of them.
Change type of `c` to `int`. `fgetc` returns an `int` not `char`. Also, you get segfault for `c` being `unsigned char`, because as I said that won't work well with `EOF`, and your loop never terminates. Why? `unsigned char` stores values 0-255. `EOF` is -1 so `unsigned char c` will never be equal to -1. If changing `c` to `int` doesn't solve your original issue, then you have another bug in `mirror()`, but then we would have to see it as well to comment on it. Edit: There are some improvements you could do to your code. For example I would replace that loop with fread().
You can indent your code so it's syntax-highlighted Have you heard of fread? You should read with fread and write with fwrite (I couldn't find your problem) I couldn't see anything wrong with your program &gt;.&lt; (If you are not using linux, you should open the file as binary with a "ra" mode). Why don't you just test "open a file and copy it to a new file"
If you declare an array with 10 elements, the legal indices that you may access are 0 through 9. You have numerous buffer overflows because you try to access `mailBox[10]` and even `mailBox[11]`, both of which are out of bounds. 
I'm not 100% sure about ARM but I am sure PowerPC uses unsigned char by default since I use a PPC daily for C programming.
Also consider doing something like: const int NUM_BOXES = 10; int boxes[ NUM_BOXES ]; for(i=0; i &lt; NUM_BOXES; i++) { ... } to avoid issues with magic numbers, &amp;c.
It was whatever Gumstix uses. I remember this because I having issues with code that was storing `getopt()` output in `char`. The code worked perfectly fine when running on x86, but it was crashing (I think) on Gumstix.
Experiences may vary. I started with C and i hate java for example. The extreme verbosity ("throwable" really?), jar files and what not drive me crazy. The tool to convert tests into C code is there for your convenience, you don't have to use it. You can write the tests directly if you prefer. Don't you have to write tests and compile / run them in one way or another in every language? Makefiles just automate some work for you. The only extra hassle i see compared to other languages is the need to compile differently for when you want to run the test or run your main program, since in C you must have only one main() in your project. I agree makefiles can be ugly but it's usually a one time investment and then the process is highly automated. For example with one hotkey in my editor (that runs the test target on the makefile), it converts my easy to write tests into valid C code, compiles the test along with the rest of the project, collects test coverage stats and outputs them in html format. Doesn't get faster than that, once you invest some initial time in creating the makefile. (which i use as a template for every program anyway, so the edits are minimal)
First, I'll plug /r/learnprogramming. it's really more of an apropriate forum for these questions. Now to the question at hand. Here's the problem: Ctl+D is not EOF. Ctl-D at the beginning of a line (or when the input buffer is empty, rather) is interpreted as the EOF character as a bit of magic to allow the terminal to be treated as if you actually were reading a file. Pressing enter also typically flushes the input buffer. when the buffer is flushed, control is passed back to your program which can then process what has been entered. Let's look at a few scenarios that should show what you're seeing: 1. "1 2 3\&lt;ctl+d\&gt;" 3 ctl+d required 2. "1 2 3 \&lt;ctl+d\&gt;" 2 ctl+d required 3. "1 2 3\&lt;return\&gt;\&lt;ctl+d\&gt;" 1 ctl+d required Case 1: \&lt;ctl+d\&gt; #1 flushes "1 2 3", 1 + 2 is read in your program. It doesn't do anything with the 3 yet because it hasn't seen that you're not going to continue to enter that number. if you were to enter "1 2 3\&lt;ctl+d&gt;1\&lt;return&gt;", the 3 and 1 are unseparated and you've actually entered 31. So it waits, leaves the 3 to be processed later. The second \&lt;ctl+d&gt; tells the program to go ahead and process the 3. the *third* time, there is an empty buffer save \&lt;ctl+d&gt; and EOF is returned. The second and third cases become trivial with this understanding. Case 2: Basically the same as case 1 but the 3 is processed at the first \&lt;ctl+d&gt;, leaving the buffer empty. the second one sends EOF. Case 3: The \&lt;return&gt; flushes the buffer, and \&lt;ctl+d&gt; is interpreted as EOF. [This answer](http://stackoverflow.com/a/1516177) on stack overflow addresses the same problem. tl;dr: you're doing it right, you just need to understand how terminals work. try "$ echo -n 1 2 3 | ./yourprog".
Ctrl+D needs to be at the beginning of a line to be interpreted as EOF. Your loop will run forever if there's some invalid characters in the input -- you could write it a bit more defensively as while (1 == scanf (...)) or use a switchblock and report error if it returns 0 instead of EOF.
Oh my goodness, thank you so much! That perfectly explained what I was having issues with. Is there a better way to do input, rather than using a scanf? I have begun to become frustrated with using it, and I have to assume there is a better way of doing things...
I hadn't thought of writing the while like that. Thanks!
For the level of program you seem to be working on, scanf is going to be your best bet. I'm guessing you don't have to worry about weird error conditions or anything based on the level of course this seems to be. There are libraries out there that do more robust IO, but they generally will require quite a bit more work to get functioning properly. It really looks like you're on the right track already though, so just keep up what you're doing. if you are using a *nix to do this, I suggest putting your test input set into a file then piping it into the program. it will save you some time and is less error prone. I suspect you'll also see the behavior you expected.
Saw this on HN, tested it with GCC. I'll copy + paste my response from there: Doesn't seem to work for me using GCC 4.7.2. flags: -g -Wall -Wextra -std=c99 -pedantic (also tested with -std=gnu99) The following code compiles and runs (for me at least) with no errors. Tried with both stack and heap allocated arrays of various sizes. #include &lt;stdlib.h&gt; void foo(int array[static 10]) { (void) array; // suppress unused var compiler warning return; } int main () { int *x = calloc(10, sizeof(int)); int *y = calloc(9, sizeof(int)); int *z = calloc(11, sizeof(int)); foo(x); foo(y); foo(z); foo(NULL); int a[9]; int b[4]; int c[11]; foo(a); foo(b); foo(c); return 0; } Essentially, it's a Clang-only feature.
It is in the standard though: &gt; A declaration of a parameter as array of type shall be adjusted to qualified pointer to type, where the type qualifiers (if any) are those specified within the [ and ] of the array type derivation. If the keyword static also appears within the [ and ] of the array type derivation, then for each call to the function, the value of the corresponding actual argument shall provide access to the first element of an array with at least as many elements as specified by the size expression. ISO/IEC 9899 6.7.5.3 bullet 7
[cexcept.h](http://www.nicemice.net/cexcept/) is an example of this type of usage. It's worked well for me in a project.
I think you mean, essentially this is yet another place where GCC doesn't follow the C spec. You come off as trying to put down clang when it's pretty clear GCC has the defect.
Not dissing Clang at all. I haven't ever used it - what basis do I have to put it down? I'm simply observing, not judging.
"Standard" is quite the loaded term. You have web standards like HTML5 that are partially implemented everywhere, you have MPEG's huge set of standards which can encode virtually any video signal in millions of different ways, yet only a good dozen or so see consistent usage (and thus those are the ones that are implemented), you have encryption standards which only OpenSSL is brazen enough to attempt to implement all of, and the list goes on. "Standard" doesn't mean "good." Very few compilers implement all of C99, even now in 2013. Furthermore, that keyword being used in that context doesn't even make a lot of sense; they simply used it because it's the closest to the meaning they wanted and it's virtually impossible to add a new keyword to C with all of the existing codebases.
Learn your 'if' syntax. (Amongst other things.)
I think the problem is that your parent process needs to wait for its child to terminate. Look up the wait function in man pages.
On the one hand, this is an impressive tool and analysis. On te other hand, it is moderately dickish to ind flaws in oss and not fix it. Good teaching opportunity however.
The folks who make Cities XL really need to run their code through a static analysis tool. It might help them fix the memory leak that has plagued their codebase for the last 4 or so releases
Oh, it's that time of the month when we get another PVS Studio ad.
How can I fix the formatting?
So change to %f and float type? 
A problem is that after an 'if' (or an 'else') conditional the results are *single* statements. If you want more than one line of branched code, all your statements must be enclosed in curly brackets otherwise your program flow may not be what you intend. Especially if another 'if' is included within your 'else' block. Personally, I make it a practice to always enclose my branched code in brackets, even if there is only one statement within the branch. A lot of others do not. Thus: if(x == 1) { a = 0; } else { a = 10; b = 100; } That said, I can't really see what you think the problem is with this particular program. 
If you look at the little input-text window in reddit, you will see a very tiny 'formatting help' link. Click on that. but the relevant information just now is :"Lines starting with four spaces are treated like code" So just add four spaces or more to each line of your code and it will show up properly. 
It does not have to be single statements, I figured it all out. 
A few things: I don't understand what you're asking. I think you're having a problem because the poop variable doesn't have any relationship to the rollavg variable. Heck, is totroll ever initialized? It's a lot easier to figure things out when you format your code properly. To retain your code's formatting in Reddit make sure each line has four leading spaces. It will look correct, like so: #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define win 0 #define loss 1 #define rollagain 2 double maxrolls, roll30, totroll; int main(void) { int n, i, wins, lose, gamestatus, winrow, winnum, loserow, losenum, poop; double winavg, test, rollavg; int PlayCraps(); wins = 0; poop = 0; printf("poop: %2.0f\n", poop); lose = 0; winnum = 0; srand(time(NULL)); printf("How many games would you like simulated?\n"); scanf("%i", &amp;n); for (i=1; i&lt;=n; i++){ gamestatus = PlayCraps(); if(gamestatus==0){ wins++; } else{ lose++; } } winavg = (((double)wins)/n)*100; rollavg = totroll/n; poop = 0; printf("Wins: %i\n", wins); printf("Loss: %i\n", lose); printf("The probability of a win: %3.4f%% \n",winavg); printf("The number of games that had more than 30 rolls: %1.0f\n", roll30); printf("The average number of rolls: %3.4f\n", rollavg); printf("The maximum amount of rolls in one game: %3.0f\n", poop); printf("The longest sequence of consecutive wins: %2.0f\n", poop); printf("The longest sequence of consecutive losses: %2.0f\n", loserow); return 0; } 
It's tough to understand your entire question, but there is one glaring error related to the output of your 'poop' variable. You have defined 'poop' as an int, yet your printf() calls refer to it as a float. You are likely seeing the incorrect value printed for 'poop' because of this. Use '%d' instead of '%f'.
Ya that was a change I made while trying some things, thanks though, I corrected it but it still is wrong for some reason. I have tried a new way of dealing with the problem also so I need to repost.
totroll is global and poop is just a placeholder I made. The problem is that for some reason the value will be the same all the way through them and I replaced rollavg with poop just to see why it is happening. If you look it is only ever given 0 so why does it produce anything else?
totroll is never given a value, i.e., it's not initialized. It sounds like you've been making lots of changes to your code to figure this out. Can you post your original code?
As to your latest change and reported error (winrow or lossrow being invalid), you are not initializing numwin or numloss to 0 in PlayCraps(). Whichever hits first is going to have an invalid value when you hit the (if gamestatus == x) checks near the end of the function. Local variables do not default to 0.
totrolls isn't initialized, so it gets a junk value. When you create your variables it's a good idea to set the initial value. In this case, set them all to 0 when you create them.
&gt; totrolls isn't initialized, so it gets a junk value. totroll is a global and is automatically initialized to 0.
#No, this has weird behavior in certain circumstances. For example, with this code: #include &lt;stdio.h&gt; int temp; double temp1; int main(void){ printf("Hello %f\n", temp); printf("Again %f\n", temp1); return 0; } You get: Hello 0.000000 Again 0.000000 #When you change the code to: #include &lt;stdio.h&gt; int temp; double temp1; int main(void){ printf("Hello %d\n", temp); printf("Again %d\n", temp1); return 0; } You get: Hello 0 Again 1602261592 
C output formatting is a bitch. ;-)
In the second example you are printing a double as a decimal integer without an explicit cast. There is no guarantee that a zero-valued float will be stored in memory as 0. The 'temp1' variable has a value of 0.0 in both of your examples.
Following on from this, use Hungarian notation to some degree to give you hints about variable type and scope when they're used in the code. eg. Define: VALUE Global float: g_fValue Static const bool: s_kbValue Local int: nValue Global array of strings: g_aszValue etc. It takes a little while to get into the habit, but you'll understand your code and other people's much quicker with this approach. 
Help! This is grammar makes no sense.
Wow I didn't even notice the extra is in t he title untill you mentioned it 
A useful tool for finding these sorts of issues: [valgrind](http://en.wikipedia.org/wiki/Valgrind). It will track memory locations and print warnings when uninitialized data is used, among many other useful things.
Call `srand()` only once, at the start of your program. The function `time()` has a resolution of one second, and it will take far less time than that to evaluate `card()`, so you're just resetting (reseeding) your random number generator with the same initial value. The quality of your system's `rand()` function is not guaranteed, so if you need good quality randomness you should consider a different implementation.
There's also cppcheck, it's pretty good as well!
the // comments are evil slide is a bit contrived. the prank slide looks like something to do at work one day to annoy a colleague. I like it.
Mildly interesting Slide 3: Yes, no surprise. Slide 4: I'm intrigued (and slightly repulsed) by this recycling of the `static` keyword; maybe this is worth a closer look... Slide 5: The dreaded multi-byte character constant. No idea why it's in the language. Slide 6: Yeah, yeah; that's old, stupid and boring ;) Exists to frighten the children, I guess. Slides 7-9: Aliasing. Sigh. Actually, this is a tricky one; guess I need to make more use of the `restrict` keyword, suspect I might get bitten if I don't take care. Yes, this is a valid murky corner. Slides 10,11: I'm missing the point here. Slide 12: The joys of C type declarations! Slides 13,14: Couldn't care less; don't write such ridiculous code! Slide 15: A not very interesting relic. Bit surprised the writer didn't mention K&amp;R function declarations; think they're still valid C99 and *much* more of a WTF. Slide 16: Cute. Is this a *language* issue? Slides 17-19: Eh? Sorry, completely failing to grasp the problem. Define values for initialised data in one place; what else do you expect? Slide 20: Meh. Same reaction as for 13/14. Slide 21: Wow! Is that a hexadecimal floating point number I'm seeing there? Had no idea. Slide 22: Hahahahaha. Slide 23: Are these good books? Confess I've not seen any of them.
Most of the "dark corners" (especially relating to junk like comments and ++++'s) are not out of the realm of expectation as it is defined and predictable. While the behavior is amusing to observe anyone who writes code like such is obviously doing it for the purpose of either showing off or pissing someone off. 
Slies 10, 11 is just showing the difference in assembly output for up vs down, and the fact that the second reduces to 7 instructions vs 9. If this isn't compiled with optimizations, though, then it's really not worth pointing out. Expert C programming is good, depending on your level of knowledge, although it has a liberal amount of history sprinkled throughout. If you knew a majority of these, you probably wouldn't learn -that- much from it. I haven't read the other two.
It sounds like your original question has been answered, but something you might want to try once you've gained a little more experience is a "bag" system... Basically, you have an array of numbers between 0 and 51. Each number represents a card in the deck. Then, instead of randomly generating cards, you shuffle the array (this can be done using the qsort library function). Now you logically have a shuffled deck of cards. Once you've "drawn" every card, you simply re-shuffle and reset your index to 0 again. This is actually the same technique used by all modern versions of Tetris (2005 and onwards) to randomly generate pieces/tetrominos. I wrote a simple example here: https://gist.github.com/cleure/5122382
Yes. If someone were to do this, they should add parentheses at the very least. And if someone really were to do this, they should stop and think about it because they shouldn't. That said, Maximal Munch is pretty commonly used by lexers while matching tokens.
Point of curiosity: gcc 4.7.2 on x86 will double load int *restrict z, while clang 3.1 will reuse the register. Qualifying "x" with restrict (in addition to "z") convinces gcc to load it just once. Is one of these compilers wrong?
What's so WTF about K&amp;R function declarations? I don't use them but I've seen way worse than that. Actually I even kinda like them.
Well, my main problem, apart from the redundancy (every name appears twice) is the complete absence of prototypes ... and hence no prospect of type checking at argument call. For example: f(a); /* Who knows what a is, we'll find out */ test(a) int a; { return f(a); } /* Seems ok */ f(a) int *a; { return *a; } /* Oh well */ Note, just for fun, the gratuitous use of implicit return type int, another relic we'd be better off without. This code compiles just fine...
 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; static const char *cards[] = { "Ace", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King" }; static const char *houses[] = { "Hearts", "Diamonds", "Spades", "Clubs" }; #define count(X) (sizeof(X)/sizeof(*X)) void card(void) { printf("%s of %s\n", cards[rand()%count(cards)], houses[rand()%count(houses)]); } int main( int argc, char ** argv ) { srand(time(NULL)); card(); card(); card(); } 
No need for the `#include &lt;unistd.h&gt;` though
Queued up some tabs, then: &gt; You've been busy! Looks like you've hit your 2 article limit. Really?
and after 2 articles.... Edit: A comment which makes more sense when you realize that I thought it said "hour" not "article" Edit++: I shall redeem my poor reading skills with this article which gives a quick overview of the changes: http://blog.smartbear.com/software-quality/bid/173187/C11-A-New-C-Standard-Aiming-at-Safer-Programming
That, and syntax highlighting completely breaks on mobile devices. It might have been an interesting article if they'd just let you read it!
Pointers = easy. Pointer syntax in c = bad.
It'd probably help if you posted your code.
Well we *would*
You are dereferencing a pointer that isn't pointing to where you think it is.
[http://i.imgur.com/pgL8KJj.jpg](http://i.imgur.com/pgL8KJj.jpg) This is the first program. [http://imgur.com/MBCfcv2](http://imgur.com/MBCfcv2) And the second program.
I posted the code to another comment if you'd like to take a look
I posted the code to another comment if you'd like to take a look
Have you tried using gdb to debug your code? You can set a break point where you think your program may be segfaulting and walk through it line by line. To use gdb, recompile your code but add a -g flag. Run gdb with your compiled program name as the argument. If you think your bug is around, say, line 73, enter "break 73". Then, you can begin your program by typing run (if your program takes arguments, put them after run). gdb will run your program up to the break point you set, after which you can step through line by line by entering "n" (for next). This will let you see the exact spot where your error is. The first thing I always check when I reach a segfault is that I don't have faulty logic with array loops. You're likely dereferencing something that doesn't exist, like an array out of bounds error or a pointer that wasn't properly initialized. 
So many pointers that could be blowing up. Program 1: line 14, that is going to dereference *a before you check to see if a is null line 102, I'll assume a isn't null there, but maybe line 106, this is probably fine, but there are better ways to do this Line 70, more importantly, this function could potentially not return anything, so when you later dereference the copy that you didn't make, you are in uncharted territory. Program 2 Line 11, this function doesn't return, also, why are you attempting to return a pointer to a pointer? Line 11 (again), don't take those arguments. They won't work. Not how you are using them on line 21 line 21, you have two pointers to pointers, not a two dimensional array. I'd wager this is your problem line 34, unless this is ... Or any of the other times you do that. You are using ** wrong. Or, I am way behind on current standards... that could be the case too. Either way, clean those up and double check every pointer going into and out of a function is not NULL before you use it. When you create a pointer, set it to NULL immediately (for safety). Once you do that, that should clean up the bulk of any potential problems and we can look for any real problems remaining. And use Calloc instead of Malloc. It will initialize the memory to 0 for you (also useful).
Bah, calloc is useful though. :( Good luck. Just remember that pointers are never to be trusted and you'll be fine. Especially once you think you understand them. 
You are off to a good start. You have a data structure. You have a function to allocate memory and initialize it. And, you have an event loop. Sure, they need some filing in, but it looks like you are thinking about the problem and are headed in a right direction. Here are a few suggestions for cleaning up what you have so far: * Move DoCleanUp() above main(). C needs to see the function before it is called. You could achieve that by moving the function above where it is called or by forward-declaring it. It's really just simpler to move the function up. * Always initialize your variables. In main() you declare a variable called keepRunning, but you don't give it a value. You then check to see if it is true in the statement "while (keepRunning == true)". You need to set keepRunning to true before going into that loop. Change your declaration of keepRunning to a definition: bool keepRunning = true; * In DoNewCommand() you allocate some memory. If that fails you simply return. You need to signal an error. If you don't, your main program will keep running and the user (and the program) will have no indication that the allocation failed and that the data was lost. * I'm not sure if it is just a result of how you pasted the code, but the #include statements at the top of the file are missing their # characters. They should read (don't indent the lines...I just did that here for readability): \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; \#include &lt;stdbool.h&gt; \#include &lt;string.h&gt; * BONUS POINTS: Read about the strcasecmp() function. http://linux.die.net/man/3/strcasecmp It allows you to make your event loop simpler (and more flexible).
One approach to problems like this is to take it in small steps. It seems like you have several things to implement: * Read input. * Allocate memory dynamically. * Store album data. * Retrieve album data. What about attacking the problem in small pieces? (1) Write a main event loop. When the user enters a command, echo the command. If they type QUIT then exit. Get that working smoothly. (2) Implement the LIST command. Create a global array variable (it seems that it is OK to use globals for this program) that has several albums hard-coded into it. When the user types LIST have that function print out what is in the global variable. Don't do any dynamic memory management yet. Just use a static array. This will be an important function to have up and running early because it will help you visualize what the user will (later) enter manually. (3) Write a first version of the NEW function. For your first version, ask the user for all of the input fields and just echo them. This makes sure that you are reading in each of the values correctly. Don't try to update the global array. Just focus on getting the reading in of the user's data absolutely right. (4) Connect the NEW function to the existing global array. Allow it to enter values into that global variable. Now you can test NEW and LIST together. This also makes sure that you have the album counting working properly. If there are two albums and they enter a third then LIST had better show three albums. (5) Once you have all of those parts working, remove the global array. Replace it with dynamic allocation. This is likely to be the hardest part of the process (if you are new to dynamic memory management). But, you can approach it with confidence because you know that all of the rest of your program works.
Ha, that's the problem. I have difficulty understanding some of these things. Basic commands, printf, scanf, logic... I understand that. Malloc and calloc pointers.. These are the things I'm still trying you grasp.
1) pastebin/gist/etc. Many of these give you syntax highlighting and formatting help. Reading arbitrary code pasted into reddit is almost always a failboat. 2) /r/learnprogramming exists to help answer these types of questions. Good luck.
[Program 1](http://codepad.org/HfA2SYZO) [Program 2](http://codepad.org/TI80aBlT)
I looked back at the code, and for line 11, I have to take those arguments. I am supposed to write in the function using those arguments given. For line 21 I'm not sure what you mean exactly, what it's supposed to do is place the value of A at different locations in the matrix times the value of B at another location and place that into tempProduct.
'double **' means "A pointer to a pointer to a double" 'double [ ][ ]' means "A two dimensional array of doubles" Internal, all arrays are one dimensional and arrays and pointers are kind of the same exact thing. Which means you can do things like this: double *p; double a[10][10]; p = &amp;a[0][0]; d = *(p + 3 * 10 + 2) and 'd' would then be equal to 'a[2][3]' (or [3][2]... one of the two. can't remember which right now). That is also about how 2 dimensional arrays are handled. For multi dimensional arrays, the compiler does some multiplication to figure out where exactly you are looking to go. So something along the lines of "index = x * numColumns + y" On line 21, you have a line that reads as: tempProduct = A[i][j] * B[j][i]; where A and B were defined as 'double **'. The compiler has no idea ho w large the array is so it doesn't know how to adjust. It's missing 'numColumns'. Make sense? Honestly, I'm a little surprised that there aren't warnings when you compile. Are you using the -Wall and -Werror flags? 
So you're saying I should find a way to define the size of each array, even though I don't know that myself?
Well I was assigned to write the function given that function definition. It's my job to write in the function itself. This file along with the library I defined, is put into a test program with test cases in it. I'm not able to see or know what the dimensions or the values inside the matrix are. I was also going under the assumption that the size of the array is given by "int n" in the function. I was told that it's a square array so that both the columns and rows would be equal.
That was my assumption (that it was a square array). And when m and n are provided it's a rectangular array. That's why I say that **you** should know the size of the array but that doesn't help the compiler. Like I said though, the ** is throwing me though. Does the function definition have any comments describing the input parameters?
In this exercise you will write several functions that operate on matrices or two-dimensional arrays. You will place all the function prototypes in a header le named matrix.h with their de nitions in a source le named matrix.c. You should test your functions by writing a driver program, but you need not hand it in. (a) The product of two square n  n matrices: C = A * B is de ned as follows. The entries for C are: Cij = the sum of Aik * Bkj where 1  i; j  n and cij is the (i; j)-th entry of the matrix C. Write the following function to compute the product of two n  n square matrices: double ** product(const double **A, const double **B, int n); This is what I have. If you can make sense of it, props to you. I still have seg fault issues trying to test it with the webgrader, the program that is testing these files. I'm honestly not sure on what to even try now. I can try getting some more help, maybe get at least one program working.
 double ** product(const double *A, const double *B, int n); That's not what you have in your code. I feel slightly more sane now. Switch up your function signature and review my comment above that looks someting like '*(p + x * n + y)'. Still not sure about the double ** return value, but baby steps. Though, on that note, you should return something from that function (i don't recall you doing that currently).
I switched it back to "const double *A, const double *B" now. I currently have it as "return dotProduct;". I'm assuming this is right because if I enter anything different, it gives me a bunch of errors. EDIT: Yeah, I looked back and I don't know why it didn't post earlier, but it does want the ** for the function definition arguments. If I try anything else, the program puts out an error code complaining.
It is quite clever. I'm not going to cover the whole thing, just a few bits. I'm not sure I could describe the whole thing. I broke it down some, but not completely. Here are some highlights: * Underscore _ is a legal variable name. This is pretty standard in obfuscated C. * It uses several instances of the [commutative property of arrays](http://c-faq.com/aryptr/joke.html). Again, that's pretty standard. * **-~** takes the negative of the two's compliment of the value which has the effect of adding one to that value. So, **-~i** is equivalent to **1+i**. * The first statement inside main, **\_\^448&amp;&amp;main(-~_);**, is actually a loop that recursively calls main until **_** equals 448. It works because when **_** equals 448 the call to main won't be made (448 exclusive-ORed with itself equals zero and there is no way for logical AND with zero to be anything but zero so the evaluation gives up). * I don't know if it was intentionally confusing, but I had to look up the order of precedence for some operators. That may just be my inability to remember things though. If you want to know more about how it's working I suggest you do the same thing I did. Start with the original and make sure it's working in your development environment. Then start pulling the code apart, breaking expressions out and refactoring so it makes more sense to you. Here is where I quit working on it. I'm sure a lot of the variable names I've got here don't really represent what the value really is (or don't make sense outside of my head), but the code still works and looks a bit less confusing. char *dots = "&gt;'txiZ^(~z?" - 48; char *shiftStr = ";;;====~$::199"; main() { int i = 448; while (i) { int col; int dot; int charPos; int digit; char *chr; int shift; int shiftIndex; int c; i--; col = i % 64; charPos = i / 8 % 8; chr = __TIME__ - charPos; digit = dots[chr[7]] + 1; shiftIndex = ((i * 2) &amp; 8) | (i / 64); shift = shiftStr[shiftIndex] / ((i &amp; 2) ? 1 : 8) % 8; dot = 32 | (digit &gt;&gt; shift &amp; 1); c = col ? dot : 10; putchar(c); } } If I were going to keep working on it I'd convert the character arrays to binary and look into how the character bit map works. I hope that helps a little. Edit: clarity 
OK, it seems that I may be far too unpracticed in C and missing some details, so i'm going to link to this: http://stackoverflow.com/questions/4408636/multiplying-two-arrays-in-c Too be honest, I don't think I've ever seen the array brackets used like this, but that is a poor excuse on my part. Ignore a bunch of stuff that I said earlier (which is correct, but applies in a different context), study that and you should be able to clean up the rest of your code fine
Don't worry. This is isn't the worst thing to happen to me today.
Yeah but then there's the issue of if you change the variable type, you'll have to go around your code changing all the variable names.
do you have no C language reference?
This is commonly referred to as shorthand if. Given: Var = x ==2 ? 4 : 5; Means the same as: if(x == 2) { Var = 4; } else { Var = 5; } 
In your case, this code is the same as: if(player == 1) { board[row][column] = 'X'; } else { board[row][column] = 'O'; } See IAmWillIAm's explanation.
With a decent IDE this argument doesn't hold. Think about how often you change variable types. Now think about how often do you come across a variable and want to know its type. Most of programming is understanding existing code, so make it as easy as possible on yourself.
I didn't check that this fixed it, but in matrix.c, there are several function where you use the variable i as an index (addToRow and multiplyToRow). You declare i, but you do not initialize it. int i; while (i &lt; var){} This code is not stable, the value of i will change every time you run your program. instead (you actually did this in the other functions): int i = 0; Also, when you declare a 2-dimensional array in C, you want to first malloc 1 column, then malloc the rows: void declareMatrix(int m, int n){ int *matrix = malloc(sizeof(int) * m); int i; for(i = 0;i &lt; n;i ++){ matrix[i] = malloc(sizeof(int) * n); } } You must free your matrix in the same way, otherwise you will have memory leakage. This is a great example of a situation when a For loop is preferred over a while loop--you have a set number of iterations and you are increasing by a set amount each time. Hope this gets you started.
Unless you are required to proceed in that manner, I would recommend fread(). BMP files have a specific header that will allow you to calculate the file size. This binary function will let you specify the location, the size, the number of times data should be copied, and of course, the file. FILE **image; *image = fopen(file, "r"); fread(&amp;aByte, sizeof(unsigned char), numBytesToRead, *image);
Or, if you really don't want to learn how to use "gdb" (which does have a rather steep learning curve and will require at least an hour or two to even get through the basics), litter your code with diagnostic output. Yes, it's a lot of make-work. But, Shellmastery is right. Don't change things randomly until something seems to work. You will never get mastery over the language or the machine doing it that way. 
Because we are all masochists at heart?
Because it would have to be designed by a committee, and that way C++ lies. You can't create a small, high-performance data structure library that'll suit every situation, as much as the C++ lot try to. I tend to roll my own as and-when, and it generally leads to much smaller, tighter, faster code for the sake of a little pain once a the beginning.
But it definitely won't be as well tested as open-source/published code.
I guess what surprises me is that nobody else has put together a more definitive library with all these generics contained in it. Would you agree that often these files are cherry-picked from various places and cobbled together in a typical application?
Writing in C is like moving a beach one grain of sand at a time. It is a great language though.
&gt; Would you agree that often these files are cherry-picked from various places and cobbled together in a typical application? Sure, if they meet the license and the use case, why not? What harm is there in doing it? &gt; I guess what surprises me is that nobody else has put together a more definitive library with all these generics contained in it. There are quite a few of them. Apple has one (the CoreFoundation set of libs). Apache has one for their software stack. GNOME wrote one called GLib. nginx has a core lib. And of course you've already mentioned the BSD ones. Which one of these is "definitive?" Does a high performance web server really want the same hash table as your desktop calculator app?
Did anybody for real used linked list for a programm? And i mean not only for practice.
What is wrong with linked lists? As long as you know their algorithmic constraints they are fine. Unless you want to get really nittygritty and compare pageallocation, cacheing and the like in which case we need to know more about the actual problem to say more.
I use queue.h for lists, Lua's hash table stuff for hashing and apr for portability and the better string library for string manipulation. I reuse all this stuff for pretty much every project.
For things that you know are going to be in linked lists or binary trees, it's often easiest to add the pointers to the struct itself. It saves memory, and more importantly, a level of indirection, compared to creating a special node type that stores a pointer to an object and another pointer to the next node. typedef struct foo { int bar_count; /* whatever else */ struct foo* next; } foo; ... for(foo* p = get_foo(); p; p = p-&gt;next) { do_stuff_to_foo(p); } [Sglib](http://sglib.sourceforge.net/) is a library of macros to manipulate data structures built like this. From its website, it supports: * sorting arrays * manipulating linked lists * manipulating sorted linked lists * manipulating double linked lists * manipulating red-black trees * manipulating hashed containers
C is designed by committee (well more designed by compiler), they just know when to say no.
The problem with implementing all of these is what kind of hash, etc? Should it be in-place or Fast? The interface is usually not the algorithm, in example qsort in glibc is introsort. 
Thanks for the info.
first off if (Numbers[i]==Numbers[i]) is always true, and Numbers[i]+1; does nothing Try this void main() { int Numbers[7]; // changed 6 to 7 Numbers[0] = -1; int low=1; int high=50; int i; srand(time(NULL)); for(i=0;i&lt;7;i++) { Numbers[i]=rand() % (high - low +1) +low; printf("The numbers are: %d \n",Numbers[i]); if (Numbers[i-1]==Numbers[i]) Numbers[i]++; } } now your 6 unique numbers will be stored at Numbers[1] rather then Numbers[0]
You can't remove all duplicates like this. e.g #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int num[6]; int i; srand(3); for (i = 0; i &lt; 6; i++) { num[i] = rand() % 50; if (num[i - 1] == num[i]) { num[i] += 1; } printf("%i\n", num[i]); } return (0); } returns: 46 35 18 40 25 40
Cleaning it up so it's readable (also changed a few things stylistically to my own personal preferences, don't worry too much about those): #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main() { int Numbers[6]; int low = 1; int high = 50; int i; srand(time(NULL)); for(i = 0; i &lt; 6; i++) { Numbers[i] = rand() % (high - low + 1) +low; printf("The numbers are: %d\n", Numbers[i]); if(Numbers[i]==Numbers[i]) { Numbers[i]+1; } } return 0; } So, some notes: #include directives require the pound sign (#) before them. This indicates that it is a C preprocessor directive rather than part of the actual C code. In the case of #include, it's sticking in code from the relevant header (.h) file, often to indicate that some functions are externally defined or something like that. I can go into more detail if you need information. I don't really follow what you're trying to do in the code. What you've actually coded for is the following: &gt; for(i = 0; i &lt; 6; i++) { &gt; Numbers[i] = rand() % (high - low + 1) + low; Store a random number between the high and low values in the current array spot. All good. &gt; printf("The numbers are: %d\n", Numbers[i]); Print the random number you just assigned. &gt; if(Numbers[i] == Numbers[i]) { This will always return true. You're asking if A == A. It always will. &gt; Numbers[i]+1; This is a completely valid expression. It adds one to the current value in Numbers[i]. And then it discards that value, because you don't tell it to do anything with it. If you want to increment the value, you can use any of the following, in order of conciseness: Numbers[i] = Numbers[i] + 1; Simply take what you're doing and assign it back into Numbers[i]. Numbers[i] += 1; This is shorthand for the previous suggestion. Statements of the form "X (op)= Exp" are shorthand for "X = X (op) Exp" where X is a valid place to assign a value, (op) is any operator (+, -, *, /, &lt;&lt;, etc.), and Exp is any valid expression that evaluates to a number that can be used in that context. Numbers[i]++; This final possibility is the most straightforward and most likely what you were going for. This is the increment operator, and it does what its name implies. It increments what it's next to. There's prefix and postfix incrementing, which we can go into, but right now all you seem to need is to increment, which both will accomplish. So I'm interested to find out what you're trying to do, but I hope that helps.
 num[i - 1] will be num[-1] on the first pass through the loop
In checkW() if a three square match is found set winner to the character that matched.
The problem is likely in checkw. Logical error. Check your last block for instance. You're looping through. If you find a match set the current x/y position to win. The result of this is that if there is a vertical win(last if block) the winner will always be the color placed at 3,3(index 2,2).since this is the last point to be checked on. Rethink your logic when scanning for a winner ;) 
Thanks for sharing 
I'm sorry I can't be more directly helpful, but perhaps this is a good opportunity to get to know gdb?
I'm familiar with it. There's nothing obviously wrong except for the fact that `head = head-&gt;next` doesn't ever become `NULL` as it should. I only went through it once this morning, but I'll probably go through it again later tonight.
I think your `append()` and `filter()` function are fine. I'm not sure why you have an infinite loop but one problem which I can see straight away is that you are trying to create a linked list of `string literals` which would ideally have a statically allocated memory location in the data section of the program. So each `elem` of the list is still pointing to the same memory, even when you do a `filter_list()`, and once you call `empty_list()`, you're calling `free()` on those elements inside the `remove_node()`. It is undefined behaviour to try to alter the contents of a string literal or in your case, freeing the memory.
your problem is here https://github.com/sigmavirus24/c_libs/blob/master/list/append.c#L5 your last node is a static and you have two list with same last removing removing the static remove the bug, you should have a list struct which contain head and last
The problem is here: [`append.c`](https://github.com/sigmavirus24/c_libs/blob/master/list/append.c#L5). You use a static variable to capture the tail of the list for a reuse in subsequent invocations but notice that when you call this method twice for different lists, the second invocation will append a node to the list from first invocation. `filter_list` uses `append` internally and in effect each call to `filter_list` in your test program appends `'b'` to the list it's going through. Not really a cycle but rather [something like that](http://26.media.tumblr.com/tumblr_lloagiRYu81qfjjkvo1_500.gif). If you want to speed up append by capturing some internal state you can try to make this function reentrant, like `strtok_r`.
I actually never free the elem member of the struct in the library.
Actually that's exactly a perfect gif for what I was seeing in gdb but couldn't exactly explain. Thank you. This is the reason I'm writing this stuff. So I can learn through these horrible mistakes.
Yeah, having just come back to this project and structure I was wondering myself why I didn't have a list structure. Thank you. I'll try this out later tonight to confirm it.
My favorite C pointer fact: any pointer can be cast to `void` pointer *except* function pointers. int main () { void *p = &amp;main; return 0; } $ gcc -pedantic tmp.c warning: ISO C forbids initialization between function pointer and 'void *' This is because on some ancient platform at some point in history function pointers were a different width than other pointers. `gcc` will only warn about this with the `-pedantic` flag. 
&gt; I wonder why nobody seems to have implemented a C compiler where function pointers are closures If they did that, it wouldn't be a C compiler any more. However, there are implementations of closures added onto C in languages like C++ and Objective-C. Take a look at [Blocks](http://en.wikipedia.org/wiki/Blocks_%28C_language_extension%29) for one nice example.
The GNU C Library allows you to implement your own [custom handlers in printf](http://www.gnu.org/software/libc/manual/html_node/Customizing-Printf.html), which seems to be what your looking for. Its non C standard though, so your code wont be as portable.
No, you can't: the resulting pair is not a function pointer and doesn't behave as such when passed to code which expected function pointers. That was my point, and is why we always have to declare callbacks with a void* context argument.
You just need another layer of abstraction to do that.
The problem with, for example, the gcc implementation of closures, is that they involve trampolines to convert a single pure code function pointer into the associated closure. As for whether function pointers could be closures within the specification of C as a language, I'm not so sure. My point is that if C allows function pointers to be different sizes from normal pointers then ... with a change to the ABI ... there's nothing stopping a function pointer carrying data baggage. Of course, the change to the ABI is not such a small point. Anyhow, this is idle speculation. Gcc has done it one way, but I intensely dislike the side effect of executable code on the stack, and there's no mechanism for allocating them on the heap, so I do my closures the old fashioned way.
You can always "make it portable" of course by instead providing your own "myprintf" function -- if you then use glibc, it's straightforward, but if you chose to use something else, you can still implement it without having to change your code (but it'll be more work)
There is an error in this article: &gt; We have the parameter list which in this case there isnt one so it is just empty parentheses `(*sayHelloPrt)()`. This could also have been written as `(*sayHelloPrt)(void)`. This is not true, the two declarations are different. The first declaration says that the function takes an undetermined number of arguments, and the second says that the function takes no arguments. Examples: // compiles OK (but won't run) int main() { void (*something)() = 0; something(1, 2, 3, 4, 5); } // does not compile int main() { void (*something)(void) = 0; something(1, 2, 3, 4, 5); }
I'm not sure what you would need to include. I suggest you try GCC instead of VS. It should build with no errors. If you don't have it you can get it [here](http://www.mingw.org/).
Sorry if this does not belong here. I was looking for rules for posting in this subreddit but could not find 'em.
I would recommend C. It is simple enough, but will teach you most programming practices you might need. It will teach you how to write your code in a readable way, handle and pay attention of many things at once, which higher level languages do for you, so most people starting with C# never really understand what's really going on, e.g. when is it better to use LinkedList and when normal List. Also, you can always expand your knowledge of C to almost any procedural programming language. K&amp;R is still pretty good. For your level, don't bother with newer versions of C.
There are two basic kinds of approach to learning C that I know of. One: learn how to do things in C, do them, see how they work, play around and see what happens. This is the approach that Zed Shaw's book has. That book makes it relatively easy to learn how to do basic things in C. You'll be told [when to use the stack or the heap](http://c.learncodethehardway.org/book/ex17.html) and you'll use them appropriately thereafter. You'll be told that [uninitialized variables have "crazy values"](http://c.learncodethehardway.org/book/ex3.html) and you'll learn to make sure your every variable is initialized before being printed. Two: learn how things in C really are, what is correct and what is not. The problem with C as a language is that it doesn't have a reference implementation like PHP and Python have, so you can't compile a program to see how it behaves and draw conclusions about the language from such experiments. You can tell your compiler to warn you when you did something incorrect, while it's compiling your program. There are other tools for that, too, like static analyzers (clang-analyzer) and run-time error detectors (-fsanitize compiler flags, valgrind). But sometimes there is no tool in the world that would be able to tell you about a mistake, because mistakes of some kinds take human brain with appropriate knowledge to notice -- then your only option is to have such brain. That's what K&amp;R 2 and the standard, in whichever version you prefer (C89, C99, C11), are for. The former is easy to read and good enough for most problems while the latter gives you nearly maximum certainty. The first approach will make you learn quickly. The second approach will make you learn correctly. You'll learn that reading an uninitialized variable causes undefined behavior, and that undefined behavior can result in anything from expected behavior, to [starting the "Towers of Hanoi"](http://feross.org/gcc-ownage/), to program termination. That there is no the stack or the heap, and that C instead operates in terms of variable's visibility scope (function, file, block, and function prototype) and object's life-time (formally called "storage durations": static, automatic, and allocated). You'll learn that the contents of s in { char s[] = "abc"; } are modifiable, while the contents of the unnamed array that p points to in { char *p = "abc"; } are not. You'll learn the difference between function declaration, function prototype, and function definition, which will be helpful to understand why main in { int main() {return 0;} } takes exactly 0 arguments and not unspecified number of arguments.
Definitely splash out [$25](http://www.amazon.com/gp/offer-listing/0131103628/ref=tmm_pap_used_olp_sr?ie=UTF8&amp;condition=used&amp;qid=1364900095&amp;sr=8-1) for ANSI C. Look at page 69 of your father's copy double atof(s) /* convert string s to double */ char s[]; { Compare that with page 71 of the ANSI book #include &lt;ctype.h&gt; /* atof: convert string s to double */ double atof(char s[]) { The duplication of the single letter variable name in original C doesn't look too bad at first. Later you will wish to make your code self-documenting with informative variable names and you will find the duplication punishing good practice. Original C is annoying enough to sap your enthusiasm. Avoid! (But keep the family heirloom in the china case :-)
I think that's an excellent approach. You'll learn some things quickly and then you can go back and fill in with a more detailed understanding of the language. Plus you'll learn about makefiles, gdb, unit tests, valgrind and other useful libraries in LCTHW. The two approaches need not be mutually exclusive.
Uhm...C is a high level language. I find it amusing how much history repeats itself as people used to have this discussion about C and ASM. **Edit:** Seems like you guys don't want to think C is a [HLL](http://en.wikipedia.org/wiki/High-level_programming_language), but sorry by definition it can be considered one. It's an incredibly thin abstraction layer, but it is an abstraction layer. True, it may be considered a lower level programming language by today's standards, but that doesn't mean it's not a HLL. Just trying to point out that history repeats itself and the languages sometimes flip which side of the fence they were on.
I like to say that C++ is twice as expressive as C, but six times more complex, three times more restrictive, and half as portable.
I would recommend Python. There are more abstract concepts inherent to the language than in C; and once you learn the concept, you can go from language to language, and from then on, it's just learning the syntax for the concepts you already know, that language is capable of expressing. If you want to write the same sort of code in C you can in Python, you'd have to write a Python interpreter in C, and write such code in Python, ran on your interpreter. As far a efficiency, Python is about as fast, and in some cases, faster; It's built upon C/C++ modules. I think by far, Python will me far more useful to you, both in and out of work, than C. There are plenty of Python projects you can contribute to as well. --- As far as C is concerned, yes, dealing with pointers is interesting, and incredibly error prone. If you're wanting to learn the special hell that is memory management, then I would say pick it up after Python. As far as K&amp;R, I would keep the book on the shelf as a memento, but C today is nothing like C of **1978**. We've moved on, we've learned a lot in 30 something years, and the style and standards of that book are barely relevant today. The book is notorious for being error prone, or the examples are inconsistent, and don't often compile, and don't comply to the library standards of today. For some reason, there's a true religious following, where the Linux kernel developers believe K&amp;R are infalliable, and even follow their *dreadful* style, as though C has never changed, which they're wrong. Pick up a book or resource on a more modern standard; I invite you to join the rest of us who live in *today*...
Allow me to echo thanks for your great reply. I've been wrestling with the same thing for quite a while. In my case, it has been between C and Python. C won. Why? Because it's cool, that's why! Thirteen years ago I got a programming certificate from a local community college, C being one of the required courses. Unfortunately, that cert didn't result in the desired job, and I bounced around the IT world for a while unable to touch code. (Not complaining, currently have a terrific job as a data analyst.) Now, wanting to make myself marketable as a programmer (embedded systems, I'm looking at you), I've rebooted my C studies. I'm going through [C: How to Program](http://www.amazon.com/exec/obidos/ASIN/013299044X/deitelassociatin), 6th edition, writing, running, and fiddling with all the examples, heavily commenting each one, and trying a couple of the problems in each chapter. I'm also chopping my way through Project Euler. As for K&amp;R, I've found the [C Programming Notes](http://www.eskimo.com/~scs/cclass/krnotes/top.html) site an indispensable companion.
I wouldn't skip C. I'd learn both. C and Scheme are both great languages to know. They are book-ends that will serve you well for a very long time. C gives you a deep understanding of von Neumann computing. Scheme gives you a deep understanding of abstract algorithms. I'd skip Java. 
&gt; Yes, it (effectively) does. If he had said "or a high*er* level language" I would agree. But programmers...especially online programmers are extremely pedantic. Just wait 15-20 years and people will be asking if they should learn C# or a high level language.
If you've got experience as a linux sysadmin and you've dabbled in shell scripts then you might want to start with Perl. It's hugely unpopular among the cool kids who are all using Python and Ruby these days (both of which would also be good choices to start dabbling in), but it has the advantage of being slightly closer to C (and shell scripting) than the others. In other words, it's a good stepping stone from where you are now to where you want to get to. Perl, Python and Ruby are all very forgiving languages compared to C. A few hours/weeks of dabbling in one of those languages should allow you to brush up your programming skills without having to worry too much about the low-level details that go with C (memory allocation, pointers, etc) Your ultimate goal should be to get to C (in my opinion) because it remains the lowest common denominator of programming languages (the fact that it's the language that Perl, Python and Ruby are written in is an indication of just how universal it is). But I think you will get there faster in the end if you take the scenic route via a higher level language. 
I agree on C, but I think it should come after Scheme and SICP. Java is the #1 enterprise language so if he wants a job...
There are *plenty* of jobs without knowing Java. And, if you want to work in enterprise... well, you don't really need to know much actual computer science, in my experience (so, yes, Java is sufficient). 
Let me refer you to TIOBE: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html Java is #1.
You need both. ;)
I should have gone on a little further. Since Java is #1, it is a major decision to decide to ignore the #1 sphere for the current most popular language. 
I guess I am more partial to enterprise. After 8 years in the Marines, I love my soul being sucked. Om nom nom nom. That hasn't stopped me from learning and messing with Scheme, Go, Python, R, Sas, Bash, Haskell.... the list goes on. Once you learn the core paradigms, the rest are just so easy to pick up.
&gt; which will be helpful to understand why main in { int main() {return 0;} } takes exactly 0 arguments and not unspecified number of arguments. Actually, it takes an unspecified number of arguments. `int main(void)` takes no arguments. Try this program: int test() { return 1; } int test2(void) { return 2; } int main(void) { test(1, 2, 3, 4, 5); test2(1, 2, 3, 4, 5); } % gcc argtest.c -O0 argtest.c: In function main: argtest.c:11:2: error: too many arguments to function test2 argtest.c:5:5: note: declared here Take out `test2()` and it compiles and runs without problem.
Well, if we end up with 2 or 3 abstraction layers on top of what C# can provide us today, then yes, C# will be at the lower end of the stack, and thus be a low level language. --- Try transferring the situtation to the hardware domain, processors specifically. The year is 1989 and you say this: &gt; Just wait 15-20 years and people will be asking if they should buy an 80486 processor or a high performance processor. Just because a 486 processor was a "high performance" CPU in 1989 doesn't mean it's high performance today. Times change, get with it :)
&gt;Take out test2() and it compiles and runs without problem. Thank you for providing us with a real example of "try and see" approach. I shall counter it with the RTFM approach ;) C89, 3.5.4.3 Function declarators (including prototypes): &gt;An identifier list declares only the identifiers of the parameters of the function. An empty list in a function declarator that is part of a function definition specifies that the function has no parameters. The empty list in a function declarator that is not part of a function definition specifies that no information about the number or types of the parameters is supplied. By the way: &gt;Take out test2() and it compiles and runs without problem. $ gcc argtest.c $ gcc -Wall -Wextra -pedantic argtest.c $ clang argtest.c argtest.c:10:23: warning: too many arguments in call to 'test' test(1, 2, 3, 4, 5); ~~~~ ^ 1 warning generated. $ cat argtest.c int test() { return 1; } int test2(void) { return 2; } int main(void) { test(1, 2, 3, 4, 5); test2(); return 0; }
Yes! Implementations, standards... :-)
Thank you! A lot of people seem to think the "Level" in HLL means it's a relative location in an abstraction/performance/compability hierarchy, but the CS meaning is that certain criteria has been met.
I think a good definition of high level language is when the language that you are using doesn't have 1:1 relationship to the computer instructions that the language is translated to.
Is there an easy format for gnuplot to read in the data? Do I need to have the information stored in a file a certain way or will it sort it for me?
It's been a few years since I used it, but as I recall gnuplot has some flexibility in formats but really you want to write to a format gnuplot likes. Also, as of say 4 years ago it was surprising (to me) that gnuplot really was the standard for generating graphs - there were actually programmer job postings for websites that listed gnuplot skills as a prerequesite. Whether that's still true today I don't know. 
Gnuplot is pretty lightweight and really easy to use. [Here](http://ndevilla.free.fr/gnuplot/) is the C interface. Also, [here](https://github.com/rb12345/gnuplot_i/blob/master/gnuplot_i_example.c) is an example program. It allows for flexible data access as well.
You can use CSV or tab delimited values to provide data to gnuplot. This is very easy to format. The rest are things you need to look for via googling/documentations.
It can read from standard input, so you can just popen() it and write your data and formatting commands to it. Or possibly the data needs to be in a file; it's been a while and I don't have the docs handy.
Maybe check out the past winners from the [obfuscated C code contest](http://www.ioccc.org/years.html). It kind of sounds like you might already know about this though.
A few of the entries on [Steike's page](http://www.steike.com/code/useless/evil-c/) fit the bill. I especially like &gt; This font definition has a bug. Find it. &gt; &gt; char font[] = { &gt; .... &gt; 0x00,0x61,0x51,0x49,0x45,0x43,0x00,0x00, // 1 :0x5A Z &gt; 0x70,0x29,0x24,0x22,0x24,0x29,0x70,0x00, // 1 :0x5B [ &gt; 0x00,0x3D,0x42,0x42,0x42,0x42,0x3D,0x00, // 1 :0x5C \ &gt; 0x00,0x3C,0x41,0x40,0x41,0x40,0x3C,0x00, // 1 :0x5D ] &gt; ... Assignments in conditionals are a standard trip, and enclosing them in double brackets will eliminate compiler warnings. I like "`while (x --- 0)`" and "`while (0 &lt;-- x)`" as alternatives to the usual "goes toward" operator. The first is the same, relying on the maximal munch rule and zero evaluating to false, the second excludes 0 because it uses a pre-decrement.
What's the structure look like? And what errors are you getting?
It's very simple, sorry for not including it before. struct word { int count; char *spell; };
What errors are you getting?
There are a couple of things that jump out at me that could go wrong. First off, you are comparing a `char*` to `'\0'`, this doesn't really make sense. Are you trying to check if the string is not empty? Second, you are freeing pointers (specifically a `char*`) that were passed into you. If you call free on a `char*` that was initialized with something like `char *test = "hi"`, you most likely (should) get a runtime error.
I'll get back to this when I get home, debugging on a phone is hard shit
I'm guessing you're not properly initializing spell. Are you malloc-ing memory to it then copying the string into it? If you could post three entire source it would be a lot easier.
So you're making some mistakes around the struct pointers. Specifically, you're not thinking about how this is laid out in memory and what a pointer to a struct is. Also you can use "word" as a variable name. This is distinctly different from the type you define called "struct word". So drop the ward/werd stuff. Run this under a debugger and understand why it's failing rather than staring at the segfault. Debuggers are your friend. 
You could call `strlen` on it and check that it's not zero. Yeah you have to free those. I was just warning you against certain circumstances. Also, to me, it seems like a weird place to free memory. Usually you would free it in the same place you create it, maybe in the same function. Freeing it in a function that is just used to print stuff out is strange. Just a heads up.
Yea C can be a nightmare without a debugger.
right at the beginning, I see you iterate over the novel array(which is initialized to empty). It is illegal to access more than 1 past the array. You cannot overrun the array **snippet** int e = 0; for (e = 0; novel[e] != '\0'; e++){ if (novel[e]-&gt;spell == argv[i]){
* MathGL: http://mathgl.sourceforge.net/ * PLplot: http://en.wikipedia.org/wiki/PLPlot
assuming the novel array provided is correct, novel[i] != null is never checked. the loop stop condition is novel[i]-&gt;spell is not an empty string but if none of the novel[i]-&gt;spell are empty strings you will go to far in the novel array ( I should say out of the array =&gt; unknown content in memory). It might be better to use ( I don't remember if the tests in the "if/while" are always perform in the provided order on all compilers) for( ;novel[i] != null &amp;&amp; strlen(novel[i]-&gt;spell) &gt; 0; i++ ){ ... bla bla } or provide a max value (nb_words) for i in the function parameters and check that i is &lt; nb_word (better imo since you might not have a null pointer at the end of the array or the array is not initialized with null values everywhere ) (it might be better to use a while loop when multiple tests are performed as a stop condition, for readability )
Found someone ..thanx guys
Here's the [official explanation](http://msdn.microsoft.com/en-us/library/ew5tede7.aspx) for the shadow space: &gt; The parameter area is always at the bottom of the stack (even if alloca is used), so that it will always be adjacent to the return address during any function call. It contains at least four entries, but always enough space to hold all the parameters needed by any function that may be called. Note that space is always allocated for the register parameters, even if the parameters themselves are never homed to the stack; a callee is guaranteed that space has been allocated for all its parameters. Home addresses are required for the register arguments so a contiguous area is available in case the called function needs to take the address of the argument list (va_list) or an individual argument. This area also provides a convenient place to save register arguments during thunk execution and as a debugging option (for example, it makes the arguments easy to find during debugging if they are stored at their home addresses in the prolog code). Even if the called function has fewer than 4 parameters, these 4 stack locations are effectively owned by the called function, and may be used by the called function for other purposes besides saving parameter register values. Thus the caller may not save information in this region of stack across a function call. I'd also like to point out that this is only a requirement of the Windows ABI. The ELF x86_64 ABI has no such nonsense, so this is about 64 bit Windows programs, not 64 bit programs in general. 
&gt; the answer is not 2, how do I make the answer 2? answer = b - a; &gt; this is working with money so it needs to be a float o.O
I need to grab the data from the array. I am generating b and a in for loops. the code I am doing is a lot more complicated but I have the rest figured out. The only piece I am missing is I need to subtract 2 dollar figures that are loaded into arrays.
Well, my guess is that you are confusing something up, and I can't really understand what you want. atoi is used to convert a C string (which is a string of a C-kind format : an array of *char* including the '\0' one). It is not used to convert any array to int (well actually that's what it does, but as you say so, you will end up with gibberish, so let's not complicate those things right now) Also, atof convert, as its name implies (a as in chAr, to f as float), C-string to a float litteral. For example, let's say I got the follow string : char *sf = "1.5"; which is actually the following sequence of *char* : '1' '.' '5' '\0' float fl = atof(sf); fl will now hold the value 1.5 . So now for your problem : float array[10][10]; is actually a float **array, with each pointer initialized nicely to a reserved space (well, for the sake of simplicity, although there are some refinements about arrays). Accessing array[3] will actually give you a row of ten consecutive floats. Doing answer = array[b] - array[a]; does not mean anything. More so, why do you think you'd end up with 2 ? because b-a should be 2 ? b and a are indices that you are using to access the elements inside your array. I don't understand.
OK, let me try to explain this better. I have a float array that is loaded with dollar amounts. money[a] == 4.50 money[b] == 4.25 i need to subtract [b] from [a] then printf the answer. If I use atoi it works fine except nothing after the decimal point is carried over because it converts them to integers. 
Okay, nobody's really noticed the important part of this question yet: it's a *two*-dimensional array. To specify a value in a two-dimensional array, you need to use two indices: `array[3][4]` gives you the 4^th value in the 3^rd row of the array. What you're doing right now is trying to subtract an array from an array, which is bad.
Okay, then why is your float array in 2D ?
That... shouldn't work. `atoi` takes a string, and you're feeding it an array of floats... What indices do you need to access? If it's a two-dimensional array, you need to access them in the format `money[n1][n2]`; otherwise, you'll only get an array.
because its holding 30 different dollar values that I have to scan through fifty thousand times, each time with different data to compare. so money is actually money[30][5]. This is a much larger code but I am only stuck on this one part, as soon as I figure out how to get the answer from subtracting 2 parts of this array the code will be complete.
so if money[a] was 4.50 and money[b] was 4.25... would'nt that make the array like this? [ [ 4 . 5 0 ] [ 4 . 2 5 ] ] I am trying to test this with printf money[a][0] and money[a][1] but they are all just zeroes. 
[Don't use floats for currency.](http://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency)
right now a rounding error is the least of my worries.
What you are describing in (pseudo)JSon is actually an array of float money[x][1]; Not really useful and rather perplexing. Currently, if your array is a 2D one, the first indice grants an access on pointers. These pointers holds values like 0xeedfadee, or something akin (depending on your architecture, and other things). This is a value of type *void** (actually, float**), the same as the NULL pointer for example. This is actually an unsigned int (but you'd have to cast it to access it in such a way). I would find it EXTREMELY strange that your compiler would convert these value without warning you. Are you sure that your array is in 2D ? The array that you are trying to access with money[a] should actually look like that : [ 4.25, 4.50, ... f29 ] only one dimension, neatly packed float values. Your array should then be created in such format : money[30] , and not money[30][5]. You should try something like that : int i,j; for(i = 0; i &lt; 30; i++) { for(j = 0; j &lt; 5; j++) { printf("%f ", money[i][j]); } printf("\n"); } If you hit up a SegFault, then your array is not in 2D. otherwise, you'll at least see what's up.
I changed money into a char and am using atof to convert it into a float. It works. I feel like this is a sloppy way to resolve the issue but I am running out of time. Thank you for your help though. 
okey first of all you want to minus two value inside the array so you would need array[row][column] a two dimentional array is more like a grid. so it looks like [this] (http://www.math.ucla.edu/~wittman/10a.1.10w/ccc/ch09/ch09/images/twodim-array.png) you need 4 different index so a1,a2,b1,b2 let a1 and b1 for the location of the first currency and a2 and b2 be the location of the second currency. it is going to be like array[a1][b1] - array[a2][b2] atoi does not work because it convert a string(aka an array of char ) into a integer.
C++ wasn't standardised until 1998, so anything prior to then was fully implementation-specific. Rhomboid explains the differences since standardisation succinctly, but if you are interested in very early C++ you'll have to start at something called [Cfront](http://en.wikipedia.org/wiki/Cfront). Essentially this program "translated" C++ code to C since there were no real C++ compilers back in that time.
Not quite what you are asking perhaps, but C++ started as a C pre-processor. It was compiled into C code and then run through a C compiler. http://www.cplusplus.com/info/history/ So yeah, minor change from there to now. 
I think most C programmers are luckier now than their peers 10 years ago. There is a plethora of libraries you could use (glib, sglib, zlib, et cetera). I would even bet that most C programmers have written their own libraries to suite their reoccurring needs. I have written many of these data structures and tend to use them if I don't or cannot use glib (i.e. portability). For data structures and common conveniences: https://github.com/manvscode/libcollections As for Dijkstra's algorithm, I have also implemented a C library for combinatorial search algorithms that I might need: https://github.com/manvscode/libcsearch
That's a good book--just didn't like the author's commenting style. 
I guess to me it seems unusual that there is not a more standardized collection of data structures for C. The C library is nice but I would think it could use quite a bit of extension.
If you want the while loop to run continuously, a while(1) would do the trick. you can break from the cycle if the user types "bye" (for example) as for the 2nd part of your question, interpreting sentences and figuring out what the user is actually meaning, its quite hard to do. It involves vocabulary, language, syntax, etc... there are a few projects that already try to do that, you can learn from them
Thanks for your response! So for the While loop could it look something like this? While (strcmp(useranswer, "bye") !=0) { scanf("%s", useranswer); printf("%s", response); } For my second question, I am just trying to make a very basic chat bot. I am more concerned with it compiling and running. So I was thinking something like this... if ( strcmp( useranswer, Keyword) == 0){ Printf("This is a proper response because the user's response matches the keyword"); This is basically how I was thinking my chat bot would work, basically having multiple keywords and just comparing the user response with keywords in a lot of different if statements
gniark just taught you how to make tables. Time to take the bull by its horns and learn stuff your teacher hasn't taught you yet.
Sorry, can't agree with you there. I wouldn't recommend learning PHP unless you're planing to build simple web sites. It's a dead-end language that's only good for one thing (which it does very well, mind you). Perl and PHP are very similar in terms of syntax. I don't think there's anything easier about PHP than Perl. If anything PHP is more eclectic and less like C than Perl, but perhaps that's just my bias. Also, I wouldn't recommend using PHP from the command line. It's a web language, not a general purpose programming language. The command line was bolted on as an afterthought. And finally, CPAN. That's the #1 reason to use Perl. PHP isn't even in the same league.
Some minor points where I think this could be improved: I usually find it clearer to make a table out of a struct array rather than a 2d array, this also allows for additional fields of different types, as well as named fields instead of array indexes: struct { char *key; char *resp; } table[] = { {"aaaa", "anser of aaaa"}, {"bbb", "answer of bbbb"}, {0} }; If you set the last member of the array as null it will result in the two char pointers being null. This allows you to iterate the struct array similar to how you would iterate a string -- checking for null termination: int i; for (i = 0; table[i].key; i++) { printf("%s : %s\n", table[i].key, table[i].resp); } 
Read up on Markov Chains and Hidden Markov Models.
&gt;"" == '\0' Just wanted to point out that this is inaccurate. While the only character an empty string contains is '\0', the type of "" is char[] (const in C++) and the type of '\0' is char. More accurately, *"" == '\0' or ""[0] == '\0'. Also, your 2d array "wordTable" is of type 'char', which means you could not actually put any string literals in there, so you'd have to declare it as "char* wordTable[][2]". However, once you do this, you'd be changing how you define the end of the array. The 0-valued chars ('\0') would be interpreted as the NULL pointer (integral 0), so to check for end of array, you'd have to compare the pointer with NULL instead of lexicographically comparing the string to "".
&gt; I'm think you sound biased You'll note that I admitted the possibility that I was. &gt; If you had more exposure to what is happening in the real world, you'd know this. Dude, I've been programming for over 30 years (and building web sites for nearly 20 of those) in a variety of languages including Perl, PHP, Python, Ruby, C, C++ and Javascript. It's about 3 hours since I last wrote some PHP and about 5 since I last wrote some Perl. I may have many faults, but not being experienced in the real world, particularly when it comes to web development, isn't one of them. Heck, I even wrote [a book](http://www.template-toolkit.org/book.html) on the subject! For the record: I didn't say PHP was a *dead* language, nor did I say it wasn't capable (in fact I said it does the job very well). I said it's a *dead-end* language in the sense that it's only good for web programming. OP didn't say anything about wanting to build web sites. If he did, I would have recommend he looked at PHP first (with the caveat that he should move on soon after if he ever wants to progress beyond just building web sites). Perl is a general purpose programming language, PHP isn't. Simple as that. It may not be what OP's looking for, but I think it's certainly a better recommendation than PHP. Your opinion may differ, but please remember that we're talking about OP's requirements, not some generic language pissing contest. 
In addition to what others have said, you definitely don't want to use `scanf()` for reading user input. It is asking for trouble (buffer overflows etc.). Use `fgets()`, then parse the input (probably by using `sscanf()`). Here is a [c-faq entry](http://c-faq.com/stdio/scanfprobs.html) about *why* you shouldn't use `scanf()`.
Yeah my bad I bugged here it was supposed to be {null, null}
Interesting. FWIW, clang handles the `t2.c` file correctly, i.e. it prints 1. 
Have you checked if your computer is plugged in? If yes, proceed with a reboot and check if it's working. 
Double-checked.
&gt;I'll reiterate: it's very easy to find jobs that don't require Java. It depends on the region you live. Here in Colombia there a very few jobs (almost none) that require C.
Use the [modulus operator](http://www.cprogramming.com/tutorial/modulus.html): `dir % 6` Be warned, though, that different compilers and different machines may give differing results for `dir % 6` if `dir` is negative.
Not sure where 128 and 132 are coming from, but the conventional way of "fixing" the modulus operator for negative integers in languages like Java and C is: a mod b == (a % b + b) % b So for OP, it would be: (dir % 6 + 6) % 6
OP said `dir` is a signed char. That (probably) means its value is between 128&amp;nbsp;and&amp;nbsp;127. To ensure that it becomes nonnegative, we have to add at least 128 to it. But if we add a number that is not a multiple of&amp;nbsp;6, we change the remainder. The smallest multiple of&amp;nbsp;6 that is greater than or equal to&amp;nbsp;128 is&amp;nbsp;132. &gt; `(dir % 6 + 6) % 6` This requires one addition and two modulus operations, whereas `(dir + 132) % 6` requires only one addition and one modulus operation.
Except if you add 132 to anything in [-4 ... -1], you end up with another negative number, so that won't work...
How about if (dir &lt; 0 || dir &gt; 5){ dir = (dir % 6 + 6) % 6;} seems fast to me, and I could easily write up a macro to use GCC's `__builtin_expect()` to mark that as unlikely.
Ah, you're correct. I would still personally use the %+% expression to avoid it breaking if I ever switch away from a signed char, but yours will work just as well.
My opinion is that it's too much code. A single line of `dir = (signed char)((dir + 132) % 6);` has just two arithmetic operations. I doubt you can get much faster than that. Have you compared the performance of these two options?
I have this: #if defined(__GNUC__) #define lif(x) if(__builtin_expect((x),1)) #define uif(x) if(__builtin_expect((x),0)) #endif uif (dir &lt; 0 || dir &gt; 5){ dir = (dir % 6 + 6) % 6;} and it seems to me that `dir` won't be out of bounds too much, so it won't run that often and if it does the slower path is probably more robust.
Well, whatever you want to do, I guess. To me that looks like a ridiculous mess of code to do a very simple thing. It also seems strange to me that you're concerned about "robustness" but are writing code that can only be compiled by gcc.
&gt;It also seems strange to me that you're concerned about "robustness" but are writing code that can only be compiled by gcc. Good point, now I have this: #if defined(__GNUC__) #define lif(x) if(__builtin_expect((x),1)) #define uif(x) if(__builtin_expect((x),0)) #else #define lif(x) if(x) #define uif(x) if(x) #endif uif (dir &lt; 0 || dir &gt; 5){ dir = (dir % 6 + 6) % 6;} the macros are defined elsewhere, of course.
No, it's not a bottleneck, but I really hate to have to go through a while loop, especially if I decide later that I want to increase `dir`'s type to a short or an int and it manages to get to some incredibly large number.
If you want to use the two-modulus solution, just do this: dir = (dir % 6 + 6) % 6; I'm not convinced that wrapping this inside an `if` statement is going to give you a performance benefit. Don't add this kind of complexity to your code unless you can justify, by quantitative experiments, that it's actually going to give you a measurable speedup. I doubt it does. &gt;  if I decide later that I want to increase `dir`'s type to a short or an int and it manages to get to some incredibly large number. Do you not know what range of values `dir` can have? It sounds to me that you need to do some more thinking about your algorithm to understand this. If you're concerned about the correctness of your code, then you'd better be able to say that the value of `dir` must be within a certain range. Even if this particular modulus line will be correct for any value of `dir`, if you can't tell me what range `dir` will be in, then how do you know it won't overflow, for example?
`dir` should be either 0, 1, 2, 3, 4, or 5, but I'm using it as a direction on a hex tile and if somebody wants to count turns (+1, -1) instead of just the direction I'll let them do that without issue.
&gt; I really hate to have to go through a while loop Yes, you shouldn't use a while loop for this. I agree. You should replace that with an expression that uses the modulus operator. The part that farsightxr20 and I are calling "premature optimization" is wrapping the modulus expression inside an `if` statement, along with the use of GCC-specific optimization macros, in an attempt to save at most a few CPU cycles. You're making your code much more complicated, and you don't even know that it will run any faster. So yes, use the modulus operator, but don't overcomplicate it.
Eh, I've already got the macros written up, and two modulos and an addition is probably going to be slower than two comparisons, so there's no reason to delete it now.
Some of the stuff came out bad, probably when you were pasting this (e.g. your declarations came out commented). That said, you don't need a semicolon at the end of your CONSTANT declaration. What errors are you getting? Seems to compile cleanly for me. Program execution is a different matter, however. :) Looking at your initialize function, you realize you are incrementing the variable 'i' and then you print a[i] after the conditional check fails in that for() loop. for (i = 0; i &lt; (size - 1); i++) a[i] = i; printf("%d ", a[i]); What is 'i' here where printf a[i] occurs?
My apologies for pasting it the way I did. Yes the semi colon! I had just taken it out before I read this but thanks still for looking at that. The syntax error lines went away as soon as I took it out. Well I have to print the array after I have it initialized. "I" is just the index. I am literally printing the array elements 1 - 20 with values 1 - 20.
Ah, well in that case it seems like you forgot the curly braces for your loop. for (i = 0; i &lt; (size - 1); i++) a[i] = i; printf("%d ", a[i]); is different from for (i = 0; i &lt; (size - 1); i++) { a[i] = i; printf("%d ", a[i]); } Do you see why?
Except, you know, the fact that it deems it unreadable now. Come back in 4 months, see uif written all over your code, go back fumbling into your headers searching for the godsacken reason that pushed your past self to include it : some measly CPU cycle, that you don't even measured accurately. GCC, MVCC will optimize it far better than you, and you simply increased the likelyhood of your code to contain nasty bugs (macro are evil, remember ?). This is everything that is wrong with C. Except for that, no, no reason to delete it.
 uif (dir &lt; 0 || dir &gt; 5){ dir = (dir % 6 + 6) % 6;} is not very unreadable, and why would anybody go through and search to find out what `uif` does? It looks like an `if` statement, it has a branch like an `if` statement, it has conditionals like an `if` statement, and it damn near smells like an `if` statement. It seems like a glorified `if` statement to me.
Yes, until you start debugging and you stumble on a nasty one, and you start deconstructing methodically every single line of this code to review where it could have gone wrong (well, except if you do it cleanly and use TDD). But eh, do as you please, and the C language is a harsh mistress that will certainly teach you those values along the way. If you are not ready to accept them from an online forum, experience will kick in, eventually. Good luck.
Indeed. The for loop does not need the curly braces if it is executing only one line but if there are multiple lines it requires the curly braces. Is that correct? EDIT: I just recompiled what I have thus far (this is only 1 of 6 functions where I run an array transformation) and it is now outputting what I was looking for. Thank you for steering me in the right direction.
Yup, you're correct. Anyways, glad I could help. :)
"const" specifies that something is constant at run time. Leaving VLAs out of the discussion, C array sizes need to be compile time constants. That leaves you two choices: * Use the #define pre-processor directive. * Define an enum The former is far more common, since #define was around long before enum. The potential benefit to enum is that it is an actual language construct, so debuggers and other tools can often work more smoothly with enums. For example, some debuggers are unable to show the symbolic name for a pre-preprocessor macro, while all will be able to show the enum name. For a simple case like this, either should be fine. Of course, a final option would be to dynamically a allocate the array, but you should master the basics first. 
I read a little bit on the enum way but didn't know a whole lot on that. #define was what I was thinking the professor wanted and makes sense because I haven't covered enum yet. Thank you the lesson on constants.
Check the documentation for printf and scanf by typing in the terminal man 3 printf or alternatively http://linux.die.net/man/3/printf to understand what the format flag "%d" does. 
You are already 99% of the way there. You just need to read about the other format specifiers for scanf(). Once you read about that, you might want look up safe alternatives to scanf() for reading input strings from the user because using scanf() prone to buffer overflow bugs.
%s #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main() { printf("Enter your word:\n"); char input[20]; scanf("%s", input); printf("You entered: %s\n", input); }
Be careful with this, though. This code has a buffer overflow bug. If the user enters more than 19&amp;nbsp;characters, the `input` array will overflow and corrupt the memory of the program.
I was just looking around online about this issue and found a post that you might find interesting: http://forums.bsdnexus.com/viewtopic.php?id=402 Look at the fourth post.
Indeed, he should use fgets.
http://pastebin.com/uxcDtFes Please post formatted code or a link to pastebin with formatted code. It is very hard to read a mash of code into a few lines. I have tried to fix the formatting and I've highlighted things I've noticed wrong with your code in the pastebin. It's been a while since I tried using fopen/fscanf so I'm working on old knowledge vs current knowledge (when I write C these days I tend to use open/write/read on POSIX compliant systems). Hope I've helped a little. 
I get an error "Unhandled exception at 0x670EB49C (msvcr110d.dll) in ConsoleApplication2.exe: 0xC0000005: Access violation writing location 0x00000000." I'm not sure how to fix that.
Yeah, that's my compiler error. Do I need to download that .dll file? I'm not sure how to go about removing that error.
Look at how you are declaring bagelDescription in the struct. Why are you declaring it that way?
I was following along in my textbook and it was declared that way but I believe that is causing one of the pointer errors so I posted a revised version. =)
&gt; char *bagelDescription[322]; This declares an array of pointers -- you have 322 pointers to work with, but they aren't pointing to anything. (Since the variable "report" is global, it will be initialized to zeroes, so you have a bunch of NULL pointers.) If you want to store a single string, you'd want either a "pointer to char" (that actually points to memory--say, by using malloc() to allocate the memory), or an "array of char". &gt; fscanf(bagel,"%d%s%d%d", bagelRep); Off the top of my head, I don't think this will work. The first %d will get stored in bagelRep as if bagelRep were an integer, but then the %s%d%d will probably try to store 3 more values into arguments that you didn't even provide to fscanf(), probably causing a fault. Pay attention to compiler warnings. You should be getting a warning at least about the fscanf() usage, and not having enough arguments, and/or the arguments being the wrong type. &gt; FILE *bagel = "bagel.seq", *bagelRep = "Bagel.rpt"; This doesn't really make sense, but it doesn't cause a problem because you overwrite the values of bagel and bagelRep before you use them. Generally, don't store something in a pointer of a different type. A c-string does not belong in a FILE pointer variable. &gt; while(!feof(bagelRep)) &gt; fprintf(bagelRep,... &gt; fclose(...) You print a message if a file cannot be opened, but after that you will attempt to use the files anyway. This will probably crash if either file cannot be opened for reading or writing, respectively.
There are a few things wrong here. The biggest problem is in your `for` loop increment. You just have `i+2` here, but that doesn't change the value of&amp;nbsp;`i`. What you need is `i+=2`. Next, the upper bound for your `for` loop is probably wrong. If `i==size-1`, then `i+1==size`, and `a[size]` is probably out of bounds, isn't it? So you probably want `i&lt;size-1` as your `for` loop condition. That means your for loop should look like this: for (i = 0; i &lt; (size - 1); i += 2) Also, you're only printing every other value in the array. You should be printing the value of `a[i+1]` too, right?
That indeed fixed the issue. Very astute. I could have sworn I used i+2 before in the past. I am using i++ in my previous functions to increment i and I would have thought that i+2 would have worked as well. I have made the changes you provided and my results are good. Always the little things.
But `i++` doesn't mean the same thing as `i+1`. When you say `i++`, you mean "*increment* the value of&amp;nbsp;`i` by&amp;nbsp;1." When you say `i+1`, you just mean "tell me the value of `i+1`, but don't change the value of&amp;nbsp;`i`." This is the same as the difference between `i+=2` and `i+2`. The first one, `i+=2`, means, "*increment* the value of&amp;nbsp;`i` by&amp;nbsp;2." The second one, `i+2`, means, "tell me the value of `i+2`, but don't change the value of&amp;nbsp;`i`."
Thank you for the thorough explanation. It's my first go with C so I try to get as many lessons wherever and whenever.
For starters the second argument to fopen is not a char. Surely any compiler would warn about that, so step 1 is to enable warnings and make your code clean.
For Context: The GetFloat function is part of the CS50 library and its essentially the same thing as the scanf function. When I run the code, it never seems to get past the initial step of asking for the change owed. I am completely lost and I've been looking at this for days. Any help with would be greatly appreciated.
Without seeing what GetFloat looks like it's hard to be sure but if I were to guess I'd say it's suffering from [scanf jam](http://c-faq.com/stdio/scanfjam.html).
If you don't have #include &lt;stdio.h&gt; at the top of your source code file, you need that. As /u/drobilla said, the second argument to fopen is not a char, so you'll need to change that. And you should turn on warnings in your compiler. You should escape the backslashes within your filename string. It should look like this: "C:\\Users\\PC\\Desktop\\New folder\\Question 5\\one.txt" You should check to make sure `fopen` actually worked. So you should be saying something like this after the `fopen` line: if (fp == 0) { perror("Cannot open file"); exit(EXIT_FAILURE); } The `perror` line there will automatically print an error message that describes what went wrong with `fopen`.
Well, that doesn't compile at all. After adding `#include &lt;stdio.h&gt;` and `#include &lt;unistd.h&gt;` and changing `Sleep()` to `sleep()` -- presumably a library function that feels happy defining a millisecond-based function with a *very* similar name to a standard library function -- I see several errors: * The file name is completely buggered. Remember that *you must escape backslashes*! Windows supports the forward slash ("`/`") in code, so I suggest using that for consistency across platforms. If you insist on using a backslash, it should become `C:\\Users\\PC`... * As /u/drobilla [said][1], argument 2 of `fopen()` is a character string, not a `char`. In the words of gcc: `warning: passing argument 2 of fopen makes pointer from integer without a cast`. Not a compiler warning to discard. * You're going to print a `nul` character. You initialise `ch` to 0 and then use `printf` to print it before calling `getc` for the first time. A more common idiom is: char ch; while((ch = getc(fp)) != EOF){ ... } And a nitpick: consider using the `putc` family of commands for writing single characters. This avoids the (theoretical) portability problems of converting integers to unsigned chars to signed chars and whatnot. Finally, if you're using a buffered terminal your lines might come out "choppy" as your terminal's buffer is flushed. Actually finally, to post code on reddit (which uses markdown), indent it by four spaces. It sort of worked in this case because the main block was indented. Edit: As ever, I took ages typing this out and /u/zifyoip beat me to it :) [1]: http://www.reddit.com/r/C_Programming/comments/1ctm9v/how_do_you_type_out_what_is_in_a_text_document/c9juni3 
Thank you so much! that helped clarify fscanf and pointers for me. =) Everyone is so nice and helpful on here.
LD, probably, not ID. lowercase("LD") is a linker, responsible for searching in libraries (and other, partially compiled files) for the functions you call, and linking them to what they actually do. Where it says "ld returned 1 exit status": Is there a tab that has debug output or compile output or build output or something like that? You absolutely need to get access to the actual warnings and error messages.
A variable should be declared and assigned a value before being used.
Right. And "ld returned 1 exit status" probably means the linker can't find a definition for one of the functions you're using in your code. Maybe it can't find the definitions for the functions `fopen` and `printf` and `getc` and `fclose`, because those functions are defined in `&lt;stdio.h&gt;`, and you're missing this line at the top of your source file: #include &lt;stdio.h&gt; Or maybe it can't find the definition for this function called `Sleep` that you're using. I don't know what that function is or where it's defined. There is a function called `sleep` (with a lower-case&amp;nbsp;S) that is defined in the file `&lt;unistd.h&gt;`, if you're on a Unix machine. If that's the function you mean, then you need to change it to a lower-case&amp;nbsp;S, and you need to have the following line at the top of your source file: #include &lt;unistd.h&gt;
I hope some of this is helpful. based on [your pastebin posting](http://pastebin.com/hkvn3DNY). It looks like you're missing semicolons on lines 71-73, 81-83, and line 88. I have no idea what you are trying to do on lines 71-73. I wouldn't have even guessed that was legal, but I ran it though a compiler and lo and behold, it works. Even if it's doing what you want it to be doing though, don't. It's confusing and odd. Just use loops or conditional statements. A word to the wise, proper indentation and spacing not only makes your code easier to read for both yourself and others, it makes it much easier to find bugs. If you're using visual studio (assumption based on earlier comments) [take a look here](http://stackoverflow.com/questions/3958903/how-to-automatically-indent-source-code-in-visual-studio-2010) The strings you've got stored in the h#[] arrays don't actually fit in the space you've allocated for them. For example, 'h2[13] = "Bagel Description"'. "Bagel Description" is 17 characters long, 18 because you need to account for the null terminator, but you've only allocated 13. You've got an extraneous \ before "File" on line 39. You're calling fprintf without specifying a file descriptor to print to. It should look like (if you want stderr): &gt; fprintf(stderr, "File could not be opened\n"); instead of &gt; fprintf("File could not be opened\n"); Or, you could just use printf instead of fprintf if you want to print to stdout. bagelSales (or bagelsales), used lines 71-73, is never declared. lines 72 and 73 do something like this: &gt; 5&lt;bagelSales&lt;=9 This almost certainly will not do what you want it to do. Let's say bagelSales has a value of 12. By the logic you seem to be trying to use, this would be false. However, This will evaluate as ((5 &lt; bagelSales) &lt;= 9). First, (5 &lt; 12) = [true] = (generally) 1. now, (1 &lt; 9) = [true] = 1, so the expression will evaluate as true instead of false, which is not the answer you were looking for. You would need to do something like (5 &lt; bagelSales) &amp;&amp; (bagelSales &lt;= 12) to get the answer you were looking for.
Thanks! I forgot to escape backslashes many times when I was starting out. I suspect I'd make the same mistake even more now after working with *nix systems for so long. I'm pretty sure I have a vague memory of frustrating times after using a `char` for the mode of `fopen()`, too :)
My guess: "Hello, world!". I have not opened your code in anything but my browser window, simply read through your code and written the following snippet to decode the encrypted comment in your source: #include &lt;stdio.h&gt; int main(int argc, char **argv) { char i, *sub, *str[] = { "\"hobmted!=ruehn/i?", "hou!l`ho)(", "z", "qshoug)#Idmmn-!vnsme ]o#(:", "sdutso!1:", "|" }; for(i = 0; i &lt; 6; ++i) { sub = str[i]; while(*sub) { putchar((*sub++)^0x101); } putchar('\n'); } return 0; } Which gives me the output #include &lt;stdio.h&gt; int main() { printf("Hello, world!\n"); return 0; } Which it appears your code will compile and run, printing "Hello, world!"
[LC-3 simulator](http://highered.mcgraw-hill.com/sites/0072467509/student_view0/lc-3_simulator.html), second Google result for "LC-3".
And for me too. First result for "LC-3 simulator". Obviously OP must be using Bing to search :).
Exactly right, congrats! The version I uploaded was purely proof of concept so it might be a little easy, but obfuscating it more would be trivial (especially if you use something a little more complicated than xor encryption).
Don't underflow a signed integer for the wrap-around. It's undefined behaviour in C.
Thanks! Those will be very helpful
Agreed! I haven't read them yet: I was looking through a tutorial-bookmarks file, loaded up the link, and thought to myself, "Holy shit, how have I not dedicated an entire week to this already?" I recently picked up a /r/raspberry_pi, and I think these tutorials will compliment it quite well.
&gt; Size of each tutorial is given in ammount of screen-pages when viewed using the lynx text-based web browser (assuming 25 lines per page) This should be a real unit of document length.
Exactly! That's what I plan on using them for as well! Mine is still sitting on my desk, waiting...
There is a port of the publicly available lcc compiler that has an LC-3 back-end (http://highered.mcgraw-hill.com/sites/0072467509/student_view0/c_to_lc-3_compiler.html) . If you manage to get it set up, you can use it to see what assembly instructions are emitted from simple C programs, which would help you to understand how your programs get translated to a form closer to what the machine can execute. I have a feeling this may be more in line with what you are asking for rather than seeing how the LC-3 CPU is simulated, but that same website also contains source code for the simulator that you will likely be using to debug your programs in that class.
&gt; Mine is still sitting on my desk, waiting... Me too! I bought a Model A and B in the hopes of practicing backward compatibility, and regression testing. I made a mistake when I ordered by not ordering an SD card: the one I have is Class 10, which isn't compatible. I do have two 1G SD cards, so I need to research making slim images, but first I'm going to get QEMU setup. I think I can resolve all of this in one go thanks to [Aboriginal Linux](http://landley.net/aboriginal/): "a shell script that builds the smallest/simplest linux system capable of rebuilding itself from source code. This currently requires seven packages: linux, busybox, uClibc, binutils, gcc, make, and bash. The results are packaged into a system image with shell scripts to boot it under QEMU." &gt; Design Goals ... Aboriginal Linux tries to support a number of use cases: * Eliminate the need for cross compiling * Allow package maintainers to reproduce/fix bugs on more architectures * Automated cross-platform regression testing and portability auditing. * Use current vanilla packages, even on obscure targets. * Provide a minimal self-hosting development environment. * Cleanly separate layers * Document how to put together a development environment. Of course, the /r/raspberry_pi also goes hand-in-hand with [Linux From Scratch](http://www.linuxfromscratch.org/).
Well it still has a +1.something percent so not exactly a halt.
I'm not sure I understand what you need to do exactly but from what I understand I would read the file, place the names in an array and the sizes in another one. The index for both arrays should be related (ie. Group[2] and Size[2] refer to the same group). Group is an array of const* char, Size contains numbers. You can then use any sorting algorithm on Size, making sure you are moving the appropriate elements of Group as you go along. For instance, if Size[3]&gt;Size[5] you'll want to swap both of them but swap Group[3] and Group[5] as well. By the end of the sort, Group will contain an ordered list of names. If you haven't done any sort of sorting yet have a look on google. Bubble sort is quite simple to implement. The main idea you need to remember while doing this is that you're sorting 2 arrays at once, but using the values of only 1 of them. I hope that makes sense, I'm on my phone so couldn't be as precise as I would want. Good luck! EDIT: As SaidinWoT mentioned, use a struct that holds a name and a value and have an array of structs. Use your sort algorithm to sort the elements by "size" by comparing Groups[i].size with Groups[j].size and swapping them accordingly. 
The "more specifically" problem description reminded me of constructing a Huffman tree for Huffman coding. Unfortunately this won't necessarily put groups in order - if you have a set with values {2, 2, 3, 10}, the '2's will be paired as children of a node with value '4', which will in turn be a child of a node with value '7' (its other child being the '3') and finally the root node will have a value '17' with children '7' and '10'. If children are thought of as being ordered from left to right, lesser and greater at each node, an in-order traversal of the tree will result in "3, 2, 2, 10". If pairing off like this is your goal, I'd construct such a tree. If you are merely trying to sort the individual groups, I'd do basically as /u/x5f5 [posted](http://www.reddit.com/r/C_Programming/comments/1cyb9q/ordering_by_amount/c9l5dp6) and simply sort by the values in place in an array, except I'd store all of the information about a group in a struct so you only have to have one array: struct { const *char name; int value; } groups[numGroups];
Okay. Thank you, it just looks like I have to review arrays(coincidentally is the section that was covered when I was incapacitated). That last bit after the bracket was extremely helpful, that part was throwing me trying to figure out how to turn it into an array. 
Feel free to message me with further questions if you like. Unfortunately your description of the problem is rather hard to decipher, so I'd need a better idea of what exactly the goal is.
The standard C library has a function called "qsort", which performs the QuickSort algorithm. Not sure if you're assignment specifies that you have to write your own algorithm, but you might be able to use it. There's tons of documentation for qsort online, and it works with structs provided you write a compare function to pass to qsort() for said struct.
Will do. I just didn't want it construed as trying to cheat. So I purposefully made it vague, but with just enough info that I could (hopefully) get the part I was confused on answered.
It does not, I'll look into it. Thanks.
Some commentary in hopes of offering things to think about (yay wall of text!): True obfuscation relies on deception and complication. It is indeed trivial to obfuscate this code by renaming all of the functions and variables you define to irrelevant words or single letter names, but it is barely less trivial to undo this. It is also trivial to make your encryption function more complicated, but as long as the purpose of your code relies on its own ability to decrypt itself, the code to decrypt will be present and can be easily extracted and analyzed externally. The encryption function itself actually serves no purpose for your end code and sadly the decryption function is a must, so any peruser of your code will always have all the tools they need immediately available to them. You did achieve some level of complication/misdirection by having it compile and run another program, but it was readily evident that this was what would happen and that the source for the secondary program must be contained within that same code (as the program should run without issue as is and you provided nothing else besides a vanilla Makefile - it would be quite impressive if you somehow did make use of this vanilla Makefile in the obfuscation, though... that would be a truly great case of obfuscation in my opinion). I never even looked at what find_location and copy_to_target did until just now - it was clear that the "/* */" delimited comment was the encrypted source. It would have in fact been more obfuscating to have an irrelevant encrypted source in comments there that was not actually used, as the first thing I did was look for some way to do something with that comment. Finally, you count far too much on assumptions about the user's system and actions. While it may seem fair to assume that they will execute the program by typing "./encrypt", this will not necessarily be the case. I just compiled it in a folder in my home directory named 'clean' and did the following for a very simple break: $ ~/clean/encrypt Aha! You are trying to run the program...well, you'll have to enter the password first: bAbelfish zsh: segmentation fault (core dumped) ~/clean/encrypt Unable to find "clean/encrypt.c", it had no clue what to do. If someone had for some bizarre reason made 'gcc' into a function that deletes (or, more reasonably, archives elsewhere) the initial source file, a similar crash would occur. If I had decided to comment up your code while trying to figure out what it did and had used the same commenting style find_location hunts for and copy_to_target terminates at, I could have easily handed gcc gibberish to compile. This is a terribly unlikely situation, if only for how bizarre the comment style would be, but it's a simple way to break it. These were the things I noticed when I was first cracking it and when I went through it again just now to write this up. I'm not trying to poke holes in it, I write up stuff like this in hopes of providing constructive criticism that gives people things to think about down the line. Your program is well written, just not very obfuscated in the sense that 'obfuscated code' tends to mean. It would certainly stump plenty of people, but I don't see it taking the IOCCC judges more than a single good read through (figuring out obfuscated code being their specialty). Whenever I write up this sort of thing I feel like I'm coming off as more of a jerk than I intend (intentions: not a jerk), so I'll shut up now. Good job, it was an interesting little puzzle, keep going!
I assumed that's why it was vague, and I'm glad you're doing your best to be academically honest. It just resulted in two descriptions that seem contradictory to me, and thus... confusion! Good luck!
Terrible. The article talks about how to understand language concepts in terms of how they work in a particular implementation. Find a strictly-compliant implementation that does something differently and be surprised - or worse, think that it's broken...
The article talks about a specific concept in a specific language. A specific mental model that has worked for me. But thanks for the feedback.
Just FYI, Apple is taking on debt because its cheaper for them to pay interest on loans than to pay the tax on its huge pile of cash abroad. That's just not a good indicator for the financial viability of adding Objective-C to your skill set. Objective-C is also a really easy language to learn, especially if you're familiar with a language like C, C++, and/or a language with a similar object system (Ruby or Smalltalk, for example). I've seen competent developers learn it in a weekend, so the opportunity cost is arguably very much in your favor.
Yes Objective-C is easy to learn, however the Apple frameworks are full of quirks that will make you wish you had another better option. 
What is the nature of the error the compiler is giving you?
"include" is a preprocessor directive (it is parsed by the C pre-processor rather than the compiler), and it needs to have a "#" in front of it. Additionally, the %s format token is to print out strings. "freq" is an int. As far as the logic of the program, note that only one printf statement is executed, which doesn't seem to be in accordance with that stated purpose of the program.
It sounds like it isn't the *compiler* that's crashing, but your own program (freq\_test.exe). The compiler is the program that converts your C&amp;nbsp;source code into executable machine code. It sounds like that conversion step goes fine. But then when your program runs, it crashes.
Note: He does have "#" in front of his include statements (as you can see if you look at the source of his post), but he didn't put spaces in front of each line when he pasted his code into Reddit, so it's formatted incorrectly here.
I can see one problem- array[18] means there are 18 entries in the array: 0,1,2,3,...,16,17 so the second for loop will still be going when n = 18, and will write beyond the end of the array. the fix is to start the first loop from zero, and the second loop from 8. in c all array indexes start at zero.
Okay so I've changed my array to start at zero and deleted the printf statement, compiler runs fine now. Would i have to change freq to an array in order to print all the values or could i put in a loop where it prints one result at a time?
&gt; compiler runs fine now Again, I think the compiler was running fine before, too. It was *your program* that crashed, not the compiler.
1. Arrays in C are 0 based, so your array[18] are the elements array[0]-array[17] 2. Your for loops, while technically correct, can be rewritten with the n increment in the parenthesis (for n=0;n&lt;=8;n++){...}) 3. When you reference array element 18 (in your second look when n==18), you are no longer reading from the array and are reading and writing to a variable outside your programs scope. (See 1 if you are confused about this) 4. Freq is an integer and you are trying to cast it to a string with your printf statement. C doesn't work this way, you need to look into the standard library's itoa() function. 5. system is used to run OS shell commands, I have no idea what PAUSE is, but if you are trying to pause the output, look into the standard library's getchar() function.
I think he meant he was getting compiler errors.
That's my point, I don't think he *was* getting compiler errors. He said in another post: &gt; The compiler window comes up as usual, nothing happens and then the windows message with freq_test.exe has stopped working comes up. If he was getting compiler errors, then he wouldn't have even gotten to the point where freq\_test.exe *existed*, much less to the point where he was able to run freq\_test.exe and have it "stop working."
As far as I can tell the %s format string will expect a char pointer but is being supplied an int. This should not produce a compiler error but a warning on any compiler I've used.
Others have given you some explanations why your code doesn't work, but here's another solution for you to consider. I won't explain it, just think about it. #include &lt;stdio.h&gt; int main(void) { int i; for (i = 100; i &lt;= 900; i += 100) printf("%i\n", i); for (i = 1000; i &lt;= 9000; i += 1000) printf("%i\n", i); return 0; }
Okay, that is true.
I see a couple of bad habits not otherwise mentioned. 1. Avoid using `system("PAUSE")` because it isn't portable. `getchar()` works well enough, and you don't have to include stdlib.h 2. I always avoid parenthesis around my `return` values unless said value is a complex expression. You should also check out compound assignment operators. With them `freq = freq + inc1` becomes `freq += inc1`. Other than that, you hit on some pretty decent conventions. Your `main` function has a return value, which is great. In time you will understand how and why you could write the same program as: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int inc[2] = { 100, 1000 }; int freq = 100; int n; int array[18]; for( n = 0; n &lt; 18; n++ ) { array[n] = freq; printf("%d\n", array[n]); freq += (n &lt; 9) ? inc[0] : inc[1]; } getchar(); return 0; } EDIT: Formatting and forgot the double pointer on the argument vector.
FYI, `PAUSE` is a Windows command, and is used quite frequently used when writing code in something such as Visual Studio to stop the command prompt from closing automatically on program termination. Although it is not as portable a solution to this problem as `getchar`, it is useful when first learning the language.
There is no need to store the results in an array -- you can simply print the numbers as you compute them. Also you can generalize the problem by thinking of it as two loops -- one that iterates over an exponents of 10 and the other that multiplies 1 - 9 by 10^exponent. It requires you to write a simple integer pow() like function. /* Compile with C99 flags. */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int ipow(unsigned base, unsigned exp) { unsigned rc = 1; for (unsigned i = 0; i &lt; exp; i++) rc *= base; return rc; } int main(int argc, char *argv[]) { for (unsigned exp = 2; exp &lt;= 3; exp++) for (unsigned i = 1, m = ipow(10,exp); i &lt; 10; i++) printf("%u\n", i * m); exit(0); } So now if he wants you to print the 10000 - 90000 or 100000 - 900000, you only have to change one line. 
Cheers for this code it works great. The only reason I use system("PAUSE") and return(0) is beacuse that's how I've been taught it, like I said pretty new to the language and programming isn't my strong point. 
What's a text archive? Is that just a text file?
If you are referring to a specific line number you can just read until EOF and split on newlines in a char** array, or read since lines at a time and count as you go? It seems like you are missing a lot of details in your question. What is the compiler for? Why has this been an issue given the above trivial solutions? Is this a straight text file? Is it small enough you can read the entire thing in at once?etc. 
I have a file with the following pattern 1,6,1000,1001,10000 2,5,1500,1001,10001 3,8,10000,10001,10002 4,20,10002,-1,x 5,1,1000,1001,8003 6,10,8003,-1,1000 now i need to replace that x on line 4 with number 6 and then return to continue writing so i need a way to 1) find the line containing the x 2)replace x with the last line's number 3)return to continue writing
You could use `fseek` to do this, but beware that if you overwrite "x" with something longer, like "10", you will be overwriting the next byte in the file. It sounds to me that you are writing the file before you know exactly what data you want to be writing, so I think you should be doing this work in memory. Use an array or some other kind of data structure. Once you have worked everything out in memory, write everything to the file at the end.
&gt; What do the two bitwise operations do when p is a memory address. They are not applying bitwise operations to memory addresses. The pointer&amp;nbsp;`p` is a memory address, but `GET(p)` dereferences the pointer&amp;nbsp;`p` and returns the value at that address. &gt; Doesn't ~0x7 just make 0x8 No, `~0x7` is the bitwise complement of&amp;nbsp;7. In binary, 7&amp;nbsp;is 00000000000000000000000000000111 on a 32-bit machine, so `~0x7` is 11111111111111111111111111111000. ~~On a 64-bit machine, it's the same, except these things are 64&amp;nbsp;bits long.~~ EDIT: Probably not true: `int` is usually still a 32-bit type on 64-bit machines. The expression `GET(p) &amp; ~0x7` fetches the value stored in memory at address&amp;nbsp;`p` and sets the three least significant bits of that value to&amp;nbsp;0.
That makes a lot of sense, thank you for your time! So the fact that they use ~0x7 is just to make the code work on both a 64-bit and 32-bit machine?
I think that the main goal of it is to essentially mask off a portion of the variable. Essentially it says, "give me the value of p, ignoring the lowest 3 bits". It's written this way because when you're putting operations in a #define, you want it to be both simplistic looking and in operation. bitwise operations are actually fairly simplistic when the code gets compiled, and if I remember right are actually single lines of assembly.
maybe reading and writing straight to a 2nd file? (replacing the x when it comes about). in the end you just replace one file with the other. might save you some memory troubles
That depends I think. Operands should be promoted to the largest int-like type in that expression.
Don't use -8 in place of ~0x7. The C standard allows for one's-complement to be used. (This is also why you shouldn't overflow a signed integer.)
I see. That's a good point. I should have been more suspicious when I found myself writing about the actual bit representation of something in&amp;nbsp;C. The C&amp;nbsp;standard never specifies that kind of thing. That being said, are there common architectures that don't use two's complement?
I don't think I know of any. If there are contemporary one's-complement processors out there, they're probably DSPs. That said, even if you don't expect your code to run on obscure processors, the compiler still has the option of taking advantage of undefined behaviour for optimizations. And even if it doesn't currently take advantage of something, it might in the future. See: http://blog.regehr.org/archives/918
Right, I know. Thanks for keeping me honest. :-)
 int compare(struct structure *first, struct structure *second) { return first-&gt;average - second-&gt;average; } Then, in your display function, before you do the printing: qsort(everything, 13, sizeof(*everything), &amp;compare); everything is now sorted. 
hei_mailma already showed how to use a compare function as a function pointer to the qsort call. I'd just add that I'd never put average as a struct member though as it depends on your scores[4] field. http://pastebin.com/CbbAEag8
That's a good point. The result of `~` is still 32 bits, but it'll get sign extended to 64 bits as necessary. This is why you really don't want `~7u` or `0xFFFFFFF8`. \* Oh, but the largest int-like type is `unsigned int`.
Here's another possible solution - /* prints 100-900, then 1000 - 9000 */ #include &lt;stdio.h&gt; int main() { int i = 100; /* variable to hold the value */ while (i &lt; 10000) { /* while the value is less than 10000 */ printf("%d\n", i); /* print the value */ if ( i &lt; 1000 ) { /* if the value is 0-900 */ i += 100; /* the increment is in 100s */ } else { i += 1000; /* otherwise increment by 1000 */ } } return 0; /* return successful execution */ } ++++++++++++++++++++++++++++++++++++++++++++++++++++++ HOW IT WORKS: In the first line of the main function, we set an int variable 'i' to the value of the first number we want to print (100). This is outside the while loop. We then start the while loop, and test the value of 'i' (100) against the condition 'less than 10000'. As 100 is less than 10000, we continue on into the while loop. We print the value of i here (100), then test to see if the value is less than 1000. As 100 is not equal to 1000, we execute the statement below it, which is to add 100 to i, giving us a new value of 200. the if statement is now complete, so we go back to the top of the while loop, again testing to see if i is less than 10000. As i is 200, we drop into the if section again. When the value of i is 900, and we drop into the if...else statement, i will be incremented by 100 to equal 1000. On the next iteration of the while loop, 1000 is still less than 10000, so we go into the if...else statement. This time, however, i is equal to 1000, so we drop to the else. This now increments i by 1000 each time, as i will always have a value higher than 1000. Once i is equal to 10000, we exit the while loop (meaning 10000 is not printed) and return a 0 exit status to the OS. +++++++++++++++++++++++++++++++++++++++++++++++++++ Let me know if this helps in any way - sorry it's a bit behind the other responses!
Well, except it's not acting on a pointer. And you can't just lop bits off of pointers, you need the actual space to be aligned, in which case the pointer would already have zeroes there. So if this *were* acting on a pointer, it would be because someone's reusing them as tag bits, probably.
You're computing the same averages many times. Wouldn't it make sense to save the average as a struct member to avoid that?
If Apple's frameworks are "full of quirks", I wonder what your opinion on raw Win32 is....it must be somewhere between "full travesty" and "crime against humanity". 
`pthread_join()` is *blocking*. It waits for the thread to return before continuing. What you've written is a sequential operation with work done on four different threads for no reason. Instead you need to `pthread_create()` all of your threads first, then `pthread_join()` on each of them. This will allow the threads to run in parallel. 
Thanks, that makes much more sense. The master function will be able to utilize the structures just by creating references to each of the variables inside right? 
Thank you. Not sure why I had it the way I did. 
Amen.
It seems like they were desperate to reuse as much of their 32-bit stuff as possible, and didn't want to have to deal with finding and fixing bugs in their own non-portable code. (Similar problems caused Microsoft to forsake all big-endian architectures.) But yeah, fucking annoying ABI they came up with. Doing a setjmp quickly is pretty much impossible because of the amount of state you have to spill and the alignment requirements for SSE loads/stores.
It looks like you've got the help you needed, so here's a quick story this reminded me of. I was working on a C# application for my college job that was developed a couple of years before me; the application had a number of text fields labeled Date1, Date2, Date3. etc.., but they were not in a list. The programmer before me needed to do some work on all of them, and seemed to understand that they should be iterated through in a loop, but not quite that he should add them to an array to iterate through. So he wrote this: for (int i = 0; i &lt; 7; i++) { if (i == 0) { //8 lines of code on date1 } if (i == 1) { //same 8 lines of code on date2 } etc... } The feeling in the pit of my stomach when I realized what was going on was dreadful. 
pthreads can return something through the second argument in pthread_join() (which you are passing NULL into) or they can share data with the main thread simply by using the same global variables/structs/etc. Make however sure that no two threads ever try to access the same data, or undefined behaviour will occur.
Filthy filthy never-to-be-repeated-except-quietly-and-covertly GCC/Clang/ICC trick: #define def(x) __asm__(".if 0\n.endif" : "=X"(x)) This will make the compiler think a variable has been initialized without actually doing anything to initialize it. (The .if 0/.endif is necessary to prevent ICC from parsing the assembly and optimizing things.) Only works on non-struct/-transparent-union types, IIRC.
So if i'm trying to pass the structure from worker 1 into worker 2, would i have to do pthread_join(worker1,a) before i do pthread_create(&amp;worker2, null, worker_func2,a) because as of now i'm getting an error saying for the worker2 saying that 'a' is undeclared which makes sense because I'm not returning a until after i create the second worker. 
Yes. The proper way to do this would probably be by sharing some global variables between the threads. The main question you need to think about first, however, is "what data do I have?" and "in which order do the threads need to access that data?" for instance, does worker2 need to access the data "a" before worker1 is finished with it? Does worker2 indeed need to wait on worker1 at all, or can you make worker2 work on its own separate "portion of data"? If worker2 really has to wait for worker1 to return a result, so that it can continue processing that result afterwards, there is no point in using threads in the first place. If you need worker1 and worker2 to "interleave" their access to the data (worker1, worker2, worker1, worker2, ...) or something like that, you can use a mutex. So start by drawing something like a flow-chart that explains the way the data takes through the threads from start to finish, and then try to parallelize that, so that each thread gets its own chunk to work on, without having to interact with the other threads in any way (so no real datasharing between the threads; each thread only ever touches his own data) and then from the main thread you can join them all and collect all the results from all the threads together into one big result. Fairly stupid but simple example of what this could look like: *add all the numbers from 1 to 4 000 000 on a 4-core machine.* analyzing this problem, we see that there should be no issue with each thread taking a completely separate chunk of the work. Each thread can do its thing, and afterwards we stitch the results together. The algorithm we can use (in pseudocode): global array results[4]; function main: spawn as thread: worker(0, 1, 1 000 000); spawn as thread: worker(1, 1 000 001, 2 000 000); spawn as thread: worker(2, 2 000 001, 3 000 000); call as function: worker(3, 3 000 001, 4 000 000); join all threads; local variable final_result = results[0] + results[1] + results[2] + results[3]; print final_result; function worker(index, start, stop): local variable accumulator = 0; for(i = start; i less than stop; i++){ accumulator += i; } results[index] = accumulator; exit thread; It's not always this simple, but if you can get your problem into a shape like this, it will always benefit from using threads, and be easy to get right (so this is like the best thing that can happen, always try to think about whether you can make your algorithm "data-parallel" like this). But it is easy to think of many more problems that can be attacked in a fashion like this, such as processing an image by giving each thread a certain set of pixels to work on, or processing a video by giving each threads a subset of the frames to process. For more complicated types of problems and interactions between threads, you can use mutexes, semaphores and such, but I assume you would learn about those later. Again, remember to never let two threads manipulate the same data simultaneously (unless the data is strictly read-only) otherwise undefined behaviour occurrs. Two threads trying to write a result to a variable simultaneously may completely corrupt what you end up with.
It's too bad I only have one up vote to give. But I am actually working with images so this will help me a lot.
"Raw Win32" vs what other version of Win32? Anyway, clearly you have beef with it. I'm sure this is the case for most people, but I've only worked with a fraction of the API, so I can't say for all of it. Perhaps my statement of the Apple frameworks being "full of quirks" was from bad experiences with it, and seeing ugly stuff as a result of it in others code (memory leaks, etc). The Windows API itself I think is a decent API, and it's documentation is excellent, giving me pretty much exactly what I need every single time. The headers themselves might follow poor programming practices and cause clashes in other code, but it's easily dealt with, that once you have the right defines in-place, it's not as painful as it normally is so is forgotten about. So, as it stands I don't think the Win32 API and frameworks are a travesty what-so-ever. Outside of that, sure Microsoft has other things that follow what you say, but Win32, not so much. So, what have you found to be such a crime against humanity, that's left you so bitter about it? 
Those programs are designed to consume all input (i.e. until the EOF condition occurs) before printing anything. If you are typing something interactively, then you need to manually signal the EOF condition, otherwise there is no way to know when you are done. On a linux system that's usually ctrl-D, but you can check by running `stty -a` and looking for something like `eof = ^D`. Pressing return is not the same as the EOF condition. 
Ohk, thank you for helping me with that. It is very unclear in the text as far as that goes.
Seems typical of the C# code I've seen. :\^)
Probably the text doesn't mention this explicitly because it's somewhat OS-specific and thus outside the scope of a C programming book. (e.g. `stty -a` wouldn't work on Windows, and CTRL-Z would produce an EOF on Windows).
Interesting perspective. Maybe our programming styles differ too much, but I find raw C code, as used by MS to be ugly. Some functions take 17 arguments, some take one that is a struct with 17 members. It's chaotic, obviously written by different people at different times with no standards in place. In fact, this was admitted by MS at one of their //build conferences. They just *recently* implemented strict standards (starting with Windows 8, in fact) as to how to write API's. Writing C code for POSIX systems is a pleasure. Clear, simple, *beautiful* API's that I learned in college and haven't forgotten since. Win32? Mother of god. They're just chaotic. There's fairly modern C code, there's *really* old-style C code, there's COM, MFC, ATL, it's complete and utter schizophrenia of different programming styles and a free-for-all. Every time they release a new set of API's, it's a gamble as to how easy they'll be to use. Apple on the other hand have Obj-C and C, and *that's it*. Consistent style, clearly defined ownership semantics and memory management rules (oh COM, how I hate thee). I can pick up any new Apple API in a matter of hours. With Microsoft.........I'd better have some books handy and some tutorials/blog posts or it's like wading through mud. I can *do* it, but my productivity is reduced by roughly 82%. At this point, I pretty much refuse to touch Win32. My windows programming is 100% .NET C# and nothing else if I can help it. For my own sanity's sake. 
If you were using this for anything real, you probably wouldn't do it this way. You would probably use a library on top of pthreads to help you, or else write your own mini-library. Thread startup and tear down has some overhead, so you probably would want to use a thread pool. [Glib](https://developer.gnome.org/glib/2.31/glib-Thread-Pools.html) has one that I'm familiar with. You create the pool and tell it what function all of the threads will run, then you push it data, and it assigns it to a free thread. (In your example, that data might be a struct with a function pointer and then your single parameter) Glib also has [Async queues](https://developer.gnome.org/glib/2.31/glib-Asynchronous-Queues.html) which are good for passing data between threads. I'm not saying Glib is a great thread library, but it has some functions that I'm familiar with that implement some higher level concepts on top of pthreads. And most of the time, you really want to use some library that does that.
I think our styles do differ. Also I speak from my experience with their Win32 C++ API; it's been a while since I've done C# outside of Windows Forms. But yeah, I see your point, the C-style API isn't for everyone, and people will say it's an antiquated way of creating a C#/C++/Objective C API; and yes, the parameters do get out of hand at times. Actually, you are too right, it is a mess of an API, that I've just become used to dealing with. Though, I feel to some extent simplification would hide low level functionality that you might access to at times. So maybe the API's are designed differently, or our expectations of what they should offer? You'd want a nice high level API that's easy to use, whereas up till now I expect a low level API that gives me access to the nitty gritty details. Though, I would actually prefer a higher level API from Windows, now that you mention it. But only if it doesn't come at the cost of performance. So I think that's where the problem lies, high vs low level API. I know Windows does offer varying levels of their API that are lower vs "high" level. Should they design a high level API and a separate low level API? Should they keep it mixed together like they have now? And by mixed, I mean low to lower level, since they don't really have terribly high level API's that come to mind. For instance, if you thought the functions you worked with were horrible to work with, you should check out the Win32's memory management functions; these are incredibly low level, things that are used inside of something like malloc/new, or other memory allocator replacements. So, part of the problem is that you're expecting the Win32 API to be higher level than what they offer, I think. To get what you want you'd need a library that wraps around the Win32 API. Though yeah, the API could still be better designed. Just spewing some thoughts, since you've made me think more about not just accepting the API I was forced to use. I know I'm trying to learn more about designing a good API, so I'm actually kind of glad you brought up these points. 
Sounds like a homework problem. Take a really close look at the for loop surrounding count_occur and run it through your head. 
* Look at your initializing -- you are doing 3 assignment operations. The goal is to be a random assignment. Is these 3 assignments the right way to do it? * in your middle code -- you give yourself a hint -- the diagonal offsets are 0 0, 1 1, 2 2, 3 3. You look at every element of the 2 dimension array and when the offsets are equal you print something out. Seems like a lot of time spent looking at part of the array that won't hold your answer. Keep in mind you can re-use variables as you need them. You don't need unique variables for row/col. * the 3rd part has you doing a for-loop. 1 time. To count the occurance. If you just need to do an operation 1 time - do you need to even have a loop? A common and easy thing to do in C when typing in your code is get assignment and equality mixed up. In other words becareful when you use mix using a "==" with "=". Make sure your logic checks are using "==" and your assignments are "=". * Your program lays out the code by single task. First you set the array. Second you display the diagonal values. Third you count the value. The cool part about programming is you can do multiple things in 1 task. Programmers like to try to avoid repeating loops or similar work in their solutions. Ask yourself what does your 2nd and 3rd task have in common. Could both be done at the same time to avoid going back and checking the array each time? 
What do you mean when you said "You don't need unique variables for row/col", you mean in the int declaration part?...or the define part? like should I erase one of the for(i=0; i &lt; ROWS; i++) and put for(i=0; i &lt;A[ROWS][COLS; i++) or something?....would you please be specific on that one?  when u said the "3rd part has you doing a for-loop. 1 time. To count the occurance. If you just need to do an operation 1 time - do you need to even have a loop?"....actually I am counting 1s and 0s, yes it is one operation but i needed to do it twice for 1s and zeros  I can actually count 1s with the code above, but not 0s , every time I do that the "else if (if ==0) { printf("\n\nThe value %d was found %d times.\n", value, num_occ)} the line just wont print anything  I've corrected the initializing part and just left A[i][j] = rand() % 2; still works as before that was my mistake. Bear with me I'm a newbie in this stuff...I'm not some fancy iphone developer, lol. Thanks for your help 
In the code above i followed your suggestion, i replaced it with this: for(value=0; value&lt;num_occ; value++) { num_occ = count_occur(A, 10, value); printf("\n\nThe value %d was found %d times.\n", value, num_occ); } BTW, I'm doing it with 10 elements first the i will replace them with 50, so and my output is: 1 1 0 0 1 1 0 1 1 1 The value 0 was found 7 times. The value 1 was found 3 times. The value 2 was found 0 times. Process returned 3 (0x3) execution time : 0.045 s Press any key to continue. Dude, this values are correct except for the last one...Why the hell is printing "The value 2 was found 0 times." where is it getting the "2" from...gosh im so close to finish this 
Actually, No... the values are backwards...a common problem I've been having in this exercise...but awesome suggestion
Here's a potential problem: &gt; infix[j] = ')'; //put ) at the end This line overwrites the `'\0'` character at the end of `infix`. So then your `for` loop can't tell where the end of `infix` is, because the `'\0'` character is gone: &gt; for (i=0; infix[i]!='\0'; i++) { You're overwriting `'\0'` at the end of strings in other places too. I suspect this is the reason for your problem.
While that's probably a problem I don't think it's causing the seg fault. I've fixed that now and same issue. Like I said it works if either the while or the initial push is commented, but not when both are there. Bizarre. Thanks for looking over it.
What does your fixed code look like?
First things first: Run the program in gdb. It'll show you where the segfault is occurring very quickly. In gdb, once you've segfaulted, use the 'bt' command to get a backtrace, which might be handy. Use 'print &lt;variable&gt;' to get the values of things.
Notes: * As zifyoip mentioned, you're overwriting your null terminators. * You're passing pointers to arrays, but no sizes. If you're intending to add to the ends of your strings, you need to make sure that you're not adding past the size that you allocated for them! * It's not very nice to ask people for help and then subject them to code like: if(condition) do_stuff(); Always use curly braces, even if it's only one line! * If you find yourself copying the same code more than once or twice, turn it into a function. * If you're going to keep searching for the ends of your strings, at least use strlen().
When you are looping through the array along the diagonal, you are only doing any computation when `i` and `j` are equal, so as you are only doing something when they are equal, so you only need one of the variables. It might be helpful to also only have a single defined macro, such as `#define SIZE 50` as by their usage it doesn't seem as if there would be a case where `ROWS` and `COLS` would not be the same thing. When he is saying you are doing a for loop 1 time, he is refering to this: for(value=0; value&lt;1; value++) which only executes once (as the less-than is exclusive), you probably want to change the `&lt;` to `&lt;=`
In C, you usually pass the size of an array with the array, since you don't always have a way of knowing when the array has ended. Also, finding the end frequently is inefficient. Yes, it's much easier for a person to parse where a block of code begins and ends when it's surrounded by braces. Also, it's easy to forget to add braces later if you decide to add another line in the same scope. For example: if(cond) { ... } else delete(foo); Now, if you wanted to also set foo to NULL after it's deleted: if(cond) { ... } else delete(foo); foo = NULL; Well, this doesn't do what you intended. It will always set foo = NULL because it's not enclosed within the else condition; it's outside of the whole if-else statement.
According to ya'lls suggestions I made this changes: #define SIZE 50 int main(void) { int A[SIZE][SIZE]; int i=0, j=0; int num_occ, value=0; for(i=0; i &lt; SIZE; i++) { for(j=0; j &lt; SIZE; j++) { A[i][j] = rand() % 2; } } for(i=0; i &lt; SIZE; i++) { for(j=0; j &lt; SIZE; j++) { if (i == j){ printf("%2d", A[i][j]); } } } ****rest of it remains the same**** and my output is: 1 0 1 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 1 0 0 1 1 1 1 1 0 1 1 1 1 1 0 The value 0 was found 22 times. The value 1 was found 28 times. Which I dont think is correct, cuz if I count them by hand there should be 25 ones and 25 zeros...so what you all think?...is this correct ? 
Try stepping through it and see what values the things take. 
Should pass argv[1] rather than &amp;argv[1] You're passing the *address* of the string command line argument rather than the argument itself.
I tried doing this before, either way it still seg faults at the same line. 
put: printf ("%s\n", parameter); before the call to read_pnm(). Should be a valid string. Presumably you are giving a filename as a command line argument? 
Are you checking for the number of arguments (e.g., argc &gt;= 1)? If you're running the program without any arguments, bad things will happen.
You should never have to cast to void\*. I'm guessing you did that because it complained that you were passing a char\*\*. Get rid of that &amp; before argv[1]. You should also make sure that you're passing enough command line arguments, or else accessing argv[1] is undefined! For example, on the command line: ./myprogram arg1 Do you wait for all of your threads to finish before returning from main? This is usually does with pthread_join(). If main returns, then the accessing the value of argv[1] will be undefined. Also, your program might terminate without killing the threads. (I can't remember exactly what happens.)
yeah i'm passing in the file name for the input image as the input as the first argument. When putting the printf() it just gives the seg fault at that line. 
Can you change the %s to %p. Are you on a 32-bit or 64-bit machine?
64-bit machine and the change didn't seem to do anything. 
It should have printed a value before segfaulting.
this is what I'm getting from my compiler now: Bus error (core dumped) 
hmm that's a bit weird. Can you post your prog on pastebin.com 
[pastebin](http://www.pastebin.com) 
warning, it may be a little sloppy. http://pastebin.com/fLjPXSLS
Can't see it - says it's a private paste
should be public now.
Ah, the problem is this: unsigned char image2[rows][cols],image3[rows][cols],image4[rows][cols],image5[rows][cols],image6[rows][cols]; rows and cols haven't been initialized yet, so it's declaring huge arrays with the garbage values they currently hold. This means you run out of stack space, and the next instruction to use the stack causes a segfault/bus error (in your case, it will probably be pushing an argument on the stack when you call a function). 
Thank you so much for taking the time to look at it. I wouldn't have even realized that this could be the issue. I moved that line down to below where the image is being read and the rows and columns are being outputted. It got rid of the bus error but I'm stuck with another seg fault when I'm trying to create a 2d array from the 1d pointer. It's line 178. for (i=0; i&lt;= r; i++) for (j=0; j&lt;= c; j++) { image2[i][j]=imagePoint[i*r + j]; } I have a feeling it's the way i'm trying to implement it, so I'm going to try and change how I have it. Thanks again for your help. 
No worries, was an interesting one :) As for the next bit, maybe the &lt;= should just be &lt; You could be reading past the end of your image data otherwise. 
Instead of answering your question, I'll point you to the tool I use to debug these problems: valgrind. It will tell you where you first write to unallocated space or use an uninitialized value, which is almost always the specific cause of a segfault. 
just ONE more question, I promise it's the last. When I try running the program I'm not sure why but it won't exit from the third thread that I create. It's getting stuck for some reason even though I have it joining. [New Thread 0x7ffff7501700 (LWP 21503)] second char 53 image read successfully rows=448, cols=448, type=5 imageIn.pgm [New Thread 0x7ffff6d00700 (LWP 21504)] [New Thread 0x7ffff64ff700 (LWP 21505)] [Thread 0x7ffff6d00700 (LWP 21504) exited] [Thread 0x7ffff64ff700 (LWP 21505) exited] [New Thread 0x7ffff64ff700 (LWP 21506)] It's just staying at this point until I kill it manually. Any ideas of why this would be happening even when I have the thread joining? 
Thank you for this, I'll definitely use it next time I run into a situation like this. 