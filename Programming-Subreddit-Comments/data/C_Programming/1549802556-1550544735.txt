And a little more detail to add -- if the first symbol of the provided filename is '|', use popen. If it's not, use fopen, which is basically what SQL is doing there. This also allows you to add a variety of handlers, like 'http://'. 
Has this been compiled with warning levels set high enough? If so, I think you'd get warnings that might give a better idea what s wrong with this code. Personally, without having run it, I'd guess that this program crashes as soon as it tries to use the stdin FILE pointer. The reason being, on line 12 of the first code example, the system-wide standard stdin pointer is being *hidden* by a pointer with the exact same name, which is not being set to any useful value. As soon as that pointer gets used, your program ought to crash... To fix it, just comment-out that line.
For the counter it depends: if your program was to loop I would say use a static int in loan application, but as it just runs through and exits you may have to keep track of this with a file, also are multiple users going to use your program? As for exiting well BREAK (CTRL + c) works wonders and you can make a signal handler if you want your program to do something before exiting, otherwise you will have to use scanf to get a string rather then an integer, check if the user inputs something such as "exit" if not then use atoi() to convert the string into an integer and carry on.
For the maximum retry count: add 1 variable and 1 constant to your program, e.g. int currentRetryCount = 0; const int maxRetryCount = 3; and then put the bits you might have to repeat 3x within a loop. For the quiting-at-any time bit, you could add an int quittingEarly = 0, and then in all of your input-getting functions, if the user indicates they want to quit, set quittingEarly to 1, and then surround each bit that asks for input with an "if (!quittingEarly) {" and "}" bit. 
&gt; But there's still the use-case of supporting cross-platform programs which are still there and the newer WSL-Stuff. Care to elaborate on the correlation between the Linux subsystem and C11 support? I'm not seeing the connection.
&gt; DEC ?
Why not use the types from stdint.h ?
Works as advertised with gcc 6.4.0 and clang 3.4.1, though clang gives warnings about tgmath.h and ccosl, csinl. Pretty picture.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/ap4nwv/consider_voting_trying_to_convince_microsoft_to/
I would recommend this library: https://github.com/jedisct1/libsodium
There’s a library called LibTomCrypt that I used for an encryption/decryption terminal program a while back. Great documentation and easy to use! Even posted it on this sub and got a *lot* of great criticism haha.
D|I|G|I|T|A|L DEC!
It's just that MS ia getting into cross-platform compatibility more and more, which kind of demands modern C support, too. I didn't intend to imply a direct connection though.
I'm sure your shittily named API and garbage code is much better than my magnificently crafted software. 
OpenSSL is probably the most widely used so there’s a lot of good examples and support out there, but WolfSSL is my personal favorite because the library is much more lightweight and easy to use. 
My calling conventions don't cause privilege escalation, so the bar's kinda low. 
A fundamental principle of deprecating features is that there should first be alternatives which are in essentially every way superior. Microsoft C supports many "popular extensions" alluded to in the Rationale for the C Programming Standard, for which the Standard has yet to define any practical alternatives, such as the ability to have a function operate on arbitrary structure types that share a common initial sequence--something for which the authors of the Standard may have intended to require support, but which neither clang nor gcc can process reliably unless optimizations are disabled. 
thank you for your (teacher) opinion - you are right! I will first try raylib since it looks the "easiest" for looking into game development in C. It is just a little bit hard to find some (real good) tutorials..
C# is off topic in this subreddit. Please post C# content to /r/csharp.
If the file is opened in text mode, CR characters are automatically filtered from the input.
Neither C++ nor C# are on topic in this subreddit. Please post questions about these in /r/cpp_questions and /r/csharp respectively.
#object region of data storage in the execution environment, the contents of which can represent values. (cf. ISO/IEC 9899:2011 §3.15)
C# is off topic in this subreddit. Please post C# questions to /r/csharp.
"thanks for the response but I ended up doing exactly what you suggested" ok mate...
Ah whoops il delete this and post it there thanks 
Gcrypt is what I usually use :)
LibSodium or MbedTLS depending on what you want to do. If I were you I would avoid RSA completely and go straight to ECC.
Then I'll leave the handler as is. I really like the way signal handler is separated from main execution with a self pipe trick. Reminds me of the first quote on [this page](http://quotes.cat-v.org/programming/). From `Xserver` man page: `-noreset` prevents a server reset when the last client connection is closed. You are totally right on that, thanks!
Why would you go with ecc over rsa? 
You forgot a semicolon in line 10. The error message says exactly what the problem is.
well yeah I guess I was blind when I was going over my code 
It's the future.
Challenge mode - non real solutions
Basically anything except openssl
Always listen to the compiler's error messages. They usually tell you pretty much what you need to know.
If you want to use a library with a smaller footprint consider BearSSL.
Challenge part 2: calculate real and imaginary solutions simultaneously. (SIMD intrinsics are allowed)
ECC can provide the same security as RSA with much smaller key sizes e.g. a 256-bit ECC key gives the same security as a 3072-bit RSA key.
Check out http://noiseprotocol.org does that and a lot more. Has a good c reference program.
raylib is quite new (about 5 years old) and yes, there is not much documentation; you have a cheatsheet, about 80 code examples, some game samples and some templates... [raylib Wiki](https://github.com/raysan5/raylib/wiki) also has some info and [here it is](https://github.com/raysan5/challenges/tree/master/01_challenge_blocks#challenge-01-blocks-game) a game tutorial. In any case, [raylib Discord](https://discord.gg/VkzNHUE) community is pretty active and open to help, I'm usually around... You can also drop me an email to ray[at]raylib.com anytime.
I like C a lot because the language itself is simple with a small standard library but not limited as a result of those things. I like C++ too, and I also really like Java (the little of it I've learned), and Python. But C is my favorite. It feels like playing with legos in the best kind of way. 
Not only with a smaller footprint, but also with a [better security record than anything else except BoringSSL](https://twitter.com/cryptopathe/status/1093789855522410497). Also, OP should consider not embedding crypto in their software, but instead, making it easier for their software to interact with a generic TLS layer such as [stunnel](https://www.stunnel.org/) or the s6-tlsclient/s6-tlsserver programs in [s6-networking](https://skarnet.org/software/s6-networking/). The latter of which can be built against BearSSL.
Well what is your class book and what section are you on? 
RSA is made almost entirely of foot-guns.
Do you always attend class? You could try emailing the professor about the truth table he or she is referencing. Professor’s and TA’s are usually more than happy to answer questions about material, especially if it was covered in class. Odds are this was mentioned, even in passing. My professor would mention details, seemingly in passing, and it would be on a quiz the next class. Students were confused and frustrated no emphasis was placed on the material. But I digress. Ask the professor or TA’s for some guidance or information on the topic 
He recommends looking things up online. 
I’m wondering if you meet the requirements for this class, or if the folks who put the course together are just confused. 
Since you're asking for C++ resources, but only C is on topic in this sub, i suggest asking in /r/cpp_questions instead.
Yeah, wrt the warnings I am using a lot of C99 features here; happen to like it. Actually, Bart over on comp.lang.c mutated my code to a point that should compile with C89: &amp;#x200B; [https://groups.google.com/forum/#!original/comp.lang.c/4196m3Raggs/6z7kaM5fEwAJ](https://groups.google.com/forum/#!original/comp.lang.c/4196m3Raggs/6z7kaM5fEwAJ) &amp;#x200B; [https://pastebin.com/raw/tJFxYsb0](https://pastebin.com/raw/tJFxYsb0) &amp;#x200B; His mutation eliminates complex.h and tgmath.h. He also made it black fractal on white background wrt colors. &amp;#x200B; Thank you so much for taking the time to give my code a go oh5nxo! :\^) &amp;#x200B; Wrt C99, well, it should be old enough to have some wide spread support, afaict, my code is 100% standard.
Not sure why I did not use stdint.h. Well, some of the types might not be guaranteed to be there. I have some future planes for this simple portable code. Might have to move over to C++11 because of lack of compiler support for C11 threading. So far, the only C compiler I can find that handles C11 threads and atomics is Pelles C. &amp;#x200B; [http://www.smorgasbordet.com/pellesc/](http://www.smorgasbordet.com/pellesc/) &amp;#x200B;
Wrong subreddit. Try /r/csharphomework .
I’ve been in your boat. My discrete mathematics teacher was useless and terrible at explaining. So I’ll attempt to explain as I understand it. https://en.m.wikipedia.org/wiki/Truth_table Refer to binary operations above. !(A&amp;&amp;B) = !A||!B So let’s say A is True and B is False. Left half would go like this. Not (True and False) Inside the parentheses, it would evaluate to False. So the left side is Not False or True. So let’s do the right side of the equation. Not True or Not False This is basically False or True. So this looking at our tables tells us the right side would evaluate to True. I always had to think about this in programming terms replacing p and q with variables. But in mathematical terms, run through your tables and see if this is always true: ¬(p ∧ q)= ¬p ∨ ¬q If P was True and Q is True, this is still a valid equation. If P was False and Q was False, this is still a valid equation. If P was False and Q was True, valid, etc. hopefully this puts it together for you. 
Ok, thank you!
A truth table is just a proof by exhaustion. Show each possible input, and compute its output. The output either shows if the claim is true, or not true.
that is just retarded lol. yeah writing to a file specified by the user or stderr it totes a security hole. for any oses that are that fucking dumb, well, they deserve it. to say that your code is insecure for not writing it in convoluted ways to mitigate ancient issues is just dumb. but hey, keep writing your ugly code that's totes secure against every possible issue, i'm sure it'll pay off.
&gt; for any oses that are that fucking dumb, well, they deserve it. Dumb for... doing the thing that you're doing in your library? I mean I agree, it's just hilarious to see you call something dumb for doing the thing you're doing. &gt; to say that your code is insecure for not writing it in convoluted ways to mitigate ancient issues is just dumb. If you think enums are convoluted, you're going to have a bad time when you get past Elementary C Programming. 
Have you considered trying pthreads first or do you just prefer switching to a language with threading built in either way
I would almost argue the opposite - that ECC is better for now, but in the future with quantum computing, ECC should be avoided. https://security.stackexchange.com/questions/33069/why-is-ecc-more-vulnerable-than-rsa-in-a-post-quantum-world
Your professor sucks. Isn't there anything in the lecture slides / materials about truth tables? Binary logic is very handy later on when you want to manipulate bits and bitfields...
The go-to website for c++ would be http://cppreference.com/. Ask away if you have any specific questions about the language.
There's a great web site, where you can find answers to this and many more questions much quicker than posting on Reddit. Bookmark it, because it is a very important source of information for programmers and students, especially when not all aspects are explained during class sessions. The link is https://www.google.com
If memory isn't a problem, you could load every word into a struct struct replace { unsigned long string_length; char *replace_string; char *replace_cmp; struct replace *next; }; struct word { unsigned long string_length; char *word_string; struct word *next; }; 1. Fill the struct word with the FILE 2. Fill struct replace with a vocabulary 3. compare \*word\_string with \*replace\_cmp 4. If they're the same, free the char \* of word\_string and set it to \*replace string ( or copy the memory into a new calloc() ) 5. print the whole struct word to a FILE and free the structs + char \* Every word in struct node will use: strlen(word\_string) bytes + sizeof(long) + sizeof(void \*) struct replace: strlen(replace\_string) bytes + strlen(replace\_cmp) + sizeof(long) + sizeof(void \*) It'll eat a lot of memory and it'll take "a lot of time" to loop through everything (growing extremly by the size of the files). &amp;#x200B;
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Linux is just a shitty clone of (more or less) 4.3BSD, a system from 1986 (that still continues to thrive).
Signal pipe could be made O_NONBLOCK. But that's over the top :) Regarding the unsticky kbd setting, another possibility is the window manager. I had trouble setting the screen saver before I saw that wm also configured it elsewhere during startup.
https://idownvotedbecau.se/imageofcode
[https://man.openbsd.org/getchar](https://man.openbsd.org/getchar) getchar returns EOF at the end of a file and EOF is an int &amp;#x200B; If getchar() should be able to return every possible char, there needs to be a thing to say: "I end here". And if there's no char left, they have to use another thing: an int
Nah Linux is more SYSV to its heritage. Now thanks to systemd its just total shit. 
Come on dude take some time to read the rules and learn to format your code properly. It is literally less time for you to read that than taking a screenshot. You haven't provided us with the Mergesort function, which seems the most likely candidate here. 
It'd help if you posted the exact error message. My guess is that the problem is happening inside the sorting functions that are in turn called inside your p12 and p12 programs. Since sorting programs often maintain two index values into an array, I would look at those. Somewhere you probably have a for-loop that is either going one beyond the end of an array or you are setting a second index inside the loop that is relative to the for-loop counter and it is going one element beyond the beginning of the loop. For example: for(i = 0; i &lt;= arraySize; ++i){ for(j = i-1; j &gt;= 0; --j){ //error is here--&gt; j=i-1 could segfault when i = 0 //sorting code here } } So, take a look at places where you increment or decrement your array indexes. Somewhere you are going outside the bounds of your array, either at the beginning or at the end. IT could be due to incorrectly setting a nested index (like my example above), or maybe you have a loop that uses &lt;= when you should be using &lt; or something like that. 
In my case it was solely the lack of `-noreset`. I've got one more option for signal handling: since I don't bother which signal happened I can raise a `sig_atomic_t running` in signal handler and do `while (running) pause();` in main function. I guess it should work properly. Your thoughts?
This is only a shit in the dark. But I think you need to declare your array size with a constant. Try setting the array size with the raw amount instead of the variable.
Apples and oranges. SDL is primarily a window / pixel buffer / OpenGL context creation and event handling library, with some extra goodies thrown in. It has a long history and is stable and mature (Valve uses it). Raylib is a new all around game framework, with a focus on graphics. It's designed to be easy to use and to get beginner programmers into game/graphics programming. It rolls it's own window handling, so SDL is more mature in that regard. For your use case (pixelart game) both would work. If you want full control and draw every pixel yourself (software rendering), you can do that with SDL2 and SDL1. With Raylib you have to grok concepts like textures and (at some point) shaders, since you'll be working with the graphics card. Drawing every pixel yourself is much simpler (just write some bytes to a location in memory and boom, there's a red square). SDL2 comes with functions and types for making drawing 2D primitives much easier, and can also do it on the graphics card if you want too (like Raylib). SDL2 will definitely be a good fit, any way you use it. For advanced graphics you will have to utilize the graphics card and roll your own shaders. Both SDL and Raylib allow you to do this, but with SDL you will have to roll your own OpenGL renderer. From scratch. Raylib comes with it's own renderer that allows you to specify custom shaders. &gt; since SDL2 is mostly used for C++ I am worried that I can rund into problems and maybe limitations with using SDL2 in pure C SDL is a C library, it wasn't written with any C++ "features" in mind. From SDL's point of view, C++ doesn't exist. In fact, SDL even has some goodies that make C programming less painful, like cross platform threads. SDL is a "pure C" library the same way Raylib is. I personally have used SDL a lot and like it a lot - it's the old faithful. Some newer competitors like glfw do some things better and have less cruft, but you can never really go wrong with SDL. **tl;dr:** SDL is a C library with low-level, cross-platform abstractions for window creation / event handling, graphics, sound, input (controller, mouse, keyboard, force feedback) plus some other goodies. Raylib is a C library with high-level concepts for graphics, audio and math. It is more aking to a game engine or framework than to a low-level library like SDL. You can use both. I'd recommend starting out with SDL.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/learnc] [Adding Scrollback](https://www.reddit.com/r/learnc/comments/apgjaa/adding_scrollback/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hmm... Is there a race, reception of a signal after the test of running and before entering pause. There is sigsuspend() for this kind of situation, but again, complexity starts to creep up. Do you know pipe2(.., O_CLOEXEC|O_NONBLOCK) function/syscall ? You would not need to explicitly close the signalpipe in any child, and the (impossible) problem of blocking at write in the handler would also be solved.
I still remember which character was mapped to 255 in several popular pre-Unicode code pages, because so many programs would treat it as EOF.
Turning it around, if fopen (or open) is used and it just cannot be changed, named pipes could be used to tap into the data.
Don't know what NoMachine is, would it have trouble with 50'000 integers on the stack ? Try with smaller array or make array\[\] static ?
For \_CRT\_SECURE\_NO\_WARNINGS to have effect, it ought to be defined **before** \#includes ?
What's so hard about strerror? An array indexed by error code can suffice..
How do you define small pet project ? I've used simply a spawned "ssh -args address remote\_program" and it has never given trouble, no dependencies, updates automatically, I like it.
Again assuming you have enough memory... Read the files into memory. Replace the line breaks with nul. Keep track of where all the "first character after linebreak" is in an array of char*. Then, you have exactly what you want. 
Not that it's very hard, it's just more stuff to implement. 
For me ticket in the world of C was the study of computer architecture and OS. The first projects were: 1) Implementation of stack 2) Implementation of simple memory allocator 3) Implementation of simple file system 4) Implementation of simple parser for my own programming language 5) Implementation of different algorithms for random numbers generating 6) Reimplementation of standard math functions, such as sin, cos, tan, etc. 
You need to call the function once for each letter in the string. See if you can find a way to go over the string, getting each letter one at a time, and passing that letter to the function
Yeah, I believe it. I have a number of years of professional programming experience in addition to college degrees and this is a nice little side project. Not too difficult, not too easy. It his the sweet spot for me.
Ehm pretty sure there is a scrollback patch on st Did you check the patches section on suckless.org?
On first read it looks like your trying to mix two features. Vim mode and scrollback. Perhaps a simpler solution is to add vim mode as a patch on its own perhaps taking inspiration from Fish shells Vi mode (i’d use it). Then go solve the scrollback with vim mode having you already brought you partly to the solution.
Well... Let's do it this way. I just need help adding the ability to scrollback while I copy. I am doing the keybindings later.
You can use strings as an array to iterate over. Just remember, the last byte is a nulbyte in cstring. This can be used as a stop condition in a loop, for example `while ( (c = array[i++]) != '\0') {...}`.
Without having looked at your patch it seems the main difficulty is persisting the current window selection across refreshes of the buffer. Since what you selected is part of the state of the buffer you need to somehow store the selection when the buffer is updated by scrollback. Then when you get back to the selected content restore the selection. Depending how closely you want to stick to Vim’s behaviour you could also trigger an “append to clipboard” at scrollback time. But bookkeeping might be a nightmare. I might have a look at what you have so far a bit later
Without having looked at your patch it seems the main difficulty is persisting the current window selection across refreshes of the buffer. Since what you selected is part of the state of the buffer you need to somehow store the selection when the buffer is updated by scrollback. Then when you get back to the selected content restore the selection. Depending how closely you want to stick to Vim’s behaviour you could also trigger an “append to clipboard” at scrollback time. But bookkeeping might be a nightmare. I might have a look at what you have so far a bit later
I have no idea how in the world I would add that... I'll look around...
I dont know how applicable tmux could be here but its scrollback feature supports what you want i think so the source code might be an option; if not for X11 specifics at least you might get a feel for their approach
I'll check it's source code. I want to add this into my terminal as I don't want an entire other application to be a dependency for my terminal.
Nah i didnt mean it as a dependency but as an example of an application that implemented scrollback quite nicely
That would be amazing, I know the code is clean. OpenBSD doesn't settle for much less than perfect. If you or anyone else does have a moment I would help finding the proper lines to implement in my terminal and get them working. I am very excited to finally add this haha.
Here you go :) for (char c = 'A'; c &lt; ('Z' + 1); ++c) { someFunction(c); }
https://github.com/tmux/tmux/blob/master/grid.c This is the part for storing screen history and scrollback. It is quite a readable solution. Both the screen and state of the screen are recorded into a "grid" data structure and scrolling simply allocates/deallocates new lines in the screen. A history limit is kept for reasonable reduction in complexity.
Thank you :)
I moved to C after having been previously working with Pascal in the late 1980s, before the divergence between *the language the C Standard was written to describe* and *the language specified by the C Standard*. I really like the former language, and have been using it for many decates. Unfortunately, the name `C` is used to refer to both, and compilers vendors do not always make clear that certain options will cause them to support the latter language (which is not suitable for systems programming) rather than the former (which is suitable for systems programming, except when implementations which are specialized for other purposes). 
I looked at them, but I am unsure how to rip them out and put them in use in my terminal. Never done this before :(
I have been stepping through this code, but am unsure how to implement this into my code base. What exactly should I move over? I am confident whatever code gets moved will go into pt.c, but am unsure. I am not entirely sure how I would go about adding this stuff into my terminal.
Your code should compile cleanly and all tests pass **before** committing to the CI branch
UNIX and my love and infatuation of how hardware and software interact.
My solution is racy indeed. I've found some nice reading on selfpipe at [skarnet.org](https://skarnet.org/software/skalibs/libstddjb/selfpipe.html) which actually advices to use O_CLOEXEC and O_NONBLOCK. Also [signalfd](http://man7.org/linux/man-pages/man2/signalfd.2.html) might be a good candidate.
I got into C after having tried java, lua, and cpp and feeling like too much of an idiot to understand how coding works. C just "clicked" the way that those other langs didn't. I haven't done much interesting with it though outside of an unfinished buggy/slow software rendered 2d game/engine. 
I'll have a read through your code later but from initial glance its unclear what you added and where there is work TODO
I apologize for lack of proper commenting in my code, I am still learning myself. I would love some more help on this. Please feel free to read through all of it when you have time. 
The write shouldn't touch errno, as long as it succeeds, but better to save/restore. On BSDs there's a really nice combined mechanism, kqueue. File descriptor, process, signal, timer, etc events can be handled in sequence, with very little fuss.
I dare to switch to OpenBSD someday (: Btw, I've found the most [significant bug](https://github.com/sineemore/sxinit/blob/master/sxinit.c#L108). Damn, I desire some better tooling to prevent this kind of errors.
Here's a little table of the state of `--lim` and `i` after/while executing the loop condition (so before the loop body): --lim i 9 0 8 1 7 2 6 3 5 4 4 5 3 6 2 7 1 8 0 9 ← Loop would abort there (--lim &gt; 0) If `--lim == 0`, then it aborts the loop, ignores the `c == 'n'` if and thus writes to `s[9]`, which is in bounds. If `--lim == 1` and `c == 'n'`, it also aborts the loop, and thus writes to `s[8]` and `s[9]`.
This code makes the assumption that lim (the amount of `s` that `getline` is allowed to use) is larger than the length of the string. For example, if I invoke this with `lim == 1` and input a string `A\n` then my output `s` is the string "\0" (because its only allowed to use one character, which is the end of string character) similarly if `lim == 2` and input string is `ASDF\n` then my output string is "A\0" This is somewhat separate, and I think your actual question is: "on any string, will the addition of the end-of-string character overwrite the new-line character if one exists?" And the answer is no. You'll notice the use of the post-increment operator `i++` whenever indexing into `s`. Doing `s[i++]` gives me the value of `s[i]` but then (after) increments `i` by one. In this pattern, any access of `s[i++]` leaves `i` in a state where it indexes to the next value of `s`. This is why they can simply use `s[i] = '\0'`, because `i` already indexes to the next value of `s`. 
Here's what I had initially in mind. Not to insist on it, but just for laughs. #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define NUMBER(r) (sizeof (r) / sizeof (*(r))) static int termination[] = { SIGHUP, SIGINT, SIGTERM, SIGCHLD, }; static void cleanup() { } static void terminate(int sig) { sigset_t mask; struct sigaction sa; cleanup(); #if FANCY if (sig == SIGCHLD) _exit(0); /* else terminate by that signal, * like nothing special happened */ memset(&amp;sa, 0, sizeof (sa)); sa.sa_handler = SIG_DFL; sigaction(sig, &amp;sa, NULL); kill(getpid(), sig); sigfillset(&amp;mask); sigdelset(&amp;mask, sig); sigprocmask(SIG_SETMASK, &amp;mask, NULL); /* bang! */ /* should not be reached */ abort(); #else _exit(0); #endif } int main(int argc, char **argv) { sigset_t open; struct sigaction sa; memset(&amp;sa, 0, sizeof (sa)); sa.sa_handler = terminate; sigemptyset(&amp;sa.sa_mask); for (size_t i = 0; i &lt; NUMBER(termination); ++i) sigaddset(&amp;sa.sa_mask, termination[i]); sigprocmask(SIG_BLOCK, &amp;sa.sa_mask, &amp;open); /* safe from those signals now */ for (size_t i = 0; i &lt; NUMBER(termination); ++i) sigaction(termination[i], &amp;sa, NULL); /* spawn Xserver, xinitrc */ /* wait */ sigsuspend(&amp;open); abort(); }
Content that is not specifically about C but rather about programming in general is not on topic. Do not post here just to reach an audience of C programmers. Nobody cares about your survey.
Are you doing the OS from the ground up or are you working off a "skeleton" filling in various features and details?
Per `man 7 signal-safety` there is a limited set of libc functions one can call from a signal handler. `kill`, `waitpid` from `cleanup` and others you've used in a handler are among them, so it's a no problem. There is one thing that are unclear to me: is there a race with `pid_t` variables used by `cleanup`? Per `man 7 signal` is interruptible, but can I assume that if it succeeds than the child PID will be properly stored in the variable. IIUC, it is [not safe to access global variables](https://stackoverflow.com/a/24931611) from a signal handler, maybe volatile can help with this.
I generally prefer to use [this](https://github.com/nothings/stb/blob/master/stretchy_buffer.h). You really need to make sure you read the docs (in the comments) for this.
I usually start with embedded doubly linked lists (https://gitlab.com/sifoo/snigl/blob/master/src/snigl/ls.h) and vectors (https://gitlab.com/sifoo/snigl/blob/master/src/snigl/vec.h) as a foundation in C. The vector design I've been honing over the years is very raw; basically a dynamic block of memory that knows its value size, length and capacity. What I often find missing in other designs is value semantics, heap allocating a ton of integers just to store them in a vector isn't very constructive. I then proceed to build ordered sets (https://gitlab.com/sifoo/snigl/blob/master/src/snigl/vset.h) on top, which together with value semantics and structs gives me ordered maps. Then hashing (https://gitlab.com/sifoo/snigl/blob/master/src/snigl/hash.h) on top and so on. Production quality usually means over engineered from my experience, and the last thing I need in C is more complexity.
&gt;Have you considered trying pthreads first or do you just prefer switching to a language with well supported standard threading right ahead I have used PThread's for a long, long time. In fact, have you ever used them on windoze? Well, the following excellent library works like a damn charm: &amp;#x200B; [https://www.sourceware.org/pthreads-win32](https://www.sourceware.org/pthreads-win32) Been using it for quite a while. However, there were always issues about compiler support for POSIX. In C11, C++11, the threads are in there, and the compiler knows about it wrt the C std, not POSIX. Well, a compiler should know about POSIX if it claims to support it as part of the overall system. Fwiw, here is a little very crude C11 threading to PThread adapter I wrote: it is missing atomics: &amp;#x200B; [https://groups.google.com/d/topic/comp.lang.c/WPH7ed5uS4Y/discussion](https://groups.google.com/d/topic/comp.lang.c/WPH7ed5uS4Y/discussion) &amp;#x200B; raw code: [https://pastebin.com/raw/bJUbDmKy](https://pastebin.com/raw/bJUbDmKy) It needs PThreads to emulate the C11 threads, however what good is that without atomics and membar support? C++11 has the support I am looking for, and so does Pelles C. Unfortunately, that C compiler has some issues wrt its full expression of the atomics and membar essentials: [https://forum.pellesc.de/index.php?topic=7167.msg27217#msg27217](https://forum.pellesc.de/index.php?topic=7167.msg27217#msg27217) 
You don't need to allocate or reverse at all. Write the digits into a fixed-size buffer. The place where you stop writing is the end. Then just move a pointer from the beginning and a pointer from the end comparing digits to test for palindromisy. #include &lt;stdio.h&gt; int palindrome(int num) { char digits[32]; char* end = digits; char* start = digits; while (num) { *end++ = num % 10; num /= 10; } if (start == end) { return 1; } --end; while (start &lt; end) { if (*start++ != *end--) { return 0; } } return 1; } int main(void) { int c = 0; for(int i = 0; i &lt; 1000; i++) { if(palindrome(i)) { c++; printf("%d: %d \n", c, i); } } return 0; } Bonus: this works for negative numbers too now (the `digits` array actually stores the negative equivalent of the digits mod 10 in that case).
The suckless community. Actually I hated C before that. I originated as a JavaScript programmer (~10ya) with no meaningful background, started writing PHP several years after that but dropped that and jumped on a NodeJS train. Heck, at that point I didn't know a thing about system programming. My lifechanger was Go. I was asstonished with its ecosystem and language simplicity. For several years I was writing Go, a bit of Lua and was mastering Linux, hopped a few distros and came to Arch. Than the rice thing started where I finally met dwm, st and the community behind them. I've started changing dwm bit by bit, studing xlib and writing own small utilities. I've learned C99 cause I wanted to rice my desktop, guys. Now it's much more than that.
Keep coding style consistent for readability. Run it through a program like indent.
It's a very complicated solution. You try to generalize too much for a simple program. * Do you really need to keep track of the size separately? If you're using C strings anyway, why not use `strlen()` for the size? Like in `cmp_bufnum` you use string comparison rather than `memcmp`. * For `init_bufnum` I prefer that you return the pointer rather than accepting a pointer where the pointer is being written to. * For `terminate_bufnum` I also don't see why you want an pointer to an pointer; a `bufnum*` is enough information you need. * The name of `set_bufnum_to_arr` is a bit weird to me, it's essentially just copying it, so I'd suggest `bufnum_copy` or similar. * Couldn't you declare the globals `arr` and `rev_arr` without the pointers? So that you basically don't need to do allocation for those structs. * You also do `free`+`malloc`, which could be replaced with an `realloc`, where the memory allocator could do some optimizations. * You never check if any of the `malloc` calls fails. * With palindromes you usually at text, so I don't see why you accept an integer rather an string. * Since you only check for palindromes in integers, and they have limits, you may be just able to get away with an buffer with a fixed size that should be able to contain every integer combination possible (either the limits or since you from `0` to `999`, a 4-char buffer is also enough). Note that, to my knowledge, there is no real compile-time way to get the max size that an integer can take up when converted into characters in base 10. I haven't checked the reverse algorithm yet because: The palindrome checking algorithm is also not very efficient, since you reverse the string, which causes and then compare it again. You can simply just check whenever the 1st character is equal to the last one, the 2nd character to the second-last one, etc. Here's an example that I've made: (`ispalindome2` is an index-based version that might be easier to follow) #include &lt;stdio.h&gt; #include &lt;string.h&gt; int ispalindrome2(char const * const str) { int i, len; len = strlen(str); for (i = 0; i &lt; len / 2; i++) { if (str[i] != str[len - i - 1]) return 0; } return 1; } int ispalindrome(char const * const str) { char const *left, *right; left = str; right = str + strlen(str) - 1; while (left &lt; right) if (*(left++) != *(right--)) return 0; return 1; } int main(void) { char *str = "abba"; if (ispalindrome(str)) printf("%s is a palindrome\n", str); else printf("%s is NOT a palindrome\n", str); return 0; } (Note that I haven't benchmarked any of this)
"The use of COBOL cripples the mind; its teaching should, therefore, be regarded as a criminal offense." Dijkstra knew best. Trust your programming seniors. Don't learn brainfuck. Don't learn COBOL. If you really want to learn how to design programs, read the book \[How To Design Programs\]([https://htdp.org/](https://htdp.org/)). Learn Typed Racket. By choosing to use C or Python you are missing out on the last 40 years of PL research. If your aim is to learn computer science I would not choose C or Python. I would pick something like Standard ML or Haskell. 
So we started off just figuring out how to get a functional queue working in C. For this kernel part the professor handed us a skeleton in cop and I think he's having us fill in the gaps with queue functions and take processes to look at how the kernel handles putting them on the cpu. I know we'll be building some kind of shell later but that might be more skeletal too.
I did something like this awhile ago. Except I didn't try to convert C++ vector, and just wrote my own take on a vector in pedantic C89. https://github.com/Chase-san/Songbird/blob/master/vector.h 
`void const **\*\***entries;`
Seems pretty cool, I like your error handling! One potential memory issue I see is that upon removal there's never a resize done in sb_vector_remove. Meaning your capacity could be huge and your size could be 1. I don't think mine perfectly decreases in size (I try to maintain that upon shrink the capacity = 2 * size) I guess mine is more of my interpretation and a drop in replacement for std::vector, obviously with some C workarounds for certain things.
Not the OP, but educated guess: Size of what is being stored in the vector isn't known at compile time. So if you want to avoid tracking that in the vector, this is the best generic solution you can provide.
Exactly that. It was suppose to be a generic solution.
^ a void* allows anyone to cast a different type to it and therefore you can have anything stored. So a void** is required (read as array of void*s). Just you have to cast it back to a nonvoid type to actually do anything with the value.
You too, why the double pointer? Also, something that would actually set std::vector implementations apart is the ability of customizing the allocator, for both when you want to save space, and when you want to do less allocations, for instance.
It's true, the actual vector does not shrink. Since I do not know the use case for the vector, keeping the capacity seems like the best middle road. As they could always destroy it and create a new one if they want to save memory.
stb has a super clever [`stretchy_buffer.h`](https://github.com/nothings/stb/blob/master/stretchy_buffer.h) that uses macros to support arbitrary types, just like `std::vector` in C++. Example: float next; float *values = 0; while (scanf("%f", &amp;next) == 1) sb_push(values, next); /* ... */ free(values); 
In that same library I also have a (non-linked list) deque, byte buffer, and array implementations.
Is it an array of references?
The reason is pretty simple: if you would assign a `const char*` to a `char*`, you would then be able to modify the contents of the string: ``` const char *const_str = "fello world"; const_str[0] = 'h'; // illegal char *str = const_str; str[0] = 'h'; // I now modified a const string! ``` Because of this, the compiler complains when you try to do this: ``` char *str = const_str; ``` Note that you can do the reverse no problem: ``` char *str = "hello world"; const char *const_str = str; // fine ```
That is very cool! Totally need to take a closer look.
&gt; Awar Oh I see! That makes sense. Thanks for your great explanation and examples!
It sounds like you are confused about what `const char*` means. With "scalar" types, there is only one place (figuratively) to put the `const` — it modifies the object and makes it immutable. But with pointers (generally, with any indirect or parameterized type), there are _two_ positions that `const` can appear in: You can have a constant pointer to a mutable int, _or_ you can have a mutable pointer to a constant int. int* const p; // const pointer const int* p; // pointer-to-const int const* p; // also pointer-to-const The difference is this: int i, j; const int* p = &amp;i; *p = 42; // ERROR: *p is constant p = &amp;j; // fine; p is mutable - int i, j; int* const p = &amp;i; *p = 42; // fine; *p is mutable p = &amp;j; // ERROR: p is constant And, of course, you can do both: int i, j; const int* const p = &amp;i; *p = 42; // ERROR: *p is constant p = &amp;j; // ERROR: p is constant
&gt; Note that, to my knowledge, there is no real compile-time way to get the max size that an integer can take up when converted into characters in base 10. Taking log10 of 256^sizeof(int) leads to the easy over-approximation `2 + sizeof(int) * 5 / 2`, or `1 + sizeof(int) * 5 / 2` if you assume sizeof(int) is even. For sizeof(int) in [2, 4, 8], this is exact, and for sizeof(int) = 16, it's only an over-approximation by 1.
Yup, agree.
A class as well, but I want to program small systems, so yeah.
If a Vector is created with an initial capacity of 1, then vector_push_back() won't ever increase the capacity since (int)(1.5 * 1) = 1.
Thank you, that totally slipped my mind when I changed the multiplier from 2 to 1.5. Freeing on pop\_back was fairly stupid I must admit, whoops. Those should be all resolved now. :)
If you want a ponder a related issue that can be a bit puzzling consider this: you're dealing with arrays of char* and you write a function something like: void print_strings(const char *strings[]) { ... } You then try to invoke it like so: char *my_strings[] = {"string1", "string2", "string3", NULL}; print_strings(my_strings); You're compiler should complain something like: Passing 'char *[4]' to parameter of type 'const char **' discards qualifiers in nested pointer types "Huh? I thought functions with `const char *` args accept plain old `char *` args as well. E.g. `strlen`. What gives?" While the _intent_ is correct, `print_strings` is equivalent to the prototype: void print_strings(const char **strings) { Writing it this way makes it a bit more obvious what's going on. It's taking a pointer to a pointer to a char. This is how you'd write a function the returns a `char *` through its argument (as opposed to its return value). Renaming the function makes the example slightly more plausible: void get_name(const char **name) { static const char *some_name = "foo"; *name = some_name; } You then try to invoke it like so: char *a_name; get_name(&amp;a_name); At this point you'd be free to do something like: a_name[0] = 'x'; // modifies a const char * - bad! The above would _not_ produce a warning even though it modifies a `const char *`. This is why passing a `char *` to `get_name` (or `print_strings`) is disallowed. If you're just learning C, this may be a bit confusing. Especially, if you haven't had the need to use pointers-to-pointers yet. File it away to ponder in the future. 
Glad to help. It's very nice overall. One more suggestion I'll give is that you might want to consider making the init functions return a Vector rather than a Vector*. Unless I'm missing something, there's no need to return a pointer. The actual Vector object should only be 32 bytes at most so copying it would be insignificant overhead.
I've always been interested in the ide of programming, what got me to finally decided to figure it ll out was I had a few ideas for how to better compress music. that coelesced into creating a video codec, which I'm laying the ground work (oh my god there's so much groundwork) for.
 #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; void someFunc(const char *array, ...) { va_list arglist; va_start(arglist, array); vprintf(array, arglist); va_end(arglist); } int main() { char *test = "DEF"; someFunc("%c%c%c", 'a', 'b', 'c'); someFunc("%s", "def"); someFunc("ABC"); someFunc("\n\tHey this is just a test: %s\n", test); return 0; } If you are able to modify the whole function, this could be a solution
Micro-controllers. Learnt Java on my own beforehand but my dad rightly told me that the market for micro-controllers was huge in my city so I learnt C. The only "big" program I have coded in C is a Lexer and Parser. I just finished it and now I am testing it, trying to make a calculator out of it. It reads text files during runtime and lexes/parses accordingly. Since I am interested in micro-controllers which are deterministic systems (and have no OS) I made my own memory allocator which gives me more control since it uses statically allocated blocks of memory so no mallocs. I have a 32 bit micro-controller which I would like to try my calculator on. In a very distant future I would also like to make it a mini computer.
It’s a very good effort, congratulations! But what I understood after reading a bit the code, is that data is actually an array of pointers to the vector elements. So the data structure itself doesn’t seem to be a vector of items but a vector of pointers to items. While this approach is ok in terms of algorithmic complexity, it’s different than what std::vector does and is introducing additional reference loading and cache penalties.
If you are using Windows and refuse to just use Java or C# and stay away from human torture you should look into the windows libraries. Last time I coded a Windows specific program in C I was using the Windows.h header which required wide characters to function correctly. If I recall correctly those wide characters are two bytes long, I don't know if that is enough to represent the greek alphabet in Unicode. I was also using Petzold's Programming Windows 3 book as a guide tho so perhaps my info is a little bit outdated. 
I dont understand the reason for the double pointer. Can you explain what the benefits are? Having a C vector share naming conventions with a well known C++ vector is a double-edged sword. I agree that the naming uniformity is probably helpful when trying to remember what function name to call, but on the other hand the C functions will not work exactly like the C++ versions and this can cause subtle misunderstandings. I agree that the naming vector\_begin makes most sense because it is closest to vector::begin. But then free\_vector breaks with this convention. Should it not be vector\_free or vector\_destruct? I have always liked overloading the constructor with the typename, but I can understand that some people consider this bad taste. For me the showstopper is the lack of type safety. I know you do this to be generic but it is possible to achive type-safety for generic containers. I have coded my own but I think darray ([https://github.com/rustyrussell/ccan/blob/master/ccan/darray/darray.h](https://github.com/rustyrussell/ccan/blob/master/ccan/darray/darray.h)) is quite close to optimal. Take a look at that to see if you can get any ideas how to improve type-safety in your own design. Good luck and keep improving!
Yeah, I'm going to work on this tomorrow as mentioned by u/skeeto, being new to C didn't know the power of macros and just thought void** was the only way to be generic. 
This isn’t a C++ subreddit. 
Since, as /u/soalfoam noted, this isn't a sub for C++, try asking in /r/cpp_questions instead.
Since, as /u/soalfoam noted, this isn't a sub for C++, try asking in /r/cpp_questions instead.
thank you. I'm new here... so i found from group... :(
I'm a history nerd and a programming nerd so learning C had to happen at some point. Turned out I liked it a lot. I also like the idea of doing OS stuff down on the road or maybe drivers. I've also got a thing for ncurses and can't get enough of making programs that use it, including attempts at roguelike stuff. For the last few days I've been making a terminal based rgb color picker in ncurses that lets me enter values in 0-255 format and see their 0-1000 equivalents, and save multiple shades into most of the 8 availablr colors slots for easy comparison. There's something fun about trying to make it ncurses and terminal emulation look better than it was intended to. Down the road I'd really like to get into SDL, OpenGL, and other tools that let me play with pixels more directly.
I think the author has mentioned that it violates strict aliasing in it's implementation. This is something you can work around, but I'm not sure if he's done this yet. Keep that in mind if you read through it's code.
To confuse you even more: A `char *` can "point to" a `const char *`. Here "point to" means alias. char *null_byte = strchr("fello world", '\0'); So `null_byte` points to the implicit null character at the end of the constant string. I can do arithmetic with the pointer and even dereference it, no problem. However, even though it is not marked as `const` (`strchr` casted that away) one must not write to it. The above issue is basically a defect in the language that C++ managed to solve with templates but is still apparent in const-methods.
Wow. That's really interesting. Thank you so much for the example!
This argument _sounds_ good, but I think it's missing an important point. In C, `const` _does not_ always mean "this object is constant". Take this simple example: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int i; const int *p; i = 42; p = &amp;i; printf("*p = %d\n", *p); i = 123; printf("*p = %d\n", *p); } This is a strictly conformant C program, and it invokes no undefined or implementation-defined behaviour. Nevertheless, the `const` object `*p` has a different value at the two `printf` calls. The only thing a `const` qualifier does is prevent a particular lvalue from being assigned to. In this example, for instance, one cannot assign to the lvalue `*p`. But the object underlying the lvalue is not necessarily "constant", and indeed in many cases the compiler cannot even optimise things on the assumption that it is.
&gt; because once they are initialized that's it No, this is missing something important. In C, `const` _does not_ mean "this object is constant". Take this simple example: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int i; const int *p; i = 42; p = &amp;i; printf("*p = %d\n", *p); i = 123; printf("*p = %d\n", *p); } This is a strictly conformant C program, and it invokes no undefined or implementation-defined behaviour. Nevertheless, the `const` object `*p` has a different value at the two `printf` calls. The only thing a `const` qualifier does is prevent a particular lvalue from being assigned to. In this example, for instance, one cannot assign to the lvalue `*p`. But the lvalue itself is not necessarily "constant", and indeed in many cases the compiler cannot even optimise things on the assumption that it is.
I use C for scientific computing in geoscience specifically for it's computational efficiency at doing repetitive tasks millions of times over. The project that brought me into it is a fluvial sediment transport model applied to the global domain at ~1 sq km resolution. 
I would rather call *this* a defect of the C standard library, since you \_could\_ introduce a function that accepts a const and returns a const. What IMO _is_ a defect of the C language, is that I can do this without the compiler throwing an warning: char *var = "Hello World"; // string literals should only be assignable to const char*'s
What's the advantage of it being a 'header-only library'? If you separate the implementation from the function signatures, you could hide the internals of your struct from the user.
I prefer clang-format. 
I prefer Linux kernel style. Mostly because I hope to contribute some day! Whichever one you choose just be consistent.
Note that using the signal mask makes sure that no function will be interrupted in a delicate state. I honestly think anything can be done in that handler. Except making permanent changes to the signal mask, because it will change back to original when the handler returns to kernel. Note also that during the handler, the signal mask given to sigaction (not the active one set by sigprocmask), will block the full group of signals. \^C and simultaneous child exit won't stomp over each other. I goofed a bit: It's simpler to spawn the children before the sigaction loop, so each child does not need to restore the handler back to default. Each will have to open the signal mask though before exec. Signals might go to a queue, or it might be selectable, but normally there is no queue, just a pending/not flag. Check also pselect(). You can be open for signals while idling, and safe from them during event handling.
Micro controllers sound pretty interesting, I'll have to look into those sometime. As far as coding the OS I'm not sure if we really will be. We're putting together a kernel that simulates putting processes on the cpu and after that making some kind of shell. I think the last we'll do is go into some threading and semaphores.
Include the headers. This will introduce symbols that your code can use. The compiler will assume the function definitions (code) will be provided later. When you compile your program, you'll get a binary that contains undefined references to the library functions you used. In order to make it work, you must provide definitions for those functions. You do this by linking your program to the library's code. These links may be static or dynamic. With static linking, the library's code gets copied into your executable. With dynamic linking, the operating system will link your executable's function reference to the library's installed shared object's function definition every time the program is executed.
Assuming you're using gcc: First build either the static (.a) or shared (.so) library using make. When calling gcc or ld to build/link your project use -L[DIRECTORY] to add the directory containing library file to the search path. Use -l[LIBRARY] to use the library (all library names start with "lib" by convention, skip that part when using -l, so if the library you want to link is lib/libmath.a use "-Llib -lmath") To use the headers use -I[DIRECTORY] to add the directory to the search path (if you wan't to include include/math.h use -iinclude. Sorry if that was unclear. If you have any questions let me know.
&gt; Also, note that const works a bit differently when using pointers vs normal values Well, sort of. The equivalent of `const int` for a pointer would be `char * const`, that is, a constant pointer to mutable data. The compiler should complain the same way if you misuse the latter as it should the former.
Note also that all `-l` operands should go after the name of source and object files in the linker invocation or they may be ignored during linking. For example: #incorrect cc -o foo -lm foo.o #correct cc -o foo foo.o -lm
Correct, but the OP sounds like someone new to the language, and I thought it more important to be comprehensible than exhaustive,
Been there, done that. Kind of depends of the target operating system. Im well versed on linux, but not sure of how to do it on windows / mac / mobile
You might want to consider a package manager like [Conan](https://conan.io/) or [Buckaroo](https://buckaroo.pm/).
Hello, we are using Linux, but thanks for the info! 
so, this should work? I built mbedlts as a shared library according to their docs \`cmake -DUSE\_SHARED\_MBEDTLS\_LIBRARY=On .\` and \`make install\` so things are in \`/usr/include\` and \`/usr/lib\` &amp;#x200B; My directory layout is: client ├── include │ └── crypto.h ├── Makefile ├── src │ ├── crypto.c │ └── main.c I included the correct header files according to the documentation, and yet when I build I get errors Then I tried to build with GCC: ~/Code/c/proj $ gcc -g client/src/*.c -l mbedtls -I client/include -I deps/mbedtls/include/mbedtls/ /tmp/ccbuyXy8.o: In function `create_aes_key': /home/***/Code/c/proj/client/src/crypto.c:19: undefined reference to `mbedtls_entropy_init' /home/***/Code/c/proj/client/src/crypto.c:20: undefined reference to `mbedtls_ctr_drbg_init' /home/***/Code/c/proj/client/src/crypto.c:23: undefined reference to `mbedtls_entropy_func' /home/***/Code/c/proj/client/src/crypto.c:23: undefined reference to `mbedtls_ctr_drbg_seed' /home/***/Code/c/proj/client/src/crypto.c:30: undefined reference to `mbedtls_ctr_drbg_random' collect2: error: ld returned 1 exit status Did I mess up the shared library part?
This is what you get when the linker can't find the library in question. It basically means i can't find these functions anywhere. I see you used -I to get the includes so I guess you'll need to add a -L to the library path. Then a -l (lower case L) with the library name should work. This is needed when the libraries aren't in the default include path which, in itself, isn't a bad thing. So say the includes are in client/include and the library is in client/lib (name libmbedtls.[a|so]) then the following should work: gcc -g -I./client/include -L./client/lib source1.c source2.c -llibmbedtls Note that if you use a shared library you'll probably want to install that in a directory known to the system (ld.conf plays a role here) so it can be found. You can use `ldd` to see if all the libraries are found. There's also an option to hardcode a shared library to a non default path but i don't think that's the proper way; maybe in that case it would be better to use the static library (.a file).
As far as I know if the library is missing from search path, ld would complain that it can't find -lmbedtls. But putting the -l flag at the very end of the gcc command is always a good idea. If that doesn't help: /u/Icecreamisaprotein can you check the included header files for the functions you're trying to call?
Yes indeed, i didn't spot the -l in the invocation :/
Thanks for the replies. Unfortunately I can't find a .pc file anywhere. &amp;#x200B; This still isn't working, just for my own sanity, you don't see any problems with this do you? &amp;#x200B; client/ ├── include │ ├── crypto.h │ └── mbedtls │ ├── &lt;aes.h // all the mbedtls headers from make install (more than shown here) ├── lib │ └── libmbedtls.a // generated from make install ├── Makefile ├── src │ ├── crypto.c │ └── main.c gcc -g -I./client/include -L./client/lib client/src/main.c client/src/crypto.c -lmbedtls /tmp/ccbuyXy8.o: In function `create_aes_key': /home/***/Code/c/proj/client/src/crypto.c:19: undefined reference to `mbedtls_entropy_init' /home/***/Code/c/proj/client/src/crypto.c:20: undefined reference to `mbedtls_ctr_drbg_init' /home/***/Code/c/proj/client/src/crypto.c:23: undefined reference to `mbedtls_entropy_func' /home/***/Code/c/proj/client/src/crypto.c:23: undefined reference to `mbedtls_ctr_drbg_seed' /home/***/Code/c/proj/client/src/crypto.c:30: undefined reference to `mbedtls_ctr_drbg_random' collect2: error: ld returned 1 exit status &amp;#x200B;
That is weird. I just tried to reproduce your error: git clone https://github.com/ARMmbed/mbedtls &amp;&amp; cd mbedtls cmake -DUSE_SHARED_MBEDTLS_LIBRARY=On . sudo make install Then for testing created main.c containing: #include "mbedtls/net.h" #include "mbedtls/ssl.h" #include "mbedtls/entropy.h" #include "mbedtls/ctr_drbg.h" #include "mbedtls/debug.h" int main() { mbedtls_net_context fd; mbedtls_net_init(&amp;fd); return 0; } compiled using: gcc -g main.c -l mbedtls and it works without problem. I expected to get undefined reference to `mbedtls_entropy_init' Maybe check if your includes contain the functions you're trying to call. Does the code above work for you?
Try this: -lmbedtls -lmbedx509 -lmbedcrypto See the mbedtls github README: &gt; The Make and CMake build systems create three libraries: libmbedcrypto, libmbedx509, and libmbedtls. Note that libmbedtls depends on libmbedx509 and libmbedcrypto, and libmbedx509 depends on libmbedcrypto. As a result, some linkers will expect flags to be in a specific order, for example the GNU linker wants -lmbedtls -lmbedx509 -lmbedcrypto.
Will the compiler not do that optimization for you?
That looks ok to me. I have a small project where i run gcc exactly like that and it picks up the static library. Does it work when you add the .a file manually? (e.g. are these functions really exported in the library?).
If you're just testing / messing around it's easy enough to modify the makefile in the 'programs' directory in a couple of places and add another program into them just like the example programs then take it from there. I take it you have already built the example programs and the library itself ?
Pointer can't have a "bunch of zeroes", it could only be a NULL pointer. Pointer merely stores an address of some memory location. What I think you're talking about is that you want to set the **memory being pointed at** to 0. Before you can do that, you must first reserve a part of memory so you can have a place to store your 0s, otherwise you could be rewriting anything and crash your program or worse. Therefore you need to use `malloc` which will return a pointer to a memory block of specified size, and only then it will be safe to use `memset` to overwrite that block with 0s.
Yeah I've built and run the example projects just fine, 
I see. So I'd be looking for the following syntax? ``` int** this_pointer = (int**)malloc(sizeof(int*) * N); memset(this_pointer, 0, sizeof(int)*N*M); ``` While this alone doesn't trigger a segmentation fault, accessing `this_pointer[0][0]` does. I thought this would be sufficient. 
You on Linux? The easy way to figure out how to set the cc command line is with pkg-config (at least on RHEL/Fedora variants, but I'm pretty sure pkg-config is somewhat universal). When building, you use the output of pkg-config --cflags &lt;pkgname&gt;, in this case &lt;pkgname&gt; is mbedtls. For linking, it's pkg-config --libs &lt;pkgname&gt;. If you're just building in one line to do both, just leave the flag off and it does both at once.
You can actually malloc only one time allocating memory for pointers and arrays of zeros at once. If this structure would be used as 2d array it could be actually more optimal I guess (assuming you can allocate one big chunk of memory, and you can make the code readable :&gt; ) If it would be used as some kind of list, then I would use multiple mallocs for sure.
Check out this chapter on pointers - [http://pweb.netcom.com/\~tjensen/ptr/ch9x.htm](http://pweb.netcom.com/~tjensen/ptr/ch9x.htm)
You are halfway there. &amp;#x200B; You used malloc to allocate space for N pointers to int. So, the total space, that you have allocated is not `M*N*sizeof(int)`. It is just `N*sizeof(int*)`. &amp;#x200B; Memset does not allocate memory. It just "set"s the memory. For someone to be able to set, change or zero the memory, the memory should first be allocated. &amp;#x200B; Understand the difference between what a malloc and a memset does. Links: Malloc: [https://en.cppreference.com/w/c/memory/malloc](https://en.cppreference.com/w/c/memory/malloc) Memset: [https://en.cppreference.com/w/c/string/byte/memset](https://en.cppreference.com/w/c/string/byte/memset) &amp;#x200B; Note: While the site says cppreference, it has good enough reference for C language too.
I'm at work right now but when I get home I'll definitely try this, thanks!
&gt;\-lmbedtls -lmbedx509 -lmbedcrypto hm okay, I tried that and get `error while loading shared libraries: libmbedcrypto.so.3: cannot open shared object file: No such file or directory` When running the binary that's built. We're getting closer...
That's really strange. I've used the same CMake and make configuration as you and there's a libmbedcrpto.so.3 installed in /usr/local/lib for me. Are there any results when searching for libmbedcrypto? find /usr/lib* /usr/local/lib -name "libmbedcrypto*"
I put an edit at the top post, I fixed it :) had to move mbedtls src out of the directory I was building and now it works great 
Hell yeah! Happy encrypting :)
That approach seems to require that all of the operations done using your types generate code in-line via macro expansion, as opposed to being able to call shared functions. It also requires that all functions whose declarations will be visible in the same scope, that take arguments of type `darray(someType)` for a common type `someType`, and will need to share such objects, agree on a common typedef since, given e.g. typedef darray(foo) darray_foo; typedef darray(foo) darray_of_foo; types darray_foo and darry_of_foo won't be compatible, and some compilers won't even allow a pointer to one type to be meaningfully cast into a pointer to the other and used to access it, even in the immediate vicinity of the cast. 
Thank you for your answer. But I have not idea how this looks as code
std::vector doesn't decrease the capacity when erasing items as state by the standard(*§23.3.6.5/4 \[vector.modifiers\]*). It would complicate things and potentially force your entire block of memory to be moved to a new location when reallocating. &amp;#x200B; It's also slower and harder to gauge for performance. I personally just create a separate function allowing the programmer to manually reduce the capacity and truncate the buffer.
Ok, I think I got it: ``` int **this_pointer = malloc(N, sizeof(int*)); // malloc so its faster for(int i=0; i &lt; N; i++) this_pointer[i] = calloc(M, sizeof(int)); // calloc because I need zeroes ``` But this is way too long. Is there no way to do it without a for loop? This seems _ugly_ and this usually means it's also bad. Can I do it in one line? 
It isn't long or ugly. It is a good first step to understanding what each function and allocation is doing. &amp;#x200B; Now that you know how to use malloc, and you want to use the double pointer to point to a matrix of size M\*N, you can think on this lines, how much memory did you allocate overall? &amp;#x200B; How can you allocate that much memory using one malloc? If you allocate that much memory, how do you initialize each element of that memory block? &amp;#x200B; Try finding out how the memory is laid out for a 2 dimensional array. &amp;#x200B; For example, int x[3][4] = { {0, 1, 2, 3} , {4, 5, 6, 7} , {8, 9, 10, 11} }; int **p = &amp;x[2][1]; int **q = &amp;x[2][0]; What is the value of `**p` and `**q` here? What will be the value of `*p` and `*q`? What will be the value of `p` and `q`? What will be `*p+1`, `**p+1` and `p+1`?
Can you post the output of `nm libmbedtls.a` somewhere? Does it contain the symbols the compiler complains about?
That indicates that the shared library is not in the search path. Try starting the program with `LD_LIBRARY_PATH` set to the directory where the shared libraries are located. Alternatively, link with `-Wl,-rpath=...` where `...` is the full path where the library is located.
Not sure. I would guess that compilers won't turn floating point numbers into integers when optimizing because there's probably no way to be sure in general that it won't change the result given the way rounding works. But I really don't know so I'm pretty much talking out of my ass.
Better to create a separate build directory and run cmake from there, rather than in the source...if you `mkdir build` inside mdedtls, the command would then be `cmake ..` and of you want to remove all of the build artifacts you just remove the build directory. Might not matter for a 3rd party library so much, but it is generally better to build out of source.
So ... what have you done so far? Where are you stuck?
i understand what the teachers asking with the integers and such but i dont know how to translate it to code if that makes sense (its a beginner computer science class btw)
Do you know how to assign variables?
like int x=10?
i know we assign with the equal sign but im a bit confused where it says " Create a new variable that is a pointer to a shape\_t. " 
Look into structs in c
yes but the other things about the assignment im confused about
i have but 3-6 on the assignment im confused about
You define your struct shape-t Then you can allocate memory using malloc or calloc to a pointer that is of the type struct shape-t Define that variable just like you would an integer, so Struct shape-t my_shape_struct Except make it a pointer. 
&gt; Create a new variable that is a pointer to a shape_t shape_t* var; &gt; Dynamically allocate a new "shape_t" variable using the pointer. &gt; Free the memory from #3. This is telling you to use `malloc` to allocate memory for that pointer, and then use `free` later on to release that memory allocation. &gt; Give it values x=5, y=20, sides=4, height=5 Now do assignments to the members of the structure, like `var-&gt;x = 5;` and such. &gt; Create a function called "calculate_area" which takes in a shape_t int calculate_area(shape_t* shape) { // Your code goes here } That should get you started.
I highly encourage you to take your best shot at each of the portions in the assignment, then post your code here when you get stuck. Otherwise it's really hard to give any meaningful help.
Did you not cover what pointers are in lecture?
&gt; int foo = 1; const int bar = 2; foo = 3; // NOT OK What is not okay there? you are changing foo which is not a constant. Did you mean that bar = 3; won't compile as bar is a constant?
I am not sure if you are asking on the correct sub. This is a C language sub. (Check the sidebar). If you are looking for help specifically in C#, you can try r/csharp. Secondly, if you are using C for controlling lights, fans etc. can you please post what platform(Windows, Linux, no-OS / gcc, clang, msvc, etc. / ARM, x86, etc.) are you using? When you say "C# will work for that but is it the best one to use" ***best*** in what sense? If you let me know, I can try to help you. 
Post your full code. Print each of the intermediate steps while you debug.
&gt; I have an error ... What is it? Errors are there to help you. 
I'm not sure what it is, i was referring to the red squiggly line but here is what the output gave me 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(19): error C2143: syntax error : missing ';' before 'type' 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(20): error C2143: syntax error : missing ';' before 'type' 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(22): error C2065: 'nums' : undeclared identifier 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(24): error C2065: 'i' : undeclared identifier 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(26): error C2065: 'nums' : undeclared identifier 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(26): error C2065: 'i' : undeclared identifier 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(26): error C2109: subscript requires array or pointer type 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(28): error C2065: 'nums' : undeclared identifier 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(28): error C2059: syntax error : '\]' 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(30): error C2065: 'nums' : undeclared identifier 1&gt;d:\\prg\\prg255 lab4 arrays\\lab6.c(30): error C2109: subscript requires array or pointer type ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ========== &amp;#x200B;
I don't think those errors came from the code you linked to. The 3^rd error is reportedly on line 22, but that line is blank.
sorry, i don't know how to put the code in properly on reddit, but line 22 for me is : printf("Enter 10 random numbers\\n\\n", nums);
You linked to code at &lt;https://pastebin.com/HKra8gKQ&gt; Compiling that with MS's compiler doesn't give those errors, so I still don't know what you're compiling. The only error in the linked code is bubble_sort(nums[], arSize); That's not the correct way to pass an array to a function.
It looks like you're missing part of the text. It should say: const int foo = 1; const int bar = 2; foo = 3; // NOT OK
side note, you can check for the matrices and return if they don't exist to avoid more loops. void Matrix2DConcat(Matrix2D *pResult, Matrix2D *pMtx0, Matrix2D *pMtx1) { if(!pMtx0 || !pMtx1) { return; } for (int i = 0; i &lt; 3; i++) { ...
so how do i correctly pass an array to a function
Leave off the `[]`
worked ty
Works for me: [https://rextester.com/WGICO23346](https://rextester.com/WGICO23346) Best guess is that your test harness is faulty or something is wrong in the way you've declared Matrix2D structs.
Need to provide an example of what paths looks like. Is it literally just like a block of memory like this: char \*paths = "path1\\0path2\\0path3\\0longerpath4\\0" ?
You can test your code here [https://segfault.stensal.com/test\_your\_code](https://segfault.stensal.com/test_your_code) for diagnosing segfault yourself. 
In a loop, get the string length, check if it is not 0 (empty string), then check if a character in that string, at index being the length, is a slash (for example `string[length] == '/'`).
Take a look at https://github.com/mgrosvenor/libchaste Specifically the logging component: https://github.com/mgrosvenor/libchaste/tree/master/log Here’s the demo (which shows of all the features): https://github.com/mgrosvenor/libchaste/blob/master/demos/demo_logger.c It does both compile time and runtime setting of log levels from FATAL ERROR down to DEBUG3. (Optionally) Includes timestamps, file/directory paths, coloured output (with non terminal detection), logging to STDOUT, STDERR, file and syslog and compiles with ANSI C in pendatic mode. 
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define SIZE 512 int main() { int i; char string_one[SIZE] = "/home/USER/"; char string_two[SIZE] = "/etc/rc.d/"; printf ( "%s\n%s\n", string_one, string_two ); // my own strlen() for (i = 0; string_one[i]; i++); if (string_one[i - 1] == '/') string_one[i - 1] = '\0'; // simple strlen() if (string_two[strlen(string_two) - 1] == '/') string_two[strlen(string_two) - 1] = '\0'; printf ( "%s\n%s\n", string_one, string_two ); return 0; } Here, in my example I remove the '/' at the end
Wrong subreddit. 
Oh I Didn’t notice
The approach does not require everything to be in-line, this was just a design choice. My own vector implementation does use shared functions for resize/append/replace which get the size of the type passed as an argument gotten via `sizeof(`[`foo.data`](https://foo.data)`[0])`. This is hidden in the calling macro for each function. But the inline code is quite small, just a couple of ifs, and I doubt it makes much difference in the big picture. You are right that two separate `typedef darray(type)` are incompatible even if the type is the same. That is probably why the `typedef darray_int` was added so that multple `darray_int` are compatible. This could also be solvable for known types with some `_Generic` trickery in the `darray()` macro I would think. But I dont see a solution that would work for all types, especially structs.
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main() { int *num[5]; int i, c; // memory allocation + filling with numbers for (i = 0; i != 5; i++) { num[i] = calloc(5, sizeof(int)); for (c = 0; c &lt; 5; c++) { num[i][c] = rand(); } } // output printf("\nEverything with numbers:\n"); for (i = 0; i != 5; i++) { for (c = 0; c &lt; 5; c++) { printf("num[%i][%i] = %i\n", i, c, num[i][c]); } } // everything zero : for (i = 0; i != 5; i++) memset(num[i], 0, sizeof(int) * 5); // output printf("\nEverything 0:\n"); for (i = 0; i != 5; i++) { for (c = 0; c &lt; 5; c++) { printf("num[%i][%i] = %i\n", i, c, num[i][c]); } } // free()'ing the pointers for (i = 0; i != 5; i++) free(num[i]); return 0; } Instead of memset, we could use: for (i = 0; i != 5; i++) { for (c = 0; c &lt; 5; c++) { num[i][c] = 0; } } To fill it with zeros.
Too long...
If you would read the code, you'd see that most of the code is filling + output + free() &amp;#x200B; Building up a int num\[5\]\[5\] with everything zero is just: int *num[5], i; for (i = 0; i != 5; i++) { num[i] = calloc(5, sizeof(int)); } &amp;#x200B;
This is pretty cool! Also, emacs has solitaire.
Rules: 2. Only C is on topic This subreddit is about programming in the C programming language. Content about other languages such as C++, C#, or assembly or programming in general is only on-topic as long as it relates to the C programming language. Merely trying to reach an audience of C programmers is not enough to make your post be on topic.
You'll want to post this on /r/cpp_questions, this sub is for C programming only. An generally when asking coding questions: show what you've tried already (in Code!) and explain which part you're having trouble with.
There's also [https://github.com/HardySimpson/zlog](https://github.com/HardySimpson/zlog).
The whole game revolves around this: // action table {{{ /* stores a function pointer for every takeable action; called by game loop */ int (*action[NUM_PLACES][10])(int,int,int) = { #ifdef KLONDIKE /* 1 2 3 4 5 6 7 stk wst fnd*/ /* 1 */ { t2f, t2t, t2t, t2t, t2t, t2t, t2t, nop, nop, t2f }, /* 2 */ { t2t, t2f, t2t, t2t, t2t, t2t, t2t, nop, nop, t2f }, /* 3 */ { t2t, t2t, t2f, t2t, t2t, t2t, t2t, nop, nop, t2f }, /* 4 */ { t2t, t2t, t2t, t2f, t2t, t2t, t2t, nop, nop, t2f }, /* 5 */ { t2t, t2t, t2t, t2t, t2f, t2t, t2t, nop, nop, t2f }, /* 6 */ { t2t, t2t, t2t, t2t, t2t, t2f, t2t, nop, nop, t2f }, /* 7 */ { t2t, t2t, t2t, t2t, t2t, t2t, t2f, nop, nop, t2f }, /*stk*/ { nop, nop, nop, nop, nop, nop, nop, nop, s2w, nop }, /*wst*/ { w2t, w2t, w2t, w2t, w2t, w2t, w2t, w2s, w2f, w2f }, /*fnd*/ { f2t, f2t, f2t, f2t, f2t, f2t, f2t, nop, nop, nop }, #elif defined SPIDER /* 1 2 3 4 5 6 7 8 9 10*/ /* 1 */ { t2f, t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2t }, /* 2 */ { t2t, t2f, t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2t }, /* 3 */ { t2t, t2t, t2f, t2t, t2t, t2t, t2t, t2t, t2t, t2t }, /* 4 */ { t2t, t2t, t2t, t2f, t2t, t2t, t2t, t2t, t2t, t2t }, /* 5 */ { t2t, t2t, t2t, t2t, t2f, t2t, t2t, t2t, t2t, t2t }, /* 6 */ { t2t, t2t, t2t, t2t, t2t, t2f, t2t, t2t, t2t, t2t }, /* 7 */ { t2t, t2t, t2t, t2t, t2t, t2t, t2f, t2t, t2t, t2t }, /* 8 */ { t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2f, t2t, t2t }, /* 9 */ { t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2f, t2t }, /*10 */ { t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2t, t2f }, /*stk*/ { s2t, s2t, s2t, s2t, s2t, s2t, s2t, s2t, s2t, s2t }, #endif }; // }}} &amp;#x200B;
I was looking at the code and this part as well. I have just started re-learning C and was wondering what you guys thought of this. Is this a good way to do it?
I did something similar for my little project: https://github.com/div0man/hnb-app/blob/master/src/jstab.c#L30 I had a data blob containing a very big string containing table data in json format, and I wanted to access that data with `a[i][j]` so had to set all the pointers to addresses of individual substrings in the data blob. Notice how I allocate storage for all pointers in a single call. It was good exercise for me, but if I had to add data, it would complicate things since the data blob is compact and has no room to squeeze new data in.
Yeah, but I didn't want to confuse the op :)
Here is (ugly) example ;) https://pastebin.com/kP08HYTS
I know this is C code but it reminds me of years ago looking at BASIC code for a few games (tic tac toe, connect 4 style) that were driven completely from large DIM tables that I never fully understood. It looks like the driver for a state machine at first glance, but I'll have to take some time to read this code and see how it is used.
Arrays in C are simply blocks of memory. with chunks the size of the array's type. The array name is an alias for the first entry in that block of memory, and array notation is simply a shorthand for the math needed to find where the nth chunk is relative to the start of the array/block. This is why you can use a pointer (for any type) to refer to an array of any type. For your question, a string is an array of chars. A char * is a pointer to a place in memory that holds a char. The first element in a string/array of chars is simply a place in memory that holds a char.
Thanks for the answer. So to confirm, the pointer basically Marks the beginning of the chunk of memory and you can use the [] notation to access the blocks of memory right next to it?
make xterm great again.
this has been done to death in libs like BLAS : https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms
Pretty sure that's exactly what it is. It's a state machine matrix of function pointers for each possible move in the solitaire game. 
Yes. For example: char arr[10] = {'m', 'y', ' ', 's', 't', 'r', 'i', 'n', 'g', '\0'}; char *p; p = &amp;arr[0]; printf("%c\n", p[5]); //output will be "r" printf("%c\n, *(p+5)); //output will also be "r" 
Here's my example: char *ptr = "Hello"; for (; *ptr; ptr++) putchar(*ptr); Output: Hello \*ptr is a pointer which points on the location &amp;ptr\[0\]. ptr\[0\] = 'H'; In the for-loop I add + sizeof(char) which let's the adress show on the next position ( ptr\[1\] ) , which is the letter 'e'. I repeat that to the char after 'o' which is automatically a '\\0' which breaks the loop. int main() { int i; char *ptr = "Hello"; for (i = 0; ptr[i]; i++) printf("%p\tptr[%i]\t%c\n", &amp;ptr[i], i, ptr[i]); if (ptr[i] == '\0') printf("%p\tptr[%i]\t\\0\n", &amp;ptr[i], i, ptr[i]); printf("%s\n", ptr); return 0; } Output: 0x100403000 ptr[0] H 0x100403001 ptr[1] e 0x100403002 ptr[2] l 0x100403003 ptr[3] l 0x100403004 ptr[4] o 0x100403005 ptr[5] \0 Hello
Just watch out for memory addresses being thrown around and some operating systems ( Linux? ) won't care if you throw away memory and then try to use it again. Maybe you get a core dump. Maybe you don't. #define _XOPEN_SOURCE 600 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main (int argc,char* argv[]) { uint64_t* p; p = calloc( (size_t) 1, (size_t)sizeof(uint64_t)); *p = 101010123; printf("p seems to be at addr %p\n", p); printf("p seems to contain %i\n", *p); free(p); /* p = NULL; uncomment this for fun stuff */ printf("p may be at addr %p\n", p); printf("p may contain %i\n", *p); p = p + 1; printf("wtf p may be at addr %p\n", p); printf("wtf p may contain %i\n", *p); return(EXIT_SUCCESS); } 
What do your function arguments then look like if they are a pointer instead of array? Suppose I need a array and length for the function im attempting to pass off as an argument to some callback.
Pipes are necessary, processes are separate entities on in the computer's execution, and pipes are the only way that is designed to communicate between processes. You may want to use threading instead since that allows shared memory and still allows for concurrent operations. 
It may be worthwhile to subdivided the category of stack-based machines into two sub-categories: those where the amount of stuff on the stack at any given point in the code will be fixed (as in Java), and those where it isn't. Requiring that all code paths that can reach a given point leave the same amount of information on the stack can greatly simplify code generation for a Just-In-Time compiler, and can also facilitate static validation, while avoiding the need to specify a register selector/address on every instruction.
i know but i thought it would have been easier without threads because there was the option in the project specification. I was wondering if i can use something like semaphores or mutexes to make them work together. 
Funny how there are **always** new POSIX things to learn, by browsing thru man pages with no hurry: sigwait. #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; static char *a_argv[] = { "xv", "../Dog.jpg", NULL }, *b_argv[] = { "xv", "../Dog.jpg", NULL }; static int termination[] = { SIGHUP, SIGINT, SIGTERM, SIGCHLD, 0, }; static sigset_t open_mask; static pid_t launch(char **argv) { pid_t pid; pid = fork(); if (pid == 0) { sigprocmask(SIG_SETMASK, &amp;open_mask, NULL); /* SIGCHLD will be reset automatically by exec */ execvp(*argv, argv); perror(*argv); _exit(127); } return (pid); } static void unused(int sig) /* needed, but unused, just for SIGCHLD */ { } int main(int argc, char **argv) { sigset_t mask; int sig; pid_t a_pid, b_pid; sigemptyset(&amp;mask); for (size_t i = 0; termination[i]; ++i) sigaddset(&amp;mask, termination[i]); sigprocmask(SIG_BLOCK, &amp;mask, &amp;open_mask); /* safe from those signals now. mask stays on until exit. * to be able to sigwait SIGCHLD, the handler must be set to a dummy. */ signal(SIGCHLD, unused); a_pid = launch(a_argv); b_pid = launch(b_argv); sigwait(&amp;mask, &amp;sig); if (a_pid &gt; 0 &amp;&amp; kill(a_pid, SIGTERM)) { a_pid = 0; perror(*a_argv); } if (b_pid &gt; 0 &amp;&amp; kill(b_pid, SIGTERM)) { b_pid = 0; perror(*b_argv); } alarm(60); while (a_pid &gt; 0 || b_pid &gt; 0) { pid_t pid = waitpid(-1, NULL, 0); if (a_pid == pid) a_pid = 0; if (b_pid == pid) b_pid = 0; } exit(128 + sig); }
Probably you just have to work harder!
Maybe you are right
Are you forking off a new process to control each alien ship? A Space Invaders clone shouldn't require multiple processes or threads. You just need to block waiting for user input, with a timeout. 
That all depends upon whether one wants to target the language the published Rationale for the C Standard indicates that it was *written to describe*, versus the reduced subset it requires to make a special-purpose implementation "conforming". The authors of the Standard deliberately allows implementations specialized for narrow purposes to process many actions in ways that would make them unsuitable for many other purposes. It is important to ensure that any users of the library be informed that the -`fstrict-aliasing` mode of gcc and clang is only suitable for programs that have no need for anything resembling user-code memory management, since not everyone is aware of this, but the Spirit of C described in both the Charter and Rationale documents for the C Standard includes the principle "Don't prevent the programmer from doing what needs to be done", which presumably includes "and don't put up needless impediments either". Because different programs need to do different things, the range of "what needs to be done" will likewise vary. The Spirit of C, however, would suggest that if a programmer needs to bend over backward to do something in one implementation or configuration which would have been easy in another, the programmer should probably be using the latter if practical. Incidentally, icc includes an `-fstrict-aliasing` mode, but unlike the one in gcc/clang, the icc mode appears to apply the "strict aliasing" rule only in cases that would *actually involve aliasing between objects of different types*. 
I cannot imagine why a Space Invaders clone (or any single player game) would need to be forking off multiple processes. You are probably extremely confused about something. If you are trying to learn game design or make a game, use an existing engine or something like GameMaker. If you are trying to learn how game engines work by writing your own... start simple and build up. Be warned that this is very hard and, while you will probably learn a lot, you will probably not make anything nearly as good as the tools that are already out there. For something on the level of Atari/8-bit games (where the graphics and game logic are so simple you don’t have to worry about performance at all) you can do everything on a single thread from a main event loop.
Again,I know but i have to,it is a project for an university exam's,probably is accepted also only one process/thread for all the moving parts but it's not exactly want we are asked to do.
it's a project for the university, but you are right i am a bit confused too
That's actually a very reasonable thing to note, yes! In this (and follow-up posts) post I don't really discuss JITs, as compilers are a universe of it's own. One good example is the latest attempt at jitting Emacs Lisp bytecode. Tom Tromey did notice that within a given function and at a given instruction it's always possible to use static variable addresses. I think this is what gave his jit a chance for inclusion into the main code base. 
Pass the size as its own parameter? void func(int *data, size_t len_data); If it's callback behavior, then the function pointer uses that notation as well. The only time that comes to mind where I'd use array notation is if I wanted to compel a minimum array size for the compiler. void func(int data[static SIZE_CONSTANT]); Never needed something like that myself but it does exist and might serve a purpose for compiler optimization or something.
Check out sigqueue and sigtimedwait.
&gt;For your question, a string is an array of chars. An array of chars is well, an array of chars. No different than an array of anything else. What makes an array of chars a string is it is NULL terminated ('\\0'.) This is a very important distinction. all of string.h functions expect this char array to be terminated properly.
Even if one isn't using a JIT that produces raw machine code, it may be useful to pre-scan the bytecode into something that's a bit faster to process. For example, if one can determine the stack displacement everywhere within a function, one can eliminate the need for stack checks within it. Further, if a programming language includes a `stack_safe` intrinsic which is guaranteed never to return `true` unless the implementation can guarantee that no stack overflow can possibly occur on the `true` branch, and if all recursive calls are performed from within an `if (stack_safe)` block, it would be possible to statically determine how much stack must be available for any particular `stack_safe` block to return `true`, and thus allow programs to gracefully bow out of recursive constructs *before* the stack overflows, rather than having to attempt recovery from stack overflows after the fact. Such constructs would only be usable if individual functions' stack usage could be statically computed, however. 
Also, there is a related [question](http://c-faq.com/decl/strlitinit.html) in the [C FAQ](http://c-faq.com/): &gt;**Q**: What is the difference between these initializations? char a\[\] = "string literal"; &gt; &gt;char \*p = "string literal"; &gt; &gt;My program crashes if I try to assign a new value to p\[i\]. &gt; &gt; **A**: A string literal (the formal term for a double-quoted string in C source) can be used in two slightly different ways: As the initializer for an array of char, as in the declaration of char a\[\] , it specifies the initial values of the characters in that array (and, if necessary, its size). Anywhere else, it turns into an unnamed, static array of characters, and this unnamed array may be stored in read-only memory, and which therefore cannot necessarily be modified. In an expression context, the array is converted at once to a pointer, as usual (see section 6), so the second declaration initializes p to point to the unnamed array's first element.Some compilers have a switch controlling whether string literals are writable or not (for compiling old code), and some may have options to cause string literals to be formally treated as arrays of const char (for better error catching). &gt; &gt; See also questions 1.31, 6.1, 6.2, 6.8, and 11.8b. References: K&amp;R2 Sec. 5.5 p. 104 ISO Sec. 6.1.4, Sec. 6.5.7 
and do you know any language with such an intrinsic? Nothing really comes to my mind even though this sounds really useful.
I haven't looked too thoroughly, but my first instinct is that your problem lies in doing equivalence checks for floating point decimals after calculations. Remember that floats are inherently inaccurate for anything that isn't the sum of multiples of powers of 2 so 1.2 + 4.0 is not going to (precisely) equal 5.2 (for example) If you can figure out a way to get the float out of the loop's condition (or use a less-than or greater-than comparison) you'll probably fix the problem.
I added a few more prints to your code: for(;;) { mantissa = temp*2.0; printf("%d ",(int)mantissa); printf("%lf\n",mantissa); if(mantissa &lt; 1.0) { temp = mantissa; if(temp == fn) { printf("Breaking on &lt;1\n"); break; } } else { if(mantissa &gt; 1.0) { temp = mantissa - 1.0; if(temp == fn) { printf("Breaking on &gt; 1\n"); break; } } if(mantissa == 1.0) { printf("Breaking on =1\n"); break; } } } Check the output of that, it might help explain what's happening.
Yes this seems obvious now. Thanks. But maybe I was trying to get at a array of different sized elements; which doesn’t exist other than a structure. But in this case you pass the pointer to structure and then on the revive side you have to cast it to the matching structure or cause the function to only accept structures of that type. Thanks!
Dude I just want a dynamically allocated matrix I'm sure it can't be that long
Hmm, tested it and the result is just as what I expected: `00110011001100110011Breaking on = 1` Got any ideas on how to solve this?
Common problem: 0.1 cannot be presented exactly in the IEEE-754 floating point format.
If the project is supposed to teach you about pipes and subprocesses... this seems like a terrible project for that. If the project is supposed to teach you about making a game... using pipes and subprocesses seems like a terrible idea. That's not very helpful, sorry. What do the actual instructions for the assignment say? Presumably they have covered how to create subprocesses and communicate with them in the class?
Here I found some good examples ;) [https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/](https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/)
They have done very little in class, the programming part was not covered well and the course in general was not well organized.
I don't know of any language with such intrinsics, alas, though it would seem like it should be practical to adapt compilers for many languages to supply them. If redundant checks don't need to be eliminated, all that would be necessary would be for each intrinsic to evaluate as either `if (__stack_pointer-_-__lower_stack_limit &gt; __STACK_SYMBOL_foo_24601)` or `if (__stack_pointer-_ &gt; __STACK_SYMBOL_foo_24601+__lower_stack_limit)`, depending upon which construct (if either) the linker could handle better, and the compiler to produce a file reporting for each function the the labels of all `stack_safe` intrinsics used therein and maximum amount of stack that each function would use on the "true" and "false" branches. The usage report should contain the stack utilization of leaf section, and a list of function calls and the amount of content left on the stack at each (e.g. `foo` uses 64 bytes, and also calls `bar` at a time when only 16 bytes of that are on the stack, and calls `boz` at a time when 32 are on the stack). For library functions that can't be processed using such a utility, it would be necessary to manually generate suitable stack-utilization functions, but in most cases that shouldn't be too difficult. After compiling all the functions, the usage reports could then be fed into a utility which would analyze all the stack usage and produce an assembler output that would define all the labels as needed. Assemble that and link it in with the rest of the program and one would have an application that would be statically guaranteed not to overflow the stack. If such semantics were added to the C Standard, it would be possible for the Standard to define categories of programs and implementations (which I'd call "Safely Conforming" and "Selectively Conforming") such that: 1. Any Safely Conforming implementation must define a set of environmental requirements, as well as any means via which it might indicate a refusal to process or continue processing a program. 2. If a Selectively Conforming program is fed to a Safely Conforming implementation, and all of the implementation's environmental requirements are satisfied, the implementation will either process the program as defined by the Standard, refuse via one of the aforementioned Implementation-Defined means, or spend an arbitrarily long time without doing either. **ANY OTHER ACTION WOULD BE NON-CONFORMING**. 3. A Selectively Conforming program may contain directives demanding that implementations offer certain guarantees about the behavior of actions upon which the Standard would normally impose no requirements. Implementations would be free to refuse to run such programs, but accepting such a program without processing the action in the indicated fashion would render an implementation non-conforming. At present, because of the One Program Rule, the Standard does not define any categories of conformance for implementations and programs such that someone who feeds a program to an implementation and gets a particular output could know that the output could only be incorrect if the either the program or implementation was either non-conforming or buggy. Adding stack-safety intrinsics would make it practical to replace the One Program Rule with something much stronger, which could offer genuinely-useful guarantees. 
I think curl does this sort of stuff really well.
I have no idea how the redit auth works in detail but there are two Common ways to do that. 1. some websites provide an API where you could authenticate through some sort of API calls. This is normally the „right“ way to programmatically interact with a web page. Give google a try 2. most websites send the username and Passworts as http post data via an https connection. You could use the developer tools of Firefox oder chrome to intercept the http header of a normal login via the webpage. Just send the correct parameters and get a session cookie in response. This is really hacky and i would not recommend to do it this way. Since there are alternative Reddit apps I would assume they have some sort of API.
Are you sure you used the edited code? They have added a print statement to make things clearer. If you are still seeing this output then you might have a different issue. 
Nonsense. Although pipes are a standard Unix feature, Unix offers many more ways for processes to communicate: 1. Signals 2. Unix domain sockets 3. TCP/IP 4. SYSV IPC: 1. Shared memory 1. Message queues 1. Semaphores 1. POSIX mq_open 1. Shared files with `fcntl` locks 
When you say function macros, do you mean the following? #define ABS(my_val) ((my_val) &lt; 0) ? -(my_val) : (my_val) If so, I can tell you when I choose ABS() macro over writing a abs() function. 1. Calling ABS() in code will make the preprocessor simply replace the code. (So, no stack will need to get set up). This is independent of compiler optimizations. For example, it might be very very useful in keeping your code clean if you have a very small stack (especially in embedded world). 2. You can sort of emulate function overloading using `_Generic` keyword in these macros.
Yes, that is what I mean. What are the benefits of this vs using inline? GCC has always_inline too I believe.
If you mean using the `inline` keyword, then that optimization is left up to the compiler. They may or may not optimize the code. It is a directive and not requirement. &amp;#x200B; If GCC uses some other GCC-specific keywords, then it might make the code non-portable. So, I prefer to not use it. &amp;#x200B; But all of this is a personal preference. If I need some guarantees about optimizations regarding the stack, I will use a macro. I do not prefer directing the compiler. If I need no guarantees, but I know it would be a good-to-have, I mention `inline`.
`strcmp`
or strncmp
Not for a username and password; they need to be identical.
Você tem que usar `strcmp` por que ao usar `==` vc está comparando os `char*`, que, nesse caso, nunca serão iguais. `strcmp` compara os bytes para os quais os `char*` estão apontando, o que seria o correto no seu caso.
In the language the C Standard was written to describe, one could easily write a function that could act upon many different structure types that share a Common Initial Sequence. Simply cast a pointer to any structure with the proper Common Initial Sequence to a pointer of whatever such type is convenient and use `-&gt;` to access the members. In the language processed by the `-fstrict-aliasing` mode of clang and gcc, however, that's not allowed. Which language do you target? 
lol you left personal files on that server. looks like you were in CS50 Harvard University's introduction to the intellectual enterprises of computer science and the art of programming. &amp;#x200B; &amp;#x200B;
He mentions in the original thread that he did indeed implement a state machine. He also did it entirely without ncurses. It's a really intense project and pretty impressive. 
First return arr; `arr` is a pointer to a local variable `read`. Once the function returns, `read` is gone and the return value is a dangling pointer. Secondly len=&amp;counter; This is changing the value of the parameter len to point at something else. The caller will not see any change. What you need to do is change the data that the passed in `len` is pointing at.
Wow! Need to go and read that thread. Impressive indeed. 
r/learnc
Olá,muito obrigado já consegui por a funcionar agradeço a ajuda: `if(strcmp(user.pass,passreal)==0)` `obrigado.`
What does casting and aliasing have to do with this? Do you mean the type that is passed to the shared functions? I use a union for type-punning as I understand it should work. However type-punning is not strictly necessary because the shared functions could be passed addresses of the pointer, the size and capacity and not need any structs at all. I am not really sure what you are getting at.
Hold on ... are you trying to learn C or C++? They are not the same thing.
C++
Thanks for the help! I realized that this actually wasn't the problem, but it was the matrix i was passing in that was causing the issues.
Thanks for the tip! 
Sorry, and thanks for the tip. I noticed as I was debugging that something else was the problem. Thanks!
This sub is for C. The sub you're looking for is /r/cpp_questions. /r/learnprogramming is also a good resource. Outside of Reddit, I'll suggest https://www.learncpp.com/.
how do i fix it so that the return value isn't a dangling pointer as for the len do you mean i should deference it? like this \*len=counter;
On windows the typical expectation for a build system/ide is visual studio. I've found that to be pretty standard from the professional environment, to open source (when it supports windows). On linux Make its very common to see professionally. Unfortunately there's a lot of automake too, especially in opensource. The reason you can find so many code editors, IDEss and build systems is because there is no right answer as to what you need to use. Personally I made a switch to CLion + CMake a year ago as I found it to be the most robust IDE for C and C++, but I came from editors like sublime and vim with gcc/make. I think it's best to start by learning from an editor and compiler, building from command line. That's how I learned the building and linking process, and it helped me understand what's magically happening behind IDEs.
I use Linux with vscode and cmake/ninja at work. I have also heard good things about clion.
Either malloc the memory for the array or pass the function a buffer it can write to.
I switch between the classics on a regular basis (emacs, vim). I've also used Atom, vscode, eclipse, netbeans, etc. etc.. As for toolchain, for C projects I usually use cmake to control the build process, cmocka for unit testing, valgrind for memory leak checking, gdb/lldb for debugging. The normal jazz. I usually use GCC to compile code, but sometimes LLVM. If you're a novice though, here's my advice: the tools don't matter much, focus on learning the concepts. I would *strongly* recommend a *nix distro, maybe start with Ubuntu. In Ubuntu, open a terminal and type ``sudo apt install build-essential``, then ``gedit hello.c``. Use gcc to compile your programs. C is the language that refuses to die, but some of us are secretly hoping it will be replaced by the likes of Rust or Go. If you're learning to code, and you're not planning to jump right into embedded systems, learn Python (I use it every day) or Go.
I did this "int \*read= (int\*) malloc(counter \* sizeof(int));" and this is the error I'm getting **test\_read\_deltas(13990,0x7fffa30aa380) malloc: \*\*\* error for object 0x7f8d00d00000: pointer being freed was not allocated**
Hi, I have been coding in C for almost 3 years, mainly for school, but also professionally for a few months. For editing C, whatever is good enough, I've used VIM, emacs, micro, nano, v's-code, atom and there were all fine. For compiler I've only used GCC and Clang both are great. For OS's I've worked on Linux and Mac OS. Linux is a tad better and is generally preferred over the later, but as long as it's UNIX based it's good. Never coded in C on Windows but do not have a good reputation, and I can imagine why, given how tightly tied to the terminal C is. Apparently it is better now with windows's Linux subsystem. If you can go Linux it's a great experience if you want to become a dev. For the workflow pretty much everyone does everything on the command line: git, compiling, small edit, ... (if you don't know git, learn the basic, it is industry standard) For most project 1 file is not enough, so I use Make for 99% of the time. C make is a more modern alternative. As for how C is used nowadays, well, it is the standard for embedded system, OS's and really high performance (radius is one example). It is also used a lot for a legacy project
Vim :D
The normal way of implementing a `vector`-style object would involve passing a pointer to a structure which contains a pointer to the information, along with the size, capacity, and whatever else the memory-management code might need to support whatever features it offers. Unless I'm misreading things, a `darray(int)` would contain an `int*`, a darray(widget)` would contain a `widget*`, etc. While it might be possible to write a resize function which would be invoked as: myThing-&gt;ptr = darry_resize(myThing-&gt;ptr, &amp;myThing-&gt;length, &amp;myThing-&gt;capacity, int requestedSize); that would seem rather more awkward than just passing the address of `myThing` to a function that could handle any `darray`-style structure that has the proper layout. 
2. Yes.
I made some updates to the body. I am also going to continue to review the code myself and work to add this feature. Just wanted to add an update.
If you're getting that assert at the time you call malloc then you've already corrupted the heap earlier in the program. But yes, call malloc, copy the data into the buffer, and return that. The caller will need to free it. 
Thanks for the free pen-testing. 
This is brilliant! :P
This is the loop I used for my buffer while(fscanf(fpointer,"%d",&amp;read\[counter\])!=EOF){ read\[counter++\]; } int\* arr; arr= read; return arr; It's still leaving a tangling pointer and stuck on the first value example: Element at index 1 is incorrect \[ i\] EXPECT ACTUAL \[ 0\] 1 1 \[ 1\] 2 1 \*\*\* \[ 2\] 3 1 \[ 3\] 4 1 \[ 4\] 5 1
Thanks for your feedback. Do you think the tool will improve the learning experience of newcomers with the C language? 
Have you heard of valgrind?
this is the loop I used for my buffer while(fscanf(fpointer,"%d",&amp;temp)!=EOF){ read\[counter\] = temp; counter++; } int\* arr; arr= read; return arr; It's still leaving a dangling pointer and stuck on the first value example: Element at index 1 is incorrect \[ i\] EXPECT ACTUAL \[ 0\] 1 1 \[ 1\] 2 1 \*\*\* \[ 2\] 3 1 \[ 3\] 4 1 \[ 4\] 5 1 &amp;#x200B;
Have actually scanned theough the api before, but was not abpe to find the one that helps with authentication... did I perhap missed something?
Im trying to limit the library usage as wolfssl itself ia already one giagantic headache for me now..
On the landing page. API Access rules. „Clients must authenticate with OAuth2“.
&gt; I think it's best to start by learning from an editor and compiler, building from command line. That's how I learned the building and linking process, and it helped me understand what's magically happening behind What’s a good way to learn this on windows then? It sounds like to do this I should avoid using an IDE or at least avoid letting the IDE do this for me 
Look into a library like [mongoose](https://github.com/cesanta/mongoose). Basically, build an API in C using the library, then have your html buttons call the URL endpoints provided by that API.
Do I need a thing on the top to activate the html
you mean like a web browser?
If I remember correctly you can use MinGW via command prompt with virtually the same effect. Add it to your environment path variable.
Cool I’ll give it a go, thanks
Hmm, I guess I don't quite sure what you're looking for, based on your questions. Maybe write up a more complete problem statement of what you're trying to accomplish? Something high level, so we can tell if this is actually a good solution for you.
We’re going to need a lot more info about what it is you’re trying to do.
&gt; I want to be able to read multiple lines and then print them back again. Currently, if I understand correctly you are reading only one line. Correct? &gt; input: Hi this, is the Op Speaking here. Output: Hi this, is the Op Speaking here. This is the expected input output. What do you currently see when you type the input and press enter?
Thanks a lot for the comparison. Valgrind is indeed a very useful tool. But the design goal of Stensal SDK is to achieve memory-safety with very high probability, and to make the behavior of C code more predictable. Stensal SDK aborts out-of-bounds read just like Java throws IndexOutofBound exception. You mentioned: "Your output is vague and hardly shows where the issue is". I want to get a better understanding what causes the vagueness and how I can improve the message. My error message shows the following: 1. The declaration location of the object that is read outside of its bounds - The object to-be-read (start:0xffc07d7c, size:40 bytes) is allocated at - file:/prog.c::3, 9 2. The stack trace that the out-of-bounds read happens - the read starts at 0xffc07da4 that is right after the object end. - Stack trace (most recent call first): -[1] file:/prog.c::7, 9 I felt the information is sufficient for me to identify the cause and fix the bug. I see it everyday and assume other people can understand it well. Do you have any advice how to make the message more understandable? Thanks a lot for your feedback. 
Wtf, a randomized formatter? If the purpose of the tool is to help ensure and standardize coding styles, you go the other and make a salad of settings? Is that it?
I started programming in 1978 in Basic, moved to Fortran/Ada in the mid 80s and in the late 80s moved to C for the rest of my career (still going, all in C). Coming from UNIX, VI is my editor of choice (using Linux as my IDE), but just use what you're comfortable in. VI is esoteric and probably not the best choice today. My career has been focused on embedded development, so GCC and more recently ARM RVCT as toolchains. Language is just a choice for development, though C is the lingua franca of embedded programming. You'll help yourself focusing on basic concepts (data structures, algorithms, etc.) and then decide which language you enjoy programming in most. C is best for bare-metal programming, but there are lots of language and opportunities for them. Once you know the basic concepts of programming languages, many languages (excluding functional) are just variations on a theme.
Just to add, I’d **highly** recommend downloading the MSYS2 terminal and getting Mingw downloaded from there. MSYS keeps everything in one place and provides bash+Unix tools while still enabling distributable programs
I use macros when I want to add debug checks around functions, or want to skip calling a function entirely when building with NDEBUG. Additionally, I use them in logging functions to transparently add information about the current file, function and line in the code, as specifying this manually in each call would be tedious. I have used it in other cases to enforce certain conventions in the code around variable naming, or just improving general usability of an API. As long as it is clear at all times what a macro does, I don’t mind using them. A downside of macros is that they obfuscate compiler errors, so it’s finding the right balance.
Are you saying your *library* is meant to be built into production code?
If you want to read multiple lines then the loop can't end when ch equals \n. You'll have to figure out another way to signal the end of input, maybe a special character or sequence (in college my professor had us read until we read STOP)
Eclipse CDT at work on Windows (lame, but my boss insists) doing embedded; text editor like Kate, Gedit, Vim, Nano (all with no plugins) on my PC (currently using Kubuntu, planning on switching to Arch eventually). [Here's a must read](https://medium.com/datadriveninvestor/dont-learn-a-programming-language-solve-a-problem-instead-654f6bbfb573).
So if I enter "hi" followed by enter I get the same thing back.
Yes. I know. So what exactly is your question then?
How do I write my code so that it reads multiple lines of input ?
EOF signals the end of input in OP's code, doesn't it? 
I see. So, why are you breaking out of while loop when you receive \n?
oh you're right. he's reading a file not stdin, I was confused.
He is reading stdin and you can get EOF on stdin. https://stackoverflow.com/questions/28216437/end-of-file-in-stdin 
It's more suitable for the former case, but it will report all illegal memory accesses that can cause segfault or data corruption with very high probability. To show how it's better than valgrind, let's look at this live test (https://segfault.stensal.com/a/kqc8xvQnCz48a0Xg), the array is indexed by 15. Stensal DTS (runtime) will report this out-of-bounds read, Valgrind will not. As a matter of fact, Stensal DTS will report out-of-bounds read for any index that is larger than 9.
I love C, and IT WILL NEVER BE REPLACED NY rust or Go . 
It can't. Being able to shoot off your own foot is impossible in those languages.
Go can't replace C because it uses garbage collection. Rust won't replace C. You can get memory safety in C with static and dynamic analysis. And the languages were designed to solve different problems - a feature in one is a misfeature in the other. The use cases for C will never disappear.
I'm trying to do this Document. getElementById(""); (this is js) but in c
I'm trying to do this Document. getElementById(""); (this is js) but in c
Yes
 #include &lt;stdio.h&gt; int main() { FILE *fp; if ((fp = fopen("test7.c", "r")) == NULL) return -1; int c; while ((c = fgetc(fp)) != EOF) putchar(c); fclose(fp); return 0; } It opens the file test7.c out of the folder I'm in -&gt; loops reading + output (char to char) -&gt; closes the file and returns
At work I use visual studio 2015 on WIN7/10, but I have an OpenBSD VM to use some protection mechanisms to debug my code. Vim is enough to write C &amp;#x200B; &amp;#x200B;
Actually `unsafe{}` blocks let you shoot yourself as much as you want. 
If you're on Windows 10, just get the Linux Subsystem installed and use all the relevant tools from there 
The method reddit uses for application login is called OAuth2. Here is the [old](https://github.com/reddit-archive/reddit/wiki/OAuth2) documentation. I assume it's not obsolete. 
There's a full guide on how to get that installed in a way that works well both inside Msys and on the windows command prompt with the right toolchains here : https://github.com/orlp/dev-on-windows/wiki/Installing-GCC--&amp;-MSYS2 I've found that you can work with various libraries like libsodium, mbedtls, etc on Windows, Linux and Mac using the same source code when developing wuth gcc. Notepad++ for the text editor on windows, 'vi' on Linux. 
Do I understand you correct? You suggest to add a way to specify certain environment requirements within a program (e.g. sort of a stack-related asserts), and then make sure that there's a way to \*demand\* satisfaction of those requirements given a program written against those requirements?
Could you please link the original thread here when you have a moment? Thanks jn advance! 
It's in the OP
 print_line(&amp;words[1]); Use t\[1\], if you want to see the 456. words is a misleading name for the variable. res[word_count] = (char *) malloc(temp_index * sizeof(char)); res[word_count] = vc_strdup(temp_word); 1st line does not make sense. &amp;#x200B; temp\_word\[\] should be one larger, to handle input with no blanks. There's no need to use explicit \\0 at end of strings, or explicit sizeof(char) (it's 1), or to cast the return value of malloc().
You could try using [CEF](https://bitbucket.org/chromiumembedded/cef/) (or something like it) and modifying it if you dont want this to run as a server. I'm guessing thats what you mean by &gt;I'm trying to do this Document. getElementById(""); (this is js) but in c What you're aiming for is pretty complex. There are a lot of GUI libraries that are far simpler and won't produce gigantic binaries. You're embedding an entire browser in this case.
Golang works pretty well for web servers, and I think it comes pretty close to the syntax and functionality of C while still offering some affordances to make it more user friendly. Still I'm anyways surprised when people do things like write low level code in Golang, it doesn't seem like the right tool for the job. As for Rust, it seems like the flat earth of program languages. It seems like a parody that most people avoid, but the people who use it are religious zealots.
&gt;C programmers, what do you use for programming in the real world, like at work, IDEs or text editors Editor is vim for everything. I use Javascript for most of my day job. C is something I work on to gain a better understanding of how computers fundamentally work. &gt;I've been picking up and dropping C programming for 3 years now. Started in college, where we used CodeBlocks. I personally thought it was dumb using CodeBlocks, not because the IDE is dumb IDE's are dumb. You hit a magic 'compile and run' button and you see some text appeal in the bottom of you screen which you have no idea how it got there, or what it's supposed to do. &gt;I didn't know which way is actually used in the industry, if there was a standard or something... The standard is what ever works for the task you're trying to achieve. One thing that's hard about C is that it has a small niche between a lot of other languages. Want to automate something on the command line? There's python for that. Want to do servers? There's Golang. &gt;I wanna grasp C well enough where I feel comfortable to take on any problem or task that can be given, before moving on to learn new programming languages, like C++, C#, Java, JavaScript, or Python. You can go with what ever works. The more you understand C the more comfortable you'll be with any language, but it's all computer science. So you can learn by using higher level languages and compare and contrast with what you know with C. &gt;I'm currently programming as a hobby, but I'm planning on starting some courses and maybe even making it my career at some point, I hope. Cool. What kind of projects have you been working on. What resources have you managed to find? And what kind of resources are you looking for?
Preprocessor options tend to be the go to for this. Simple #define around code blocks allow you to compile in and out certain functionality. 
As the Standard is written now, the question of how deeply function calls can nest is purely a Quality of Implementation issue, with no requirement that implementations be capable of processing any useful programs without bombing the stack (an implementation could be incapable of processing anything other than a single contrived and useless program and yet still be "conforming"). As such, the authors of the Standard didn't expect it to matter whether the Standard defined behaviors which would obviously be useful for most kinds of implementations, since implementations that wanted to be useful could define them, and those that wanted to be useless could process almost any source text in arbitrary meaningless fashion. The Standard would be much more meaningful if there were a category of programs for which the Standard would require implementations to offer at least some behavioral guarantees, and if the Standard were to recognize as "optional features" some of the more useful "popular extensions" alluded to in the Rationale's paragraph about Undefined Behavior. A requirement that an implementation either process code with a certain directive a particular way or reject it entirely need not cost *nothing* on implementations that opt not to support the semantics, if the directive were specified in such a way that it would fail compilation on any implementation that doesn't understand it. The purpose of environmental requirements is to avoid requiring that implementations do the impossible. The classic "what if someone pulls the plug" could be answered with "the environment would most likely cease to meet the implementation's requirements, releasing it from any obligation to continue processing code usefully". I say "most likely" because it would be possible (and perhaps even useful) to have an implementation for certain microcontrollers include logic that would respond to a power-fail interrupt by storing program state to non-volatile storage, and then reload that state and resume execution when power is re-applied. The question of the circumstances under which execution would or would not be able to proceed usefully should generally be a Quality of Implementation issue, *but only if it's documented*. 
Not really, actually you learn from a "perfect piece of code" what your standard coding style is and create a matching config file. Then you can use it to reformat all your code base.
The first line has no effect except to leak memory since the second line overwrites whatever it was that `malloc()` returned.
How about a 1700 year old algorithm? The "Sieve of Eratosthenes" would be a good place to start. 
Suggested approach: 1. Find out how to input and print numbers with stdio.h 2. Find out how to check if a number is prime. 3. Iterate down from the inputted number, checking if each is prime.
Vim + youcompleteme + vim-snippets + ultisnips+ vim-cmake and some other vimrc configrations settings along the way.
First off all, thank you for this insightful comment. I've been mostly working on simple programs in C, trying to find what to use to get the best results. I've build calculators, simple programs to get information about my system, I encountered some difficulty grasping loops and pointers so, that's where I wanna focus more on. I'm currently working in an IT company, data entry, and just started SEO. Like I said, I've been learning programming on the side, I love computer science, studied 4 years in high school, then went to college for 3 semesters but, I dropped out because I didn't like the way they teached the subjects. I was overwhelmed with information, adapting to the new city, my apartment was 20min bus ride from the college, the college itself had the worst organization I've ever seen, all in all, I decided to drop out and pursue programming on my own. Once again, thank you for your comment. I think what I gathered from all the comments, I will set up Ubuntu on a USB and use that to start, I'll try out different text editors and see what works out best for me. 
Wouldn't that be finding the next smallest prime?
I'll look into this. I also have Ubuntu on an USB, in my opinion, that should work out for the best. A clean OS, just for programming, without much of the distractions I have on my Windows. 
What I gathered from the comments so far, using any text editor, that suits you the most is the best option also, I'll start using Ubuntu, set everything up, grab a big cup of coffee and I'll try to dedicate at least 2-3 hours to it during work days and more on the weekends. I wanna thank you all for the comments, you've cleared a lot of things for me and, in a way, inspired me to get back to it. Finally, I wanna say, from my experience in CS so far, I love the C programming language. 
Yes kind of. The question should be: find the biggest prime number inside a given range. Or how you said find the next smallest starting from any number
As /u/f3zz3h says, preprocessor options are a common solution to this sort of stuff. However you should be careful to structure your code in a way that wraps as little 'real' code as possible in those directives, e.g: Do this: void DoComms() { #ifdef __USB_DEFINE__ USB(); #else WIFI(); #endif } void USB() { // Do some USB stuff } void WIFI() { // Do some WIFI stuff } Don't do this: void DoComms() { #ifdef __USB_DEFINE__ // Do some USB stuff #else // Do some WIFI stuff #endif } The reason is because in the first example both your substantive USB and WIFI code will be built (and checked for syntax/well formedness) even if not selected. Sometimes you will not want to build both sets of code in both configurations. For example, you might need a specific header file for USB to build which is not available when you're building the WIFI configuration. In that case I would suggest putting the USB/WIFI code in different files and use a CMake/premake/make option to decide which one to build. You can select between them by either using #ifdefs in your calling functions, or simply have them expose the same symbol names. This avoids having large source files with a ton of #ifdef blocks around function definitions. I find those very hard to read.
 #include &lt;stdio.h&gt; int main() { unsigned long i; printf("Input:\n"); scanf(" %lu", &amp;i); switch(i) { case 20: printf("Answer: 19\n"); break; case 10: printf("Answer: 7\n"); break; default: printf("Input wasn't predicted"); break; } return 0; } Partial solution
It depends on whether a pointer is always the same size/alignment/layout regardless of the underlying type. My understanding is that it is usually the case, but not guaranteed by the language. This only influences what type to pass to underlying generic functions. If everything is done in the macro in-line as in darray then it does not matter, everything just works and you get the advantage of type-checking from the compiler. But the awkwardness is only seen by library designer, not the user. You would hide that complexity in a macro wrapper anyway, so the user would not see anything other than darray\_resize(mything, newsize) for either case.
You do not seem to allocate any memory for `new-&gt;name`. Before you can execute `strcpy`, you first have to allocate some memory to copy the string into.
No browser speaks C so there isn't really a way to script HTML with C. What you can do is writing your web application in C and having the Javascript code send everything the user does to your application so the application can react appropriately.
Oh thanks
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
If by this you mean you wish to use C in the browser instead of js, check out [WebAssembly](https://webassembly.org/docs/c-and-c++/). WebAssembly lets you write a program in C, then compile it to WebAssembly. The resulting executable can be run in the browser.
Lol, it does what he wants. Signing in that homework assignment ASAP :p
Oh cool thanks! :)
So the input is a code file?
All tests green
As well as what /u/FUZxxl said, you're also not allocating any space for `value` before passing it to `scanf`. 
Hi there, &amp;#x200B; Here's me from like 10,000 feet. &amp;#x200B; **Source Editting:** &amp;#x200B; Normally vim and tmux in some combination. Sometimes it's one pane for source and another for compiling and testing, others it's multiple sources. I use ctags pretty frequently to pop around the codebase. Aside from these, I use my shell (bash) with some frequency, and what I use in the shell varies based on the day. &amp;#x200B; **Operating Environments:** &amp;#x200B; I pretty much use Linux exclusively (I need windows for email at work though). Mostly Ubuntu, but Red Hat pops up a lot too. Targetted Operating environments are very different questions. A lot of the time I'm working bare metal on RISC-V or with some very thin layer between me and the proc (like and RTOS). Not infrequently I have to get things playing nice in Xilinx Vivado, which while not an OS can be a beast of its own to wrangle. &amp;#x200B; **Build Systems:** I'm pretty much always in gnu Make, and git is almost always constant as well. I'm a super big fan of Make since a little effort in it normally reaps huge rewards. My main project work right now I have set so that any one on my team can literally clone then type \`make\` and they have a clean build of everything without hassle (or I can run to fetch coffee). I do sometimes embed git stuff in makefiles (almost always submodules business in case people don't clone recursively). As for compilers, I'm in a space where I can get away with being fairly agnostic most of the time, but I definitely rely on gcc more than say clang or others. I also have to end up using objcopy and objdump with some frequency. &amp;#x200B; **Other Notes:** &amp;#x200B; &gt;but I wanted to see how everything connects and how the compiler worked &amp;#x200B; Keep this curiosity going. Don't be afraid to dive down rabbit holes, this doesn't have quick returns academically or economically, but in the long run is a good thing. &amp;#x200B; &amp;#x200B;
 // In God we trust #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "hash.h" #include &lt;string.h&gt; typedef struct node { char *name; struct node *next; } node; node *add(char *value, node *ptr) { // adds a value to beggining of the list and returns the pointer to the start of list node *new = malloc(sizeof(node)); // new-&gt;name = calloc(strlen(value), sizeof(char)) &lt;-- perhaps + 1 to get a '\0' behind it strcpy(new-&gt;name, value); &lt;= here! // /* if you define a buffer on new-&gt;name: new-&gt;name = calloc(strlen(value) + 1, sizeof(char); snprintf(new-&gt;name, strlen(value) + 1, "%s", value); you would force a '\0' behind new-&gt;name, strcpy() won't do that */ new-&gt;next = NULL; if (ptr != NULL) { new-&gt;next = ptr; ptr = new; // I don't get it return ptr; // return new; ? } else { ptr = new; // I don't get it return ptr; // return new; ? } } int main(void) { node *table[26] = {NULL}; // if you want space on it here: table = calloc(sizeof(node), 1); printf("HASHTABLE V1\n"); printf("Please enter the words(type \"end\" for end of list)\nWord: "); char *value; &lt;-- you want to overflow that pointer? char value[1024]; ? while (scanf("%s", value)) { if (strcmp(value, "end") == 0) { break; } int hashed_value = hash(value); add(value, table[1]); } See comments
I've ended up with `sigprocmask` and `sigsuspend`: https://github.com/sineemore/sxinit/commit/ee81b0ba86c372456731b67fb16acf864f83ece4 I like your example with `alarm`! Awesome use of it actually :) Btw, do you have a GitHub repo or something?
One really simple way to calculate whether a number is prime is to count the divisors. An integer &gt;= 1 will have exactly 2 distinct divisors -- 1 and itself. This is a really expensive way to calculating whether large numbers are prime but works fine for smaller numbers. int divisors(int num) { int divisors = 0; for (int i = 1; i &lt;= num; i++) { if (num % i == 0) { divisors++; } } return divisors; } 
Hm, there is one more thing, that bothers me. I use redshift to make my monitor colors warmer. The program is started with `redshift &amp;` from .xinitrc. When I restart Xserver I still can see old redshift processes.. Should I do some magic with process groups?
Wow, this is awesome! Thank you for elaborating on your workflow. I wanna say that I've learned more on this post, than I did in college or from my own tempering and testing things out. I'll do my best to always stay curious and learn something new each day. I love your comment. 
This is REALLY ineffecient, you only need to count numbers &lt;= sqrt(number) to get what divisors are there, in reality. Also starting at 1 would mean that it always returns that there is at least 1 divisor, when you could just... do for (int i = 2; i &lt;= (int)sqrt(num); i++) { if (num % i == 0) { divisors++; } } It's much faster than what you posted and gaurentees that there are only realistic divisors.
Can you try doing that without math.h though?
Two things: 1. Check out the strtok() function. I’m not quite sure what your use is for counting white space but if you just need to return the strings separated by white space, then that function is golden. 2. I haven’t looked at your full code yet but I’m not sure why you’re incrementing size inside the whole loop. You increment it once in the loop condition so I think the incrementation in the body of the loop is extraneous. Again, I haven’t taken an in depth look. This is just what stands out to me right now.
yes
Yes
He doesn't want you to help him, he wants you to write the code that does it for him.
Thanks kindly! Feel free to ping me if you have any questions as you explore!
That's fair, I didn't notice that part of the question, if really needed you only need to do an integer sqrt, which you can find the source code for, even still, I was still ineffecient since I checked 2 and iterated by 1, better would be: if (num % 2 == 0) return false; for (int i = 3; i &lt;= (int)sqrt(num); i += 2) { if (num % i == 0) { divisors++; } } And THAT is a much faster speedup (checking 2x less numbers, and sqrt less numbers is much better, but doing one or the other is a great speedup) https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2) wikipedia gives a nice isqrt implementation for us... so...
What exactly is the “global declaration section?” I have no idea. C programs are not divided into sections like, for example, Pascal programs are.
In the language the C Standard was written to describe, if `s1` and `s2` have the same layout, one could convert an `s1*` to an `s2*` and use the latter to access the object, at least in the contexts where the compiler could see the conversion or where the object was accessed exclusively as an `s2*`. The C Standard does not mandate such behavior, however, since the question of when to recognize cross-type derivation was left as a Quality of Implementation issue, and some compiler writers have decided that since the Standard doesn't require that conforming compilers be of sufficient quality to be suitable for any particular purpose, they have no obligation to offer anything other than the minimal conforming behavior. 
I know what I posted was inefficient — I said as much in my OP. Were libs other than stdio allowed I’d have probably included the sqrt bound. I might have even unrolled the loop a bit and only checked potential divisors of the form 2k+1 or 2k-1 (only 33% of the numbers to check!). But then we’d be completely missing the entire point of OP’s post trying to optimize an obvious beginner question and getting him into failing the assignment territory for not reading directions. Maybe he wants to go ahead and implement an integer sqrt function — or maybe he doesn’t care that my horribly inefficient algorithm takes like half a second to check the first 10000 integers. 
That's fair enough, true, but as I did say before, I didn't notice math.h wasn't allowed.
I never really like the discussion of Language X replacing Language Y. It feels better framed as topic or niche X seems well suited for Language or Tool Y. As engineers, we shouldn't be looking to defend a particular language, but rather find a reasonable tool for a target. &amp;#x200B; C is great for systems, drivers, and that whole spiel. It's also super important if you want to do any vulnerability related work. However, if I was dead set on writing something that needed memory safety as a hard requirement, I'd likely avoid C because it requires a lot more investment both upfront and through the program's duration. Why should I expend my time and energy chasing down something C doesn't enforce natively when another language handles it for me? Memory safety in the OS or driver space, I'd be willing to hear the arguments for or against it, but it feels like it would be a great argument for trade-offs specific to the space or application. Memory safety for something application level, that would take a lot more convincing based on the use case.
Are you asking how to declare and use a global variable in a C program or are you asking where in memory global variables are stored when a program is running or are you asking how a compiler reserves space in the global memory segment for individual variables?
[Because `==` compares pointers to strings, not their contents](https://stackoverflow.com/questions/8004237/how-do-i-properly-compare-strings)
Rust is not only about memory management; I believe its main strength over C/C++ is to be free from Undefined Behaviour. Then rust will give you guarantee that static and dynamic analysis cannot hive you.
Undefined behavior is one of those feature/misfeature things. Undefined behavior in C usually exists because they don't want to rule out using C on a variety of computer hardware, some of which may not exist yet (or anymore).
\&gt; // In God we trust &amp;#x200B; It's a C subreddit, please, don't advertise MML schemes here.
All good — my bad for sounding snippy, I may have taken your attempts to correct me a little personally and I’ve already been through all these prime-checking optimizations working through Project Euler problems. I’d certainly give OP extra credit for a more efficient implementation, I just figured simplicity was the better route here.
I think he is asking about the generated assembly, dont take my word for it though
you can tell me about everything related to it
No. You tell us what you want to know and narrow it down to some definite scope. As is, your question cannot be answered in a sensible manner. If you want a general overview over the topic, pick up a book. I recommend *The C Programming Language* (Kernighan &amp; Ritchie) and *Linkers and Loaders* (Levine).
Whole lot of xinitrc in it's own process group and killpg instead of kill, would not be a bad idea. SImply setpgid(0, 0) before exec. Some utilities might daemonize themselves in such a way that they inconveniently leave the group, but with luck, not many. X programs ought to notice their connection closing... I don't know redshift or why it would not go away. Don't have Github.Maybe I try it.
ok then tell me how to use global declaration
Thank you. The cmake and premake options are nice to keep file size down to save on RAM and ROM in the embedded world. I will go look into more examples of cmake. Thanks!
You could check until num/2 since &lt;math.h&gt; isn't allowed. Iirc the highest divisor a nonprime will have won't be bigger than it's half.
Maybe you can only check until n/2? It's not quite a precise bound but it should at least be between sqrt(n) and n for n&gt;4
I'm not sure what a “global declaration” is supposed to be; the C standard does not contain this language. I am also not sure how you want to “use” declarations. Can you give an example for a global declaration?
I fixed the stdout and your code will print out the first 10 iteration before being aborted. `value: 0 value: 1 value: 2 value: 3 value: 4 value: 5 value: 6 value: 7 value: 8 value: 9 DTS_MSG: Stensal DTS detected a fatal program error! DTS_MSG: Continuing the execution will cause undefined behaviors, abort! DTS_MSG: Out-of-bounds read is detected. DTS_MSG: Reading 4 bytes at 0xff9409b4 will read undefined values. DTS_MSG: Diagnostic information: - The object to-be-read (start:0xff94098c, size:40 bytes) is allocated at - file:/prog.c::5, 7 - 0xff94098c 0xff9409b3 - +------------------------+ - | the object to-be-read |...... - +------------------------+ - ^~~~~~~~~~ - the read starts at 0xff9409b4 that is right after the object end. - Stack trace (most recent call first): -[1] file:/prog.c::10, 5`
hi, author here! sorry for showing up late! the state machine i talked about in the other thread was about parsing ansi/vt100 control/escape sequences to read cursor keys and mouse clicks. I'd call action[][] a lookup table. there is no state between moves (in regards to this lut)
don't learn from my sometimes pretty horrible C :o (my terminal games all started out as a sandbox to try some ... unconventional ... programming ideas I've had) i do think this is the cleanest way to do it, though. the alternative would be nested switch cases inside the keyboard read function. 
Do you mean define a global variable? These are simply defined outside of any function. **Global across application:** file.h // define a global // ex: extern &lt;type&gt; &lt;varname&gt;; extern int something; file.c #include "file.h" // not necessarily required, but often will be // initialize global int 'something' to 5 int something = 5; &amp;#x200B; You can also have 'globals' that are restricted to a single file. **Globals scoped at a single file** These are somewhat akin to class member variables in OO languages. file.c static int something = 5; &amp;#x200B;
it's about to get 50% [bigger](https://en.wikipedia.org/wiki/Freecell) in the next few days...
Yes, perfectly indented according to your standards
As others have said, the preprocessor is the usual way to go about this. However, you can also do it without the preprocessor by choosing which files to build and link. For example: entropy.h: #ifndef ENTROPY_H #define ENTROPY_H /** * Put LEN (max 256) bytes of entropy into BUF. Returns 0 on success. */ int gather_entropy(void *buf, int len); #endif entropy-unix.c: #inlude &lt;stdio.h&gt; int gather_entropy(void *buf, int len) { int r = -1; FILE *f = fopen("/dev/urandom", "rb"); if (f) { r = fread(buf, len, 1, f) ? 0 : -1; fclose(f); } return r; } entropy-linux.c: #include &lt;sys/random.h&gt; int gather_entropy(void *buf, int len) { return getentropy(buf, len); } entropy-win32.c: #define WIN32_LEAN_AND_MEAN #include &lt;windows.h&gt; #pragma comment(lib, "advapi32.lib") int gather_entropy(void *buf, int len) { BOOLEAN NTAPI SystemFunction036(PVOID, ULONG); return !SystemFunction036(buf, len); } Then later you choose an implementation to link: # Build for Linux $ cc -O3 -o main main.c entropy-linux.c # Build for generic Unix $ cc -O3 -o main main.c entropy-unix.c # Build for Windows C:\&gt;cl -Ox main.c entropy-win32.c 
Very interested to see the code that moves stacks of cards from one column to the next! 
hi, author here! shameless plug to my [minesweeper](https://gir.st/mines.htm) and [snake](https://gir.st/viper.htm) games that also run in your terminal!
Is there a configuration tool that allows me to visualize configurations in a given codebase? Like a makefile parser into a project tree? Or a tool with its own database that could be used to generate and manage configurations?
Do you at least have embedded software experience ? What language(s) did you use for previous embedded roles ?
all the `x2y()` functions are horrible! so much copy-pasted code! but I'd rather program features than cleaning it up :| the one you are looking at is `t2t()` (tableu to tableu) 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions. Also, there is no way you are going to pass an interview if this topic comes up at all.
&gt; Is there a configuration tool that allows me to visualize configurations in a given codebase? I've never heard of one, but that sounds like it could be a cool project. &gt; Or a tool with its own database that could be used to generate and manage configurations? That's basically the purpose of CMake and Autoconf. They present a configuration interface to the user, and they can interrogate the host/target for specific features or libraries, automatically generating a proper configuration.
Thanks habarnam! Will take a look into it as well. Cheers!
Oh I see. Cmake is something I just learned about a few weeks ago when I was looking for a json library. I’ll go research note from there. Thanks for your help.
I recommend Vim. learn Unix commands; if you're using C you're most likely going to use Linux and Unix commands can be used in Linux/mac/Windows(WSL)
I agree with your position on "replacing" languages. I'm always using different tools for different types of safety assurances. It just depends on the project. For me, having just one type of tool built into the compiler would be an annoyance without any real benefit.
google.com
A lot will depend upon the kinds of tools you are using, how tight you expect your memory budget to be, and whether your memory budget will need to accommodate "debug" builds. Given something like: #define USE_FOO 0 void test(void) { if (USE_FOO) foo(); else bar(); } many tools would generally omit any reference to `foo` in the code above, but some--at least in unoptimized builds used for debugging, may retain the reference. Use of `if` rather than `#if` is syntactically cleaner and less lightly to result in wackiness than interspersing `if` tests on run-time conditions with `#if` tests based on build selection. One should take care, however, to avoid needlessly linking in code the program could work just as well without. An alternative approach which plays nicer with tools like `diff` is to define macros for PLATFORM1_ONLY(x) and PLATFORM2_ONLY(x), where one will expand to `x` and the other one to nothing. It's necessary to be careful about commas and trailing semicolons when using such techniques, but it makes it obvious to anyone looking at a `diff` report that the code inside one of those macros will be processed or ignored based upon the target platform selection. My contrast, if one makes a change between `#if PLATFORM1` and the corresponding `#endif`, it may not be clear from the `diff` that the change is only relevant on platform 1. 
Simple, every prime number is either 6·n+1 or 6·n-1 (except for multiples of five of course), so you could find the multiple of 6 that comes right before the number introduced (you could decrement one by one starting from the number you provide) and evaluate the "adjacent" numbers (±1), one of those must be a prime number, the other could be a multiple of 5, if not, it's a prime. All of this can be evaluated by using the modulus operator and some for loops.
There's a trend now a switch trend to meson for those feeling that autotools is.... Lacking. 
You could always replace the "i &lt;= (int)sqrt(num)" part with "i*i &lt;= num" to get around the no sqrt function limitation.
Yes, the freecell one. Very interested in see an optimized function that moves a stack/partial stack from one column to another. Normally only one card at a time can be moved, but if you have several cards in sequence (downward in alternating colors), you can move them all at once if you have enough freecells empty (all four freecells empty means you can move five cards, three freecells let you move four, etc.; Would be nice to see the algorithm that checks and see if you have enough freecells to move a stack/partial stack and just move them without having to manually (or even automatically?) move each card separately onto the freecells and then to the destination column. 
CFWhitman over on the /r/linux thread said "part of the game is for you to figure out more complex sequences yourself." so i'll ask you too: what level of automation would you like? only considering spaces (either on the tableu or the top cells) seems relatively easy. would it be good to also move to other cascades as well? what algorithms do other implementations use?
Look up CGI. You can direct standard output from to server to client browser. So instead of .html pages the user would see .cgi (old standard)
I prefer CMake.
You could stop at its square root without using math.h by checking if i*i &gt;= num
`i * i &lt;= num`
This is horribly false, it does not follow that because all primes have the form 6n+1 or 6n-1 that a multiple of 6 has to have one prime "adjacent" to it! Take for example 120. Neither 119 nor 121 is prime.
IMNSHO get away from there.
I learned using Dev C, don't do that. Not that it was bad in fact it was quite good at everything I was using it for but its so out of date its not even funny.
Yeah that'd work. I still don't know why we're trying to optimize this for primes &lt; 100.
Put that in a macro! 
Mouse button number.........4
I once did a contract job for a very large 3 letter computer company. They had a similar product -- thousands of lines of code, each little module written and maintained by one team member, and nobody had any idea how any other module worked or how it all fit together. They hired me to go through the code and document it in clear English. Perhaps you could suggest your company do something similar. Hire a C contractor to come in and work through all the code, talk to individual developers, and document each piece of code and how it fits into the larger whole. It took me about 6 weeks to complete that contract. I was absolutely amazed by how little code the programmers who worked there wrote on a daily basis. 
Actually your compiler should be able to strip unused symbols, so you shouldn't see a significant difference in generated output size between these methods.
C has no *de facto* standards. On Unix/Linux, less than 50% of coders use an IDE. For compilation, `make`, or `make` in conjunction with `cmake`, or GNU autotools. On embedded, it varies, but the platform is often using vendor-specific toolchains. On Windows, MSVS is perrenially popular for any language it supports, because people love first-party solutions on Windows. I think technically only C89/C90/ANSI has full support, not C99. The only big difference is that dependency management differs on Windows, as opposed to having all of the libraries in `/usr/lib` and the headers in `/usr/include`. 
What even is this post? This sub needs better moderation
When I’ve seen that done you then find the usual software mods going on make it increasingly obsolete soon after it is published if there is not a corresponding “maintenance” effort to keep it relevant. A rule of thumb: bad documentation is worse than no documentation. 
&gt; writing something that needed memory safety as a hard requirement, I'd likely avoid C What does "memory safety" mean precisely in this context? Lots of safety-critical systems are done in C, often using MISRA guidelines, enforced by toolchains. Some are written in Ada. I'm not aware of scientific comparisons about which are more safe. It's possible for a "more safe" or "garbage collected" language to produce worse results in the end, due to toolchain or human processes. That can be important, depending on the results you seek. CompCert is a formally validated C compiler, but other languages may not have tools like that and Address Sanitizer or `-D_FORTIFY_SOURCE=2`. 
&gt; (almost always submodules business in case people don't clone recursively) It's *really* helpful when people do this, especially if they don't explicit point out in the `README.rst` that it's necessary. 
You may have learned *faster* from the things that someone else mentions that trying all of the possibilities yourself, but that doesn't mean you learned more. First-person experience is the best teacher. 
How do you handle the Penalty keys?
I make sure to point this out in the download/install portion of the README; that said I don't make the assumption that everyone will read it, despite its name. It also makes for a nice quick gut-check. If I get a call from someone having difficulty, I can just ask "did you type make?" If that doesn't work, they have some underlying stuff to set up and it's not on me to fix.
Are you kidding? Google it.
It depends on the architecture and the compiler, I guess. For example, in arm64 UL is 64-bits, in arm32 it is 32-bits.
The vast majority of 64-bit systems today are either [LP64 or LLP64](https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models), and these each disagree on whether long is 32 bits or 64 bits. The C standards says long is *at least* 32 bits and long long is *at least* 64 bits. 
Linux, Slackware, emacs, make
What you are describing is documentation. Generally you generate the high level system design documentation diagrams by hand using Visio or Dia. A good way to do this is as you, or your latest hire, are learning the system. Generating the documentation builds understanding and means you now have documentation.
How simple? Mine literally just writes to stderr (or a file the user specifies)... [take a look](https://gitlab.com/MarcusJohnson91/FoundationIO/blob/master/libFoundationIO/src/Log.c)
What's a "programme"?
I write all my code in Linux; using Emacs for editing and CMake to compile with both GCC &amp; Clang, while Valgrind is holding my back and making sure no one looses any feet. Out of these, the tool I'd be most unwilling to give up is without a doubt Valgrind.
My idea of simple can vary, it depends on the structure of the framework, how well documented it is and should be easy for team members to learn or refer to the documentation.
What about a software which takes HTML code, parses it and shows the content on the screen? Shouldn't take long :P
Make a keyboard hotkey. 
To ensure compatabilty, use stdint.h, uint8_t, int8_t, uint16_t, int16_t, etc.
I only asked because I've seen other people ask for "simple" logging libraries, then they expect network connectivity and all kinds of wonky shit.
Sure, but in a lot of cases you aren't in a position to dictate the compilation flags used. IMO if you're writing a library, it's not your place to try to control those things, that's a choice for the application developer to make. Also you can almost always get around strict aliasing by using memcpy, it's just a bit more tedious. 
A cache simulator is always a really good one, if you're looking for a challenge.
Using `memcpy` doesn't fix much of anything, since the Effective Type rules contain an explicit provision allowing `memcpy` to behave as though it transfers Effective Types and use that as an excuse to ignore the possibility of affecting a destination which will be accessed using a different type. If a compiler makes an effort to regard pointer casts as containing both an action on the pointer and a sequencing boundary with regard to its target, and its optimizer recognizes that eliding the former does not eliminate the need for the later, use of silly `memcpy` hacks will be unnecessary. If a compiler can't recognize such things, such `memcpy` techniques will be unreliable. For a compiler to process `memcpy` as a literal sequence of byte copy operations involving objects of unknown alignment would be needlessly slow. The only way compilers will achieve good performance is if they replace `memcpy` operations with sequences that are more efficiently suited to the types involved. And if compilers do that you're back to the same old problem of compilers reordering access patterns that didn't alias so that they do alias, but without taking the aliasing *that they introduced themselves* into account. 
UL means unsigned long, which is a type of at least 32 bits. ULL means unsigned long long, which is a type of at least 64 bits. There are no further guarantees. 
But please pay attention and don't use pointers you've already freed, we've had enough of that.
Line text editor. Program starts and it prints out "000: ". You can type out the first line of text, hit enter, and on the next line it prints "001: ". You can continue adding lines of text until you start a line with the control character maybe a comma or some other symbol that isn't likely to be the first character on a line. ",s filename.txt" saves to filename.txt. ",q" quits the program. ",d 14" deletes line 14. ",r 23" gives you the prompt "023" and lets you enter a new line to replace the old line 23. These commands end with the last ten lines of the text file being printed out. ",l" (the letter L) also prints out the last ten lines. ",l 6" (the letter L) prints out lines 6-16. This uses just the standard library and it is just barely enough text editor to write simple programs or start building better text editors with.
You could probably do the job with regular expressions. [https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454)
That actually sounds like a fun project ngl. 
What libraries is your teacher allowing you to use? If you have a wide enough selection, find two or three of them which you are interested in learning more about, and try to make them work together in an interesting way.
Distributed AI based OS
as my final project(also beginner) I implemented Tetris. Although it used some graphic library and C++ also.
Huffman encoder with variable stride length. Along with a lossless decoder with a nice output of compression or decompression rate. 
I always wanted a Porsche, still waiting. May I ask why you are learning C? Because with this level of motivation it's going to be hell for all of us.
The way I sifted through the various logger libraries was to create a local log package, which would expose an API which I liked, and then use it as a wrapper for the ones I wanted to test. Since logging is being done in a relative uniform way, switching between packages wasn't a very big deal.
From existing source? Maybe Rational Rose?
Use the POSIX library to create a text editor.
You didn't specify enough, so display the html content on the screen... 😂 
I would always go for using &lt;stdint.h&gt;. If you than have to specify constants, you can use the following macros: UINT64\_C, UINT32\_C etc. Than you are safe and platform independent. &amp;#x200B;
I second this. Make a little command-line codec utility for compressing/decompressing individual files, or get really crazy and build a file table index to prefix your compressed archive so you can store multiple files inside a single compressed file.
Look at exactly what you're printing.
I know the problem is in the for loop in makeEvenList, however I don't understand why it stores the same value in every new node. It's the same procedure of addToList, but one works and the other doesn't. Guess I'll keep staring at it a little more.
Does this video help you with pointers at all? https://www.youtube.com/watch?v=5VnDaHBi8dM
Read my previous reply very carefully. 
[https://pastebin.com/712ymM2z](https://pastebin.com/712ymM2z) I rewrote big parts of your code, so I don't really know where your problem was, because the loops + functions are really hard to understand (for me). &amp;#x200B; Output: Full list: 8 7 6 5 4 3 2 1 Inserted value: 8 Inserted value: 6 Inserted value: 4 Inserted value: 2 Even list: 8 6 4 2 Perhaps it helps, or not :) &amp;#x200B;
Practice with very basic usage of pointers. Do very simple tasks, and experiment with different usages (along with printfs so you can see what is/isn't happening to variables/memory). In particular, toy with arrays of char (char\[\] or char\*) as they're probably the most intuitive use of pointers, which represent strings. &amp;#x200B; For example, write a basic program with just a main, declare a char string\[\] = "FooBar"; &amp;#x200B; then declare char \*pointer; Try pointer = string, printing pointer using %s. pointer = &amp;string and see why that won't work. Try pointer = string + 1, print it and see what happens. Try adding different values. Try printing a char via char test = \*(string + 2). Keep thinking of different things you can try, and operators you might not fully understand (for pointers: &amp;, \*, +, -, declarations like char \*\*pointer or char \*pointer\[2\]). &amp;#x200B; If this method of learning doesn't appeal to you, I'm sure someone will provide textbook recommendations. Personally I find learning this way really drills in what's happening and prevents you from making syntactic mistakes even if you understand the theory behind what pointers are and do. Pointers will be very important, and can be an absolute pain in the butt to diagnose in large programs, so you'll definitely want to get a very solid grasp of them.
The logic in your program is 100% correct, but there is a minor error in the last `printf()`, so it prints the wrong value. Instead of assuming that the `printf()` is correct and that the error must be in the logic, do what /u/computerachitect says: start with the `printf()` and work your way backward.
BMP file head reader. A novice should be able to work with opening and closing a file, reading the contents of a file. BMP files have a spesific formatting information contained in the file header. The header is separate from the pixel data and stored in a spesific location of the file so reading that shouldn't be too much trouble. You'd be demonstrating that you can safely work with opening, reading, and closing a file. Reading data contained in a very spesific format and reformating that into a human readable format / display (you should be able to easily find this information online). You could hard code this to automatically read a specifically named BMP file but you could show off your understanding of user inputs to control the program and decide which file to read the header information from and as a cherry on top deal with the user inputting incorrect commands or specifying the wrong kind of filetype as well as deal with malformed or missread BMP file types. I'd have had more fun doing this than the typical "hotel check in system" crap they had all of us doing in my first year of college.
Now even I found the mistake, it's very obvious\^\^
Great!
My teacher taught me C++ first. 😅 but I think I wanted to try C? Anyway thanks for the suggestion. I'll try to look it up 👍 
Found it, thank you very much. /u/a4qbfb gave me the final hint, which was to look at the last printf statement. Now I know what you meant.
Thank you, I got it to work now.
Thanks for the effort! However I already saw where I went wrong, it was the variable I print in the final for loop in main :)
The same goes for C++. Both languages are not suited to beginners. Source: I learned C as my first language.
So what the ideal language for beginners to learn? 🤔 
 while (evenList) { printf("%d ", evenList-&gt;value); evenList = evenList-&gt;next; } Would do the same, but I think that wouldn't work on every system, because evenList being NULL at the end is not always the case (compiler specific?). &amp;#x200B; setting the last evenList-&gt;next to NULL in makeEvenList() and using: while (evenList-&gt;next) { printf("%d ", evenList-&gt;value); evenList = evenList-&gt;next; } would be the best way. &amp;#x200B;
By the way, this was an exercise in a C exam I took a few weeks ago. My professor marked it wrong because "I only return the last element"... I guess he's wrong? https://i.imgur.com/DZbsXck.jpg 
In my opinion, Python or Java. They both abstract enough from you to allow you to think about the program - not the nuisances of the language you're using. At the end of the day, your first programming course is supposed to teach you to think like a programmer. Learning it is much easier if you don't have to fight with memory errors along the way... But learning C or C++ as a first language has its advantages, too. For example, a lot of other useful languages use C-style syntax, so you'll probably be able to read program written with them without too many problems. Also, you'll have a thick skin. After C/C++, pretty much every other language that's useful will be a piece of cake\*. :)
By the way, this was an exercise in a C exam I took a few weeks ago. My professor marked it wrong because "I only return the last element"... I guess he's wrong? https://i.imgur.com/DZbsXck.jpg
After learning C, using Java or Python has sped up considerably my development. I wouldn't mind undertaking a big project in Java, but C and C++, after 10 years, still scare me (but that's probably just me, I hunt errors people make in C/C++ code for a living...).
Oh I see, yeah that's a better way to put it. Mind checking [this](https://www.reddit.com/r/C_Programming/comments/aquvm1/struggling_on_a_linked_list_exercise/egiu2lc/) out?
I had to do this in a previous class. That crap actually made me regret being alive ngl. I had to invert it, remove all of one color, multiply the size using a command line param, split it diagonally, and then copy it to a new file.
This is really helpful 👍 this is my first project. Idk what project should I do. 
He's right, but that doesn't change that you're right too: &amp;#x200B; Your struct EL \* -&gt;next shows on the last loop which makes it really hard to understand 1. struct EL \* of malloc() // I call it xy 2. then you set xy-&gt;next to the malloc() call out of your last loop (the first was NULL), because your \*list started at NULL 3. you set list to xy &amp;#x200B; Took me 5 minutes to get 7 lines of code, I don't think that's good, because the code in it could be extremly simple and easy to read (or I am just bad at reading code).
Pointers can be difficult to get your mind around at first but they are a critical part of what makes C such a powerful language. I definitely second what another commenter suggest in regards to just experimenting yourself to see the behaviour of pointers and try to understand how they work. For a textbook, my recommendation is Programming, Problem Solving and Abstraction by Alistair Moffat. Great textbook (is the one used at our uni for our introductory C class, written by the lecturer). It is very concise but will give a great overview of all the basics (and his brilliant sense of humour shows through in the writing). There are tonnes of worked examples, and a lot on basic algorithms (insertion sort, quick sort, merge sort, heap sort, pattern search algorithms, traversing a bst etc.) and data structures (heap, hash table, linked list, tree, binary search tree etc.)
https://www.learn-c.org/en/Pointers 
Im confused, does this mean in my not so honest opinion?
Humble
Thanks!
No, /u/computerarchitect told you everything you needed. I just repeated it with more words.
Yes, and that helped me find it :p
Sudoku solver. You will need to use arrays, recursion, backtracking, file input, output, and sine matrix math. 
Thanks 👍 
&gt; ISO approved. What does that mean for you?
Jezzz! Even I feel like writing this fuzzing thingy and I've got many years of experience. This was very interesting. Are you single? 
There's a company that has a database of development practices and critical failure rates. I don't have access to it anymore, but as I recall the language doesn't really matter if your development practices are good. Just using the Rust borrow checker wouldn't satisfy all the criteria of a good development process. Rust does satisfy more requirements than C "out of the box", but as you've noted, C has more tools available currently.
I'm wish I had money to spare and distribute to all those who commented here. Thank you all. 
Some compilers offer debugging strings, which aren’t as helpful when used in functions: **\_\_FILE\_\_, \_\_LINE\_\_, \_\_func\_\_**. The reason why they won’t work as you’d want in a function call is that it will print **the line of the program in that function**, rather than the line in the function that called it. Same goes for **\_\_func\_\_**. You can use these to define macros used for debugging your code like below. Other than getting familiar with GDB, this below is all you need to properly debug code (well, that and your trouble solving skills!): #include &lt;stdio.h&gt; #ifdef DEBUG #define log_info(M, ...) fprintf(stderr, "[INFO] (%s:%d) " M "\n",\ __FILE__, __LINE__, ##__VA_ARGS__) #else #define log_info(M, ...) #endif int main(int argc, char *argv[]) { log_info("Start of program"); int var = 10; printf("my variable is %d\n", var); log_info("End of program"); } &amp;#x200B;
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
This is really useful and something I've never learned about. Before, I used to put in print statements like `printf("made it to line XX\n");`. This makes it a shitload easier. Thank you
If you want something to twist your brain while not using advanced C, you can try to implement a high volume logger that's safe to use in a multithreaded environment.
Just do it! ;D Nope, I have a beautiful girlfriend and we're travelling across Europe since 2016, just like every other programmer out there.
Even on x86_64 architecture, your statement would be true on Windows but not true on Linux. As /u/skeeto says, Unix and Linux are LP64, making `long` 64-bits. On 64-bit Windows and OpenVMS, which are LLP64, your statement is correct. 
[Brainfuck](https://en.wikipedia.org/wiki/Brainfuck) interpreter or a Brainfuck to C compiler.
Which parts are you stuck with specifically? Writing a function? Checking if a number is odd or even? Something else? We're not going to do your homework for you but with some more information we can nudge you in the right direction.
A GIF decoder. They're not all that complicated and you can have some fun turning a specification into something with potential real-world application.
Write a raytracer!
`cat /dev/urandom &gt; /path/to/target`
lol I recently did that. I don't know how, but gnu bf manages to be *so* much faster than what I wrote.
I definitely seen some job postings that required knowing how to use valgrind for C development. Maybe try brushing up on using valgrind.
I really wanted to write my own text editor from scratch when I started learning C but I didn't want to spend weeks building something I would never use. When I wrote my line editor, I wrote it so you pass some pointers to it at the beginning so whenever I need to build some initial data file with multiline strings I can just #include "LineEditor.h".
I haven’t intimately read your code, but you can use a char pointer to access whatever you want. The void pointer doesn’t exactly alias: you can’t actually write or read what a void pointer points to so there’s no aliasing problems there. It’s just a memory address and nothing more. Once you return out of the function your void*, it can be cast into whatever type by the caller. That’s how memory allocators work, which is what you’re building.
I use stdint.h all the time, but it does not have macros that behave like UL/ULL/F etc.
In your insertion function, within the "else" block that handles insertions once you have a root node, you are not descending the tree before creating your new node. Your for-loop isn't doing anything except repeatedly inserting nodes at the root's L or R child for whatever value in have passed to the function. You need to traverse the tree down to a child node, choosing your steps at each branch according to the comparison with your value to be inserted.
Can you give us any more information? I had an interview once where using a debugger wasn't allowed, and I had to debug the code. It just came down to understanding common coding mistakes, and coding in vim helped a lot with that. In fact I've never had an assessment where I was allowed to use a debugger.
The Standard makes no attempt to demand that all implementations be suitable for tasks requiring their own memory management. Most compilers can be configured so as to be suitable for such tasks, via `-fno-strict-aliasing` flags, but are not designed to be suitable for such tasks in `-fstrict-aliasing` mode. Some others like icc seem to be designed to be suitable for such tasks even when `-fstrict-aliasing` mode is enabled. The Effective Type fail to recognize any distinction between constructs like: void writeIntAndFloat(int *ip, float *fp, int mode) { *ip = 1; *fp = 1.0f; if (mode) *ip = 1; } void compilerShouldntHaveToAllowForAliasing(void *p1, void *p2, int mode) { writeIntAndFloat(p1, p2, mode); } and void writeInt(int *p) { *p = 1; } void writeFloat(float *p) { *p = 1.0f; } void compilerShouldAllowForStorageReuse(void *p1, void *p2, int mode) { writeInt(p1); writeFloat(p2); if (mode) writeInt(p1); } I think the rules are clearly intended to allow for storage reuse the latter pattern, but I don't think they're intended to allow for aliasing in the former. Since allowance for aliasing in the first form impedes useful optimizations while seldom serving any useful purpose, I would not expect compilers to maintain support for that construct, but unless the latter is recognized as different, dropping support for the former would mean dropping support for the latter. In the former snippet, if the arguments identify the same storage and `mode` is 1, that will mean that storage was accessed as a `float` *between the creation and use* of an `int*` identifying the same storage, meaning there is aliasing between active pointers of type `int*` and `float*`. In the second example, no `int*` identifying the storage would exist at the same time a `float*` identifying that storage, and thus no two such pointers alias. 
I never use those. I care about the storage type, not trying to designate a type for a numeric constant which is superfluous. The storage var dictates the type, and my compiler won't let me overflow a numeric with an out of range constant. The only constants I decorate are wide strings: L"just like this";
Usually /dev/shm is just mounted as tmpfs or something like that. It’s possible to put things elsewhere, both in terms of `mount`ing and `shm_open`ing, just not generally a good idea for use with SysV IPC. You don’t want your shm hanging around cluttering up non-tmpfs directories if you can help it. `mmap` is a more general-purpose doodad that allows you to do basically the same thing with ~any file ~anywhere, as long as you use `MAP_SHARED`. Things may get weird if you’re going over NFS, of course, in which case you may need to use `msync` to flush changes. (Theoretically you should always use `msync` for anything `mmap`ed for which you want changes to be externally visible, but in practice as long as both processes are on the same machine they should be sharing a single block of physical memory.)
There are many things wrong with this line realloc(integerPtr, sizeof(integerPtr) + sizeof(int));
Hi, There are a few misconceptions in your code. First thing I would suggest is turning all warnings on because when I pasted this code into my editor my compiler immediately gave me some hints. The most important one being this: /tmp/p2.c:39:9: warning: ignoring return value of function declared with 'warn_unused_result' attribute [-Wunused-result] realloc(integerPtr, sizeof(integerPtr) + sizeof(int)); I don't know what compiler you're using but you can enable all warnings with something like: cc -Wall -pedantic my-program.c What the above warning is telling you is that you're ignoring the return value of `realloc` which you can't do. The system may need to move the pointer so you call realloc with something like the following: /* In actual production code you need to protect against NULL as well but an example this is fine */ ptr = realloc(ptr, newsize); Another problem in your call to `realloc` is that you're passing `sizeof(inttegerPtr)` which will _always_ be the size of a pointer, not the total amount allocated at that position. I have written a function which reads a variable number of integers into a pointer, reallocating as it goes which should help explain how to do that. [Here is a link to the program](https://pastebin.com/G75nyWua). You'll need to implement the endian conversion but that should get you started. Good luck!
I don't think casting to `void *` magically solves the problem. As soon as you cast from `void *` to something else, you are back to square one. Also the strict aliasing rules doesn't mention that it's only local to functions. When you access malloc'd memory using a type, that memory's "effective type" does become that type, this is stated in the standard. My confusion is whether part or full memory becomes effective type. Like, if I set one field of the struct, does it affect the effective type of the memory in other fields? If it doesn't then there's no problem. But if it does, then strict aliasing is violated. 
Would it be useful, if the shared memory wasn't in any directory ? shmget, shmat et al would do that. Depending on how your OS does things, of course.
The standard doesn't mention `scope` in the strict aliasing rules.. It just says "subsequent access" which means it can go through function calls. &gt; If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for **subsequent accesses** that do not modify the stored value &gt; An object shall have its stored value accessed only by an lvalue expression that has one of the following types — a type compatible with the effective type of the object As per these rules, both your examples contain aliasing. 
Good idea. :-)
Sounds like they have no idea as to what they're asking for in regards to simple logging. I just need to keep track of program activity for quality and have the library live in the project. I don't think network and connectivity is required mostly because that does not sound like a simple logger that sounds like a logger plus more.
It means the library must not violate the users project any via memory like and date lost. Altho now that you asked I actually meant [SEI CERT](https://wiki.sei.cmu.edu/confluence/display/seccode/SEI+CERT+Coding+Standards) Coding standards.
You made me sit at a keyboard for this one :| I kid, I kid. Ok, no, that's not exactly what that means. The memory has no type, it's just an address to a block of memory that holds some values in it. That's it. It has absolutely no concept of types. Don't believe me? Break into the actual machine code in your debugger and show me where you see any type information in your block of memory. It's just 1's and 0's. So what's that got to do with aliasing? Aliasing is when you have two pointers of different types pointing to the same block of memory. Why's that a problem? Well, the compiler, when strict aliasing is enabled (which it should be by default), can presume that two pointers to unrelated types are pointing to wholly unique blocks of memory. This means it can order the instructions in an optimal manner to increase memory bandwidth. What's that mean? Well, if you have two pointers, say int and float pointing to same block, the order in which they execute at runtime is going to be undefined. It's up to the compiler and hardware setup you have. But aliasing is only a problem when you're accessing the same block of memory. And by block, I mean some chunk that overlaps. Let's say I do this (assuming sizeof(float) == sizeof(int)): void foo() { int *pi = malloc(sizeof(int) * 2); float *pf = (float*)(pi+1); *pi = 4; *pf = 6.3; free(pi); } There's absolutely no problem there. I'm not writing or reading to same block of memory. Let's say malloc returns 0xff00. malloc just returns a number, after all. That means that pi has a value of 0xff00. pf then has a value of 0xff04, assuming a size of 4 bytes for both. When I access the memory, it's uniquely accessed. There's no competing read or write to 0xff04. It's just accessed through pf. Strict aliasing is upheld. Now what if I change the code to this: void foo() { int *pi = malloc(sizeof(int) * 10); float *pf = (float*)(pi); int i; for (i = 0; i &lt; 10; i++){ *pi[i] = i; *pf[i] = (float)i; } free(pi); } Yeah, aliasing is broken there. They're reading and/or writing to same block through the lifetime of that block. What about this? void foo() { int *pi = malloc(sizeof(int) * 10); float *pf = (float*)(pi); int i; for (i = 0; i &lt; 10; i++){ if (i%2 == 0) *pi[i] = i; else *pf[i] = (float)i; } free(pi); } What about that? Totally fine! At no point is a memory block accessed by two different pointers within the memory alias barrier. That is, you have unique pointers to each block of memory: pi[0], pi[2], etc all point to unique integers pf[1], pf[3], etc all point to unique floats In your case, as long as you're never accessing the memory you're sending back to the user, you can do whatever you damned well please with the rest of it. That's literally how allocators have to work otherwise how could you ever send memory back or track blocks?
You can try to write your own shell!
Thank you very much! That explains my confusion. Btw, I didn't mean the type exists at runtime. I meant the effective type is tracked by the compiler, like how types of local variables are.. 
Ok cool, glad that helped clear things up. One thing, though, the compiler doesn't keep track of the types beyond superficial things. That is, it doesn't track what you do with your memory. That's why aliasing rules exist! So the compiler doesn't have to track what you're doing -- they're rules the user has to follow. That's why its not a compile time error to violate strict aliasing rules, but is, instead, a runtime undefined behavior.
I believe your understanding is correct (effective type, etc.) as far as a strict interpretation of the standard goes, and so technically speaking you're not supposed to do this. However, I don't really know how a flexible array member affects it. In practice, you're probably fine as long as you don't actually make aliasing accesses and you're reasonable (for the target platform) about alignment. If you want to sanity check your program, test with address and undefined behavior sanitizers enabled to at least make sure the compiler isn't confused with what you're doing. 
No, he's not wrong. Look close.
&gt; §6.5:6 - The effective type of an object for an access to its stored value is the declared type of the object, if any.87) If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value. If a value is copied into an object having no declared type using memcpy or memmove, or is copied as an array of character type, then the effective typeof the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one. For all other accesses to an object having no declared type, the effective type of the object is simply the type of the lvalue used for the access Doesn't this imply that the compiler has to keep track of this "effective type" to implement aliasing analysis? 
The compiler doesn't do aliasing analysis. It presumes that pointers don't alias by default. If you say use no strict aliasing, then it just presumes that everything can alias so won't reorder memory instructions unless you tell it the pointers don't alias. The keyword in that snippet is "declared type". That means the type you're accessing the memory with. E.g. int *pi in my above example.
The post you just replied to is a completely wrong load of rubbish so please don't try and take any understanding away from it
Oh? Why not explain? I'd gladly admit I'm wrong if I am.
Every *access* in both examples modifies the stored value of `*p1` and/or `*p2`. There was a defect report that proposed striking the language "...that do not modify the stored value", but it was rejected. Note that according to footnote 88 of N1570, the purpose of 6.5p7 is to specify *when things are allowed to alias*, not to define what aliasing *is*. Aliasing occurs if a reference R is used to access an region of storage or generate another reference that will be used to do so, at a time when there exists another active reference, at least one operation involving the references is a write, and the former reference is not derived from the latter. Given something like: int foo(int *p, int *q) { *p = 1; *q = 2; return *p; } If `*p` and `*q` identify the same object, the accesses between them will alias, but aliasing in that scenario is expressly allowed because the objects are of the same type. I'm not sure where the misconception that the "strict aliasing rule" defines what aliasing *is*, rather than when it is *permitted*, came from, but it lies at the root of nearly all contention on that issue. 
&gt;Basically, I think the question can be simplified to this: If I malloc a memory region of say, size 10, cast the pointer to `struct {int a;} *`(assume 4 bytes int), set it a to something, what happens to the rest of the 6 bytes? Nothing, those 6 bytes still have no effective type. &gt;Does the presence of flexible array member affect this in any way? The standard doesn't cover this, however in your example it's moot as it would be undefined behaviour for the client to read uninitialized memory anyway. They will write to the memory which sets its effective type. &gt;But since I'm casting the malloc'd pointer to `ArenaNode *` and setting its data members (next and dataSize) after allocating it (in ArenaNodeNew), the effective type becomes ArenaNode. Or does it? I didn't set data field of that. The standard is actually not clear on this question (i.e. whether writing one member of a struct (a) requires memory for the whole struct to exist, and (b) sets the effective type for the whole struct), however common compilers assume that it DOES. &gt;Does this violate strict aliasing rule because I'm converting a pointer to u8 to something else and using that? Pointer casts don't violate the rule; writing as one type and then reading as the wrong type would . I don't see you do that anywhere in your code, and the user of the arena would write to the memory they are given, they wouldn't try reading it before writing it. 
There seems to be a bunch of stuff wrong, and you aren’t getting the whole pointer thing. A pointer is the “name” of someplace to find and/or put data. (A pointer to a pointer would be the name of someplace you could find or put zero or more pointers, etc. etc.) The way you’ve got things you’re just leaking memory all over the place with no effect, then violating bounds almost immediately. First off, sizes, array indices, and counts relating to memory should use type `size_t` from `&lt;stddef.h&gt;`. `int` is very, very unsafe to use for these; without specific ABI information, you know that `int` has a range of at least −32767 to 32767, and that’s it. You know nothing about its relationship (or lack thereof) to `size_t`, and very little about its in-memory format. Overflowing an `int` is also undefined behavior, so a 32-bit `int` would overflow (→UB) at 2^(31) input elements, and `int` involved in size calculation would overflow at 2^(30) input elements. Second, it’s not actually safe to use `int` for your purposes anyway. You’re printing it with `%x`, which expects an `unsigned` argument. You’re intending to byte-reverse it, but shifting the top byte down or the bottom byte up will be very difficult to do safely (i.e., without UB) if you’re working inside `int`. So after includes, typedef unsigned IOElem; This lets you easily change it to (e.g.) `uint32_t` later, which would at least have a specific size and alignment. (Also, you don’t need `&lt;math.h&gt;`. You’re not touching floating-point, nor should you. You probably don’t need `&lt;errno.h&gt;` either, but you will want) #include &lt;stddef.h&gt; #include &lt;limits.h&gt; #include &lt;assert.h&gt; Moving on… Your declaration of `readAndAllocate` is all I need to see to know what’s happening. It has no way of handing an `int *` back to the caller. It takes an `int *`, meaning “someplace I can find zero or more `int`s,” but (a.) the caller doesn’t/shouldn’t/can’t know where the buffer should end up, and (b.) you can’t set the caller’s `int *` without taking an `int **`. Stepping back a bit: A buffer is an `IOElem *` with a count, and those two things need to stay together. typedef struct { IOElem *data; size_t count; } IOBuffer; Some things to manage buffer state more formally: #define IOBuffer_INIT {NULL, 0} static void IOBuffer_deinit(IOBuffer *buf) { assert(buf); if(buf-&gt;data) { free(buf-&gt;data); buf-&gt;data = NULL; } buf-&gt;count =0; } Reads can succeed or fail; failure modes include I/O error, input being too large to represent, insufficient memory or some internal error. I’m going to do a quick-and-dirty `enum` for this, but IRL you’d probably want a macro or include table so you can manage error names and messages in one place. typedef enum { RR_OK = 0, RR_IO, RR_2BIG, RR_NOMEM, RR_INTERNAL } ReadResult; And now we can declare `readAndAllocate`: static ReadResult readAndAllocate(FILE *, IOBuffer *); It reads from a `FILE *`, it sets the caller’s `IOBuffer` once it’s done, and it returns a status code telling you how things went. `static` because nothing outside this .c file needs to see it. Inside `main`, you’ll want to call it like this: // Pack all variable decls/defs up at the top of their {block} unless you’re sure C99 is allowed. IOBuffer buffer = IOBuffer_INIT; ReadResult rr; … if((rr = readAndAllocate(input, &amp;buffer)) != RR_OK) { [kvetch by `switch`ing or array-mapping rr] fclose(input); return 1; } and then `buffer.data` and `buffer.count` give you array location and length, respectively. Before `return`ing or `exit`ing: IOBuffer_deinit(&amp;buffer); Nothing outside of an `IOBuffer_`- function or `readAndAllocate` should allocate or free anything. (And you wouldn’t use `calloc` if you did want to.) Moving to the implementation of `readAndAllocate`… Before launching into the loop, come up with a large-ish buffer and expand that occasionally as you go, rather than reallocating for every single integer. This lets you read much bigger chunks of input at once. You’ll need a couple of constants for that, one that sets the initial buffer limit and one that sets the amount you should expand the buffer by (=a reasonable guess about how many *more* `int`s you’re likely to need if the prior buffer size was too small). #ifndef BUFFER_LIM_INIT # define BUFFER_LIM_INIT 16384 #endif // Should probably error-check as &gt;=0 and &lt;=SIZE_MAX #ifndef BUFFER_LIM_INCR # define BUFFER_LIM_INCR 16384 #endif // Error-check; &gt;0 and &lt;SIZE_MAX (Note that in real life, expanding a buffer by ~1.5–3× is the Proper Thing To Do in most circumstances, but that takes more thought and care and this specific use case probably wouldn’t see any real improvement from that.) Back down into it: static int readAndAllocate(FILE *const input, IOBuffer *const bufOut) { // Maintain the buffer size and fill counts separately. size_t n, bufSize, bufFill = 0; IOElem *buf = NULL; ReadResult ret = RR_OK; // Validate arguments—pick one: // No export (i.e., this fn stays `static`) {{{ assert(input); assert(bufOut); assert(!bufOut-&gt;data); // }}} or export (i.e., non-`static`) {{{ if(!(bufOut &amp;&amp; input)) { static IOBuffer dummy; if(!bufOut) bufOut = &amp;dummy; ret = RR_INTERNAL; goto finish; } if(bufOut-&gt;data) free(bufOut-&gt;data); // }}} // Allocate initial buffer bufSize = BUFFER_LIM_INIT; assert(bufSize &lt; SIZE_MAX / sizeof(*buf)); if(!(buf = malloc(bufSize * sizeof(*buf)))) { ret = RR_NOMEM; goto finish; } The `while` loop will first assert that *fill* &lt; *size* (if not, *size* − *fill* is nonsense), then read from the input stream, then expand the buffer if it’s full: while(assert(bufFill &lt; bufSize), (n = fread(buf + bufFill, sizeof(*buf), bufSize - bufFill, input)) &gt;= 1) { if((bufFill += n) &gt;= bufSize) { void *newBuf; IOElem extra; // We could overflow `size_t` if there’s more input waiting: if(bufSize &gt; (SIZE_MAX / sizeof(*buf)) - BUFFER_LIM_INCR &amp;&amp; fread(&amp;extra, sizeof(int), 1, input) &gt;= 1) { // If you’re being properly polite, you should push back `extra`. // Exercise for the reader. ret = RR_2BIG; goto finish; } bufSize += BUFFER_LIM_INCR; if(!(newBuf = realloc(buf, bufSize * sizeof(*buf)))) { ret = RR_NOMEM; goto finish; } buf = newBuf; } } if(ferror(input)) { ret = RR_IO; goto finish; } Once everything is in, you can potentially downsize the buffer to fit exactly: if(bufFill &lt; bufSize) { buf = realloc(buf, bufFill * sizeof(int)); // Expect to succeed, since we're strictly shrinking it. // Theoretically it could fail, but you’re not likely to ever see a `realloc` // implementation that will. assert(buf); } Before returning, handle error cases. Since there’s a single `ret`, we can funnel everything out through a single exit. finish: bufOut-&gt;data = buf; bufOut-&gt;count = bufFill; return ret; } // end of function Note that you can return an error *and* hand off valid data; e.g., with `RR_2BIG` or `RR_NOMEM`, the caller might want to process just what it has, then free the buffer, then try again. Stream handling can be tricky like this, and it can be hard to leave a stream in the right state if there’s an error. In general, consume the data xor leave it in the stream. Also note that it’s probably better design to leave opening and closing files to the caller. Hoist things that require error messages and whatnot as high up towards `main` as you can without breaking DRY too badly, since this helps keep I/O and exiting from turning into a mess. That should get you past your problem at least. One little extra: // With `IOBuffer` stuff: #ifndef IOBUFFER_DEBUG #define IOBuffer_dump(iobufp) ((void)(iobufp)) #else static void IOBuffer_dump(const IOBuffer *const bufp) { register size_t i; fputs("Current array:", stdout); for(i=0; i &lt; bufp-&gt;count; i++) fprintf(stderr, " %08X", bufp-&gt;data[i]); fputc('\n', stderr); } #endif Now you have an automatic debug dump of an `IOBuffer`. If `IOBUFFER_DEBUG` is defined (preferably by `-D` flag), `IOBuffer_dump` will dump the buffer to stderr. If not, it’ll do nothing other than evaluate its argument. You may also want to add nearish the bottom: #undef EOT #define EOT #define STATIC_ASSERTIONS(F)\ F(sizeof(IOElem) * CHAR_BIT == 32, IOElem_is_32bit, "`IOElem` must be 32-bit")\ EOT #if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__+0) &gt;= 201112L # define GEN(cond, fld, msg) _Static_assert((cond), msg); STATIC_ASSERTIONS(GEN) #else # define GEN(cond, fld, msg) unsigned fld : (cond) ? 1 : -1; struct StaticAssertions { STATIC_ASSERTIONS(GEN) char dummy__; }; #endif #undef GEN `STATIC_ASSERTIONS` is a table macro that includes things to check at compile-time. C11 provides `_Static_assert` for this purpose, but pre-C11 you can use a negative bitfield size to piss off the compiler if an assertion fails. You can add other rows to the table like F(BUFFER_LIM_INIT &lt; SIZE_MAX / sizeof(IOElem), \ BUFFER_LIM_INIT_fits_size_t, \ "`BUFFER_LIM_INIT` is too large")\
&gt; The memory has no type, &gt; [...] &gt;memory returned by malloc is not inherently different to stack memory on any system you're working on. It's all just memory. Wrong, in Standard C. The "stack memory" inherently has the type that it was declared with. The dynamically allocated memory has the type that it was last written as. Your second and third `foo` (it would be less confusing to give each one a different name) don't even compile, `*pi[i]` is not valid if `pi` is not a pointer-to-pointer, which it isn't. 
Is it not a interpreter as oppose to a compiler?
Oh yeah,my bad. Editing time
Hey thank you so much for your help! I am now successfully returning the appropriate pointer and am now setting about using the same technique to implement the endian conversion! Not capturing the return from realloc was definitely because I misunderstood what it did, thank you for helping me clear this up!
&gt; you can use a char pointer to access whatever you want. IIRC you can use a `char *` to access whatever you want as long as it’s been allocated via runtime/OS (e.g., `malloc`, `alloc_aligned`, or POSIX `mmap`) and your pointer stays entirely in-bounds (or bottom−1 or top+1) w.r.t. the underlying allocation. You have to fall back to something along the lines of `uintptr_t` if not.
Thank you. This is more clearer. 
*pi[i] is obviously a typo. You seem to have no actual understanding of what memory actually is. Memory is just a bunch of numbers. The types are how those numbers are given meaning. There’s no system that I’m aware of where that isn’t true. In fact, it has to be true because otherwise couldn’t reference random memory with a char*. Alias analysis is a thing, but it’s not something compilers generally do. Static analyzers like coverity may catch it. I don’t know what your point is given that you immediately agree with me and say it would be impossible to perform perfect alias analysis. The declared type is just what that block of memory is being interpreted as. You can reference it via char. If you reference it via any other pointer type than a char pointer, you would be aliasing. However that doesn’t matter if the only pointer to that block or memory that is either reading or writing to that block is your “aliased” pointer. Essentially, I could declare an int on the stack, take its address cast to a float pointer and do whatever the fuck I wanted safely so long as I never use that memory any other way within the same memory alias scope. You can generally flush the alias scope with a memory barrier that forces a sync point.
This is correct. However, if you go from one type to char to another type, within the same alias scope, you would be violating strict aliasing. I’m not sure why you’d do that, but yeah. 
Is this language Turing-complete? If so, it is crazy that a complete programming language can be defined in about 50 lines! The example code given is pretty simple, but shouldn’t code get extremely complex with more complicated programs? Also, how does this language handle branching? Or is everything completely deterministic in this language?
I made one. [It's called "Lob".](https://git.orangehattech.com/dirkson/lob) It exposes two functions, so the API is as simple as I could reasonably make it. It gets slightly more complicated if you want your own logging levels, but not too bad. I have no idea what SEI CERT is, though, and I use Meson rather than Cmake, because I don't hate myself. Also what does "Not expectable" mean in this context?
Hi there, I want to thank you for taking the time to explain all of this. I have to admit though that you lost me pretty early on... this is my first go at C, I'm taking an introductory class right now. But I have tutoring on Saturday and I will be bringing your comment with me so the instructor and I can go over it together!
Brainfuck is Turing-complete, but writing anything other than very simple programs is extremely difficult (by design). It has basic conditional support via the `[` and `]` operators.
/u/32BitLongSucks 
Can you check that path to make sure that C:\\MinGW/bin/mingw32-gcc.exe actually exists. Also the mix of path seperators \\ and /, try using just one.
Thank you
the part after the dash (-) is the instructions btw
Pick [raylib](https://www.raylib.com) and code a small game, you have multiple templates to start with.
Wrong sub, but most importantly https://idownvotedbecau.se/unreadablecode/
wtf is this
&gt; I’ve changed it to reflect the typo. It still says `*pi[i]` and `*pf[i]` in the second `foo()` 
Hahaha holy shit. Is this a question?
Fixed 
Yeah and the “question”/instructions are at the bullet point at the end
That bullet point isn’t a question. It seems to be a set of instructions.
It is a set of instructions lol thats what I was trying to say 😂
/r/cpp_questions Also, the compiler that comes with codeblocks is crap, it would be better to install mingw-w64
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
What exactly do you think a “declared type” is? Physically, in memory? It’s a block of bytes. That’s why it can be accessed via a char*. If I access the same block of memory with a float, it’s still just a block of bytes. Aliasing becomes an issue on optimization when instructions can be reordered. What do think happens when you call printf with %x? That’s simply reading the memory and spitting out the raw contents. Major compilers don’t test aliasing in the way you’re describing, they simply have a setting on how to assume the user is treating pointers. Alias analysis is not the same as disable strict aliasing, so I’m not sure what you’re on about there. My understanding of the C language isn’t an issue, I’d say you have an issue understanding what the language standard actually says and how it actually works in hardware.
I gotta say, I absolutely love the readme. Sorry to know you cry in the shower bud
Good luck then. I've never seen an open source project which bothers with this crap. 
&gt; just like every other programmer or there What do you mean? 
Does looping work as expected? Seems like upon `[` it just continues to the next character, diaregarding the value of `*ptr`
&gt;What exactly do you think a “declared type” is? Physically, in memory? The C Standard says what a declared type is. It's part of the type system. Specifically when a variable is declared to have a type. You were falsely claiming that memory allocated by malloc can have declared type, which it cannot. &gt;If I access the same block of memory with a float, it’s still just a block of bytes. It's undefined behaviour. You seem to be in denial about this fact while accusing me of not understanding the language standard, lol. &gt;What do think happens when you call printf with %x? If the argument has type `unsigned int` then its value is printed in hex, otherwise undefined behaviour. In the latest version of your second `foo()` you say "aliasing is broken" but in fact it is not. In C it is permitted to *write* to the same dynamically allocated location as different types. What's not allowed is writing as `float` and then reading as `int`, for example. &gt;Major compilers don’t test aliasing in the way you’re describing, Yes they do. They perform alias analysis in order to optimize the code. LLVM can even output the metadata associated with its alias analysis. &gt;Alias analysis is not the same as disable strict aliasing, so I’m not sure what you’re on about there. `-fno-strict-aliasing` means to disable alias analysis (and not give warnings about aliasing violations).
Wtf is an ‘AI based Os’
Other decent options for 2D include SDL
"program" in UK spelling, although typically not used in computing context. Come on, man.... get with the programme...
Given the function: void foo(int *p) { *p = 1; } void test1(void) { void *t = malloc(sizeof (int)); foo(t); free(t); return; } void test2(void) { struct s1 { int x; } s1; foo(&amp;s1.x); } void test3(void) { union u1 { int i; float f; } u1; foo(&amp;u1.i); } What do *you* think the "declared" type of `*p` within `foo` is when it is invoked from test1? How about test2? Or test3? I don't think the authors of the C Standard, collectively, have any consistent idea of what section 6.5p6 of the C11 draft N1570 (commonly called the "Effective Type Rule") is supposed to mean, since it uses the term "object" in a manner which is inconsistent with how the term is used everywhere else, and suggests that the question of whether `*p` within `foo` has a "declared type" is somehow dependent upon whether it identifies a region in allocated storage. In the absence of the "Effective Type Rule" and "Strict Aliasing Rule", one could say that every sequence of bytes that could hold a value of type T is an object of type T; the fact that memory is occupied by countless objects that could have values stored there, but which will never be accessed, would pose no problem. While the presence of all those objects would seem to make the 6.5p7 "strict aliasing rule" nonsensical, it could be remedied by limiting application of the rule to the purpose specified in Footnote 88--saying when objects are allowed to alias--that is, when *seemingly-unrelated* objects would be to allowed to be accessed in conflicting fashion. I don't really see any way to reconcile the 6.5p6 with anything else in the Standard except to apply a weird loosey-goosey notion of "object" which doesn't fit with how the word is used anywhere else, and serves no purpose except to cause countless man-years of confusion and discord. 
Not intended as an outright correction, and it would be obvious to somebody who’s read the standard through high-magnification lenses, yes. —Though even system library writers took their sweet time moving over from slightly-incorrect `char *`- and `void *`-based allocators to `uintptr_t`-based ones, and there’s still a lot of misinformation about what pointers are and can do out there.
What would you expect it to do when it encounters [?
I don't think the authors of the Standard had a consensus understanding of what they were using terms like "object" to mean or, to be more specific, what "objects" exist at various times in various scenarios. As the term "object" is used in all parts of C11 draft N1570 except 6.5p6 (the "Effective Type Rule") every object has a single unambiguous type which is fixed throughout its lifetime. Given a declaration: struct S { int x; float y;} s; the lvalues `s`, `s.x`, and `s.y` identify objects of type `struct S`, `int`, and `float`, respectively. Writing to `s` will not affect the lifetime of `s.x`, nor vice versa, despite the fact that a write to one will affect the stored value of the other. Attempting to apply that notion of "object" to 6.5p6 would make no sense, but the meaning of 6.5p6 will be highly dependent upon how one bodges the definition of "object" to try to make it somewhat meaningful. If one pretends that an allocation returned from `malloc()` is a single object, then 6.5p6 will mean one thing. If one regards every disjointly-used sequence of bytes as an object, it will mean something else. If one expects that compiler writers will attempt to process the language described in K&amp;R2 in cases where the Standard would allow it and their customers would find it useful, even if the Standard doesn't mandate such behavior, the question of what such usages of the term "object" mean should pale in significance compared to the question of what implementations' customers need.
I think you forgot to actually post a link 
[I have put together some educational material on the topic](https://imgur.com/a/zOgHUrX)
Pretend your Elon Musk cross meth addict and jam as many hours in a single week into c programming projects. Caffeine up and sleep when your dead
It’s possible that file could not be opened - i think, it’s good idea to check if `file` is non-NULL after opening. Also, i’d suggest using float as latitude and longitude as `double` type is usually 8 bytes (I’m talking about PCs)
Well, not easy to answer, because you haven't written where the segmentation fault occurred. But you didn't check the return value of fopen() which might return NULL if the file was not found. BTW, you should use a memory checker like valgrind to show exactly where the segmentation fault occurred.
Or even just a regular debugger. New programmers should learn to treat debuggers as important as compilers.
You are such a badass. I wish I could be a tenth of you.
If you're a beginner in C you should take into account the fact that you will likely screw up. It can be helpful to have the program you were thinking about written in a higher level language and then written in C.
Never skip sleep
It's a do while loop, [ simply steps forward ] Tests the current pointer, if true, it winds back to [
Oh right, this is not Brainfuck
In addition to the other comments, I would never assume the size in bytes of types. Instead, you can use sizeof(variable) to get the actual size for the platform the code is running on. If you guess the size wrong, you might either not get the whole value, or write outside the memory reserved. 
LMAO. The VC++ and Windows team at Microsoft should see this
haha nice github intro tho
I believe that when defined in global contexts (like `char name [6]`), the variable is a pointer, and not the array as a whole, meaning when you `fread` into the array, your loading the data into a pointer, and you are potentially over writing other data depending on how long the string is. The segfault then occurs when you are null terminating the string (`name[5] = ‘\0’`) you are attempting to dereference a pointer read from a file, while is almost definitely invalid. Try using `&amp;name[0]` in the `fread` line.
This. Skipping sleep will make you worse at everything you do. It's not worth it. Email your professor for help, stay after class to ask a quick few questions, or try looking up help if you're stuck. Good homework is supposed to leave you a little stumped at some point, but learning "to code by yourself" is nothing more than dedicating yourself to long term practice. Not sleeping will just slow that process down.
I prefer the classics like : C: https://en.m.wikipedia.org/wiki/The_C_Programming_Language C++: https://en.m.wikipedia.org/wiki/The_C%2B%2B_Programming_Language Even if it’s a little bit dated, those books expose the good practices and the philosophy behind the languages. As always this is just my opinion dint be too hard on me! 
As others have said, never skip sleep. Skip the videos though. Focus on written material. My favorites are: 1. Programming C: A Modern Approach 1. Modern C 1. Head First C And for a tutorial on pointers and arrays, Google Ted Jensen's tutorial. Write a lot of code. **A lot.** There are no shortcuts. Get a decent editor with syntax highlighting and code completion learn it inside and out. Learn a decent debugger and use the debug macros like __FILE__, __LINE__, and __func__ 
There are better books out there
For a reference I find https://en.cppreference.com/w/c to be invaluable. It even will let you know what standards support a functionality you're looking at.
The C Primer Plus is a good start. I'm working through it myself at the moment. Keep us posted with your progress
This is by far the best [Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/~tjensen/ptr/).
So, there’s a misunderstanding on the alias analysis. I thought you were implying that the compiler is going to go through and do the impossible determination of whether the user has aliased in each and every place, which it certainly doesn’t do. As you said yourself, that’s impossible. You’re not exactly correct on my example not being s problem. The issue with aliasing is that the behavior isn’t expected. In my example, the int or the float could be written last to that piece of memory. So when you do read it, whether in the debugger or printing it out, it won’t be what you expected in the order that it was written. And no, printf %x is not undefined if the type you pass isn’t an unsigned int. That’s absolutely asinine. It’s going to treat the memory you pass it as an unsigned int and write out the value. So If it’s a float, you’re going to see what the actual binary representation of that float is. I don’t know any implementation or system where this isn’t true. I’d welcome to be corrected, but I don’t need more intellectual masturbation about what the standard says, I mean something actually substantial. 
Dont listen. C primer plus is an amazing book. Good luck!
I think the issue is that the standard is trying to set some guidelines safely. So they can say “we guarantee this”, but the guarantee is just on paper. Once implemented in real hardware, there’s no “type” stored with memory. It’s just data, that’s it. Arguing what the standard is fucking pointless. There’s plenty of shit that goes in and then comes out or that never gets implemented by anyone. Who the hell cares “what the standard says” if no one actually does it?
OK .thank you 
oops I did now
Do you have a recommendation of a really good book I can use to learn C. My school has a lot of Classes that need you to understand C.
Look at my numbered list above
The fact that it works or that Unix re-uses file descriptor IDs?
I dont see that fitting in your pocket
I am half-way through C Primer Plus. It's a good book with lot of examples and exercices. Now that you own the book, my suggestion is to put it on a shelf and download the pdf instead. Having the pdf and studio code side by side on the screen is way more enjoyable.
Sounds like Annex K
...... Stroustrup's book is not a book to learn C++ from. It used to be used to define the standard. It's terse and complete and highly non didactic. That would be like learning english by reading the dictionary page by page. I'm guessing you meant to link his other book? [http://www.stroustrup.com/programming.html](The one he wrote to teach C++ since the other book was no good for that purpose.)
The problem is that the maintainers of a couple of popular compilers routinely use the Standard as an excuse to claim that they have no obligation to efficiently support various common constructs, because any code relying upon them is "broken". I had misunderstood your question as implying that you thought the question of whether an object had a "declared type" was meaningful. 
I haven't read either of those, but I did enjoy and find a lot of value in [K&amp;R](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628) and [21st Century C](http://shop.oreilly.com/product/0636920033677.do).
I meant that the memory itself doesn’t have a “type”. The standard dictates how the code itself behaves. The implementation is ultimately what matters. The standard doesn’t mean a fucking thing if no one uses it.
Did you just assume his pocket!
I learn C++ with this book but it wasn’t my first language. Maybe yours is more appropriate for someone who never learnt any other language. Again this was only what worked for me it’s subjective :).
This is what the debugger gave me \_\_GI\_\_IO\_fread (buf=0x601078 &lt;latitude&gt;, size=4, count=1, fp=0x0) at iofread.c:37 37 \_IO\_acquire\_lock (fp);
Looked quickly, but GI__IO_fread (buf=0x601078 &lt;latitude&gt;, size=4, count=1, fp=0x0) at iofread.c:37 Makes it seem like your `fopen()` call failed. Are you sure tracks.dat exists in the working directory of your program? You should always check the return of `fopen()` to check for errors.
Use 4 spaces at the start of each line of code to format for readability. 
sorry i dont understand, I am new to reddit
You are recursing infinitely, which of course your machine eventually cannot handle. That, in turn, is probably leading to some other error like a segmentation fault, yes? Think about your logic step by step in the 'product' function. You first make sure that the 'a' argument is greater than the 'b' argument. That'll work fine and put your negative in the 'b' argument's place. Then, on the next call, you will recursively call the same function again, except reducing 'b' by one. What happens if this is a negative number? Where does it stop? 
Sorry i am confused, could you show me what you mean
Stephen prada is shit 
 product(-3,3); //recursion level 0 --first call &gt;a = -3, b=3 &gt;a &lt; b is 'true', so the function executes "return(b,a)" &gt;&gt;product(3,-3); //recursion level 1 -- second call &gt;&gt;a = 3, b = -3 &gt;&gt; b != 0, so function executes "return(a, b-1)" &gt;&gt;&gt;product(3, -4); //recursion level 2 -- third call &gt;&gt;&gt;a = 3, b = -4 &gt;&gt;&gt; b != 0, so function executes "return(a, b-1)" &gt;&gt;&gt;&gt;product(3, -5); //recursion level 3 -- fourth call &gt;&gt;&gt;&gt; at this point we will keep repeating this process over and over because th line b != 0 will always be true and we will always recursively call the function with a more-negative value for the b argument. None of these recursive functions ever finish because when they call "return(product(a, b-1))", they basically don't actually return until they have the result from the function they're calling recursively, which means your computer's memory continually grows a bunch of in-progress functions until it can't handle any more.
https://www.reddit.com/r/raerth/comments/cw70q/reddit_comment_formatting/ Look at #6 block code
Holy globals and unchecked input, Batman
en.m.wikipedia.org/wiki/Indentation_style Pick one and use it. Your code us very hard to read. 
Desktop link: https://en.wikipedia.org/wiki/Indentation_style *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^238904
You probably don’t. You have to know a filename for an inode before you can unlink it, and it’s unlikely that the OS is going to have a filename for every TCP-related socket. What you can do is enumerate ~all active TCP sockets (not necessarily *actually* all because there’s no way to enumerate from outside the kernel without race conditions) and kill the process(es) holding those sockets, damn the torpedoes etc. Might not immediately free up the port(s) in question, though.
Did you just assume ze gender!?!
So it segfaulted inside the `fread` function. Debugging the `fread` function itself wouldn't be useful: it would be simpler to assume that it works correctly... _so long as you pass it the right arguments_, of course. So the question is really just "what arguments did you pass it?" And look at that! You've already answered that question.
The primer book is very good (also is the HFC) but neither is perfect, for the parts you find them less than your expectation, make sure you'll have this pdf open all the time: https://www.gnu.org/s/libc/manual/pdf/libc.pdf This one is also good for faster(online) searching(not as good as the pdf in the link above to the libc.pdf). Also "Learn C the hard way" has a really interesting method (was really new to me) for teaching any language and he's an awesome person. In brief, if I were obliged to name only ONE document, I think the best(most precise, most explanatory) document for learning about C, is the one on the GNU website, to which I put a link above, so that's I would recommend(if you know how to use such a document). Here's the link to it once again: https://www.gnu.org/s/libc/manual/pdf/libc.pdf
&gt;In my example, the int or the float could be written last to that piece of memory. In the `foo` examples you posted earlier there's no observable behaviour so actually the entire bodies could be optimized out. However if you add output statements (say, in the second foo, `pi[i] = 1; printf("%d\n", pi[i]); pf[i] = 2; printf("%f\n", pf[i]);`) then the output must be `1 2`. The standard guarantees this, up to floating point precision, and I bet you every compiler will comply. If you want to argue about this further then please include the exact code you want to refer to. &gt;And no, printf %x is not undefined if the type you pass isn’t an unsigned int Yes it is, the standard explicitly says this. BTW try `printf("%x\n", 3.14);` on a 64-bit system and see what happens. &gt; I don’t need more intellectual masturbation about what the standard says, I mean something actually substantial. There's no greater authority on C than the C Standard. It seems like you're just trying to avoid the realization that behaviour of systems you're used to is not the whole story of C. 
In your printf case, it’s going to write out the first 4 bytes of that float then the following 4 bytes on any system I’m aware of, presuming the %x is treated as a 64-but value. It may also crash if the memory is protected outside the size of the float. You’re being purposefully pedantic, my examples were limited to the specific usage that could lead to unexpected behavior. That is, after the writes, the data in the variables may not be what you’d expect based on the way the code was written. That’s the reordering from the aliasing. And no, the C standard is an authority on what people agree to do. It isn’t an implementation. The compilers that you use and how they handle the standard are the authority. If all it takes is a committee coming up with a standard to be done with things, then we wouldn’t have lists of shit the compiler vendors just say no to. If a major compiler vendor doesn’t support it, it basically doesn’t exist regardless of what the standard says. At this point, I haven’t actually said anything that’s incorrect. It seems you simply want to be pedantic for no actual reason. 
&gt;In your printf case, it’s going to write out the first 4 bytes of wherever that float is located then the following 4 bytes on any system I’m aware of, Have you actually tried it? [Spoiler alert](https://ideone.com/X8pPKH) &gt;presuming the %x is treated as a 64-but value. This is fairly uncommon, most consumer level 64-bit compilers have 32-bit `unsigned int`. Also `3.14` is a `double` which is usually 64 bits. &gt;That is, after the writes, the data in the variables may not be what you’d expect based on the way the code was written. That’s the reordering from the aliasing. Whether reordering of writes to the same memory location is permitted depends on the exact code. I gave an example of where it wasn't; in your example it was but the whole function could be optimized out too so your example doesn't actually demonstrate what you were claiming. &gt;At this point, I haven’t actually said anything that’s incorrect. You've made multiple claims that contradict the standard. It seems your position is "lol standard schmandard, my experience is the real authority on C" , so I doubt we will make any further progress here. 
Yeah, I presumed 64-bit unsigned int and 32-bit float. I thought you were suggesting an overflow read, but I see you were suggesting that it reads only the first portion. If it writes out 32-bits of a 64-bit floating point, then 0 is what gets written out. The leading zeros of your double. I’m not even entirely sure what we’re disagreeing on at this point. My examples were limited to “don’t do this specific thing” because the code you insert after could be unexpected. If you use the snippet itself directly, it could potentially be optimized out since it basically does nothing. What specific claim did I say contradicts the standard? The standard itself is vague in a lot of specific bits. All I’ve claimed is that the memory itself has no type. And it doesn’t. The machine doesn’t know what the type is, the memory doesn’t know. It’s just bytes of data.
`UINT64_C(3)` expands to `3UL` or `3ULL` as appropriate 
&gt; f it writes out 32-bits of a 64-bit floating point, then 0 is what gets written out. The leading zeros of your double. [Here's another version](https://ideone.com/CA28BV) that avoids any such objection (although there are not 32 leading zero bits in the representation of 3.14f converted to double) 
Hold up, let me look at the disassembly for that, I was just working off of the top of my head. I wouldn’t normally pass in just a raw number, but I might print out the actual hex in memory value of a double by using %x. 
&gt; What specific claim did I say contradicts the standard? The standard itself is vague in a lot of specific bits. All I’ve claimed is that the memory itself has no type. I already responded to each of your standard-contradicting claims on this thread. Go back through the comment chain for any time I quote you and then give a rebuttal. "The memory itself has no type" is such a claim; the standard says that memory does have a type. 
That's nonsense and is completely untrue on x64, x86, PowerPC, SPARC, and Itanium. I've at least worked on those systems. The standard can say whatever it wants. The memory itself in the implementation has no type.
The Book of Decades of Experience. :-) &gt; There once was a master programmer who wrote unstructured programs. A novice programmer, seeking to imitate him, also began to write unstructured programs. When the novice asked the master to evaluate his progress, the master criticized him for writing unstructured programs, saying, 'What is appropriate for the master is not appropriate for the novice. You must understand the Tao before transcending structure.' -- [The Tao of Programming](http://canonical.org/~kragen/tao-of-programming.html)
https://idownvotedbecau.se/noattempt/ https://idownvotedbecau.se/wronglanguage https://idownvotedbecau.se/nocodeforreview/ https://idownvotedbecau.se/imageofcode 
I have the code that I have started 
Then post it, and details about where you are having problems in the appropriate forum. 
How do I post another picture? It only let me post 1
Do NOT post code as a picture. post it as preformatted text. See the other answer for why. 
you under estimate the size of my pockets!
This is a subreddit for the *C* programming language. For C++ questions please try /r/cpp or /r/cpp_questions. Also, please indent your code by four spaces.
You totally missed the opportunity to use https://idownvotedbecau.se/wronglanguage/
This is what cargo shorts were made for!
C++ is off topic for this board. Try /r/cplusplus.
No. In C you have to use a second variable to keep track of the length. Sometimes a struct is used to keep them together.
It's nothing complicated, just thought I would share. Would love to get some feedback!
often length has to be inferred by counting characters till you find a null '\\0' char splicing you have to do manually by allocating new space for the destination string, in fact thats the great thing about C you get to do \*everything\* yourself....! or you could use glib... [https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html](https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html) or some other (ideally) cross platform library 
If you are manipulating strings, you can use `strlen`.
free() and strdup() of variable brush could be both done in setBrush(), near each other.
won't adding free() in setBrush() give a runtime error? because brush wouldn't have been allocated memory the first time the program is run
No.
No blog spam please.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
It is legal to call `free` on a `NULL` pointer. So if `brush` is not initially allocated, you can simply initialise the variable to `NULL`.
Nice project. I always wanted something like that.
oh i see. thanks! 
What exactly does “using only `&lt;stdio.h&gt;`” mean?
Note that “global variable” is not a term used in the C standard. Your “something” is a *static* variable with *external linkage.* 
Interesting but might be more appropriate for /r/computerscience
Add a comment with the code as text. Make sure to indent each line of code with four blanks so it is formatted correctly.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
what have you tried so far ?
These skills are referred to by Google Engineering, for what it's worth, as _Systems Engineering_. In Google's SRE team there is a whole job function around this kind of stuff.
Wrong subreddit mate try /r/cpp instead.
This might work dunno how to use that pointer check this tho I'm noob int isSpaceFound=0; int i=1,len=0; char str[100]; printf("Enter your String \n "); scanf("%s",str); len=strlen(str); if(str[0]&gt;='a' &amp;&amp; str[0]&lt;='z') str[0]=str[0]-'a'+'A'; while(i&lt;len) { if(str[i]==' '){ isSpaceFound=1;} else if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z' &amp;&amp; isSpaceFound) { str[i]=str[i]-'a'+'A'; isSpaceFound=0; } i++; } printf("%s",str); 
This is c language, not c++
&gt;"expression must have integral or enum type" &gt; &gt;"expression must have a constant value" Evaluation of string types is not possible in C / C ++. You should std::string as type for name. Use std::endl instead of newline ('\\n'). Here is valid but not good solution: ... std::string name; std::cout &lt;&lt; "Welcome to the bank. Please enter your name."&lt;&lt;std::endl; std::cin &gt;&gt; name; if (!name.empty()) { std::cout &lt;&lt; "Welcome to the bank " &lt;&lt; name &lt;&lt; ". Your curent balance is: " &lt;&lt; balance &lt;&lt; "$"&lt;&lt;std::endl; ... }else { ... } ... See also "But when reading a string std::cin stops reading as soon as it encounters a space or new line." [https://stackoverflow.com/questions/2616968/how-to-read-and-write-a-stl-c-string](https://stackoverflow.com/questions/2616968/how-to-read-and-write-a-stl-c-string) [https://www.learncpp.com/](https://www.learncpp.com/)
- You haven't read the sidebar, otherwise you'd know that this subreddit isn't to answer beginner questions, there are other more relevant subreddits for that (see the sidebar). - You clearly are solving a school question. If you are tasked with an exercise trying to solve it yourself is the only way to learn, you wouldn't have an assignment if it weren't to help you grow by experience. - You haven't shown the slightest hint of personal research or involvment in solving that question: no code, no thinking, nothing. - You don't show the bare minimal respect by trying to use actual words, "PLZ HELPP" is no way to ask for help. Why should anyone try to help you?
Standard free() "of today" does nothing with NULL, but checking explicitly would cover old systems too.
Not as part of the standard library but other 3rd party libs are out there like glib mentioned elsewhere in this thread is you can roll your own. 
thank you so much! I didn't think the GNU project had such a great manual!
JS idioms don’t map well into C, and vice versa.
&gt; Note that “global variable” is not a term used in the C standard Sure it is, F.8.1 Global transformations. Even if they didn't, calling them "global variables" is the professionally accepted term. 'Static' is used far too broadly for it to be a helpful description to anyone learning.
Hello and thanks for the reply. I forgot to mention that the user has already defined the string name. Here is the code: string name; &amp;#x200B; // S - stands for start / starting. &amp;#x200B; class bankS { public: const float balanceS = 0; void atmS() { cout &lt;&lt; "Enter your name.\\n"; cin &gt;&gt; name; cout &lt;&lt; "You do not have a bank account. Creating one . . . \\n"; cout &lt;&lt; "Welcome to the bank, " &lt;&lt; name &lt;&lt; ". Your curent balance is: " &lt;&lt; balanceS &lt;&lt; "$.\\n"; } };
... or /r/cpp_questions 
Okay, point taken. However, note that this term is nowhere defined and never used in conjunction with static variables with external linkage.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead. Also do all of us a favour and **do not post screenshots of text.** Not even error messages. Instead, copy the error messages into your post as text.
&gt; You haven't read the sidebar, otherwise you'd know that this subreddit isn't to answer beginner questions, there are other more relevant subreddits for that (see the sidebar). The sidebar doesn't say that. Please don't lie to other users, especially not about our rules. Beginner questions are firmly on topic.
That's right, I went too far on that one. My apologies.
Thank you.
&gt; However, note that this term is nowhere defined and never used in conjunction with static variables with external linkage. This in no way reflects how *the programmer* should refer to elements in a program. You'll notice the term "local variable" is also not defined in the any C standard, yet it's used all the time. C is known to be a sparse language for a reason, such terms remain undefined intentionally to avoid meaningless complexity in the language. There would be no point. You actually wouldn't be able to clearly articulate anything to someone trying to learn (like OP) if you restrict yourself only to terms defined by a C standard. The term "global variable" is well known to any C programmer, and they can be defined on two seperate ways as I've shown above. Beyond that, the term is used within the documentation of every major compiler and standard library implementation.
Why release it with a function instead of just calling d3d-&gt;vtbl-&gt;release(d3d)?
 int Sum(int \*val, int numVal, int low, int high) { int sum=0; for(int i = 0; i &lt; numVal, i++) { if(val\[i\]&gt;= low &amp;&amp; val\[i\]&lt;=high) sum+=val\[i\]; } return sum; } &amp;#x200B; &amp;#x200B; in main() you call function with int a=Sum(numbers, 11, 0, 100) and then printf("Sum is: %d", a); &amp;#x200B;
I think the K&amp;R C programming language book was a really well written book. It was great to learn from for both new comers and for language specification. It's actually an enjoyable read front to back. Though I agree the Bjarne C++ programming language wasn't great for it. I refer to it for some specific topics sometimes, but it wasn't written well for learning. I remember it was difficult to read front to back because it seemed to constantly refer to other chapters for explanation of topics. And when you went to those chapters, they would in turn refer to more chapters for explanation. 
this is actually a more complicated topic than you might realize. these class of sorts (ones where the dataset exceeds memory of a single machine) are generally called external sorts, and might involve disk access, or can even be distributed across multiple machines. interestingly enough, a common external sort actually uses a quicksort-like algo. another thing is don't let hw considerations come first. the priority is always still the algorithm. the difference between a pathological cache and a good one is far smaller than selecting a bad algo and a good one. but algo choice can and should be informed by your actual conditions (including data size, hw limitations, etc).
That's pretty cool. Nice job!
Oh, no, no, no, no, no...... To get comfortable in C, you can't think like JavaScript -- you need to understand what's going on under the hood. You can't treat variables in C like objects in OOP -- they don't have methods you can call. There are a bunch of standard library functions you can use, but it'll be confusing as all hell until you understand how assignment and pointers work. You need to understand that working with variables in C is all about setting values in memory. Furthermore, you need to understand that C is a pass-by-values language, rather than a pass-by-reference language. If you need a function to manipulate memory directly with a function, you need to pass that function a pointer to that memory address. C doesn't have a built-in concept of a string. What you think of as a string is really a char*, that is -- it's a pointer to a memory address that contains the first character of the string. Functions like fprintf() or strlen() "know" where the end of the string is by iterating byte by byte to subsequent memory addresses until they find a byte that is all zeros. This entire set of bytes is called a "null terminated string". In a nutshell -- unlike other higher-level OOP languages, there are no shortcuts in C. In order to know what you're doing, you need to start from the ground up.
Going forward, please format your code with 4 spaces T the beginning of each line Like this. Code with indentation Is much easier to read And will result in more people helping you. 
Well what about the code using these functions? Also, you can write `char* n = malloc(size);` instead, since it's simplier.
 free(p); You are trying to free automatic/stack memory. You are returning a value from your 'newPerson' function, not a memory address. As such, the values inside the function are copied into a new location managed by your machine (as opposed to malloc'd memory that you manage on the heap).
That worked thanks.
yes thanks, like Neui said, i changed the returns to pointers and it worked
I really like it. One question though: Why did you not just use strlen in line 81? (just curious whether there's any special reason for that)
The name C refers to a number of dialects, which are suitable for different purposes. Before the Standard was written, it was recognized that implementations claiming to be suitable for certain purposes on various platforms should support features appropriate to those platforms and purposes, even though implementations targeting other platforms and purposes would not. When the Standard was written, the authors deliberately ignored such features, leaving the question of whether to support such "popular extensions" [as the Rationale called them] up to the marketplace, since compiler writers and programmers would be better placed than the Standards Committee to weigh the costs and benefits of supporting them on different kinds of implementation. Unfortunately, very few books are clear about whether they are talking about the language (family of dialects) the Standard was *written to describe*, versus the language which is actually specified by the Standard. Most of the tasks that could be accomplished using only the language defined by the Standard could be accomplished more practically using other languages, and thus books which that focus on tasks that can't be done in other languages will need to be based upon the languages the C Standard was written to describe. This requires that in many cases any code using principles from the books will need to disable the "optimization" features of compilers such as clang and gcc, since those features are generally only useful on programs which limit themselves to constructs which are mandated by the Standard. 
You can simplify even more by replacing: size_t size = strlen(name) + 1; char* n = malloc(sizeof(char[size])); memcpy(n, name, size); with: char *n = strdup(name);
Interesting approach to reduce memory fragmentation. Here’s what an implementation of his idea looks like: https://github.com/plasma-umass/mesh
Thanks for feedback, i am glad you like it. &gt; Why did you not just use strlen No specific reason actually. I have always used snprintf.
I wouldn't mind playing around with a text editor; it sounds like a fun side project. I can't devote full time to it of course, but I'd like to help.
Msys2 isn't trying to be posix in the slightest, maybe you're thinking of cygwin? Compiling with mingw-w64 gcc produces native windows binaries with no posix wrapper or anything.
You're confusing msys2 with mingw-w64. msys2 is literally a fork of cygwin who's own documentation states &gt; The msys2 subsystem provides an emulated mostly-POSIX-compliant environment for building software, package management, and shell scripting." environment to work on. mingw-w64 is a toolchain for compiling native PECOFF binaries. You usually use mingw-w64 on Windows from the msys2 environment.
Think about how you would tell if a letter is the first letter of a word. Also, a common idiom in C to iterate over a string is to loop until you reach the NULL terminator at the end of the string: int i = 0; while(str[i] != '\0') { // your code i++; } 
Posix environment, but the code is still 100% windows without a hint of posix. The trade-offs between them are negligible compared to using a compiler which doesn't even fully support C in a quite bloaty IDE _cough cough msvc cough_
They'd have to be very old systems indeed for that to matter, since [the 1989 ANSI C standard guarantees that `free(NULL)` is a no-op.](http://port70.net/~nsz/c/c89/c89-draft.html#4.10.3.2)
Exactly.. I was really surprised when I learn shuffling data set to avoid worst case of of quicksort and using insertion sort when array size less than an exact number.
&gt; Posix environment, but the code is still 100% windows without a hint of posix. I never said otherwise. I never even mentioned mingw. I'm not sure what point you're trying to make by bringing it up. 
Thank you all for your answers :) !
Fuck off, spammer.
Calling msys2 a compromise due to its posix nature seemed a bit off. A real compromise would be using msvc with its incomplete C implementation. I think at the moment msys2 + mingw is the best toolchain for C that you can get on windows, no compromises at all (unless you consider not using Linux a compromise).
that is not a spam, watch your language.
It is spam. You are too dumb to make this subtle. Literally every single one of your contributions to reddit plugs freelearning.club in one way or another. This is called spam, you idiot. Don't do that.
Wow. Seriously? Now that you got caught you decide to hide the fact that you are spamming by *drumroll* making the link say “HERE” instead of the name of your site? How pathetic.
I thought reading sequentially from RAM was much faster as well because of CPU caches? But maybe the difference is not big enough in this case to make merge faster?
You might enjoy reading about ["data oriented design"](https://en.wikipedia.org/wiki/Data-oriented_design), which is a technique for writing code in a way that takes most advantage of CPU caches. This can make a huge difference in performance, as [is shown in this benchmark](https://www.reddit.com/r/C_Programming/comments/anb55k/benchmarking_vectorized_vs_nonvectorized_code_see/) (the first 4 columns use data oriented design practices). In addition to storing data in arrays, you can also structure your data in a certain way that further minimize the chance of cache misses (arrays of structs vs. structs of arrays), and write code in a way that a compiler can generate SIMD instructions that can execute multiple calculations in a single instruction (aka vectorized code). In the gaming industry DoD is getting a foothold with the [ECS (Entity Component System) paradigm](https://github.com/SanderMertens/ecs-faq), which proposes a more structured way of writing code (like OOP) that in theory take advantage of DoD. Writing vectorized code can be hard in higher level programming languages, as things like bounds checking, operator overloading, garbage collection, RIIA can insert "hidden code" that causes code not to be vectorized- which is why C works well for high-performance code: everything is explicit. Modern C++, when used with care, can also take advantage of DoD, as many STL datatypes (like std::vector) and algorithms can be vectorized.
**Data-oriented design** In computing, data-oriented design is a program optimization approach motivated by efficient usage of the CPU cache, used in video game development. The approach is to focus on the data layout, separating and sorting fields according to when they are needed, and to think about transformations of data. Proponents include Mike Acton and Scott Meyers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Man, as I learn more about this stuff, I can really see why computer scientists made their order notation neglect constants. Once you get down to the hardware, there's just so much more things to take into account, it's crazy. Now I'm gonna have to research why for external sorts people are using a quicksort-like algo. &gt; another thing is don't let hw considerations come first. the priority is always still the algorithm. the difference between a pathological cache and a good one is far smaller than selecting a bad algo and a good one. but algo choice can and should be informed by your actual conditions (including data size, hw limitations, etc). Good insight. That is indeed about what I've gotten from my Data Structures and Algorithms class. Like, for almost all intents and purposes, the O(n log n) algorithm is always going to be better than the O(n^2 ). *Certainly* this is the case for large inputs, so if you know your input will tend to be large, there's really no question as to what you should pick: go with the nlogn one. However, as you said, it can still be very important to keep the very real constants in mind though between your algorithms -- to account for the hw conditions and the type of inputs you're gonna get as. As an extreme example, [consider this case](https://www.desmos.com/calculator/ishv0gjon9). Here, even though 100xlogx is in O(x^2) -- i.e., if inputs are large, you should pick the 100xlogx algo -- it is the case that for *small inputs* (less than 237 here), the x^2 algorithm is actually better! So the constants and hardware differences really can matter. And of course, if you're comparing two algorithms with average case theta nlogn or whatever (like mergesort v. quicksort in the post), then really the *only* way to pick a winner is to consider the constant factors -- consider the hw differences and sample space of your inputs (along with other things like whether the sort is stable, online, its space complexity, etc etc). There's just so much to think about. IIRC, this consideration of the constant factors is also why people can say that for small inputs, insertion sort is actually a good algorithm. Even though in the worst case insertion sort is theta n^2 , it has a low a relatively low constant, and so for small inputs can actually beat our more asymptotically efficient sorts like mergesort or quicksort. Pretty cool. But yeah, thank you for reiterating that probably the single most important fact in picking an algorithm is it's time complexity / order. I'm still definitely gonna keep in the back of my head that the order notation doesn't give us the full story, but it's reassuring to know that it does give us a pretty good story. At the least, for large inputs, we can be sure. Guess it's easy to forget that "premature optimization is the root of all evil" sometimes, lol. 
That's really cool! Seems like a very interesting job. The more I learn about computing, the more I'm realizing just how stupidly important a knowledge of hardware is (if you're trying to optimize your code). Never would have guessed when I started this stuff that *where* my data lives is so important to my program's efficiency.
That's very interesting! Indeed the book we have for my systems class (CSAPP: Computer Systems, A Programmer's Perspective) seems to have this idea as a takeaway too. Being careful about *where* your data is during computation is very important, as I'd guess I summarize it. Never want any cache misses ;). I'll definitely read more into the links.
&gt; I thought reading sequentially from RAM was much faster as well because of CPU caches? Prefetching specifically, which is usually associated with caches.
Knowledge of hardware is *most* of performance optimization work. It kills me that all our college hires at [big software company] learned only java/js and know nothing about how things run on actual hardware. Plus it makes my job of increasing perf more difficult. The number of times I’ve had to explain cache coherency or how virtual calls have a cost to them is too damn high.
You’re correct, it’s a huge issue in games/simulations/OS’s when people don’t do linear reads/writes to RAM.
Memory is not `NULL`; it’s mapped or unmapped, absent or present, accessible or inaccessible. Pointers can be null or nonnull; a null pointer isn’t pointing at anything (as far as the language standards are concerned) and a nonnull pointer is pointing at something. Like any other value, (non-`const`) pointers can be reassigned. int a; int *p = NULL; p = &amp;a; // Now `p` is nonnull p = NULL; // Now it’s null again 
Great, thank you! Just a small bit that I had never fully grasped.
One further thing to consider if you're not working with large data sets(ie. Those cases where the constants make a difference), is do you really care about the speed of execution? When optimizing a problem, your best bet is to profile your code, and attack the pieces that are happening most frequently, or taking up the most time(or likely both). So if you're in the space where dataset is small enough that the constants matter, it's probably not going to be the bottleneck of your overall system. Therefore, you have other priorities to optimize for...simplicity and maintainability of your code, and where you invest your time. Bubble sort is terrible time complexity, and it won't scale well for large data sets, but for cases where you have a known small data set it's dead simple to write and get correct the first time, and any programmer will automatically recognize it on sight. Additionally there's little advantage in investing your time improving the time complexity of your data sort, when the bottleneck of your system is the communication module. Personally, I'll take correct and easily verifiable over fast but more complicated every time. Then I can profile the system and if the correct(but slow) piece ends up being the bottleneck, I can write a ton of unit tests, make sure that piece is well encapsulated with a good interface, and then work on optimizing it. Now, remember that in 99.9% of cases you won't be writing your own sort routines, the library of your chosen language probably already has a very efficient general case algorithm for you to take advantage of. So, given the library already has it taken care of for you...which programmers will make most use of these algorithm analytics the most? The library implementers, embedded device programmers, and big data engineers! So if you are passionate about these sorts of topics, I encourage you to pursue jobs in those areas.
&gt;The number of times I’ve had to explain cache coherency or how virtual calls have a cost to them is too damn high. Yeah! I hate it when people don't understand this stuff. I mean, it's so simple that you could just explain it right now, for all us simpletons. Not me of course, I totally understand it all ready.... I joke of course, but seriously I would appreciate an explanation if you'd like to spare the time. I'll look up the topics and read about em too. All I really know right now (in terms of low level optimizations) is that you want to avoid cache misses, and that sequential memory access on disk is fast, but randomized access on disk is rather slow. I'm still learning a ton obviously but that's about what I've gleaned from that SO post, my textbook, and this thread. 
This sub applies primarily to C, although how return values work is mostly the same between the two languages as long as you’re not using features specific to one language or the other. Think of the return value as a special nameless variable where you can stash something (exactly one thing, exactly once) for the caller to grab. With return values: int function(int a, int b) { return a + b; } … // somewhere in another function: int x; x = function(99, 11); // Now x is 110. Without return values: static int function_return; void function(int a, int b) { function_return = a + b; } … int x; function(99, 11); x = function_return; —Not that this is precisly identical to what’s happening under the hood, but it’s near enough for thinking of while learning.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Note that the glibc is an implementation of a subset of the POSIX feature set. POSIX is not the glibc and the glibc is not POSIX. That said, the best way is to [grab the POSIX standard](http://pubs.opengroup.org/onlinepubs/9699919799/) and to start reading it.
I get it now, thanks alot! 
I don't know, but... &gt; +#include &lt;X11/keysym.h&gt; /* include keysym.h */ +#include &lt;X11/X.h&gt; /* include x.h */ Haven't you been listening to me? You don't need notes there. You're literally just repeating what the line itself says and it clutters things up. I know you think I don't know what I'm talking about when it comes to anything (and I'm not sure why you ask me stuff given that fact) but that's a bad coding practice.
I add those cause not everyone who patches knows C
Haha fair enough. The high topic of your OG post could kind of be “cache coherency is important”. When I’m saying cache coherency, I’m referring to organizing your data in ways that can be read linearly in memory. Small preferably in small POD types to maximize the number of elements that can be prefetched at once. You were on the right track with “linear reads fast, random reads slow”. The reason for that, is hardware is optimized for linear reads. At every level of memory (RAM L1 L2 etc), when your system reads an address, it reads all around that address as well (because the time to read X and X+Y bytes is the same on most hardware, and the assumption is if you touch a piece of memory, you will be touching near it too). In the disk scenario, it’s a little different. Spinny disc HDD drives have a mechanical arm that needs to move to get to the address you’re looking for. That seek time is about 10ms on most modern drives, which is an ETERNITY to a processor. Once the arm is in the correct spot, many modern HDDs can read quite fast. Thus, if you’re reading all over the disc, it’s going to be mostly the 10ms “pauses” introduced by the seek time. This isn’t present on SSDs or NVME drives, they behave more like ram. Which means linear reads are still faster, just less so than HDDs.
If they're patching C code, they should know C, first of all... Secondly, you're literally repeating the C code. That's a really bad coding practice. Comments should explain why something works, not describe what it does. [Do's and Don'ts of Code Comments](http://teeohhem.com/dos-and-dont-of-code-comments/)
Virtual call overhead is rarely caused by cache misses. It's usually the branch predictor not being able to predict the target of the call correctly, which results in having to flush your pipeline once you know you misspecculated. 
Shameless plug, we built a tool to test segfault in C code for people to self-diagnose the cause of segfault. A live test of your code is here: [https://segfault.stensal.com/a/Nuekm9kqPc5weZ27](https://segfault.stensal.com/a/Nuekm9kqPc5weZ27) It shows the cause of the segfault. 
There is always r/Cplusplus for your C++ questions. A tip though: it helps if you are able to phrase your question very clearly. Most programmers are not mind readers. So, what exactly do you not understand about return values? If you are confused about the values returned by functions, in essence it's quite simple. Also, C and C++ on their most basic level are similar enough that we can ignore/overlook the differences for this example. Consider: int square(int param) { int result; result = param * param; return result; } int main(int argc, char* argv[]) { int calculated; calculated = square(2); // calculated will be 4 at this point return 0; } Here we define a function named **square()** that takes a number named **param**, which is an integer, as an input - and that will return a result which is also an integer. It will apply some processing to the parameter to arrive at a new value, in this case the value of **param** multiplied by itself. It will then pass back (return) the result to the caller. From the point where we have defined this function we can call it in our program to calculate the square of an integer number. We pass it a number and we receive its squared value back. I could have save on a few lines of code here but I chose not to, to make it very clear what is happening. Notice that the function **main()** also returns a value to its caller, which is the operating system where this program will run. This way you can create status codes that will tell the system whether the program was successful or not. The default value of 0 (zero) means: there's nothing to report. In modern C dialects and in C++ you aren't required to explicitly return 0 from your **main()** but if you omit it, the compiler will make sure that it still happens.
See also http://norvig.com/21-days.html#answers
I didnt understand what the return statement did overall. And that cleared alot of things out for me. Thanks!
You asked this yesterday and got an answer. The result of the multiplication is being added to the array element, not assigned to it 
I asked this yesterday on a different subreddit. I understand that last bit, but I'm not sure how to implement it. I've tried a few ways that all haven't worked. 
What do you mean "haven't worked"? arr[3] += arr[4] * arr[8];
NULL is guaranteed to compare equal to zero, though technically according to the language standard NULL doesn't have to be represented as all zero bits. In practice, there aren't any common platforms or compilers where NULL isn't just zero. You can think of NULL as just a synonym for `(void *) 0`.
The point of the assignment is to essentially reverse engineer code based on the the assembly of an already compiled file. `arr[3] += arr[4] * arr[8]` results in mov -0x34(%rbp), %edx mov -0x30(%rbp), %ecx mov -0x20(%rbp), %eax imul %ecx, %eax add %edx, %eax mov %eax, -0x34(%rbp). First off, the top `mov -0x34(%rbp), %edx` shouldn't be there. Second, the bottom `mov` should be an `add`. 
Those pointers are just numbers. A pointer type is guaranteed to be able to point to a particular 8-bit byte in memory, regardless of the architecture - on a modern PC that's probably going to be a 64-bit number, on smaller platforms it'll be a 32-bit or even 16-bit number, and on more exotic architectures that don't have byte-addressable memory it might be a struct with a word address and a byte offset. That means that you're not making memory null, you're just setting a variable to a value (NULL) that indicates that it doesn't point to a valid memory location. Usually that value is 0, but not always. If a pointer exists and is writable (it's not const) you can set it to NULL or to any other value, valid address or not - though of course you don't want to try dereferencing it if it's not valid.
Why is learning C first bad? In my computer engineering major course track it's the first programming class we have. My teacher said C itself isn't really used as much as other languages like C++ and learning C first isn't the most useful thing, but he hasn't indicated it's a BAD thing at all
Yes, these topics can be fascinating for those who like them. That's why I studied "Computer Engineering" back then instead of "Software Engineering". To me it was the best of both worlds between electrical and software engineering. Today I'm a professional embedded software engineer and I love having to take hardware limitations into consideration on a daily basis and coming up with creative ways to abstract them (when possible) using clever software architecture and design. Having to balance together efficiency, performance, security, flexibility, ease of use, hardware bugs (not just Software can have bugs!). That's one of the reason why C still has a big place today, however C++ and more evolved languages can help a lot too. And yes, I still HAVE to use Assembly more often then I would have imagined. It's always a case of using the right tool for the job. Heck, I've been doing a lot of Java, C# and even Python to solve problems in the embedded world. It's a challenge of every instant, but I enjoy a good challenge. And whenever I manage to push the hardware beyond what it was designed to do because of crazy requirements, I still get an adrenaline rush 😋. I keep learning a lot every day, and that's the really cool part of it.
Do you the compiler and all the [switches](https://godbolt.org/z/7qcsS0) used?
Did I what now
*know
I really don't know what I'm looking at, but when I plug in my code I get the exact same thing my disassembled program is showing me. 
why would you think the last mov should be an add? the value somehow has get from the register back to the variable in memory. also why are you bothered by the first line ? 
My disassembled C program is supposed to match the assembly code of a file my professor gave me. The `mov` instruction should be an `add` according to the file, and if I were to do `arr[3] += ...` it would give me an extra `mov -0x34(%rbp), %edx`.
this sounds like you compare debug with release output possibly with optimisation flags not set to the correct level as jedwardsol already suggested. have you checked on that? 
From one newb to another (also learning c). Isn't netbeans available for Win? Consider a dual boot setup? Does you school have a server that you can ssh into - just code from the shell from a text editor. Good luck!
I have not, and I don't know what that means. What optimization flags? 
These macros expnd to that. If you `#define COBJMACROS` before including any COM headers, these macros will be defined.
I was told the windows version of Netbeans is different and requires a little work to get going with C
Well 1, check if everything on the win32 side of things is suited up for full screening and 2, try doing it without the COBJMACROS which is how I normally do it (works well enough for me) 
I installed it but never did anything with it, we are purely in a text editor on Linux. Going the dual boot way might be a great way to go, just back up before you touch your partitions.
just google it. where and how to pass these flags depends on how you compile your program. also since this is a basic feature of the compiler you should probably read up about it. but basically what is happening here is that the compiler takes every shortcut it can take, like optimizing out variables if possible (in optimization mode). in non optimized mode, code is generated almost line by line as it is found in the source. this might be a good start: https://stackoverflow.com/questions/1778538/how-many-gcc-optimization-levels-are-there also you might wanna try to create a program that has a variable optimized out and then try to view it in the debugger so you can see it first hand. 
So... it's an oddly length process. For something like Java, you can just install Java, get an IDE, and GO. I'm going to put two things. MinGW and Cygwin are compilers for your computer, and are accessed via IDE or command line. 1. You can install the gcc compiler on your computer via free software like Cygwin or MinGW. I use MinGW with an IDE, but this just allows you to run the command line on your computer. i.e. If you write a C program in a notepad program, save it as file.c (or whatever name) on your Desktop, navigate to your desktop and then you can run the same gcc commands you would run on the Linux computer whilst in that directory after installing one of these compilers. [https://www.quora.com/How-do-I-install-or-upgrade-the-GCC-compiler-on-Windows](https://www.quora.com/How-do-I-install-or-upgrade-the-GCC-compiler-on-Windows) CygWin and MinGW do the same thing, just make sure when you get to the window to install packages, you select the gcc package. There are probably more in-depth written guides out there for them specifically too. &amp;#x200B; IDEs are all unique, CodeBlocks would be a good place to start. If you want to just run it on a command line, follow instructions above to compile. Then you just run the newly created executable file. &amp;#x200B; Hope this helps!
If you want to get consistent experience and focus on learning, then you might want to stick with Linux and Netbean running on VMWare or VirtualBox. The behavior of C code depends on C compiler and C libraries. The same C code might behavior subtly different on Windows and Linux. This can be annoying. 
No. The most efficient way is installing Linux through the WSL. Google for "windows WSL". From there, install clang or gcc, and use Nano (preferred at first) or Vim (if you're for real). Apart from C being a second class citizen in IDEs, using barebones text editors can be a really great challenge to train your attention, as well as your knowledge about the language and the problem, which you should have sorted out before typing your program. Also, learn to write makefiles.
Do you want to learn the implementation of POSIX functions or how to use them? If you only want to learn how to use them, you can just use Linux man to look at each function. If you want to learn the implementation of POSIX functions, you can look at the source code of musl libc, which is a new implementation of C standard library and is easier to understand than glibc. 
It’s a combination. 
Also when I get integer input using scanf, do I have to covert it to BCD in my program?
Rarely.
The code the compiler generates depends on more that just the single line of code being compiled. The -O0 and -O1 switches change the code a lot. And your disassembly is using more registers than necessary - suggesting the array elements are used later in the function and the optimiser is storing one in an spare register for later
[Advanced Programming in the UNIX Environment](https://www.amazon.com/Advanced-Programming-UNIX-Environment-Addison-Wesley-ebook/dp/B00DB3G8KY).
[Advanced Programming in the UNIX Environment](https://www.amazon.com/Advanced-Programming-UNIX-Environment-Addison-Wesley-ebook/dp/B00DB3G8KY) by Stevens and Rago.
If you have a nice fast laptop and you're used to Windows, then VMware free version + Ubuntu will serve you nicely. If you want to leverage your computer's hardware to its fullest (CUDA for scientific computing, for example), you will need to dual boot and install proprietary drivers.
CygWin and MinGW take completely opposite approaches.
They both get c code to compile in run, which is what I was going for in "do the same thing"
You've asked a really great question, and I think it's very relevant to C programming, since anyone who's ever taken a data structures and algorithms (DS&amp;A) course in C has dealt with this very issue. I took my DS&amp;A course decades ago, so I'd actually forgotten the details of *merge sort*, but your post jogged my memory to remind me that, theoretically, *merge sort* can give better performance than *quicksort*. Interestingly, when I started writing production code, I just started using *quicksort*, and it always performed so well for me that I never had to check the performance of other algorithms. When I started writing code for distributed systems, the lower level details were abstracted away, so I'd typically just call a higher level sort function and everything would just work. I'm glad that universities still teach fundamentals and that students still care about them.
Well when the spirit of two things are completely at odds with one another, it is strange and misrepresentative to lump them together like that.
Sure, big num arithmetic is the first place.
&gt;Rational Arithmetic: represent all numbers with fractions It's all fun and games until someone asks you for pi or wants to run sqrt(2).
I'm curious what problems you have experienced that lead to suggest not going anywhere near MinGW or Cygwin? I can't speak for Cygwin personally (I never used it), but I used MinGW quite a bit, and apart from the weird 32-bit/64-bit schism they had going on for a while and the lack of threading support (which got fixed), it was GCC, and it worked just fine.
For cases where precision is of utmost importance, they tend to use integral datatypes to represent the fractional parts of rational numbers, as far as I'm aware. I've never worked with these myself, but I'd guess it would be something like \[integer\] (whole part) \[unsigned\] (fractional part), which would be put in a struct or class and operated on via specific methods. &amp;#x200B; The problem with your first idea is that it lacks coherency in terms of the way programs operate. Example: Is it looking at \[1\].\[1001\]\[11\] or \[1\].\[10011\]\[1\] or \[1\].\[100111\], etc. You'd need cardinal values/bytes for it to know, which can end up wasting both space and processing power when operating on them. &amp;#x200B; The second solution is probably more operable, but like others said is going to be trouble when irrationals start appearing.
The first solution (once the obvious issues are handled) is called binary coded decimal. But this doesn’t really solve your problem. using decimal vs binary just changes what fractions will not be represented fully. for example 3 * (1.0/3) in bcd will still not be equal to 1 I don’t know of a domain specific name for the second solution (though I have seen “rational” classes for c++). This solution solves a lot of problems, but will not handle irrationals. A third opinion (depending on your goals) is fixed point arithmetic. This will still have limits on how precise it can represent numbers, but will be very stable and fast for the domain it covers. I have yet to see a “great” solution, but keep thinking about the problem. You will either solve it (which is good for everyone) or (just) learn a lot (which is good for you)
Well if you're taking a C class taught in \*nix, MinGW will flat out not work for you because it is not \*nix, and also it is simply a bad alternative to using MSVC or the GNU Collection itself (which is available for Windows). CygWin is extremely slow and crashes all the time.
Your first solution does solve the imprecision caused by converting decimal numbers into binary and vice versa, but not anything else. Nevertheless judging from the fact some languages have built-in support for such types (e.g. `Decimal` type in .NET languages) the solution should get the job done indeed in some applications.
This sort of thing is also incredibly relevant when writing performance sensitive code for device drivers and other low level software ..
Just FYI, I'm pretty sure the improvement offered by sequential r/w is negligible (if present at all) on a system with an SSD. So another set of factors that complicate your evaluation is the characteristics of the system itself. In this case I'm talking about the hard drive, but almost certainly other variables can be very impactful too, such as the cache size/coloring, page eviction policy, etc.
Or you can guarantee average quicksort via linear time median pivot section using the Median Of Medians algorithm, if the data is large (better than shuffle).
There’s PellsC IDE which is a no bullshit simple C editor. I learned C on that and it was easy to focus on learning code and not getting caught up in the frills and overhead of the IDE itself.
Now you need key frames, to do ANSI art BBS style.
Most compilers have speculative devirtualization now, so the overhead isn't nearly what it used to be. Of course, it's still good to understand how that works
CLion + WSL
Clang, at least, was pretty awful at it last time I checked. Admittedly, that was a while ago, but I doubt things improved drastically. Will be happy to be proven wrong. (I'm not saying people should avoid virtual functions out of performance considerations, or anything like that. Just commenting on the state of compiler technology.)
can you explain what those terms mean? 
One more, someone posted this here the other day, [libc.pdf](https://www.gnu.org/software/libc/manual/pdf/libc.pdf)
I am not sure how you got this idea. There is no BCD involved in the way computers process numbers. Can you elaborate what you mean with “I believe we are displaying BCD or the bits?” I have no idea what either “display the BCD” or “display the bits” would look like. &gt; But the way he wants us to display it, it looks like a calculator display. Can you give an example? None of us are clairvoyant, so you gotta show us what you mean.
Key frames are a concept from animation. In a stream of characters it would delineate one frame from another. [ANSI style BBS art](https://www.youtube.com/watch?v=tbgD14LH0Ck) was common as a greeting on BBS login screens, and can be played in terminals.
So which line is it segfaulting on? Have you run this program through a debugger?
Line 7
Which one's that?
To help someone help you, your code sample should: * compile * be in english * use variable meaningful variable names longer than 3 letters
1. Assign 0 to i in fin2 before while loop. 2. Rewrite comp since it's nonsensical. 
Problems: * Place-value arithmetic requires say 4 bits per digit but the average entropy of a base 10 digit is 3.16 bits so you're guaranteed to waste space. Also, you have to specify upfront how many digits you'll keep track of, so you still have a precision problem it is just a fixed precision problem rather than a floating precision problem. * Rational arithmetic is all well and good but you have to decide how large your numerator and denominator are allowed to be. So you still have a precision problem since arbitrary precision would require arbitrarily large numerators and denominators. Worse, the distribution of values which are representable is not even, so you still have the old floating point problem of losing post-decimal precision at higher values, but you have an arguably worse distribution of values. E.g. INT\_MAX/1 is the highest possible number representable, (INT\_MAX-1)/1 is the next highest possible number, you can't actually represent INT\_MAX-0.5. Until you get down to INT\_MAX/2 you don't get 0.5 increments - it's just whole integer increments. Maybe instead you could use one integer for before the decimal point, and one unsigned integer after. The unsigned integer afterwards represents the range 0-1 divided into the precision of that integer. So your number can be recovered by pre\_int + post\_int / unsigned\_int\_max. This gives you reliable precision increments over the range INT\_MIN to INT\_MAX.
Unlike floating point numbers which can represent pi and sqrt(2) without any loss of precision right? There are other reasons why rational representations are not a good idea in all cases, but the existence of irrational numbers is not one of them.
isikp and isiks (what are those?) are too large to fit in int. You need to use unsigned long or somesuch there.
The point is that rational arithmetic does not guarantee you that all computations can be carried out without loss of precision if roots or transcendental operations are involved. Why bother with this at all if you introduce imprecisions anyway? 
You cannot do sizeof(dynamically\_allocated\_array) to get the number of elements
It does not guarantee that all computations can be carried out without loss of precision **even without considering irrational numbers.** Irrational numbers are a red herring, and in fact in the case of pi, this scheme yields a higher level of precision per bit than you get from floating point representations.
Did anyone already mention choosing most stable algorithms
In most applications it is very hard to avoid a gradual loss of precision. This has multiple reasons: * some operations such as square roots and the exponential function yield a transcendental result that cannot be represented exactly in any number format. It is some times possible to address these issues (e.g. by storing a number squared or under logarithms), but often, such a method is not available. * even if no such operations are present in the desired computation, storing each number exactly roughly doubles the amount of space needed to store each number with each operation. This is because when storing rational numbers, it is (a / b) · (c / d) = (a · c) / (b · d) and the product of two numbers has as many digits as the sum of the number of digits of each number involved. The number can be lower if there are common factors, but it is very likely that no common factors exist. Given that almost all real-world programs have fairly deeply nested operation trees, you are bound to quickly run out of memory. For example, if each number initially occupies one byte, you run out of memory after just 30 operations on a machine with 1 GB of memory. However, there are solutions to these problems. The theoretical property behind the precision of computations is called [*numerical stability*](https://en.wikipedia.org/wiki/Numerical_stability). The key idea for real-world computations is to design your numerical algorithms such that they are *numerically stable,* that is, such that a slight imprecision in the input values yields only a slight imprecision in the output. Now designing algorithms for stability is an entire discipline in computer science and numerical mathematics and this comment does not have enough space to discuss it. However, in many cases it is possible to find algorithms that are able to correct imprecisions on their own, allowing you to carry them out without having to worry about numerical error even if you let them run for a long time. One example for this is Heron's method for computing the square root; if you perturbate the immediate values, you are still going to end up at the correct result but it might take you a bit longer. This nonwithstanding, many instruction set architectures designed for numerical computations have quad precision floating point units, allowing you to keep 39 decimal digits of precision without any special code.
With rational arithmetic, you can in fact carry out all computations involving just the ring operations over **Q** without loss of precision. Not very useful in practice though. &gt; Irrational numbers are a red herring, and in fact in the case of pi, this scheme yields a higher level of precision per bit than you get from floating point representations. Citation needed. I mean, I do believe you that you can build a rational number format specifically tuned to represent pi with more precision than a floating point format of the same width, but is that format really useful for general computations? 
Where on earth is this reddit thumbnail coming from? I see some old room with sun coming in a window, yet no such image is on the linked page.
Because segmentation faults and all the other errors you made ARE fun, I got a bit sidetracked and fixed your code. There were many little issues. I hope you can learn something from the fixed version: [https://gist.github.com/barafael/b1e36061547ef509154a26f930ea330c](https://gist.github.com/barafael/b1e36061547ef509154a26f930ea330c)
&gt; Place-Value Arithmetic 10 is a particularly bad basis for this (though some languages like J use it successfully) as it wastes memory and requires expensive operations to compute carry and borrow. Why not set the base to (some power of) 2 and use binary numbers?
You got the wrong subreddit mate, try /r/csharp
C# is off topic in this subreddit. Please post C# questions to /r/csharp instead.
ok ty i didnt know that csharp is c# &amp;#x200B;
You really do a good job making this seem tedious when it is actually very simple.
There was a nasty string corruption there, fixed it: [https://gist.github.com/barafael/b1e36061547ef509154a26f930ea330c](https://gist.github.com/barafael/b1e36061547ef509154a26f930ea330c)
Given that there are systems with 9, 16, 24 and 32-bit “char”s this is clealy not universally true.
Don't allocate for slices. Represent strings with (pointer, length). Null terminated strings are a thing of the past. Inefficient and hard to use. 
The code doesn't have so sense,check the function you declare sum as an int var and then you use it like an array wtf
Did you perhaps mean to write `sum += i + someArray[i]` instead?
Newb here. Would also like an ELI5 explanation.
Check out this tutorial. Thus helped make pointers click with me http://pweb.netcom.com/~tjensen/ptr/
Have any such devices received C11, or even C99 implementations? I would not be particularly shocked if a C99 implementation has been produced for a 16-bit DSP, but octet-addressable storage is so commonplace that "C with octet-addressable storage" should be recognized as distinct from "C with (some other N)-bit storage". 
A pointer is a special variable which contains the memory address of another variable ("points" to another variable). A pointer can be "dereferenced", which accesses the data contained in the variable which is pointed to. &amp;#x200B; Pointers can be manipulated with addition and subtraction, for example adding one to a pointer will access the variable in the chunk of memory next to the original chunk that was pointed to. In this sense, pointers also act as arrays, where adding one, then two, then three will access the successive members of an array which are all next to each other in memory. &amp;#x200B; For ten year olds: When adding or subtracting values to/from pointers, the compiler will decide exactly how many bytes to increment the pointer based on the base type assigned to the pointer (for example: char, int, double, etc.). Chars are typically one byte, so (char) pointer + 1 will increase the memory address by exactly one. Ints are typically 4 bytes, so (int) pointer + 1 will increase the memory address by 4 bytes.
Computer memory is a sequence of boxes. Each box is numbered, starting from zero. This is called the address of the box. Each box contains a byte. Data types like int, float are made up of more than one byte. So they fit in more than one box (contagiously, of course). A pointer is an integer-like data type. But instead of storing an arbitrary integer, a pointer stores the address of a box. You can dereference a pointer to get what's in the box pointed by the pointer. If the data type of the pointer is made up of more than one byte (int, float, etc) then you will read from multiple boxes (contagiously). 
Objects don’t exist in C but for the purpose of the explanation it’s easier to speak about an “object” in general terms, as a request for sequential memory to store a value. Pointers are useful as instead of passing the actual value contained at a point in memory between functions, you can simply pass the memory address which points to the start of the “object” you want to manipulate. This is why pointed syntax differs upon use case. Upon declaration you would see something akin to int x = 0; int ptr* = &amp;x; Which is storing x’s memory address in the value ptr. You then have two options of how to use the pointer. To refer to the “object” being held by the pointer you use ptr* This is known as dereferencing. The other option is to see the address of the pointer itself by using ptr This is used to make pointers to pointers etc. 
A pointer holds the location of another variable. Think of the memory like a big drawer, with each compartment is a variable. If I want to change or look at the items stored in the variable I need to know its location. The type of the pointer is important for adding or substracting from its value. For example an integer is 4 bytes long, therefore if in an array I wish to move to the next element, I need to move to the next 4 bytes. (Declaring the pointer as int* allows you to just add 1). If you want to send a local variable to a function, but you also want the function to modify the variable, you need to send its location (you should also read about scopes and by value vs by reference).
&gt; contagiously Autocorrect, Of course he means "contiguously." 
Thanks. Corrected. 
&gt;Where on earth is this reddit thumbnail coming from? That's my github profile picture lol
Thank you.
Well, it takes time to completely get accustomed to pointers, but to give you a really simple idea of how they work: A pointer is, in C a type of variable that points to the address of another variable. That is, it holds as value the address of the variable is pointing at. So when you print the pointer as it is (just like a normal variable), for example: `printf("%p\n", pointer_to_int);`, it will return that variable's address (in order to get the address, you need also to input the correct format to get the address. If you want to retrieve the value of that particular variable (this is called dereferencing the pointer), you'll have to use the '\*' symbol before the pointer, for example: `printf("%d\n", *pointer_to_int);` will print the value at the address `pointer_to_int` is pointing at. &amp;#x200B; There is a bit more to pointers than this, but if you are a beginner this much is enough for now, in order to use them properly. You'll find out more as you advance. This is a simple as I can explain it :D 
Memory has little boxes. All those boxes have addresses. Variables are stored in those boxes. Some variables use only one box to store its value, others use more boxes, it doesn't matter. The values of those variables can be anything you want them to mean, it can be integeres, characters, etc. One special type of value is storing addresses inside those variables, it's still a numerical number, but you know it's special because it's a address. This is your pointer, it's the same as the others variables, but you can do one more thing than the others types: you can access the box that is in the address stored in that pointer. You can use that pointer to reach those boxes indirectly without having the name of that box, because you know where is located the box. This is called dereferencing a pointer.
First off, your first code example (as written above) doesn't do what you think it does. In fact, it'll simply create an array, and then print `0` 100 times, and then say `The sum of the array is 0`. Secondly, with regards to your function, let's start from the beginning and think about what steps we're trying to accomplish. You want to: 1. Take an array and a number of elements in that array 2. Keep track of a sum value (starting at 0) 3. Iterate (it's a fancy word for going element by element) through the array.... 4 ... and add each value to the sum. Your code doesn't do that. Here's what your code does: 1. Take an array and a number of elements in that array 2. Keep track of a sum value (starting at 0) 3. Iterate through an array 100 times (How many times do you *really* want to access the array? Notice that you are disregarding your numElemInArr value. How can you fix this?)... 4. ... and each time, increase the sum by i (which is simply your counter for how far in the array you are) and then increase the value by a garbage value, `sum[i]`, which has no meaning within your program, as sum is neither an array nor a pointer) Remember, `i` is just a counter to keep track of how far you are in the array. You should never be adding `i` to your sum -- instead you need to add the value in the array that is stored at the `i`th index. You can access values of the array by using `nameOfTheArray[i]`. Good luck.
The idea was to eliminate the inherent imprecision in decimal-binary conversion. Now that I think about it, base-5 would work too.
- Data is stored in memory. - Memory is stored in a giant list. - Each entry of data has an address and a value. Pointers are simply references to those addresses. This allows you to modify the value of the data indirectly through the address, as well as pass the address to another part of the program. This is called passing by reference. If you "dereference" the pointer using the &amp; symbol, it returns the value of pointer's address. 
You don't actually lose precision if you use sufficiently many binary places. 
Well, concerning the place-value stuff, you won't get imprecision until you hit the digit limit, which let's say is 16 digits, as opposed to floats where all numbers with a decimal portion have imprecision. And concerning the issue with large numbers with rational arithmetic, you have a very similar problem with floats, though it's a bit less pronounced.
we all know that your not five lol.
I’m highly advanced compared to my kindergarten inferiors.
C uses prefix notation for pointers int x = 1; int *p = &amp;x; *p = 2; assert(x == 2);
You know how every house has an address? Like 123 fake st? That’s what a pointer holds: an address. (E.g. the value of a pointer is 0x456f). It doesn’t tell you what’s inside the house, though, you have to go to the actual house to see (e.g. dereference). There’s different kinds of houses (e.g. int, struct, whatever), so you have different pointers so you know what kind of house you’re going to. Sometimes you have an address and inside that address is another address to a house. That would be a double pointer, e.g. char**.
An “object” in C is just a “region of memory in the execution environment, the content of which can represent values.” Every single datum is an object.
Most C developers have little to no awareness of implementation defined, unspecified and undefined behavior. The end result is at scale you can lose many calendar years ”porting” C to the very next release of the same compiler on the same hardware and OS. Well run projects spell out what you can and can’t depend on. For most projects 8-bit chars, 2’s complement signed integers (and with them the guarantee int8\_t and the like will be available) are spelled out, and problems with things like alignment are addressed so the code doesn't end up being brittle. It’s a little learning up front with a big payoff for large long running development efforts. &amp;#x200B;
Y'all know some smart 5 year Olds Pointer is like the address of your house. They are useful because it easier to give someone your address than to give them your house. When you order a pizza. You give the driver tour address and the driver delivers the pizza to the house that corresponds with the address. When you hire a painter to paint your house. You don't want to drag your house to the painter. And you don't want the painter to paint a copy of your house, you want them to paint the house you live in. You want to give them your address so the painter can come work on the house. Likewise in a program you don't always want to copy a variable or move it to a new function. It's easier to feed a function the address of a variable and let the function go off and do it's dirty work on the original variable. It's a useful way of preventing your neighborhood from filling up with copies of your house.
a pointer is a variable that holds a memory address if you dereference the pointer, the computer will "go and get" whatever is at the address. If it's the beginning of an array, hey cool you just got the first item of the array. If it's garbage data, hey you either got memory corruption or a segfault.
Pardon my ignorance, but if you're on Windows isn't another option to download Visual Studio Community, install the C/C++ packages, then create a C template and write and run your C code? I had to use VS recently to start writing some C code and that worked fine for me. &amp;#x200B; If that's too much hassle and you just want to get on with writing some C, you could try and use a browser based editor, like Repl??: &amp;#x200B; [https://repl.it/languages/c](https://repl.it/languages/c) &amp;#x200B; By all means if you want to get more familiar with Linux/Netbeans go for it, but just so you know there are other options for you. &amp;#x200B;
The C Standard was written to describe a simple language, memory would behave as one or more grids of consecutively-numbered mailboxes, each of which would hold some fixed number of bits (typically 8), each of which could be one or zero. Mailboxes would typically be in rows of one, two, four, or [later on] eight mailboxes. Individual mailboxes were called "bytes", and rows were often called "words". For each numeric type, an implementation would describe a means by which the bits in a sequence of consecutive mailboxes could be interpreted as a number of that type. Some implementations may allow larger values to be stored in any group of consecutive mailboxes, while others would require that when accessing a value stored over several mailboxes, all the mailboxes must be on the same row, or--for types larger than a row--must be stored ass a sequence of complete rows, rather than using some boxes on one row and some from another. Implementations also included types which could identify mailbox locations, which were called addresses, , If all the mailboxes were in a single grid, an address might behave as a simple mailbox number. In some implementations, there would be multiple grids, and so an address would need to identify a grid as well as a box number within that grid. In any case, implementations would define a means by which sequences of mailboxes could be used to store addresses. Every variable not declared using a `register` storage class would be stored in a sequence of consecutive mailboxes. The address of the first such mailbox is the address of the variable in question. If code were to say, e.g. int i; int *p; ... p = &amp;i; ... *p = 23; the code would reserve some ranges of mailboxes for `i` and `p`. It would then take the sequence of mailboxes reserved for `p` and change the ones and zeroes therein so that, if interpreted as a pointer, they would represent the address of `i`. Later on, the code would read the address stored in the mailboxes reserved for `p`, take a sequence of mailboxes which starts at that address and is large enough to hold an `int`, and change the ones and zeroes in that sequence so that, if interpreted as an `int`, it would represent the number 23. In the language the Standard was supposed to describe, all storage behaved as a sequence of grids of mailboxes. Writing a variable would change the pattern of ones and zeroes stored in a mailbox, reading a variable would read the pattern of ones and zeroes, and changing the pattern of ones and zeroes would change what value would be produced by reading variables containing that mailbox later on. The Standard adds a bunch of complicated and contradictory rules and allow compilers to behave nonsensically if they're not followed, but the language Dennis Ritchie designed, and which the Standard was supposed to describe, works as described above.
The main thing to remember: make sure the pointer is pointing at the right thing before you use it. 
Isn't it true that an int is an "object" in C but not in Java?
Yes. But what Java considers to be an object differs considerably from what C considers to be an object.
I got gdb to work on macOS Mojave and posted instructions here: https://stackoverflow.com/questions/54736753/gdb-errors-on-macos-mojave
My professor said visual studio runs into issues with scanf and a few other things and requires some workarounds. Also, I tried using visual studio but it keeps spitting out errors about being unable to find the file and build errors keep saying "did you forget to #include &lt;something&gt; then adding that makes it spit out a different error because it thinks im trying to run and use c++ files and headers when in reality im using c on a source.c file
For windows everything links to the msvcrt library which is the windows c run time so no matter what you pick, it'll link up to msvcrt (except for pelles c but that has its own issues). You essentially have to use visual studios if you want to do c programming in windows. As for its weird c kinks, yes it sucks for c support but it does support a majority of c99. As long as you don't use c11 stuff (which you Mos Def won't in an intro class) you'll be fine using visual studios, don't try to make extra work for yourself by using anything else. Besides visual studios is hands down one of the best IDEs out there! By the bye, if you want to do c11 stuff like multithreading in windows check out the win32 api which is what is used to program in windows. It's built into the windows sdk and visual studio so you don't need to link anything as it does it for you
Our intro class actually has us make all files use C11 in netbeans, but I don't think we are using any C11 specific features or functions
So then visual studios will provide everything you need then! Also note that visual studios only says visual c++ but in reality if you change the source file to a ".c" it'll compile as a c program.
What's your background? Are you an academic (student or professor)? You've been riding the c-standard-vs-the-language-it-was-meant-to-describe horse pretty hard, I've started to recognize your posts from the language used :)
When I tried that, it just spits out constant build errors. And it's literally a simple print("Hello World"); so it's not a code issue. It keeps telling me about some headers missing that from what I can gather are c++ headers despite using normal c on a source.c file and adding those headers makes it spit out other errors when building
so you are probably familiar with x = 1. That means the variable x has the value of 1. a pointer is just a variable, like x, whose value describes a location. so you might have x = 34388. In this case, the contents of x is an address (34388). What about the contents of 34388? Could be anything, maybe 9 for example. You are probably wondering, why not just make x = 9? why do a round-about, two step thing? there are a few reasons, but I'll give one. Let's say you want to pass the value of x to a function, maybe to increase it's value by 2. increase_by_2(x) The way C works, it will make a copy of x and pass that on to the function increase_by_2. Whatever changes happen to x inside of the function increase_by_2, it will not affect the value of x whenever you exit the increase_by_2 function. That kind of of sucks. Pointers help because when you pass a pointer (an address), you can dereference and manipulate the contents of the address. Imagine passing a pointer to x. increase_by_2 can dereference, get the real address of x, and add 2 to its value. Now when you return from increase_by_2, x is different.
You and I are watching cars passing by, You point to a red car with your index finger. I look at your finger and then at what it is pointing to. I see a red car. If you now point to a white car i will see where the finger now points to and see the white car. &amp;#x200B; &amp;#x200B; The point is, the only thing i have to remember is where your finger is, because whatever it is pointing to i can reach the real value by checking it. In this case, the finger is the pointer, and a car would be the variable it points to. Therefore, a variable that can hold multiple different variables at different times without me having to know which exact variable it is, could be a red, white or yellow car, but by knowing the pointer (finger) i don't need to worry about it.
Okay I understand a little better
I've been programming C since the late 1980s, and have observed that there's been a divergence between the language which is suitable for low-level programming, versus the language that is favored by the maintainers of gcc and clang. It seems that the current generation maintaining those compilers thinks that the language originated in 1989 with the C Standard, when many parts of the language were defined 15 years earlier, as evidenced by the Dennis Ritchie's 1974 C Reference Manual. If one looks at e.g. the Java specification, there are clearly-designated means by which implementations may allow programmers to access platform-specific semantics; the Java spec discourages implementations from offering extended semantics via other means, even in cases where they would be allowed to do so. Someone who looks at the C Standard from the same standpoint as the Java spec might believe that it was intended likewise, but reading the published Rationale and the 1974 C Reference Manual would reveal that is not the case at all. There are many situations where a programmer will know things that an implementation won't. In the language described by the 1974 C Reference Manual, given `extern char a[10],b[10];`, an attempt to access `a[15]`, would take the address of `a`, add 15, and operate on whatever byte happened to be at the resulting address. An implementation would typically not be expected to ensure that attempting to access that address would do anything useful (or would be at worst harmless), nor to make any effort to prevent such access. Instead, the prevailing philosophy was that the programmer might know something useful about that address that the compiler didn't. The sample `printf` function given in the 1974 C Reference Manual, for example, exploits the fact that on the intended target platform (the PDP/11), function arguments were passed in consecutive rows of mailboxes. Code which relies upon that wouldn't work on other platforms where arguments were passed via other means, but the compiler's job wasn't to ensure that accessing memory beyond the storage reserved for some objects would serve a useful purpose, but merely to let programmers who knew what storage they wanted to access, to do so. Unfortunately, a compiler that has to process all actions as reads and writes of memory which are performed in exactly the specified order will be unable to generate code that is nearly as efficient as that generated by e.g. a 1980s FORTRAN compiler. Because many applications don't require such precise semantics, the authors of the Standard didn't want to mandate that *all* implementations support them. Nor did they want to try to decide when such semantics should be supported. Instead, they figured that people writing implementations for purposes that would sometimes require such semantics should be better placed than the Committee to determine when such semantics would be required and support them appropriately, and there was thus no need for the Standard itself to say anything about them. This approach worked, until a generation of compiler writers started "optimizing" on the assumption that the Standard was intended--like the Java specification--to include everything that programmers should ever need. The way pointers are defined in the 1974 C Reference Manual is simple. A bit *too* simple in some cases (e.g. given `struct foo {char x,y;};`, the language described in the 1974 CRM would process an expression like `q-&gt;y` by interpreting `q` as an address, adding 1, and accessing a `char` at the resulting address, without requiring that `q` be a `struct foo*` or *even a pointer*) but it clearly describes a mailbox model in a way that none of the C Standards do. 
Depends on the compiler/platform. In the hot path on the devices I work on there is a measurable overhead for virtual calls.
The x86 FPU can directly load and store 10-byte BCD, at least. Still expensive and unpleasant af.
Can yous how me the code and the errors? My guess is that it's an issue with the project setup and properties but I can't tell without seeing the actual error
Without loss of precision assuming arbitrarily large integers for the numerator and denominator. See my other post in this thread for the pi example.
Ok. Imagine a box with a #1 on it. This box is a chunk of memory adressed with #1. Now imagine a piece of paper with an arrow to the box and a #1 written on the arrow. That's your pointer.
Use functions instead of macros.
Painting is literally dirty work but it's a bit too pejorative for my 5 y.o mind. 
It is not correct to say that all numbers with a decimal portion have imprecision in floating point representation. 0.25 for example has no imprecision. And some numbers with non integer parts have imprecision even in arbitrarily large base 10 representation e.g. 1/3*3!=1. It is just easier to show the imprecision in base 2 when you start with a decimal representation. Deca of course meaning 10, by virtue of writing the number in decimal you have set yourself a self fulfilling prophecy, allowing you to conclude that base 10 has no imprecision. If you wrote any number in base 2 you would shockingly find that your base 2 scheme has no imprecision! In both cases the conclusion is false - both representations are unable to represent some numbers with arbitrary precision. Using base 10 with a fixed point is in fact no different to using base 2 with a fixed point, except that you are losing entropy in the base 10 scheme due to your underlying binary representation. So you would expect more precision per bit on average from the base 2 scheme. Let's check this by emulating a base 2 fixed point scheme by just using a floating point number with a fixed decimal place. In that case the mantissa represents a measurable level of precision. Let's say the mantissa is 64bits on a number with a single digit before the decimal place (as you assumed for your 16 digit example). Then the most error our representation can have is 5.4e-20! Quite a bit better than 1e-16 wouldn't you say? Or in a simpler frame, lets say you just had 4 bits. That gets you within 1/10 of your number in the decimal scheme, but within 1/16 of your number if you used a binary representation. Yes you have lost the ability to represent numbers written with a single decimal digit precisely, but numbers written in decimal are in the minority of rational numbers, it is just easier for humans because that is the system we are used to. Agreed that you have the same problem with floats for the num/denominator representation, but it is worse for the rational representation, which is exactly what I said.
I finished computer science 1 last semester in college and you explained this much better then they did. My only question is why would you ever use pointers? If it just points to where another variable is, why not just reference that variable in the first place?
Painting is pejorative? I don't understand what you are trying to say.
"dirty work"
``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { for (int i = 0; i &lt; 100; i++) printf("%lf\n", rand()/(double)RAND_MAX); } ```
So, let’s say I have 10 different houses and I want to access them separately in order. I can use a pointer to go to each house one by one. E.g. an array. Now, what if the houses aren’t right next to each other? That is, I have a set of houses I want to look at, but they’re all scattered? Well, then I’d keep an array of pointers to houses. E.g. A double pointer array. Leaving the house analogy, you want to look at what you’re doing. Like a data structure, say a linked list. You have all these objects scattered in memory so you keep a point to the next object in your list, that way you know where to find it. As for why not just copy? Well, copies are expensive as data gets bigger. If you have to copy 256 bytes every time you want to do something, that gets a lot more expensive than copying the 4 bytes (or 8 or whatever) that’s the size of your pointer.
This forum is about the C programming language, so if you're using C++ you might want to ask over at /r/cpp_questions, or /r/cpp. That said, Google is your friend. Here is an algorithm in C to pick a random number with an arbitrary floating point range. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* generate a random floating point number from min to max */ double randfrom(double min, double max) { double range = (max - min); double div = RAND_MAX / range; return min + (rand() / div); } [Source on StackOverflow](https://stackoverflow.com/questions/33058848/generate-a-random-double-between-1-and-1)
Ahh I think I see what you're getting at. So a valuable way to use pointers is when you need an array of objects that arent all beside each other in the memory, but you still need to edit/organize them as if they were?
Thanks for the summary of your perspective, but I'm still curious about your background. What industry or industries have you been employed in? What do you do for work currently? Are you a professor?
That’s one way, yes. You essentially use pointers to avoid copying and duplicating memory. Additionally, you may want to share a bit of memory so it can be updated independently on a different thread or function. Like, let’s say I have a function that is going to write out bit of data, but it runs in a different thread / process / whatever. I could pass it a pointer to where I want that function to write out the stuff I want. Then, I could check the data once the system tells me it’s done: could be a callback, could just be a call to a function called “mythingisdone”, whatever. Essentially, anytime you want to share a specific piece of memory, you use a pointer. In C++, they add references, which are nothing but pointers that are automatically dereferenced by the compiler as a shortcut that adds some compile time checks. Under the hood, they’re just pointers. Same goes for other languages that use “references”, like c# or java. They’re just pointers to dynamically allocates bits of memory.
Awesome, that helps alot. Thank you! Now back to studying for my calc exam in an hour lol
Good luck!
I still don't understand what you're trying to say.
It can't calculate in BCD though. The only BCD operations are conversion from/to binary.
That when talking to a 5 years old you shouldn't use the terms you used to describe a profession, instead you could have said "do it's beautiful work". 
Yeah, and the leftover stuff like DAA and AAM either isn’t especially helpful, or was removed entirely for x86-64.
Oh I understand now. I guess I let my metaphor escape me. In my comment, when I said "dirty work" I was referring to the lower level operations that might be occurring within a function. It was not my intention for the adjective "dirty" to apply to metaphorical work I mentioned. Obviously I need to be more careful scoping my variables!
&gt; Without loss of precision assuming arbitrarily large integers for the numerator and denominator. Yeah of course you can achieve arbitrary precision with infinite space. What a bullshit argument.
Lol? That was your argument not mine. But yeah I agree it is bullshit.
Since this is a C++ question you might want to look into its random number library instead of using C's `rand()` function. See [this documentation](https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution) for an example that's pretty close to what you want. In the future, /r/cpp_questions or /r/learnprogramming is where you want to go with questions like this.
Then you misunderstood my argument. You cannot exactly represent &amp;pi;, with any amount of memory. However, given enough memory, you can exactly represent any rational number. That is the fundamental difference between rational and transcendental numbers.
I'm self taught and have made my own programming language, am I an anomaly? 
I'm an embedded systems programmer who has targeted a variety of platforms, but mostly use ARMs today. My current compiler vendor (Keil) unfortunately seems to have shifted focus toward using clang instead of its own compiler, despite the fact that the clang doesn't support some of the useful constructs that Keil supports, and despite the fact that the authors of clang generally seem more interested in what the Standard requires than in what constructs a compiler must support to be suitable for low-level programming or work with code written for that purpose.
Yes. Congratulations, you are amazing!
I got you. Imagine a puppy. But you(main) want to give the puppy to Mr.Function. Mr function needs that puppy in a container. So you pur puppy in your pointer(container). Mr function now has a way to hold your puppy, without touching the puppy with his hands. Because of this mr.function can feed your puppy, and now when mr.function is done with your puppy, he is fed. Now to give a more detailed explanation. A pointer is a point in memory where your variable is stored. Sometimes you need to store large amounts of data in memory instead of the stack. Because of this, you may not want to pass a value to a function because that could mean making a copy of HUGE data. So instead you give a function the point in memory where your variable is, and it can work with that data. Hopefully my ELI5 was good.
Cool, thanks! I'm a longtime programmer but am new to the world of C, have only used GCC thus far, so it's nice to get some context.
Yeah and in order to exactly represent every rational number you need infinite memory. Why is it bullshit when I say it back to you but not bullshit when you say it? I think you're thinking that is a marginal case and that with a modest amount of memory you will be able to represent a really large swathe of numbers exactly. This is not correct, at least when compared to floats. You will find even with very large memory the occurrence of rational numbers which cannot be represented exactly occurs at a higher rate than in a floating point representation. Consider that both 2/6 and 1/3 represent the same number and you will get an idea of why this method has more redundancy than floats (and therefore represents fewer numbers exactly given the same number of bits).
&gt; Yeah and in order to exactly represent every rational number you need infinite memory. Nope. For every single number, you need an arbitrary, but finite amount of memory. As in, if you give me a number, I can give you a limit on how much memory you need to store it exactly. This is impossible with &amp;pi; which is the fundamental difference I am talking about.
Representing ANY number and representing EVERY number does not mean the same thing. But I think you know that. Thanks for playing but I'm done being trolled.
I generally like your comments because they provide some pretty deep insight into the C language, but this was just insanely arrogant. Basically saying that it's impossible to learn somewhat advanced computer science subjects without attending college, as if the world wide web and the instant access to the combination of human knowledge doesn't exist. Why even a C subreddit if learning anything outside of university is entirely moot.
So could anyone give me an ELI20 on the usage of pointers? Why reference a pointer when I can reference a variable? I know it has usage but I'm not sure on why/when
If you use gcc or clang, I'd suggest using `-fno-strict-aliasing` and `-fno-strict-overflow`. Those flags block more optimizations than should be necessary to make most programs work, but if those flags are omitted, gcc and clang will sometimes generate really wonky code in situations that had been clearly and unambiguously defined since 1974, and have no practical Standard-defined alternative, or in cases where the Rationale indicates how the authors expected and presumably intended that commonplace implementations would/should behave.
I'm sorry if this comes over as arrogant. The point is not that is is impossible, the point is that very few people manage to do that as doing so requires a lot of concentrated work and long term commitment. Most people are unwilling to put this amount of effort in.
Pointers are useful when you need to do something outside of the memory of your current function. Remember that for any function, the memory inside the function will be destructed as soon as the function finishes. Look at `memcpy` for example. It writes n bytes from one place to another place. Both of those places exist *outside the memory of memcpy´, so it has to use pointers to do what it wants. You can write your own memcpy pretty trivially: void memory(void *destination, void *source, size_t n) { while(n-- &gt; 0) { // copy the byte at source to the destination *((unsigned char *) destination++) = *((unsigned char *) source++) } }
 *sigh* have you given this any thought at all?
Just imagine, your girl gives you her address and you go to her house only to find a note that says 'the princess is in another castle'
Let me follow up with a less than snarky off the cuff reply ... see : 1 2 #include &lt;stdio.h&gt; 3 #include &lt;math.h&gt; 4 5 int main() 6 { 7 int answer=(int)sqrt((double)100000000); 8 double answr = sqrt((double)100000000); 9 printf ("just an integer %i\n", answer); 10 printf ("just a double %18.12g\n", answr); 11 return 0; 12 } 13 What datatype is answer and what datatype is answr ? Think about what "sqrt()" does and what it expects as input and what you get as output. 
read data from /dev/random or a pile of okay data from /dev/urandom. Start there. 
how do their definitions differ?
A pointer is basically an array index. If you've been programming for long, you've surely come across code similar to this char arr[5] = "abcd"; int i = 1; char c = arr[i]; where `c` will equal 'b'. Now, imagine your computer's memory like a big array. A pointer is just an index into that array. It's just used differently, so it gets special syntax, like `*` and `&amp;` 
As I said before, in C, an object is a “region of storage in the execution environment, the content of which can represent values.” In Java, an object is an instance of a class. Huge difference.
&gt; Could the program sometimes end up with something like 9999.9999, rounding it to 9999? `sqrt` work on `double` values. On (most every) machine, that can precisely store integers up to 53 bits in length (up to 9,007,199,254,740,991). Taking the square root of numbers up to this size should give you the exact number you need. But what happens when you exceed this precision? Well, theoretically you could have a problem, because the computer is free to use a slightly smaller number than you provided, if that's the closest number that a `double` can store. Then, taking the `sqrt` of that could have a slightly smaller value that would then be truncated. Take 9,007,199,515,875,289 for example. The computer can't store this number in a `double`, and instead uses the closest alternative: 9,007,199,515,875,288. And now we have to worry about what happens when taking the square root. So ... what does happen? Well, it would compute the square root as 94906266.9999999947316..., but this can't be stored precisely in a `double` either. So it rounds to the nearest number it can represent: 94906267.0000000 ... which is the correct solution for our original number! I wrote a quick program that would check all perfect squares that can be stored in a 64-bit integer ... and this is true for *every single one of them*. I wasn't expecting that! I suspect there's a property of significant digits and square roots that will ensure that the correct integer value will always be computed, but I'll leave it to others to work through the math on that one. End result: no, that is not possible in this case. But you should keep things like this in mind when working with floating point numbers.
all he asked for is a random number between 0 and 1 so `rand() / (double)RAND_MAX` should be enough, no?
The published Rationale for the C Standard states that the purpose of Undefined Behavior is to allow for implementations to behave in ways the Standard can't adequately describe, with the question of which "popular extensions" to support being a "quality of implementation" issue. Since uselessly unpredictable behaviors could be adequately described in three words--"behave uselessly unpredictably", and since defining actions that the Standard would require an implementation to define would hardly be an "extension", I think it's pretty clear that the authors of the Standard did not intend to forbid code which was intended to run only on platforms with certain features from being able to exploit such features on such platforms. It would be impossible to write programs that would behave usefully on all "conforming" implementations, since--as the Rationale acknowledges--it would be possible to write an implementation which is "conforming" but which can't meaningfully process anything other than a single contrived and useless program. I'm not sure why compiler writers have latched onto the notion that the Standard is meant to fully specify everything needed to make an implementation useful, but in reality it makes no attempt to do so. Instead, it relies upon compiler writers to make a bona fide effort to make their implementations useful whether or not they're required to do so. 
Not really a programming issue. You would either modify the permissions on /home (hint: don't do this) or run the program as a user with permissions to write in /home (see sudo).
Honestly I have no idea what you are trying to say. “Undefined behavior” up to and including C99 could literally do anything from making the disk drive play “Yankee Doodle Dandy” to crashing with an error at the console. C11 tried to reign this in somewhat. Depending on pure undefined behavior in C isn’t C at all. There is also “unspecified behavior” such as the order on which parameters to functions are evaluated. Depending on this behavior results in code that is not C either. What I was referring to with word sizes, signed representations, etc... is known as “implementation defined behavior.” Almost everything worth doing in C will depend on this class of behaviors, and if you ever want to use code for more than one environment you need to define your expectations so you know what will and won’t be available to you. Properly written code will compile and run correctly on 16, 32 and 64-bit big and little endian systems (you have to manage the byte swapping - C doesn’t help you here) and large code bases (obviously starting on 32-bit systems) with tens of millions of lines of code can more cleanly move across compiler, operating system and hardware changes. The standard leaves open optional behaviors as well, such as having char or short bitfields. It may work, it may not. Implementations also add extensions which may provide (not by the C standard use of the phrase) implementation defined behaviors for what was undefined behavior. The complete insanity of strict aliasing with no way to cleanly support constructs depended upon by existing C is often dealt with by compiler extensions and the result is a lot of needlessly fragile code.
I try to run with sudo but its not creating the directories for a path /home/files/disk1.disk directory only contain /home/files `if(mkdir(directory, 0777) == 0)` `puts("ok");` `else` `puts("Error");`
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead. Also, never ever post pictures of code. Instead, make a self post and copy-paste the code into it.
What is the value of `directory`?
The Standard has a term for actions which quality implementations should process 100% predictably *unless they document a good reason to do otherwise*, but for which some implementations might be unable to offer any meaningful behavioral guarantees. Such actions are categorized as "Undefined Behavior" [characterizing them as "Implementation-Defined Behavior" would imply that *all* implementations should document their behavior]. Quality code should be prepared to handle any common combinations of integer types and storage representations upon which it should be called upon to run. That does not mean that it should be expected to accommodate all 32! ways that the bits of a `uint32_t` might be distributed among the four constituent `uint8_t` values. Nor should quality code be expected use `memcpy` and other bodges to guard against obtuse compilers abuse of the "strict aliasing" rules. A quality compiler suitable for low-level programming won't need such bodges, and a compiler that isn't suitable for low-level programming shouldn't be trusted to refrain from exploiting the ability to carry "effective types" through `memcpy` for the purpose of ignoring visible relationships among objects. It's not hard to distinguish which kinds of optimizations are likely to offer major benefits but unlikely to break very many existing programs, and which kinds are likely to break programs but unlikely to offer much benefit outside contrived scenarios. Unfortunately, C is caught in a "catch 22": some people argue that there's no need for the Standard to officially recognize ways of accomplishing things that have historically been supported on implementations where they made sense, while others argue that programmers have no "right" to expect that compilers should support actions beyond those mandated by the Standard. Unfortunately, from what I can tell, the Committee is controlled by people who are unwilling to suggest anything negative about the current trends. 
The C standard does not specify how precise standard library functions are. If you want proper rounding, use the `round` function as converting floating point numbers to integers by mean of a cast simply chops off the fractional part.
If you don't have write permission then no difference in how you make your program will change the result.
Imagine a laser pointer that tells you "there is that thing you were looking for", then you can change what it points to. 
&gt; So if you're in the space where dataset is small enough that the constants matter, it's probably not going to be the bottleneck of your overall system. Dang, good insight! I never thought about this, but you're definitely right. Basically everything is gonna run instantly for small data anyway, so optimizing for small inputs is indeed probably not super useful. And I totally agree with your idea about tilting more towards simplicity and maintainability, rather than a *technically* more efficient algorithm but a complicated one! Like you said, if you write for maintainability and understand-ability, then when you're done, you can just profile the code and actually see what the bottleneck is -- rather than guessing and potentially wasting your time optimizing something that isn't event the bottleneck! Like you say, &gt;there's little advantage in investing your time in improving the time complexity of your data sort, when the bottleneck of your system is the communication module. In general, I find the blend of software engineering (where I guess I'd place topics like maintainability, code architecture, design patterns, dependencies, coupling, reducing the impact of change, etc etc) and the more "pure" computer science / optimization mindset pretty interesting. When I write "actual" code for applications (and not code for my Date Structures &amp; Algorithms (DS&amp;A) class), I'm also always in the software engineering mode, where my primary goal is to write maintainable and basically simple code. One-liners and complex is "cool" I guess from a certain perspective, but who the heck wants to maintain or try to understand that stuff, lol. So like you mention, just write your code to be understandable, and then test, and if something takes a lot of time, abstract it out/encapsulate it, give it a well defined interface, and *then* maybe start thinking about more complex algorithms to get your job done. Ideally, to me at least, the perfect piece of software is one written with minimal coupling (or equivalently few dependencies), that's well encapsulated and *simple* to understand. Performance is of course important but it shouldn't be the primary concern imo, at least for most applications (unless of course you're writing something for the express purpose of efficiency!). Basically I'm just saying I agree: always default to the software engineer mindset, where your goal is to write simple, clean, and maintainable code. If you need to, you can then switch into your more CS mindset to optimize the heck out of it if you need to, but make sure to wrap those more complex bits of code up nicely! It's a strange balance though. Obviously, you don't want to write wildly inefficient code, cause you'll just have to replace it later when you find it bottlenecking your system. But at the same time, you won't really know what the bottleneck will be until your profile the code! So it's a balance. And of course, it seems you and me both tend to prefer the simpler side if we can, even if it isn't the *theoretically fastest and most amazing* algorithm to ever exist. And indeed, I'm not going around and writing my own sorts, don't you worry ;). It's such a common operation that I'm sure all the language designers have optimized the heck out of it and thought about the problem *much* more than me. But I still think it's real cool to know the different techniques, just because you can get a nice sense of what's going on under the hood, and perhaps optimize if needed. And those are some cool jobs, maybe I'll look into em! Thanks for the reply. 
That's very interesting! Thanks for the reply. That's pretty enlightening that a call like "fetch byte at 0xWhatever" is really probably going to return a whole bunch of bytes around that location. I'll keep this in mind as I learn more about the memory hierarchy with all the different caches and whatnot.
This is a cool article, thanks for the link. Indeed I can see how it can be very handy to know just what operations take orders of magnitudes longer than others.
[Pointer Fun with Binky!](https://www.youtube.com/watch?v=f-pJlnpkLp0) You said like you were 5, claymation seems appropriate :D
A lot of good explanations here on pointers. I will explain the part I struggled with for years until I took the time to really invest in it - the symbols representing pointers. When you define a variable you get the variable and it's value, and the memory location it's saved in. int variable = 5; // value 5 stored in memory if you want to know the memory location you can get the *address* of the variable using the `&amp;` operator int address = &amp;variable; // address value = say, 0xD16B835C (memory location) if you want to do it in reverse you can instantiate a variable from a memory location with the `*` operator int* pointer = 0xA0000000; // create a pointer to memory location 0xA0000000 int* other = &amp;variable; // create a pointer to the memory location of variable to get the value stored at that location of a pointer we use the * operator again, but this time it means "de-reference" the pointer - ie tell us the value at that location int value = *pointer; // value = value at memory location pointed to by pointer Other useful operators are the member reference and de-reference symbols `.` and `-&gt;`. These are useful for when you are passing a pointer to a struct. struct Car racecar; // a normal struct type struct Car* luxurycar_pointer; // a pointer to a struct racecar.speed = 60; // set the speed member variable to 60 using the . operator luxurycar_pointer-&gt;speed = 80; // set the speed member to 80 using the -&gt; operator because it's a pointer Here's a really good Quora article on why pointers are so handy in C: https://www.quora.com/Why-do-we-need-pointers-in-a-C-program