Fuck no, that douche is circlejerking his ego every other sentence.
Bjarne's *A Tour of C++* is ok, but it's not designed to teach you anything useful about the language. I would recommend Scotts *Effective Modern C++*. If you are serious about using C++, then you should also read the second edition of *C++ Templates*. It will teach you about far more than just templates. The strongest feature of C++ is the type system, and understanding how types work together and how type deduction works is essential to writing good C++.
Also, bool is supported in MSVC now, before then I wouldn't even consider using MSVC.
&gt; Unicode-C Huh?
&gt; You end up reusing variables, shadowing them, misspelling then, etc. wat... Use a modern fucking IDE, jesus.
I think [A Tour Of C++](http://www.stroustrup.com/Tour.html) is a quick summary of everything. However, if you‚Äôre looking for an in-depth, intensive book, then there‚Äôs [The C++ Programming Language ](http://www.stroustrup.com/4th.html). Both are written by the same guy. Stroustrup is the founder of the language. But I think OP just wanted a quick run down. 
Install Xcode from the App Store. Create your Project. Next to the run button (it looks like a play or go button on the top left) you'll see a little drop down that contains a black icon with your program name, click on it and any libraries you're using. Click "Edit Scheme...". In the right panel you'll see a bunch of options, go to the "Build Configuration" one and make sure it's in Debug mode. Do that for all of your libraries and executables. When you're done, make sure your executable is selected in the drop down. then click the run button, feel free to set some breakpoints by clicking on the left hand pane in the source code view right on the line numbers (if you have them enabled) that'll set a break point for you, click run whenever you need to restart. Anyway, once you do that, it'll bring up a pane on the bottom of the source code editor where you can step through, jump over, etc each instruction. 
I did it similar to your description. It's been working so far, thanks.
Why would you need 8 tones to represent a bit? just make 3, one for a zero, 1 for a 1, and one for an end tone.
320kbps lossy is fine within a reasonable data rate.
No, it isn't; that's literally not how lossy compression works, especially not when you're talking about using the DCT.
I'm already writing my own Unicode library tho, StringIO :(
C++ Annotations by Frank Brokken is precisely what you're looking for.
You wouldn't, but for a byte per the OP you would. Conversely, why would you need 3 tones for a bit? ;P. One for a 1, none for a 0 (usr a header byte/word denoting expected byte count)
&gt; only Rust tries to do that There are also F* with kremlin and Ada 2012 with SPARK.
&gt; [‚Ä¶] you know what they say about premature optimizations! I know what Donald Knuth is saying about *premature optimization*. &gt; We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. Growing a buffer exponentially, is absolutely critical to guarantee the amortization of the allocation overhead to O(n). Likewise, using the string length for looping will be *much* faster than checking for null. This is because it will enable SIMD optimisations and can easily speed up the process by 4x. So the code is not any more complex but way faster, thus an optimisation really worth implementing.
[The Unicode-C Standard](https://www.google.de/search?q=you+dont+get+the+joke&amp;source=lnms&amp;tbm=isch&amp;sa=X)
Since you mentioned it, I recently used this app called Sololearn and it teaches you the very basic of all features. Example questions are easy but explanation is pretty nice. It's free and took me a week of busrides to finish it.
Coursera has a "C++ for C Programmers" course taught by a UC Santa Cruz professor. Worth checking out. https://www.coursera.org/learn/c-plus-plus-a
Golang is not just another Python, Lisp... Even with its GC, it is as fast as Java, sometimes achieves C. It is a unique PL that brings fast execution with the easiness programming of PL as Python... 
I rather learning Java or Python than C++
Ask the oracle about best-practices. Skim a fuckton. Whatever seems to hook you, save. Grab whatever libraries the tutorials and guides tell you to get, and get crackin'! (The oracle is Google...)
&gt; going for an internship and they want C++, you refresh your C++ NEVER. I rather do web development with Python and Javascript!
A low/medium bit rate PSK modulator will not degrade enough at 320kbps mp3 to be rendered useless, this is simply untrue. North American IS-54 digital cellular, a medium over which you can easily make dial-up modem connections at 56kbps and usually have an effective throughput of 41kbps, typically offers only 30Khz of bandwidth with a maximum data rate of 48kbps. Amateur radio operators use low bit rate digital modulators over AM every single day for passing images and telemetry, a medium that imposes much more signal degradation than mp3 at the highest quality. These days storage space is not at a premium so raw PCM files are not a big deal to use, but I suggested OP store them as high quality mp3 for portability. If he plans on writing/using a very high bandwidth phasing modulator then yes lossy compression would cause problems. Digital modes in Amateur Radio: http://wb8nut.com/digital/
Although they're not quite as popular at the systems programming guys. Strictly speaking there are even some more, but I think it's fair to say that Rust currently is the only major player against C with the "security/safety" traits as big as it is.
Don't post pictures of code, post the actual code. There are plenty of places to do that e.g.: * [Github](https://gist.github.com/) * [Pastebin](https://pastebin.com/) You can also post code on reddit too **but** you need to add 4 spaces at the start of every line to get it to format correctly. So: ----&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#include &lt;stdio.h&gt; #include &lt;stdio.h&gt; except you don't need the ----&gt;, that's just to show where the spaces start.
Thank you! I am new to posting code on Reddit! FIXED
Ada is very popular when it comes to critical systems, it is widly used in aerospace and similar domains. Fstar is fairly new, version 1.0 is not released yet, however it is already used in some cryptography applications, and there is some Fstar code in firefox already. Anyway both are great languages and worth to be mentioned, especially considering both are far ahead of rust in terms of security.
I should've said "popular" in the sense of "how many people" deploy it, and arguably they aren't close -- but still very real, though mostly in really specific systems from what I can tell. Why do you think F* and Ada are ahead? Genuinely interested!
If you feel masochistic, grab a copy of the standard and read it front to back. You might learn something, you might go completely mad.
If you want to do OOP then C++ is not the right answer. Java or a much more robust OOP language will be a better career path. I rarely see pure C++ positions, but Java, Swift, Android, iphone devs etc are needed everywhere. 
It was asked not to give a solution ;)
except python has generics already (being a dynamic language itself).
DUDE WE'RE TALKING ABOUT TEXT DATA HERE. the data is transmitted via audio, but it's not the audio that's being compressed.
Speed isn't the main concern, latency is. As I said, garbage collection is a hard no in some subfields and nothing you say will change that.
The borrow checker idea is interesting, tho it's ramifications are dubious. That doesn't mean that it's syntax isn't shit (returning without the return keyword is just a bad idea, `func` is absolutely, entirely 100% useless at best, then there's this cliplet:) #[derive(Debug)] struct Person&lt;'a&gt; { name: &amp;'a str, age: u8, } That syntax is fucking garbage dude. Putting the type after the variable's name adds absolutely nothing to it's readability, understandability, and even makes parsing harder. weird apostrophes being used for what exactly? #Confusing. and what exactly is `a`? where's it's type? The syntax is just confusing.
derp. data is data, and mp3 is a viable audio compression scheme for LBR phase modulated data. not going to argue, look at the real-world examples provided above, they are proof of concept.
I think it's dubious if you don't have any idea about how things should work securely. It makes the memory model explicit, ie. you suddenly cannot write compilable code without understanding the memory model. Thus people who don't, will fail writing bad code. This is expression-based programming, it's not "returning". You seem to have not got the whole idea behind this. --- Just restating your distaste for the syntax is not making it an argument. The type after the name was actually I think even added because it's easier to parse. Also I find it as easily readible as anything. It's just something you have to get used to, it's no newfangled shit -- it's the way it was done for years. Only C diverted from this path. Seriously, just restating "Confusing" or "weird" don't make it so. It's a completely new concept, to have to state life-time information if needed -- so if you're unfamiliar with the concept, there's no way you'll understand the syntax, no matter how it is. Grasp the concept first. Then the '`a`' will make sense to you suddenly too. tl;dr: The syntax is different and you don't understand ML-like typesystems, expression-based programming, lifetimes etc. -- thus you have a hard time understanding the syntax if you don't know the concepts.
The right tool for the right job. Non-GC PL for the core and Golang, Python for everything else.
How I would do it: The first character is always the same so you can calculate that before the loops start. BUT if I enter A,B,C,a,b,c that first character has to 'wrap around'. When input - 4 is less than 'a' (lower case input) or less than 'A' (upper case input). Each line, i, has: 1. Some spaces, j, - from 4 down to 0 - looks like you have that right :) followed by... 2. Some characters increasing (from 1 up to 5), followed by... 3. Some characters decreasing (from 4 down to 0) Notice that if you set up the loops for 2. and 3. carefully: * they are basically the same except backwards e.g. the 3rd line will be 1,2,3 and then 2, 1. * the actual character you print is added to the value of the first character you calculated, BUT you need to check if it's greater than 'z' (input is lower) or 'Z' (input is upper.) and act accordingly. 
I disagree. It depends on the use case mostly. In our company, we have tools that parse native source code and analyses it. It also injects native assembly into the source code. Such thing would be impossible with Java, and we simply can't use C because we want the tools to have that OOP architecture to it. So it's like a balance of having something in the middle. 
I believe you would be better served asking on /r/cpp or one of the related subs. That said I believe this should probably get you going: https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
Classic beginner exercises: 1. Write a program to remove comments from C source code, s.t. line numbers are preserved. (optional) Include support for C99 style comments. An edge case that students need to consider is when there is no whitespace between comments and other elements of the code (for instance, a/**/b, post processing, should be a b, not ab). 2. Write a program to perform simple textual substitutions as done by the C preprocessor. For simplicity, you can provide constraints (i.e. - assume no macro name / expansion will be more than N characters, assume that macros are never undef'd, assume that there will never be more than M macros defined). (optional) Provide support for multiline macro expansions using \ 3. Write a program to modify XPM image files without using any library functions. (i.e. - scale an image, change the color scheme, rotate / mirror, etc.) For simplicity, I would advise against asking students to include all of this functionality. You would be better off to pick one for an inclass exercise, and perhaps do the others as homework. I chose the XPM format because, for students in a C programming class, it should be fairly simple to understand and parse through. 
&gt; Java or a much more robust OOP language will be a better career path. Java's OOP model is weaker than C++, and Lisp's CLOS object model is far more powerful than both. Additionally, Java doesn't really allow you to program in pure procedural style, nor allows you to use pointers to functions (this has been recently 'fixed' but it still has a performance overhead). C++ and C does.
This guide is indeed very great! Thanks for mentioning it!
Be careful not to assume that the C way to do something is the optimal way in a C++ program. You mentioned operators and for statements as basics that you want to skip over, but the differences between C and C++ actually start from there. For example, for a custom class that represents a 3D vector, you can define operators such as the following. Vector3d A {0.0, 1.0, 2.0}, B {3.0, 4.0, 5.0} A += B; Whereas in C you would probably define helper functions like that take A and B as parameters. `for` loops can be safer and more generic for classes that offer `begin()` and `end()` iterators. std::vector&lt;int&gt; v; for (auto elem : v) { // Print every element of v std::cout &lt;&lt; elem; } Notice how the above loop works for most containers without modification. It doesn't even rely on the type (use of `auto` for `elem`) as long as an appropriate `operator&lt;&lt;` overload exists. Try to find a resource on modern C++ (at least C++11) and it will probably be worth it to read over the whole thing.
To rectify this will I remove the &amp;?
https://imgur.com/a/mn7oO - first few lines of the input file I have them all defined as doubles
If `O` is a double then you must use `%lf`, not `%d`, in the scanf and printf format strings. Similarly, if `T`, `reh3` and `imh3` are doubles then you must use `%lf` and not `%f` in the format strings.
I really like the following lines from [memcpy](https://github.com/intel/safestringlib/blob/master/safeclib/memcpy_s.c#L145-L149). /* * overlap is undefined behavior, do not allow */ if( ((dp &gt; sp) &amp;&amp; (dp &lt; (sp+smax))) || ((sp &gt; dp) &amp;&amp; (sp &lt; (dp+dmax))) ) { mem_prim_set(dp, dmax, 0); invoke_safe_mem_constraint_handler("memcpy_s: overlap undefined", NULL, ESOVRLP); return RCNEGATE(ESOVRLP); } They try to protect against UB when the two pointers come from the same object, but trigger UB when the two pointers come from different objects. üòÖ 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [intel/safestringlib/.../**memcpy_s.c#L145-L149** (master ‚Üí 77b7728)](https://github.com/intel/safestringlib/blob/77b772849eda2321fb0dca56a321e3939930d7b9/safeclib/memcpy_s.c#L145-L149) ---- 
*C: A Reference Manual* is probably perfect for someone already familiar with C++. It's essentially a guided tour through the specification. And since Guy Steele is one of the authors you know it's good.
Fantastic! The h3.txt is being printed to the screen properly now. Would you be able to help me with the output file for the formula just coming out as a series of 2.000000s?
It was being printed as 2 because you were printing `&amp;H3W` instead of `H3W` 
How about people just don't use the `str` functions incorrectly? These checks should be the caller's responsibility, not the callee's.
Oh bollocks I mis read! I‚Äôll edit my post accordingly. 
You can try playing around with [this](https://gist.github.com/crucialmuzic/0ef52c73f638d808f99f321221de6a74). This is just reading a file from input and delimiting each value via comma and printing the result to stdout. Let me know if that helps you
Thank you, but I've solved it now thanks to jedwardsol!
Okay great, glad to hear that!
C++11 is almost new language will how differently it can be used.
I can verify this claim. Read the ISO standard. Went insane.
Try reading the [Go specification](http://golang.org/ref/spec) for comparison.
You'll probably want to be more consistent with your coding style. From your code: if (a-&gt;size != b-&gt;size) { return (int)a-&gt;size - (int)b-&gt;size; } if (a-&gt;size == 0) return 0; (...) if (n &lt; 0) { return; } Personally I prefer the second style, but as long you pick one and use it consistently, no one can complain.
`lldb` is also an option on macOS or BSD.
&gt; the title should be "Moving for C to C++" No, it should not.
Syntax error: C++ code detected. Please post to /r/cpp_questions instead. There's a good chance that the seg fault is not due to the code you posted, so please include everything when you post to that other sub. In the meantime: `vector&lt;string&gt;` should be passed by const reference. Also: what happens if the loop doesn't find the name you're looking for or if `values` is empty? `values[index+1]` would invoke undefined behavior as `index` is uninitialized.
i included
I included
This is a horrible mix of C and C++. We can't really tell what you're trying to do without the full code but I'll have a go. (i != (values.size() - 1) I assume this is because you never want to return the string in the array. Instead of this, just terminate the for-loop earlier. What happens if you do not find a match (size - 1)? Index is uninitialised and you'll return an undefined number + 1 (i.e. seg fault most likely). I assume FIRST_NAME is a macro, why do you want to return it again? Are you trying to return the index of the first name if it's there or do you really want to return a macro you've already defined? Or are you trying to test if that first name is in that vector of strings? If you're trying to find a name in an array of C strings and you want to return the index, try something like (NB. it won't handle the case of a repeated name): int find_name(char** list, int size, char* name) { for(int i=0; i&lt;(size-1) ;i++) { if(list[i] == name) return i; } return -1; } In C++ you can use std::find in the algorithm header and you can accomplish the same thing on one line.
no im coding in c++
&gt; Putting the type after the variable's name adds absolutely nothing to it's readability It is derived from ML and it is great, prove me wrong. Apostrophes are also derived from ML. Hebrew and Chinese are not bad just because they are different from english. There are a bunch of different PL families beyond C/Algol. What syntax for lifetime parameters would be sane in your opinion?
Hey, thanks so much for such a detailed response! Looks like we agree on a lot of things, and where we don't agree, I can see where you're coming from. Always interesting to see someone else's style.
***Most*** C++ books assume a knowledge of C. *Accelerated C++* is a little dated, but it's a very fast-paced introduction to C++. I'm told that *C++ Primer* is also good, but I've not read it myself. &gt; I was looking for a book which immediately dives into OOP basics. To be quite honest, any of the books that do that are very poor learning resources and end up teaching you very poor C++ style. Forget the OOP for now. Modern C++ uses a lot less of it than it used to anyway.
ok script kiddie tell me moar
There's also sites you use to share code, and then just give us a link.
Open browser console &gt; '1' + 1 &gt;11 Accept cpp internship
haha, An proud script boy... Learning C so I can have the greatness of both "worlds" haha 
Print debugging is indeed a useful technique sometimes, however I would strongly recommend that people take the time to learn more advanced tools. It's easy to insert print statements to inspect things, but that doesn't mean that solving problems this way is easy. There's more of a learning curve to more advanced tools, but they can also provide capabilities that make solving problems easier. Learning to use a debugger also isn't that difficult and a decent benefit can be had from just learning a few easy basics. Learning more advanced features, e.g. breakpoint scripts, can provide correspondingly larger benefits. Debuggers can also be used for more than just debugging; For example scripting the debugger can be a useful way to run some kinds of automated tests. 
`gcc` also allows the use of the `-Og` flag to perform optimizations that do not interfere with debugging.
haha
Please do :-) Thanks!
While `valgrind` is useful, many simple memory errors can be caught with sanitize flags, like `-fsanitize=address` or `-fsanitize=leak`. It is, however, worth noting that the sanitizer has yet to be properly implemented for operating systems running on ARM architectures, with the exception of Android.
Please explain number four in a better way. I don't get it. 
It took 10 years to discover those security problems by security experts. And Intel is a big company, they not only make processors and other kind of hardware but also specialized software. There are some libraries out there that are pure software engineering gems. In the end, all these things involve human interaction, and no matter what we are error prone.
Why are they invoking UB on different objects? They are not dereferencing anything, just doing pointer math.
From Section 6.5.8 of the C11 standard: &gt; When two pointers are compared, the result depends on the relative locations in the address space of the objects pointed to. If two pointers to object types both point to the same object, or both point one past the last element of the same array object, they compare equal. If the objects pointed to are members of the same aggregate object, pointers to structure members declared later compare greater than pointers to members declared earlier in the structure, and pointers to array elements with larger subscript values compare greater than pointers to elements of the same array with lower subscript values. All pointers to members of the same union object compare equal. If the expression P points to an element of an array object and the expression Q points to the last element of the same array object, the pointer expression Q+1 compares greater than P. In all other cases, the behavior is undefined. Basically, historical reasons.
Do note that there is already an excellent production-grade C library called Simple Dynamic Strings ([sds](https://github.com/antirez/sds)). Not the name of your project, but the reddit post title confused me for a sec. One thing I'd recommend with dynamic strings is to store the string [inline with the length](https://github.com/tavianator/bfs/blob/75ad5815156efe50e6a94be3c98a058d93717a89/dstring.c#L27) rather than behind another pointer indirection.
You are right! I think I will do as follow: if (condtion) line; if (condtion) { ... code; ... } else { ... code; ... } ```
Nice to know! I will see if it fits my need! :D Can you explain better with `to store the string inline with the length`? Thanks!
C++ is of topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Have you tried turning on the debugging symbols as suggested below? This is because some line of code is accessing outside of the allocated memory for potentially the values container. Did you load the core dump and take a look at the stack with debug enabled?
So, imagine you have a greyscale picture. Really this is a grid of little squares of various shades of white to black. If we let white be 0 and black be 9 then a medium grey would be 4. So we can pretend our picture is a text file of numbers. Now we can write a program to read in the numbers to an array (needing array definition, and file handling) The array can now be manipulated. To invert the picture you‚Äôd need a function to turn 0 to 9 and 9 to 0. Maybe some modular arithmetic. There might be some loops there too. Or you could rotate the image or something. Then you can output the ‚Äòimage‚Äô back to file by writing a text file of 0 to 9 values using again some file handling. I suppose someone could have some fun displaying the image as a spreadsheet or something. In my day job I do a lot of reading in and manipulating data, and printing it out again. It‚Äôs all model data for me but this is similar and without the science aspect
http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm talks about a wide range of problems with the broader Annex K functionality and ultimately recommends its removal from the C standard. This library is referenced as a woefully incomplete version of this part of the standard. Looking deeper at this library, the only documentation is in the source. Based on that documentation code written against a real Annex K implementation wouldn‚Äôt build against this library and code written against this library wouldn‚Äôt build against a real Annex K implementation. **EPIC FAIL.**
Adding to kloetzl‚Äôs reply, there have been architectures where a pointer is more than a scalar value and therefore what appears to be simple math isn‚Äôt. Highlighting the fact that fields other than a sement identifier have existed in pointers, for the case of a pointer that does have a segment identifier the idea that a pointer in one segment can be greater or less than a pointer in another segment is meaningless.
check your multiplication. 1073741824 * 5 is 5368709120, which still fits in an unsigned integer (it's 0x40000000). But I see your point, and will like to point out that doing optimizations based upon undefined behavior can lead to some rather surprising results: [Why undefined behavior may call a never-called function](https://kristerw.blogspot.com/2017/09/why-undefined-behavior-may-call-never.html) and [the followup post](https://kristerw.blogspot.se/2017/09/follow-up-on-why-undefined-behavior-may.html). 
This is what I'm saying though - these checks should not be done every time a string function is called. When some kind of trust boundary crossing or initialization happens, the programmer should ensure their strings are in these valid states, and they should forever maintain these as invariants. If they can't do that, there is something very wrong with their code.
&gt; So get to know better the tools used by a specific PL is more important than learning another PL basics. Exactly. &gt; Do are all Java tools proprietary and require a license to use? I'm not sure. There was a kerfluffle about Java licenses a few years ago but it doesn't matter for my purposes.
Tell me more about debugger scripts.
When it comes to gcc, compiling without optimization can actually suppress useful warnings (you're using `-Wall -Wextra` like you should be, right?), as well as producing horrible code. I suggest almost always using `-O` or `-Og`. Compiling with `-fsanitize=undefined` is useful in testing too. 
Also, gcc-specific functions for detecting overflow in integer arithmetic: https://gcc.gnu.org/onlinedocs/gcc-7.3.0/gcc/Integer-Overflow-Builtins.html
What exactly are you trying to achieve?
C culture blindly assumes a pointer is all that is necessary to identify a string and there are far too many cases in large systems where you have source and destination pointers with no idea how long either underlying array is and if someone increases the length of a source string 30 levels above you in the call stack they‚Äôre never going to know that something is going to be blown out that far away. It‚Äôs wrong, but it‚Äôs how much C is written. The reason these newer functions don‚Äôt work in practice is because even when the lengths are available people still can‚Äôt pass the right parameters. Again, it‚Äôs a cultural thing. Decades of exploits have been built on these very errors.
`-fsanitize=undefined` does literally this.
C++ still uses the procedural concept of C, whereas Java operates purely on the object model. The common (old?) saying is C++ is C with some OO bolted to it. Java is from the ground up OO. To say that Java has a WEAKER OO model is really baffling. It was written to address the weaknesses of C++ and cement the OO paradigm into the language. 
Then you are clearly not using an OO approach, but a hybrid one. java's strength is that everything is operated on as a class. C++ uses its C roots to give you a procedural language with OO components. Also once you inject assembly you're breaking the java paradigm of run everywhere. So really your company could not use an OO language to its full extent. 
As this sub is for C and not C++, you might find /r/cpp_questions a better place to ask this.
&gt;Java is from the ground up OO. int vs Int and other built-in immediate types vs objects, disagree. No, it is not, and this was one of the early criticisms of the language. Built-in types are passed by value, objects by reference. Any good java 101 course teaches this. Smalltalk, for example, is truly OOP from the ground: everything is an object. Note that Java has good things as well: the bytecode delivery, the very fast VM, modularity, etc. &gt;To say that Java has a WEAKER OO model is really baffling. It does. Weaker as in "less power". In C++, one has m√∫ltiple inheritance, just to put an example. Another example: it doesn't support operator overloading at all.
&gt; http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm I am not sure what those guys have been smoking either: &gt; As a simple example consider the following function. Astute readers will notice that the function is correct and safe and, provided the str argument is a valid pointer to a string, cannot result in a buffer overflow. char* string_dup (const char *str) { char *dup = (char*)malloc (strlen (str) + 1); if (dup) strcpy (dup, str); return str; } As I am super astute, I notice the function is soooo correct that it doesn't even bother to return the duplicated string... :-D Thank you, RedHat top engineers :-)
C is a much simpler language than C++, be ready to roll your own algorithms and data structures though. That's why I recommend two books K&amp;R and Mastering Algorithms in C
I did it the other way (moved from C++ to C) ... never looked back. Every time I have to code something in C++ I'm always amazed at how elegant C really is and I'm reminded how much I love and prefer C over C++. Just my 2¬¢, anyway.
Here's an example using breakpoint scripts: https://lldb.llvm.org/scripting.html First the debugger is used to brute force a particular solution (a path through a recursive data structure) and then a breakpoint in a recursive algorithm is set with a script that checks if the recursive algorithm is going down the right path, so that the breakpoint will trigger at exactly the point in the recursion where the algorithm goes the wrong way. It definitely takes more setup than simpler usage, but I've done debugging where I've had to walk through large recursive data structures and done so using hit counts and manual checking, and doing that with a lot of data can be real tedious. Sometimes taking the extra initial time can have a big payoff, and it's worth having those tools in your tool chest. For scripting the debugger for other purposes, I don't have any handy links. If a debugger is a command line program you can just use redirected IO. E.g. `diff &lt;(gdb &lt; test1.txt) expected_output.txt`. So one example of a test that might be easiest to implement this way is to load up a shared library and use debugger commands to verify the library interface's ABI, like that a particular struct returned from some API has a particular memory layout.
Wake me when you can beat a single executable built in such a way that 20 unique ‚Äúglobal‚Äù instances of this same broken function coexist! This kind of thing hasn‚Äôt made me blind yet but I have the cynicism of a 600 year old man.
Neat, I'm looking forward to checking it out! Is it online somewhere?
It depends on your architecture, of course, but I find it unlikely that `unsigned int *` would be a string type. `char *` would definitely, though. Pointers can be thought of in two ways, either as a reference to a point in memory, or as an array. I suppose you think of them as references in this case and thus a pointer to an unsigned int can as well point to a string. You should be thinking of them as arrays here. If Format is a char array then Format[0]='h', Format[1]='e' and so on, while if it‚Äôs an unsigned int array then Format[0]=(whatever ‚Äúhell‚Äù equals as an int), Format[1]=(whatever ‚Äúo wo‚Äù equals as an int) and so on... Edit: rereading your post I realize you probably know all this already. Thing is, printf and gcc probably does not know about 32bit unicode code points. Printf formating expects an 8bit character string. 
The attribute should go with the function prototype in a header file, btw, so that gcc and clang can give feedback at point of use, and not at the definition. And it only works with `char *` strings. *Maybe* it might with `wchar_t *` too, but the docs don't say anything about it specifically.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
For the future, please try to be a bit more civil. I do understand your sentiment, though.
Sorry, I was just remembering a system I worked on with 20 identical broken copies of a particular str\* function in the same process which was not in a theoretical example as the string_dup function but in shipping code everyone here was likely dependent upon at one time or another. It‚Äôs among the smallest of the rediculous I‚Äôve seen but it struck me at the time...
"less power" is not really a metric. Use the language that accomplishes the task. Java's automatic garbage collection and threading vs C++ manual destructors and having to 'free' memory is a huge hindrance. C++ breaks the OO model by allowing procedural programming because it still brings a lot of C with it. Operator overloading is not a huge deal... you can write a class to deal with it. Multiple inheritance is supported in Java 1.8 
A small critique: never, ever use floats, unless you are trying to save on space and need it greatly and can afford the loss in precision. There is absolutely no reason for you to take a float const as the scaling factor. Firstly, C is pass by value, so the const means nothing. Secondly, the parameter takes up negligible amount of space without inlining. With inlining, it probably won't even end up on the stack.
This subreddit is meant to discuss the C programming language. Check out r/cpp_questions. But also: 1. No. GUI apps take a significant knowledge of the language and the APIs involved. 5 months would be kinda fast. 2. Go for it. Generally speaking Java is higher level than C++, and typically better used for server-side applications. Java, like any language, can be used for anything (Minecraft was written in Java until Microsoft decided to switch it to C++), but I think it's better to use C++ for client-side things. Bear in mind, I'm biased, as I hate Java. 3. There are a number of GUI API options, like [GTK+](https://www.gtk.org/), or [qt](https://www.qt.io/). For games, check out [OpenGL](https://www.opengl.org/), or [Vulkan](https://www.khronos.org/vulkan/) if you want to write your engine from scratch. Otherwise, you may want to check out [Unreal Engine](https://www.unrealengine.com/en-US/what-is-unreal-engine-4) or [SDL](https://www.libsdl.org/). Bear in mind there are all manner of other options, these are just what I would use. Good luck, have fun, and keep C in mind for future projects. We're happy to help, and in my opinion Entity-Component systems (commonly used in game dev) are better written in C. 
Thanks for the comment. Really appreciate it ! Just started to learn Java 5 mins ago, it kinda looks like c++, much easier than expected. I guess that's just the beginning :)
Pick one language and stick with it for a good while. Chopping and changing will just confuse you between the differing behaviours and syntax of each language.
&gt; unless you are trying to save on space To save on space *and speed*: depending on the operation and CPU, float and double will have same speed, or float will be faster, or float will allow more parallel calculations at the same time.
1) Do you really think that the prefix "linear algebra" and the suffix "test" in the names of the files in the "tests" directory of the library named "portable linear algebra" add something more than redundancy and noise? 2) yet another linear algebra library. It can certainly be fun and educational, but is there any reason for other people to check it or use it? Have you tried evaluating it against well known and used libraries?
C++ is off topic in this subreddit. Please ask C++ questions in /r/cpp_questions.
I suppose I should have prefaced with the intent of the system. I'm trying to make a general purpose, C, linear algebra header. But yes, the floats aren't optimal for calculations but the issue is portability. As /u/gnx76 pointed out, this depends on the operating system and I initially wrote this for a 32 bit system with optimizations for float calculations. It can also be used for front end applications with minimal memory usage. In this case, floats are the least common denominator for usage. I could add a double extension. As for passing a float as const for the scaling factor, thanks for pointing that out! I didn't realize I did that. What are your thoughts on the const arrays? I typically write C++, so I'm not certain of C conventions. I assume const is preferred typically. 
1) I generally followed my common naming. This was originally mangled with another library I was working on. I'm definitely open to suggestions. 2) I searched endlessly for a clean Linear Algebra library in C. All fell well short of my needs. There is clearly an abundance of high performance libs in C but they are all processor specific or require a ton of overhead. The lib I built this off of ( [datenwolf's](https://github.com/datenwolf/linmath.h) ) was nearly ideal for my needs. It was hardware independent, header only, and had a nice license. The only problem was column major ordering, a lack of testing, and missing types. So I built my own, and now it's free for anyone who'd like to use it for whatever purpose. I'm quite open to collaboration as well. EDIT: Also, I intentionally avoided heap allocation for MISRA compliance. I had some difficulty finding other libs that did this as well. 
Recall that `i++` increments the pointer, not the pointee. You want `(*i)++` and `(*j)++` instead. Though I really wonder why you pass these as pointers in the first place. 
Your bug is here for(*i=0;*i&lt;9;i++) What are each of the 3 terms doing? 
My apologies then for not reading too much into your project's intentions. So long as you are aware of the associated tradeoffs, I can't comlain about your usage. Most often, floats are misused, so I just wanted to point out that it may have been in error. As for the other point, everything in C uses pass by value semantics. The only times where it makes sense to use const in a function prototype are where you have are passing in a pointer, and want to designate what you will and will not change. For instance, consider int f(int * const * ppi); Here, I am promising that f will not modify \*ppi, since it is const. However, since \*ppi is a pointer to a nonconst int, it is fine for me to modify the value of \*\*ppi. This isn't terribly strict, as you can just cast away an const. However, it is part of a contract between you and the users of your api, which you should ideally honor. If you don't, document it appropriately. An equivalent function prototype would be int f(int * const * const ppi); However, since we never get ppi, but rather a copy of its value, we couldn't change it anyway. Now, this *is* fine to do, as a tool for maintainers, to ensure that the value of ppi never changes throughout the function body (once again, you can still ignore this, but at that point, you either know what you are doing, or are trying to shoot yourself in the foot). For simple 3-4 line functions where the value is only used once or twice, though, this safeguard isn't really necessary, and just adds clutter. Additionally, seeing as how you come from a C++ background, you're probably tempted to put in const, since that is idiomatic for C++ pass by reference calls, like int g(const vector&lt;int&gt;&amp; i);
&gt; Though I really wonder why you pass these as pointers in the first place. He gets the coordinates of the found BLANK out of the function this way.
Great explanation, and yes my C++ autopilot took over. I'll fix that as well. 
The attribute syntax is unsettlingly fluid. You can generally put the attribute before the function (useful if you‚Äôre defining it in-place), but the most compatble, most correct place seems to be at the end of a declaration (not definition) before the semicolon. Newer versions of GCC/Clang support attributes in more places. In the texinfo docs for gcc post-4.8, search "Attribute Syntax‚Äù and you should find a page with nauseating detail on the syntax. AFAICT you‚Äôre not going to be able to use `attribute((format))` for this case. The closest thing to your `UTF32 *` format string would be something like a `wchar_t *` argument to `wprintf`, and that‚Äôs declared like this in the GNU headers: extern int wprintf (const wchar_t *__restrict __format, ...) /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */; So it looks like they have it ready to add that attribute should the compiler eventually support it, but the compiler doesn‚Äôt support it yet.
You apparently have no experiences with deep learning libraries. Almost every one of them uses floats because with vectorization/GPU/FPGA, floats are twice as fast to process as doubles.
You should [change the loop order](https://stackoverflow.com/questions/7395556/why-does-the-order-of-loops-in-a-matrix-multiply-algorithm-affect-performance) in matrix multiplication. For large matrices, this simple change will dramatically improve performance due to fewer cache misses.
It is but it's not done yet, my username here is my username on Github, the project is currently called BitIO tho I'm in the process of renaming it to FoundationIO.
Still, this is intended for use on embedded systems (hence, why the OP aimed for MISRA compliance). Admittedly, I'm still a student, and don't have much experience in industry, but I'm not certain that there are too many embedded systems out there committed to deep learning calculations - that sounds to me like a job for a dedicated machine. 
High-end ARM comes with NEON, which is used in most smartphones nowadays. Admittedly I don't know how widely it is available in embedded systems, but if I wanted to do serious linear algebra (not limited to deep learning), I would certainly take the advantage of that.
Speaking from work in hardware security, thank you. It's fun stuff, but, like other defensive angled security, really really frustrating at times.
Hey, thanks for the reply! You make some good points. Regarding #1 - It's funny you should bring up this point, because I've been really debating whether or not to add the stipulation "Use Function_Style naming conventions with function pointer variables". Do you think that would be a good choice? Regarding #2 - I'm in the same boat where I don't see my code needing to run on a system without a (mostly) C99 compliant compiler. I usually feel safe adopting C99 features as they're implemented by MSVC, which currently supports // comments. That being said, I never see myself using some C99 features, such as variable-length stack-allocated arrays (how did that even get into the standard?). As for #3 - I don't use split-screen when editing enough for this to be a QoL improvement to me. Maybe I should try it for a while and see how it effects my productivity?
And the fact is, unicode is typically encoded by UTF-8, which is an eight-bit format.
Exactly. It does not even need to be a deep learning application. I've worked in a research company which developed several scientific applications, and I remember a presentation on single vs double precision. The conclusion was that the user has to really evaluate whether or not it's necessary to use double precision, and that many applications such as some iterative algorithms did not need them really.
Embedded processors either * have no hardware double support at all (or doubles are emulated), therefore doubles are much slower than floats ; * have instructions slower for doubles than for floats (I mean, even on top Intel x86, last time I checked, a complex operation like division was a bit slower for doubles than for floats, and the difference gets stronger and more widespread as you move towards CPUs where cost optimisation, power optimisation, size optimisation matter more and more)
&gt; As /u/gnx76 pointed out, this depends on the operating system Not the operating system, but the operation : which instruction (addition/multiplication/division/...) from which instruction set (FPU, MMX, SSE, other architectures...) :-)
thanks! please do bare in mind the instruction set is *very* much simpler than ARM... (which is the whole attraction)
True, ARM isn't too bad though. I think this would be a fun project to do as well! 
1) I find this kind of duplication to hinder readability and not convenient for typing. It's your library of course! 2) All the libraries I can think of work on a number of platforms (usually they only require standard c compilers) and they may be optimized for specific CPUs but that obviously doesn't mean they are required. I do not see why header only can be a requirement. Testing can be very tricky and - no offence - chances are your testing is at best as good as that of Blas, imkl, armadillo,etc. I hope I am not misunderstood, I am asking out of genuine interest. I know about a number of libraries,I usually use 2-4 of them but I am always open to new ones.
Thanks for the tip. This is definitely faster for larger matrixes. The tipping point seems to be a 6x6 matrix. Less than that, and this is a bit slower. Which makes sense, due to the inline zeroing of the result that the original method provides. I'll add this as an optimization.
I've changed the names of the test files. They were a bit redundant. Since this is a side project, I often don't notice these things. The closest I got to a lib that could work for me was linmath.h or CBLAS. In c++ I use Eigen and armadillo. Though I was open to armadillo, It is C++ based and I was requested not to use anything c++ for this project. Can you use IMKL on ARM? If not, that's a deal breaker. A single header makes it much easier to port this lib into multiple environments and builds. There is much less overhead. For an example, my project at work was running on a micro with a RTOS, Linux, in a frontend client, and on my dev machine. It's just easier to have the flexibility of a single header than another lib to port. 
Please format code by place 4 spaces on each line before it. There's enough here you may want to use [pastebin](https://pastebin.com). I haven't looked through your code but adding a 50/50 chance of the human playing first should be as simple as generating a random number and seeing whether it's odd or even with modular division by 2.
What are you using for the GUI? I am thinking about a similar project and the most accessible interface would be a web page, with client-side javascript, so the users won't have to install anything to use it.
Not sure what you are trying to accomplish, here are some options: + [zeromq](http://zeromq.org/) + [libuv](https://github.com/libuv/libuv) + [libevent](http://libevent.org/) + [gobject &amp; GIO](https://developer.gnome.org/gio/stable/GSocket.html) + [libsocket](http://dermesser.github.io/libsocket/doc/libsocket/DOCUMENTATION.html) 
There are GUI wrappers for gdb that might make it less tedious. I think ddd is one. 
I agree, a web app would be more practical. He can use cimgui &amp; SDL2 then he can compile it to either asm.js with emscripten, or as a regular desktop program.
If the line wraps on 80 columns then you're doing it wrong
NEON was an alternative for me on the MCU. But, this will be run in multiple environments so I couldn't take advantage of their lib.
a lot of coding standards, including googles, specify 80 character limits https://google.github.io/styleguide/cppguide.html 
Thanks. 
I thought a out this too, there's also * VisUAL, a highly visual ARM simulator (Java) and * smz32 in Delphi for older Windows versions, but with a rather simple-yet-good UI.
Hm, it seems that in virt.c you never close the file you opened in void fileInput( char *fileInputName) and I don't really see any comments except the block at the top. You should also definitely put in a proper readme if you want to keep this on your github to make your github look appealing.
You're right; I wrote this initally during exams season so it doesn't have any of the polish that it deserves.
https://www.kernel.org/doc/html/v4.10/process/coding-style.html
See also [this fork of linmath by BlackDoomer](https://www.gamedev.net/forums/topic/685839-linmathh-a-lean-c99-library-for-linear-math-aimed-at-graphics-programming/) which has some similar goals
Dat warp jump though. 
You have to cast it because server_addr is a different kind of struct than a sockaddr -- probably a sockaddr_in, sockaddr_in6 or sockaddr_un. All of which have a sockaddr as their first element, plus family specific stuff afterwards. It's a way to get polymorphism in a language that doesn't natively support it. 
What kind of RPC? There's lots of protocols. Sun, XML-RPC, SOAP, JSON-RPC, etc....
this is exactly what I thought because casting void* is reasonable for implementing polymorphism in c but casting an argument doesn't gives you anything, as you are just sending the starting offset of the arg
casting void* is reasonable for implementing polymorphism in c but casting an argument doesn't gives you anything, as you are just sending the starting offset of the arg 
Using a void pointer implies the function can take *anything* as the address, which simply isn't the case. See https://beej.us/guide/bgnet/html/multi/ipstructsdata.html#structs for more detail on sockaddr specializations.
Please don't post these.
It's a constraint violation to not cast it correctly. Some compilers "only" write a warning message for this error, and proceed as if you had written the cast.
This is a horrible hack in the design of `bind`. Effectively it is a single function name implementing what nowadays whould be designed as separate function calls. * If you are doing `bind(AF_UNIX` then the in-parameter should be a `sockaddr_un`. * If you are doing `bind(AF_INET` then the in-parameter should be a `sockaddr_in` * If you are doing `bind(AF_INET6` then the in-parameter should be a `sockadder_in6` and there are other possibilities too. The C function prototype system doesn't allow having the parameter type vary based on the value of an earlier argument, so they decided to make you cast the argument to some fixed type, and inside the `bind` function implementation, it will do an `if` branch based on the first argument, and each branch will perform a different reverse conversion to get back the actual struct you passed. It could equally well have been `void *` or `uintptr_t or any other argument type chosen, instead of `sockaddr_in`, the only actual property it needs is to cast back to the real value. 
You can also open the file for appending to safely append to the end of the file.
Have you tried reading the documentation provided by your vendor? If you don't understand some part of the documentation, we can help you with that, but please try to read it first.
i just saw a clock () function ,which reading algorithm ,so i got confused and decided to ask.
i have asked someone and get to know that clock function is just the clocks cycles that algorithm is using in worst case scenario, am I right ?
It is not the worst case scenario, it is how much time it used in each instance the segment run. You might also want to research what clock cycle, clock speed and cpu time exactly mean as they all refer to the same thing but have slight differences.
If you want to do RPC over HTTP look at SOAP.
If I want to send c structures as argument to the remote procedure and receive as a return value a c structure, SOAP isnt the technology for that, am I right? 
That sums up what I was going to say after figuring out my mistake. I read the title initially as "Moving from C++ to C" and thought there was hope, but I quickly become disappointed after I had read the post. I was under the impression most people moved from say, alcoholism, to C++.
https://linux.die.net/man/3/clock
I'm using gtk3 (via glade) but to be honest I'm thinking of just going OpenGL as its likely to be much faster especially if I want a 160x120 matrix of 4x4 "dots" as I can probably handle all the rendering with a shader (glUniform*v to transfer the memory map to the shader) A web app is going to be way to slow for what I want to do...
Soap is a way of serializing any data structure to xml in http and deserializing back. JSON virtually replaced this as it‚Äôs more efficient. If you are dealing with local processes you may want to look at IPC. If this is remote systems then you don‚Äôt need soap or Json. You could build a socket client server using tcp or udp and send your data in binary. http sucks because it‚Äôs base64 so this may be somewhat of a limiter
For the life of me, I don't understand why they didn't just change the definition of `sockaddr` to be larger. Maybe there's some history or a technical reason in that decision that I'm just not understanding. Well... hmm... I hadn't ever though of this until just now, but I guess technically it would create some binary incompatibility. Executables compiled with an older definition would allocate less space for their `sockaddr` than ones compiled for a newer definition. But that's fine, because older ones (e.g. ones compiled before the existence of IPv6) wouldn't ever *need* the larger storage. They should only ever be setting a `family` that indicates a size equal to or smaller than the amount of space they actually allocated for their small `sockaddr`, and as such, `bind()` and other socket APIs would only ever read that amount of space, and would never read into the additional space of the larger `sockaddr` that they know about; there's no undefined behavior or reading memory that might not exist if you never read it. So no, I still don't see a problem with that; it still seems like the right solution. I guess it doesn't eliminate the need to cast; the only way around that is with a union. But if they're not going to make `sockaddr` itself a union of all possible families allowed on a system, then the next best answer IMO would have been to make `sockaddr` big enough hold anything, rather than leaving it unchanged and adding `sockaddr_storage` for that purpose.
thank you very much
Well yes, but I assumed OP was interested in _reading_ the file, not _writing_ it.
Good find. I appreciate his row and column support. 
On a pedantic note, the optional type uintptr_t is not guaranteed by the language standard to be compatible with an actual pointer even if it does ‚Äúhappen‚Äù to work on some systems.
There is no single RPC protocol or technology, any more than there is one ‚Äúsubroutine‚Äù protocol or technology. A normal RPC involves - Registration of available procedures with the service. You can do this by using a predefined/preconfigured set of procedures, auto-configuring them from an available set of interfaces (e.g., load plugins from DLLs and see what they give you), or running some init code that explicitly registers specfic things. - Some means of the client finding/connecting to the service. Usually this is just a TCP socket from client to service, but there are other discovery and distribution methods available also. - Some means of the client sending a procedure call request, usually along with serialized arguments. The serialization is thoroughly tedious and error-prone at scale, and there are cross-platform issues things like alignment/packing and byte order to consider. It‚Äôs pretty common to have some preprocessing/autogen layer that makes wrappers to do that for you‚Äîi.e., call the client wrapper to serialize, send request, and wait; service will deserialize and call the server-side wrapper to make the [local] call. - Some means of the client retrieving a procedure call response, usually along with a serialized return value or exception. Generally this uses a flipped version of the client-to-server serialization/deser.‚Äîserialize the return from the wrapped server call and respond, then the client will deserialize and return from its wrapper. Things like out arguments (e.g., `struct foo *out`), localization (e.g., relative to whose time zone should time/date strings be formatted? with what character encoding?), and optimizations (e.g., must the client always wait for a response? if they‚Äôre asking to perform zero actions, can‚Äôt the client just do nothing on its own? should it be possible for the client to do complex interactions on the server side before returning, like `return rpcQueue-&gt;isEmpty() ? rpcQueue-&gt;pop() : NULL`? can some things be reordered, distributed, or parallelized?) get into more complicated problems.
This isn't C and doesn't belong here. 
There is a c library that does all the above? If there is, does it have any documentation? Thanks
This subreddit is about programming in C. Please post questions in whatever programming language this is to the language appropriate subreddit.
I meant the function on line 565 : void match_dna_data(uint8_t *str1, uint8_t* str2, uint32_t offset1, uint32_t offset2, uint64_t length, match_counts *score)
I imagine that it matches dna data. Use backticks (\`) to mark inline code so Reddit doesn't mangle it.
Wow. Not a single comment to explain why this and this nibbles are used... Actually, not a single comment anywhere, despite the fact that he handles bytes and nibbles, and not structure fields with proper descriptive names that could help a bit in the absence of comments. I pissed myself laughing when I searched what `match_data_bytes()` was doing and found this beauty in [case.c](https://raw.githubusercontent.com/TonyNazzal/Open-DNA-Search/55b555e5b957e7bc84a828209d5e59259563d078/case.c). The function is over 3 million characters long... It is a `switch` on a 16-bit value, with a `case` for each value (said otherwise, a 64k x 8 ROM). 
That is in a old test function. **Not being used** anymore in the program if you look line 241 "string_list_t *expand_string" :) The main program has never segfaulted on me in its current state.
I really hope he didn't write that by hand.
Have you learned about while loops yet? Might want to take a look at them to solve this problem.
One loop for counting how many number, variables that hold the values of entered numbers and sum = 0 so you can calculate the average. What exactly is the thing you are having problem with?
My problem is that i don't know what variables should be involved with the loop
To post code, just put four spaces before each line. Check the formatting help to learn this. It makes it hard to read and for people to help you otherwise.To post code, just put four spaces before each line. Check the formatting help to learn this. It makes it hard to read and for people to help you otherwise. You want to compute an average, so how do you do that? Divide the sum of things by the number of things. So how many variables are involved in a mean? You want to compute an average, so how do you do that? Divide the sum of things by the number of things. So how many variables are involved in doing that?
To take the last digit u can do ID %10 . To take the first one u can do a while(ID&gt;0) x= ID %10 and ID=ID/10
Ok I fixed it so you might understand. Im restricted to inputtign four variables. 
You need to solve the logic problem before you try programming it. If you can't put into words what you need to program, you are going to have a really tough time.
 int id = scanf(); int d1 = id % 10; int d2 = (id/10)%10; int d3 = (id/100)%10; int d4 = (id/1000)%10; int sum = (d1+d2+d3+d4); if((sum%2)==1)floor = sum; else if(d4==d1)floor = 1;else if(d4&gt;d1)floor = d4-d2; else floor = d1-d4; I inserted a bug in the code above on purpose. See if you can find it. Good luck :)
I think you're misunderstanding the restriction. 
Often I'll use macros for that, and define them all in a hardware-specific header file. Macros don't add any extra memory or processing overhead at runtime.
Yup, this question is bad and should feel bad.
The Q already qualified the address, but yes it should have also stated to assume adjacent-in-order-of-declaration with sizeof(int) alignment
Here is the solution for your first problem: #include &lt;iostream&gt; using namespace std; int main() { int x = 1, max = 20, min = 10, count = 0; while(x){ cout &lt;&lt; "Enter your number (enter 0 to end)"; cin &gt;&gt; x; if (x &gt;= 10 &amp;&amp; x &lt;= 20) { count++; } } cout &lt;&lt; "The answer is " &lt;&lt; count &lt;&lt; endl; return 0; } This is kind of a simple problem, read the book/tutorial again **not to understand this specific problem, but to learn the "spirit" of programming**. Start with some simpler problem like, enter 2 numbers then do the sum, etc. Best of luck.
What does the variable "mem" represent? And what do you return if you don't return B or C? I confess I have not yet read the other post enough to understand what you are trying to do.
mem is a global variable used by the function to give it a hint as to which function it should be writing. I've been struggling to use inverse sine functions and modulo's to detect what I should be doing when the function is called, so I've been using mem to better wrap my head around this. I've updated my post with a screenshot of what it does and what I roughly want it to do. 
So you want your logic to be something like "return the value of B until B drops to 0, then return C until C gets back to 0, then go back to B, etc"?
Exactly. 
In what way? The only thing I see is that when you flip mem, you should return the other value right there...so return C in the first part and return B in the second part. Do you want mem to start at 1, not 0? Also for clarity I would set mem explicitly to 0 or 1, don't use ! there.
When the function is https://pastebin.com/AFc5SR72, the output is https://imgur.com/a/A2Trs (top is roughly what I want, bottom is the actual output). 
It looks like the problem is that C is also positive in that range (the first zig-zaggy one), so your are flipping between a positive C and a negative B each time. Do you expect C to be negative there? Or do you just want to return something like -(abs(C)) until it crosses 0 again?
Yes, in the first part B is positive so it works. Then B goes negative, but it looks like C is positive at that point. So it prints a C value, then flips mem to 1, next time it prints a B value, flips mem to 0, etc. You can see in the positive values it is following the C-shaped curve and in the negative values it is following the B-shaped curve. I don't know what input values you are passing, so as I said I don't know if you expect C to be positive or negative there.
This is the full thing here: https://pastebin.com/5iqfeneX Sorry for not sending this sooner, I assumed you knew what I was passing to the function. I then take stdout and pipe come data to a file, I then import it to audacity to get the images.
Were you using PSoC Creator?
This sub is for C, not C++, so your question is better suited to /r/cpp_questions.
IF all you want to do is graph half a B cycle in the positive range and then half a C cycle in the negative range, do something like this in your outer loop: double result = 0.0; uint64_t i = 0; do { result = Peicewise(i, 0.25, 440, 8000); printf("%c", (char)(127*result) ); i++; } while (result &gt;= 0.0); i = 0; do { result = - Peicewise(i, 1.0, 440, 8000); printf("%c", (char)(127*result) ); i++ } while (result &gt;= 0.0); Although I'm not sure why you are converting the result to a char before printing it.
I'm converting it to a char so it can easily be graphed in audacity. The point of the function in the first place is to be able to output B in the positive and C in the negative. It's all supposed to be done in a single function. I'm going to have to rethink how to do all of this. I honestly didn't even think about values that are not 1/n, because I figured things would fall into place. 
What happens when you convert a negative number to a char? Well, I guess it works, since your charts look right. If you always want to deal with 1/n, then don't pass in shape as a double, pass in n as an integer and convert it to 1/n inside the function. But you still have to deal with n being even, so C goes positive when B does; and then B not being back at 0 when C gets there. I agree this is not obvious. You have to figure out the length of the "B when positive, C when negative" cycle, and then if your input value is higher than that, you first take the input value module that magic cycle length, calculate the output value, and then add back on the part you moduloed off.
chars are just signed integers, so converting a negative number to char works just fine as long as the absolute value of the function isn't greater than 1. I need to take a break from this function before I rewrite it. Thank you so much for the help!
C++ is off topic in this subreddit. Do not post C++ questions.
is the scanf format string prefixed ? `scanf("%1d%1d%1d%1d",&amp;a,&amp;b,&amp;c,&amp;d)` 
try putting your example in pseudo code: Query number Ask for continue if continue go to start else calculate average how would you calculate the average average=total/count how would you get `total` and `count` ?
As well as the ways suggested, you could also scanf it in to a char array and convert the ascii chars to integers very simply, e.g. char *c, buffer[5]; int id[4]; scanf("%4s", buffer); for (c = buffer, i=0; *c != '\0' &amp;&amp; i &lt; 4; i++, c++) id[i] = *c - '0'; Also the first example is wrong. The sum of 9999 is 4x9 which is 36. 36 is even, and the first and last digits are the same, so the floor is 1, not 36.
let's try to go line by line (but this a wery wierd question) int main(){ int x = 3, y = 7; // nothing out of the ordinary so far int *p = &amp;x; // create pointer p and points it to value held by x int *q = &amp;y; // create pointer q and point it to value held by y int a[3] = {2, 4, 5}; // create array with these values // we have these objects in memory *q += 2; // increment the value q points to by two (y is now 9) q = p; // q now points to the same thing p points to (x) p++; // EXTREME SILLY ALERT; increment p by one (pointing one address over x) *p -= 1; // decrement whatever value p points to by one (this is stupid/dangerous behaviour the computer is now free to launch bats out of the cd drive) // y is now 9, q points to x and p is being very silly q = &amp;a[1]; // q now points to index 1 in a (the value 4) p = q++; // p now pints one index above q (index 2 in a or value 5) *p = 6; // the value pointed to by p is now 6 (meaning a[2] = 6) *q = 10; // the value pointed to by 1 is now 10 (meaning a[1] = 10) // can't be arsed to write the print statements since their output is unpredictable (you have no controll over what memory addreses things get put in) } I hope this was helpful but it is a silly question
Macros are the way to go here, they're expanded at compile time so no performance loss.
Yes, PSOC Creator, but I'm trying to decouple my libraries from their generated function names.
I'll give that a shot since I'm working with 4k of RAM and 48MHz. I *think* the IDE is smart enough to deal with the macros pre-compile so it isn't throwing up warning indicators all over the place.
So many people here willing to help you and tutor you on how to solve this and no engagement from you. Are you just looking for the full solution? Don‚Äôt you think engaging some of these folks would be helpful to you?
I have some bioinformatician friends who may be interested in seeing this, and maybe get a laugh out of it, but I was hoping you could answer some questions for me before I forward this to them. Is this intentionally designed to be obfuscated? Or did you write it, find it years later, and decide to share it because you found it difficult to read? Assuming you made this for DNA sequencing, and not for shits and grins, what manner of research did/do you use it for? Does anyone else use it that you know of? Are there measurable benefits to using nibbles? Is the trade-off of memory saved worth the cycles for alignment? Why not use bit fields like u/gnx76 suggests? Why the switch in case.c? Are the gains of using a lookup table significant enough to forego using the algorithm that generated the switch for on-the-fly calculation? Regarding `match_dna_data()`, I'm struggling to find a purpose for `offs1` and `offs2` when you could just use `offset1` and `offset2` respectively. Am I missing something? Sorry if any of these are stupid questions. I haven't read all of the source, and since there's little documentation and at least some parts of it seem to be hard to grok I don't see myself wading in anytime soon. Thanks in advance.
&gt; Red Hat haha 4kk
yes, this will work. the and comparison operator is garenteed to give you a 1 or 0. each comparison will only add to the total if it is true. doing all the checks on the same line will make your code hard to read though, you should split it up into multiple lines, maybe even use a loop to iterate over the neighbors.
I think you got the `q=p++` line wrong?
good catch, I wrote this in a bit of a hurry.
This for a class project and we haven‚Äôt really touched on function pointers yet (it was made so that they weren‚Äôt required). However, I am also retaking this class and have dealt with them and sort of know how they work, but am still a bit rusty. I‚Äôm sure I could totally go with this approach, but I‚Äôd have to check with my professor. Worst case is I‚Äôll have to stick with the messy version, but at least I know that would work. If I understood all of what you said correctly, you‚Äôre saying to essentially make a new function that will determine the count for burning and will use a function pointer to the function that determines validity? I‚Äôm sorry, I‚Äôm not sure I‚Äôm picking up what you‚Äôre putting down. I think the use of a function pointer is kind of throwing me off a bit. 
Alright, thanks for verifying that! I‚Äôll definitely look into the suggestions. I‚Äôd have to check that they would be acceptable, because this is for a class assignment (some of what‚Äôs suggested hasn‚Äôt been covered yet and they can be pretty strict with that sort of stuff because they don‚Äôt expect us to need to use it or even want us to just figure it out without using it). 
This is probably an option I may end up with since as I said in my other comments, this is for an assignment and I may not be allowed to use function pointers as they were suggested. Thank you for the suggestion!
Thank you for your help! I changed the typo'd 'greater than' and replaced it and removed the '5' in courseList[5] in my header and student and it worked. I dont understand why the dubugger in CLion is still showing only the first struct when the array is passed into the function though. 
Oh. Yes. I also removed that. That makes a lot of sense. Thank you for all of the help. 
All of those are good suggestions, with their own advantages and disadvantages. Function pointers should probably be avoided unless you need to dynamically install or change functions at runtime. For small microcontrollers they're especially bad because they will take up additional space and add a bit of calling overhead. Wrapper functions are fine, and sometimes they're necessary to translate between your preferred API and the API of whatever library you're using. If they can be inlined, then they will have minimal or no performance impact (depending on the work they do), and might take up no space. Macros aren't as flexible, but they're guaranteed to have the best performance. If they're just used to change the name of the function, they'll have zero overhead. If they perform work like translating the return value or changing arguments around, they will still be fast, but at some point all that duplicated code may be taking up more space than a wrapper function. You also lose a little bit of safety and convenience because you can't prototype a macro, so the compiler can't check that you're using the macro itself correctly, only that the code resulting from the preprocessor is valid. (You *can* write a C function prototype for a macro name, and it might fool IntelliSense into giving you popups for the macro's arguments and their types, but it won't change the compiler's behavior at all.)
the provided snippet doesnt compile becuase of the semicolon at the end of the if condition. when thats removed and `string`, the program works (besides some garbage being printed, probably because of a missing null terminator). 
i got errors with clang and gcc because there was the `else` without a previous `if`
help me sensei
1. How do you know the string is in "string" array? 2. Pointer "pt" is needless. 3. You have semicolon after if statement. Next time I suggest usage of pastebin or sth like that, it is much easier to read code with indentations.
1. I'm sorry I don't understand what you mean here? 2. I have to use the pointer as part of my class just to learn how to use it 3. That was a typo, I deleted it
Oh yeah, that's correct indeed.
The semicolon was a typo, I have deleted it.
how/where are you actually storing "asd IS asd" in `string`?
printLower is actually a function in my main.. i just put everything into printLower to make it easier to diagnose. I added the string to the array now.
what you have posted looks fine, apart from the lowerString not having a null terminator. i suspect you have accidentally fixed whatever your problem was while copying it to the post.
In the absence of an enumeration function, you could also just iterate over all neighbors with two `for` loops, and accumulate neighbors with `+=`. I think I would find this a little easier to read than a sum of 7 terms, each with slightly shifted `x` and `y` coordinates.
You need `#include &lt;ctype.h&gt;`. And the cast to `int` should be to `unsigned char` although it wouldn't matter if your input only contains standard letters and space
Thank you so much! :)
I figured I would follow up on this thread here rather than create a new one. I have a question about this and if you have the time, I'd appreciate the help. In this code: #include &lt;stdio.h&gt; char strA[80] = "A string to be used for demonstration purposes"; char strB[80]; int main(void) { char *pA; /* a pointer to type character */ char *pB; /* another pointer to type character */ puts(strA); /* show string A */ pA = strA; /* point pA at string A */ puts(pA); /* show what pA is pointing to */ pB = strB; /* point pB at string B */ putchar('\n'); /* move down one line on the screen */ while(*pA != '\0') /* line A (see text) */ { *pB++ = *pA++; /* line B (see text) */ } *pB = '\0'; /* line C (see text) */ puts(strB); /* show strB on screen */ return 0; } I don't understand the third line from the bottom where *pB = '\0'. I understand that in the loop above, the string is copied from pointer A to pointer B one byte at a time. Then they tack on a null terminator. They do this, yet they don't specify "where" in the pointer to add this. Does it go on the end automatically since the pointer has been incremented as much as it needs to? Does the compiler "know" to add this to the end?
Does this work? `angle` is the angle and `end_positives` is a value from `0` to `2œÄ` representing at what point the positive numbers end. #include &lt;math.h&gt; double shaped_sin(double angle, double end_positives) { angle = fmod(angle, 2 * M_PI); end_positives = fmod(end_positives, 2 * M_PI); if (angle &lt; end_positives) { return sin(angle * M_PI / end_positives); } else if (angle &gt; end_positives) { return -sin((angle - end_positives) * M_PI / (2 * M_PI - end_positives)); } else { return 0; } } 
**Pipeline (Unix)** In Unix-like computer operating systems, a pipeline is a sequence of processes chained together by their standard streams, so that the output of each process (stdout) feeds directly as input (stdin) to the next one. The concept of pipelines was championed by Douglas McIlroy at Unix's ancestral home of Bell Labs, during the development of Unix, shaping its toolbox philosophy. It is named by analogy to a physical pipeline. The standard shell syntax for pipelines is to list multiple commands, separated by vertical bars ("pipes" in common Unix verbiage). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
No one equation can do what I want, it needs to be a peicewise function. The plotting for what I want to do is found in the reddit page I linked, as well as the math. If one half of a sine wave is 1/4th the desired frequency and the second half is three times the frequency of the first, the frequency is consistent. It still takes the same amount of time to complete a full cycle. I've already explained this in everything I've linked. 
Why do you need the answers from questions? If you program does what you questioned then it is ok. Might not be the most efficient but that it for later! 
I‚Äôm a fellow students as well, but something that really worked for me is to stick to the course content while supplementing it with outside resources such as YouTube videos or udemy courses. If the place where you study has a tutor, I would recommend you to set up some time to clarify questions (or look for other students in your class that are going through the same and would like to get together to clarify doubts). 
Project Euler
I personally never understand how books and course material are relevant. They don't teach you how to program, just how to mirror someone's text. Sure youaybe understand it but you don't learn how to think abstract like. So what is your question? How do I get good at C to get hired? Or how do I just pass this class? A1: Personally, find a project to work on and learn every aspect of what it is you're trying to do through Google and other resources until that project is functional. Then go back and see what you could have done better and improve it. Then start a new project, keeping all your projects small and relevant to something you care about and want to see finished! (Not a program to sort numbers or cars). Try to join open source projects and other group projects. You will then learn by doing and actually have experience to back up that education. These things maybe arnt what will initially help you Ace a test... But employers don't give two shits if you are actually competent and experiencent in programming. A2: Memorize the syntax. It won't be ultimately helpful to you in the future but it'll help on the tests. Just make sure you understand the course material as the teacher is teaching it regardless of what others say are best practices. Then, try to expand on that course material on your own to get a better understanding. Sometimes textbook examples are wrong and you'll need to understand why they don't compile. So take the time to research what the conpiler is telling you.
Codefights?
I've updated my post with a lot of new info. 
I've updated my post with new information. I've rewritten the function and I'm very close to solving this! Again, thank you so much for your help!
Wow thanks a lot, this is amazing advice. I want to just pass this class but would also like to know the language well! So that I CAN put it on a job app. Thank you so much for the thoughtful response!
You're welcome! Hope C becomes a good cornerstone for your future. Whether it's becoming a C programmer or a higher level language like C#, Java, Python, ect, let your experience in problem solving and being respectful be what guides you. That's what moves and inspires the industry. Another bit of advice, but you may already know. Be careful not to confuse C as a subset of C++. C can compile under C++ and they share a lot, but think of them as their own separate languages. This will help you avoid being confused by classes and object oriented concepts while learning C. Unless you want to learn C++ as well, (which is fun, but one step at a time)
Thank you so much üòÅ, honestly inspiring.
I didn't mean how you line up the processed to feed one into the other. I mean what if your value is 0, that will output character 0, which is the NUL character. There are a host of other low values which will probably be interpreted in unexpected ways by the system, like 10 which is line feed, or any white space character, or whatever the end-of-file marker is, etc etc. 
HackerRank can be helpful! You can use C and a number of other languages.
Omg! the only language they don't have is C üò©üò© 
When piping, the raw char values are sent, so an eof, line feed or even beep wouldn't cause any issues, unless they're printed to the screen which they aren't in my case. 
What do you mean? You can select it when solving the general problems.
When I run the program, the compiler spits out all the printf functions instead of taking into account the variable age I inputted. Any assistance would be greatly appreciated!
Are those semicolons supposed to be there after the if statements? Try removing those, might be evaluating the statements but ending the line instead of encapsulating the printf‚Äôs after
Who knew. TIL!
I'm still working through the chapter I'm reading so I'll give that a try once I come across how to use else if and else statements. Thanks for such a quick reply! 
You have semicolons immediately after the if statements. These are then the empty body of the if statement (as the warning shows). The printf statements area no longer part of the if statements and run separately after the blank ifs. Remove those semicolons on the if lines and it should work.
oh okay I gotcha, thanks I'll use this! really cool website
If I wasn't poor, I'd give you gold! That totally did it! Thanks so much :) 
No problem!
No problem! It‚Äôs a simple fix, your first if is perfect, the ifs after that should be else if unless you‚Äôre trying to use a separate if statement for another variable etc. Not too proficient myself, but glad I can help :) oh and also if you want a default as in age isn‚Äôt any of the three things you specified just use else instead of else if. 
You got it!
Oh one more thing, you‚Äôre ending your statements with a ; after the parenthesis, those are also causing an issue because it makes it so what‚Äôs inside the if statement is used regardless as it‚Äôs not being checked. 
It looks like the semi-colons after the condition is what was causing the issue. I appreciate the tip though! I just started learning C a few weeks ago so debugging code has been an interesting experience (interesting == mind-numbingly frustrating) 
I‚Äôve just started learning classes and that == thing gets me so many times it‚Äôs insane haha
You have placed semicolons after the if statements - this effectively is an if with an empty body. The curly braces (blocks) you have after do nothing but introduce a new scope - you code is equivalent to the following: if (age &lt; 100) ; printf("Man you are young!\n"); if (age &gt; 100) ; printf("Man you are really old!\n"); if (age == 100) ; printf("Man you are old!\n"); or another way to write the above/your code would be if (age &lt; 100) { } printf("Man you are young!\n"); if (age &gt; 100) { } printf("Man you are really old!\n"); if (age == 100) { } printf("Man you are old!\n"); Hopefully two examples above (which are equaillent in function to your code) allow you to understand what your code does wrong - you need to remove the semicolons following the if statements - your code should look like the following: if (age &lt; 100) printf("Man you are young!\n"); if (age &gt; 100) printf("Man you are really old!\n"); if (age == 100) printf("Man you are old!\n"); or if you wanted to use braces if (age &lt; 100) { printf("Man you are young!\n"); } if (age &gt; 100) { printf("Man you are really old!\n"); } if (age == 100) { printf("Man you are old!\n"); }
Awesome!
No problem :) You're not the first person to fall into this trap! In Fact, some really big (opensource) projects have been affected by "bugs" that really boiled down to someone placing a semicolon after an if and not noticing it. Sometimes you may come across code that dilibrarlt does what you did - they make an if statement with an empty/no body - however to indicate that this is intentional the semicolon is usually placed on the next line: if (thisIsEquall == doNothing) ; /* Plcaed on next line to make it clear that this is empty on purpsoe */ else if ( ... ) /* Do more things ...*/ /* ... */
Well one use case I can think of is if you had user input that you didn't want to do anything with. Take the following example: void getInput() { char in[256]; printf("Please provide a command: "); gets(in); /* This is just for the sake of example, NEVER USE THE gets() FUNCTION! */ if (strcmp(in, "exit") == 0) print_exit(); else if (strcmp(in, "info") == 0) print_info(); else if (strcmp(in, "read") == 0) print_read(); else if (strcmp(in, "write") == 0) print_write() else if (strcmp(in, "") == 0) ; /* &lt;-- This empty block allows us to avoid printing the error (the else case below) when the user provides no input (i.e. press Enter/Return without typing anything) */ else print_error(); } I can't think of a better example right now, but hopefully it gets the idea across - basically it's a way to inform someone reading the program that you have considered this posabile case (i.e. the user giving empty input) and do not want to act on it. The compiler will almost certainly optimise it out.
I have never used it bit I can imagine some - maybe stupid - cases. If one of your if statements take many clock cycles to complete and you now when you want to check it. Say you want to check when variable x contains a 1 but you'r not interested in doing anything when it's 0. Then you can save time by checking the variable x first and simply do nothing in an empty if statement.
As well as what's already been said your editor there is already trying to warn you about the problem. Notice how those lines have a yellow background, the semicolons have a little red line under and it says 'if statement has empty body' on the right hand side of the screenshot. Learn to notice these warnings and learn what they mean and you'll have a much easier time of it.
You meant to write ` scanf("%lf", *angle);` Dereference `angle`, not try to multiply it with something.
Function parameter `angle` has type `double *` and `scanf` expects a `double *`, so you need to just pass `angle`: `scanf("%lf", angle);`
Aha. Thank you!
Gotcha. Thanks!
Please post your code as text instead of an image!
Oh, my eyes. Those function header comments are 75% couterproductive. Most of the content just repeats information that's right there in the function definition - the parameter types and names. The only thing that's useful in there is the function description. And if you do want a function header comment there are some things that shoudl be in there but aren't: for mathematical functions, the domain and range of the function. For functions with side effects, any pre- or post-conditions. 
* Don't put function declarations inside other functions. That usage dates from pre-ANSI C. That is, before 1989. It's outdated. If you learned this from a book, change the book. Put the forward declarations somewhere near the topof the file, in global scope, instead. * Skip useless comments such as " //Local Declarations". They add nothing to the reader's understanding of the code snad just take up space. * Instead of casting an int to produce a double (`(double) 2`), just use a constant of the right type (`2.0`). * `return` is not a function call. It does not need parentheses. * The code lacks error detection and handling. Specifically, it ignores the return value of `scanf`. * This code is voluminous in ways that impedes reading, rather than helping it. Specifically, `getProbabililty` would be better coded like this: double getProbability(double radians) { // &lt;optional explanation of the implementation here&gt; // Angle is with respect to a normal at the impact point return 2.0 * sin(radians) * cos(radians); } 
I agree totally, but my school requires them.
This certainly seems clearer than my current code. Thank you for taking the time to write a detailed description!!
Buy a microcontroller and make leds light up in interesting ways. 
Sorry! Will post as text next time! 
Thank you for your cooperation.
Pick a project and start. The challenges and difficulties you face and you try to solve/google will determine how much you grow 
should one read simultaneously ? or practice examples ?
Practice until you can compile your first line of code. Read when needed or stuck. Practice comes naturally as you debut errors 
C doesn't have vectors. If you are programming in C++, please post your question to /r/cpp_questions instead of here, as this subreddit is exclusively about programming in C.
Sedgewick's books are pretty good. While he has older editions written in C, I would recommend just getting whatever the latest edition is (uses java, if I recall correctly). You can easily adapt the ideas to C. 
&gt; I understand that in the loop above , the string is copied from pointer A to Pointer B one byte at a time. This is not correct. The program is copying the contents of one array of char's to another array of char's. This is a very important distinction. Ted discusses this and walks through the code in the paragraphs after program 3.1: In the above we start out by defining two character arrays of 80 characters each. Since these are globally defined, they are all. initialized to '\0's first. Then, strA has the first. 46 **(Ted had this as 42 but it's 46!)** characters initialized to the string in quotes. Now, moving into the code, we declare two. character pointers and show the string on the. screen. We then "point" the pointer pA at strA. That is, by means of the assignment statement we copy the address of strA[0] into our variable pA. We now use puts() to show that which is pointed to by pA on the screen. Consider here that the function prototype for puts() is: int puts(const char *s); The parameter passed to puts() is a pointer, that is the value of a pointer (since all. parameters in C are passed by value), and the value of a pointer is the address to which it points. Thus when we write puts(strA) we are passing the address of strA[0]. Similarly, when we write puts(pA); we are. passing the same address, since we have set. pA = strA; So, basically, a pointer to an array is really a pointer to the address of the first element of the array (strA[0]). And, When you pass an array to a function that accepts a pointer the array is said to decay to a pointer whos value is the address of the first element of the array. Ted goes on to explain the while loop: Given that, follow the code down to the while() statement on line A. Line A states: While the character pointed to by pA (i.e. *pA) is not a nul character (i.e. the terminating '\0'), do the following: copy the character pointed to by pA to the space pointed to by pB, then increment pA so it points to the next character and pB so it points to the next space. When we have copied the last character, pA now points to the terminating nul character and the loop ends. However, we have not copied the nul character. And, by definition a. string in C must be nul terminated. So, we add the nul character with line C. So, order of presedence for *pB++ = *pA++ is: First, dereference ("*") Second, set ("=") Third, increment ("++") So, in the first iteration of the while loop: pB is pointing to the address of strB[0] and pA is pointing to the address of strA[0] dereference to get the contents of the 0 index of both arrays strA[0] == 'A', strB[0] = '\0' Set the contents of strB[0] to the contents of strA[0] (*strB = *strA). Now strB[0] == 'A' Move the pointers to the next array index (pB++ and pA++) pB is now pointing to the address of strB[1] and pA is pointing to the address of strA[1]. LOOP When the while loop check returns false (*pA != '\0') then: *pA == '\0' (pA now has reached the end of the string and points to the address of pA[46]) *pB == '\0' pB points to the address of pB[46] which is '\0' since the end of every string/character array there is a null terminator character '\0'. It then breaks out of the loop and does the following: *pB = '\0'; pB is still pointing to the address of pB[46] and so *pB dereferences the pointer and sets the content of that array index to '\0' Again, This is unneccesary since the end of every string/character array there is a null terminator character '\0'! So, what you should be asking is how does the compiler know how to set the address of the pointer when you increment it by 1 (pB++)? The answer requires the answer of two questions: How are arrays stored in memory? Increment by 1 what? An array is a contigious block of memory defined by the sizeof(type) of the array. For ints it will be 4 or 8 byte blocks. For char it is 1 byte blocks. So pA++ moves the pointer to the ajacent block of memory (1 byte away.)
&gt; I understand that in the loop above , the string is copied from pointer A to Pointer B one byte at a time. This is not correct. The program is copying the contents of one array of char's to another array of char's. This is a very important distinction. Ted discusses this and walks through the code in the paragraphs after program 3.1: In the above we start out by defining two character arrays of 80 characters each. Since these are globally defined, they are all. initialized to '\0's first. Then, strA has the first. 46 **(Ted had this as 42 but it's 46!)** characters initialized to the string in quotes. Now, moving into the code, we declare two. character pointers and show the string on the. screen. We then "point" the pointer pA at strA. That is, by means of the assignment statement we copy the address of strA[0] into our variable pA. We now use puts() to show that which is pointed to by pA on the screen. Consider here that the function prototype for puts() is: int puts(const char *s); The parameter passed to puts() is a pointer, that is the value of a pointer (since all. parameters in C are passed by value), and the value of a pointer is the address to which it points. Thus when we write puts(strA) we are passing the address of strA[0]. Similarly, when we write puts(pA); we are. passing the same address, since we have set. pA = strA; So, basically, a pointer to an array is really a pointer to the address of the first element of the array (strA[0]). And, When you pass an array to a function that accepts a pointer the array is said to decay to a pointer whos value is the address of the first element of the array. Ted goes on to explain the while loop: Given that, follow the code down to the while() statement on line A. Line A states: While the character pointed to by pA (i.e. *pA) is not a nul character (i.e. the terminating '\0'), do the following: copy the character pointed to by pA to the space pointed to by pB, then increment pA so it points to the next character and pB so it points to the next space. When we have copied the last character, pA now points to the terminating nul character and the loop ends. However, we have not copied the nul character. And, by definition a. string in C must be nul terminated. So, we add the nul character with line C. So, order of presedence for *pB++ = *pA++ is: First, dereference ("*") Second, set ("=") Third, increment ("++") So, in the first iteration of the while loop: pB is pointing to the address of strB[0] and pA is pointing to the address of strA[0] dereference to get the contents of the 0 index of both arrays strA[0] == 'A', strB[0] = '\0' Set the contents of strB[0] to the contents of strA[0] (*strB = *strA). Now strB[0] == 'A' Move the pointers to the next array index (pB++ and pA++) pB is now pointing to the address of strB[1] and pA is pointing to the address of strA[1]. LOOP When the while loop check returns false (*pA != '\0') then: *pA == '\0' (pA now has reached the end of the string and points to the address of pA[46]) *pB == '\0' pB points to the address of pB[46] which is '\0' since the end of every string/character array there is a null terminator character '\0'. It then breaks out of the loop and does the following: *pB = '\0'; pB is still pointing to the address of pB[46] and so *pB dereferences the pointer and sets the content of that array index to '\0' Again, This is unneccesary since the end of every string/character array there is a null terminator character '\0'! So, what you should be asking is how does the compiler know how to set the address of the pointer when you increment it by 1 (pB++)? The answer requires the answer of two questions: How are arrays stored in memory? Increment by 1 what? An array is a contigious block of memory defined by the sizeof(type) of the array. For ints it will be 4 or 8 byte blocks. For char it is 1 byte blocks. So pA++ moves the pointer to the ajacent block of memory (1 byte away.)
Basically all I want to do is to understand other peoples made code and alter them as I want them to be, and in general have a better understanding of coding.
Thanks for the replies, do you know if java or other programming languages are easily learnable after I know C++? 
C++ is the most complex and hard of all the most used languages. Java itself is made as a more programmer-friendly version of C++, as it removes dangerous features, encourages you to adopt Object Orentation, and adds some other utilities that often make C++ programming hard. Python and scripting languages in general are a joke after you learn C++. Be sure to learn Object Oriented Programming in your C++ course. C++ allows procedural programming, so sometimes C++ courses don't teach object orientation.
If you a nul-terminated string then, yes, you can pass it to strcmp.
IMO you should do the boring problems in the book. Every single one of them. They're boring because they're specifically designed to help you test and practice what's in the book. I lost count of how many times I thought I understood something then discovered I didn't because of some seemingly stupid little exercise problem. That said, everyone is different, and I haven't opened that book in a long time and I don't remember what's in there. 
 int main() { double radconvert (double* angle); //Converts angle to radians You're not calling any of your functions. All main does is `return 0;` The other 3 lines are function declarations.
I will do the problems then. 
Why are you using pointers to doubles as arguments instead of just doubles? You're making things way too complicated. For example: double radconvert(double deg) { return ang / 180.0; } 
Gotcha. Thank you!
Mostly inexperience. I‚Äôm not entirely sure what I‚Äôm doing yet in C
The IDE is telling you the issue: "if Statement has empty body" Learn to use the IDE and (wait for it) GOOGLE IT. REALLY. 90% of programming is googleing the answer. The other 10% is fixing typo's.
That's also not the right equation to convert degrees (or any other measure of angle) to radians, btw.
The "frequency" of your signal is not 440hz ( or whatever your slower signal is). If you were to sample it at 2x the lowest frequency, you would not get consistent results.
Once you realise you need to know something better, go back to the book, or online, read it, do the exercises, and go back to your project. I did something like that with pointers, I ‚Äòunderstood‚Äô them after my first reading. Then realised I was just sticking &amp; or * places and hoping it would compile. Went back to the book, did some exercises, did some of my own demonstration code and went back to the project knowing more! 
That question is not really on topic. This subreddit is about programming in C, not even C++ is on topic. For programming and career advice in general, try other places (not sure which).
If you're referring to my screenshot, you're right, it's 1Hz, as I mentioned in my post. You're also right about 2 x 1Hz doesn't give consistent results, but if you look, you'd see I've updated my post, mentioning that I'm done writing the function for now, and the issue is fixed. The working source code can be found here: https://pastebin.com/JpXMmCLa
/r/cscarrerquestions
Here's a sneak peek of /r/cscarrerquestions using the [top posts](https://np.reddit.com/r/cscarrerquestions/top/?sort=top&amp;t=all) of all time! \#1: [Did you mean /r/cscareerquestions?](https://np.reddit.com/r/cscareerquestions) | [0 comments](https://np.reddit.com/r/cscarrerquestions/comments/5jbb6v/did_you_mean_rcscareerquestions/) \#2: [Preparing for Goldman Sachs Tech Internship.](https://np.reddit.com/r/cscarrerquestions/comments/7l03qz/preparing_for_goldman_sachs_tech_internship/) \#3: [No idea what field to work. Should I just take any decent job?](https://np.reddit.com/r/cscarrerquestions/comments/7cm2pf/no_idea_what_field_to_work_should_i_just_take_any/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
After reading K&amp;R I practiced by writing my own version of library functions like strcpy, malloc, etc. Might seem mundane but it really helped me understand pointers. Dont mean to be mean but you probably should have done those problems in the book, they are great teaching tools for learning C specifically. 
*The Art of Computer Programming* by Donald Knuth
Would you be willing to share your full source via [pastebin](http://pastebin.com)? My initial thought is that this is a problem with `isValidAndBurning()`, because the only way to change that cell is via that `if` block within `spread()`. The problem is that you also have `if((double)(numBurning / total) &gt;= 0.25)` which as far as I can tell should always be false. This is because `numBurning` and `total` are integers, so `numBurning / total` is committing integer division which will result in a value of 0 (due to truncation) and then that value is cast to a `double`. The process you use on the next line should be repeated here to ensure that you're comparing the value you want, though it is also worth noting that I don't think you need to cast both operands, one should do. So I'm led to believe that there must be something else going on somewhere in your code to result in this behavior. As a side note, I think `applySpread()` can be shortened to a single loop, since I think the return value of `spread()` shouldn't require the entire grid to be processed before changes are made (although I may have misunderstood the assignment specifications). But also, I would recommend the use of a `switch` in the logic of the second loop, as I find it to be much cleaner. Hope this helps!
https://pastebin.com/4cR2NYxt I figured people didn't want to look at a bunch of code. If you wanted to look over that then there you go. That was definitely very helpful, I'll look into it. Thank you!
Imagine a world where nothing segfaults and just fails silently for years in production.
Sorry, I'm still looking for the source of your original error, and I'm struggling to find it. Could you provide the changes you've made?
You have code which will not return anything. Your compiler should be warning you about things like that: static int spread(int size, char grid[][size], int x, int y, double catch) { ... if(!(isValidAndTree(size, x, y, grid[x][y])) &amp;&amp; !(isValidAndBurning(size, x, y, grid[x][y]))) { return 0; // nothing } if(isValidAndBurning(size, x, y, grid[x][y])) { if((double)(numBurning / total) &gt;= 0.25) { if((double)rand() / (double)RAND_MAX &lt; catch) { return 1; // burns out } // what happens now? what ends up getting returned? } // what about now? } else { if(isValidAndTree(size, x, y, grid[x][y])) { if((double)(numBurning / total) &gt;= 0.25) { if((double)rand() / (double)RAND_MAX &lt; catch) { return 2; // catches fire } // and now? } // and now? } } } It should be written something like this: static int fun( ... ) { if( validandburning() and somenum() &lt; catch ) { return 1; } if( validtree() and somenum() &lt; catch ) { return 2; } return 0; }
I did the double thing you suggested in those if statements in spread. I also just did another change. In main, I had a loop that I called applySpread in, but I already loop through the grid in applySpread, so I now just do a single call to it in main. That seemed to fix a majority of the output, at least from what I see. However, some 'Y' go straight to '_' still and I'm not sure why. I added a print statement to determine the exact times it happens and this was the output: YY * Y YY* YYYY* YY* Y* Y Y YY* Y * YY Y Y Y * Y Y Y Y* Y Y *Y* Y Y*YY * *Y *Y Y Y Y * Y cycle 0, size 11, probability 0.77, density 0.50, proportion 0.25, changes 0 (0, 4) (1, 0) (2, 4) (3, 0) (4, 0) (4, 4) (4, 8) (5, 0) (5, 4) (6, 0) (6, 2) (7, 0) (7, 2) (8, 10) (10, 10) *_ * * _Y* Y***_ _** *_ _ * _** _ * _Y _ _ * * _ _ Y *_ _ _ **_ Y Y*Y_ * *Y ** Y Y * _ _ cycle 1, size 11, probability 0.77, density 0.50, proportion 0.25, changes 34 __ * * _*_ *____ ___ __ _ _ ___ _ _ _* _ _ * * _ _ * __ _ _ ___ * ***_ * ** *_ * * _ _ _ cycle 2, size 11, probability 0.77, density 0.50, proportion 0.25, changes 61 __ * * _*_ _____ ___ __ _ _ ___ _ _ __ _ _ * _ _ _ * __ _ _ ___ _ ____ _ __ __ _ _ _ _ _ cycle 3, size 11, probability 0.77, density 0.50, proportion 0.25, changes 74 What's confusing me is that it seems to partially work and not work? 
I love how your library function examples goes from 0 to 100 really quick. I've had strcpy down months ago yet I still have no idea how you'd recode malloc
Consider, the answer u/dumsubfilter provided, it may be part of the reason. Could you provide updated source code?
https://pastebin.com/mxMjkf2n Each time I apply changes, the output is different. At this point I'm having a hard time determining if the output is what it should be. If I run it now, it seems like the fire spreads way too much, but idk.
Lines 85 to 101 have you returning 1 or 2 regardless of whether conditions are met. I would change the function like [this](https://pastebin.com/FEUu4AuC). It's still sloppy, but it results in the behavior you want, without having to drastically change your logic.
I pretty much did what you said and it seemed to help. Thank you!
So I think I got it working, but was just wondering if you thought the output looked right (based on the rules I mentioned)? YY * Y YY* YYYY * cycle 0, size 5, probability 0.77, density 0.50, proportion 0.25, changes 0 YY * Y *Y* *Y** * cycle 1, size 5, probability 0.77, density 0.50, proportion 0.25, changes 4 YY * * _Y* _Y__ _ cycle 2, size 5, probability 0.77, density 0.50, proportion 0.25, changes 10 *Y * _ _*_ _*__ _ I think it looks about right, I just want another set of eyes to verify because I've literally been staring at this code and output all day.
I've been using [Codewars](https://www.codewars.com/) lately. It's pretty cool; compared to other services like [Project Euler](https://projecteuler.net/) and [Exerism.io](http://exercism.io/). Regarless, you should re-read your source material and practice the example problems. C has a habit of being "deceptively simple".
I understand now. I appreciate your time and patience. 
Yeah. Fuck a linked list im just gonna rewrite malloc
I was hoping for a resource which identifies my shortcomings and trains me only on those. Like a quiz with solutions. Something like haskell 99 questions - where i try the questions and realize where i fail. And study that specifically. I will start solving k and r and any other examples - i can get my hands on. Cheers. 
Thanks for answers, support. 
The compiler should still warn against mismatched parameters in a macro, its still translated to the true function then checked against that. Simple return translations like small math or basic if/else/?: may be negligible enough to be the same size as a call to a wrapper function
OK, so what ? if it is in production no one will bother you!
To start, I recommend going through the book "C Programming Language, 2nd Edition" and do all of the programming practice in the book. It should give you a pretty good grasp of all of the basic syntax. After that, if you're the kind of person that like to learn while doing, you could try writing some basic games in C. There's [this repository](https://dashgl.com/) for some command line games, and [this site](https://dashgl.com/) that outlines a few examples using graphics.
Your code seems to look for string1 in string2, i.e. string1 is the "needle" and string 2 is the "haystack". But in your title you have the arguments the other way around. Apart from that, the logic in the inner `for` loop is not right. You want to abort the loop with Failure when the characters differ, and you want to return from the function with Success if you reach a null terminator in the Needle. Other than that you continue looping. There is no place for the variable `match` in all this. 
Your welcome. Feel free to DM me in the future as you go along and follow Ted's Excellent Adventure...err Tutorial and I can try and help.
If you're looking for intros to game engines, check out Blender, but otherwise I can't really help you... do what you think is best.
K&amp;R ? good lord. Get a newer book and just fast through it. K&amp;R has a lot of bad practices and tips that are useless nowadays with embbedded hardware stronger than servers in K&amp;R days! 
What framework or toolkit do you use to draw windows? Are you programming for X or for Wayland?
sorry I forgot to specify. I'm using X
If you're using GTK, there is [`gtk-widget-set-opacity`](https://developer.gnome.org/gtk3/stable/GtkWidget.html#gtk-widget-set-opacity) (replacing [`gtk-window-set-opacity`](https://developer.gnome.org/gtk3/stable/GtkWindow.html#gtk-window-set-opacity)).
Checkout Xlib.
What library are you using the draw X windows?
just plain X
xlib is plain X right? that's at least what I thought
Okay. So xlib is the library you use to talk to the X server. No, it's not plain X. xlib is a library that implements the X11 protocol and wraps all its messages and states into nice functions for you to call. You could also directly send messages to the X server but nobody does that because it's so tedious and pointless. Let me check the documentation for you.
I found this tho I haven't tested it yet https://gist.github.com/je-so/903479/834dfd78705b16ec5f7bbd10925980ace4049e17
 printf("%.2f", (x-0.005));
Ah I see how that works, thanks.
Output to an intermediate string using snprintf and copy the part you need.
 If there is a possibility of negative, you could use a ternary operation: x &gt; 0 ? (x-0.005) : (x+0.005)
&gt; As far as I remember, division and multiplication have the same precedence, right? Yes, and that's the problem. They have the same precedence, so the evaluation happens left-to-right. Take this example: double d = 10 / 2 * 5; This is evaluated by taking 10, dividing by 2, and then multiplying the result by 5 (so `d` is 25). It's exactly the same as if we had written: double d = ( 10 / 2 ) * 5; Everything has the same precedence, so it happens left-to-right. But, if we instead wanted the multiplication to happen first, we need to write: double d = 10 / ( 2 * 5 ); So 2 and 5 are multiplied to get 10, and 10 is divided by 10 to get 1.
Oh, right! My bad! Makes sense now, thanks. 
Yes! Thanks.
Now I understand. Thank you!
windows on linux?
title says linux :p. it's under X11 and I'm using xlib
Use trunc(), from math.h, along with some multiplication and division. In this case you would * 100, then trunc, then /100 
Incorrect. That intermediate string will have to be rounded. Imagine 0.9999... It will print as 1.000... if given any required digits and then you would cut that down to "1.00" when OP wants "0.99"
It‚Äôs not exactly clear how much you‚Äôre supposed to modify or how, and ‚Ä¶ like everything in this is weird and/or Not How Things Should Be Done. But germane to the question at hand: - If you‚Äôre supposed to modify `getNumberAndBase` to break out when the user types zero as the number to be converted, you could have it immediately return a value if the `scanf` gives you a zero. (Not if `scanf` returns zero, which it can do if the user glitches their input or ends stdin early. One of the NHTSBDs is not checking the return value from `scanf` in case there is such an error. Always do that in any code you write.) You‚Äôd then check the return from `getNumberAndBase`, and propagate a ‚Äúbroke out early‚Äù return successively out into `main`. - If you‚Äôre supposed to modify `getNumberAndBase` to break out when a zero base is entered, you‚Äôd throw an `if` into the `do`/`while` and return early there instead. Alternatively, you could add another condition to the `do`/`while` and re-check it at return time. - If you‚Äôre supposed to modify something else, you can either `return` or `break` early, and again, use the return value to indicate what happened. Do not declare the functions inside `main`. You don‚Äôt actually need to declare them at all in this case because the definitions come up first; if you wanted to declare them, you‚Äôd declare them at the global scope since that‚Äôs where functions live. (Properly, they should probably be `static` globals, but I‚Äôm guessing you don‚Äôt know/care about that yet. You *can* prototype things inside functions if you use the `extern` keyword, but that‚Äôs mostly useful for symbol-hiding, which again, I‚Äôm guessing you don‚Äôt know/care about yet.) If you‚Äôre allowed to freely modify the thing, kill the globals. Kill them with fire. You should do something like int getNumberAndBase(unsigned *number, unsigned *base); with the `int` return telling you what happened (properly, should be an `enum`, but `#define`d constants will suffice too), and `number` and `base` being out-parameters passed as if to `scanf` (not sure if you ken pointers yet?): unsigned inputNum, inputBase; int whatHappened; whatHappened = getNumberAndBase(&amp;inputNum, &amp;inputBase); To assign those values explicitly within `getNumberAndBase`, you‚Äôd do *number = value; /* =‚ÄúSet what‚Äôs at address `number` to `value`‚Äù */ *base = value; or to assign them with `scanf`, you‚Äôd just omit the `&amp;` in its argument list. You should also be using `%u` and `unsigned` for your number and base, or else you‚Äôre going to accept negative numbers for either and shit‚Äôll go sideways when you mix that with the `%` operator.
I have started learning C through CS50, an online Harvard course, and before finishing the C programming section, I decided to go through this book to get a better understanding of C. Since I have only been learning about the language and programming in general for no more than 5 weeks, there was a bunch of stuff of what you said, so if you don't mind, I have some questions. This are the instructions: * Modify Program 7.14 so that the user can convert any number of integers. * Make provision for the program to terminate when a zero is typed in as the value of the number to be converted. 1. How do I check the value of `scanf`? 2. I know that in this case the functions don't need to be declared. Why should functions be declared in the global scope? 3. What does the `extern` keyword do? The problem with your answer is that even if I were to do all of that, I'd feel like I'm cheating. This problem is supposed to be solved without pointers (since the pointers chapter comes one or two after this one). I'm still confused as to how I would get it done. Could you please ELI5? I really want to understand C, and it seems like you do. 
What answer do you get for the for loop and what answer do you get for your while loop? 
From what I can tell just at a quick glance is you start the even counting at i=2 and then add 2 to i before adding the value to evensum. Basically what you are doing is not adding the first even number, 2. One solution is to start evensum=2 rather than 0. You have the same issue with odd numbers. Another way to condense this code, if you want to, is by having one loop and using modulo to switch from adding an odd or even number
in forloop is 2550 and 2500 in do while is 2650 and 2600
There's a difference of 100. In the for loop are you using &lt;= 100 or just &lt; 100? 
Can you post your for loop code as well? 
 int i,j; int evensum=0; int oddsum=0; for(i=1;i&lt;=100;i+=2) { printf("%d\t", i); evensum=evensum+i; } printf("\n\nThe sum of all even numbers from 1 to 100 is %d\n\n",evensum); printf("\n\n"); for(j=1 ; j&lt;=100 ; j+=2) { printf("%d\t", j); oddsum=oddsum+j; } printf("\n\nThe sum of all odd numbers from 1 to 100 is %d\n\n",oddsum);
You haven't initialized the i and j values in the for loop like you have in the while loop. Both i and j are starting from 1 as opposed to i = 2 and j = 1. Your even and odd loops look exactly the same. 
i is starting from 2. Sorry, I just copied the wrong code. I corrected it now. How can I properly convert the initialization?
Try putting the i += 2 and j +=2 statements after evensum += i and oddsum += j statements. 
Wow! Finally it worked! Thanks a lot man!
 do { evensum=evensum+i; i+=2; } while(i&lt;=100); printf("\n\nThe sum of all even numbers from 1 to 100 is %d\n\n",evensum); printf("\n\n"); do { oddsum=oddsum+j; j+=2; }
didn't know there was a difference if you interchange those codes
There is a massive difference. Your while loop executed one more than it should've. I will leave the rest for you to figure out. It's pretty easy to understand what went wrong. Good luck! 
1\. `scanf`‚Äôs return value under normal circumstances is the number of things it successfully read, which would be 1 for this code. It‚Äôll be &lt; the desired count if there‚Äôs bogus input, and &lt;0 (the constant `EOF`, technically, which is almost always ‚àí1) if the file‚Äôs at EOF or there‚Äôs some error (e.g., I/O, out of memory, whatever). Any outputs filled in will be left in their prior states, which here would be undefined. Normally you use it like if(scanf("%u ", &amp;number) &lt; 1) { complain(); return SOME_ERROR_CODE; } If you want to distinguish between the EOF and bogus-input cases, you can expand to int k; if((k = scanf("%u ", &amp;number)) &lt; 1) { if(k &lt; 0) handle_eof_or_io_error(); else handle_input_error(); return APPROPRIATE_RESPONSE; } where `if((x=y)&lt;0)` is just a more compact form of `x=y; if(x&lt;0)`. 2\. Functions should be declared in the global scope, unless you have a very good reason to do otherwise. They behave just like global data anyway (=one copy, initialized by run time), so it‚Äôs sort of like using ‚Äúthou‚Äù in common speech to declare them inside another function like locals. That you can do so anyway is one of C‚Äôs weird scoping/lifetime exceptions, and it‚Äôs best to avoid invoking those when possible. Also, it tends to introduce a bit of a ‚Äú?‚Äù‚Üí‚Äú?!‚Äù‚Üí‚Äú‚Ä¶‚Äù in the reader‚Äôs mind because compilers (like GCC or Clang) permit you to create `auto` functions that *are* nested properly inside other functions, which makes a lot more sense than the usual rules. Something like this: void outer(int k) { auto void inner(void); int n; n = -k; inner(); n = -1; inner(); auto void inner(void) { /* Note that this can see `n` and `k`. */ printf("outer::k = %d\nouter::n = %d\n", k, n); } } You *would* want to declare a function in a non-global scope in the rare case where you don‚Äôt want/need the name symbol to be available outside the function (at compile time; it‚Äôs there regardless at link time). So for example, if you‚Äôre making a library where there‚Äôs a common case that you want inlined (or don‚Äôt care about that much of it being hidden), you could do this in the header: inline void log(int level, const char *p) { extern void log__impl(int, const char *); extern int log__threshold; if(level &gt;= log__threshold) log__impl(level, p); } So anything that includes this code can readily take advantage of inlining in the fast (=hidden) case, and will just call the backend function (which isn‚Äôt supposed to be used publicly, and won‚Äôt have a global symbol emitted) in other cases. Also useful in macros, for the same reason: #define foo(p) do { \ extern void foo__impl(void); extern struct foo_node *foo__queue[2]; if(foo__queue[0]) foo__impl(); } while(0) (I.e., if there‚Äôs something in the queue, make the slower backend call; otherwise just fall through quickly.) This kind of code is reasonable but rare, and I can‚Äôt think of any other good cases where you‚Äôd actually want to prototype non-globally. Maybe if you wanted to choose between two functions like this: #define foo(a, b)((a) ? foo__1 : foo__2)(b) Final note along these lines: It‚Äôs legal to declare more than one function per statement, but I can‚Äôt think of a time I‚Äôve seen it done unless the function‚Äôs type is abstracted behind a `typedef`. Functions tend to have longish decls, and long decls should generally get their own statement so the reader doesn‚Äôt miss something. General rule of thumb is anything much longer or more complex than `int foo` should get its own statement. 3\. `extern` tells the compiler that a declaration refers to something non-`static` that may be outside the current compilation unit. It‚Äôs optional and assumed for (global) function prototypes, though it‚Äôs not a bad idea to use it anyway if you‚Äôre feeling explicit. It‚Äôs required for external variable declarations, because without it the compiler will place the variable in the current compilation unit. (You can issue the same variable declaration multiple times in C as long as there‚Äôs only one definition; in C++ you only get one variable declaration-or-definition unless the decl is `extern`.) So for example: /* in file1.c */ extern int foo; void bar(void) {foo = 2;} /* in file2.c */ int foo = 0; extern void bar(void); int main(void) { printf("%d\n", foo); bar(); printf("%d\n", foo); } This would print `0` first, then `2`, because `bar` is able to get at `foo`. `bar` could also/instead declare `foo` as `extern` inside its own scope, as could `main` with `bar`. IIRC doing this would allow file1.c to create a global `static int foo` without it conflicting with the other module‚Äôs `foo`; however, `bar` wouldn‚Äôt be able to see the `static` `foo` because the `extern` declaration masks it. &gt; The problem with your answer is that even if I were to do all of that, I'd feel like I'm cheating. I understand‚Äîmost of what I was suggesting was because I wasn‚Äôt sure how much you know or were allowed to alter, and a lot of things were of the sort that build/reflect bad habits. Probably a good idea to solve the problem as assigned, then fix it up properly‚Äîeither is instructive, but there‚Äôs a lot wrong (including lesser sins I didn‚Äôt mention) and if nothing else it‚Äôs good practice. At some point every good programmer has to grumble their way through mound-of-shit code some bad programmer left behind, and it tends to look very similar to this. So first, in order to make it convert any number of things, you can just throw `for(;;) {` and `}` around the group of three function calls in `main`. That‚Äôs an easy ‚Äúforever‚Äù loop. (You could `goto`, you could `while(1)`, you could `do`/`while(1)`, whatever.) The minimum possible modification for the early exit part of things, which again is not something I would recommend for real-world code, is to throw `#include &lt;stdlib.h&gt;` up top and after the first `scanf`, do if(!numberToConvert) exit(0); Slightly less-minimum and -rule-breaking would be to bubble up a return value, so instead of the above you‚Äôd change the return type of `getNumberAndBase` to `char` (or some integer type, or `_Bool` if you can use C99, or some enumerated type if you‚Äôre feeling super-Proper), and assign a return value of (say) 0 for ‚Äúdon‚Äôt do this conversion‚Äù and nonzero for ‚Äúdo it.‚Äù Then you‚Äôd do if(!numberToConvert) return /*(say)*/ 0; instead of the minimal-mod condition, and at the end of `getNumberAndBase` `return 1;` to indicate success. Inside `main`, either change the call to `getNumberAndBase` to if(!getNumberAndBase()) break; /* ‚Üê this kills the loop */ Bubbling up a return value lets `main` catch whatever happens and deal with it. Maybe `main` will want to print a message, maybe it‚Äôll want to write something to a file, maybe return something nonzero, etc. etc. Whereas if you run `exit` or otherwise suddenly terminate from within a function call, it‚Äôs considerably more complicated to deal with that. (There is `atexit` to intercept `exit`s‚Äîand only `exit`s, not `_Exit`s or `abort`s or `raise`s‚Äîbut it‚Äôs not the cleanest thing and function pointers are one of the more intimidating parts of the language.) Alternatively, you can hoist `getNumberAndBase` up into the loop conditional, so `for(;;)` would effectively become `for(; getNumberAndBase();)`, which is just `while(getNumberAndBase())`. Note that this nonzero=true=keep going accordance is why I chose zero for the don‚Äôt-convert return value; this is otherwise totally arbitrary, and if you had an enumeration you‚Äôd want to do the more complete while(getNumberAndBase() == GNAB_OK) or whatever. (Cont‚Äôd, gimme a minute‚Ä¶)
(‚Ä¶Cont‚Äôd.) For instructional purposes, I‚Äôll spitball-walkthrough a more ‚Äúperfect‚Äù (by no means all the way perfect, not that that‚Äôs ever possible) version of the program. First though, a couple quick notes on pointers in this context: An array is a sequence of ‚â•0 component values in memory. Strings are represented by creating an array and filling it with characters, so x = "text"; is the same thing as static char ___text[5] = { 't', 'e', 'x', 't', '\0' /* '\0' == 0; NUL; ends all C strings */ }; x = ___text; Input and conversion functions often have more than one kind of output; in this case, we have either a number and base, or some reason why we don‚Äôt have both. In cases like this, usually C functions return a status code and take pointers to wherever outputs should be stashed, or else they mix a return value with the error status (like `scanf`, error or EOF&lt;0; otherwise, number of outputs filled and ‚â•0). This allows the caller to control how data gets passed around, rather than forcing it into a single shared location. Aside from being easier to reason about, this makes sure control and data flow stay bound together tightly. So putting all that to work and adding in some niceties, the prologue would look something like this: #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; /* Constants: */ #define MIN_BASE 2U #define MAX_BASE 36U #define SZ_RENDER_BUFFER 256U /* ‚Üë almost certainly overkill---an n-bit number would require ‚â§n+1 chars */ /* Possible results from getNumberAndBase: */ enum getNumberAndBase_result { GNAB_OK = 0, GNAB_STOP, GNAB_EOF, GNAB_ERROR_INPUT, GNAB_ERROR_EOF, GNAB_ERROR_IO, }; /* Possible returns from `main`: */ enum exitStatus { EX_OK = 0, EX_ERROR_INPUT, EX_ERROR_EOF, EX_ERROR_IO, }; /* Prototypes: */ static enum getNumberAndBase_result getNumberAndBase( unsigned *number, unsigned *base); static unsigned renderNumber( unsigned number, unsigned base, char *buffer); static void prompt(const char *message); Notes: - The `#define`s let you easily parameterize the file, so you can very quickly/easy reconfigure it. You can also wrap in `#ifndef NAME`/`#endif` to let the compiler command-line override the source code. - `enum` gives you a handy way to come up with automatically named integer values (e.g., error codes). Dangling comma is stylistic; permitted by C, lets you add and rearrange easily. - `static` prevents something from being seen (easily, by name) from outside the compilation unit. Inside a function, it also tells the compiler to allocate and initialize exactly one copy of the object, not one per call. - `displayConvertedNumber` has no reason to exist. If you‚Äôve actually converted the number, it should be in a state that can be readily displayed. The original source uses an `int[]` as a buffer for some reason, but making it NUL-terminated `char[]` lets `printf`/(`f`)`puts` use its output directly. - State isn‚Äôt global. Function output comes from return values and via out-arg pointers. - I prototype first, then do `main`, then other stuff. Opinions differ, though mine are the only correct ones. :) Anyway, `main` first: int main(void) { unsigned number, base; enum getNumberAndBase_result res; while((res = getNumberAndBase(&amp;number, &amp;base)) == GNAB_OK) { char buffer[SZ_RENDER_BUFFER]; renderNumber(number, base, buffer); printf("converted number: %s\n", buffer); } switch(res) { case GNAB_ERROR_INPUT: fputs("error: invalid input\n", stderr); return EX_ERROR_INPUT; case GNAB_ERROR_IO: fprintf(stderr, "error: unable to read from stdin: %s\n", strerror(errno)); return EX_ERROR_IO; case GNAB_ERROR_EOF: fputs("error: premature EOF\n", stderr); return EX_ERROR_EOF; } return 0; } Perpetuated state goes in `main`, along with most error messaging and primary (i.e., not prompt, not log) output happens in `main`. Side-effects should be clustered according to use/concern to make reasoning and reading easier. I‚Äôll have to break this rule a couple times below to keep with the overall structure of the original program. GNAB: static enum getNumberAndBase_result getNumberAndBase( unsigned *number, unsigned *base) { int k; prompt("number to convert: "); errno = 0; [`errno` is set either to 0 or an error code by most stdlib and POSIX function. Most of the time it‚Äôs not strictly necessary to set it to 0 yourself, but it‚Äôs a good idea to do so just to be sure you don‚Äôt pick up leftovers. `errno` is a global variable or something roughly equivalent, and it‚Äôs a fine example of global state being a bad idea that everyone is now stuck with forever.] if((k = scanf(" %u", number)) &lt; 1) { if(k &lt; 0) return ferror(stdin) ? GNAB_ERROR_IO : GNAB_EOF; return GNAB_ERROR_INPUT; } [The above assumes that an initial EOF is acceptable, which is reasonable. If the input stream ends, then you should take the hint and politely stop accepting input. If EOF isn‚Äôt acceptable: if(scanf(...) &lt; 0) return ferror(stdin) ? GNAB_ERROR_IO : GNAB_ERROR_INPUT; In case you‚Äôre not familiar, `a ? b : c` means ‚ÄúIf `a`, then value `b`; else value `c`,‚Äù and it‚Äôs super-handy for cases like this. Resuming:] if(!*number) return GNAB_STOP; for(;;) { prompt("output base: "); errno = 0; if((k = scanf(" %u", base)) &lt; 1) { if(k &lt; 0) return ferror(stdin) ? GNAB_ERROR_IO : GNAB_ERROR_EOF; [The original program treats errors inconsistently: If no or bogus input is given, then it leaves the variable undefined and continues (potentially infinitely looping). However, if an out-of-range (=less but still bogus) base is given, it retries the input. Retrying is almost never a good idea, because if you‚Äôre taking input from a file‚Äîand the common case for most non-GUI programs is interacting with non-TTYs‚Äîthen attempting to retry input is going to de-sync you from the rest of input. Usually you should exit with an error, or at least make sure the input‚Äôs coming from a TTY so retrying makes sense. Anyway; option 1, bogus input‚Üíerror: return GNAB_ERROR_INPUT; Option 2, bogus‚Üíretry:] continue; } if(*base &gt;= MIN_BASE &amp;&amp; *base &lt;= MAX_BASE) break; fprintf(stderr, "error: invalid base (min: %u, max: %u)\n", MIN_BASE, MAX_BASE); } return GNAB_OK; } Unfortunately, the way this is structured there needs to be an error message in this function so the user knows WTF just happened, or else you‚Äôd need to break up the function or use error callbacks or something else unseemly or leap-ahead-in-the-book-ly. Normally you should keep retry loops as close to the frontend as possible/comfortable. Moving on to `renderNumber`, where I‚Äôll try to minimize apparent pointer use: static unsigned renderNumber( unsigned number, unsigned base, char *buffer) { unsigned i, j; unsigned ret; i = 0; do { static const char DIGITS[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; [Note that `DIGITS` is only used in this loop, so it‚Äôs declared in the loop body‚Äôs scope. It‚Äôs easy to pull outwards if we need to, and this keeps names from clashing and other code from accidentally (well‚Ä¶ easily) affecting/accessing unrelated code/data. Because `DIGITS` has a fixed value, it‚Äôs `const`; because only one ever needs to exist with one value, it‚Äôs `static`. It would be good to have some sort of (compile-time) assertion that `sizeof(DIGITS) &gt;= MAX_BASE + 1`, but meh. We can &amp; should check that our assumption about the size of the output buffer holds, though.] assert(i &lt; SZ_RENDER_BUFFER - 1); buffer[i++] = DIGITS[number % base]; } while(number /= base); buffer[i] = '\0'; /* terminate the string */ ret = i--; [We don‚Äôt technically need the return value, but it‚Äôs almost free and often useful so we may as well return length. Because it‚Äôs a `static` function, the compiler can trivially do away with any code involved if it‚Äôs not needed. Now we have a buffer with least-significant digits first; we need to reverse it to match hyoo-maan expectations. Alternatively, we could have scanned upwards for the most-significant digit of `number` and filled in the right order to begin with, but it‚Äôs either two loops or a (slowish for non-binary output) logarithm and a loop no matter how you slice it.] for(j = 0; j &lt; i; j++, i--) { char t; t = buffer[i]; buffer[i] = buffer[j]; buffer[j] = t; } return ret; } This could be done more concisely with straight pointers, but a good compiler will pick the best option regardless. Finally, `prompt`: static void prompt(const char *msg) { fputs(msg, stdout); fflush(stdout); } Seems small and pointless, but putting it under a single name it makes it easy to swap out for any other implementation, according to what counts as ‚Äúproper‚Äù output and whether you want to prompt if there‚Äôs no human there. E.g., to determine whether to avoid needless prompting (POSIX-specific): #include &lt;unistd.h&gt; /* ‚Üëup top‚Üë */ static void prompt(const char *msg) { if(isatty(STDERR_FILENO)) { /* ‚Üê could be cached */ fputs(msg, stderr); fflush(stderr); } }
Yup, I saw that as well, he isn't starting increment i to 4 before he uses it.
Notice the date of that article...
And still there are no full C11 support in most OS! 
As far as I understand it `auto` is the default storage class for local variables, and explicitly declaring these `auto` doesn't make them any different from the parameters. Please correct me if I've misunderstood.
This subreddit is meant to discuss the C programming language. Please direct your C++ related question to r/cpp_questions.
No worries! Thanks for your cooperation.
Thanks for the reply. It's weird, because when I input a string like this: "12 24 46 68", it runs normally, but if I place a zero on the front ("0 12 24..."), it seems to jump-cut right to the next line (I forgot to mention that the program reads multiple lines of a file, the lines being in this format, and converting them into characters.) I suspect that it has something to do with the while() loop.
Thanks for the reply! Yeah, the nul char printout is intended (if the original input has '0' in it, of course). I am not quite sure of what you meant by nul-terminated string; is that one where operations stop when it reaches nul? If so, then I didn't intend for that. My current objective is to simply recognize the numeric strings ("12 24 36 48..."), and split them between the whitespaces, storing its integer-equivalent char into the array listConvert[]. I have the array length and the number of characters I want to process, but I am not sure how to include the NUL char into this, too.
* [*The Little Book of Semaphores*](http://greenteapress.com/wp/semaphores/) is both free and excellent. It's not C, but it's trivial to translate into C. * *Programming with POSIX Threads* by David R. Butenhof is a great introduction and overview of pthreads. * [*Futexes Are Tricky*](https://www.akkadia.org/drepper/futex.pdf) by Ulrich Drepper gives a peak at how incredibly tricky it is to do get everything right without using the higher-level synchronization primitives. 
Does you input string look like "74 74 74" or "74 74 74 0" The former will give an array lineConvert containing 3 characters `JJJ`. The latter will give an array lineConvert containing 4 charactes `JJJ\0` If it is the former, then you cannot pass that array to printf and fprintf because they rely on a terminating nul to know where the end of the string is. If it is the latter, then the array is compatible with a string and you can use strlen, printf etc with it. But it also means that you can only have a nul at the end. If there is a nul at the beginning then printf will that that is the end of the string.
Thanks for the reply! Both inputs are allowed (it depends on the file being read). And yeah, the problem I encountered is that these files have a null in it, so it terminates. Other than fprintf, what functions should I use that would allow this?
fwrite takes a buffer and number of bytes to write.
Excellent thank you, this sounds like exactly what I need. Some looking around suggested using vectors of `uint` and then defining some macros to quickly index bits, but I imagine this library will be more optimised than anything I could dedicate time to.
Where do you think `start_server()` and `start_client()` are defined?
Ok, I put that in the header files, but it still doesn't like it (same error). My IDE gave a syntax error warning when I tried to add it to the .c files (which makes sense I guess). I'm sure I've mixed c and cpp before, and don't ever remember having to do this.
&gt; g++ main.cpp Foreman.o Miner.o -o run It also doesn't look like you're linking with tcpclient.o and tcpserver.o 
I had thought that too, but when I rewrote the demo rule in makefile as demo: Foreman.o Miner.o g++ main.cpp Foreman.o Miner.o TCPServer.o TCPClient.o -o run I got g++ main.cpp Foreman.o Miner.o TCPServer.o TCPClient.o -o run TCPServer.o: In function `main': TCPServer.c:(.text+0x69): multiple definition of `main' /tmp/ccCcjlxU.o:main.cpp:(.text+0x0): first defined here TCPClient.o: In function `DieWithError': TCPClient.c:(.text+0x0): multiple definition of `DieWithError' TCPServer.o:TCPServer.c:(.text+0x0): first defined here Foreman.o: In function `Foreman::Foreman()': Foreman.cpp:(.text+0x1d): undefined reference to `start_server(int)' Miner.o: In function `Miner::Miner()': Miner.cpp:(.text+0x27): undefined reference to `start_client(char*, char*, int)' collect2: error: ld returned 1 exit status make: *** [demo] Error 1
Those errors suggest that you have a `main` in main.cpp and TCPServer.c Each function can only be defined once.
A string search in TCPServer.c for "main" in my IDE returns nothing.
&gt; g++ Foreman.cpp TCPServer.o Your main is in main.cpp. And you're not linking with that.
See edit. Somehow I had deleted the -c flags when editing my makefile.
Might as well go with Go if you want highly concurrent, lock-free code. You'll be using queues and channels I assume, if you don't want to be locking memory regions.
Channels in Go are implemented using locks anyway, I want to do all my work in C. Go is a nice option for doing concurrency but I want to know more on the C side of things..
A lot of the new features in C11 were tacked on a little awkwardly, so it‚Äôs probably going to be a bit before they‚Äôre widely available. [The way they specced threads was kinda bogus](https://gustedt.wordpress.com/2012/10/14/c11-defects-c-threads-are-not-realizable-with-posix-threads/), for example.
Interesting. Dig it on later! 
"Handmade Hero multithreading". There's a playlist on youtube.
Besides what has already been mentioned in this thread I'd say look up OpenMP for shared memory and MPI for distributed memory. Both are commonly used in HPC algorithms.^[citation ^needed]
There is no way you're overcomplicating things, because no matter how complicated you think memory management works, *it's even worse*.
Hehehe, Thanks man :)
[Here's](http://arjunsreedharan.org/post/148675821737/write-a-simple-memory-allocator) a good article on how to write a simple memory allocator.
Looks like you never initialize i?
You initialize it after it's use though. You use I to access the emp array, and then set I to 0.
oh okay, i must have accidentally added that second int to i
Thanks! Will check it out.
If OP mentioned high performance as in HPC then this is the answer to follow. The vast majority of applications use them nowadays. For C multithreading go with OpenMP, since MPI is multiprocess (the next step). http://www.openmp.org/resources/tutorials-articles/
There is no `extern "C"` in C, this is a C++ only feature. The usual trick is to begin your header files with #ifdef __cplusplus extern "C" { #endif and end them with #ifdef __cplusplus } #endif This makes C++ compilers see all declarations as `extern "C"` whereas C compilers don't see that. You should also change your makefiles to compile C programs with `gcc` instead of `g++` as the former is the C frontend and the latter is the C++ frontend.
I keep meaning to find a use for this http://www.hboehm.info/gc/ dunno if it might suit your application....?
I'd recommend CMU's 15213 course video lectures and slides. They're available [here] (https://www.cs.cmu.edu/~213/). One of the labs in the course actually covers writing your own allocator.
&gt; have you tried implementing them on your own? Yes, but failed miserably. &gt; have you ever done any multithreading of your own? Yes, but none of which I wrote had good quality code and good performance. Also, [this](http://bholley.net/images/posts/thistall.jpg) pisses me off so badly.
If you can describe what went wrong when you attempted it, I can help you out and potentially guide you along the right path. You didn't try using `free` directly without some kind of memory reclamation technique (like hazard pointers), did you? You didn't try recycling nodes ergo exposing yourself to the ABA problem did you? Did you appropriately make use of certain memory barriers and/or atomic operations over normal load/store operation and use the appropriate read-modify-write atomics? There are tons of ways you could have 'failed miserably', but I'd need to know which one and what you've attempted thus far (like source code) to provide feedback. Also to write multithreaded code, you merely need to expose yourself to it. My first exposure was writing a thread-pool using pthreads, mutexes and condition variables, and a simple FIFO queue. To learn anything you need adequate exposure and some guidance in the right direction.
fuck it, i suck so the code stays scuffed, i sent a link for code in colour http://prntscr.com/ima1pj SORRY
You need to put four spaces in front of every line of code so reddit formats it correctly. Please edit your post to fix the formatting.
ok thanks i finally made it
* [Github](https://gist.github.com/) * [Pastebin](https://pastebin.com/) 
i think the code is good in my post now?
Binary, hexadecimal and decimal are *representations* of a number. In your application, the binary number is just a string of ones and zeroes that you interpret it as a number. &gt; how does line 9 work? ( byte |= (1&lt;&lt;(7-i)); ) `1 &lt;&lt; x` is a common construct to get a number whose `x` th bit from the right is set. `x` is in this case `7-i`. Because you read the digits from right to left, you must start with `7` (`1 &lt;&lt; 7` is `10000000`) and go downwards with each digit. `byte |= y` is just shorthand for `byte = byte | (y)`. &gt; 1)does/how does the computer know that the 1 is binary and 7-i is decimal? in (1&lt;&lt;(7-i)) Without any indication, the C compiler just interprets these digits as decimal numbers. Also, `1` in binary is also `1` in decimal. &gt; 2) when i = 5 it enters the if statement, and byte =0 -&gt; byte= 0 |(1&lt;&lt;(7-i)) so byte = 00000100 when the whole for loop is done then byte = 00000101 not 5 right??? `byte` can either be represented as a `5` in decimal or `101` in binary. Remember, it is just an **representation** of a number. They both have the same value. &gt; printf("%d", byte); shouldnt work then?? since byte = 00000101 and not 5 See above. `%d` prints the number as a (signed) decimal number. There is also `%x` for unsigned hexadecimal and `%o` for unsigned octal. Note that there is nothing for printing as binary.
Thank you for you help.
* https://danluu.com/malloc-tutorial/ * http://www.labbott.name/blog/2016/10/06/write-your-own-kmalloc/ * "Implementing Malloc: Students and Systems Programming" - http://www.cs.cmu.edu/~bryant/pubdir/sigcse18.pdf - worth reading even if just to make sure you aren't making any of the mistakes/omissions students implementing `malloc` have; the part on programming style (Section 4.2) is a must read /* macros (ab)use isn't as necessary as it used to be */ * https://github.com/angrave/SystemProgramming/wiki/Memory,-Part-1:-Heap-Memory-Introduction, https://github.com/angrave/SystemProgramming/wiki/Memory%2C-Part-2%3A-Implementing-a-Memory-Allocator * A Malloc Tutorial - http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf * https://wiki.osdev.org/Writing_a_memory_manager * Ryan Zezeski's Memory by the Slab: The Tale of Bonwick's Slab Allocator + http://paperswelove.org/2015/video/ryan-zezeski-memory-by-the-slab/ + https://www.youtube.com/watch?&amp;v=UQVd9mZr-jI + Paper: https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a + Slides: - https://speakerdeck.com/paperswelove/memory-by-the-slab-the-tale-of-jeff-bonwicks-slab-allocator - https://zinascii.com/pub/talks/mem-by-the-slab.pdf 
See edit in the OP. Question though: why would all that stuff you mentioned matter if I can get it to compile like I did anyways? Who cares if I use g++ to compile my c files?
You need to specify `extern "C"` because C functions have (a) different calling conventions and (b) have different name mangling than C++ functions (as in, usually none at all). If you don't tell the compiler that the function has C linkage, behaviour is undefined. This might manifest itself as linker errors or erratic programs. &gt; Who cares if I use g++ to compile my c files? The compiler uses different default settings depending on whether it is invoked as `gcc` (the C compiler) or `g++` (the C++ compiler). Compiling C code with `g++` is only possible for compatibility reasons and may cause weird errors (such as wrong language versions or accidentally compiling C code as C++) depending on your compiler configuration.
OK. I just want to double check, how do you use extern c in a header file? The example you gave doesn't seem consistent with ifdef I've seen before.
You do it as I said in [this comment](https://www.reddit.com/r/C_Programming/comments/81i9uf/linker_not_finding_functions_undefined_reference/dv45z35/). You can specify `extern "C"` like this for a single declaration: extern "C" int foo(int); or like this for multiple declarations: extern "C" { int foo(int); } The example I give above generates an `extern "C" { ... }` for C++ compilers but nothing for C compilers as they don't understand `extern "C"`.
Just an approach in mapping the functional data types `Maybe` and `Either` to plain C. :)
Isn't this a typo - ` Maybe(foo) maybeFoo = Just(foo, 2);`. Shouldn't this be ` Maybe(foo) maybeFoo = Just(2, foo)`.
Correct, I also thought about getting rid of the type in that case but have no solution yet. 
Heriot Watt?
c++? lmaoooo
As a programmer who does both C and C++ for $$, personally I think this is a great idea. C is a dangerous, possibly outdated language, but C++ is in my opinion an unnecessarily complicated language with not much going for it. Sure, you get OOP + the ability to get close to the metal, but you also get all the weird quirks (rule of 3, lvalue and rvalue rules, move constructors, etc.) of a 20+ year old language, much of which has been bolted on to the (much more elegant) original. (I've programmed professionally in python, java, c, c++ and 68k asm for over 20 years, and know objective-c and swift pretty well, so I'm fairly well versed in languages). 
My basic motivation was to find out which hacks are needed to get these great data types into the language. If I would prefer a systems programming language with functional aspects I think Rust can be a good choice too.
Yep go is really a fast learning language but also has no Maybe or Either type. :-/
I'm a big fan of swift. This is probably why the idea appeals to me so much. 
Garbage Collection isn't quite what I need... But it still seems like an interesting read, I might use it in future projects. Thanks!
thank you for the quick answer! i dont really understand why this code below dosent work since byte has the same value as it did in the original code example? ------------------------------------------------------------------ #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { unsigned char byte = "00000101"; printf("%d", byte); return 0; } --------------------- it prints out 0 and not 5.... 
Definitely helpful, thanks for the link.
Look at existing simple memory managers, like uClibc or phkmalloc. There is a [collection on Github](https://github.com/emeryberger/Malloc-Implementations).
A lot of links to pull from, thanks!
thank you for the quick reply again but excuse my stupidity, i dont understand how/where byte goes from a string to a number. byte |= (1&lt;&lt;(7-i)); simply makes byte have the binary value "00000101" which is the same as 5 in decimal, but isnt it the "%d" in printf("%d\n", byte); that decides to print it in decimals? without the "" on "00000101" it would be 101 in decimal right? isnt it that which makes the computer understand that its binary and not decimal? or is the "" just for a string? and the zeroes and ones just takes a spot in the array? 
Usual use cases for both types are error handling related. If I do not need a detailed error type then I usually stick to 'Maybe'. If I need a more detailed explanation or error code then initialization with Either can be pretty handy: I have the ability to return Either an error or a valid object of some type. :) Both types are Sum types in type theory, which also allows to convert one into another. But this is not implemented yet. Also default functions are not implemented yet, something like: "give me the inner value of the maybe type and if not existing a default one). 
&gt; or is the "" just for a string? and the zeroes and ones just takes a spot in the array? Yep. In `char str[] = "00000101";`, you can do `str[0]` to get `'0'` and `str[5]` is `'1'`. It is just an array of characters(/digits), not a number. &gt; without the "" on "00000101" it would be 101 in decimal right? Actually, any number starting with `0` is getting interpreted as octal by the C compiler, so in decimal it is 65. &gt; i dont understand how/where byte goes from a string to a number. In the loop, you check each character of the string and when they're `'1'`, you do something special (modifying `byte` based on the position in the string). Try to trace it for yourself, step by step.
Used instead of special values to signal an error. So `fread` could instead of using 0 to signal either an EOF or an error (Because it can't tell you directly which one it is), could return a normal 0 if it's EOF (Since an EOF is not an error), and return a None value (or, better, an error type that includes the errorno) on error.
i have: the for loop runs 5 times before it enters the if statement with the values (i=5,byte = 0) then assigns byte with the current byte value (0000000) added with (1&lt;&lt;(7-5)) which is 00000000 + 00000100 =00000100 then it runs the for loop 2 more times and enters the if loop with values (i=7,byte=00000100) then assigns byte with the current byte value (00000100) added with (1&lt;&lt;(7-7)) which is 00000100 + 00000001 =00000101 so byte = 000000101??? which is not a string, and not number 5. shouldnt it be 65 that is printed out? like how this prints out 65: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char byte = 00000101; printf("%d", byte); return 0; } what step am i doing wrong in my tracing?
 &gt;so byte = 000000101??? &gt;which is not a string, Correct. &gt;and not number 5. Incorrect.
then why does char byte = 00000101; printf("%d", byte); print out 65 and not 5? "any number starting with 0 is getting interpreted as octal by the C compiler, so in decimal it is 65."
&gt; ...C is a dangerous, possibly outdated language... wat?
I'm not sure but what I think you're saying is the compared to C the newer languages (rust, ,etc) don't have a compelling reason to exist. If that's what you mean, then what _I_ mean is that IMHO the language should prevent you from doing something dangerous unless you explicitly force it to do so. An example would be, in keeping with this thread: no NULL in the language. (Another would be explicit ownership rules of resources). 
&gt; To each one's own. I've fixed so many bugs over the years (mine and others') that I'm really quite ready to have the language help to avoid them. Uh, I didn't say that. I guess you're just trolling. However, to each one's own. I've fixed so many bugs over the years (mine and others') that I'm really quite ready to have the language help to avoid them. 
You guys need to be more creative. I've heard this one for years! 
Define the counter as a global variable int _for_counter; #define FOR(X) for (_for_counter = 0; _for_counter &lt; X; _for_counter++) 
I feel silly having asked this because I forget that #define is done during compiling rather than during runtime. 
What if your code needs to be reentrant?
Tfw rule of 5 now...
What does that mean in this context?
It means your idea breaks if you nest `FOR` macros, even across function boundaries (ie, an outer `FOR` calls a function in the loop that inside tries to use this macro). 
Also in multi-threaded code it would break.
Follow-up question: how do you do this? I tried: #define FOR(X) int c # __LINE__; ... and: #define C(x, y) x ## y #define FOR(x) int C(c, __LINE__); ... and a million variants (with ID applied in various spots) of: #define ID(x) x #define C(x, y) x ## y #define FOR(X) int C(x, ID(__LINE__)); ... and can't get it to expand out __LINE__ properly. I know I've done this at least once before, but I can't remember what the trick is.
What is c99 Any good resources to learn ?
Ah, yes you need a couple of levels of indirection for the preprocessor to see `__LINE__` in the right way and to treat it as a macro parameter. #define C2(X, Y) X##Y #define C1(X, Y) C2(X, Y) #define C C1(c, __LINE__) C
Right...I don't know how I could fix it to work in those cases.
It's seems to be an interesting question but I'm curious as to why you would ever actually need to do this?
To expand on /u/jedwarsol's answer, the general idea is to create a new scope using the `{ ... }` construct so variables you create do not leak to the outside. For example, the J interpreter defines: #define DO(n,stm) {I i=0,_n=(n); for(;i&lt;_n;i++){stm}} Note that this approach doesn't exactly mesh well with the syntax you desire.d
Rust? There are almost NO Rust jobs. And NO big corporation will choose Rust over C, C++, R. Rust might have a great future, but today it is just a StackOverflow hype! 
I would recommend the greatest C99 book out there: [C Programming: A Modern Approach - K. N. King](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504) But if you already know C basics, just go with [C: A Reference Manual -Harbison/Steele](https://www.amazon.com/Reference-Manual-Samuel-P-Harbison/dp/013089592X) 
Again, there are jobs. I don't know how all those people pay their bills otherwise. Soooo, could you just stop trolling, just because *you* ain't got a Rust job? (Might also be so because you don't know Rust well enough).
&gt; PS: I still hope a new safer C arrives! [It did.](https://en.wikipedia.org/wiki/Cyclone_(programming_language)) Dead on arrival though.
No. They get paid for Rust. Yes, there are not a majority, but it's a good market still.
Well, this is something I can understand, depending on the current job, city etc. As someone interested in security and systems programming, Rust is definitely a player.
I've used it a lot. It's nice. Going from garbage collection to manual deallocation is a royal pain, though. Wouldn't advise doing that.
What happens when you hit a serious issue (such as GC latency) and have to stop using GC entirely? Then your code has a million memory leaks and you're dead in the water until you've fixed them.
Why do you need the C1-C2 indirection?
I've used it, but that's a very very very long time ago (in 2002 or so?), both as GC for a Java-to-C transpiler for embedded POS systems (m86k and ARM based), and also as a leak detector. I don't remember much except that we never really had issues with it.
&gt; Does it just make the preprocessor easier to implement? No. It's so you can stringify or concatenate stuff without having it expanded. For example, suppose you want to make an array containg signal numbers and their names. You could initialize the array like this: const char *signals[] = { [SIGTERM] = "SIGTERM", [SIGKILL] = "SIGKILL", ... }; but this is repetitive, so you might want to make a macro like this: #define SIG(x) [x] = #x If the argument to `#` was expanded, this would fail and the lines would look like this after preprocessing: const char *signals[] = { [15] = "15", [9] = "9", ... }; The only way this could possibly work is if `#` stringifies unexpanded tokens. The same kind of reasoning of course applies to `##`.
Aha! Enlightenment! What I know as X-macros would be broken if it weren't for this.
This seems like a homework problem. Rather than handing you a solution, can you tell us what you've tried and where you are having trouble?
Wow! That was a great read. Thank you very much. I ended up taking the easy route (using an infinite loop with a condition to test if the return value of GNAB was non-zero and terminating the program if it was zero) but I learned a whole lot after reading this. I keep falling in love with the language, wow. May I ask how you know so much about C? And what can I do to achieve that level of knowledge?
ok. Tips: f(n-1) and f(n-2) are going and getting the numbers in the positions one and two before the position you are currently working out. You could just make your loop remember the last two values it produced in temporary variables and add them to your accumulated total.
It is *blog spam*, because it is very low quality and riddled with advertisements. If your post is nothing more than a solution to some simple exercise you got in class, it is not welcome in this subreddit. Nobody wants to see these. Indeed, people should do their homework on their own. Nobody learns anything by copying other people's solution from shit blogs like yours. So please fuck off with this sort of content.
My tip: try to think about this problem a bit longer. Try to work out the computations on a sheet of paper, then think about what part you are doing again and again. That's what goes in your loop.
&gt; Is there any harm in implicitly casting between unsigned short and uint16_t or explicitly? There can be. `uint16_t` is guaranteed to be 16 bits, whereas the standard guarantees that `unsigned short` will be *at least* 16 bits. In practice, `unsigned short` will usually be 16 bits, but I find it better not to take the chance. &gt; When should I be using fixed width integers over just int or short int? In this instance I think it would be best to only use fixed width types from `stdint.h`. &gt; I've noticed some people will instead use bit masking and shifts to write one byte of an integer at a time to the buffer array, but that seems like a bit of a pain in the ass. It absolutely is, but it also guarantees uniformity. I'm not an expert in this area, and haven't done this myself, so take my conjecture with heaps of salt, but: I imagine this would work by writing the 8 least significant bits to the buffer, truncating those bits off the value (right shift), and continuing this process until the value is 0. This requires you to delimit numbers within the buffer, but also allows you to send numbers of any size. This also has the benefit of side-stepping endianness if you size the elements of your buffer to 8 bits, since you've set the order for bytes. It's worth noting that if you're guaranteed to only be sending 16 bit values, then it's a waste, because the delimiters add an additional 50% to your buffer size, but in that case just use `uint16_t` and if you need to cast from `unsigned short` verify that the value isn't larger than 16 bits before casting. I hope that helps, but most importantly if anything I've said is wrong, misleading, or poor practice, please correct me and downvote.
You can use a struct to make it more readable: struct header { uint16_t len; uint16_t offset; }; void hton_header(struct header *h) { h-&gt;len = htons(h-&gt;len); h-&gt;offset = htons(h-&gt;offset); } void ntoh_header(struct header *h) { h-&gt;len = ntohs(h-&gt;len); h-&gt;offset = ntohs(h-&gt;offset); } int main(void) { int sockfd; struct header header, myheader; header.len = 64; header.offset = 12; // Disclaimer: that's not a proper way to read or write to a socket, // it's here just for demonstration purposes. // send header hton_header(&amp;header); write(sockfd, &amp;header, sizeof header); // receive header read(sockfd, &amp;myheader, sizeof myheader); ntoh_header(&amp;myheader); assert(myheader.len == header.len); assert(myheader.offset == header.offset); } Well at least imo it's more readable
I'd like to add a little something. &gt; When should I be using fixed width integers over just int or short int? When you care about memory layout (which is mostly when serializing data), use fixed size ints. Otherwise, use your usual `short`, `int`, etc. As u/Newt_Hoenikker mentioned, `unsigned` is at least 16 bits, but it can also be larger, say 32 bits, if it'll work faster that way.
so i got here: int f(int n) while (n&gt;0 &amp;&amp; n &lt;3){ n=1; } while (n&lt;=0){ n=0; } what should i do with the last line? 
I think that structs aren't guaranteed to be byte aligned/differences in padding, so writing out the struct to my buffer or to the socket isn't guaranteed to be de-serialized on a different platform correctly.
So it should always be safe to cast from uint16_t to an unsigned short, but not necessarily safe to cast from unsigned char to uint16_t? How would I be able to check if it is safe to cast from unsigned char to uint16_t?
&gt; from unsigned char to uint16_t You mean 'from unsigned int', right? Well, you can just compare the value to `UINT16_MAX`.
Yes, my mistake, edited to correct. Thank you for your assistance, getting confused by all the integer types. 
Since you are sending values over the network as `uint16_t`, i'm assuming you never planned to have the values of `len` and `offset` to be greater than `UINT16_MAX`. I.e. if the value is bigger, than it's a bug. So I would write assert(len &lt; UINT16_MAX) (don't forget `assert.h`) just before the assignment to `uint16_t`, so it would fail and you can find the source of the problem.
Since you are sending values over the network as `uint16_t`, I'm assuming you never planned for `len` and `offset` to be greater than `UINT16_MAX`. I.e. if the value is bigger, than it's a bug. So I would write `assert(len &lt; UINT16_MAX)` (don't forget `assert.h`) just before the assignment to `uint16_t`. If it fails, it's a bug, if it doesn't it's a ~~feature~~ safe conversion.
It works as an analogy if that's your concern, but it is certainly not the only way to think about multi-dimensional arrays.
This is known as pointer tagging, maybe you can find more information if you search that.
&gt; Is it always safe (C standard wise) to cast a pointer to an unsigned long? Generally no. It is only safe to cast T* to intptr_t and uintptr_t and vice versa. However Linux requires following data sizes: sizeof(char) == 1 sizeof(short) == 2 sizeof(int) == 4 sizeof(long) == sizeof(T*) sizeof(long long) == 8 If Linux would‚Äôve been written in modern C, they would‚Äôve used uintptr_t instead of unsigned long for adsresses.
&gt; As long as any flag is &lt; size of the struct file, then it can ORed in and masked out later? Other answers have addressed the casting. The availability of flags depends on the alignment of the allocation. E.g if the memory allocator always allocates on an 8-byte boundary then the lowest 3 bits of any pointer value returned from it will be 0. And you can "safely" use those bits because you know that they must be restored to 0 before using the value as a pointer.
Thanks.
 int f(int n) int i,j; for(i=0;i&gt;n,i++){ if(n&gt;0 &amp;&amp; n &lt;3) n=n-2; } for(j=0;j&gt;n;j++){ if(n&lt;=0) n=n-1 } something like that?
&gt; Data is stored contiguously from {r_0 c_0, r_0 c_1...r_n c_n}. Doesn't have to be. What if you're working with Fortran style column-major 2d arrays?
Please only post content in English.
Any reason they cant write thr worlds biggest Sed command to change it over. üòõ
C is pass by value, so if you want a function to modify a value passed to it, you pass a pointer to it. Obviously, there‚Äôs more that you can do with pointers. But the first thing is to nail this basic use case. Anything advanced in C, such as data structures will require you to use pointers. The simplest linked list in C, is a struct with one of its elements being a pointer to a struct of the same type as itself. Pointers also to implement a rudimentary form of generic programming, a void* can point to any type, so your linked list can have its data as a void*.
Here's the Wikipedia article on Linked list with a simple implementation in C. The implementation uses int data in struct node, but if you used void* data, you can store any kind of data, not just integers. https://en.wikipedia.org/w/index.php?title=Linked_list&amp;oldid=8887076#Language_support
What do you get for a sample input? What do you expect to get?
You *are* using pointers, though. You can't avoid them when passing an array to a function. (Personally, I'd use qsort()...)
It is! I'm trying to use bubble sort since its one of the simpler sorts, but there are errors in my code and I don't know which they are. Enlighten me please!
You appear to be neglecting to end your strings with null terminators. After the `for` loop in `intToStr()` add a line like `result[i] = '\0';`. What's happening is `printf()` is printing the string until it reaches the `'\0'` character, which is why you're getting those garbage values. Them being largely integer values and variants of `Kw` I suspect is a coincidence. Hope this helps.
Beginner's mistake, whoops! I got it to work for both positive and negative integers, but whenever there is a 0 at the end of the integer, it doesn't get converted because of the condition of the `while`loop. I tried a couple of things and they didn't work. Do you know how I can fix this bug ^^i ^^mean ^^feature ?
Part of your problem is printf("%d", dec); Dec is a float, so printing it with %d will give nonsense. Fix that, then see how your outputs go with your inputs
This first case should be obvious. Put the zeros on the left side of the number and they are gone forever, so 2450 becomes 542. You‚Äôll also get bad results if the reversed number won‚Äôt fit in the number of bits in an int (a 16-bit int can represent a positive signed value of 32767 but not 76723.) The second should also be obvious: strings must end with a ‚Äò\\0‚Äô character. You don‚Äôt add that so you are printing whatever is left in the array result[] on the stack. A better approach is to write a ‚Äò\\0‚Äô at the end of the array then write the digits from right to left, then use the pointer to the last character written to the array which will be the first valid character in the string. Note this still won‚Äôt work for negative numbers. Finally, another common error you might see is having intToString return a pointer to the local variable result[] which no longer exists when the function returns. Don‚Äôt do this!
You're right. I just fixed it and now I'm getting other numbers as output. At least these are actual floats, but they are nothing like those of the expected output. 
How could I do that with C? I'm very new to programming and the C language, so it's pretty difficult to do this. Could you help with some pseudo code?
I'm assuming your homework assignment specifications require you to not use functions from `string.h` like `snprintf()`, because that is how I would do this without restrictions. Trying to stay in keeping with your current algorithm, I would change your `while` loop to determine how many digits are in `n`, assuming `m` digits I would place a `'\0'` at `result[m]` and then change your `for` loop to place each digit, starting with the m^th digit at `result[m-1]` and the 1^st digit at `result[0]`. I hope I didn't spell that out too much, as I don't want to rob you of the chance to learn from experimentation. Most of all I hope I've been helpful.
&gt; Would that have any performance penalties compared to just doing type &gt; puning? The good news is that modern compilers produce efficient code for your `read_be32()` function. Here's how GCC compiles it: mov eax, [rdi] bswap eax ret That's perfect, and way you wrote it is clean, portable, and correct. The type punning shown your original question is undefined behavior and violates strict aliasing. Don't do that. 
__attribute__ isn‚Äôt C. As a practical matter on a system with 8/16/32/64 bit ints and byte level addressing a struct will align on the largest boundary for the elements in the struct and only pad as needed, so a struct of only uint16_t values will have no internal or trailing padding and an array of that struct won‚Äôt have padding between each struct. By not using poorly defined nonsense like ‚Äúpacked‚Äù your code will work on any C compiler and you won‚Äôt have to guess what happens when your POSIX system defines uint16_t with another non-C feature to mandate that it will be aligned on a 16-bit boundary. Does this or packed win? Avoid it altogether. As for this working portably without all the extensions, this has worked on systems meeting the word and addressing requirements for dozens of operating systems with dozens of compilers over many decades. Explicit padding with only fixed width types both internally and trailing generally deals with the corner cases.
Your code has a few problems. First off, the inner for loop doesn't behave like you think. It will further increment 'i' until the end of the string, but you're including the ASCII value of '.' while calculating the dec variable ('.' - '0' is equivalent to 46 - 48 == -2). Furthermore, 'j' is incremented but isn't applied anywhere else in the code. Were you trying to use 'j' as the inner loop variable? Also, if the dec variable is supposed to represent the accumulated number to the right of the decimal point, I'm pretty that your current calculation won't work. Here's a sample implementation that changes some things: ***Keep in mind that the snippet is by no means the most efficient way to solve this problem. It also assumes that the user provides well-formatted input (virtually no error checking done here). *** #include &lt;stdio.h&gt; #include &lt;math.h&gt; //needed for the pow(double x, double y) function float strToFloat(const char string[]) { int i; int j = 0; int ten = 0; float dec = 0; //initialize to zero float result = 0; for (i = 0; string[i] != '\0'; ++i) { if(string[i] == '-') continue; //skip to next iteration if string contains '-' char at front if (string[i] == '.' &amp;&amp; string[i+1] != '\0') //additional check to see if there are any chars following decimal point { for (j = i+1; string[j] != '\0'; ++j) { /*Calculate value to right of decimal point. similar technique to result's calculation*/ dec = (dec * 10) + (string[j] - '0'); ten = j-i; //keep track of the number of inner iterations } break; //you've grabbed every digit. Break from the outer for loop. } else { result = (result * 10) + (string[i] - '0'); } } /*the denominator variable is the divisor of the final division calculation. The number of inner iterations (ten variable) is the power of 10 that we need as the divisor. If the value to the right of the decimal is '234', then denominator will be 10^3 = 1000. This is because Length('234')=3, which is the number of inner iterations. */ float denominator = pow(10, (float)ten); /* Now we'll multiply the value to the LEFT of the decimal with the denominator calculated above. This is setting up the value of the dividend for the final division calculation. Following from the example above, if denominator is 1000 and the value to the left of the decimal point is '11', then temp will be 11 * 1000 = 11000. */ float temp = result * denominator; /* This expression will compute the final value of the dividend. We're simply adding the value to the RIGHT of the decimal point to temp's value from above. Following from the examples above, if the temp was computed to 11000 and the value to the right of the decimal point is '234', then temp's final value will be 11000 + 234 = 11234. */ temp += dec; /* The hard part's over. The reason we went through all of that trouble is that now we can simply divide by the magnitude of the value to the right of the decimal point (1000 from the running example) to get the final answer. So 11234/1000 = 11.234, which was the original string. */ result = temp/denominator; if(string[0] == '-') result *= -1; //if the string represented a negative number, perform the conversion here. return result; }
I‚Äôm on a tablet so I won‚Äôt guarantee it (I like to run real C code before releasing an example but I don‚Äôt have access to a real system with a compiler at the moment.) If there are errors hopefully the comments will give you clues to follow up with your favorite C documentation. \#define BUFLEN 81 char result \[BUFLEN\] // 0..BUFLEN-1 char \*s s = result + BUFLEN - 1 // point to last character in array \*s = ‚Äò\\0‚Äô do // do this at least once so if n==0 we still get a zero \*‚Äîs = (n % 10) + ‚Äò0‚Äô // predecrementing s leaves it pointing to the last character written n /= 10 while n printf ‚Äú%s\n‚Äù, s As for negative numbers, C allows for a variety of formats where sign-magnitude and one‚Äôs complement can have negative zeros and two‚Äôs complement has one negative value that has no positive equivalent. You may never see anything but two‚Äôs complement going forward but it‚Äôs good to understand binary representations of numbers if you are already down at this level.
As it turns out, `__attribute__((packed))` is not fully supported on [TCC](https://bellard.org/tcc/) (which some people use to build linux kernel, so it's a big deal), so yeah, I should've been more careful. &gt; Does this or packed win? Avoid it altogether. Yes, I have to agree with you here. It'll be more portable that way
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://bellard.org/tcc/) - Previous text "TCC" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
linux is typically ILP32 or LP64. Windows as well as an assortment of large proprietary systems made when ‚Äúall the world was a VAX‚Äù are P64 (sometimes called LLP64) where pointers are 64-bits but longs are 32-bits. As for linux, the idea of fixed width types either explicitly build into other languages or done with macros in C well predates linux so it was more a function of it being built by people inexperienced with coding for multiple architectures.
First thing you should try is instead of d.word[i] (and d.word[j], etc) you need to be using the form d[i].word. This will give you the word part of the ith element in d[]. You can see the exercise uses this form when it prints the dictionary before and after the sort. This will probably get rid of the pointer errors. After that your sort still won't work because you are using the &gt; sign to compare the char arrays which doesn't work like you would expect it to. Try using a function like strcmp if you are allowed.
Hey mate. 1) use vim. It's a pretty old text editor and you might have it on the server you're using, meaning that you can develop locally and remotely. It has a lot of features tied to keyboard shortcuts so your best bet is to save/print out a vim cheat sheet (https://rumorscity.com/2014/08/16/5-best-vim-cheat-sheet/ number 1 is what I use, and I still use it as a reference). Also make a simple vimrc file with at least 'set number'. 2) buy "the c programming language" by kernigan and Ritchie. It's old but is still the standard. It has a Wikipedia page. 3) best practice won't mean much for apps that small, just learn and work through the examples in the book. If I had to give pointers, I'd say two things: - learn to use a makefile, so you can compile your program with one command. This will help with the second pointer - make small changes and compile often. E.g. Don't try and write 100 lines of code and then see if it runs because if it doesn't you've got to find a bug in 100 lines of code. Even if you're writing dummy output e.g. printf("hello") you'll be able to see where and when certain code blocks are being executed. 
First, do you use Windows, Mac, or Linux. This changes how you develop in C and C++. Windows And Unix systems have different compilers, which can be annoying for a person starting out. Second, do you have interest in micro controllers or kernel development? If not, then you should learn C++ or Python. Not C. Third, you bring a student means you can get the best IDEs for free. If you are on windows, grab visual studio. If you‚Äôre on mac or Linux, I suggest CLion from jet brains. Lastly, should you choose C++, focus on using the standard libraries in a modern way. This will make your code more portable (compatible with more devices). Also, it will teach you good programming practices. I would absolutely not suggest C for a beginner programmer with no interest in developing professionally. It‚Äôs like having a software engineer bend tubes to make a heat exchanger in a heat transfer class. Way too low level. 
To improve readability, you can use macros (haha): #define SERIALIZE16(PTR, VALUE) \ (((*(uint16_t *) (PTR)) = htons((VALUE))), ((PTR) += 2)) #define DESERIALIZE16(PTR) \ (((PTR) += 2), ntohs(*(uint16_t *) ((PTR) - 2))) #define SERIALIZE32(PTR, VALUE) \ (((*(uint32_t *) (PTR)) = htonl((VALUE))), ((PTR) += 4)) #define DESERIALIZE32(PTR) \ (((PTR) += 4), ntohl(*(uint32_t *) ((PTR) - 4))) int main() { char buf[6]; uint16_t val1 = 12; uint32_t val2 = 36; void *ptr = buf; SERIALIZE16(ptr, val1); SERIALIZE32(ptr, val2); void *myptr = buf; uint16_t myval1 = DESERIALIZE16(myptr); uint32_t myval2 = DESERIALIZE32(myptr); printf("%d %d\n", myval1, myval2); }
Is your school server Linux or Unix based? Yes there are free tools. If you have a mac, use Xcode. If you have Windows, use Visual Studio. If you have linux, well you should already know what you use. Some really good books on C out there. I like C primer but there are lots of good ones. For practice, just do as much programming as you can. I once wrote a program for a sophomore level class that was 1800 lines long. I then re-wrote it in 600. I told my teacher that I felt bad about throwing away all that work I had done, but his comment was that I didn't waste any of it... rather that I gained 1800 lines of experience. And he is right. Do all the assignments you do multiple times in as many ways as you can and you will massively ahead of your peers. 
msgpack is great. https://msgpack.org/ For C, I like this implementation: https://github.com/clwi/CWPack 
I think they stick with C89 because many embedded systems still only support that or something.
 #include &lt;math.h&gt; int main(void) { float arr[] = {NAN, NAN, NAN, NAN, NAN}; } 
Null in c is for pointers only. I don't think you can create a nan array for integets
It's best to avoid complicated stuff like that... they're doing it to remain compatible with ancient ABIs (the SysV ABI is over 30 years old) in new code, try to write stuff as straight forwardly as possible.
Isn't it probably just a macro from math.h though?
uh, the format of LP64/LLP64 etc is that everything mentioned in the acronym is 64 bits, in those cases, longs and pointers, and long long and pointers. Anyway, I don't get why Windows uses LP64 instead of LLP64, they should've left all the previously defined types the same and just added a new long long one for 64 bit.
Thank you! but how do I declare it if I want to create a bigger array, say: float arr[50]? 
Same as initializing with any other value. for (size_t i = 0; i &lt; sizeof arr / sizeof *arr; i++) { arr[i] = NAN; }
Yeah so, C is really good if you want to stay close to the hardware. The processor doesn't actually have a "NaN" value. It has 8 bit, 16 bit, 32 bit, and 64-bit numbers. None of the combinations of 0's and 1's mean "NaN" to the processor. If you make your own programming language, like python, you can create a structure like this: struct extended_int { int number; bool NaN; } and then create special operators like + and - that do extra checks. But C compiles basically straight to assembly- and assembly only recognizes integers and floating point numbers (signed and unsigned) of different sizes, and has a limited number of arithmetic it can do. It's possible that the _compiler_ can allow you to use NaN and then provided limited debugging/error feedback if you use it in a weird way- but C doesn't.
why not memset?
I'm not going to just give you the answer, but I'll put together the parts you have right and add the line I've been hinting about. int f (int n ) { // n is less than 1 if ( n &lt;= 0) return 0; // n is 1 or 2 if ( n &gt; 0 &amp;&amp; n &lt; 3) return 1; // n is more than 2 // initialise tmp1 to remember f(1) and tmp2 to remember f(2) int tmp1 = 1, tmp2 = 1, ans; int j; for(j=0;j&lt;n-2;j++){ /* TODO: Calculate the next fib number here. f(3) can be calculated right away. f(4) will go round the loop again and need you to update the last two numbers you are remembering in the tmp variables. */ } return ans; }
It seems like that the problem is some were else.. Anywho, thank you. Have a great day :) 
I don't think memset works correctly for floating point, because it casts to char (aka unsigned int).
&gt; None of the combinations of 0's and 1's mean "NaN" to the processor. ** Yes it does. All ones is a NaN value, for example.
Saw [this](https://stackoverflow.com/a/1565469/7841202) beautiful solution on stackoverflow. I'd put everything in a header, like this: #define VAL_01(...) (__VA_ARGS__) #define VAL_02(...) VAL_01(__VA_ARGS__), VAL_01(__VA_ARGS__) #define VAL_03(...) VAL_02(__VA_ARGS__), VAL_01(__VA_ARGS__) #define VAL_04(...) VAL_02(__VA_ARGS__), VAL_02(__VA_ARGS__) #define VAL_05(...) VAL_04(__VA_ARGS__), VAL_01(__VA_ARGS__) #define VAL_06(...) VAL_04(__VA_ARGS__), VAL_02(__VA_ARGS__) #define VAL_07(...) VAL_04(__VA_ARGS__), VAL_02(__VA_ARGS__), VAL_01(__VA_ARGS__) : : #define VAL_27(...) VAL_16(__VA_ARGS__), VAL_08(__VA_ARGS__), VAL_02(__VA_ARGS__), VAL_01(__VA_ARGS__) : : You can use it like this: float arr[50] = { VAL_50(NaN) }; or if you only want define VAL_[2\^N] you can do this: float arr[50] = { VAL_32(NaN), VAL_16(NaN), VAL_2(NaN) }; Or if you want an array like this: arr[50 * 2] = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, ..., 1, 0, 1, 0, 1 } you can use float arr[50] = { VAL_50(0, 1) };
I recommend the GNU toolchain for free programming software. They are available for Windows, Linux, and macOS. For Windows: http://gnutoolchains.com/ GNU gcc (C/C++ compiler): https://gcc.gnu.org/ GNU make: https://directory.fsf.org/wiki/Make More GNU software: https://directory.fsf.org/wiki/GNU
Luckily setting a float to all 1 bits (0xFFFFFFFF) is a Nan. So memsetting with 0xFF will work.
You are practically there. You have three small errors. 1. Your code doesn't compile. Always check your code compiles before posting it. It's a trivial fix this time, but in more complicated cases people are going to abandon your question. 2. You are remembering the last number by storing it in z. You need to remember the last two numbers though. You have to store z in i before updating z. 3. You'll need to play with the initial values for i, j, z and ans to account for f(1) and f(2). Tackle these problems **in order** and you'll have it.
Please do not post code on paste bins with expiration dates. I want future readers to be able to learn something from this post, this is not possible if your code is unavailable.
i actually fixed the second one and removed it again when i was rewriting earlier. thanks for pointing the others out. in my life in general i could benefit from trying to be more organized, i am really feeling the consequences of not being organized in a systematic way and paying in bugs in this endeavor. more stuff to work on i guess. :^)
Back there in 70s years, C++ was an extended C with class... But nowadays C and C++ are totally different programming languages. It is like comparing Java with Python! Whoever write C/C++ deserves to be called retard! 
&gt; Anyway, I don't get why Windows uses LP64 instead of LLP64 Windows uses LLP64. [I've read about that](https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563) ([the dead link is actually this one](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384083\(v=vs.85\).aspx)) and one reason is to keep structures and stuff the same size otherwise processes probably have problems reading existing binary data, resulting in potential compatibility problems and it's easier to port.
what the fuck is this. 
So... How are you trying to print the values?
How are you printing it?
Yes that is correct
A request for exercises.
Ok. However, I moderate this subreddit so I get to decide what is on topic and what not. Your post is not. Have a nice day.
You have to be careful because old MIPS treat "all-bits-1" as a [*signaling* NaN](https://en.wikipedia.org/wiki/NaN#Encoding), so you'll get a floating point exception if you try to use one. It's much safer to use the macro `NAN` from C99, which is guaranteed to be non-signaling.
Is this important to put here? Do your work yourself? I think this is the stupid thing you do.
&gt; Second, do you have interest in micro controllers or kernel development? Not to hijack OP, but I've been trying to find a sensible platform to start working with micro controllers. I use Linux (Ubuntu and Puppy). Any suggestions?
You have to terminate your strings. Most, if not all C string functions assume that the string will be terminated with '\0'. So, you need to add this character to the end of your string. If you don't the string will just continue into your programs memory until it *does* hit a terminating character.
Thank you for the explanation! Works as expected now.
build a basic reverse polish notation calculator. The wikipedia page explains what it is, how to implement it and gives an example run through with some actual inputs/outputs: https://en.wikipedia.org/wiki/Reverse_Polish_notation
It‚Äôs all personal choice. I come from a Java background, so I use option 1 and 3 because I‚Äôm not a fan of memory allocation. I guess if you are familiar with pointers and memory then use option 2. It‚Äôs really just personal preference.
 &gt; // 2. dynamically allocate everything but I have to manage my string lenghts &gt; char **strings_ptr; &gt; size_t lengths[MAX_COUNT]; // ?? &gt; size_t count; You don't need to store the lengths. You don't necessarily need to store the strings count either (just build a NULL-terminated list of strings). Roughly : char **read_all_strings(...) { char **str_list; size_t str_count=0; char *new_str; str_list=malloc((str_count+1)*sizeof(char *)); str_list[0]=NULL; while(new_str=read_a_string(...)) { str_count++; str_list=realloc(str_list, (str_count+1)*sizeof(char *)); str_list[str_count-1]=new_str; str_list[str_count]=NULL; } return str_list; } int main(void) { char **strings_list; int i; strings_list=read_all_strings(...); for(i=0; strings_list[i]; i++) { printf("string %d = %s\n", i, strings_list[i]); } } (not tested)
Also if the strings are `'\0'` terminated, `strlen` can tell the size.
Yes, I was thinking about that too, but I don't know where I can find the code for the caller to main. 
Hello, this is my code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int lignes = 5, colonnes = 5, i, j, k; int **arr = (int **)malloc(lignes * sizeof(int *)); for (i=0; i &lt; lignes; i++) arr[i] = (int *)malloc(colonnes * sizeof(int)); k = 0; for (i = 0; i &lt; lignes; i++) for (j = 0; j &lt; colonnes; j++) arr[i][j] = k++; int *a = arr[1]; int **b = arr+1; for (i = 0; i &lt; lignes; i++){ for (j = 0; j &lt; colonnes; j++){ printf("%d ", arr[i][j]); } printf("\n"); } printf("%d, %d, %d \n", *(a+1), **(b+1), *(*(arr+1)+1)); return 0; } 
arr looks something like this in memory: 0,1,2,3,4 5,6,7,8,9 10,11,12,13,14 15,16,17,18,19 20,21,22,23,24 arr[0] would point to the zero-th row, arr[1] to the first, and so on. When you increment an int pointer, the compiler doesn't care about the array you're pointing to or its dimensions. It simply increases the address it's pointing to by sizeof(int).
What happens instead?
Read my post again. Windows uses P64. It‚Äôs like ILP32 but pointers are 64-bits, which wouldn‚Äôt be the case if they left the previous types (which include pointers) ‚Äúthe same.‚Äù Too much code incorrectly assumed *long int* would always be 32-bits so Microsoft punted. It‚Äôs not like the 1978 K&amp;R didn‚Äôt warn people... The C99 standard introduced the *long long int* type and mandated a minimum range of +/-9223372036854775807 which cannot be represented in less than 64-bits so they are by definition at least 64-bits everywhere.
May i ask why you want to do this?
&gt; If not, then you should learn C++ or Python. I understand that you mean well, but this isn't really good advice at all. &gt; Lastly, should you choose C++, focus on using the standard libraries in a modern way. Oh, you're one of those misguided C++ people. Perhaps you should be in a C++ subreddit, reminding each other to use the latest C++ standards so that you're not [evil](http://yosefk.com/c++fqa/picture.html#fqa-6.16) or unfashionable or whatever. You should perhaps consider a career with Swift or a functional language so as not to fall behind. &gt; It‚Äôs like having a software engineer bend tubes to make a heat exchanger in a heat transfer class. Way too low level. So then you recommend Common Lisp? OCaml? 
What microcontroller? [Arduinos are easily available and seem to use C.](https://www.arduino.cc/en/Main/FAQ#toc13)
Well, \*(a+1) is essentially the same as \*(\*(arr+1)+1), as \*(arr+1) is the same as int\* arr[1], so \*(\*(arr+1)+1) reduces to \*(arr[1] + 1) = \*(a + 1). \*\*(b+1) is incrementing the row, as it's a double pointer. It's incrementing from arr[1] instead of arr[0], though, as b was defined as arr + 1 = arr[1]. I'm terrible at explanations, so here's someone much smarter on SO: https://stackoverflow.com/questions/7586702/is-2d-array-a-double-pointer
That's equivalent to `float arr[50] = { NAN, 0, 0, 0, ... };`, sadly.
The first thing is that you have to terminate your strings. Second, I'm not sure if this has anything to do with it but it might, malloc allocates chunks from a linked list which have specific sizes (powers of two iirc), so it will always give you 16 bytes when you ask for 10, for example.
If you‚Äôve gone through a first programming and a data structures course in C already these might be good next steps. If not, start with those courses or equivalent. While type casting wasn‚Äôt unique to C, in the modern era C‚Äôs ability to map structures onto blocks of memory remains one of the few reasons one would use C over other high level languages. In particular, learning alignment and padding will be extremely important. It‚Äôs also important to learn about a concept known as ‚Äústrict aliasing‚Äù as most people [who] don‚Äôt understand it can‚Äôt diagnose the bugs they are writing. Figuring out how to open an MP3 file and make sense out of the headers and metadata might be big enough to have to learn issues of casting, alignment, padding, etc... without being too much to eat at one time. Pulling apart the bits of graphics file formats which aren‚Äôt compressed is another option. Learn to use the ‚Äúfixed width types‚Äù from &lt;stdint.h&gt;. If you have more than one machine on a home network you could use superuser/root access and write simple binary protocol stuff. You could write something that does an ARP request or ping and processes the return packets. This will force you to understand the OS specific APIs in more detail and learn how to read the RFCs which define network protocols. On a different note, C has concpets such as ‚Äúunspecified behavior,‚Äù ‚Äúimplementation defined behavior‚Äù and ‚Äúundefined behavior.‚Äù These allow for *properly* written C to run on wildly different systems unchanged but most C developers never learn these concepts and freak out when their code no longer works the same as it did on one OS with one processor with one compiler and everything build with one set of flags. You don‚Äôt really learn C by simple trial and error on one system.
I think you can split the 2D array arr[M][N] into M one dimensional array whose length is N.these 1D array 's first element ' address form a new pointer array.Then in this way *(arr+i) is the pointer of arr[i][0],so *(*(arr +i)+j) equals arr[i][j]
Really? I thought the standard stated that the last element specified was to be used for remainging elements. I must've misremembered. 
I can't use any function like that, but I can make my own string-comparing-function, so that's what I did. I also made a function that calculates the length of the string and use `for` loops to assign each character of d[i].word to temp, d[j].word to d[i].word and temp to d[j].word. However, when the program prints an output after printing the dictionary before the sorting, the output is an infinite loop of only one word. How can I fix that? This is my code: #include &lt;stdio.h&gt; struct entry { char word[15]; char definition[50]; }; void dictionarySort(struct entry d[]); int compareStrings(const char s1[], const char s2[]); int stringLenght (const char string[]); int main(void) { struct entry dictionary[100] = { { "ajar", "partially opened" }, { "aerie", "a high nest" }, { "affix", "to append, attach" }, { "agar", "a jelly made from seaweed" }, { "acumeen", "mentally sharp; keen" }, { "ahoy", "a nuatical call of greeting" }, { "aigrette", "an ornamental cluster of feathers" }, { "abyss", "a botomless pit" }, { "addle", "to become confused" }, { "aardvark", "a burrowing african mammal" } }; printf("NO SORT DICTIONARY\n"); for (int i = 0; i &lt; 100; ++i) { printf("%s %s\n", dictionary[i].word, dictionary[i].definition); } dictionarySort(dictionary); printf("SORTED DICTIONARY\n"); for (int i = 0; i &lt; 100; ++i) { printf("%s %s\n", dictionary[i].word, dictionary[i].definition); } return 0; } void dictionarySort(struct entry d[]) { int i, j, k; char temp[9]; for (i = 0; i &lt; 100 - 1; ++i) { for (j = i + 1; j &lt; 100; ++j) { if (compareStrings(d[i].word, d[j].word) == 1) { for (k = 0; k &lt; stringLenght(d[i].word); ++k) temp[k] = d[i].word[k]; for (k = 0; k &lt; stringLenght(d[j].word); ++k) d[i].word[k] = d[j].word[k]; for (k = 0; k &lt; stringLenght(temp); ++k) d[j].word[k] = temp[k]; } } } } // Function to compare two strings int compareStrings(const char s1[], const char s2[]) { int i = 0; int answer; while (s1[i] == s2[i] &amp;&amp; s1[i] != '\0' &amp;&amp; s2[i] != '\0') ++i; if (s1[i] &lt; s2[i]) answer = -1; else if (s1[i] == s2[i]) answer = 0; else answer = 1; return answer; } int stringLenght (const char string[]) { int count = 0; while (string[count] != '\0') ++count; return count; } 
I tried this, but it ended up outputting only `0` for every test case. And everything you wrote in your implementation seems to make sense. I don't understand...
You helped a lot! Thanks! I ended up following what you said, but there wasn't any output, and I can't find my mistake. Could you please help? I don't know what I'm doing wrong. void intToStr(int n) { int i,right_digit; int temp = n; int count; char result[81]; if (n &gt;= 0) { // reverses integer while (temp != 0) { temp /= 10; ++count; } // adds each digit to character string for (i = count; i &gt;= 0; --i) { right_digit = n % 10; n /= 10; result[count - 1] = right_digit + '0'; } result[count] = '\0'; } else { // integer becomes positive n = -n; temp = -temp; // reverses integer while (temp != 0) { temp /= 10; ++count; } result[0] = '-'; // adds each digit to character string for (i = count; i &gt;= 0; --i) { right_digit = n % 10; n /= 10; result[count - i] = right_digit + '0'; } result[count] = '\0'; } printf("result: %s\n", result); }
Call [exit(1);](http://en.cppreference.com/w/c/program/exit)
Oh, FFS. Why didn't I think of that?! Thanks so much! Also, for further reference, what's the difference between return 1; and exit(1)? And what happens if I call exit(1) in main(); would it have the same effects as return 1;? Thanks again!
The difference is what you wanted - calling exit ends the program immediately. Something watching the program can't tell the difference - the program will end cleanly with a status of 1 in both cases
Ah, got it. Thanks!
I'll be surprised if you have that much stack space.
r is not initialized so this program is exploiting undefined behavior. There is no justification as to why the program outputs what it does as far as ISO C is concerned, because the program is not valid. 
What result did you expect?
ASCII letters are in alphabetical order. ... RST... So the code for 'T' minus 2 gives the code for 'R'. 
I picked up the O'Reilly book on using and understanding pointers. It's made it all a lot easier for me to understand. 
&gt; r is not initialized r = x - 2 ;
&gt; calling exit ends the program immediately. * Provided nothing has been attached to `atexit`
Have a look at this [ASCII Table](https://www.asciitable.com/). When you assign `char x = 'T'`, what you are really doing is assigning `x` to decimal 84. `r = x - 2` is, in this case, equivalent to `r = 84 - 2`. Now, if you take a look at the ASCII table, you'll find that decimal 82 is 'R'. That's why you get an output of 'R'.
What may be missing for your understanding is that everything that a computer can manipulate is a number or a sequence of numbers : images are numbers, sounds are numbers, this website is numbers, basic text is numbers. So since text is numbers, individual characters are each represented by a unique number also. The relation between a number and its character is called an "encoding". The most basic encoding of characters is ASCII+ and it can only encode 255/256 symbols or letters. That's so they fit in a single octet (byte of 8 bits). Your char variable is a 1-byte long integer number. When you assign 'T' to it you tell the compiler to give it the ASCII value of T (84). The reason you can type 'T' instead of 84 is called syntactic sugar. Some syntaxes are redundant so that the programmer can deal with more important issues. Now your char is 84. You substract 2 from it so you get 82. Then you ask it to print on the screen but as if it was a letter or ASCII symbol. 82 is the encoding of the letter R. That's what you get.
This is the explanation IÔ∏è needed, thank you!
`count` isn't initialized to `0`, but should be, because as of right now your code increments some arbitrary value in your `while` loops. Your `for` loop for positive values only sets a value for `result[count - 1]`, but the general problem with your loops is much larger as changing `result[count - i]` when `i` starts at `count` and decrements to `0` will fill digits in reverse order. Those are the main things I think you need to change in order to have a functional program. On a more organizational note that is completely personal preference, you have *a lot* of repeated code. The way I would remedy this is by having an `if` statement check if `n` is negative, and if it is increment `count` and set `result[0] = '-';`. It is also worth noting that you don't need to change `temp` or `n` if `n` is negative, because your `while` and `for` loops should work the same way regardless (integer division always truncates toward zero regardless of sign). Hope that helps.
Inspiration my foot. This is only to impress others that you are doing good for others. stop asking such a fucking question on such a good platform. 
I guess that depends on what you‚Äôd like to do with the micro. If it‚Äôs just learning and maybe a few tasks, then an Arduino is a great place to start. Past that, there are other hobby grade controllers that take minimal set up. If it‚Äôs the setup itself that you‚Äôre trying to learn, then you could pick up anything on digikey and have a go, depending on where you live. I‚Äôll try to find a better suggestion. 
This is hilarious. Are you racist and nationalist too, or is your idealism and pride only tied to a programming language?
Yeah this is a pretty tough project for a beginner, but you are actually extremely close. There's nothing wrong with your sorting algorithm :). The issue is actually in your first question. You need to be appending the null terminator after its respective for loop, i.e. the line tempWord[k] = '\0'; needs to be after the first for loop, and so on for the other word transfers. The reason for this is that after the second for loop, k = length(d[x].definition). So if you put d[x].word[k] = '\0' after the second loop, you'll actually be modifying the character that would be at the end of the definition, not at the end of the word. As a result this null terminator isn't really doing anything, since it'll be out further in memory than it should be. If you make this swap your code should work fine (I ran it on my own machine to check). If it's still not working keep asking questions here! As an aside, assuming you are learning on Linux and using gcc and such, I recommend getting familiar with gdb ASAP. gdb is a debugger that will let you step line-by-line through your C code as it's running, and also let you check the values of variables and such to see what is going wrong. It can seem a little daunting at first, but once you get the hang of it (and the basics aren't too difficult) it will really help you, even at the beginner phase. I'm a university student and we were taught gdb within a month of starting C, and it helped me immensely! If you are not on Linux, I'd recommend learning whatever debugger is available in your IDE.
So the algorithm itself has a runtime of O( 2^N ), so the function calls 2 functions each iteration... That's one reason and the other reason could just be the hardware I'm running with (i7) and with the amount of computations that get put onto the the CPU could just be what causes it to take a while. I had it running for about 2 hours before killing the process because it had not completed.
GP's point is that in Java, almost everything uses the heap whether you like it or not.
x86_64 has NAN. It has an FPU. The newest x86 CPU without an FPU was the 486SX, if I recall correctly.
Right, I didn't realize there was a bit representation of NaN in FPU's until I dug into this. I guess there are a couple NaNs. I guess I just don't know how it's treated in C. Are operations defined for NaN?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [torvalds/linux/.../**exec.c** (master ‚Üí ce38061)](https://github.com/torvalds/linux/blob/ce380619fab99036f5e745c7a865b21c59f005f6/fs/exec.c) ---- 
Thank you. :) 
I recommend reading https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
Code blocks are not done using `-----` but by indenting with 4 spaces as described in the submission guide.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
I'm not trying to impress anybody and apart from you (who seems to have a peculiar connection to blog spammer /u/mukeshkumarphd2014), nobody seems to understand it this way.
Which doesn't call `fflush(NULL)` and doesn't invoke all the `atexit` handlers, so don't use it unless you understand the consequences.
 unsigned long fib(unsigned long first, unsigned long second, int n) { if (n &lt; 1) { return second; } return fib(second, first + second, n - 1); } int main(void) { unsigned long ans = fib(N); printf("%lu\n", ans); return 0; } Is this what you were looking for? its recursive and can be tail call optimized by the compiler.
thanks buddy i shall get on this. 
The upper right portion of the convex hull would be non-defeatable. But I have no idea how to find them with O(1) space.
Are you allowed to mutate the array itself?
I guess just sorting the array for either X or Y and picking up the last element should find the undefeated entry (say sort by X and find the pick the last point, this should cause all other points to fail the X1 &gt; X2 check). Sorting can be done in nLog(n) time complexity and (1) space complexity. 
Hi SS0113, You've had a few answers tossed at you, I want to help break it down a little and give a small warning. bhrgunatha explained memoizing (**N.B.:** NOT memorizing, memoizing). It's a decent approach if you'll have long program duration and multiple calls to the same function. It will be a little more taxing memory wise however since you are storing extra info (the memo isn't free) FUZxxl mentioned an iterative method. This would use a for or while loop instead of recursive function calls. I suspect you've done this one before (though some CS programs prefer to introduce recursion first, which has its merits, so maybe I'm wrong) Both he and wudangmonk also mention tail recursive methods. Your solution uses recursion (self calls) but not in a way that the compiler can use tail-call optimization. wudangmonk's solution does take advantage of this. So what's the big difference? Let's lay some groundwork out. In order to use tail-call optimization, the call has to be in a tail position. This can be tricky sometimes. Tail-position is essentially where a subroutine can exit. Sometimes this will be the syntactic end of a function, sometimes it will simply be a return nestled in an if structure. Other times, you may have something like this res = foo(val); return res; the foo(val) there is in tail position. so let's alter it with a few permutations return foo(val) + 1; Though foo(val) looks like it's in tail position, it isn't. We have to return from the call then modify it. This is akin to what you are doing above. return (cond) ? 0 : foo(val); Again, this looks like tail position, but it isn't. If this feels odd, don't be alarmed. It can take a bit of practice. For tail-call optimization to work, you want to call a reduced form (something that will lead to function termination) in that tail position. In wudangmonk's solution, the if(n &lt; 1) gives us the base case (where we can terminate the recursive calls) and the other portion gives us a reducing self-call, since we call ourselves with n - 1. the compiler can see this, and won't put more frames on the stack. Under the hood, his solution can be reduced to something like this label_top: if (n &lt; 1) return second; temp = first; first = second; second += temp; n -= 1; goto label_top; might be mincing something, but, in the assembly your "call" instruction (maybe a raw instruction, might be a pseudoinstruction, it will still push the stack) is gone completely, so you stay in the same frame. I hope this helps a little bit.
Create a 1D array with numbers 1-9 inserted, and shuffle the values. Then iterate over the array, and insert the value at that index. Since all values in the array are unique, you will not insert a duplicate anywhere. You're using C++, not C. So, #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;algorithm&gt; int main() { int numbers[] = { 1,2,3,4,5,6,7,8,9 }; std::srand(std::time(0)); std::random_shuffle(std::begin(numbers), std::end(numbers)); for(int i=0; i &lt; 10; i++) std::cout &lt;&lt; numbers[i] &lt;&lt; " "; std::cout &lt;&lt; std::endl; }
&gt; That's one reason and the other reason could just be the hardware I'm running with (i7) and with the amount of computations that get put onto the the CPU this should be faster than a single screen frame on a black and white gameboy the problem is that you've re-done every step on average 1,267,650,600,228,229,401,496,703,205,376 / 2 times try just not doing it the wrong way once instead of blaming the hardware
the stack space is limited by the call depth, not the call count, so it'll only ever need 102 (one for the outside call, one for the terminating call) stack elements, which pretty much everything has
Learning and tasks for sure (for example, a hydration sensor for my garden) and perhaps robotics after that. I've just checked Digi-Key. Wow! I don't even know where to start there.
One potential reason: What if the code that you wrote intending to work as a standalone program, now needs to be converted into a library? Imagine the frustration if the library calls exit instead of returning an error code! In general, "good programming practice" includes cleaning up the state that you created. It is like curly braces: close required for every open. This avoids potential memory leaks, handle leaks, and is less sloppy to deal with and maintain.
Thanks -- I'll look at them both.
Fair enough, thanks!
First it leads to hard to decipher code. Second it leaves memory and the stack in a fragmented state that either the compiler or the OS has to handle. Ever hear of a 'memory leak'? When a program exits and doesn't clean up the environment properly it relies on less efficient methods to do it. Third is that it can leave files/handles/pipes open. Say you open a file to write data but some random function exit()s. Now you have a dirty file system. The general jist is that if you use system resources, you should/need to clean them up. Free memory, close files etc etc Just bailing in any random function does not allow any of that to occur. 
Ah, ok. Thanks!
Thank you!
So I checked out the CS50 IDE quickly (apparently I can use it with an edX account?) and it does have gdb. To give you the basics, when you run gcc, also include the "-g" flag. For example instead of gcc -o hello hello.c, you would run "gcc -g -o hello hello.c". This tells gcc to make your program debug-able. After that you can run gdb on your program with the command "gdb &lt;program name&gt;", i.e. "gdb hello" in my example. The super basics of gdb are as follows: there are things called "break points", which are essentially just particular lines where the program will *stop* executing when it gets there. To set a break point, type "break &lt;line or function where you want it to stop&gt;". For example, the command "break main" will cause the program to stop running at the main method, and "break 50" will cause the program to stop running when it reaches line 50. The command "run" will start your program, and after it hits a break point, you can use "next" (or "n" for short) to run the next line of code. The command "step" (or "s" for short) does the same thing as next, except it will 'step inside' function calls. FOR EXAMPLE: I write this program, hello.c: #include &lt;stdio&gt; int main() { printf("Hello World!\n"); return 0; } Now running the command "gcc -g -o hello hello.c" creates the hello program that is also debug-able. Now I run "gdb hello" to start gdb on my program. The inside of gdb will look pretty similar to the command prompt you've been using already, except the start of the lines will say "(gdb)" instead of "~/workspace $" or whatever shows up in your IDE. The first command you should type is "break main". This tells GDB that when you start running the program, you want it to stop at the main method to let you step line by line. Next you type "run", and your program will start. Now if you type "next" or "n" you will advance line by line through your program. Pretty cool! To exit gdb, type the command "quit". http://web.eecs.umich.edu/~sugih/pointers/summary.html this link has brief descriptions about some more of the gdb commands, but for now just knowing how to "break main", "run", and use "next" and/or "step" should be enough. There are other more in depth tutorials online if my tutorial wasn't good enough haha.
It helped a lot. Thank you. I did what you recommended (both in the organizational context and the functional one) and this is what I came up with: void intToStr(int n) { int i, right_digit; int temp; int count = 0; char result[81]; if (n &lt; 0) { n = -n; ++count; result[0] = '-'; } temp = n; // reverses integer while (temp != 0) { temp /= 10; ++count; } // adds each digit to character string for (i = 0; i &lt; count &amp;&amp; n != 0; ++i) { right_digit = n % 10; n /= 10; result[count - i - 1] = right_digit + '0'; } result[count] = '\0'; printf("result: %s\n", result); } It works perfectly now! However, I still have one question: you said that there is no need to change `temp` and `n` if `n` is negative, but when I executed the program without doing that change, it was not working. Do you have any idea why that may be?
Forgot to mention that the gdb command "print &lt;variable name&gt;" will display the value of the variable as of whatever line of code you are currently examining. I'd suggest making a dummy C program (maybe one that just has a variable that you change the value of) so you can mess around with the basic gdb commands.
That's my bad. I had forgotten that modular division returns a negative value when operating on a negative dividend. Glad you got it working!
Thanks for everything!
&gt;Second it leaves memory and the stack in a fragmented state that either the compiler or the OS has to handle. Ever hear of a 'memory leak'? When a program exits and doesn't clean up the environment properly it relies on less efficient methods to do it. I'm pretty sure it would just be faster to exit than to free all your memory and then exit. 
C != C++. there is no right or wrong ways to do something, just better and worse.
that's not the programs call to decide how much cpu it gets. every program gets as much as possible if it requires any. very simplified: programs that don't need much cpu are usually depending on some kind of i/o. while reading from a disk oder waiting for some network packages no cpu power is needed.
What does your program spend most of it's time doing? Profile it and see. Then figure out how you can reduce that. If it's just doing some sort of loop like: while(1) { // do stuff } Then you might have to add some calls to sleep() or something similar to slow down how often it loops.
you need to show how you created your file pointer, fp1. My hunch is it is not a valid file on empty file.
You probably don‚Äôt want to do that. Let the OS determine when your program sleeps. Unless you‚Äôre waiting for some event.
Not sure exactly what your programs doing, so it's hard to say. Just add a small sleep to the thread and it won't use 100% anymore. `struct timespec sleep_time; sleep_time.tv_sec = 0; sleep_time.tv_nsec = 1000000; //1ms while (1) { if ((time(NULL) - last_time) &gt; period) { nanosleep(&amp;sleep_time, NULL); } }`
Most applications don't actually run all the time. They spend almost all of their time waiting for something to happen, e.g. for user input or for data to arrive. Thus they consume very little CPU time. If your program is doing computations, of course it consumes all CPU time available. Why should your CPU sleep when there is work to do anyway? This is not a problem though: The operating system employs a sophisticated *scheduling algorithm* to make sure that every process gets its fair share of the CPU time. Processes that do less overall are typically given slots quicker than processes that spend all their time running, so you should normally not notice a huge difference. If you want to reduce the impact of your program on other applications, you can tell the operating system that you are a nice process by lowering your priority (the higher the niceness the lower the priority) with `setpriority`. This causes the operating system to favour scheduling other processes instead of yours, making the system more responsive overall at some performance impact for your application.
So you basically want us to explain how to do a simulation of SRTF scheduling?
Yes and no. But thats why i aked that question because i wasn't sure if i had to write to the file in order to get my end result or if i had to program/print out the headers(PID,arrive,burst,remain,finish,wait) # of process, # of context switches, then calculate the remain,finish, wait,averages, total # of process and context switches and final "insert" the file into the code to print out my end result 
&gt;write to the file to get my end result I have no idea what you mean by this. I think you‚Äôre supposed to calculate the stuff you don‚Äôt have. I don‚Äôt see what the alternative is.
&gt; ptr=fopen(name,"r"); so instead of reading the file, i would write instead as such below &gt;ptr=fopen(name,"w"); 
That will just truncate the file. What I meant was that I don‚Äôt see how writing (or appending) to the file is going to get you closer to the end result.
Yes i agree. I just wasnt sure if i would have to write to the file to get my end result. Thats what was making this confusing. I simply didn't know if writing to the file was the way to do this or if that aprroach was wrong and i just had to program code to get my end result. Sorry for so much confusion
&gt; So basically the OS manages all of that for me and I don't need to do anything? Exactly. &gt; App Nap, and timer coalescing? I have no idea what ‚ÄúApp Nap‚Äù is. Timer coalescing is an operating system programming technique were timers are made slightly less precise to save wake ups, this is automatic, too.
[Here's NASA's C styling guide](https://www.google.ca/url?sa=t&amp;source=web&amp;rct=j&amp;url=http://homepages.inf.ed.ac.uk/dts/pm/Papers/nasa-c-style.pdf&amp;ved=2ahUKEwik0P-H-tjZAhUIXK0KHXarCZwQFjAAegQIBxAB&amp;usg=AOvVaw2zH17ikqSOqUmWDtJh6MKM)
Is that K&amp;R C? May be a bit outdated
Probably, I just think it's pretty cool and lays out some simple stuff. It is dated 1994
There are 2 "classes" or types of string in computing. There are NULL terminated, C style strings. and there are structs or classes in OO that contains an array of a string type (bytes, short ints, long ints generally), with a variable that contains the size of the string at whatever "resolution" (for example in Unicode it could be code units, or code points, or something else entirely, hell it could be a linked list containing an encoded codepoint in whatever unicode transformation format you want for example UTF8, UTF16, UTF32) The easiest to deal with is a NULL terminated array, and generally it would require less memory than the other options described above, for example if your string can be long than 255 "characters" (you decide what that means to you) then a NULL terminator would take up less memory than a dedicated variable containing it's size. Also, you can easily deal with string literals with the array approach, where with a struct/class method you'd need to use operator overloading to get the same benefit, and C doesn't have that.
It's not a string if it doesn't have a \0 in it. It's just a bunch of bytes. If you can't put into words how to know when you've reached the end of your bunch of valid bytes, then you can't put it into code. So, how is it you know you're at the end of your bunch of bytes?
Yes, the OS manages them too, but it's different. The types of apps /u/FUZxxl is talking about are "compute bound" apps. Say you have to write a big C++ app for school that balances big trees or something, or you build ffmpeg on your machine and run it in Terminal. These are classic "compute-bound" apps that just use as much CPU as they can while they do their work, just like running on Unix in the 80's, and the OS treats them that way, too. Most apps you run on macOS aren't like those, though. The vast majority are interactive apps that spend most of their time idling and waiting for user input; a much smaller number are daemons, or faceless background apps, that do things like checking for updates regularly. These aren't straight POSIX apps but Cocoa apps written in Swift and Objective-C and using Apple-specific APIs like Cocoa and Cocoa Touch. Mostly you have to use these APIs to get the more complex load-balancing features you're referring to. The lowest-level API that affects system load is GCD, or libdispatch, which helps an app take advantage of multiple cores on the machine in a way that the system can manage. It's a low-level C API so you could use it on those Terminal-based apps (or on FreeBSD). Sure, you can use pthreads, fire up a bunch of threads and keep multiple cores busy, but that doesn't help the system manage load. The simplest way to look at GCD is as a system thread-pool: instead of managing your own threads, break your work up into lots of small tasks and submit them on GCD's threads. If the system gets bogged down to the point that user responsiveness is affected, the system can choke down the number of threads in the GCD pool so your app uses fewer cores. That's something you couldn't do on Unix in the 80's (or, to be fair, the 90's, when threading became ubiquitous) but you have to use GCD APIs to take advantage of it. AppNap and Timer Coalescing are all about faceless background apps and their timer usage. Most of these guys are inactive most of the time but set a timer so they wake up every now and then to check for updates. If you use the shiny new timer API you can add a parameter that expresses your intent, as in "this timer runs code that was requested by the user" or "this timer runs code that checks for app updates in the background." In the former case the timer will always wake the machine up from sleep; in the latter case, the timer may run under AppNap if your laptop is plugged in, otherwise it won't run at all. My point is that all of these fancy macOS features require API usage to take proper advantage of them; you don't generally get that kind of behavior for free.
There are still a lot of usefulness yet. Programming Languages "best practices" did not evolve that much since 90's. Mostly added some new and interesting features/Data Structures. That is all!
Thanks for the reply! Firstly, yeah I think I'm mixing between binary data and string. I've edited the textpost. It's more of a set of characters containing a bunch of printable &amp; non-printable chars. I'm not quite sure how I should approach this, honestly. I could feof(), but it requires a file stream.
Those tasks must rely on OS features. Actually, most OS advise you to not manually. Exceptions: RTOS... 
Where's the data coming from? Is it already in memory somehow? If so, then there should be something that already tells you the length. Are you reading from a file? Then the filesystem should tell you when you're at EOF. Looking at your sample doesn't make this clear. Your array might have NULL in it, but it's using NULL to indicate the end of the array, which is your problem. How did you populate `lineCurrent` in the first place? 
If you don't know anything more about the bytes, you're SOL, but, your example code says something about reading lines. Can you rely on each sequence of binary data ending in a `'\n'`? If so, problem solved. Note, using newlines (or for that matter, any terminating character) is not something I'd normally expect in "binary" data. You should make sure this is the case before proceeding. The reason I'm skeptical is the comments also say something about "blanks" - are you sure blanks mean NULL? NULL is generally used for pointers - a pointer, not char, sized value. C-strings, are terminated in `'\0'` (aka Nul spelled with one letter el) which is a single byte. Generally, no one would call `'\0'`a blank. Blank is an ambiguous term, but I'd be more likely to associate it with a space than `'\0'`. But, then again the program specification does spell out NULL as a sample input - which is weird (for the reasons stated above). I'd give this program specification a grade of D. In any event, once you fully understand the problem specification, you might want to read up on the `%[` format specifier, especially the `^` option.
Here too is the [Linux kernel coding standard](https://www.kernel.org/doc/html/v4.10/process/coding-style.html). The writing is a little obnoxious, and some of it is a bit controversial, but Linux kernel code is some of the cleanest I've seen.
[FreeBSD Style Guide](https://www.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9)
&gt; AppNap and Timer Coalescing are Whoops, sorry, I was thinking of "Power Nap" here and not AppNap. Similar situation with AppNap though: it's not something the OS can do for you with no changes for your app, you have to explicitly support it. Your app has to advertise that it knows how to handle it, and you need to respond to special system events when it's time to quit/launch and save/load state.
[C/C++ style guides archive](http://www.maultech.com/chrislott/resources/cstyle/) 
This is very subjective and overall your post is bad influence.
Linux kernel code is by far from clean though... like, not at all. Not saying FBSD would be much better :)
No. Expressions given as function arguments are computed before calling the function as per the C standard. func(1 + 3, 6 / 3) will always be equal to (ignoring global state) func(4, 2). What would separating with a semicolon even do? What does func(4; 2) do differently? A for loop is completely different than a function call because it evaluates the parameters every loop, not just at the beginning.
As I said it is the evaluation order. In your example, evaluation of 4 may be evaluated before 2 or vice versa. For values that return, it is not a problem. However, if there are side effects, the ordering might be important. 
Easiest fix: add your expressions before the function and store the result. Those expressions will be guaranteed to be done in the right order. int a = blah blah blah; int b = whatever; func(a, b); a will _always_ evaluate before b.
&gt; a will always evaluate before b in this case. Except when `b` doesn't depend on `a` and the compiler reorders it anyway. This will give you a tiny performance boost on x86 and alike.
Looking at this, you're looping over i and over j to output your Array A right? But not ever defining the numbers that go into A? You could do something similar to put them in there in the first place (seeing as you're meant to be looping to do this), and do a little arithmetic on the i and j to get the numbers 1 to 12. 
Review the definition of the `*` (dereference) operator to understand the difference.
In fact I would argue that tabs should be tabs and 8 space long... I would argue that the only reason for not liking 8space tabs is if you want to have code nested too much nested (eg 4+ ) and that this is the problem in the first place!
It is not always the integral expression that matters but side effects. Thanks for the alternative ways but I am looking for an answer that is directly about this question itself.
I wanted to add a quick follow up on this because *niceness* is an OS bound thing: https://stackoverflow.com/questions/4208/windows-equivalent-of-nice
WSL should support niceness at least.
The classic is clearly Kernighan &amp; Plauger's *Elements of Programming Style.* The fun thing about this book: All the examples about bad programming style they list were taken from other people's programming manuals.
&gt; I am looking for an answer that is directly about this question itself. If you're not looking for how to handle your perceived issue then you already received your answer in the very first comment to your question. The answer is no.
I want to clarify what the OS is doing a bit. If your program has nothing to do until the user does something, your program should somehow ask the OS to let it know when this happens. In Unix, this is usually done by waiting for data to be available on a file descriptor, which can be an actual file, an input device, stdin, etc. Your application calls read() (or select/poll/whatever), and the call does not return until data is available. During this time, it is not using CPU. The OS knows when this event happens, and it will reschedule your process to return from this call. If you are busy-looping checking for data, you are using CPU when you don't need to. Similarly, if you want to wait for a certain amount of time, you can sleep, which is asking the OS to not schedule you for a period of time. The alternative is to busy-loop checking the time, which is wasting CPU.
This is part of pset1 from Harvard‚Äôs cs50. I completed it already (Mario: user inputs a height and you build a pyramid of hashes) but I was wondering if there was a way to exclude the initial int height; I have at the beginning and maybe have it as a return value. Or whatever way that would make my code look better. I want the main to call the get_height, get_height returns the value to the next function. Or something like that.
Instead of a void function which returns nothing, have an int/float/etc function and return a value. int foo() { return 1; } int main(int argc, char *argv []) { int result = foo(); return 1; }
You're pretty close to the solution. Making a function return a value involves 2 steps: 1. Define the return type by changing the 'void' in front of your functions name to the type you want to return. (in your case, int) 2. Call return at the end of the function. It is *necessary* for all 'paths' of logic in a function to end in a return statement if your function returns a value. In your case, you could create the height int before your loop and add the line return height; at the end of the loop.
P and Q are both pointers. Pointers hold an address as their value. The first expression is assigning the address held in P to Q so that it points to the same address, that of i. The dereference operator (*) means use the value in that address instead of the address itself. The second statement says assign the value in the location pointed to by p to the value in the location pointed to by q. It will have the same effect as saying "i = i" (since you've set them both to point to i). Feel free to reply with more questions if you're still confused. This is tricky until it clicks.
Next, try to guess what this does: unsigned lolwut(unsigned a, unsigned t) { unsigned r = 1 &lt;&lt; t, rr; do { rr = r; r = a &amp; (r | r &lt;&lt; 5 | (r &amp; 0x0f7bdef) &lt;&lt; 1 | r &gt;&gt; 5 | r &gt;&gt; 1 &amp; 0x0f7bdef); } while (rr != r); return (r); } 
http://en.cppreference.com/w/c/io/gets &gt; As all bounds-checked functions, gets_s is only guaranteed to be available if __STDC_LIB_EXT1__ is defined by the implementation and if the user defines __STDC_WANT_LIB_EXT1__ to the integer constant 1 before including &lt;stdio.h&gt;.
thank you for the quick answer! so if i understand correctly, it only jumps out of the while loop when *pp = 0000000000000000 ....(only zeroes)
btw i was trying different things with this to test, whydo you think this crashes my program? unsigned char* pp= "11101"; 
I don't speak for FUZxxl or the moderation team, but I don't think this sort of garbage adds anything worthwhile to this sub. Additionally, std::move() is C++ specific, not C. This sub is *not* for C++.
&gt;is the value of pp in the if statement only the first bit in *pp the if statement is true if the least significant bit of *pp is set. &gt;wont the function jump out of the "while(pp)" loop when the FIRST bit of *pp is 0? and therefor not check if the remaining bits ==1? the while(*pp) loops continues as long as any bit of *pp is set. &gt;how does the last line work? how does &amp;1 have anything to do if returnvalue is odd or not? all odd numbers in binary have their least significant bit set and all even numbers in binary have their least significant bit cleared. Imagine the program running with pp pointing to the number 5. pp will point to these values over the program loops. 5 = 00000000000000000000000000000101 2 = 00000000000000000000000000000010 1 = 00000000000000000000000000000001 0 = 00000000000000000000000000000000 twice the least significant bit was set, so the result is 2. 2 &amp; 1 is false because 2 is even and even numbers have their least significant bit cleared.
Guess what it does!
looks like it loops through and modifies the value of r with some bitwise operators, based on the value of of a and t inputs, and then returns r.
&gt;&gt;&gt;implying memes are garbage I agree that this he uses a C++ specific command in a C specific sub, but the general attitude that a picture macro with text *does not belong* seems a little hypocritical. The point of the subreddit is for C programming. The point of this image series is to show a perceived increase in intelligence by saying increasingly simpler things. It does not seem there is a set of rules here preventing memes or other images from being posted, and it is closely enough related to be posted here. Like I conceded earlier though, he should have been using a C command to make it as relevant as possible.
Guess harder! Try to visualize how the individual bits move through the function. What is the significance of 0x0f7bdef?
no thanks, i don't have time to look further into it right now. Why don't you tell us what it does?
Don't confuse text strings containing '1's and '0's with binary. For that value, which is 29. Just use. unsigned int* pp = 29; Internally all numbers are stored in binary, so there's no conversion to do. The compiler does it all for you. 
Because it's much more fun to find out than it is to guess. 
Do you have any example code showing these side effects? I have never encountered any problems with how function parameters are evaluated.
Ok so you're generating a makefile from your cmake project, and you wan to duplicate the make install functionality in a script? I assume you're using windows, if you can't run a makefile, right? Ok well I hand wrote makefiles before I switched to cmake, the "install target" ina. makefile is literally just a few commands instructing cp on unix, on windows it'd be what, copy? to copy a file directly from a certain path to a certain path. if you're on windows just make a batch script to copy those same files... Here's a link describing windows' copy utilities options: https://www.computerhope.com/copyhlp.htm
Yes that is fine. Any member you don't explicitly mention will be initialized as if you had written `.name = {0}` for it.
thank you! how would you go about checking if the most significant bit is set? to check if it is a negetive number or not?
I'd flunk that teacher. His "function " has the side effect of destroying the input. That was not part of the spec.
That's a trivial thing to do if you break it into steps. 1. Get the most significant bit. 2. Check if it is set. I'd recommend trying to do this yourself, but if you get stuck[...](https://codeforwin.org/2016/01/c-program-to-check-most-significant-bit-of-number-is-set-or-not.html)
`unsigned int* pp = 29;` would store the memory address 29 in the variable `pp`, which means that `*pp` would refer to whatever value happens to be at that location in memory. On a typical modern computer, address 29 is within the range of memory addresses reserved by the operating system, and trying to access the value stored there will cause your program to crash. What you actually want is for the number 29 to be stored somewhere in your program's memory, and for `pp` to contain the address at which it is stored. In C, the way you tell the compiler, "please store the number 29 somewhere in my program's memory," is to assign the number 29 to an integer variable‚Äîfor example, `unsigned int p = 29;`. Then you can get that variable's memory address using the `&amp;` operator, and store the address in your pointer variable: `unsigned int* pp = &amp;p;`
If your buffer contains a real C string, you shouldn't even have to `memset()` your buffer. Making sure a single `'\0'` is present at the end of the current string is enough. 
It probably doesn't matter that much for your use-case, but in general, it's better to increase capacity by a factor of 1.5 on each reallocation than to double it. See ["Optimal memory allocation and the golden ratio"](https://crntaylor.wordpress.com/2011/07/15/optimal-memory-reallocation-and-the-golden-ratio/) for the math.
&gt; A little bit of investigation reveals that this varies across languages and across data structures. Commonly, a multiplicative growth factor is applied. For example, with a growth factor of two, you would double the size of the allocated block each time. To ensure that the array elements remain sequential in memory (so that it‚Äôs still fast) you probably want to allocate a new block and copy across the elements in the old block ‚Äì so your strategy works like this: &gt; * Allocate a new block of memory that is bigger than the current block by some factor &gt; * Copy the old data into the new memory block &gt; * Start writing the new elements here &gt; As Simon points out, a natural strategy is to double the size of the array each time, but this is probably a bad choice. This is because at each stage you assign a new memory block of size 2^n, but the total size of the memory locations used so far (assuming your initial array size is rescaled to be 1) is 1 + 2 + ... + 2^{n-1} = 2^n - 1, so you can‚Äôt reuse any of the old memory. Since you‚Äôre now only dealing with the newly allocated memory, all this old memory goes to waste. That's not how `realloc()` works. In most cases, the 'old' memory is reused and there is no data copy involved.
&gt; Isntead of this malloc/freeing, I've been thinking about just keeping the capacity at the largest size ever known, and instead of freeing the buffer, just `memset`ing the contents to `\0` once the drawing has finished. You need to do the `memset` regardless -- `malloc` isn't guaranteed to return initialized memory. Some operating systems will initialize out the memory the first time you get it for security reasons (don't want private data from other applications leaking into other memory), but after you `free` and `malloc` again it might not be initialized anymore. Or you can use `calloc` which does initialize the memory for you. So, we can ignore that part and just focus on the cost of `realloc`. On Linux, `realloc` actually isn't all that bad, once you're over a page size. The reason is that `malloc` uses the virtual address space to do some neat optimizations so that the data never needs to be copied when the size is extended. I think it also does things like always allocating full blocks so fragmentation isn't an issue. So I don't feel bad just using `realloc` and calling it good. That said, if performance is critical then a single allocation will *almost always* beat `realloc`. It's just simpler: just allocate it all and be done. The only downside is that you might be over-allocating, which can itself be bad. Allocating to the largest size needed so far means your application will always be using more and more memory as it runs long-term. Not exactly a memory leak, since that memory is always freed, but it's certainly using more than it needs. So there's a trade-off that depends on your exact situation and that we can't advise on over the internet.
Strategically ignoring your questions ... You have in your possession 2 programs one using realloc and one using memset. So measure the difference yourself. And if the slower still refreshes the screen fast enough that the user doesn't care then you're good. 
[Here's the rest of the story on Annex K.](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm) Basically, they're a failed experiment by Microsoft, and shouldn't be used. Bounds-checking is a laudable goal, still. [Linux has recently adopted -D_FORTIFY_SOURCE and other measures](https://idea.popcount.org/2013-08-15-fortify_source/). This is supported in Glibc and Musl libc but seemingly not yet in *BSD. 
That makes the rather large assumption that no other memory allocation happens in the program that re-uses the space vacated by a grown array.
Maybe it does, and maybe it doesn't. If you choose a good growth factor, you can *guarantee* you'll be able to re-use memory, and not just have to hope it'll happen by coincidence.
thank you!, while we are on the topic of adresses and memory may i ask what a port is? ive googled it alot and the only thing i come in contact with are people reading and writing to ports. but not WHAT it really is. i came in contact with it in this explanation of what *a is in my school powerpoint: a* -&gt; what variable "a" points at. here must a's value be a valid adress( for example to another variable or port) and a must be a pointer. *a retrieves the value for that variable/port so is a port just a memory adress? like 29 in your example or 0x2001bff3 or something
Alright, so... how would one do this with multidimensional arrays? Previous attempts at accessing data with a pointer through multidimensional array syntax have not worked for me, and I get the oddest feeling that similarly, a flexible array will not support multidimensionality (is that a word?) I suppose a bit of explanation on the purpose, then, is in order. Suffice to say, I'm trying to generate random "dungeons," which are a 2D array of rooms, each of which have randomly assigned entrances and exits. By having a struct for a given 2D array, I can not only pass my current level along, but I can form it into a doubly linked list allowing for multi-level structures. So, that's the context if it had been needed.
AFAIK mingw comes with some version of make. Also, bumblebritches57 never talked about make, only cmake. Also AFAIK cmake default installation folder is in the Program Files folder, where (probably, not tested) no mingw compilers looks into. Since you didn't state how you are building your project, I'm just assuming you call the compiler directly. For the gcc compiler specify `-L../projects/th/ -lTH`. `-L` to add an path for the compiler to search libraries in and `-l` the actual library, without any prefix or suffixes. You probably want also `-Ipath/to/folder/of/the/header/files -I../projects/th/` so you can `#include "TH.h"` it. (The second `-I` argument is needed because `TH.h` includes a `THGeneral.h` file which is generated at build time)
&gt; Why is total printing as 1 when 8 + 7 is clearly 15 It shouldn't be. Post your full code. &gt; and why is win% always showing as 0.00? You're doing integer division. One last note: `Win%:` should be `Win%%`.
hello all, here is what i have now. this prints fine but does not remove the trailing tabs and spaces. i am not sure why. https://0bin.net/paste/EXOlPc2ursjfndMg#-YeeZB4Wu6/l3/Gjmga5cER+24spSkkdRte9y0AGMOR
My guess is they're using "port" to refer to some kind of [memory mapped](https://en.wikipedia.org/wiki/Memory-mapped_I/O) hardware register, but it's hard to say without knowing the full context. It's a little confusing, because the same word is also used to refer to [network ports](https://en.wikipedia.org/wiki/Port_(computer_networking), which are completely different (and have nothing to do with pointers or addresses).
No worries, this already helped me correct it. First part: maybe I misread- is returning the correct total now. Second Part: I did a (float) cast and it's working now, thanks. Third part: is that for all % that you mean to print?
Yeah, if you want to print a % you need to double it up. Right now it's trying to interpret `%:` as a format string, which isn't anything so it'll do what you're hoping, but you should at least be getting a compiler warning about this. And if you aren't, turn up the warning level on your compiler.
i removed the !=\n condition and it still doesn't work :/ i also changed it to end=i-3 and no dice
here is an example of "port-adressing" my teacher uses, i dont know the context, he just has this example becuase he later shows how you could adress the ports using structs. #define portModer ((volatile unsigned int *) (PORT_DISPLAY_BASE)) #define portOtyper ((volatile unsigned short *)(PORT_DISPLAY_BASE+0x4)) #define portOspeedr ((volatile unsigned int *) (PORT_DISPLAY_BASE+0x8)) #define portPupdr ((volatile unsigned int *) (PORT_DISPLAY_BASE+0xC)) #define portIdrLow ((volatile unsigned char *) (PORT_DISPLAY_BASE+0x10)) #define portIdrHigh ((volatile unsigned char *) (PORT_DISPLAY_BASE+0x11)) #define portOdrLow ((volatile unsigned char *) (PORT_DISPLAY_BASE+0x14)) #define portOdrHigh ((volatile unsigned char *) (PORT_DISPLAY_BASE+0x14+1)) the "portModer" is the variable name, "volatile unsigned int *" is the type, im guessing "(PORT_DISPLAY_BASE)" is the port/adress does this code ring any bells what a port may be? or should i just assume that port is a memory adress.
also i am not sure why this post is being downvoted..
You could have a FAM of arrays, every dimension except the innermost most be known at compile-time. Using a dynamically allocated 1-D array of rooms seems like a simple solution. (Either actually an array of room, or an array of pointer to room). The lookup mechanism doesn't have to be part of the array structure.
Yeah, that's some kind of system-specific code for doing memory mapped I/O, like I suspected. You can read about it more on Wikipedia (linked in my previous reply), but the short version is, some systems allow you to communicate with the hardware by writing to and reading from specific locations in memory.
Hmm, I suppose. Would there by any way to cheese it so that I could have a syntax similar to a 2D array for accessing an element of the array? I really like the simplicity of floor[y][x], plus it allows access to the first column and row, whereas floor[y*x] would't work if either one is 0. Though, I suppose an array of room pointers, I could access it with (`*roomArr[y])[x]`?
Next time when programming use proper variable names (meaningful one) and use proper documentation too :)
no meaning you don't want to answer the questions or no I don't mind answering?
yes
I'm assuming you are trolling.
I'll answer 
To make matters worse, the Microsoft version [doesn't even have the right prototype](https://msdn.microsoft.com/en-us/library/5b5x9wc7.aspx) for Annex K: char *gets_s(char *s, rsize_t n); // Annex K char *gets_s(char *buffer, size_t); // MSVC So literally no C library provides this C11 function. 
I DM the questions to you 
I DM you the question Lyie, thank you in advance 
probably going to have to start using malloc
can you be more specific? 
Talking about the number 2 solution, How will the data in the numbers array will get be written in the file if there are say 50 members and and what will happen to the remaining 50 memebers that will not be assigned any value? numbers[0] = 1; .......................; numbers[50] = 50; but rest of arrray indexes will not asigned. Once I assign values into the data types inside the struct I am going to write it into a file in binary format..
I don't know the exact method you are using to write this struct to a file but the unassigned (unused) array indexes, from 50 to 99, will contain garbage values. But that doesn't matter, they will only take up disk space.
I am trying to write using fprintf function 
Side effects are the effects that occurs which is not directly related to computation of ALU while program runs. /* There may be a better explanation*/ Examples: printf, changing L-value.
Well with struct seems to be a good idea. ;) Then it seems to be, ugh, typedefed. typedef struct node {} node; Then you should have a char pointer named nb? {char *nb;} And a linked list. {struct node *next; char *nb} There I think you should have the most of it. 
https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm
I didn't notice any difference, so I suppose we're good about that :) Like I said: it's not that I am doing premature optimization, but it was just a question I stumbled upon.
In my case, the buffer contains any char between `0x00` and `0xff`.
&gt;You need to do the memset regardless Thanks for that heads-up. I knew this, but I did some extra inspection and I reckon I can do a tiny improvement with this somewhere. &gt; That said, if performance is critical then a single allocation will almost always beat realloc. It's just simpler: just allocate it all and be done. The only downside is that you might be over-allocating, which can itself be bad. Allocating to the largest size needed so far means your application will always be using more and more memory as it runs long-term. Not exactly a memory leak, since that memory is always freed, but it's certainly using more than it needs. So there's a trade-off that depends on your exact situation and that we can't advise on over the internet. This part is actually what I was wondering about. Sure it'll use a large block of memory, but there won't be many mallocs/frees. In any case, for my application performance is not criticial (it's just a hex editor) so I'll just keep it as is. Thanks for the response!
omfg that's it I see it now, thank you
Then why are you still replying to this?
It's called moderating and it's his "job". And I'm glad he does it because he does a good job at it. Your posts are low-quality or insulting, and I'm totally on board with the moderation team. Looking at the almost no upvotes on your posts, it seems that I'm not the only one, too. So he's actually doing a job for the community, not for himself.
That worked, thanks very much for your help.
errr... writing a device drive for a specific part of a SoC was one of the most challenging things I've done in a long time.... it needed all my skills in data sheet deciphering and some nifty struct handling.... so simpler..... nah.... 
I don't know why you read only the last half of my sentence: &gt; In most cases, *the 'old' memory is reused* and there is no data copy involved. Data copy is just a consequence of not being able to re-use old memory. His whole calculation is based on the assumption that old memory is not reused. This assumption is wrong most of the time. A not-stupid allocator has strategies to avoid fragmentation. For small blocks, it will reserve blocks larger than requested, so it can expand into that space without moving data around. For large blocks, it will use OS capabilities to re-map virtual addresses. Yes, we can end up in areas where there is no good strategy to avoid moving. Sometimes. But if we suffer fragmentation due to allocation of other interlaced data in the meantime (between 2 `realloc()`s of our main buffer) in our case, he cannot either make the assumption that the former memory is not reused for this interlaced data and remains available in his case! Which is the second assumption on which he bases his following calculations: &gt; What would be a better factor? Let‚Äôs say we used x. Then initially we‚Äôd have a block of (rescaled) length 1. We allocate a new block of length x. When we extend again we allocate a block of length x^2. We need to keep the old block of length x around to copy over the old data, and we can‚Äôt fit our block of size x^2 in the space of size 1, so we allocate this as a new block too. But when we allocate the next block of size x^3, we might be able to fit it in the two old blocks, of size 1 and x. This works if &gt; 1 + x = x^3
May I ask how you interpret and use `0x00`?
Removed not because meme but because unrelated to C.
I don't know about any established best-practices, but in all my days designing UIs for different programs I've written I have found that the big central theme is accessing specific data/values and functions/actions which can be organized and navigated hierarchically. When plotting out everything I need the user to access into a hierarchy I try to keep two things in mind: the hierarchy's depth and width. I don't want users to have to navigate through a dozen things to get to a single button or editbox, which means that at each level of the hierarchy, along a branch, I should present more options - so that the 'tree' isn't too tall and skinny. It should be bushy. Simultaneously, I don't want to overwhelm the user with everything on the screen at once. Groupings and logically classifying everything together into a hierarchy should be intuitive, it should just make sense without too much thought. I've also found it important to keep in mind what things should be accessible all-the-time, as a parallel hierarchy - sort of like a menubar that's always there at the top. I reserve UI items that are less related to the program's utility and more peripheral to what it's actually meant to do. I.e. the business is organized in a main hierarchical interface while the user preferences and configuration, documentation, etc.. is all accessible from a 'global' means at all times, no matter what state the business hierarchy is in while the user works with it. I don't know if any of that is relevant, or means anything, I just thought I'd put it out there. Let me know if you have any questions, and good luck!
Oof I remember the pain caused by this one. Great write up.
The only user interface I could imagine a 65 year old who's never held a mouse before comfortably using would be the rotary telephone, but even that I believe may be too complex. 
The left column increases in simplicity, the right column increases in complexity. It's an irony thing. 
You're arguing for making optimistic assumptions about the code's execution environment, whereas the author of the post I linked is making pessimistic ones. Sometimes optimism is justified, but in general, making pessimistic assumptions leads to more robust code.
Huh? If you read `insert` function, when `node` is `NULL`, it creates a new node and returns that otherwise it inserts the data and returns the same node it was given in the `node` parameter. So that is your constructor. Also, at the moment, in `build_tree` you call `insert` with the `root` as the node, but `root` is `TreeNode**`, not `TreeNode*`. (Probably) it is `TreeNode**` so you can do `TreeNode *root = NULL; build_tree(&amp;root, elements, count);` in the `main` function. I'll let you figure out yourself on how to make build_tree correctly. `cleanup_tree` seems to be fine.
So I made a bunch of changes and my program is able to compile and run. However, it seg faults when it builds the tree (in insert) and I'm not sure what I'm doing wrong. Could it have to do with the first case I'm checking? Here's the revised code: https://pastebin.com/gx7s4dJZ
Tabs are just better. If you want there to be 8 spaces then you can do that, if you want there to be 4 then you can do that too, all without changing the file. Nobody else has to deal with your preferences because it is consistent.
Ever thought of freeing the stuff you reserve on the heap? Thats a bad habit. Just reverse the reserving part: for (i = 0; i != rows; ++i) free(arr[i]); free(arr);
Thank you! completely forgot about that.
No, your computer isn't haunted. Basically, this is because computers aren't very good at floating point arithmetic. On top of that, they also have limited precision depending on your CPU and data type. If you change f to a double, you should get different results with the same numbers. I'm far from an expert on this, and it's been a while since I've read up on this stuff, so if someone can add some more detail here please do. 
This is exactly what you expect from using `float`s. It's important you understand what's going on. There's lots of resources on the internet, but I'll give a quick summary. There's three concepts you need to keep in mind. First, computers use binary, a `float` is essentially scientific notation`, and a computer only uses so many bits to represent the number. Let's start with a base-10 example, and we'll add in binary later. Imagine our computer can store up to 4 digits in scientific notation. If we try to store the number 10.23, it actually holds 1.023\*10^(1). The number 0.00345 is 3.450\*10^(-3). But what if we want to store 3.10293? Well, we're in trouble. The closest we can do is 3.103\*10^(0). If we try to add 0.0001 (1.000\*10^(-4)), the number doesn't change. If we could store 8 digits we'd be fine, but 4 just isn't enough. The same thing is going on with your example. A `float` just doesn't have enough digits (well, bits) of precision for the result of the addition to actually be stored in the number. Speaking of bits vs. digits, that's the answer to your fist question. Computers use base 2, not base 10. It's impossible for a `float` to hold exactly the number 91.3 once you do the conversion to base 2. The closest it can do is 91.300003, rounding up just a tiny bit. Using a `double` instead of a `float` increases the number of bits that can be used to represent a number. You still have the problem that many numbers can't be stored exactly, but any errors will be much smaller.
My point is that in decimal we can exactly describe 3/10 as 0.3, but in binary the representation would be non-terminating. The equivalent to this is representing 1/3 in decimal (which is 0.3333333333...). If you only have a fixed amount of space (like a 32-bit `float` or a fixed number of characters), you need to decide where to stop the representation, which leads to some rounding error.
&gt; My point is that in decimal we can exactly describe 3/10 as 0.3, but in binary the representation would be non-terminating. Specifically, it's 0.010011001100110011...
I remember that C# has a *decimal* class that pretends the number is an integer and then uses some of the bits of precision to instead store how many positions to move the decimal. even as im explaining it im having a hard time distinguishing that from regular scientific notation...why is that better, or more importantly why can't C do something similar?
I got it to work! :) Thank you so much for all the help and the detailed explanations. It really helps to understand. 
The advice to copy proven UI designs and avoid "making the user think" is especially appropriate for programs which will only get occasional or very infrequent use -- which means the user probably hasn't burned the knowledge of how to use it into his muscle memory. OTOH, an innovative UI and even a complicated one can be effective if the program is what Alan Cooper called a "[sovereign app](https://en.wikipedia.org/wiki/Sovereign_application)", by which he meant one in which the user will be spending most of his time and therefore will be more likely to have developed some expertise. 
I'm more confused why it doesn't print out a million times 0.0000038 + f Shouldn't it print out the same as if he had: #include&lt;stdio.h&gt; int main(void) { float f = 91.3; float g = 0.0000038 * 1000000; printf("%f\n", f + g); } 
Basically, 91.3000068 can't be exactly represented either and gets rounded back down to 91.300003. So each iteration of the loop actually leaves `f` unchanged. 
Not trying to be snarky or anything but have you considered using a debugger and single stepping through your program? See the sidebar, there is a link to GDB. Or I suppose if you use a IDE there is one built-in, but it's worth in my opinion to learn GDB.
I find Gdb to be confusing (perhaps a personal problem). I mainly debug with print statements. Probably not the best way, but it‚Äôs been sufficient thus far. In this case I was able to pinpoint that the location of my woes was within insert, in particular when I was calling it. Again, stepping through with gdb would have probably been better.
‚Äúit doesn't work‚Äù is not an error description. What happens? What do you expect to happen? Please do post your whole code. Make sure to put four blanks in front of every line of code so the code appears readable.
You said "algorithms" a couple of times here. Do you mean "digits", as in the individual numbers? So you want 12345 to turn into v=1, w=2, x=3, y=4, z=5?
I guess you wants units, tens, hundreds etc digits ? Forget C for a minute and just try to solve this using basic mathematics. If you can do that then C is just learning syntax to covert that mathematical model to a program. If you were given a 1000 digit number and a calculator that can handle this number and asked to find the number in 500th place then how would you do it ? Would you just count the digits to 500th place and try to use some math ? Start with a small number and try it on paper and you should be able to visualize the result.
You are passing 3 values to the function and it is showing that you only should be passing 2 in your declaration.
&gt; then I declared File pointer in my function paramters as shown below: int second_input_type_to_first(int pos, char* binary_buffer){ There is no `FILE*` in that prototype. And no argument called `pointer` either. ---- fwrite((uint16_t)second_input[index], sizeof(uint16_t),1, pointer); Also, the 1st parameter to `fwrite` must be pointer to the data being written.
Yes I meant digits, but I figured it out already :) Gonna post my code here
the prompt just crashed. my code was: #include &lt;stdio.h&gt; int main() { int num; int v; int w; int x; int y; int z; printf("Pick a number to separate its digits\n"); scanf("%d", num); v&lt;10; w&lt;10; x&lt;10; y&lt;10; z&lt;10; num == (10000*v + 1000*w + 100*x + 10*y + z); printf("%d %d %d %d %d", v, w, x, y, z); return 0; } 
Thanks man!! I got this "epiphany" while reading your comment and I solved the problem in no time ahaha. I tried to think like you suggest before but I came with the wrong idea I guess, I tried to the following: #include &lt;stdio.h&gt; int main() { int num; int v; int w; int x; int y; int z; printf("Pick a number to separate its digits\n"); scanf("%d", num); v&lt;10; w&lt;10; x&lt;10; y&lt;10; z&lt;10; num == (10000*v + 1000*w + 100*x + 10*y + z); printf("%d %d %d %d %d", v, w, x, y, z); return 0; } But thanks for the reply! :)
Guys, the code I came with is the following: #include &lt;stdio.h&gt; int main(){ int number; int v; int w; int x; int y; int z; printf("Pick a number to separate its digits\n"); scanf("%d", &amp;number); v = number/10000; w = number%10000/1000; x = number%1000/100; y = number%100/10; z = number%10; printf("%d %d %d %d %d%", v, w, x, y, z); return 0; } 
Not yet, I'm afraid. AI is still some time away ;-)
If you're going to ninja-edit the code you posted at least warn the people who tried to help you.
This is my exact area of research. Let me write a more detailed answer tomorrow.
`fprintf`
Something like int ch = fgetc(infile); if (ch != EOF &amp;&amp; ch &gt;= 0 &amp;&amp; ch &lt;= 9) { fputc(ch + '0', outfile); } 
Thanks. I'm looking forward to it.
That prints out the whole file. Wow simple as that. Thank you haha
Use a string. If you really think about it, you don't do math on phone numbers. So a char array (string) should more than suffice.
Thanks!
Nice piece. Echoes much of what I do myself.
nobody really knows... thats why most apps have horrendous interfaces, till you learn them...
If you really have to start from an integer, you can * extract each digit with a loop doing a series of `% 10` and `/ 10` operations, then process those characters as you wish. * you can convert the integer to a string with a function like `sprintf(str_phone, "%010d", int_phone)`, and then process the characters as you wish. In `%010`: `10` stands for the field width (the number of resulting characters you want), `0` stands for padding the field with `0`s on the left when there are not enough digits (by default, padding is made with whitespaces). * you can convert the integer directly to the string result you wish with a function like `sprintf(str_phone, "%02d-%02d-%02d-%02d-%02d", int_phone/(100*100*100*100), (int_phone/(100*100*100))%100, (int_phone/(100*100))%100, (int_phone/100)%100, int_phone%100,). But otherwise, as /u/Bill_Morgan said, there is no reason to start with a phone number as an integer, better get the input as a string in first place. Particularly since the leading `0`s are significant in a phone number.
What you are trying to build is known as a *pattern database.* I've written my [bachelor thesis](https://opus4.kobv.de/opus4-zib/frontdoor/index/index/docId/6558) about constructing these, although for the 24 puzzle instead of the Rubik's cube. The key idea here is to realize that eventually, you are going to have a table containing all possible configurations, so storing configurations themselves is not necessary. Instead, you devise a bijective *perfect hash function* that maps configurations to indices in an array (and back). The array itself only stores the distance of the configuration to the solved configuration; you can use a single byte for this ([I used](https://github.com/fuzxxl/24puzzle) a single byte with `0xff` representing ‚Äúconfiguration not yet reached). There are 8! ¬∑ 3^7 = 88179840 possible corner tile configurations (already accounting for the orientation invariant). If you are careful while writing your perfect hash function, you can make it produce numbers in the range 0 to 88179839 with each configuration receiving a different number. This way, you only need 88179840 &amp;approx; 85 MB of storage. I'm currently working on a scheme that reduces the required storage to a single bit per pattern database entry. Stay tuned for the paper!
Use `fprintf` instead.
Sparce 3D matrix implemented as a binary tree of binary trees of binary trees
An IRC bot, where each command is its own .c file, compiled as a shared object. Similar to how Postgres has user-written C functions, just with less macros.
C++ is off topic in this subreddit. Please post C++ content elsewhere, e.g. to /r/cplusplus.
I'm continuing my research I wrote my [bachelor thesis](https://opus4.kobv.de/opus4-zib/frontdoor/index/index/docId/6558) about. Right now, it's mostly a bunch of combinatorics, bit fiddling, and statistics.
I'm still trying to create a string formatter for Unicode. I'm lost in how to actually parse the format specifiers without having over a hundred lines of if/else checks. that's what it currently is, but I fucking hate it. An earlier approach used a shit ton of functions (like a dozen) to parse them, but there's just so much "bureaucracy" (for the lack of a better term) in managing the which and where and whatnot that I don't really like that approach either.
Written from the trenches vs ivory tower. Nice.
I wrote a very basic software renderer, texture generation and fractal visualization(mandelbrot and julia).
You might want to learn how to use lex for this purpose. Lex is a tool to generate lexers, which is what I think you need.
I'll check it out, thanks for the tip.
Mostly embedded stuff.
I was briefly interested in UTF-7 and wrote a stream encoder and decoder for it. It operates somewhat similarly to zlib's API: https://github.com/skeeto/utf-7 The value of a streaming API for UTF-7 is that the optimal encoding ‚Äî and in some cases the only correct encoding ‚Äî for a particular code point depends on the adjacent code points. So unlike, say, UTF-8 there's some state to carry around between code points. 
Mostly hardware control stuff. Essentially making lots of shitty vendor serial protocols work, against all odds. I mean, wtf, this protocol controls safety critical equipment and it doesn't even have a freaking checksum?!?
Project Euler
Using string to store phone number is the easiest way
I'm trying to work my way through ldd3.
Do you have plans to make it N dimensional?
I first need to re-make it using generic values, so the same struct can be used on multiple levels, then I can make it n-dim It'll be fun!
Rewriting my [game launcher](https://github.com/iguessthislldo/Banner_Launcher) using GTK that used to be written using Qt. The Qt/C++ version was starting to feel very messy. It's also coming along faster/better than the Qt version was.
I am just learning to code in c. I am trying to make some monitoring software by combining a couple of them
Emacs video player! hehe... 
You could take a look at ragel state machines. It can generate goto based state machines, which are comprehensive in a way that human code will never be.
Still working on my MPRIS daemon which reads track change signals and submits the songs to last.fm, libre.fm and listenbrainz.org services. 
My latest project was client for ;--have i been pwned Password API. https://github.com/pczajkowski/pwnedpassword/
My day job: cryptography. 
SSD firmware
http://openafs.org http://gerrit.openafs.org 
Still toiling away on an irc client now and then as a hobby project http://github.com/rcr/rirc
The [SEI CERT C Coding Standard](https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard) has 51 rules and 51 recommendations for writing secure code.
How did that go? Any interesting results?
Playing around with parsing wikipedia data and categorizing strings so that they compress better using the zlib api as an attempt to win the hutter prize. Not making a lot of progress, but it's been a fun diversion.
Done https://github.com/C-Learners/Dynamic_Sparse_ND_Matrix
[Partial answer on Stack Overflow](https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration) 
&gt; Any mistakes above? I'd say B is a declaration followed by assignment, not initialization, but colloquially you'll hear any first assignment to be considered initialization. &gt; And where does 'define' come in, if anywhere? Since you're using local variables, you're both declaring and defining the variables. We can see the difference between declarations and definitions when we consider global variables: extern int x; // Declaration int x; // Definition Note that global variables are zero-initialized by default, so the definition is an initialization. &gt; Also, what are the lvalue and rvalue effects after each of those statements are executed? I'm not sure what you mean by the "effects." lvalue and rvalue are just categories. As a shortcut, think of lvalues as things that can be on the left hand side of an assignment and rvalues as things that can only be on the right hand side. So `x` is an lvalue in all cases. More officially, an lvalue is anything that has an address: if you can do `&amp;x`, then it's an lvalue. Everything else is an rvalue.
&gt; May your code be free of segfaults and your threads never deadlock! You forgot memory leaks and use-after-free. Also some joys of C. :) May you also never require any type-safe generics.
I use it mostly to toy around with algorithms, data structures and other CS topics. Also planning to learn how to do Embedded Programming with it.
I'm under the impression that the lvalue of a variable is its address, and the rvalue of a variable is its value. For instance, after A above, x would have no valid rvalue but I *think* it would have an lvalue (but I'm far from sure). After B or C above I have to imagine x has both an lvalue and a rvalue.
rvalue and lvalue aren't things a variable **has**, they're something an expression **is**. So, really, we shouldn't be looking at variables at all in this discussion, but the expressions in which they are used. The expression `x` is an lvalue since we can do `&amp;(x)`. The expression `x+1` is an rvalue because we can't do `&amp;(x+1)`. If we have the array `int y[5]`, the expression `*(y+1)` is an lvalue because we can do `&amp;(*(y+1))`.
A code generator to generate new C code from existing C code according to specified attributes.
On this topic, the author of the book I'm reading, "Beginning C for Arduino", does use the disclaimer "While I've taken a few liberties to make things easier...", so maybe that's my problem. He uses an integer as an example and refers to its lvalue as its location. However, he also keeps referring to it as a 'data item'. Thanks for your help. Your clarification above does seem to be filtering through my skull.
Since any corner combination can be reached in 11 moves or less, I only need 4 bits to store that value. So I can fit this within half the space. I also use a lexicographic permute to assign an integer value to any given combination. This is what I've come up with in the past couple of days: &gt; [moves.h](https://pastebin.com/pEAKudse) &gt; [mymath.h](https://pastebin.com/BmPGXvS9) &gt; [cornersDB.c](https://pastebin.com/QwYkfpYU) Everything in this code appears to work except for the breadth-first search. It isn't very efficient at the moment, and I don't know how efficient it really needs to be. For example, if it does the turn R, and can do the turn Rprime after. It won't store a value for it, but it will spend more time than necessary on figuring out whether or not this pattern has been seen already.
Programming this and that for a hobby rogue-like project. Managed to simulate a simple fire spreading system using breadth-first search. (Confession: I got lazy and ended up using C++ for its vectors to store neighboring cells instead of taking the time to whip up a linked list)
Put 4 spaces at the beginning of every line to format it properly.
ok done ..
Here's a sneak peek of /r/cpp_questions using the [top posts](https://np.reddit.com/r/cpp_questions/top/?sort=top&amp;t=year) of the year! \#1: [What are some beginner friendly C++ github projects?](https://np.reddit.com/r/cpp_questions/comments/61cucu/what_are_some_beginner_friendly_c_github_projects/) \#2: [C++ without ever using the letter i in your code?](https://np.reddit.com/r/cpp_questions/comments/5ztsku/c_without_ever_using_the_letter_i_in_your_code/) \#3: [How to (re)learn C++?](https://np.reddit.com/r/cpp_questions/comments/7hgpj3/how_to_relearn_c/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
line 23 which is *p-&gt;next = *head;
I'm working through SDL2 to hopefully get something basic like a Tetris clone up.
That checkered pattern in my peripherals while trying to read hurts my eyes/brain :(
You don't really need the `first` variable, just check `p` directly. 
Saw your other post. Looks like you got it right. Congrats!
in a good way?
I feel ya!
I'm pretty sure you're heavily into undefined behavior doing that.
 node *head = new node; create(head , count); These lines are really weird. There's no "new" in C, there are no constructors. You have to do everything manually. You want to malloc a new node, you have to explicitly write a function that does this. Also, C is pass by value. If you simply pass *head to other function, it will get a copy of the *value* of *head. Any time you want to change a variable outside its scope, you pass its address, that is, the pointer to it. I think a good solution would be void create_node(node **head , int data) { struct node *new_node = malloc(sizeof(node)); 
Do you thing so? I would be interested to hear what would be the cause of UB.
We are not here to do your homework. You need to sum the multiplies and then look at reminder when dividing by eleven. 
Entirely correct except that `register` variables can‚Äôt have their addresses taken, but they can act as lvalues.
First: reading a union "field" different than the one you wrote to. Second: accessing the same memory area both as const and as non-const. You're basically casting away const behind compiler's back.
I wrote a program that reads our company documentation DB and generates LaTeX and HTML versions of our internal directory for distribution.
Thanks for the feedback. You are correct with the First, although I'm under impression that this rule is being commonly violated in many projects. In the Second, I'm casting only in the direction mutable -&gt; const, so basically all objects are created as mutable and only temporarily converted to const for convenience.
Both might work on most compilers on most platforms, but it could stop working or do something different any time. For the second, I don't think you actually need it, just use an opaque struct and accessor/mutator methods with const parameters as needed.
Trying to write an [RTS engine](https://github.com/eduard-permyakov/permafrost-engine) akin to the ones in Age of Empires or Starcraft. Of course, it is still early in its' development and I think it will take a year to make a playable single-player demo.
i thought that the first was pre-C99 only. I'm pretty sure type punning is a thing...
Hmmmm... you're right. Come to think of it, bit fields have the same problem.
&gt; First: reading a union "field" different than the one you wrote to. That's perfectly valid in C. From [C99](http://port70.net/~nsz/c/c99/n1256.html#note82) section 6.5.2.3, footnote 82: &gt; If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called "type punning"). 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://port70.net/%7Ensz/c/c99/n1256.html#note82) - Previous text "C99" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Building the native gcc port to www.harvey-os.org
http://en.cppreference.com/w/c/io
Writing Windows 10 kernel drivers. This is not fun.
Here's a little something to help you out: * Do a for loop through argv[1]. * While one iterator increments, have another that decrements from 10. * Each digit's value is 48 subtracted from the character value. * Good luck!
The code int main(void) { int *a = malloc(sizeof *a); *a = 23; free(a); printf("%d\n", *a); } doesn't result in a segfault on my system. Rather, 0 is printed out. What really happens within free (e.g. setting the memory location to 0) is implementation-defined, so you can't really reason about it in Standard C. However, a segfault seems unlikely since `a` still points to the same memory location that still belongs to the current process space. So, I wouldn't put use-after-free under segfault. 
I would actually simplify the definition of lvalue and rvalue. And lvalue is any expression that can be assigned (IE. write to). And rvalue is any expression that you can read a value from. Most (all?) lvalues in C also workout to be rvalues, because they express a value stored at some location that can either be read or written too. But some rvalues may represent temporary values which have no defined location to be assigned too. So variable `i` is an lvalue and rvalue, because you can both assign it or read it. But the result of `i + 2` is an rvalue, because the result is a temporary value that does not exist in any defined location and cannot be assigned.
*learning
From an ancient draft http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf section 6.7: &gt;A *definition* of an identifier is a declaration for that identifier that: &gt;‚Äî for an object, causes storage to be reserved for that object; &gt;‚Äî for a function, includes the function body;101) &gt;‚Äî for an enumeration constant or typedef name, is the (only) declaration of the identifier. I‚Äôm sure a more careful reafing of the standard will provide a more complete picture. For $60 the real standard could be yours: https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS%2fISO%2fIEC+9899%3a2011%5b2012%5d
&gt; rvalue and lvalue aren't things a variable has, they're something an expression is I could have sworn this nomenclature came about because `lvalue` is what goes on the left side of the equal sign and `rvalue` is what goes on the right side of the equal sign. That is, the address goes on the left side because we are setting that memory location to the value of what is on the right side of the equation. Am I remembering incorrectly?
UEFI bootloader and a 30 year old code base.
Please do not post these.
In-memory database, but is mainly used for practice and keeping up with C
Trying to write a simple game using C11 and SDL2 on Linux. Going slow, but it's going somewhere at least :)
The most common one is the CLRS book. They don't cover encryption. Therefore, I can recommend you Applied Cryptography by Schneier. Another one I like is Algorithms 4th edition by Sedgwick and Wayne. The examples are in Java though, so it's a great exercise to write them in C. 
Thomas Cormen's book on Algorithms is the best.
Does it cover encryption?
I cant really aford 2 books hehe. But thanks for the recommendation.
I don't think there is one that covers both.
Programming metrology hardware, torque testers force testers, other various measuring equipment with lasers and whatnot.
You're remembering right, and I briefly mentioned this in my first reply.
Try to implement B trees. They appear quite often in database design. One of my favourites are *suffix trees.* Which can be expanded into finite state machines for string matching using the algorithm of Aho and Corasick.
But a linked list is like the easiest thing to implement...! 
wow, this is pretty hard. I'm trying to implement the normal b-tree with defined order. I need to think in really different way... I'll keep trying
Next time ask for a book that covers both gardens and mathematics!
No need to be rude. Algoritms is pretty general so its not unlikely that some books also cover encryption algoritms
I'm working on my own linked-lists lib
CLRS are used at almost all universities. You can easily find a used one.
In case of memory leaks, just download more RAM. 
If the file pointer is 0 then the file wasn't opened. Use `strerror` to get the reason.
Oh sweet -- haven't learned about strerror yet. Thanks! Stupid question, which line would strerror go on? Thanks again!
Where you're printing the error string now
Perfect, thanks!
Remove that * after Node and DictionaryObj. It should be by the names at the bottom if you want the structs to be pointers by default.
man I both hate it and love it when when its an easy fix. Thanks for the help!
&gt; Edit: Out of curiosity, we were provided a header file to base our Dictionary.c program off of and if specifies the interface as &gt; &gt; typedef struct DictionaryObj* Dictionary &gt; any idea why it might be they specify it as a pointer first? Well in this case it's a prototype and the syntax is fine. If you add the body of the struct the syntax gets different.
The best story about memory leaks, that I've heard so far, is ["Garbage collection" in missile software](https://groups.google.com/forum/message/raw?msg=comp.lang.ada/E9bNCvDQ12k/1tezW24ZxdAJ).
That was the story I was thinking about as well :-)
The changes you suggested are still syntax errors
A typedef isn't a prototype. A prototype is a function declaration that includes a typed argument list.
Please see /r/C_Homework.
&gt; I'm behind on the reading Catch up on the reading.
Wow, never thought of that. Thank you. 
What's the problem?
temp is a pointer to a struct, so you have to dereference it in order to access the struct members. temp-&gt;next Is equivalent to (*temp).next
fixed it
I tried to but maybe I'm doing it incorrectly. Do you have a suggestion?
Looks like a string compare function that returns 0 if the two don't match and 1 if they do match.
Thanks. I'm working on it as we speak, this is due at midnight tonight and I wasn't expecting the chapter to be 100 pages.
Yep. But also, if the strings are unequal length, it will return 1 if the beginning of the longer string matches the entire shorter string. And, OP should catch up on the reading. Classes can get away from you quickly; I know this from experience.
You need to use a counter variable to hold the total number of primes. Also, you will need to add logic to print a '\n' every 16 numbers.
Jesus christ that's such an easy function
A bit of a late reply but hopefully this helps if you haven‚Äôt figured it out yet. You have a section of code that prints the prime numbers inside of a conditional statement. This is what‚Äôs actually giving you some output. So if you program prints 5 prime numbers then it must have entered that conditional statement 5 times. Likewise if it prints 30 numbers then it must have entered 30 times. Your best bet for printing the number of primes is to make an integer variable starting at 0 and add 1 to it every time you print a prime number. Then simply print that variable. 
codeblock
Eclipse is what I use.
Well, what do you mean when you say it won't work for you? What are your requirements? A Google search would reveal the best IDEs. I personally don't use IDE for most of my projects. But for me, CodeBlocks works pretty well. 
why not
From what I've heard one would be better off looking in another direction.
I would honestly not recommend you make decisions just because you heard something from someone. Do your own research. See if the tools you are investing have everything you need. If not, then look for other resources. 
emacs of course, it's the best ide for every language except maybe java
For future reference when you're trying to find the cause of segfaults, valgrind is your friend. :)
tempstore[0] of course is a pointer, as you correctly stated. C has no strings. C has a convention that says, a string is a consecutive memory block, where a '\0' character signifies the end of the string. In other words, a string in C is nothing but the pointer to the first character of it. C provides no further encapsulation, safety, or checking of the string. Does that help?
I use utlist.h, uthash.h....
QtCreator is pretty good.
Set a has symbol Boolean to false and a has digit Boolean to false Iterate through string until null character. For each character, if it‚Äôs a symbol or string, set the appropriate Boolean to true At the end, if both Boolean are true, allow the password
Came here to post this but you bet me by a hair my friend.
The `%s` format specifier is defined to expect a pointer (which points to the first character of a string). So I am not sure what you are unclear about.
&gt;C has no strings C does have strings; and it's defined by the C Standard that a string is a (possibly empty) sequence of characters followed by a null terminator. 
Your password is an array of 20 chars. The program gets input from the user. If you type in ‚Äúpswd‚Äù , the first four chars will be the number codes for the letters pee, ess, double u and dee. The fifth character is the special null terminator character, which we represent with ‚Äú\0‚Äù . What the while loop does is see what the character in the array is at index i, then check some things about the character. Here, I think it‚Äôs whether the character code is an upper case letter or a lower case letter. At the end of this while block, the value i is increased by one. The while condition is evaluated again. If the value of the array at index i is the null character, the while loop isn‚Äôt performed. If the null terminator is reached, then it means that every letter (character) of the password has been looked at. Based on what has been seen of the password, the password is either rejected or accepted. NOTE! It‚Äôs a bad idea to use the function gets. Here, the array is 20 characters wide or long (however you want to think of it). Gets does not know this. Gets will keep putting the characters the user inputs, even if the user puts in more than nineteen characters ( the array has room only for 19 characters, because the last one should be a null terminator to show that the string has ended). So, gets will continue writing past the array the letters the user inputs. And then tack on the null terminator at the end of that. Outside of that array, you might have other variables that you need. These will be written over with the user input. Please don‚Äôt use gets! Where did you get this example, anyways? Gets is such a bad idea, it has been officially removed from the C standard. The first computer internet virus took advantage of the effects of overflowing a buffer array in order to do things it wasn‚Äôt supposed to. 
What he's getting at is that C doesn't have a struct called "String" that contains the size and other properties of that string like C++ does for example. it's just a 1D array with the final code unit being NULL.
Uh, basically every IDE is free? I use Xcode 80%+ of the time, and Visual Studio "Community edition" the other 20%, they're both free...
OS? On windows use visual studio.
Vim
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Check out the ctype.h header. Specifically the functions isupper(), islower(), is isdigit() and ispunct(). Also, stdbool.h provides a boolean type (or, rather, a bool macro for the _Bool type) and true and false macros. 
I thought this was /r/ProgrammingHorror 
The same way you check for upper and lower. You can check if it's between '0' and '9', inclusive, no need to figure out the ASCII code. And if it's nether upper, lower or digit, it's"other". So you can use switch/case or if/else if instead of plain if.
Yeah it's Windows, thanks
Tip: a program equivalent to yours would only use a loop like this: while( password[i] != "\0" &amp;&amp; !(upper &amp;&amp; lower &amp;&amp; i &gt; passlen_min) ) This will stop scanning the password as soon as it fulfills all the restrictions. In this example it's not going to make any difference, but IMO it's always good to take these things into account.
I‚Äôm not entirely sure what you‚Äôre asking, but if you‚Äôre asking how to do runtime linking, you should use dlfcn.h. It‚Äôs pretty simple to use (there are only four functions total) so I‚Äôll leave that part to you. If that‚Äôs not what you‚Äôre asking, a little clarification for my understanding would help!
`int x;` is a definition. At file scope it is a *tentative definition*. The only declaration of a variable which isn't a definition is when they keyword `extern` is used , and no initializer. B. This is a definition followed by an assignment statement. People sometimes call the first assignment "initialization", pedantically speaking this is not correct. C. This is a definition with initialization. There is no such thing as "lvalue and rvalue effects". Lvalues and rvalues are expression categories. 
I know how to dynamically link objects. What I'm asking is, how can you build a nice and simple interface to fully control a large back end with a lot of complex variables?
&gt;Note that global variables are zero-initialized by default, so the definition is an initialization. Grammatically, it is not an initialization unless there is an initializer specified. 
&gt; He uses an integer as an example and refers to its lvalue as its location This is completely wrong. It seems that author thinks "lvalue" is another word for "address" (it isn't).
After `const int y = 5;`, then `y` is an lvalue but cannot be assigned to. The C Standard defines lvalues, we don't need to start making up new definitions. Also lvalues are not rvalues (every expression is one or the other). Lvalues can be used when an rvalue is expected; in which case they undergo conversion to rvalue (this process is called *lvalue conversion*).
Search for n1570 to get a more up to date document
You've got a few options, but none of them are perfect. You can use _Generic macros to call different functions. You can use Variadic functions for functions that require an unknown amount of arguments. You could set up a struct with parameters per instrument that the user sets up with setters and getters, and maybe a union if you want to get fancy.
I'm going off the wording in 6.7.9: &gt; If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static or thread storage duration is not initialized explicitly, then: &gt; ‚Äî if it has pointer type, it is initialized to a null pointer; &gt; ‚Äî if it has arithmetic type, it is initialized to (positive or unsigned) zero; &gt; ‚Äî if it is an aggregate, every member is initialized (recursively) according to these rules, and any padding is initialized to zero bits; &gt; ‚Äî if it is a union, the first named member is initialized (recursively) according to these rules, and any padding is initialized to zero bits; The standard says that it's an initialization, which is good enough for me.
Go do your homework dude. No one here will do it for you.
She assumed that the int is 4 bytes. Which may or may not be true. On a system where int is not 4 bytes, the code will fail. It's safer to use sizeof(int) *8 to find out the exact number of bits in the system. 
ok thank you for the quick answer but how does she know then that *p consists of 8 ints?
I'm not sure what you mean by 8 ints. Do you mean 8 bits? Unless you're working on a really old machine or a DSP, it's safe to assume that 1 byte = 8 bits. Formulate the code to do what? 
Either way should be fine. I would recommend using a variable in terms of efficiency so that you don't spend time calculating the same value again and again. 
thank you for the answer, but what "unsigned int *p" points at dosent have to be (one) byte though? she assumed it was 4, it could be 6 or 8 no? "If the number of 1s is a multiple of 8 then the number of 0s is too." i dont understand, maybe my english is limiting me here 
If there are 8 bits in a byte then the number of bits in an int is a multiple of 8 (16, 24, 32, 80, 88). If you count the 1s then you know whether the number of 1s is a multiple of 8 or not. If it is, then the number of 0s is a multiple of 8 as well. It doesn't matter how many bits there are in total
This isn't what you asked, but these crappy examples common in educational materials are a pet peeve of mine. There are so many instructors who barely know what they're doing teaching things in a confusing, bad way to students who don't know any better. First ‚Äî perhaps this was just an error on your part typing up your question, though I wouldn't be surprised if it wasn't ‚Äî but the prototype and definition don't match. The prototype is actually a little more reasonable since it avoids aliasing issues. Second, why pass a pointer for the integer argument? It's pointless. When `bitcheck` returns, the integer will be set to 0 regardless. The caller could do that themselves easily. This complicates the function, makes it harder to use, and pointlessly makes it slower since the compiler must assume `p` may alias with `num` in the function definition. The integer should be passed directly. It's just confusing otherwise, which is at odds with the whole purpose of the example. Why do this divisible-by-eight thing and have an output parameter? Again, it's just pointlessly complex and makes for a poor example. Instead the function should just count the number of bits and let the caller decide how to use it. Also as was already pointed out, it assumes `int` is 32 bits. I imagine the instructor didn't know that wasn't always true. Finally, don't write `num &amp; 7` when you really mean `num % 8`. In other words, the purpose of that code is to test division by 8, not to AND with 7. Both trivially compile to the same thing, so state your intentions rather than obfuscate your meaning with a pointless "optimization." 
well i think they formulate alot of questions to involve functions such as pointers and such to see that we know how to use them, not to construct the best and fastest program. "Finally, don't write num &amp; 7 when you really mean num % 8" but dosent % take the decimals of num/8? like num =12 12/8=1.5 12%8 = 5 
It's good that they want to teach pointers, but they should use examples where pointers actually make sense. Examples not only teach the language's semantics, but also demonstrate its idioms. (K&amp;R is really good at this.) Nonsense examples lack the latter. The operands are integers, so there are no decimals. So it's all integer division. If in doubt, write it both ways and inspect the compiler's assembly: int usingAND(int a) { return !(a &amp; 7); } int usingMOD(int a) { return !(a % 8); } The assembly (via `objdump -d -Mintel` on x86-64): usingAND: xor eax, eax and dil, 0x7 sete al ret usingMOD: xor eax, eax and dil, 0x7 sete al ret 
I understand but atleast give me some tips or suggestions
Long long int is different than int. Float and char etc are also different than an int. Yes. All ints for a particular system would be of the same size. 
How about you study? Read your course materials, try something. If you at least tried we would be *a little* more prone to help you, but as it is no one will. You have to be responsible.
ok i will try.
oh so a pointer of type "x" must point at a value of the same type, didnt know that thanks!
This is fine for educational purposes, but in general I would suggest using `ctype.h` to classify characters. Uppercase, lowercase, and digits can all be checked directly; symbols should probably be considered as either graphical or printing characters excluding letters and digits. 
&gt; On a system where int is not 4 bytes, the code will fail It might still work. The behavior is not deterministic at that point. 
In C, there are explicitly 8 bits in a char.
No, there's CHAR_BIT bits in a char, and it has to be 8 or higher.
Well, I'm not sure if it'll really help you too much, but I've got an irc bot that's going to have each similarly functioned command worked into their own .so. [It might help you](https://github.com/brimonk/retropie_irc) Also, the README is terribly outdated. The functionality is dynamically linked.
Doing this in C is so good. It really makes you think about reducing the problem.
I also need the program to return 1 and print "is a palindrome" and return 0 and print "isn't a palindrome" for the users string
Post code, not pictures of code.
It seems a little late in the semester to be giving the late, great isPalindrome problem lol. Anyway the best way is to use std::cin to get the word from the user, then pass that string (the one you read the input into) to another function which has the functionality for finding the palindrome (hint, hint thats whats in your main function). Now to print out and then return you follow exactly what is already being done here. You use std::cout to output then return 0; or return 1; in the appropriate conditions. 
Ok going to see what I can do. Apologies for posting pictures, im new here. 
Agreed with the being explicit with the intent part.
You won't be able to use std::cin, as that's a C++ feature, not C. You probably want to look at the scanf function. Specifically, something like: char str[100] scanf("%s", str); And then whatever is input (that is less than 100 characters) would end up in the str variable. Over 100 characters...This'll have problems. Further work would be required.
std::cin is for C++, not C. I'm guessing you mistook which subreddit this was :P
Oh thats hilarious. Youre right I definitely did. Scanf and printf friend. Lol. 
Very handy trick, i implemented it for [FNV_1A](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) &amp;nbsp; #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #define FNV32_OFFSET 0x811c9dc5 #define FNV32_PRIME 0x1000193 #define FNV64_OFFSET 0xcbf29ce484222325 #define FNV64_PRIME 0x100000001b3 #define H0(c,h) ((c^h)*FNV32_PRIME) #define H1(s,p,h) H0((uint8_t)s[(p)&lt;strlen(s)?strlen(s)-1-(p):strlen(s)], ((p!=strlen(s)-1)?h:FNV32_OFFSET)) #define H4(s,p,h) H1(s,p,H1(s,p+1,H1(s,p+2,H1(s,p+3,h)))) #define H16(s,p,h) H4(s,p,H4(s,p+4,H4(s,p+8,H4(s,p+12,h)))) #define H64(s,p,h) H16(s,p,H16(s,p+16,H16(s,p+32,H16(s,p+48,h)))) #define H256(s,p,h) H64(s,p,H64(s,p+64,H64(s,p+128,H64(s,p+192,h)))) #define FNV32(s) ((strlen(s)==0)?FNV32_OFFSET:(uint32_t)H256(s,0,0)) #define HL0(c,h) ((c^h)*FNV64_PRIME) #define HL1(s,p,h) HL0((uint8_t)s[(p)&lt;strlen(s)?strlen(s)-1-(p):strlen(s)], ((p!=strlen(s)-1)?h:FNV64_OFFSET)) #define HL4(s,p,h) HL1(s,p,HL1(s,p+1,HL1(s,p+2,HL1(s,p+3,h)))) #define HL16(s,p,h) HL4(s,p,HL4(s,p+4,HL4(s,p+8,HL4(s,p+12,h)))) #define HL64(s,p,h) HL16(s,p,HL16(s,p+16,HL16(s,p+32,HL16(s,p+48,h)))) #define HL256(s,p,h) HL64(s,p,HL64(s,p+64,HL64(s,p+128,HL64(s,p+192,h)))) #define FNV64(s) ( (strlen(s)==0)?FNV64_OFFSET:(uint64_t)HL256(s,0,0) ) //ONLY FOR TESTING uint64_t fnv64_1a(const char* str, size_t len) { uint64_t hash = FNV64_OFFSET; for(size_t i=0; i&lt;len; ++i) hash = (str[i] ^ hash) * FNV64_PRIME; return hash; } uint32_t fnv32_1a(const char* str, size_t len) { uint32_t hash = FNV32_OFFSET; for(size_t i=0; i&lt;len; ++i) hash = (str[i] ^ hash) * FNV32_PRIME; return hash; } int main() { const char* const STR = "funny_bone"; printf("\nHASHING STRING:`%s`\nMACRO -&gt; FNV32:0x%X FNV64:0x%llX\n", STR, FNV32(STR), FNV64(STR)); printf("PROC -&gt; FNV32:0x%X FNV64:0x%llX\n\n", fnv32_1a(STR, strlen(STR)), fnv64_1a(STR, strlen(STR))); return 0; } 