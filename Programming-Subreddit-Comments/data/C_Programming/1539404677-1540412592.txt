I'm a proud user of the Microsoft C/C++ compiler which comes with the Visual Studio Community Edition. But I have used GCC and Borland's Turbo C/C++ in the past.
&gt; While C is certainly closer to hardware compared to e.g. Python or Haskell, C is actually defined for an abstract machine modeled after the PDP-11 This may be true. However, x86 also defines such an architecture (and the microarchitecture is hidden on any 'usable' cpu) so it's unclear that it's possible to use anything closer to the hardware.
PGI for HPC as well as nvcc for CUDA
good work... continue
`strcmp` is in string.h, the compiler may be smart enough to include it for you or the string.h header was included inside another header you may be using. Satan may also live inside your computer.
&gt; Also, some big datacenters and research organizations use ICC, or Intel's C Compiler. I have heard of this exposing bugs in software that wasn't developed with it. I guess that is not too big an issue for a research org.
&gt; just so that I can feel like a real man after compiling something in C from a command line I always use make, I never invoke the C compiler directly.
Interesting. I'd guess ICC takes "better" advantage of the number of cores in a given CPU just based on the observation that Intel makes both. Maybe some shared memory related issues written by the programmer? I dunno.
It will be implementation-specific if you include other headers and they indirectly pull in string.h. I've just tried a basic test with gcc, clang, and VS2017 with just &lt;stdio.h&gt; and get the expected "implicit declaration" (or equivalent) compilation error. What compiler are you using? And what headers ARE you including? 
If no prototype exists, the compiler will create one with the parameters passed and assume int as the return type. This will throw a warning, but the code will work if the function is actually defined. Note that this is undefined behavior; it does work on most compilers though.
gcc i included stdio and stdlib
There's nothing wrong with asking for help, but maybe try to learn something on the way? You got a snippet of code that's not yours, and you want someone to edit it for you instead of figuring out how it works? I have a hard time to see what your contribution will be in your assignment, and what's worse, how it will actually benefit you in the end.
I want C11 features of course, and also `?:` with empty true branch. Fortunately both gcc and clang support these. I like to shift between them as they sometimes catch different problems. I suppose I also use __has_include, only started doing that recently. 
To be honest I normally use more GCC since I tend to use the GNU system. But Clang is also great!
Autoconf is primarily for dealing with differences in kernel and library interfaces, declarations, and stuff like that. Automake is for dealing with differences in make implementations, build tools and automating dependency management within your project.
Sure, but his point about readbility is true. Just because you *can* do it in online does not mean you *should* do it in one line, regardless of the language. When you inherit code, you want to be able to understand it right away, not marvel at some long gone coder's ability to save a couple dozen bytes of hard drive space..
The text seems to be interesting. Thanks for sharing!
They serve different purposes though.
I'd say we can judge a language's usability for large projects based on a couple of things. First, how many rules do I need to add to people writing in the language to confirm that we can coordinate coding together? Second, how many of those rules are enforceable automatically by compiler tools, and how many must be checked by a human? So, for example, C, C++, and Python all have a problem where the order of #include/import statements can matter. So, on a large codebase you typically have to implement standards that say, "Yeah, don't write code where your import order matters." This is one of those things that can almost be checked automatically. Another one -- naming of functions. In C++ I can say, "You may not add a function to the global namespace." And I can even check to see if that happens or not automatically. In C, I have to have naming rules like, "Either make a function static, or use the appropriate prefixes for the code. namespace_function()" These are a couple -- there are more, from policies on who is managing what memory, to policies on what to do with a free'd pointer's value after freeing it (free(p); p=NULL;). All of these make coding a large project in C manageable. I'd be absolutely lying to say "it's impossible to do a large programming project in C". The Kernel is a pretty good example of a large programming project done in C. However, they have done so with very exacting standards for development. And even then, they are managing very small changes. There have been 225000 lines of code added to the Linux Kernel this year. From 3300 developers. That's not a lot of code for a group of that size. Compare to pretty much any other current project under active development, and you'll see very different numbers. So, I'm being hyperbolic with, "virtually impossible." But, I still believe if you are choosing a language for a large project for contribution and coordination by many people, C is a really bad idea.
Yep. Cross built on Linux for Windows a few times. Only got ya is getting libs as msys2 won't run on Wine and has no native version for the job. So you need Windows to get the libs. Or you build them all. Shame Debian doesn't have a mingw-w64 multiarch. Once you have them, you can develop on Linux and run it with Wine.You only have to use Windows for final testing. So you can develop for Windows like anything else and not have to change your whole development enviroment.
Thanks for your response. There are many day to day problems for which I would prefer to choose a different language than C. I surly wouldn't choose to write a text parser in C if the situation allows it. But in this case I wouldn't choose C++ either but Python or something similar for example. Maybe I got too hung up on the "cannot get shit done" part, because in my job (embedded Linux programming) I need to get shit done with C every day and I think I'm doing quite fine. &amp;nbsp; Here my subjective answers to your arguments: * No template libraries: depending on the problem at hand (lets assume the problem is even one where you would consider C) I feel that templates do nearly nothing for me. `void*` and some functions and you are ready to go. * Manual memory management: it is not that bad with proper abstraction and encapsulation. * No object abstraction: I'm not quite sure what features you consider as "object abstraction", but polymorpism is the only feature I really miss in C. But I don't mind to call `my_func(&amp;my_obj)` instead of `my_obj-&gt;my_func()`. Aggregation beats inheritance most of the time anyways. * Poor package management tools: I think in the domains where you would use C you will either use static linking or use the shared libraries provided by your distribution. So this argument seems like a red herring to me. * poor / nonexistent error / exception reporting: this is the one I never understand. Most errors are non-recoverable in a meaningful way. All you can do is pack your shit and go home: cleanup resources and die gracefully. Cannot reach the database? No space left on the drive? Out of memory? In all these cases you cannot do anything meaningful to recover. `try/catch/finally` is little more than syntactic sugar over `if(error) {goto cleanup;}` as it is done all over the Linux Kernel. The flow of control is the same. &amp;nbsp; Besides of this, all error / exception handling techniques suck big time, the only exception for me is Common Lisp and consorts. Which really gives one a powerful mechanism to handle errors. But even there it ends in cleaning up resources and dying gracefully. &amp;nbsp; So trying to get to an end with my rambling: in a situation where I wouldn't consider C I also wouldn't consider C++ or Java but a completely different kind of programming language. Which would be strongly typed and supports dynamic typing and might even break out of the common cruft like scheme / CL. All the languages in the "gray area" in between don't offer enough abstraction to get me really hyped :)
You're almost certainly better of just using [Expect](http://core.tcl.tk/expect/index) rather than trying to reimplement it yourself. 2-way communication with another process presents a number of challenges. In particular, that other program may behave differently when its standard streams aren't connected a terminal. The C standard requires that a program's standard input and output are fully buffered if and only if it can determine that they are not connected to a terminal.
I agree. Coding is not for everyone is what this post tells me. This person does not have the perseverance to be a coder. 
If you don't have the determination to solve this on your own, you shouldn't code. It's not for everyone. 
I used to enjoy using the Metaware C compiler years ago. When it issued an error message it would tell you which section of the C standard you'd violated.
Many thanks. That solved the question that keeps bothering me. 
tcc
Yup. But I use windows.
You don't get to decide what "a large project" is, and you also don't get to decide on how someone else writes code or manages a project, or any of the things you seem to think you get a say about. Sorry, you're still just acting as a goalkeeper and it's getting a little tiring. 
Depends on what I'm doing. Sometimes it's GCC (EMX/DJGPP/A.OUT/ELF/COFF)... Sozobon, PCC, Watcom, Borland, Microsoft QuickC/Visual C++, Plenty of CPU OS types as well. Just the other day I built a toolchain for a.out on 68000's to target MachTen, and just by guessing and mashing machine &amp; definitions I got one to actually work. GCC is great for being portable, open and free, although PCC is more human readable. Sozobon is basically 68000 only, although I tend to use that more as proof of concepts, and it's a heck of a lot more lightweight than GCC. Watcom was the king of fast/portable on x86, the source has stuff in there for all the NT RISC targets, although I don't know if they ever made production releases. I guess it's more famous for DooM &amp; DOS4G/W than anything else. Although the Windows Extender, WIN386 is pretty neat too. And it's pretty much the only way to write a NLM. For a while Borland TurboC/C++/Borland C++ was king, but their failure to jump on the 32bit bandwagon left a lot of people going to Lattice &amp; Watcom. Watcom was far superior. Microsoft C was pretty touchy in the day, many things would partialy build in 5.1, needing either 6.0 or 7.0 to fully compile. Speaking of 7.0 was a full on train wreck, and the lack of 32bit versions again in those key 1987-1993 years are so utterly bizare that I don't know what the hell was going on. Especially as the C compiler on Xenix 386 *IS* Microsoft C, along with MASM386. It's not like the tools didn't exist just that Microsoft kept them off the shelf for some strange reason. By 1992 with the NT Beta in full swing, and Pharlap TNT 4.0 making it's debut allowing you to run 32bit MS C stuff on MS-DOS things started to look up, although using a beta compiler? yeah no. Ever since the rapid decline of Watcom, Visual C++ has picked up speed. Although it's always good to have a 'go to' benchmark that is more 'real world' than some specint thing to mess with compiler flags &amp; versions. I've been using timedemos out of Quake1 for a while as a good mix of integer &amp; floating point performance. Although the jump from VC 2008 to 2010 was [kind of freaking crazy](https://virtuallyfun.com/wordpress/2010/04/15/follow-up-on-visual-c-2010/). Another annoying thing about Visual C++ is that it's been a cross compiler for the longest whlie, but for the most part, released as native tools. This didn't help things in the NT RISC days, as you'd have to buy a MIPS,PowerPC &amp; Dec Alpha to get all four CPU types... Nothing your normal user would do, and if you were going to pick one non i386 platform, it'd be the Alpha which brings me to my next point: Visual C++/Microsoft C 8 on the Dec Alpha was terrible. Like the WORST kind of terrible with slow programs, or running with /OX or /O2 yielding binaries that wouldn't run on many machines. What really sucks is that by the time Visual C++ 6.0 &amp; Visual Basic 6.0 shipped for the Alpha (yes they were a thing!) they had gotten the compiler working great and it was cancelled. Oddly enough Visual C++ 4.0 on the MIPS &amp; PowerPC worked just fine. Also I've found stuff like [MS-DOS Player](http://takeda-toshiya.my.coocan.jp/msdos/index.html) incredibly valuable under Windows, as a great way of running old toolchains, it let me build a significant part of MS-DOS 2.00 withouth having to dualboot or us a full VM. If only the source to 2.00 was complete....
Thanks OP, I feel the same way too, you summed up my opinions perfectly. I still love C though
Legos are easy.
This. Work I want easy. Play I want challenging.
Clang, it has -Weverything
I'm not goalkeeping. You may choose whatever you want to for whatever project you want. You may also choose to have a wolverine as a pet. But don't be upset that people tell you that it's not a good idea. And also don't be upset if you come home to find it has eaten a delivery guy. 
I cut teeth with borlands free c compiler, but migrated to mingw(gcc cross compiled for windows) then gcc on nix and finally clang I really like clangs more descriptive errors and warnings compared to gcc's, for assembly I like Nasm.
Username checks out?
LLVM on Xcode and GCC on my other IDEs.
Beautiful
For home projects I'm normally a go to for preinstalled gcc and I like it. &amp;#x200B; For work, I'm pretty regularly on a risc-v flavor of gcc and increasingly clang, and the hacks of those crocked up in house (I'm not the compiler guy, so yey! I only report problems!)
Oh you! I'm sure you're beautiful yourself, too :)
I'll take a shot: Python has become one the most popular languages out there, praised by its readability and flexibility. It is very easy to learn and has superseded many other languages (C, Pascal, Java, etc) in introductory programming courses. Does it have some funny features at times? Yup, it does, and I don't know any language which doesn't. But if you actually take time to learn the language, you will be more than capable of reading almost any Python code out there. I mean, to say that C is more legible than Python is pretty ridiculous: imaging learning from scratch either language and, after 1 month of doing so, trying to read a production code of a standard library of either language. I can guarantee you that the Python coder will at least understand what is going on, while the C coder will be mostly likely lost. There is a reason why Python is called "high level". Now, as many people have said every language has their purpose. OPs attitude is extremely naive and conceited, saying that he should "immediately give up" learning something because he's not used to the philosophy of the language. If he wants to actually be a decent coder and expand his skills, then sometimes you gotta bite the bullet. For example, I got a job which the expectation is to write in C. I am not a proficient C coder, but here I am, learning. Back in the day another job required Perl to do a bunch of small scripts, so I learned Perl. When I did my postgraduate degrees, everyone used Matlab, so I learned Matlab. A friend of mine was doing back end web design but wanted to move into frontend, so he learned JavaScript. His new job also uses a lot of serveless, so he learned Node.js. I could go on. I'm sure you have had many of these experiences in your life as a coder as well. OPs attitude is pretty ridiculous and I guess it's spilling on you!
Huh, a quality answer. Didn't expect one of these here. Good job mate.
I have never been so jealous of a surname.
gcc, Solaris studio, xlc++, Visual studio 
= is an assignment operator == is comparison (Not being used) Source is being assigned to dest and then dest is checked if it is nonzero. 
Understand what?
Can confirm, am compiling through command line, so I **know** I have no idea what I'm doing.
Watching without doing is pretty much useless, if you're watching and coding along, you'll learn a lot though. You also need to solve some problems, just copying what someone else is doing with minor alteration doesn't challenge your understanding of the language, it's when you try to do stuff on your own that you start to realize where you misunderstood things and can improve.
You don't need to package msys2, though you will need bits. Just getting the files isn't quite enough because there is some setup. Least that is true with GTK3.
If I'm writing C and not C++, usually gcc. Occasioanly I need to write C programs in visual studio at uni, in which case, whatever that uses.
no. just no. That damn think from kitware was looking good up until they made it like emacs. Freakishly huge bloated and out of control.
All options suck. But at least cmake is better than autotools.
There’s a possible difference between you including `&lt;string.h&gt;` and not: `strcmp` may have two meanings to the compiler. E.g., you may have #define strcmp __builtin_strcmp on a GNU-like compiler. `__builtin_strcmp` is a glorified operator, which allows the compiler to “see into” `strcmp`-ness and reason about it better during optimization. If the compiler can’t/doesn’t optimize away an actual function call, it emits a normal call to some extern int strcmp(const char *, const char *); If an actual `strcmp` function is declared, it may be `inline`, or it may have `__attribute__` or `__declspec` modifiers that affect how the compiler treats a normal function call to `strcmp`. So omitting the include of `&lt;string.h&gt;` can drastically affect the compiler’s ability to reason about calls to the functions it sets up—unless it acts from some built-in assumptions, no `&lt;string.h&gt;` means every `strcmp` call is emitted as a full function call.
There should be a error message preceding the “conflicting types” error, which should give you where the 2nd declaration of strtold is. What is it?
Are you putting your own declaration of strtold? If so, take it out and let the stdlib one do the job
I understand this, but it doesn't explain why this is happening on the new server and not the old. That is what I'm seeking here. It is going to make this migration a pain and I'm hoping to understand why.
Try compiling build.c with -E to get the preprocessed output on both the old and new servers, and see what’s different in regards to strtold.
Clang is my primary compiler by far. I occasionally test on MSVC. I completely ignore gcc.
While doing some genealogy I ran into some ancestors named "bonesteel" and I lost my shit in pure jealousy.
command line man! Good ol' cc this and cc that and ln me and me too and that over there and output an executable! Front toggle switches! We had all we needed in 1974 and should have stopped there! 
The only thing that seems to differ is that the new server is 64-bit and the old one 32-bit. Does the same error disappear if you force 32-bit compile on new server? Or conversely, does it appear if you do vice versa on the old server? I suspect it has to do with the size of pointers no longer being the same as the size of integers somehow. Why is unclear. The `args()` macro just removes any arguments, so the two declarations should never match, not even on the 32-bit system. Does that macro get defined for both systems or is it conditional somehow?
SizeofA and SizeofB are not arrays, don’t use them as such, and you need to check if the lengths are equally before looping over all the elements. 
This is easier if you take it in steps. Step 1: sort each array in ascending order. Step 2: “compress” each array removing duplicates. This is fairly easy as the arrays are sorted. This can shorten either or both arrays. Step 3: if the length of the arrays differ, you are done - they do not contain the same elements. If of same length, compare element by element, rejecting on first difference. If you get to the ends of the arrays, the elements match. For Step 1, any sorting algorithm will do. For Step 2, copying an array to another one element by element, and suppressing copies if the last copy matched the current one will do the trick. You can do this in place if you maintain two cursors, “next to copy” index, and “next place to copy into” index. Step 3 should be pretty self explanatory. I don’t know if there are more efficient approaches, but above is ok. Step 1 is O(N log N), Steps 2 and 3 are O(N) each.
Oh okay. Well I was given that function and then I'm suppose to add on to that function. So once I check if the lengths are equal, I just have to do a nested loop for sizeOfA and sizeOfB?
Here's a technique that usually works for me when I'm stumped: Try to perform the comparison task yourself, by hand (using some simple example data), and carefully observe the steps you're taking. Talk to yourself out loud and take notes and make diagrams while doing it. Repeat for a few different examples. Once you're confident you know how to do the task by hand, write down the steps in plain English, then in structured pseudocode, and then finally in C.
Sounds like homework? Not going to write it for you but here is some pseudo code. I'm sure there are lots of ways to do this. &amp;#x200B; find length of first array find length of second array compare shortest array first element to all elements in long array until match if no match = not same if match move on to shortest array second element.... and so on if all elements in short array match an element in long array = same
Yes, its part of my homework. Thank you for the helpful tips! This is more understandable with these steps. 
That makes so much sense! Thank you for your advice and help! I understand what I'm trying to do now. 
There's no need to distinguish between the short array and the long array as it makes no difference. Also, your solution is incomplete as it doesn't detect elements in the long array that are not in the short array. I think OP has more than enough to go on at this point, and we shouldn't spell it out any further.
Yep, I misread it. Should be switched around. I was just ignoring the extra data in the long array, which matters in this case. Good luck OP.
That is actually the point of most of your education in CS. Once you learn one or two languages and a bit about how hw and OSs work you can pick up others pretty quickly on the job.
 **#include** **&lt;stdio.h&gt;** **#include** **&lt;stdio.h&gt;** **#include** **&lt;unistd.h&gt;** **#include** **&lt;fcntl.h&gt;** **#include** **&lt;stdlib.h&gt;** **#include** **&lt;errno.h&gt;** **#include** **&lt;string.h&gt;** &amp;#x200B; here are the headers
I'm also using a linux shell as well
Did some digging with gcc -E: https://www.reddit.com/r/C_Programming/comments/9nyrq9/conflicting_types_for_strtold/e7qfusq/
So here's my code so far : &gt;^(#include&lt;stdio.h&gt;) &gt; &gt; &gt; &gt;^(int main()) &gt; &gt;^({) &gt; &gt; ^(double f1, i1, f2, i2, w, l, area;) &gt; &gt; ^(double paint\_required;) &gt; &gt; ^(int wall;) &gt; &gt; ^(int counter=1;) &gt; &gt; ^(float sumpaint, sumarea;) &gt; &gt; ^(int paint\_cover = 115;) &gt; &gt; ^(int can\_paint5;) &gt; &gt; ^(int can\_paint1;) &gt; &gt; &gt; &gt; &gt; &gt; ^(printf("Welcome to AA Painting Company !\\n");) &gt; &gt; &gt; &gt; ^(//number of walls//) &gt; &gt; ^(printf("Enter number of walls: ");) &gt; &gt; ^(scanf("%d", &amp;wall);) &gt; &gt; &gt; &gt; ^(if (wall &lt;= 0)) &gt; &gt; ^(printf("Invalid number of walls !\\n");) &gt; &gt; &gt; &gt; &gt; &gt; ^(//loop for the whole process//) &gt; &gt; ^(//looping//) &gt; &gt; ^(while(counter &lt;= wall)) &gt; &gt; ^({) &gt; &gt; ^(++counter;) &gt; &gt; &gt; &gt;^(//width and length//) &gt; &gt; ^(printf("Enter wall width (feet and inches, separated by a space): \\t ");) &gt; &gt; ^(scanf("%lf \\t", &amp;f1);) &gt; &gt; ^(scanf("%lf", &amp;i1);) &gt; &gt; &gt; &gt; ^(if (f1 &lt;= 0, i1 &lt;= 0)) &gt; &gt; ^({) &gt; &gt; ^(printf("Error!\\n");) &gt; &gt; ^(break;) &gt; &gt; ^(}) &gt; &gt; &gt; &gt; ^(printf("Enter wall length (feet and inches, separated by a space): \\t ");) &gt; &gt; ^(scanf("%lf \\t", &amp;f2);) &gt; &gt;^(scanf("%lf", &amp;i2);) &gt; &gt; &gt; &gt; ^(if (f2 &lt;= 0, i2 &lt;= 0)) &gt; &gt; ^({) &gt; &gt; ^(printf("Error!\\n");) &gt; &gt; ^(break;) &gt; &gt; ^(}) &gt; &gt; &gt; &gt;^(//area//) &gt; &gt; ^(w = (float)i1 / 12;) &gt; &gt;^(l = (float)i2 / 12;) &gt; &gt;^(area = (float)((w + f1) \* (l + f2));) &gt; &gt; ^(printf("Area is %.2lf sq. ft.. \\n", area );) &gt; &gt; &gt; &gt; ^(if (area &lt;=0)) &gt; &gt; ^({) &gt; &gt; ^(printf("Error dimension!\\n");) &gt; &gt; ^(break;) &gt; &gt; ^(}) &gt; &gt; &gt; &gt;^(//paint required//) &gt; &gt; ^(paint\_required = (float)area / 23;) &gt; &gt; ^(printf("Paint required is %.2lf L.\\n", paint\_required);) &gt; &gt; &gt; &gt; ^(//total paint//) &gt; &gt; ^(sumpaint = sumpaint + paint\_required;) &gt; &gt; &gt; &gt; ^(//total area//) &gt; &gt; ^(sumarea = sumarea + area;) &gt; &gt; &gt; &gt; ^(//can paint//) &gt; &gt; ^(can\_paint5 = sumarea / paint\_cover;) &gt; &gt; ^(can\_paint1 = (int)sumarea % paint\_cover;) &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; ^(}) &gt; &gt; &gt; &gt; ^(//total paint//) &gt; &gt;^(printf("Total paint required is %.2lf L. \\n", sumpaint);) &gt; &gt; &gt; &gt; ^(//can paint needed//) &gt; &gt; ^(printf("Number of 5L paint can needed is %d.\\n", ++can\_paint5);) &gt; &gt; &gt; &gt; ^(if (can\_paint1 &gt;= 0)) &gt; &gt; ^({) &gt; &gt;^(printf("Number of 1L paint can needed is 0.\\n");) &gt; &gt; ^(}) &gt; &gt; ^(else) &gt; &gt;^(printf("Number of 1L paint can needed is %d.\\n", ++can\_paint1);) &gt; &gt; &gt; &gt; &gt; &gt; ^(return 0;) &gt; &gt;^(}) &amp;#x200B;
Can i call c code from Python? Or the other way around?
Weird. I just helped my friend with this exact problem for his assignment due on Monday in systems programming class.
To get the size of an array you can do: int size = sizeof some_array / sizeof some_array[0]
Now you've got me curious. I can immediately think of an O(n + m)-time solution, but it has a very high space complexity (takes up to half a gigabyte of memory on a 32-bit system, depending on the input). Is that what you're thinking of, or do you have something better?
There are a massive amount of libraries that abstract all of that stuff...
I'm interested in using it to do really amazing work in making simulations, like VR engines and such, but that's so far away. For now, I'm hoping to start programming by learning how to have a 1 on 1 conversation with the computer. Mastering basics and such. If C is a tool, then I'm wondering if it scales with skill (i.e. the more I invest in this language the greater the pay-off). Can I do complicated things with C too? Or would I eventually have to move on to another language for that.
 I think you dont realize how C and Jesus are synonyms. Almost all modern languages use C or were influenced by it. **You can do anything in C**, whether it is a good idea or not is another question. You are not gonna write a website in C when there are languages dedicated to that. 3D graphics are pure mathematics and you need to be able to interact with the GPU. As far as I know C++ and C are the preferred options for that. &amp;#x200B; Your friend is using Python, a language that is being interpreted by software written on C. &amp;#x200B; The whole embedded system world is based on C. Your car and lots of devices at your home are full of C code. That is what it is mainly used for right now. I like that since it involves very much real problems, math (sometimes) and you are constrained by the memory and processing power of micro controllers, which weirdly enough I like.
I am doing the same thing. Learning C is not my goal. I am just doing it so I can learn more about systems. I am trying to read *Computer Systems, a Programmer's Perspective* and knowing C is a prerequisite. I am reading K&amp;R. I'm in chapter 4. Some exercises are challenging, so it's taking me too long. I didn't even start the pointers chapter yet, which I've never dealt with before. The problem with python is that you do fancy things without understanding much of what's going on. You understand the logic, but you don't know what's a file, how to open it? Can you have different processes read the same file? Many things that seem like magic. You feel like you are just using some gui software and you're still far away from understanding how the ones and zeros do all these amazing things. With C, you're kinda getting closer to the machine. I didn't get to that point yet, but at least I understand passing by value vs. by reference, I read files one character at a time and found it really cool. Don't let the fancy things javascript does distract you. When you start learning python in the future, you will find it very easy and will pick its syntax in a few days. 
See if the declaration of strtold() in stdlib.h on the new server is surrounded by any #if's or #ifdef's that would allow you to omit it. My guess is though, even if you can omit the declaration, the definition in the libc library would cause a problem at link time. You might want to dig more into __LDBL_COMPAT. It might be related to the 32-bit vs. 64-bit difference that another poster mentioned.
When you're having trouble trying to break a problem down, consider how you might do things by hand.
&gt;making simulations, like VR engines and such I would imagine that would involve a low level language like C, C++, or possibly Rust. &gt; Can I do complicated things with C too? You certainly can. It is just a question of is it worth the costs of doing complicated things in C. &gt;I'm hoping to start programming by learning how to have a 1 on 1 conversation with the computer. Mastering basics and such The best way to learn is by working on something.
so i shall. cheers m8 :)
Find a/the reference for the standard library. Figure out how to find things in it. `ceil` for example.
You should perhaps learn both of them. Do something in C first then look up the python equivalent. You can write a lot of programs which use very little in terms of base library functionality, of course that depends on what you're doing but if you were to write a list of say 20 different things you do in your C programs and then figure out how to do the same 20 things in Python you will see what I mean. Things that I would put on the learning list are : Variable declaration and types Basic control structures loops, if/else File input/output Manipulating data read from files Writing functions with all types of arguments. Passing variables and/or pointers to functions Connecting to a database and sending sql statements. etc,etc With a list like that you have a template for moving between languages and you don't need to open the book and start learning from scratch. This kind of approach applies to all languages. The main difference is the concept of object orientated languages (Python) vs procedural (C). You should learn about classes and objects but they aren't really used in C, you could implement them in C but that's another subject. 
Maybe the libc is different from the one on the old server?
If you use stdio and fgets() for input it's a lot easier.
Are you having trouble with rounding? &lt;math.h&gt; has functions for that, example: ``` #include &lt;stdio.h&gt; #include &lt;math.h&gt; main() { printf("%f", ceil(1.000001)); } ```
just a side note: all that machine learning, simulation etc. libraries for python are just wrappers that basically allow you to call c/c++ functions from python
&gt; Can I do complicated things with C too? You can indeed do complicated things in C too. But C won't do them for you. That's the difference with python. Your friend is making impressive stuff, but it can with libraries he didn't write and has no idea how they work (I assume). C is a tool allowing you to build your own tools. And as these tools will be built on specific purpose they will be more adapted and fit exactly your needs. It requires more work for sure. But the performances and rewards are noticeable.
Why would you need to check the lengths if the criteria is that they just need to have the same elements? You need to loop through `a` and `b`, those are the arrays. `sizeOfA` just gives you the size so you don't try to access members which don't exist. If array `a` is `[2,3,2]` it has 3 elements and `sizeOfA` is `3` so `a[0] == 2`, `a[1] == 3`, `a[2] == 2` and `a[3]` would give you something undefined so you have to limit your loop with the `&lt;sizeOfA` otherwise you'd be accessing some random location of your computer's memory and anything could happen (program crash, mostly). What you need to do is see whether array `a` has some element which array `b` doesn't, and whether array `b` has an element which array `a` doesn't. If you find such element, your program should return false, otherwise true.
Do you have em on your GitHub? I'm having troubles making my data structures generic, mind sharing a link?
[Here's the link.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
I have the perfect code for u https://pastebin.com/QEwkfXyA Hope this helps
&gt;Reddit suggested I start with C instead Blunder #1. Never, EVER let reddit tell you what to do! While this sub is a notable exception, 80% of reddit users are kids under 20, and the average age is 15, who have never held a job in the field.
&gt; Can I do complicated things with C too? C can do anything any other language can do and smaller and faster, too. Some languages even compile to C first.
imagine that you have to do something i times, then that while will decrease by one in each iteration, and stopping when i == 0 (as 0 is casted to boolean as false)
Let's say you have a variable `i`. ```c int32_t i = 842; ``` When you execute `i--`, it decrements `i` and returns the **previous** (pre-decementing) value of `i`. When you have a `while(expr) { body }` loop, it will keep on testing if `expr` is true, and if so, execute the `body`. In C, anything that is not 0 (`NULL`) evaluates to `true`. So, when you have a construct like `while(i--)`, you can read it as: ```c int32_t i = 842; beginning: // decrement i and store previous value int32_t previous_i = i; i = i - 1; // test if previous_i is true (as in, nonzero) if(previous_i != 0) { // execute body (no statements here) // start again goto beginning; } ``` So this code will run (and keep on decrementing `i`) until `previous_i` is `false`. When `previous_i` is false, `i` is one less than that, so it's -1. Here's some actual code you can run to test this: ```c #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int32_t i = 842; while(i--); printf("i = %i\n", i); return 0; } ``` Now, here's the important bit. Yes, that construct works. But I can't think of a single use case where it would make sense. It's confusing to someone who it reading the code, and it doesn't communicate the *intent* of the code. A while look without a body is legal in C but again, kinda weird, I wouldn't recommend it. 
it is like writing while(i&gt;0) { i--; // same as writing i = i - 1 } while will evaluate the expression (i--) as true, and false when it's 0
Okay, here's the thing. I love C, I've been using it for almost ten years now. I like how simple it is compared to other languages, I like how it's always obvious what's going on. But, we live in the 21st century, and not in 1970. C is great for a lot of things. But I don't think it makes a particularly great beginner language. It just takes too much time to get anything done. For example: * Need to work with large numbers? Python, Ruby, etc. all have BigNum libraries built right in. C? Forget about it, you'll have to use something like GMP manually. * Want to fire off some HTTP requests, maybe log into twitter? Well, good luck. C doesn't have HTTP stuff built-in, so you'll need to figure out how to use libcurl. That'll be like a couple hundred lines of code (that you need to understand and maintain). In Ruby and Python, that kinda stuff if built right in. `Net::HTTP.get_response(URI.new("http://twitter.com/api/..."))` * Need an array? Maybe a HashMap? All languages have that built-in, except C of course. You'll need to roll your own, which you have to understand and maintain, or pull in a huge library like glib. And if you do roll your own, and there's a mistake, good luck tracking that down. What I'm trying to say is that for a beginner programmer, it's more satisfying to actually *get shit done*. And as a beginner, C is not the right tool for that. You should definitely learn something like * Python * Ruby * Swift * Java Once you are really familiar with programming, and you've done a bunch of projects, you can always expand. You can, for example, write extensions (plugins) for both Ruby and Python in C. It's actually really easy, I've done some modifications to my Ruby runtime. To me, even though I do like C, I only think it's useful for a few cases. * Implementing or extending programming languages. Ruby, Python, etc. are written in C, and you can write native extensions and work on the interpreters itself if you know C. * Working on embedded systems or operating systems. Most microchips have a toolchain that only supports C and a subset of C++ (most of these are based on gcc). That's a place where C really shines. * Writing libraries. libexpat, gmp, glib, jansson, libavcodec, etc.
0 is not “casted to boolean as false”. C does not have a “boolean” type and 0 is an int.
&gt; However, when I look over to my friend who's doing Python...and he's an actual professional This makes a big difference. When I was starting out I wanted to write my own operating system. I naively believed if I just learned C that would be enough. Then I ended up studying computer science because well, knowing a language isn't enough if you don't have the ideas to express in the language. &gt; If I invest as many hours in C as Python, will the pay-off be as rewarding, career-wise and in terms of what I can do with the language. When you are first starting to program, I usually advise to stick to a single language. But once you are comfortable with "programming" itself, there is no reason to focus on one and only one language. I know many languages and actively maintain a working knowledge of about 5-6 of the ones I use frequently. That line up includes both C and Python. &gt; It seems to me that Python is an expanse of libraries and imported functions, and C is, like, a well that's really deep C also has a vast expanse of libraries. Grant it, they are not as well organized as Python. But C is the lingua franca of the software world. Most projects provide a C API before any other cross-language API in order to allow people to access their code. &gt; Would I have to eventually move on to another language if I want to do more advanced stuff? No. You need to study computer science if you want to do all the cool stuff like design your own programming language or write a machine that plays Mario on a gameboy emulator. To a degree, languages can make certain tasks easier, but when you learn about the computability theory you'll see that most languages can express solutions to the same problems. I'm 27, so Python was around when I was getting started. I stuck with C as a first language and learned how to write basic linear data structures on my own before enrolling in an undergraduate computer science program. Having that experience allowed me to get more out of my courses. But I could have done that in any language. The trick is, C doesn't have lists, stacks, or hashtables out of the box, you either need to link in a library or write them yourself. I think the big thing when you are first starting out is to pick one language and stick to it for a while, until you are fluent in that language. I see a lot of beginners jump from one language to the next and never really learn anything because they get caught up in the syntax of each language instead of "programming" as an abstract approach to problem solving.
We are one hundred percent in the same class lmao. 
Yeah that’s what I’ve come to realize. However I’m not sure if we can use those, or if we have to use system calls. 
Theoretically it will never reach 0 because it will keep decrementing from -10 to -inf. In reality it will stop because of how computers store numbers. When you reach the max. negative value and decrement it by 1 it will wrap around and becomes a positive int, which will then come down to 0 eventually.
Something that isn't mentioned here is that --i is similar, but different. It is also shorthand for i=i-1. However, the decrement is done before any evaluation, while i-- does the evaluation then decrements. To show this in action, i=0; while(--i) printf("\ni: %d",i); will run forever, while i=0; while(i--) printf("\ni: %d",i); will stop immediately.
Please edit to fix formatting, and add the #include statements. Your buffer is one character so you can't even detect "\n\n" pattern since it won't fit in the buffer. Even if it would, you could have read "something\n" and "\nsomething" in the next read and again fail to pick it up. Seems to me that in the last loop you should keep track of the previous read. Then for every "\n" found you'd have to check whether the last char was also "\n" or something along those lines. With a buffer &gt; 1, I suppose it would become a bit more complicated.
p is of different type "addrinfo"
And if you look, in addrinfo, the type of ai_addr is "sockaddr *", which you need to cast to a sockaddr_in. In other languages, this would be done by parent classes and subclasses. 
This is really easy, you can use the C built-in `qsort()` function to sort the elements, and write a couple helper functions to remove duplicates and then it's a simple array comparison. ```c bool contains_same_elements(array a, array b) { int32_t a_copy_data[a.length]; int32_t b_copy_data[b.length]; array a_copy = uniq(sort(copy(a, a_copy_data))); array b_copy = uniq(sort(copy(b, b_copy_data))); /* print_array(a); print_array(a_copy); print_array(b); print_array(b_copy); */ return equal(a_copy, b_copy); } ``` Full, compilable code [here](https://hastebin.com/qesosokewa.cpp). You're welcome.
I don't know what a MUD is or anything but did you re-run `./configure`? It sounds like the project has a replacement for `strtold()`, and it thinks that this function is missing from the host when in fact it exists?
Wow that’s awesome! I can use this as a guide which is gonna help a lot. Thank you! 
To be honest, I can't give you detailed stats because I don't usually manually pick a compiler. As I do most of my coding on macOS, that'll be `clang` for everything. But the stuff that gets built on Linux machines will probably use `gcc`, although I haven't checked. Both of these compilers are pretty standard compliant and basically interchangeable (in the sense that they take the same arguments and spit out the same errors and warnings). When I do work on embedded systems, I usually have to use `gcc` with a custom toolchain because that's usually the only option. Depends on the system of course. I do like `clang` and the LLVM that is behind it. I love that Apple is adopting this kinda stuff, the architecture is just so clean and nice. It's so easy to write your own frontend or backend. I think on a theoretical level, LLVM is vastly superior to most compilers out there. Practically, `gcc` is so old that it's received so many optimisations that it'll probably produce faster code *in some cases*, although I don't know (haven't checked) if that is still true. Now here's the [killer features of `clang`](https://clang.llvm.org/docs/index.html) that means that I'll probably always pick it over anything else: * [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html), you can just pop that in and it'll tell you if you're accessing memory that you're not supposed to. * [LeakSanitizer](https://clang.llvm.org/docs/LeakSanitizer.html), you can just pop that in and it'll tell you if you have any memory leaks anywhere. * [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html), this one tells you if you read from uninitialized memory. * [UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html), this one tells you if you use a wrong pointer (for example a `NULL` pointer) or do some wrong floating-point conversions. These are *really* awesome features and I've used them a bunch. This kind of tooling is just amazing!
Okay, that makes more sense of what a, b, sizeOfA, and sizeOfB are. Thank you for your help! 
You could do something like [this guy did](http://agateau.com/2008/gdb-trick-the-poor-man-loop/). But yeah, `gdb` is **not** a REPL, you shouldn't treat it like one! Maybe write a function to do that, recompile the code, and you can call it.
No worries. Remember to make your life easier by: * Commenting stuff * Breaking things down into small, independent functions that you can test individuall (see my `test()` function). * Use your own data types to encapsulate things (eg. if an array has some data and a length, put that both into a struct so you don't need to pass two parameters per array, and it's easier to follow the logic). * Write some debug functions like `print_array()` to see what's going on with your data types. * Be consistent in your naming of things. In C it's common to write function names lowercase with underscores `like_this()`, constants in all caps `LIKE_THIS`. * Use all of the features of the standard library. Don't use an `int` to represent a boolean value, include `stdbool.h` and use the `bool` value. Don't write your own sorting function, use `qsort()` from `stdlib.h`. If you want more of these kinds of tips to make your life easy, I can recommend the book *21st Century C* that is available on [Amazon](https://www.amazon.com/21st-Century-Tips-New-School/dp/1449327141). I'm not affiliated with the author in any way, but I bought this when I was starting out and it blew my mind!
Wow! Thank you for going an extra mile to help me out! I appreciate it! I will definitely look into the book. I need all the help I can get haha. 
I'm using 'C Programming, A Modern Approach 2nd Edition' by K. King. I believe it's a college textbook for C? I found it online and it's pretty engaging. Right, that's the idea I am holding on to when learning C. I've heard a lot about K&amp;R (I think it's like the bible of C written by C creators). I trust that it'l be worth it; I'll read that once I'm more familiar with my current material :)
Right, that makes sense. Thanks for giving me perspective on the job aspects too :)
I can understand that criticism. But the thing is, you're gonna pick up that syntactic sugar at some point. And when you do, it'll tremendously speed up your coding. Let me give you an example: let's say that you want to convert a string (like `hello`) into it's binary representation (like `0110100001100101011011000110110001101111`,still as a string, tho). In Ruby, using a bit of syntactic sugar, you can do it like this: ```ruby "hello".bytes.map{|b| b.to_s(2).rjust(8, '0')}.join # =&gt; "0110100001100101011011000110110001101111" ``` How does that work? Well, we can break it down piece by piece: ```ruby "hello" # =&gt; "hello" (string) "hello".bytes # =&gt; [104, 101, 108, 108, 111] (list of numbers) "hello".bytes.map{|b| b.to_s(2)} # =&gt; ["1101000", "1100101", "1101100", "1101100", "1101111"] (list of strings) "hello".bytes.map{|b| b.to_s(2).rjust(8, '0')} # =&gt; ["01101000", "01100101", "01101100", "01101100", "01101111"] (list of strings) "hello".bytes.map{|b| b.to_s(2).rjust(8, '0')}.join # =&gt; "0110100001100101011011000110110001101111" (string) ``` Now, whether you like this syntax or not, to me it's very useful because I can just read it. It translates to &gt; Take the string "hello", turn it into a list of bytes, map every byte to the base-2 string representation, right justify every base-2 string to 8 characters with leading zeroes, and join everything together to a large string. If you tried to code this same function (and I do encourage you to!) in C, it'll be much longer than one line (maybe 25 lines of code), which means that it'll take a lot longer to understand it when you're reading it for the first time. Having this kind of syntactic sugar means that you can move fast. I often use Ruby as a calculator. Need to know how an IP address would be encoded in hexadecimal? ```ruby $ irb irb&gt; "192.168.2.1".split('.').map{|d| d.to_i.to_s(16).rjust(2, '0')}.join =&gt; "c0a80201" ``` Are you curious how many digits the number 35359 to the power of 38445 has? ```ruby $ irb irb&gt; (35359**38445).to_s.size =&gt; 174868 ``` You get the idea. Do try to implement some of these things in C: it'll be a great learning exercise. But you don't want to do that everytime you just quickly need an answer. 
I think this was the perspective I was looking for. It's assuring to keep in mind what this language is suited for and what it isn't. Thanks for giving me a clearer idea about the limitations of C :)
Hey, thanks for the insights :) I especially needed to hear that last bit; some time ago I really was vacillating between several languages and not making much headway. As a beginner, I'll take up your advice. Cheers.
I can't agree more with u/SuborbitalPigeon. You should use [meson](http://mesonbuild.com/index.html). It's used by some large projects already, for example the [elementaryOS](elementary.io) team is moving everything over to it. It is ridiculously easy to get started, and it uses the ninja build system by default which is also used by Google Chrome. A simple `meson` configuration looks like this: ``` project('tutorial', 'c') gtkdep = dependency('gtk+-3.0') executable('demo', 'main.c', dependencies : gtkdep) ``` It's straightforward, you can declare projects (multiple ones if you want!) and libraries. Libraries can be system libraries or they can be part of your project (so you could split your project into multiple libraries and multiple executables, no problem). Stay away from Autotools, CMake, Scons, etc. Have a look at the syntax and features they offer if you like, but trust me that meson is much nicer to work with. Makefiles are nice, and I use them for a lot of my projects. They are simple to understand, and they do *exactly* what you want them to. But they can quickly get out of hand in terms of size and complexity, I've seen projects with thousands of lines of manually written Makefiles. That is horrible. Autotools was a good project at the time, but since then C compilers have become much more standards-compliant and newer build systems have come up. 
+1 on *21st Century C*. I read that years ago when I was starting out with C programming, it blew my mind. But I do have to say that it's getting a little bit outdated now. For example, now we have the meson build system, which the book doesn't mention unfortunately (Makefiles are still useful to know, but meson is *so much nicer* when you have a big project). Also, with `clang`/LLVM you have a lot of awesome tools (see [my post](https://www.reddit.com/r/C_Programming/comments/9nonk4/which_ccompilers_do_you_use/e7r1poh)).
ccsu? &amp;#x200B;
C is for situations where performance matters a lot or there are heavy resource constraints (think of the computers in your car for instance). Web servers, operating systems, databases are written in C. Things where an extra 5% performance can make a big difference. If you're calculating the first 100 primes, it doesn't matter what you use as long as it works. &gt;Would I have to eventually move on to another language if I want to do more advanced stuff? You can do anything that you can do in Python in C, it's just probably a lot more lines. If writing software quickly is important, then Python is probably a better choice.
 Can I do complicated things with C too? YES! You can do things like write operating systems, drivers for hardware, other programming languages (like Python), space ships, martian rovers.
I've never heard of an *internal header*. As you can see [here](https://stackoverflow.com/questions/34312185/c-internal-header-conventions-for-libraries), the usual convention is to keep public headers and internal headers separate by putting the public ones into `include/project_name/header_name.h` and internal ones in `src/header_name.h`. Then, when you compile, you pass `-Iinclude`. In your code, you can then show the semantic difference between these two by how you include the header: ```c // public header #include &lt;twitter/api.h&gt; // internal header #include "twitter_api_callback.h" ```
I took that class a year ago. I graduated last semester. When it comes to the cat program, it helps to come up with a strategy before you start coding. I actually took this class twice initially back when it required using the Raspberry Pi. I had to drop the first time because Unix was so foreign to me and learning it was taking up too much time and affecting my performance in other classes. So, I've written the cat program 3 times now in different ways. The approach that seems to work the best for me is to set a maximum line length rather than a maximum buffer size. This helps create a well-defined program. It's easy to come up with extreme outliers that break the program. For example, what if you have a blank line that is 1000 whitespaces long and your buffer is only 256 bytes? You wouldn't be able to check that the line was blank in order to remove it if the s flag was set. I would set a restriction to only allow a fixed number of bytes per line and truncate the line if any file goes beyond that. However, this approach would cause the program to not work for unformatted javascript files for example. Webpages will often send javascript over the internet without the formatting to reduce the amount of necessary information sent. The program wouldn't work for things like that. You shouldn't go overboard with the extreme input file cases though. I currently don't know how to write a cat program that does formatting to account for all possible extremes when it comes to the input files. Processing the file one line at a time helps make the code a little bit more modular so that you can make changes to the logic easily. You may also need to use the lseek system call.
Looks like a decent article however the code is completely managed on mobile so I couldn’t really view it :/
aka Exploding comments
On both servers it is surrounded by: #ifdef __USE_ISOC99 __BEGIN_NAMESPACE_C99 
Hey, I started with c and did not stick with it for long, but that's because I dont work with low level stuff. What you should do in my opinion is learn the basics of multiple programming paradigms. And that will help you a ton in expressing problems differently. A language is simply a tool and you need multiple tools in order to pick the right one for the right problem. At that point it becomes more about what kind of programming concepts a language supports so you have an idea of what the language can do. Does it support objects or classes? Can you use recursion? Can you pass functions to other functions ? After that you can start going really In depth Into a language in my opinion. Do you have a short or long term goal for learning programming? 
The one thing about learning a low level language like C, you will have a better understanding of how programming works at the lower levels; and if you learn it well enough, that knowledge will bleed into higher level programming languages and make you better, over all, programmer. Other languages are very useful and I wouldn't do everything in C, that would just be painful... but, for some things, C is the best choice. Mostly, myself, I use C for server programming.
https://stackoverflow.com/questions/2728552/how-to-link-to-a-different-libc-file
Thank you for pointing out that to me :) I update a css style. Does it looks better for you now? Thanks!
C takes a while to learn, and an even longer time to get familiar with the intricacies of the language (pointers vs arrays is a notable example). If you want to do stuff fast, use a higher level language like python or javascript (with or without node), it will also teach you a lot of the basics of how programming works (logic flow and stuff). If you want to do stuff that *is* fast (rather than writing it fast), C is probably better. But what's great about higher level languages, is that when you need something to be fast, someone will already have written in for you in C and you can just interface with their code and get the best of both worlds. Don't get me wrong, I love C, but right now it's one of the lest efficient ways to translate an idea into a working prototype, even when you're already good at the language. However it offers you freedom that you'll be hard pressed to find anywhere else.
Most languages generate code which is designed to run on an underlying operating system, and would be totally useless without one. What makes C (and to a lesser extent C++) unique is that some implementations are designed to generate code which can run without an underlying operating system. C is by far the best language for the latter purpose (nothing else even comes close) but it's not even close to being the most suitable language for most other purposes. &amp;#x200B; For $5, one can buy a circuit board containing a small microcontroller and USB interface that can be used to install written in C to operate buttons, LEDs, displays, servo motors, or many other things. Both Keil and IAR produce C compilers that are designed to produce freestanding software, and supply free versions that are limited to 32K code (which is enough to do quite a lot). Alternatively, gcc and clang can be configured to be suitable for such purposes if enough "optimizations" are disabled, but may generate useless machine code with "optimizations" enabled. &amp;#x200B; It's important to note that there are two families of C dialects, since some implementations try to uphold the "Spirit of C" described on page 3 of the published Rationale document, including the principle "Don’t prevent the programmer from doing what needs to be done.", while others try to optimize on the assumption that programmers will never try to do anything for which the Standard makes no provision. I'm not sure why the authors of optimizers are so focused on dialects which aren't suitable for the purposes where C is \*the\* best language, and instead are trying to make C match the performance of languages like Fortran when doing tasks for which those other languages are more suitable than C. Trying to use gcc or clang for embedded programming without disabling many of the optimizations is apt to be an exercise in frustration as things will \*usually\* work but may fail in weird an bizarre ways because of "clever" optimizations. &amp;#x200B;
Not exactly like this, though. This version retains the value of `i` upon loop termination. The OP decrements one additional time. 
If `p` type is `struct addrinfo *` then `p-&gt;ai_addr` type is `struct sockaddr *` and NOT `struct sockaddr_in *`. That's why the cast is needed, you have `struct sockaddr *` and you want `struct sockaddr_in *`. `struct sockaddr` is used all over the place in socket api as "base/parent type" for addresses and then casted to/from a more specific type of address (`struct sockaddr_in`, `struct sockaddr_in6`, ...). This is a form of "rudimentary polymorphism". If you notice, all sockaddr structs begin with a "family" field, starting from a `struct sockaddr *` you can "switch" on that field and know which specific sockaddr this pointer actually refers to. In this way, functions like `bind()` can work with either IPv4 and IPv6 addresses for example. So if you have a generic `struct sockaddr *`, you know it's actually a `struct sockaddr_in *` (like in the OP) and you want to access for example its `sin_port` field, you need to cast it.
Well, gcc 3.4 was released in April 2004 (according to https://gcc.gnu.org/releases.html), so I wouldn’t be surprised if it defaulted to C99, the revision to the C language released in 1999. It should be the same for 32-bit and 64-bit, though. Since strtold() was added in C99, you could try turning off C99 entirely. I’m not sure if __USE_ISOC99 corresponds exactly to turning off C99. Hopefully, your project doesn’t use other features new to C99.
Personally I prefer the macro to be a thin wrapper to a function. Have it grab the expression, file and line, then pass to the function as arguments. Makes the assert usable as an expression; allows customizing the behavior on assert failure, without necessitating a full rebuild of possibly hundreds TU's. 
thanks man, I was actually able to get all commands finished except for -e, i can get the $ to print to the end of the line, but it also prints to the beginning of each new line. it's a great class, new teacher this year who is amazing.
Let me know if you want me to look it over.
Why you want to have assert prints in stdout? Use stderr. In that case no need for macro at all https://linux.die.net/man/3/assert
It's good to study the low level engine stuff and, in parallel, be playing with high level stuff. Especially bc you want to do VR. Get the VR 3D tools, just make stuff, keep yourself excited while you learn the stuff for engine work. Keeping excitement and interest is essential while you specialize 
Thanks man but I was actually able to get it to work, I find sometimes if I take a quick break and clear my mind, coming back fresh always seems to help me solve the problems 
[https://pastebin.com/iaUGCxR9](https://pastebin.com/iaUGCxR9) &amp;#x200B; Here is a queue.c and header file cat'd into one i whipped up this morning.
In the end, some libraries are made in C, others like NumPy are Fortran IIRC and the Python runtime was developed in C. Pretty much the whole plumbing.
Your improvement and abilities as a programmer won't depend on the hours you spend in a particular language. Once you have experience with the main programming paradigms (procedural, oop, functional), then it will not be very difficult to convey your thoughts in various programming languages. The first language you learn takes some time, but that's because you are also learning programming in general, after that learning a new language is pretty easy. It's the general programming concepts and the domain of your field that will be the main difficulty points. 
Firstly you can not do anything you want in C. Most likely no such perfect programming language exists. There may be a way to ask a slab of computing machinery "does my mother love me?" but don't expect an answer that makes more sense than Douglas Adam's "42". Just think of any programming language as a way to translate and idea in your head to some sort of problem solving steps for a dumb machine. To quote the great Paul Graham from "ANSI Common LISP" : Why learn Lisp? Because it lets you do things that you can't do in other languages. If you just wanted to write a function to return the sum of the numbers less than n, say, it would look much the same in Lisp and C: ; Lisp /* C */ (defun sum (n) int sum(int n){ (let ((s 0)) int i, s = 0; (dotimes (i n s) for(i = 0; i &lt; n; i++) (incf s i)))) s += i; return(s); } If you only need to do such simple things, it doesn't really matter which language you use. Suppose instead you want to write a function that takes a number n, and returns a function that adds n to its argument: ; Lisp (defun addn (n) #'(lambda (x) (+ x n))) What does addn look like in C? You just can't write it. So a language in your head is what you use to think with. If you speak and dream in four languages then you are likely able to describe concepts that do not easily exist in other languages. People may think of you as an alien in that most people will not understand you. Worse, they ignore you entirely because you treat ideas and concepts in a very foreign way. Even alien to them. The same can be said of programmers. Find the ones that have worked in the industry since the days of the front toggle switches and you will likely hear tales of many languages to address many problems. Pascal and Fortran linked objects to process numerical data structures. C is a very good one for low level stuff. However it is very much like a swiss army knife. You can peel an apple with a swiss army knife but you can not play Bach's Cello Suite No.1 with it. It would be alien to Yo Yo Ma to even suggest such a thing. https://www.youtube.com/watch?v=PCicM6i59_I
Premise: I love Python For work: I implement communication and security protocols. You can do it in Python? For sure in user space and (eventually) for fast prototyping. But I mainly work in firmware/kernel space. At that level serious stuff is (and should be) written in C. For fun/work: I work on a cryptographic library. High performances and portability are paramount. Even in this case ANSI C is the way to go.
[Some were meant for C](https://www.cs.kent.ac.uk/people/staff/srk21//research/papers/kell17some-preprint.pdf)
If the numbers in both arrays are bounded, and that bound is relatively low, you can just count occurrences. Let's say every number in `a` and `b` is less than `N` and `N` is a few thousand at most: int count[N], i; memset(count, 0, sizeof count); for (i = 0; i &lt; sizeOfA; ++i) count[a[i]]++; for (i = 0; i &lt; sizeOfA; ++i) count[a[i]]--; for (i = 0; i &lt; N; ++i) if (count[i] != 0) return 0; return 1; 
I'm building a compiler in c right now as a side project, so I'd say you can do complicated things in c. (Also most c compilers are compiled in c by themselves.) A lot of things present in C++ that would be great to have in c have to be manually implemented since for whatever reason there is no official implementation of: vectors, linked lists, size aware arrays/strings, etc. Also you can't get type as a string in c for all cases.
No need to copy. Just iterate over both sorted arrays using two counters: int i = 0, j = 0; while (i &lt; sizeoOfA &amp;&amp; j &lt; sizeOfB) { if (a[i] != b[j]) return 0; while (i + 1 &lt; sizeOfA &amp;&amp; a[i] == a[i+1]) i++; while (j + 1 &lt; sizeOfB &amp;&amp; b[j] == b[j+1]) j++; } 
The program has its own prototype for `strtold()`, and that prototype is incorrect, which is precisely why you should never do that. Just remove the erroneous prototype include the correct header instead. I'm guessing this code is really, really old. It looks like it's trying to support pre-C89 compilers. Is it still being maintained?
&gt; Let's say every number in a and b is less than N and N is a few thousand at most: 
This is cheating, and the odds are good that you will get found out. Throw that code away and write your own from scratch.
It has _Bool
Yo my dude, if you're gonna paste code, surround it in proper code tags. You need to write something like ``` \``` int my_function() { return 0; } \``` ``` Also, try to post a small minimal example and not one thousand lines!
I see a problem with ``` if(inicio=NULL) ``` You should use inicio==NULL, because '==' is the comparison operator, and '=' is the assignment operator. I think when you run this code, inicio always gets set to NULL, then it prints "nao na elementos na lista" and never reaches the 'else' block.
Thank you very much bro, this solved my problem. 
In this case, I recommend using flags (booleans) that are part of the conditional of the for loop to indicate an answer has been found
The `break` will only terminate the current loop iteration and continue testing the condition. Rather than using break, you should test against a `prime_sum_found` var in addition to the other checks in the body of the inner loop which will be e.g. set to 1 if it is found and set back to 0 in the outer loop.
Put a label after the end of all the loops and jump to it with `goto` once you meet your condition.
Sorry I am not sure what you mean by putting a "label" at the end. Sorry I am really new to programming, but thank you so much for your reply!
Added an example for ya 
I figure people will be learning C for a very long time, in the way that people still learn Latin even though no one speaks it as a primary language. Latin is held up as a model language, the progenitor of many modern languages, and learning Latin will help you understand how other languages are built and where they came from. C is still *the* portable language for working close to the hardware. It's not the *only* game in town for embedded systems, but it dominates there and not much can touch it for efficiency. Operating systems and drivers and things are still generally written in C. And whether you ever need to write that stuff yourself, learning C will teach you a lot about how things work at a low level and you'll be a better programmer for it.
This is the first time I've seen someone advocate using a goto.
Thanks. That’s what I meant by in place.
Goto when not jumping out of the scope of a function is not a bad thing in a lot of cases. Go despite having a very minimal feature set has goto statements, and lua did not have goto statements, but added them in version 5.2 because they are so useful. Goto statements can also be used for some advanced C preprocessor macro bullshit.
Thanks everyone for the help. I figured out a way to do it with a break statement by combining all of your helpful comments. Thank you very much! And here is the code in case someone else can benefit from it &amp;#x200B; void conjecture(int low, int high) { int even_number; int i, j; int existing_statement; for(even_number = low; even_number &lt;= high; even_number = even_number + 2) { existing_statement = 0; for(i = 2; i &lt; even_number; i++) { if(is_prime(i)) { for(j = 2; j &lt; even_number; j++) { if(existing_statement == 1) { break; } if(is_prime(j) &amp;&amp; i &lt;= j &amp;&amp; i + j == even_number) { printf("%3i = %3i + %3i\n", even_number, i, j); existing_statement = 1; } } } } } } &amp;#x200B;
Because UTF is an acronym... and those underscores between parts of the type are consfusing and ugly... But hey, if you on't like my naming convention, you can use 90% of the C libraries out there with a shitty naming system.
OP probably doesn't know how to put labels, so here's an example with the label included for { for { for{ ... goto label } } } label
Tangentially relates: Do you know the difference between `i++` and `++i`? In your code, there is no reason to use the postfix-increment because the non-incremented result is not used. Using prefix-increment makes the code clearer in intent to other human beings. 
``` tripple backticks on multiple lines ``` four spaces on multiple lines
I should also point this out, I realized this today. It is when you updaete Xcode that Clang will be updated. I thought it was CLion because I updated everything at once and forgot that I also did a software upgrade and XCode upgrade. Just wanted to point that out that CLIon does not update/install a compiler for you. I was incorrect.
Hard to tell with the formatting in mobile, but I think you are "returning" a reference to a local variable in add_card. That memory location is not valid any more outside of that function.
There's something weird going on. When I see your reply in the messages section, then indeed the triple backticks one collapses. When I see it here on the post however, it looks fine. [Here's what I mean](https://imgur.com/a/BkF3KLO). I don't know why this would be, they must be doing something weird. But yeah, fenced code blocks are not part of the [original markdown specification](https://daringfireball.net/projects/markdown/syntax). Still useful to get syntax highlighting working on GitHub, tho, that's why they exist in the first place. I still like to use them without working syntax highlighting because it means that I don't have to indent everything --- just pop a few backticks above and below et voilà.
The Linux kernel famously uses `goto error;` in a lot of places to do cleanup in case of an error before a function returns.
I've always used `i++`. Using the value returned before the increment isn't usually good practice anyway and can be hard to debug.
In `add_card` you store a pointer to a local variable, which is destroyed when that function returns
`_Bool` is ugly and doesn't fit in with the other type names.
My dude, why are you writing int variable_name; for(variable_name = 2342; ...) { First, you should put the declaration right into the for loop, like such. for(int variable_name = 2342; ...) That way you save two lines of code and make it more readable. The only reason that old code doesn't do that is that it used to not be allowed (early versions of C required that you declare *all* variables at the top of a function). But we're in 2018, and since C99 (1999) it's been legal to put the declaration where it should be. Also, this is more a matter of preference, but it looks cleaner when you put the opening brace on the same line as the for loop, like so: for(int variable_name = 3434; ...) { // body ... } Just a hint :)
I would love to, buutttt my professor has a strict style guide I have to abide to. I appreciate the tip though :)
I'm assuming that the fenced one is parsed as inline there, since the style of the box matches that (and backticks *are* used for inline). The thing is, that it apparently only does that *sometimes*.
" I get that you clearly need to feel bigly and tough" providing evidence for this is impossible... bc u have misinterpreted the points of my insults...ill clarify , they were insults based of impatience for your stupid worthless comments. &amp;nbsp; " is it truly that difficult for you to say Thank you" to someone for providing input (even if it was a dup) ?" yes , not sure why you think its your duty to correct everything you dont like ... &amp;nbsp; "You chose to be snarky, ungracious, and contemptuous " ...youve concluded way too much from just a single reddit conversation &amp;nbsp; "- qualities that don't help you get the feedback you're looking for, let alone get and maintain a job at any place of high repute (post-school)." thanks for the advice but it really just makes you sound more sanctimonioous and its really just going to be completely disregarded..just like your useless intolerable futile 'input' &amp;nbsp; "Try to remember: people here take time out of their day to help you; so duplicate or not, be gracious and polite - it goes a long way." really dont get why your trying to "correct" my mentality or change the bad people like and i really dont think you are in a position to indoctrinate others with the common person ethical garbage.. last as a response heres some succeeding real advice ... the world is a big place, your a tiny ant just like me ....stop trying to make the world a "better place" and dont scold others with your INHERITED interpretations of politically correct ethics because they aren't universal mandated laws that humans are obligated to follow theyre just your stupid narrow minded opionion of how you want others to act...therefore ill just keep telling you to shove them up your tiny little butthole ... you FUCKING maggot 
Please do not post your code as pictures. Always post code as text so others can edit and compile it!
Oh damn I totally forgot to put the label, thank you
It's my pleasure
Yeah it really doesn't matter. I use ++i just because it makes more sense to me but modern (very loose definition of modern) compilers optimize (very loose definition of optimize) it to be the same thing in this context.
If your only concern about `_Bool` is that it's ugly, use `&lt;stdbool.h&gt;`. It has the advantage of being constrained to either `0` or `1`, so `if (p == false)` will do what you mean.
While it's true that go-tos are a tool like any other, teaching beginners to just use them like that is probably going to lead to them writing sloppy code in the future. OP, use a boolean flag like another commenter said. Go-tos are, IMHO, a tool that is best used when you have more experience and understand the pros and the cons of such an approach.
Yeah you are right it should be on stderr. Thanks for catching.
Thats a good point. In general that is the case as many macros are implemented. 
It will still point to the memory location http://www.c4learn.com/c-programming/c-dangling-pointer-causes/
&gt; 7.22.3 Memory management functions &gt; &gt; 1 ... The lifetime of an allocated object extends from the allication until the deallocation. Each such allocation shallyield a pointer to an object disjoint from any other object. 
Well, first of all, you're lying to the client about sending HTML when you're actually sending plain text. Second, HTTP uses CR-LF (`"\r\n"`), not plain LF (`"\n"`). Third, `char *passdb = robe[0];` is not a call, it's a variable definition and initialization. Fourth, you never check if `mysql_fetch_row()` succeeded. If the user does not exist, there is no row to return, so `robe` is `NULL` and dereferencing it (evaluating `robe[0]`) results in undefined behavior — specifically, a segmentation fault. I find it strange that you systematically check the result of every API call *except this one*, and even stranger that you didn't immediately realize what the problem is. Fifth, as people told you on Stack Overflow, don't ever store a password in a database, even encrypted. Apply a salted cryptographic hash to the password and store the result, then overwrite the memory that contained the password. To verify a password, retrieve the hash, apply the same salt and hash to the password the user typed in, and compare the two hashes. 
 robe = mysql_fetch_row(result); char *passdb = robe[0]; printf("Content-type: text/html\n\n"); When the user doesn't exist, you'll have an empty result set, so mysql_fetch_row() will return NULL. `robe[0]` will then be a null-pointer deference, crashing the program immediately. Your Content-type header doesn't get printed, so Apache complains about "End of script output before headers." Note: Doing mysql_num_fields(result); in both cases gives 1. Your SELECT statement is asking for one field ('password'), so I believe this is correct behavior, even for an empty result set. Instead of using mysql_num_fields() after mysql_store_result(), try using mysql_num_rows() after mysql_store_result(), which should return 0 for an empty result set.
Ok, checking again (I did try it among many other things) and will revert back shortly. 
It seems to be working now. I'm quite sure I checked it earlier, as I should, but not sure how made that silly mistake. Thanks a lot for pointing it out. \- Also please elaborate your point 1. \- Can you also discuss, as to what is in your opinion the right way of "overite the memory" which you mentioned in regards to storing salted passwords. (I use bcrypt/blowfish). 
Yes, I thought so too, that much was obvious. My confusion arose, since I did check it earlier.. but perhaps I made a silly mistake earlier. Thanks a lot for pointing it out. \- can you please explain in simple term, what is a null-pointer 'deference'. I know null-pointer. \- Also, thanks for mentioning about mysql\_num\_fields and mysql\_num\_rows(). I was going to try using mysql\_num\_rows method, but somehow didn't try it yet. 
&gt; Is that pointer valid until I call free() from elsewhere, or is that memory going to get overwritten once control leaves that function? `malloc()`works globally. Its scope isn't imited to one function. The scope of the variable `out_buf`, on the other hand, is limited in scope to that function. But you're not returning the variable. You're returning its value, which is a pointer as returned from `malloc()`. 
1. You're sending `Content-Type: text/html` instead of `text/plain`. 2. There is no valid reason for violating standards. 3. No, there is no call. It dereferences a pointer and assigns the resulting value to a new variable. 4. What is `rower`? There is no `rower` in the code you showed us. Finally, when you're asking strangers to help you for free, I suggest you park your attitude at home.
&gt; what is in your opinion the right way of "overite the memory" Check if your C implementation has `memset_s()`. If not, you're going to have to get creative, because the compiler is likely to optimize a plain `memset()` away.
&gt; what is a null-pointer 'deference' [Here](http://lmgtfy.com/?q=null+pointer+dereference)
Thanks for this! Much appreciated.
&gt; can you please explain in simple term, what is a null-pointer 'deference'. I know null-pointer. A null pointer is "guaranteed to compare unequal to a pointer to any object or function." Using a null pointer in the context of an object access (`robe[0]`) or a function call is an undefined operation. For an undefined operation, the C standard allows pretty much anything to happen, but a common implementation approach is to have a null pointer behaving as a reference to address 0 in a virtual-memory subsystem, with the hope that null-pointer dereferences will be caught by a memory manager as an invalid access, thus resulting in a signal such as SIGSEGV being sent to the offending process, commonly resulting in immediate termination of the process. Immediate termination is the ideal scenario. Worse scenarios can arise when you introduce optimizing compilers that treat undefined behavior as a do-what-you-please license or when you introduce kernels that allow userland processes to set up a valid mapping for address 0. 
Ah okay, I'm in the clear then. What I'm actually trying to achieve is serialising a structure into a predefined binary format for transmission over TCP, nothing is declared within the function in question. I've been using Rust so much lately (which uses scope-based memory allocation and lifetimes) I had a bit of a brain fart and forgot how malloc() worked. Cheers for the help.
I think bool optomizes by making subsequent bools share the same underlying int, but the next unused bit. It is ugly, you're right. It was made to be so ugly that it would not conflict with other people's implementations of boolean they had created in _Bool's absense.
1. Well, since I have to print additional html later on, so I guess starting with text/html is right? 2. I have to cross check that. Are you sure? I think /n/n is confirming to standards, I did went through w3 standards and ietf rfc's. 4. I meant robe, nvm. Chill bro, I'm not giving you any attitude. Even if I was not asking for help, I would still not mean any offense. I appreciate your help, no complaints. 
Ok thanks. 
Well I got it roughly. Will look into it. Thanks a lot!
Being polite to those attempting to help you - at your request, no less - isn’t being politically correct (polictics? really? Next stop, Godwin I suppose..), it’s being gracious and humble; qualities appropriate for someone looking for **help**, and qualities you clearly lack when the attempt at help doesn’t fit your narrow view of "help." Your loss I guess, but then again you obviously don’t mind; you are, after all, just looking for people to spoon feed you answers (to your homework), and if they aren’t doing that, then they're wasting your time, right? So sad...
i was downvoted by retards, but dont worry bro. youre on the right path. normies shall crawl across your toes like insects in confusion, and even your failures shall tower over the successes of inferior men. go forth my child. 
What is the danger in this goto that you're insisting we avoid?
I don't follow how using this goto would lead to writing sloppy code in the future. However, I do see how teaching someone to fill their code with pointless flags would.
I didn't want to reformat the whole function from my code for Reddit so I made up that brief example. The real function is serialising a struct into a custom binary format, the length property is either 2, 4 or 8 and I explicitly test for this before the rest of the processing takes place (and it's actually a uint_8) along with the obvious test that out_buf != NULL so I think my risk of a numeric catastrophe is quite low. Please do correct me if I'm wrong though, it's been quite a long time since I've worked with C!
C u there man
It's in C11 Annex K, so CentOS probably doesn't have it. Copy it or `explicit_bzero()` from one of the BSDs, but beware that it *has* to be in a different compilation unit so the compiler doesn't know what it does at the point where you call it, otherwise it will be optimized out.
&gt; Well, since I have to print additional html later on, so I guess starting with text/html is right? It won't be valid HTML if it starts with your debugging message. &gt; I have to cross check that. Are you sure? I think /n/n is confirming to standards, Then you [weren't paying attention](https://tools.ietf.org/html/rfc7230#section-3).
Shouldn’t you have malloc(length* sizeof(uint8_t)); ?
As far as I know the standard specifies that `unsigned char` and `uint8_t` have a length of one (making that pointless) while the other integer types are implementation-defined, I could be talking rubbish though. I'll look it up.
Remove the last semicolon from the for loop. And use braces?
&gt; Can anyone help me understand and write malloc hooks and explain the same. You'll have to give more details than that. There's no point telling you how to use, say, glibc's __malloc_hook (assuming it's still around) if you're talking about something else entirely. 
&gt; I have to cross check that. Are you sure? I think /n/n is confirming to standards, I did went through w3 standards and ietf rfc's. The RFCs require CRLF, which is \r\n. You're getting away with using \n\n instead of \r\n\r\n because Apache is forgiving and rewrites it for you. (I suppose it doesn't help that [Apache's own CGI tutorial](https://httpd.apache.org/docs/2.4/howto/cgi.html) uses \n\n.)
This is correct. CHAR_BIT is required to be at least 8, and the presence of the optional uint8_t forces CHAR_BIT to be exactly 8. sizeof(uint8_t) is therefore 1.
yes thought so. There should be something native to CentOS since its associated to RHEL? 
Just an extension to his answer - it is usually best practice to free these in the function that calls it to avoid mem leaks and for code friendliness.
Just an extension to his answer - it is usually best practice to free these in the function that calls it to avoid mem leaks and for code friendliness.
&gt; it is usually best practice to free these in the function that calls it What's the point of using malloc in that case (other than dynamic sizing)? The whole reason for heap allocation is so that you can share the memory across functions and keep it alive as long as you need it. If the scope is limited to a function, stack allocation should be preferred. If you only need dynamic sizing or temporary heap memory, allocate and free within the function. But saying that this is best practice is not correct since you are eliminating the most common reason to use malloc.
Thank you for the response, I had not considered that. I was simply regurgitating information from my intermediate C class, where I assume this was labeled as 'best practice' because we're idiot students and can't learn nuffin.
/r/cpp_questions 
Is this whole sub just "do my homework" now?
Yeah I'm sorry. Not trying to be rude, just seems that every other post is people flat out asking for people to do their homework. Hell some of them just take a picture of their homework and post it. lol no shame. I'll delete my comment though, and good luck.
RHEL's glibc doesn't have `memset_s()`. It's possible that libbsd (`yum install libbsd`) has `explicit_bzero()`. But it's easier do just copy it.
I know this isn't exactly serious, but at medium indentation levels, fibonacci actually looks pretty good.
It also serves multiple purposes: * Keeps code easier to read with less wasted space when the block is just one or two levels deep * Acts as a warning to the programmer when they start to get nested too deep * Presents a semi-hard limit on indentation In languages like C, it would work well. In languages where whitespace is syntax, it's not so great (1 vs 2 spaces can be hard to distinguish visually). 
yes thou shalt
That sort of attitude is utter bullshit. Can you justify it?
Stack space is limited to a few megabytes on modern systems. On old and embedded systems, the limits are even tighter. Allocating more than a few 100 bytes on the stack is generally a bad idea.
The C language doesn't know `malloc` hooks. If you are talking about an implementation detail of your vendor's libc, please specify which platform you are programming for.
Same place is vastly different from same function though. I'm not saying it isn't justified. I just don't think it's fair to call it best practice since it is very much dependent on what you are developing. What you say works for normal applications. For libraries and runtime environment providers, it is not that simple since there is no way to know how and when heap variables are being used. Also, variables internal to the library have to be handled correctly as well which is a different mess altogether. I generally prefer the statement that malloc and free should be done by the same caller, either directly or indirectly. And the callee (library or runtime) should provide ways to do it.
Why are you testing `existing_statement` inside the loop rather than as part of the loop condition?
It’s highly unlikely that a single, standalone `malloc` of small size will return `NULL`, but if it does and you try to dereference that pointer somehow then there’s literally no telling what could happen. Maybe it segfaults, maybe it skips a bunch of code, maybe it detonates your relatives and teleports you to Moscow. If it’s anything that runs in the real world (i.e., with input that you didn’t personally validate and give it, or on behalf of someone who wouldn’t recognize/appreciate relative denotation etc.), then you need a null check. Alternatively, since there’s such a small maximum size, this is a perfect candidate for just taking a `void *` to a buffer (asserted nonnull, presumably) that’s guaranteed to be big enough and filling that. No `malloc` needed, no `free` needed, no possibility of undefined behavior. Also, `int16_t` is a really bad size type to use on a number of fronts, especially if you know it’s one of a few values, all of which are powers of two.
&gt; (Also most c compilers are compiled in c by themselves.) I believe I've heard this before, but it's still kind of mindblowing -- it's like the digital equivalent of parthenogenesis.
Big projects benefit due to its object orientated nature. Also high performance projects due to its speed of execution. Also projects that use a C++ library obviously stand to benefit.
C is still commonly used in embedded systems, where CPU cycles, storage size, and memory are all in short supply.
Good points. So, it may not be any one characteristic (after all, there are many languages with OOP), but the combination of several at once.
Your computers operating system, no matter what you use, is written mostly in C. The web server and browser you are reading this with is written mostly in C. Almost every program in the world has parts written in C and probably has a C interface. Virtually every small device you use is written in C if not assembly. Every device driver on your computer is written in C.
No real embedded system company programs their micro controllers in any high level language. It is a waste of money to buy more powerful systems just to be able to run a language that is not meant to be there in the first place. If you want to "get your hands on fiddly stuff" you need to call native code from your high level language or just program in native code directly. Why do you think the JNI exists for example? &amp;#x200B; People seem to forget there is stuff running behind their high level languages. I guess you can thank 1 week web development bootcamps for that.
I'm surprised Assembly isn't seen more frequently, since it would provide the greatest level of efficiency by nature. That said, C is tight enough for most anything and surely it's more practical (less code to write.)
Well, I knew it was wide-spread; the question I am interested in is learning what about C makes it good for those uses?
I'm sorry; I don't understand how this relates to my question.
\&gt; I gather that C is worth learning on its own merits, without considering practical application. I'd say its handicapping yourself to try and learn a language without practical application... Where C really shines is its stability - there are no new fad language features added to the language each year. Comparative simplicity, and reasonable ease of porting to different platforms, also make it a useful tool. The downside is that you may well find yourself implementing things that other languages have in there standard libraries - for example Java has some really quite nice generic containers that provide amongst other things sortable linked lists, want that in C and you'll either be scouring the internet for someone elses implementation (YMMV!!!) or implementing it yourself. Don't forget though just because you have mad C skills it doesn't mean you should crush every problem with your shiny new C hammer.....
When I first heard about C, it was described to me as a replacement for assembly language. I was skeptical at first, but once I learned the language I was convinced. I have written an operating system. Except for the core context-switching code, and a few other low-level bits, all the rest was written in C. C may be *slightly* less efficient than handcrafted assembler, but what you gain in portability and fewer errors more than makes up for it. There are those who contend that C is *more* efficient than assembler because the people who design the compiler know the hardware better than you do.
My post basically said C was good at embedded systems. The whole world is made out of embedded systems, that is how handy it can be to be able to program those beauties. Most people wont notice it since its not a flashy website or mobile app but people will use your creations every day. &amp;#x200B; Since C is good for embedded systems which have no OS (for the most part) then you can imagine how great C is when it comes to developing anything that has to be low level, like OS or drivers. &amp;#x200B; Besides that C is stable and you can rely on it. That is something I really like about it. C and C++ are languages designed to make programs last. An application coded in C or C++ will last decades, Bjarne has said this himself about C++, one of his main goals is to keep C++ as a language that you can rely on. &amp;#x200B; The "low level world" of computing is not as open as the "high level world" of computing. It is very easy to go to reddit and find tons of stuff about Java, or Python or anything related to web development but the information and resources on the internet when it comes to micro controllers or low level computing in general is far less, perhaps because you need math. &amp;#x200B; If you ask me I prefer the "low level side" or what happens behind the curtains, even tho every job is important and challenging I just find it more interesting to develop and work in an area more concerned about math and engineering.
C is not object oriented. And that's good.
question said c++ also, and that is object oriented
you can expect what ever you want, but like i said, its in the title of the question, plain as day. deal with it.
Maybe I'm just blind but I'm unable to find any optimization flags for the compiler whatsoever, this needs to be the first step! Without specifying O2 or something comparable, no optimization or inlining is going to take place anyway. Even in a debug build, Og should be considered as the default. 
Thanks ! I might as well try this.
Thanks ! I certainly will proceed towards this.
At first I never thought of this. Thanks for informing about this!
Chances are that you wouldn't really benefit from inlining here then. GCC tends to be quite good in figuring that out, there are usually no significant performance gains in forcing GCC. You might want to go with __attribute__((always_inline)) but I wouldn't recommend that...
Perhaps it's time you start using a build generator like CMake or Meson. Having said that, you should take a look at the papers on the GNU Make mantainer's website: http://make.mad-scientist.net/papers/ it helped me a lot in the past. Also, I'd recommend a thorough read of GNU Make manuals.
Google SDL 2. I used to make simple graphics in C using just SDL, you can add OpenGL too to make games in C. Quake was made in C as an example. 
Your performance hit is the modulo operator. Instead, make sure to use sizes that are powers of two, and then use bit manipulation to perform the operation: x % 16 ----&gt; x &amp; 15
I am using code::blocks, build in compiler I suppose. The interface file you fill in a,b and c, the abc file generates the answers and prints them for the amount of triplets given. So no executable or anything.
Don't write Makefiles directly. Use Autotools to generate them. Here's a good guide to get you started: https://autotools.io/index.html
[https://github.com/bkaradzic/bgfx](https://github.com/bkaradzic/bgfx)
I find it helpful to use tools like astyle to format my code. It'll also help find missing closing braces because if you forget one your code will be indented wrong.
You may have a look at these: [http://en.wikipedia.org/wiki/Simple\_DirectMedia\_Layer](http://en.wikipedia.org/wiki/Simple_DirectMedia_Layer) [http://en.wikipedia.org/wiki/Allegro\_library](http://en.wikipedia.org/wiki/Allegro_library)
You'll have to learn how to do this from your study material. Your question is too vague for us to know what answer your teacher is looking for. 
It really is incredible; Typically toolchains will undergo a 'bootstrapping' phase on their journey to become self-hosting (i.e. capable of build themselves), where there are really two compilers; For instance, if you are creating Language X, you must first build a means of translating `X` to machine code, you'll do this in language `Y`. Once you have your first toolchain (built with `Y`) translating your `X` code, you can then use this initial translation to bootstrap or seed writing a toolchain in `Y`.
https://www.raylib.com/
Not true. A compiler won't know ahead of time what size was chosen. It's a variable, and there's no way to guarantee what value it would choose. 
Oh, sure, if the modulus is a variable then there's nothing you can do. But if you *are* going to use a constant, and that constant is a power of two, then you don't need to use bit masking; the compiler will know to do that for you.
Ya know, I was curious about what you said, since it didn't sound right. Spoiler: You are right. First: int f(unsigned int a, unsigned int b) { return a % b; } Which leads to: movq %rsp, %rbp .cfi_def_cfa_register 6 movl %edi, -4(%rbp) movl %esi, -8(%rbp) movl -4(%rbp), %eax movl $0, %edx divl -8(%rbp) movl %edx, %eax Note the divl. So then I ran: for ((i=2;i&lt;40000;i++)); do echo "int f(unsigned int a) { return a % $i; }" &gt; modtest.c; gcc -S modtest.c; grep -i div modtest.s; done Which results in nothing. It seems gcc does absolutely everything it can to not do a div. This is one of those dusty places from compiler classes that I'll have to shake off.
For one, X % Y is a division which is the slowest mathematical operation you can do. just do X - 1.
I don't know how to do it with your compiler, but maybe showing you how I'd handle it with gcc might help? # First compile the C files gcc -Wall -pedantic -c abc.c gcc -Wall -pedantic -c interface.c # Now link them together to make our executable, also linking in the math library for sqrt. gcc -o our_command abc.o interface.o -lm That will create an executable file called `our_command`.
I like how the page contains mojibake.
Thank you, I'll see what I can do with this info
See the `[[likely]]` and `[[unlikely]]` attributes that will [probably go into C++20](http://wg21.link/p0479r5). If you want these in C2x as well, write a paper to propose it. Even if it isn't accepted, I wouldn't be surprised if individual compilers offer it as a non-standard attribute (that's what they do for C++ already).
First off, don't make it more complicated than it needs to be. Second, don't do [recursive makefiles](https://embeddedartistry.com/blog/2017/4/9/recursive-make-considered-harmful). It's not hard to build a `makefile` that will do what you want that's simple. Here's one I'm using for a project: CC = gcc -std=c99 -Wall -Wextra -pedantic CFLAGS = -g LDFLAGS = -g LDLIBS = -L/usr/X11R6/lib -lICE -lSM -lXpm -lX11 -lXext -lXmu -lXt -lm # ================================================================ VIOLA_PATH := $(shell pwd)/resources override CFLAGS += -DPOSIX_C_SOURCE=199309L \ -D_POSIX_SOURCE -D_XOPEN_SOURCE \ -D_BSD_SOURCE -D_SVID_SOURCE \ -DDEFAULT_VIOLA_PATH='"$(VIOLA_PATH)"' \ -DVIOLA # =================================================================== %.a : $(AR) $(ARFLAGS) $@ $? # =================================================================== .PHONY: all depend clean all : viola/viola depend: makedepend -Y -- $(CFLAGS) -- $(shell find . -name '*.c') 2&gt;/dev/null clean : $(RM) $(shell find . -name '*.o') $(RM) $(shell find . -name '*~') $(RM) $(shell find . -name 'lib*.a') $(RM) $(shell find . -name 'core.[0-9]*') $(RM) viola/viola $(RM) Makefile.bak libIMG/libIMG.a : $(patsubst %.c,%.o,$(wildcard libIMG/*.c)) libXPA/src/libxpa.a : $(patsubst %.c,%.o,$(wildcard libXPA/src/*.c)) libStyle/libStyle.a : $(patsubst %.c,%.o,$(wildcard libStyle/*.c)) libWWW/libWWW.a : $(patsubst %.c,%.o,$(wildcard libWWW/*.c)) viola/viola : $(patsubst %.c,%.o,$(wildcard viola/*.c)) \ libIMG/libIMG.a \ libXPA/src/libxpa.a \ libStyle/libStyle.a \ libWWW/libWWW.a (the dependencies generated by `make depend` not included). This works, and even `make -j` works (parallel build---goes really fast).
Yeah, it *really* goes crazy to avoid a div.
Was not my intention. Just wanted to spread the good word.
I would disagree -- there's really no good reason not to just enforce a power of 2 for the size during the init call. You could either say, "The provided length is 'at least', or assert to check to see if it's a power of two.
I like the introduction of new syntax in the first approach less but it's less typing work. I'm not sure if I want it at all, I'm quite happy with the current simplicity. When it comes to Errors I like go or even Rust's way most: fn foo() -&gt; Result&lt;i32, i32&gt;; match foo() { Err(e) =&gt; panic!{"error: {}", e}; Ok(x) =&gt; println!{"result: {}", x); }
I do not like wildcards for generating source lists. Do that once and then update manually. Also recursively calling make is bad. I usually have one root Makefile for settings which recursively *includes* submakefiles for each module that just describes the contents (ie. object files) and perhaps overrides or adds specific rules for these. Basically I have one list of all OBJS, eg.: # root makefile OBJS = main.o include mod1/targets.mk all: main main: $(OBJS) %.o: %.c $(CC) # ... # .... and in the module makefile: # module OBJS += mod1/module.o Generating source lists is just you building a new buildsystem within make and not using make, and I honestly don't see the point.
Yes, you do need to type out the type definition of the result it gives you if you don't plan on immediately passing the failure up the call stack with _Try, but it gives lot more flexibility as to what kind of error information you return, and would allow most modern languages to expose fallible functions to C, greatly increasing cross-language interoperability. From the paper: &gt; If this coordination can be pulled off􏰂, the bene􏰁fits could be profound for &gt; all C speaking programming languages, for example Rust, Python or &gt; Fortran. All these, being able to speak C, could directly understand and &gt; generate C++ exceptions. Also, it's not like the macro is bad: `#define caught(T, E) struct caught_ ## T ## _ ## E { union { T value; E error; }; _Bool failed; }` Sure, macros aren't as nice as language level solutions, but I very much doubt any new failure handling facility would be accepted by the committee if it also included generic types.
The result will eventually need to be used by something, which means that every program will either need to define the type explicitly (which is idiotic) or copy/paste that macro in (just as stupid, especially since there's going to be variations in what that macro is called). At a minimum it should be standardized into `&lt;stdfails.h&gt;`. &gt; Sure, macros aren't as nice as language level solutions, but I very much doubt any new failure handling facility would be accepted by the committee if it also included generic types. Yeah, the committee can get finicky about such things. But that's why I like N2285's version of the syntax, though. Either version is defining a `struct` that's dependent on the return type of the function, but N2289 allows the user to specify the type of the error as well. (Allowing for `_Exception(double)` in the function declaration should be a minor change; it's exactly what N2289 does.) N2285 provides a syntax that has no generic type handling at all, since an instance of the return type has been declared for you implicitly. But I suspect there's problems with N2285's syntax. I don't think they've fully thought out the possibility of reusing the function name. For example, what happens if you try to call the function recursively: does that symbol name refer to the function or to the exception information? Calling the function a second time has the same problem. Even if you say that `foo()` means calling the function and `foo.xxxx` means accessing the return information, what does `&amp;foo` mean? Saving off the exception information means you have to declare the same `struct` that N2289 makes you do anyway. In fact, the more I look through that proposal, the more strangeness I see. Like error codes needing to be odd values (so even values are pointers). Or being able to turn off exceptions, which will turn `return _Exception;` into a NOP -- globally changing the control flow is exceptionally dangerous. I like that N2289 forces the user to use `_Try` or `_Catch` so errors aren't easily ignored. I'm not sure how you'd apply that feature to N2285.
Ok, so you have the code to read in the number, and you're starting on the code to handle each digit. It looks like you recognize that `% 10` will be essential in this process, and you're right: `n % 10` will extract the rightmost digit of `n`. The next step is to do something with this digit (the assignment says to print it, but you'll also need the value to add up all the digits), and then do all that in a loop. So the next questions you need to ask yourself are: 1. How do I add up the digits? 2. What needs to happen to `n` on each loop iteration? 3. How do I control when the loop ends? Once you answer those questions, you're ready to write the loop. I recommend removing the `% 9` check from your current code for now, you can get to that part later.
Okay so question one, I’m guessing something like sum+=num? But I don’t know how to end it ? And I don’t know how to subtract the last integer that gets removed 
Would a for loop be the loop for this? Maybe like for( I = 0; i &lt; n; i++ or i- - ) And inside this loop will there be the num % 10 ? 
You could do it with a `for` loop like that, but it's definitely the hard way. You need to do this loop once for each digit, so you have to calculate how many digits there are before the loop. This can be done with `log10` and `ceil` ... but don't go down that route.
Honestly i give up. I have tried asking the user for the size of the number then asking for a number While that kinda works it doesn’t keep extracting the last numbers. How would I use a while loop to do this? Every time I use a while loop all it does is infinitely keep repeating the last number 
Don't worry. I try to avoid giving away too many answers, because figuring things out is part of the learning experience. But sometimes you just need to see the answer to have that "a-ha!" moment, which is why all textbooks need to have the answers in the back of the book. The first here is how you go from 154368 to 15436: though integer division. So the process we need to code will do this: n = 154368 n % 10 =&gt; 8 n /= 10 (== 15436) n % 10 =&gt; 6 n /= 10 (== 1543) n % 10 =&gt; 3 n /= 10 (== 154) n % 10 =&gt; 4 n /= 10 (== 15) n % 10 =&gt; 5 n /= 10 (== 1) n % 10 =&gt; 1 n /= 10 (== 0) And here's where we stop the loop, since we've gone through all the digits. The condition that we're looking for is when `n` becomes 0, because after that everything's just going to be 0 again and again. So the loop needs to look something like this: while ( n != 0 ) { printf("%d", n % 10); n /= 10; } Alternatively, you can write this as a `for` loop, though it will look different from what you're used to: for ( ; n != 0; n /= 10 ) printf("%d\n", n % 10);
OH MY GOD I had the printf , n % 10 part earlier but it would just keep infinitely repeating because I didn’t have the n/=10; I would have never thought of that. I didn’t even know that was possible, I was about to pay Chegg to solve it for me. BUT THANK YOU ! 
Gcc already supports it for C
+1 on meson. -1 on cmake. 
What is the definition of meetingResponses?
Let me confirm whether I really \*\*have\*\* to use % modulo operator
&gt; The worst part is that you can't even do this stuff manually in standard C right now, because identically defined structs aren't compatible in the same translation unit, and the committee rejected the proposal to make them compatible because they couldn't see a use for it. I'm surprised nobody else pointed this out, I had this exact thought when I saw the syntax - as I tried to do something similar maybe a year ago and ran into this exact problem. The "irony" here is that, if they did just say they were compatible, you wouldn't even *need* the `_Catch` or `_Fails` keywords at all - it would just be a matter of making a macro that creates the type, and then using it everywhere. And if you're going to use `typedef`s to solve this problem, then again you still don't need `_Catch` or `_Fails` (And they likely wouldn't even work with the `typedef` anyway, for the same reason). It makes me pretty sad that they outright rejected what I consider the "good" solution, but are considering all this ugly error handling stuff.
Unless the op needs to cope with very old or weird systems, or wants to contribute something to GNU, there is absolutely no reason to continue using autotools, simply because there are much better tools, like CMake, Meson, waf, tup, build2, etc.
It uses pointers to strings. MeetingResponses[0] is a pointer to the first string in the array. I think you should try removing the &amp; and see if that isn’t what you were wanting to do. 
Yeah that's what it was... I made a new variable and converted it to a string: holdString = strdup(meetingResponses\[0\];
this circular queue needs the use of modulo operator (for indexing after overflow had happened) which require the use of divide operations which takes some CPU time. I wonder if anyone had any idea on how to implement circular queue without the use of modulo operator ?
Efficient, simple, not a trillion syntax complications. Performant and nice if you know what you are writing. While there are people bragging about noob languages, most of rightly engineered operating systems are written in C. And they are more efficient than operating systems written in languages like rust, and also more secure because lots of effort is put on that. As for c++, I don't think it is a nice language. It just bloats gcc and clang installations in most environments, I suppose golang may be better..
C too has prebuilt libraries, but not as much as python. I think C made me think like a computer scientist, visualizing memory locations and literally everything. Learn python because it lets you do things faster with a little impact on performance. (Use pypy or even cython).. Learn C because it makes you brilliant and faster in python programming as well beside producing efficient binaries. Personally I think python is too bloated compared to Lua. But alternative implementations exist. In fact the difference between C and Python is a tradeoff between computer time and programmer time.
MIT OCW has a practical C programming course for free, think will be worth it.
It's almost as if the people who do proposals focus on the things they feel are most important, rather than listening to some random dude on a mailing list. 
&gt; Unless the op needs to cope with very old or weird systems, or wants to contribute something to GNU, there is absolutely no reason to continue using autotools, simply because there are much better tools, like CMake, Meson, waf, tup, build2, etc. Bullshit. Try doing custom stuff like mixing Go and C objects in your hipster reinvention of Autotools: https://github.com/stefantalpalaru/golib/blob/9aab52b3af6c6d770c8da5c44523f2c86be5effa/Makefile.am Also, good luck finding a simpler way to build a Vala desktop application that includes C files: https://github.com/stefantalpalaru/iccloader/blob/575695a9591c3c21135135729e166f8d64ccb82c/Makefile.am You will only understand the madness of CMake by having to maintain it in parallel with an equivalent Autotools build system. I did that and it wasn't pretty.
&gt; Jesus I don't know about that. Autotools is so old an crufty. So is C.
The address of `var` isn't stored in `ip`, `ip` is a pointer to an integer, which is pointing to the integer `var`. `ip` doesn't store anything. `%x` is used in the format string to display the content of an unsigned integer as hex, and as `ip` is not an integer at all but a pointer you can't use it in this way. To print the address `ip` is pointing to use `%p` as you've already discovered.
Without knowing much about the setup I would guess that you're on a 64 bit architecture with 32 bit integers. Under this assumption, the warning is because %d is expecting an integer (32 bits) and you're passing it a 64 bit value (probably a long long). It would probably work with %llx. The question is, why do you want to print a pointer with %x? The purpose of %p is too abstract out pointer size As a related side, before C99 C did a terrible job of handling fixed width data types (the size of an int or a pointer are not defined) but C99 added fixed width types using the inttypes.h header file (https://en.cppreference.com/w/c/types/integer). In general I prefer to use that whenever the actual data size is important, which is most of the time for me. So I'm this case I would do something like this on a 64 bit machine: printf("addresses: " PRIX64 "\n", (uint64_t)ptr); 
Meson does that all. CMake might not be much better choice here, but like I said there are others.
You can cast the pointer to an unsigned integer type to “make this work.” But keep in mind that on many platforms, pointers do not fit into objects of type `unsigned int`. Instead, cast to `size_t` (`uintptr_t` would be even better but there is no length modifier for it) and use `%zx` to print it.
Not gonna argue with that. But C is sometimes necessary, the build system you can choose as you please. At least in theory. 
this phk guy is annoyingly ignorant. Regarding the first comment: * there was a need to add new identifiers for new features * we don't want to needlessly break existing code that may use those identifiers for variables, structs, etc * there's a naming convention for compilers implementation in the standard, it is to use \_ prefixed identifiers. They are reserved and thus cannot clash with standard-complying user code * to make it more palatable, you can have a header file that #defines a more readable name. It is assumed that if you knowingly want to use those you can include that header. Thus any file with old code which you cannot touch for some reason can be mixed with files with newer code with the same compilation settings.
Learn things. I usually use %x to print a pointer too.
What about if the input is 0?
Technically for printing each digit, it should work even if the input is 0. I guess my point is to help the OP to think about edge cases and handle them correctly.
I find it funny that there's no reference to the intended semantics of the attributes in the normative part of the standard, just in a note. It makes sense, as program behavior won't be affected by the attributes for the purposes of the standard, but still.
All documentation I've ever read says pointer variables store the starting memory address of what they point to. If you examine the output it shows this as &amp;var which gives the memory address of var is the same exact address printed when you do this: printf("Address stored in ip variable: %p\n", ip );
Thanks for the precision. My point is this is not done randomly and it is not stupid.
r/https://pastebin.com/XhXL3c6r Will include a packet dump later.
Doesn't seem to work, full code posted below.
I'll look at it again, but 137 is definitely wrong.
&gt; https://pastebin.com/XhXL3c6r Oh, here's why: send(client_socket, response_data, sizeof(response_data), 0); Use strlen().
Oh of course, thank you so much!
You could do it like this: int v = 5; int *some_ptr = &amp;v; char *pptr = (char*) &amp;some_ptr; printf("0x%x%x%x%x%x%x%x%x\n", pptr, pptr + 1, pptr + 2, pptr + 3, pptr + 4, pptr + 5, pptr + 6, pptr + 7); If I ever saw somebody do this, I would immediately post it to /r/codegore
&gt;`ip` doesn't store anything. It stores the address of an integer.
Yeah, sizeof will report the size of the pointer, not the length of the string the pointer points to. Also be certain to never modify that string, it's allocated as a static string that's not to be messed with. If you want to change it, allocate differently. #include &lt;stdio.h&gt; int main() { char *crash = "This is just\na test."; char c[] = "This is just\na test."; printf("%s\n%s", c, crash); c[4] = '!'; printf("%s", c); crash[4] = '!'; /* This will cause a segmentation fault! */ printf("%s", crash); return 0; } I'm only saying this because another new C programmer recently tripped over that in here.
Yeah, as /u/TheGrandSchlonging says, sizeof will report the size of the pointer, not the length of the string the pointer points to. Also be certain to never modify that string, it's allocated as a static string that's not to be messed with. If you want to change it, allocate differently. #include &lt;stdio.h&gt; int main() { char *crash = "This is just\na test."; char c[] = "This is just\na test."; printf("%s\n%s", c, crash); c[4] = '!'; printf("%s", c); crash[4] = '!'; /* This will cause a segmentation fault! */ printf("%s", crash); return 0; } I'm only saying this because another new C programmer recently tripped over that in here.
&gt;`uintptr_t` would be even better but there is no length modifier for it `PRIuPTR`, `PRIxPTR` etc.
Needs fixing as well: if ((listen(server_socket, 2)) != -1 ) Another change is pretty anal for the current version of the program but may be useful later: Move the `close(server_socket);` after the `end:` label, called if server_socket isn't -1. 
Please be more specific, what do you want to do?
Start by writing out, in english, how you would solve this problem, step by step. Then start writing the code.
Easiest way to compare would be to measure the slope (rise over run) of the two vectors, and compare those I think. If not, use some algebra to figure out where they meet.
Wouldn't have been a problem if OP was checking the return value from `send()` like you're required to... which is another problem that needs to be fixed.
What do you think this is *supposed* to do? You're looping over 8 of something, but what do you think that is? I don't see 8 of anything in that program.
Pretty sure this is just an excerpt from the code that only contains the erroneous bit.
Well then they shouldn't give incomplete examples. Since OP is obviously a beginner at C code with some fundamentals that they don't understand yet, how are we supposed to know that the rest of the program is correct? In any case, OP already got the correct answer from someone else, but didn't understand it, so we need to find another way to get to the root of their lack of understanding.
Since a char is 1 byte and a pointer is 8 bytes it loops through each byte of the pointer to print the full address it points to. It works if you leave off the *.
&gt; I'm surprised Assembly isn't seen more frequently, since it would provide the greatest level of efficiency by nature. This is true for code that is aboslutely performance critical. In some cases, the programmer knows things that can't really be expressed in any programming language, and can write assembly code that performs better as a result. However, writing assembly code is, in general, harder than writing code in higher-level languages, even for programmers who are accustomed to it. In assembly you have to juggle a limited number of registers, and spill extra variables to memory. Figuring out the most efficient way to do that is burdensome for humans, but easy for compilers. In fact it's so easy that we no longer need to use the `register` keyword to assist the compiler in doing this job. As a result, it's "just as hard" to write a function whether it has 3 local variables or 30. Compilers can also easily see optimizations that humans may not be diligent enough to catch or willing to take the time to figure out, such as replacing `mul` and `div` with combinations of `mul`, `add`, and `shift`. (Just came up in [this thread](https://old.reddit.com/r/C_Programming/comments/9ol9su/execution_speed_optimization_of_atomic_functions/).) Languages higher than assembly also give you power constructs such as variables having "types". In C, you could change a definition from `short x` to `long x`, and when everything is recompiled all of the assignments, comparisons, etc., would have been changed in the resulting assembly code, across the entire program. Just that one line of source code could change hundreds or thousands of assembly instructions scattered throughout the program! Most of the time, we care about "programmer efficiency" more than we care about "execution efficiency". At the scale of comparing C versus assembly, modern systems are just too fast for that to matter very often.
Okay, well let's look at the syntax and try to make sense of it. WHen you're *declaring* a variable, the `*` adds a level of "pointer". So * `[unsigned char p](https://cdecl.org/?q=unsigned+char+p)` is an "unsigned char" * `[unsigned char * p](https://cdecl.org/?q=unsigned+char+*+p)` is a "pointer to unsigned char" * `[unsigned char ** p](https://cdecl.org/?q=unsigned+char+**+p)` is a "pointer to pointer to unsigned char" It means something different when you use it in a statement or expression. There, `*` means "remove a level of 'pointer'" and `&amp;` means "add a level of 'pointer'". So if we have `unsigned char * p`, then * `*p` will be "unsigned char" * `p` will be "pointer to unsigned char" (exactly what its type is) * `&amp;p` will be "pointer to pointer to unsigned char" Now, what happens when you mix pointers and integers? Suppose that you have `unsigned char * p`. * `p` will obviously just give you the value of `p`, which is a "pointer to unsigned char". * `p + n` will add the value of `n` (which is an "integer") to the value of `p` (which is a "pointer to unsigned char", so its value is a number which is a memory address). The result will be a slightly different memory address, and its type will still be a "pointer to unsigned char". * `*p` or `*(p)` would give us the value of whatever `p` is pointing to, which would be of type "unsigned char". * `*(p + n)` will give us the value of whatever `p + n` points to, which would still be of type "unsigned char". * So will `p[n]`. It means *exactly the same* as `*(p + n)`. That syntax exists because it's shorter and easier to read. So doing `p[n]` will *also* give us the value of whatever `p + n` points to, and it would *also* still be of type "unsigned char". So when you try to do `*p[n]`, what do we have? Well, we have `p[n]`, which gives us a value of type "unsigned char". Note that it's not a pointer. Then there's a `*` in front of it, which means "remove a level of 'pointer'". Well, there is no more "pointer" to remove. So doing that is a syntax error, and shouldn't even compile.
Eh, it's hard to tell from the details you've provided whether you're dealing with a basic problem in analytic geometry or a more general problem in linear algebra. There are some edge cases you'll need to consider even for two lines in ℝ^2, including vertical lines and coincident lines. 
&gt; If we needed more info, we'd ask for it. I *did* ask for it. &gt; You have no idea whether they inderstood it or not. We know OP didn't understand it because OP told us so, when they wrote &gt; Can someone explain why that doesn't work and what c-god is saying about it in the link? I am having trouble understanding what he's teaching.
So they either give it to you or not. Regardless, you don't need more for this specific issue. You're asking to look at more of their code for a problem they didn't ask you about and that may not exist. And it was dumb of me to say that last part, I will admit.
The memory containing the password should also be locked using `mlock()` or something similar, otherwise it could potentially get paged out to disk where it might not get overwritten for a long time.
Don’t; it’s UB.
If there's a format that will allow me to edit on the pixel level, that is the format I want lol. 
This looks promising!! Thanks! 
Given a video with n frames, I'd like to be able to treat a given frame n1 as a matrix of rgb values or, preferably, 3 matrices of unsigned chars, each holding an r, g, or b values that I can then edit, effectively applying a custom filter of my own creation to a video with highly parallelized code. 
You probably haven't used structs yet, maybe not even functions, if that's the case just try to split the problem into smaller parts and ignore the following advice. This is how I would *structure* my code: struct Point { int x, y; }; struct Vector { struct Point p1, p2; }; // A vector in y = mx+n notation struct Line { int m, n; }; Then implement a function to transform a vector into a line, another function to check if two lines are parallel, and another one to calculate the intersection between two lines: struct Line line_from_vector(struct Vector v); int lines_parallel(struct Line l1, struct Line l2); struct Point point_of_intersection(struct Line l1, struct Line l2);
Awesome dude! Imma look into it. 
Solve the linear equation system made up by the two lines. If it has one solution, that's your intersection point. If it has none or infinitely many, the lines are parallel.
`\r\n\r\n` would be correct as the header is terminated with two line breaks.
When you post code, indent it by 4 spaces (easy to do from a good editor before copy/paste) so it formats correctly; you won’t need to escape anything (e.g., `\\n`) that way. Anyway, if what you’re asking about is what I think it is, you’re running into a DRY problem; there are a bunch of different call sites to `funkcija`s, which gives you no single place to insert calls to `V1` or `V2`. There’s repetition in your `if` ranges and body statements where the functions are being called. E.g.: if(x&lt;9 &amp;&amp; a&gt;=5 &amp;&amp; y&gt;=7) { printf("\n"); printf("t1=%4.2lg\\n",funkcija1 (x,y,a,b,c,n)); } To factor these down into a single call site, look at the things that are different in the repeating sections; what I see is - range values (≤1 test on `a`, ≤2 tests each on `x` and `y`) - variable names (technically one character different, but may as well count it as a full string), and - function being called. If you pull these differences out into a data structure, (a.) you can add/remove test blocks trivially, and (b.) you have a single `funkcija` call site to do with as you please. First, kinds of tests that can be performed: typedef char test_fn(double a, double b); // Note: Use _Bool for C99, since it’s more precise. static char test_eq(double a, double b) {return a == b;} // or within some EPSILON, because floating-point static char test_ge(double a, double b) {return a &gt;= b;} //etc. for gt &gt;, le &lt;=, lt &lt; static char test_none(double a, double b) { (void)a; (void)b; return 1; } These are function stand-ins for the Boolean operators `==`, `&gt;=`, etc. (Note that `==` is nigh meaningless when working with floating-point; usually you want `fabs(a - b) &lt; EPSILON` for some reasonable `EPSILON` instead of just `a == b`. Floating-point numbers can gradually accumulate error as you apply operations to them, which means that something algebraically true isn’t necessarily program-true.) The last `test_` function can be used to “eliminate” one of the conditions if you don’t need it for a specific block. Now, data structures to help you apply these tests and do something with them: typedef double funkcija_fn(double, double, double, double, double, double); // which you should probably use for prototypes as well // One test that should be performed: struct test_action { test_fn *test; // Test function to use; one of the `test_`s preferably double arg; // Second argument to `test_` function }; // Represents one of the `if(…) {printf(…)}` blocks: struct action { // Variable name: const char *var; // Function to call if all tests succeed: funkcija_fn *funkcija; // Test actions: test_action test_a, test_x[2], test_y[2]; }; The differences in code can be reduced to an array this way; e.g., to encode the above `if`/`printf` block, you can do static const struct action ACTIONS[] = { { "t1", funkcija1, {test_ge, 5.0}, // test a &gt;= 5.0 { {test_lt, 9.0}, // test x &lt; 9.0 {test_none, 0.0} // (no other x test) }, { {test_ge, 7.0}, // test y &gt;= 7.0 {test_none, 0.0}, // (no other y test) } }, … }; You may want to make a macro to wrap up some of that initializer, but up to you what all you do there. Also, if you’re using C99 or better, it’s best to name the `struct` fields you’re initializing for your own sanity; e.g., for the field `var`, it’d be .var = "t1", Now you can set up the skeleton for this flesh to fill out: #define countof(array) (sizeof(array) / sizeof((array)[0])) … unsigned i; for(i = 0; i &lt; countof(ACTIONS); i++) { const struct action *act; act = ACTIONS + i; if(act-&gt;test_a.test(a, act-&gt;test_a.arg) &amp;&amp; act-&gt;test_x[0].test(x, act-&gt;test_x[0].arg) &amp;&amp; act-&gt;test_x[1].test(x, act-&gt;test_x[1].arg) &amp;&amp; act-&gt;test_y[0].test(y, act-&gt;test_y[0].arg) &amp;&amp; act-&gt;test_y[1].test(y, act-&gt;test_y[1].arg)) { // ↑ another DRY “opportunity” printf("\n%s=%4.2lg\n", act-&gt;var, act-&gt;funkcija(x, y, a, b, c, n)); break; } } if(i &gt;= countof(ACTIONS)) // I.e., no ACTION’s test matched funkcija4(x, y, a); // Why does funkcija4 take arguments, and why is it named like the others? It’s an error message. So the `if` inside the `for` captures all the other `if`/`else if` tests in the original code, and the `printf` captures all the `printf`s in the original code. Now, with the `funkcija` calls centered in a single place in that inner `if`, you can pull the call out and do roughly what you wrote: double v; v = act-&gt;funkcija(x, y, a, b, c, n); if(t2 &gt; v) V1(…); else V2(…); printf(…, v); Not sure if you’re supposed to print the *result* of `V1` or `V2`, but it might also manifest as something like v = act-&gt;funkcija(…) v = (v &lt; t2 ? V1(…) : V2(…)); printf(…, v); or, if `V1` and `V2` have the same prototypes, even v = (v &lt; t2 ? V1 : V2)(…); There are some other things I noticed. First, if you’re just going to overwrite an argument as soon as you enter a function, it shouldn’t be an argument, it should be a variable inside that function. Second, statements like `a=2, b=3, x=5` are legal C but (a.) likely to net you a warning or three, and (b.) usually not a good idea outside of macros; stick with `;` as a separator.
Oh, those aren't separate lines I quoted. They're consecutive, so there's already one CRLF at the end of Content-Length.
"being polite" .." is being gracious and humble" ... really that isn;t the generally agreed upon ethical understanding between sheeps like you? ?? then im confused... you just be defeated and attempting to fight back but have nothing left you can really say ... lol spoon fed... hmmm okay sure. interpret it that way... either way nothing wrong with being spoon fed answers... much easier then spending time figuring it out. its good to do both ...therefore ur insult is fking pathetic just like your existence.
Raw video formats are HUGE. I.e. 1920x1080px24bbp @30fps = 178Mb/sec What about GIF images ?
That's the most recent gcc, right? You can file a bug report about it. In the meantime, removing any optimizations (take out `-Og`) is usually your best bet at working around those unfortunate ICEs.
I have tried your third version myself on this PCIe linux driver. However, this modification crashes my system, it seems like (count-len) is still greater than len , therefore modulo operator is still needed.
I would look into why that's the case. From the uses in the file you linked, it doesn't look like count should be greater than len by more than 1. And surely you should never get to a point where count is larger than double of len, because that's twice as much data as can fit in the queue. So perhaps this is being used in ways you're not expecting, or perhaps there's a logic error somewhere. If you don't find any such problems, the version with a while loop should still work, and I'd expect it to still perform better than the modulo.
You won't be able to edit the frames of a compressed video file in situ. You'll need to break them out into individual frames, do your batch processing, then recompress the frames back into a video file. Ffmpeg/avcodec can help automate this.
compiler hates you using the same identifier for a struct tag as for a typedef to pointer to that struct
[Reproducible on godbolt](https://gcc.godbolt.org/z/z9GnvE)
Also one gotcha for OP: don't expect to compare two floating-point numbers for equality. Due to rounding errors, it's common for 2 numbers to compare false when they should compare true. Use a margin of error, like "if the slops are within 0.001%, assume they're parallel".
Ahh not really what I'm going for for the purposes of this project. 
 #include &lt;stdio.h&gt; int num1 = 0; int num2 = 0; int ans = 0; char plus[] = "+"; char minus[] = "-"; char op1[]; int gotostart=0; int main() { printf("enter operand:"); scanf("%d", &amp;num1); printf("enter operator:"); scanf("%s", op1); printf("enter operand:"); scanf("%d", &amp;num2); if (strcmp(plus, op1) == 0) { ans = num1 + num2; } if (strcmp(minus, op1) == 0) { ans = num1 - num2; } printf("%d %s %d = %d", num1, op1, num2, ans); return 0; }
All programs have an infinite loop that keeps them running. Or how do you think programs stay open while they dont have anything to do? Your program, like any other program under the sun needs an infinite loop. The infinite loop will ask for input, parse and do whatever you want until it receives an specific command like EXIT. &amp;#x200B; You should probably start by using fgets, and making a shell that takes 5 basic instructions. SUM, REST, DIV, MULT, EXIT. &amp;#x200B; If the user types SUM you run a nested infinite loop that will keep asking for the next number on an on until the user says something like STOP. When he says stop that nested loop stops running and returns control to the main infinite loop. &amp;#x200B; And that my son, is programming in a nutshell. &amp;#x200B;
Ah man, this has gone from sad to entertaining! Please, *do* go on - just give me moment to grab my popcorn...
Oh is it ? But I'm not pretty sure of myself how to use the fmod 
Check out the man pages for it: [https://linux.die.net/man/3/fmod](https://linux.die.net/man/3/fmod) &amp;#x200B; you would use it like ``` rem = fmod(a, b); ```
The modulus operator only works on integer types. If you need to use doubles for your areas, you can't use %. you'll have to use floor() to get the number of whole cans, and compute the remainder by subtracting off the cover area of the whole cans.
I can't seem to identify what to insert in the (a, b) part. Sorry if I am that dumb, it's just I've only started learning on programming about 1 months. :')
In the case of your original code, you would replace `can_paint1 = sumpaint % paint_cover;` with `can_paint1 = fmod(sumpaint, paint_cover);` 
Think of it this way: using *p gets the thing pointed to by p. Using p[0] also gets the thing pointed to by p. They are both a dereference operation. The array access notation p[n] is effectively just a short cut for adding an offset to p before dereferencing with the * operator.
Thanks a lot!
Do I need to include something in my identifiers ?
[ffmpeg is the true libav](https://www.ffmpeg.org/doxygen/trunk/index.html)
The build was successful , but didn't get to receive the correct answers for the 1L can paints. Here's my full code: ^(#include&lt;stdio.h&gt;) ^(#include&lt;math.h&gt;) &amp;#x200B; ^(int main()) ^({) ^(double f1, i1, f2, i2, w, l, area;) ^(double paint\_required;) ^(int wall;) ^(int counter=1;) ^(double sumpaint;) ^(double paint\_cover = 115;) ^(double can\_paint5;) ^(double sumarea;) ^(double can\_paint1;) ^(printf("Welcome to AA Painting Company !\\n");) ^(//number of walls//) ^(printf("Enter number of walls: ");) ^(scanf("%d", &amp;wall);) &amp;#x200B; ^(if (wall &lt;= 0)) ^({) ^(printf("Invalid number of walls !\\n");) ^(}) ^(//loop for the whole process//) ^(//looping//) ^(while(counter &lt;= wall)) ^({) ^(++counter;) &amp;#x200B; ^(//width and length//) ^(printf("Enter wall width (feet and inches, separated by a space): \\t ");) ^(scanf("%lf \\t", &amp;f1);) ^(scanf("%lf", &amp;i1);) &amp;#x200B; ^(if (f1 &lt;= 0)) ^({) ^(printf("Error!\\n");) ^(break;) ^(}) ^(if (i1 &lt;= 0)) ^({) ^(printf("Error!\\n");) ^(break;) ^(}) &amp;#x200B; ^(printf("Enter wall length (feet and inches, separated by a space): \\t ");) ^(scanf("%lf \\t", &amp;f2);) ^(scanf("%lf", &amp;i2);) &amp;#x200B; ^(if (f2 &lt;= 0)) ^({) ^(printf("Error!\\n");) ^(break;) ^(}) &amp;#x200B; ^(if (i2 &lt;= 0)) ^({) ^(printf("Error!\\n");) ^(break;) ^(}) &amp;#x200B; ^(//area//) ^(w = (float)i1 / 12;) ^(l = (float)i2 / 12;) ^(area = (float)((w + f1) \* (l + f2));) ^(printf("Area is %.2lf sq. ft.. \\n", area );) &amp;#x200B; ^(if (w &lt;= 0)) ^({) ^(printf("Error dimension!\\n");) ^(break;) ^(}) &amp;#x200B; ^(if (l &lt;= 0)) ^({) ^(printf("Error dimension!\\n");) ^(break;) ^(}) &amp;#x200B; ^(if (area &lt;=0)) ^({) ^(printf("Error dimension!\\n");) ^(break;) ^(}) &amp;#x200B; ^(//paint required//) ^(paint\_required = (float)area / 23;) ^(printf("Paint required is %.2lf L.\\n", paint\_required);) &amp;#x200B; ^(//total paint//) ^(sumpaint = (float)sumpaint + paint\_required;) &amp;#x200B; ^(//total area//) ^(sumarea = (float)sumarea + area;) &amp;#x200B; ^(//can paint//) ^(can\_paint5 = sumarea / paint\_cover;) ^(can\_paint1 = fmod(sumarea, paint\_cover);) ^(}) ^(printf("Total of area is %.3f \\n", sumarea);) &amp;#x200B; ^(//total paint//) ^(printf("Total paint required is %.2lf L. \\n", sumpaint);) &amp;#x200B; ^(//can paint needed//) ^(printf("Number of 5L paint can needed is %.0f .\\n", floor(can\_paint5));) ^(printf("Number of 1L paint can needed is %.0f .\\n", ceil(can\_paint1));) &amp;#x200B; ^(//labours 1h=28.75sq.ft.) &amp;#x200B; ^(return 0;) ^(})
Interestingly, if you make `reserved` static in main the error goes away. 
What result are you getting? Are you sure that your math is correct? I don't want to just do you homework for you.
what is the misbehave? also check this `scanf("%s30",str);` 
Can reproduce. I'm able to make the error disappear by removing any one element from the reserved array initializer list. Seems to happen with all optimization levels.
please justify your suggestion :)
Use integers, not floating-point. And please format your code correctly.
This scans only 30 characters 
you have str and randstr for 49 places, and the scanf for 30 chars, where do you chage the string size to 40? also have a for loop, then a while loop, and inside that another for loop, where is the program looping?
The notion of a random number generator being “too strong” intrigues me. Please elaborate. As for your question, just use `crypt(3)` or `crypt_r(3)` with SHA-512. It is far more portable than bcrypt. Use `mlock(2)` and `munlock(2)` to prevent the memory containing the plaintext password from being paged out and `explicit_bzero(3)` from libbsd to wipe it when you're done.
you're using sumarea but its not been given a value in the code you share... &amp;#x200B;
For loop
Bcrypt computations are a lot easier to speed up with special purpose hardware, making it less secure. Besides, Argon2 was designed specifically with password hashing in mind (see password hashing competition)
For loop 
you can do a `printf("size: %d\n", strlen(str))` before the first for loop to check for inconsitencies on str do a `printf("loop n: %d\n", loop)` inside the for loop to check if its ok
forks are confusing …
yes, that, and also the algo to see if he take the 5L can or the 1L can
`memset(str, '\0', sizeof(str))` will put all zeros on the string before you use it
Thanks
Just subtract them. `sum -= *max + *min;`
*min can be a negative number, then subtraction doesn't work. 
Why do you think it doesn't work?
I think the judges will give all positives scores
You're wrong on every count. It's just as strong as bcrypt, but (unlike bcrypt) supported by all modern Unices.
To me it looks like no reputable crypto expert cared to look at Argon2. The reference implementation is a mess. I would not recommend it until the algorithm got properly tested.
What? Just looking at the panel of the password hashing competition that selected Argon2, reveals several prominent cryptographers and practitioners. 
 for(N=N;N==0;N=N-x) This is saying that the loop will run while N is 0 (N==0). If N doesn't start at 0, the loop will never run. And the `a` is not initialised to anything. So the 2^nd loop is printing out the random contents of memory.
Hey, thanks for replying! I thought that the middle expression in a for loop was what would stop the loop. As in, when N reaches 0, the whole loop will stop. Which expression is it that does that? Also, i thought that me typing a[i] would cause it to print the first entry of the array a (a[0] ), then a[1].... and so forth. Since I said that i = 0 and keeps going up by one for every loop. What should I say if I want it to run like this? Sorry, I'm not arguing with you if I sound argumentative, I'm just really knew to this so I have alot of questions haha
Move the i=0 out of the first for loop. You constantly write to a\[0\]. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt; I thought that the middle expression in a for loop was what would stop the loop No. The middle expression is tested and, if it is true, the loop goes one more time. &gt; i thought that me typing a[i] would cause it to print the first entry of the array a (a[0] ), then a[1].... and so forth It does. But int a[50]; creates an array with undefined contents. The 2nd loop is correct for printing the 50 elements. The problem is that the 50 elements are nonsense. Fill the array with zeros at the beginning. The easiest way to do this is int a[50] = {0}; 
The middle expression is used to say if (N ==0) then do the for loop. You want if N&gt;0 or N&gt;-1 instead.
Please read up on password security before making such accusations (https://crackstation.net/hashing-security.htm for a start). SHA functions are not good for passwords because they are extremely fast and can be brute forced using rainbow tables or dictionary lookup. bcrypt, on the other hand, is a slow hashing function that cannot be brute forced within a reasonable time. This has nothing to do with the strength of the hashing functions themselves.
It seems that `tmp_string_for_extend` is used to store the pointer in `write_to` which is then `free()`, althrough I don't see the reason why not just to use `free(write_to)` instread. The reason to free it was probably so that you can chain multiple 'calls' to `Sasprintf` together with the same variable without using `free()` inbetween. `asprintf` is basically `sprintf` (put formatted string into a buffer), but allocates the buffer itself and puts it into the first parameter (`&amp;(write_to)`, since it should write to a variable so you can easily access it). The `__VA_ARGS__` expands to the additional arguments (`...`), complete with commas. Also the `{}` introduces a new scope so that it won't overwrite an `tmp_string_for_extend` from outside. Also notice that the return value of `asprintf` is ignored.
Also, N=0 is never reached. Example: `N x=N/2 N=N-x --- ------- -------- 10 5=10/2 5=10-5 5 2=5/2 3=5-2 3 1=3/2 2=3-1 2 1=2/2 1=2-1 1 0=1/2 1=1-0 1 0=1/2 1=1-0 ...` "When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded."
Thanks for the tip :)
If you wanna get out of a loop when a particular condition is reached( here N==0) use if(N==0) break; You wrote i=0 inside the for loop, it does go up by one when it reaches i++, but then goes back to zero since it enters the loop again. So use i=0 outside the loop and it’ll work.
What is the purpose of the "list"target in your makefile? Why type "make list" instead of "ls" ?
The reference implementation isn't a mess. It does some minor, irritating things with macros, but it's actually quite reasonable. I haven't taken a deep dive, but I've worked with it as a whole (enough to make [a PR](https://github.com/P-H-C/phc-winner-argon2/pull/259).
Just part of learning my way around make.
As others have pointed out, bcrypt is dated since it's not memory-hard. But if you insist, I've got a [complete implementation of bcrypt](https://github.com/skeeto/blowpipe) (in blowfish.c and [blowfish.h](https://github.com/skeeto/blowpipe/blob/master/blowfish.h)). It's validated against test vectors from OpenBSD (`make test`). If you want to encode the hashes like OpenBSD does, there's some additional code in [test.c](https://github.com/skeeto/blowpipe/blob/master/tests/tests.c).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [skeeto/blowpipe/.../**tests.c** (master → 1e5dff1)](https://github.com/skeeto/blowpipe/blob/1e5dff1adadb23123011ed8bccf132bad2a2f342/tests/tests.c) * [skeeto/blowpipe/.../**blowfish.h** (master → 1e5dff1)](https://github.com/skeeto/blowpipe/blob/1e5dff1adadb23123011ed8bccf132bad2a2f342/blowfish.h) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e80h13c.)
``` size_t GRID_SIZE; size_t GRID_WIDTH; size_t GRID_WIDTH_SQUARE; ``` Capitalized names are usually only used for constants and macros. Usually you want to have include guards in the header files. Also, `size_t` is not defined in the header file, which can cause errors when including it. (`#include &lt;stddef.h&gt;` would be good`). Not necessarily bad, but you don't have to declare a pass-by-value type as `const`. 
(C File I/O, Tutorialspoint)[https://www.tutorialspoint.com/cprogramming/c_file_io.htm]
Googling "c file i/o tutorial and samples" came up with a ton of stuff. Write some code to play around with the samples, work with some files out of your document or program files folders.
Still reproduces if you expand the typedef by hand and remove it. But I agree that's confusing.
Dude, you have no idea what you're talking about. Bcrypt password hashing is N rounds of Blowfish for a very large N. SHA512 password hashing is N rounds of SHA512 for a very large N. And no, you're not going to brute-force *salted* SHA512 with a rainbow table.
Oh, and that link you gave me contains the following line under “DO use”: &gt; Secure versions of crypt ($2y$, $5$, $6$) Guess what `$6$` is? Salted SHA512.
&gt; You mean #ifndef wrapper? Yes. That or `#pragma once`. You will get errors if you somehow include the file more than once without one of those. 
Seems to work fine for me? Are you using the old version of reddit?
Yes. I can't stand the bullshit redesign and many users in here haven't switched either.
Right below that is also says: &gt; DO NOT use: Fast cryptographic hash functions such as MD5, SHA1, SHA256, SHA512, RipeMD, WHIRLPOOL, SHA3, etc. `$6$` seems to be based on SHA512, but not actually SHA512, so can't really comment on that much. Also, bcrypt is way more portable than sha512 as per https://passlib.readthedocs.io/en/stable/modular_crypt_format.html#mcf-identifiers. So, again, please read up before offering others advice.
Won't using if statements be more efficient though? I only want the minimum confirmation that it is indeed a HTTP Request to index.html.
Won't using if statements be more efficient though? I only want the minimum confirmation that it is indeed a HTTP Request to index.html.
Yes. And surround the code with blank lines.
You need to parse the fields in the header to understand if it is valid. This is slightly complicated.
FYI `size_t` is made to represent the size of objects, i.e. what you'd get from `sizeof`. It's a bit strange to see it used the way you do -- I would probably use `int` instead (or maybe `char` if I was on a memory-pressured platform). You might want to do something like : typedef cell_t int; in your header file, and then _s/size_t/cell_t/g_.
Recursion is not the way to go here. It's fairly trivial to write a back tracking solver in a while loop.
Read the RFC for examples.
They still exist even though you apparently wish they don't ... Writing correct code is a pretty convincing reason
how ??
As a state machine?
I wouldn't call this an example of good code, I wrote it 6-7 years ago when I was first learning C, but here's a complete, non-recusrive solving algorithm in about 50 lines. https://github.com/rcr/sudoku/blob/master/sudokuSolver.c#L36
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rcr/sudoku/.../**sudokuSolver.c#L36** (master → e8ecaba)](https://github.com/rcr/sudoku/blob/e8ecaba9d9d645df82a097731ce4491fb7ece98d/sudokuSolver.c#L36) ---- 
Having worked on wget, and implemented HTTP twice now, please don't try to do it yourself. The spec is quite complex. Use a library to do that for you. This is especially true if you're dealing with HTTP/2 requests. As one of the authors and maintainers of libwget, the HTTP library powering Wget2 I am biased towards it. But you really should use any HTTP library to deal with parsing the request.
if you want to DIY take a look at [https://savannah.nongnu.org/projects/lwip/](https://savannah.nongnu.org/projects/lwip/) check for the HTTP part
&gt;About RNG being too strong, please see point no 2 here: [https://blog.ircmaxell.com/2012/12/seven-ways-to-screw-up-bcrypt.html](https://blog.ircmaxell.com/2012/12/seven-ways-to-screw-up-bcrypt.html) &gt; &gt; Isn't crypt(3) itself deprecated? [https://man.openbsd.org/crypt.3](https://man.openbsd.org/crypt.3) &gt; &gt;I would love a example of using all the steps carefully. Sure, knowing the functions is one thing, but given it is cryptography that we are talking about here, I might go wrong in using them. So I humbly request for a full example assuming a string name **'passwordgiven'** contains the plain text password entered by the user via HTML form (Don't worry about sanitization for abnormalities, assume that they are taken care of and as such this is a proper NULL-terminated string in C). And a string name **'queriedpass'** contains the salted hash already queried from Mysql DB. &amp;#x200B;
Indeed it is a good reason! But you can get the same result without these piece of shit macros by casting to `uintmax_t` and then using `%jx` to print. This is legal as the range of an `uintmax_t` is never smaller than the range of an `uintptr_t` by definition.
Well, I would still insist on using bcrypt for now at least (due to its proven track record, and lack of any solid proven attack against it). If properly implemented, it should do the job. So keeping with the original request, I would like a proper example, showing proper salt generation, hashing, comparing, memory overwriting and other steps if required. 
Should I use int unsigned int unsigned short uint16_t uint32_t instead of `size_t`?
In reality, some library implementations haven't gotten around to supporting `%jx` yet (even when the compiler part is up to date) , and some major compilers have a 64-bit `uintmax_t` while offering 128-bit extended integer types 
Thank you for the Makefile suggestions. Excellent.
You need to use `malloc` if you don't want to limit the size of an array to a constant (i.e. a dynamic resizable array). You could also set it to a large constant to avoid complexity (like 512 or something)
`size_t` is by definition unsigned. You just have to make a choice regarding how big numbers you want to be able to handle. 
&gt; some major compilers have a 64-bit uintmax_t while offering 128-bit extended integer types See also [N2303](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2303.pdf) for a discussion of this problem and ways out. TL;DR: once decided upon, what `uintmax_t` is cannot be changed without breaking the ABI. Thus it is a 64 bit type despite the compiler being able to work with 128 bit types just fine. To fix this, Gustedt wants to redefine `uintmax_t` to be a type large enough to hold values of any unsigned integer type specified in the standard.
On the notion of SHA-512: See this: [https://stackoverflow.com/questions/1561174/sha512-vs-blowfish-and-bcrypt](https://stackoverflow.com/questions/1561174/sha512-vs-blowfish-and-bcrypt)
Literally look up HTTP on Wikipedia, then implement it.
Excellent! Thank you.
I read the code and I could nit-pick but I think I'll just say it's pretty solid. I'm glad you see you using size_t from the start. That's a good habit for making portable code.
"I only want the minimum confirmation that it is indeed a HTTP Request to index.html" Handling a GET request for "/" or "/index.html" is less than a day's work, but that's assuming you're happy to false-negative "/////index.html", "/./index.html", "/index%2ehtml", "/index.html?butterfly", and on and on. 
Thank you!
When I first read C I thought I had understood pointers after reading a few pages of a what people call a crappy 1990s book on C (it was Turbo C by Herbert Schildt). It was until I started playing with them in my code that I faced real world situations and was put to the test. &amp;#x200B; This is the internet son, there are billions of resources, but if you dont actually code and play around with pointers to see what happens if you do this and that then you will never fully understand them, regardless of how much you read.
You're not actually calling your function, you need the parentheses. PrintVals();
You can post the question, I dont consider myself a pointer lord but I may be able to help.
I'm an idiot. Thanks.
By the way, that's also the source of the warning you're getting: warning c4511: function call missing argument list
embrace gdb. Give it a warm hug. The debugger is the tool that lets you single step along and see what is happening. Unless you are trapped on Windows. In which case ... get a login session on a Linux or UNIX server and code there. 
I find that when I cannot find a smoking gun it helps to start eliminating suspects. Once all the code that does not trigger the error has been eliminated the error must be in what remains. TL;DR start by commenting out lines and simplifying inputs. 
your `freeMAZE()` function doesn't free `m-&gt;matrix`
Valgrind is telling you the line number the leak occurred at. What line number is line 39 and 32? &amp;#x200B; Also, I don't see you actually calling freeMAZE on the maze you create in pullMAZE. In addition, you allocate m-&gt;matrix but never call free(m-&gt;matrix). You should have a one-to-one mapping of mallocs to frees.
tl;dr You are not freeing `m-&gt;matrix`. You have four `malloc`s in `newMAZE` and three `free`s in `freeMAZE`, counting the implicit `malloc` in `newCELL`. First off, please don't post text as image. Either use reddit's formatting and ident your code by four spaces such that it looks like this: int main(int argc, char **argv) { // Just an example! return EXIT_SUCCESS; } Or use a service like https://pastebin.com or https://paste.debian.net. If you're posting Valgrind output, which points out the line number where the memory was allocated, it's also helpful to post the entire code. Also, what does `newCell` do? Does it allocate memory? There's no way of knowing judging only by the snippets you posted. We can only assume it does judging by the subsequent `free` call. Please post full code next time. That being said: 1. Consider using `m != NULL`, instead of `m != 0`, as `NULL` is not guaranteed to be `0`, but the return value of `malloc` is guaranteed to be `NULL`. 2. Consider using `type *variable = malloc(sizeof(*variable) * count)` instead of `type *variable = malloc(sizeof(type) * count)`, this way if you change `type` your code is still correct - moreover, in the code you posted we have no way of knowing what `CELL` is preprocessed into. 3. You did not free `m-&gt;maze`, at least not explicitly in the code you posted.
I do see it, however instead of telling you outright I'll explain my thought process in how I found it. A basic rule of thumb is that every `malloc` should have a corresponding `free` call. So in this case, compare all the `malloc` calls in `newMAZE` and find their correspond `free` call in `freeMAZE`. A catch is here is `newCELL` - you have no `freeCELL` (I would recommend adding one personally, this might be what tripped you up) so in this case I would just consider `newCELL` to be another `malloc` call. That noted, including the `newCELL` call there are 4 `malloc` calls in `newMAZE` - ignore the loops and such. There are only 3 `free` calls in `freeMAZE`, hence the memory leak. So just match each `malloc` and `newCELL` call to the corresponding `free`, and whichever one doesn't have a match is the one being leaked. It's worth noting the above is just a role of thumb. You might still have memory leaks after fixing the above, and then you'll want to look into the logic to make sure your loops and such match.
Thank you; sorry for not following formatting rules.
You're going to have to either tie into xinput or Wayland, whatever your route. Likely xinput.
Every time you post code as an Image, Grace Hopper's ghost curses you with seven years of off by one errors.
Every time you post a screenshot of code, Grace Hopper's ghost curses you with 7 years of off by one errors.
Squiggly boys gets us all
This is a good explanation, but in my experience I've found that what people seem to mean when they say pointers are confusing is what happens when you actually start using them in function constructions or requiring pointers to pointers. My primary languages are R and Python, so I don't spend enough time in C to really have the "feel" for pointers, but they do get a bit messy once you realize things like arrays essentially being pointers and that you can't easily have a function that returns a data structure that wasn't initialized before you called the function. Unfortunately I don't have a ton of good advice since I'm still getting a handle on these things. But I did find Head First C and Kernighan and Ritchie useful when I was getting started.
your just not going to get it because you want to be correct and you want to stick up for yourself and you to indoctrinated to expand your mind to understand ... so im not going to go on. I dont really care anymore if you get it.
Could I get a reference for that? 
I found this article very instructive. Please check it out. [https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back](https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back)
Try [Blinky Pointer Fun](http://cslibrary.stanford.edu/104/).
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions. Also, please never ever post pictures of code.
Please do not post pictures of code!
I have tried your third version with increased value of 'len' of 30 and I also made some modification to the linux driver in order to avoid the circular queue premature overflow issue for large data batch size transfer. However, I am still stucked with the same speed performance and another crashed system. So, this concludes that I still have circular queue premature overflow issue AND could I say that the modulo operator is not causing the PCIe performance hit ? I have used systemtap [linetimes.stp](https://sourceware.org/systemtap/examples/profiling/linetimes.stp) script to measure timing overhead and found that both [push\_circ\_queue() and pop\_circ\_queue() functions](https://github.com/promach/riffa/blob/full_duplex/driver/linux/circ_queue.c#L88-L144) add a lot of timing overhead during actual code execution Could anyone advised in this case ?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [promach/riffa/.../**circ_queue.c#L88-L144** (full_duplex → 733e1a8)](https://github.com/promach/riffa/blob/733e1a82b0c16b7082f55c55b6ce1fc635c22b2e/driver/linux/circ_queue.c#L88-L144) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e81vwff.)
TIL - it's used all over the place though! Like this feels really idiomatic to me: typedef struct foo_s { ... } foo_t;
I would use either `int` or `unsigned`, as it's pretty much guaranteed to be the most efficient type for your machine. Remember that, e.g. on x86, if you have a type which is say 16 bits, the compiler has to insert some additional instructions to mask the bits as required (to properly handle overflow).
&gt; Won't using if statements be more efficient though? I think what you're not taking into consideration when you're saying this is that yes, maybe simple if statements are simpler on the happy path of your code, but a library will cover you for those cases where the request is not valid, malicious or both. A very important rule of development states that user input data should never be treated as safe, so always sanitize, validate and make sure it won't break your app before you use it. HTTP requests are user data so treat them accordingly.
I think people get confused because they don't understand what OP has explained very well: variables are stored in memory and contain what we call "values". Pointers are also stored in memory but they do not contain "values", but the memory addresses in which our variables are stored. People don't get that, and don't care to understand what * or &amp; mean, they just want to type a few things like maniacs until it works.
*sigh* It's about Good Manners buddy. I don't know why you can't see that having good manners will ultimately help in your interactions with people, while "being mean, inconsiderate (, and) intolerable" (in your words), will not. And I'm sorry but, there *is* a correct way to interact with people when you expect something in return. Acting "mean, inconsiderate intolerable" will not get you the net result you expect over your life. I do you hope you see that eventually. 
*sigh* It's about Good Manners buddy. I don't know why you can't see that having good manners will ultimately help in your interactions with people, while "being mean, inconsiderate (, and) intolerable" (in your words), will not. And I'm sorry but, there *is* a correct way to interact with people when you expect something in return. Acting "mean, inconsiderate intolerable" will not get you the net result you expect over your life. I do you hope you see that eventually. 
Start small. Get familiar with the debugger. Build small testable units. Add comments. Use sane variables initialize them. Test with known good data. Don't panic
Here's a couple videos: [Binky, the classic 3 minute silly video about pointers that's actually pretty good](https://www.youtube.com/watch?v=5VnDaHBi8dM) [20 minute talk from Harvard's CS50 on pointers](https://www.youtube.com/watch?v=XISnO2YhnsY)
You cant declare "char \*p" inside the if() and else() and then use it outside of there. &amp;#x200B; Why not split the print into two parts? &amp;#x200B; printf("%d is "), num; if(.......) prinft("even\\n"); &amp;#x200B; &amp;#x200B;
You can’t create the variable p in the code block of the if-statement and expect to use it outside that scope. p should be declared at the beginning of the function. 
yeah you need to declare char \*p before your if else blocks &amp;#x200B;
Be very wary of assigning strings in the manner of char *s = "String"; read up on strings in C there is very different behavior than what you might expect from another language that is more string friendly. The error you are seeing is due to declaring `char *p = ...` inside of an if/else For your case why not just print what you want inside the if/else?
Be very wary of assigning strings in the manner of char *s = "String"; Read up on strings in C there is very different behavior than what you might expect from another language that is more string friendly. The error you are seeing is due to declaring `char *p = ...` inside of an if/else For your case why not just print what you want inside the if/else?
`char * p = "even"` is not valid because you're declaring it inside of an if/else statement. You cannot declare a variable inside and then use it outside Here's the simplest way to modify `eop()`: void eop (int num) { printf("%d is ", num); if (num % 2 == 0) { printf("even\n"); } else { printf("odd\n"); } } That way you print your text first, then the result and newline character. If you really wanted to use `p` instead of `printf()`, you could do the following (You'll need to include `string.h`): void eop (int num) { char *p; if (num % 2 == 0) { strcpy(p, "even"); } else { strcpy(p, "odd"); } printf("%d is %s\n", num, p); } The first one is a much better choice though.
Why not just use bitwise operations if your plan is to manipulate individual bits?
You want to read about "variable scoping."
```1 | 0 == 1 0 | 0 == 0 1 | 1 == 1 0 &amp; 0 == 0 0 &amp; 1 == 0 1 &amp; 1 == 1 0 \^ 0 == 0 0 \^ 1 == 1 1 \^ 1 == 0 ``` if you apply these operation on numbers, a new number will be returned,, where each pai of bits in the numbers has gone through the operation: ``` int a = 2; // ..10 int b = 1; // ..01 int c = a | b; // ..11 aka decimal 3 itn d = a &amp; b; // ..00 aka 0 ```
Why would you use `strcpy`? void eop (int num) { char* p; if (num % 2 == 0) { p = "even"; } else { p = "odd"; } printf("%d is %s\n", num, p); } Is simpler, and closer to OP's code. I agree that the first one is a better choice, though.
I wouldn't, but figured since OP used a `char*` I'd explain both ways.
I didn't see it mentioned, but you can also omit the if/else statement entirely by using the conditional operator: (condition) ? (true) : (false); Your example would instead look like this: void eop(int num) { printf("%d is %s\n", num, (num % 2 == 0) ? "even" : " odd"); } Sorry if this is more confusing, I figure it may be useful given the context. 
wow thanks guys! i really wasn’t expecting this amount of feedback. sorry for such a trivial question - this is all so new to me Thanks again!
This is an incredibly straightforward explanation and has truly helped me to understand them a bit better! After reading this I went through and took a few practice questions and started running through them and have generally been getting better results. Thank you SO much for taking the time to comment, you have helped me out tremendously.
Thank you for the suggestion, I'll check them out.
So is it fair to say that "\*" suggests the name of the pointer and "&amp;" is how you access the pointer? Or am I way off base with that one?
I will, thank you
Oh, I should add that info. Thanks
You should be able to get rid of the statement `return 0;` also if the compiler is &gt;= C99 compliant...
I dunno, you're going to have to debug things yourself and figure out where the problem is. Now that I have a bit more context, I don't know why you're implementing a circular queue in the first place. [Linux already has macros for implementing circular buffers.](https://www.kernel.org/doc/Documentation/circular-buffers.txt)
[removed]
Is your data made off double-precision floating point numbers? If yes then you are lucky because that's basically the only type where such a thing as an unused value exists. Look up “NaN values.” NaN stands for “not a number” and represents the result of an illegal operation. The mantissa of a NaN value can be used to encode some extra data, such as what generated the NaN. In your case, you could encode “this is an actual NaN” and “this is a terminating NaN.” If you do so, make sure to set up the mantissa of NaN values you get correctly before writing them to your file.
Why do you both open the file with `fopen` and then with `open`? I don't quite understand what you try to do. Note that you need to also pass an opening mode to `open`, I think your call simply fails. Have you tried adding some error checking to see if it does?
Nope, `O_APPEND` is just a flag to specify that before every write, the file shall be wound to the end. You still need an opening mode such as `O_WRONLY`. If you want `open` to create the file if it doesn't exists, you also need to specify `O_CREAT`. All these errors could have been caught easily if you had just added some error handling, e.g. int fd = open(file_name, O_APPEND); if (fd == -1) { /* if open failed... */ perror(file_name); /* print error message */ exit(EXIT_FAILURE); } That said, please take the time and read the [man page](http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html) for `open` at least once. It's an elementary and quite important function that you should know in and out for programming on UNIX.
I didn't realize that multiple flags could be strung together with " | ". I just tried to have multiple flags separated with commas as arguments. Realized that when I followed your link, the in-terminal man page didn't have an example of that. It did say "or" them together which is counter intuitive to me. I would think that they should be connected with "and" statements. Seems to be working now, thanks for your help.
Each flag is a single bit in an integer. If you and then together you'd get 0, which kind of defeats the point.
ah, thanks.
Well it does say: &gt; The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. These request opening the file read-only, write-only, or read/write, respectively. &gt; &gt; In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags. You use a bitwise `or` because each flag is a bitmask with some bits set. You use `|` to get the bits set in all the flags you use. An `&amp;` would result in just the bits set in all flags which are typically none at all.
Thank you!
don't use integers, use the STDIN/STDOUT macros for readability.
I strongly recommend taking a look at how other shells implement I/O. It's a big hair ball of gross, and you're going to make all of the same mistakes they did at least 10 times (like they did) unless you start from known working approaches, if not code. Here's one to start with: [bash](http://savannah.gnu.org/git/?group=bash) 
First of all, thank you so much for the help. I looked into it already. My goal is actually to receive a 32-bit binary input and then turn into an integer and float. That's why I used scanf in there. Here is what the output I wish to achieve: Input: 11100000000000000000000000000000 Integer: -536870912 Float: -36893488147419103232.000000 &amp;#x200B;
It took me a while too. at the time it was like "it's easier this way" but then it becomes "what in the shit is 1? true?"
are you looking at this ? : char* to_hex(char hex[], const uint8_t bin[], size_t length) { int i; uint8_t *p0 = (uint8_t *)bin; //uint8_t *p0 = bin; char *p1 = hex; for (i=0;i&lt;length;i++) { snprintf(p1, 3, "%02x", *p0); p0 += 1; p1 += 2; } return hex; } that thing ?
No that works. unsigned char *tmparr = (unsigned char*)to_hex(phexbuf, alice_publickey, crypto_box_PUBLICKEYBYTES); unsigned char arr2[]=""; int n; char tmpnum[3]; tmpnum[2] = 0; for(n = 0; n &lt; crypto_box_PUBLICKEYBYTES; n += 2) { tmpnum[0] = tmparr[n*2+0]; tmpnum[1] = tmparr[n*2+1]; sscanf( tmpnum, "%02x", arr2 + n ); } printf("alice's public key in arr2: %s\n", to_hex(phexbuf, arr2, crypto_box_PUBLICKEYBYTES));
Before I start, you can read about the larger topic, [scoping] (https://en.wikipedia.org/wiki/Scope_\(computer_science\)) here. We need to talk about 2 different things you can do in c. int foo; This is a declaration. It is creating an int variable on the stack. int foo = 0; This is a definition (and declaration). It creates an int variable on the stack and assigns it a value. foo = 0; This is an assignment. It sets the value of foo. It does not create a new variable. If you put this statement in your code with our declaring or defining foo, you will get a compile error. So what's up with the code you're looking at? Well let's look at this simpler case: int foo = 0; // declaration 1 int some_function() { int foo = 0; // declaration 2 foo = 5; // assignment } This codes declares 2 different variables called foo. Declaration 1 is in global scope. It can be accessed from anywhere. (That's not really true, but let's just hand wave the issue of translation units.) On the other hand Declaration 2 is in a local scope. It is scoped and belongs to some_function. It can only be referred to in some_function, and only after it has been declared. It does not affect the variable created in declaration 1. Because C is lexically scoped, the assignment will only set the value of the variable made in declaration 2. When some_function terminates, the foo of declaration 1 will be unchanged. On the other hand, this code: int foo = 0; // declaration 1 int some_function() { foo = foo + 1; // assignment } Will leave the global foo with a new value every time some_function runs.
I did the same a few years ago. My code for io redirection is [here](https://github.com/lollek/lsh/blob/master/src/io.c) if you are interested. Check the readme at the top of the repository to see the syntax
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lollek/lsh/.../**io.c** (master → 4a441b5)](https://github.com/lollek/lsh/blob/4a441b56d2e06a9645ea8995a9304d9046878d99/src/io.c) ---- 
You mean STDOUT_FILENO I think.
sed s/Visual Studio/Vim or Emacs/
Another way of looking at this is that the compiler keeps a stack (like floors of a building) of variable names it has seen declared alongside where that object/data currently lives in memory, and every time it sees a "{", a new frame gets pushed on top, so you can reuse a variable name for a totally different object. Every time the compiler sees "}" the stack gets popped. When it sees a "naked" variable (i.e. not a declaration), it goes down the stack until it finds out the name and what the address is, and then stops without even considering whether something with the "same name" happens to be somewhere further down. Anything named at the "zeroth" frame — ground floor if you will — is called "global"; if it's not there, it's as if the compiler has searched the entire globe and not been able to find it. (A good C compiler, of course, is doing its own optimization tricks behind the scenes. In a complex enough program something like your global *j* might be in RAM at one point and refer to data in a register at another in the compiled version of the code. But the compiler has got to know where stuff is, has been, or might need to be copied back to before optimizing, and it can't start to do that without being able to remember what "j" is referring to in the first place.)
I'd just go with the IEEE754 NaNs. There's no portable sentinel for a double -- the closest thing to one, assuming you're not doing anything too mathematically involved, might be a negative zero, which exists on IEEE754 systems and many non-IEEE754 systems, but then you're going to need C99 features such as signbit() for portable sentinel checking. 
Can't be a C example. `delete` is C++.
I not have the book, but it can be possible to set pointer to a struct. In that struct maybe you have some data as for example an array of data. The same struct have void \* function pointer, SetContenteToGarbage(), so the last function knows the struct data and can operate over that data.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/embedded] [How to study K&amp;R in 2018?](https://www.reddit.com/r/embedded/comments/9pt6ol/how_to_study_kr_in_2018/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
No offence, but this sounds like a total waste of time. Instead of focusing on tooling, I would recommend focusing on the language and the algorithms for the problems (most of which are topnotch). Tooling et al is always streamlined for the job. Even if you want to learn using make files and mock tests, I would suggest doing that for a hobby project instead of getting sidelined by them while doing K&amp;R.
Do a project in C, study existing code. You won't become a better programmer by just reading the manual. e.g. learning English doesn't mean you can write a book. 
&gt; C++ and C# falls under the "C Programming" category If that were true, it shows how clueless redditors are--that they think that C# is the same as C because the only resemblance is it has the letter C in its name. How morbidly stupid can you get?! &gt;Visual Studio is mostly used across all devices, even Linux. Talk about morbidly stupid thoughts. That one takes the cake!
I didn't really understand pointers for an embarrassingly long time. It seems like many professional C programmers don't fully understand them. My problems were that I came from a higher level language and most discussions of pointers give them fancy meaning. Later, when I spent some time working with assembly code it started to make much more sense. Assembly only has one type, integers. Numbers can hold a memory location, numbers can be mapped to letters with a lookup table like ASCII. It is always just about integers though. C types basically give you syntactic sugar around these fundamental assembly types. A C array is a pointer to a memory location. The compiler also typically knows the type of the array member, the size of this member and the number of members, none of this information is available at run time. This allows the compiler to jump to specific members and catch overflows. uint16_t a[10]; // 16 bits * ten elements = 20 bytes of memory a; // pointer to array a, lets call it memory location 0x80 a[0]; // Data at memory 0x80 a[1]; // Data at memory 0x80+sizeof(a member) = data at memory 0x82 a[9]; // Data at memory 0x92 (0x80+9*2) a[10]; // Compiler error/warning, the compiler knows there are only ten elements uint16_t* p = a; // == memory location 0x80 *p; // Data at memory location 0x80 == a[0] p++; // p=0x82 == 0x80 + sizeof(pointed to type) *p; // Data at memory location 0x82 == a[1] p++; // p=0x84 p+=8; // p=0x94, note we have overflowed // The pointer has no concept of number of elements *p; // Data at memory location 0x94, whatever that happens to be There are some oddities and silliness but that is the basics. To me, this concept of everything being a number/integer flows through C. Strings are numbers which hopefully map to characters, arranged sequentially in memory, with a zero entry to know when to stop. Variable length arrays, particularly arrays of structs, are often done the same way. Structs btw are nicely named fixed memory offsets. Rereading this, please don't take my flippancy about sugar to mean that it isn't important. Memory issues are a huge source of bugs in C, and that is with the compiler doing its very best to help you keep things under control. The compiler is a huge help in identifying and avoiding bugs, no matter how tempting a cast (void*) might be.
"Visual Studio Code" runs on Linux. It's a completely independent program with a frustratingly overlapping name.
I think it's a great idea, but I would not use KNR C, it's an old and ugly style with none of the modern libraries available to you. Check out a book like [http://www.knking.com/books/c2](http://www.knking.com/books/c2/)/
I don't think you can go wrong with these first three steps: 1. *C Programming: A Modern Approach*, 2nd Edition, by K. N. King and *C Primer Plus*, 6th Edition, by Stephen Prata. These two books show how to use strncpy() and strncat() properly, which is a decent "security consciousness" litmus test in a world where C beginner books fail to describe the integer promotions and the usual arithmetic conversions properly. Take *Programming in C*, 4th Edition, by Stephen Kochan, for instance: If I look up "strncpy()" in the index under 'S', I find nothing. That's because I'm supposed to be looking up "char *strncpy(s1, s2, n) function" under 'C' -- the most tone-deaf C index for a beginner I've ever seen. The description of strncpy() occurs in an appendix as follows: "Copies *s2* to *s1* until either the null character is reached or *n* characters have been copied, whichever occurs first. Returns *s1*." Yet there are 10 pages on Objective-C, C++, and C#. By contrast, the other two books work strncpy() into the main text and show how to use it properly, ensuring there's a terminating NUL, etc. 2. K&amp;R2. 3. *C Interfaces and Implementations* by David Hanson. Avoid YouTube, MOOCs, Web tutez, etc. Those are fine for something like Python, but you need to learn C properly. 
You don't need a Makefile. If you have a file 'foo.c', you can simply type make foo I wouldn't worry too much about the tooling. It's all different and will depend on the project. You might find yourself clicking new project in visual studio and hitting F5, could be Makefiles, could be anything. 
Unless you have to program in straight C like half of my company needs to. Then KNR is a great start.
1. Am I right about crypt(3) being depreciated? 2. Please elaborate how he is wrong (I expected you to say so without me asking) 3. yes, I'm using so. 4. First I'm not sure, whether to use the BSD implementation or the libcrypt one (if there is any difference). Can anyone point me to where libcrypt examples are located? I went through its documentation, but it seems I missed out on any examples. &amp;#x200B;
If it makes you feel better, I'm an embedded engineer and I'm basically on stack overflow every day.
Like I said, bcrypt is not *memory-hard*. It requires very little memory and it's [easy to parallelize](http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html) on GPUs or ASICs. Modern password hashing algorithms intentionally have significant memory requirements, which makes them very expensive to parallelize.
What is a makefile
&gt; I'm planning to treat each exercise as a project with its own Makefile and test suite. What do you think? I think that might be overkill. Most of the solutions to each problem comfortably fit in one or two source files. Probably doesn't hurt to do it a few times just to learn how to write a Makefile. &gt; What would be the most pedantic and conservative gcc flags? Is `-Wall` enough? -O2 -Wall -Wextra -Werror -Wpedantic -std=c11 And don't forget to use the sanitizers when debugging. &gt; I'm thinking about using cmocka as test suite since it seems it also could be used in embedded. What do you think? Other better alternatives? I'm not familiar with cmocka, but if you plan on doing a lot of embedded work, it looks like it might be worth it to learn cmocka. I usually use glib for bigger projects and asserts for simpler projects.
&gt; I would not use KNR C, it's an old and ugly style with none of the modern libraries OP is using the second edition of the book which covers ANSI C89, not the first edition. C99 and C11 did _not_ deviate significantly from C89. And many of the new libraries added in C99 and C11 are not something you would use in day to day programming.
I think this is a good idea. Find your style. At some point, about 4 months or so, I realized that my style was no longer changing. When you find your style, you will be able to go back to code you wrote a month ago, a year ago, and understand what the code does. Learn to write comments that explain what your code does. Learn to write unit tests to test your code. I often write a main() program that tests and exercises the target code. I use #ifdef UNIT_TEST and gcc -DUNIT_TEST to activate it. I compile a separate program that runs the tests.
I think your argument makes a lot of assumptions about OP's end game, learning style, and current skill level.
Thanks for sharing your insights. Yes, I've learned and forced myself to use a non-IDE approach [on recent months](https://www.reddit.com/r/vim/comments/97v0ix/how_do_people_use_vim_which_does_not_have_ide/). I also use vim with YCM plugin. I still don't know things like ctags, efficient debugging with gdb, autotools and make, cmake and lots of other things so I should also add them to the list sometime :) About Grenning's book, yes it was already on my todo list. There is also [this blog](https://mcuoneclipse.com/2018/08/26/tutorial-%CE%BCcunit-a-unit-test-framework-for-microcontrollers/), discussing other options ;D
The Realtek8723 drivers in the kernel are really modular and is well designed. I'll post the link when I'm not on mobile
rtl8xxxu
I also thought that I should not focus too much on tools and testing everything. Regarding language and algorithms, I already know \*some\* C which I guess is a dangerous level of \*knowing\*, every time I try to learn it, books/blogs/moocs seem to miss out on the more difficult and advanced things like calling an external function from a portion of memory, \*modern\* ways of handling strings, unix SIGNALs, thread safety, how really printf works and how you can stream it to a UART instead of system terminal, circular buffers, linker scripts elf data sections. I thought having those tools may make the process less tiresome.
I think you got the wrong end of the stick. OP is still in university and wants to get into embedded eventually. Given his specific goals of completing K&amp;R, I was simply pointing out that spending all that energy into creating makefiles and setting up mock tests is simply going to divert his attention from actually finishing the book. Tooling, testing, and software engineering practices are things that are best (and usually only) learnt on the job. That is my point. If he wants to finish K&amp;R, he would do best focusing on the content and solving the problems instead of bothering with these ancillary matters. If I recall correctly, the book itself mentions that it deliberately avoids all setups issues precisely because they vary tremendously. My suggestion was that if his secondary intent is to learn about tooling, he would do best by doing it on a small hobby project of his own where it would make a lot more sense (as well as provide a better platform for working with tooling) rather than by doing it specifically on a book about the C language.
This was actually good to know! I didn't know that you could simply call \`make\` on a source file without a makefile present in directory. Thanks :)
&gt; Interesting switches for compiler. I have to search them. As you know `-Wall` enables all warnings. However "all" isn't actually "all", so `-Wextra` is needed in addition to enable all warnings. `-Werror` turns warnings into build errors. Basically, forces you to stop and fix things if you have the discipline to leave the flag enabled. `-Wpedantic` requires fairly strict standards compliance and disables extensions. `-std=c11` tells gcc to use the C11 standard (this works with `-Wpedantic`) otherwise gcc will default to some version of the GNU extensions. &gt; What is the reason for optimization though... Its kind of an old habit of mine, I generally also use fortify source which require optimizations. Plus at level 2 they don't really hurt you (until you try to profile or debug).
A number will be entered on the keyboard and the C program will be written to calculate the G(y) function.
Post what you've got and you might get some help, this is obviously homework so nobody is gonna just give you a working program. What seems to be the issue?
Sir, I just started learning about the C program and I couldn't get back to it. `#include &lt;stdio.h&gt;` `#include &lt;stdlib.h&gt;` `int main(void) {` `int y;` `double large,medium,small;` `printf("Enter a number : ");` `scanf("%d", &amp;y);` `if(y&gt;10)` `large = (y*y*y+1)^1/2;` `printf("The number you enter is greater than 10, and the calculated function : %lf\n" , large);` `...` `system("PAUSE");` `return 0;` `}` &amp;#x200B;
Not looking too bad, you’ve even got an if statement. You might need to look at ‘else’ as well to get the rest of the g(y) options. Also, don’t assume everyone is male! 
my problem is : when the number entered is greater than 10, he takes his cube and adds 1, but does not take the square root.
I think you were misunderstood. You said it's better to focus on book itself not tools and learn tools on a hobby project (you didn't mean mocking is a hobby/not-serious thing). Thanks for your advice :D 
&gt; You won't become a better programmer by just reading the manual. He did not say just reading. He said he wanted to do the exercises. 
 Where am I wrong? #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define e 2,718 int main(void) { int y; double large,medium,small; printf("Enter a number : "); scanf("%d", &amp;y); if(y&gt;10) { large = sqrt((y*y*y+1)^1/2); printf("%lf\n" ,large); } else if(y&lt;=10 &amp;&amp; y&gt;=0) { medium = ((e,y)-10); printf("%lf\n" ,medium); } else { small = (y+(y+15)); printf("%lf\n" ,small); } system("PAUSE"); return 0; } &amp;#x200B;
i updated and still getting the error
[https://i.hizliresim.com/3zyyRO.png](https://i.hizliresim.com/3zyyRO.png)
&gt;[https://i.hizliresim.com/9Nkk9Q.png](https://i.hizliresim.com/9Nkk9Q.png)
What's the error? I'm testing with 11 and 15 as inputs and getting the correct answer according to my calculator, once I change the line to large = sqrt(y*y*y+1) 
i updated and still getting the error r/https://i.hizliresim.com/9Nkk9Q.png
I understand that, point is that there are some great examples of C coding out there that will teach design and architecture of C applications better than the manual will. e.g. the Linux Kernel has a bit of everything, and it's very accessible. I studied engineering, and did all the exercise from my engineering textbooks, but I didn't really learn how to be an engineer until I worked on real projects.
&gt;What's the error? I'm testing with 11 and 15 as inputs and getting the correct answer according to my calculator, once I change the line to &gt; &gt;large = sqrt(y\*y\*y+1) I shared the screenshot, I think the pow command is wrong
Me too. Nonshame in having a reference near by.
The image with the error in it is a broken link.
&gt;Learn to write comments that explain what your code does. This can not be emphasized enough. I typically write a complete description of the problem to be solved, and how I'm going to solve it before I write single line of code. It helps *immensely* when revisiting code years later.
okay, I'm sharing the commands. `#include &lt;stdio.h&gt;` `#include &lt;stdlib.h&gt;` `#include &lt;math.h&gt;` `#define e 2,718` &amp;#x200B; `int main(void) {` `int y;` `double large,medium,small;` `printf("Enter a number : ");` `scanf("%d", &amp;y);` `if(y&gt;10)` `{ large = sqrt(y*y*y+1);` `printf("%lf\n" ,large);` `}` `else if(y&lt;=10 &amp;&amp; y&gt;=0)` `{ medium = ((e^y)-10);` `printf("%lf\n" ,medium);` `}` `else` `{ small = (y+(y+15));` `printf("%lf\n" ,small);` `}` `system("PAUSE");` `return 0;` `}` &amp;#x200B; for example, when we enter the keyboard -10 as output -2 number, but I get the output -5. &amp;#x200B;
Not the op, but about the e constant. Should that have a decimal point, or is a comma permitted according to locale?
Ok I had a better look here and you've got a lot going wrong here. You aren't using the pow() function, you've just wrapped two numbers in parenthesis in your second if statement. You've also tried to declare e as a variable using a #define statement, when it should just be a constant, and you've used a comma instead of a decimal which I gather is probably how they do it in your country but isn't how it works in C. If you fix those things you'll get in the right direction I think.
I skipped over that part and went right into the function, but yes that should have a decimal point, and it should be declared using a const var not a #define macro, I pointed those things out to him in another comment, hopefully that will get him on the right track.
Oh yeah i overlooked it. 10&gt;=y&gt;=0 how to command here ?
Compare this to what you've got int main(void) { double e = 2.718; double y, answer; printf("Enter a number : "); scanf("%lf", &amp;y); if(y&gt;10) { answer = sqrt(y*y*y+1); } else if(y&lt;=10 &amp;&amp; y&gt;=0) { answer = pow(e,y) - 10; } else { answer = (y/(y+15)); } printf("%f\n" ,answer); return 0; }
there's so much more to learn. thanks for your support 
Good luck! In the future you'll get a lot more help a lot faster if you start by posting your code so far, even if you think it's not even close to what you need. People like to see that you've tried, and what you've tried, otherwise it can be hard and frustrating to give help. C is a lot of fun though.
An exercise in frustration
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [BoschSensortec/BMP280_driver/.../**bmp280.c#L604** (master → d1936f9)](https://github.com/BoschSensortec/BMP280_driver/blob/d1936f9f04f851403f616574ad3493ffd00d16fb/bmp280.c#L604) ---- 
How to set up array and ints for it, been trying to do it for hours. (O\_O)
Right now you’re just asking people to do your work for you. You need to ask specific questions and show that you have put in effort.
\#include &lt;stdio.h&gt; &amp;#x200B; int main() { int Trump\[5\]; int Obama\[5\]; int numState; numState = 1; int state; int i = 0; int x = 0; int sumTrump = 0; int sumObama = 0; int size; size = 50; &amp;#x200B; printf("Election Program\\n\\n"); &amp;#x200B; for (state = 1; state &lt; 5; state++) //state = 0 and state 1 will be called state 0, state = 1 and state 1 will be called state 1 { for (i = 0; i &lt; 1; i++) { printf\_s("Enter votes for Trump from state %d: \\n", numState); scanf\_s("%d", &amp;Trump\[i\]); } for (x = 0; x &lt; 1; x++) { printf\_s("Enter votes for Obama from state %d: \\n", numState++); scanf\_s("%d", &amp;Obama\[x\]); } &amp;#x200B; for (i = 0; i &lt; 1; i++) { sumTrump = sumTrump + Trump\[i\]; printf("Trump %d \\n", sumTrump); } for (x = 0; x &lt; 1; x++) { sumObama = sumObama + Obama\[x\]; printf("Obama %d \\n", sumObama); } if (Trump\[0\] == Obama\[0\]) { printf("Equal in state: %d\\n\\n", state); &amp;#x200B; } &amp;#x200B; &amp;#x200B; } &amp;#x200B; &amp;#x200B; printf("Trump Total Votes: %d\\nObama Total Votes: %d\\n\\n", sumTrump, sumObama); &amp;#x200B; } &amp;#x200B;
&gt; anyone know why it's 1-indexed here? &gt; https://github.com/BoschSensortec/BMP280_driver/blob/master/bmp280.c#L604 interleave_data() is called from bmp280_set_regs(). For a burst write, the buffer needs address-data pairs, except for the first pair, which needs only the data because the first register address is written to more explicitly: temp_buff[0] = reg_data[0]; [...] rslt = dev-&gt;write(dev-&gt;dev_id, reg_addr[0], temp_buff, temp_len); 
I think I get it. I can only change the global variable from a function if there's no local one set yet correct? Thanks for the explanation! 
Learn to write tests from the start. Every "source/foo/bar/component.c" Should have a "test/foo/bar/component.c" On top of the obvious benefits of testing your code, no matter how trivial the test cases are, this alone will give you immense insight into modular design when you start to realize you can't write tests for some component because it's too tightly coupled with some other component or state. I personally with id learned this sooner.
Way to fucking nail it in with the visuals, and metaphores. Excellently explained! 
&gt; all the exercise from my engineering textbooks, but I didn't really learn how to be an engineer until I worked on real projects. But in their defense, it's easier to grasp concepts, and understand logic once you know WHY things are the way they are. Had you not read your engineering textbooks, I think it's safe to say you would've had a hard time understanding WHAT you were doing don't you think?
Global j and func3's j are two completely separate variables that happen to have the same name. The topic is about which one you get if you say j in various contexts.
&gt; large = (y*y*y+1)^1/2; C doesn't have ^ as an exponentiation operator, but even if it did, this wouldn't work, because 1/2 gets truncated to 0 in integer arithmetic. The statement will still compile, but ^ is the xor operator, so you're xor'ing with 0, which does nothing to the original value. The problems with your code have been fixed elsewhere in this thread, though to calculate e^x you don't need to define your own e and use pow(e, x). Just use exp(x).
Well I wasn't sure what the difference was between setting a variable globally within a function vs locally, but I was already helped! Thanks! 
`int foo;` is a definition (and a declaration).
You are correct, I was using *definition* where I should of used *initialization*. Now that you mention it, K&amp;R usually uses the word definition in relation to pre-processor macros and function definitions anyway. Your comment made me want to look it up before I responded.
https://github.com/torvalds/linux/tree/master/drivers/net/wireless/realtek/rtlwifi Sorry for the wait. Hope this helps. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [torvalds/linux/.../**rtlwifi** (master → bab5c80)](https://github.com/torvalds/linux/tree/bab5c80b211035739997ebd361a679fa85b39465/drivers/net/wireless/realtek/rtlwifi) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e8582jh.)
your do/while loop has nothing in it, and your scanf happens before &amp; outside the loop. so all this does is lock you program unless your first entry was *
Isn't the if missing braces?
Hi, can you also point me into a simple yet detailed explanation of 'memory-hard' algorithms. And who is this Tony Arcieri whose blog post you have linked. 
Interesting ! To be honest, I'm still a bit overwhelm by linux driver complexity, but I'll make sure to check it out. Thank you ! 
As you explain it, you make a fair point, but to be fair you did not hedge, not offer a word of description, when you stated that the OPs efforts are a "total waste of time". Given the later, more nuanced, response to my post, I can see the merits of a focus on K&amp;R. And yet, I protest, there is a difference between the reader and the author, and just because the author skips set up I don't see why the reader should. They have different needs and constraints, and in fact the reader cannot skip set up, even if an IDE will present a narrative pretending to do so. You are advocating for abstractions when the OP was advocating for deep understanding. I get your point, but I think you ignored his. Respectfully Yours
Thank-you very much for your thorough answer! This was very helpful.
By asking this question here, you will probably get answers that slant more to the C-side of the spectrum. However, personally, I would not recommend you to use C for this project, but rather recommend you to use Rust. Many of the abstractions that you take for granted when writing in a language like Python, like object orientation, closures, first-class functions, sum types, parametric polymorphism, generic container structures and destructuring/pattern matching are things that do not natively exist in C. Some of these features can be _emulated_ in C, but you will not be able to use them without resorting to writing a lot of boilerplate, ceremony, non-idiomatic and type-unsafe code. The only way to use those features safely, is from a preprocessor (or a fullblown language...) that compiles to C. Rust, on the other hand, has these abstractions built-in, and its compiler enforces you to write disciplined code (rather than you yourself having to make sure you keep up your discipline to never leak memory, file handles, access an uninitialized or wild pointer, etc.) 'I want to do a non-trivial project to learn language X' is always a good reason to try to do something in a language. But if your goal is to write a serious cross-compiler or re-compiler, I would strongly advise you to use a language that has more abstractions built-in. On top of that, Rust has built-in support for testing, writing and generating documentation (and even doctests!), and comes with a package manager. C is still a great and very relevant language, in its role as portable Assembly. It still is the 'quantum foam' that keeps all of our computers together. But projects like this really benefit from being able to use more abstractions.
Thank you very much for such a great answer. I haven't looked into Rust other than knowing it was a buzzword of sorts. Now I have a reason, a pointer, to go look at it so thanks again!
No problem, and good luck! :-)
Personally I would use a higher level language like python for something like this. Would be so much easier to define and implement transformations. You would be able to see results faster and there doesn't seem to be any compelling reason to choose C for this task. 
1. No, `crypt(3)` is not deprecated. OpenBSD has a newer API that they'd rather you used, but other OSes don't, and `crypt(3)` is in POSIX anyway. 2. He suffers from the same misconception as the author(s) of Linux's in-kernel PRNG, despite *decades* of experts telling them they are wrong. You cannot reliably estimate the amount of entropy available in a system, trying to do so is foolish, and you should instead use algorithms like Fortuna that are resistant to guessing and / or force-feeding. The only truth in what he's saying is that if you read from `/dev/random` on Linux, it will eventually block; that doesn't mean the data is “too strong” for your use, only that the PRNG you're using “ran out of entropy”, for some completely meaningless definition of that concept. Other operating systems do not have this problem, and on FreeBSD, for instance, `/dev/urandom` is a symlink to `/dev/random`. 3. Then you probably shouldn't. 4. The BSD or libcrypt what? Examples of what? Have you even tried *anything*?
Compilers are quite heavy on the use of data structures. This makes C a difficult fit for a compiler. But for decades, C was the most common choice for compiler writing, because of its portability. I'd suggest a language with better built-in (and library) support for advanced data structures. (Just as an example, the GCC team recently switched away from C)
I also agree. I may make C the intermediate output language, while having the actual recompiler run in a much higher language -- something able to find large patterns and structures without so much grunge work first. &amp;#x200B; Speed is likely the most useless thing to have in this case -- it's run once on a target. If it takes 3 hours , or 3 days, you're still fine.
Really? where? in Xcode STDIN/STDOUT/STDERR are all defined and accessible without including any special header.
Yes, I have gone through the libcrypt documentation for example ([https://www.gnupg.org/documentation/manuals/gcrypt/](https://www.gnupg.org/documentation/manuals/gcrypt/)). 1. [https://www.gnupg.org/documentation/manuals/gcrypt/Available-hash-algorithms.html#Available-hash-algorithms](https://www.gnupg.org/documentation/manuals/gcrypt/Available-hash-algorithms.html#Available-hash-algorithms) on this page it doesn't list bcrypt. Am I looking in the wrong place? 2. Alternatively on: [https://man.openbsd.org/crypt\_checkpass.3](https://man.openbsd.org/crypt_checkpass.3) , I do not understand the function: int crypt_newhash(const char *password, const char *pref, char *hash, size_t hashsize); My assumptions: - *password argument is the plain text password used to generate corresponding hash. - *pref argument identifies the hashing algo and parameter. a) if using bcrypt, and round 10, do I need to first declare "const char *somestrname = "bcrypt", 10 " (is the correct syntax?) and then use it? b) what about other hashing algos available for use with it (pref argument) i.e., where can I find them? c) I do not understand the mention of "the special value ‘a’" - *hash is the string where the generated hash is stored - hashsize is the most confusing one, I do not understand what it means by "available space" and "PASSWORD_LEN" regarding the headers: I'm already using "#define _POSIX_C_SOURCE 200809L" as I have to use some other POSIX functions, as well as -std=c11, so its okay? 
`stdin`, `stdout`, and `stderr` are of type `FILE *`. They point to the `FILE` structures for standard input, output, and error as needed for stdio. `STDIN_FILENO`, `STDOUT_FILENO`, and `STDERR_FILENO` are macros for the file numbers of these streams as needed for IO system calls.
What you describe sounds like a hard problem. Decompilation of machine code is very difficult and often impossible without human intervention. Mapping APIs is easy (just insert a compatibility layer and call that) as long as each concept from one API maps to another. I don't think the programming language to write this in is the most interesting thing to think about when designing this project.
Sure, feel free to do so!
1. Why did you go through the libcrypt documentation? You don't need it. Everything you need except possibly `memset_s()` or `explicit_bzero()` is in libc. If your implementation doesn't have `memset_s()`, just copy `explicit_bzero()` from one of the BSDs or from [OpenSSH](https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/explicit_bzero.c) (all you need is the *second* version of `explicit_bzero()` in that file, but you *must* put it in a separate file from the rest of your code or the compiler will most likely optimize it away). 2. If you're on OpenBSD, then by all means, use `crypt_newhash()` / `crypt_checkhash()`, but they are not portable. And the documentation seems perfectly clear to me; pay attention to the quotes. 3. As for the `_POSIX_C_SOURCE` macro, just don't use `-std=c11` until you are ready to learn a lot more about POSIX than you ever wanted to know. Use `-std=gnu11` instead. Finally, if you want help with your code, you're going to have to show it.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openssh/openssh-portable/.../**explicit_bzero.c** (master → aede1c3)](https://github.com/openssh/openssh-portable/blob/aede1c34243a6f7feae2fb2cb686ade5f9be6f3d/openbsd-compat/explicit_bzero.c) ---- 
https://stackoverflow.com/questions/52858804/c-find-maximum-twos-complement-integer
 #include &lt;limits.h&gt; #include &lt;stdio.h&gt; int main(void) { print("%d\n", INT_MAX); return 0; }
Cool, thanks!
&gt; it should be declared using a const var not a #define macro Why? It makes absolutely no difference.
A #define macro can always be undone with #undefine. Also, not that it matters in this situation, but a const var has set scope and #define will always be global, so I was taught to avoid that.
C would be a better choice I think because it'll allow you to manipulate data more easily than Python, that put more abstraction around memory and binary content (C allows you to manipulate the memory content directly). But you could also look at other low level languages such as Rust, which could be a better choice : more modern, more tools to easily code, but the benefit of working with a low level language (like C). Note however than the learning curve of Rust is pretty hard (many many things to learn), while C is easier to learn (very hard to master) but much more error prone than Rust. &amp;#x200B; Anyway, you'll indeed need a low level language for your (very huge) project as you want to manipulate the lowest thing a computer can work with : binary.
What is your output, why do you think it skips the enterScore method and how have you verified it actually skips that part?
&gt; In this situation it would make little difference It would make no difference at all.
There is no largest possible integer, so it seems that the language choice shouldn't really matter.
1. The functionality you need is available in libc, there is no reason to add dependencies. I have already told you *several times* which functions you need: `crypt()` for the actual hashing, `memset_s()` or `explicit_bzero()` to wipe the password from memory, and optionally `mlock()` to prevent it from being swapped out. 2. CentOS and OpenBSD are two completely different operating systems. So no, you can't use something that only exists in OpenBSD in CentOS, unless you port it over. 3. Using `-std=c11` will cause you a ton of problems that you do not yet have sufficient understanding of or experience with C to solve, so don't. 4. No, you haven't shown me a single line of code.
Your problem is the delcaration of a constant n at line 30 and the array of size n on line 31. The integer nrOfJudges gets initialised to 0, then the constant n is also set to 0. you can fix the program by moving the constant and array delcarations on lines30/31 to after the do/while loop.
It is already required and I do remove unformatted posts if I catch them quickly enough. I do think however that removing a post with bad formatting that has already received responses is unfair, so I just ask OP to format his code in such situations.
If you mean the maximum integer size possible: ```c #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; int main (void) { printf ("Maximum integer is %jd\n", INTMAX_MAX); return 0; } ```
 int nrOfJudges = 0; double arr[nrOfJudges]; Your array is big enough to hold 0 scores. The fact it goes wrong at 6 is a red-herrings. It could go wrong with just 1 score.
When I change it to: `int nrOfJudges;` `double arr[nrOfJudges];` It gives the error "In function 'main': steg6.c:40:3: warning: 'nrOfJudges' is used uninitialized in this function \[-Wuninitialized\] double arr\[nrOfJudges\];" and still gives the same problem.
The size of `double arr[nrOfJudges]` is set when control passes over the array. What is the value of `nrOfJudges` at that time?
I don't know? 0?
Well, yes? You have to assign a value to a variable before you can use it.
How do I do fix that when nrOfJudges gets it's value in the function enterNumberOfJudges?
Create the array *after* you know how big it needs to be.
Any way that we can have a “report” option for this kind of infraction?
I would define a constant of min\_judges as 3 and max\_judges of 10. Use the max\_judges to define the array of judges. Then when you enter the number of judges ( nrOfJudges), make sure that the amount entered is between the min and max judges. 
let me add such an option. Thank you for the suggestion.
Yay 🎉
Its needed, unstructured code is hard to read and understand. You can post a code without a single line break, just one big one-liner. Code formatting can be automated in some IDEs and its a good habit to write properly formatted code in general. There are several "standards", they are having small differences, but overall, they are all easy to read and cohesive. 
Your for loop doesn't terminate, you never update `whole`, you never use `number`, and you never initialize your array to whatever you think it should be. That's just from a light scan. There's a lot wrong with the code, and without fixing those major items, we can't even begin to scratch the deeper issues
1-3. Understood. about 4. I will get back to you later via PM. 
Shit that's a step up from all the screenshots.
For a start, this doesn't do what you think/hope int whole = fnum; //111 float decimal = fnum - whole; //0.5 int array[100]; int number = whole; Take the 1st line for example. When `fnum` changes (during the call to `scanf`) then `whole` will *not* change in response. `=` means values are copied at the time the line is reached, not that there is a permanent link between the 2 variables. Secondly what do you even mean by " turn a float number into a single strand of binary. "? Your loop is operating on `whole` and `number` - 2 integers. The floating point number is never used.
"Here's a picture of unindented code that I took with my shit cellphone in the dark so the background is blooming around all the text. I've tried nothing and I don't know what to do"! 
expanding on this, you need to think about the order in which things happen. imagine the computer "reading" the code and following the instructions one by one.
[removed]
&gt; All the code written is wrong because they don't understand anything at all about c and just assumed they could just write python and it would compile.
C is just python with `{}`'s, right? 
No no no. floating point numbers use a specific format (it's almost always IEE754, and any other formats are almost certainly not worth your time). The algorithm is complicated but I'm not going to go into that here (unless you want?) just use the standard library's ftoi/ftoll/etc family of functions.
**Possible fix** string = realloc(string, (i + 2) \* sizeof(char)); &amp;#x200B; **Reasoning** According to [https://en.cppreference.com/w/c/memory/realloc](https://en.cppreference.com/w/c/memory/realloc), 1. *realloc* returns a pointer to the new memory block. 2. *realloc* either expands the current memory block **or** creates a new one and copies the old content to the new memory block. What I suspect is happening is that up until \~20 characters the memory block is only expanded and thus the old pointer is still *technically correct*, but whenever the memory block can not be expanded further the memory block must be reallocated to somewhere else. Since you never update the string pointer you will eventually try to access memory you no longer have access to.
Try something like this: while ((c = getchar()) != 10) { string[i] = c; char *newptr = realloc(string, (i+2) * sizeof(char)); if (newptr) { string = newptr; } else { fprintf(stderr, "FAILED!"); exit(1); } i++; } This should work. 
main is executed first because the definition of the C language says it is. Something has to be 1st, and in C that something is called `main`.
Thank you, it works! 
Your problem is that you're thinking of C as if it were a scripting language -- something like MatLab where you write a command and watch it execute. It isn't. &amp;#x200B; Instead, you define a bunch of functions that do stuff, call other fuinctuons, etc, and then tie the whole thing to a "main" function, which gets called first when the executable runs.
In C, you first **define** functions and then you eventually **call** them. Writing: void func1() { int i = 5; printf("\t[in func1] i = %d, j = %d\n", i, j); func2(); printf("\t[back in func1] i = %d, j = %d\n", i, j); } Will both **prototype** the function ```func1``` (allow people to call it) and **define** it (make sure that the compiler knows what code to run when someone does call the function) Here is just a prototype for ```func1```: void func1(); You need to always have the function's **prototype** located before it's called. You do **not** need to do the same for definitions Ex this is valid: void func1(); int main() { func1(); return 0; } void func1() { printf("In function 1!\n"); } Let me know if this helped!
Use a union ToInt{ int i; float f; }; //Write float read int format ToInt test; Test.f = 12.5f; While( test.i ) // will stop when all bits set to 0 { Sprintf( "%d", (int)(test.i &amp; 0x01)); \\print 0 or 1 Test.i &gt;&gt;= 1; //remove least significant bit };
 string str = "hello"; str.append(" world"); print(str); Guys why doesn't this work?
Ahh; see I didn't know this. Thanks! &lt;3
You're fucking papa. Thank you so much! &lt;3
Tremendously. Thank you so much! 
[This is a good example of an algorithm for Python](https://stackoverflow.com/questions/104420/how-to-generate-all-permutations-of-a-list-in-python) For C, you just need to calculate the number of permutations you will generate before allocating an array. You would need to generate the array dynamically (ie. with ```malloc``` and ```free```) based on the number of inputs.
Where did you find this assignment?
It *might* have been funny, sort of, if the OP hadn't explicitly said “in C”.
You'll have better luck searching for algorithms to enumerate *permutations*, not combinations. "Combinations" in CS usually means "taking or not taking each element, ignoring order". So the "combinations" of `[1,2,3]` are [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]] but the permutations are [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
Are you're using C? This looks like C++ code to me.
It is, im sorry but i couldnt fin the c++ subreddit
It should just be /r/Cplusplus.
Here's a sneak peek of /r/Cplusplus using the [top posts](https://np.reddit.com/r/Cplusplus/top/?sort=top&amp;t=year) of the year! \#1: [Been creating a 3D game engine from scratch in C++ that is capable of running the original DOOM and wanted to share my progress with you guys who have helped out quite a bit along the way.](https://np.reddit.com/r/Cplusplus/comments/8apgra/been_creating_a_3d_game_engine_from_scratch_in_c/) \#2: [50+ problems &amp; solutions to DataStructures in C++ with Diagrams Explained in an easy way](https://np.reddit.com/r/Cplusplus/comments/7wrxg1/50_problems_solutions_to_datastructures_in_c_with/) \#3: [C++ Projects for Beginners](https://np.reddit.com/r/Cplusplus/comments/80sllf/c_projects_for_beginners/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
r/Cplusplus r/cpp
Bosch doesn't disappoint with their drivers - I haven't worked with the BMP series, but I worked with their BMA and BME sensors and the drivers are fairly easy to get into and well-structured inside.. If I can give a counter-point with a driver worthy of studying because it's inconsistent and in bad form, take a look at the example driver for the Si1133 ALS/UVI sensor on something like the STM32. I had to dig through it recently to adapt it to our own use and... let's say that there's a lot going on there that's not done right. From multiple repeated identical code blocks (which would normally be off-loaded to a function of their own) to inconsistent naming, reusing the return values for both actual error codes and received data, lack of separation of functions into API (public) and static (internal) ones (hint: there's no static functions in there at all)... The driver maybe works as a starting point if you want to take something and get it to look right. Nevermind how the actual chip works (the method of working the registers reminded me of the Yamaha OPL2 and the Commodore 8563/8565 and those are _very_ unwieldy to program), the entire driver needs more than a combover.
 main() is required for a program to run, it's not just another arbitrary function like func1/2/3. You cannot make a program that does not have a main() (unless you're writing OS-specific code, such as WinMain for Windows programs) because it's how you tell the compiler what to run first. The program would never the other functions if they were never specified within the body of main(), or within the body of some other chain of functions that main() calls (such as your code). 
Adding on, there isn't a single c program that doesnt have a main function
It depends what you want to do with the result. E.g. do you want to store an array of 24 rows each containing 1 permutation? Or do you want to execute a function for each permutation? (If so, what info should the function receive?)
&gt;Adding on, there isn't a single c program that doesnt have a main function There isn't a single **hosted**, **strictly conforming** program that doesn't have a main function. However: # You can have a **freestanding** environment where "the name and type of the function called at program startup are implementation-defined" and "Any library facilities available to a freestanding program, other than the minimal set [...], are implementation-defined". This is usually the case when compiling for a microcontroller. # You can also have a conforming implementation that provides alternative entry points that are not required by the standard. Programs that make use of such alternative entry points must necessarily rely on implementation-defined behavior, so they aren't **strictly conforming**, but they are still **conforming** programs as long as there exists at least one implementation that accepts them.
Direct URL: https://www.humblebundle.com/books/make-electronics-2018
In case someone hasn't covered it yet: void func3() { int i = 11, j = 999; // Here, J is a local variable of func3(). printf("\t\t\t[in func3] i = %d, j = %d\n", i, j); } ^ is a function definition -- to compare this to natural languages, think of this like defining a phrase in a dictionary -- the program's own internal, mental dictionary. The phrase is `func3()`, and everytime you say `func3()` the program will do what you wrote in its definition that its supposed to do -- but you are NOT actually "saying" it when you write that definition, you are just explaining to the computer what it should hypothetically do when you do say it. `int j = 42` also will add the definition of j into its mental dictionary to mean "42", so everytime you say "j", it will know "oh, he or she means 42". The same with your `func2()` and `func1()` definitions below `func2()`. Now, main is important because you are defining what the program will actually do; the first line of `main()` is the first thing the program will do, followed by the second thing... *you are no longer being hypothetical; now you are actually describing what the program will do, and you may use the words that you defined earlier (and the program will understand thanks to your earlier definitions) or you may not*, its up to you. `func1()` you might say as your 4th command in main int main(){ func3(); //First thing program will do func2(); //Second thing program will do int cat = 2; //Third thing program will do, add 'cat' to its internal dictionary func1(); //Fourth thing; do what func1() says to do , and the program will say, 'hey I remember what that means, sure, let's do what func1() says to do". ================ Optional extra metaphor ======================== To go to another metaphor, if you wrote a poem in a language you made up, and then you gave everyone a dictionary to decipher the words, it might have a 1 page dictionary that looks like this: bluka = roses ik = are robo = red sippy = violets laba = blue And then you might have a page for the actual poem that looks like bluka ik roba, sippy ik laba Someone would refer to the dictionary to translate the words into what they understand, so that this poem would really mean roses are red, violets are blue to the person. So the dictionary would define the words, and the page with the encrypted poem would be, well, the actual poem. Likewise, everything outside of main is your dictionary you give to the computer so that it knows different phrases and what instructions it should perform when it sees that, and the `main()` function is the actual program, it is the page with your actual poem on it, it is a description of what the program will actually do, using words already defined in the language C, or defined in your dictionary or defined in other dictionaries you will include in your program (such as, in this case, stdio.h). Let me know if that is clear!
You have an infinite loop in `sieve()`.
Oh my gosh I see. Wow. Thank you so much! Got it to work now!
It's implementation-defined what it does. On Unix systems (e.g., OS X, Linux), it will run a command with the user's default shell (probably /bin/sh). On Windows systems, it will interpret a command using CMD.EXE. In any case, it's used for running external programs. In my experience, it is rarely used.
From the Linux man page: The system() library function uses fork(2) to create a child process that executes the shell command specified in command using execl(3) as follows: execl("/bin/sh", "sh", "-c", command, (char *) 0); system() returns after the command has been completed.
So, if you're writing a program that's supposed to implement a specific linux command like ls, cat and others. If you were to put the command and filename (-a DIRECTORY) into a buffer, and then call system(buffer) would it go into the shell and find out what each parameter is supposed to do? I'm only asking because I saw this program that takes arguments and filename from the user, puts them into the buffer, then prints them out using system(buffer), without defining what 'a' does, and it still prints the files in the directory with hidden files showing. I think I'm just wondering why in the code, there was no definition for what each command does and how it still prints out the way it's supposed to.
Yup, OP is just a referral link spammer using several layers of redirects to hide it.
Don't feel bad I was curious to know the answer.
Look at the line whole = number / 2; The variable `number` isn't referred to anywhere else in the code snippet. The value of that expression doesn't change from iteration to iteration. I think that's at least one problem.
I think `i &lt; 32 || whole == 0` is also wrong - it'll keep the loop going while `i` is less than 32 OR whole is 0, and `whole` is going to reach 0 at some point. And OP, there's a more direct way to accomplish this using bitwise operators. Instead of using the modulo operator, you can just test `whole &amp; 1` - it'll give you the value of the least significant bit. And instead of dividing, use `whole = whole &gt;&gt; 1` or the equivalent `whole &gt;&gt;= 1` to shift `whole` right one bit. If you're always printing exactly 32 bits you can save yourself the trouble of reversing the printout by doing it backwards - test `whole &amp; 0x80000000` to get the high bit, and then `whole &lt;&lt;= 1` to shift *left* one bit.
`-a` is an option recognized by `ls` that tells it to list all of the files in the directory, including hidden ones. The definition for what the `-a` option does is [in the source code for ls](https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/ls.c#n1796).
I don't want the whole number to be 32 bits, but how do I know at what value will it stop?
Right, but if in this program it wasn’t the actual source code for ls. It was some guy who programmed his own. And what he did was take an option such as -a and put it into a buffer with the path and then call system(buffer). I’m just asking if system() recognizing that -a from the buffer and is able to execute it the way it’s supposed to. Actually now that I’m thinking of it “ls” is put into the buffer first, so the entire buffer consists of; ls -a DIRECTORY 
&gt; I think i &lt; 32 || whole == 0 is also wrong - it'll keep the loop going while i is less than 32 OR whole is 0, and whole is going to reach 0 at some point. This is fine. The `i &lt; 32` is redundant if `whole` is a 32-bit integer, but it's not problematic. &gt; using bitwise operators Shrugs, I don't think there's any reason to prefer bitwise operators to div/mod. Their code isn't performance sensitive and IMO it's no more readable one way or the other. And if the OP later wants to try printing numbers in ternary or octal or decimal or hexadecimal... (Neither approach will "do the right thing" if `number` is negative.)
I haven't tried this, but logically it wouldn't work because IEEE754 formats use an offset, like 0 is set as X (I don't remember what X is off the top of my head, but it's different between floats and doubles) that has to be subtracted from the exponent, then the adjusted exponent has to be multiplied by the sign, and if any rounding is taking place the mantissa has to be read and dealt with too.
My base is 150k
If you want to call something before main, you could always override the GNU provided constructor class: __attribute__((constructor)) and put some stuff in there. &amp;#x200B;
Nobody has made this point, so I thought I would; The computer isn't exactly executing *your* program. It is executing machine code that was generated by the compiler that is the representation of your program for the architecture and operating system you have compiled it for. We have a way of representing machine code, called 'assembly', which is basically a one to one relationship of one assembly instruction = one machine code instruction. On my Mac, for example, which is an intel x64 based machine, the generated assembly for a hello world program looks like this: .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90 _main: ## @main .cfi_startproc ## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $32, %rsp leaq L_.str(%rip), %rax movl $0, -4(%rbp) movl %edi, -8(%rbp) movq %rsi, -16(%rbp) movq %rax, %rdi movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -20(%rbp) ## 4-byte Spill movl %ecx, %eax addq $32, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literals L_.str: ## @.str .asciz "Hello World!\n" .subsections_via_symbols You'll note that there's some stuff at the top, that defines what function is the first function to execute. It does a bunch of assembly instructions, basically to set up a function call to printf(), and then does a callq to printf() to print the string, and then returns at the end to end execution of the program. The C language specifies that main() is the first function to execute in a program, though some platforms (notably windows) use other entry points for various purposes, and therefore the generated machine code is out in a way that makes that true. As for *why*, well, it's just a decision some people made. It could be anything really, but then it wouldn't be C. 
Nice! I'd suggest storing the ones and zeros somewhere like you were doing before -- in an array, with an index that you advance by one place every time around the loop. Keep that index variable after the loop! After the loop has exited, you can use it count down from the last place back to zero, and print the digits in reverse order.
Can you recommend a good book about embedded C programming?
If you want something for beginners, I'd suggest [Making Embedded Systems](http://shop.oreilly.com/product/0636920017776.do) by Elecia White. I've only skimmed the book and gave it to my son, but I've heard good things about it, and I was on Elicia's podcast a while back and she seems to know her stuff.
THANKS! SOLVED
Don't forget `system("pause")` for people who insist on running a command line program from a gui.
&gt; I’m just asking if system() recognizing that -a from the buffer Usually not on a POSIX system. POSIX requires that system() behave *as if* it does a fork() followed by an execl(&lt;shell path&gt;, "sh", "-c", "ls -a DIRECTORY", (char *)0) in the child process. And the most straightforward way to accomplish this *as if* behavior is to actually do it. Then it's the shell's responsibility to parse "ls -a DIRECTORY" and execute it.
The main function is the thing that is executed in the first place. Other functions may be called by it, but it is the MAIN function!!! Files are not executed themselves, as they are all compiled and squished together eventually. Separate source code files just help organize code. The main function determines what is actually run. Random helper functions aren't executed in the order they appear in the file. Some functions may not be executed at all!
Most often you have to extract all files - configure just configures them for installation to your system.
Do beginners post here enough times each for habits to be relevant?
There are worse things than G*U. Whitesmith for example.
You're dropping the least significant bit before you print it.
You download the source code into any directory you want, usually your home dir. Something like ~/projects/network_project Then you navigate into that project dir, and the src dir within it to run ./configure That script prepares the project for compilation in your system. You can google ’automake’ to see how it works. After that is done, you can run ’make’ to compile, and probably ’make install’ to install it. This is how most *nix software is built from source. Though exceptions exist.
I'm sure you are aware that you posted basically the same thing 13 hours ago. https://www.reddit.com/r/C_Programming/comments/9q56pk/how_to_turn_a_float_number_to_binary/ Why don't you respond to some of the people attempting to help you there?
There are more bugs here than lines of code. Start over from scratch. Work out the algorithm on paper first, not in C but in English (or your native language) or mathematical notation. Then translate your algorithm into C. I can give you two hints: first, don't use floating point; and second, if you find yourself working backward, that's OK, you can always reverse the result later.
I have been doing the same assignment for hours now and yet to complete it 😂. Sorry troubling you
This distinction was the same in all versions of C from C89 onwards; what changed in C99 is that you can no longer call a function with no declaration at all. It's useful so that the compiler catches the error `func1(5);`
libfree # make cc -I../lib -g -O2 -D\_REENTRANT -Wall -c in\_cksum.c -o in\_cksum.o cc -I../lib -g -O2 -D\_REENTRANT -Wall -c inet\_ntop.c -o inet\_ntop.o inet\_ntop.c:56:1: error: conflicting types for '\_\_inet\_ntop' inet\_ntop(af, src, dst, size) \^ /usr/include/arpa/inet.h:131:20: note: expanded from macro 'inet\_ntop' \#define inet\_ntop \_\_inet\_ntop \^ /usr/include/arpa/inet.h:147:13: note: previous declaration is here const char \*inet\_ntop(int, const void \* \_\_restrict, char \* \_\_restrict, \^ /usr/include/arpa/inet.h:131:20: note: expanded from macro 'inet\_ntop' \#define inet\_ntop \_\_inet\_ntop \^ 1 error generated. \*\*\* Error code 1 Do you know what to do with this error? &amp;#x200B;
Did you get any errors while configuring?
The one above your reply. 
Can you explain what unexpected thing is happening when you are executing the code? What are you entering at each step and what you are seeing every time?
You declared process to be a character, then compared it to an integer. Change the process variable type to int and the program will work.
I get 0 as output
What are the inputs that you try and get 0 as an output?
I've defined 'process' int, and this time it just adds. Subtraction, division or multiplication operations on the output 0
 I did what @sme272 said and defined the variable 'process' as int. The program is only running the addition process. All numbers output to be 0. 
Do you know how to use gdb? 
&gt;Do you know how to use gdb? yes i know a litte
So run the program through gdb and set a breakpoint at the switch statement. Print values of all 4 variables there and let us know what they are. 
Add „fflush(stdin);“ after your first scanf. That will clear your input-puffer. Maybe your second scanf takes the Enter-Button from the first one and your var process has some strange value.
It didn't work :( &amp;#x200B;
I wrote a software suite to interface to a line of industrial controls we make. Various other companies use different parts of the suite, when writing it I tried to get them to link to a class library (C#), no one was interested, they just wanted to use a command line, so I was like cool, here is one. Years later we were running into trouble with external applications overwriting data with 0's as they ignored the content of the file and just updates their parts, so we wrote some code to detect the program and then apply filters based on the path.... You can guess what I found..... All the "industry leading" software used a batch file to call my software. I looked at this a few weeks ago, they're still using batch files to run my program from their program and this is on windows 10..... Nice.
these commands working but I do not understand why switch(process) { case 1: printf("Result of the addition process : %d", (x+y)); break; case 2: printf("Result of the subtraction process : %d", (x-y)); break; case 3: printf("Result of the multiplication process : %d", (x*y)); break; case 4: printf("Result of the division process : %d", (x/y)); break; } &amp;#x200B;
Try to use %c in your second scanf instead of %d
Did you check with gdb as I had mentioned?
No, i don't know how.
No issues. Firstly, are you running this on Mac or Linux OS? Or is this on Windows?
That’s an output from make, not configure.
oh. ./configure ran without erros.
&gt;I see. What is the development environment? Visual Studio, MinGW, Cygwin, Bash on Ubuntu on Windows? i'm using bloodshed dev-c++ 
Please don't repost the same content in quick succession. As /u/lordlod pointed out, you've already posted about this question 14 hours ago, so why don't you keep it to that post?
Thank you so much. What compiler do you use ?
`fflush(stdin)` is implementation-defined and not likely to help. `fflush(stdout)` on the other hand will ensure that the output is actually printed before input is expected. And not using `%d` to read a `char` should also help.
Comparison is not an issue, using `%d` in `scanf()` is.
This book is 15 years old, and the code is not likely to work unmodified on modern platforms. The problem here is a combination of the age of the code and the fact that it reimplements APIs which are already provided by the system.
Just for completeness. From section 5.1.2.2.1 of [The C11 Spec](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) &gt; 5.1.2.2.1 Program startup &gt; 1 The function called at program startup is named main. The implementation declares no &gt; prototype for this function. It shall be defined with a return type of int and with no &gt; parameters: &gt; int main(void) { /* ... */ } &gt; or with two parameters (referred to here as argc and argv, though any names may be &gt; used, as they are local to the function in which they are declared): &gt; int main(int argc, char *argv[]) { /* ... */ } &gt; or equivalent;10) or in some other implementation-defined manner
&gt; a one to one relationship of one assembly instruction = one machine code instruction That is very rarely true these days. What we think of as machine code is usually interpreted (with a shit-ton of optimizations) by microcode written in a lower-level instruction set.
when I fixed the type of the process variable, this program just works for me.
You may want to escape the \* after char in the arguments
Your loop **runs** if `i` is either `&lt;32`, or if `whole` **is** equal to 0. Since you put OR operator, any condition will suffice to continue the loop running. I thought you want the loop to stop when either `whole` becomes 0 or i becomes 32.
There are two things at play. First, I don't know what 'sizeParamOf' is -- did you define that somewhere else? Second, the '[]' is higher precedence than *. And so you need to dereference first, then index. Hence the parentheses. 
Oh okay, thanks
It's due to operator precedence. Without the parenthesis, the operator for the array subscript (\[\]) will will get priority, and you will then first offset the 'pointer to the pointer', and then take the value from that address with the dereference (\*). With the parentheses, you will first dereference the pointer (get the start value for your array/memory), and the array subscript operator will fetch the value from your chosen offset.
Operator precedence. To the compiler `*mallocArray[i] = i` means: "load the value behind `mallocArray[i]`, which is of type `int*`, dereference it and write the value `i` to it. Or as code: int *ptr = mallocArray[i]; *ptr = i; Now, the () in `(*mallocArray)[i] = i` change the precedence of the dereference operation, so the compiler reads it as: "dereference what's behind `mallocArray`, which is of type `int*`, index it by `i` and write `i` to that. Or as code: int *ptr = *mallocArray; ptr[i] = i;
The expression `*mallocArray[i]` means `**(mallocArray + i * sizeof(int))`, whereas (\*mallocArray)\[i\] means `*((*mallocArray) + i * sizeof(int))`. This is because `[]` (array subscripting) has a higher precedence than `*` (dereference). In other words, `*mallocArray[i]` means "take the `int*` at position i in `mallocArray` (which is an `int**`), then dereference it". This is not what you want, as `mallocArray` is a pointer to a single pointer to `int`, so `mallocArray[i]` is out of bounds if `i &gt; 0`. `*mallocArray[i]` means "dereference `mallocArray` (which is an `int**`) to get an `int*`, then access the i-th position of that `int*`". First it dereferences the pointer to pointer to int, and it finds your `int* array`. Then it finds the `int` at the i-th position of that array, which is exactly what you wanted. BTW: &gt;`sizeParamof` That should be `sizeof` (and probably is, as your code wouldn't compile otherwise).
Are you actually seeing the output of your printf lines or is 0 the output from the exit of the program? I ask because when I run your code as you have it written I don't get any prompts visible until the process menu prints because neither of the first two prompts has a new line. Then the output text in the switch statements also do not have new lines in them so the program simply exists with the exit code 0. By added newlines (and fflush(stdout)) after each line of text they are now all printing and it seems to work just fine.
Thanks for the details. I appreciated it
Thanks, but do you have any website, or source where that kind of details is explained? I could also see some new stuff if you have one ! (Even if you explained me well what was going on in my code)
No, `x[y]` means `*(x+y)` (by definition) . There is no extra size of multiplication.
You are right. I forgot the way pointer arithmetic works, for some reason. I hope my mistake didn't confuse the OP.
Well yeah. It’s turtles all the way down. But for the purposes of this explanation...
It works fine for me, but whatever move I make, I lose. Not sure if I understand the rules of this game.
ah ok, well one little improvement would be to allow comitting moves in steps, cause otherwise it becomes hard to visualize the path one is taking on larger boards.
also, OP could implement depth first search and see if the puzzle is solvable without asking the user if they want to rethrow...
I figured if you'd have to make the move in 1 go it'd be at least moderately challenging to get to the end :P
I'm afraid that's out of my depth atm. I'm looking at that error and I think it's because I regenerate the field on a reroll and those malloc's arent' being freed. I figured I'd check if either of em was a nullpointer and then malloc, but it segfaults on checking if (f-&gt;lines) :/ Thanks for looking at my stuff and wanted to let you know I'm looking at it too :P
Hey, thanks. This will be a big help going forward.
Please don't post these.
ok
&gt; What's bad about using a Makefile? You lack a configuration step and you'll waste a lot of time when the project becomes larger. &gt; From what I've heared Autotools is a pain in the ass for the maintainer and I don't feel like I need it my projects. That's hearsay, your Honour! I speak from experience, you speak from assumptions. &gt; What could it add to the build process of something like an X.org window manager? Portability, feature detection, library detection, enforcing requirements, facilitate distro-level packaging, etc. Did you really think people have been working on this particular wheel in vain? We use it because it solves problems.
&gt; We use it because it solves problems. I do trust you on that, I just don't see problems. I don't plan on having many optional features, just the stuff that's in there, so I don't need feature detection. How would it increase portability? Just where the libraries are at? Enforce what requirements? I wouldn't say I speak from assumptions, I speak from what other people, who've used Autotools, tell me. Thank you for the answer, [this](https://github.com/buffet/kiwmi/blob/2fb1f6d812f11b2588f8527a42ef62619303af15/Makefile) is what the Makefile currently looks like.
 //Is the memory allocated for the string above safe, after the function returns? The memory for a string literal is allocated elsewhere, so that line is technically fine. You should make the pointer a `const char*`, because the string is read-only. Most compilers warn about this nowadays. //If yes, how would I assign a dynamically constructed string to buffer? If you need to allocate a new buffer for the string, just `malloc` and `strcpy` it in. Don't forget to allocate enough for the terminator. `strdup` does this in one step for you. Just make sure to `free` that memory later. If you need to modify the string then you'll also need to allocate a copy. //I know this is wrong practice. tempInt will go out of scope. //Yet, it will not be not be freed instantly, right? The memory will be freed as soon as it goes out of scope. //Given that I did no memory operation(like malloc) since calling myFunc, //I can safely read s-&gt;a right? (Even though it is wrong practice) No, reading `s-&gt;a` is not safe. This is undefined behavior in C, and you might get very strange results (including working like you wanted). Avoid creating dangling pointers, and make sure you never can never dereference them. //someStruct.buffer[0] = 'M'; //I know that string assigned to buffer is immutable That's why I suggested `const`. It's technically immutable, but the compiler might let you do it anyway without `const` added. This is also undefined behavior, though.
&gt; How would it increase portability? Just where the libraries are at? You define _POSIX_C_SOURCE like you'd only target glibc. There are other libc implementations out there. Do they all provide the functions you need when you define that constant? "libxcb" might be installed in a non-standard location, so you should use the output of "pkg-config --libs xcb" for linking to it. BTW, you should never replace the user's/packager's CFLAGS/LDFLAGS. Append to them, but only what you need, not stuff like "-Os".
Thank you for helping me out. My compiler(MSVC) does not warn me about `char* buffer` not being const. Also I am observing that the freed memory for `int tempInt` still holds the value of 22, such that it is not zeroed out. (Isn't this normal behavior?) Also if I make `char* buffer` const, doesn't that mean I can not reassign a string to it? I can do it when the const char\* is in the struct, however when it is a global variable, compiler won't let me. &amp;#x200B;
&gt; You define _POSIX_C_SOURCE My software only runs on POSIX systems. Non-POSIX libc implementations won't provide the functionality I need, but I don't feel like supporting something aside from Linux and BSDs. &gt; output of "pkg-config --libs xcb" Will do. &gt; never replace the user's/packager's I've never seen this on a system, is it typical to have CFLAGS and LDFLAGS in your env? Thanks for the overall feedback though.
What about: #include &lt;stdio.h&gt; int main(){ recurse_reverse(); } void recurse_reverse(){ char c = getchar(); if(c!='\n') recurse_reverse(); putchar(c); } This is how I would probably do it.
I made a really simple "Matrix" program which just has random characters scrolling down the screen like the movie. Had to have the console set to a certain width and height (and text colour to green) but it was pretty neat, and I recommend it if you're bored. #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; int main(){ char letter; int i,j,c,d, length=230; /* controls horizontal width of line. DEFAULT = 230 */ int segLength = 75, original = segLength; /* Controls how long each vertical segment of characters is. DEFAULT = 75 */ int numSegments = 5; /* Controls how many characters on each line ON AVERAGE, LOWER = MORE CHARACTERS PER HORIZONTAL LINE. DEFAULT = 5 */ int line[length]; int delay = 300; /* Speed characters appear (lower = faster). DEFAULT = 300 */ while(1){ for(i=0;i&lt;length;i++){ line[i] = rand() % numSegments; } for(i=0;i&lt;segLength;i++){ for(j=0;j&lt;length;j++){ if(line[j]==0){ letter = (char) (rand() % 100)+40; printf("%c", letter); }else{ printf(" "); } for ( c = 1 ; c &lt;=delay ; c++ ) for ( d = 1 ; d &lt;= delay ; d++ ) {} } printf("\n"); segLength = (rand() % original) + 10; } } } Apologies if some of the comments or other things are ambiguous. I made this when I was fairly new to the language and haven't touched it since. 
Fixed it (NSFW) #include &lt;stdio.h&gt; int main() { int i, j; for (i = 5; i &gt;= 1; i--) { for (j = 1; j &lt;=&gt; i; j++) { printf("*"); } printf("\n"); } return 0; } &amp;#x200B;
&gt; I've never seen this on a system, is it typical to have CFLAGS and LDFLAGS in your env? It is, when you package software for a Linux distribution or when you run a source-based distro like Gentoo or when you're a programmer.
I get the idea. However, it reverses only the first line. You'd need a loop in the main() and a way to know whether you have to make another call. Also, if we have a line terminated by EOF instead of `'\n`, the program doesn't stop.
You have to use the address of operator. struct X { char *string; } X; (init your struct and get a pointer to it) InitedStruct.X = &amp;String;
What about people who don't run Gentoo, that want to build from source?
yep, works fine: https://imgur.com/a/JbOBraC
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/WME9eeZ.mp4** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e89193a) 
Honestly it looks like there is an over-arching object-oriented abstraction at play here...
Again, I am grateful for the thorough explanation. Cheers!
&gt; What about people who don't run Gentoo, that want to build from source? Those people should learn how to build packages for their distro, so as to avoid bypassing the only package manager they should be using.
It was just a simple example without a buffer. Those are easy changes to make, I just wrote a quick program to read from stdin, where there should be a newline.
`BUFSIZE` is a bit small. Usually you use something to the power of two, like `256`. i = 0; while ((to[i] = from[i]) != '\0') ++i; can be rewritten to for (i = 0; (to[i] = from[i]) != '\0'; ++i); (Maybe use `{}` instead of `;` since the compiler might think it's a mistake) 
&gt; the only Why so strict?
Got it, easier to test with a small buffer :) Where to use `{}`? You mean like: `for (i = 0; (to[i] = from[i]) != '\0'; ++i){}` ? K&amp;R says `;` is a "null statement", and I doubt modern C standard has changed that. They put the `;` in a separate line to make it clearer that there's no body: for (i = 0; (to[i] = from[i]) != '\0'; ++i) ; Also I know `for (head = 0; head &lt; tail; ++head &amp;&amp; --tail)` should be written as `for (head = 0; head &lt; tail; ++head, --tail)` but that's "future knowledge" :)
&gt; Where to use `{}`? You mean like: `for (i = 0; (to[i] = from[i]) != '\0'; ++i){}` ? Yes. &gt; K&amp;R says ; is a "null statement", and I doubt modern C standard has changed that. They put the ; in a separate line to make it clearer that there's no body: &gt; &gt; for (i = 0; (to[i] = from[i]) != '\0'; ++i) &gt; ; This is true, but (I haven't checked yet) I think gcc can warn you if you use such construct, since you might write: for (some; example; loop); some_code; I'd also say that this is just preference.
&gt; Why so strict? Because when you use multiple ways of managing the same set of files you are going to run into problems, sooner or later. If you want a clean and stable system, stick to your distro's package manager. When the use of a third party package manager cannot be avoided, jail them to some dir in your home that can be easily deleted.
I also have beej's guide to socket programming.
thanks.
thanks.
I didnt. It says it cant find the /../config.h file. I'm not familiar with including files with the .. in front of it. Do I need to put it in the parent directory?
.. just means ’one directory up’. There should be instructions on how to get it set up. Perhaps a README
Since you wanted a full example: &amp;#x200B; [https://pastebin.com/nnS7F8G8](https://pastebin.com/nnS7F8G8) &amp;#x200B; Note how 90% of the code is just handling command line arguments for files.
No, this is still not correct.
You're welcome.
Since you've figured out that system() is executing whatever command you put in, here's a bit more info: system() is actually just a wrapper for execl(). What system() does is start a new /bin/sh process and then plug whatever you've written into it like so: execl("/bin/sh", "sh", "-c", your_command, NULL); execl is just a function for conveniently invoking the `execve` system call, which is used to start new processes.
Funny.
[Doxygen](http://www.doxygen.org/) 
Don't you hate it when people write code in a font that is not monospaced? Ughh ghastly
I prefer rosewood for all my code actually.
Funny people. 
From what I've seen, typically when you launch an executable, the first function that will be executed will be `_start`. This function is usually provided by the C standard library (glibc, if you're using Linux). Now, if you want to see how that works, you can check out [this code](https://github.com/bminor/musl/blob/master/crt/crt1.c) from musl, a libc replacement. I don't exactly know how musl ties together, but you can see that it's calling the main function (in kind of a weird and indirect way). But yeah, `main()` is executed because the C standard library launches it when you launch your program, and typically it'll clean up afterwards and send an `exit` system call to tell the system that your program has finished.
As a begginer C programmer im thankful for this cause I still havent come to for cycles and this helped me understand them.
&gt; Have I properly assigned those values to an array (in this case "int x"). If so, how would I call the values in the array and perform a function such as below. You're missing the actual assignment! You need something like `x[i] = ...;`. You should then print out what's in this variable. However, there's a big problem: `x` is an array of integers, and you're trying to generate floating-point random numbers. That won't work very well. Remember that C arrays start at 0, not 1. Get used to it, or you'll end up confusing yourself constantly (you have a bug in your loop bounds right now, for example). Your compiler should be giving you a warning right now about `printf`. Always listen to those warnings; they often tell you that something is wrong, so don't ignore them. &gt; How would I then group those into bins of 10 bins of a range of 0.1 (i.e. place all values falling with 0&lt;=0.1, 0.1&gt;=0.2, 0.2&gt;=0.3, etc.) and show their frequency? 1. Create an array to hold the results 2. Determine what the mapping is between a value and what bin it should be in. In other words, if I give you the value 0.1415, calculate a bin indexed 0-9 for it. 3. Loop through the data, and determine the bin index for each value. 4. Increment that bin number. 5. Print out the results.
&gt;I tried to do the addition first then the multiplication wich is wrong. That's right. &gt; can i "return" a SINGLE value to a pointer by using my first method (AKA \*mallocArray\[i\]) ? What do you mean? `*mallocArray[0]` would be the same as `*(*mallocArray + 0)`, which would be the same as `**mallocArray`, which in turn would be the same as `(*mallocArray)[0]`, so if you have a single element it doesn't matter which one you use (although `**mallocArray` would be clearer).
Thank you so much. A couple follow-up questions. 1) Can I make an array of floating numbers? If so, would it go something like “float x[SIZE];”, then assign it later? 2) I am not getting a printf error on my compiler. I’m using VIM with the gcc compiler on Linux. What error should I be getting?
Thank you very much!
Technically not an auto-documentation generator, but I've been quite happy with the literate programming tool [CWEB](https://en.wikipedia.org/wiki/CWEB) for personal projects.
in case you're on *nix: $ man operator or here http://man7.org/linux/man-pages/man7/operator.7.html
No problem bud, but in the future, if you have a question, don't be afraid to ask. "If you don't ask, who will?" Don't be afraid to look like someone inexperienced, or you won't learn! I can honestly say that no one here has 100% mastered c, also, we're here to learn ya know?
Thanks! The book I'm reading is a C book in its first chapters, and I don't even think it's mentioned that main is first. I appreciate it! 
&gt; constructor Dude! This is an awesome concept! Thanks for showing an alternative to my answer. You not only answered my question, but you did it without sarcasm and introduced a bit of creative out-of-the-box thinking. I appreciate it!
LOL I questioned the c source that was given to me. Not the almighty C! Also, I'm kinda new and didn't know main was first. I appreciate the patience, and memery.
1. "hardware" interface. Write a program that can interpret your file as a series of sectors. 2. "software" layer. Using the raw sector read, interpret that as a [FAT formatted](https://www.win.tue.nl/~aeb/linux/fs/fat/fat-1.html) volume.
&gt; , and the program will say, 'hey I remember what that means, sure, let's do what func1() says to do". &gt; &gt; Great explanation. Truly good definition. Thanks :D
That part I knew already, but I do appreciate your feedback, and non-sarcastic answer! 
&gt; hat to run first. The program would never even run the other functions if they were never called from within the body of main(), or within the body of some other chain of functions that main() calls (such as your code calling func1 which calls func2 which calls func3, etc). Interesting, so if a function is outside of main (above / below) and it's never called, it won't run?
Thank you. My book mentions this aswell, but I haven't gotten it into my thicc skull. Thanks! 
While I do understand your frustration, please do remember that I am a noob, and (from my understanding), people come to this forum because they don't know things, and while this may be the back of your hand, this isn't for me (and possibly others who were too afraid to ask). Please just consider this when looking at noob questions. Thank you for your resource!
%s stops scanning at the first whitespace. If you think "L. A." is acceptable input for "enter an initial", then %s is not for you. A [scanset](https://www.geeksforgeeks.org/scansets-in-c/) might do the trick, but it depends on what you consider to be acceptable input. And what you want to happen if the user enters something that doesn't conform. If you want to read an entire line from the terminal, use fgets() instead. In fact, if your parsing is going to be the least bit complicated, use fgets(), and then sscanf() to extract information from the string. Or gettok() perhaps. Or regex() Or write your own parser. You really need to sit down and decide what the acceptable inputs are going to be, then figure out how you're going to parse it.
`s-&gt;buffer = "string constant";` is acceptable C, and the string constant will stick around forever, so you're good as far as your question is concerned. But if you're going to be doing this, consider making buffer a `const char *` instead. Any attempts to write to the string buffer will result in your program crashing.
yea i tried fgets and fputs but that command takes me to a new line. In my assignment im supposed to type that line with spaces and dots on the same line as the printf which should be done thru scanf since thats all we've been taught till now. So i have no clue what my prof wants... 
`scanf("%d", &amp;process);`. `process` is a char, not an int. This scanf call will read a value and store it in multiple (probably 4) bytes starting at c. This will overflow, and all bets are off after that. I would make `process` an int. Once I did that, the program worked for me. You also need a newline at the end of your final printf(). Listen to /u/a4qbfb: always enable warning messages and turn them up to 11. I always compile my programs with -Wall -Werror.
Any textbook will describe how to seek and read blocks of data (sectors) from the file. The link describes how the bootsector is interpreted, and how the other sectors can be interpreted as FAT
Thanks man!
Do you need to debounce the button?
no i don't need to. "if (exchange == 1) " didn't work either.
 while(1) { if(exchange != 0) { PORTA=0x00; } if(exchange == 0) { PORTA=0xff; } } How about something like that?
sorry i think the post was misleading. the code works fine as it is. it works just fine . its just i want to know why "if(exchange=0)" does not work while using the !(not) works fine. i want to know what's casuing this. all i can think of is because of the variable declaration
Only if it is called by main, or indirectly by main - which is the case with your code where main calls func1 and *only* func1. If func1 didn't call func2 (which in turn calls func3) then neither func2 or func3 would ever be executed. It's called "execution flow" and you can think of it like a tree, with main() as the trunk of the tree, and then the first branches of the trunk are just all the function calls that are made from main(). Those functions in turn then call other functions, branching the branches further. The analogy is flawed, however, because you can can have any function call any other function, which would be the equivalent of multiple branches from all over the tree coalescing into a single branch. i.e. you could have a special logprint function which writes some debugging text to a file, and have main call your logprint function to output some information about program initialization, but then you could have all kinds of other functions that end up getting called through the hierarchy of your program's flow which also call logprint to commit their own debugging information to the log file. At any rate, yes, everything a program does starts in main(). The functions it calls and the functions they call and on down the line (however deep your program goes) are what gets executed, and simultaneously the means by which you control order of execution. Which brings us back to the concept of "execution flow".
&gt; its just i want to know why "if(exchange=0)" does not work while using the !(not) works fine. `if(!exchange)` is equivalent to `if(exchange == 0)` -- notice the two equal signs. Likewise, `if(exchange)` is equivalent to `if(exchange != 0)`.
Okay, i may start going to understand. I am wondering who was the first to "discover" this though, it's a bit like a brain gymnastic.
i tried if(exchange==0) and if(exchange==1) once. and those did not work. are you if(!exchange)는 if(exchange==0)are same 
In the pointer version, `end` points to `last_element` instead of pointing to the `last_element`th character in the string. I would just get rid of `last_element` altogether and initialize `end` to `phrase + length - 1`, or: for (char *end = phrase + length - 1; phrase &lt; end; phrase++, end--) if (*phrase != *end) return 0; return 1;
`if (exchange == 0)` is *exactly* equivalent to `if (!exchange)`. The problem is the other case; since you use `exchange = ~exchange` to flip the flag, it will alternate between `0` and `0xff`, so `exchange == 1` will *never* be true. If you absolutely want to compare to 0 and 1, use `exchange = !exchange` instead of `exchange = ~exchange`. But if I were you, I would just write my test as if (exchange) PORTA=0x00; else PORTA=0xff; Although it would be much simpler to rename `exchange` to `value` and do: PORTA = value; This flips the logic, i.e. it will start by setting `PORTA` low rather than high, but you can change that by initializing `value` to `0xff` instead of `0`.
You can also use `%[^\n]`. This scans a string until a newline is reached.
See our sidebar.
Please don't post these.
Heh, yes. Unfortunately that's a limitation of using the console
Note that `()` does not create a prototype for a function that takes no arguments: int main() { main(5); // allowed, but UB } Please write the correct `main(void)` instead.
Yeah, it looks really elegant when you do it char by char :) btw, it prints an extra '\\n', fix: &amp;#x200B; while(gc!=EOF){ recursive_reverse(); if(gc!=EOF) fputc('\n',fptrOUT); } &amp;#x200B;
Futures / promises are functional programming idioms which don't really translate to a procedural language such as C. You can achieve a similar effect using a combination of callbacks, async I/O, threads, and / or IPC. As always, you should start by stating your goal, not how you intend to solve it.
Thank you. The issue in question is waiting upon multiple Websocket connections for replies after sending a message
wouldn't one just use c++ then at this point ?
I'm thinking your problem is that your struct is something like: struct NameStruct { char first_name[100]; char middle_initial[1]; char last_name[100]; }; &amp;#x200B; Which has a problem when you do: struct NameStruct name; scanf("%s", name.middle_initial); if your entry is, "A." You are expecting any number of characters, and you have room for only one. You may be able to fix that problem with : scanf("%1s", name.middle\_initial); Or, even better, make middle initial just one character, and then look for it: scanf("%c", &amp;name.middle\_initial);
That depends on which OS you're talking about. Generally though that would be handled by the kernel and filesystem, but the OS should give you an API to read and write to a floppy directly. On Linux this is the block device, like /dev/fd0 (I'm not sure where it would be on a modern Linux OS, I haven't had a floppy drive for going on 20 years now) and to read it all you need to do is open it like a normal file. To get started now you can use floppy disk images. If you're on Windows grab a copy of WinImage, create a floppy disk image, throw in some files and save it as an ima or img file. That should be a raw image of the disk as if you read it directly from a physical disk. On Linux you can create a floppy disk image using a loopback device, formatting it to fat12 and copying the files in in the same way, there should be direction on google for that. After that, you're read to start reading the FAT12 header and listing files. Hope that gets you started.
What difference does it make?
That's a typical use case for an event loop. If your client library doesn't support some form of polling, you'll have to run each request in a separate thread and use queues and condvars to coordinate them.
It depends on what OS you're using. On Linux it'll probably do a typical fork/exec, for more information on that see documentation on Linux/UNIX programming in general. It's more or less equivalent to just running the command yourself from the command line and then waiting for it to finish before continuing your program. What it's used for is highly dependent on your program. For example, I may have a simple C program that needs to play a sound. C has nothing for sound built in and I might not care enough to figure out how to load samples myself and use an API to play sounds from the OS, so I'll just do something like **system("play alert.mp3")**. In other words it's a way of reaching outside your program to provide functionality implemented by other programs on the system. It's also not generally considered a very good way of doing things. It can be very insecure, it's highly dependent on the OS the program is running on, etc. It works, but you probably shouldn't use it unless you have to.
exchange ^= 1; Will also work
&gt; I can safely read s-&gt;a right? (Even though it is wrong practice) No. From the standard: "If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime." So not only is the attempt to access tempInt after its lifetime undefined -- there's no guarantee that s-&gt;a even points to the right place for such an attempted access. Even if you insist on a "practical" answer, the answer is still no. If I add `printf("%d\n", *someStruct.a);` to main(), look what happens as soon as I bump up optimization a notch: $ gcc6 -Wall -Wextra -pedantic -std=c99 -o test test.c $ ./test 22 $ gcc -O1 -Wall -Wextra -pedantic -std=c99 -o test test.c test.c: In function 'main': test.c:19:1: warning: 'tempInt' is used uninitialized in this function [-Wuninitialized] printf("%d\n", *someStruct.a); $ ./test 0 For -O1 with gcc, 22 isn't written anywhere, s-&gt;a gets initialized to a ghost location on the stack where the 22 would otherwise be, main() doesn't call myFunc() at all, and the second argument to printf() in main() gets replaced with a constant 0: myFunc: subl $16, %esp movl 20(%esp), %eax movl $.LC0, (%eax) leal 12(%esp), %edx ; -16 + 12 = -4 movl %edx, 4(%eax) addl $16, %esp ret [...] main: [...] pushl $0 pushl $.LC1 call printf That's an old version of gcc, and it does the same optimization at higher optimization levels. With a newer version of clang, it's even more of a circus. For -O1 with clang, 22 isn't written anywhere, s-&gt;a gets initialized to a ghost location on the stack where the 22 would otherwise be, main() *does* call myFunc(), and main() *doesn't* replace the second argument to printf(): myFunc: pushq %rbp movq %rsp, %rbp ; frame pointer used this time movq $.L.str, (%rdi) leaq -4(%rbp), %rax ; ghost -4 easier to see movq %rax, 8(%rdi) popq %rbp retq [...] main: [...] callq myFunc movq -8(%rbp), %rax movl (%rax), %esi movl $.L.str.1, %edi callq printf The result is that printf() prints garbage from the stack. For -O2 and -O3 with clang, myFunc() remains the same, but the call to myFunc() gets eliminated from main(), and printf() isn't provided an explicit second argument at all: main: [...] movl $.L.str.1, %edi callq printf The result is that printf() prints whatever happened to be in %esi -- probably the lower 32 bits of argv.
Fixed it [https://imgur.com/a/NUvCtpl](https://imgur.com/a/NUvCtpl)
Manually. There is no library routine to do this.
Ncurses can do text boxes with boarders
Not qiite sure if it works (don't have an access to a computer right now), but I would try `printf("%20c",'|');` where 20 is the width from the left side (you can choose the number you need). I've been using this, worked fine on my program, which is a copy of "ls -al" command. It saved my life. Still not quite sure if it's what you're looking for though.
Not necessarily. It depends on how the library is written. Besides, you should use `poll()` rather than `select()`, unless you need to run your code on a system that doesn't have it.
r/https://i.imgur.com/DmclOKU.png &amp;#x200B; Yea, my structure is exactly as you described it but i was already doing scanf("%7s", name.middleInitial) but it still cuts off at the space. Same thing with the last name, whereas the last name is supposed to be Wong Song but it breaks if i type that...
Should be a null check here: https://gitlab.com/RJKruit/minefield/blob/master/field.c#L16 and here: https://gitlab.com/RJKruit/minefield/blob/master/field.c#L40 and pretty much every function that takes a pointer!
Thank you for taking the time! Am I not checking that with if (NULL != pList-&gt;next){ ... } ? The recursion should stop if the next item would be NULL
Yes.
Print horizontal bars some length L. Decide the next line T to print with length W. Identify right padding by P = L - (W+3) for end bars and one space pad. Print "| " Print T Print P Print "|" + new line. Verifying example: Print "| test |". L=8. T="test", W=4. P=8 - (4 + 3) = 8 - 7 = 1. Which is correct. So, you should be good.
What you're looking for is called "coroutines" and there are plenty of C libraries for them. The fanciest one I found gives you M:N green thread scheduling with work stealing, among other options: https://github.com/Qthreads/qthreads Other libraries of interest: https://github.com/baruch/libwire/wiki/Other-coroutine-libraries
You're welcome! Main is first and only! Other functions are only called if main calls them!!
Thanks. I was considering libevent/libuv. Have you used it before ?
No, but libuv is a good choice if you need an event loop running on a single OS thread. I'm more interested in using all the available cores.
I believe that you can use libuv on multiple threads for multiple cores. Are you suggesting moving the tasks between cores which libuv does not allow ?
Well, I suppose it crashes but how do I check? If I test if(pList == NULL){ do something; } it does not detect it being NULL either...
On Linux there are a pair of system calls, [`mount(2)`](http://man7.org/linux/man-pages/man2/mount.2.html) and [`umount2(2)`](http://man7.org/linux/man-pages/man2/umount.2.html), for mounting and unmounting filesystems from a program. There's no portable interface for this. All the other things you list would require parsing the filesystem's data structures, and that's not platform-specific. Either you need to find a library to do this, or you'll need to study [a FAT format specification](https://staff.washington.edu/dittrich/misc/fatgen103.pdf) [PDF] and parse it yourself. 
C# compiles its `async`/`await` code to an [FSM under the hood](https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine), the same can be ported to C, you just don't have the nice syntactic sugar. JS relies on its event loop rather than an FSM to perform the same task, which can be done is C using [libuv](https://github.com/libuv/libuv) for example.
lol
&gt; I believe that you can use libuv on multiple threads for multiple cores. Only if you do your own initial scheduling, which can't be optimal. &gt; Are you suggesting moving the tasks between cores which libuv does not allow ? That would be "work stealing" and yes, it would maximise the core usage when an imbalance appears between the task queues on different OS threads. So you have two problems here: initial task distribution and dynamic redistribution later on.
I see Thanks. Do take a look at libdill too. [http://libdill.org/](http://libdill.org/)
The insertList in a for loop is pretty suspect to me. Can you show that code?
Not to throw a wrench in the works, but what if the user changes the default terminal font? I'm not sure every font option has uniform character widths.
Actually, all terminals use a monospaced font. There are some caveats tho. If you output CJK (chinese, japanese, korean) characters, they'll typically take up two spaces. Same with emojis. [Here's an example on my machine](https://imgur.com/a/OPGJvtU).
Okay I figured it out and it is because end needs to be declared a constant char. Also the i and phrase = &amp;i should not exist. 
That's no problem at all.
C isn't interpreted, so yea basically no. You have to compile your C code and run the binary. That's how C works. It's designed for different use than Python and has totally separate goals. I've never been able to stand the IDLE interface, too minimal for me, but if you want more minimality you can use literally any text editor you want with C. Try notepad++ if you're on windows.
Again, thank you for the detailed explanation of what is going under the hood. I am now more than convinced that what I thought would work to a certain extent, is clearly undefined behavior under all conditions. I never experimented with optimizations before. Is using extensive optimizations a norm for production code?
Still don't see the source for `insertList`, what you've given is `insertData_LC` Also, how come you're allocation and accessing `pList` like an array when you're using a linked list? Also, the source doesn't seem complete, since I see no "pointing to Particle %s"
&gt; Actually, all terminals use a monospaced font. No they don't. I mean, first of all, as a concrete example, the KDE konsole on my computer can be configured to use pretty much *any* font. I know this because I actually use nurses and it's a pain to make sure the font *is* monospace. But second and more importantly. Wtf kind of sweeping statement is that? How on earth can you *possibly* know about every terminal in the whole damn world? You *have* to be talking out of your arse. Please don't make shit up and then spout it like it's true. 
You're right, sorry: void insertList(ParticleList **root_list, ParticleList *i){ i-&gt;next = *root_list; *root_list = i; } &gt; Also, how come you're allocation and accessing pList like an array when you're using a linked list? Because I dont know how many particles I will need to initialize before runtime. How else would I assign values to each particle? &gt; The source doesn't seem complete, since I see no "pointing to Particle %s" That's just a call of printList() in the main function. Should I upload the entire codebase? 
Python is good at what it does and C is good at what it does. There are things I'd write in Python but not C and things I'd write in C but not Python.
If you have a git repo that would be best! Also, the motive here is a little unclear if I'm honest. Some comments would be much appreciated! Why not allocate another node on the fly and insert it into the linked list? That's what they're good for!
Even if terminal emulators support non-monospaced fonts, all bets are off if you don't use a monospaced font. Output on a terminal is expected to be monospaced. Imagine programming with a non-monospaced font
I also didn't fclose my file*'s. Whoops.
Learning how to use pointers or recursion effectively takes a lot less than 100 days. Typically, about a week is needed. I'd rather recommend you to pick a project and then take 100 days to implement it. You are going to learn all these things during your journey.
I understand the concepts pretty fast - but in order to hard code them into my brain, it takes way longer. That's why I want to continue doing them religiously every day so that it sticks forever.
I can understand this motivation, but again I think it's more fruitful if you do this as a part of a medium-sized programming project.
Why on earth are you typedeffing double to real?
There are many C interpreters. Popular examples include : (1) PicoC (gitlab.com/zsaleeba/picoc) which is a small open sourced compiler originally for embedded something or other, and (2) CInt (root.cern.ch/cint) which is part of the massive CERN ROOT software stack.
You didn't say if ur on Windows/Linux/MacOS, and I would recommend using an IDE, my favourite is Pelles C (Win) and Geany (Linux): https://en.m.wikibooks.org/wiki/C_Programming/What_you_need_before_you_can_learn
Well, did you code this? What output did you get? I did just to be sure, and exactly what I thought would happen did. Sometimes it's much faster just to code a quick test than to go and read ancient standards.
It’s effectively undefined behavior for now AFAIK, although compilers may be nice to you in this regard and the standards are a little iffy on this point. [N2279](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2279.pdf) discusses basically this situation if I’m not mistaken. If the change suggested there goes through, the `printf` should reliably print `4`. If it doesn’t, an enterprising compiler might decide that `a` and `b` don’t/can’t alias, in which ccase no telling what happens.
This won't even compile: if ( double problemValue == 0) What you probably want: if ( problemValue == 0 || anotherPotentialProblem == 0 ) It's often better to use `assert` to enforce contracts: assert(problemValue != 0 &amp;&amp; anotherPotentialProblem != 0);
Any such projects for a beginner? If so, where should I be looking?
Thanks for sharing. That's super interesting and quite analogous to the stuff I built with knowing about it.
CLion is a very good IDE (Android studio is based on it). Its multiplatform (is written in Java) and is very comfortable. The only negative thing is that doesn't support Makefile but only Cmake. If you are on Linux, use vim + youcompleteme plugin. If you are on windows visual studio is very good, now there is the free edition.
I'm working on a verification framework for C and C++, and because of that I'm interested in the C language semantics. The implementations may handle things differently for many reasons, but what I'm interested in is behavior of \*any\* conforming compiler. This is important when you want to show that your reasoning is correct/sound with respect to the specification of the language you analyze.
Python's Idle has excellent new book! https://www.amazon.com/Always-Look-Bright-Side-Life/dp/1984822586
I see what you were trying to do now. It's more customary to show a declaration instead: double problemValue = ...; int anotherPotentialProblem = ...; if ( problemValue == 0.0 ) printf(ERROR); else if ( anotherPotentialProblem == 0 ) printf(ANOTHER_ERROR); else calculateAvg = ((valueI * valueJ) - (valueF / problemValue )) / anotherPotentialProblem; It also helps to show as much code as possible.
Sir, this is not how Undefined Behavior works.
&gt;As I understand it, this would mean that there is only one object in the snippet Correct. The lifetime of an allocated object ends when it's deallocated via free() or realloc(). Therefore, 6.2.4#2 is not a concern. Each store changes the effective type of the allocated object: "If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value. " (6.5#6) &gt; and the *a* pointer is invalid before the first write, then becomes valid by writing *1*, becomes invalid when a float gets written, and becomes valid again upon writing 4 to *c*. Yes, with validity defined in terms of deferences for read accesses. Dereferencing `a` for a read access when the effective type of the allocated object is a float would violate the aliasing rules listed in 6.5#7. 
I never said it was undefined behaviour, thats something somebody else said. I made no claims about how this is defined. All I suggested was that the OP give it a shot before asking questions. As I just found out, the nature of OPs work makes my suggestion useless. 
Fair enough. There's too many half-assed noob questions on this sub for me to put a lot of thought into my responses. Now that I know your project I know why you're asking specifically about standards
Think of something you'd like to have for yourself and implement it. The probability of needing pointers to do so is pretty high.
 // get random number for (i = 0; i &lt; max_tries; ++i) { // get user input // if input == random number // print success message. // break from loop. // else if input &gt; random_number // print lower message // else // print higher message } // if i == max_tries // print failure message; &amp;#x200B;
I think what you really need is to study recursion and pointers that are applied in various different examples. I would recommend you buy a book on algorithms and data structures in C. Take 100 days to study it and it will give you what you are looking for, plus much more you probably don't know you need.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; //provides a feature for seeding the time #include &lt;math.h&gt; #define SIZE 100000 int main(void) { float x[SIZE]; //This is the for the array int i;//inner counter variable for number of iterations in the for l srand(time(NULL)); //Establish the first for loop. for (i = 0; i &lt; SIZE; ++i) { x[i] = (double) rand() / (double) RAND_MAX; //printf("a[%d] = %.6f\n",i , x[i]); } //j = (double) rand() / (double) RAND_MAX; //x[i] = -log(j)*(1 - j) / lambda; //double j; //double lambda = 0.05; int frequency1 = 0; int frequency2 = 0; int frequency3 = 0; int frequency4 = 0; int frequency5 = 0; int frequency6 = 0; int frequency7 = 0; int frequency8 = 0; int frequency9 = 0; int frequency10 = 0; for (int j = 1; j &lt; SIZE; ++j) { if (x[j] &lt;= 0.1) ++frequency1; else if(x[j] &gt; 0.1 &amp;&amp; x[j] &lt;= 0.2) ++frequency2; else if(x[j] &gt; 0.2 &amp;&amp; x[j] &lt;= 0.3) ++frequency3; else if(x[j] &gt; 0.3 &amp;&amp; x[j] &lt;= 0.4) ++frequency4; else if(x[j] &gt; 0.4 &amp;&amp; x[j] &lt;= 0.5) ++frequency5; else if(x[j] &gt; 0.5 &amp;&amp; x[j] &lt;= 0.6) ++frequency6; else if(x[j] &gt; 0.6 &amp;&amp; x[j] &lt;= 0.7) ++frequency7; else if(x[j] &gt; 0.7 &amp;&amp; x[j] &lt;= 0.8) ++frequency8; else if(x[j] &gt; 0.8 &amp;&amp; x[j] &lt;= 0.9) ++frequency9; else ++frequency10; } puts("Probability Distribution Function from Bin1 &lt;= 0.1 to Bin 9 &lt;= 0.9 (100K iterations)"); printf("Bin1 %d\n", frequency1/100); printf("Bin2 %d\n", frequency2/100); printf("Bin3 %d\n", frequency3/100); printf("Bin4 %d\n", frequency4/100); printf("Bin2 %d\n", frequency5/100); printf("Bin3 %d\n", frequency6/100); printf("Bin4 %d\n", frequency7/100); printf("Bin7 %d\n", frequency8/100); printf("Bin8 %d\n", frequency9/100); printf("Bin9 %d\n", frequency10/100); //printf("Bin10 %d\n", frequency10); return 0; } Could you give me a hint or advice please how I implement the log() function, so I can make a probability distribution? I have been getting this error message: "/tmp/ccJhf3Rs.o: In function \`main': randomexp.c:(.text+0x7e): undefined reference to \`log' collect2: error: ld returned 1 exit status" I didn't think I had to call log since it's built into the standard &lt;math.h&gt; library. &amp;#x200B; &amp;#x200B;
On macOS, and I would imagine the same goes for Linux-based systems, when I set a non-monospaced font in the Terminal, it will still use a constant width for all characters. I'm guessing it just uses the width of the widest character. Needless to say, it looks *really* ugly, because most characters are quite slim and therefore have a lot of space around them.
Yeah recursion is very useful with trees for example, and pointers are vital if you want to implement any data structure.
That is C++. This is a sub about C.
Ok
A follow up question from another beginner: why use C for these kinds of activities when Python can do it in a much better and easier way? I have read recently that Python does things well that C is not built for and vice versa. Isn't it a good idea to get a good grasp at both and use them interchangeably according to needs? Thanks.
I'm guessing one of yiur problems is you are comparing a double to an int. 
Some compilers require a `-lm` option to link in the math functions. I'd try that. Using `log` like that is an interesting way to do the binning. I would highly recommend turning the frequency variables into an array, which can greatly simplify your code.
Error messages should go to stderr, not stdout.
This is actually a fantastic idea. I was going into algorithms and data structures any way - this should be a very good start. Any suggestions on this? Thanks!
I think so but I also tried to compare to double but still didn't work. I did a lot of research and found that you can't really compare doubles as easily like you can an int or string. I dont know. Never got it to work but it was past due anyways and just wanted it to work for curiosity so I'll wait on professor feedback.
Watch out for hop ons.
Generally `fabs(foo) &lt; EPSILON` for some acceptable `EPSILON` is how you compare `foo` “equal to” zero. Also, are you `printf`ing regardless of whether the input is zero?
https://eli.thegreenplace.net/2012/08/24/plugins-in-c
Reinventing the wheel is the best practice to master new language.
I have a source of (pseudo) code that uses real as var type. Trying to stay coherent with it
I'll add some more comments and upload to git asap
In the context of homework-type assignments like these, almost none of those things matter unless the TA is expecting to see them. &gt;First three questions Access control like global/local and static don't matter when you can see all the variables in the program in one screen. &gt;I am thinking to open the file in every function and write to it and then close it. Will this work? This file can be called to read at the same time while it is being written. I am skeptical that my code can break in this scenario. what things should I keep in mind so that I am able to handle this? Do I need to lock my file? I have no idea what a "file lock" is, in Windows you have mandatory file locking and applications must opt-in to sharing files they have open descriptors for. You can implement something similar to this with fcntl(2) on Linux but I don't know why you'd want to in a single-threaded linear program. &gt;There are multiple files in one download. The newFile will have entry for each file. Each line will have various attributes of file separated by colon. I will update the last value in each line which is current download percentage when call back function is running. any tips or a better approach? Why are you even bothering with a file? If you're doing this in the grand Linux tradition you should just push the output as text to stdout. If the user wants a file than can create one with `&gt;` or pipe the output into another program to interpret. If you're doing this as a library of some sort just hold the data in memory and have an access function or better, a well documented struct. If you're dead set on a file, sure, that works &gt;I always get confused if I should declare char[] or char* . char[] for a static string constant that will never change from what you set it to at compile time. char* for damn near everything else. 
Can you just build it twice? dll for windows and shared object for Mac and linux? You could distribute them in a zip or similar and just load the appropriate one depending on platform.
[Git Hub repo](https://github.com/Marc408/linked_cell/blob/master/git_linkedcell.c) That's basically the entire code. You can ignore all functions except for printList(), initData() and main() &gt; Why not allocate another node on the fly and insert it into the linked list? I'll look into this now!
Because `select()` provides less functionality and scales very poorly, in terms of both ease of use and performance.
On UNIX, the standard way to do this is to compile your plugin into a shared object and then call `dlopen()` to load it into your program and `dlsym()` to access functions and symbols in it. On Windows, this works differently but I don't know how.
&gt; I mean unless you really like C Even if you love C using it for something that in Python would be 10 lines is not very productive. For hobby? Yes, great idea. For work? Not so much.
There is also [CEPL](https://github.com/alyptik/cepl) : [https://raw.githubusercontent.com/alyptik/cepl/master/cepl.gif](https://raw.githubusercontent.com/alyptik/cepl/master/cepl.gif)
case ranges are an extension in gcc. It's not available in MSVC as far as I know.
C doesn't support that. For a case statement you can only check against a single value with each case. I'd recommend using an if statement.
I don't think that case suports this syntax. This is the perfect place for a normal if. if(i &gt;= 1 &amp;&amp; i &lt;= 25) { printf("range 1-25"); } else { printf("outside of 1-25"); } This really is no reason to use a case here...
The Win32 equivalent is [LoadLibrary](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) and [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress). There are some subtle differences between these and `dlopen()`/`dlsym()`, particularly with respect to global variables, but most of the time you wouldn't notice.
&gt; char[] for a static string constant that will never change from what you set it to at compile time. char* for damn near everything else. Why is a char[] better for the first situation?
Personally, I'd just have a platform specifics file that loads them according to the local platform, and handles all the quirks therein. Usually I have a platform specifics file regardless exposing the functionality I need and this would fit right in.
Malloc allocates a 4 byte block of memory, and you then assign that pointer to x. There is no subsequent free, so the block stays allocated. Each casting assignment of x into a, b, and c just makes a copy of the pointer x, it does not change that pointer. So, at the end of your code, all four pointers have the same memory address value, just different type interpretations of that value. Since the last assignment to use the pointer value was as an int with value 4, the block of memory allocated by malloc will then be written with the value 4. The danger your code presents is in the assumption that all type casts are to types of same size (I.e., sizeof(type)). For example, this will get you in trouble: float *x = malloc(sizeof(float)); long long *a = (long long *) x; *a = 0x99999999l; Here, the malloc allocation is four bytes, but the long long assignment will write 8 bytes (64 bits). 
I'm a bit confused. `Sasprintf1` seems to work fine here: ``` #define _GNU_SOURCE #include &lt;stdarg.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define DebugPointer(p) \ { \ __typeof__(p) p1 = p; \ printf("address of " #p ": %p\n", &amp;(p1)); \ printf(#p " points to: %p\n", p1); \ } // memory-safe asprintf, implemented as a macro #define Sasprintf(write_to, ...) \ { \ char *tmp_string_for_extend = (write_to); \ asprintf(&amp;(write_to), __VA_ARGS__); \ free(tmp_string_for_extend); \ } // memory-safe asprintf, implemented as a function void Sasprintf1(char *write_to, char *format, ...) { DebugPointer(write_to); va_list args; va_start(args, format); vasprintf(&amp;write_to, format, args); DebugPointer(write_to); free(write_to); va_end(args); } // varargs example double average(int count, ...) { va_list ap; int j; double tot = 0; double arg = 0; va_start(ap, count); // Requires the last fixed parameter (to get the address) printf("count: %d\n", count); for (j = 0; j &lt; count; j++) { arg = va_arg(ap, double); printf("arg: %f\n", arg); tot += arg; // Requires the type to cast to. Increments ap to the next // argument. } va_end(ap); return tot / count; } int main() { char *s1 = NULL; Sasprintf(s1, "select * from mytable"); printf("%s\n", s1); free(s1); int i = 3; char *s2 = strdup("select "); DebugPointer(s2); Sasprintf1(s2, "%s%s%i * from mytable", s2, "col", i); DebugPointer(s2); printf("%s\n", s2); free(s2); printf("Average of 1, 2, 3: %f\n", average(3, 1.0, 2.0, 3.0)); } ```
(Reddit doesn't support code fences, so you have to put four spaces in front of it.) In this version it's a macro, not a function. The pointer in this case is effectively "passed" by reference rather than by value, as it is in your original code where this is a function.
There are two implementations in the snippet above, one as a macro, one as a function. Both seem to work as expected. 
But let's assume that the `Sasprintf` function is wrong, and let's not use it in main: int main() { char* s; int n = 0; // Sasprintf(s, "%s", "sss\n\n\nbbb"); s = "xxx\neee"; s = "new\nthing"; printf("string: %s\n", s); n = count_lines(s); // printf("n lines: %d\n", n); // free(s); } It still gives a segfault. 
When you run this program, does it give you an error? Also, you should look at this: [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) 
I don't think your use of `Sasprintf1()` is doing what you want or expect since your program makes no sense after the `strdup()`. The `Sasprintf1()` function is effectively a no-op. The only thing it does is allocate memory then immediately free it, all without side effects. Here's the output when I ran your program: select * from mytable address of s2: 0x7ffd670d2cd8 s2 points to: 0x1205080 address of write_to: 0x7ffd670d2bf8 write_to points to: 0x1205080 address of write_to: 0x7ffd670d2bf0 write_to points to: 0x12054b0 address of s2: 0x7ffd670d2cd8 s2 points to: 0x1205080 select count: 3 arg: 1.000000 arg: 2.000000 arg: 3.000000 Average of 1, 2, 3: 2.000000 Note line 10 ("`select `"). The format string you passed to `Sasprintf1()` didn't do anything. The program just printed the original string assigned to `s2` and `s2` was never pointed somewhere else. 
I hear you, but isn't that the point of abstraction? When I'm using stdio, I don't know what that's doing. Also, Python's modules are mostly open source , so if you want to learn under the hood, you can always do that.
Thanks. Does the following make more sense? // memory-safe asprintf, implemented as a function char *Sasprintf1(char *write_to, char *format, ...) { char *tmp = write_to; DebugPointer(write_to); va_list args; va_start(args, format); vasprintf(&amp;write_to, format, args); DebugPointer(write_to); va_end(args); if (!tmp) { free(tmp); } return write_to; }
Ok thx
Thx
Take a pen and a piece of paper. Write down your values of 'i' and 'j' and walk through the loop by hand. When do you think it should stop? When does it stop? I suspect you will find the problem this way. Also, add lots more comments, in English, describing what you expect it to do.
That doesn't look like an infinite loop for me. But what I see is division by zero in second iteration: i=0; j=0; a[i] == x == b[j]; -&gt; a[j] = 0; -&gt; x = 0; j=1; if (b[j] % x) == b[j] % 0;
I think you need an C++-style interface that can be emulated in C using a struct of function pointers. Many of the answers here focus on runtime loading, but that doesn't seem to be your main problem here. Either use function pointers or declare functions you expect to be defined elsewhere in one of your headers.
This is correct, but it appears like you're aping the `Sasprintf` macro without really understanding its entire purpose. The first argument to `asprintf()` / `vasprintf()` is strictly an output argument. It doesn't care at all about the original pointer value. It simply clobbers it without looking at it. So if `asprintf()` doesn't care about the original pointer value, why does `Sasprintf` accept that first string argument? The hint is in the name of the temporary variable: `tmp_string_for_extend`. They key word is "extend." It waits to free the passed string until after `asprintf()` has returned, meaning the caller can use the input in the output. For example: char *s = 0; Sasprintf(s, "SELECT %s FROM %s;", column, table); /* ... */ Sasprintf(s, "SELECT %s(*) FROM (%s);", func, s); exec(s); free(s); In the second use of `Sasprintf`, `s` used as both an input and an output, and the original string was freed. The string was "extended." The function `Sasprintf1()` that you just wrote also supports this, but I suspect this was an accident that happened from copying the macro. Your version is more complicated than it needs to be because it's such a direct copy of the macro. Also, the `if` is unnecessary since `free()` will happily accept a null pointer: if (!tmp) { free(tmp); } Final note: I used an SQL query in my example because it appears that's what you're doing in your program. **This is wrong and dangerous! Don't do this!** Your program will almost certainly be vulnerable to an SQL injection attack because I'm sure you're not escaping all the inputs properly (if at all). Instead, look into *bind parameters*, which will be supported by whatever SQL database you're using. It's safer (no SQL injection vulnerability), faster (query is only parsed and compiled once), and it avoids all this complex string building mess. 
When I run your code the inner loop completes twice and then I get an error: test test Floating point exception (core dumped) At some point you are setting a\[j\] = 0; and then on a subsequent loop you are attempting to divide by zero with the condition b\[j\] % x==0 when x is zero, which is causing the error. 
It's pricey but I read the entire "Algorithms in C" and found it very insightful and I recommend it. You can get it on Amazon. You might be able to save a few bucks by getting a used copy. You can probably save even more by just getting parts 1-4 (skipping part 5, which is a separate book).
&gt; but isn't that the point of abstraction? The short answer is that you use specific tools for specific jobs for specific workflows. For example, if you’re making a game in C++ and want to pull down images from a server for a game lobby or something, you aren’t going to have an external hook into python just to do that — you’ll do it in C++. Also in corporate environments, introducing extra toolchain dependencies for trivial stuff is usually frowned upon unless you’re working with JavaScript. 
Warning: Black hole ahead! Perhaps a little more advanced, but if you like through /r/crypto, you can find some useful stuff about checking for primes.
if it was my code, I'd do `int loadMatrix(int \*\*matrix, int rows, int cols) {...} ` and in `main()` or whereever ``` int rows = 5, cols = 3; int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i &lt; rows; ++i) matrix[i] = (int *)malloc(sizeof(int) * cols)); loadMatrix(matrix, rows, cols); ``` and of course some `frees()` afterwards
Thank you, and is this: loadMatrix(&amp;matrix[0][0], .. the same as this? loadMatrix(matrix, .. &amp;#x200B;
And how would you access the matrix elements in the loadMatrix() function? scanf("%d", matrix + i * rows + j) is giving me a segfault..
Oof ouch my code formatting.
take a look at this: https://cboard.cprogramming.com/c-programming/164493-trying-fill-character-array-scanf.html
Say you have a complex problem. Most optimal solution will not be recursion most of the time. Do not obsess over recursion IMO. 
all the countS, countI,count R, countV are 0.
the file will be input from the user's local file. The matrix above is an example of file content
That's not what I asked. I asked, where is the file pointer? Ie. which character from the file will `InFile &gt;&gt; file` read first.
Character 's' I suppose. Sorry if I'm incorrect, I'm still new in programming world. I may or may not fully know or understand what you are implying. 
I'm implying that "InFile &gt;&gt; file" will not read the 1st character of the file. What other operations have you done with `InFile` before you get to this point? You've read it all - this loop won't execute at all since the `eof` flag is already set.
ok I got your point. Do you have any suggestion for me to fix or change something? 
I'm trying to print out the result from the col vector that I store the input file in
You've already read the entire contents of the file, the file pointer is at the end of the file, and you need to look at the data again. You could * look at the data you've already stored - it's in your vector. * move the file pointer back to the beginning of the file. * reopen the file
You've already read the entire contents of the file, the file pointer is at the end of the file, and you need to look at the data again. You could * look at the data you've already stored - it's in your vector. * move the file pointer back to the beginning of the file. * reopen the file
You've already read the entire contents of the file, the file pointer is at the end of the file, and you need to look at the data again. You could * look at the data you've already stored - it's in your vector. * move the file pointer back to the beginning of the file. * reopen the file
You've already read the entire contents of the file, the file pointer is at the end of the file, and you need to look at the data again. You could * look at the data you've already stored - it's in your vector. * move the file pointer back to the beginning of the file. * reopen the file
You've already read the entire contents of the file, the file pointer is at the end of the file, and you need to look at the data again. You could * look at the data you've already stored - it's in your vector. * move the file pointer back to the beginning of the file. * reopen the file 
You've already read the entire contents of the file, the file pointer is at the end of the file, and you need to look at the data again. You could * look at the data you've already stored - it's in your vector. * move the file pointer back to the beginning of the file. * reopen the file
ef
I've posted a question on stackoverflow in case anyone is interested: [https://stackoverflow.com/questions/52977103/two-pointers-residing-at-the-same-address-but-pointing-at-different-things](https://stackoverflow.com/questions/52977103/two-pointers-residing-at-the-same-address-but-pointing-at-different-things)
I've posted a question on stackoverflow in case anyone is interested: &amp;#x200B; [https://stackoverflow.com/questions/52977103/two-pointers-residing-at-the-same-address-but-pointing-at-different-things](https://stackoverflow.com/questions/52977103/two-pointers-residing-at-the-same-address-but-pointing-at-different-things)
I've posted a question on stackoverflow in case anyone is interested: https://stackoverflow.com/questions/52977103/two-pointers-residing-at-the-same-address-but-pointing-at-different-things
I've posted a question on stackoverflow in case anyone is interested: https://stackoverflow.com/questions/52977103