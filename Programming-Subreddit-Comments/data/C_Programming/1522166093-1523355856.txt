&gt; I read through the file twice The only way to read through it once is if you have a preset maximum size for your maze dimensions. Reading through it twice makes sense if you want your 2d array to be the exact right size and there are no restrictions on your maximum height and width. &gt; Aren't the lines basically arrays of char or is my understanding completely off? You can store them as `char arr[]` but you'll have to perform comparisons like `if (arr[i] == '1')` etc... You can also store them as `int arr[]` which affords comparisons like `if (arr[i])`, but it wastes memory.
But how can i do it with system calls, I mean, using open instead of fopen, etc
This is the answer. The `-l` flag just tells the compiler to find the library in the directories set in the environment variables. It does not know where else to look for all the libraries in the system. To tell the compiler to look into other directories to find the library, you use the `-L` tag and give it the path to where to find the library `quantum`.
Because you haven't initialized your variables, you are getting what is called "Garbage Data". It is just random bits left by other programs in memory that never got cleared out. So when you're allocating space for that variable `age`, your getting all that garbage data at that memory address. By using this garbage data, you're experiencing what we call "undefined behavior". Which is behavior that you don't expect from the program like how it output a huge number when you expected it to output nothing.
To your question about my program knowing the cpu cache size
Not OP, but thanks! I never would have found this on my own.
Did you see [this](https://www.reddit.com/r/C_Programming/comments/872rlt/c_project_based_tutorials/) just a few posts down? Some wonderful stuff on there.
Oh wow. That's just awesome. Thanks!
Alright, yeah there’s no way to otherwise know the dimensions. So for the second part, shouldn’t what I have be correct then? Isn’t maze-&gt;array[i] and are array of char?
&gt; The only way to read through it once is if you have a preset maximum size for your maze dimensions. Just dynamically allocate the memory you need. I would probably just use `fgets` to read lines one at a time: while( fgets( buf, BUFSIZ, in ) != NULL ) { ... } You could also just read a single character at a time if you wanted. You could store each line in a linked list, then when you run out of lines, see how many you have and allocate the entire grid and dump everything you've already read into it.
Here's a bunch more: https://www.reddit.com/r/C_Programming/comments/872rlt/c_project_based_tutorials/?utm_source=reddit-android
You either need to read it twice or use a more dynamic method of managing your array. Hint: you won't be able to read from stdin twice, so maybe give up on that method. Hint: pointers can act like arrays, and can be allocated space dynamically. Slight digression but I can't let it lie: cat is for concatenating files, it's not for providing stdin for something else. Your shell can already do that on it's own, e.g. `command &lt; file` will do the same as `cat file | command` but without the use of cat.
First time I've seen this. It's pretty cool. Here's the macro: #define ICE_P(x) (sizeof(int) == sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1))) It's meant to determine if `x` is an integer constant expression (ICE). It does this by comparing sizes via `sizeof()` in a fairly clever way. First, there's some tricky multiplication: (x) * 0l When `x` is an ICE this will multiply out to 0, otherwise effectively nothing happens^1 and you end up just looking at `x`. From here it is cast to `void *` and we're looking at a ternary operator: 1 ? ((void*)((x) * 0l)) : (int*)1 Ternary operators have the form `A ? B : C` and can be seen as a sort of if-else statement condensed into a single line. Essentially if `A` evaluates to true, the ternary operator returns `B` and otherwise returns `C`. In this case, though `A` is always true (`1`) so the ternary will always return `B` or `(void *)((x) * 0l)`. Here's where the genius of it comes in. If `x` is an ICE, `x * 0l` will result in `0`, and `(void *)0` is `NULL`. When given the option to return pointer types, a ternary operator will default to the pointer that is not `NULL`. So if `x` is an ICE the ternary operator must return `(int*)1`, which is importantly an integer pointer. If it is not an ICE, the ternary operator must return `(void*)x` which is importantly *not* an integer pointer. This all then gets evaluated inside `sizeof(*())`, where it is dereferenced prior to being fed to `sizeof()`, like so: sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1) That dereference ensures that we are comparing `sizeof(int)` with either `sizeof(*(void*)x)` or `sizeof(*(int*)1)`. In the case of the latter, we're evaluating the size of an integer, and so the macro will return true. In the case of the former, we're evaluating the size of something that isn't an integer, and so the macro returns false. I hope that was helpful, but regardless thank you for sharing, I hadn't seen this before. Very cool. ^1 Bear in mind that "nothing happens" is a gross oversimplification, but for the purposes of this example it works because this is all being cast to `void*`. If you know more about the mechanisms involved, please comment below, as I would love to learn more.
I'm looking for the same thing. Example programs like the above showing proper use of the library for specific cases - like: which cipher algorithms require an initialization vector? Which ones are compatible with Counter with CBC-MAC mode? It would be easy to "think" you are doing it right but miss a trick like the initialization vector and not really be getting the security you are hoping for.
Neat!
Not necessarily. I haven't looked over all your code, but this sticks out to me: while((read2 = getline(&amp;buffer, &amp;len, file)) &gt; 0) { maze-&gt;array[x] = read2; x++; } `getline()` doesn't return a `char*`, it returns a `ssize_t`. Could you be more specific with how your code is not working? What errors are you getting, and where?
It's a use case which yields little to no benefit. Ignore it for the time being and so since reading on it later.
Thank you ! I get it now :)
Whoa. I feel like a child.
Welp. I'm a moron. I've been using C for years, and I didn't know that the ternary operator behaved like that for pointer types. 
`strtok` can be used within loops just fine. But I still recommend using `strtok_r` because non-reentrant functions are a bad thing in general. The problem is that you're trying to retokenize the same string each time through the loop. `strtok` (both versions) modifies the original string, inserting `'\0'` between each token. If you need to reuse the results of the tokenization, I would suggest keeping an array of pointers to each token and using that in your loop.
Show a *minimal complete example* program that demonstrates the problem. There's no nested strtok in what you did post...
You are not alone. Linus's description linked in the original post is the first I had heard of it, but it makes a lot of sense.
&gt; When given the option to return pointer types, a ternary operator will default to the pointer that is not NULL. To be clear, it chooses the type of the pointer that's not NULL. So here `1 ? ((void*)((x) * 0l)) : (int*)1` must return the left side, or `(void*)(x*0l)`, but that value is converted to `int*`. The reasoning here is that a ternary expression has to have a type; The second and third sub-expressions of the ternary expression don't have to have the same type, so the ternary operator has to choose a common type that it returns and which works whichever side gets returned. Normally the common type between `void*` and `int*` would be `void*`. However there's a special rule motivated by the following: condition ? NULL : &amp;something; Obviously `NULL` is intended to be a null pointer to the same kind of object as whatever `something` is, so when one of the sides is a null pointer constant the type of the ternary operator is computed by ignoring the type of the null pointer constant and just assuming the desired result is whatever the type of the other side is. But because C allows arbitrary expressions that happen to be integer constant expressions and which evaluate to zero to count as null pointer constants, this rule kicks in whenever `x` is an ICE. Side note: recent versions of C++ change the rule such that null pointer constants cannot be arbitrary expressions, but must be either an integer literal (or a particular C++ type). So in C++ `0` is a null pointer constant but, for example, `(void*)0` is not. Which means that in C++ `x ? (void*)0 : (int*)0` has type `void*` and `x ? 0 : (int*)0`has type `int*`.
&gt; The problem is that you're trying to retokenize the same string each time through the loop. strtok (both versions) modifies the original string, inserting '\0' between each token. If you need to reuse the results of the tokenization, I would suggest keeping an array of pointers to each token and using that in your loop. Oh, so that's why I'm having problems... Thanks! Now I'll be able to fix my code, yeppi! 
Show a *minimal complete example* program that demonstrates the problem.
This is neat, but I’d note one thing: It will only test for integer constant expression if the *integer* part is known. You can’t use a pointer for `x`, for example, because the multiplication by `0L` would be bogus.
This is the errors I'm getting when I compile: mopsolver.c: In function ‘read_maze’: mopsolver.c:178:20: error: subscripted value is neither array nor pointer nor vector while(read1[i] != '\n') { ^ mopsolver.c:190:24: warning: assignment makes pointer from integer without a cast [-Wint-conversion] maze-&gt;array[x] = read2; ^ As for what I think they mean, I know that it's because I'm trying to do something that isn't possible. I now know that read2 will be a ssize_t, so trying to set an array equal to it obviously isn't going to work. The first one where I'm trying to do a check for newline, I know that I want to index the line character by character, but what I currently have isn't correct. Aren't the lines getting stored somewhere? If I wanted to access the line, would I do buffer? I know something is getting stored somehow, I just don't know what to access to use it and what to do to accomplish what I want to do.
I managed to get a procmon log of it failing, and there are two subsequent SHARING VIOLATION events of ld.exe trying to access the executable. How do I get procmon to tell me what other processes had the handle at that point? There's some QueryOpen events from explorer.exe and dllhost.exe before it, but AFAIK those shouldn't be causing a problem.
I understood it like so that if x is an ICE it is determined by the compiler that this evaluates to NULL so the "if one of the branches of the ternary is NULL, use the type of the other one" kicks in. Otherwise it cannot be determined as 0, thus the compiler uses just sees a choice between a `void*` and `int*` and uses `void*` etc.
Just turn in diff. After editing the module headers.
&gt; When x is an ICE this will multiply out to 0, otherwise effectively nothing happens This is not true in any sense; the rules of arithmetic are the same for ICEs and non-ICEs. What happens is that the result of the multiplication would be 0L for both ICEs and non-ICEs; with the result being an ICE if and only if `x` was.
That does help, thank you so much! I think I understand what you mean and removed that loop in create_maze(). In read_maze, I removed the first loop because apparently I can only read from stdin once so the approach I had wouldn't work. This is what I currently have, but I'm still stumped because I'm not sure how I'd determine the dimensions to initialize the maze with. Also, I don't know how I'd access and set the characters in the line to the corresponding spot in the maze. char* buf = NULL; size_t len = 0; ssize_t read; char *line = calloc(1000, sizeof(char *)); // don't know don't know # int x = 0; // initialize maze while((read = getline(&amp;buf, &amp;len, file)) &gt; 0) { maze-&gt;array[x] = line; x++; } return maze;
Not mentioned yet on this thread: * It relies on a non-standard GNU extension that `sizeof(void)` exists and differs from `sizeof(int)`. In ISO C `sizeof(void)` is a constraint violation, and the macro must generate a diagnostic if used with an ICE. [Portable version discussion here](https://stackoverflow.com/questions/49480442/detecting-integer-constant-expressions-in-macros) 
Yeah, my wording for this wasn't great, which is why I footnoted it as a "gross oversimplification," but I also didn't want to detract from the main mechanism. Thank you for the clarification though!
I think the kernel uses `__builtin_constant_p` elsewhere for this, so I really have no idea why this macro exists.
The whole sysinternas suite is amazing for Windows. SHARING_VIOLATION means something has opened a handle to it with a permission like FILE_SHARE_READ and then ld.exe is asking for FILE_SHARE_WRITE which isn't allowed. Just to check, when using Process Explorer there was no handle to it open before you built? You should be able to see the original thing that's opening a handle to it in your log somewhere? If you post the log somewhere (strip sensitive info if there's any) and I can have a look over it.
&gt;Just to check, when using Process Explorer there was no handle to it open before you built? That's exactly what makes this so elusive, the conflict only happens for a really brief moment, immediately afterwards ld.exe is able to delete the executable in response to its failure, and it also first generates it immediately beforehand (which it couldn't if there was a handle). Might be some obscure race condition within ld.exe itself or it and other MinGW components. I haven't checked explicitly every time, and maybe I will, but like I said if there was a handle beforehand then ld.exe would fail much earlier. &gt;You should be able to see the original thing that's opening a handle to it in your log somewhere? What kind of events would indicate the opening of a handle? QueryOpen?
Very clever code, demonstrating a mastery of overly complex macros. Also as portable as the rock of Gibraltar, as easy to follow as Olmec and absolutely useless in production code that may be maintained by others. 
The operation will be CreateFile (which is the Windows API used)
the first guy was trying to show off no doubt. AhAHAHAH
I am sure you are correct, and it is why I am happy that somebody as good as Linus is in charge. I know I could not do what he does, and he does it in the full glare of the LKML!
Turn off active protection in the virus scanners and see if the problem goes away
The two CreateFile operations ld.exe chokes on attempt to get "Generic Read/Write" access, the one immediately after that succeeds only wants "Read Attributes, Delete", suggesting that the problem is the "Write" part. Looking for earlier CreateFile operations that don't permit "Write" in their share modes I only find ones from explorer.exe, though there's also CloseFile operations after. There's tons of other explorer.exe operations on the executable right before the ld.exe ones that fail too. I've read online that explorer.exe can be a bit too proactive when it comes to reading metadata or even analyzing entire file contents. Apparently there's issues with .wav files and some component of explorer.exe called "PropertyHandlers", which also acts on .exe files. I'd have to go edit some registry entries to turn this off, might try that or have gcc output into a non-exe file as a workaround.
I dislike this kind of code, it really doesn't aid readability...
yeah I was being a little facetious, the the point being, you can't really be sure what hardware you're running on (at least not without a lot of pain...) so... unrolling loops (for example) could have a very different effect depending on the number of iterations and the type of hardware, all too often you can be in danger of making things worse, if you really want to optimise leave it till late in the game, and profile the optimised code first make test functions that implement different optimisation to see what methods yield the best results, of course you are well to test on at least AMD / Intel and Arm cpu's and if possible with 32/64bit processors... As well as optimising code, look for different types of algorithms, maybe you can kill two birds with one stone...
&gt; I am afraid of choosing one that may be too difficult for a programming newbie like me. That fear is completely unwarranted, no matter what project you take on, it's going to require you to learn new things, that's kinda the whole point. you'll grow with the project you choose. Which leads me to my point; what is your goal? Why did you spend 2 months reading a book bout programming? what are you hoping to accomplish? Whatever your answer is to those 3 questions, is what your project should be.
You're absolutely right. I have decided I'm going to build a chess engine. I found a guide that goes through every step of building something like that. Would you recommend I use it or learn by myself, from my own mistakes? 
Design a data structure to represent a board. Real engines use bitboards so they can do clever tricks, but for a first time implementation, stick with something simple and straightforward. It could be almost as simple as an 8x8 array of pieces. Keep in mind you'll also need to track a few additional pieces of information, such as whether or not the king and rooks moved (for castling purposes). Next design a data structure to represent a single move given a board state. It could be as simple as two board coordinates, though keep in mind the special cases: en passant, castling, and pawn promotion. Next write a function that, given a board and a coordinate, enumerates all the moves for the piece at that location. This is where you code the rules for each kind of piece. You can then use this function to define another function that, given a board state, enumerates all the moves for a given player. From there you have enough to enforce the rules for a game between two players. Each player must pick from one of the moves generated by the move enumeration function. For a first pass at an AI, code up a minimax routine. Then add alpha-beta pruning to speed it up. You'll need a board heuristic to evaluate the bottom of the search tree. You can start by adding up all the material, but a better heuristic will also account for positioning: king exposure, preferred placement towards the center, number of available moves, etc. 
I mean you're being a smartass for no reason, but I'll ignore that. The entire point is for learning on your own, if you're just following someone elses tutorial you're not really learning why it actually works, you're just piecing together someone elses code.
u/skeeto please cover up the case file upon your mom's rape be safe bro its time to find u 
What’s the context for needing this? What is it used for?
It was a suggestion to be added, but based on the tone Linus uses in his response it is likely nothing more than an interesting hack.
I would go so far as to say that nobody *needs* it. It was a suggested addition to the Linux Kernel that will likely never be used as it is less than portable and more than oblique. u/VincentDankGogh mentions lower in the thread that there is already a working method in the kernel which renders this particular macro obsolete. Mostly it's been floating around due to the heavy critique Linus gives it.
Okay... lemme’ rephrase, what would you use it for? What’s the existing method used for?
Since you're freeing it in the same function, make the struct a local variable
True. 
Apparently you didn't add getch() at the end to pause the script and see the results. But the main error is at the following lines of code: while(n &gt; 0 &amp; n &lt; 0) { printEven(n); } This makes the program keep printing the even numbers forever, since there's nothing in the loop that changes n. Here's the correct code: #include &lt;stdio.h&gt; void printEven(int n) { printf("\nEven numbers between 0 and %d: ", n); if (n &gt;= 2) { int i = 2; do { printf("%d ", i); i += 2; } while (i &lt;= n); } else if (n &lt;= -2) { int i = -2; do { printf("%d ", i); i -= 2; } while (i &gt;= n); } else printf("Nothing to print.\n"); } int main() { int n; while (n&gt;0 &amp; n&lt;0) do { printf("Enter an integer: "); scanf("%d", &amp;n); if (n=0) break; printEven(n); } printf("Bye.\n"); getch(); return 0; }
My bad. I'm actually not 100% sure. There are several [contexts](http://en.cppreference.com/w/c/language/constant_expression#Integer_constant_expression) where an ICE is necessary, but I'm having trouble thinking of a scenario where you might not know if a given symbol would evaluate accordingly. I suppose if you have a value for an allocation size that may either be written as a `#define` or within a variable, checking whether or not it's an ICE could determine if it's best used for allocation via the stack or the heap. Even that seems kinda far-fetched though, because you'd know before compilation, but it could be a lazy workaround. Anybody got something better? I'm at a loss.
An even number is by definition a number that is divisible by 2 (plus 0). So just loop from X to Y (the start and end points in the number space), and have an if condition in there that uses `X % 2 == 0` (the percent symbol here is the modulus operator, basically it returns the remainder after dividing X by 2) If the result of the modulo operator is 0, your number is even, if it's 1, it's odd.
fpga_send() and fpga_recv() have memory leaks because you assign a different value to tinfo_send/tinfo_recv *after* assigning calloc()'s returned value to them. And if whatever arg is in those functions isn't an address that was returned by malloc or friends, trying to free it is going to give you a bad time. So I supppose getting rid of the allocation is a good thing.
EOF can't be in a file at all. Except maybe if you're using CP/M. https://latedev.wordpress.com/2012/12/04/all-about-eof/ 
Just to say that I regularly use mingw-w64 on Windows 10, and have never ever experienced this kind of issue when linking. I'm on the latest releases (gcc 7.3.0, ld 2.30). I use MSYS2 (in Mingw-w64 64 bit mode) as my shell, and GNU Make to build. If there *is* an obscure race condition in ld.exe, I've certainly never witnessed it myself (in a couple of years of using mingw-w64 for personal projects).
You could use open and close instead of fopen and fclose, read instead of fgets. In that case it will be better to implement a function that read file byte by byte and put it in buffer until '\n' or EOF appear. And then returns buffer as string. So, it will be your implementation of fgets.
I will try that, thanks!
doubly linked list, implement your own, useful practice and you may well find yourself using it later down the road...
I don't really expect this to turn out to be a race condition within MinGW itself, it would've been fixed by now if that was the case, so don't worry. More likely some interaction with Windows. Unfortunately I've had the exact opposite experience than you, as this issue has existed for as long as I've used MinGW (well over a year by now).
You dont need allocate memory for tinfo_send. Just point tinfo_send to arg.
This post doesn't seem to be about C programming. Removed as off topic.
Have you seen [this](https://superuser.com/questions/361028/windows-7-access-denied-to-executables-by-what) thread here? I was going to suggest that maybe this is a Windows 7 issue only, but realised that I also use a Win7 laptop and have never seen the issue there either.
If I'm reading this right, wouldn't this try to link the old .o target with itself? Assuming that `*` is finding all files in that subdirectory, including `res.o`? [This](http://forums.codeblocks.org/index.php/topic,15047.msg116940.html#msg116940) post is interesting - it sounds a bit like what you're describing. The insight being that ld fails and deletes its target because there's an issue with one of its inputs (in this case it was because a directory had been erroneously passed, but it could also presumably be a permissions issue); then collect2 fails because the target doesn't exist.
You got downvoted for speaking the truth lol.
That post describes something consistent rather than random, right? Suppose the randomness could be in the generation of `res.o` which then causes the issue in that post to occur. Also I stumbled upon the Application Experience "fix" about half a year ago, IIRC I've had the service enabled eversince but it hasn't corrected the issue. Gonna take some time to look into all the possibilities, not to mention that I may have already fixed it with what I'm currently trying.
You are using `char` instead of `int` for what you are storing the read variable in: char c; while( (c = fgetc( in )) != EOF ) ... EOF isn't a valid `char`.
I would start by picking an implementation. I hear good things about [Open MPI](https://en.wikipedia.org/wiki/Open_MPI). In general I would say you could split the matrix up evenly among machines in your cluster, and further split it up among logical cores with `pthreads`. You may want to consider changing `old_matrix` to `const` since you don't need to write to it. You'll also want to change `ROWS` and `COLS` to parameters that you pass to the function so you can reuse the function within each thread and properly slice up the matrix. Bear in mind, I've never used Open MPI or other implementations of MPI, so I could be wrong, but it's been 10 hours and I feel like you'd rather get something instead of being completely ignored.
okay okay so he can code and make it readable and he's helped make a kernel that I like, but genius? that's a little strong isn't it ?
What qualifies as genius for you?
Can you provide actual differing packets? Say from byte position N onwards and what the failing CRC for these pairwise packets is?
You're missing the point, there are no "geniuses". It is kinda feels like the OP is claiming Linus is a christian or something because he isn't in the "iamverysmart" camp that would rather listen to their own voice than to focus on issues at hand. Linus has been coding since he was a kid and is respected his vast _experience_. If he has any unique abilities, it would be his ability to pick the perfect mascot, tell people off and for keeping it real.
Oh I see, I will try to implement it :) thanks!
For me, it can mean: * either people with super-abilities (like two levels above most gifted people), * or people who (thanks to one of those super-abilities or not) managed to make a huge breakthrough (conceptual/theoretical, or advanced comprehension of the surrounding world) in a domain, generally scientific but not always. They went in an uncharted territory, they progressed far into it, and they returned with a brand new crystal clear map. Replicating a UNIX kernel doesn't belong there, IMO. (Neither does building an umpteenth VCS, probably the less original and the less well thought and designed of all VCS in the last 15 years, built by roughly patching up ad-hoc bits and parts as different needs appeared.) Don't get me wrong, I've been using Linux since 1995, and I do respect the guy. It's just that IMO the word genius is nowadays over-used, and shouldn't apply to him.
&gt;As for why I'm even doing this, in terms of efficiency and memory usage this seems like the best option for what I'm trying to do. If you struggle with such a basic concept as treating a 1D array as a 2D array then forget about optimizing and do the simplest thing. That said, access it like this: `[y * width + x]`
Wouldn't it be [x * width + y]? And how about the other 3 neighbors (wouldn't that only find one)?
`[y * width + x]` is the center `[y * width + (x - 1)]` is the left neighbor `[y * width + (x + 1)]` is the right neighbor `[(y - 1) * width + x]` is the bottom neighbor `[(y + 1) * width + x]` is the bottom neighbor Don't forget for corner and edge cases
Would you mind providing an example of how this works? I'm sorry, I'm just having a hard time understanding the computation.
sorry while both are quite workable solutions neither is indicative of genius there is no blinding leap into a new paradigm, simply a decent re-implementation of ideas that came before... 
yeah, you get what I mean....
I'm genuinely not trying to start shit, but is there a VCS you recommend over git? What notable features does your VCS of choice have over git and how do these make it superior?
there are `width` items in each row, so to get to the correct row you do `y * width` then to get the correct item in that row just add on the `x`. Then you can check the values surrounding \(x, y\) by just substituting `x` wit`h x +` 1 an`d x -` 1, and substitutin`g` y wit`h y +` 1 an`d y -` 1. You just have to be careful you don't check to the left of a point wher`e x ==` 0, to the right of a point wher`e x == width -` 1, above a point wher`e y ==` 0 or below a point wher`e y == height -` 1.
I am just not getting this. I tried to do this by hand with the same array I provided as an example above. For 1,2 on the 2D array, doing what I was instructed gave me 8 (2,0), 10 (2,2), 5 (1,1) and 13 (3,1) for left, right, bottom and top respectively (On the 1D array). However, 10 (what I got for left) would be the bottom and 5 (what I got for bottom) would be left. The other two just aren't even close. I'm just very confused.
2 \* 4 \+ 1 = 9 0 \* 4 \+ 2 = 2 2 \* 4 \+ 2 = 10 1 \* 4 \+ 1 = 5 1 \* 4 \+ 3 = 7
I today joined reddit, sorry if I made something bad.
Did you do x times width plus y for each (for that the x and y of that neighbor)?
He wrote the difinitive industry standard VCS that has created a cottage industry around it and he did it in 5 days. He ported the unix OS to x86 that jump started a revolution. I would label him a genius.
&gt; in terms of efficiency and memory usage this seems like the best option for what I'm trying to do. all your doing is duplicating by hand what c would do automatically for you if you used a 2d array. see http://www.drdobbs.com/the-new-cwhy-variable-length-arrays/184401444
Welcome to the mad house that is one of the man forums on the Internet. What I said was meant to inform, not to criticise. I hope the link provided the answer you sought. 
I think the standard `timeit` utility already does this for you. Nice project though!
What if in parallel to the queue you were to have a 2D matrix of ints that stored the length of the path? This would do 2 things for you: first it would help keep track of already traversed cells (i.e. a cell that's still 0 wouldn't have been traversed) and at the very end, when you get the solution, you should also have the number for shortest path. A direct result of BFS is supposed to be only the shortest path. You shouldn't be getting anything else.
Didn't know that exist. But I just tried it on my Windows 7 system and it didn't work. According [this](https://stackoverflow.com/questions/673523/how-do-i-measure-execution-time-of-a-command-on-the-windows-command-line) I need the Windows Server 2003 Resource Kit.
&gt;I have tried that at a few different times, but I am having issues with my code getting correct output from BFS. As of the code I posted, I am getting… what appears to just be a bunch of the goal node as a result of my BFS. I have earlier revisions where I received a map of all reachable spaces. I am thinking I probably have some small error in the way my queue's working, or in my BFS setup, that I just have not noticed. 
Can a book have more than one last page?
Your queue implementation seems to be reasonable. As for the BFS in solve, I am not sure. That's not the same approach I'd take. Not to say it's wrong, I just couldn't tell you what would be wrong.
Obviously not. But my getc() was stopping halfway through the file. 
Hmm... Any idea why that may be? This is how I'm running it: cat empty4x4 | ./mopsolver -m I also ran it with the -i flag and a file to actually take in a file and it seems to work for that. But why would it get NULL when it's stdin?
Each time you enqueue a new position, mark the direction from which you came. When you reach the end, follow these breadcrumbs from that position back to the start and that's your shortest path.
 FILE * file = fopen("filename_goes_here.file_ext_here", "w+"); [example here](https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm)
8 (2,0) 0 1 2 3 4 5 6 7 8 _ _ _ _ _ _ _ 10 (2,2) 0 1 2 3 4 5 6 7 8 9 10_ _ _ _ _ 
I thought you couldn't use fopen on stdin?
(2,0) with a witdh of 4. so y is 0 and x is 2. so y * width + x = 2 0 1 2 _ _ _ _ _ _ _ _ _ _ _ _ _ and counting that far into the array gets us to (0, 2) (where x goes to right and y goes down), (2,2) gives 2*4+2 = 10 0 1 2 3 4 5 6 7 8 9 10_ _ _ _ _ which again finds us at (2,2), where (0,) is top left.
* getline is a stream. * it stores what it has read from the stream in to *buf* up to size *len*. * *file* is supposed to be a file object that has is an I/O stream (if i remember correctly... correct me if i am wrong) * *file* points to nothing, *getline* fails to read file and attempts to read an invalid section of memory * seg fault
But why is file nothing? This is in a function where I provide a FILE* file. So file should be defined (it's set to stdin by default in my main). I am an idiot for not including at least the function prototype, so my bad.
according to the given context, i can't tell you why. nobody can, we will all come to the same conclusion.
You seem to have a comma between the square brackets and parentheses of your link; remove it to have the link appear as you intended. Like [this](https://stackoverflow.com/questions/673523/how-do-i-measure-execution-time-of-a-command-on-the-windows-command-line).
Fixed. Thanks :)
Windows Powershell has `Measure-Command` installed by default. Regardless this is a cool project! Great work.
try writing up a driver that does what you expect it to do first. make sure it works the way you expect. once it does, you can do a comparison and see where you went wrong. that's what i used to do when i was still coding c and got stuck. all i can say is pointers are tricky bastards lol. you do have a clue given to you from gdb... 52 iogetdelim.c: No such file or directory. this is trying to tell you, "hey! you! i'm looking for a reference, but it doesn't exist..."...tbh, i couldn't tell you why. there's not enough info here. all i can do is assume that there's a function reference that's missing.
https://pastebin.com/9r57AnvQ There's still print statements I tried to use for debugging. I really didn't want to post it because it's a lot of code. I've spent hours trying to get this program to work and I have no idea what to do at this point. I tried gdb, here, google, etc.
Assembly varies depending on your machine's architecture. This *looks* like x86, but I'm not sure since I've only ever studied ARM. Could you please specify which assembly language you are studying?
I believe we are dealing with x86, yeah 
&gt; (file=0x0) unfortunately, i don't have time to do a full code review right now since I'm supposed to be doing other things (i was being lazy by looking at reddit lol)... (your code is beautiful btw) from what i can see, your program takes formal args from stdin from the prompt (looks like a cli tool)... uses getopt to sort through the programs options, and passes opt to a switch. so i would assume, calling it would look something like # assuming this is input ./yourProg -i filename and # assuming this is output ./yourProg -o filename i can tell you this though... set a breakpoint as the beginning of your while loop, feed it minimal args so youre not stepping through a ton of needless loops... while debugging with gdb, set your breakpoints to center around this bit...that way you can inspect your opt value when it hits these case statements... validate that your optarg values are valid and what you'd expect. case 'i': // read maze from file inFile = fopen(optarg, "r"); case 'o': // write maze to file outFile = fopen(optarg, "w"); gdb has an option that will allow you feed it arguments before you run the program... feed it the appropriate args and you should isolate your issue.
You're missing a lot of `break;`s in the `switch(opt)` block.
No idea why I'm getting a segfault in FreeCAD. FML.
I see you know about idiomatic. Is it ok to "cat linux_livecd.iso &gt; /dev/sdx" instead of dd? It always works...
You said it defaults to reading from stdin? If you don't specify a file, does the readline on stdin work or is that what's causing the segfault? If reading from stdin doesn't work, try doing a one-off compile and run with line 265 changed to: Maze* maze = read_maze(stdin); See if that works. If it works, your problem is with assigning file pointers. If I misunderstood you, I'm sorry.
Yes the "C" register on x86 (1-byte: CL, 2-byte: CX, 4-byte ECX, 8-byte RCX) is traditionally used as the counter register for loops. In fact there's even an x86 LOOP instruction prefix where the programmer loads the desired count ("n") into CL/CX/ECX/RCX and then calls LOOP *desired instruction* and *desired instruction* runs "n" times as CX is automatically decremented each time.
I see. So it is decremented each time. Is that why cl's value is checked against zero(test %cl, %cl)? Is cl automatically being decremented in this case? If so, do we know what value it starts at?
My TLDR refers to the sentence right after. It is a TLDR for the long block of text you just referred to. I thought that was self explanatory. I used it in my main question too. 
There should be a load or move operation that sets cl to the desired number of iterations.
It's not possible, sorry.
"stdin" is a macro that expands to a FILE* type. So, in order to pipe your file in as described, just replace your FILE* variable "file" with "stdin" in the getline call (and make sure you've included stdio.h where stdin is defined). Do a "man stdio.h" in your shell or in google to read up on it.
C isn't inherently object oriented, so to get OOP principles like calling objects, constructors, etc. you gotta do it yourself. So, you gotta pass in that first parameter the way you are. Sorry dude
That is a super cool illustration!
It's best to not compare C to OOP languages when implementing OOP concepts. Passing the struct as the first argument to a function is the "C-way" and is functionally no different than what you are asking. I also wouldn't even bother with function pointers within the struct if the only reason is for aesthetics. SomeFunction(s, 4); Vs s.SomeFunction(s,4); The first example is much cleaner. 
Even with C++ and a pointer to a member function, you still need to prove the object that will provide the "this" pointer, and the syntax is clunky.
see this [http://c\-for\-dummies.com/blog/?p=1112](http://c-for-dummies.com/blog/?p=1112)
&gt;Also, is there an easy way to help determine whether an argument is being passed in or not? I had to guess what my input was. I know rdi rsi etc are traditionally used for arguments, but are they ever used to store local variables? You can tell that RDI is a parameter here, as we use its value without first setting it. (Plus of course the usual calling convention that it's the first function argument.) Think I'd need to see the assembly in Intel syntax (rather than the weird AT&amp;T syntax that GNU tools default to) to get my head round it. 
The OP might be interested in Schreiner's book "[Object-oriented Programming in ANSI-C](https://www.cs.rit.edu/~ats/books/ooc.pdf)" [PDF].
^* hacked together in Perl
It's npt more recommendable maybe, but git has no new "ideas" or "concepts"
&gt; Also, is there an easy way to help determine whether an argument is being passed in or not? I had to guess what my input was. I know rdi rsi etc are traditionally used for arguments, but are they ever used to store local variables? Look up the [Sys-V ABI for x86-64](https://www.uclibc.org/docs/psABI-x86_64.pdf)—that dictates what GCC will do for argument passing etc. on Linux; Windows has a rather different one. W.r.t. using them for locals, sure if the original argument value isn’t needed any more. (Just like you can reassign argument variables in C, should you be so inclined.)
No! http://man7.org/linux/man-pages/man3/getline.3.html does a better job in explaining what getline does behind your back.
You need to put breaks into your switch statement. case 1: x--; break; case 2: x++; break; Otherwise, whenever you roll a 1, you jump to case 1 and execute x--; x++; y--; y++; and end up in the same place. Whereas when you roll a 2, you increment x. 3 has no effect. 4 increments y.
Ah! Silly me. Dumb question. Is my code and formatting at least readable?
It's largely okay, but your indentation and curly brace style is giving me eye cancer. But that's _also_ okay, as long as you're happy with it and are consistent!
While there is some merit to borrowing OOP concepts when writing C, I'd encourage you to try and be more flexible and to adopt the style and convention of the language. It'd be like if you were learning German and you insisted on using English-like sentence structure. Fully commit! Don't write C with a Java accent. ;)
What bothers you about it, other than it's not K&amp;R style?
There's generally two forms for indentation. void same_line_brace() { if(something) { // ... } } or void next_line_brace() { { if(something) { // ... } } Then there is the perverse and not often seen GNU style. void gnu_style() { if(something) { // ... } } GNU style is strange. No on uses it, people expect one of the first two styles. And not only that, you seem to be using something else entirely. This effects readability of the code, in particular where you end braces are and what they match to. In general your style just looks... wrong. Syntactically fine, stylistically strange.
This is the way to do it and in C it looks much cleaner in my opinion. Just wanted to add that in addition to all the boilerplate you have to write and the "uncleaniness" of it all, you're also bloating your struct's memory footprint with unnecessary pointers. Each "instance" would have a pointer to each "method", which is redundant.
The value of having the function pointer on the struct is that it allows for dynamic polymorphism, behaving as a virtual function.
The last example in that is outright wrong.
When I've done this in the past, I've created a wrapper "method" to avoid the redundancy in each call site: static inline int SomeStruct_y(struct SomeStruct *s, const int z) { return s-&gt;y(s, z); } Usage: SomeStruct_y(s, 4); This doesn't look like a typical, single dispatch method call anymore, though. There is *one* convoluted way I can imagine eliminating the explicit "this" argument. You really shouldn't do this in practice and I'm only sharing it because it's interesting: [turn each method into a closure](http://nullprogram.com/blog/2017/01/08/). The closure is really just a run-time constructed trampoline function that injects "this" as an argument for the real function. This has a lot of overhead, though. 
Shitty Garbage! you are such a loser!
Garbage! 
C++ is off topic in this subreddit, please post C++ question elsewhere, e.g. in /r/cppquestions.
`char` is a datatype defined as one byte. You use a `char` typed variable when you need to represent values between -128 and 127. You can use an `unsigned char` to represent values between 0 and 255.
Thanks it really helped me
Sorry, I made a typo. It's /r/cpp_questions.
If each different instance might need to point to a different function, this makes sense. E.g the application can select from a number of different callbacks to use when initialising the struct. 
Tnx I asked
That's true, but that's useful only in a very specific use-case. Op was asking how to make his C programming more "OOP-like" which implies following this pattern for all structs, which would be a really bad practice.
no
That looks like homework, not a project. It's probably your homework.. 
but why would you not do someones homework for them, really how mean....
 * You don't need to export LD_LIBRARY_PATH at build time. * Assuming that INCLUDE_PATH and LIBRARY_PATH and EXE_NAME are set correctly: Linker flags always go the very end of the gcc invocation: `gcc -Wall -I$(INCLUDE_PATH) ./src/main.c -o bin/$(EXE_NAME) -L$(LIBRARY_PATH) -lhello`
Please repost your question as a self-post with the question as text. Nobody wants to read images of text.
I took another look at it this morning. My assembly is a little rusty and my "native" assembly language is MIPS R2000 from school. I'm not super fluent in x86-64 and haven't done assembly in a while other than asking my DSP compiler to generate assembler output to see how it's optimizing. I think the issue is is that the assembly isn't a very good word for word translation from C. I say that because it looks like a preamble statement's set of instructions was also similar to the main loop instructions and got reused to shrink code size. It also reuses/abuses %cl/%ecx/%rcx: %cl/%ecx is a data value and then it becomes an array index as %rcx. Usually %rbx gets used as the index value. I was assuming based on your commentary that it was a for loop. With that funny preamble, it looked more like a do {} while loop. As I looked into it more, I realized what it is. It's a search function designed to operate on ASCII "C" strings that are terminated by a NULL byte (0x00, '\0'). The 0x61 isn't a counter, it's ASCII character 'a.' The function is checking first if it's been passed an empty string and then begins iterating through the string (byte array) looking for 'a' and also checking to see if it reached the end of the string.
Thank you that really helped
OK sorry will keep in mind next time 
You forgot to put it in h
whats wrong with the examples? \(apart from the disgusting `return(0);`?\)
&gt; Maze* maze = create_maze(0, 0); [From an previous post](https://pastebin.com/9r57AnvQ): &gt; Maze* create_maze(size_t height, size_t length) { &gt; Maze* maze = malloc(sizeof(Maze)); &gt; int * a = malloc(sizeof(int) * height * length); // !!! malloc(0) &gt; maze-&gt;array = a; &gt; maze-&gt;rows = length; &gt; maze-&gt;cols = height; &gt; return maze; &gt; } So first, you're having undefined behavior since trying to allocate `0` bytes which is not valid. &gt; maze = realloc(maze, maze-&gt;rows * maze-&gt;cols); Later on, you `realloc` the `maze`. You probably wanted to resize the array, not the `maze` structure itself. &gt; maze-&gt;array[counter] = atoi(&amp;line[i]); This is where it probably crashes, since the `array` member is not valid.
&gt; As for when I initially create the array, what should I be doing for that? Should it be 1 and 1? You can, or you can also just use `NULL`. `realloc(NULL, num)` is basically the same as `malloc(num)`.
Alright, thank you so much for pointing that out! The program can run now, but it doesn't seem to be parsing correctly. I used the example I provided, but this is the output I get: 0 0 0 0 0 No solution. So it has one extra row but only 1 of the 4 columns. Could that have to do with what you pointed out for how I calculate the width?
After getting the line, the buffer contains "0 0 0 0\n", which is 8 characters. Divided by 2 is `4`, which seems to be correct for the column count. &gt; char *line = strtok(buf, " "); &gt; for(int i = 0; i &lt; strlen(line); i++) { &gt; maze-&gt;array[counter] = atoi(&amp;line[i]); &gt; counter++; &gt; } `strtok` returns `buf` but with the twist that the first space is changed to a `\0` (so you don't read past it). This is the intended usage of `strtok`: /* https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm */ token = strtok(str, s); while( token != NULL ) { /* Do something with token */ token = strtok(NULL, s); } If we continue with your loop, `strlen(line)` would return `1`, so the code in the loop is only being executed once per line. In `atoi(&amp;line[i])`, `&amp;line[i]` is the same as `line + i` (which in this case is also the same as just `line` since `i` is `0`) Also I am not so sure what you wanted to do in the loop. Try the correct `strtok` loop first. Some other stuff: - You never check if any of the allocation failed - You never `free` the buffer `getline` returns (from the [manpage](http://man7.org/linux/man-pages/man3/getline.3.html): "If `*lineptr` is set to `NULL` and `*n` is set `0` before the call, then `getline()` will allocate a buffer for storing the line. This buffer should be freed by the user program even if `getline()` failed.")
I was looking at your code last night (from your previous post) and I'm wondering if it's a problem with your call to atoi(char *). I think you want to convert a single ASCII character to an int BUT atoi operates on null terminated C strings so if the line is "0 0 0 0\n" then atoi(&amp;line[i]) passes the full string when i =0 and the last three characters + spaces and line break when i = 2. you may need to do: char tmp[2] = "0"; for(...) { tmp = line[i]; atoi(tmp);
Well having the return type on its own line as shown in the GNU style example is actually fairly common, unlike the weird braces indent. /* useful to avoid long lines when having qualifiers, attributes, long type names etc... * in this example the function is declared static as it is used only in that file */ static void print_stuff (int bleh) { printf("%d\n", }
I tried to follow the correct use of strtok as you suggested as the following: int i = 0; char *line = strtok(buf, " "); while(line != NULL) { maze-&gt;array[counter] = atoi(line + i); counter++; i++; line = strtok(NULL, " "); } It now core dumps and spews out a ton of memory information with an issue with the realloc. I'm not sure if I followed what was said correctly or if this is something else. Someone else mentioned it could be atoi because although I'm looking for a single character atoi expected null terminated C strings. I get the feeling that I want to combine what you both said; use the while loop and stuff but also modify my use of atoi so that's right. I just don't know how because what was suggested for atoi was with a for loop.
As I said in my comment above, I think that you're right but I just don't know how that would work with a while. Or do I not even need to change what I have to a while at all? I'm also not quite sure why you have tmp[2] set to that or what that means. 
Why do you need `i`? 
Well it's as correct as it is wrong. If you write poor C code every day it's not going to help in any way. I'm fairly positive it's not what you meant, so I'll point to [another comment](https://www.reddit.com/r/C_Programming/comments/85hykf/how_can_i_pull_my_grade_up_for_my_c_programming/dvxm9wk/) that has some good links to practice daily.
Not related to your problem(s), but you do not need a double pointer for `file`: Maze* read_maze(FILE *file) { /* ... */ while((read = getline(&amp;buf, &amp;len, file)) &gt; 0) { 
 maze = realloc(maze, maze-&gt;rows * maze-&gt;cols); You are reallocating a space of `maze-&gt;rows * maze-&gt;cols` **BYTES**. I suppose that's not what you want. If I read the bits you've written in other comments: int * a = malloc(sizeof(int) * height * length); // !!! malloc(0) maze-&gt;array = a; and: maze-&gt;array = realloc(maze-&gt;array, maze-&gt;rows * maze-&gt;cols); See the difference between both? In the second case (`realloc`), you lack the size (in bytes) of each element: `sizeof(int)`.
Yep, I modified it to take in a double. Thank you for pointing that out! :)
Do you mean to make it this? maze-&gt;array = realloc(maze-&gt;array, sizeof(int) * maze-&gt;rows * maze-&gt;cols); 
Order matters. Doesn't seem like it should (all the same address space, right??). Cant' tell you how many linker problems I resolved by swapping around -l arguments.
Yes: all the `*alloc()` functions want a size in bytes, so you need to pass *(size of one element in bytes) x (number of elements),* hence the `sizeof(int)` for the "size of one element in bytes".
tmp[2] = "0"; is allocating a character string that's two bytes long and preinitializing it to "0" which is really {'0', '\0'} Remember a C string ends with a NULL (0x00 or '\0') byte and is one character longer than the number of printable characters in the string. And actually it should probably be tmp[0] = line[i]; If you post a few sample matrix files, I'll play with it when I get home tonight. 
&gt; I thought I needed that to get what's next. Like i + 1 would be what's after the first character. Idk. `line = strtok(NULL, " ");` returns the next "token", or in your case, a number (separated by spaces). So `line` would point to e. g. `"0"`, thus doing `line + i` on the second iteration (where `i` is `1`), it just points to an empty string, and after more iterations it would point somewhere outside the string.
Alright, so I got it to work (I think). This is the loop I now have: char *line = strtok(buf, " "); for(int i = 0; i &lt; maze-&gt;cols; i++) { maze-&gt;array[counter] = strtol(line + i, NULL, 10); counter++; line = strtok(NULL, " "); } I think there's just one last problem and that's the newlines. I get a weird number in my output and I think that it's related: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 130785 0 No solution. It's very strange idk how it's getting an entire extra row and that number.
This subreddit exists to discuss the C programming language, and while your specs could be fulfilled in C, this program likely exists in a different language. What you're looking for sounds like a web scraper and automation tool. These are typically written with Mechanize and/or BeautifulSoup, and in languages like Perl or Python. Things that you should be aware of when using these tools are your website's rules pertaining to the use of these tools, because if you're not careful you will be banned. Information can be found usually via robots.txt *if* the site allows automation at all. If they don't you'll have to be clever with how often and regularly your bot checks player availability. If I were you I would redirect this question to a fantasy sports subreddit, because I'm sure someone out there has a tool for some site, possibly even yours. Good luck and have fun.
I just did away with atoi apparently it causes more trouble than it's worth lol. I went with strtol instead and it seems to mostly work. I still get wonky stuff (output in another comment I made). If you'd still be down to playing around with matrix files, I'd really appreciate that! Honestly, they are any # of rows and columns and are 0's or 1's separated by spaces. Here's a few samples: File 1 (Name not included in actual file) 0 1 0 0 0 0 1 0 0 0 1 0 1 0 0 0 File 2 0 0 0 0 0 1 1 0 0 0 0 0 File 3 1 1 1 1 1 1 1 1 1 1 1 1 Honestly, the layout or specific contents (they can really be any single digit #) don't matter, my concern is really reading the files at this point.
Thanks. Does 0 indicate a clear path in the maze and 1 a blocked path? Did you make any changes to your pastebin'ed code from last night like add *break* statements to the switch statement? Also turn on all warnings (e.g. -Wall -pedantic if using gcc). I know you used '==' where you meant '=' last night. The warnings catch this.
&gt; **EDIT:** Just looked it up, and fantrax allows you to play for cash, so they almost certainly don't allow you to do this, so be extra careful. The good news is that this means there's likely tools out there to do this for you. Heh, ain’t that the truth.
Ended up figuring it out. On the line scanf(" %c", &amp;ch); I was missing the space before the %c
If I were you, I would change the following aspects: 1) Remove the do...while. 2) Create a separate function which calculates the hypotenus 3) In main, I would structure it like this: YourFunction(); //You also scan the values here Scan Ch; While(Ch condition to CALCULATE AGAIN){ YourFunction(); Scan Ch; } return 0; Basically, you calculate the result once when entering the app, and then you will do the same thing while your Ch is ‘y’ or ‘Y’. This is why after calculating the second time (if you need to), you also need to scan another Ch. If your Ch is anything else than the respective chars, your program will just return 0 and end. That’s my way of doing it, although maybe there are better options. :)
Because some languages really are better than others at certain tasks. If he's working with sensor input, I agree that a browser scripting language isn't the right choice and something lower-level should be used.
You have sensors for which the manufacturer has provided drivers compatible with JavaScript? 
Just wait. At some point, JS will not be fast enough or won't be able to communicate with the hardware. At that point you will have your case. If, by any chance, this doesn't happen, be happy you didn't have to get dirty debugging segfaults.
I've used javascript + node to drive a robots around and it's fantastic. I made a 3d puppet version of my bot and used it to drive the real thing, with very little discernible latency. I used three.js and its curve generation code to do smooth interpolation of my animation keyframes to drive the servos... and the whole app took a couple days to write. If you are trying to make a self balancing robot, a drone, or something with REALLY hard realtime constraints, then by all means do some logic in C on the controller itself. But for slapping together interfaces or throwing together graphs and diagrams, 3d visualizations, etc. there is a HUGE amount of stuff you can do really easy with webbier tech. Not to mention with node in the mix, making things controlled over the web via websocket becomes pretty trivial. 
 I've gotten so much better. check this out: #include&lt;stdio.h&gt; int main() { char screwyou[] = ("no need to be such a fucking dickhead, asshole"); printf("%s", screwyou); return 0; } 
Lol, good work man
&gt; Then there is the perverse and not often seen GNU style. GNU formatting is an abomination that should be made illegal. 🤣
compile C to asm.js?
I'm a C guy through and through, but if you don't have any serious reason it needs to be written in C (interfacing with drivers etc.) then JS is actually pretty solid for robotics. JS has really easy to implement asynchronous IO and the EventEmitters in JS are super useful for robotics applications. That said if you were looking at releasing this project commercially or something like that you might want a compiled language like C...
Except I doubt there is a node module for his sensors. He might have to write the sensor control in C anyway and export that to node. Will the sensor misread due to timing from e.g. garbage collection? There are good reasons to code something like this in C. It wouldn't hurt to use both. JavaScript on the PC acting the control station, C on the ROV. That's how it would be done commercially. 
That's a really good strategy. But AFAIK there's no equivalent of ctypes for JS.
Many node modules are written in C. If there are no node modules for his sensors he can write them in C as a node addons. It used to be easy now it is even easier. https://hackernoon.com/n-api-and-getting-started-with-writing-c-addons-for-node-js-cf061b3eae75 If it were me on this project I would want to do it in javascript node too.
&gt; https://hackernoon.com/n-api-and-getting-started-with-writing-c-addons-for-node-js-cf061b3eae75 
Thanks :) Yeah, I also think that the first one is a lot cleaner but as I was looking for a method to solve this in a struct I had to go with this way. ^^ Im obviously going for the first way ^^
Interfacing with sensors is a pretty big deal for us, actually- right now we're relying on packages from npm, none of which seem to work well.
I'd rather debug that than doing control loops in JS, since it's designed to fail quietly rather than the very loud and obvious stuff C does.
Unfortunately no, we're relying on libraries by 3rd party hobbyists that don't work very well.
I don't plan on re-writing it if possible, but I plan on not being forced into writing in JS in the future. The issue is we're now facing walls caused by using JS- having to rely on NPM packages that aren't working, for example.
Underwater ROV, it moves around and completes tasks. We've got a surface station running on an Intel NUC, and the ROV running on Raspberry Pi. Not sure the JS library, and the stuff we have to interact with is a bunch of ESC's, sensors, etc.
So your team knows JavaScript and wants to use JavaScript. You've decided that some other language is better but have no argument as to why this is the case. While you were off pouting about it, the team did almost all of the work without you. Now you want a subreddit to justify your laziness... No dude... Just no. 
Hehe I applaud your initiative to double the cognitive load and halve the productivity. :)
You can use both. If you write the low level interface in C, you can pipe JS to the device to script the actions. If it isn't a real-time system, you don't *have* to do it in C. Having a simple interface that is exposed to the JS script is a very powerful tool for rapid development for simple systems.
^^^^^^^ 100% this. 
That's a very unbalanced point of view. Are you trying to hash something out?
&gt; My main issue with JS is that it's designed to fail quietly ... And C isn't? Functions in C don't throw errors, they return an error code which can easily be ignored. You need discipline to write robust programs in C. You can apply the same discipline to Javascript
If you cant figure an argument and you have access to the robot and code and sensors and brief and everything, why do you think that this subreddit will help? 
&gt;My main issue with JS is that it's designed to fail quietly and keep chugging along I don't think you have a firm enough grasp of javascript to make this claim. You're really just crying about type coercion, and if you actually understood how to use it and leverage it, it wouldn't be so scary. I've been coding JS for 20+ years, C for 25 and Assembly for 30+ years. I've done all kinds of sensor and robotics control with JS, and C, and assembly, but type coercion in JS has never been the boogeyman you think it is. 
movslq %edx, %rcx copies the value from edx to the lower part of rcx (i.e ecx) and sign extends to the top of rcx. movzbl (%rdi, %rcx, 1), %ecx - moves the byte value at memory location rdi + 1*rdi to lowest byte part of ecx (i.e cl) and zero extends to the rest of ecx. test %cl , %cl is just a way to check if cl is zero, test performs bitwise and on the operands and sets the zero-flag, parity flag and sign flag, that is zf, pf and sf respectively. The result is that zero flag is 1 if cl is zero. This usage of test is usually followed by either jne or je since they check the zero flag, je jumps if zero flag is set, and opposite for jne
Hah. C only fails loudly if you're *lucky*. If you're not, that out of bounds memory write silently corrupted all your data for the past week or somebody hijacked your program and is now running their own code in its place.
just don't try looking at the asm output when you do -O2 its mind boggling trying to follow what its doing sometimes!
Honestly I find it easiest to read at -Os. At -O0 it's very verbose with lots of spills, loads, and redundancy, which is good for the debugger but annoying to read as assembly. At -O3 it does crazy loop unrolling stuff and generates extra branches for special cases, making it the hardest to read. -Os hits a nice sweet spot. 
Just to be clear, when I said the test instructions sets zf,pf and sf, I mean't it sets it to the appropriate values according to the results of the and operation, not that it sets all to 1.
I have been using both- it makes sense for our control station, where we have a lot of visuals. The issue is that they want to use JS on the real-time stuff- PWM, etc.
You're welcome! Glad you found some insight.. right tool for the job, etc. etc. :) Good luck!
Sry last night i was mad cuz nothing i did worked and since it was the first time trying to understand glib's GTrees for a college project i was really frustrated so i decided to vent out to reddit.
Ah. Yea... I am not sure how to convince people about basic timing problems in real time systems. It's just basic math. 
Yes take a look at MAP_ANONYMOUS mmap's option.
Did you [read the man page](http://man7.org/linux/man-pages/man2/mmap.2.html)? &gt; `mmap()` creates a new mapping in the virtual address space of the &gt; calling process. ... &gt; &gt; If `addr` is `NULL`, then the kernel chooses the address at which to &gt; create the mapping; this is the most portable method of creating a &gt; new mapping. ... This makes the kernel does the address choosing for you. You can then just use the area to put in your structure and other stuff you want to put in.
I've been reading stuff from other people, though, and I keep reading mmap maps a whole page when I only need sizeof(struct) and I don't want to bomb my computer's memory when I make multiple thousands of calls to mmap. Is that not true?
It is true that memory mapping is based on pages, but this is a way to get memory from the kernel. *Your job* is then to use the space to track the allocations and "give space away" (for your own `malloc`).
Isn't it possible to execute your process using a task runner (runnit, systemd, supervisord) which can capture the stderr of your instance?
We're using old school Linux (like I said, embedded), so the only option I can think of in terms of that is to pipe 2&gt;file in the init script, but that seems inelegant. Ideally it would go into the syslog
On this device, everything (dmesg etc) dumps into /var/log/messages, and I haven't seen any OOM errors. The process dies when running a certain serial command on some hardware it's bound to, which is what's perplexing. I know almost for certain that it's not OOM, as we use very little heap allocation, all done using RAII. Fortunately (unfortunately?) the program is single threaded, so it seems like calling syslog() in the handler itself shouldn't present an issue. The stdout/stderr solution seems best, though it's not what I wanted to hear. Thanks for the input!
I bet he goes to school with this guy: https://www.reddit.com/r/C_Programming/comments/87wtlc/assembly_problem/ Yes it's a string checking loop
&gt; **Don't forget to handle quoted strings and character constants properly.** "/* abc */" it being turn into "" despite being in a string (where it is *not* a comment). Also, this is somewhat useless as a tool, because it also prints a separator (`------------------`), so you can't even take the output and input it to an C compiler without modifying. And lastly, try without any "limits" (without using dynamic memory allocation).
Thanks for reminding me of the quoted strings. The separator is there for my own sake so I can see where the old code ends and the new code begins. What would you suggest the program do? I'm not sure is not using dynamic memory allocation has been covered in Chapter 1 of K&amp;R. I'm trying to answer all the exercises using only coding techniques taught up to the where the exercise is found. I will double check the reading in Chapter 1. Thanks for your comments.
&gt; I'm not sure is not using dynamic memory allocation has been covered in Chapter 1 of K&amp;R. I mean you can do without limits WITHOUT dynamic memory allocation. You just parse the code "on the fly". &gt; The separator is there for my own sake so I can see where the old code ends and the new code begins. What would you suggest the program do? Print the edited code. No seperator, so I could so something like that: comment-remover &lt; myfile.c | gcc -xc - -o myfile
Unfortunately when you've blown half the stack and segfaulted, and you have to unravel what the fuck happened from the dump, you only have the output the compiler gave you.
If I understand your question correctly, all you are trying to do is log (specifically to syslog) from within a signal handler? I am assuming this is before your process gets SIGKILL'ed though? Note that [signal(7)](http://man7.org/linux/man-pages//man7/signal.7.html), [sigaction(2)](http://man7.org/linux/man-pages//man2/sigaction.2.html), and [signal(2)](http://man7.org/linux/man-pages//man2/signal.2.html) all say &gt; The signals SIGKILL and SIGSTOP cannot be caught or ignored. The [signal-safety(7)](http://man7.org/linux/man-pages//man7/signal-safety.7.html) man page discusses the issue of non-async-signal-safe functions and has a list of functions that are ok to use. Using printf() as an example, my understanding is that it boils down to "if you were in the middle of a printf() call and then receive a signal, calling printf() in the signal handler is a Bad Thing^TM because the internal printf() state will be messed with." I am assuming that since syslog() is a printf-style function, it is async-signal-unsafe for the same reasons. The "safe" way to print instead of printf() can be found in the function list on the [signal-safety(7)](http://man7.org/linux/man-pages//man7/signal-safety.7.html) man page: the [write(2)](http://man7.org/linux/man-pages/man2/write.2.html) function. So in your signal-handler you would do the following: // printf("we're in the signal handler!\n"); // don't do this char msg[] = "we're in the signal handler!\n"; write(STDOUT_FILENO /*1*/, msg, sizeof(msg)); Obviously this will get more complicated with any variables or arguments, as you will have to manually format your strings. It's annoying, but doable. If we couple that with a little knowledge of syslog, I think it points towards your "safe" solution. From the [glibc syslog documentation](https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_18.html): &gt; Syslogd listens for messages on a Unix domain socket named `/dev/log' &gt; &gt; `openlog` may or may not open the `/dev/log' socket, depending on option. If it does, it tries to open it and connect it as a stream socket. If that doesn't work, it tries to open it and connect it as a datagram socket. The socket has the "Close on Exec" attribute, so the kernel will close it if the process performs an exec. Lastly, using a little [socket(7)](http://man7.org/linux/man-pages//man7/socket.7.html) knowledge, we know that write()ing to a to a connected socket is identical to a [send(2)](http://man7.org/linux/man-pages//man2/send.2.html) with no flags. I think this is all the pieces we need to make the solution for your "safe" syslogging: 1. When your process starts, open a [unix(7)](http://man7.org/linux/man-pages//man7/unix.7.html) socket and [connect(2)](http://man7.org/linux/man-pages//man2/connect.2.html) to `/dev/log` 2. When you want to log to syslog, write to the connected socket. I am not sure if there is any special formatting needed for syslogd (like how printk() prefixes each string with a priority) or if you can just send a plain string. Here's a rough outline of what I am thinking: // put all the various include files here int main() { // open connection to syslog int sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if(sockfd &lt; 0) { /* error */ } struct sockaddr_un dest; dest.sun_family = AF_UNIX; strcpy(dest.sun_path, "/dev/log"); // remember, sun_path is only 108 bytes if(connect(sockfd, (struct sockaddr*)&amp;dest, sizeof(dest)) &lt; 0) { /* error */ } // Async-signal-safe syslogging char msg[] = "Hello, syslog!"; if(write(sockfd, msg, sizeof(msg)) &lt; 0) { /* error */ } return 0; } 
You can use states to signal if you are in a string (skip comment check) or in a comment. I think k&amp;r shows how to do that before this exercise? e.g. you have a set of flags `incomment` `instring` and then read input char by char figuring out if you have to set them to true or, if you are in a state, reset them. In the middle of these two actions you then print the read character if it's not incomment. So you would have something like: while ((ch = fgetc(stdin)) != EOF) { /* are we in a comment? */ if (ch == '/') { if ((next = fgetc(stdin)) == EOF) break; if (next == '*') incomment = 1; else ungetc(next, stdin); } /* print stuff outside of comments */ if (!incomment) fputc(ch, stdout); /* any chance of getting out of one? */ if (ch == '*') { if ((next = fgetc(stdin)) == EOF) break; if (next == '/') incomment = 0; else ungetc(next, stdin); } } This is just an example however, it has several issues (like not checking string, leaving a newline) but shows better what i mean. I'm terrible at explaining code in words. 
Yeah, I saw that other post after I answered this one. Looks like the same problem. 
^ this is the assignment, so that you understand how `malloc()` works in userspace.
&gt; There's plenty of server side JavaScript and js programs that have nothing to do with the web. That's not a good thing.
This might be the way I do it, so thanks for making me aware of it, and thanks for posting that link!
One difference is that seeking doesn't work with data received from a pipe (the first method). Show your code and we can tell you what the problem is.
The way you should be doing it is by getting a big chunk of memory from mmap and then dividing it up as required. So your allocator should only be calling mmap very infrequently.
Here's my code: https://pastebin.com/NhvtdW69
I’m a high schooler who can’t work full time, but I work mostly in c and I have a bunch of experience writing networking stuff (I used enet), I’d love to send code if you guys offer internships or something. Btw I develop on bsd and for Linux so I’m experienced w/ that stuff too
What does it do?
I found what was wrong, so basically I forgot to add a check for the flag to actually do something when given the arguments. Program still doesn’t solve the maze correctly though... 
You can't. It is not possible to assign to an array in C.
I love C and I prefer it over many other languages... but I’m not sure I see the relationship between a hedge fund and a programming language. It’s more common to choose the language according to the project rather than start with a language requirement (best tool for the job rather than design a job to fit a tool)... What’s your objective?
speed?
Makes sense if they have an established C codebase. Personally I'd go with C++ for something like this, and even then only for the core low-latency part.
Thanks for the fast answer! I guess I have to find way around it.
If the function is returning a pointer to an array and you want the contents moved to another array, take a look at `memcpy`. Normally you would just keep a pointer, though, rather than copying it to a different array.
Not true. You cannot assign anything to an array
do you need any c#/.NET developers?
`logger(1)` is designed to take stdout/stderr and pipe it into syslog
Yeah. Here's your guy right here.
If the rest of the team is dedicated to the JS approach but you're still needing C/C++ to handle interfacing take a look at gyp (I think that's the right one). It allows you to bind Node.js applications to C/C++ binaries and write wrapper functions. You could work on the sensor interfacing stuff and just hand the data up to the JS as an object.
If you're actually qualified for this, don't do it for anything near free. This position is easily $150k minimum full time, closer to $250k if they're actually looking for a senior engineer.
&gt; That's why you are... Nope. That's not the reason. But I'll happily degrade to your level and call you an idiot if you wish ;-)
Who would use .NET for HFT?!
C++... brrr... I'll take C over C++ any day.
&gt; Did you miss the "linux, tcp/udp, low-latency" part? Nope, I just doubt they know what they're talking about. If a hedge fund manager could design software, they wouldn't need me to code it. We all do different things. I recommend that they describe the project and their objectives rather than describe the language they think is best.
Uh, I do low latency, async., distributed systems programming in C and C++. On Linux. For, like two decades. And those are not words that suggest they don't "know what they're talking about". In fact, most of the HFT shops hire sophisticated low level programmers. And, they *did* describe the project. They want you to write code in C which talks to the network. Fast code that handles network traffic. On Linux. Both TCP and UDP. Were you thinking they should say, "we need super fast code to make trades with other automated systems" and let you pick Prolog and Windows, or something? 
&gt; JavaScript developers are everywhere and their mistakes cost less Ah... the irony... 
keep in mind I'm a highschool student who doesn't have the time/maturity to work a full time job, but I am pretty good at C, and any real world experience is priceless for me because that's my main deficiency.
Yes, I think you can. Assume u have an array a and a pointer b. You may first do size_t offset=a-b, then use inline asm to calculate %esp - offset and %ebp - offset，and then use mov to change the registers to the shifted value, then a will point to the same location of b. After the operations u may want to restore the value of %esp and %ebp. On modern system this may cause segment fault, and you may need to run it on ring 0 and change the segment table, etc to bypass mem protection.
left hand rule and then dispatch a worker thread when ever you hit a branch? I think this is covered in the CLRS text book somewhere. 
But this is a case of: "Yes you can, but you probably shouldn't!" ;)
Your question has been answered poorly so far. Certainly, you can't *return* multiple values (ie, an array) from a function. But you can absolutely modify and *effectively return* an array. int myArray[10]; void myFunction(int *passedArray); main() { myFunction(myArray); //myArray has been modified and "returned" } void myFunction(int *passedArray) { passedArray[0] += i; passedArray[1] = 0; }
If this causes a segfault, it's because there is an error, not because it's a "modern system". As someone else suggested, memcpy would suffice. No assembly required, and anyone else who has to read or debug your code will thank you for avoiding it. 
It wouldn't normally be idiomatic, but you can wrap the array in a structure and then return the structure from a function.
Thankyou.
Not really. This subreddit is about programming in C, C++ questions should be posted to /r/cpp_questions.
It is the difference between a regular file(reg) and a pipe(fifo). You only think of this as "stream" once you no longer care why or how the data is flowing from A to B.(or that is just my take on this "stream" thingy) See https://linux.die.net/man/2/stat.
It is the difference between a regular file(reg) and a pipe(fifo). See https://linux.die.net/man/2/stat. Stream is when you no longer care how the data comes from A to B. Stdin is simply the source, or the A before the B. Stream is what should come between the two. Or that is my take on this "stream" thingy.
Or between the stdin and the source, that is. This "stream" thingy confuses me... cat file | stdin // or stdin &lt; file // ./program then reads from stdin, but you never see stdin. Does stream mean from program to stdin or from source to stdin? Or is it just stdin? I need answers! 
&gt; When you define int a[10] you are allocating memory for that array. [...] Those 10 int will be lost as memory leak. You will never leak memory unless you allocate memory explicitly with a function like malloc or calloc. C itself has no support for dynamically allocated memory, it must all come from a library function of some type. So saying **int a[10]** will never leak memory. It's either allocated on the stack (if declared in a function) or in a static portion of memory (if declared outside of a function), neither of which need to be freed or will leak memory. Returning a pointer to a stack array is a real bad idea though. 
You should probably look into POSIX and output redirection.
If you want to get the investing side of the hedgefund head over r/wallstreetbets /s
I know you said no GDB, but why not just do a core dump and analyse the file offline?
technically, it can be used but it's next to impossible
^ This. 
Oh that can be easy enough. An array is a pointer with preallocated space. Replace its declaration with one using `*int`, and you don't have to change anything in the rest of the code. For example, `a[1]` will still work, as in: #include &lt;stdio&gt; int b[10]; int *a; int i; for(i = 0; i&lt; 10; i++) b[i] = 6*i; a = b; printf("%i\n", a.[3]); 
Look up the concept of “recursion”. Basically, the function is calling itself. 
I know the concept of recursion but I cant understand how do we know when the condition is true or false
Ahh. In C, 0 acts like “false” in an if statement while all other numeric values are “true”. 
It looks so..ideally there should be a base condition. Please use the pastebin ,as it becomes difficult to read code on reddit app on phone.if possible, post the whole code on pastebin and share a link here.
It exits when it cannot find an empty cell. 
`sudoku[][]` is not declared inside the function (or in its parameters), so it is a global variable. It is very likely that `findEmptyCell()` and `isValid()` use it as well. That's the thing that changes between calls.
Not OP. But good idea. 
Same result also with single quotes 
Could you explain me a little bit of it
Okay got you:) Thanks for your help
Please insert 4 spaces before each line of code so that reddit will properly format it. I don't understand what you mean by "number of even numbers." Could you be more specific? How is you code not working? What values have you provided as input, what was the output, and how did this differ from what it should have been?
Yup I'll keep it in my mind about pastebin and GitHub, thanks man:)
I've been trying to put it in the right format without success. Posted img of my code. User is supposed to enter numbers and program should count frequency of positive numbers and return frequency number.
StackOverflow have a nice introduction to how to ask questions, read it! https://stackoverflow.com/help/how-to-ask
This is what I have to do: Write C function void number_eNumbers(int n, int *numberOfEvans); which is calculating positive numbers (0, 2, 4, 6, 8) in form of n. In main function load numbers by input as long as user doesn’t enter negative number and then show number (frequency) of Evan numbers.
Your example causes undefined behaviour by using `%s` with `destination1` which is not null-terminated
&gt; That said, you're going to see random data to the right of the fifth character if you print it with %s because it's no longer null terminated. Yeah, I noted that in my reply. I wasn't totally sure what OP was going for but in the question, they were filling with 'A' as an exercise, so I left it be. 
Programmers have full control over this issue in both C and C++.
You're conflating encapsulation with security. Both C and C++ has language features to prevent one part of the program from accessing "internal" parts of another part of the program. C++ has more such features than C, though this is not necessarily *better*. This has nothing to do with *security* since it's still trivial to access encapsulated data. There are no run-time mechanism to prevent that access. These are purely compile-time checks intended to catch programmer mistakes. 
i_ptr is local to the loop. It is reinitialized each iteration.
Nope
You're assigning i_ptr inside the loop, so the increment isn't ever sticking. You should get the behaviour you're looking for if you move it back before the loop. a won't actually be incremented either, as assigning i_ptr copies the pointer into the variable and future operations leave the a pointer alone. As an aside, you shouldn't cast the return of malloc. A void* is automatically cast to other pointer types and it can actually hide bugs if you forget to include stdlib.h, as functions without a prototype are assumed to return int.
I was just fiddling with the strncpy function
Also; you're using 'sizeof(a)' which is the size of the pointer variable, which is 4bytes on a 32bit compiler. Clearly not the intended operation. Try using a const/define to reference the intended alloc length (for later usage). Have a look at calloc(), check if this will do anything of interest. When printing an address '%p' will produce something alot more readable, although in this case the value isn't changing ('a' isn't modified). 
I’m sorry I still don’t understand, why does an ICE * 01 result in 0?? 
No need to apologize, friend. Where I think you're getting hung up is that it's not `01` but `0L` where the L denotes a long integer. I hope that helps.
Real men program in assembler. 😉
Worst April fools ever. Obviously Rust is the future. 
If you like high-level languages! 
F E A R L E S S C O N C U R R E N C Y E A R L E S S C O N C U R R E N C Y
Why would you state a fact as a joke?
 back in the Good Old Days, when the term “software” sounded funny and Real Computers were made out of drums and vacuum tubes, Real Programmers wrote in machine code. Not FORTRAN. Not RATFOR. Not, even, assembly language. Machine Code. Raw, unadorned, inscrutable hexadecimal numbers. Directly. -- From The Story of Mel
C is highlevel enough. :)
My favorite part is the Away construct.
*autistic screeching intensifies*
:D
Go is the spiritual successor to C. Go has been designed by the same team for the same purpose C was designed and carries big chunks of its legacy. For many purposes, Go is indeed better suited.
Butterflies.
Aaah I see now. But doesn’t multiplying anything with 0L still result in 0? Why would non ICEs not also be reduced to 0? 
i rub my hand on a baloon and then program flash memory with my pinky
The fuck, I use light rays and atmospheric pressure. Pleb
&gt; Happy April fools It looks like it started a couple of days ago when most of the sub recommended to use Javascript to do low-level embedded programming interface with drivers. But that was probably an hallucination of mine. I hope it was.
Go is the best thing since sliced bread. Roflmao.
Manage to find some more tutorials that look decent. I haven't gone through any of these as of yet, but do plan too. - [Hack the Virtual Memory](https://blog.holbertonschool.com/hack-virtual-memory-stack-registers-assembly-code/) - [Multiplayer WebSocket Game server written in C](http://www.gamedevcraft.com/2016/08/part-1-multiplayer-websocket-game.html) - [Emulator 101](http://emulator101.com/)
lol design your program properly
Please don't post these.
YOU KIDS AND YOUR LOWER CASE AND YOUR AUTOMATED GARBAGE COLLECTION - GET OFF MY LAWN!
pushing a single button synchronized with a clock !
Enums are basically integers, starting from `0`. You can even explicitly assign a specified "start": enum { A, /* 0 */ B, /* 1 */ C = 5, /* 5 */ D /* 6 */ }
Nay
Yeah I get that but can you do arithmetic on them like typedef enum { enum_1, enum_2, } enums; enums a; enums b; enums c = 2 * a; enums d = a + b; etc.? 
&gt; Enums are ~~basically~~ integers http://port70.net/~nsz/c/c99/n1256.html#6.7.2.2 &gt; The expression that defines the value of an enumeration constant shall be an integer constant expression that has a value representable as an int. &gt; ... &gt; Each enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type.
Not even a backspace key. 
no thta is totally real. There are node.js projects to begin writing down to the hardware and even pull in cpu timing registers. There is word that a node.js real time based implementation will be available for medtronic heart implants by late fall this year.
real programmers use font toggle switches to load in the paper tape reader software
C enums are extremely weakly typed, you do pretty much anything with them. You do not even need to cast from an integer type to or from an `enum` type. Sometimes we wish they were more strongly typed.
As a student in university taking an ARM assembly language course using uvision keil as my compiler... I can confidently say this shit is for the most barbaric of men.
But it's glorious! When you reach the point where you're staring at a raw hex dump and disassembling it in your head... Or when you are hot patching code in memory by hand... You feel like a damn wizard. This is the deepest of deep black magic. That feeling is amazing.
A *what*space key?
Real programmers buy bulk N and P MOS and place them on an infinite grid with jumper wires. 
Yeah, who needs an assembler anyway, we write Bytecode directly!
My point exactly.
Real *people" , please. Don't trigger the girls.
I will give you that looking at a memory map and decoding the hexadecimal to verify it’s doing as it should or checking what’s happening through the registers in hexa makes the magician feeling certainly a big plus!
Minecraft Mods are the future
except when you want manual garbage collection, small binaries, greater portability, bindings with every language ever etc. I see go as more of a C++ is god awful, let's make a semi-low level so we can stop forcing are selves to program in literal dog shit every time we want to go fast, and not dereference free'd pointers at the same time.
C is just a portable assembler anyways, amirite :)
F E A R C O N C U R R E N C Y L E S S
You need to be able to capture input from your mouse. This process relies heavily on the graphics library you're using. Some may have a built-in button object you can slap on, but generally that's not the case. What library are you using to display the shapes? 
I'm using the graphics library, yet in my lectures, we haven't covered that library much.
&gt; the graphics library I'm sorry, I'm not familiar with a project by that name, could you link me some documentation?
It's not THAT bad for small micro controllers, but I would rather use C.
sorry I meant stdio.h stdbool.h I think... Im not entirely sure to be honest. Only done a month of c programming. 
http://lazyfoo.net/tutorials/SDL/17_mouse_events/index.php
We have to use NotePad++ for the code and MinGW for compiling. We have a custom "SwinGame" we can use to ./build.sh and ./run.sh the code. Running the windows OS. It may be custom? Im not entirely sure, we werent given much to start with.
Thank you, ill give this a try 
OP mentions lectures and being new to the language. I don't recommend using SDL as a beginner, but more importantly it sounds as though they are expected to use a specific library for what I suspect is a homework assignment. Don't misunderstand, SDL is a solid library and learning to use it is a valuable educational experience, but I don't think it is the solution in this case.
We are just given instructions on to create a button. There is a template for future work. He has the code for the button as "void_drawbutton(color clr, int button, float x, float y, int btnWidth, int btnHeight)" 
[SwinGame Documentation](http://www.swingame.com/index.php/api/input.html) can help point you in the right direction. Since this is a game library, I very much doubt there's a simple button in the API. The way I would do this is to display a button shaped area using the shape display methods you mention. You'll need a loop to call `ProcessEvents()` and check if the mouse was clicked via `MouseClicked()`. If it was you can determine if it clicked the button by using `MousePosition()` and comparing it to the location of your button. I hope that helps. Feel free to keep asking questions.
Thankyou a ton :) 
Actually I found a [UI section](http://www.swingame.com/index.php/api/user-interface.html#parent_ButtonClicked) in the docs that details the use of a `ButtonClicked()` function. Unfortunately I don't see a button creation function anywhere, but I'm sure it must be there.
Im having a look now. Im sure ill find it somewhere. Thank you for the help. Appreciate it
There's not a good workaround for using Valgrind with High Sierra yet. AFAIK the reason for this is due to a section of the OS code that isn't open source; without knowledge of how that section works the dev team can't do much. What I recommend you do in the meantime is use the [address sanitizer](https://clang.llvm.org/docs/AddressSanitizer.html) in `clang`. This will catch simple leaks and improper accesses. In `gcc` the flags I typically use are `-fsanitize=address` and `-fsanitize=leak`, and I think they're the same for `clang`. If you need a more in-depth check for leaks or improper accesses you will likely need to use `lldb` (or `gdb` if you're using `gcc` for some reason). This can be tricky, but there are likely tutorials out there to help you catch memory issues via the debugger. Hope that helps!
hey, thanks for the input! I'm currently using gcc and gdb, so when I compile you're saying I should do $ gcc -fsanitize=address -fsanitize=leak -g &lt;filename.c&gt; -o &lt;filename&gt; right? Also how can I get the memory leak report from gdb?
&gt; I have zero experience with clang and lldb :( That's fine. I mention them only because they are the default OS X tools; GNU equivalents need to be installed separately, and in many cases are aliased to run LLVM equivalents regardless. Were I you I would start using `make` right away. [Here's a tutorial I like.](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/) But otherwise, yes that line you pasted looks right to me. Using debuggers can be difficult. As I recall this particular problem may require you to write a script for the debugger, which is a fairly advanced technique (in my opinion). In fairness I'm terrible at using debuggers, so I'm sorry to say I don't think I can be more help in this regard, but learning how to use them is incredibly valuable and can help beyond just finding memory problems.
Ahh did not know clang and lldb are the default tools for macOS. I use gcc and gdb only because my university requires me to compile on Linux platform but yes, I will take a look at the gdb documentation to figure out how to do a memory check. Thanks for the help!
I think it's more of an issue with your gui library than the language. What cross platform gui did you plan to use with C?
I'm not sure, hence why I asked. I'm on Linux and I never want to hand carve a GUI ever again, so something with a good GUI creator and layout manager on my platform.
Finally something like this!
All you said is right.
Lol
Lol
There is also this small How-To: http://www.swingame.com/index.php/documentation/how-to/item/how-to-use-button.html 
This looks correct. Recall, a string ends at the first `\0` byte, what comes afterwards doesn't matter.
Yep this. If you initialised your character array as 100 long, you’ll have the hello world filling the first 11 and then the other 89 will be the \000 as it’s still empty. The string ends at the first null terminator.
You and Golden nailed it thank you!
Go for GNU/Linux, go for freedom.:)
Done that on a Xerox 530. 
Women are not masochist enough to avoid using the correct tool for the job.
There are GUI creators for Swing and JavaFx. For Swing there is an Eclipse plug-in called WindowBuilder. For JavaFx there is SceneBuilder.
Well it's safe
First of all, I don't know nothing about the topic. &gt; I am posting links to individual files Please consider some site like [GitHub](https://github.com/) or [GitLab](https://gitlab.com/) for sharing code with multiple files. It just makes it easier to navigate and test locally. &gt; -sdt=c11 You surely mean `-std=c11`. Now to the code. I just scratched the surface and just scrolled through the code. So for one thing, I'd like some documentation in the header files. What does `p_hit_x(struct key, struct deck, int, int)` do? `double _17_21[5];` what is that for an array? (examples from [`combo.h`](http://codepad.org/Ujag1Jy9), but other header files apply). What's `MAX_C`? Do such documentation early, this will help a lot later. (This will help with your point number 3.), " will place a bet that within 30 days, much of what I have written will be a mystery to myself.") Secondly, in [`enum.c`](http://codepad.org/VnSephgm), in the `print_player` function: &gt; printf("\n"); &gt; printf("\t\t\t\t"); You could also just do `printf("\n\t\t\t\t");`. Also, for statements like `if` and `for` whose actual code to be run is also just one statement, you put them into the same line. I think this isn't really optimal, because you'd get long lines such as these: (from `print_card`, the individual `for` loop parts could also be separated by new lines) &gt; for(list.next = list.first; list.next != NULL; list.next = list.next-&gt;next) printf("%d ", list.next-&gt;rank); can be more readable: for(list.next = list.first; list.next != NULL; list.next = list.next-&gt;next) printf("%d ", list.next-&gt;rank); Also for `printf` formatting, you can just use `%+d` to always display the sign. So it turns &gt; if(t-&gt;stand[k] &gt;= 0) printf("+%0.6f ", t-&gt;stand[k]); &gt; else printf("%0.6f ", t-&gt;stand[k]); into printf("%+0.6f ", t-&gt;stand[k]); There are also cases where `printf` has been used but not the formatting features and the string ends with an `\n` (eg. `printf(" A\n");`) - Such calls can be replaced by a `puts` (without the trailing `\n` which prints it automatically). But GCC (and probably clang) already detect such calls and replaces it accordingly, so you can just continue doing this if you want. (same for `putchar`) In the function `double_` in [`double.c`](http://codepad.org/yS0zhORI), you use 3 `for` loops, where 2 of those you use an `i` variable to iterate but in the 3rd loop you suddenly use `j`. Just some inconsistency. Also, `while(t != NULL)` can also be replaced with `while(t)` (think of "while t is valid", where "is valid" also means that it isn't `NULL`). I'm also seeing that you allow to pass huge structures over the parameters. For example, in [`stand.c`](http://codepad.org/MtAQYTcS)) the function accept a `struct key` in `compute_p`, which on my system is `528` bytes (chars) big. Since parameters are "copied", you end up copying `528` bytes. Using pointers (which on my system are just `8` bytes) bypasses the copying and thus function calling overhead. In [`hit.c`](http://codepad.org/XCqUjGM8), in `find_key` you use `exit`. However, it seems it is an impossible condition, so calling the `abort` function is probably better since, for example, it can create an core dump file that you can then analyse with an debugger. That's it for now. Also, while I haven't used such tools in your project specifically, try something like [clangs static analyzer](https://clang-analyzer.llvm.org/scan-build.html) (`scan-build`), [valgrind](http://valgrind.org/) (detecting memory leaks, although I haven't seen the program asking for dynamic memory) and [gcc](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html) and [clang](https://clang.llvm.org/docs/index.html) have sanitizers.
java is way easier for GUI's than C/C++, let alone cross platform development. I suggest sticking with java and trying a different GUI library. There are plenty of tutorials on youtube if you get stuck.
I plan to haha
lol no generics /s
sorry this is a full time position on-site in NYC
No problem. Open to relocation but if not in budget then fair enough, good lick with the project.
Say what it is **exactly** you need help with, otherwise you sound like you are asking someone to do oyur homewrok for you?
Are you sure that setpgid() is succeeding?
19573005 looks like a TID; PIDs should be in 0…32767 AFAIK.
What have you tried? Why didn't it work? If I were writing this code, I would iterate through each column of cells, from the bottom to the top, looking for cells with a value of -1 where the cell above has a value which is not -1.
Check to see if your university has a server you can SSH into. Not only is learning how to develop remotely an incredibly valuable skill (it's how I tend to do most of my development), building and troubleshooting on the machines that will likely test your assignment for compliance ensures that you don't run into unexpected differences in implementation. As a bonus, they probably have valgrind installed.
That’s actually what I do via terminal. But I was thinking it’d be convenient if I could run valgrind locally 
Oh no worries, I've definitely been there, but I've always had a Linux machine handy. Sorry I couldn't be more help.
&amp;a specifies the address of a. It should just be: printf("%lf",a);
My suggestion would be to use a switch statement to keep it nicely organized
is it just me, or is there no code for this year's winners?
Pretty quick and simple to use. No vulnerabilities found (3 projects scanned), so I can't really give much more feedback :)
I wasn’t able to find it either I think they will release it soon though.
You're probably getting mixed up between how to use printf and scanf. int x = 5; printf("%d\n", x); vs. int x; scanf("%d", &amp;x); With printf, you're saying "here's are value I want to print", so you give it the contents of a variable. With scanf, you're saying "I want to store a value in a variable", so you give it the address of a variable --- the location you want the value stored at. x; // the contents of x &amp;x; // the address of x (where x is) That's why you use x with printf, and &amp;x with scanf.
[Gtk](https://www.gtk.org/) can be used for cross-platform development. But it is really only native on Linux/BSD. On Mac and Windows, you will have to install the run time libraries. There are some other options that I haven't tried: + [Nuklear](https://github.com/vurtun/nuklear) and other [immediate mode UI](https://en.wikipedia.org/wiki/Immediate_Mode_GUI) + the [libSDL](https://www.libsdl.org/) game library + the [Allegro](http://liballeg.org/) game library
**Immediate Mode GUI** Immediate Mode GUI is a GUI where the event processing is directly controlled by the user. The immediate mode GUI widget toolkits are more direct and thus less complex, thus they are a good choice for those who want a simple but easily changeable and extendable GUI toolkit, they are usually generic, open source and cross-platform. The original Immediate Mode GUI toolkit was imgui which is based on OpenGL. There are others such as nuklear with backends for several graphics libraries, kiss_sdl for SDL (Simple DirectMedia Layer) or dear imgui written in C++ (here the jvm port). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.gtk.org/) - Previous text "Gtk" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Gtk+ has a graphical GUI designer called [Glade](https://glade.gnome.org/). Not sure it has a integrated UI designer, but you might want to check out [Gnome Builder](https://wiki.gnome.org/Apps/Builder). Its been a while since I played with Gtk+, but I am fairly sure that Glade integrates with Anjuta and Code::Blocks. If it doesn't, then you can still use Glade to design your interface, then use the XML files it generates in your project.
Congratulations!
I glanced quickly and noticed the same thing 
*Uhh... * saved?
Just ran this in CLion, this is absolutely hysterical. Take your upvote
Dude.. 
If it works for you, why not? 
I was just looking for some extra input. I’m really liking C and it makes a lot of sense compared to how (when I first started) Java was really confusing 
Depends entirely on what you want to be doing. C is the language of unix/linux &amp; I'm also learning it for the sake of it's portability (microcontrollers/embedded in particular, although that's a bit of a murky subject in itself) What do you want to do with your programming? If it's just a hobby and you like it, might aswell.
you're an artist
Nothing wrong with your path, just program in whatever interests you/gets the job done. If you are looking for breadth, you can maybe look into some web languages in the future. maybe pickup JavaScript + PHP or nodeJS or python web-server. This can help tremendously as it will aid your other languages. For example, you can start to write PHP that is on a server and have a windows application that communicates with it (C#) and maybe an android application that communicates with the same script (Java). Basically it can open up a lot of cool possibilities for programs. Its a quick and easy way to learn about servers/communication over networks, and it can help you learn about handling many asynchronous requests and so on. IDK, just my 2c.
Why do you program? Professional, or for fun? What do you want to do? Do you want to release the Ruby Gem of the week, or contribute to something that Ruby Gems links to cross-platform (and Python, and Objective-C, and everything else under the sun). C isn't for everyone, but it's the lowest common denominator (in the good sense). And what's really cool is, if you master C, you can master everything. 
Thanks for trying it out! You could fork some older projects and try the scan to see what the vulnerability report looks like. (We'll be happy to top-up your scans :D)
it should be simple harmonic motion, not linear!
You’re fine! Thank you
Different strokes for different folks
I totally agree! But I like when I can use my code multiple times over multiple projects without much fiddeling with global variables and such... Do you have some tipps how I can achieve this when not going the "OOP-Like" way? Thanks a lot for your time :)
I was about to be like any language that requires a certain naming convention is garbage.
Are you castro's son?
_Generic
Stop using the address of operator...
Can anyone explain why someone would use valgrind over the sanitizers or lldb? I don't get where it's supposed to fall in that spectrum.
according to the judges twitter, code will be released on the 8th of may (https://twitter.com/ioccc/status/980665762665807874)
If you set it up so that each enum has a value that's a multiple you could OR them together and do math like that.
No, not really. I'm coming from Delphi and C# so I coded object oriented for the most of my life and I have no Idea how I could solve things differently without using global vars and such. What I'm currently working on is porting a virtual machine/processor from Delphi to C. You can see it [here on github](https://github.com/pointermess/FlexVM-Runtime-Environment/blob/master/src/FlexMemory.c) (Its not very clean yet and I have to do some refactoring, but I think most of the code will look like this). Do you see anything I could do to make it better and more C-Like? Thanks a lot for your time! :) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pointermess/FlexVM-Runtime-Environment/.../**FlexMemory.c** (master → a458796)](https://github.com/pointermess/FlexVM-Runtime-Environment/blob/a458796a7954c477bfdfef27a76f0ebcba052bbe/src/FlexMemory.c) ---- 
NOW THE WOORLD DON'T MOOOOVE
....You're a wanker.....
How can I find a valid id for which the group is empty? I'm wanting to have only A and B in the group when I send the signal.
You do this by forking A and B off C and setting the process groups as indicated in the [documentation](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setpgid.html). Should look like this: 1. C is executed 2. In C, call `cpid = getpid, setpgid(0, cpid))` to create a new process group with C as its leader. 3. Fork off two children A and B from C. 4. In A and B, call `setpgid(0, cpid)` to join C's process group (I believe this is the default) 5. Call `exec` in A and B to run the desired programs.
CPP is the C preprocessor. Very worthwhile to get familiar with.
I can't. The assignment requires me to run A, then B, then C, with no command line arguments. I guess I'll have to write pids to files. I was hoping for a more elegant solution.
Then the question remains whose pid you use as a process group.
This masterpiece definitely should be considered for inclusion in ACM Digital Library. At least set up a github repo to report issues and request new features for V2.
Someone hire this man at google.
You are true programmer someone give him gold
It's a good path, good luck with c++ tho
It's too bad that it's *hard* coded.
&gt; I mean 3 or less. Wat. It's not like programming languages are particularly hard to learn. Also you'll need more than three languages for most kinds of work. I use no less than four (C#, Lua, Python and a little bit of C++. Also LaTeX, which is Turing-complete, so it counts, too).
Define **Learn** Learning basic aspects of a PL does not qualify one as (good) at it! But knowing valuable and important aspect of PL takes years...YEARS! 
sounds too hard I'll just code up hello world in it and add it to my resume.
That is basically what most "programmers" do! &gt; Toy projects that have no security or wise implementation
You might get better answers in an Arduino specific subreddit. Also note that the Arduino programming language is a dialect of C++, not C.
Please clarify. The Arduino IDE allows you to program in a single language, which is a dialect of C++ as far as I am concerned.
C is a subset of C++. Arduino IDE will run C properly...
C is not a subset of C++ (cf. [this list](https://stackoverflow.com/a/31505447/417501) and also [this one](https://stackoverflow.com/a/1201840/417501)). This subreddit is about C, not about “C++ but I pretend it is C” so Arduino questions are generally off topic. 
C is the original programming language, a C++ is simply C99 with improvements, c++ compiler will compile C code. It is not exactly a subset of you want to be annoying about it. Anyone all the library’s that are written by arduino are essentially using C library’s not C++. Take for example the iom328p.h file, it defines PORTC... (that you use to turn bit on and off) it’s a C library.
&gt; a C++ is simply C99 with improvements Complete bullshit. C++ is based off ANSI C (C89) but isn't even compatible to that. It misses all C99 features such as `restrict` pointers or variable length arrays. &gt; c++ compiler will compile C code In general not. Read the links I provided. &gt; It is not exactly a subset of you want to be annoying about it. It is not even a subset for normal code. For example, my code makes vast usage of `restrict` and C11 atomics, both of which don't work in C++. &gt; Anyone all the library’s that are written by arduino are essentially using C library’s not C++. Again, C++ that pretends to be C is still C++ and is not on topic. This is not negotiable.
I’m pretty sure C++ now does support C99’a restricted. It is not C++ that pretends to be C it is C PERIOD. “The core libraries are written in C” The compiler is smart enough to differentiate between C++ and C in compilation. Please all your comments here are off topic. If you are not familiar with this topic, just don’t comment! 
I've never got on with cmake.... a simple boiler plate Makefile can cover a surprising amount of corners look particularly at pkg-config which can at simplest be used just to get your cflags and ld (-libs) flags 
Indeed but at the moment I'm working with CLion (and I don't want to change) and it supports CMake for building a project. Out of curiosity how would you do this with a simple Makefile? I'm new with developing in C (I know my way around the language but I've never developed anything but university exercise level stuff) and have no idea how to handle errors of any kind nor use the available tools.
CMake is actually pretty awesome. The documentation is not. Makefiles are also pretty good on every platform that isn’t Windows. 
Is this a middle out algorithm??
A few comments. 1. Instead of using "set(CMAKE_C_STANDARD 11)", set the property of your target. for example. set_target_properties(Test PROPERTIES C_STANDARD 11 ) 2. You don't need to set C_LIBRARIES_DIR in your build script for CMake to find SDL2. In fact the fewer custom variable in your CMakeLists.txt, the better. Instead, set the SDL2_DIR path in CLion's CMake options (located in the settings). For example "-DSDL2_DIR=E:/Work\ Related\ General/C\ Projects/Libraries/SDL2-2.0.8/x86_64-w64-mingw32" 3. Never use include_directories() in modern CMake, it's the devil! It'll bite you in the end. You don't need it at all if you use step 4. The include path will automatically be added when you link it with the proper target. 4. Replace target_link_libraries(Test ${SDL2_LIBRARY}) with target_link_libraries(Test PRIVATE SDL2::SDL2). Check out the video https://www.youtube.com/watch?v=bsXLMQ6WgIk for more help with CMake. This is the best talk explaining it. 
I am truly amazed
This is pretty cool. I'll check it out once I have a bit more time. My main critique at a glance is I'd prefer if you explicitly chose a standard. As it stands I think this will default to `-std=gnu90`, but for portability you may want to explicitly use a C standard in the future. Still, solid project.
I mean this is cool if you want to learn stuff, but then why wouldn't you use C++ implementation for production software? This reminded me of "We programmers made a lot of things because we could, but never stopped to think whether we should" ( I don't know the source).
I absolutely agree with you. But after all, this is a library for pure C. I do not know how it would be possible to transfer containers from C ++. In C, there are no language constructs that exist in C ++. For example, there is no template mechanism. 
And you can't go wrong learning SQL and some shell scripting. Learning frameworks and libraries takes a long time. Learning languages certainly doesn't.
Thank you didn’t know about r/avr... And the ATMega32 library’s are built with C so it’s related to C programming
C programmers are very conservative in that they would rather use simple arrays than vectors and the language constructs such as templates in C++ are generally not suitable for C programmers since they are more memory-oriented than type-oriented. I don't want to discourage you however, maybe someone someday will find your code useful.
So registers are basically allocated at a static position in the memory?
&gt; ATMega32 library’s are built with C so it’s related to C programming Your questions do not pertain to usage of the library, they pertain to chip specs. At best I could see your questions begging questions that pertain to the library, but at no point do you explicitly mention it. This subreddit exists to discuss the C programming language. Please redirect your questions to r/avr.
Here's a sneak peek of /r/avr using the [top posts](https://np.reddit.com/r/avr/top/?sort=top&amp;t=year) of the year! \#1: [My life has got 6% better since I started crimping my own cables](https://i.imgur.com/skPPiXw.jpg) | [6 comments](https://np.reddit.com/r/avr/comments/7hc5h7/my_life_has_got_6_better_since_i_started_crimping/) \#2: [My first completed avr project](https://i.imgur.com/QJGGvCR.jpg) | [8 comments](https://np.reddit.com/r/avr/comments/7bycer/my_first_completed_avr_project/) \#3: [Atmel site down, super annoying!](https://np.reddit.com/r/avr/comments/7ozahc/atmel_site_down_super_annoying/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
I have some experience with the topic at hand, on an ATmega328P (the common one in Arduinos). 1) Unsure what you mean by this, see my next answer. 2, 3) TWCR is a register yes, the I2C control hardware has a bunch of assorted registries. I'd recommend reading the ATmega328P manual, it is slow reading sometimes but tells you everything you need to know. Roughly the usage of the I2C hardware is this: You set a registry to indicate the desired communication frequency. Naturally this must be supported by the device you wish to control. You tell TWCR and related registries that you want to operate in Master Write mode or Master Read. Yes you have to use TWCR *IF* you want to use the I2C hardware support. You can always bit-bang I2C (i.e do it yourself, with all the caveats this entails)! I'm gonna assume you want to use the hardware, so everything I say from here on is under that assumption. No, you can probably not chose exactly the frequency you want. It's in the data sheet along with the exact formula for calculating the registry bits. avr-gcc has a header with some helper stuff, twcr.h I believe. The hardware is made under the assumption that you want to do I2C 100kbit, 400kbit or something similar. 4) The TWCR and associated hardware manages the protocol for you. So you don't really care about the clock at that point. All those things are abstracted away by the registries, and you only have to follow the procedures laid out by Atmel. The AVR chip communicates with the device, you tell it what to communicate. 5) This seems unrelated to I2C so I'm going to assume you just mean PORTB for example. Assume you want to set pin 0 and 1 of PORTB, then you simply do a bitwise operation: PORTB = (1&lt;&lt;0) | (1&lt;&lt;1); equiv. PORTB = 3; If you want to preserve the state of the other pins: PORTB |= (1&lt;&lt;0) | (1&lt;&lt;1);
Thank you, assuming I don’t want to use TWCR, (but bang): How do I control my clock speed? Assuming I use a loop?
Probably just poor understanding of socket programming by the previous programmer. Fix it and move on
Absolutely. There are dozens of us willing to help. Unfortunately, we are not mind readers. In the future please detail the nature of your project and the nature of your problem(s). If you have code, show it. We are more willing to put in effort to help you if we can see you're putting in effort.
I'd say it depends on how precise you need to be. If you really want to do one high and one low each second, like 1 Hz, and you have some strange device that is fine with this, then you can just go with a _delay_ms (which is a busy wait), or use one of the hardware timers. Higher speeds, you probably need to count cycles and maybe even be mindful of things like GPIO-timing (it takes time for a pin to go from 0 to 1 etc.) By this point you'll probably have to use assembler or be very sure about what the critical piece of C code will compile to.
How do you count cycles?
Do not repost a post I removed.
Let's say you have some code with three instructions. You know that these instructions take one cycle each. You know your CPU frequency. For simplicity's sake our CPU is really bad and takes one second to complete an instruction. Your three instructions will then take 3 seconds to complete. We can use this to design our own _delay_ms. If our CPU is operating at 16 MHz, we have 16 million cycles per second. So 1/16e6 = 0.0000000625 s. 0.001/0.0000000625 = 16000. Thus we need to wait roughly 16000 cycles (about 16000 NOP) for 1 ms to pass. https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_NOP.html See bottom, where it says "Cycles: 1".
amd why do you think I wrote V1 in there there's yet more to come
Noted. thanks for the suggestion.
Thanks for the detailed response! I actually started with web development when my friend taught me what HTML was. I've never done in-depth work with PHP, and I might really want to look into it! Thanks!
I decided on C after I did some interning for a company that built some banking software that was Unix based. I was talking to the head of their department and he recommended that I focus on learning C/C++ and Java because of their applicability.
Oh yeah! And BASIC while I'm at it.
Noted! Thanks!
I think you're on the right path with doing C, then progressing to C++ and Java then if that's what's been recommended.
Thank you. Yes, this is really an interesting idea. I will think about it.
I recognize some of the words! I think maybe if you posted a comparison with the ICC compiled code, that would help people understand, but maybe this is just over my head
Good to know! I always assumed the ABI required sign extension of smaller than word sized types. I mostly use clang so that may explain my false assumption.
10/10 would submit to Computing Science professor in hopes of extra credit
x86-64 has sixteen 64-bit general purpose registers: rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, and r8–r15. You can access the lower 32 bits of the first eight registers as: eax, ecx, edx, ebx, esp, ebp, esi, and edi (e.g. change the "r" into "e"). The "e" means "extended" since x86 was originally a 16-bit architecture and these are the 32-bit extended registers. The original eight 16-bit registers are: ax, cx, dx, bx, sp, bp, si, and di. These names access the lowest 16 bits of each 64-bit register. When functions call each other, they need to coordinate on argument passing, how a value is returned, how control is returned, stack alignment, etc. — a *calling convention*. There's an [x86-64 ABI](https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf) that defines a single calling convention, and code from different compilers can call each other. (Rather than play nicely with everyone else, Microsoft went off and invented their own ABI called x64, but I won't be discussing that here.) According to the x86-64 calling convention, the first integer/pointer argument is passed in rdi. An integer/pointer return value is stored rax when control returns to the caller. For example, take this C function: long times2(long x) { return x + x; } Might compile to (keeping this simple): times2: mov rax, rdi add rax, rax ret If the argument is smaller than 64-bits, only part of the registers are used for passing values: int times2int(int x) { return x + x; } May compile to: times2int: mov eax, edi add eax, eax ret Suppose the argument is even smaller, just 16 bits: int times2short(short x) { return x + x; } Since C says the addition is computed as int (32 bits), and also since it will be returned as an int, this short needs to be sign-extended first. Here's what gcc 7.3 does: times2short: movsx eax, di add eax, eax ret It didn't make any assumptions about anything but the lowest 16 bits of rdi. It spent an instruction (movsx, "move and sign extend") to sign extend to 32 bits. Here's Clang 6.0.0: times2short: lea eax, [rdi + rdi] ret Clang is using lea (load effective address). It's a way to leverage memory addressing to compute simple kinds of expressions without actually accessing memory. In 64-bit mode, addresses are always computed with 64-bit registers, so here it's using the full rdi register despite its argument only being a 16-bit short. The caller is under no obligation to ensure any bits above the lowest 16 have any particular value, but Clang assumes they're zero. If they're not zero, then this function may return the wrong value. Both Clang and GCC always extend 16-bit arguments to 32 bits before making a function call. For example, int wrap(short v) { short x = v * v; return times2short(x); } GCC 7.3 is defensive: wrap: imul edi, edi movsx edi, di jmp times2short ICC 18.0.0 is not: wrap: imul edi, edi jmp times2short Oops, the upper 16 bits of edi are filled with garbage! If times2short() was compiled with Clang, and wrap() was compiled by ICC, the resulting program would compute the wrong value for certain arguments to wrap(). The ABI probably *should* specify that arguments smaller than 32 bits are zero / sign extended, but currently it does not, and ICC exploits this. 
Truly we live in wondrous times
I am not sure what the problem is? Is it the array of characters you are referring to or the pointer to a note?
If you know the size at compile time: struct foo { struct bar data[NBARS]; }; If you only know the size at run time when allocating an instance of the struct... Pointers like you have, or a flexible array member: struct foo { int nelems; struct bar data[]; }; ... struct foo *f = malloc(sizeof(struct foo) + sizeof(struct bar) * n); f-&gt;nelems = n; f-&gt;data[0] = something; // Etc.
This is how the Redis [sds](https://github.com/antirez/redis/blob/2.8/src/sds.h#L47) dynamic string object works. It's a really elegant solution because you can pass the dynamic object around as if it were a normal NULL terminated `char*`. Note: I linked to an old version because although newer versions still use this [strategy](https://github.com/antirez/redis/blob/4.0/src/sds.h#L83), it's a bit harder to follow because there are now several header encodings.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/antirez/redis/blob/2.8/src/sds.h#L47) - Previous text "sds" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
What output *are* you getting?
If your printf isn't working at all it is because you forgot the '#' before "include&lt;stdio.h&gt;". If you're getting 50000.000000, it's because your using a float instead of an int. Other than that, your program should work...
The code works fine for me and produced the intended output https://www.onlinegdb.com/online_c_compiler See compiling it here for yourself. Maybe something wrong with your ide or compiler i guess.
That definitely shouldn't be happening. Are you sure the program you're compiling is the same as the one you posted? If you don't have a '#' at the beginning of "include&lt;stdio.h&gt;", be sure to add that, but it doesn't seem like that is that is the problem you're having.
Yes I went through the link you provided me. But I got output 0.000000 instead of 50000.
Yes I put # at the beginning. But I am not able to understand why I am getting wrong output.
Doesn't the malloc initialize it? I have the same malloc in the main function as I do in the menu function, but only the write in the menu function crashes. 
That's strange i put the exact same code and got 50000.00000.
No. malloc gives you memory but makes no guarantees about its contents
Oh.. yes it shows 50000.000000 But can you expect where is the problem? Is it in my compliler ?
thanks. I like the way you did the dayspermonth function.
Hard to say without the `C_lex_pos` function, but you could try building both versions with the `-S` option and then doing a diff on the generated assembly. My _guess_ is that your compiler unrolls that loop either way since the number of iterations can be calculated at compile time, but then again I might be horribly wrong.
I'll take a look at the assembly code, but why does the C_lex_pos function matter? It's receiving the same inputs in both cases. I'll post it here if you want to see it: // Determine lexicographic position among remaining elements. unsigned C_lex_pos(uint8_t *comb, unsigned remain) { unsigned pos = 0, i; for (i=1; i&lt;=remain; i++) if (comb[0] &gt; comb[i]) pos++; return pos; }
Here is the assembly for [i=8](https://pastebin.com/H6wtFtk4) vs [i=7](https://pastebin.com/ZGBcrunB). The main difference seems to be in .L156. There appears to be 3 additional instructions in the i=8 assembly code, which is what I expected to be the case. And yet, it still runs faster.
Fewer instructions doesn't necessarily mean faster run time.
I am using TURBO C++ 
This subreddit exists to discuss the C Programming Language. Please redirect this cross post to r/cpp_questions.
OH GOD WHY.
Because of branches and jump? Or are you talking about something else?
Clock cycles per instruction and speculative execution and branch prediction and cache misses and lots of other things. CPUs are complicated beasts.
Everything you stated, if not wrong, we know already. Believe me, some people here *know* C, far better than you, judging from what you write here. The GNU Compiler Collection indeed supports C and C++. It also supports FORTRAN, used to support Java, etc. Yet, they aren't the same language. Also, yes, GCC has automatics to try guess whether to compile code as C or C++ ... but this has nothing to do with all this. C++ was built on pre-C89. AFAIK even the first C++ standard was no superset of C. And since, the languages have diverged, but the committees have discussed to jointly add certain features, because C++ has a quite good C-interop and this was long the reason to use it. Many changes have been done in C++, but also quite some people do not see them as "improvements". I recognize that C is not perfect and some things C++ *tries* to improve but it fails because of the limited possibilities they have to hack their solution together. So, if you use the Arduino IDE, you write C++, albeit C-style C++. If you use gcc in C mode, you can write C, for sure. What you wrongly name "libaries" are headers, and those usually have some ifdef-guards for cplusplus, st. you can use those libraries with C++ and C -- but what they are originally written in does not matter, because the interface works for both. Finally: Refrain from subtly insulting "smart... unlike some other people" and keep it civil. Some people on here definitely know C and C++ better than you and you should accept that. C++ is not just an improved C, despite Bjarne maybe wanting it to be and the Microsoft VS C/C++ team treating it so.
Is this the only incompatibility, or might there be others ? In other words, if you don’t use any (signed) arguments smaller than int in your interfaces then should everything else be OK ?
What’s wrong with include_directories?
If you get 50000.0000, that’s because you multiply 2 floats. I think that’s the expected result. You can solve this by using a setprecision function or converting your y to an int. :)
Are there any sort of warnings or error message produced?
Damn that pun. Have my upvotes, all of them.
I see two possible effects: * it is ever so slightly faster to compare a number with zero than with any other number, especially if the variable was modified right beforehand * your second version has less arithmetic operations in the indices, allowing the compiler to generate slightly faster code This might already be enough to explain the effects, but I can't say for sure.
Did you enable optimization? Something like -O2 or maybe -Os. The assembly output looks like it's not enabled. Also `static` for C_lex_pos (and other functions whenever possible) may improve runtime.
OP is saying the second version was slower 
Oh indeed, I totally missed that.
This is the only incompatibility I know about. It effects both signed and unsigned integers smaller than int, since ICC will not zero-extend arguments either. Here's ICC 18.0.0 again but with all unsigned shorts: int times2short(unsigned short); int wrap(unsigned short v) { unsigned short x = v * v; return times2short(x); } Output: wrap: imul edi, edi jmp times2short A Clang-compiled times2short() would effectively receive the full 32-bit multiplication result since ICC doesn't truncate it to 16 bits before passing it. GCC puts a `movzx edi, edi` between these instructions to truncate and zero-extend. 
What do you expect the line `head=(Node*)malloc(sizeof(Node));` in `menu()` to do? Or in other words, what happens with the list you pass to `menu()` when you assign the result of the call to `malloc()` to `head` in `menu()`?
Thanks for the interesting read!
Only 1 `ungetc()` is guaranteed, you should not call it several times in a row. 
Wow a non-beginner post on /r/C_Programming! Keep this up!
Yeah, I know. Easy fix though, give me a minute.
Please edit the submission to format the text as code, this isn't readable.
Your code looks like shit and you are a faggot for abusing mod powers to sticky your trash code for attention.
There, fixed.
Is it readable now?
Hmm, I've never seen `while (x = y, x != z)` before, I kinda like it (as opposed to `while ((x = y) != z)`). Btw, &gt; `cahracter`
`-O*` means optimize -- `-O2` is the "level 2" optimizations. The default is not to optimize, since it makes debugging way harder (and, for backwards compatibility/tradition).
If the format of your input is roughly what you showed, you might be able to use [`strchr`](http://en.cppreference.com/w/c/string/byte/strchr) and [`strrchr`](http://en.cppreference.com/w/c/string/byte/strrchr). I would have these search for the first and last spaces in your string, and they'll give you a pointer to each. That gets you 90% of the way there. The last 10% deals with string termination, and here you have a few options: 1. Don't bother terminating the strings at all. You'll have to calculate the size manually using the pointers if you're going to use `printf` or any other string functions. 2. Terminate in-place. This is how `strtok` works -- basically, modify the original string to change the spaces you found into `'\0'`. (Note: this won't work with the read-only string literal in your example, but I'm guessing the real code isn't going to be like this.) 3. Copy the strings into separate buffers and terminate them. Basically, you use option 1 just long enough to call `strncpy`, and then you can deal with them like C strings.
Modern CMake is all about assigning properties to targets and letting CMake figure out the proper flags for the correct build system and compiler. include_directories works on a directory level, meaning it becomes messy once you want to link to them elsewhere. It's much better to use the target_include_directories with your target. For example, add_library(mylib mylib.c mylib.h) target_link_libraries(mylib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) Now as soon as you use target_link_library from another target with this library, that target can also find the headers, regardless where the source of the other target source is located. Using include_directories makes this very messy. It might work now but it quickly becomes unmanageable. It's best to avoid it whenever possible.
For (1) I could have made a `while` loop, but this would indicate that repetition is the normal control flow. Rather, discarding continuation lines is an exception. This is indicated by a goto instead of a loop. For (2) I wanted to express that this is basically a state machine matching a fixed string. If we don't match the string, we reject the input and continue.
It's weird as fuck, I would reject such code on first sight. Gotos should be used sparingly and only as a way of early return with cleaning up, but using them in the main logic as control flow... no, thanks!
Global variables (even with external linkage). Variables named `c0`, `c1`, `c2`... Using `goto`s when loops would've sufficed. God have mercy Big FUZ's students. 
-Og is nice when debugging.
Put 4 spaces in front of each line to format code for Reddit. Turn on your compilers warnings. Pay attention to them.
Oh... I just realized that I shouldn't have had two separate heads for the main and menu functions. Deleting the one in the menu seemed to fix the problem. Thanks!
Can you take a screenshot of your code and the compilation messages?
 if (rank == ACE) { // ACE is an enum or define or whatever for 14; avoid magic numbers fputs("ACE", stdout); } 
That was exactly it. Thank you. Now I just got to figure out why its printing [ACE14 of 3].
"Does anybody have a clue what I'm doing wrong?" Yes, you should read your C book. 
Don't be rude
I do agree with OP honestly, while gotos for cleanup is the prime use-case, I do think that it can certainly be used as a main control flow device, such as done here. I think it's not even more complicated -- only if one doesn't work with gotos used that way often, ... which honestly is no good reason. If such style would be more common, this issue would solve itself.
* it's an application, so yeah, they have external linkage but it really doesn't matter much. * the naming makes totally sense. Should they be named `character_read_first`, `character_read_second`, ... instead? They are local variables that only serve one, short, dedicated purpose that is perfectly described with these names. We got one student who has variable names which are all long, even the unimportant ones -- the code's a mess. Not much actually because it's all spaghetti, but because it's unreadable. Chosen wisely, the variable name length can even communicate the importance of a variable. You know what to focus on -- but in such code, everything basically craves for attention and one doesn't know where to start. It's really difficult to read. * The students are doing fine, we so far have a much lower drop-out quota than average courses in CS here and I think we managed to achieve a great balance between challenge and manageability.
 char *strings[3]; char *p = string; strings[0] = string; for(; *p &amp;&amp; *p != ' '; p++) (void)0; *p = '\0'; strings[1] = ++p; for(; *p &amp;&amp; !isdigit(p[1]); p++) (void)0; *p = '\0'; strings[2] = ++p;
&gt;"I agree, it just looks right" &gt;"I do agree with OP, honestly" &gt;"The students are doing fine, **we** so far have a much lower drop-out quota" Is that you FUZ?
This subreddit exists to discuss the C programming language. Please redirect this to r/cpp and/or r/csharp.
any idea, why this may be the output from the above? [Imgur](https://i.imgur.com/hxTQ5At.png)
Hard to say without the code, but my guess is you're still printing the number along with the string representation. If you post your code it'll be much easier to help :)
Like /u/raevnos said, you need to format all of your code by prefixing each line with four spaces so that it renders correctly on Reddit. It's much harder to help if we have to transcribe the code. You can also just include a link to your code on something like pastebin.com or gist.github.com.
https://pastebin.com/JfmWmfsc
It's printing both because you're printing both :) You're calling this: printf("%d", getValue(currentCard)); That's going to print the return value of `getValue` which for ace is apparently 14 (you return it by doing this `return current-&gt;value;`). But in `getValue` you're doing a `puts` of "ACE". So `getValue` prints "ACE", and then the `printf` prints 14 resulting in "ACE14" You could just call `getValue` without the printf. You might want to change it to `printValue` though if it's going to print the value. 
Wow. Always something very small being overlooked. Thank you guys so much for your help.
Use `strchr` to find the first space. Copy everything before that into a location to store the first thing. Use `strrchr` to find the last space. Copy everything after that to some place to store the last thing. Copy everything between the two to another space for the middle.
A segfault is the OS reporting that your program is doing the wrong thing with memory. You need to fix your program. If i was grading you, i wouldn't give you a pass if you just tried to ignore your program segfaulting.
It is not the language that is reporting the segmentation fault. It is your OS preventing your program from accessing memory it has not allocated. If your program really is operating correctly until near the end you could be trying to free memory that “isn’t yours” or something like that. 
I agree with other comments that you can’t (and shouldn’t) just suppress a seg fault. There must be something incorrect in the way you’re handling memory. You might have a better chance of getting some help if you post the code as well.
God no. Tail calls are evil
The reason I am trying to cheese it like this is because they mark the course I'm in with an auto-grader that just looks at the output. If it sees "Segmentation fault" it gives you a zero. pretty dumb but i'm desperate
I mean, you *can* install your own signal handler that just does nothing, but that's not the right thing to do here...
Our bad, we are working on the documentation for the tool. The license checking is a standard part of SCA - we try to identify open-source libraries/code fragments that you're using in your project, and try and notify if those are licensed under an agreement that is restrictive for your use case. Basically, we try to minimize legal risk from use of open-source components in your project. Its a part of code-related risk management - vulnerabilities are security risks and licenses are legal/compliance risks.
compile with debug info and fire up gdb
We will be soon adding that to our dashboard, so keep a look out! :) But if you'd like to take my word for it, we cover almost all CVEs and Security Bugs (~25000) for C/C++ as of now.
https://photos.app.goo.gl/pRB285cpnLrq4W0i1 Click on the above link to view thr screenshot
And that, estimated C developers, is why most blame C as buggy programming languages! They rush on to get a program running regardless of warnings, and sometimes with success. Late, we have to hear a lot of bullshit... 
No. It didn't show any error or warning messages
But how converting y to an int gives the correct output. 
Have you run your program under valgrind? It's an invaluable tool that will likely show you _precicely_ where the corruption occurs.
Is it not a good compiler ? Which one do you recommend for C/C++ ?
Well, let’s be honest. C, by nature, is a language open to bug. It’s not a safe language, nor easy, and that’s why so many people do bugs. Who can say they write safe and good C? Not a lot...
Yes I did, but it didn't help very much because I am not familiar with what the things it is telling me actually mean.
&gt; Who can say they write safe and good C? lame
What is cbt declared as? An array of how many elements of what type?
static unsigned cbt[15];
You might look into SIMD. If you can use AVX2 instructions, you can load the first 8 elements into a ymm register and do the first three increments of each switch case all in one go.
Binary tree contains 15 nodes, all initialized to 0. There are 8 leaf nodes that correspond to values 0 through 7. The function essentially takes a value between 0 and 7, and increments nodes from the root of the tree to the corresponding leaf. That's what all of those add instructions are. After this is done, a small amount of arithmetic is done that depends on how many times the path down the binary tree goes through a right child to reach a given leaf node. Whenever the path goes through a right child, the value stored in the left child node needs to be subtracted in the return value. [Here](http://jlearnplus.com/wp-content/uploads/2016/05/fig3.png) is a diagram that shows how the values in the array are numbered.
Its ~250 lines. I would link it if I knew how...
that's why rust exists. those types of errors rarely make it past the compiler
Thanks for the advice. I'll take a look at that in a bit.
Um. No. It's a terrible compiler. It's been hopelessly obsolete for over 20 years now. It's a **DOS** compiler for crying out loud! If you're trying to use it with C++, it predates even the first version of the language standard. It won't even compile most old C++, much less anything modern. Nor does it support the last few versions of C for obvious reasons. Given that it's not 1992, it's hard to find a compiler that's *worse* than Turbo C++. gcc, clang, Microsoft Visual C++ are the big three... and all are lightyears better.
i'm only buzzed and it's after midnight here. HOWever, i totally get it. some people *can* write good C. no doubt. but the opportunities that C allows for bugs and security vulnerabilities makes it pretty unaproachable, despite being taught to n00bs at universities.
You are probably telling fread to read more data than *curr* can fit. This goes unnoticed because for a low *i* it'll just overflow into the following array elements, which will be overwritten on the next loop anyway, but near end it'll overflow beyond the end of the array causing a segfault.
Mhm okay thanks! I did find some websites with solutions along with explanations
I think that's a matter of taste, but tail call elimination is an optimization you shouldn't depend on when presenting "normal" codw to students.
Your program fails to recognize `**/` as the end of a comment. Or really just any even number of stars before a slash.
1. As 6 different arguments. 1. As an array. 1. As a struct that has 6 fields in it. That's about the extent of your options. Which one is best depends on the details.
Not sure if its the best solution but you can return an array.
At first even I felt good that I have exercises to practice and everything. It became difficult once the author started giving exercises for which I need to use some things like pointers, bitwise operations etc which I have no idea about and had to open up wikipedia to learn about them.
As arguments? void my_function(int a, int b, int c); As a struct struct arg_s { int a; int b; int c; int d; } struct arg_s my_function(struct arg_s args); 
*curr* has previously been malloc'd by *(sizeof(struct) * listLength)* Do you think this could still be the problem?
My partner and I were able to solve it. Thank you!
My partner and I were able to solve it. Thank you!
My partner and I were able to solve it. Thank you!
Take a look at the K&amp;R book. I found it very approachable when I was starting out, at least the first few chapters: https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628 
I think that's the book OP is talking about
"The C Programming Language" was written for existing programmers (particularly those who knew Pascal or FORTRAN) who wanted to learn C. It's certainly a book which requires a little bit of prior programming knowledge. I don't know any C books for absolute beginners, but if the language isn't *that* important to you I'd recommend "Programming: Principles and Practice", a book whose main goal is to teach you programming *using* C++. 
Dead link :3
Damn - looks like that list has been deleted from StackOverflow now. I’m not aware of any other similar list, so that’s a loss.
Please use a code-sharing site like pastebin or github's gist instead of... whatever that is. Much more user friendly. Anyways... % gcc -Wall -Wextra ping.c ping.c: In function 'setup': ping.c:15:23: warning: unused parameter 'sig' [-Wunused-parameter] static void setup(int sig, siginfo_t* siginfo, void* context) ^~~ ping.c:15:54: warning: unused parameter 'context' [-Wunused-parameter] static void setup(int sig, siginfo_t* siginfo, void* context) ^~~~~~~ ping.c: In function 'hitBall': ping.c:34:2: warning: null argument where non-null required (argument 2) [-Wnonnull] sigwait(&amp;su2, NULL); ^~~~~~~ ping.c:29:25: warning: unused parameter 'signo' [-Wunused-parameter] static void hitBall(int signo) ^~~~~ ping.c: In function 'main': ping.c:63:79: warning: ordered comparison of pointer with integer zero [-Wextra] if (sigaction(SIGUSR1, &amp;action, NULL) != 0 || ((action.sa_handler = SIG_IGN) &gt;= 0 &amp;&amp; sigaction(SIGUSR2, &amp;action, NULL) != 0)) ^~ I suspect your problem comes from ignoring one of these warnings that is more important than the others.
Check the number of bytes read by fread, if the value is different form sizeof(struct) exit the loop. Is the struct size constat in every iteration? Is listLength the number of structs in the file? If so you could read the entire file into the array of struct.
No.
Hm.. Interesting. Let me fix this.
Since this is a sub for C, and not C++, your question is probably best asked in /r/cpp_questions.
Thanks! 
I assume `struct` is just a placeholder for the struct's actual name? Or do you literally do `sizeof(struct)`?
no its not, not for beginners
I found it on waybackmachine: https://web.archive.org/web/20171027171621/https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list/562377
how about modern C http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf Who cares what book you use. Learn enough to get ideas, try to implement the ideas. Then come back to reading. Use multiple sources. Use IRC, stackoverflow, google, when you have questions. You aren't the first or last person to get confused with pointers. There's a lot of clarification documents online, even on youtube. This is binky the clay pointer animation from 1999 https://www.youtube.com/watch?v=f-pJlnpkLp0 http://cslibrary.stanford.edu/
I too started with higher level languages before moving to C. It quickly became my main language. When I started, I felt I had a very firm grasp of the basics. I didn't need to learn how control flow worked, or the differences in variable scope. So I started with [tutorialspoint](https://www.tutorialspoint.com/cprogramming/index.htm) to jump-start me on all the syntax. I had some exposure to C++, so a lot of it looked familiar. The thing I liked about it so much was how heavily compartmentalized it was. I could, and did, skip anything I recognized as something I already knew. Bear in mind, this wasn't a perfect resource and it only taught me syntax. It took me a long time, trying (and mostly failing), at writing programs in C before I felt like I had a good understanding of how to do it. I'm also still learning new information constantly. Were I you, I would start by getting really comfortable with the syntax of C. Make sure you understand how to use your IDE or command line tools. I had several years of experience with the command line before I started C and it was a huge boon to my education. From there, the biggest hurdles you're likely going to have are pointers and dynamic memory allocation. Once you understand one the other makes a lot more sense. Then, start doing your Algorithms and Data Structures work. You don't need to understand pointers and allocation perfectly going in. I went in understanding specific use cases and I found that the work I did with algorithms and data structures really brought me up to speed on the use of pointers and memory allocation. This method may not be for you, but it worked for me, and I hope that my advice was helpful. If you ever get stuck or have more questions we're always here.
To understand data structures, you need to learn to use pointer really well, and how to use them efficiently in structs. Also malloc is your friend, learn how and when you need to use it. If you understand how a binary tree works, you are almost done with the basics. As for algorithms, you just need practice. You'll face them while studying those data structures, since you often need recursive algorithms to push and take data from them.
To do anything interesting in C, even print "hello, world!", requires pointers. That's why he uses pointers without first teaching about them. 
I am comfortable with the syntax of C, it's pretty straight forward. And I feel like I have a 'good' understanding of C and its innerworkings. What I still need to learn are indeed pointers and dynamic memory allocation. I fear it would take me too long to understand those topics to start learning algos and ds. 
Weekends are on the table too, but still I have a limited time during them. My resource for learning A/DS is this: https://www.amazon.it/Data-Structures-Algorithms-Made-Easy/dp/819324527X I really like the book.
Okay, what are your goals? Are you just trying to get through the book? Is there a particular thing you're trying to learn, or do you just want a good overview? How quickly do you need to accomplish your goals in regards to understanding A/DS?
That book is more about mastering C than learning it. I would only look to it after you're decently comofortable with the language.
What's your platform? I'm assuming your program is being run from the terminal you're trying to close? In my experience this is generally easier to do outside of C. Like, you could write an alias or script for your program to run the program and then exit.
No I need an overview more than anything. Just so I have a better grasp of how to approach problem solving in more complex situations. I thought of just simply learning them in JS so I don't need to learn C but I have the feeling JS is not the right language to learn DS and Algorithms. Most resources use either Java (which I simply dislike as a language and don't want to see) or C/C++ that's why I went for C.
Yeah, I would say JS is a little too high level for complex data structures. If you don't have a deadline for learning A/DS, I wouldn't worry about spending too much time learning C. Pointers, memory allocation, and low level programming are all really valuable concepts beyond just C and A/DS.
I kind of have a deadline, around 50 days, since it's tied to a possible promotion/change of position and it requires a good overview of data structures. I fear that it would take me way too long going through C and that book, even if I studied 2-3 hours a day. I can pick up new topics at a good speed, but picking them up and absorbing them are two different beasts. I've found this book, and I've heard good things about it and it focuses on interview-like problems: https://www.amazon.com/Data-Structures-Algorithms-Using-JavaScript/dp/1544911149/ref=asap_bc?ie=UTF8
Cool - thanks for finding it! 
No blog spam please.
No blog spam please.
If you are desperate, you can just end your program with `_Exit()`. This avoids flushing the stdio buffers, hopefully avoiding your crash. Though, you should really fix your code.
&gt; 50 days That might be tough, but I think you should still try. Even if you don't finish the book in time you're still learning valuable skills, and there will likely be other opportunities in the future. &gt; I've found this book If the position you mention requires javascript alone then it may be worthwhile to use that book instead. Learning for the sake of learning is all well and good, but it's important to keep your goal in mind. It really comes down to what your employer is looking for in a candidate for the position you want.
That's not what I call "normal code". It shouldn't take 10 minutes to understand 5 lines of normal code. Comments could help much but they are lacking. If we take the first example: /* * read one source code character into the read ahead buffer. * This function interpretes trigraphs and continuation lines. */ static int input(void) { int c0, c1, c2, c3; begin: c0 = rawinput(); switch(c0) { case '\\': c1 = rawinput(); if (c1 == '\n') goto begin; /* not a continuation line */ backup(c1); return (c0); case '?': c1 = rawinput(); if (c1 != '?') { backup(c1); return (c0); } c2 = rawinput(); if (c2 != '/') { backup(c2); backup(c1); return (c0); } c3 = rawinput(); if (c3 == '\n') goto begin; backup(c3); return ('\\'); default: return (c0); } There is almost zero comment *inside* the function describing the action steps or the action steps purposes, or the flow. The external comment is wrong. Truth is the only role of the function is to detect continuations from normal characters; and those continuation can have 2 forms: the regular one, and the trigraph one. Internal comments should at least explain which sequence is being detected. case '\\': // let's check if we have the "\\\n" sequence (backslash (\) followed by newline) case '?': // let's check if we have the "??/\n" sequence (trigraph equivalent of backslash (\) followed by newline) The `goto begin` should have a small comment too, like "// ignoring the continuation sequence" or something. The comment `/* not a continuation line */` should also be present at the end of the second case (trigraph case). Another comment to explain why one returns `'\\'` (substitution of a regular character instead of its trigraph expression). BTW, I don't know why you substitute this trigraph, was it in the exercise requirement? Why substituting this trigraph and not the other trigraphs? That's not consistent. --------- If we consider the second example: do { discard(); c0 = input(); if (c0 != '*') continue; c1 = input(); if (c1 != '/') continue; break; } while (c0 != EOF); What happens when the first input returns `'*'`second `input()` returns `EOF`? It is not clear **at all** from reading the function. One need to go see the `input()` function and examine its internals to see that it is OK, because the next `co = input()` will also return EOF (in 99,999% of situations, and if it doesn't it won't cause trouble anyway). A comment should explain this. BTW, the loop construction makes it so that you jump (`continue`) to the loop condition test (`c0 != EOF`) even when you know that `c0` is not `EOF` but `'*'`. So you test something that doesn't need to be tested, but you do not test the one that should be tested (`c1`) for `EOF`... So maybe a comment is not needed, but a correction of the logic of the function would be much better. -------- Same goes for: static void stringchar(int delim) { int c; do { c = input(); if (c == '\\') input(); copy(); } while (c != delim &amp;&amp; c != EOF); }
Try [Project Euler](http://projecteuler.net)
Project Euler
I have heard about project Euler... But the problems seems a little bit complex for my knowledge. Any other suggestions? 
Start with the simple ones. Expand your problem-solving abilities and your knowledge of mathematics and logic by trying to solve the harder ones. Easy problems are not really helpful in making you better, hard problems are what drives you to new abilities.
[This list of projects](https://github.com/karan/Projects) is a good start.
Keep going! If you're feeling stuck, you need to go back and reread previous material. That book is very concise, and it takes effort by the reader to really understand what is being presented.
&gt; If my understanding is correct, unions are like structures. However, objects within occupy the same space in memory correct? Is that why it's only not gibberish when it's the desired type? And what would the size of it be (i.e. the union itself, a particular object, etc.)? I believe I was told that it goes with the largest item, so if it contained a long and an int it would go with the size of the long, right? All correct.
Awesome! :) Thanks for verifying that. I just remembered that we also need to understand padding and how to be efficient to avoid wasted space (as wells as holes). How exactly does ensuring that work? Would I go from the largest sized item down to the smallest like this: struct foo { long a; int b; char c; }Foo; 
&gt; Would I go from the largest sized item down to the smallest like this: Yeah, that is generally a good idea. Though in general, you should not worry too much. Arrange your structure members by meaning so it's easy to understand your structure. Space optimization is only important if you have many structure members.
NOPE. Its outdated and its pace is rather rushed on thus it doesn't explain concepts in minor details. I loved King's book because he explains C as in his class. You can find it used too: [C Programming: A Modern Approach - King](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504) 
Thanks for clearing that up. One last thing, do you have any suggestions for understanding bitwise operators? I don't understand what's going on. I found a decent source: https://www.tutorialspoint.com/cprogramming/c_bitwise_operators.htm But I just don't get what's happening with the bits at all.
That tutorial is not very good. Try to find another one. It's really not super complicated but can be a bit confusing if you don't understand what bits are or how boolean logic works.
Hi there, I'll help a bit. # Unions Unions are indeed like structs, but have some major differences, and you hit on the major one. Let's break it down with examples. Structs seem more intuitive to beginners, so start there. typedef struct { data_t pos_x; data_t pos_y; data_t pos_z; } point_t; Here a point_t struct nicely holds the position of a thing in 3D cartesian planes. It's size will be 3 * sizeof(data_t), where data_t can be an int, a float, a double, etc. It will all be in contiguous memory. Unions behave in a similar way, but with a major caveat. With Unions, we are coallescing everything to one place in memory. Thus, the size of the union will be the size of the largest element in it. An example that is useful is registers in simulation for older hardware, such as the Z80. On those processors, most of the registers had high and low bytes, and you could access the full 16 bits with certain instructions. Using stdint.h you could model registers like this using this union typedef union { uint16_t full; uint8_t half[2]; } register_t; In this way, when you store a number to register_t.full, you see the result broken into bytes half[0] and half[1]. Also, if you write to register_t.half[0] you modify the low haf of full and can observe this result. however, despite how this union here looks, my gut is telling me that sizeof(register_t) would be the same as an int on your system because I think C would pad it to a full int in this case since it is smaller than that. # Bitwise This is real easy. Generally, think of it as 4 operations: AND, OR, XOR, NOT ( &amp; | ^ ~ IIRC) Think of the value in a variable (say 4) now convert it to binary (for 4: 0100, with zeros to the left for the full size) and think of another, let's say 5 (LSB is now 1) then apply the bit logic 4 &amp; 5 0100 0101 _____ 0100 = 4 if it were OR, we get 5, and XOR 1 (Wikipedia is good here)[https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators]
If you still need help, just post it to pastebin.com or gist.github.com. As long as the program doesn't rely on a bunch of external libraries I'm sure I can help find your issue.
Bitwise operators are very easy if you consider the binary value of a number. 3 = 0011 and 2 = 0010. How could you use binary shifts to check the oddness of a number? isOdd(int n) { // say n = 3, 0011 int p = n &gt;&gt; 1; // p = 0001 p = p &lt;&lt; 1; // p = 0010 return n - p; // n - p = 0001 } Binary shift up x &lt;&lt; 1 is x*2. Binary shift down x &gt;&gt; 1 is x/2. Write some code and try to solve logical problems with bitwise math and it'll all come together.
Thank you so much for the detailed explanation! I think that at this point I got it all down except for the not (~) operator. Also, I'm not too experienced with converting to binary (I'm hoping we're provided the binary numbers). But in case we aren't, is it easy to do?
Well, we are friends and live in the same city so this is quite to be expected ;)
I ran the supplied code again, but this time trying to work out all of the operators and I think I finally get it! It actually isn't bad at all, I think that I was maybe overthinking this a bit (heh). I know there's calculators online to convert from decimal to binary, but how exactly is it done by hand?
&gt; How would you write the loop? I wrote it like this so it's immediately clear that we won't get into an infinite loop when the file ends in the middle of a comment. The compiler takes care of the redundant test. Let's try... (completely untested, thus possibly wrong): do { discard(); c0 = input(); if (c0 != '*') continue; c1 = input(); if (c1 != '/') continue; break; } while (c0 != EOF); =&gt; /* Discarding everything until we reach a "*/" sequence */ while(1) { discard(); c = input(); if(c == EOF) break; if(c == '*') { /* first character found, let's check the following one c = input(); if(c == EOF) break; if(c == '/') break; // sequence found } } --------------- static void stringchar(int delim) { int c; do { c = input(); if (c == '\\') input(); copy(); } while (c != delim &amp;&amp; c != EOF); } =&gt; static void stringchar(int delim) { int c; while(1) { c = input(); if(c == EOF) break; copy(); if(c == '\\') { /* escape character: the next one won't be a delimiter */ if(input() == EOF) break; copy(); } if(c == delim) { /* end of string or char found */ break; } } } I won't pretend I am immensely satisfied with this one :-D Perhaps rather: static void stringchar(int delim) { int c; do { c = input(); if(c == EOF) break; copy(); if(c == '\\') { /* escape character: the next one won't be a delimiter */ if(input() == EOF) break; copy(); } } while (c != delim); } so that early breaks only concern pathological (`EOF`) cases.
Super super easy! Let's do both! Lets convert to binary first. First we need to notice the difference between [signed](https://en.wikipedia.org/wiki/Two%27s_complement) and [unsigned](https://en.wikipedia.org/wiki/Binary_number#Binary_counting) numbers. Let's start with something you definitely know, counting in decimal. Take any number, let's say 205, and pay attention to that zero!. We assign a power of ten to each place such that the number can be broken down as follows ( 2 * 10^2 ) + ( 0 * 10^1 ) + ( 5 * 10^0 ) for binary, we just swap all those tens with twos, so if we have 5 which is binary 0101 we can break it down as follows ( 0 * 2^3 ) + ( 1 * 2^2 ) + ( 0 * 2^1 ) + ( 1 * 2^0 ) : 205 in binary would be a bit laborious for an example You'll so its essentially sums of powers of 2. Using this, you can count to 31 using one hand! just assign a power of two to each finger. This above should illustrate how to go from binary to decimal. The other way, I may be a bit unorthodox for pencil math. I subtract powerws of two from greatest to least Write out powers of two : 64, 32, 16, 8, 4, 2, 1 Lets pick a number, say 55 less than 64 so we keep 55 and write a 0 now, 55 &gt; 32, so write a 1 (01) and we're left with 55-32 = 23 again 23 &gt; 16 so (11) and 23 - 16 = 7 7 &lt; 8 so write a zero and proceed (110) 7 &gt; 4 -&gt; (1101) remains a 3 3 &gt; 2 (11011) leaves 1 1 = 1 so write a 1 (110111) and boom the end Let's do an interlude for NOT (~) quick since it will help with signed. NOT basically looks at all the bits in a value, and reverses polarity. for example 5 = 0101 ~5 = ~(0101) = 1010 = 10 (in unsigned math) That is unsigned. For signed, linked above, we use two's complement. The most significant bit marks the sign (0 positive, and 1 negative). If positive, proceed as above. If negative, it takes a little more thinking. -1 is all ones (111111111). From there, offset all values from -1. -2 is 1111110, -3 is 11111101, etc. An easy way to remember this is that to get a negative number you can NOT it (see above) and add 1. for example below MSB is sign ~3 + 1 = ~ (0011) + 0001 = 1100 + 0001 = 1101 = -3 the best way to go about it is to do a bunch of exercizes, and check with either a TA or online calculators. And feel free to bounce more questions here.
The issue with C is there's going to be a lot to learn. If you understand what is happening underneath and behind the scenes it gets easier. I would say to take the time and learn this stuff as well, as if you can learn C/C++ you could probably learn any language.
Oops, yep, thanks. It'll be fixed in a minute.
&gt; What I meant is that if you want to run a test comparing the file resulting form this preprocessing and the expected result, you want to have something consistent (either is is specified that all trigraphs (and digraphs) should be substituted, or all shall remain untouched), and the simplest way to achieve this is by not substituting any trigraph. Note that I only substitute trigraphs in what `input()` returns. The text that is copied to `stdout` by `copy()` is taken from `rabuf` which contains the unchanged program input. This is the whole reason why we have this buffer in the first place, if I wanted to not only remove comments but also resolve continuation lines and resolve trigraphs, my code could have been a lot simpler.
No, although we went to the same highschool and teach a C course together right now.
I learned to program with C For Dummies, and I look back on it fondly. You already know some programming concepts so it might be too basic, but getting into volume 2 would probably be beneficial (that's when pointers are introduced). I moved onto The C Programming Language afterwards, and it all clicked.
Unions are basically another way to type cast variables. Basically, you put 2 variables with different sizes (a char and int for example), when the code is compiled the union occupies sizeof(int) bytes (since int is larger than char). 
No, there isn't. There's like 30 of them, frankly I'm just gonna start using what my IDE provides.
&gt; C isn't like webdev dude. Software testing is still important for C
[Codewars](https://www.codewars.com/) is the same kind as Hackerrank, with plenty of small exercises and a few more complex ones.
I use CppUTest for my embedded project. It used the book [Test Driven Development for Embedded C](https://www.amazon.com/Driven-Development-Embedded-Pragmatic-Programmers/dp/193435662X/ref=sr_1_2?ie=UTF8&amp;qid=1522955881&amp;sr=8-2&amp;keywords=test+driven+development+for+embedded+c) to get into it. So far I'm rather pleased with it. There is also [Unity](http://www.throwtheswitch.org/unity/). I don't think there really is a standard framework that everyone uses.
&gt; You need to establish your own signal handler. Why? That doesn't make sense to me considering the existence of SIG_DFL and SIG_IGN.
If you use `SIG_IGN`, the signal is ignored. If someone sends you this signal, it is immediately discarded and no interruption happens. This also applies to functions like `pause()` or `sigsuspend()` that wait for a signal: they are not interrupted either. If you specify `SIG_DFL`, the default action happens. For `SIGUSR1`, this is to terminate your program which is not so useful either. Thus, the solution is to establish your own signal handler which does nothing.
How about you try to do it yourself and come back when you are stuck at some part?
Is the lgdt instruction faulting, or a later one? struct gdt gdtr = {sizeof(gdt_table)*3, (uint32_t)gdt_table}; The limit should be `sizeof(gdt_table)*3 - 1 `
thats a very good catch and I did just change it. But sadly no, still crashes
I haven't looked at it enough to know what's going on, but I don't understand why you're doing: sizeof(gdt_table) * 3 Shouldn't it be : sizeof(gdt_table) or: (sizeof(gdt_entry) * ENTRY_COUNT) If you want the total amount of memory allocated for the array. 
 GDT_MAKE_TYPE(0, 0, 1)) If I'm interpreting the macros correctly, this is making both the selectors readonly. The 1st should be execute, and the 2nd should be read/write.
https://open.kattis.com/ https://open.kattis.com/help/c
Rust actuall ^^^:)
that's a good catch, no dice tho
I really dont know and Im not sure how to check
How much C do you know? You could do a simple check book program.
Have you tried using a debugger? Where exactly does it crash?
I tried reading the entire file in one go and it worked! Thank you!
this maybe dumb but I have no idea how to use objdump with the output that qemu gives me
Basically just run &gt; objdump -d path/to/kernel.elf (might also be named .bin, but whichever file isn’t the ISO basically) The address of each instruction is printed on the left so just scroll to the address indicated by EIP (= instruction pointer) in the QEMU output and see which instruction is under that address.
What does GetName() return? A value that's destroyed when it goes out of scope, or a reference to something that continues to be valid when your functions return?
You should always compile with a healthy set of warnings. Though the warning that alerts on your segfault causing issue should be an error instead imo.
It crashes on the call to GetName().
So my first case? Yeah, that's a problem.
But then why does it work within the nameOf() function?
unless Im not understanding how to do this properly there's no address objdump gives me that is the same as the last printed value for EIP
Good thing you haven't shown us the source code to GetName() or I could have debugged this myself.
You're there to learn not to pass, if they attitude doesn't change you're wasting your time, you won't make it into the industry.
Dereferencing invalid pointers is undefined behavior. One time it could seem to work, another use could cause a crash, or summon Cthulhu. 
Macro arguments should be parenthesized on use in the macro 
Thanks!
changed :) still doesnt work tho
This algorithm that you posted from Stack Overflow is amazing. Thank you for posting it. I implemented it, and it made a difference. Not as much as I thought, but it is still a difference (about 3m 15s to generate pattern database instead of 3m 30s). I was placing too much value on the growth rate of the algorithm, but I'm dealing with small values of n, so it hardly matters. The nlogn algorithm with the binary tree actually ended up taking much longer (about 5 minutes and 30 seconds). I found the corresponding reference to stack overflow in your Bachelor thesis after I learned the algorithm, but it's just too cryptic to me. I'm unfamiliar with too many terms and notations. Sorry about that. Pseudocode is often hard for me to grasp, even when I have an understanding of what it is doing. [Here](https://github.com/AdamHayse/optimal-solve-rubikscube/blob/master/cdatabase.h) is a link to the final product. The encoding function is built into the C_get_index function. There may be some minor improvements that I can make. I'm not sure if storing two path lengths per byte is a valuable time tradeoff for the space it saves. My next step is to apply this encoding to the edge get index function. This seems tricky though because some of the values I don't care about. It is probably solvable with an if-statement. I'll probably figure it out. After this is all set, I think these functions might be optimal enough and I'll start writing the IDA* algorithm.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AdamHayse/optimal-solve-rubikscube/.../**cdatabase.h** (master → 73f9e10)](https://github.com/AdamHayse/optimal-solve-rubikscube/blob/73f9e10b1418056f8560cabe49060f9cee0f49f4/cdatabase.h) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dww1itj.)
I tried compiling the nlogn algorithm with -O2, -Os, and -O2 and -Os. Whenever -Os was present in the compiling, it seemed to run about 45% slower. I'm not sure what caused it. FUZxxl basically solved my problem for me, but thanks for the useful info. I didn't know vectorization was a thing. 
I definitely have to commend you for opening yourself up to criticism. The interactions with u/hogg2016 are a good resource for learning control flow concepts.
Ok, I udated my program but it's still not working. Here's my [new thread](https://www.reddit.com/r/C_Programming/comments/8a6eco/trouble_with_pingpong_simulation_using_signals/).
Ok, I udated my program but it's still not working. Here's my [new thread](https://www.reddit.com/r/C_Programming/comments/8a6eco/trouble_with_pingpong_simulation_using_signals/).
 raw.c_lflag &amp;= ~(ECHO); Do you know what the ECHO bit does if it's set and what that line of code does?
Yes, absolutely. But what I mean is, after the bit masking happens, how does the function know what bit is set and what bit is not? 
 &gt; 12! 12! = 479,001,600 &gt; 6! 6! = 720 
Take a look at github.com/nishanthspshetty/genesis . Its not complete but implemented gdt successfully. Might help you with that. And also if also i have issue with paging. Also reply here when you move paging. Thank you.
Oh I actually thought Modern C was a good book for me to start as the book has sections for each knowledge level
Mhm thanks, I'm aware that this book is not quite up to date with the current standards :3 
Start by turning on compiler warnings, and fixing the warnings.
I think for someone who is patient and does research online along side reading the can get through it. After reading most of though, it seems the author intended it for experienced programmers to double down on how C really works and avoid any kind of pitfall the language offers. It has a list of rules which the author compiles as you go through, and knowing what all of them mean for is difficult for a beginner.
By testing them with &amp;.
Your implementation is miles ahead on readibility.
I have the following warnings on. What should I add? -std=c99 -w -Wall -Wextra
As I understand from your linked page, the `TCSANOW` applies the change *now*, where `TCSADRAIN` applies the change after the what is in the "buffer" (something to be sent/received and managed by the kernel, read [17.2 I/O Queues](https://www.gnu.org/software/libc/manual/html_node/I_002fO-Queues.html#I_002fO-Queues)) has been written to the terminal and `TCSAFLUSH` empties the queue/buffer without actually writing to it. `TCSASOFT` is a BSD and GNU extension that is just a bit flag (so you need to `|` it together with one of the 3 above) and does the same as the `CIGNORE` flag in the `c_cflag` member of `struct termios`, which "ignore the control modes and line speed values" (see [17.4.6 Control Modes](https://www.gnu.org/software/libc/manual/html_node/Control-Modes.html#Control-Modes)).
`-O3` (`-O2` also works, `-O1` does not, at least for me), since it forces the compiler to do more analysis.
You aren't going to like this. In the function `lgdt`: : : "m"(gdtr) : "%ax" : : "m"(*gdtr) : "%ax" A new fault occurs afterwards, though. Running `info gdt` in Bochs verifies that the previous load address was bogus (base of 0x10 and a limit of 24K, printing ~3000 descriptors), and adding in this correction shows the correct GDT: Global Descriptor Table (base=0x0000000000105fd8, limit=23): GDT[0x00]=??? descriptor hi=0x00000000, lo=0x00000000 GDT[0x01]=Code segment, base=0x00000000, limit=0xffffffff, Execute-Only, Non-Conforming, Accessed, 32-bit GDT[0x02]=Data segment, base=0x00000000, limit=0xffffffff, Read-Only, Accessed Feel free to find a nearby pillow, bury your face in it, and scream -- that is the sort of reaction I had when I hit a wall like this my first time working on the related IDT.
&gt; printf("Unsigned char max: %ul\n\n", counter); You're using `%ul` (which is `%u`, an unsigned integer, and just a stray `l`), but `counter` is `int`. Some other calls are also using `%u` for `counter`. You could just have used `longCounter` instead of also having `counter`. Also, they're signed, so for the `unsigned long` counting, `longCounter` won't even get the value "correctly" (i. e. undefined behavior). So it also should be unsigned. You also can share the signed min/max counters (eg. `longCounterSignedMin` and `longCounterSignedMax`). Also the unsigned integer checks can also just use underflow rather than checking for an overflow. If you still want to detect an overflow, then you could also just add some bigger number than `1` and if you see that you've overflowed, you can go back to the before-overflow state and then use a smaller number so you're more exact, so you don't have to iterate through everything. And as it has been already (somewhat) said, signed over/underflow is implementation defined. For the many `printf`s in the beginning of the program, you can just group some together in order to reduce an call, like: printf("Signed char min: %i\n" "Signed char max: %i\n\n", SCHAR_MIN, SCHAR_MAX); Note that the string literals have a limit of 509 characters (in C89; In the C99 draft it is 4095 characters).
Thank you for the explanation. But may I know what is the meaning of word "buffer" ?
I tested some stuff out on my corners pattern database program. I think the code you provided is working in both, but there seems to be some strange behavior with the calculation of the orientation offset. The following code appears to work when I test the database that results from it: // Calculate which orientation number for orientation offset. for (i=0; i&lt;7; i++) add += comb[i] % NUM_CFACES * three_to_the[6-i]; However, when I make a small change to the order in which the orientations are stored by changing the "6-i" to just "i", the database no longer has correct results. In both instances, the database gets generated in the same amount of time, but the 2nd approach produces incorrect results. Why does this matter at all? Isn't this orientation offset completely separate from the permutation offset?
Locking on a file works too. fcntl, flock, etc.
Making sure the string was written...
Do you have an example of how to use this with fork? From what I have read, threads and child processes are different.
ah ok that makes a lot of sense. Thank you!
That is true. But in the program you posted threads would be fine. If you want to use processes, pthreads also has semaphores: https://stackoverflow.com/questions/16400820/c-how-to-use-posix-semaphores-on-forked-processes That would do the trick.
Thank you!!!
Why don't you directly link to your article instead of the landing page? Also, the title is a bit misleading; It should include the complete thing: `char x = -1` Otherwise the actual content seems to be pretty ok.
This looks interesting! How does this compare to Unity?
AFAIK `sleep()` isn't apart of the time library. Try `#include &lt;unistd.h&gt;` instead. Otherwise this looks like it should work.
First you should #include &lt;unisdt.h&gt; in order to use the sleep command. And also, be careful with '=' and '=='. When you want to test "sum equal 7" the second time, you need '==', here you are doing an assignment. One more thing "srand(time(NULL))" means that you initialize the random generator with the current time. You do not need to do it every time in the loop, but only once at the beginning of your program/main-function.
The C language doesn't have *commands.* Do you mean the `sleep` *function?*
Removed as the link doesn't actually go to your blog post. Please repost with a link that actually goes to your blog post.
I solved the problem with the windows libray and the Sleep function, I didn
Looks like gcc output to me, though I'm sure clang's is very similar.
``` ass ```
``gcc version 7.3.1`` They made some changes to the error/warning output somewhat recently.
&gt; sizeof(register_t) would be the same as an int on your system because I think C would pad it to a full int This depends on the ABI in use. It is not a part of C language definition.
The for loops in each child go past single digits and each child writes into a starting point (gotoxy) but once the child gets to 10 won't they overwrite each other on the terminal? 
There's not really any reason for using the second one. I'd say that from the C code I've looked at, the third one is most popular. It's mostly down to personal preference / convention, but one reason that is always cited for that style is because declaring multiple pointers is much more natural. int* a, b; If you're using the first style, you might be mislead into thinking that the second line above declares `b` as a pointer when it is in fact just an integer. Under the third style, it's: int *a, b; Where it is clear that the `*` only applies to `a`. 
Hm, that's a good enough reason for me to start adopting the third style. I hadn't considered that. Thank you.
Also, what about functions that return pointers? int* func() or int * func() or int *func()?
Why yes, GCC, I did mean "fabsl"! How helpful of you! /s
Im going with int* func(). Functions can't return more than one value, so it is pretty clear that you want to return a type "pointer to int". 
Again, personal preference. I tend to use `type * functionName()` because it more closely resembles the style I use for variables: `type *variableName`. I don't actually like the way it looks, but I find myself fighting myself less due to muscle memory using this. I tend to prefer this over `type *functionName()` as it can look confusing when declaring function pointers. Consider `type *(*functionPointerName)()` as opposed to `type * (*functionPointerName)()` or `type* (*functionPointerName)()`. I find `type* functionName()` to actually look the best, and be more clear than the other two conventions, but I find myself constantly fighting it. It has the benefit of not only pairing the type with the asterisk to emphasize the return type as a pointer, it stylizes it differently from my convention for variables: `type *variableName`. Looks good with function pointers too: `type* (*functionPointerName)()`. Your mileage may vary, but in general your preferences should be: 1. the conventions defined in the style guide of the project to which you're contributing. 2. whatever looks and feels best to you.
`gmBListHas_safe`? What kind of naming convention is that? 
I use the same style for returns as regular variables, aka `int *func()`
Two-hump camelcase leading a baby camel on a rope.
Haha! Great!
You are right :O 
Not currently on a machine with a new enough GCC. Does it still suggest it with `-Werror=address` (strict enough compiler flags that converting a function's address to a boolean is an error)?
However the type is `int`, and the kind of type it returns is a pointer-type, the `*` is not part of the type but the declarator (per standard).
The standard says that the `*` is part of the declarator and thus it goes right. Anything else is "against" the idea of how this is represented in C. One could say this was a bad decision when writing C, but if you don't want to change the language you write in, you should put it on the right.
Could you cite this? In the versions I was able to find freely available online (which means they may not be perfect) I didn't see a strict rule verifying your claim. The versions I saw for the *Pointer Declarator* subsection of the standard (sections 3.5.4.1 in C89, 6.7.5.1 in C99, and 6.7.6.1 in C11) don't make this explicit. They *do* use the right aligned asterisk style in all of the examples, so I could see it being a heavily implied rule. However, the generic form of the declarator that I saw in all three was approximately: * type-qualifier-list&lt;opt&gt; D with a space after the asterisk, which to me implies that it *could* have that form.
The grammar in the standard does not deal with whitespace, it deals with tokens. What /u/pink_echoes means is that syntactically, int *foo; is parsed as int (*foo); where `*foo` is a *pointer declarator* and not as (int*) foo; Placing the asterisk to the right indicates to the reader that it belongs to the identifier (forming a pointer declarator) whereas placing it to the left indicates that it belongs to the type name which is just misleading.
My bad. Based on their wording I was under the impression that they meant that the standard doesn't support writing it like `int* foo;` which seemed bizarre to me because every compiler I've used doesn't seem to care. This makes much more sense. Thank you!
Sorry, but the link you sent me isn't that thing I was looking for. My program needs to check the numbers to make them in a corrector order. For example. I type 324, 523, 143 The program gives out in cmd 143 324 523 The numbers need to go from low to higher.
Then I'm not really sure. What's the rest of your program look like? What's the type of `array`?
It's a function that is wrapped inside a macro, I use the ``_something`` convention in parts of my code to refer to separate versions of a function. The ``_safe`` means it has some runtime bounds checking, the program can then be built to disable these by changing some ``ENABLE_SAFE_MACROS`` macro to ``0``. Basically it's a version of a function that should never be called manually, only through something else, that's how I think of it.
Nice work. I was going to suggest not putting the entire API behind function pointers since it could create inefficient, indirect calls that cannot be inlined — which would be giving up one of the natural advantages of header libraries. However, it seems both Clang and GCC are able to resolve these to direct jumps thanks to that `const`. Don't include `stdio.h` in `str.h`. Rather than hack my own structure together by sneaking a pair of `size_t` fields before the string pointer, I'd formally define a struct with a flexible array member. struct string { size_t length; size_t offset; char data[]; }; Then I'd still return the pointer to `data` like you're doing. To get the original back, just back off that pointer using `offsetof()`. Technically it's more portable, though this approach requires C99, and the only (trivial) C99 you're using right now is the `inline` keyword. 
Why not just use [assert](https://en.wikipedia.org/wiki/Assert.h) for that? It lets you write the runtime checks right in your functions and offers the same ability to turn them off at compile time.
 // make allocates a stringheader with the specified length. static inline string make(const char* cs, size_t len) { char* s = malloc((2 * sizeof(size_t)) + (sizeof(char) * (len + 1))); memcpy(s + (2 * sizeof(size_t)), cs, len + 1); (*(size_t**)&amp;s)[0] = len; (*(size_t**)&amp;s)[1] = sizeof(size_t); return s + (2 * sizeof(size_t)); } // new creates a string from a c string. An empty string is reflected by a // null pointer. static inline string new (const char* cs) { size_t len = (cs == NULL) ? 0 : strlen(cs); return make(cs, len); } I don't think `memcpy()` likes being called with a `NULL` `src` parameter. The behaviour must be undefined. 
 // grow reallocates the string to a new length. static inline string grow(string src, size_t newlen) { size_t offset = *(size_t*)(src - sizeof(size_t)); char* s = realloc(src - sizeof(size_t) - offset, (2 * sizeof(size_t)) + (sizeof(char) * (newlen + 1))); (*(size_t**)&amp;s)[0] = newlen; (*(size_t**)&amp;s)[1] = sizeof(size_t); return s + (2 * sizeof(size_t)); } // len returns the length of the string in constant time. static inline size_t len(string s) { size_t offset = *(size_t*)(s - sizeof(size_t)); size_t l = *(size_t*)(s - sizeof(size_t) - offset); return l; } It looks like what you call 'length' of a string is in fact the allocated size. So you'd better call it something else to avoid confusion, `size()` for example.
GCC 8 has some [improvements](https://developers.redhat.com/blog/2018/03/15/gcc-8-usability-improvements/) that should suggest including `&lt;stdbool.h&gt;` instead of just "typo" corrections.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AdamHayse/optimal-solve-rubikscube/.../**testheuristic.c** (master → 73f9e10)](https://github.com/AdamHayse/optimal-solve-rubikscube/blob/73f9e10b1418056f8560cabe49060f9cee0f49f4/testheuristic.c) * [AdamHayse/optimal-solve-rubikscube/.../**database.h** (master → 73f9e10)](https://github.com/AdamHayse/optimal-solve-rubikscube/blob/73f9e10b1418056f8560cabe49060f9cee0f49f4/database.h) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dwz5i0i.)
I'm still fairly new to C, so maybe that accounts for it, but I can't say I've ever seen someone use a struct to implement dot notation/namespaces. That's a clever way to create an API. Great work.
What is the point of the struct? Why not just prefix the function names with `str_`?
I implemented that stack overflow code and did some empirical time analysis to find out the best way I could implement it. I came up with this for my edge set 1 database encode function: unsigned long long state = 0xFEDCBA9876543210; for (i=0; i&lt;5; i++) { int p4 = comb[i]/2 * 4; add = (11-i) * (add + (state &gt;&gt; p4 &amp; 15)); state -= 0x1111111111111110 &lt;&lt; p4; } add += state &gt;&gt; comb[5]/2 * 4 &amp; 15; and I came up with this for my edge set 2 database encode function: unsigned long long state = 0xFEDCBA9876543210; for (i=11; i&gt;6; i--) { int p4 = comb[i]/2 * 4; add = i * (add + (state &gt;&gt; p4 &amp; 15)); state -= 0x1111111111111110 &lt;&lt; p4; } add += state &gt;&gt; comb[6]/2 * 4 &amp; 15; Strangely, the E1 function takes 8% longer to run than the E2 function. The only difference that seems like it might be causing this is the subtraction in add = (11-i) * (add + (state &gt;&gt; p4 &amp; 15)); It is strange that such a small operation would add up to so much. My guess that the function has become so efficient that very small things start to add up, or that there is some unknown optimization by the -O2 switch that isn't handling the subtraction very well.
What is the type of `comb` in these? Division of signed types cannot easily be replaced with shifts by the compiler as right-shits have different rounding.
[Agreed](https://github.com/tavianator/bfs/blob/master/dstring.c#L24).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [tavianator/bfs/.../**dstring.c#L24** (master → 0dcf9ed)](https://github.com/tavianator/bfs/blob/0dcf9edcadc058bcf5d595d59564fb35d108c177/dstring.c#L24) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dwz7ucp.)
Comb is a pointer to a uint8_t.
I've seen them all. If you develop a hard preference and inability to deal with other people doing it a different way, you 're in for a hard life. I personally prefer the last form, and my recollection is that in the old olden days that was more prevalent. FWIW I've been coding in C or derivatives since the 70's (1970's, not 1870's).
You may want to use `break;` to exit out of the loop instead of setting `c` to `EOF`. Also, instead of doing if (condition1) { if (condition2) { /* Actual Code */ } else { exit early; /* Just a example, not actually valid */ } } else { exit early; /* Just a example, not actually valid */ } You may want to use the following for a cleaner flow: if (!condition1) exit early; if (!condition2) exit early; /* Actual Code */ Any reason not to do `while ((c = getchar()) != EOF)`?
It looks like your rewrite calls getchar an extra time 
Hm... that should work. Is the full code already uploaded so I can do my own tests?
I've never heard of valgrind. I installed it and ran it. It looks like it found [something](https://i.imgur.com/0d6w9SE.png). I'll see if I can figure it out with the information it gave me. I wish they taught me how to debug in school. They haven't even talked about IDEs and I'm in my final semester.
Yeah. University is about teaching concepts and ideas, it's not about teaching the practical side of things.
Yes. https://github.com/AdamHayse/optimal-solve-rubikscube/blob/master/testheuristic.c
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AdamHayse/optimal-solve-rubikscube/.../**testheuristic.c** (master → 07857cd)](https://github.com/AdamHayse/optimal-solve-rubikscube/blob/07857cd1f74ab7d440affe75d9cfb569cbfaed44/testheuristic.c) ---- 
All my findings are very minor. 1. Why is "c" an int, not a char? 2. Why is "i" an int, not an unsigned int? 2. I don't like that you are not consistent when using or not using curly braces 3. at the end when you write the string trailer i think it is clearer if you use "i" and "i + 1", because "i++" may confuse me in thinking that i is incremented for later use. ------------------------- char s[lim]; unsigned i = 0; char c; while ((c = getchar()) != EOF) { if (i &lt; (lim - 1)) if (c != '\n') s[i++] = c; else break; else break; } s[i] = '\n'; s[i + 1] = '\0'; printf("%s", s);
Why do you define functions in header files? 
Thank you for your comments. I will look into these.
I define functions in header files because I've seen it done before when using C in my systems programming class. We used a Raspberry Pi and a sensor kit called GrovePi. Defining functions in header files was done in the C library for the GrovePi, which is now deprecated because the developers replaced it with a C++ library. This seemed wrong to me, but it is functional. I don't know the proper way to structure a repository.
This is great. I like the way you're using the struct with function pointers as a sort of namespace. I'm not sure if you're familiar with it but [Redis sds strings](http://github.com/antirez/sds) use the same strategy of passing pointers to the right of the struct header. 
The resulting string object can contain a string of length `newlen`. That should probably be more clear in the docs. Thank You!
How many decimals do you think pi have?
https://github.com/smasher164/str/blob/master/str.h#L62 I think this violates the strict aliasing rules. Feel free to correct me if I'm wrong..
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [smasher164/str/.../**str.h#L62** (master → e009569)](https://github.com/smasher164/str/blob/e00956965cdf737a33174ebea819f401f4a18775/str.h#L62) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dwzkft4.)
Some where between 6 and infinity. 
The only reason to do this is to define small functions that are inlined across module boundaries. Unless that is your use case, please don't do that. If you don't understand this concept yet, do not define functions in header files. And if you do so, you need to define and declare all such functions as `static inline`, otherwise you get errors at link time. The approach you should take is to *declare* functions in header files and to *define* them in source files. The purpose of header files is to give you an easy way to declare a bunch of functions by including a header file. Thus, for each translation unit you usually have a corresponding header file that contains declarations for all functions defined in the source file. This header file is included by all source files that want to use these functions. Defining functions in a header file is an exception and usually wrong. Unless you know what you are doing, don't do that.
Well, it's the latter. So what you need is just a type with infinite precision
It's the only way I can trust the result. Maybe AWS could have an expensive solution to store the value 
 Btw, for the OP: sizeof(char) is 1, by definition.
just use a string. 
make a circle with the string, and divide its length by its diameter
You joke, but there is such a thing as symbolic or exact arithmetic that allows things like pi to be represented exactly (at least, until you try to print it out ;). For example, the [`xrc`](http://keithbriggs.info/xrc.html) library has `xr_pi()`.
Thank you, this is now fixed. I no longer accept NULL pointers to reflect empty strings. It's inconsistent with the stdlib functions anyways. It is invalid for the user to pass in a NULL pointer for CS.
Thank You! I'm going to try to define a struct header instead of allocing enough memory to contain the two fields at the front.
Thanks for the info. I've never seen the inline keyword before. I'll look into it.
No it most likely doesn't, every symbol is external by default (this can be changed using the `static` keyword) and the linker is the one resolving the symbols, and it has no way determining whether the two symbols are duplicates or really different (and it shouldn't). Maybe there's some really weird compiler where that's different but I doubt it. This is something that has to be solved code-wise, not by the compiler.
Oh, I just notice that `grow()` is just an internal function, not exposed to the user. As long as you concatenate each time the string data just after calling `grow()`, that's indeed okay, the length and the capacity will always be equal. Sorry.
Oh no, this was all my fault. I'm sorry if I sounded standoffish, and thank you for your patience!
There's no way you would ever need all of Pi, unless you're displaying it for fun. Truncate it to 15 decimal digits and it'll fit just fine in a double and most likely (unless you're doing astronomy), work just fine for what you need. They only use 39 decimal digits to calculate the circumference of the universe to within a single hydrogen atom.
This subreddit exists to discuss the C programming language. Please redirect this question to r/csharp.
This but unironically
 struct Number { bool isPi; };
I'm gonna need plank level precision 
I don't like the global namespace clobbering this has the potential to introduce -- I could easily see a collision happening with functions like `grow()`, `make()`, etc. Your use of a struct to provide namespace is clever (especially given the comments suggesting the compiler can optimize away the runtime cost), but for the actual function names I'd urge you to add some sort of prefix (a-la `syring_grow()`, `string_make()`, etc). It's unfortunate that C doesn't support real namespaces, but it's the way things are :(
Because the second argument to memset must be a char, and char can only contain values less than 128 (to be precise, only values in range [-128, 127]), but RIO_WHITEBOX_BUF_MAGIC is 0x0123456789abcdef
So u say that the second arg to memset must be a byte size? 
I agree. I just updated the repo to prefix the namespace "str__" to all internal functions. Thank You!
If so, how do I memset something bigger than a byte? 
Hey, not entirely sure why your program doesn't work as it's a little hard to understand but a few things I noticed. When you call the final two printf()'s, don't use reference of operator (i.e. the &amp;) and when you go to return from your function cal(), return x, y; doesn't really make any sense. You can only return one object not multiple.
The function that calculates the interpolation should get different parameters. The coordinates of start and end points and the amount of points to interpolate. You could also later think about giving the function an array where you put in the interpolation values. What you could do in the function is this, roughly: construct a vector from start point to end point by subtracting the end point from the start point coordinate-wise. That is the vector you want to walk along in 100 steps to reach the end point. Then, start a loop that counts from 0 to 100. In each loop, divide 100 by your loop counter. That will give you a number that slowly goes from 0.0 to 1.0 in 100 steps. Then multipl your vector with that number and add the starting point to it. That is your coordinate.
Use your compiler's warnings as a guide. skit.c: In function ‘cal’: skit.c:8:10: warning: left-hand operand of comma expression has no effect [-Wunused-value] return x, y; ^ skit.c: In function ‘main’: skit.c:37:11: error: too few arguments to function ‘cal’ result = cal(a, b, c, d); ^~~ skit.c:39:18: error: ‘x’ undeclared (first use in this function) printf("x=%f", &amp;x); ^ skit.c:39:18: note: each undeclared identifier is reported only once for each function it appears in skit.c:41:13: warning: format ‘%f’ expects argument of type ‘double’, but argument 2 has type ‘float *’ [-Wformat=] printf("y=%f", &amp;result); ~^ ~~~~~~~ First warning is basically saying you're doing it wrong (you can't return two variables).
If your structs are the same size just fseek to the beginning of the struct you want to overwrite and write there?
what if I have 5 structs saved and the user deletes 1 so I am writing 4 structs to the file? I don't want to overwrite the last struct I want to delete it from the file.
Two solutions: * The easy: just rewrite the entire file each time with all the valid structs. Don't bother trying to minimize it, it's likely not worth it. * Use ftruncate to define a new length for the file which in your case should be the current size minus the size of your struct. That presupposes that the structs you want to remove are packed at the end which involves copying and overwritting to exchanges structs within the file otherwise in order to get that particular setup... As said, it's not worth it, just rewrite it all with valid data.
Why?
so like I said in my post of closing and reopening the file?
For you, the next step is learning C. To use large frameworks like GTK+, you don't have time to think about how to use C. GTK+ uses pretty general GUI concepts and (even C is not OOP-friendly) the OOP paradigm. You need to know what a "widget" is (also sometimes called "GUI component") and understand its abtraction. You need to know about layouts and how windows and dialogs are populated using layouts. Then you need to learn about "signals" (or sometimes called events) and the their counterparts "signal/event handlers". One hard part is also controlling the state of your application and its representation in the GUI, but this is the case when your application grows. You have A LOT to learn. A small tip: learning is most efficient when combined with motivation. For example, make an application that you REALLY want to have as GUI for some small or middle-sized frequent task.
`void main(void)`? Unless they have really good reason to do that, I'd call that bad.
WhO CaReS ? Is_JuSt_As_ReAdAbLe_As_AnY_OtHeR_CoNvEnTiOn
I highly recommend this book, [Foundations of GTK+ Development .](https://www.apress.com/gp/book/9781590597934) It's on Gtk2 unfortunately, but it's the best I've read. You have to read the documentation to see what's deprecated in Gtk3. IMO, it's very hard to learn GTK+ if you don't have a good grasp of C language basics, especially on variable lifetime, pointer, and struct. Once up a time, I forget to mark a local variable `static`, I debuged my ass for half a day to find out why the program crashed. There is an example here for [tic-tac-toe](https://developer.gnome.org/gtk-tutorial/stable/a2901.html#SEC-TICTACTOE). Take a look to see if you're comfortable.
NASA only use 12 decimal places....
My professor will explain what a funcion is in the next lessons, he preferred to teach us other things before (like types of variable, cycles, pointers), that's why
Thanks for the book suggestion and for the example, I still can't fully understand that program, maybe I'm rushing a bit. But I'll keep your suggestions for the future!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AdamHayse/optimal-solve-rubikscube/.../**a74ffd07058ed1d8263d7ea2a3084f4499614281** (new-structure → a74ffd0)](https://github.com/AdamHayse/optimal-solve-rubikscube/tree/a74ffd07058ed1d8263d7ea2a3084f4499614281) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dx0d0ug.)
[removed]
My professor is a "C master race", and I would not learn something different until I have to pass his exam
That's a way yes.
This collision is not a problem with C, it is a problem with this new fad of single-header libraries which go pollute the namespaces of other source files :-/ If you just provide a normal library as it has always been until a year or two, you do not have this problem.
To me, a good professor would teach you to use the right tool for the job. The more I have to deal with C++ the more I love C, but GTK is object-oriented, so using it with C++ would be more natural, IMO. I'm not advocating you try to pass a C course using C++.
I used an OO library in C and I thought it really gave me a great understanding of how everything works. With C++ there is too much magic and too many strange decisions going on behind the scenes.
Yeah, I always get a Warning for that, if I want a warningfree program I use to write int main(void) and at the end return 0; not knowing exactly what that means 
Please reformat so we can read it. 
What are you trying to accomplish? You indicate you're looking for a series of button presses but the if/else constructs don't seem to take into account any previous presses to enforce a sequence. Have you considered looking into a [state machine](https://en.wikipedia.org/wiki/Finite-state_machine) model?
**Finite-state machine** A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The suffix is redundant. As explained by the page you linked, the constant is given a type which it can fit in. Also the second argument to memset has type `int` , although it will be converted to a character during the operation of memset
The memset function sets all bytes of the target area to the same byte value. If you want to set a repeating pattern that is several bytes long, memset is no help. Use a loop.
A file with lots of structs haha
Good Bot
GTK is written in C, not C++. Most GUIs are written in C++ but GTK is not. "GTK+ is written in C..." https://www.gtk.org/
Thank you, oldprogrammer, for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
If already know Python and JS you only need to rush through a good C book. Then pick some interesting Data/Log book!
Writing into malloc'd space is never a strict aliasing violation. What you can't do in malloc'd space is to write as type A, then read as type B , where B isn't in the list of allowed types based on A. I only looked briefly at the code in question but it only ever seems to read or write that memory location as `size_t` .
`ftruncate` is the function you are looking for.
Just trolling boy...
I assume it's written in C+ then. ;)
:(
The if statements are inside each other so if a is pressed it goes into the next loop to check if b is pressed and so on. The else ifs will print wrong as soon as any the wrong button is pressed that doesn't follow this order. How would I use a state machine for this code?
But for that to work the way coded, you would have to press a &amp; b at the same time, otherwise if a isn't pressed it will never check for b. It sounds like what you need to do is something along the lines of setting a flag when button A is pressed then when B is pressed, check if the A flag was set. If not or if anything other than B is pressed, you clear the A flag.
C-Files are not exectuables! One C source code file includes one or multiple header files which together form a compilation unit that results in an object file. Multiple object files can then be linked into one executable or library. You can also do all this in one step, like you do. I recommend writing a simple Makefile for automation, a simple one would just be: # Rule to build generateEDB1 from the listed prerequisites # $^ expands to the list of prerequisites, $@ to the target generateEDB1: generateEDB.c moves.c edatabase.c mymath.c database.c gcc -D HALF=1 -O2 $^ -o $@ You could write other rules too, or make it more complex ([see my fork](https://github.com/LeonardKoenig/optimal-solve-rubikscube/tree/prq/cleanup)) Also: 1. You've missed some include guards, also a canonical way to for the guards macro-variable is HEADERNAME_H 2. A common scheme for include-order for file A.c is: A.h, sytem-headers, library-headers, own headers 3. If you need some library definitions in a header, include the header providing those already there, eg. include "`&lt;stdint.h&gt;`" in "cdatabase.h". 4. If you have big integer constants (eg. `0x1111111111111110`) that are of a specific type, add suffixes (eg. ULL for unsigned long long), st. they won't get truncated. 5. You can rewrite int i; for (i = 0; /* ... */) {} to for (int i = 0; /* ... */) {} this will make `i` only available in that scope. Also you often don't want `int` but some unsigned type in your case, eg. `uint8_t` for arithmetics or `size_t` when indexing arrays. 6. Use `X function(void)` instead of `X function()` more consistently. 7. A variable declaration is `static` by default, in this case this means that the `moves` array will be local to each compilation unit -- which means every compilation unit whiches source file was including your header will have an own copy. The linker is usually smart enough to figure this out, but eg. using `-fno-common` will turn that off (because it's wrong). In clang you have the warning "-Wmissing-variable-declarations" for that. Thus, make the variable declaration in the header `extern` (which tells the compiler "hey, this variable exists, even if you don't know it -- some other module will provide it") and then add an additional declaration (which is `static` by default) to the source file. I've implemented most of these suggestions in my aforementioned fork in the prq/cleanup branch [1](https://github.com/LeonardKoenig/optimal-solve-rubikscube/tree/prq/cleanup), feel free to use it. I've also added some Warning/Diagnostic options, which highlight some other possible bugs.
I have tested this code and it works for me. Whe a is pressed it just carries on to check if b is pressed. It will only stop after a if the first button the user presses is not a. I am just looking for a shorter way for doing this so I will try using flags thanks you.
Well, usually they teach `int main()`, which is equally wrong :-D
Likely the wait and sleeps you put in after the button checks are giving you sufficient time to click the next button. Does your sequence have to be pressed in a given period of time?
GTK+ – or better GObject – is rather painful. Even the developers admit that today they would choose C++. Basically they implement their own object system in C. It works more or less but is incredible complicated and still far less powerful than a real object oriented language. There is almost no type safety in GObject, you pass around void* and sprinkle your code with run-time type assertion. There is nothing wrong with doing the GUI in C++ and all program logic in plain C. This may actually do some good by forcing you to cleanly separate them.
No it just waits for each button to be pressed
If you want a few examples for some simple games made in GTK with C, there's https://dashgl.com/.
If a 64 bit float doesn't have enough precision for what you need. Then you can make your own data type. All floats really are is a series of bits arranged in a certain way: https://i.ytimg.com/vi/N6U_xUdUWC8/maxresdefault.jpg If you want more bits to store more information than declare two unsigned longs, use one for the mantissa, the other for the sign and exponents and then write some functions for handling the calculations.
how can i affect something to a cell in the array of notes for example ? 
This is no C code, C++ programming communities can be found elsewhere on reddit. Anyhow, this can be simplified by eg. putting the correct sequence in a data structure somehow and writing a function that loops over the input and compares it with the expected input.
[Here's a good explanation](https://www.quora.com/What-is-the-difference-between-a-static-variable-and-global-variable-in-C-C++).
The difference is found in *linkage* and *scope.* Variables declared `static` outside of a function have *internal linkage* and *file scope.* That is, they are visible from the point they have been declared to the end of the source file and they aren't linked to variables with the same name from other files. Variables declared `static` inside functions are similar but have *block scope.* That is, they are visible till the end of the current block. Variables declared outside functions without `static` have *external linkage* and *file scope.* All such variables with the same name in the program refer to the same variable (i.e. they are *linked*). Use whatever is appropriate for the task at hand.
&gt; Notes: As I am a relatively new programmer, there should be a better way (or something in the C library) that lets me convert a char value to its int equivalent. As you can see, my function convertCharToInt is quite sloppy and would like to know if there is a built in alternative. `char`s can be subtracted and added. This method relies on the characters '0' through '9' and 'a' through 'f' have values in sequence, but it works since that's very common. int convertCharToInt(char hexChar) { char c = to_lower(hexChar); // turn 'A'-'F' into 'a'-'f' // in case it's a digit. eg. (ASCII) '4' - '0' = 52 - 48 = 4 int digit = c - '0'; if (digit &lt; 10) return digit; // in case it's a letter. eg. (ASCCI) 10 + 'e' - 'a' = 10 + 101 - 97 = 14 else return 10 + c - 'a'; }
Thank you
Your Prof should have told you a correct way to write main even if they haven't explained what it means yet because that's wrong. 
Yes, it *has* to be acceptable because of backwards compatibility to K&amp;R style C. It still doesn't provide a prototype but otherwise is equivalent to `int main()`. Thus needs to be acceptable but is bad.
This sub is for C, not C++. Free hint though: turn on your compilers warnings. Pay attention to them.
The standard string to int function is [strtol()](http://en.cppreference.com/w/c/string/byte/strtol).
Have a look at GNU GMP. They have arbitrary precision floating point arithmetic. There is also something related to the project which is good for 6 billion digits of Pi. 
There are only 2 versions defined by the standard: * `int main(void)` * `int main(int argc, char **argv)` The rest is implementation defined. /u/pink_echoes is right in his explanation that `int main()` just happens to be "accidentally" accepted because it happens to fall back on pre-ANSI function declaration, which is still supported but deprecated since C99. (That's not because main would be special.) 
edited
&gt; Write the function htoi (s) There is no function called `htoi` in your code. The closest thing would be `convertHexToInt`, but it takes 3 parameters and returns nothing. &gt; while ((userInput = getchar()) != '\n') No `EOF` check. Also, no size check whenever the character still fits in the buffer. &gt; if ((userInput &gt;= 'A' &amp;&amp; userInput &lt;= 'F') || (userInput &gt;= 'a' &amp;&amp; userInput &lt;= 'f') || isdigit(userInput)) There is [`isxdigit`](http://port70.net/~nsz/c/c89/c89-draft.html#4.3.1.11). It looks like `getDigitLocations` is just the [`strlen`](http://port70.net/~nsz/c/c89/c89-draft.html#4.11.6.3) function under a somewhat confusing name. &gt; digitLocations--; /* digitLocations is decremented to make caluclations of powers easier */ &gt; return digitLocations; Can be just `return digitLocations - 1;`. &gt; void convertHexToInt(char inputHexadecimal[], int outputInteger, int digitLocations) `outputInteger` is basically useless because the function only gets a copy of the integer and any writes to it won't affect the caller. You'd either return the converted value (this is what the exercise probably wanted) OR you could accept a pointer where to write the result to (you probably haven't had pointer yet, so you can ignore this for now). Any reason not to do the `digitLocations` calculation in the function itself rather having the caller (`main`) to do it? &gt; outputInteger = outputInteger + ... outputInteger += ... Also, `intCounter` is basically `digitLocations - hexCouter`. &gt; while (intCounter &lt;= digitLocations) Since you basically read the string from the end to the beginning, a `for` loop could be better to understand: for (hexCounter = digitLocations; hexCounter /* != 0 */; hexCounter--) &gt; pow(16.00, intCounter++) `pow` uses `double`, which is pretty slower than integers, but this isn't really notable today. You can also calculate it "on the fly", like: int hex_value = 1; while (/* ... */) { /* ... */ hex_value *= 16; /* hex_value = hex_value * 16 */ /* OR hex_value &lt;&lt;= 4 */ } &gt; printf("\n\nThe hexadecimal input of %s converts to an integer of %i.\n", inputHexadecimal, outputInteger); This should rather be in the `main` function since `convertHexToInt` should, as the name indicates, only convert, not also printing the converted value. &gt; convertCharToInt(char hexChar) Converting a `char` to `int` is `(int)hexChar`. A better name would be something like `valueOfHexChar` in my opinion. Aside the other post, C only guarantees that the the numbers (`'0'`, `'1'`, ..., `'9'`) are sequential, so `'0' + 5` results in `'5'`. But this doesn't apply for letters. Today like all systems use ASCII, where the letters are also sequential, so this isn't really a problem, but if you really want to be standard compliant, you could create a string with the valid hex characters use [`strchr`](http://port70.net/~nsz/c/c89/c89-draft.html#4.11.5.2) and some pointer math to determine the offset (which would also be the value of the hex digit), like: char const * const hexString = "0123456789ABCDEF"; if (!isxdigit(hexChar)) return 0; return (int)(strchr(hexString, toupper(hexChar)) - hexString); You can look at this later when you know pointers.
When I mentioned executables, I was talking about the file that the C source code compiles into. I shouldn't be putting these on GitHub, right? I do have them in my local repository though. It seems improper to have them in the same location as my source code and header files. I could maybe make a folder called bin and stick them in there like I think I've seen people do. Instead of referencing my databases likes "pattern_databases/corners.patdb", I would do it like "../pattern_databases/corners.patdb". Referencing the parent directory seems a little awkward though. I was pretty sure that the 0x1111... value would get truncated because I didn't specify the "L". I never knew about "LL". It's interesting that the program still seems to work even when it gets truncated. The professor who introduced me to C always declared the increment variable outside of loops. This is his [website](https://chortle.ccsu.edu/), and here is an [example](http://programmedlessons.org/CPuzzlesNew/PartL/partLPuzzle01.html) that he provided for us. I was under the impression from his class that we couldn't declare variables within the "for" statement, that it was a special thing that we did in Java. Java was the first language that we started with. Thanks for these fixes.
Some observations: - In main you first call `copydir` and then you call `makedir` - that strikes me a bassackwards. - `readdir` returns a struct pointer. Who is responsible for creating the storage for that struct? Who is responsible for freeing it? - Look at the logic of the if statement that calls 'stat'. What happens if `stat` fails - e.g. the src file doesn't exist? - As for `perror`, you should read up on it and `errno`. Some functions, when they fail, set `errno` and you can use `perror` to print a description of the error. Using them properly can be a little tricky. E.g. you probably need to be zeroing `errno` before making calls that use it - otherwise you might run into a stale value set by a previous call. 
`scanf` returns the number of read "arguments", so a successful read in `scanf("%d %lf", &amp;id, &amp;value)` would return `2`. If it isn't `2`, then either the `%d` part isn't "correct" (would return `0`) or the `%lf` part isn't corrent (would return `1`, since to get that far the `%d` part would've been successful).
Ah, yes, you shouldn't track binaries in git (in most cases). You can write a ".gitignore" file that lists such files (and add it to the repo st. no-one needs to bother again). However you do *not* have them in "your repo" -- you have them in the same folder. The repo is what is tracked by git (just some terminology). For a simple program, having them in the same location is totally okay. There are generally two ways of doing it: Building binaries in-tree (ie. you have a directory tree with multiple source files, even in different directories and the binaries are built in the same directory as the corresponding source) and out-of-tree (the whole tree is first copied into a build-directory and then compiled there. The first is far more easy to implement, especially in Make. Yeah, L is for long LL for long long etc. That it still does work is something you should adjust to in C :) -- much stuff just happens to work and it's really difficult to figure out why when it is at least not guaranteed to work. But never rely on such thing, it can change with every new compiler updateor behave differently on different systems. Well, all the stuff he writes he refers to ANSI C, despite newer standards of C being also ANSI, ANSI C usually refers to C89 -- in which you couldn't do that. He also seems to recommend using Dev-C++ / VC++ which are not C compilers and which does irk me much, although for older C++ and ANSI C the saying that C would be a subset of C++ is not as wrong as it is today. Also using `system("pause")` is Windows/DOS-specific and not portable at all. Anyhow, he's teaching C89 for some reason, so that's probably the reason. Modern C has many things that make it a much nicer language, like compound literals or structures initialization.
You are creating array of N items but at that time N is uninitialized.first take number of items N and then create the array.
Bonus tip, use pastebin to show code.
That's not what I'm asking for. I'm just asking for a line of code that evaluates something like whenever the user enters a letter from the alphabet instead of an integer and the error message says "Invalid ID or value"
I think I got the makefile to work. I just typed "make all". It did give me a bunch of warning though. It suggests that I put quotes around arithmetic operations when there is a shift operator next to it. I know that arithmetic has higher precedence than shift. I remember this because of a silly mnemonic I came up with: **N**obody **U**nderstands **A**ssociativity, **S**o **R**emember **L**est **C**ompiler **A**llows **C**onfusion. N - non-operators U - unary A - arithmetic S - shift R - relation L - logical C - conditional A - assignment C - comma Is it recognizing parentheses around the arithmetic operation because it makes it more readable and people who aren't accustomed to operator precedence will have an easier time?
It is. `scanf` reads and converts the numbers for you and stores it in your variable `id` (and `value`), and `scanf` also returns the number of successful read "arguments". So if the user inputs a letter, the `%d` part in `scanf` fails to match the letter (since it expects numbers) and thus returns `0`. You just can't directly check `id` if it contains a letter because `id` is a number. And what should the number be set to when the user inputted a letter? Let's take for example `0`. What if the user actually inputted `0`?
Boy, bye. Stop wasting my time.
noted, sorry
Ahhh thank you. Moving those two lines above to where I created the array worked. :)))
Yep, although `make` should suffice too, since it then executes the default, that is first, rule. The warnings come from `-Wall -Wextra -pedantic` which I added to the CFLAGS as a sane default. The suggest-braces diagnostic is one of the most heatedly discussed ones, basically both reasons apply but some argue that since they're unnecessary (which they, strictly speaking, are) they shouldn't be warned about. However I usually take this warning as a wake-up call that my expression is probably unncessary complex/tight and could be made more readible.
Note that he also must clean the input buffer after `scanf()` failed, otherwise the same crap remains in the buffer and next `scanf()` will try to read it again and, depending on the structure or the program, it will loop infinitely or give unexpected results. Something like this: r=scanf(" %i %lf", &amp;id, &amp;value); printf("scanf returned %d (%d, %lf)\n", r, id, value); if(r!=2) { while(getchar()!='\n'); }
Thank you for the very detailed and through commentary. Very useful.
Just store it as an array of bytes and you'll easily fit billions of digits in memory
sscanf doesn't do any allocation for you. You must read into a block of memory big enough for the string.
You're creating a pointer, but not allocating memory to it. You can either change s1 and s2 to `const char s1[200] /* 200 being the size of the array */` or use `malloc(size)` from `stdlib.h' Also, when passing in a pointer, you don't use the ampersand as it is already an address
This looks correct. I think both while loops would make more sense as for loops of counter and i, but that's just a personal opinion. Is the goal of the exercise (or your personal goal) to be efficient? This is independent of the C language, but algorithm choice is an important part of programming, so I thought I'd ask. If s1 is m characters and s2 is n characters, your implementation of squeeze is O(mn), but it can be written as O(m+n) if I'm not mistaken.
Thanks for the reply. The book itself shows the original squeeze function using for loops which is inline with your opinion. I used a while loop as I didn't reference the book while writing the code. I decided to use what made sense (in my head) and start programming with that. Is my goal to be efficient? I'm not sure I know how to answer that. I dont know the difference between what would or wouldnt make this efficient. I just took up C programming a few weeks ago. I took programming at school over 15 years ago and am now getting reacquainted with all this. If you have a moment could you elaborate on the last sentence about O(m+n)?
The ones in main, where you define them.
re while vs. for. That's perfectly reasonable. "While" reads much more like spoken language and is conceptually easier at first. Your view of what comes naturally may shift or not over time. By efficient, I mean that no matter what language you're using you can make a task faster or slower based on the procedure (or algorithm) you use to get it done. This is usually expressed in "big-O" notation which is roughly the cost or time in terms of the size of the input(s). Consider an extreme example: s1 is a string of 1 million "a" chars and s2 is 1 million "b" chars. This version of squeeze will then perform 1 trillion comparisons (the inner if statement) before completing (m*n). But there is a version of squeeze that can do the job with around 2 million comparisons (m+n), which is a huge savings.
Sorry, I forgot to link. Big-O has a formal, mathy definition that can obscure the more intuitive idea it's describing. That's why I prefer to link people to the "simple English" version of its Wikipedia page: https://simple.wikipedia.org/wiki/Big_O_notation
Okay, having now gone out and found the exercise and K&amp;R's first version of squeeze, I think the code you wrote is exactly how the problem is intended to be solved. There are better ways to write squeeze, but that's not the point at this stage. I'm happy to continue, but it's well outside the scope of the exercise, and likely involves concepts that haven't been introduced yet. Having seen your other posts, you seem to be trying to be strict with yourself in that regard. If you get to the end and still want to pursue it, DM me.
As others have said, learning C needs to be your next step, UI stuff tends to rely on slightly advanced topics. You might also consider an alternative library, like [libui](https://github.com/andlabs/libui) or [IUP](http://www.tecgraf.puc-rio.br/iup). They are a little less complicated than GTk, although there may be less help from others online because they are less used
Ok I have done that, and it removed the segmentation fault, but now it just prints the 2 strings one after the other. So if i type abc and cba, it prints abccba
It uses the Leonardo board (memory limits and all that are there): https://store.arduino.cc/usa/arduino-leonardo-with-headers What you're paying for is a "batteries included" arduino setup. After you take a test drive. You may want to go all in and make your own Arduino gaming machine. Atari supported the kickstarter and did Tetris in its entirety (levels, sound and all). So it can at least support that size of a game.
Your while statement is out of syntax! This is the reason you are getting debug errors and statements from missing colons and wrong while statement. It is actually doing a &lt;b&gt;do while statement&lt;/b&gt; you are trying to implement in this case! For that here is mine revised code for you: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define loss 15 int main () { int roll1; int roll2; int roll3; int done; int sum; int i; i = 0; int point; point = 0; int firstroll; firstroll = 1; srand(time(NULL)); // randomises the numbers roll1 = (rand() %6) +1; //Random no. roll1 from 1-6 roll2 = (rand() %6) +1; //Random no. roll2 from 1-6 roll3 = (rand() %6) +1; //Random no. roll3 from 1-6 sum = roll1 + roll2 + roll3; printf("You have rolled: %d + %d + %d = %d \n", roll1, roll2, roll3, sum); if (sum &gt;= 13) //You Win due to total is greater or equal to 13 { printf("You win\n"); } else { if (sum &lt;=6) { printf("You lose \n"); } else { point = sum; // Sets the point printf("Point is: %d\n",point); firstroll = 0; } } do { for (i=0; i &lt; done; i++) { if (sum &gt;=15) { printf("You lose \n"); done = 0; } else { roll1 = (rand() %6) +1; //Random no. roll1 from 1-6 roll2 = (rand() %6) +1; //Random no. roll2 from 1-6 roll3 = (rand() %6) +1; //Random no. roll3 from 1-6 sum = roll1 + roll2 + roll3; printf("You have rolled: %d + %d + %d = %d \n", roll1, roll2, roll3, sum); } if (sum == point) // If the sum is equal to the point, you win and leave the loop { printf("You Win"); firstroll++; } } } while(firstroll &lt;=12 &amp;&amp; firstroll &gt;=7); return 0; } 
Hahahaha oh my, thanks for that! Been working on this assignment for 7 hours now and finally done! Head is so dizzy but at least its done.
No problem, anytime! :) 
Whichever variant you choose (take #3!), use (and enforce) clang-format on your codebase.
 &gt; 3! 3! = 6 
Can you give an example of what you mean?
If you have comma separated value (CSV), you can just name your file fileName.csv and Excel will automatically open your CSV file after the program creates it, assuming you already have set Excel as your primary software for opening CSV files. I'll give you a snippet of code that is usually used to create files in C: FILE *fp; // just create a pointer which can point to a file fp = fopen("fileName.csv", "w"); // create a file with the name "fileName.csv" with write permission // WRITE TO THE FILE with various functions already provided by C like fprintf, fscanf etc. look these up. fclose(fp); // close the file before exitinf the program. This will create a file called fileName.csv in the same directory where the program is run.
Very nice, but sadly C++ is off topic in this subreddit. Please post C++ content to /r/cplusplus.
oh my god thank you so much
Thank you again. You're a big help
yep did this the charm thx. what an idiot. i never thought of closing the file
Also, please do not delete your questions once you received an answer. Future readers with the same question can profit from reading yours. Deleting your question denies them this resource and is not a good thing to do.
Your comment got caught in our spam filter. I apologize for the inconvenience.
That's a nice mnemonic. Please post it to /r/c_programming for all to see!
Your question is incredibly vague, but are you talking about using the casted ints like parameters to functions? You would typically only do this when you are using library functions that are meant to process arbitrary parameters. These functions typically take void pointers as parameters. There are some other cases where you would do this, like for hardcoding specific pointers in OS/Embedded programming, but I digress. You **only** do this when you know more than the compiler. This is an incredibly unsafe operation, and you need to be extra careful when doing this. 
HBOTMAPs don’t have DCs, DCs have HBITMAPs. What you’re doing right now is selecting the bitmap into a device context, drawing on it, restoring the device context to its original state. You’re just missing the part where you draw a rectangle to the window’s device context (the one returned by `BeginPaint`) which you can do with [Rectangle](https://msdn.microsoft.com/en-us/library/windows/desktop/dd162898\(v=vs.85\).aspx).
formatted
What does "won't work" mean? What do you get and what do you expect? 1 bug is that you're using the same function `convert` for lb-&gt;kg and for kg-&gt;lb
ok can you describe the issue? also if you're printing a double printf("%f", m); might not give you what you're looking for. 
For dynamic allocation, you want `malloc`, `realloc` and `free`. This sounds like either a class or book exercise so they should provide explanations of how those work.
The basic idea is to malloc a small amount of memory, and then call realloc whenever you reach full capacity to resize the array.
Judging by your description it's not clear whether you care about previously entered strings. If you don't, you don't need free store allocations. Just have a single char array of 100 (+1 for '\0') and keep rewriting it until you hit "quit".
If I've understood, you need to store each string passed by the user's input until they type "quit". If that's the case, then I would initialize a linked list which stores a char *. If strcmp(input, "quit") != 0, store the string, else set list-&gt;next to 0 and exit
The reason I used `extern ... inline` functions is that when compiling, the `-O3` flag will (generally) treat them as macros and substitute them accordingly, avoiding using more memory for function arguments.
How so? The entire program takes up more than 3 bytes due to IO, but that isn't related to logic and game data.
Your memory usage for variables is indeed 3 bytes, but logic refers to the procedure of producing the result.
 int *buf; ... buf=malloc(3); // allocate buffer (3 bytes = 24 bits) Urrrg, that's not good. Each time you'll write to `*buf`, you'll write an `int`, that is 4 bytes (in general), while you have only reserved 3 bytes. Even if your constant number fit in 24 bits, 4 bytes will be written, one of them outside of the allocated area. 
I'm using `int` to avoid casting. No errors are produced when using `long` (with my setup anyway) but the ~100 warnings don't help with debugging. Using an `int` pointer allows me to allocate my 3 bytes/24 bits of heap memory (`malloc(3)`), instead of just using an `int` which is always 32 bits (or whatever a given system uses).
I wouldn't use bit fields for that.. Does your spec say what size the int fields are and what their endianess is? Once you know that, just read into an integer variable of the appropriate size and swap bytes if needed. On Linux, [&lt;endian.h&gt;](http://man7.org/linux/man-pages/man3/endian.3.html) makes that part easy.
I'm aware that it's not a best practice, but due to the fact that there's nothing else to be overwritten I don't see it as a problem in this case. Is there any way to remedy this without using a full 32 bit `int`?
You can refer to something like this - https://github.com/timmyjose/dynamic_string_buffer_in_c/blob/master/dyn_str_buf.c. The definition of the buffer type itself is in the header file. The code should be mostly self-explanatory, but the basic idea is that you start off with an initial capacity of, say, 1, and then whenever you need extra space, you double the capacity of the buffer. Also, when you remove elements from the buffer, you can (optionally) shrink the buffer using the same logic in reverse. The performance should be amortised `O(1)` for each such operation. Feel free to ping back if you have more questions!
I was expecting some C_Golf, but I'm confused. 3 bytes where?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [timmyjose/dynamic_string_buffer_in_c/.../**dyn_str_buf.c** (master → 1865142)](https://github.com/timmyjose/dynamic_string_buffer_in_c/blob/18651424e6910b899a3cf7e30cd51a5b244c8e59/dyn_str_buf.c) ---- 
No kidding. I can't even think of a way the logic would only take up 3 bytes. Maybe on a 8-bit CPU it might be possible to have a program that small (but unlikely), but on anything desktop, no way.
Struct packing.
would be a bit more clear if you said the entire "game state" was 3 bytes. "logic" would imply most of the code, and there isn't much "data" to speak of here. 
I would just use a boolean like: int duplicates = 0; and increment it if you find one if(count &gt; 0){duplicates++;} , then you can just check duplicates == 0 and print a message after all your loops.
Would that just be for if it were the first 4 bits AKA a single int? I am just trying to understand why I even need to use a structure at all or even why my professor mentioned bit fields and the like. In regards to your specs question, do you mean the system itself or the data? Another hint I got was part of a hexdump that I was shown: [Imgur](https://i.imgur.com/2f4WVWX.jpg) I've been trying to let that sink in, but it hasn't made total sense yet. Do you have any idea what it is showing? 
An array of 3 bytes.
As I understand your problem you're unclear on how to print a message when no duplicates are found, while still printing each duplicate as they come up. The way I would do this without having to change your code too much is create a flag variable before the loop (line 12 or earlier) like `int no_dup = 1;`. Remove the `else` block starting at line 28 and insert `no_dup = 0;` somewhere in the `if` block starting at line 24. Outside the loop, have an if that checks the value of `no_dup` and if it's still `1` then print your "no duplicates" message. Now, all that being said, your code could be cleaned up in other ways. The biggest thing that sticks out to me is that you don't have to iterate through the entire alphabet. You can just iterate through the string, and look for matches for each character. This would require significant refactoring, especially to avoid multiple prints for the same character. Just a thought.
I think you're getting bits and bytes confused. 4 bit integers aren't really a thing. The largest number you could hold in one is 15... A structure with bit fields *might* be useful in interpreting the data in the packet payload. Depends on what it is.
Are you by any chance from India?
Impressive, but that's a lot of undefined behaviour.
I think you're right, I'll need to read up on the difference between the two. How would you decompose this problem? I have a tendency to overthink stuff, and I don't think this is supposed to be overly complicated. Would a reasonable solution even need anything aside from main and some sort of decoder? I know that I can determine how many packets I'd read and even the length of each, but at this point I'm still trying ti figure out how it would work in regards to actually extracting the information from the file. The picture I provided in my comment above illustrated an example of a packet itself (everything lines up with the datagram alongside it). I feel like I'm rambling at this point. I hope you can sort of see my thought process and what I'm circling around... 
One optimization is that I don't think you have to keep the interior nodes updated until the end. So for the main loop just update the leaves, then compute the interior nodes as the sum of their children up the tree afterwards.
&gt; Also, using malloc() is automatically going to incur extra memory overhead. The allocator has to keep track of what's been allocated, so you're going to have a minimum of an extra 32 bits taken up on the heap. Even just 'inside' his program, the `buf` pointer needs 8 bytes (on a system with 64-bit pointers, which is probably the most common nowadays) to store the address returned by `malloc()`. So the `int *` alone already spends more than just using an `int` straight away as a global variable.
There're also lisp, perl, Fortran, python &amp; others that you don't seem to take into account. Anyway I love C and strongly believe that any real programmer should write at least several programs using it. 
Hence the "I think your title is misleading."
That's a cast to void, not to void pointer.
Look into uint8_t, and similar, if you want exact control over integer sizes.
Oops! I apparently did not read the OP very carefully.
I'm not even sure what this diagram is supposed to tell us. Also note that C is an improved B which is a cut-down BCPL which is an improved CPL which is a simplified Algol 60. C is just one step in a long history of incremental progress.
&gt; d. Decode and print each field in the first 20 bytes of the header. That's the only non super trivial part, and it's only a pain because some fields are 4 bits wide and it's bigendian in a littleendian world. I'd probably read the packet into a byte array much like the code in my other comment (Whether it'd be into a dynamically allocated one, or wrapped in a struct like above, depends on what you're going to end up doing with it), and then copy the first part of the packet's data payload into a struct that mimics the ip header format - instead of defining one myself, I'd probably use `struct ip` from `&lt;netinet/ip.h&gt;`, which has everything but the optional options. You could just read directly into a struct ip variable, but then you have to worry about any of the options left on the stream leaving things out of sync - I'd rather read an entire packet all at once. If using your own struct instead of a predefined one this is less of an issue of course. Then when actually working with the 16 and 32 bit fields, use be16toh() and be32toh() so the numbers make sense for my hardware, and then htobe16() and htobe32() if I need to write new values into the header.
Still, even excluding the text and data sections in the binary, your program needs a ton more than 3 bytes to run. Or have you created a new libc/runtime that doesn't need a stack?
Because writing a tic tac toe game using 3 bytes of ram should be portable and multi-platform?
`int *buf;` probably consumes 4 or 8 bytes. Hard to understand why you wrote that instead of `int buf[3]` 
That's not what I said. I just found it amusing how hacky it is.
How do you figure 9 x 9 x 9? There's 9 first moves, and then 8 second moves for each of those first moves, then seven third moves for each second move, then six fourth moves for each third, etc. Seems like it would have to be much bigger than 9^3.
One thing you still need to do is to delete the bitmap. You load one every time the window paints but GDI has a very limited amount of handles and you will exhaust them if you’re not careful. You might want to load it as your app starts and delete it when the app ends.
Each cell can have 1 of 3 possible states {null, o, x}, there are 9 cells, so there are 3^9 board states. Order of moves does not matter in tic-tac-toe, so counting permutations over estimates the moves required.
I'm confused by your question. `gcov` is a tool that will analyze coverage of C source code that's been compiled with proper coverage flags (ie `gcc --coverage`). It's meant to determine how much code from a given library is run during a test build. A continuous integration platform like Travis allows you to integrate coverage analysis into your tests. As far as I know Codecov will take the output from analysis tools like `gcov` and use it to calculate useful statistics for your CI process. The example you linked from Codecov provides a general example of how to do this with C using `clang`, `gcov`, and Travis-CI. Are you trying to ask how to write test cases for use with Travis? Or are you looking for more complex examples of integrating Codecov into a CI platform? Or are you wondering how tools like `gcov` work? Disclaimer: I've never used Codecov, and have limited experience with Travis, so if I've said anything wrong or misleading please correct me below.
You don't store the moves in sequence, you just snapshot the current state of the board. Each cell can be one of three states. You need 9x9x9 possible states. 
The logic is all the `if`s and `for`s and function calls etc. Your `check_win` function *is the logic for checking for a win*, and this function alone compiles to ~70 bytes of machine code on my system. The entire program takes up more than 3 bytes because of all the *logic*. This is why your title is misleading, because I think people were expecting to see 3 bytes of machine code that somehow magically represented the state and logic of a tic-tac-toe game.
If you want three bytes, just use three bytes: unsigned char state[3]; 
I don't think that's correct. It's not possible to have, say, a board of only X or only O.
You're exactly right. That's how most experienced programmers would code the function. However those like me who are going through the book from start to finish use only techniques introduced up the exercise. I know of pointers and built in functions, however the book hasn't introduced pointers at this stage and the exercise is to get us to build our own function without using something built in.
You're right about the `positionElement` variable. It doesn't make sense to create a variable and then define it as -1. 
Unfortunately it doesn't work. Try, for instance, the sequence: 2 8 5 4 0 3 1 At that point, it should have detected an X win, but it doesn't. I know it can be fun packing state using bitwise operators. You haven't really done what you're claiming, though. You've used 3 bytes on the heap (by using undefined behaviour, for really no good reason: just use an array of 3 bytes if you want to do it properly), but you've used more than that in a global variable (how much memory does `buf` use?) and much much much more than that in the code segment (how much memory does your logic use?). If you're going to mislead anyway, why not just put your 3 bytes as global variables and claim that you've used "0 bytes"?
True, but I would caution against over applying that lesson. Giving meaningful names to constants such as default values, error codes, enumerated cases, limits, etc. is a great way to [ensure your code is comprehensible to people who read it](https://en.wikipedia.org/wiki/Magic_number_(programming)#Unnamed_numerical_constants) (including your future self). Whether to name or not name a particular constant value depends a lot on context. For a function this small, it's not particularly necessary, but it's a good habit to develop as you work toward more complex projects.
I believe start_routine is a function pointer that takes a void pointer as an argument and returns a void pointer.
This is pretty common any time you roll your own allocator; e.g., you need to do something like this to construct subregions of your heap memory, or to align a pointer to some boundary. Some programs also use low or high pointer bits to encode extra data (e.g., you know your block is aligned to a 16-byte boundary; therefore the bottom 4 bits are free for you to use), although this can be a little iffy in terms of breaking compiler expectations and it imposes an overhead on any access through the pointer.
Thanks! I was confused because I thought void always meant nothing. But I also just read that in C void is sometimes used as a function parameter when the data type cannot be known ahead of time. Then once that data is passed in to start_routine() it can be cast to another data type, and then used.
Are you familiar with the representation of number in binary (i.e. base 2)? If not, you should google up some tutorials and familiarize yourself with it.
Keep in mind instead of String1[i] you can skip a computation step, make the function arguments pointers (int any(char *String1, char *String2) and do *(String1+i). That's the only change I would make if I wasn't using any library functions such as strchr.
Each bit is a power of two. The number five is the following bits: bit0 = 1 (1) bit1 = 0 (2) bit2 = 1 (4) ... all the rest are not set 1 + 4 = 5 A bitwise *OR* compares the bits of two values and returns all of them in either that were set to 1: 7 | 5 = b0 1 vs b0 1 = 1 b1 1 vs b1 0 = 1 b2 1 vs b2 1 = 1 In this case, 7 | 5 = 7, because as you can see with 7, all of the bits compared exist in either one. 8 | 5 : b0 0 vs b0 1 = 1 b1 0 vs b1 0 = 0 b2 0 vs b2 1 = 1 b3 1 vs b3 0 = 1 The answer would be 13 ( 8 + 4 + 1 ). Bitwise *AND* is similar, except it makes sure the same bit is set in both values.
I am familiar enough with the system to understand the binary system is made of 0's and 1's. I understand how to convert from decimal to binary and vice versa. My problem is understanding what this function is suppose to do and how it works.
p + 1 - n = 3 75 in binary: 01001011 shifted to the right by 3 = 00001001 ~0 = 11111111 shifted to the left by 4 = 11110000 ~11110000 = 00001111 00001001 &amp; 00001111 = 00001001 = 9 this requires some basic knowledge of binary numbers and simple logic (ands and nots)
[translator](https://cdecl.org/?q=void+*%28*start_routine%29+%28void+*%29%3B)
&gt; void *arg like this right?
very nice, thanks
I guess you meant `x=75` rather than `n=75` ?
note that `~0 &lt;&lt; n` is undefined behaviour; it should be `~0u &lt;&lt; n` to ensure the desired result 
This isn't directly related to explaining your example code, but may give you an overview of the kinds of tricks you can do with bitwise operators, and may help you understand them more: http://www.catonmat.net/blog/low-level-bit-hacks-you-absolutely-must-know/ https://stackoverflow.com/questions/1533131/what-useful-bitwise-operator-code-tricks-should-a-developer-know-about https://graphics.stanford.edu/~seander/bithacks.html Note, many of these examples will be tricky, so don't dwell on them too long if they are confusing, but move onto others, and over time you'll begin to understand them more and more. (or ask questions here)
Compile sources with -fprofile-arcs - ftest-coverage. Run the unit test. Run gcov on all the gcno files. Then run the codecov.io uploader. See a project I work on: https://github.com/opentracing/opentracing-c.
That's how you would declare a void pointer, yeah. Basically, the standard just guarantees that any other pointer type can be cast to `void *` without losing any information so you can pass any pointer into a function that takes a `void *` argument.
to add to this comment, here are all the bitwise operations/operators in C: BITWISE OR ('|' operator (note the single pipe!)): u/dumsubfilter covered this one, OR compares the bits of two integers. If either bit is a 1, the resulting bit will be 1. if both are 0, the resulting bit will be 0. example: 00110011 OR (|) 11100111 = 11110111 BITWISE AND ('&amp;' operator (note the single ampersand!)): this operation is similar to OR, but both bits being compared must be 1 in order to get a result bit of 1. otherwise, the resulting bit will be 0. example: 11001100 AND (&amp;) 10101010 = 10001000 BITWISE NOT ('~' operator): this operation simply flips each bit to the opposite value. note that this operation is unary, meaning it only takes one operand. example: 00001111 NOT = 11110000 BITWISE XOR ('^' operator): if the two compared bits are different, the result bit will be 1. otherwise, it will be 0. example: 11001100 XOR (^) 10101010 = 01100110 BITWISE SHIFT ('&lt;&lt;' or '&gt;&gt;' operators) these operations simply shift each bit to the left or right by a given number of places. bits shifted "off of the integer" are discarded. bits that fill in the empty places created by the shift are set to 0. '&lt;&lt;' shifts the bits to the left (toward the most significant bit) '&gt;&gt;' shifts the bits to the right (toward the least significant bit) examples: 00001111 LEFT SHIFT (&lt;&lt;) 2 (the second operand is the amount of places to shift) = 00111100 00011100 RIGHT SHIFT (&gt;&gt;) 3 = 00000011 note that some bitwise operations work differently on signed vs unsigned integers. i would recommend reading up on bitwise operations and the uses for them. they can be very handy. :3 (sorry if things aren't formatted right!)
Yes, I suggest you to try to write the same code but working with pointers instead.
Hey @FUZxxl thanks for reply. It's a simple diagram, shows that some of the most popular tools all over the world is made using C. I agree that other languages also used to build those tools. But at root level c programming is commonly used to develop platforms like; android, google search engine or microsoft windows.
Yes redrod17 other programming are also used. but platforms like; unix, google search engine or windows have one thing in common that is C programming.
Note that as far as I'm concerned, the Google search engine is written in C++, not C.
no worries, urls ?
Side note: Perhaps some of the confusion here comes from the density of the one line. When you see this sort of thing, first try to logically split up the line into multiple lines. It might make things clearer and it's good for general understanding. 
There's nothing wrong with using array notation versus pointer arithmetic. However, try not to use the array notation in the function arguments. This is usually never a good idea. Use pointers in the function arguments. Note: you can use array notation with pointers it's just shorthand and can often make the code more readable.
My dear FUZxxl, it is written in C, C++ and python. you can check from this link : https://en.wikipedia.org/wiki/Google_Search