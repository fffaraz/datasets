You'd be better off to just install FreeBSD or a linux disto and dual boot. MinGW and MSYS are massive PITAes.
Imagine this simple scenario (in UNIX/Linux): You invoke a command like so: $ wc somefile.txt $ 45 Now, if you check return code, you would do so: $ echo $? $ 0 This '0' means that the 'wc' tool completed successfully i.e., "somefile.txt" actually exists and is a valid file that 'wc' could parse to get the word count of the file. On the other hand, suppose you try the following (where "fakefile.txt" does not exist): $ wc fakefile.txt And then see what the return code was, $ echo $? $ 1 You see that it is a non-zero return code. This means that 'wc' failed to get the word count for the file for whatever reason. This is one example where return codes are useful. Suppose you had 'wc' as part of a small custom script where you check its return value before proceeding, you could easily check for the return code, ensure that it is 0 (success), and the proceed or fail (if the return code is non-zero). Now imagine writing your own tool where you have complete control over the return codes. Following convention, you return 0 for success and then some non-zero code for error conditions. You could then even check for the return code, and then see what error condition made it fail! Pretty useful, isn't it? 
[musl](http://www.musl-libc.org/), an alternative to glibc, claims to support C11 threads. I haven't tried it personally. 
It works out-of-the-box for me using MinGW-w64 6.2.0 . Maybe you are using an old version (or even worse, using the defunct MinGW instead of MinGW-w64)
mainly to actually learn c.
Yup, that's exactly right! Haha, I'm pretty new as well actually, I just finished my intro to C class in college! Let me know if you have any other questions.
hmmm.... 1 - 0 --- 1 the difference is one.
[removed]
You could do some pre-processor fun to direct the program to the proper implementation of pthreads or windows threads using pre c11 tech. But it means you basically have to write the same program twice. You might be able to get around it a bit by writing most of your functions generically, but it sounds hairy. I've also been very disappointed in the adaption of c11 standards and documentation. Someone badly needs to write a book on it, and I'd love to see more Windows support. On the other end, I'd probably say that if your intention is to learn C, you don't need to be using c11 in the Windows world. You can learn everything you need in the nix world, and then when you need cross compiled native threading, you can jump to c++11 and higher, which is well supported. 
The C specification doesn't specify how memory is fetched, and we are trying to operate within the specification. Although it is likely by word on most architectures in use. I think `base[offset]` desugaring into `base + offset` which then means advance `offset` steps of `sizeof(*base)` is a nice and clean in meaning. It explains why arrays are 0-indexed: as `base[0]` is the first item, the same as `*(base+0)`, however then in your system `base[1]` not being equal to `*(base+1)` would seem odd to me. The issue is that there is already lots of C code out there relying on this matching behaviour between pointer arithmetic and array indices. The change you are proposing would *require* everything of `size &lt; atom` to be padded up to `sizeof(atom)`, whereas he current spec *allows* this behaviour but doesn't *require* it. &gt; I'm still not sure how &amp;some_var +1 meaning one byte beyond &amp;somevar regardless of sizeof(typeof(somevar)) is going to break lots of things But you were saying that `&amp;some_var + 1` would always mean one `architecture/implementation defined unit` beyond `&amp;somevar`, which is where I have issue - as this completely destroys portability of any kind of pointer arithmetic. It means the expressions `&amp;some_var + 1` no longer has any static meaning without considering which architecture it is running on. For some context: my ideal C would have even more behaviour defined by the specification and leave even less up to individual implementations / architectures, but I think that difference comes down to how you and I both use C in different ways. I primarily use C as something above assembler, and my primary use cases are implementation programming languages and their supporting environments (runtime, data structures, etc.). So I *want* to escape individual architecture / implementation details as much as possible. &gt; And C offers no protection against illegal access anyway, so I'm not entirely sure I follow you argument there. My argument is that your `strncpy` code *assuming* your memory allocator and accesses are always word aligned is less portable and not guaranteed by the spec (AFAIK), and thus could lead to *more* illegal accesses. And what word alignment do you pick ? do you always assume 4 byte ? 8 byte ? Does your ideal C standard specify alignment to be at least 4 bytes ? For example, the Glibc `strncmp` correctly avoids making this assumption by having two code paths for dealing with 4-byte aligned portions and then any non-4-byte 'leftover': 4-byte portion: https://sourceware.org/git/?p=glibc.git;a=blob;f=string/strncmp.c;h=b77a33452bf94643eb1946018fe75fa9bd6944cd;hb=HEAD#l37 leftover: https://sourceware.org/git/?p=glibc.git;a=blob;f=string/strncmp.c;h=b77a33452bf94643eb1946018fe75fa9bd6944cd;hb=HEAD#l62 
Do you mean "implemented efficiently" and without relying on an alloc? As a naive first pass would be (ignoring error handling): void *my_memmove(void *dest, const void *src, size_t n){ void *tmp = 0; tmp = malloc(n); memcpy(tmp, src, n); memcpy(dest, tmp, n); return dest; } edit: or something avoiding using memcpy (also naive, avoiding error handling): void *my_memmove2(void *dest, const void *src, size_t n){ size_t i =0; const char *from = 0; char *to = 0; void *tmp = 0; tmp = malloc(n); to = tmp; from = src; for(i=0;i&lt;n;++i){ *to++ = *from++; } to = dest; from = tmp; for(i=0;i&lt;n;++i){ *to++ = *from++; } return dest; } edit 2: forgot the increments, added. edit 3: added mention of 'without relying on an alloc'.
I've never used C11 threads, but the general vibe I get from a few C experts both here and on StackOverflow is that C11 threads are a really dumbed-down and incompatible version of pthreads. Thread support in C11 is optional as far as I am aware, so even a conforming implementation need not provide threading support in its standard library, and like you say, support for C11 threads is pretty scarce. Even though it's usually preferable to use functionality from the standard library, in the case of threading, it may be better to use a more mature and portable library (e.g. pthreads, which is also supported on Windows using [SFU](https://technet.microsoft.com/en-us/library/bb463209.aspx)).
I tried using this but doesn't print out anything, would the fact I have to use Ansi C make any difference?
`intptr_t` is a signed integer type, `uintptr_t` is an unsigned integer type. You can do all arithmetic on these types you can do with other integer types. Read too the footnote I cited above.
One mistake I can see is that you are using `%ld` to scan a `double`, but you should be using `%lf`. Try to get into the habit of checking the return value of `scanf` (look up the documentation for `scanf` to see what it should be returning). Also, make sure that your input matches the format you specify.
TIL on the non int return being undefined in C89. I assume that, legacy wise, it is probably a good reason why it is advised against even if it is complaint for some given vendor embedded compiler. Thanks for sharing!
How about [GLib](https://developer.gnome.org/glib/2.50/). It is portable and has a library for threads.
Sometimes a pager is attached and you might still want highlighting. BSD ls uses `$CLICOLOR_FORCE` for this purpose.
What does the function return if `values[a] != value` and `a != n` ?
Nothing yet, because it is still searching. It return false if a ==n and values[a] != value.
Because if n=0, the loop will never run. Your code shows that you don't quite understand how loops and flow control work. Having a `break` after a `return` statement is nonsensical. Checking for `a==n` or `a==n-1` inside the loop is a waste of CPU cycles; the loop already tests that, and what you're trying to do there (have a condition for "item wasn't found in the array"), you really want to move to below the loop.
&gt; So for example in a bare-metal micro it would be indifferent to have int main return 0 or just void main return, without any return values. Depending on how bare your baremetal is, you needn't even use `main()`. You could just as easily have the assembly code that sets up your C runtime environment call `start()` or some other function.
&gt; I don't really know much about how sound data is stored or manipulated or anything. Right, so let us explain how much you don't know: a lot. Sound is generally *manipulated* as raw PCM samples. That's the only way that makes sense. You can't really do sound editing on an MP3 file itself, and if you could, you'd have to use totally different techniques for editing a file encoded as AAC or Opus or any other codec, since they're all encoded differently. For actually manipulating audio, you start with raw PCM samples (since that's the common denominator) and manipulate it from there. Some manipulations are done on those samples (like applying gain [changing the volume] or mixing [summing] signals), but a lot require you to convert from time domain to frequency domain, manipulate it, and then convert back. That's all in the realm of [Digital Signal Processing (DSP)](https://en.wikipedia.org/wiki/Digital_signal_processing), which I never studied and don't know much about beyond the very basics. This is stuff you cover in 2nd and 3rd year of a university Computer Engineering degree. Encoding and decoding stuff as MP3s is yet another application of DSP, but it's different because someone has already determined the correct way to do it; if you do it any different way, you'll be decoding it wrong. This is why it's not worth it to implement that part yourself. Just use an existing implementation to decode it.
The best I can think of is to make a new 2D array and fill it with processed data from first one(process struct by struct from first and write it to second 2D array). First one will stay untouched, you will have processed one. Total memory has to be double of first 2D array if you need both to be saved. Correct me if I'm wrong somewhere.
I've never actually heard someone suggesting *not* to use -Werror. Can you expand on that advice a little?
That only “works” if `arr` is an object of array type. However, in OPs example (whose code he didn't show), `values` is a pointer, not an array.
One other (premature?) optimization I can think of (which is not really related to your question, however), is using a one-dimensional array instead, which in this case holds (rows × cols) elements. So for instance if you have a matrix as follows (imagine the numbers are structs though): rows = 3 cols = 5 array = [ 1 0 3 4 5 9 0 7 1 2 5 6 8 4 9 ] int find(int x, int y) { return array[y * cols + x]; } or something like that.
How about instead of allocating an array of pointers and then one array for each row, you allocate one flat array and then do the index computations manually?
I guess that's what Azzk1kr said. It's same amount memory that needs to be allocated, I tought that it doesn't make a difference.
A one dimensional array requires one loop for iteration if you want to visit all items. If you have a two dimensional array, you will most likely need two loops: one to iterate all 'rows', and one to iterate over all 'columns' in the current row. There's probably also some optimization about addressing or memory layout, but I'm not too knowledgeable about that, currently :)
I've coded my [hex editor](https://github.com/krpors/hx) with ANSI escape sequences only as well. I haven't yet come across any (major) portability problems. Like you, I don't want to have a dependency on ncurses as well. IMO, most Linux distro's ship with VTs which are VT100 compatible anyway, and I don't need/want to support that magnitude of (probably unused) terminals anyway.
Thanks for writing this out. I sat down and thought about it over a cup of tea. Warnings are handy because so frequently they're an indication that I did something wrong. If there's a bunch of existing harmless warnings, it can be hard to spot a new one popping. And the new one might not be so harmless. As a result, I tend to strongly prefer -Werror because it forces me to keep my code warning-free, making it highly obvious when a new warning pops up. But your writeup made my realize that's just a personal preference, rather than some Grand Truth About Programming. And you're probably right that it can give beginners some weird ideas about what is and isn't C. And -Werror definitely gives different results on different compilers. That's a problem I should be thinking about how to solve on my own projects. Cheers!
The compiler can transform loops very well. It'll swap, unroll, or merge as it sees fit, but honestly the most troublesome part is going to be the loop body, not the bounds.
Malloc works better as you move from more, smaller calls to fewer, larger calls. Best is a single slab of memory, either statically alloc'd at compile time or once at runtime, then treated however you like. MyStruct* slab = malloc(cols * rows * sizeof(MyStruct); Slab[row][col] will now work just fine and be a MyStruct object, not a ptr.
It's actually less memory as you don't need an array of pointers. It's also faster as the data is close together and quicker to allocate and deallocate as there is only one region to deal with.
Modern gcc and clang versions come with a bunch of exceptionally useless warnings. For example, clang warns by default if you use the C operator precedence rules, e.g. in a &amp;&amp; b || c &amp;&amp; d clang warns you by default, asking you to use parentheses. This is completely inacceptable and I refuse to tarnish my code by adding useless irritating parentheses. Some other warnings are just plain wrong. For example, I distinctly remember gcc warning about a statement of the form foo || bar(); having no effect, even though it clearly has (if foo is zero, that is). It is very annoying to disable every such warning individually and `-Werror` would totally kill my productivity.
Thank you again, I have been useing the last method you mentioned for a few years now. I would recommend *research gate* as another source of papers.
Eh, I'm pretty skeptical of your examples. In your first example, you're saving four keystrokes, and in the second, you're saving about eight over the equivalent if-structure. You're paying for that by making your code slightly less readable - I had to look up &amp;&amp;/|| operator precedence to understand the first one, and it took me a moment of confusion to work out what the second one likely does. I've seen a lot of people claim that saving a handful of keystrokes is worth adding additional complicity, but it's never been true for me - I'm always limited by my speed of thought, and never by my speed of typing. Shucks, I once re-typed eight hours of work in two hours! Cheers!
It's not about saving keystrokes, it's about not restricting the featureset provided by the language because of some arbitrary made up things the compiler warns about. The C language has operator precedence rules, so I don't see why using them warrants a warning.
You can allocate a 2d array on the heap as well. This would be my preferred solution. http://stackoverflow.com/questions/10116368/heap-allocate-a-2d-array-not-array-of-pointers
Won't he need to do Slab[x * COLS + y]?
Same thing. slab[rows][cols] causes slab to be a buffer of (rows * cols) instances of whatever type it contains. It just allows for multidimensional access, so instead of doing the multiplication ourselves, the [] operators do it. Slab itself is a data** double pointer, so it can support two [] operators to reach a data item. Size-wise, slab's block is the same regardless of whether you use two []s with smaller indices to declare it or one with the product of the two.
I didn't explain it clearly enough. The spec allows for any `void *` type to be converted to an `intptr_t`, and for that same `intptr_t` to be converted to a `void *`, and for those two `void *`s to compare equal. It doesn't (to my knowledge) require that any `intptr_t` can be converted to a `void *` and have a meaningful value. So I don't see any part of the spec requiring this code to be defined behaviour: void foo(void *v){ intptr_t it = v; it += 4; v = it; *v; // do something with v } as I am not just converting back and forth, I am also changing the value of my `intptr_t` and I don't see any requirement that the conversion back is well defined. The footnote above only states that the conversion is defined in two cases: 1. any `void *` can be converted to an `intptr_t` 2. any `intptr_t` that was converted from a `void *` can be converted back to `void *` and will compare equal to it's original value It doesn't say what happens when the converted back value would no longer compare equal, or that the conversion back is even defined. Is there another section covering this? edit: formatting; not used to reddit markdown
&gt; You can't malloc because that may fail This is the part I failed to consider, I assumed that memmove/memcpy could fail - but looking at the spec their return codes don't allow for any kind of error value it seems. &gt; Btw, your code leaks. I was omitting error handling, cleanup, etc. for brevity. There are of course far more expensive ways of doing this: I could iterate over all pointers between `src` and `src + n` and `dest` and `dest + n` checking for pointer equality to find how/if they overlap, in fact I can do this with a single for loop. There are only 3 cases to consider since both are regions of size N: 1. they represent the exact same region: `src == dest` 2. src &lt; dest: `src + i == dest` where `i &lt; n` 3. src &gt; dest: `src == dest + i` where `i &lt; n` 4. they do not overlap Comparing pointers of the same type for equality, and incrementing pointers are both defined operations. I can then use this knowledge to decide how to perform the copy, possibly even falling back to memcpy if I detect they don't over lap. I decide to try throw together a quick version of this, it could likely be made a lot faster and maybe even tidied up (using goto to prevent code dup) - but I wanted to keep it clean and simple: [https://gist.github.com/mkfifo/a82604ad0a0438d915ff829b89b9fc9d](https://gist.github.com/mkfifo/a82604ad0a0438d915ff829b89b9fc9d) edits: * formatting; not used to reddit markdown. * changed "Comparing pointers of the same type," to "Comparing pointers of the same type for equality," to remove ambiguity. * fixing equality operator (accidentally used assignment). * mentioned single for loop * added concrete example
The issue is that you are declaring Person *person as a pointer in main() and passing it as a pointer into first_init(). The malloc() on the line of first_init() makes p point to a newly allocated chunk of memory, but person in main() still points to NULL. To make this work, you can either return p from first_init() instead of taking it as an argument, or you can move the malloc() into main(). 
 void first_init(Person *p, int age, int salary) { p = malloc(sizeof(Person)); You're passing the *value* of `person`, not a *reference* to the `person` variable. What happens is `p` gets initialised to the value of `person`, which is actually undefined. But let's assume here that `person` is defined to NULL. So `p` gets set to NULL. `p` then gets set to a block of memory because of `malloc` returning a pointer. Thus, `p` is set to a valid block of memory, while `person` remains NULL, and continues to be NULL even after `first_init` finishes. `p` is forgotten about, and the block of memory isn't freed. So not only is `person` NULL, but you've also leaked memory, which will not be cleaned up until your program exits or crashes. Fortunately, that doesn't take long at all. ---- Here's one way to make your program work: void first_init(Person **p, int age, int salary) { (*p) = malloc(sizeof(Person)); (*p)-&gt;age = age; (*p)-&gt;salary = salary; } and you'd call it like so: first_init(&amp;person, 10, 20); `&amp;` gives you a *pointer* (or a *reference*) to the variable in question. `*` dereferences a pointer. My advice here, however, is instead of making `first_init` a `void` function, you'd be better off returning something of type `Person *`.
&gt; you can either return p from first_init() instead of taking it as an argument I've tried this approach with a function signature like: Person *first_init(int age, int salary); In this case though I can't seem to be able to free the struct later in the code. I've tried to use a destructor like function: person_free(Person *person) { free(person); } But this doesn't work when called from main.
Thanks. I've already tried the second approach returning a pointer from first_init: Person *first_init(int, int); But now I can't properly *free* the struct, still leaks.
How does that not work? Got an example?
Changing the value of the passed in pointer does nothing, it's like assigning a integer parameter a new value, only changing the data the the pointer points to does anything. If you want to do this, simply pass a pointer to the pointer. Meaning change `first_init(person, 10, 20);` to `first_init(&amp;person, 10, 20);`. Change `void first_init(Person *p, int age, int salary) {` to `void first_init(Person **p, int age, int salary) {`. Finally last but not least change all the `p` in that function to `(*p)`. Done.
Okay. That frees the allocated memory. But then trying to set the pointer to NULL and wondering why that isn't reflected in the caller is the exact same issue from the original question, with the same answer. The function gets a *copy* of the variable. Make that copy point to a new address, and, yes, the original will not change. 
 void first_init(Person *p, int age, int salary) does not change the **passed parameter** p value, you could use void first_init(Person **p, int age, int salary) to write back the pointer value
I hope you don't suggest a double free, becouse it's a potential security vulnerability or at least undefined behavior: http://stackoverflow.com/questions/21057393/what-does-double-free-mean
No, the two generally cannot use the same code.
I think the above code I posted isn't actually standards-compliant, as pointer comparisons are even less defined than I thought, I had some help from a few friends as well as ##c on freenode to get to this point. Two conditions under which my above code would fail: 1. if in the case of overlap: two pointers from the different arrays referring to the overlapped section may not compare equal 2. if in the case of non-overlap: two pointers could compare equal despite pointing to different objects within different arrays I am unsure if `(1)` is possible, but `(2)` appears to be possible. Some examples from ##c: char a[2][3]; &amp;a[0][3] == &amp;a[1][0]; This may compare true, `&amp;a[0][3]` cannot be dereferenced as it refers to a non-object, but it may compared equal to a later element. int i; int j; (&amp;i + 1) == j; This may also compare true. any dereference of `&amp;i + 1` would make that program non-conformant, but the comparison may still compare true. 
Mostly. You can *kinda* get C libraries to work in C#, *usually*. But it's generally not at all worth it.
you could use numpy
We don't have new, and for regular types like a char array, you'd simply declare the char beforehand with it's size. so something like: char pszOutBuffer[dwSize + 1]; This assumes dwSize is a compile time constant. If you need a char array for a dynamic string, you can call malloc or calloc like this: char *pszOutBuffer = calloc(((sizeof(char) * dwSize) + 1), 1);
What are you trying to do, dude? I mean, I've got arrays of structs, but a 2D array of structs? #Insanity
You are correct. It's implementation defined if you.can do that.
I want to generate a tile map, each holding some information.
since you've not actually asked a question, i will give my opinion on this: k&amp;r is designed to give examples of c usage; for the most part, these examples are relatively easy to maneuver for an experienced programmer if you are having trouble understanding the examples/exercises, this means you need to work on your ability as a programmer, not specifically a C programmer i will provide a basic example of a solution to the exercise you gave this makes use of the standard library, though the routines used (pow, atof, atoi) can be implemented with relative ease #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; double atof_sci(char *s) { //parse the base double base = atof(s); // scan s for an E or e and stop when either is found while (*s &amp;&amp; *s != 'E' &amp;&amp; *s != 'e') { s += 1; } // parse the exponent int exponent = atoi(s); return base * pow(10, exponent); } int main(void) { printf("%f\n", atof_sci("1e-3")); } edit: yes, the above code is kind of fucked and i cbf fixing it
Good idea, however I think it'd make it a bit inconvenient to iterate a section of the matrix, for example an area described by some coordinates. 
To reduce the memory usage I came up with the idea, to use the same pointer to a struct where the values are the same, and later replace with a new one if necessary. 
Yeah I know im not a good programmer but this is supposed to be a begginers book. Everyone on the internet reccomends it to begginers. I guess i should try harder to understand, thanks for the example
And btw how would someone work on their ability as a programmer?
The same way you work on any ability, by practicing and gaining experience. Try writing simple programs for fun. Perhaps automating something that you do on a regular basis, even if someone else has already done it. The more you do anything the better you get at it. People who are really good at something are that way because they do it all the time; usually because they love doing that thing and spend lots of their free time doing it.
&gt;Descriptions and everything is really clear but examples and exercises are really hard. Academics love to do this and it's extremely frustrating for students
You can either proceed as /u/02471 said, or modify the `atof()` function itself. But for this, you must have understood how it works, how it progresses through each element of the number, how it decomposes it and deals with the sign, then the digits before the dot, then the dot, then the digits after the dots. Once you've understood that, it should become easy to deal with scientific notation. That notation comes *after* a number in the previous form. So you just have to append your extra processing after the existing one, you don't need to change or insert anything in the existing one. And you deal with this extra notation the same way the original `atof` dealt with the first part of the number: decompose it and process each part one after the other: first, the letter `e`/`E` (as dot was processed in the existing `atof`), then the sign `+`/`-`/none (as sign was processed in the existing `atof`), then the digits (as digits were pro...). 
It really does not go into detail
Come on, you need to learn the value of patience and perseverance! You haven't given any information about yourself, so how can we even know what to say? That being said, I would classify this as a book for beginning C programming, not necessarily a beginner's book. It's for someone already with some experience in programming, and who wants to get started with C. Don't be fooled by the size of the book, it's pretty dense because no words are wasted. In my opinion, if you have the character to work through it, and not merely expect to blaze through it like those washed-out videos you find everywhere these days, it will definitely reward you wholesomely. We had this text book in college, and I worked through the whole book (including most of the exercises). It took a whole semeter to do it properly the first time, so be patient! A good solution manual is by Clovis Tondo (if I recall the name correctly). However, I would highly recommend that you work through all the given code, understand them, implement them yourself, and then work through the problems. If you really can't find a solution after spending an hour on a problem, leave it for now, and move on. Revisit them after a day or so, and if you still can't solve it, look at the solution, understand it, and implement it yourself. Rinse and repeat. This exercise itself will improve your programming (and problem solving) skills tremendously. Above all, you have to work through it with enjoyment! It's not a chore. It's a great source of pleasure along with frustration! Good luck.
&gt; Although there may be a more elegant way to do that, that doesn't destroy the return value of printf. Maybe you can use [comma operator](https://en.wikipedia.org/wiki/Comma_operator).
K&amp;R is considered brilliant and well-written, even after all these years, so complaining about it isn't going to gain you sympathy. 
Any idea as to why it's called C# in the first place?
It's supposed to be C++++ and # kinda looks like four plusses.
Please copy/paste the relevant information into this post.
It depends on what libraries you are talking about. In your example, you are referring to the .NET platform class libraries (System.Net.Socket is part of .NET). The .NET platform is available as libraries for C#, C++, VB (and maybe more languages I don't know about that MS supports). To generalize: Yes, you **can** link a C# DLL library to C, but you must use the C++ compiler/linker. It's also perfectly legal to link a C library into C#. Therefore, yes, you could write C code, compile and link with the C++ compiler and link it with the .NET platform libraries and thus gain access to the *System.Net.Socket* namespace. However, be aware that you are asking to do something *pretty weird*. You are about to write procedural code using an object oriented library. I would recommend you either use an object oriented language (such as C++ or C#) with the .NET class library or use C (procedural programming language) with a procedural library. If you want to do sockets in C (in windows), use the the Winsock library.
I really don't get why people would like their code to compile with warnings. Compilers implement these warnings for a reason that we shouldn't ignore. In the if case with several comparisons, IMHO it is dangerous to rely on the operators precedence. Besides the fact the parenthesis doesn't in general add complexity to the code, but rather clarify it, they can avoid mistaskes when one needs to add other set of comparisons to that if. Ignoring warnings may lead to difficult to trace errors, specially when one is extending an existing code base. It worth mentioning that we can still compile with the -Werror flag and disable specific - so called - annoying warnings using the set of flags -Wno-&lt;annoying-warning&gt;. Another approach is to use #pragma directives to suppress specific warnings in a given chunk of code. This is useful when one wants to use the -Werror flag, but some included external header is the source of the warnings. Ps: I dare those who are brave to use the flag -Wpedantic =p
Yes K&amp;R is not a beginner's book. You should read it only if you are already good with a programming language. 
As other's have said, K&amp;R is a great introduction to C, but not a great introduction to programming/computer science. I think more people should try to C as their first language as it gives the student a better idea of what the computer is actually doing than high-level languages. I wish I had a modern book I could refer you to for learning C as a first language, but I am out of the loop, however, I have heard great things about [Harvard's free online course: Introduction to Computer Science](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x#!) which uses C (and some other languages). As far as learning how to be a better programmer, I think one of the key things is to 1) strive to understand what is happening under the hood. 2) Break large problems into smaller ones 3) Logically order the operations needed to complete the tasks that solve the problem, 4) Learn multiple programming languages. #Some tips for becoming a better programmer **Strive to understand what the computer is doing when you execute your program** Understanding what the compiler/interpreter is doing with your source code, how the the processor executes the binary and how information is stored/accessed in memory will help you write more efficient code. The C language is great for learning these things once you start to wrap your mind around it. I would also recommend learning computer organization and hardware. One book I found that really helped me learn what a computer does is [The Elements of Computing Systems: Building a Modern Computer from First Principles](https://www.amazon.com/dp/0262640686). I would recommend a casual reading of it, don't get too hung up if you don't quite 'get' it. Read it and see what sinks in. After you get better at C and maybe learn another language, come back to this book and read it again with closer scrutiny. **Break large problems into smaller ones. Logically order the operations needed to complete the tasks that solve the BIG problem** Before I write a single line of code I will spend days, weeks or even months just planning the program out. Flow charts and lists, pseudo code are your friend. Identify your large problem, think about all the different steps needed to get there, write them all down. Determine how to what you need to do to complete each step. Determine if you are doing the same task multiple times (I keep writing data to this log file, I keep checking to see if this array is full, etc.), if so, then you need a function for that. Write this all down as a human readable list of steps. Once you think you have solved the big problem, start coding the small stuff. Write small programs that complete each step you identified and test each little program. Once you've written all those little programs, put the pieces together. Check out [How to Think Like A Programmer](https://www.amazon.com/Think-Like-Programmer-Introduction-Creative/dp/1593274246/). It's an excellent book in this area. **Learn multiple programming languages** Again, stick with C until some things are really clicking for you. Eventually though you need to learn another language or two before the "thinking like a programmer" will really sink in. The more languages you learn, the easier it is to learn even more languages. You will begin to see the patterns in languages. You will notice the different approaches that different programming paradigms take. There is a reason that nearly every book, course or tutorial on learning a language follow very similar trajectory: What datatypes exist in this language? How to declare a variable of a particular type. How to output text to the screen, how to cast a variable to a different type, how arrays work in this language, how IF/Then/Else works, How loops work, etc. These are things (nearly) every language has and they are the first steps to learning how to work with that language. Hope some of this helps! 
Instead of "(1 &lt;&lt; n)-1" to get n amount of 1s you can use "~(~0 &lt;&lt; n)" if you think that looks neater, either of them works 
I'm left wondering what that advanced C book was...
It was "Expert C Programming" by Peter Van Der Linden. Recommended.
Thought you were joking but I now know it's the truth. Thanks! Any idea as to why it is more like Java than C++? (Am I making that up?)
Is this technique widely used? It seems like applying the precedence rules is easier than this.
&gt;It is like the function first_init gets a copy and not a pointer to the one from the main function. That is exactly how parameter passing works in C. 
Also the array operands of `%s` should not have `&amp;`, and the `%s` should have a length limiter.
Maybe it will be clearer without macros? #include &lt;stdio.h&gt; void func(unsigned int flags) { if ( flags &amp; 1 ) puts("A"); if ( flags &amp; 2 ) puts("B"); } int main(void) { func(1); func(2); func(1 | 2); } Try to predict the output of the program before running it.
I don't know how widely it's used, but it's old as hell and it works. This page helped me a lot: http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html
Microsoft basically tried to copy Java and was somewhat successful with that.
`0` is a signed int. It would be OK to use `~0u &lt;&lt; n`, assuming `n` is less than the number of bits in an unsigned int.
fgetc takes one step forward, and fseek -2 takes two steps backwards, which results in one step backwards in total per iteration.
1 If you did seek(0,FILE_END) then the file pointer would be a the end of the file. After the last character. 2 When you read Z the file pointer is advanced by 1. If you then did seek(-1) then the file pointer would be back at Z. seek(-2) jumps over the Z and over the Y, so the next read reads the Y.
You're mixing signed and unsigned types. You have `sum` as a signed integer and `count` as an unsigned integer. When you write `sum/count`, the compiler has to sort out the mismatch. And in this case it does it by converting sum to an unsigned value. -74 in 2's complement form is FFFFFFB6 or 4294967222 And that number divided by 28 is 153391686
Q1: The file writing leaves fptr one past the end of the file. Back up one (fseek -1) and fptr is to the left of the 'Z'. Q2: fgetc reads a character and then moves fptr to the right 1 byte. Since you want the next character read to be the one to the _left_ of the character you just read, you need to back up two (fseek - 2) from where fgetc left the fptr in order to be in the right position to read it the next time through.
Thanks. I was confused about what actually happens when you pass a pointer to a function, actually free works just fine in my cleanup function (since free frees the block of memory to which p points and doesn't try to modify p) . Working example: void person_cleanup(Person *p) { if(p) { free(p) } } Using free directly in main also works. 
It is a way of *hiding* the definition of the struct from main. All that main cares about is that this is a structure. This works just fine as long as you keep a pointer to the struct in main and modify the object through functions that have access to the full definition of the structure. For example this will work: Person *person = person_init(...); person_do_soemthing(person); ... But you won't be able to create a Person on the stack since main doesn't actually know the full definition of Person. This code won't work: Person person; // compilation error 
It breaks in certain cases which [Linus explains at the top of the comments](https://plus.google.com/+gregkroahhartman/posts/1ZhdNwbjcYF).
Protip: Subscribers to /r/C_Programming tend to like C more than C++, and you're just posting bait.
Sorry, C++ is off topic in this subreddit. Please post C++ content elsewhere.
You need all the header files to *build* the `.a`, but you don't need them to *distribute* it. Once it's built, it and the API headers can be packaged for distribution, and that's a wholly other process than compilation.
[Here's my best simple sketch](http://i.imgur.com/EFcXoww.jpg). Basically I was under the impression that I could create the static (.a) library and include only TopLevel.h as the API since function calls to the library would all come from there. But it seems like the lower level header files such as Functions1.h, Functions2.h and Functions3.h are saying that they're required as well.
They are not. It's more like one project with a couple separate source files packaged as a single library for someone to use. Since each level requires at least one header (sometimes more), I'd rather not have to give them all of the headers from the bottom to the top. I thought just the top header would suffice since those are the only direct calls the user would make to the library from his source code.
That's certainly one option, and probably the quickest.
Why would an ide highlight this error? From the compiler perspective this is perfectly allowed and the compiler did it it right. 
Rewriting an article that's been written many times before is easy clicks, huh?
It's a pity, that now it is no longer free.
I would recommend Pointers on C by Kenneth Reek together with Understanding and using C pointers by Richard Reese
web version is free
You should absolutely not edit assert.h itself. To disable the error dialog boxes for a process, use the [SetErrorMode](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621(v=vs.85\).aspx) function, e.g: `SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );`. 
Well, the variables are pretty fucking cryptic, and it would remove that, making it easier to understand what's going on.
&gt; none of these examples include keywords ... volotile, To be fair I would be very surprised if it included the keyword `volotile`, `volatile` is far more likely. 
The more complicated declarations are totally unnecessary and shouldn't be done. People like to point to such things to declare their own disgust for C but no experienced C programmer would ever do such a thing.
How did you installed GTK on your Mac ? If you've used [brew](http://brew.sh/) this command: brew install gtk+ will install GTK 2.24 and not version 3. To install version 3, use: brew install gtk+3 If you've correctly installed GTK 3, make sure you are using backticks (upper left on your keyboard) and not single quotes in your pkg-config command. Something like: cc `pkg-config --cflags gtk+-3.0` example-0.c -o example-0 `pkg-config --libs gtk+-3.0` 
Well, I can't say that I did it for clicks, unless there is somewhere I can cash them in. Just trying to write about things I find interesting or insightful. If others feel the same, great, I get an upvote. If not, no harm done. But you have a legitimate point. I didn't really consider how often this topic had been written about. Going forward, I'll try to vet my topics for uniqueness. Thanks.
This looks like homework. What have you tried so far?
Is quite simple, a `for` and a `printf`. I give you my deposit number?
Does the output just need to be: 1 4 9 16 25 36 49 64 81 By using nested for loops? Can you provide more information about thought process and what you've tried? I have a solution to display those numbers in that configuration but as other people have addressed similar concern, I don't want to be doing someone's homework...
Hey, thanks for the answer. I think I was expecting to blaze through the book. I guess i will be more patient with it.
Great, thanks! I must have only tested that on Linux. I'll update the post. * https://blogs.oracle.com/DatabaseEmporium/entry/where_is_ld_preload_under * http://blog.timac.org/?p=761 * http://stackoverflow.com/q/34114587/1027966 * https://glandium.org/blog/?p=2764 * https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html * http://docstore.mik.ua/orelly/unix3/mac/ch05_03.htm * http://www.fabiensanglard.net/cellphoneModem/
Do you initialize the array with anything?
What do you mean by "correct"? You haven't initialized the array, so there's no such thing as correct behaviour.
Exactly how I feel. Python developer at the moment but in my spare time I just love working in C
i used jhbuild all the files are there, including gbinding and i used the backticks, but it still says it cant be found
I directly calculate the values of B. The part of the code looks like this: float B[columns][columns]; for(i=0; i&lt;columns;i++){ for(j=0;j&lt;columns;j++){ float sum = 0; for(k=0;k&lt;columns;k++){ sum = sum+A[k][i]*A[k][j]; } B[i][j] = sum; } (The result should be the product of a transposed matrix A^T and the original A.) I tried initializing every value of B as 0, but the result is the same.
I do some calculations with the array later in the code, which I left out here for reasons of keeping my post short. As mentioned in the other comment, B is supposed to be the product of a transposed matrix A^T and the original A. When launching the program in debug mode, or using these "mixed expressions", B gets calculated "correctly". When I use the other methods, all values of B are correct as well, except for B[0][0] or B[2][2].
You're going to have to post the complete code. Nothing you've posted so far indicates an error, which means the error is necessarily in the rest of the code.
The array is being defined at compile time, but since the 6 is not stored in columns till runtime the array is likely initialized to size 0,0. Writing to the B array is likely corrupting the stack or data segment(depending on where in scope B is defined). It can be hit and miss but I would expect this code to crash. If you change "columns" to a define or maybe even a constant it should produce consistent behavior.
OK, I never used jhbuild, but the Homebrew installation approach works on Sierra.
Added it in the description. Whats especially confusing to me is that everything works fine with the array A. Only B has this problem.
I just built it again today and it seems like my top level header was including some lower level headers that weren't required. I stripped that out, and I *think* it's working now. My original question was more wondering (if you look at the diagram I included) if something like Functions3.h was something that I'd need to give out to someone using the library just because Functions3.c was including it. Or if those definitions get added to the object files during compilation and subsequent static library building. In that case, all I need to give someone using the library is the top level header file that has definitions for the top level API calls.
only if A is also being defined with constants. Since calc against A is being stored in B.
This is incorrect. There's nothing wrong with saying `float B[columns][columns];`. Variable-length arrays (which are not allocated at compile-time) have been standard since C99.
That was the problem, thank you! Setting it to k&lt;rows solved it.
In the future, look up the title of a book with 'errata' in your search terms and you'll find *someone* out there has likely found the problem before you did.
X-Post referenced from [/r/forth](http://np.reddit.com/r/forth) by /u/pointfree [C as an intermediate language](http://np.reddit.com/r/Forth/comments/5l4e8a/c_as_an_intermediate_language/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
yes yes, i've already started in the way u mentioned, but to proceed now, is how to put the menu in parts like functions, the main menu must be in function, so when the user is in The submenu, and clicks "4" to retun to main menu, i'm gonna call the "main menu" function, right ? that's how i see it. i'm struggling to how to puzzle those menus...
IIRC, thread support in C11 is a question of the standard library (libc) implementing it, not compiler support. Almost no widely used library (MSVC, glibc) supports C11 threads today, though. [musl](https://www.musl-libc.org/) does, but when your project requires a certain version of a specific standard library implementation, you're not optimizing for portability, exactly, which to me seems like the point of picking C11 threads over pthreads. So your suggestion of a wrapper to use pthreads on Windows is probably the way to go.
I agree. I chuckled when I read about 3 star C programmers on wikiwikiweb.
No one is forcing you to read or agree with anything. These are ideas, shared openly.
They may be mnemonic to you, but I'm not going to go thru each macro you have defined, and memorize them before reading the post. No one's saying don't use macros, just... if you are trying to share code or an idea, write it out in a language for the intended audience.... c programmers, not c4life programmers.
At the very least write out the relevant macros you're using. And if that makes the post look long and confusing... it's still 10x easier to read than going into your library, finding the macros, finding out how they interplay and then remembering long enough to read the code. Or run it thru cpp, which also produces difficult to read code.
Run it through valgrind.
Your description how to reproduce is not very clear. It's actually just trying `cons 1 { 2 3 }` a second time that it crashes. I can confirm that it does not happen in valgrind. Valgrind runs your code in sort of a "virtual machine" and it's possible that in this environment some stuff just doesn't happen that does on real hardware. For gcc you have the address sanitizer as a compiler tool to detect mismanaged memory: Just use the `-fsanitize=address` switch and run normally and you will get detailed information on what went wrong when something went wrong. Works best with debugging symbols enabled. For example I get the output ==16086==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000004e88 at pc 0x7ff1f91ac8dc bp 0x7fff654b9c10 sp 0x7fff654b93b8 WRITE of size 23 at 0x603000004e88 thread T0 #0 0x7ff1f91ac8db in __interceptor_memmove /build/gcc-multilib/src/gcc/libsanitizer/asan/asan_interceptors.cc:429 #1 0x556081502f07 in builtin_cons /home/chris/build/mpc/parsing.c:313 #2 0x556081503824 in builtin /home/chris/build/mpc/parsing.c:400 #3 0x556081503ba2 in lval_eval_sexpr /home/chris/build/mpc/parsing.c:435 #4 0x556081503c2a in lval_eval /home/chris/build/mpc/parsing.c:443 #5 0x55608150469b in main /home/chris/build/mpc/parsing.c:525 #6 0x7ff1f888e290 in __libc_start_main (/usr/lib/libc.so.6+0x20290) #7 0x556081500669 in _start (/home/chris/oldhome/build/mpc/lispy+0x5669) 0x603000004e88 is located 0 bytes to the right of 24-byte region [0x603000004e70,0x603000004e88) allocated by thread T0 here: #0 0x7ff1f920f210 in __interceptor_realloc /build/gcc-multilib/src/gcc/libsanitizer/asan/asan_malloc_linux.cc:75 #1 0x556081502e61 in builtin_cons /home/chris/build/mpc/parsing.c:310 #2 0x556081503824 in builtin /home/chris/build/mpc/parsing.c:400 #3 0x556081503ba2 in lval_eval_sexpr /home/chris/build/mpc/parsing.c:435 #4 0x556081503c2a in lval_eval /home/chris/build/mpc/parsing.c:443 #5 0x55608150469b in main /home/chris/build/mpc/parsing.c:525 #6 0x7ff1f888e290 in __libc_start_main (/usr/lib/libc.so.6+0x20290) which is memmove(&amp;v-&gt;cell[1], &amp;v-&gt;cell[0], sizeof(lval*) * v-&gt;count - 1); I need some sleep, so I haven't looked at the code. Does this mean anything to you? edit: Was curious and tested the first thing that was obvious without trying to understand the code: You should be able to solve this with one pair of parentheses.
Do it right from the start, K&amp;R. It's one of the best books ever written on a programming language. It doesn't spoon feed you, but if you're willing to make an honest effort you will learn more than enough to make up for it.
In over 500 lines of code? That's easy to miss. GCC has a lot of interesting options for stuff like this: https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html
Looks like a good resource. I'll check it out. I'm still relatively new to programming and learning a programming language, vim, linux and the tools that come with the overall development is a dauting task for me still.
But why try so hard to persuade others to not even consider an idea because of your, by definition arbitrary, opinions? Doesn't make sense to me. So, we don't agree on macros; I'm not here to preach. Using them with GNU extensions and some common sense is perfectly fine from my experience. Being scared of macros is also fine, even some of the old grey beard Lispers have confessed their macro fears among friends; I don't agree with them either. I fully realize that my approach is unorthodox, but so is my experience; extensive but unorthodox. On the other hand, one more answering machine repeating the same message wouldn't be worth my effort. From the tone in your message, I get the feeling that you're underestimating the quality level of the work so far. I've spent 30 years doing these kinds of experiments, I'm comfortable with this level of complexity. And by reducing it to a minimal set of mnemonics, I hope I'll be able to share at least some of that experience. Oh, it's too late to stop this train :) More obligation than pleasure on my part, I assure you; but I've agreed to finish this, it's complex. Be well!
I only have experience from gcc and clang. Using them allows me to get where I'm going in C. Don't think I haven't tried to do without them; I spent probably ten years trying out ways of modelling the kind of systems I want to build in straight C; can't do it, I need better compression rates, more leverage.
Not what I'd consider a sentence. If it's always going to be the same format like that, scanf() will work just fine.
scanf only read strings without space, if i enter "Hello everybody" as a sentence, with scanf it will only read "Hello", i want something that will read the spaces too.
In scanf you can use `[a-z]` as a modifier of what characters you want to read.
to avoid all missunderstandings, i want to read an adress and scanf doesnt do the job, what could replace it ?
Use a regex library. https://www.gnu.org/software/gnulib/manual/html_node/Regular-expressions.html Regular expression you need is something like "(\\d+)\\s+([^\\d+])+(\\d+)" This is says capture one or more digit \d, skip over space \s, capture everything that isn't a digit, then capture one or more digit. A regular expression will effectively tokenize the input string for you. Google how to access captured _groups_. Don't forget to _trim_ your tokens as they could be padded with whitespace.
You can, but you shouldn't, for the same reason you shouldn't use [gets](http://man7.org/linux/man-pages/man3/gets.3.html).
Thanks for the comment. When I woke this morning I had the idea of going in a while loop: while(userNumber &gt; 0) { //malloc(); //Prompt the user and set up struct // userNumber --; } I Think that should work. What I had in mind was to get the chuck of memory for all users at once, but I think this should also work although I may run in memory leaks...idk 
You may want to escape your \^.
 for (int a = 0; a &lt; 33; a++) Using that loop, `a` will go from `0` to `32` (`32 &lt; 33` is true, `33 &lt; 33` not anymore). However, your array `rightjpg` only has 32 values (valid indexes are `0` to `31` - last index is always `size - 1`). Also, please don't read characters into an `int` array. Assuming `sizeof(int)` is `4`, you read 4 characters into one integer, except it is something you wanted to to. (File is just made out of integers) But even then, to avoid confusion, use something like `512 * sizeof(int)` to read 512 integers (`512 * 4 = 2048` bytes)
Thanks, the error is gone now. For the sizeof, I want to fread 512 bytes (not integers). 
Encapsulate index translation as a function or macro? There's really no reason to let syntax concerns stop you from doing the right thing here. Allocating a single, flat slab of memory will be faster since you can replace the loop with a single call to memcpy(), remove the malloc() and free() loops; and limit pointer chasing to one block of memory which plays nicer with caches. Apart from that it's difficult to say from the information given about the actual processing.
The C Programming Language 2nd Edition? This book, correct?
Can you paste more code? It's possible you're doing something wrong elsewhere which is causing this function to crash. 
What happens when index is 0 and the function is called again?
I indeed get the last 500 lines of output. I've updated the code at [GitHub](https://github.com/SandervanL/CodeEval-Segmentation-Fault/blob/master/UglyNumbers.c) and implemented a depth counter (if the function `makeNumbers` is called, the depth counter increments. The result is, that the program causes a segmentation fault at a depth of around 174400. Should I use another algorithm, without recursive functions?
Yeah, that looks like a Stack Overflow. Try implementing things without recursion.
The function won't be called when the index is 0, because for the function to be called again, it has to meet the following condition: return index &amp;&amp; changeOperatorList(numberList, index - 1); So if `index`equals zero, the function `changeOperatorList will not be called anymore.
It's my pleasure.
Segfault in a recursive function that works on a bounded array: first thing to look for is "is the basis step correct and is the recursion stopping when it's supposed to" or, more to the point, why is is recursing right off the end of my array? You're using "index" to handle recursion depth, but looking at your code don't see a value of "index" that would end the recursion; instead I see index being used to index the array and a value from the array being used. So there is no way to tell if this recursive function is correct because it's based on the contents of the array, which is outside the scope of the code you have posted. Any chance "numberList" is initialized to different values on the two platforms you're running this on? If so, you've found the source of the difference in behavior. Good general practice: if you read a recursive function and can not tell exactly how the basis step will be reached, then you've written it poorly.
Use `fgets(s1.model, 19, stdin)`. This will read at most 19 symbols from the stdin. It has the desired property of gets (reads a string with spaces) while protecting against buffer overrun (if you remember to specify a proper amount of symbols to read).
I assume this is for your assignment (referencing a post from you, earlier this week). If you compile and run this example, you can see how `scanf` works, sort of: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char* argv[]) { int num; char input[100]; int code; printf("Input stuff: "); scanf("%d %s %d", &amp;num, input, &amp;code); printf("Num: %d, input: %s, code: %d\n", num, input, code); } If you run it, you could input `91 California 1160`, and `scanf()` will have read the values 'into' the variables `num`, `input` and `code`. You could use the same technique for whatever you require.
The first one is correct. The array contains pointers to structs and `qsort` sends pointers to the array elements to the comparison function (for obvious reasons, as sending the actual elements could result in potentially huge structs pushed on the stack). So what `compare` receives are pointers to pointers to structs. My guess is that some of the pointers in the array are uninitialized. Are you sure all of those point to valid structs? Try iterating through them, if it crashes you know what's problem.
You might be right. I just counted by printing how many elements there are, and changed the table size to that, seemed to work. Now I think I just need to find a way to change the array size depending on the input size. Thanks so much!
As a general request, please do not delete vital parts of your question after receiving an aswer. My answers are useful for future readers and removing the question (or relevant parts, such as the code) makes the answer much less useful. Please don't do this again.
Oh okay, I put it back
Thank you.
Sorry, I was wrong the first one is correct. But yeah if you don't set some of them, chances are they're uninitialized, meaning the values are arbitrary, and some will be random huge numbers.
Needs more functions. Stuffing everything in a main() is hard to read and maintain.
Is filename a null pointer?
Can you provide us with your full program please? Right now I can't see any mistake, the error is likely elsewhere.
Very well done! There are some stylistic things you could do better but overall the program is well written. One last stylistic thing you could do is using a `for` loops instead of the `while` loop. This is a bit more readable: for (i = 1; i &lt;= max_guesses; i++) { ... } Another thing is that you should check the return value of `scanf` to see if the user actually typed a number. Read the manual of your C implementation for details.
You were right, the mistake was an attempt to copy the contents of 'source' into a variable named 'target' and adding ".cr" to the end, all while having a too small 'target' array.
That's very particular.
This is not C, your post has been removed.
Ok, that's fair.
I would also suggest using strncat instead of strcat, as well as keeping track of your buffer sizes.
There's a good chance they would have different integer values, which is true in this case: for `TokenType_T`, `INT` is 0, but for `SymbolType_T`, `INT` is 1 (I believe this is actually undefined, you can't techinically count on those exact values but in practice it's what you'll usually find). When you use it the compiler would have to infer which type you're using to know which value to substitute in, and there are almost certainly times when that becomes ambiguous, not to mention C compilers already have almost a complete lack of type inference, and they would never have been able to add this back when C was first created.
Each identifier can only be defined once in each scope. If you define two enumerations that share some members, this is violated.
That's kinda what I thought. Just making sure. Thanks for the response.
If the compiler sees the token `INT`, how would it know which `enum` that identifier belongs to?
Thanks! &gt; Remember, there is a subtle difference between `int main()` and `int main(void)`. What difference is there, besides visual? Does using one over the other affect your program in any way? I don't really want to use `int main(int argc, char *argv[])`, because those variables are never used in the code. (`gcc` also throws a `warning: unused parameter`)
Good point.
Thanks.
I don't mind how other people do it, but yes I prefer a newline for the brace. I find it much easier to match brackets, and spend far less time debugging when a scope is wrong.
What is the point of using a `static const` over just `const` here? There is no way that they will change between running, unless you change it in source and recompile. Also, `main()` is only called once, so using `static const` wouldn't really be much different than `const`, would it? Like I said, I'm new to this, so I'm not sure I completely understand `static`. Thanks.
I think I did all the exercises, but the comments are in Spanish (the variables are in english). If it is not inconveniente I can upload the exercices
it's a rough book to start, deitel &amp; deitel is more didactic
No sweat. I have a pet peeve when apps display bad grammar or spelling purely out of laziness, when the solution can be quite easy, low risk, and easily tested. The logic in the ternary works for any amount, including zero. Cheers.
&gt; 2) Use the established convention of the existing project This should be 1). Don't mess up existing code!
Discussions on naming and formatting will never lead anywhere but in circles. There are no good answers, as it's all a matter of perspective. That being said; opening braces go on the opening statement line, always :)
It's certainly very short and dry, I have just had to accept that I might need to mull over a tiny snippet of text for the better part of a day now and again. I find it a lot more accessible than some of the other famous CS intro texts like the SICP, so maybe it is a good way to learn how to read these incredibly terse, dry books. I used C Programming: A Modern Approach, by King, when I was first starting, but it was wordy and the exercises were really tedious - at least the parts of it that overlap with the early K&amp;R chapters are clearly designed for the totally new programmer. 
Hahah! This only proves my case! :P KNF cuddles braces so I'd say it is similar enough to TOTBS that you might not be an asshole. :)
For some reason I feel the need to complain about you using pre-increment in your for loop though. :P 
Formatted: int main(int argc, char* argv[]) { int n; // ensure proper usage if (argc != 4) { printf("Usage: ./resize n infile outfile\n"); return 1; } else { n = atoi(argv[1]); if ( ( n &lt; 0 ) || ( n &gt; 100 ) ) { printf(" n must be a positive floating integer from 0.0 up till 100.0\n"); return 1; } } // remember filenames char* infile = argv[2]; char* outfile = argv[3]; // open input file FILE* input = fopen(infile, "r"); if (input == NULL) { printf("Could not open %s.\n", infile); return 2; } // open output file FILE* output = fopen(outfile, "w"); if (output == NULL) { fclose(input); fprintf(stderr, "Could not create %s.\n", outfile); return 3; } // read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf; fread(&amp;bf, sizeof(BITMAPFILEHEADER), 1, input); // read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi; fread(&amp;bi, sizeof(BITMAPINFOHEADER), 1, input); // ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 || bi.biBitCount != 24 || bi.biCompression != 0) { fclose(output); fclose(input); fprintf(stderr, "Unsupported file format.\n"); return 4; } int originalwidth = bi.biWidth; int originalheight = bi.biHeight; int originalpadding = (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4; bi.biWidth = bi.biWidth * n; bi.biHeight = bi.biHeight * n; int newpadding = (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4; bi.biSizeImage = bi.biHeight * ( 3 * bi.biWidth + newpadding ); bf.bfSize = bf.bfOffBits + bi.biSizeImage; // write outfile's BITMAPFILEHEADER fwrite(&amp;bf, sizeof(BITMAPFILEHEADER), 1, output); // write outfile's BITMAPINFOHEADER fwrite(&amp;bi, sizeof(BITMAPINFOHEADER), 1, output); // iterate over infile's scanlines for (int i = 0; i &lt; abs(originalheight); i++) { int numberoflines = 0; // iterate over pixels in scanline for (int j = 0; j &lt; abs(originalwidth); j++) { // temporary storage RGBTRIPLE triple; // read RGB triple from infile fread(&amp;triple, sizeof(RGBTRIPLE), 1, input); // write RGB triple to outfile n times for horizontal resize for (int a = 0; a &lt; n; a++) { fwrite(&amp;triple, sizeof(RGBTRIPLE), 1, output); fclose(output); //temporary = malloc(sizeof(RGBTRIPLE)); //temporary = fopen("tempmem.txt", "w"); //fwrite(&amp;triple, sizeof(RGBTRIPLE), 1, temporary); } //for (int b = 0; b &lt; n-1; b++) //{ //fwrite(temporary, sizeof(RGBTRIPLE),1, output); //} } // skip over padding, if any fseek( input, newpadding, SEEK_CUR); // then add it back (to demonstrate how) for (int k = 0; k &lt; newpadding; k++) { fputc(0x00, output); } if ( numberoflines &lt; n - 1) { fseek( input, -1 * ( 3 * originalwidth + originalpadding ), SEEK_CUR); } numberoflines++; } // close infile //fclose( temporary); fclose(input); // close outfile fclose(output); // that's all folks return 0; }
Doesn't matter much either way. Your way saves vertical space which is valuable. The other way can sometimes make it more visually obvious where the block begins and ends, which is valuable. 
OP decided to [cross post](https://www.reddit.com/r/c_language/comments/5lpfer/unsupported_file_format/) this question. Please cross-check with the post there to avoid writing duplicate answers. OP, please tell us if you cross post in the future.
I prefer KNF, I mostly agree with the rationale behind the decisions for it. Additionally, I am pretty lucky as my workplace agree with me. In the end, use whichever style the project you contributed to has agreed upon. If there is none, produce an RFC for your peers ASAP so that there is one. The arguments of your reviewer is moot here: just follow common practice. If it so happens that it is to put the opening brace on a new line, then so be it.
In this case it doesn't matter -- ++i is the only statement and we don't care about the resulting value of i BUT... It just seems like i++ is the idiomatic way to simply increment an integer when you don't care about the side-effects/order of operations.
Gotcha. Thanks.
I know k&amp;r is always recommended but get the latest of edition of C Primer Plus by Stephen Prata.... k and r is way outdated and you'll learn insecure usage. I get it, its a great book but I've tried both and primer plus is way better in every way (imo).
I did,umm maybe 30 years ago, in my 2 week work experience placement.
I've been going through it and put my progress into a Git repository. Unfortunately it's not back up yet because I'm waiting for my Raspberry Pi to get here so I can build a home server. It should be here tomorrow, so maybe by the end of the week it'll be ready. I decided to go for what's called *Category-0* (zero), limiting myself to things that have been covered in the book up to a given exercise. I'm almost done with Chapter 7, so if you need someone to bounce ideas off of or just want to chat with another C fledgling, I'm down.
macOS should be totally fine, and you can always spin up VM inside VirtualBox and install Ubuntu (or whatever Linux distro you want) in it.
Here's what mine looks like: ch1/ ├── 1-01_hello-world.c ├── 1-02_escape-sequences.c ├── 1-03_temp-table-header.c ├── 1-04_celsius_converter.c ├── 1-05_backwards-table.c ├── 1-06_eof-test.c ├── 1-07_eof-value.c ├── 1-08_space-counter.c ├── 1-09_single-spacing.c ├── 1-10_literal-escapes.c ├── 1-11_word-count.c ├── 1-12_one-word-per-line.c ├── 1-13_word-length-histogram.c ├── 1-14_character-freq-histogram.c ├── 1-15_temp-convert-func.c ├── 1-16_longest-line.c ├── 1-17_over-80.c ├── 1-18_strip-blanks.c ├── 1-19_reverse-lines.c ├── 1-20_detab.c ├── 1-21_entab.c ├── 1-22_wordwrap.c ├── 1-23_decomment.c └── 1-24_syntax-checker.c Ditto for ch2, ch3, etc. Then at the top level I have my README and eventually a Makefile. Inside each .c file is the exercise text straight from the book, so the entire repo is pretty much self-contained.
I mean, don't cheat; don't gloss over parts you don't understand. Make sure you understand how the programs work and why, change them and see if the results match your expectations. Remember why you're doing this, because you want to learn; there is no final goal in learning, hence no short cuts either.
As I am not English (nor German) and don't pronounce automatically the proper English way either the names or the adjective, I have absolutely no problem with it :-)
to host the solution of several users in a single git / repo "k&amp;r 2ed" +-- progA/CC-nn_exercice_name.c +-- progB/CC-nn_exercice_name.c +-- progC/CC-nn_exercice_name.c +-- .... CC = chapter nn = exercice exercice_name = more clarity
I feel like I'm the only person who uses `i += 1;`.
There is no right answer and typically all that matters is that you are consistent with whatever style you choose.
I remember that I used CodeBlocks when I first started writing infinite for loops and while loops or if statements that were never executed.. Then I realized that the real programming is done in linux. I was lucky to get a MacBook pro, which I love, and started using Xcode. Then I realized that I was not learning the syntax and making sense of what I was typing. It's been a while now since I begun to code on the terminal only. I use emacs to code in the terminal. Take a look at vi, vim, pico, nano, or emacs on the terminal and try to write a very simple code there. For example: Open the terminal and type: emacs test.c Then when you're done with it, ctrl+s and ctrl+x will save and close the program. Finally, type: gcc test.c If no errors where found, type: ./a.out to execute your program.. If there were error, start with step 1 again and make the required changes. You will see that by typing EVERYTHING manually, You will have less errors when you become frequent to it. I am now learning about dynamic memory allocation and data structure in C. I think it is a power language but we all started with the same questions that you have right now. Good luck. PS: you SHOULD learn bash programming or at least command line commands 
I prefer brackets on a new line. I've been coding in C for about 35 years. The old arguments about preserving vertical space are no longer [as] valid. I started out with the opening bracket on the same line. After I switched back and forth enough between Pascal and C, I decided to try to unify the style (BEGIN/END vs. {}). I much prefer the clarity of Allman/BSD. (opening bracket on new line). If I'm making a change to an existing library that I did not author, I stick with the style used in the library.
I cut my teeth on BASIC and FORTRAN 20+ years ago. If I'm programming in C it will be like this: for (i = 0; i &lt;= SOME_NUMBER; ++i) { // do something here }
`const` would be preferable to `static const`, IMO. Some people have their ingrained habits...
Putting the guess loop in a function means you could exit more naturally, e.g. `return true;` or `return false;` to indicate success or failure, instead of having a bunch of `break` statements and repeated tests. 
Except that many of the CLI programs/utilities are from FreeBSD and don't support the same options or option positions as their GNU counterparts. For the most minimal usage, you're right, but a programmer will probably bump into those difficulties if they just assume it's going to be the same.
It's totally personal preference. I settled on this style many years ago because I like the whole block to be indented the same way, including the ending brace. Just looks better to me. while(i-- &gt; 0) { // whatever } Especially in an `if` statement: if(a == b) { // bla, bla } else { // yakkety yak } I also use hard tabs for indentation exclusively -- no runs of spaces. I'm probably the only person in the world who does this. :-]
I've observed that people who see assholes everywhere are usually assholes of some kind.
 #define F_CPU 1000000000UL uint32_t t; uint32_t nCycles_us = t * F_CPU/1000000UL; Will overflow on 32 bit CPUs with t &gt; 4 (i e int(2^32 / 1000000000)). This should work better: &gt; uint32_t nCycles_us = F_CPU/1000000UL * t; 
Learn the osx terminal, most Unix commands you come across should run perfectly fine on your Mac. If you wanna step it up partition your hard drive and install arch Linux, then skip installing a gui. 
F_CPU is an unsigned long, while t is uint32_t
Oooh! That makes sense!! Thank you!
Welcome to floating point math. You're assigning a floating point value to an integer type, where it will get truncated to the whole number part of the floating point value. 
No, ignore that asshat. Follow the style of the code you're working in. If it's all your code, do whatever you like. If it helps you at all, a lot of the most widely used C code bases are in the brace style you used. Including the Linux kernel. 
This book contains all the necessary information. The problem for modern programmers are some concepts who faded away when Java arrived. You have to be aware that the book was written when most programmers were used to direct mess with addresses. C according to K&amp;R is to access values by a pointer or direct and nothing more. You get an additional standard library which is very basic. I'm considering this book as very well written and it has all the necessary information. 
What is the value of F_CPU? It would help if you posted a complete program showing the two different outputs so we don't have to guess about details. 
The "==" operator on char arrays compares the pointers which won't match with the string constants "bob" and "alice". Instead you need to compare the content using strcmp or similar.
yeah I guess I would need to extend me array size. Additionally, I wouldn't have to declare Bob and Alice arrays because they are constants, right? Thanks for your help 
You may also want to look at fscanf.
My plan (if I get around to it) is after K&amp;R is to go through [The Unix Programming Environment](https://en.wikipedia.org/wiki/The_Unix_Programming_Environment) with unix [version 7](http://emma.nfshost.com/v7x86/vm.html). 
Why the x86 port and not the original?
What is the correct way to round the number properly? Also, does it mean that I can't trust gdb in these situations?
No need to sweat this issue, if you are maintaining some old code with a style different from your favorite one, just run the code through the "indent" program to reformat it into your favorite style. Check out the [Wikipedia indent](https://en.wikipedia.org/wiki/Indent_style) entry for a long and detailed treatment of this vital, burning issue. (I'm a big fan of the "Horstmann" style myself...) 
Turn on the pedantic compiler flags and all errors (on gcc and cc, -pedantic -Werror -Wall). You also declare two char* that you never use (Alice and bob), which should cause a warning about unused variables :P Compiler warnings would catch the string pointer comp too I think (I didn't check)
If you want to know the whole story, read the C standard (ISO/IEC 9899:2011). It's a good 700 pages and costs about CHF 200. If you don't want to pay that much money, look for a document called *N1570* which contains the last draft. The other standard relevant for C programmers is [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/) which is available online. That said, you really should read a basic tutorial before diving into the standard.
Emacs using \^S for searching is the dumbest thing ever as it breaks XON/XOFF flow control.
What should be gdb command be in this case? I copied exactly what I had in the code though
I suspect that gdb handles numeric conversions differently as what it uses isn't exactly C.
You find this *easier*? What could be easier than running simh?
Arch is ridiculous to set up even in a virtual machine for beginners. If OP wants to learn Linux, Arch isn't the way to do so also because of its unique structure. Ubuntu or Mint would be more standard, maybe CentOS if you want to get familiar with the enterprise industry standard
Hey, thank you for the fast reply! Sorry for my lack of knowledge in C and programming in general, I am trying to pick up programming and starting from the bottom :) &gt; x++ is 8 &gt; nope Why not? If we increment 7 it becomes 8, right? &gt; 6) Can you describe it and explain it? &gt; Hint: it's a function Yea I understand it now, it's a function that has 2 parametres (double and int) and returns value of type float, right? &gt; 8) Explain code marked as A. Explain code marked as B. &gt; really? Sorry, that was what is in the excercise I understand A, don't understand what is inside the if in B tho and don't understand C either. Sorry if these are dumb questions I've just started learning, but if you are bothered by my dumbness then I apologize. /e: &gt; 3) The answer is supposed to be 0. I thought it is supposed to be undefined since we overwrite c4 with c3, why is it 0? &gt; https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html So if we initialize some of the items, the others are 0, therefore when we overwrite c4 with c3, the age of c3 was 0, right? Thanks! &gt; 4) Look up what each operator does and their precedence. I think I got it: a &amp; b = 1 &amp; 2 = 01 &amp; 10 = 00 (false) a &amp;&amp; b = 1 &amp;&amp; 2 = (true) &amp;&amp; (true) = true therefore 0 || 1 = (false) || (true) = true = 1 
&gt; Why not? If we increment 7 it becomes 8, right? Not immediately. There is `x++` and then there's `++x`. The former is call *postfix increment*. Look it up. &gt; Yea I understand it now, it's a function that has 2 parametres (double and int) and returns value of type float, right? To be precise, it is a type of a function taking two parameters, … &gt; what is inside the if in B tho and don't understand C either. You should split the code into smaller parts to understand it. For example `a ^ b` is an xor operation. `a ^= b` immediately assigns the result of that xor to a. If you can't figure out what B does [click this link](https://graphics.stanford.edu/~seander/bithacks.html#SwappingValuesSubAdd). I actually think that is some really tricky thing to give to newbies. For C look up the % and ?: operators. 
&gt; Yea I know this one, but it still should be &gt; &gt; z = 8 - 5 &gt; &gt; right? Or is it &gt; &gt; z = 7 - 5 = 2 &gt; &gt; and then it increments? Try it and see! &gt; Oh so B is basically a switch to ensure a &gt; b before the function is run. The usual term is *swap*. &gt; right? yep. 
I worked with a guy who put his opening braces on the opening statement line................ AND HIS CLOSE BRACES TABBED TO MATCH THE OPENING BRACE. infuriated me
Thanks for your shitty reply. I asked a question on how to do it **in C**. I didn't say I'm writing it in C because it's in a C subreddit. I want to do it efficiently and without using some ugly textual matching representations of stuff which is bad and I'm pretty sure it doesn't support nesting, and I don't learn shit from it.
In remove_by_value function: previous = *head; current = previous-&gt;next; EDIT: Instead of: previous = current = (*head)-&gt;next;
The question mark operator is, basically, a shorthand "if" statement that _returns a value_. In some languages "if" returns a value and you could write this as sigma = if... but C does not support this directly, so the question mark operator gives you a shorthand for that. The line you quoted could be rewritten without the question mark operator as something like: if ( ( theta - s ) &gt; 0 ) { sigma = 1; } else { sigma = -1; } Some style guides hate it. I use it in my own code, and think it is very useful in some cases, but only if you keep the expressions simple and avoid nesting them into complex monstrosities. If you are ever tempted to nest question-mark operator expressions or results, just stop and write it out using if/else logic instead. The basic form is expression ? true result : false result If you have anything at all complex in the "expression," "true result" and "false result" slots, use parentheses to make it very clear what order you expect things to be evaluated.
Thanks for the reply. I was confused as I thought it was checking if sigma was 0, 1 and -1 on the same line, but I understand now it's assigning values. Again thanks for the help.
There's an idiom using nested ternary operators: int foo = condition1 ? value1 : condition2 ? value2 : condition3 ? value3 : default_value; It does depend on the reader knowing the idiom rather than having to manually parse the nested operators to figure out what's going on, but given that, I find it more readable than: int foo; if (condition1) { foo = value1; } else if (condition2) { foo = value2; } else if (condition3) { foo = value3; } else { foo = default_value; } - With the chained `?:` it's clear from the beginning that you're doing an assignment, and only to a particular variable. Chained if-else-if takes more visual parsing to figure out what it's doing. - Chained `?:` makes it easy to scan the conditions and values, and see the relations.
I'm having a hard time understanding what you mean. GDB itself is written in C. GDB isn't doing any conversions itself, here, I don't think. It's just emitting the value according to the type, which it knows from the symbols that get fed to it. Am I missing something? 
Also, to add to what /u/FUZxxl suggested, in many cases it's sufficient to add 0.5 to whatever floating point value you want as the nearest integer. It depends on what rounding mode you want, of course, but that is what you'd want, most of the time. Lastly, you might want to study floating point representation in computers a bit, but you should also be aware that the FPU can be set in various modes which affect both precision and rounding. 
Hmmm... well, I agree that it is not too bad, nested like that, as long as you maintain the indentation. If I were in charge of the universe I might let that pass in a code review. I've seen some pretty horrible examples that don't use clear indentation though... people write code like whitespace costs CPU cycles, or else they are writing on those tiny magnified monitors from the movie _Brazil_... 
Look at OP's screenshot. He types an expression into gdb to print. gdb accepts “C-like expressions,” but there is nothing that says that the semantic is exactly like C's.
Because it's completely impossible to use regular expressions in C (And they're likely a poor choice for this task unless you're just using them to get the next token).
Guess you can write Python in any language too :)
Fuck that. Develop your own style btw, don't just listen to opinionated jerkoffs like that guy, or anyone that's commented here. Do what you find the most readable and pretty.
You should be able to do everything from the terminal. You can use nano, it's probably the most basic; or vim, a popular editor that can help you save a ton of time if you get good at it, but has a relatively steep learning curve for a text editor; or even emacs, I don't have much experience with that so I can't help you there. Of course, all you're doing is writing a text file and saving it with a particular extension, so you can use any editor your heart desires. Atom is a good cross platform GUI editor. Once you have your file then type gcc inputfile.c -o outputfile. Then run your program with ./outputfile. That's all you need really, and it's all baked into macOS. Well, not Atom, but the rest of it is. 
&gt;efficiently in C Best of luck. Just because C compiles to machine code very well doesn't mean that what you tell it to do will be efficient. Markdown isn't a regular language. I think it would require a state machine to crawl, plus a decorated AST to handle backreferences. If I were to try this, I'd do it in a dynamic language first to understand the end goals, and then incrementally translate to C. It's easy to lose the forest for the trees in C. I definitely wouldn't jump right into C as my first take, especially since I haven't written an irregular parser before.
Well just bought that book based on your recommendation. Best be good!
You won't be disappointed :)
Type aliasing doesn't change the fact that the underlying syntax is unintuitive.
It's the ternary operator. It's the equilivent of this if statement: if (theta - s &gt; 0) { sigma = 1; } else { sigma = -1; }
Count the number of consecutive \*'s before deciding on the new markup state.
My suggestion would be to write a tokenizer which just separates markup from regular text. Then you can traverse your newly created structure and using a stack to remember the current style(s), output it in whatever form you want. The problem with a state machine is you wouldn't be able to handle multiple styles at once. Whereas with a stack you can simply apply every style that is currently on the stack.
Compilation error: missing brace
I actually just talked to someone thinking whitespace would bloat his executable...
Considering that there is no grammer for Markdown it is not that trivial to implement all the ambiguities. 
It's actually fairly easy to parse context free languages in C and Markdown is a context free language. You should use a parser generator like yacc though.
If this is your first programming language, then absolutely start with the basics, I cannot recommend the tutorialspoint website enough. I also might recommend starting with c++ instead, unless you have a specific need to use C. If this is not your first programming language, then it really depends on what you hope to get out of learning C.
Reminds me of this lol https://www.youtube.com/watch?v=SsoOG6ZeyUI
I created an anonymous union composed of two types: an int and an anonymous struct. In C you can specify how many bits a struct's variable is gonna use using that syntax you see inside the struct. So I delcared, inside the struct, a variable 'pad' that uses 3 bits, and then the variable 'bit' (which is then gonna be the fourth one). after the declaration I initialised the variable to 0 and set the fourth bit to 1.
oh wow mind blowing... where i can study this type tricky hack stuff?,please suggest me.
&gt; Very cool, so will it ever give you memory that is currently used by another process? No, that would be a massive security problem.
If it calms you down: coding is a hobby for him. He actually did intend and put only one statement per line. But... that's why he tried keeping his loc count low. 
Looks like your question has already been answered, but I thought I'd chime in with a bug I found today that relates to the ternary operator, and looks very similar to your line of code. The buggy code was roughly: if (pinNumber &gt; (thisDevice-&gt;flags &amp; FLAG_8_PINS) ? 8 : 4) status = FAILURE; if (status == SUCCESS) // do some more stuff Do you see the problem? ... The comparison operator (`&gt;`) has *higher* precedence than the ternary conditional operator (`?:`). For the statement to work as intended, it needs extra parentheses: if (pinNumber &gt; ((thisDevice-&gt;flags &amp; FLAG_8_PINS) ? 8 : 4)) Without them, it first checks whether `pinNumber &gt; (thisDevice-&gt;flags &amp; FLAG_8_PINS)`, and depending on that returns either 8 or 4. Both of those values are true, so the first if statement *always* runs. Because it always runs, the second if statement can *never* run, and the compiler actually eliminated the body of it.
While the standard is the only real way to cover "all of C", I don't think it's a good way to start.
The question has already been answered but OP should also note that the same principle applies to more than just arrays. int x; printf("%d", x); is also undefined behavior.
As someone who works in assembly where this does happen, it's also a nightmare to debug
Assuming you're using a modern OS, it will use memory that may or may not have been already used in the current virtual address space, meaning the current process (and any threads in the same address space). That memory could have been already previously used, for example if you are creating a local array on the stack then it could have values from other previous variables on the stack, old return addresses, etc.
Have you tried?
Only as the result of extremely dangerous security bugs.
POSIX is an operating system interface specification. The only relationship it has to C is that C is the default language for it. It's like how the Catholic Church writes all its canon law in Latin, so you interface with the Church in Latin, but Latin is more than the Church. The C specification says what the language syntax and grammar look like, what behaviors are and aren't defined. It also mandates what the components of the standard library are. A conforming C *installation* must include the compiler, preprocessor, and standard library according to the ISO spec. Each implementation can do whatever it wants, as long as it presents the specified API. POSIX threads, Windows threads, the cooperative threading model the OS I'm using employs, doesn't matter how it works under the hood as long as the specified APIs are in place. If you compile with MinGW on Windows, (I think) you'll be linked against the GNU libc, which includes POSIX threads. I honestly don't know how it links against the Windows headers and APIs, but since your code won't be using either directly, it shouldn't matter.
This is difficult mostly because of Windows. Every other relevant platform has a variant of the gcc compiler and gnu libc, but the canonical compiler and library on Windows is the one shipped with Visual Studio (Visual C++), which doesn't strictly implement any C standard. There's mingw, but it's not widely installed, and most people just want to use Visual Studio (it's a great IDE). I used to limit myself to C89, and as a rule of thumb, code that compiled in gcc with those limitations would also work on Windows, and vice versa, with a few exceptions like, which header defines NULL, and some other edge cases, and there are a few gotchas like the string.h functions having different names or different behaviour (like not nul-terminating a buffer when it is too small to hold the result). Stay away from gnu or posix extensions like unistd.h, obviously. Eventually, MSVC support for C99 got so good that it made no sense to keep restricting myself to C89, and the lure of a bool datatype, stdint.h and wide-character support pulled me in. There is still different behaviour, but somewhere around C99 is where I think the sweet spot is for not having to write too much platform-compatibility code, and having portable code. C11 has some very nice features that I look forward to, but even the gnu toolchain doesn't support them yet, so it's going to be years before I think we can use them in portable code. 
I can only reiterate what I said before: C11 threads are castrated pthreads. Pthreads is the industry standard interface. You should use pthreads for portable multi threading. &gt; Also as a secondary question, what's the difference between POSIX and a C standard? I understand that POSIX is supposed to made available by the OS, and the C standard defines how compilers should understand the language, but how do say C11 threads fit with the C standard if they're implementation specific? POSIX is a standard for operating systems that standardizes a number of command line utilities and expands C with a number of system interfaces.
[removed]
I can get it to work if I redirect the output to a file and open it up in a text editor (specifically gedit), but not if I just print it directly to the terminal. It probably has something to do with my terminal emulator, but I don't know enough about Unicode or RTLO to know what that is.
splint hasn't had a release in almost a decade. It's pretty much a dead project. When I looked at it many years ago, it had so many false positives without extensive source code annotations that it was a royal pain. These days I'd use clang's static analyzer to look for potential issues.
`setlocale` shouldn't make a difference unless you use `wprintf` (I'd really like to see your code, I believe there is something wrong with it). Try printing the UTF-8 encoded byte sequence with `printf`.
You need to set an appropriate locale before `wprintf` does what you expect. The default locale is ASCII only. To do that, call `setlocale(LC_ALL, "")` before the `wprintf`.
&gt; Whereas with Python, on the same terminal: &gt; &gt; &gt;&gt;&gt; print('now this is a story all about how \u202E my life got flipped') &gt; &gt;&gt;&gt; now this is a story all about how ‮ my life got flipp Where did "ed" from "flipped" go?
Here's the most recent attempt, which doesn't work: #include &lt;locale.h&gt; #include &lt;wchar.h&gt; int main() { setlocale( LC_ALL, "EN_US.utf8"); char *string = "foobar"; wprintf(L"\u202e%s\n", string); } The output is: ./a.out |hexdump -c 00000000 e2 80 ae 66 6f 6f 62 61 72 0a |...foobar.| The terminal shows a black character with a question mark, followed by foobar. Trying to copy and paste the output here results in "raboof", which does indicate that it might just be a terminal problem. 
Indeed. That seems to be the case. Bummer! Alternatively, you could try and output two backspaces (`^H`) after every character to write the text right-to-left.
Hah, now that's creative!
Well that's just great.
Yes, thats what u/YellowFlowerRanger also said. Thanks still!
Interesting. I don't think VS 2017 is out yet, though? And does this clang build come with its own C run-time library, too, or is that still the same? 
&gt; I don't think VS 2017 is out yet, though? VS 2017 has Release Candidate status for now, I have the Community edition installed. &gt; And does this clang build come with its own C run-time library, too, or is that still the same? Not 100% sure, but I think Clang has his own C run-time library. I've just tried a small C99 program that *doesn't work* with MS compiler (VLAs are not implemented in the C compiler from VS) and the code works just fine. 
Username checks out :P
&gt; clang's static analyzer it reports to me: scan-build: No bugs found. So I must assume that I can go on with other analysis. 
That was it, thank you! I had thought that I had thought of that. To wit, the documentation I just looked up starts out: &gt; A C program inherits its locale environment variables when it starts up. This happens automatically. And I'm like, 'yeah, *I know*, and I'd already made sure that the environment's locale is OK' ... but then, of course, it continues: &gt; However, these variables do not automatically control the locale used by the library functions, because ISO C says that all programs start by default in the standard ‘C’ locale. And I'm like, \*facepalm\*, I'd been so close to just trying it before deciding it wouldn't help. TIL!
Good question! Fortunately, I was able to reproduce that bug quickly; the answer is interesting IMHO: Upon running that line again, it produced the correct output. The 'ed' was only gone after selecting the output and copy-pasting it over here. It's second nature to quickly check the start and end of the string to make sure the selection was just right, but I'd totally missed the problem because I'm not used to the end of the string being in the *middle* of the line. Turns out I had dragged the selection precicely to the visual end of the line, thus missing the invisible character at the end. Just now I made sure to actually select the *entire* line, et voilà ... now this is a story all about how ‮ my life got flipped ... that works around the bug.
It's very useful for the locale to be C by default as locales can have surprising behaviours. For example, in many non-English locales, `,` is the decimal separator. This breaks many programs that use `printf` or `scanf`for floating point numbers (like certain versions of the SUN compiler).
I'd say just go with C++. What's your end goal other than junior developer? What industry do you want to end up in? I'm curious why you wouldn't want to just keep going down the path you're on now, with more web based languages.
So the stuff you select is still in its original unicode form, and what you get in the copy-paste buffer is not what you visually selected. Right? Unicode... :-/ (What terminal is it that you use?)
That's what i thought. I like the idea of a standalone lint, independent of a particular compiler, i just don't know of a good, free one. 
Maybe its something like (char[]){"hey", "ho"} Official documents are so difficult to read. I'll look more into it after some sleep, although answer are still very much appreciated :)
The website claims it understands C99. I never tested it and I'm not going to. C11 postdates its last release by a few years.
That's because there isn't one, sadly :( I've wanted the same for years.
All the job listing I've seen are for c/c++. Because c++ is a superset of c, learning c is essentially just learning the base for c++. I don't know about "junior" but there are tons of jobs for c/c++ debs. Gaming and Microsoft accounting for a lot of them as far as I know. 
Care to share?
Heartbleed is a pretty famous and recent security bug due to buffer overrun. The National Vulnerability Database and CVE Mitre Database keep lists of known public bugs. The Wikipedia page on Buffer overflow has some good jumping off points
If you want to both read and write from a file, you need to open it with the appropriate mode, `w+` in this case. And after doing so, you must always follow a write to the stream with either a call to `fflush()` or a call to a positioning function such as `fseek()`, otherwise you invoke undefined behavior. In this case to read the character just written you would need to seek to the beginning of the file (or use `rewind()` as a shortcut) or seek backwards by one, as the current file position indicator was updated by the write and points after the character written. Also, that's not a valid way to check for a null pointer. The null pointer and the null character are two completely different things. 
Yes, I was talking about compound literals. My mistake, sorry.
I just checked the man pages, and I can't see a "b" option at all.
It is in mine, but not in the main list of options. `man 3 fopen`: &gt; The mode string can also include the letter 'b' either as a last character or as a character between the characters in any of the two-character strings described above. This is strictly for compatibility with C89 and has no effect; the 'b' is ignored on all POSIX conforming systems, including Linux. (Other systems may treat text files and binary files differently, and adding the 'b' may be a good idea if you do I/O to a binary file and expect that your program may be ported to non-UNIX environments.) tl;dr: There is a 'b' option but on UNIX systems it doesn't mean anything.
I find low level programming just sexy :) I hope you understand what I mean. Microcontrollers, PIC, Kernel, device drivers etc etc sounds seducing :) Want to know them better, I think C is great for this :) 
Sizeof(r) == 8 because r is a pointer to first element of arr.
[removed]
Is it mandatory that it be the base array? Because otherwise you only have to pass `array+1` to the function from inside itself (i.e., `func(array+1)` inside `func`).
Can you please explain what you are saying with some more code . What would be your base condition ?
You need to know the length of your array. If you allow an array to contain pointers to another array, you need to be able to distinguish a pointer to an array from a number.
That's what I was thinking after I answered, actually. You would need a value that you won't be using as part of the sum. For example, you could use INT_MIN, as that would make the range of positive and negative values symmetrical. Without such a value, however, you can't.
 int calc (int **pt) { if (*pt) { return **pt + calc (pt + 1); } return 0; } int main (void) { int **ptlist = malloc (sizeof (int*) * 6); if (!(ptlist)) return 0; for (int i = 0; i &lt; 5; i++) { ptlist[i] = malloc (sizeof (int)); if (!(ptlist[i])) return 0; *ptlist[i] = i; } ptlist[5] = NULL; int total = calc (ptlist); printf ("%d\n", total); return 0; } 
The C preprocessor needs to know when the name of a macro ends. It does this by defining which characters are allowed to form the name of a macro. Sadly + is not one of those characters. If it's really that important to you, you can make a simple custom preprocessor out of an awk script or shell script or something. Probably it's easier to accept the syntactic limitations of the C preprocessor and do something like this instead: #define U(x) 0x ## x
That's not really possible with what the C preprocessor provides.
What makes you think that the ISO 646 header (which is just a bunch of macros anyway) or digraphs would help you? I can't really understand the thought process behind that.
It seems like you don't quite understand C macros. The preprocessor can only replace identifiers and function like macros. A string like `U+1ABC` is composed of the tokens `U`, `+`, and `1ABC`. There is no way to replace `+` or `1ABC` as these two are not identifiers. Only `U` could be replaced but then the remaining tokens would be left over unchanged.
Try using the `strftime` standard library function.
Why would you wanna do it that way?
So this is my code for a function called getTime() which returns a char* char buff[50]; int size = 50; time_t curtime; struct tm *loc_time; loc_time = localtime(&amp;curtime); strftime(buff,size,"Time is %I:%M %p. \n", loc_time); return buff; Thanks for the assistance :)
I find that most people don't quite understand the difference between an array and a pointer, and confusion surrounding things like this stems from that misunderstanding. There *is* an array type in C, and that is where all of the differences come from. The above is perhaps shown best by simply showing that you can have a pointer to an array (Though it's not something tons of people see on a daily basis): int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int (*arr_ptr)[5] = &amp;arr; printf("%zd\n", sizeof(*arr_ptr) / sizeof(*arr_ptr[0])); } The above prints the size of the array `arr` despite using a pointer instead of using `arr` directly. This works because our pointer is of type `int (*)[5]` (The parenthesis differentiate between a pointer to an array of 5 ints, and an array of 5 pointers to int), and when you dereference that with `*` you get the type `int [5]`, which is an *array type*. Thus `sizeof` gives the size of that array. This also may make it more clear why it works at all - the type of an array contains its bounds. So `int [5]` and `int [7]` are two different types. `sizeof` simply uses this information to calculate the size of the array. And hence why it doesn't work for pointers of type `int *`, because those contain no array-size information in their type. You can `typedef` arrays as well, which might make it more clear (Or maybe just more confusing...): typedef int array_type[5]; /* typedef's "array_type" as the type "int [5]" */ int main() { array_type arr = { 1, 2, 3, 4, 5 }; array_type *arr_ptr = &amp;arr; /* "arr_ptr" is of type "int (*)[5]", which is also the same as "array_type *" */ printf("%zd\n", sizeof(*arr_ptr) / sizeof(*arr_ptr[0])); } Using a `typedef` allows you to avoid the weird pointer syntax (Similar to `typedef`ing a function), so the code looks a lot more 'natural'. Personally I don't use `typedef`'s of arrays, I don't find the syntax to be hard to understand after a bit of use, but it is what it is.
r/dailyprogrammer
Ah i didn't realise it's reserved, i just called my variable that to store it. I've changed that and i'm passing in a char buffer into the function to set the time to that buffer. However i'm not sure what value i'd set curtime to or why I'd need to do that? I'm not sure why you felt the need to say "Argh!". If this is an exclaimation of frustration, I'm just learning C and i was under the impression this is the subreddit to ask questions like this.
\#define ARRAY_LENGTH(X) (sizeof(X) / sizeof(X[0])) Obviously you have to pass it a valid array. Edit: This likely won't work
[Project Euler](https://projecteuler.net/archives). Put all the problems in the same directory and practice with makefiles and macros too. Practice linking in header files and building libraries that will help with all of the problems, not just one. You can actually make euler pretty complex. HTTP server is good, a simple one isn't super hard and you will learn about sockets. A simple shell is another good one.
Thanks, I'll consider these.
Yup. the b denotes whether is for text or binary mode. (this is mostly a relic of the past, but you should still use it because it's supported on newer platforms, and older ones require it)
Amen dude that's what brought me in too. webdev just doesn't interest me. Anyway, finding C jobs (at least the ones I'm interested in) tend to require at least a BS in EE or CS with a focus on math.
The standard library. don't use anything outside of it if you can help it.
Clang recently deprecated gnu++ in favor of it's libc++, so it's probably using Clang's runtime.
Not sure why you're trying to lie this problem at C's feet tho, seems like something the OS should take care of
https://codewars.com
If you want a challenge more in line with your background, perhaps a C program like "http://boston.conman.org/cgi-bin/raw.cgi". This is a C program I wrote that executes under a web server and dumps the environment variables, command line arguments and data fed into it to a webpage. Doing something like this will teach you: * how to write a simple C program and compile it * how to interface a C program to the web server * what information is available to a C program executed from a webserver I've also found such a program useful for debugging at times. 
I made a remote file server, and it was pretty good practice. It's a great way to get familiar with socket programming in C. I also made my own implementation of malloc, using a 5000 byte array to simulate heap memory. Really helped with my understanding of memory allocation in C.
Something I remembered now... A friend of mine has, if I recall right, some sort of simple image manipulation program he likes to work in. It's his own thing, nothing professional as far as I know. He has implemented it in Java, C++ and Javascript I think. He once told me that he first did it in Java, but rewriting it in C++ and Javascript was a means to get somewhat significant practice in these languages. So, maybe you have a system you've programmed before. Rewriting that in C and figuring out the tools you need to get used to (libraries, compilers, etc) can be an interesting exercise in learning C by doing. Make sure you know how to use your compilers with warning flags turned on. C programming can be very deceiving, that is, you can happen to think you're doing something which is valid C while it isn't even though the code compiles and runs. 
No problemo :) I have that :) 
Your formatting specifiers are wrong. When you call `printf` with argument types that don't match the formatting specifiers, undefined behaviour occurs and weird things can happen. For `int`, you need to use `%d`, but for an `int64_t`, you need to use the macro `PRId64` from `&lt;inttypes.h&gt;` like this: "tailWins = %" PRId64 "\n" Alternatively, convert `tailWins` to an `unsigned long long` and use `%lld` to print that.
You opened the file in write-only mode, `w`. Using an input function on an output-only stream causes undefined behaviour. To do this you need to open in *update mode* (i.e. read-write mode), `"w+b"` or `"r+b"` or `"a+b"`. Note that writing to a file and then reading from the same handle without an intervening seek or flush operation causes undefined behaviour -- so you'll need to make further modifications to your code. See C11 7.21.5.3/7: &gt;When a file is opened with update mode (`'+'` as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the `fflush` function or to a file positioning function (`fseek`, `fsetpos`, or `rewind`), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end- of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations. 
It is a valid way to check for null pointer because `'\0'` is an integer constant expression with value zero, therefore it converts to the null pointer when compared with a pointer. But it is not good style. 
I guess I finally got bit from not paying enough attention to my format specifiers. I was able to get both the macro and the `%lld` specifiers to work. Thank you for your help. I've been able to do some further reading and feel I understand this now.
I've been running gcc 5.3 with `-Wall -Wextra -Wpedantic`. I've been meaning to reinstall clang, just haven't gotten around to it. I used to run clang with all warnings enabled and just turned off the ones I felt confident I could ignore (also looking up online to see if there could be a good reason to keep a particular one on).
Good question, I never read a book about pthreads. Basically, the POSIX threading API provides all classic primitives and structures for multi threading. If you know how to write multi-threaded programs in general (e.g. by taking a class), then using the pthreads API should be easy.
By class you mean university? Is there are something accessible through the internet you recommend?
Hm... I learned most of it in our University's class *operating systems II* though, even if I would have found the material in my brief 5 minute search, it's all in German and thus probably useless for you.
Also it would be a good idea to use INT_MIN, if INT_MIN were a legitimate value in the program then very likely there's an overflow occurring, it's enough to subtract 1 from INT_MIN or negate it. Moreover from the 2's complement representation of the integers, eliminating the smallest integer makes the interval symmetric around 0. As INT_MIN=-2^(n-1) and INT_MAX=2^(n-1)-1 (n dependent on word size). This is why negating INT_MIN overflows and results in INT_MIN. For floating point numbers the NaN constant could be used.
Windows doesn't support C... not directly anyway. But yeah Clang doesn't include it's own C standard library, it uses the system supplied one.
I think AFL (American fuzzy lop) is a runtime analyzer, but it is independent of compiler.
Man Pages and https://computing.llnl.gov/tutorials/pthreads/
This is correct.
Pthread programming, from O'reilly. Was the perfect book for me :) 
Different GUI applications use different approach. Business/user applications typically use some sort of a graphical toolkit or a framework, like GTK+(cross-plarform), wxWidgets or Win32 controls. Games typically use lower level graphical routines, to draw exactly what is needed. You can use low-level Direct3D/OpenGL calls, or use a nice wrapper library like SDL ([see this example](https://github.com/cypok/sdl_example) or any other SDL tutorial).
That looks like a useful tool, but it's not a lint. A lint is a static code analyzer; it reads source code and analyzes it for potential/likely errors without compiling or running. 
Check out the [Wikipedia article on graphic toolkits](https://en.m.wikipedia.org/wiki/List_of_widget_toolkits). Excuse the mobile link. 
Finding a line with maximum score is simple. Example in pseudo-code: best_score = 0 best_line_no = -1 for (line_no = 1; line_no &lt;= line_count(file); line_no++) { line_score = score(get_next_line(file)) if line_score &gt; best_score { best_score = line_score best_line_no = line_no } } But it's not clear yet what metric you'd like to use. What do you mean by 'symbol', are you simply looking at individual characters? Do you have a definition of the meaningfulness of a character and you'd like a line where the characters have the worst score on average? Or do you divide characters into meaningful and meaningless ones and want a line with the fewest meaningful characters? In the latter case, how would you like to deal with the fact that pretty much every source file will have a line with zero meaningful characters?
Not sure what your parenthesized line refers to, binary mode is still alive and kicking, and there hasn't been any change over time in its relevance. 
Your comment might have been true in 1985, but now C++ is not a superset of C, and learning C could even be detrimental to learning C++. 
You are right. Then i guess any of those NaN values will do, even infinity.
Unrelated to the sentinel value point, but the significand bits of NaN are sometimes used to encode the reason a NaN was produced, like overflow, underflow, or parsing fault
OK, so basically you could adapt my sketch above by making a score function that loops through the characters in a line and counts how many times that `if` is true, changing the \&gt; to a \&lt; and initialising best_score to something like MAX_INT. Then best_line_no would have the number of the first line with the lowest count at the end. I'd also consider skipping certain lines, such as ones that are empty or only contain a `}` after stripping out whitespace, as otherwise the results would be rather boring for most inputs.
You'll likely need to acquire the SE_DEBUG_NAME privileges for your process. Check out: https://msdn.microsoft.com/en-us/library/windows/desktop/aa446619(v=vs.85).aspx
Ah, terrific. I didn't know this existed. I also appreciate that each is broken into three levels of difficulty.
Ah, neat, in that case you only need to figure out three easy things: * How to get one line from the file at a time. Do a web search for 'getline' examples that apply to your OS/compiler. * How to check whether a line starts with an `if`. You can use strstr for this. If you just need to check for `if`s at the very beginning, comparing the pointer returned by strstr to the pointer to the start of the line will do the trick. In case you need to ignore leading whitespace for indented lines of code, I'd suggest making a separate function that strips off leading whitespace, which lets you reduce the problem to the simpler case. * How to count the number of occurrences of a certain character in a string. You can easily find solutions for this on Stackoverflow etc.; just pick one you find easy to understand. I'd suggest making a function that takes two parameters: The string and the character you're looking for. Then you can just do something like parens_in_line = char_count(line, '(') + char_count(line, ')') I hope this was coherent, I was typing it while watching the GDQ Mega Man speedrun ;)
&gt; Also, I'm afraid that I won't get any job with this stuff, am I just paranoid ? If you can write Linux drivers, it shouldn't be too hard to get a job. People with such knowledge aren't exactly common. If you don't understand something, try to work your way through it, often understanding comes later. If that fails, you can always ask. Learning is never a bad thing, the deeper you dive into the details, the more you understand. An understanding of how these things work is not just important for C but also for other languages. And even if it is not directly applicable, it makes you write better programs because you understand what the computer actually does.
broi means count in bulgarian. but yes. I fixed it, thanks. since its 4 AM I think its time i go to bed. I will continue working on it tommorow. If I have any other questions I will ask you. thanks for all your help
http://www.geeksforgeeks.org/data-structures/
Thank you! I am going to take a huge jump here and assume there are examples in the above written in C? No hand-holding, but basic functions/procedures for the algos and data struct?
Thanks!
Neither Knuth nor Aho have C code in their books. The Aho book isn't in front of me but I recall it being Pascal-like, which is close enough for any C coder. Knuth jumps from the math and theory of an algorithm directly to pseudo (MIX) assembly examples because he thinks it's critical to understand CPU cycles and memory accesses in order to properly judge an algorithm. And who am I to disagree with Knuth? ;-) Either way, you'll be fine as a C programmer. Just make sure you have a foot of shelf space and strong shelves for the Knuth tomes. :-)
maybe `buf` does not have enough space allocated
Steven Skiena, The Algorithm Design Manual
You can learn the Win32 API and compile programs that create an actual 'Windows' window, or dialog box, and spawn a bunch of buttons and edit boxes and menus. I use resource files and hand-design a dialog box layout for all the simple GUI programs I've made. I've even incorporated OpenGL rendering right smack on the dialog box. Here's a good guide I just found that explains the process: https://www.codeproject.com/Articles/37665/Introduction-to-ResEdit You can also find GUI libraries out there that render unique custom interfaces with OpenGL/D3D, and can be incorporated into your own graphics projects, like a game for instance, and they handle all the updating and drawing of buttons and sliders and menus and text. Aside from that, there are other GUI libs out there that allow you to make your program portable and not platform-specific, like GTK, Qt, etc. which just use the OS' existing GUI system but abstract it so that you can describe your GUI in a generic way that the library will then go ahead and convert to whatever OS you are compiling your program for. This is one way to avoid having to deal with OS internals and APIs.
Maybe write your own little toy OS. http://wiki.osdev.org/ is a good place to start. C is in essence a really simple language (the corner cases are where the difficulty comes in) that generally maps rather well to modern assembly language. So with some assembly under your belt (necessary for OS dev) C should be rather easy.
I would follow the advice of the first few answers.
Will setting that path mess with anything outside of when I'm trying to compile C code? I figured I would do what it says in the step by step instructions just changing C: to F: but wanted to make sure it was correct before doing it. The contents doesn't show anything for GUIs so should I find another guide maybe using the third way? What do you recommend?
This, but I would like to add a fourth option: Install a light linux distro on your old laptop. Developing C will feel more native and you'll find that your old computer is not necessarily done for just because it doesn't run windows as smoothly anymore.
Sedgewick, "Algorithms in C" is a very good book by a respected author. Has chapters on many kinds of data structure. Seems to be pretty much exactly what you're looking for.
It says that future downloads could be affected by the other. The SSD is only for my OS and software for my hardware. So I might just read about that and familiarize myself with that topic before messing with C. As far as the IDE I have one on my laptop that I downloaded for class using python. However I hear a lot of negative commentary on python as a programming language and it was an introductory course. I want to educate myself outside of the class but I'm overwhelmed on where to start. I am told to just dive in but no matter where I start I always seem to be behind with something. 
&gt; c language programming Then what is "Popular exercises: Animated text – Javascript" in the context of C programming? 
&gt; I hear a lot of negative commentary on python as a programming language You can hear a lot of negative commentary about anything. Don't follow any site that is highly critical of it. 
Or Vulcan *cough cough*
Python is a fine language for many applications. If you like it, then you might want to stick with it for the time being.
Not sure of the extent of your C knowledge but I am currently reading the second edition of The C Programming Language by Kernighan and Ritchie. I'm loving it so far. I find it all very interesting. The book is very popular so people have GitHub repos with answers of the practice problems as you go along.
I meant GTk, thanks. I corrected my comment. I was on my phone in a car (**not** driving!) so didn't notice the error. 
I took a free class from coursera by him, great classes... though it is done with java. Algorithms 1 and Algorithms 2 
Very helpful. Thank you!!! I knew there was a missing link somewhere. This stuff seems to be pretty scarce on the internet.
I think this is the best way to begin. Install MinGW and also the base package within it, which should contain what you need. Then install Code:Blocks which will auto detect your MinGW install if you did everything correctly. Very easy to set up and is well-featured IDE to start out with.
This is awesome, good job, will read the source soon
Another good resource for learning GUI programming from scratch is [Handmade Hero](https://handmadehero.org/). There you can see an expert C programmer set up and initialize a Windows application from scratch: opening a window, setting up the event loop, and drawing in the window buffer. Once you have done that, you probably want some abstraction instead of drawing pixels directly in the buffer. Look at [IMGUI](https://github.com/ocornut/imgui) for a self-contained graphics library that works with OpenGL.
I have final tomorrow and I still got no idea how to hand-evaluate these codes without a compiler. Can someone teach me a way to do that? Image is just an example
That may be more than the OP is ready for, if I'm assessing his skills correctly. There is a download on the link I provided that include MinGW and (presumably) sets it up. This sounds like a "one stop shopping" solution to get started. 
I've been looking for this kind of minimalist ANN library for C for ages. Great work by the authors!
I had the same thought, I'm currently in the middle of the course and quite enjoying it.
No blogspam please.
Can you not post questions from within your exam?
They are sample questions
Well, have you tried to answer them on your own? Where are you stuck?
Is the answer C-36 ?
So users don't have to deal with the dread that is C/C++ library management.
Follow the code and do everything it does on a piece of paper. Try it out!
Hi! Sorry for asking but could somebody explain a litle what is that and what it is used for? I have a finish exam next week for my 1 semster c course and I have no idea what that is. (I'm noot a complete noob)
As well, [Foundations of Computer Science](http://infolab.stanford.edu/~ullman/focs.html) by Aho and Ullman This one is GREAT. Just took Computing Foundations 1 and 2 using this book. Very theory heavy, but all the info is still relevant. EDIT: There is C code in this book. Code examples are in C I believe.
Please stop posting these.
Please be civil.
Would prefer to see `static` on the function bodies too -- if you happen to have a function body that didn't have a prototype with `static` then it is silent undefined behaviour.
I describe my files, functions, parameters, variables, etc as logically as I can, without being ridiculous, or wasting too much space. I avoid underscores as much as I can, and i'm not a big fan of acronyms, but sometimes you gotta do what you gotta do. tl;dr: KISS.
i mean the common use case for *signal* function. it describes a special and not clear example to recommend the lock held way so I do not think it is very right. &gt;it's easier to think about the control flow if you know that the set of waiting threads can't change between the point where you set the condition and send the signal. this is the only reason to do like that? the **signal** function in or out of the locked region are correct ?
Too write your own GUI toolkit is somewhat of an undertaking, especially when portability comes into play. For a simple user interface you could try linking this library to one of your projects: https://github.com/vurtun/nuklear I usually do code for games using OpenGL and SDL for cross platform portability and performance. SDL is very simple to get started with, OpenGL not so much. What all this boils down to is using libraries to avoid re-implementing the hard stuff yourself. So you get to just call a function "give_me_a_button();" instead of having to learn a lot of low level platform specific stuff. 
I would argue that GTK is an unecessary burden for a new programmer. Much better to use one of the myriad of small, simple, portable toolkits that are out there.
see: http://lazyfoo.net/SDL_tutorials/ The industry standard SDL tutorials. SDL2 is a great way to get your feet wet in graphics programming without getting bogged down.
Elements of Computing Systems: Building a Modern Computer from First Principles
&gt; So for example, you can run a 32 bit program on a 64 bit machine. In the context of the program itself, what does this mean? It means nothing really. The operating system will make the 32-bit program think it is running on a 32-bit computer. In x64 case, at least, the processor really is in a 32-bit mode when executing a thread from the 32-bit app. The O/S manages the transition. 
Thank you! Your analogies were surprisingly helpful. 
Running a 64 bit application on a 32 bit os or hardware would be a lot more work. You'd need to run a vm if it was a 32 bit processor. A 32 bit os could run a 64 bit application if it was on a 64 bit processor possibly without a vm.
I don't see where you see a "special and not clear example" considering that the only code example is precisely the way you should do things. And making it easier to think about flow control is a pretty huge reason to keep the lock held while signalling since it's pretty much the hardest part about threading. 
&gt;pthread_cond_signal(), which wakes up thread C I mean above is the special example. although I mainly focus the signal function
Gnu Make 4.2.1 from msys2 distro. I tried placement of spaces after : first thing to do, but it didn't solved the problem. There is also no space in c-&gt;o rule but that one works.
Hmm, docs says that suffix rules are obsolete since new pattern rules don't need them. Here are docs: https://www.gnu.org/software/make/manual/html_node/Suffix-Rules.html I tried them anyway, and I tried even old syntax (with .SUFFIXES: .c .o .rc .rs): .rc.rs: rule ... but it does not work either.
You're right, I mixed confused pattern rules with suffix rules. My suggestion then is to add an explicit rule "bla.rc: bla.rs" and see if that works. Then go for pattern rules.
FWIW I suspect the pattern rule was failing because it couldn't find the .rc file in your root directory (as the actual command looks in $(INC) for it, but this isn't specified in the rule).
That's the correct way to do that. Or even better, run make in the $(BIN) dir with VPATH set to the sources dir and the $(INC) directory.
http://eudyptula-challenge.org/ Advanced Programming in the Unix Environment, Stevens and Rago
"Some of the interfaces are for data structures, but this is not a data structures book, per se. The emphasis is more on algorithm engineering — packaging data structures for general use in applications — than on data-structure algorithms. Good interface design does rely on appropriate data structures and efficient algorithms, however, so this book complements traditional data structure and algorithms texts like Robert Sedgewick’s Algorithms in C (Addison-Wesley, 1990)." - C Interfaces and Implementations, Hanson
Just under forty years coding C. Hoping for another ten. Mind is still there, but I spend an increasing amount of time talking to my cat. She likes all of my ideas. C has been my go to language since I left university. I like it because if there is a bug, a) it's my fault, and b) I have everything I need to fix it. Every now and then I'm envious of the python guys importing antigravity and flying about the room, but I just like doing things myself. Takes longer, but in the end it's mine. Advice? Keep your dependencies to a minimum. Don't re-invent the wheel, but if the wheel is not a good fit try making one yourself. It's not that hard and you might learn something. Plan your projects. Diving in is fun, but doing something over again and again until it works is not. A little effort up front will reward you with a better, more easily maintained result. Living with a steaming pile of poorly designed code is not a path to advancing your career. Read this [list of lessons](https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style) from The Elements of Programming Style. Have fun. If you don't enjoy the domain you're in find a route to someplace where you will. 
I love your advice, because it's basically the advice you'll get from any seasoned professional. "Hit then ball hard, but not too hard" or "Use a lot of contrast, but not too much contrast." At a certain level of proficiency, it's all about internalized intuition. 10k hours is having more opportunity to fail and succeed from choices made (and following up with the requisite post-hoc analysis) thus improving your intuition. Essentially, confusion happens less, but when it does happen you've learned to spend the right amount of time understanding that confusion and hopefully getting yourself out from under it. You actually get excited for the confusion, because it's an opportunity to improve and because it happens a lot less often. 
Is it C that you're burned out on or your projects / company? I got burned out a few years ago but that's because I realized that my place wasn't going anywhere. I still like coding in C. 
Probably more like 20 - 30K hours programming C, C++, Python. I like working with python for one off things, proof of concepts, stuff that is not serious, or web stuff. More and more I have come to like C over C++ due to its simplicity. C++ provides so many fancy ways of doing things (stl, lambdas, inheritance, etc) which serve to make writing a programme easier, but often make understanding a programme much harder. Writing good code requires a lot of discipline; the more flexible and complex the language is, the more discipline is required. The main disciplines required in writing good code in my opinion are: * Input validation (it's so easy to just assume that the input you are getting to a function, or a programme is correct, requires discipline to make sure all input is valid). * Appropriate handling of errors (so your input is invalid, or there is some other external error, how are you going to handle that?) * Clear and obvious storage and communication of programme state (especially important in multi threaded programmes, so easy to let assumptions about state creep into your code). * Keep it simple. (Break down what you are trying to do into it's simplest elements and then put them together in an obvious and readable way).
While very interesting, I can't see how your submission is about C programming and have removed it for being off topic.
okay i get it now , Thank you :) and keep the good work
Thank you for your understanding. I welcome your effort, if you have contributions that fit our topic, I welcome you to post them here!
I learned more reading other people's code than writing thousands of hours of my own. I wish I figured that out earlier.
I've been coding for about 17k hours in Python, C++, Ruby, JavaScript, etc. I still dig it. I still love making things that do other things. I recommend that you think twice, consider failure scenarios, and then write code. Compile and test often. Make sure you're always pursuing your agreed upon definition of done. And, at the end of the day -- have some fun with your family and friends. It's not all about the code. 
In the register it still takes up 64 bits, but when it's read back into memory to the register and from it, it's cut down to 32 bits.
I really don't have one. Like I said -- just the one book. The side bar has a few good links. I hear King's C Programming: A Modern Approach mentioned quite a bit. It's supposed to have more examples and embraces the newer standards. Never read it though so can't say one way or another.
Please take a look at how your code ended up formatted by reddit and try to straighten that out. A pastebin link would also be awesome. EDIT: Ok, I haven't dealt with single char inputs in a while, so I tested. What's happening is that the carriage return is in the stdin buffer when you call the second scanf. To fix it, simply change the formatting string in your scanfs from "%c" to "%c\n" so the computer will remove the carriage return from the buffer. EDIT EDIT: Here's the code I threw together to see what was going on. It runs straight through and outputs the ASCII value of the letter you put in followed by the ASCII value of a line feed. #include &lt;stdio.h&gt; int main(){ char c; scanf("%c",&amp;c); printf("%d\n",(int)c); scanf("%c",&amp;c); printf("%d\n",(int)c); }
Oh, you're of course right! It's like 6am here, I still felt like dead, didn't have my coffee...
You doing that "[cat debugging](https://en.m.wikipedia.org/wiki/Rubber_duck_debugging)" thing?
To improve your knowledge of pointers I would lookup some projects that you could do that work with linked lists!
Indeed, thank you. I admit that I am not so educated when it comes to Make :-).
Now I don't want to download MinGW because I can only find it through source forge and a lot of people have said they get malware from their downloads
*How do you test your skills in C and what exercises do you take to improve your C skills from beginner to intermediate?* Haha, just write as many programs as you can! As Chistler say, do lot with linked data structures. For example implement your own binary trees, RB tress, linked lists (single, double, cirkular, fifo,lifo etc). I remember when I had a first course in programming at university we had to implement that simple game with dungeons, items &amp; monsters in it to practice linked data structures and OOM. To practice file handling implement some simple parser. For example Obj file parser to parse graphic scenes http://paulbourke.net/dataformats/obj/ You can also make your own small graphic library to display them in OpenGL a lá GLUT/GLFW. Make it to work on both Linux &amp; Windows (I did it once for practice). 
i would recommend &lt;the Linux Programming Interface&gt;
Start with a simple project: - open a file with a file name specified in argv (if it does not exist - create one) - prompt the user for a string to be inserted into this file - allocate memory for the string, reallocate is the string is longer than expected at first - move to the end of the file and paste the string there - free the memory, close the file For more project ideas go to eg. https://github.com/karan/Projects 
Do small projects on your own (along with a good reference - http://en.cppreference.com/w/c is pretty decent) - https://github.com/karan/Projects Bounce feedback off forums, and then repeat and improve. Also, this is **not** exactly related to what you're asking, but http://www.nobius.org/~dbg/practical-file-system-design.pdf is a beautiful piece of work, and it makes for very easing reading as well (if you have some basic idea how file systems work). Plus, it does show one excellent use case where you definitely would use pointers (multiple indirections, in fact). Recommended reading.
The /g/ recommends trying to program the following: https://wiki.installgentoo.com/images/5/5c/Programming-Projects-for-N00bz.jpg It is also recommended to read some code, for example the nice code from the [musl libc](https://www.musl-libc.org/) project, which implements a lightweight C library with focus on security and code correctness.
Do the pintos projects 
Why did you learn C, or programming at all, if you have no need for it?
I've always been a fan of [Glib](https://developer.gnome.org/glib/2.50/), but I think it's closer to the C++ STL than Boost.
[GLib](https://en.wikipedia.org/wiki/GLib) is pretty much what you're looking for. I can't vouch for its quality though – I really dislike adding dependencies to my software unless strictly necessary. 
An extension on this that I always like to suggest to people is that they make a basic Caesar cipher that takes a filename from argv as input. That teaches how to read and write files and take input, similar to what you suggested. However, it also forces you to learn how strings are viewed by the language as well as how characters are converted to and from numeric values. Plus it's fun to have something to just play around with sometimes.
Why [yes I do](https://www.reddit.com/r/learnprogramming/comments/5n59bk/what_can_i_buy_to_increase_my_productivity/dc8v230/)
address sanitizing with gcc or clang. Write a script to replace allocations with a failure. Use a fuzzer. Write tests for functions and or modules. Use debug asserts. 
stb libs! https://github.com/nothings/stb
I see everyone's rightfully recommending Glib, which is the closest to C++'s STL or Boost. I personally dislike it and here are a few reasons: * Moves away from C and tries hard to object-orientify everything, sometimes that doesn't make sense and some things are still better done the C (functional or procedural) way. * ~~You can't build your own Glib-like data structures without going through the (complex) GObject constructs.~~ /u/TingPing points out that this isn't true. GObject constructs are nevertheless quite complex and macro-heavy though. * Too much reliance on macros for my taste. * Too much reliance on pointless `typedef`s for my taste: was that thing an `enum` or a `struct`? * Too much reliance on runtime introspection and dynamic-ism for my taste (why use C, then?). * Memory leaks: try instantiating a GHashTable thingy and releasing it immediately and run that in Valgrind. I would personally love to see a library for system-level application development that at least satisfies the following: * A set of routines and structures that are useful to the programmer without any extra fuss, something very POSIX-like and feels like it's extending POSIX rather than reinventing every design-pattern wheel. * Portable, reimplements what's needed from POSIX and achieves full POSIX compliance on platforms that don't (no shame in making use of the platform's specific libc and syscalls to achieve that). * Avoids preprocessor macros except where they're really needed. * Doesn't make it impossibly complex to do multi-threading with its data structures. * Pays careful attention to memory management and especially memory leaks. * Pays careful attention to error handling. * Doesn't try to hide information from the user as part of its API. * Does as much as possible at compile-time, and when really needed, does as much as possible at data structure initialization time. * Clarity at all cost (not to be confused with simplicity).
I notice you want as much as possible done at compile time, but as few macros as possible. These may be criteria that are somewhat at odds, yes? 
If you want all the fun properties of vectors, maps, etc, why not just use C++ and ignore classes?
There certainly is an intersection of use-cases where these would be at odds, but compilers have gotten really good which helps close the gap. So instead of a function-like macro, simply write a function, unless you know you really need that tiny extra bit of runtime speed.
I found a C game library that allows me to build cross platform and I don't think that will work with C++.
https://isocpp.org/wiki/faq/mixing-c-and-cpp
I've not heard of that one before - that looks great!
For those of your recommending GLib, does dynamically linking against the library free you from entangling GPL licensing terms? I've always thought that GObject (and possibly Vala, which compiles down to C) looked like they could have some merit, but I don't want to run afoul of their terms of use.
Finally finished exercise 1-21. Lessons learned: give variables decent names, or you will find your code totally incomprehensible every time you sit down to it, and delete your progress over and over in frustration! I learned the lesson long ago in JavaScript, I don't know why C compels me to give one-character variable names.
&gt; Why not C99? stdint.h, declare-anywhere, etc. &gt; I still use MSVC 6 (1998) as my IDE because it has better human factors for me than later versions of MSVC. I like this guy :)
Wasn't there a C library that abused the preprocessor to create a sort-of pythonic dialect of C? I remember seeing it here a couple years ago, and some discussion about its huge set of collections and boost-like functionality, but I've lost track of it. Edit: [libcello](http://libcello.org/) is what I was thinking of. Thanks /u/FUZxxl.
It's licensed under the LGPL, so, yes.
Not sure about expandable but this is what I was talking about https://github.com/raysan5/raylib/blob/master/src/raymath.h. it's not to hard to reallocate more memory
Is it undefined behavior? 
The syntax for casting to an `int` is: (int) variable If you have this: int x = 7; int y = x / 3; The second line will perform integer division since `x` and `3` are both `int`s. (A number that's just digits with no decimal point or type suffix is assumed to be an `int`.) No cast is necessary. You only need a cast if you want to change something to a different type than what it is.
The first version copies five characters, 'd', 'u', 'c', 'k' and a null. The second version copies four characters, leaving the fifth member of the destination array uninitialized. It might be a null by pure chance, but it doesn't matter because you invoke undefined behavior if you attempt to find out. (That is, reading an uninitialized value is UB, so it doesn't matter whether the fifth member was a null by luck or some stray non-null value; it's always undefined behavior to do something like `printf("%s", tt)` without writing to the fifth slot to terminate the string.) 
Given the code above, x will be 2 without the cast (since the math is all integer math in the given example). A better example of a cast would be: double x = 7.0; double y = x / 3.0; int z = (int)y; or even x = (int)(7.0 / 3.0); There should be very little reason have a cast (of any type) in most code. 
Clang implements it, but most other C compilers don't. Notably, Microsoft's compiler doesn't, and you should try to be compatible with MSVC if your code might be used on Windows.
Thank you, also edited made sure that the char t[] is the same string ( sorry for confusion )
I'm a fan of [Project Euler](https://projecteuler.net). Try to do the first 20 problems or so in any new language that you're learning or want to get better at. PE is nice because you can focus on pure data and algorithm aspects of the language, instead of GUI or framework issues. Later problems at that site get heavy on number theory, but the early ones are high school level math and none of them should require more than a page or two of code and an average computer. e.g. Problem 1 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. Anyways, just a suggestion. I enjoy it whenever I want to wade into a new language. Keep it fun! :-)
libcello?
That's the one!
My first exposure to C was in 1985. I guess that 32 years ago, now. :-) I have coded C professionally and recreationally since then, learning and using more than a dozen languages in addition. I don't know how many *hours* I have in C. A lot. I still really like C. It's still a go-to language for me for some work. Besides recreational projects and programming contests, the professional utility of C for embedded systems is still tops. Also great for some commandline utilities. And sometimes I'll write the business logic or computation of a larger desktop or phone app in C and link that library into Swift (nice) or Java (yuck). :-) I enjoy learning and honestly trying most languages I get exposed to. I stick with very few. C is one. Lisps are another. I'm wrestling with Haskell. Python is still my guilty pleasure (sorry Perl). But speaking as a C-lover, I think Rust could be the one head-turner for C programmers now or soon. Otherwise, for a no-hidden-abstractions/costs, non-auto-garbage-collected, strongly-typed, minimal-runtime language that can run or dynamically/statically link into almost any other language and platform ever invented ... nothing beats C. Enjoy the path. Stay fresh. Keep it fun. TL;DR: ♫ still **C**-razy, after all these years ♬ :-)
You can try GLIB and stb as many people are recommending in here. You can also try APR (https://en.wikipedia.org/wiki/Apache_Portable_Runtime). Consider SDL2 as well for "low level IO" related features. The problem is that C is not really a very good language for library development. The features are not quite there. For example, if you have a GC in place (like with java, python, C# and so forth), your library doesn't have to worry about how it integrates with the application's memory management mechanisms. You allocate as much as needed, return the references to the allocated structures to the application and it all works out fine. This makes library writing less work to do. C doesn't give you anything like that to facilitate library writing. Another reason (besides annoyances with memory management) is that the C standard library is extremely poor. Anything interesting will rely on some system dependent library or some portable layer on top of that (like SDL2). In a language like java in which, for example, you have tons of built-in facilities for dealing with files, directories, networking, and IO of many sorts, you don't need to add dependencies to your library if you want to use those things. They're part of the standard library which you have available as a java programmer. In C, you barely have file IO utilities, and not even that to be honest (they're extremely poor). So if you want something interesting going on having to do with IO in your library, you'll need something system dependent (or a layer on top of that like SDL2). Consider how error handling in C is really annoying. As a library writer, this is worse than usual. As an application writer, you have way more control on what to do if an error happens. As a library writer, you can't really make a decision there in many cases and thus have to somehow inform the application of the error. This can be annoying. As much as I dislike exceptions, they make this process easier at least (they have their problems as well). The issue here is not that C doesn't have exceptions. It's that C doesn't help you with error handling. Things like data structures and algorithms in libraries tend to benefit from generic programming-ish features. In C, you basically don't have that. What you have for writing algorithms and data structures related libraries (that I see people using) usually goes back to void* (or some generic indexing type, whose type is just "as meaningless" as void*) and macros. Both are very unsatisfactory solutions to many people (most I've seen, me included). In the end, you can write nice libraries in C. I've seen some people saying good things about the stb libraries. There are so many annoyances though. In C++, a lot of the memory management annoyances go away because of RAII. In C++ you still have the system dependencies problem. Templates gives you, as annoying as they are, a way to write generic code if you want. So things look way better for C++ than they look for C as library writing facilities. If you look at languages like Java, C#, Javascript, Python, Ruby, Perl and so forth. Library writing there is way less problematic. No wonder there are so many of them. Some of these are dynamically typed, which facilitates some more things as well.
You probably didn't see how it is written yet. It's really horrible to read this library sometimes, so I'd be very careful before using this in your project, because by doing this, you can indirectly force someone to read this in the future...
There is also CCAN: https://ccodearchive.net/
in gamedev circles people are more likely to like that style. (note the ops usersname)
wooow
Thanks that clears it up for me. 
thanks, So for instance: float foo = 3.56; int ans = (int)foo/21; If I want to divide by 3 and not 3.56? 
What style? I'm not talking about code style or that actually implementation is in the header files - this happens. But the things like that: if (bits&gt;=100000000) { n = (stbsp__uint32)( bits % 100000000); bits /= 100000000; } else {n = (stbsp__uint32)bits; bits = 0; } while(n) { out-=2; *(stbsp__uint16*)out=*(stbsp__uint16*)&amp;stbsp__digitpair[(n%100)*2]; n/=100; e+=2; } if (bits==0) { if ((e) &amp;&amp; (out[0]=='0')) { ++out; --e; } break; } are simply wrong and there is no reason to put this in any code, because overall it might look like immature code probably with many bugs inside. I know that this is r/C_Programming and most of the problems here are related to "How array works?" or similar, but any professional C programmer with 2+ years of experience shouldn't recommend this library at all in that form. Of course, you can use part of it, rewrite some for your needs or just get some ideas, but it isn't the code you want to include and be happy forever.
Thank you very much and now I think I know why my functions were not functioning, or creating the tree, as I wanted it. I must have been passing a copy instead of the address to create the tree, that is why everything would work, take values and and everything, but didn't actually created nothing because it was a clean copy every time. Thanks mate. 
You're simply adding the null character, '\0', or space and the end of duck in the first example. Try using sizeof to see if your able to notice any difference, or use a for loop both at i&lt;5 to see what it shows you in both cases..
"Standard strings" in C are character arrays that have `\0` as the final character. `tt` in your second case will only copy `duck`, and not the terminating `\0`. The NUL byte is generally created for you in `strncpy` if you give it enough room. It didn't have the room, so if `printf("%s\n", tt)` produces "duck" and no garbage, it's completely due to luck. The last byte in `tt` hasn't been set to anything, so it's effectively garbage. That means if you try to use that particular character in anything, you'll be venturing into what's called "undefined behavior" territory, meaning that its effects will be different or unpredictable; it's not covered in the standard, and so each compiler and OS may handle it differently, or not at all, causing a crash. If possible, try to use string functions that protect you from this type of thing, or use `sizeof` where possible. EDIT: C gurus, please pick this apart if my understanding of this is off.
the guy who wrote it has decades of experience of has shipped code like, the engine that Thief used, and tools that are in the new Doom. So, as usual in programming, one smart guy says a thing is horrible, another smart guy says it is great. 
Awesome, thanks. You were super helpful! This is going to come in handy as I am just beginning my x64 assembly journey.
&gt; You can't build your own Glib-like data structures without going through the (complex) GObject constructs. Why not? Most of the data structures in GLib don't even use GObject. &gt; Memory leaks: try instantiating a GHashTable thingy and releasing it immediately and run that in Valgrind. Plenty of Valgrind complaints are false positives, they actually ship an official suppression file now to help silence these. If real leaks are found obviously submit a bug over it. 
For reference, the developer [said on Hacker News](https://news.ycombinator.com/item?id=8799070) two years ago that "I probably wouldn't use [libcello] for anything serious either." Don't know if he still means it today. In contrast, Sean's stb library has got serious uses in practice.
Well, that's actually a good approach for a first assessment. If someone is not able to adhere to at least some kind of formatting standard, chances are they are sloppy in content as well. Of course, that does not mean that the library is bad. It might be excellent. I think that coding style is a bit like the clothes you wear. If you want people to be impressed, you better dress up.
&gt; Why not? Most of the data structures in GLib don't even use GObject. You're right, I updated the original comment. &gt; Plenty of Valgrind complaints are false positives, Probably true if you're doing something low-level, or dealing with direct hardware access. If your user-space data structures library is causing Valgrind to scream, you most probably have serious design issues. &gt; they actually ship an official suppression file now to help silence these. Sweeping Valgrind reports under the rug speaks loads about design and code quality.
&gt; You mention routines / structures that would feel like "... extending POSIX, rather than reinventing every design-pattern wheel.", can you explain further what you mean by this? I mean that simple functions that take inputs and return outputs (+/- an error code) are most of the time all you need, are most of the time the correct abstraction and are most of the time the simplest to use. There's no need for a class, or an actor, or a prototype, or whatever nextgen-lang is trying to offer. &gt; What information do you think should be hidden for clarity purposes, or exposed to not hide information from the user as part of the API? In general, avoid `libfoo_stack_get_length(&amp;stack)` when it's just a simple `stack.length` or `stack-&gt;length`. Avoid `libfoo_stack_is_empty(&amp;stack)` when it's just a simple `stack.length == 0` or `stack-&gt;length == 0`. &gt; How would a data structure, for example, a stack be implemented in a "POSIX-like" manner? Unless there's a really good reason you need an explicit stack implementation (something you cannot comfortably do with a POSIX `memstream`), then a `struct mystruct *ptr = NULL` and `size_t len = 0` could easily be used with a function like `stack_init(char **ptr, size_t *len)` as follows: `stack_init(&amp;ptr, &amp;len)`. If you want a bit more convenience and want to keep a capacity vs length as well as a pointer to the top of the stack (good reasons for an explicit stack implementation), then you could offer a traditional `struct stack`, given the preferences discussed above about the API. &gt; Achieving full POSIX compliance (I think) is far beyond the scope of a single library considering all the utilities that must be implemented. Are you suggesting implementing only the required headers in a POSIX compliant manner? Not only the required headers but definitely not all utilities. Maybe a few useful ones for software development and systems programming. Take one example where I think `getopt(3)` isn't available on Windows: provide a complying implementation for that, but there's no reason to provide a `getopt(1)` implementation because a shell is certainly out-of-scope for a project like that.
Also, these stb libs are already widely used. Personally, I'd prefer a mature library that's difficult to read over lesser used ones that are formatted nicely.
Great, useful tips. Does anyone use same-line comments at all in C, or do they usually add comments on separate lines? I can see how if the editor has a smaller window everything becomes a lot more messy due to the line length.
Writing comments is good practice. I usually follow the following principles when writing comments: * Every function gets a comment explaining what the function does, what it expects from its parameters (e.g. if a pointer you pass as an argument is allowed to be NULL), what error conditions the function has and what it returns. Generally, the comment should be written such that you can reimplement the function just from looking at the comment. * If pieces of my source code are hard to understand, I add brief comments explaining what the next chunk of code does so you can follow easier. * Very importantly, comments should always explain *what* you do, not *how* you do it. So, for example the following code: for (i = sum = 0; i &lt; n; i++) sum += array[i]; is not commented as “loop over all entries in `array` and add each of them to `sum`.” but rather “compute the sum of `array` and store it in `sum`.” If you write short comments, write them like this: /* short comment */ // alternative short comment (I don't like this style) For longer comments there are multiple styles; I usually write them like this: /* * A longer comment with a lot of text. You may want to use this style * when writing comments over functions. Two blanks after a full stop * and keep the line length under 72 characters for readability. * * You can make paragraphs, too. */ Here is an [example](https://github.com/fuzxxl/dobutsu/blob/master/tbgenerate.c) of a well-commented source file written by me. I usually write the function comment before implementing the function. This makes things much easier as you are lead to think about what the function is going to do before writing any code. Implementing it is then quite easy.
This is what I needed, thanks.
Some of the comments are good, but others are not. I'll point out the ones that are not very useful. // Declare getline() return type and its arguments // Declare copy(); return type and its arguments I can read C code. I already know these are function declarations. What I want to know, and what these comments don't tell me, is what those functions *do* and how I should use their arguments. The comments on the variables are so-so. It's not bad, but in general if you name your variables well, you shouldn't need a comment to explain what it's for. If you renamed `len` to `curLen`, it's only 3 more characters but the name is basically self-documenting. Although calling it just `len` is pretty obvious, too. // Executes when the length is more than 0 Yes, I can read that that's what it does. No need to explain that one. The comment on the `if` statements, though, are fine, because they tell me at a high level *what* we're doing and *why*, as opposed to just restating the C code in English. It's a subtle but important distinction.
Personally I think a general overview comment is highly appreciated. I don't see them very often and can be very helpful. We can read c, so that isn't usually an issue, but the high level abstraction is usually rather difficult to understand from just source code. So if you have some abstraction layer, it can make reading your source much easier if you explain the purpose of the module, and any abstraction.
In my case, I used comments to [document what DNS records I support and where they are defined](https://github.com/spc476/SPCDNS/blob/master/src/dns.h#L107) and to describe some [tricky code](https://github.com/spc476/SPCDNS/blob/master/src/codec.c#L355). You don't need to document every line. 
Check https://computing.llnl.gov/tutorials/pthreads/
Where are you located?
Florida.
&gt; I don't agree so much here. I understand that annoyingly long function names like the ones you give above are frustrating, however the ability to guarantee users don't edit critical state, I.e. I have a stack with a void* tosp member pointing to the top of stack, and a user edits it to circumnavigate the API. I understand this is stupid, but so are many people... I would much rather have an opaque data structure that is accessed through short, clearly named functions, for example void libxyz_stk_length(struct stack* s, size_t size). For the small amount of cruft added visually, a lot of safety against mistakes is gained. Well my argument wasn't about long function names at all, let me clarify, it's something along the lines of "if you stop the user from doing something stupid, you're also probably stopping them from doing something clever". If users want to edit critical state, the consequences are theirs to deal with. By being transparent, you're making it clearer to your users that what's behind a function call is more expensive than trivial one-liners, and that what's not behind a function call costs exactly what they do with it. Also, your API is probably more composable and flexible when it is more transparent. Take an example where you have a vector implementation with `capacity` and `length`. The user wants to clear the vector without incurring a `realloc` or `free` because they plan to refill it. `vec.length = 0` is the clearest and cheapest implementation of that. Consider an opaque API, would you offer a `vec_set_length()` for performance reasons? Would that still `realloc` to keep a 1.5x or 2x ratio between capacity and length? That would defeat the purpose of the API's opacity. Let the user decide what's best for them, they will have to deal with their own bugs if they decide to do idiotic shit, not you.
I would if people actually went there. :)
Circular causality 
^Feelsbad
https://github.com/attractivechaos/klib
Hey please reach out to me: sam@breadwallet.com
How and where do you learn C advanced skills and tips when at work?
`strcpy` is undefined on overlapping strings though it traditionally works fine if the first byte of the target does not overlap with the source. To make sure that behaviour is not undefined, use `memmove` instead.
&gt; If the source isn't terminated, errors can occur, but that's not the fault of strcpy. So strcpy *doesn't* always terminates the destination. It terminates the destination *if and only if* the source is terminated. Compare that with strcat/strncat that *always* terminates the destination, no matter if the source was terminated or not. 
&gt; It terminates the destination if and only if the source is terminated. False. Whenever `strcpy` returns, the destination has been terminated. However, if the source has not been terminated the program may crash or more data may be copied to the destination than expected. A null terminator is appended in any case (if the program doesn't crash before). Behaviour is also undefined if source and destination overlap (which can unintentionally be the case if the source is unterminated) in which case the destination may technically be unterminated (due to undefined behaviour, anything can happen), but no such implementation is known to me and there doesn't seem to be a good reason to implement such behaviour.
That's not what is stated in strcpy manual (https://linux.die.net/man/3/strcpy for example). In my understanding, the destination is terminated *because* the source is terminated. In most cases you won't see the destination unterminated because if the source is unterminated, the program will crash *before* (buffer overrun). But that's just a *side-effect* of strcpy copying everything *up to* the terminator. Again compare that with strcat (https://linux.die.net/man/3/strcat) which states explicitly that it **adds** a terminating null byte. 
I have followed your advice and used memmove, it works nicely thanks. 
Sorry, I mistyped, I did use memmove. Sorry If i made your heart race.
Ah okay. *calms down.*
I typed the wrong function, I did use memmove in the end. Thanks for the advice though.
I feel like that's what he is doing with this post.
Best of luck my friend
If your comments describe the what, that's bad. That's what code does. If your comments describe the how (eg: "This is an implementation of the crc32 algorithm as described...",) That's good, since now people understand what the code is supposed to be doing. If your comments describe the "why", that can be good or bad, but usually deserves to be part of a design document instead. 
There's no such thing as a string in C. The source argument is a `char*` that should have a null byte at some point after it.
Yes which is why he said what he said
IIRC look at gettime() 
Declaring an extra integer has a nominal effect on the program. However, having confusing code reuses declared items is a bad habit and can lead to larger problems down the road. Legibility is one of the most important parts of coding.
Yours is fine (the `n = n` would likely be optimized away anyway), and the author's is fine. Note that I goofed on the `while` loop I originally presented. I've corrected it. The `n--` needed to not be in the `while` condition. That's one reason why some people frown upon the increment and decrement operators (`++` and `--`). 
You can use `alarm()` to get a signal after a specified duration. Here is one possible use case: #include &lt;signal.h&gt; #include &lt;time.h&gt; static volatile sig_atomic_t done_flag; void alarm_handler(int signo) { (void)signo; /* suppress warning about unused argument */ done_flag = 1; } void do_something_for_90_seconds() { done_flag = 0; signal(SIGALRM, alarm_handler); alarm(90); while (done_flag == 0) { /* do something */ } /* when the loop ends, you received an alarm */ }
Solid advice all around. Going with Doxygen style doc comments is always a good idea, since the format is widely recognized and easily understood, and it encourages you to be thorough until you reach the point where it's just habit. My nit picks: `\param[in]` is verbose. I would just say `\param`, since that's the normal case. The descriptions could be better. Format as exactly as possible. Be self-referential for clarity (explain that `maxline` is related to `line`, not just "the buffer"). Be explicit about both normal and abnormal cases. So I would instead write: /** * \brief Read a line from `stdin`. * * Read a line, including the trailing newline, from `stdin` into the * buffer pointed to by `line`. If the line is longer than `maxline`, * it will be truncated, but the entire line (up to and including the * trailing newline) will be read. If `stdin` returns `EOF` before a * trailing newline is reached, the line is written to `line` as * normal, and a courtesy trailing newline is appended. If `stdin` * reads `EOF` before any characters are read, an error is returned. * * \param[out] line The buffer to read the line into. Must be * non-null, otherwise the behavior is undefined. * \param[in] maxline The length of the buffer pointed to by `line`. * * \return The number of characters written to `line`, or `-1` * when `stdin` reads `EOF` before any characters are read. */ If that description looks like it's pretty long, that's because it is! Maybe that's okay, but maybe it's also a [code smell](https://en.wikipedia.org/wiki/Code_smell) that the function's behavior is too complex or non-obvious.
You seem to be confusing `strcpy` and `strncpy`. `strcpy`, by its implementation, will either (1) null-terminate `dest`, or (2) overrun the buffers of `src` and/or `dest`, which is undefined behavior and will do something in between "work perfectly anyway" and "crash your program" and "create an exploit for hackers to use". If you had said `strncpy`, you'd be correct that there are cases where it won't null-terminate `dest`. But that doesn't have to be because `src` doesn't contain a null terminator. Maybe `src` is correctly null-terminated, but you specified `n` smaller than that length.
&gt; There's no such thing as a string in C. Then what is `"` used for in C? &gt; The source argument is a char* that should have a null byte at some point after it. That's literally the definition of a string in C. It's why man pages like [strcpy(3)](https://linux.die.net/man/3/strcpy) say it copies a "string". It's also why those functions have undefined behavior if you pass NULL: NULL cannot be a pointer to a string in C, so by saying the function takes "a string" it implies that the parameter cannot be null.
`"Hello, World"` is syntactic sugar for `&amp;[0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x00]`. So when you do something like `char msg[] = "Hello, World";`, the above byte array is stuck somewhere in the executable, and `msg` is the address of that particular `'H'` character. *And that's it*. You can assign `msg` to be *anything you want*` (other than NULL, since that's the default "no value here" case), and it will assume that the memory at the far end is text, and to just go and go and go and go and go and pray that eventually some byte will be zero. That's not a string, that's a stream. A real, proper, actually useful String would be something like `struct String { size_t len; char text[0]; };`, or `struct String { size_t len; char* text; };` if you want the string control structure separated from the payload, because then you'd actually have useful information about the data over which you're operating. But C is badly designed, and so a "string" just means "a pointer somewhere into memory, from which we will run forever and hope we get told to stop." C, *the language*, has no concept of strings. The C compiler will interpret `"text literals"` as any other literal value, except the `""` wrapper means "even though I know exactly how long this text literal is, because I'm *looking right at it*, I'm not going to store that information but instead stick an 0x00 on the end so that the entire world, who all are on board the 'bounds checking is stupid, I'm sure I'll be told to stop' train, will stop." char text[] = "Hello, World"; // text is a char* size_t tlen = strlen(text); text[tlen] = ' '; // this is perfectly legal, because tlen is 12, but the compiler put a 13-byte chunk at memory address 'text' printf("%s", text); // prints "Hello, World " followed by who the hell knows what. C. Doesn't. Have. Strings. It has streams of data it really really hopes is finite. And this isn't just true of "strings", it's true of every collection. C's theory of what "strings" are is just "an infinite stream of data, except we break at the first zero-byte", while C's theory of what arrays are is just "an infinite stream of data." The compiler isn't completely moronic, though, because it will happily tell you how many elements are in an array ... if you remember to do `sizeof(arrayptr) / sizeof(arrayptr[0])`. It can do that, because the array is baked into the executable, and it knows how big it is. It will even do that for text literals, since it knows *their* size at compile time. But if you have text that isn't compiled into the executable, well, god help you. Everything that starts with `str` has *no* concept of data validation or bounds checking, and will simply run forever and we have to hope the data is going to play nice. Spoiler alert, *it doesn't*. That's how all sorts of bugs happen, like Heartbleed. C, the language, only knows of bounds checking on `struct`s. It doesn't bounds-check any data collection, which means that it doesn't have strings or arrays, it has streams of text that it calls strings, and streams of binary data it calls arrays. If these collections are statically allocated, the compiler can graciously give you the size of them, but if they're not, it's up to the code to decide to stop at some point, because the size *isn't* intrinsic to the data. Which is one reason that *no other language*, not even C++ has null terminated, non-length-aware, strings or arrays. Every language who has to deal with C's crap has methods to translate actual collections into these unbounded streams, and back, and everyone in C who works with either knows to track their damn length manually or crash. I'll be honest I'm as exceptionally passionate about this as I am because my job entails working with *non-null-terminated messages*. The byte `0x00` isn't a sentinel value in my arbitrary-length data, because it's a binary message. And the packet length isn't prefixed, either, my messaging protocol signals "last byte" out of band, so in order to make my client code not blow up when they try to read it, I get to throw away every `str*` function in `&lt;string.h&gt;` and ~~re~~implement the sane, safe, length-aware packet structure that C should have been using from the beginning, and that every other language I can think of does as part of their standard String and Array handling. C doesn't have strings. It has pointers to infinite data that, in cases where it assumes the data will be (a) ASCII and (b) eventually have a terminating sentinel value, people call "strings" incorrectly. Also, the "undefined behavior if you pass NULL" is only because MMU-protected systems will crash you if you try to deref address 0. There are plenty of systems where address 0 is perfectly valid to deref.
~~This looks good.~~ Uuuggg. Can't get it to compile on Windows. Thanks.
I'm going to join in on the "Yes, it's a bad practice" boat. Compilers are pretty good these days and they can optimize away variables if they decide that they are trivial. Let them do that. Creating a new variable because it keeps things easier to understand is free at best and likely cheap at worst (until you start getting into structs and massive arrays and stuff). Also, if I might, regarding this line: `for(i=n; i&gt;=1; i--)` Specifically. `i&gt;=1`. While that is 100% correct and proper way to do it, if you can get into the habit of it, put the constant on the left and the variable on the right. ie `1&lt;=i`. This is because you can't change the value of the constant and if you accidentally use a `=` instead of a `&gt;=` or `==` in a conditional the compiler will through an error rather than a somewhat difficult to find bug in code.
Checking it out. Thanks.
Unfortunately, *strlcpy* is nonportable. I believe the safest method that is still portable is char buf[BUFSIZE]; strncpy(buf, input, BUFSIZE-1); buf[BUFSIZE-1] = '\0'; as kludgy as that might be.
&gt; This is "less clear" (to the less experienced in C) due to the decrement operator in the printf statement Then: do { printf("%d\n", n); } while(--n); 
&gt;while (n) i dont get it. when the code stop ? how can the code stop ?
n becomes 0, while true becomes false.
It is a bad practice because the n=n bit is confusing. You can simply omit the declaration part of the for loop. for(; n &gt;= 1; n--) printf("%i",n); Would have worked. There's no need for the assignment to be there and it is confusing. Leaving the declaration out of the for loop is idiomatic. 
n is initialized before the loop, and decremented as the last part of the for expression
What if the user enters 0? Also, i should have tested &gt; 0, to allow for negative entry.
It's preferable to use a for loop when the number of iterations is known, since all the looping information is in the for statement. It's also easier for the compiler to optimize.
you're executing C in a bash terminal? C needs to be compiled. Or if you are compiling it, post your code.
You'll need to compile C code into an executable to be able to run it. If your file is 'a.c', you'd do something like: gcc a.c -o ./a and then to execute it run: ./a
It's a bit complicated to explain exactly why your program works. The one thing that is probably throwing you for a loop is that strlen() doesn't give the full length of a string. For example, strlen("hello") is 5, but there are SIX characters in "hello". This is because all strings in C are null terminated. The real string looks like this "hello\0". Hopefully a slightly less confusing version of your reverse function is the following: char *reverse(char *string) { int len = strlen(string); /* create result with same length of string */ char *result = (char*)malloc(sizeof(char) * len + 1); result[len] = '\0'; /* make sure it's null terminated */ len--; /* we already set the last char, so decriment len */ for (int i = 0; i &lt; len; i++) { result[i] = string[len - i]; } return result; }
You are forgetting about the null terminator of the strings. The arrays a,b should be of length l+1 to account for it. You can work without NUL but then you can't use the string functions as they expect the args to end with NUL, if this isn't the case then the functions will happily read as much of the program memory as possible until '\0' is encountered. What happens is that in the i=strlen(s) iteration of the loop l is 0, and b[i] gets assigned to a[l-1]=a[-1] which coincidentally is 0 therefore b is well terminated and the last strcpy works. The program has a number of other issues: please don't use strlen in the exit condition of the for as the length gets recalculated each time. This makes the program O(n^(2)) where n is the length of str ! Use l instead because you know l=strlen(s). Try to think of an in place string reverse function because the string could be allocated dynamically and occupy far more space than the stack allows.
hahaha true 
I'm connecting to it through putty and it's a bitch to go back and forth between different methods and I hate having to use the arrow keys to scroll through big ass projects with hundreds of lines of code and debugging can be really annoying.
won't you have a problem with len-i, for when i = 0?
Visual studio is probably as good as you're going to get, but it's windows only. It puts eclipse to shame. There's a really full featured version available free for non-commercial use as well. 
Does it cost $$? If so how much?
I usually use CLion. It's one of the best C/C++ IDEs out there. And since you're a student, you get it for free! :D Otherwise I'd just use Codeblocks. Not great, but not bad either and it's pretty simple to use.
Whoops, left out a word there. The non commercial version is free. https://www.visualstudio.com/vs/community/ . For the commercial use version, it'll run you $499. 
Good thing I asked then since it seems like he's misinformed.
sweet thanks!
I would prefer this while (n) printf("%d\n", n--); edit: Because it doesn't clutter. I find cluttered code harder to read than code that uses "advanced" tricks.
sh + vi + make
I'll put a vote in for XCODE although I'm growing more and more tired of apple. Clang is incredibly solid though and since I always cross checked everything on Linux, I know from the start that I am compatible with 2 out of the 3 big platforms. XCODE is wonderful for debugging, and handles threads decently, although I've yet to understand most of its built in stuff for alternative debugging modes (called instruments or something). Regardless, if you have a mac, use Xcode. Otherwise, use something else. I'd kinda lean towards Codeblocks or Eclipse because they both have powerful debuggers and will never cost you anything... and they are cross platform compatible. The both work on all Windows, Linux, and Macs and are really the only big ones that are available and are completely free (maybe there are others?) unless you want to get into VIM or EMACS, which I have found much harder to use. That doesn't mean they aren't powerful though, it just means you have to invest a lot into them to get out the same thing out as you'd get from Xcode or some other IDE that you can jump right into without much of a learning curve. 
if you have windows 10 it has an included linux bash just enable developer tools and enable in features 
You just blew my mind with all these different options! I know some basic ones, but I just never considered going a step further. Definitely doing this soon!
Each line is arbitrarily long, a solution would be to keep a dynamically allocated buffer that increases its capacity using realloc. #define LNINCR 128 char *freadln(FILE *f){ char *ln=NULL; unsigned i=0,sz=0; for(int c; (c=fgetc(f))!=EOF ; ln[i++]=c){ if((i+1)&gt;sz){ char *tmp=realloc(ln,sz+=LNINCR); if(!tmp){perror("malloc error");break;} ln=tmp; } if(c=='\n') break; } if(!ln) return NULL; ln[i]='\0'; return realloc(ln,i+1); } This solves half the problem because you need to store all those lines somewhere. Again, you don't know how many lines of input there are (there could 2, or 3, or several thousands) so you must have a vector that can increase in size when it's filled up to capacity. The function that you need to write for this is very similar to that above but instead of getting chars from the file you get lines with `freadln` above until one of them is NULL and store them.
&gt; How so? I find it easier to debug in a bash shell with gcc and gdb rather than using an IDE. As a devout cli and vim user even I acknowledge that an IDE (or visual debugger) is far superior to using the command line. Everything is visually available to you, whereas in gdb (or lldb) you need to be fairly capable to know where you and the context of a file. Of course, a visual debugger might not always be available.
thanks i think that actually helps me quit a bit
Thanks for the in-depth reply! Your consideration for the other areas of my program were very helpful. Using strlen() as my for loop's termination condition was a pretty slow idea.
 The original file has lines of Text? Yes. What are the "new lines'", where do they come from? In the file are information, these are stored seperately in each line. What does "saving them in another string" mean? appending them to the original file? I want to store each line in its own string. "splitting string up": splitting the strings from the original file? splitting the original text at each `\n'? As i have understood if i use the fgets function i have the whole file in one string not sure if i understood that correctly though. "saving them in a new file"? how/what do you want to save? how do you keep your strings separated from each other in the new file? I actually just want to store them in a string and do some operations with them, i dont really have a problem with that but i am not sure how to get the information to a form in which i can work with them.
But what if the user enters 0 or a number less than zero?
Integers. Here are some of the examples I am supposed to run. http://www.filedropper.com/input-poly-1 http://www.filedropper.com/input-poly-6 I am interested on how to use those functions, since I didn't get many examples in my class and it isn't easy to navigate online through the ones I find on forums, since english isn't my first language. Could you please help show me how to use them here? It would make things so much easier for me 
It's hard to say for sure, but looking quickly at a hex dump of that first file, it looks like you're storing things as 16-bit little-endian integers. Let's say you have some integer variable `x` that you want to store in a file. There are two things you have to worry about before writing it: the size (making sure it's exactly 16 bits in size) and the endianness (making sure it's little-endian). Here's some example code to write it to a file: FILE *f; // the variable f is already opened for writing int x; // the integer variable x is going to be written to the file uint16_t x_output = htole16(x); fwrite(f, sizeof x, 1, &amp;x); The `htole16` function, read "convert host representation to 16-bit little-endian" (which is not standard C, but supported on most modern Unix-like operating systems. Your professor may have told you to use a different function) will ensure that the data is formatted as little-endian. You use a `uint16_t` data type to ensure that the data written is exactly 16 bits in size. The `fwrite` function then writes it to disk. To read it you do something similar, in reverse order: uint16_t x_input; fread(f, sizeof x_input, 1, &amp;x_input); int x = le16toh(x_input); The `le16toh` function, read "convert 16-bit little endian to host-representation" is the counterpart to `htole16`. I haven't included any code for error-checking. Let me know if that makes sense at all.
To read a byte from a binary file, use `getc()`. To read a block of bytes, use `fread()`.
Wow. Enforcing anything is pretty stupid, especially at the college level where students should instead be encouraged to try out and use what they like. I use various tools depending on the size of the project and/or my mood - Vim, Emacs, Eclipse CDT, Visual Studio (great if you're on Windows) etc. I do agree with one of the suggestions made here - Clang is far superior to gcc in terms of error messages. One thing though - learning anything outside your comfort zone is bound to be hard at first, but it's an essential skill to pick up.
Using l as a variable name - my eyes hurt now.
&gt;you're saying I should convert the binary data to integer, store it in a variable When you say "convert the binary data to integer" it makes me think you're missing something about how this works. If you have a 16-bit integer in memory, whether it's a uint16_t on its own or it's part of a struct, it's stored in binary form. There are two formats it could be stored in - big-endian or little-endian, and which is used depends on your processor architecture. Big-endian will have the most-significant byte first. The number 0xff00 will be stored as 0xff 0x00. On a little-endian system, it's the other way around and will be stored as 0x00 0xff. The only *conversion* to be done when reading or writing that data fro memory is the endianness correction described above. If you're writing code that needs to be portable across architectures, you need to do that conversion. The other thing to watch out for is when you're working with data structures, you need to be aware of packing. If you store a uint8_t and a uint32_t in one struct, in memory they may not be adjacent because it's inefficient for most processors to read data not aligned on word boundaries. Again, if you're just reading and writing from the same program and nothing else needs to work with the file and you don't need it to be portable, you can just read and write straight out of memory, albeit with some wasted space. You can control packing with compiler-specific #pragmas. If you're unsure of how all this works, I recommend spending some time stepping through your program with a debugger and inspecting variables in memory so you can see how they're stored.
there is nothing that the compiler did wrong. There is nothing wrong with an assignment in a conditional and there are plenty of reasons to do it.
As well as being a low-effort post to something you didn't make, this site is already very popular and shows up near the beginning of Google search results, meaning that lots of people already know about it. 
http://vim-adventures.com/ Good resource for learning vim.
If you're modifying the string to reverse, why not do it totally in place? You don't need any extra space for this (apart from 2 or 3 local variables)
&gt; As i have understood if i use the fgets function i have the whole file in one string not sure if i understood that correctly though. No, `fgets()` stops at each newline (providing it can reach it). The problem with unknown length lines, is that `fgets()` only reads at most as many characters as you tell it to. It stop early if it encounters a newline, but in the opposite case, it does not read further than you told it to (because it doesn't reallocate the buffer you told it to use, and would make it overflow if it would read more characters). So it is only suitable when you know the maximum length of every line. `fread()` will allow you to get the whole file in one block. It does not interpret the data.
It's a crackme. You need to find out what string it accepts as a correct password. Have fun!
For your problem, a *word* is a series of *non-whitespace characters* delimited by *whitespace characters.* You can easily recognize the beginning of a word because the previous character has been a whitespace character (or you are at the beginning of the input) but the current character isn't. By counting the number of word-beginnings, you can easily compute the amount of words. If you need further help, please ask.
In a while loop, OK. But as an exit condition in a for loop, not so. Online GCC produces a warning: `source_file.c:7:3: warning: suggest parentheses around assignment used as truth value [-Wparentheses] for (i=0; i=1; i++) `
How about two build targets? The first one is a short main() that just printf's the size, the second one is your actual project.
Unfortunately, printf is not available: this is an embedded system. Thanks though.
When you store a negative number in an unsigned integer, the number is reduced by repeatedly adding one more than the largest possible integer until you reach something in range. For example, on a typical 16 bit system the largest 16 bit integer is 65535, so when converting the number -123456 to an unsigned integer, the following reduction happens: -123456 + 65536 = -57920 -57920 + 65536 = 7616 So the number actually stored is 7616. This may sound arbitrary but it makes a lot of sense when observing the binary representation. Basically, all bits above the 16th bit are thrown away. -123456 is -0x1E240 in hexadecimal and 0xFFFE1DC0 as a 32 bit two's complement number. If we throw away the highest 16 bit we are left with 0x1DC0 which is just 7616.
You already receive input with the `getchar()` call. The `fgets()` call reads the current line to the end (including any possible slashes). Note that you receive any character of input only once, so if you read the line with `fgets()`, `getchar()` returns the first character of the next line. I recommend you to remove the `fgets()` call. Instead, count lines by comparing the character you just got to `\n` (the line terminator) and the increment `totalLines`. Instead of terminating on `/`, consider terminating on end of input, which (on Linux/UNIX) is sent to your program when the user types Ctrl+D or Ctrl+Z on Windows. In this case, `getchar()` returns the special value `EOF`.
Always happy to help.
There are many passwords to "solve" this. The first (smallest) is: **8114** Password: 8114 Password OK :) The flag follows: MAYTHEFORCEBEWITHYOUYOUNGPADAWAN Also 8122 8178 8218 8242 8266 8274 8338 8346 8354 8362 8482 8586 8594 8698 9138 9146 9154 9162 9226 9234 9258 9314 9322 9378 9498 9682 9786 9794 18186 ... ADDED: Describing method... Use the code against itself. Comment out the `exit` calls in `s`. Comment out the `Bad Password` messages (there will be too many!). Comment out the `scanf` and throw an endless loop around the `s(i)` call in `main`, brute-forcing through valid password space, using the `i` buffer each time. What's that string space? Reading the logic in `s`, you can conclude a valid password is at least 4 characters long and contains only digits `1`..`9` inclusive. No zeros or anything else (thanks to `atoi`). So that's easy to generate and `sprintf` or otherwise render the iterator of the endless `int` loop into `char i[]`. Heck, the author of the code left us an `int idx`, unused, right there. As if they wanted it brute-force cracked. ;-)
When working on my own projects I usually create a bunch of smaller projects that work out the details of things I'm not sure about. Then I write the project. Then I write more smaller projects. etc. It's usually true that the functional pieces are fairly obvious. What's not obvious is the best way to implement these pieces, both in terms of interfaces and implementation. And on that front I generally (when writing in C in particular) have a "Divide and Conquer" strategy, where I often break down the tasks into very simple routines, with reusability a nearly ever-present goal. Unlike FUZxxl I usually start writing the implementation file first. The .h isn't really an afterthought, but usually the implementation has been written before I copy the routine declaration over. One way this is advantageous is that data hiding is more natural when things are written in the .c first -- structure definitions should remain in the .c file unless there's a compelling reason not to leave them there. K, I've blabbed enough. Not sure if there's anything useful there, but I've been writing C code professionally for over 20 years, so I must have learned something... 
FWIW I don't think I've ever written C in an IDE. I was in a very similar situation in college. I had not used anything but Windows at that point in my life and the professor really pushed us to use vim but didn't require it or anything, and gave us the option of working in the building directly on the Linux cluster, or using Putty from a Windows machine. I was hoping to learn something so I installed Ubuntu as a dual boot, and forced myself to use vim. It was painful for the first month. By the end of the second, it was actually fun. By the end of the semester, I had learned so much about how an OS works (just from using a Linux environment) and I could write code faster and more elegantly that I'd ever come close to before that. Give it a shot for your first project and if you really don't see the merits, it's all good at least you tried something new. Also saw you're using Putty. That's really not fun and almost turned me off to the whole thing. Install Linux and write all your code locally and then learn to use sftp and ssh and make sure it compiles and behaves as expected on whatever Linux server your professor will be testing on. There are a lot of really cool auto complete, file viewer, syntax highlighting, and a ton more plugins available for vim. You can essentially build your own IDE and know exactly how everything is setup, and that's a really great feeling. 
The responses you're getting here are good. But why don't you share a small, compiling example with us that confuses you? Then we can talk in specifics.
Unsigned types use modulo arithmetic, where attempting to assign a value to an unsigned type actually sets it to that value mod 2^n, where n is the number of bits in the type. For example, if `unsigned short` is 16 bits, `(unsigned short)-3 == 65533`, `(unsigned short)70000 == 4464`, `(unsigned short)42 == 42`, and so on.
Had your same question some months ago. [This](http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/create.html) is how I learned about fork. 
Its a personal choice, try it out on live mode, see if it still breaks for you :)
Probably? If you want a reasonable environment to use C in, you're either going to need to be using an emulation environment (MinGW, Cygwin) or you're going to be using a UNIX-like environment, period (unless we're counting niche systems like Plan 9.) One option you may want to consider is Windows Subsystem for Linux if you're signed up for the Microsoft program that lets you use preview builds: it adds support for Linux binaries to Windows and installs Ubuntu onto your system to use 'natively' from Windows, although it doesn't actually interact very well with the rest of the system.
I believe that's exactly what C++ does under the hood. But you have to be careful to keep the structs in synch or you'll run into issues. Also take a look into GObject, it's a library implementing OO in plain C.
You can put a TreeNode as the first field of NewTreeNode so it literally starts with a TreeNode and can be cast to one or you can use a pointer to the member to avoid the cast (GObject, amongst other things, works like this). This avoids the need to manually keep them in sync and makes the inheritance relationship clear in the code.
That's a complicated subject, but in a nutshell, POSIX does exactly that (with `struct addrinfo`) so it should be legal. People expect this to be legal so I expect the standard to not change in this regard.
X11 does the same with its event structs. All different event types are packed into a union, where they all share the same initial elements. Among which is the event type, so you can find out which specific event struct you should access. See [here](https://tronche.com/gui/x/xlib/events/structures.html).
So? Where are you stuck?
The "correct" way to do this (absolutely guaranteed to work) is to make the base struct a member of the derived struct explicitly: struct NewTreeNode { struct TreeNode base; void *extra_data; int *ptr; }; This has the side-effect that you must say, e.g., `n-&gt;base.l` instead of just `n-&gt;l`, which may be annoying to you. You can get around that with a fancy use of anonymous unions, but it's probably not worth it. In any case, even if you do it the way you're doing it, you should be fine. It's not guaranteed by the C standard, but realistically every compiler is going to support it.
UEFI/BIOS stuff
As other people have already pointed out, without using unions, this is undefined behavior. That being said, it's not an unreasonable thing to do. As a further precaution you could add static asserts (or regular asserts) such as: _Static_assert(offsetof(struct NewTreeNode, k) == offsetof(struct TreeNode, k), "Unsafe to cast between TreeNode* and NewTreeNode*."); Also, if you're not already familiar with it, you should read up type-generic macros (assuming you're able to use C11). You can use it to get compile-time polymorphism (think function overloading) which may be helpful an alternative, or in addition to, what you're contemplating. Edit: as a further precaution, you can even check field sizes in addition to offsets. E.g. #define fieldsizeof(t, d) (sizeof(((t *)0)-&gt;d)) _Static_assert(fieldsizeof(struct NewTreeNode, k) == fieldsizeof(struct TreeNode, k), "Unsafe to cast between TreeNode* and NewTreeNode*.");
I work for a chip design company... one of the things I work on is SoC boot ROMs. It's challenging but tons of fun... lots of having to dig into Verilog/VHDL (and sometimes doing a bit of coding there) as I'm writing the ROM code while the hardware is still being developed. I get to cover various areas, such as system init and control, boot interface device drivers (both basic (eg. SPI) and more complex interfaces (eg. USB)), crypto, and fault-injection and power-analysis countermeasures. Plus tons and tons of testing in simulation. Patching the code after release costs a fair bit of money, so there's no room for error!
I would agree. I feel like there probably is some leeway for the compiler to mess this up because the `struct`s simply contain the same members at the top. They could probably decide (for whatever reason) to pad the headers of the two `struct`s differently and get away with it. But that said, you're absolutely right that other standards like POSIX already assume this works and it's safe to assume it will stay that way. That said, he can essentially 'ensure' that this will work by extrapolating the common part out into a `struct`, and then placing a member of that `struct` into both of the other `struct`s. This also obviously has the other advantage of reducing code duplication, which will become a big problem if you want to add a few members to that header. And then you can go from there and take advantage of things like `container_of` to make the casting to and from each type easier and safer (And `container_of` allows you to do this with members which are not located at the top of your `struct`, making it much more flexible).
Hey, this looks interesting. How does it compare to things like lint, how much manual labor or analysis does it require to be useful, and how does it fit in an automated build and test system?
Much work as you need to annotate everything but it pays off; at the end you have a definite proof of correctness.
Yes this is going to work unless the structures have some different packing/alignment around them. it's done throughout the linux kernel and used in standard interfaces.
Yes. In addition to the examples in the other comments, check out [libuv](http://libuv.org/). It makes extensive use of this technique.
Being that these structs are different lengths, I would be worried about how you allocate and free instances. If, for instance, you tried to use a free on an array of TreeNodes for an array of NewTreeNodes, you'd have a size mismatch that might cause a seg fault on future reads/writes or have incorrect alignment and wrong values. In your case, wrong values mean bad pointers. Another example: Lets say you declare a struct of NewTreeNodes as 'struct TreeNodes temp_nodes [16]' in a function (contiguous and on the stack), and then attempt to use a function with NewTreeNode * in the parameter list on one of the elements of that array. Once you've passed the first element, you'll be referencing something with bad alignment and it won't work correctly. write_data(struct NewTreeNode * a_node, int * val) { *(int *)a_node-&gt;data = *val; } void temp_fn() { struct TreeNode temp_nodes[16]; int temp_data = 42; write_data((struct NewTreeNode *)(temp_nodes + 15), &amp;temp_data);// you'd overwrite past the end of temp_nodes here ... } To avoid this, you'd have to be sure your function only took a void * and you had either a parameter that specified what type it was, or there was something in the struct that had it. Another way is two separate functions, but then this kind of defeats the purpose of polymorphism. The other suggestions here to use C11 macros to verify casting are new to me, and look like the right way to go, especially if you cannot modify your API's existing functionality/structure size (It seems like this is why you're attempting this). Of course, a true linked list wouldn't care that much since each node would have a separate place in the heap (never use on the stack), but if you wanted to optimize this implementation for CPU caches and had several nodes in contiguous memory (I believe std::vector does this), you'd be either fragmenting memory by treating each node as a bigger version of itself, or you'd be incorrectly looking at what you thought were contiguous structs. What this means is that you'd have to be meticulously careful about how you handled them, and if it were me, I'd just modify TreeNode to include the additional pointers so that I don't have to dance around possible crashes that I've hidden from the compiler, or I'd use the NewTreeNode specifically for the places it is needed. After all, if you care about the two additional word-lengths in your struct because memory is precious, keep TreeNode the way it is for where it is best suited and use another where it is better suited. 
I build kernel middleware for satellites. Right now, that's just a very small networking stack.
Ah. I'm restricted to C99 for work, and apparently those started in GNU99
Can you please copy the questions into your post in case your link goes down?
0. Yes 1. The mutex is locked when the call to pthread_cond_wait returns which means the described scenario can't happen. 2. I guess g shouldn't call pthread_cond_wait in this case. Why wait for something which seems to be available already?
I think your 2. is referring to something else. The call to pthread_cond_wait returns not only after pthread_cond_signal but after the signal and the unlocking of the mutex right? When the pthread_cond_wait returns, that still takes time. In that interval, we could have locked again somewhere else. Why is it not possible for pthread_cond_signal to be reached by thread A in function f before pthread_cond_wait is reached by another thread B in a different function g if they are parallel? We may lock, pthread_cond_signal, and unlock in f before we get to locking in g right? 3. Is there a good way to parallelize three tasks where the first starts after the second reaches a certain point, and the second starts after the third reaches a certain point?
http://www.drdobbs.com/object-oriented-programming-in-c/184402190
You are probably right, and according to the document you linked: &gt; The Pthreads library is permitted to issue spurious wake ups to a waiting thread without violating the standard. But I can't find that information in the Linux man page.
No. A type with the value 0 is not guaranteed to have all bits set to zero. Check *6.2.6.2 : Integer types* in the C standard. The only exception is *signed* and *unsigned char*; there are no guarantees for all the other data types (including a plain *char*). For an example of an architecture where this is true, check out the [Burroughs large systems B6500](https://en.wikipedia.org/wiki/Burroughs_large_systems) from the late sixties; it had 51-bit integers where the last few bits were used as flags. 
&gt; Unless you are very particular, the compiler has free reign to &gt; reorder the memory layout of fields within structs. So, no, it's not &gt; safe to cast like that. This is incorrect. 
It came from Plan 9 originally.
I basically write them down into an emacs org-mode file. It allows keeping a good structure, makes for a good Todo list and allows me to link to source.
&gt; both in the middle of a call to fork() thanks!
[6.7.2.1p13](http://port70.net/~nsz/c/c99/n1256.html#6.7.2.1p13) guarantees it
I'm learning as our main data processing for the earth observation satellite I work with is in C. 
Thanks!
No, unfortunately it is a proprietory library 
Firmware for managed switches.
Basic outline to get you started: Get a string as input. For each word in the string { Increase the word count by one. For each letter in the word { If that letter is an 'e' { Increase the letter 'e' count for that word by one. } } } Print out the word count. For each word { Print out the letter 'e' count for that word. }
Probably there are some more sophisticated methods, but I think something like this should work: char *str = "This is one sentence\0"; size_t len = strlen(str) + 1; int all_e = 0, word_e = 0; int word_count = 0; for (int i = 0; i &lt; len; i++) { if (str[i] == 'e') { word_e++; all_e++; } else if (str[i] == ' ' || str[i] == '\0') { printf("%d. word has %d e\n", ++word_count, word_e); word_e = 0; } } printf("There are %d words in this sentence\n", word_count); 1. word has 0 e 2. word has 0 e 3. word has 1 e 4. word has 3 e There are 4 words in this sentence 
Can I see a copy of the code edits you did? I can not seem to get mine to work the same way.
Student here. Choosing C sometimes because I know my teacher won't understand (he's *that* guy).
Yeah, C is the wrong language for that. Try C#. Also for programming questions always show what you have done so far and indicate where exactly you need help. This looks suspiciously like one of those crazy 20$ tasks from UpWork...
Yeah this is clearly someone wanting a tool developed.
Try using VB
How do you get graded then ?
This. OP imagine an array of 1000 elements, are you going to pass all 1000 elements to a function? That's not efficient because you need that much extra space in your stack. So instead arrays are always passed by reference rather than pass by value. This is why it looks like it's a global variable, but it's not. 
Woops wrong subreddit, I'm retarded
haha it isn't, i'm an intern and this was one of the task i was assigned to do
Try to add a line break to the end of your string. Output is only flushed on line break, which might be different in debug mode.
It appears that you have been shadow banned. Please talk to the reddit admins to rectify this issue.
Thanks! I'll give VS a look, then! :) I'm very new to programming and am still in the introductory CS50 course so I don't have a deep understanding of a lot of things. I simply assumed C# was in the same "family" of C/C++ even though I don't exactly know how they relate.. Thanks for clarifying that for me, though... :)
I can't see anything wrong or suspicious. NB: `sizeof(char)` is 1 by definition so you could remove it in your `malloc()` but you may prefer to be explicit.
2 aspects: 1. When he copy pasted it it worked 2. Every single line is commented like this: `frame.setVisible(true); // set frame visibility to true` Oh and btw, he can't do shit.
using variadic function is an odd choice. if the strings are constants, you can join them by hand ``` "foo" "/" "bar" "/" "far" ``` if they are dynamic, then you often do not know how many of them there are. Using a 0 terminated array of string pointers would make more sense to me, but i don't know your use-case.
You should be doing this in VBA.
Try checking the log file of any anti virus program that you may be running. It's not unheard of, for them to silently cancel small binaries as false positives.
 bar((char *[]){"hello", "world"}); It's called a compound literal and it was introduced in C99. 
I am new to C, but it seems very clean and functional. Although it is pretty clear you could add more comments and maybe a context.
 int main() { char i[1024]; int idx = 1110; // 1 less than the first possibly valid password while (++idx) { sprintf(i, "%d", idx); } } Then replace the three `printf`s for `Bad Password` with `return(1)`. And make this replacement for the `Password OK` conditional: if(cur_val == 132) { printf("%s\n", in); //printf("Password OK :)\n"); x(); //exit(0); return(1); } Also, function `s` should now return `int` instead of `void`. That's the gist of it. Run it and you'll get a fuckton of passwords on `stdout`. Press CTRL-C when you've had enough. Good luck.
Just a few things that I would do differently for the first function: (This is more a matter of tast) Use spaces instead of tabs. While there's nothing wrong with tabs, I believe most developers prefer spaces. E.g. in python spaces are recommended over tabs (i.e. 4 spaces for 1 tab). Currently, the indentation level is pretty high with tabs (at least on githubs viewer). But that leaves less space for the code itself. Then the indentation for the variable arguments is quite high too. Also I think it's much more readable like this (added new line to visibly separate the function declaration from its body): size_t compute_joined_length( const char* separator, const char* first, va_list argp ) { size_t seplen = strlen(separator); Then you can use a little C trick to save some lines of code, i.e. you can 'abuse' the fact that assignments are also expressions that evaluate to the value that is assign to its target: const char* next; while ((next = va_arg(argp, const char*)) != NULL) { length += seplen + strlen(next); // next = va_arg(argp, const char*); -&gt; no longer necessary } Now there is one more transformation I care about. Whenever you use a comparison operator (==, &lt;=, &gt;=, !=) there is the danger to forget the first character so that each comparison operator becomes = (assignment). That's why some coders prefer to always put a constant value on the left instead of right. This way the compiler will find the mistake easily: while (next != NULL) { //... could be mistyped to: while (next = NULL) { // and the compiler won't complain (might give a warning about misleading code). So if you write it like this: while (NULL != next) { // ... and you mistype it, it becomes: while (NULL = next) { // ... and now the compiler is forced to complain. Then the loop becomes: const char* next; while (NULL != (next = va_arg(argp, const char*))) { length += seplen + strlen(next); } At this point you can also 'elegantly' skip the brackets of the while loop, because your loop body is only one statement (length += ...) const char* next; while (NULL != (next = va_arg(argp, const char*))) length += seplen + strlen(next); But that's also a matter of taste and some people prefer to use brackets, because it's less error prone and will lead to less confusion for new developers -&gt; better maintainability. Then you can also declare 'seplen' as const, just as you have done with next: const size_t seplen = strlen(separator); size_t length = strlen(first); const char* next; This is good practice, because it prevents you from accidentally overwriting your variables. Particularly, variable that you don't expect to change are good candidates for the const keyword and lenghts of strings you don't want to modify fall into that category (in my opinion). So the final version would be: size_t compute_joined_length( const char* separator, const char* first, va_list argp ) { const size_t seplen = strlen(separator); size_t length = strlen(first); const char* next; while (NULL != (next = va_arg(argp, const char*))) { length += seplen + strlen(next); } return length; } Also, I think the 'static' keyword shouldn't be there.
What you want to do is called "web scraping". You will need to know a bit of HTML. As for selecting images with a specific color, you probably want some image processing library. Using C seems like a lot of work in this case. Consider using Bash, Python or anything higher level.
I like the idea, but a single exit point seems to me, to only work with more simple functions. If you are doing multiple things that can have failures, you would have different cleanup situations. So either you'd have to track the state, or have multiple exits. For example a function to open a file and copy the contents to a buffer. If the file fails to open, you don't close the file. If the file opens, but the allocation fails, you need to close the file. I generally prefer writing fail fast methods, where I check preconditions first and exit early. But I do write scripts to consecutively fail allocations in a path, to make sure the cleanup goes as it's supposed to. But they're rather complex scripts of changing the source code, recompiling, running valgrind and scanning the output. Of course you can write simpler functions, and I know some people prefer that. But when writing c, testing all the ways to fail is cumbersome. And I think once you've tested all your post conditions, it's nice to get some mileage out of a known safe state.
Use the strtoll/strtod functions and check str_end to see if the entire string was parsed.
That's because `strtod` makes the the second pointer point to somewhere into the string pointed to by the first pointer. Thus no memory allocation is needed.
Presumably, your image parameter already has allocated pixels, so when you do `*plain = temp` you've overwritten those pointers and leaked the old memory. Since you then free the pixels that are now a part of your output parameter, you've not only leaked memory but your output is garbage. In other words, you are freeing the new memory, rather than freeing the old memory before replacing it which is what you want to do. You also don't try to free the pixels array itself whatsoever. P.S. it would be simpler and much more efficient to allocate images as one chunk of memory unless you have a reason to allocate each row separately.
No real difference. You're still freeing the *new* data, then setting the output to garbage pointers.
I imagine your pixel is bigger than 8 bytes. A malloc (sizeof (struct pixel)) will return an 8 byte address to a correctly sized pixel... aka a pointer to a pixel. All assuming you're on 64 bit system.
I am actually surprised this doesn't produce any segfaults. sizeof(Pixel*) gives you the size of a pointer to a structure called Pixel, so you are allocating space that would be enough for pointers, not for the pixel structure itself. Also, as noted down below, you are freeing the memory you want to return and are producing a memory leak
FWIW, my [man page](https://linux.die.net/man/3/strtod) tells me that on error endptr is set to str, so you can also if (endptr == str) { printf("not a valid number\n"); } This is useful when there is data after the number, e.g. another number, a descriptive string, or even whitespace! Edit: I wasn't entirely clear there. If the number *is* valid, endptr will point to the first character in str after the number. If there is more stuff after the number, that is where you can start your parse back up to get that other number, descriptive string, etc.
Using a tool like valgrind might help you see where you're allocating memory, whether that memory is being freed, what isn't being freed, and what calls to free may be wrong (either the memory has already been freed, or it wasn't allocated). 
Okay, so the output for me (on a platform where `int` is 32 bits): -5 4294967291 This is expected. You declared an unsigned int and immediately assigned it a negative value. That sounds like it's a mistake, but C lets you do things that are weird because sometimes you intend to. No problem. What happened was you put the two's complement representation of `-5` into those 32 bits. Even though you declared `number` to be unsigned, really what you were doing was allocating 32 bits of local variable space and calling it `number` and storing ` 11111111111111111111111111111011` in it. So when you asked for those 32 bits called `number` to be printed as a *signed* int (with `%d`) ... I hope you got what you were expecting ... the signed value you assigned it. And when you asked for those 32 bits called `number` to be printed as an *unsigned* int (with `%u`) ... surely you didn't expect to see `-5`, so why is this confusing for you? What you're seeing is the bits stored for `-5` (two's complement) now rendered as if they were `unsigned`. In short, here's what you asked to be stored in those 32 bits you called `number`: 11111111111111111111111111111011 Same bits. You can interpret this bit pattern simultaneously as `(int)(-5)` **and** `(unsigned int)(4294967291)`.
Do you lose marks if you don't comment your code on every line even if it's obvious what is happening?
Also causes UB for out of range inputs
Why is this tagged NSFW?
no idea. i just want to make more people pay attention.
What are you working on? 
How do you implement C in web design? I've used JavaScript and jquery and things like that. I'm just starting to learn C, so I haven't done any GUI with it, just command line programs. Just curious 
No blog spam please.
For web sites? No. C from to back.
We don't use C for design. We use it for programming. We use it the same way amateurs use PHP except we're professionals.
Can you give an example of the input and output you would like?
* Learn [how virtual memory works](http://marek.vavrusa.com/c/memory/2015/02/20/memory/). * Learn how to read and write the assembly language for your current computer hardware (probably x86-64). Unfortunately I don't know of any good introductory resources for this. * Spend time studying the output of your C compiler to learn how C is implemented on your hardware, and how various C concepts map onto the hardware. You can ask the compiler for assembly output, or you can disassemble it (objdump, dumpbin, etc.). Once you've got a feel for this stuff, read and understand the [formal ABI specification](https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-secure.pdf) for your platform. * When studying compiler output, compile with different code generation options (position-independent, different optimization levels, SIMD options, etc.) and observe how they compare. * Learn the binary format for your preferred systems (e.g. [ELF](http://refspecs.linuxbase.org/elf/elf.pdf), [PE32+](https://www.microsoft.com/en-us/download/details.aspx?id=19509)) and how programs are loaded and linked. Learn how dynamic linking and ASLR work. * Learn [how a linker works](https://lwn.net/Articles/276782/). * Once you're much further along, learn how instructions are encoded for your preferred hardware. It's an integral part of obfuscation and reverse engineering. 
In pseudo-code: for each line y: for each row x: if the point (x,y) is inside the circle, print a '*' else print a ' ' print a '\n' to start a new line What part of this are you stuck on? Is your problem with C, or with math? 
do you maybe have any good resources?
Yup, "3.5E-2" will be accepted by strtod, for instance.
AFAIK, you have two options: * Use console functions from *windows.h*, specifically *SetCursorPos* * Use a portable library like ncurses, Windows version is named pdcurses. 
Many years ago, in the DOS era, there was an [ansi.sys](https://en.wikipedia.org/wiki/ANSI.SYS) that had to be loaded (in~~`autoexec.bat`? or was it `config.sys`?~~ [config.sys](https://en.wikipedia.org/wiki/CONFIG.SYS) ) to enable ANSI escape codes. This may be woefully outdated, but it might get you where you need to be. 
As a signature : typedef void SIGNATURE(void); SIGNATURE *f; 
for (unsigned int i = 0; i &lt; plain-&gt;height; i++) { free(plain-&gt;pixels[i]); } free(plain-&gt;pixels); solved all my problems. 
/r/dailyprogrammer has some good challenges.
I'd say that workaround is acceptable insofar as it gives you the desired result. It's not exactly too cheaty, but it's a super iffy hack. Think about what this macro really does: It replaces the string `value_answer` with the string `value_number*PI` in your source code before passing it on to the actual compiler. So getting rid of `value_answer` completely and just putting `value_number*PI` would have worked as well. The define is completely superfluous. It would be more instructive to figure out the original compiler error and how and why you managed to get 0 as an answer, because that will provide you with knowledge about essential fundamentals instead of phylosophising about coding style, which is a bit much to ask on the first day. A good way of getting help with that would be to chop the problematic program down to a minimal example that produces the error in question and then posting that code snippet in full, so people who are able to help don't have to guess at what you're actually doing. (Or put it in a pastebin with nice syntax highlighting and post a link to that, along with your question.) Once you get into the habit of putting your question into a proper form like that, you'll find that often the answer will become obvious or Google-able before you even hit 'submit' :) Btw., a better way to be lazy about writing out an approximation of π is to include [math.h](http://tigcc.ticalc.org/doc/timath.html#PI). P.S.: I see that while I wrote my comment, the post was downvoted a bit. If this was /r/Python, I'd instantly know what the problem is: This belongs in /r/learnpython instead! However, I'm not aware of an equivalent subreddit for C, so I can only provide the following advice for avoiding the wrath of those who know [K&amp;R](https://en.wikipedia.org/wiki/The_C_Programming_Language) back-to-front: Before you post, copy the error message into your favourite web search engine. Most of the time, a site such as StackOverflow will have good answers already.
I'm under the impression that you don't understand what you are trying to do. If you want to multiply a user inputted number by 3.141 your *solution* is just wrong. Split the problem in simpler subproblems and find solutions for each one, hint for the first subproblem: - How do I get user input in C or how do I read the user input in a C variable ?
Sorry, I just meant gdb included in most GNU environments 
Unfortunately I have no idea how you'd get started in assembly these days, especially x86-64 since all the introductory x86 materials are at least 15 years old. So I have nothing to recommend. Once you're fully bootstrapped, it becomes easy to learn from the reference documentation.
1. In line 273 you should probably write *blabla = bla, without "[60]", because bla[60] is a char, btw which doesn't exist. You need to assign the address. 2. Your function insert() returns new head, so when you call it you should write: head = insert(head,n); that's how you'll update your head if you don't use a pointer. 3. In function insert() you've forgotten to write head-&gt;prev=new_head; 2 and 3. destroy your linked list dramatically because when you "insert" new nodes you don't change your head, this will lead to memory leaks, which will probably be difficult to detect if you don't really understand what is going on, however valgrind will probably help you in this situation)
i understand having some inspiration can be helpful, but i've always found the best learning tasks to be ones that i was particularly interested in. for me that's mostly been games, but i think the idea of working on something that interests you personally helps.
Run the program in a debugger. It will show you the location of the fault. Or post a reduced testcase, not 500 lines of code. 
What's line 134?
main.c::134 precoAtual += f-&gt;vet[f-&gt;inicio].valorLance; I use to do the same some lines before. Couldn't figure why getting the error. PS: sorry for the not English code. precoAtual is a float for current price. It receives the initial price than her adding valorLance. f is a queue with a vet that is a pointer to a typedef'ED struct. ( you may find it on the other file). f-&gt;inicio says where the list reader is current in, its head actually. So I'm trying to get the valorLance field of the vector at position f-&gt;inicio that is the head of the queue f where have values in its vet vector. 
A function pointer can be stored like any other variable, contrary to a standard function. It can also be passed as an argument, a common example is changing the behaviour of a sort algorithm. It's probably best known for callbacks though, in which you can make functions invoke after some kind of event, like a mouse click.
Sorry for that. I just thought that this is a classical programming problem and it is important to every beginer in the programming community!! C is not only the pointers and the structures but the algorithms way of thinking and the way that you solve a problem!! When I was beginner I start from C! I learn only the commands because the most of the tutorials talks only how to emplement a if statment or how to create a matrix! And when i try to solve a problem or to create a program I leateraly couden't think anythink And this. With that video I thought that it is good Idea from the creator to focus on how to solve a problem in every programming language is focused on the process that solve a problem and not in the actual commands. And I believe it is inportant to have a little bit of this tutorials too! Again sorry for the inconvinience. Have a nice Day
So they want it to do it both ways? So both reverse the thing that was imputed in AND return the reversed string. Edit: no, thought about it more. Your reversing the input string when you shouldn't. Copy the input string to a new variable and reverse that. And return that. Don't touch the input string
The swap part of your reverse function isn't correct. Look up how to do a swap with a temporary. You're missing a step. Also, you should swap for n less than m, not str_length.
You have to allocate memory and build the reversed string in there, not modify the argument string. 
It lets you treat a function like a variable. Analogous to how we could use a `name` variable in `printf("Hello %s!\n", name)` to change what is said, we can use a function stored in a variable to change what is *done*.
For this assignment I'm only allowed to use stdio.h Library 
[Project Euler](https://projecteuler.net). Great exercises and experience-builder for any language.
Let G'(n)=G(n-1), plugging this in for G(n-2) gives: G(n)=aG(n-1)+bG'(n-1)+c G'(n)=G(n-1) Writing this in matrix form: | G'(n) | | 0 1 | | G'(n-1) | | 0 | | | = | | * | | + | | | G(n) | | b a | | G(n) | | c | As you see there is no 2D matrix whose power gives you that vector because of the translation with [0,c]. Translations are not linear transforms, however there is well known trick of increasing the matrix dimension so that translations too are modeled by a matrix multiplication. See [here](https://en.wikipedia.org/wiki/Translation_\(geometry\)#Matrix_representation). | G'(n) | | 0 1 0 | | G'(n-1)| | G(n) | = | b a c | * | G(n-1)| | 1 | | 0 0 1 | | 1 | Therefore from the above recursive relation it can be seen that the column vector of the n-th iteration is obtained by raising that 3D matrix to the n-th power and multiplying by the initial conditions vector. 
thank you! I found one. http://cs.lmu.edu/%7Eray/notes/nasmtutorial/ Is it okay?
Just adding to what the others pointed out. If you want to call a function from another code you can cast itvs address to a function pointer and call it. I use this pretty much for game hacking only.
Never learned a thing from him. He's my advanced class teacher. Just 3-4 months left... Edit: Actually I did learn that one can somehow pronounce thread like string. Never actually did it myself though. His mouth skills are over 900000.
Ok. Isn't this kind of like "GOTO" in BASIC? Which i was taught is very bad.
And, here's a very usable example: http://www.iitk.ac.in/LDP/LDP/lkmpg/2.4/html/c577.htm This is the way the Linux kernel handles (or handled -- I haven't been doing in-depth kernel stuff for many years) device drivers -- all the drivers expose a common API (read, write, etc), and then you explain how they are each implemented. Many years ago, this was considered such a useful pattern that people went out of their way to add this as a native capability to C: basically, can I declare a "Signature" that then different people implement but I get to treat them all the same algorithmically. And thus C++ was born.
Hi! I wrote this small piece of code http://ix.io/1QzX/c which is supposed to be the beginning of a std::vector-like using the C preprocessor. The functions are fine and work well but I don't understand how to use it in multiple files because it'll get multiple definitions of the same functions every-time I try to call the `DefineVector(foo)`. For example: * foo.h contains `DeclareVector(int)` * foo.c contains `DefineVector(int)` and * bar.h contains `DeclareVector(int)` * bar.c contains `DefineVector(int)` Compile output: http://ix.io/1QA0 Is there a way to avoid this issue, a bit like a #ifndef XX, #define XX etc? Thanks in advance!
usually when I see header guards, they look something like this: #ifndef _H_FOO #define _H_FOO ... #endif // _H_FOO with the actual header being the "..." The idea is that the preprocessor will only parse the header once because it defines the global variable _H_FOO, which is checked for every time it's parsed.
I studied the Linux drivers in my OS class last semester, that's still how it is done. Edit: more specifically, there's an array of structs with function pointers, that the kernel uses to deal with the inputs from devices. 
As you said, you can only have one call to `DefineVector`. You need to put it in its own `.c` file, or actually whereever you want, as long as you have only one call to it throughout your code. Then, you need to call `DeclareVector` whenever you want to use the vector in another file. You can also make a `.h` file with the call to `DeclareVector`, and then `#include` that `.h` whenever you want to use it. So, for example: foo_vector.h #ifndef FOO_VECTOR_H #define FOO_VECTOR_H DeclareVector(foo) #endif foo_vector.c #include "foo_vector.h" DefineVector(foo) Then, to use it: #include "foo_vector.h" int main() { foo_vector_some_function(); } It works just like anything else.
I think what's happening is that `foo.c` and `bar.c` are compiled separately, each declaring the same function. The linker can't recognize that they are supposed to be the same function, so is giving an error. Off of the top of my head, I can't think of a clean way to resolve this except to have `extern` declarations and one canonical implementation per type. 
Which `graphics.h` are you referring to? Regardless, I would suggest starting with a terminal-based game instead of adding the complexity of a GUI right away. Terminal I/O works well with turn-based games as you're describing. Then you can focus on the rules and gameplay first and add GUI once it plays as you want it to. Your code for game logic and data structures for turns, players, decks, etc. will be mostly (should be mostly) independent of terminal or GUI presentation. Suggestion: Find the source for an existing card game written in C (GitHub, etc.). Understand it, make some changes to it, screw around with it, and *then* start your own game. Good luck! TL;DR: `stdio.h` before `graphics.h`
Short answer: Yes FILE *fp makes fp a variable pointing to a structure of type FILE, and as a variable it can be passed along to different functions _as a pointer_. The function nextStep() should be defined as this: void nextStep(FILE *fp); 
I write POSIX drivers for my job, this is exactly how we register functions
 I'm not really sure which "graphics.h" im referring too. Basically I add "#include pg/graphics.h" to the project, and I add to install the library through a file the teacher provided. This was an exercise given by the teacher too practise and he said I'll be needing that library. I use Lubuntu operating system and in there I use "geany" to code. There's also this "program" (I guess) named PG graphics which I suppose is what will run the "graphics.h" coding. I'm still pretty much a begginer so I still strugle with the terminology. Apologize for that. And if I already have the code do you have any tips on how to implement that to the GUI (which I suppose is what gives the "graphics" to the game, like the image e provided"). I'm quite lost here 
I'm an engineering student so my math is at least decent! Thank you for the resource, I'll look into it. I really appreciate it.
Ah ok. So like in other langauges when you can next functions within functions, like: Update_Display(Current_Temp); Where Current_Temp could be a simple int returned from a "get the tempurature" function? But Current_Temp would merely be a pointer and Update_Display would handle the pointer instead of a regular int?
How widely supported is #pragma once?
You can't meaningfully read and write structs like that. If you write a pointer to disk, the only thing that is written is the pointer value (i.e. the address), not what is pointed to. If you try to read that back in a separate invocation of the program, you get a pointer that points to that address, but that address doesn't contain anything meaningful because you never put anything there. (Most likely it's an invalid address anyway.) This is all undefined behavior. 
 #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(int argc, char *argv[]) { int r; printf("Enter radius: "); if (scanf("%d", &amp;r) != 1) return 0; for (int y = -r; y &lt;= r; y++) { for (int x = -r; x &lt;= r; x++) putchar(sqrt((x*x) + (y*y)) &lt; r ? '*' : ' '); putchar('\n'); } } 
allocate memory for `ha' before reading into it :\^) try ha[256] or something similar
You don't need visual studio unless the professor wants you to turn in projects as a visual studio project. And unless you are doing windows programming. Mac will work just fine for c programming. Learn how to use a compiler and basic make files and your life will be way easier. Even just a basic text editor and the terminal will work for c programming. 
VS for C? Oh, I dislike that guy already.
This is the best way to do it. I have a similar vector implementation and I have something like "VECTOR_MAKE_H" and "VECTOR_MAKE_C" macros.
So how am I going to save all the data from the hash? I've been thinking on saving the content (Persons only) but then I lose the Hash meaning of encrypting the data.
C has no standard way of serializing data. So you need to write functions that serialize the data structures and then unserialize them. For example, to serialize your linked list, you might have to write name, ID, and an indicator (say, 0 or 1) for the next person pointer. For more complicated data structures, you need to figure out what metadata you need to save so you can recover the information fully when reading from the disk.
The question is, will the teacher test/grade your homework on VS ? If yes, my advice is to at least test your code with VS. The problem with VS is that it does not implement latest C standards (C99 is implemented for most part, C11 not so much) so by using a different compiler (on macOS you will use Clang) you risk to use something that simply won't work on your teacher's machine. Easiest approach is to install a Windows VM on your Mac. My advice is to test your C code with both VS and Clang, Clang has better errors and warnings messages and VS will ensure that your code will work on your teacher's computer. 
This. Best solution is to use the exact same setup as the instructor. I had issues in school with code using dirent.h that ran fine using Mingw on Windows but seg faulted on our Solaris server. I started doing all my assignments over SSH and my life got easier.
There is now a native version of Visual Studio available as a preview for Mac. It's basically cross-platform compatible with Windows (with some exceptions), but projects can be moved between both platforms without too much hassle. It's also substantially smaller than Windows Visual Studio, coming in at around 550-600 megs fully installed. The advantages of VS are that debugging is usually way simpler with all the language support already built in, rather than having to install a slew of plugins to get what you need. https://www.visualstudio.com/vs/visual-studio-mac/ Failing that, you can always use Atom and add a slew of plugins for linting, building, etc.
I thought you shouldn't really pass arrays as arguments. I think you should use pointer to char. https://lkml.org/lkml/2015/9/3/428
Your signature is fine since you're not specifying an array size. These 2 are equivalent: char s [] and char *s.
Thanks! that's the array size that caused the problem. And thanks for the suggesstion I'll be looking into valgrind.
is the preview version limited? do i have to pay for the full version?
he will grade based on the outputs that come from compiling it on Vim. VS was a way to make sure the output are always right.
 typedef struct { float x; float y; } coordinate; I think you could just create a struct like that and use it?
Your program's prompts don't match those in the screenshot you posted. I'd fix that first if the image is showing what is expected. Beyond that, what's the issue?
Vim is a text editor that has nothing to do with Visual Studio. Visual Studio is an IDE (text editor + compiler + debugger + ...). By testing your homework in VS I meant testing the homework with the C compiler from VS. The C compiler from VS is different from the C compiler you will use on Mac, different as in code that compiles and runs on Mac can fail to compile on Windows if you use the compiler from VS. 
`char argv [][]` is ill-formed, `char ** argv` and `char * argv []` are the legal versions
True. By "classic", i meant very old - like pre-iso old. I recall seeing the old form. 
well i am using Xcode on Mac and vim through terminal to double check outputs.
The preview version still needs work to bring it up to the same level as the Windows variant, yes, but everything works (it's based on the Xamarin IDE) and at the moment it's free. In addition, it can be used for making Mac, Linux, iOS and Android apps as well. Hopefully when it's fully released there'll be a community edition, the same as Windows VS.
&gt; but I started on C and I'd like to stay focused and not move around. So you're now limited to only writing C. Go learn some other languages. At least C++ as a babies first step in branching out, that has Qt.
Thank you for an actual answer. Everyone else on Reddit are just plain dickhead-ish. 
https://www.reddit.com/r/C_Programming/comments/5jrxrp/simple_gui/ Personally for Linux I like raw X11 
If you need some custom UI (without using native widgets) you may look into imgui or nuklear, both use opengl so might also work on Android. Nuklear is just one header file so it's easy to integrate into your build system.
GTK+ has a feature of defining the GUI in an XML file then loading that. The builder stuff. There is Glade to create those. Shame really you can't define gobject networks in general and that it's XML not YAML, but it is still good.
I'm learning to write stuff in gtk+ now and there is a really cool book (you can google it's name + "pdf download" and find it for free) called Foundations of Gtk+ Development that explains Gtk+ really well as far as I'm into it. Gtk+ is not just a gui toolkit, it also has it's own object system that if you don't realize how it works then that will make Gtk+ confusing. The book explains that pretty well I think. All the online tutorials are pretty brief for some one who wants everything explained a laid out in one place instead of having to search around. The book is on Gtk+2 instead of Gtk+3 though, but for me that didn't matter.
absolutely never go to the ##c irc channel then
If you are interested in graphics, you could learn opengl. It's not designed for easy GUI implementation, as it is a pretty low-level API, but it gives you a pretty good basis on graphics in general. It might seem a bit trivial, but after all, all low level programming is like this. Now as others mentioned, if you want to build a GUI you could use Gtk+ or Qt but you'll need C++ for that. There is also Allegro, which i used 3 years ago when i asked myself kind of what you are asking right now; how can i make anything graphics-related in C. I didn't built a GUI, but i made a small game from a tutorial, as well as a Sudoku.
What I mean is the XML builder stuff is for GTK were as really it could have been at the GObject level as it just saying "objects of these types", "setup like this", "connected like this". You then load the network and lookup the inputs and outputs by name. It not that big a deal, just move some of what is code now into data.
[removed]
If you want to learn python then you might wanna have a look at [PyQt](https://wiki.python.org/moin/PyQt)
Nice explanation and i totally relate. 
As some have said, Gtk+ is far and away the most used gui toolkit for c. There are a few others, like libui mentioned here. Gtk+ is built on an "object oriented c" library called gobject, with its own abstractions for strings, os interfaces, etc. It's very powerful and proportionately large. Of you just want to start simple and get the ideas (which, presumably, would translate to understanding Gtk+) I'd recommend libui
Don't hit me if I'm wrong but it's pretty much GCC, clang, VC++.
The industry standard toolkit is IEEE 1295 Motif, though it's kinda dated. I recommend you to not write your GUI in C if you can avoid it. Rather consider writing the GUI in a scripting language like tcl/tk and communicate to your backend over a (text) protocoll.
If you want to read a single character, use getchar().
XCode is your best choice though, I think. Integrated IDE, source-level debugging is a breeze. You could do this from the command line, makefiles, gcc, gdb, etc, which I've done many times. But I don't think it's worth the bother, unless you are doing cross-platform development. (I just checked to make sure that gcc and gdb are still installed with the command line development tools, and they are, on Sierra). So, install xcode, install the command line tools, have at it. You probably need a developer account, but unless you're intending to ship something, I think it's free.
Author of the article here. I can try to walk you through it if you can give me some more information. You're off to good start with those compiler flags, especially since PIE and stack protectors are enabled by default on some systems — something I had forgotten when writing the article. The only thing I'd change is to compile with `-Os` instead of `-O0` since that's less assembly to read through. 1. What architecture and OS are you running? 2. Give me the `objdump -d` of your binary (also with `-Mintel` if on x86). I'm most interested in the prologue of `main`. 3. Give me the output of `nm &lt;binary&gt; | grep self_destruct`. I used `readelf` in the article, but `nm` should work anywhere (e.g. on OS X and Windows). 4. Edit: Also, what did you try? 
How do install the command line tools?
I am no expert but from what I remember it is because there is some sort of input buffer. Are you taking another input after this and it just skips the next scan? That's usually where it messes up. So when you type a character in and then hit enter the character is assigned to variable x, in your example, but the system also reads the 'enter' into the input buffer. Then the next scanf comes a long and finds the enter in the input buffer and assigns the enter ascii value to whatever variable the scanf has assigned. And it looks like the program just skipped over that part of input. The space before the %c cleans the input buffer, and I guess getchar() does the same thing and is a little easier to read maybe.
Pretty much identical to linux. Vim or emacs, and gcc or clang. cc defaults to clang on mac
It's great, all the unixy stuff and even xwindows stuff to boot(xquartz). You can use a whole bunch of IDEs including CLion (intelliJ) or use cc(clang) and vi if you're that tough.
&gt; But why is there 32-bit instructions in a library intended for 64 and 80 bit math? You're conflating different things. A 32 bit x86 processor has integer/general purpose registers that are 32 bits wide. It has floating point registers that are 80 bits wide. The two sizes are not related. Integer and FP operations are different and distinct. &gt; The only solution I saw said to compile for 32-bit If you're talking about `cephes-math-28.tar.gz`, it has not been updated since 2000. 64 bit x86_64 processors didn't even exist then. This has no chance of ever working on x86_64, unless somebody manually ports it or removes the hand-written assembler. 
And you can run Valgrind on a mac too! 
Vim already comes installed. Open Terminal, or your favorite console app, then type `vim`, then hit enter. That's vim. Just look up vim tutorials on youtube. Also, you have to figure out how to quit after you open it :) (you might have to look that up too) gcc and clang are compilers. Just look up any basic C tutorial and it'll probably tell you how to use them. To install other developer tools you'll need a package manager, the most popular for mac is called [homebrew](http://brew.sh/). Install it, then you can use it to install emacs or whatever other packages you need.
Thanks! That makes sense. 
Install xcode, but then also install the command-line tools. Learn to use the vi editor and to write Makefiles. Otherwise, I don't think Xcode is more complicated than Visual Studio; it's just different. Edit: I mean install the command-line *developer* tools. The regular command-line stuff is already there. Just type "make" at the command line and you'll get a prompt asking if you want the command-line developer tools installed. If you don't get that prompt, then they're already installed.
&gt; some students told me that for certain assignments i will in VS or something really similar to do the assignments because its a unique environment ideal for school assignments. Sounds like a load of nonsense to me. I can't see what difference VS vs Xcode would make unless your professor wants you to use one in particular. If you really want to be a Real Programmer™, you need to learn to use the command line, a real editor (vim), and how to write Makefiles. Other than that, one IDE is as bad as another. Just use Xcode.
I'm on x86-64 as well (Linux, gcc, glibc). [objdump](https://paste.debian.net/plain/910073) with `-O0` $ nm a.out | grep self_destruct 00000000004005e6 T self_destruct $ size a.out text data bss dec hex filename 1428 576 8 2012 7dc a.out $ echo -ne '12345678\xe6\x05\x40\x00\x00\x00\x00\x00' &gt;boom $ ./a.out &lt;boom Hello, 12345678�@. The result is similar with 16 instead of 8 bytes: $ echo -ne '12345678abcdefAB\xe6\x05\x40\x00\x00\x00\x00\x00' &gt;boom $ ./a.out &lt;boom Hello, 12345678abcdefAB�@. [1] 27029 segmentation fault ./a.out &lt; boom With `-Os` ([objdump](https://paste.debian.net/plain/910072)) I get something different: *** buffer overflow detected ***: ./a.out terminated ======= Backtrace: ========= /lib64/libc.so.6(+0x6f013)[0x7f0b117b2013] /lib64/libc.so.6(__fortify_fail+0x37)[0x7f0b1183a8d7] /lib64/libc.so.6(+0xf59e0)[0x7f0b118389e0] /lib64/libc.so.6(__gets_chk+0x1a2)[0x7f0b11838962] ./a.out[0x400523] /lib64/libc.so.6(__libc_start_main+0xf0)[0x7f0b11763790] ./a.out[0x400569] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 08:02 655235 /home/afh/a.out 00600000-00601000 r--p 00000000 08:02 655235 /home/afh/a.out 00601000-00602000 rw-p 00001000 08:02 655235 /home/afh/a.out 00fd5000-00ff7000 rw-p 00000000 00:00 0 [heap] 7f0b1152c000-7f0b11542000 r-xp 00000000 08:02 603054 /usr/lib64/gcc/x86_64-pc-linux-gnu/4.9.4/libgcc_s.so.1 7f0b11542000-7f0b11741000 ---p 00016000 08:02 603054 /usr/lib64/gcc/x86_64-pc-linux-gnu/4.9.4/libgcc_s.so.1 7f0b11741000-7f0b11742000 r--p 00015000 08:02 603054 /usr/lib64/gcc/x86_64-pc-linux-gnu/4.9.4/libgcc_s.so.1 7f0b11742000-7f0b11743000 rw-p 00016000 08:02 603054 /usr/lib64/gcc/x86_64-pc-linux-gnu/4.9.4/libgcc_s.so.1 7f0b11743000-7f0b118d3000 r-xp 00000000 08:02 345835 /lib64/libc-2.23.so 7f0b118d3000-7f0b11ad2000 ---p 00190000 08:02 345835 /lib64/libc-2.23.so 7f0b11ad2000-7f0b11ad6000 r--p 0018f000 08:02 345835 /lib64/libc-2.23.so 7f0b11ad6000-7f0b11ad8000 rw-p 00193000 08:02 345835 /lib64/libc-2.23.so 7f0b11ad8000-7f0b11adc000 rw-p 00000000 00:00 0 7f0b11adc000-7f0b11aff000 r-xp 00000000 08:02 341693 /lib64/ld-2.23.so 7f0b11ce6000-7f0b11ce9000 rw-p 00000000 00:00 0 7f0b11cfd000-7f0b11cff000 rw-p 00000000 00:00 0 7f0b11cff000-7f0b11d00000 r--p 00023000 08:02 341693 /lib64/ld-2.23.so 7f0b11d00000-7f0b11d01000 rw-p 00024000 08:02 341693 /lib64/ld-2.23.so 7f0b11d01000-7f0b11d02000 rw-p 00000000 00:00 0 7ffea4902000-7ffea4923000 rw-p 00000000 00:00 0 [stack] 7ffea4979000-7ffea497b000 r--p 00000000 00:00 0 [vvar] 7ffea497b000-7ffea497d000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] [1] 24539 abort ./a.out &lt; boom 
Visit homebrew.sh If you prefer an IDE, check out Code::Blocks or CLion, though I do recommend getting at least somewhat acquainted with the terminal.
What OS?
What specific functions do you need to use from it?
just remember 60 hz monitors only refresh every 0.01666 seconds
It's not necessarily unsigned. In a string literal it is plain char for example.
 $ xcode-select --install
You don't need XCode to program in C. OSX is certified Unix and runs C perfectly fine.
I don't recall, you don't *need* homebrew to install packages, do you?
In any non-Windows environment, vi is almost expected with vim a close second and emacs available but Xcode is Apple only.
Command line tools need to be installed? I don't think so.
In what way does this answer the question?
If you do it this way you will be just measuring the amount of time printf takes, as it will take longer than the rest of the code. So you would be better off storing your samples in an array and then processing them after you have done your measurements. Additionally if you are looking to optimize this code, I would pass into the fib function, the last Fibonacci number you calculated.
gcc defaults to clang, too, on OS X.
Though my coworker is very suspicious as to how they got their UNIX™ certification if not even their shell is conforming.
&gt;Which shell? Only sh, the POSIX shell, is required. Of course, but does the OS X shell conform to POSIX?
Are you sure about that...? [6.4.4.4.9](http://i.imgur.com/OnQ3wJt.png).
So your argument is “OS X has a shell that managed to get a POSIX certification because they got POSIX certified?” Sounds circular. Actually, the OS X shell has a couple of discrepancies to POSIX (e.g related to `IFS` behaviour with respect to numbers) and should have never passed the certification.
Atom is a free open source lite weight editor made by GitHub that's highly customizable. I use it it on my Mac, and just compile any source files directly in the terminal. You can get it at https://atom.io
https://railsapps.github.io/xcode-command-line-tools.html 
What do you need this library for? Support for `long double` math has been available in open source libm implementations for quite a while now. Perhaps you can live without it.
 I get it now thank you for your help
Thank you very much for your help, i get it now :)
Check the size of the boom file created with echo. Use "/bin/echo" if the file is bigger than 24 bytes.
So, it appears that a large part of the library is written in 80386 assembly. There is no way to compile this for amd64 except with serious porting effort. Note that you are probably not going to need this library anyway; its functionality should be available on all modern standard C libraries.
op is on mac
I'm a vi user, too. If OP thinks an IDE is too hard, how would console, command line, and screen swapping be easier than a GUI text editors and a compile button? I'm not disagreeing it should be learned
And? I don't understand what you're trying to say.
Emacs too, although you might want to get another installation of it. 
Try to disable FORTIFY_SOURCE as shown here: http://dustin.schultz.io/blog/2010/09/11/turning-off-buffer-overflow-protections-in-gcc/
Note that C# is entirely unrelated to C. It's more like Java.
I would say for a beginner learn the basics of C, then switch to c++. If you like uses classes(or c with class) and the like you can, but if not valid c is pretty much always valid C++.
As others have mentioned C# is not really as closely related to the other languages as its name suggests. C and C++ are actually more closely related to one another, to the point that historically C++ has been taught as C plus some additions. But what I wanted to say is that in my view teaching or learning C++ that way is a mistake. In some contexts it's perfectly sensible to write a program that can be processed as either C or C++, but much of the time you shouldn't do that; the best way to do something in C will be completely different from the best way of doing that same thing using C++. C and C++ are two separate languages. Even though it's possible to do some things in C++ the same way as in C, it's typically a mistake to do so. Learning C++ the "right" way often means unlearning habits you pick up from learning C. That's not to say that there won't be things you can usefully transfer from C to C++, but it's not as straightforward as C giving you a subset of C++ that you should use. Kate Gregory gave a [good talk][1] some time ago on teaching C++ and how some traditional ways of teaching it aren't very good. It's not really aimed at people wanting to learn C++ though. Rather it's aimed more at people who may be teaching it. [1]: https://www.youtube.com/watch?v=YnWhqhNdYyk
So how do people install software without it? Don't you drag and drop the .dmg(?) file and it installs it? (It's been a while since I used a Mac.)
I don't know if I understand what you're asking but it sounds like you need to use high resolution timers and signals. Moreover, you need a preemptible kernel and you need to set your task's priority high and preferably, to make it more reliable, you need to set affinity to an idle core (if multicore) and make sure no other tasks or interrupts are scheduled to run on the same core. What you would do is you'd create a high resolution timer, set it to expire in 10e-5 seconds and raise a signal when it does. Once you catch the signal, you need a mechanism to print it. Note that printf is not reentrant. Even after all that, getting real time performance from non-realtime kernels is very difficult, and most CPUs we use are not suitable for 'real' real-time to begin with. But you might get close enough for your test program.
Have you tried gcc's -m32 flag for 32-bit compatibility? 
Yes, for finding addressing bugs, but valgrind can do a lot more.
I don't really know what you mean by that but Code::Blocks just feels like a bad Windows port on Mac.
The windowing system. IIRC, it runs in an X11 window instead of as a native app
Well said!
What stops you from using it?
Please read the actual text in that image.... (paraphrased) "The value of the escape sequence shall be in the range for unsigned char". Not "The escape sequence has type unsigned char". Escape sequences don't even have a type. 
You're right, yes. I only meant sequences in the context of character literals, which do get directly converted to ints without having anything to do with plain chars. Sorry for being unclear. 
I must respectfully disagree with the answers here. I would suggest learning C++ before C. * C++ is easier to learn. It's a higher-level language, so code is easier to read, write, and reason. * You can use C++ to teach yourself object-oriented programming or other high-level programming concepts. This is more important than learning any given language. * C++ is safer. C uses things like raw pointers and C-arrays, which are easy to mess up (forget to delete a pointer? memory leak!). C++ provides safe versions of these, like std::unique_ptr and std::string, which handle memory safely and provide extra functionality. * I sort of lied about the last point. C++ also has stuff like raw pointers and C-arrays. However, this means that you can start by using the safer features and then move to the unsafe features. In fact, many C++ programmers do this when optimizing. C++ is a great way to ease yourself into low-level programming. I'd recommend learning it before C.
If you're doing embedded programming - go for C. If you're wanting to write fast code on a regular computer - go with C++. If you need to do any work on the heap - the c++ standard library is the place to do it - not malloc.
https://www.reddit.com/r/C_Programming/comments/3y194q/officially_learning_cneed_project_ideas_i_can/
But OSX is a Unix system. How can a Unix system not have command line tools on first boot?
Oh, it has nearly the full suite of command line tools. It just doesn't have any command-line developer tools such as "make" or "cc". You have to install Xcode to get those.
No one else has mentioned it but be aware of what language standard you are learning. There are features in C that aren't supported in C++, and it's actually best to approach C++ as an entirely different language from C (at least modern C++, ie C++11, imho). Certain changes in C introduced in the C99 standard like variable length arrays have no equal in C++, for example. Just something to keep in mind and be aware of more than anything. Don't write C code and always expect it to compile with a C++ compiler. Best of luck, both languages are fun to work in.
I like this answer as well. This way should avoid the pitfalls of thinking of C++ as "C with classes." Learning C now should almost entirely be for fun. You're signing yourself up for a ton of headache. It definitely still has its place, close to the metal.
[removed]
What about a bookmark manager? It can be dealt with in different steps: - First just store a list of links, add some, remove some, but without saving it anywhere (you start from a fresh list whenever you launch the program). This will require you to use arrays or linked lists or fancier data structures if you want (but don't rush into it) and read user input. - Then add the possibility to save that to a file. It will involve file operations and will require you to think about your storage format. Is one link per line ok? Should you do differently? - Add a way to search links within your newly created database (by that I don't mean you should use a database such as MySQL, I just mean that your file is storing data so it's a simple database). When you get there you have a fully functionnal (yet simple) bookmark manager. You can switch to something else or evolve it in two ways: - Rethink it. You used linked lists to store the data? Try with a balanced tree, or a red-black tree, or try using an existing database system. Make this project your "Hello World" when trying new technologies. You want to learn GUI programming? Add a gui to it! By starting off the same base each time you are working on something you know and it's easier to test variants of it than to start all over with a new problem. - Add more features: What about adding a tagging system to the manager in order to find all links on a given topic? Or add a way to store descriptions of links? What about automatically generating short links to allow easy manual copy? Or password-protecting the database using encryption? By making the tool more useful you'll want to use it more, which means you'll want to polish it more too, and that's how you end up with a great project that will last for years. There again the goal is to start from something you know to build toward something you don't know yet. Of course those advices are completely independant of the actual thing you're making. I find however that CRUD programs (where you Create, Read, Update and Delete data) are good to start because the concept is at the core of most useful simple projects.
Write a simple webserver.
[removed]
Keeping in mind that even the [EASY] ones are often quite difficult and/or long.
But understanding "low-level" memory management (à la C) will help you understand what C++ does under the hood and the difference between its different ways of managing memory allocation, and not to be confused by something that looks like fuzzy obfuscated black magic. 
You don't need a developer account anymore, Xcode is available free of charge from the Mac App Store.
With C languages, you need to compile a different target for each platform. You don't actually need to be on the same platform and can theoretically use a cross-compiler. However, I wouldn't describe this process as easy. For a beginner, I would not recommend it. I would recommend dual boot or VM. 
This. Whenever I need a GUI in C I use IUP. Eliminates all the fiddling around with gnome or other massive tool kits.
Hey, I won't tell her about that one if you don't.
I probably should mention the new cross-platform native SDK I'm working on called Blurrr, because it is very much related to this concept of native development that I described. Blurrr's core provides a bunch of cross-platform C libraries, the majority open source, like SDL. So you can write in C. But I also provide language bindings for Lua, JavaScript, and Swift, so you can write native Windows, Linux, Mac, iOS, and Android apps in those languages. Blurrr also spends a lot of effort to tame the cross-platform build systems, so you can just focus on your code instead of fighting the build process for each platform. But as a native SDK, I still let you go through the real native platform tools, like Visual Studio, Xcode, and Android Studio. I'm still in private beta, but here's a video link introducing the project. http://blurrrsdk.com/videos/blurrrsdk-quick-introductio/ It is game centric for the moment, but I am working seriously on IUP because I hope to bring it to Blurrr. (I need to write the Mac, iOS, and Android backends first.) 
Checkout the books and resources on the side bar.
This is a very common question. Consider searching through the archives of this subreddit if you can find anything useful.
Think about the definition of a prime number and look at your code again. 
Other than your code using a few bad practices and containing an error, you're using a very roundabout and inefficient way to determine if a number is prime. You should look up and learn proper variable initialization, naming, semicolon usage and methods of determining if a number is prime mathematically before you tackle this problem again. But since you asked... you've got a comma after your for loop 'for (;;);' that makes the body of the loop a separate unit from the for loop itself, meaning that it executes one time after the loop, messing up your logic.
Please put four blanks in front of every line of code so the code appears readable.
The C Programming Language by Dennis M. Ritchie and Brian W. Kernighan, second edition, ANSI C. Written by the language author, and known colloquially as the "K &amp; R" book—a book of lore on the side panel....
thenewboston
The short answer is no. C was designed as a system programming language for writing things like operating systems, servers and low level protocols. C has no native concept of object oriented design making managing objects to draw a GUI more cumbersome and error prone. While there are frameworks to write GUIs with C it is not the optimal language to do this. If you want to write a well looking and less error prone GUI quickly use a high level language that was designed with this kind of task in mind. Such as Python, C# or C++.
I feel it is best to do a project that interests you. For me, it was writing a program that reorganized my .mp3 files according to their id3 information. Ask yourself what would be useful for you to have or you would be interested in learning more about.
Have a look at qt. There is a creator for it, and the API is pretty good. I don't like qt, and prefer GTK, but GTK isn't that easy to use with windows.
Have you found the eclipse IDE yet? Multi-OS compatible IDEs are great for this case; no worrying about any nuances specific to any 'OS Only' IDE.
For cross platform I would have to agree with you there. I wish GTK was more relevant in the cross platform world. I think it's pretty cool but so is Qt granted I have never used it. In general I just find GUI programming very interesting
Just curious what don't you like about Qt? What do you feel are the advantages of GTK over Qt? And have you ever gotten a GTK application running on Windows?
I am good to know this information.. Thanks for sharing..
But is it that "simplifying";
Format your code by putting 4 spaces in front of every line, or put it on pastebin or the like. It's an unreadable mess right now. What errors are you getting?
when you declare areaofabrick=num1*num2; `areaofabrick` is evaluated right then with the values of the uninitialized variables `num1` and `num2`. When you change the values of `num1` and `num2`, the value of `areofabrick` is not changed. What you need to do (in addition to fixing your formatting) is to move the calculations for `areofabrick` and such after you get the values of your numbers. C does not behave like the math you do on paper or the math you might do in a CAS. Variables are evaluated immediately and they can be modified without changing the values of other variables.
&gt; your syntax is wrong Where/what is the mistake?
This is incredibly cool. Are you doing this all by yourself? I would LOVE an SDK that allows for JavaScript. Electron is just not the answer for bringing JS to GUI apps. I would use this in a heartbeat.
This is weighing heavily on my decision. So you think I would have an easier time in C++/Qt over C/IUP, since this is what C++ was designed for? I'm not great with C either, just took a class on it before, so I do worry about my ability to avoid segfaults/memory leaks all that (I know how to use valgrind, though). But your point is essentially I'm using a language for something it wasn't really designed for, and it will be easier in the long run if I just use C++ and pick it up along the way?
Now it compiles, but results are not as needed. Please run it yourself and see #include &lt;stdio.h&gt; int main(){ int num1, num2, num3, num4, num5, areaofabrick, areatobebrick, costperbrick, neededbricks; /* Declaration of variables */ printf("Welcome to the brick Calculator\n"); /*title of prorgram and presentation name*/ printf("-------------------------------------------\n\n"); /*division line separating tiltle from body of program */ printf("Please enter the length and width of the brick:\n"); /*asling for the value */ scanf("%d %d", &amp;num1, &amp;num2); /*reading the values entered */ areaofabrick=num1*num2; printf(" Please enter the length and width of the surface to be brickd: \n"); scanf("%d %d", &amp;num3, &amp;num5); /*reading the values entered */ areatobebrickd=num3*num4; neededbricks=areatobebrick/areaofabrick; printf("Please enter the cost of each brick: \n"); scanf("%d", &amp;num5); costperbrick=num5; printf("You will need %dt bricks \n", neededbricks ); float finalcost=neededbricks*costperbrick; printf(" %d bricks will cost you $ %.2f \n", neededbricks, finalcost ); return 0; }
You have a typo here. Considering this should be a copy paste, I don't see how you managed to do that. areatobebrickd should be areatobebrick. Anyway, [try not to use scanf to read user input](http://c-faq.com/stdio/scanfprobs.html). But if you insist on using, you need to account for the \n character too.
"C Programming Absolute Beginner's Guide (3rd Edition)" Is a very good book that I recomend. It has 32 short and informative chapthers with complete coding examples that you can write to better understand whats going on.
Also, notice that '10' and '5' both appear twice in your code, so if you wanted to switch to 11 and 4, you'd have to fix it in both places, it might be better to have your printf work something like this: printf("The two numbers used in this program are %i and %i\n\n", num1, num2); That way, just changing num1/num2 will do it, your printf wouldn't have to be touched
Just a correction, '-' cannot be used in a variable name.
C was designed as a "high level" general purpose language, like many others. Remember it was made in the 70's. The concept of "high-level" has shifted somewhat through the years. C++ was another general purpose language developed in the 80s. It was no more designed for GUI application development than C. You are going to get a lot of religious arguments against what I say here, but OOP is a red-herring and isn't going to magically solve all your problems. And there is a lot of arguments about what OO really means (look up Alan Kay who invented the term, and he hates what it has become to mean for most people, inheritance being the least interesting part to him.) In fact, Obj-C/Cocoa, also came to this realization. It actually is closer to Alan Kay's idea, but they also quickly learned the inheritance aspects which Kay didn't really think should be the focus, were actually not so great an idea. So in Cocoa, delegation, composition, and message sending are the norm and subclassing is comparatively rare. And the current trend in computer languages is also following this. We're seeing a resurgent interest in functional programming techniques. We're seeing old languages pick up features like closures, and new languages like Go are fairly opinionated on what OO really means to them and you see things pushing back to composition instead of taxonomy. And if you look at the immediate mode GUIs I mentioned, OO is a completely an irrelevant concept to both how they work and how to use them. Anyway, for a beginner, I think exposure to the all different types of programming is useful. But I don't think you should be dogmatic about it. The big three are procedural, OO, and functional. I also recommend keeping Alan Kay in the back of your mind when studying OO: In addition to C++/Java/C#, ideas in SmallTalk, Obj-C, and Go will give you a broader perspective of what OO is. Also JavaScript is really interesting here with their prototypal inheritance system. (And you should look at Lua and metamethods and see how OO systems can be constructed from basic building blocks...and you can construct single inheritance, multiple inheritance, and prototypal inheritance all with the same metamethods building blocks Also Lua supports functional programming pretty well too and you can actually build OO systems completely around closures. There is a quote: "A closure is a poor man's object. And an object is a poor man's closure.") So I'm a big fan of people understanding the fundamentals so they can then decide on what the best tool for a specific job is. Right now, since you are a beginner, I think Qt is a giant rabbit hole. IUP is small and easy so you can learn other concepts. And since you are currently interested in both compiled languages and GUI programming, I think you would also be well served playing with Swift. (And trying Android Java and Windows C# wouldn't hurt either.) And *if* you really want a good student project, I'm been (slowly) writing a native backend for IUP for Mac, iOS, Android, and Emscripten. I could use help. It's not an easy project, but it will give you a lot of perspective in that you will need to use C on the front-end, but use the native GUI APIs and languages on the backend. So say for Mac, you get to see how Obj-C/Cocoa works on the backend, and then make it callable by IUP's C front-end API. Projects like these will give you a much deeper perspective of how things actually work than what most developers do. 
Yes, I'm mostly on my own. I had a little help from former associates/friends, but one just passed away unexpectedly this summer. Yes, most JavaScript frameworks come from the web, and they try to bring all their web baggage to the native platforms which I think is a poor way of doing stuff. I want to push back in the other direction and bring native development sensibilities back. If you separate JavaScript (just the language) from the web browser, a lot of bloat goes away. And you begin to get more clarity of ideas since you are really doing native development, just with a language binding to JavaScript. I write the entire core in C and make everything still possible to write in pure C to keep everything honest (and also fast). Anyway, I hope to eventually get IUP bindings done for JavaScript so you can do native GUI application development in addition to games. 
Use "diff -u" to get more readable output.
The first line lets you use printf and scanf The second line declares variables and asks the user for a number and stores it in num1 The third like iterates from 1 to the number and uses whether the number of divisible factors is exactly 2 as its check The fourth line prints out if the number is prime or not
Okay, I'll contact you privately to get more into the details. But for anybody seeing this who is also interested, feel free to contact me directly too. (I should also say I'm trying to get the IUP community to participate in Google Summer of Code this year...we'll see) Here are some useful links: https://github.com/ewmailing/IupCocoa https://github.com/ewmailing/IupCocoaTouch https://github.com/ewmailing/IupAndroid https://github.com/ewmailing/IupEmscripten IUP for iOS &amp; Android announcement/intro video (with IupMac backend cameo): https://www.youtube.com/watch?v=UvrEfOg3Nyk IupEmscripten announcement https://groups.google.com/forum/#!topic/cocoaheads---silicon-valley/6uknlh3kS8M 
Yea so this is precisely what I was going to do, have a default and then be able to override it later on. Thanks for the example I've edited post to add missing full stops, typos!
I am potentially interested but I would prefer if you would just write what you want here.
[removed]
It might be that you accidentally removed the include file folder.
I would love to reinstall it. However, I uninstalled VSC, deleted everything in the program file, then reinstalled it. All settings seemed to be exactly the same. Know how to clear it out completely?
You tried. I appreciate it.
You can't use Visual Studio Code to build the project, you should use `make` in the WSL terminal, remember that you're not supposed to run WSL commands from Windows. The Plan B is to install the [Visual C++ Build Tools](http://landinghub.visualstudio.com/visual-cpp-build-tools)[1]. [1] Fine Print: Binaries built with these build tools don't work with XP.
What you show us should work. Perhaps the error lies somewhere else?
Thats strange... Is it normal for me to add the } else { ... at the very end of my program? As in there's a huge chunk of code where the comment in the code is. Maybe the problem lies within it?
The else part is normal. However, you should make sure to flush all buffers (call `fflush(NULL)`) before calling `fork()` to make sure that you don't get any funny behaviour from unflushed data. It is very likely that your problem lies in the chunk of code you haven't shown to us. Perhaps it might be useful to debug that.
Ich versuche verkettete Listen mal anhand eines Arrays zu motivieren. Wenn du ein Array zum Speichern einiger Datensätze verwenden möchtest, dann musst du vorher festlegen, wie groß es sein soll. Was aber, wenn du nicht von vornherein weißt, wie viele Einträge du speichern sollst? Es ist nicht ohne weiteres möglich, das Array zu verlängern. Man kann dafür zwar `realloc()` verwenden, aber dann wird das Array möglicherweise kopiert, sodass alle Zeiger auf es ungültig werden, was häufig unerwünscht ist. Ein möglicher Lösungsansatz ist, zu dem Array einen Zeiger zu speichern, der auf ein weiteres Array mit den restlichen Einträgen zeigt, wenn das ursprüngliche Array nicht groß genug ist. Dieser zeigt zunächst auf `NULL`, ist das ursprüngliche Array voll, wird ein neues Array alloziert und der Zeiger dorthin umgebogen. Auch zu diesem neuen Array gibt es wieder einen Zeiger, der, wenn es voll ist auf die weiteren Daten zeigt. Wenn jetzt jedes Array in der Kette genau einen Eintrag hat, dann hat man genau eine verkettete Liste. Ich hoffe, diese Erklärung ist nützlich. Wenn du weitere Fragen hast, einfach Schreiben.
This subreddit is about programming in C only. C++ is off topic. Please ask C++ questions elsewhere, e.g. in /r/cpp_questions. I have removed your post as it is off topic.
Ok, sorry.
Please do not answer off-topic questions.
A pointer is like a house address, it tells you where the data (the house) exists. If a new friend told you to come to his house, you would need his address to know where to meet him, otherwise it'd be almost impossible to find him. Now, for linked lists, imagine you needed to find the house of a person, let's call him friend C, and you know he is is a friend (C) of a friend (B) of a friend (A). You only know friend A's address, he's your closest friend. So you go to friend A's house, and ask him for friend B's address. Then you go to friend B's house, and ask for friend C's address. Then you've found friend C's house! So, you know friend A's address, friend A knows friend B's address, and friend B knows friend C's address. It's a linked list: You -&gt; friend A -&gt; friend B -&gt; friend C You ask why you need a start: well, in the example, if you don't have any friends at all, then how would you find friend A's address? You couldn't. So, in order to find C, you need to have a pointer (address) to the beginning of the list (A).
Others have answered the question already, but try some other format strings: %x - hexadecimal %X - HEXADECIMAL %f - floating-point %d - signed integer %u - unsigned integer %s - string (this one will print the "C" correctly) Also notice that if you pass more specifiers than there are additional arguments (e.g. `printf("%s %x %f", some_string)`, then you wind up with garbage printed out. This garbage is actually the contents of your stack and can be used to do bad things!
While probably not the problem, your code is not correctly handling errors: int pid = fork(); if (pid == 0) { // child } else if (pid == -1) { // parent but no child has been created. } else { // parent and the child is running. }
If you did this, you could see that the character output matches one end of the pointer. int main() { const char *ptr = "C"; printf("address = %p; buggy char = %c\n", ptr, ptr); } Then compile and run both with and without hexdump. `%p` prints the pointer value in hex.
If you did this, you could see that the character output matches one end of the pointer. int main() { const char *ptr = "C"; printf("address = %p; buggy char = %c\n", ptr, ptr); } Then compile and run both with and without hexdump. `%p` prints the pointer value in hex.
I often say, getting "Hello, world" to build and run is half the battle to learning a new programming language. ---- First, please edit your post and indent all your code 4 spaces; that will make it much more readable. Like this: #include &lt;stdio.h&gt; int main (void) { printf("The GCC hopefully works."); return 0; } Second, you'll need to add a newline to your printf() statement; printf() does not implicitly add one. printf("The GCC hopefully works.\n"); Third, take your Windows box and throw it in a dumpster and get a Unix system before it causes irreversible brain damage. Any C programming environment that doesn't have &lt;stdio.h&gt; in the default path is horribly broken. If I had to take a wild guess, I'd say that somehow the full C programming environment didn't get installed on your system. Diagnosing that is probably above our pay grades. Probably your best bet is to take your computer to someone with more experience with this stuff and have them look at it.
You need to dereference the nm pointer in assigning a string to it. *nm = "blablubb" Otherwise you try to write the string to the memory Adress of the pointer.
Maybe this could be useful: http://c-faq.com/aryptr/aryptr2.html try doing: char *nm = dud; printf("%s\n", nm);
Totally not true. `*nm` is of type `char`. A string constant (in double quotes) is of type `const char*`. You cannot assign the latter to a variable of the former. `nm = "abvxs";` is the right way to do things.
What you posted is ok, assuming that it is in the main() function, after including stdio.h. There must be something else in your program that causes the segfault.
I would just suggest to use daemonize here. Basically what you want is a daemon running. http://man7.org/linux/man-pages/man3/daemon.3.html 
Can you show us a minimal code sample that reproduced the issue? And make sure to compile your code as C, not C++.
It's worth noting that the command line tools are the only thing you need, other than editors... But you may want to know that they aren't always that up to date, so you may want to use macports/homebrew to install git and stuff — but you need the command line tools to use the package managers (at least, macports requires it) because you won't have a compiler otherwise. Once you have macports, there are *a lot* of compilers in their repos, ready to be cursed upon when you find out that your laptop is compiling an odd version of gcc because of build dependencies of stuff you decide to install. :D
WSL is the *Windows services for Linux* which is a component of Windows that allows it to run Linux programs. *make* is a program that is typically used to compile large programs (it determines what files need to be compiled and then calls the compiler to compile all files in the correct order).
Thanks for the information!
Without anything to do, the child will exit as well.
You need to allocate memory for the pointer to point to, else you're trying to write somewhere you can't write. char dud[] = "abcd"; Array automatically allocates+deallocates memory for all its elements. This is why the compiler needs to know its size. char *nm; You've only allocated space for the pointer itself.
It's actually valid to do char *str; str = "hello world"; because writing the string literal `"hello world"` means the compiler will allocate space (likely in the read-only section of the executable) and store the string there. The pointer `str` then points to the string literal, which is all fine - no `strcpy` effect has happened. You may have a problem if you try to mutate the string (not the pointer), though, because the string literal may not be in a writeable area. For example, you can certainly do (with no warnings) char *str; str = "hello"; puts(str); str = "world"; puts(str); and get the output hello world but you can't (safely) do char *str = "hello world"; str[0] = 'H'; /* Error: tries to write to RO memory */ 
Can you be a bit more specific? What threading API do you want to use? What operating system? What program counter do you want to obtain? Note that in a multi-threaded program, there is no single program counter. Instead, every thread has its own program counter.
Exactly! "S" creates a stack-allocated string with two characters: 'S' and '\0'. 'S' creates a one-byte integer type (83, in this case). %c takes an integer and figures out what ASCII character that corresponds to and prints that character (83 is converted back to 'S'). I'm sure you found that out in your research, but it's still fun to discuss. Best of luck!
I don't see why it matters since you "removed" it. Also, in my opinion, a question like this doesn't even matter because C and C++ are basically the same thing at the level that I'm programming at. It may be off topic, but I didn't know that, and you're just being a jerk.
**Here's a sneak peek of /r/cpp_questions using the [top posts](https://np.reddit.com/r/cpp_questions/top/?sort=top&amp;t=year) of the year!** \#1: [Where does the spit go that the dentist sucks up in the tube? I tried asking my dentist and she had no idea](https://np.reddit.com/r/cpp_questions/comments/4rqlto/where_does_the_spit_go_that_the_dentist_sucks_up/) \#2: [Most beautiful piece of C++ code you've seen](https://np.reddit.com/r/cpp_questions/comments/5c6wwj/most_beautiful_piece_of_c_code_youve_seen/) \#3: [IMPORTANT - READ BEFORE POSTING](https://np.reddit.com/r/cpp_questions/comments/48d4pc/important_read_before_posting/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
I'm not sure what other code would be useful in diagnosing the issue? engine_text.c looks like this: #include "engine_text.h" #include &lt;ft2build.h&gt; #include FT_FREETYPE_H void LoadFont(char* FontPath) {...} And the main file where main function is found also includes engine_text.h. How do I know whether cl.exe is compiling as C and not C++? I'm having trouble finding any information about it.
Granted, but it is the *de facto* package manager for macOS even if it doesn't come bundled like apt or yum might be. I couldn't imagine running a mac without brew, and it's got so much inertia now that it's hard to imagine any other package manager taking its place. Vim indeed does come bundled with macOS, but just like the bundled Ruby, it's pretty much outdated. For instance, the version on brew is 8.x whereas the bundled version is 7.4 (macOS Yosemite upgraded to Sierra). Similarly for Clang, a real PITA if you ask me.
/*Now it compiles, multiplies and divides, I am not getting the final cost though*/ #include &lt;stdio.h&gt; int main(){ int num1, num2, num3, num4, areaofabrick, areatobebrick, neededbricks; /* Declaration of variables */ float num5; printf("Welcome to the brick Calculator\n"); /*title of prorgram and presentation name*/ printf("-------------------------------------------\n\n"); /*division line separating tiltle from body of program */ printf("Please enter the length and width of the brick:\n"); /*asling for the value */ scanf("%d %d", &amp;num1, &amp;num2); /*reading the values entered */ areaofabrick=num1*num2; printf(" Please enter the length and width of the surface to be brick: \n"); scanf("%d %d", &amp;num3, &amp;num4); /*reading the values entered */ areatobebrick=num3*num4; neededbricks=areatobebrick/areaofabrick; printf("Please enter the cost of each brick: \n"); scanf("%d", &amp;num5); printf("You will need %d bricks \n", neededbricks ); float finalcost=neededbricks*num5; printf(" %d bricks will cost you $ %.2f \n", neededbricks, finalcost ); return 0; }
You should probably post Parts 1 and 2 if they are related to this assignment (if they define Simpson's method).
Ok. Easiest way to do this is as they suggested, with WSL. Do you have windows 10? If so, you _hopefully_ have it. If not you'll need to google and install it. The actual application you'll want to open is called "Bash on Ubuntu on Windows". Once you have that downloaded/open it, you'll see a terminal. Navigate to the folder where your .c file is, and type `gcc filename.c -o filename`. That will compile your program for you. You can then run your program by typing `./filename` and you should see the output on the terminal. Note: this only works with really simple programs. As you add more stuff to your program and call more libraries, you'll need to add more flags to the command, and as u/Aldonio mentioned, at that point you should probably start reading about `make`. Let me know if that works for you.
All the code I need to reproduce the issue. Make a self-contained source file that shows the problem. You can test if you are compiling as C++ with code like this: #ifdef __cplusplus #error Compiling as C++ #endif
There actually is under “other subreddits of interest.” Perhaps you should look closer.
 int year; int age = 2017 - year; scanf_s("%i", &amp;year); You seem to have some fundamental misunderstanding about how variables work in C (or most programming languages). The value of a variable will not change unless you change it. Your assignment of the `age` variable happens before you read the user input, so it won't reflect what they enter.
Here is the simplest formulation of the problem that I could distill it down to. If I try to compile these files, it will result in the same error. **engine_text.h:** #ifndef H_ENGINE_TEXT #define H_ENGINE_TEXT #include &lt;ft2build.h&gt; #include FT_FREETYPE_H #endif **engine_main.c** #include "engine_main.h" #include "engine_text.h" int main() { } This produces the C2208 error. 
This is very interesting. Is there anything interesting in `engine_main.h`? Otherwise this looks like a library bug or misconfiguration to me.
I updated the thread with the SO thread.
For this example, engine_main.h is just empty.
Along those lines, you could make an insult generator. There are many examples out there, but they're all basically Madlibs style substitution of random words from various lists.
I second this, fortune is fun and easy, as a bonus build a web scraper for generating a text file full of fortunes so you don't have to write them yourself
Oh okay, thanks for letting me know! 
Make something like 'sl'
I like this. Alternatively, fork bomb roulette: http://askubuntu.com/questions/159491/why-did-the-command-make-my-system-lag-so-badly-i-had-to-reboot
The remainder of 10/5 is 0, not 10. Use the `%` operator to find the remainder.
It would be neither of those on a system that passed pointers in different registers to (promoted) chars 
No blogspam and shitty tutorials please.
If you manage to crank out full tutorials in less than two weeks, then your tutorial is probably full of shit. I have decided to remove all such tutorials a while ago because they are universally disliked by our readers and often full of misinformation. I don't want to have to clean up the misconceptions caused by your tutorial.
I think someone wrote a fortune-clone that pulled from /r/showerthoughts.
Here's a fortune file of /r/showerthoughts (1.3MB): [showerthoughts](http://skeeto.s3.amazonaws.com/share/showerthoughts). The only thing needed is to run strfile to create the index. 
i am running windows,can you ell me how linux affecs coding than windows which videos? what is gcc and gdb by good book u mean k and r right? 
Why C, specifically?
Everyone should learn C, or any other high performance functional language. The speed gains for simple algorithms alone make it worth while; and perhaps he wants to transition into c++ or c# while they're quite different languages both are extremely easy to call C in and should always be in his back pocket. Other good alternatives would be Go and Elixir but that's really his call.
Depending on your operating system, a newline in the file may be made up of both a '\n' (line feed, which it looks like you're handling) and a '\r' (carriage return, which you're not checking for). Try taking a hexdump of your file and looking for a 0x0d character.
Sorry I should have specified my environment. I'm on Linux using gcc
Sorry I should have specified that I'm on Linux using gcc. I'll add the check for the carriage return and see if that does it. 
Sorry, I thought I did, this is what I have at this exact moment. Right now I am using FHHJJL corresponding to ABCDEF, since I am using values 5 and 6 for each cipher. https://gist.github.com/anonymous/7f75a5526de48c4a0ba1ab559d601363
[removed]
Used to be the standard, OOD is by far a worse starting point; it's much harder to go back to functional programming after being exposed to OOD. 
SOLVED: you need to include stddef.h. ICC seems to automatically do this, and not gcc.
This was just a 2 second thing for the purpose of Reddit. No need for pedantry. This is why you are a software engineer and not a scientist. You don't understand big picture thoughts but instead focus on trivial irrelevant details.
Should I be doing a: char string[]?
You don't have to be pedantic when posting on Reddit. It is 100% irrelevant to the question
Fine, do whatever you feel like in your little shitty sub reddit community. I got better things to do
Have fun! You won't be missed.
Yeah, I'll. Nobody cares about your shitty sub reddit btw
alzhiemer Randomly removes a system library, binary, or alters a config file every time it is called. 
Just a sidenote: the character classification functions (#include &lt;ctype.h&gt;) would make your code in get_symbol_type little bit cleaner. There are functions such isalnum(), isalpha(), isdigit() etc. https://linux.die.net/man/3/isalpha Here's the man page (lists all the functions).
It's simple - just include it as a regular source file in your project. Treat the c file as part of your code base.
Yea that works. Seems weird having a source file that isn't my own in my project, but if needed I can just put it in a subfolder I guess. Thanks!