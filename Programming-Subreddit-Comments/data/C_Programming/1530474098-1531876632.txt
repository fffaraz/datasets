I'm still doing my research on the best course to follow. I'm going to try and get some course work to start
Sorry, try the [slides](https://sites.google.com/site/cs101atjust/slides) (unzip with [7z](https://www.7-zip.org/download.html)) and/or [syllabus](https://sites.google.com/site/cs101atjust/syllabus). Or any of the other links others posted. The course here is pretty old and C++ keeps evolving, but I thought an easier 3-credit academic course would be good too (with follow up). No matter where you go learning will need to be iterative.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.7-zip.org/download.html) - Previous text "7z" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
ganbare
You could probably do some prototype comps in a spreadsheet and let a dedicated programmer take over from there. But i guess your boss wont want to be told...
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
`perror(e)` is most definitely wrong. As is `perror(strerror(e))`. The `perror` function appends the current error message anyway, idiomatic usage in this case would be `perror("malloc")` or `perror("myalloc")`.
Thanks, bookmarked.
C11?
These ideas may seem neat, but in the end they overcomplicate things and make your program hard to debug and hard to understand for anyone who is not familiar with your error handling style. Just keep it simple and stick to the established way for doing this in C, even if it looks a little ugly: board *allocBoard(void) { board *this; this = malloc(sizeof *this); if (!this) goto err; this-&gt;tab = malloc(TABSIZE * sizeof *this-&gt;tab); if (!this-&gt;tab) goto err_free_this; this-&gt;name = malloc(NAMESIZE); if (!this-&gt;name) goto err_free_tab; return this; err_free_tab: free(this-&gt;tab); err_free_this: free(this); err: return NULL; } See also [Centralized exiting of functions](https://www.kernel.org/doc/html/latest/process/coding-style.html#centralized-exiting-of-functions) in the Linux coding style guide.
That sucks :(. I've absorbed everything that I can from that site. Thanks for the heads up and for the recommendation. Will start K&amp;R today.
Relevant: https://lwn.net/Articles/754980/
Doesn't matter though. `strerror` will still succeed (but give a slightly questionable error message). Note that they even save the value of `errno` before `malloc` and restore it after `malloc`. Furthermore `man 3 strerror` clearly states that the only error `strerror` produces is `EINVAL`, **not** `ENOMEM`. 
You could do that with the preprocessor, but it's a seriously dumb idea to do such a thing. In the preprocessor you'd just write 2 macros, 1 would be the high level one called in other places, and the other would simply do what you want one step at a time. and you'd use the `##` operator to concatenate the variable name (in this case "Example" with the number.) `Example##Num` You can figure the rest out yourself.
Awesome read! I knew I didn‚Äôt reinvent a wheel here but it was cool nonetheless.
Excellent read! Pointed me in the right direction by referencing and addressing any questions I may have had stacked in my memory.
Ugh. Take my upvote you demonic entity.
&gt; Pointed me Good post
You could use &amp;pointerToPointer and get the address of the pointer without generating another pointer.
Even if a library allows the user to pass their own malloc replacement callback, this function might fail too, which leads back to the problem that the library must correctly handle out-of-memory situations. Not using dynamic memory allocation at all is rarely an option; almost every library needs it at least for opaque data structures.
Sure, its a driver. I have a header that's like... three macros for my test "framework".
Does it really matter?
Yes, because it‚Äôs what he wants to do...
No, but if there is a way to accomplish this, I'd like to know how it's done.
There isn't, but I don't see why you would want to anyway. What problem are you trying to solve?
My goal is to have as clean of an interface as possible.
Those functions are not part of your interface.
For me, the overarching goal in selecting a test framework are to find something with a very short learning curve and does not impose significant framework or structural overhead in my testing. While I am still ramping up my use of it, I must say that I feel ¬µnit really hits the mark on these points. The framework is well documented and includes support for test suites and set-up/tear-down code. There is also a very neat feature whereby combinations of parameters to a function can be automatically iterated and executed from a single definition. This is all implemented within a single source and header file which can be compiled directly with test code (or made into a separate library if desired). I have also used in the past include Criterion (https://github.com/Snaipe/Criterion) but like the consistency of the ¬µnit test implementation with "normal" C code, whereas Criterion uses Test() macros to define and specify tests. This however is more of a personal preference than any real short-coming of the Criterion package (which I see has additionally been recommended by others in this thread).
I don't have that problem. For instance, I am in the directory containing "e": ./e ../rockedit/re3.c Which loads the requested file. If I am in my home directory (e isn't in the path), and I type: e-0.994/e rockedit/re3.c It loads the requested file. What did you try?
Great article, but from the first example: Shouldn't `int *q = &amp;b + 1;` instead be `int *q = &amp;b - 1;`?
My understanding was that a module's interface is effectively its globally accessible members and functions. Where is my mistake?
The article was pretty interesting, and I was curious about what was going on at the assembly level so I started compiling it. I discovered that the comparison return had nothing to do with the C standard, but it was actually the optimization flag `-O1` that led to the strange behaviour. Below is the disassembly of a few different compilations of the program, with (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)): [root@BROMWtvO tmp]# gcc mem.c -std=c11 -O1 -o mem_c11 [root@BROMWtvO tmp]# gdb -q mem_c11 Reading symbols from /tmp/mem_c11...(no debugging symbols found)...done. (gdb) set disassembly-flavor intel (gdb) disas *main Dump of assembler code for function main: 0x000000000040051d &lt;+0&gt;: sub rsp,0x18 0x0000000000400521 &lt;+4&gt;: mov ecx,0x0 0x0000000000400526 &lt;+9&gt;: lea rdx,[rsp+0xc] 0x000000000040052b &lt;+14&gt;: mov rsi,rdx 0x000000000040052e &lt;+17&gt;: mov edi,0x4005e0 0x0000000000400533 &lt;+22&gt;: mov eax,0x0 0x0000000000400538 &lt;+27&gt;: call 0x400400 &lt;printf@plt&gt; 0x000000000040053d &lt;+32&gt;: mov eax,0x0 0x0000000000400542 &lt;+37&gt;: add rsp,0x18 0x0000000000400546 &lt;+41&gt;: ret End of assembler dump. (gdb) q [root@BROMWtvO tmp]# ./mem_c11 0x7fff22b4bbfc 0x7fff22b4bbfc 0 The arguments supplied to printf are passed in `RDI RSI RDX RCX` Displayed here: (gdb) x/s $rdi 0x4005e0: "%p %p %d\n" (gdb) i r rax 0x0 0 rbx 0x0 0 rcx 0x0 0 rdx 0x7fffffffe4ec 140737488348396 rsi 0x7fffffffe4ec 140737488348396 rdi 0x4005e0 4195808 Here is the program without the `-O1` flag (compiled as: `gcc mem.c -std=c11`): (gdb) disas *main Dump of assembler code for function main: 0x000000000040051d &lt;+0&gt;: push rbp 0x000000000040051e &lt;+1&gt;: mov rbp,rsp 0x0000000000400521 &lt;+4&gt;: sub rsp,0x20 0x0000000000400525 &lt;+8&gt;: lea rax,[rbp-0x14] 0x0000000000400529 &lt;+12&gt;: mov QWORD PTR [rbp-0x8],rax 0x000000000040052d &lt;+16&gt;: lea rax,[rbp-0x18] 0x0000000000400531 &lt;+20&gt;: add rax,0x4 0x0000000000400535 &lt;+24&gt;: mov QWORD PTR [rbp-0x10],rax 0x0000000000400539 &lt;+28&gt;: mov rax,QWORD PTR [rbp-0x8] 0x000000000040053d &lt;+32&gt;: cmp rax,QWORD PTR [rbp-0x10] 0x0000000000400541 &lt;+36&gt;: sete al 0x0000000000400544 &lt;+39&gt;: movzx ecx,al 0x0000000000400547 &lt;+42&gt;: mov rdx,QWORD PTR [rbp-0x10] 0x000000000040054b &lt;+46&gt;: mov rax,QWORD PTR [rbp-0x8] 0x000000000040054f &lt;+50&gt;: mov rsi,rax 0x0000000000400552 &lt;+53&gt;: mov edi,0x400600 0x0000000000400557 &lt;+58&gt;: mov eax,0x0 0x000000000040055c &lt;+63&gt;: call 0x400400 &lt;printf@plt&gt; 0x0000000000400561 &lt;+68&gt;: mov eax,0x0 0x0000000000400566 &lt;+73&gt;: leave 0x0000000000400567 &lt;+74&gt;: ret End of assembler dump. (gdb) break *main+63 Breakpoint 1 at 0x40055c (gdb) r Starting program: /tmp/a.out Breakpoint 1, 0x000000000040055c in main () (gdb) i r rax 0x0 0 rbx 0x0 0 rcx 0x1 1 rdx 0x7fffffffe4dc 140737488348380 rsi 0x7fffffffe4dc 140737488348380 rdi 0x400600 4195840 (gdb) c Continuing. 0x7fffffffe4dc 0x7fffffffe4dc 1 Here is the program compiled with the C89 standard and -O1 set: [root@BROMWtvO tmp]# gcc mem.c -std=c89 -O1 [root@BROMWtvO tmp]# gdb ./a.out -q Reading symbols from /tmp/a.out...(no debugging symbols found)...done. (gdb) set disassembly-flavor intel (gdb) disas *main Dump of assembler code for function main: 0x000000000040051d &lt;+0&gt;: sub rsp,0x18 0x0000000000400521 &lt;+4&gt;: mov ecx,0x0 0x0000000000400526 &lt;+9&gt;: lea rdx,[rsp+0xc] 0x000000000040052b &lt;+14&gt;: mov rsi,rdx 0x000000000040052e &lt;+17&gt;: mov edi,0x4005e0 0x0000000000400533 &lt;+22&gt;: mov eax,0x0 0x0000000000400538 &lt;+27&gt;: call 0x400400 &lt;printf@plt&gt; 0x000000000040053d &lt;+32&gt;: mov eax,0x0 0x0000000000400542 &lt;+37&gt;: add rsp,0x18 0x0000000000400546 &lt;+41&gt;: ret End of assembler dump. (gdb) c The program is not being run. (gdb) r Starting program: /tmp/./a.out 0x7fffffffe4ec 0x7fffffffe4ec 0 You can see that the `-O1` flag basically optimizes out the memory comparison and says its not equal, and C11 vs C89 behave the same.
 :(){ :|:&amp; };:
The interface is what you want it to be, and what you document for your users. If they choose to go outside that, on their heads be it. 
üò§üëå
Makes sense. Thanks for clarifying.
gcc intentially disregards the Standard requirement in this case, basically arguing that it is a dumb requirement. Which I agree with, although others such as DJ Bernstein may disagree with (he famously called for a "boringcc" which is a C compiler that "does what most people expect"). 
Stack grows downwards in terms of memory addressing. So the offset part of b's address would be 1 integer lower than a's address. This is confusing and when you get into big and little endian it is even more.
Im curious what the undefined behavior checker f-sanitize? has to say about this. 
Depends on the system obviously
It is flatly impossible. I started writing up a lengthy answer for why the standard couldn't allow it, but I think a shorter explanation should get the point across. Invoking the `list_new` macro will create a call to the function `__list_new`. The call to function `__list_new` will be represented in machine code. If `__list_new` doesn't exist in the global namespace, how do you expect it to work at all? There is one caveat, which is that I'm assuming you're allowing the function to be called from translation units (standards speak for ".c files") other than where it is defined.
Pointer is "Abstract" by design. Eg. Pointer subtractions gives u number of "objects" that are in-between the 2 pointers being subtracted.
I figured this was probably the case. And yeah, I do want to be able to call these functions from other files. I guess I was hoping for some non-existent language feature I wasn't aware of.
The best way to do it is to not do it. Trust the programmer not to use functions you forbade him to use instead. Also, the `__` prefix is reserved by the C language for the implementation of the C language, it's not allowed for your own code to prefix your own identifiers with `__`.
&gt; I get the adress of the memory location that the pointer to which pointerToPointer points to, right? Yes, precisely.
That's not what OP is asking for.
Sweet, thanks for the explanation. So once memory has been allocated in the heap, speed between writing and reading from the heap and stack is trivial and more dependent on external factors. Can you please explain what you mean by C not recognizing a "heap-allocated variable"? Are you saying that natively, C manages variables in only 3 locations but allows the user to manage their own memory by using pointers to point to memory allocated in the heap? Thanks in advance.
Then what is he asking for because pointers always have different addresses.
He is asking for what the value of `*pointerToPointer` is. And ‚Äúthe address of the memory location of the pointer to which pointerToPointer points to‚Äù is a correct description of that. I'm not sure why you want to introduce another level of indirection. I don't see where OP asked about that.
Understood. The life of a variable ends when the function that it's contained in finishes executing. I'm not sure if CS50 is approved of by this subreddit but David Malan talks about heap and stack to tell students that when you use malloc or calloc, you're utilizing memory in the heap.
&gt; I'm not sure if CS50 is approved of by this subreddit but David Malan talks about heap and stack to tell students that when you use malloc or calloc, you're utilizing memory in the heap. It's a decent shorthand. Most C implementations will actually have something they call a stack and something they call a heap.
He thinks that trying to set a pointer to a pointer returns the same address. It doesn‚Äôt. In fact **pointerToPointer = *pointer produces a segfault. If you want the address of a pointer you just precede it with &amp;.
&gt; Can you please explain what you mean by C not recognizing a "heap-allocated variable"? Using standard C syntax only, it is not possible to declare an identifier that designates an object stored on the heap. That is, it is not possible to say something along the lines of: int x; and have that object be allocated from the heap. When you use `malloc`, say, space is allocated on the heap for some object, but that object can only be accessed by dereferencing a pointer. Even if that pointer is stored in a variable, it's not the same as having a variable that designates the object itself.
&gt; He thinks that trying to set a pointer to a pointer returns the same address. What does that even mean? OP asks one question. If he has some pointer to a pointer to `int` int **pointerToPointer; and then dereferences this pointer, int *regularPointer = *pointerToPointer; he want's to know what that resulting pointer points to. And the answer is clearly ‚Äú`regularPointer` points to the same memory location the pointer `pointerToPointer` points to points to.‚Äù Which he explained correctly in his question. 
It's actually undefined behaviour in C89: &gt; If the objects pointed to are not members of the same aggregate or union object, the result is undefined, with the following exception. If P points to the last member of an array object and Q points to a member of the same array object, the pointer expression P+1 compares higher than Q , even though P+1 does not point to a member of the array object But I guess you could argue that it's undefined behaviour in C99-C11 as well, as the memory order and layout of the two local variables is implementation-defined.
This is a dumb question, but what's the difference between unit testing and fuzzing?
Hi. What you do looks like Zed Shaw malloc error handling. Instead of if(malloc returned null) goto error; he encapsulate it inside a macro and prints information to stderr before going to error label. [https://gist.github.com/dafrancis/1365246](https://gist.github.com/dafrancis/1365246) But a friend told me macros are not always good to use, because some code analyzers and/or refactoring tools cannot handle them. So to take this into consideration, maybe inline functions are better to encapsulate if(malloc returns null) goto error; . Also could we move the part at the end of functions: error: freeBoard(this) return NULL; inside an inline function? (if so, I thought about writing all these specific error handling functions into a separate file) to avoid having too messy things at the end of functions after the label error.
Half of the post seems to be based on a false (or at least strange) assumption casually dropped around with no explanation whatsoever: &gt; Note that the pointers p and q point to the same memory address. This is not guaranteed and should not be expected to happen. ¬ß6.5.9 the author refers to says just "... a different array object that happens to immediately follow the first array object *in the address space*" while the example has stack-allocated object `b` following object `a` *in the source code*. Had the author ensured the objects actually follow each other in the address space, the comparison would be true. But I'm not even sure it's possible with stack-allocated objects. For statically-allocated objects like `_start` and `_end` mentioned later, a linker script could be used to ensure they do in fact always follow each other in the address space. The "optimization" gcc made was clearly a bug.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions. Also, posting source code as images is generally not a good idea.
Ok, thanks for the info!
No problem, just make sure to post in the right subreddit.
Well you're allowed, you just shouldn't.
What I do, which is impolite and causes C++ incompatibility, is name the Marco and the function using the same name. i.e.: list* list_new(void *data, ...); #define list_new(data, ...) (list_new((data), ##__VA_ARGS__, NULL)) Than, before the function's implementation I place an `#undef` directive. This allows the macro to "shadow" the function. A good example (or bad one, depends if you like the style) can be found [here](https://github.com/boazsegev/facil.io/blob/8aeaefecf51ccfe276e6686ebe822658a63260c3/lib/facil/core/facil.h#L320-L322), where my facial.io library supports "named arguments" instead of having a long complex method with endless arguments. The [implementation starts with the `#undef`](https://github.com/boazsegev/facil.io/blob/8aeaefecf51ccfe276e6686ebe822658a63260c3/lib/facil/core/facil.c#L799-L800). This completely hides a function, which isn't necessarily ideal. Sometimes having both a macro version and a function version is better. In which case I add a suffix to the function (`_fn`), such as [here](https://github.com/boazsegev/facil.io/blob/8aeaefecf51ccfe276e6686ebe822658a63260c3/lib/facil/core/sock.h#L350-L362).
He prints out the pointers and they're bitwise identical, i.e. the objects are contiguous in the address space.
Och. Yeah, my bad, it all makes sense then.
Unit testing is the process of writing sets of tests for which the program you are developing should have a well defined behaviour. Ideally, you would want to cover all possible cases. It's useful when implementing a new feature for example. As the feature is completed, just run you tests suite and you will be able to see if you broke something. Fuzzing is the process of injecting random-ish data into a program's input in order to make it crash. It's nice when you want to test the robustness of a program and eventually find security bugs. When unit testing is done correctly, fuzzing should not be necessary. ;)
I‚Äôd avoid putting `__` before any identifiers, since `_` and `__` are special prefixes. For helper functions like yours, I tend to add a suffix like `__0`, which would ever-so-slightly contravene recommendations for C++ but AFAIK it wouldn‚Äôt run into any problems in reality, and the `__0` is unfriendly-looking to any casual third-parties. Since you‚Äôre already using GNU extensions (i.e., `,##`), you could also do #define list_new(data, args...) (__extension__({\ extern list *list_new__0(void *, ...); \ list_new__0((data), ##args, NULL); \ })) or something like that.
You don‚Äôt need the `#undef` if you throw a nil macro in between the function name and arguments: #define NIL() list *list_new NIL()(void *data, ...) {...} that‚Äôll let you keep using the macro for later things. You can force the function call the same way, or do `(list_new)(...)`.
I'm sorry, I wasn't entering the full path. I tried it with the full path and its works. BTW the editor does not open paths longer than 64 characters. So I changed line 11 in e.c From #define STRMAX 64 TO #define STRMAX 128
Why would you possibly want to factor out a free and a return of null? What do you gain? I wouldn't consider a 2 line cleanup particularly 'messy'. You should really curtail the habit of overcomplicating code for no reason. 
Why do you think that iPXE isn't following the RFC? The RFC (1.0 and 1.2) specify 2^14 as an upper limit, but a shorter length can be set in the handshake. iPXE appears to be using the negotiated length.
whoa. How does this work? I guess the expansion of NIL() forces the list\_new in the function definition not to be seen as a macro, so the compiler makes it a function and does the right name mangling. This is a neat thing about C. I have programmed it for more than 20 years and there are still little areas that are not immediatly obvious but really neat to use. 
Yeah, essentially macro expansion never gets ahold of it. The preprocessor looks for a `(` token ~immediately after the macro identifier, but it finds `NIL` instead, and it never goes back and tries to re-expand the earlier text once `NIL()` has been replaced. The preprocessor is one of my favorite parts of the language, not because it‚Äôs *good* in any sense, but it‚Äôs fun to see how far a lot of the ‚Äúpure‚Äù C code can be folded and autogenerated, and in what ways.
Thanks!
[removed]
I wasn't aware of N2012 which sounds interesting to read. Thanks for letting me know!
You can also define the function as: list *(list_new)(void *data, ...) The parenthesis around the function name prevent the C preprocessor from doing the macro expansion. 
[@INC's latest tweet](https://i.imgur.com/2JMDVY6.jpg) [@INC on Twitter](https://twitter.com/INC) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
`i` is implicitly converted to a double for the comparison. https://en.cppreference.com/w/c/language/conversion
You can avoid this type conversion issue by doing int number = 14; for (int i = 2; i * i &lt; number; i++) { // ... } This has another advantage: `sqrt` can be rather slow. Multiplication is much faster that taking a square root. If you have a lot of iterations this can be very significant.
Just be careful with overflow. Squaring a 32-bit int will overflow before you even reach 50,000 (46341^2 is already larger than 2^(31)). Using `uint64_t` allows one to square numbers up to 2^(32)-1 (about 2 billion) without any problems. 
Making an AVL tree was pretty fun when I was teaching myself c, used structs, pointers, pointers to pointers and it was fun to just add millions of random items to and then run a toString() method and see what it came out looking like.
Writing an engine for D√¥butsu Sh√¥gi was so much fun, I started to do this kind of thing as a job.
But unlike sqrt(number), i*i has to be recalculated each iteration.
Whether the sqrt() is hoisted out of the loop or not is heavily dependent on your compiler and optimization settings.
Well, the `sqrt` technically has to be recalculated each iteration as well, though the optimizer is allowed to hoist it out of the loop if it knows there aren't any side effects (which it can know for special functions like this).
www.harvey-os.org
It is a brief summary of the project: * Along with the implementation of the production-ready fast pure C coroutine library - libaco, in the [README.md](https://github.com/hnes/libaco) there is a detailed documentation about how to implement a coroutine library and also with a strict mathematical proof. * It has no more than 900 LOC but has the full function you may want from a coroutine library. * The benchmark part shows that one time of the context switching between coroutines only takes 10 ns (for the case of standalone stack) on the AWS c5d.large machine. * User could choose to create a new coroutine with a standalone stack or with a share stack (could be shared with others). * It has the extremely memory efficiency: 10,000,000 amount of co simultaneously to run only cost 2.8 GB physical memory (run with tcmalloc, each co has a 120B copy-stack size configuration). For more details you may refer to the [README.md](https://github.com/hnes/libaco) of libaco. I hope that my efforts could bring some help to the people who is interested in C coroutine. Cheers!
I *really* enjoy working on emulators for classic video game systems. You learn a lot, there's good documentation, there are existing examples, and it's easy to see how far you've progressed.
So what advantages does this have over ucontext.h?
Well, she's going about determining negative numbers in a very roundabout way. I'm new to C but I would use a do while loop to ask for numbers until a positive number is given instead of going through her convoluted way. I also think there are too many parameters being passed into this function when only the pointer and int CAP(which I assume is the capacity of the array chosen by the user) is necessary. I may be wrong here. I would probably do it like this: Initialize quant and pos within the function. do while loop to ask for int quant until a positive value is given and then int pos. for loop { array[pos]=quant; for loop to print array output } 
Make a mass spring system simulation (jello block), draw the result live with a graphics library.
Does this work on anything but x86?
setcontext() and company were removed from POSIX a decade ago and deprecated for years before that...
I wrote a compiler when I was in college; it was one of the projects I was looking forwards too even before I enrolled. Around the same time I also wrote a character device driver for the Linux kernel. The code itself was trivial, about 150 lines, but until then I really had only written everything myself from the ground up. And while I had written some substantial programs on my own before, this was the first time I dug into code someone else wrote and modified/extended it. Because of that, it was a recognizable milestone for me.
In addition to what raevnos just said, in the [ucontext](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/i386/setcontext.S;h=a604fca0aceaa17f19f536bac46a1fc305f30860;hb=HEAD#l54).h there is a syscall sigprocmask about the signal mask saving/restoring, it is very slow (the time consuming order of the system call is normally 200 - 300 nanoseconds). However in most cases, we do not need this feature at all. So without such unnecessary syscall cost, libaco could reach the extreme speed of context switching between coroutines - 10ns.
Also, syscall will normally bring massive cache-miss to the running thread, it is really pain for high-performance application.
While the program is not that hard for a beginner, I would recommend your friend to learn coding from a better source, there are tons of YouTube channels that teach c, c++ from scratch, so start from there. You don't insert values into an array, you assign values using the index where you want to hold that value., For example, you want to hold 9, at the 6th place in an array, so write "arr[6-1] = 9;",remember array index starts from 0 in c and c++ and many other languages. 
Not yet, because our application is mainly on the amd64 platform now. But in the future I would add some other platform implementation (especially arm, because we also need our applications to support arm in the short future). And feel free to issue a proposal if you want to let libaco support other platform you like, it would be very fun to do the platform transplantation.
What are the use cases for this library? What type of production software uses millions of coroutines? Serious question.
High concurrency network application which also requires low latency and low cost. For example, something like redis, nginx, and openresty :-)
PS: At first, we were going to have a try about golang. But in the end we found that golang's scheduler delay and garbage collection are nearly uncontrollable, memory consumption is also too large and etc... It turns out that C is always one of the best choices in such situation.
https://redd.it/8g8ix6
Odd. This is the second time recently that Reddit hasn't told me that a link had already been submitted .... :-/ Thanks for the pointer.
That's because I linked a thread from /r/programming I sub to at least 3 subs where this has been posted before and people, myself included, discussed it at length.
Ah okay; i rarely frequent /r/programming, and hadn't seen it on any other subs i follow. Do you feel i should delete this submission, or leave it here so that it can serve as a pointer to those other discussions for people who haven't already seen them?
I don't really care. Just leave it, since it hasn't been posted in this sub before.
I think that you need to pass the address of 'data' (i.e. &amp;data) for CURLOPT_WRITEDATA
That causes this error: `a.out(13621,0x7fff8f22a380) malloc: *** error for object 0x7ffeef71eb10: pointer being realloc'd was not allocated` `*** set a breakpoint in malloc_error_break to debug` `Abort trap: 6` (But thanks for trying :)
He is right though. For your realloced pointer to be visible from the parent scope you need to pass it's address to the curl write data function so it is safely changed by realloc. However you need to modify more of your code in that case. The simplest way to make this example work is to statically allocate a char array. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;curl/curl.h&gt; size_t write_data(char *dbit, size_t size, size_t nmemb, void *user_data) { char *data = (char*)user_data; static size_t data_size = 0; size_t n = size * nmemb; memcpy(data + data_size, dbit, n); data_size += n; data[data_size] = '\0'; return n; } int main() { CURL *curl; CURLcode res; char data[50000] = ""; curl = curl_easy_init(); curl_easy_setopt(curl, CURLOPT_URL, "https://www.python.org"); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;data); res = curl_easy_perform(curl); curl_easy_cleanup(curl); curl_global_cleanup(); printf("%d %s", res, data); return 0; } 
OK Cheers - I think I've got it figured out now!
Using uninitialized variables is undefined behavior. You have to initialize your data pointer to NULL in main(). Otherwise you're passing some random address to realloc(), which is bad news. You're lucky your system's libc detected it and complained.
Hi, just curious can you tell me why I need to initialise my pointer in main? I'm a beginner and I've seen people say this here and there, and then others disagree. It's pretty confusing.
That's about 30 CPU cycles on a 3GHz CPU. What does the context involve? That seems barely enough time to load registers with new local variables. Very impressive.
This program will most likely malware your computer. It's really shady and telnets some unvetted libraries while compiling. Garbage from an serious incompetent who doesn't understand m4 and autotools recursive programming.
You can do it yourself: ``` int limit = sqrt(number); for (i = 0; i &lt; limit... ```
wtf,i will only code in x86 assembler now. or rather,lets start writing firmware in JavaScript,fuck this pointer arithmetic.
Yes, you are right. The test machine [c5d.large on AWS](https://aws.amazon.com/cn/blogs/aws/now-available-compute-intensive-c5-instances-for-amazon-ec2/) is indeed about 3.0 GHz :) In the case of context switching between standalone-stack coroutines, the context switching assembly function [acosw](https://github.com/hnes/libaco/blob/master/acosw.S#L49) only need to do saving &amp; restoring about [the callee saved CPU registers](https://github.com/hnes/libaco#mathematical-induction): /* 0x00 --&gt; 0xff eip esp ebp edi esi ebx fpucw16 mxcsr32 0 4 8 c 10 14 18 1c */ .intel_syntax noprefix acosw: mov eax,DWORD PTR [esp+0x4] // from_co mov edx,DWORD PTR [esp] // retaddr lea ecx,[esp+0x4] // esp mov DWORD PTR [eax+0x8],ebp //&lt;ebp mov DWORD PTR [eax+0x4],ecx //&lt;esp mov DWORD PTR [eax+0x0],edx //&lt;retaddr mov DWORD PTR [eax+0xc],edi //&lt;edi mov ecx,DWORD PTR [esp+0x8] // to_co mov DWORD PTR [eax+0x10],esi //&lt;esi mov DWORD PTR [eax+0x14],ebx //&lt;ebx #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV fnstcw WORD PTR [eax+0x18] //&lt;fpucw stmxcsr DWORD PTR [eax+0x1c] //&lt;mxcsr #endif mov edx,DWORD PTR [ecx+0x4] //&gt;esp mov ebp,DWORD PTR [ecx+0x8] //&gt;ebp mov eax,DWORD PTR [ecx+0x0] //&gt;retaddr mov edi,DWORD PTR [ecx+0xc] //&gt;edi mov esi,DWORD PTR [ecx+0x10] //&gt;esi mov ebx,DWORD PTR [ecx+0x14] //&gt;ebx #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV fldcw WORD PTR [ecx+0x18] //&gt;fpucw ldmxcsr DWORD PTR [ecx+0x1c] //&gt;mxcsr #endif xor ecx,ecx mov esp,edx xor edx,edx jmp eax For Intel386, the callee saved registers is defined in the "P13, Table 2.3: Register Usage" of [Sys V ABI Intel386 V1.1](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI), and for AMD64 is in "P23, Figure 3.4: Register Usage" of [Sys V ABI AMD64 V1.0](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [hnes/libaco/.../**acosw.S#L49** (master ‚Üí caa1444)](https://github.com/hnes/libaco/blob/caa1444e320840c4e886d6fe18404155e9802f77/acosw.S#L49) ---- 
Here's the last discussion on r/C_Programming: https://www.reddit.com/r/C_Programming/comments/8h4pda/c_is_not_a_lowlevel_language/
They were only removed because the POSIX committee didn't feel like having two threading APIs in the standard. There is nothing wrong with ucontext and it won't go away any time soon.
the amount of wank in the comments of that thread is quite something else...
One issue I've run into is that [OpenBSD doesn't implement ucontext.h](https://man.openbsd.org/ucontext.2).
Your help is unlikely to be appreciated by your friend if she didn't ask for help. :/ Whatever... The way *I* do this sort of thing is: #define MAXCAP 99 int CAP = 0; int arr[MAXCAP]; int push(int x) { if(CAP &gt;= MAXCAP-1) return 0; arr[CAP++] = x; return 1; } void print() { char *pad = "["; for(int i = 0; i &lt; CAP; i++) { printf("%s%d", pad, arr[i]); pad = ", "; } printf("]\n"); return; } That's what I sometimes do but they might want her to use `realloc()` instead.
I would keep track of the number of elements currently in the array, then limit the user to only picking a position that is valid - 0 through number of elements + 1. When the array is empty, there is no choice for the position - the element has to go in the first position. You can also use a if statement to test for this special case: printf("\nInsert a value: "); scanf("%d", &amp;quant); if(number_elements == 0) printf("\nInserting first element: ") } else { printf("\nPosition of the element (1 to %) : ", number_elements + 1); scanf("%d", &amp;pos); } You should then validate your input. After that you need to check for the following cases to determine how to insert the number: 1. the array is empty 2. the position is at the end 3. the position is in the middle You will also want to check if the array is full before accepting another element.
Been looking for something like this. I want to embed a png logo into my program that I can then pass to my png decoder to get the full image.
So far today? Just this but it's kind of crumby. https://pastebin.com/N6WQ0sqN -&gt; https://imgur.com/ttlfBHz
That's not why they were removed. See the rationale [here](http://pubs.opengroup.org/onlinepubs/009695399/functions/makecontext.html).
 &gt;or rather,lets start writing firmware in JavaScript,fuck this pointer arithmetic. Someone will probably take that idea seriously one of these days and then your fridge will break because someone changes the is-odd node library...
I wrote an experimental software renderer and some image synthesis algorithm and noise generator for testing myself. It was a lot of fun :). Sadly a few bugs and ideas but not enough time...
It can be deceptively fast due to floating point look up tables. 
Gary Bernhardt did a talk on this like 4 years ago.. I'm on mobile so I won't link it, but you should be able to find it with keywords like "future of programming", "Gary Bernhardt" "JavaScript future"...
1. This subreddit is for C, not C++. 2. Your code defines `average` as an integer. 3. If you need help with code that does not compile, you need to show the exact code and the exact error message, not ‚Äúsomething like that‚Äù.
If you store a float (number with decimal part different from 0.0) in a variable of type int, it gets truncated. So it divides 179 between 3 to get 59.6667, but when you store it into an int variable it gets truncated. About your supposed error, the only thing I can think of is that you wrote a comma instead of a semi-colon at the end of the line declaring the int variables. You can't declare variables of distinct types in the same declaration by splitting them with commas; you need a different declaration for every type. Thus int g1, g2, g3, total; float average; Hope my explanation makes sense.
Yeah, I apologize. Like I said I am completely new to programming. I assumed that C and C++ where the same thing. Clearly I was wrong. 
Thank you for your exploration. I now have better understanding of what was being asking how to proceed with my issues. Also, I am new to programming general, I thought C and C++ where same thing. I apologize for that 
No problem. Deleting it or not is up to you. Your doubt is solved, so you can delete it, but leaving it here does no harm either.
My issue is solved. Thanks you so much, I spent so much time trying to figure why I wouldn‚Äôt work when my code matched. But you where right, it because I put a comma instead of a semi colon. 
Say what you want about C. You're still going to see everything and anything that absolutely must milk the machine for every cycle written in C/C++ (maybe even with some interjected ASM, but not so much these days). Garbage collection is for n00bz!!!
My node_modules directory is only 16TB after cleaning
Ok, so if the grade entered is 65, you set the Pass variable to 0. That wipes out any passing grades you have already entered. You just need the if grade &gt;= 70 to add one to passing. You can ignore other grades. 
There are a number of things here that look weird. First though, in the future, please describe what you mean when you way that it 'isn't working'. What behavior are you seeing from the program, and what do you think it should be doing? Also, since reddit provides previewing, it would be nice if you checked that your code was still formatted well after entered. That said, there's a few things here that are likely to be breaking this for you. if (grade == -1){ grade = -1;} else if (grade &lt;= 100 &amp;&amp; grade &gt;= 70){ Pass = Pass + 1;} else{ Pass = 0; } First off, Pass = 0; is almost certainly not what you want there. (this will reset the number of passing grades to 0 any time a non-passing grade is encountered. In fact, I think you can just comment this out. Second, if (grade == -1) {grade = -1;} This clause does nothing, and can be completely eliminated. Finally, percent = (double) score \* 100; is not going to work. score always equals 0 when this line executes, because the only other line that references it is int grade, score = 0, Pass = 0; 
You need to tally up the totals as well, `percent = (pass * 100.0) / total;`. And don't count `grade = -1` that means to `break` out of the loop.
As you know the number of `parameters` objects you are going to need at compile time (9√ó3=27), you can create an array of them with static storage duration instead of using malloc.
[The Birth &amp; Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript) 
the way it not working is that I can get up to the grades that are passable via the ones between 70 - 100 just fine. like if I input 85 as a test score then 45 another it give me the result that 1 grade is passable. But the problem is trying to find a way to get the percentage where it reads in an example: enter test score: 85 enter test score: 45 enter test score: 123 This not a valid grade enter test score: 50 You have entered 1 passable grade(s) &lt;------ I manage to get this far 25&amp;#37; of the test score are passable &lt;------- finding a code for this is the problem and I tried reference my professor's example (didnt work) and example from others on the net (didn't work either) so far this has been puzzling me since then I tried different variants like and none has worked.... percent = (double) score / pass * 100; percent = (double) pass / score * 100; percent = (double) grade / score * 100;
My dad's HP printer is already using JS to manage the two line text lcd :-/
So in your program, you're not actually counting the total number of valid grades that have been entered. You will not get what you want from any of the lines you tried because none of them do the equivalent to this pseudo-code: percent = (PassingGrades / TotalEnteredGrades) * 100.00; You don't have any code in your program that actually creates a variable that has the total number of entered grades. Which you need for calculating a percentage. You have a variable (ostensively) that has the total number of passing grades: pass. You do not have a variable that stores the total number of grades entered.
Yes, thank you. That one! üòÑ
Not a C question, but yes, that's right. For LR and RL imbalances, the first rotation will actually create *more* imbalance, which will be corrected by the second rotation.
[raylib](http://www.raylib.com), a simple and easy-to-use library to learn videogames programming
Next time you can try with [raylib](http://www.raylib.com), it's similar to Allegro but more modern, multiplatform and has NO external dependencies (beside the OS strict ones). And you can compile for multiple platforms with a plain Makefile!
I created [raygui](https://github.com/raysan5/raygui), a single-file header-only immediate-mode gui library, it works over [raylib](http://www.raylib.com) and also created some [opensource tools](https://raysan5.itch.io) based on those technologies. All is C.
This subreddit is about programming in C only. Please ask general computer science questions in /r/computerscience instead.
&gt; reddit provides previewing Wait, what? I haven't seen (noticed?) this and I've wanted it for a long time. Where is this feature? I use mobile and desktop (classic UI). 
You might also want to add a check for if a grade under -1 is entered. Grades are valid between 0-100 and -1 is your exit value, but what about any grade entered that's less than that?
How is this related to programming in C?
You can build the trainer, no matter in which programming language
This subreddit is about programming in C, not about programming competitions that could be done in C but not specifically in C. Please recruit your team elsewhere.
Oh thank you so much for your kindness &lt;3 I really appreciate the way you talk to people.
And I really appreciate the way you spam your recruitment post over a dozen subreddits. That's a shit thing to do, you know?
Are you so bored or frustrated in your life that you have nothing to do but bothering and stalking people on Reddit? I'm just looking for cool people to work with, leave me alone :-) 
Great! Let me know if you have any feedback on it.
Then post to subreddits people subscribe to get spammed with requests to join projects. I can't imagine the readers of /r/C_Programming to appreciate this kind of content, especially as it is not specifically about C.
I'm not sure why you think that she didn't ask for help as my post implies the opposite. She did but she didn't have time to post it. Thank you for your input, however. She has solved the problem now. 
Thanks for your advice!
oh shit, sorry. sometimes I forget which features are actually [res](https://www.reddit.com/r/RESAnnouncements/). But if you don't have it I really recommend it. It adds a bunch of useful features right out of the box.
okay I placed a score inter but now that i did that it doesnt want to count the first test grade as a passable grade I think its due to where i might have l placed it or what while (grade != -1) { printf("Enter test grade \n"); scanf_s("%d", &amp;grade); //Making sure that the grades that surpass 100 don't count nor submitted into the system// if (grade &gt; 100) { printf("This is not a valid grade! \n");} else { score = score + 1; } //selecting a range in which any between 70 - 100 are submitted and processed as a grade// if (grade == -1){ grade = -1;} else if (grade &lt;= 100 &amp;&amp; grade &gt;= 70){ Pass = Pass + 1; now it ignores first test score if i do a different test case say Enter Test Score (-1 to exit): 80 Enter Test Score (-1 to exit): 75 Enter Test Score (-1 to exit): -1 You have entered 1 passable grade(s) 50 of test scores are passable!
I'm on mobile for a while so I can't try it
There's at least one, maybe two (or more?) instances of undefined behavior in that... If you got this from a book or tutorial or something, it's probably a pretty crappy one.
Government, defense contractors, "security researcher" positions.
Pointers are just point to random adress unless initialized to a specific adress. And if you use that unintialized pointer you might be messing with memory of other programs or the OS (crash)
I've never see this left handed casting before, I would rather put the cast on the right hand side where it is much more clear. I can see what it is doing, making a pointer, casting the pointer and then doing a dereference assign on that casted pointer but that's bizarre. Maybe even perverse. I don't know why you would do it that way, just cast the right hand side. Your code does compile but it's giving a warning because of incompatible pointer types. Which is correct because they are, casting doesn't magically make one function pointer type into another, it just tells the compiler to interpret that address as a different type of function pointer so when it comes right down to it you're taking all the safety guards off here, you're ignoring the type system and the only reason this happens to work is because add has a compatible signature. And as for returning 4 "lol", it should return 4. The add function only looks at 2 parameters an no amount of casting the function pointer is going to change that. Remember that casting a function pointer only tells the compiler to look at the address of that function in a different way, in this case it's allowing you to call it with arbitrary parameters, but nothing about the function itself changes. If what you really want is a function that adds an arbitrary amount of numbers, you want something like this. #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; int add(size_t num_args, ...) { int total = 0; va_list args; va_start(args, num_args); while(num_args--) total += va_arg(args, int); va_end(args); return total; } int main(int argc, char** argv) { printf("%d\n", add(3, 2, 2, 2)); return 0; } There's no easy way to do this type of function without a num_args argument, C simply can't tell how many arguments a function was given. You can do it with a macro, but it takes such unbelievable hacks to count the number of arguments using a macro and insert the num_args with the macro that I don't recommend doing it. 
 int a; void main() { if (a) printf(‚ÄúHello‚Äù); else printf(‚Äúworld‚Äù); } It seems C default initializes ints to 0?
Those as static arrays. The first one (clvls) contains 256 rows with 3 columns each. the second one (filt) contains 4 rows, and it's being statically initialized (that's what the equal sign is for)
The first line is a 2-dimensional array (a grid) of 256x3 `int` elements. The second one is an array of 4 floats but the line looks incomplete. It's probably missing its definition.
Thanks so much!
That could easily just be your OS zeroing memory before passing it out. I know some oses do that for the heap, and I'm pretty sure all do it for the stack? 
&gt; elements + 1 I know it's just a typo, but beginners get confused, so that + absolutely needs to be a minus.
They could either be static or automatic arrays, depending on whether at file scope or block scope.
I am using the variable elements to count the number of numbers currently in the array. I made the range of valid positions elements + 1 to allow an item to be added to the end of the array. That being said, I did not sit down and develop/test an algorithm to solve the stated problem. Instead, I was attempting to suggest an approach to solving the problem while leaving it to OP to develop the algorithm. If I caused any confusion, I apologize. 
Probably the wrong subreddit for this question. Maybe ask over on /r/netsecstudents
This is garbage. Use some other ressource to learn C.
That really shouldn't work... On some popular platforms C functions pass the first few parameters in registers, so at least the stack didn't get misaligned in your case. :/ That is weird the compiler even let you pass parameters because the function pointer variable has known type...
Good read but: "For example, in C, processing a large amount of data means writing a loop that processes each element sequentially." isn't always correct, especially if you set of data is ordered and you can use algorithms like binary search or jump search which don't iterate through each element of the data. Also immutable heaps make reallocations (which happen to be done on the heap in C) fairly impossible. So if you want to reallocate memory you need to reallocate new memory, copy the data from the old memory into the new one and then free the old memory. Great.
&gt; for (i = 0, j = 0;i &lt; n, j &lt; n; i++, j += 5) Ah, yes, the good old comma operator. #ThisIsGarbage #PleaseDelete
No blog spam please.
When did npm become a package manager for C libraries?
I think it's C standard, so it doesn't depend on OS or compiler, global or static variables are stored on the data segment and are initialized before the programs starts, so there's no performance hit either, variables declared inside functions are stored on the stack at runtime, they get the value that was previously there, initializing them with 0 when not needed would result in a performance hit.
still an easy way to manage libraries.
I'd just like to point you here: [https://www.espruino.com/](https://www.espruino.com/)
If you are using CMake, use Hunter (https://github.com/ruslo/hunter). Otherwise, maybe conan. Don't know much about conan though.
We needed something 
The day you're sitting in a compiler design course, and the professor tells you that BNF is an LL-1 grammar ‚Äî mind blown. I love writing recursive-descent parsers. It's my favorite thing to do.
Hi, This isn't C (it's C++), so you may have more luck asking in /r/cpp_questions. That said, "creating Excel files" is rather complicated and likely requires a big library which you haven't posted. Good luck!
Over in that forum, they told me it's C. Yeah I mean that's part of all the equations. There's a lot of ()Createlocations in the equation part as it uses vectors. 
&gt; // No toll.cpp : Defines the entry point for the console application. It actually says `cpp`. üòä Also, namespace, [ofstream](http://www.cplusplus.com/reference/iostream/), and [endl](http://www.cplusplus.com/reference/ostream/endl/) (among other things) are all C++.
Great, that's actually very helpful. I think they may have referred to the fact that I wrote C in the post text. 
I would have thought Python‚Äôs Pip would be a better substitute, at least Pip can run on a non-Unix machine unlike npm 
Conan seems promissing!
Creating Excel files without some kind of library or external program would be hard, but maybe you could generate CSV and import a CSV file into Excel. A filename is appended to a directory path, it really should double-check whether a '/' character is at the end and append that first if missing. What was the question again? It looks like it generates tab seperated values... Maybe do something like this: `cat file.tabs | awk -f tab2csv.awk &gt; file.csv` using: #!/bin/awk BEGIN { q="\042"; # quote character bs="\134"; # backslash character } { a=split($0,a); str=""; for(i=1; i &lt;= length(a); i++) { gsub(q, bs q, a[i]); str = str "," q a[i] q; } print substr(str, 2); # skip the first comma } 
This is a C++ program. Please post C++ questions to /r/cpp_questions as this subreddit is about C only.
Thanks for those. Will have to check them out.
I hope guys will remember that days, when you needed to clone git repo to get lib on your pc...
Wow I wish understood any of that code lol
Honestly, I think there should be at the very top a quick rundown of how compiling even works, I see questions about that fairly often, we should dedicate a few sentences to it.
Is it even legal to have C libraries on NPM?
Npm runs on everything.. what u smokin?
It depends on what the values of `i`, `length`, `overflow_check`, and `head_struct-&gt;length` are when it gets to this code, so I'd guess the segfault is caused by at least one of those not being what you expect. You could add some `printf` statements to show those values each time through each loop, or use a debugger. But I'm puzzled by the logic of the two loops. If the while loop sets `valstore` to the integer value 457, and if the for loop runs three times and `overflow_check` starts at 0, `overflow_check` will be 50727: (((0*10+457)*10+457)*10+457). If your linked list is longer, that's going to get large pretty fast.
I realized this after posting. This is because prior to what I have now, I had something a little different in the first loop that made it relevant. At first I was saving each value individual digit in a cell in an array of appropriate length and was applying it to each cell in the array holding the value. So it was along the lines of 0*10 = 0 + 4 = 4 4*10 = 40 + 5 = 45 45*10 = 450 + 7 = 457
What's wrong with your distribution's package manager?
But, my lord, is that legal?
I will make it legal!
It‚Äôs more efficient for the developer / small team to have *you* figure out how to get npm to run on your distribution. Publishing to a large number of package managers is certainly doable but can be a chore. 
The problem is in the code in your for loop.
That is C++, wrong subreddit.
Can you please explain?
When you run isprime (9) you immediatelx test if 9%2 == 0 which is not true. Then instead of testing if there is another number you terminate the loop.
You're not letting your for loop finish. Return exists the function. Move the return line a few lines down. Plus you can have your for loop upper bound be sqrt of the input instead of half the input. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
This cannot happen.
What if 'if' and 'else if' both become true?
The code if (a) { ... } else if (b) { ... } is exactly the same as if (a) { ... } else { if (b) { ... } } so I think you can answer your own question.
The conditions are verified sequentially. Meaning, only the very first condition which is true is relevant. The rest is ignored. 
It's just that the code that was sent to me includes this: //output variants associated with housing market sprintf(tempFile+len,"HousConsumption.xls"); outFile.open(CString(tempFile)); outFile&lt;&lt;"Location(km)\t p(x) ($/m2)\t g(x) (m2)\t r(x) ($/m2)\t S(x)($/m2)\t h(S(x))"&lt;&lt;endl; outFile&lt;&lt;0&lt;&lt;"\t"&lt;&lt;p[0]&lt;&lt;"\t"&lt;&lt;g[0]&lt;&lt;"\t"&lt;&lt;r[0]&lt;&lt;"\t"&lt;&lt;S[0]&lt;&lt;"\t"&lt;&lt;h[0]&lt;&lt;endl; for(int i=0;i&lt;x_num;i++) outFile&lt;&lt;x_vector[i]&lt;&lt;"\t"&lt;&lt;p[i]&lt;&lt;"\t"&lt;&lt;g[i]&lt;&lt;"\t"&lt;&lt;r[i]&lt;&lt;"\t"&lt;&lt;S[i]&lt;&lt;"\t"&lt;&lt;h[i]&lt;&lt;endl; outFile.close(); So because it has worked when they used the code, I assume it should work for me as well. 
Yes I found out. 
Well that sure can happen, just look at this. int i = 15; if(i % 3 == 0) { printf("i is divisible by 3\n"); } else if (i % 5 == 0) { printf("i is divisible by 5\n"); }
as the semantic of "else" imply, the second condition is only tested if the first is false. if(a &gt; 1){ do this } else if (a &gt; 0) { do that } if a is 2 for example, the program will `do this` and never check whether or not a is greater than 0, it will bypass `do that` completely.
 int main() { int a = 10; int b = 10; if(a==10){ printf("Hello world!\n"); }else if(b==10){ printf("Hello universe!\n"); } return 0; } If you have an if statement that's true; it will fire and skip the rest of the conditions, no mather if the next conditions are also true. So this prints out "Hello World!" and nothing else.
This has nothing to do with C programming.
&gt;And as for returning 4 "lol", it should return 4. The add function only looks at 2 parameters an no amount of casting the function pointer is going to change that. Remember that casting a function pointer only tells the compiler to look at the address of that function in a different way, in this case it's allowing you to call it with arbitrary parameters, but nothing about the function itself changes. If what you really want is a function that adds an arbitrary amount of numbers, you want something like this. I am aware that it should return 4. simply something i find amusing. And just define a macro that adds a 0 at the end. ie. `#define Macro_VA(...) va_arg_function(first_var, __VA_ARGS__, 0)` or something like that. &gt;I've never see this left handed casting before, I would rather put the cast on the right hand side where it is much more clear. I can see what it is doing, making a pointer, casting the pointer and then doing a dereference assign on that casted pointer but that's bizarre. Maybe even perverse. I don't know why you would do it that way, just cast the right hand side. &amp;ptr\_func = something will throw compiler error. \*(voidf \*) &amp;ptr\_func will compile. look i'm really not here to discuss how to do things and when to do it. I just want to know if my interpretation of the syntax is correct or not.
it works because (best guess here) of two levels of indirection. add\_ptr, which points to add is cast as a pointer to voidf and dereferenced. so it's really not much different than casting a variable of type 'pointer to struct' to type 'pointer to void' again, im not too sure because im not sure if i'm interpreting the syntax correctly. regardless, it does its job.
got it from a book by Axel Schreiner, Ph.D in computer science. 
Removed: unrelated to programming in C.
`else` means *if the previous condition was untrue*. So the situation you describe simply isn't possible; a value cannot be both true and false. The answer doesn't change for `else if` branches; in fact, these are just other `if` statements nested inside `else` branches! This ‚Äî if (...) { // (a) } else if (...) { // (b) } else if (...) { // (c) } else { // (d) } ‚Äî is exactly the same as this ‚Äî if (...) { // (a) } else { if (...) { // (b) } else { if (...) { // (c) } else { // (d) } } } ‚Äî just without the braces. See it? You should be able to run through the logic in your head and verify that the situation you describe cannot happen; each condition will be tested only once and only if the previous condition failed.
There is no such a thing C/C++. C and C++ are different programming languages and share a minimal syntax, but to that extent even Python shares it! And C is usually used in programs that C++ do not fit or will never be a choice to use instead of C!
Passing a null pointer to `free()` is a no-op. So it's not harmful, but it is pointless.
You only need to free it if it was successful. If that pointer is null, calling free doesn't do anything.
If malloc fails to allocate memory, I would advise that you log/print an error message and then exit the program. 
 if(temp == NULL) { free(temp); Why would you think you need to free NULL?
It really depends on what sort of system you are working on. If this was your pacemaker, would you want it to, "log/print an error message and then exit the program"? Hopefully a pacemaker, or other critical system, wouldn't use dynamic memory allocation, but if for some reason it does, it ought to deal with it in some sort of reasonable deterministic way.
Regardless if you end up a C fan or a C++ fan, it is best to learn both. Plus some assembler so you can read how your code comes out. If there is two jobs, take the C one! You will have to do C++ soon enough.
Shouldn't it be nullptr insted of NULL?
Freeing NULL is unnecessary. You don't have to compare to NULL either; if(!test) { return NULL; } is enough and clear
How did you make it? It takes tons of maths for 3d graphics!
Ping pinh
Ping ping 
No. C, not C++...
'ping ping' lol ok i will go to cpp subreddit
It's neither necessary nor does it cause problems. For your example where you just bailing out I wouldn't bother. But other times it may be more natural to always call free and that is fine as well.
free will delete the memory part that was made, so when there is no memory allocated why do you need to free it? in other word you cannot delete something that does not exist already
You're overwriting your destination pointer instead of reading into the buffer you've allocated
Then explain to me how a C++ compiler can seamlessly transition to compiling ANSI C if they are so 'different'. Yes, C++ has much more functionality, but the reason a C++ compiler can compile C is because C++ is a superset of C. I don't know any devs, personally, who use Ada or Fortran. Although I met an engineer once who had coded in COBOL for a while back in the day. Those of us writing high performance code will use C/C++, thank you very much. Show me a game engine not written in C/C++, where rendering game frames as fast as possible is the top priority. The fastest code in the world is written in C/C++, period.
As others have said, you do not need to free unallocated memory. For situations like your third example, correct usage of goto can simplify the error handling logic. int *temp1, *temp2, *temp3; *temp1 = malloc(sizeof(int) * n); if(temp1 == NULL) { goto err1 } *temp2 = malloc(sizeof(int) * n); if(temp2 == NULL) { goto err2 } *temp3 = malloc(sizeof(int) * n); if(temp3 == NULL) { goto err2 } // Do stuff /* error block */ err3: free(temp2) err2: free(temp1) err1: return NULL;
pointerless
Thanks A LOT! Removed '&amp;' from sectionCode, when calling ReadMemoryProcess and worked.
Dammit.
Does anyone know of this is legit? My Bullshit-o-meter is off the charts looking at this, but it's still very tempting.
&gt; Take a hike pal. Like OMG that's so totally *not nice*! How dare you be anything other than the nicest person in the world on reddit! Like totally *down**boat***
Fuck you bud.
It smells a little fishy to me, it feels like allofmp3.com. They've hidden all of their whois contact info, and I can't find a business address anywhere on the site. They probably will sell you what's advertised, but I'm not sure the publishers will see any money.
C/C++ lmaooooooooooooooooooo
I know you‚Äôre being facetious but it costs nothing to be courteous. 
As others have said, `free(NULL)` is fine. If you already know the pointer is null, don't bother trying to free it. But if you don't know if it's null, go ahead and free it, i.e. don't do ``` if (ptr != null) { free(ptr); } ``` If the pointer isn't immediately going out of scope, consider setting it to null after freeing it. 
Sure, because making websites is... soon to be automated.
Lol
People keep bringing this up as if it's important, but it's really a non-problem, people who are working on safety critical systems *know* they can't just crash and log. There are other reasons to not crash and log than safety-critical equipment, for example when you're trying to load data of unknown size into memory, it's often better to display an error message and return to interactive upon failure. Especially since on modern systems with over-commit enabled, the most prominent failure mode is trying to allocate one huge block that can't fit into memory, meaning you're not really out of memory.
I would accept help adding the library even outside of codeblock. 
Anybody got a set of colors for this (for src/colors.c) that roughly match gruvbox?
I completed the quiz, the content is ok, but whoever made the quiz needs to look over it once more. Question 6 has a 'not' where there should not be one. It's not role over, it's roll over. If you fix the errors in grammar to, it will be a good quiz.
Just awful. The english is terrible, and several of the 'tricky' questions make platform-specific assumptions, contain undefined behaviour, or have answers that are flat out wrong.
Thanks for your suggestion 
This quiz is horrible. 
Some of the questions rely on UB, and some questions are formulated wrong. But overall I would say it is rather good
‚ÄúWhich of the following is not a valid declaration in C? 1. short int x; 2. signed short x; 3. short x; 4. unsigned short x;‚Äù The ticked answer is ‚ÄòAll‚Äô. This implies that all are NOT valid, but the explanation says all are valid.
That is a FANTASTIC question. I always just assumed that you didn't need to.
This is what I'm doing, but I don't call `exit()` or anything like that. I just log it, and it's on the user to fix their code. (which is almost always me, but it's important to separate these concerns)
&gt; People keep bringing this up as if it's important, but it's really a non-problem, people who are working on safety critical systems know they can't just crash and log. Typically the target audience of those types of comments is _not_ the people who should already know better, but people still learning the ropes. It is a good use case to remind prospective programmers of.
too late!
This is... not very good. Question 3: a `float` is implicitly promoted to `double` when passed to a variadic function, so the correct format string for *both* `float` and `double` is `%f`. The `l` modifier ‚Äúhas no effect on a following a, A, e, E, f, F, g, or G conversion specifier‚Äù (C99 7.19.6.1 / C11 7.21.6.1). Question 5: there is no such thing as `MAXUNIT`. Question 6: the question is ‚Äúwhich of the following is **not** a valid declaration‚Äù and the expected answer is ‚Äúall‚Äù. The correct answer is ‚Äúnone‚Äù since all four are perfectly valid. Question 8: the explanation is incorrect as `'12'` is not a string but a syntax error. C strings are enclosed in *double* quotes. Question 10: the explanation is correct, but unhelpful. Someone who answered the question incorrectly most likely does not grasp that the `*` only applies to `vptr`. Question 11: the answer assumes that `char` is signed, which is not necessarily the case. For instance, is signed on IRIX. Question 13: the question makes no sense as stated. Once decrypted, it seems to be as much of a math question as a C question. Question 14: the answer assumes a specific representation of floating-point numbers in which 0.1 cannot be accurately represented by `float`. If you choose a different value (e.g. 0.5) or your implementation uses a different floating-point representation, you will get a different result.
prospective programmers don't program safety critical systems which is exactly my point. 
intentional "grammar to" not "too"? ahahaha
did you check their website? there's some instructions there 2.) Installation of Libraries and Utility Programs a) Uncompress the tar.gz file with the command gzip -d dislin-11.1.xxx.tar.gz b) Restore files from the tar file with the command tar xvf dislin-11.1.xxx.tar c) Change to the installation directory of DISLIN cd dislin-11.1 d) Choose a directory in the file structure where DISLIN should be installed and define the environment variable DISLIN with it: For example: DISLIN=/usr/local/dislin (for sh, ksh) export DISLIN or: setenv DISLIN /usr/local/dislin (for csh) e) Run the install program with the command INSTALL This program copies files to $DISLIN and sets protections. f) To make DISLIN available for general use, write the following com- mands to your .profile export DISLIN=dislin_directory PATH=${PATH}:${DISLIN}/bin LD_LIBRARY_PATH=$DISLIN:$LD_LIBRARY_PATH export LD_LIBRARY_PATH For a C-shell, you should include the commands setenv DISLIN dislin_directory setenv PATH ${PATH}:${DISLIN}/bin setenv LD_LIBRARY_PATH $DISLIN:$LD_LIBRARY_PATH into your .login file. g) Now you can compile, link and run the example programs in the direc- tory $DISLIN/examples ($DISLIN/examples/F for F) with the commands: clink -a exa_c (C) cpplink -a exa_cpp (C++) dlink -a exa_f77 (Fortran 77) f90link -a exa_f90 (Fortran 90) h) You can delete the installation directory 'dislin-11.1
No, that's bad practice. Always use explicit comparisons unless your variable or function call is a predicate and clearly named as such. Not doing so is how you end up with hard-to-spot `if (strcmp)` bugs.
That's not wrong, but needlessly complicated. int *p = NULL, *q = NULL, *r = NULL; if ((p = malloc(...)) == NULL) goto oops; if ((q = malloc(...)) == NULL) goto oops; if ((r = malloc(...)) == NULL) goto oops; /* do stuff */ return (0); oops: free(p); free(q); free(r); return (-1);
&gt; prospective programmers don't program safety critical systems Obviously. &gt; which is exactly my point. Somewhat ironically, you are missing the point. First you say it is a "non-issue" because people writing critical systems already know not to just log and abort. Then you turn around and list a bunch of use cases that anyone writing software professionally should already know about. Instead of focusing on the specifics of the use cases, the big take-away from Wetbung's comment is that "it really depends on what sort of system you are working on". i.e. a prospective programmer who _doesn't_ already know better should be learning to think about how their design choices impact the real world - regardless of whether the software is critical or not.
Burn it.
The use cases I pointed out also very much apply to hobbyists, who may not be aware of the problem, and are better examples than the usual vehicle control system or pacemaker.
I'd like to take the opportunity to point out that sizeof(char) is always 1. This is garantueed by the standard. Also it would be nicer to cast to size_t instead of unsigned int when dealing with memory sizes. In this case it's not strictly needed but it's a good habit to pick up.
I followed this instructions from the site because i was trying to use it in windows please download the Dislin distribution for MingW (dl\_10\_mg.zip) and set the following project options in the IDE: * Build Options -&gt; Directories -&gt; Include Files Add here the entry c:\\Dislin for finding the Dislin header file Dislin.h. * Build Options -&gt; Linker -&gt; Linker Options Add here the entry c:\\Dislin\\dismg.a -lgdi32 -luser32 -lopengl32 
&gt; Question 8: the explanation is incorrect as `'12'` is not a string but a syntax error. C strings are enclosed in double quotes. It's not a syntax error, see [C89 draft 3.1.3.4](http://port70.net/~nsz/c/c89/c89-draft.html#3.1.3.4) or [C99 draft 6.4.4.4](http://port70.net/~nsz/c/c99/n1256.html#6.4.4.4) (quoting from the C99 one, emphasis mine): &gt; character-constant: &gt; ' c-char-sequence ' &gt; L' c-char-sequence ' &gt; c-char-sequence: &gt; c-char &gt; c-char-sequence c-char !!!!!!!! &gt; c-char: &gt; any member of the source character set except &gt; the single-quote ', backslash \, or new-line character &gt; escape-sequence &gt; &gt; [...] &gt; &gt; An integer character constant is a sequence of one or more multibyte characters enclosed in single-quotes, as in 'x'. [...] &gt; &gt; [...] The value of an integer character constant containing a single character that maps to a single-byte execution character is the numerical value of the representation of the mapped character interpreted as an integer. The value of an integer character constant containing more than one character (e.g., 'ab') [...] is implementation-defined. But yeah, it seems the author confused `'` with `"`. &gt; Question 13: the question makes no sense as stated. Once decrypted, it seems to be as much of a math question as a C question. It seems like the author wanted to ask about overflowing integers, since the first sentence in the explanation states that if `n` gets big enough, some of the answers would overflow. 
`if (strcmp)` will issue an warning (it always evaluates to true). Do you write `if (my_boolean == true)` too?
Please try to be a bit more civil.
Please be civil.
Please post questions about C++ code to /r/cpp_questions as this subreddit is about programming in C only.
Please don't post this kind of content.
Please don't post these.
Thanks, maep. Agree, I better stick to best practices. Still have to learn C programming, as I started learning it at the same time with Windows API. Thanks for sharing ;)
Ok, I don't post. 
Since you've managed to learn C, I'm sure you're smart enough to understand that I elided the parentheses and arguments for brevity. &gt; Do you write `if (my_boolean == true)` too? No, because a boolean is (equivalent to) a predicate.
&gt; It's not a syntax error A constraint violation, then, unless that sequence of characters happens to be an escape sequence (which is not the case in the example). &gt; It seems like the author wanted to ask about overflowing integers I understand that ‚Äúset p to nC3‚Äù? Since I recognize the equations, I can figure out that the author meant ‚Äúset **`t`** to C(`n`, 3)‚Äù, but I suspect that many readers, perhaps even most, will be utterly bewildered. And figuring out that *n(n-1)* is always even and *n(n-1)(n-2)* is always a multiple of 3 is outside the scope of the quiz.
Why not? I mean, apart from the fact that more than half the questions are wrong. Would you have removed the post if the questions and answers were correct, and perhaps more challenging?
Thank you.
Yes pretty much. The site being an ad infested shitfest and generally being very blog-spammy is another reason. "no blog spam" is a rule I try to enforce very consistently.
Couple of notes on the first sight: 1) You don‚Äôt have to flush stdin, that‚Äôs UB to flush input streams, AFAIR. 2) main prototype should be either with (void) or (int, char**) 3) If I chose to display graph as my first choice, nodes and number of nodes contain gibberish, which most likely lead to segmentation violation. You should initialize them on start.
Who the hell uses a grey highlighter for grey text? Should probably call it lowlighter. And why is it being used anyway? Wtf.
I'd describe this as a *very* basic implementation of a graph. The article describes a graph **G** as the set {**V**, **E**}, but then ignores this fact for the implementation. An implementation for a graph should include several functions, including add_vertex(), add_edge(), delete_vertex(), delete_edge(), etc
&gt; I have never encountered an implementation that defines it. I just looked up what GCC says. On [GCC 7.2.0 "Characters implementation"](https://gcc.gnu.org/onlinedocs/gcc-7.2.0/gcc/Characters-implementation.html#Characters-implementation): &gt; The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4). &gt; &gt; See [Implementation-defined behavior](https://gcc.gnu.org/onlinedocs/cpp/Implementation-defined-behavior.html#Implementation-defined-behavior) in The C Preprocessor. The wording seems partly match, so I'll continue from there. From the linked site: &gt; The numeric value of character constants in preprocessor expressions. &gt; &gt; The preprocessor and compiler interpret character constants in the same way; i.e. escape sequences such as ‚Äò`\a`‚Äô are given the values they would have on the target machine. &gt; &gt; The compiler evaluates a multi-character character constant a character at a time, shifting the previous value left by the number of bits per target character, and then or-ing in the bit-pattern of the new character truncated to the width of a target character. The final bit-pattern is given type `int`, and is therefore signed, regardless of whether single characters are signed or not. If there are more characters in the constant than would fit in the target int the compiler issues a warning, and the excess leading characters are ignored. &gt; &gt; For example, '`ab`' for a target with an 8-bit char would be interpreted as ‚Äò`(int) ((unsigned char) 'a' * 256 + (unsigned char) 'b')‚Äô, and '\234a`' as ‚Äò`(int) ((unsigned char) '\234' * 256 + (unsigned char) 'a')`‚Äô. ---- &gt; &gt; It seems like the author wanted to ask about overflowing integers &gt; I understand that, but ‚Äúset p to nC3‚Äù? True, I agree with the bad wording, but I was specially pointing out the C aspect since you wrote &gt; it seems to be as much of a math question as a C question (Also thanks for the nC3 explanation, didn't thought of that)
How long has gcc supported this? I'm pretty sure I've gotten compiler errors when I have accidentally typed multi-character character constants (be it a typo or `ETOOMUCHPERL`).
Now make node CREATION/EDIT accept a room description and list of exits and walk around in an Interactive Fiction (IF) text world!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
No. What makes you think that? You are also wrong about arrays, although I can understand why you are confused since arrays devolve to pointers in most situations.
Amateur answer: I think your intuitive understanding is correct. A stored value has to be stored *somewhere*, so a generally represents the name/address of that location. However, on the machine level, what that means could vary. It could be a pointer to a location in RAM, or the value could be held in a register. For instance, in a simple loop counter like `for (int i=0;i&lt;10;i++) {`, `'i' could be held in a register and never saved in RAM. That's how I'd do it in assembly, anyway, so although I'm no compiler expert, I think a compiler could do the same.
Compilers will generally compile a variable into a load instruction which needs to know where that variable is in memory. Once it's in a register it is manipulated or used and eventually written back to that location. That's why you can do &amp;x in the first place. So your intuition is correct. You should read up on how programs are read into memory and addresses are resolved, it will help your understanding. Look up the "loader" and how it works.
Your 1st interpretation is correct. int x = 5; means that somewhere there is 4 bytes that contains the value 5. If you then do x=6; then the value in those 4 bytes changes to 6. There is no pointer stored anywhere.
Well I could find documentation on the behaviour on [gcc 3.1.1 cpp](https://gcc.gnu.org/onlinedocs/gcc-3.1.1/cpp/Implementation-defined-behavior.html#Implementation-defined%20behavior) (didn't check version 3.0.4 since it's only distributed in PostScript. See the [documentation list](https://gcc.gnu.org/onlinedocs/)), so I guess that is probably a version where it supported this. When I tried the code from the question in GCC 7.3.0 (Ubuntu 18.04, also clang 6.0.0), it warned me (`-Wmultichar`), so maybe you had `-Werror`.
The answer to any low level question like this is "it depends". The first thing to understand is that `x` is to some small degree an abstraction. It has the value 5, and you can do all the various operations supported on C integers to it. Any programming language, with the arguable exception of assembly and hardware description languages, should be understood as an abstract machine that must be implemented in terms of some more fundamental set of tools. C certainly allows you *more* access to hardware and other fundamentals than e.g. Java or Python, but it still abstracts things somewhat from the operation of a CPU. You aren't "really doing" address-of and deference operations, you're doing an addition operation and that is implemented somehow between the hardware and the compiler. As far as where `x` lives, it could be either a register or memory, though it will generally be memory for several reasons. First, any address-of operation on a variable requires that it live in memory. So if you ever pass around a pointer to the abstract value `x`, you require that it be represented by memory (I think, it's possible that in some cases this could be optimized away by the compiler). Second, unless you compile your code with optimization, most values will generally be placed in memory as doing so saves work for the compiler. Third, you are likely running on an Intel chip, which uses a Register-Memory architecture, allowing operations to be performed on data in memory. TL;DR: `x` is an abstraction that could be represented in different ways. Generally it will be represented by bytes of memory with the value of `x` in them.
The reason I think that variables that store primitive types have to somehow store the address is because I don't understand how else you can store the value. Everything has to be stored in memory. A declaration like `int x = 4` has to somehow store the integer value 4 in the variable x. How else can x store this information without storing a pointer the 4 bytes that are used to store the number 4? (assuming 4-byte integers). [In this video](https://youtu.be/h-HBipu_1P0?t=2m43s) he says that the computer has an "internal structure" that he calls a lookup table that stores the information the x is an int, and has base address whatever. That would make perfect sense to me. To be clear; I'm not saying that you would go around expecting *x to work. Obviously x is NOT a pointer, so you can't dereference it. I was just saying that somewhere the computer has to store the address of x... cause how else can it retrieve the value of x? And in regards to arrays -- in what ways am I wrong? I was under the impression that something like int A[5] would essentially store the base address of the array in A. This makes it possible to do things like *(A+2) to get the third element of the array. Is that incorrect? 
You're not wrong, Walter, you're just an asshole.
bad bot
Sometimes the values are just kept directly in registers. Those are the processor's working memory if you wish, and there's a limited amount of them. Often the variables are stored on the stack though. Each time a function is entered, a new part of the stack is allocated and you can see that as a big array of you wish. One of the processor registers contains the base pointer for the current variables on the stack, so you are indeed using a pointer in a way. I would recommend reading up a bit on assembly code if you're interested about this. It's not terribly hard to understand if you already know pointers. 
you're generally right, except that (1) things are more complex (the data may be in a register or on the stack) and (2) when you say *variables would have to store just a pointer to 'base address" of the integer or whatever* you're wrong, because you're confusing how things are implemented with the more the language is using. in a sense you're being too concrete about what a "variable" is. a variable is conceptual. it's something in the language. and the language definition and the compiler work together to mean that for primitive values the variable "is" the value. for pointers the variable "is" the address. that's completely separate from what goes on "under the hood". at some level of abstraction it's all values at addresses, sure. but there's an extra level of abstraction (part of the language) that makes pointers and values different.
That makes a lot of sense. I think I do understand that somewhere in my RAM there lives those 4 bytes storing the value in x. And I do understand that x is an *integer* -- it's not a pointer, I can't deference it, no pointer arithmetic, etc etc. It does not store an address. I suppose I should have been more explicit in my original post; I wasn't trying to say x stored a pointer -- I was just trying to say that *somewhere* there must be the address of x for the computer to know where to go to get its value. I guess my question was just how the computer knows the value of x if it didn't store the address of it somewhere. [This video](https://youtu.be/h-HBipu_1P0?t=2m43s) says that it stores the address and types of variables in a lookup table. Is that correct? That would make sense to me. And thank you for drilling home that I should really think of variables as abstractions. That's an important point that I don't think I had really internalized. 
OHH. That makes a lot of sense. So I am trying to drill through a layer of abstraction -- learn how something works -- and bring it back *up* a layer of abstraction, claiming that's how its always done. Obviously that doesn't make sense though, and is just incorrect. A variable is just an abstract concept defined in the language specification. It can be implemented in any number of ways. So I should really just think of it like a "black box" that holds my value. I guess what was bugging me was the itch that the computer *somehow*, *somewhere* has to store the address of x. Sure, it's not in *x* itself -- maybe it's in a lookup table, [as this video suggests](https://www.youtube.com/watch?v=ASVB8KAFypk&amp;index=6&amp;list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_) -- or maybe it's implemented some other way. But I was just curious how the program could ever get the value of x if it wasn't stored somewhere. To be clear -- and this is my fault, because I wasn't careful enough with my words -- I know that x does not in anyway store an address. It's not a pointer. You can't dereference x with the `*x` syntax; you can't do pointer arithmetic; none of that. It's just a variable that, when evaluated, will give you it's value. That's all. I think I get what you are saying now though. Think of x as storing the number. It's an abstraction the language provides. Its underlying mechanics can be implemented in all manner of ways. So leave its full sense of meaning at the abstraction level, where it belongs. Right?
The compiler decides where to place `x`. For a block-local variable, that location is an offset from the bottom of the stack (remember that call stacks grow downwards). For a global variable, it can be either an absolute address or an offset from the base of a data section, depending on the environment. When you perform an operation on that variable, the compiler emits an instruction which includes the absolute or relative address of that variable.¬π This does not mean that the variable is a pointer. There is no indirection. A pointer is a variable (a location in memory) which contains the address of another variable, so that accessing that variable requires *two* memory operations. As for arrays: if you write `int a[5];`, then `a` *is* the array. In C, arrays often devolve to a pointer to their first element, which means that `int *b = a;` is exactly equivalent to `int *b = &amp;a[0];`, but that is just a quirk of notation. Without that quirk, dereferencing elements of a dynamically allocated array would be very unwieldy, especially for multidimensional arrays. Note that in this example, while `b[1]` evaluates to the same value as `a[1]`, they are *not* exactly equivalent; barring compiler optimizations, the former requires one more memory access than the latter. ________ ¬π In practice, it will often load the variable into a register, operate on that register, and write the result back later. For [some processors](https://en.wikipedia.org/wiki/Load/store_architecture), this is the only way to operate on a variable.
&gt; it stores the address and types of variables in a lookup table The compiler does. The code it produces does not.
Depends how you're using `x`. As other have said better, `x` is just an abstraction. It doesn't *have* to actually exist with a real pointer. If your compiler has enough free registers to keep `x` in a register instead of having it in memory, it'll do that. And it might get optimised out completely. Unless you do things like take the address of `x` then pass it around, then the compiler is forced to actually store it somewhere. Like if you do int foo() { int x = 4; x = x + 5; x = x * 2; return x; } That's just going to get compiled down to int foo() { return 18; } if you have optimisations enabled. No variables used at all. 
&gt; I was just trying to say that somewhere there must be the address of x for the computer to know where to go to get its value. Okay, I think I see what you're asking. That value does exist, but it's tracked internally by the compiler/assembler by the lookup table you mention. The compiler tracks a lot of details like that which are necessary to bridge the gap between program and hardware, but which are not important to the programmer. It assigns a location to `x` (either memory or register), and then it produces assembly code that performs whatever operations you have asked to be done to `x`, which may vary based on where `x` happens to live. If you're still interested in this, you could try writing some simple C programs that do basic operations on integers and using the -S flag on gcc to look at the assembly it produces. That will let you see how `x` is represented when the program runs.
Just start with something small and keep growing it for sone years.
right. also, your model is too simple, because it may be a register, which isn't really "memory" at all. and the abstractions of the language protect you from all this.
for me it was making simple terminal based games using ncurses. (here's one of mine)[gitlab.com/jul2040/2p-snake]
&gt; how the computer knows the value of x if it didn't store the address of it somewhere. In compile time, the linker does it through offsets, or relative addresses. Put it simply, it's like the first byte of your program had a RELATIVE address of 0x0. Then suppose the next 4 bytes are reserved and your `x` variable come right after it. The linker will store its relative address of 0x4 or 0x0 + 4. In runtime, the OS will do setup work, including allocation of your variables, will assign them addresses, and will link these offsets to the allocated addresses through a lookup table private to every process, effectively turning `x` into an alias. So when you compile your program, the data layout is blueprint of your program, and upon execution, the OS takes care of shaping it up. This is a really simplistic explanation, as in reality is way more complicated than this, especially the runtime part. But I hope you get the idea.
Those are your terminal colors? This program uses the terminal colors only... Not colors of its own. Just install the gruvbox color scheme in your terminal and the program will use the same ü§î
What's the point
 for (int *i = a; i &lt; a + n; i++) *i = 0; 
&gt; boolean is (equivalent to) a predicate Predicates in C are int, so boolean isn't any more equivalent to it than a pointer
You are using a much narrower sense of the word ‚Äúpredicate‚Äù than I was. But if you want to nitpick, most mainstream implementations define booleans in terms of `int`.
[This is the blog post linked in the first reply, about why it's a bad idea to have an object bigger than `PTRDIFF_MAX` in size](https://trust-in-soft.com/objects-larger-than-ptrdiff_max-bytes/). It's interesting to see those examples, but they feel a bit contrived to me: all of them involve indexing using integer constants, and all of them involve calculating a difference between an element and the base pointer. Neither of these is really very common. For the more common types of code, where you index using a variable, I haven't seen any problems in using an object that's bigger than `PTRDIFF_MAX`, e.g.,: char *x = malloc(0x9000000000000000); // bigger than PTRDIFF_MAX size_t i; for (i = 0; i &lt; 0x9000000000000000; i++) x[i] = 5;
Apparently you and comment chain OP never learned the golden rule in elementary school. 
Fuck off retard
C does not have a distinction between "stored by reference" and "stored as primitive" like Java does. All objects are what you might call "stored as primitive". A `char` occupies 1 byte of storage; an array of 23 chars occupies 23 bytes of storage. The `int x = 5;` reserves enough bytes of memory to store an `int` value (usually 4 these days) and sets the bits of those 4 bytes to represent the value `5`. 
I just use `uint64_t`
Very hard to figure out what you mean without more context. I'd say avoid tightly coupling modules when they are not modeling the same behavior. Try to encapsulate behavior where possible.
Thanks! I thought more context might add to the convolution, but essentially I‚Äôm tying an off the shelf Bluetooth module to a vehicle infotainment system. Both communicate over UART and I‚Äôm trying to develop the code that takes actions from the infotainment bus and converts them into actions on the BT module. Basically, should the Bluetooth and infotainment structs hold their own states, or should a third party struct hold the state for both modules and use that data to act accordingly? The source is here, if you want even more context: https://github.com/tedsalmon/BlueBus/tree/master/firmware
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [tedsalmon/BlueBus/.../**firmware** (master ‚Üí d03549a)](https://github.com/tedsalmon/BlueBus/tree/d03549a62c554cbd526e16e3fe6ca156df88e71f/firmware) ---- 
I don't find this argument particularly compelling. Yes, `a[i]` is exactly equivalent to `*(a + i)`, but that does _not_ necessarily mean that `i` can be negative. If `a` is an array, you invoke undefined behaviour when `i` is negative no matter which form you use. There are certainly good reasons to avoid allocating objects whose size can not be represented in `ptrdiff_t`, but all objects that _are_ safely allocatable must have a size that can be represented in `size_t`, simply because that's the return type of `sizeof`. That implies that a loop with a `size_t` counter can always safely iterate across any array.
IMO, the best way of thinking about it is that C has a "virtual machine" and as long as your compiler produces a program that does the same thing (has the same output) as that virtual machine, it's correct. In the C virtual machine, global variables are stored in a constant memory location, so if `x` is stored at address `1234`, then you simply replace every instance of `x` with `1234`. Since the address of `x` is now it's name, the virtual machine knows where to look for `x`. If `x` is a local variable, it is stored on the stack. The C virtual machine has a global stack pointer implemented as above. There could be multiple `x` on the stack, so instead of naming `x` to an address, we name `x` to it's offset from the top of the stack. So if `x`'s offset is `4` then we rename `x` to `4`. The C virtual machine knows where to find `x` by adding the value of the stack pointer to `4`. We find the value of the stack pointer because it's address will be it's name (as above). That's how it's implemented in the C "virtual machine", but your compiler can choose to implement it however it likes, as long as it has the same output
&gt; size_t is for byte counts source? `fread()`/`fwrite()` uses it for the size of one element and the number of elements in the passed buffer. This is a pretty similar case, where the `size_t` is used as an index/size of an array or array-like buffer. Analogous are `calloc()`. In 7.20.5 it's said: &gt; [...] `size_t nmemb` specifies the length of the array [...] etc. So it's pretty clear that `size_t` would be the go-to type for indexing arrays, to me at leat. It just happens to me that we most often care about bytes and thus it usually denotes the size in bytes, but if we don't, it doesn't.
&gt; 4 bytes Word.
&gt; 4 bytes Word.
C doesn't have primitive types, primitive types come from a higher level languages and imply that there are types that will decompose into simpler types. In the case of int x = 5 with an optimizing compiler it would just substitute the value - [https://godbolt.org/g/Gm5zFY](https://godbolt.org/g/Gm5zFY) (change x to 5 and notice there is no assembly difference). Now baring an optimizing compiler things get complicated real quick as the C language describes a virtual machine and how real machines implement it will vary, for example \`int x = 5;\` in a function for almost all arches will be on the stack which eventually uses up stack memory which is why large alloca or VLA's is bad.
That's not even guaramteed to exist though
`%` is defined only for integer types. In C, it is an error to use a pointer as an integer like this without an explicit cast. `intptr_t` and `uintptr_t` are the only options for standards-conformant code when using a pointer value as an integer.
C does not have any implicit conversions of pointers to integers, so an explicit conversion is required. Casting `d` to a `void *` wouldn't help.
Thank you so much.! To do this, I should use uintptr_t or unsigned int/long.
Lol at the LS/RS macroes
It feels good to not be the only directionally challenged person here.
I'm always uncomfortable using `size_t` for element counts or loop indices, because of the potential for confusion between the size of an array (as repoted by `sizeof`) and the number of elements in it. It seems that `ptrdiff_t` was created more or less precisely for this purpose, but I have never encountered it in the wild.
My comment is kinda OT but I once read "The byte order fallacy" from Rob Pike where he said that byte order doesn't matter, so why the musl guys, who are certainly smarter than me, are doing that?
&gt; &gt; size_t is for byte counts &gt; source? 7.19 defines `size_t` as ‚Äúthe unsigned integer type of the result of the sizeof operator‚Äù. It also defines `ptrdiff_t` as ‚Äúthe signed integer type of the result of subtracting two pointers‚Äù. The former is always expressed in terms of the size of a single `char`, while the latter is expressed in terms of the size of the type pointed to by the two pointers.
Never use explicitly-sized types unless you need that exact size. I would use `unsigned int`; if you're worried that your array might contain more than 2^32-1 elements (assuming ILP32, IL32P64 or I32LP64), use `uintmax_t`.
&gt; If `a` is an array, you invoke undefined behaviour when `i` is negative no matter which form you use. It is not UB if `a` is a pointer and `a + i` is within the bounds or one past the end of the same object as `a`.
They probably write code where the byte order matters for performance reasons
Because this is `memcpy`. You speed up `memcpy` by copying `n` bytes at a time where `n` is usually your register width (for AVX2 this would be 32, for SSE2 16, for generic 64bit 8, and so on). Now at the beginning or the end there might be left-over bytes that don't fulfil alignment constraints, say m bytes. Those can be copied as an n-byte word as well, however endianness now matters because only the bottom or top m bytes in the n byte word are payload and it's quite important to know which one it is (bottom or top).
What state are you referring to? Can you provide the specific types. Reading the code is a bit difficult without many comments/documentation.
Thank you, that makes sense
You are right, this is a very basic implementation. I will implement functions add_vertex(), add_edge() etc.
I don't give a shit about exotic platforms, it saves a lot of trouble, and really, anything made in the last 15 years supports it. In related news, I don't support compiling for non-64 bit architectures.
1) I have used flush stdin because scanf while taking a character input consider key "Enter" an input. You can check by removing fflush(stdin). 2) You can choose any prototype for main, there is no rule for this. 3) You are right, there should be an initialization of choice and totalNodes. 4) I did addMatrix[10][10]=0 to initialize whole array with zero. If one wants to make another graph by again pressing "1" the line addMatrix[10][10]=0 again runs that's mean your previous graph is now deleted. Hope you understand. If you have any doubt, copy the code and run it on your device by removing addMatrix[10][10]=0 and other time by removing fflush(stdin); you will get the answer.
Gray highlighter is used because by convention it represents programming code in text document. I have described in post how to convert it to directed graph implementation.
Just use uint_fast64_t or uint_least64_t, or even uintmax_t. How do you not support non-64 bit architectures? gcc has almost the same support for 64 and 32-bit, even __int128. Unless you are doing something like ``` #ifndef __x86_64__ #error fuck you #endif ```
only uintptr_t for 32-bit vs 64-bit portability
1) Flushing only streams is UB. 2) Standard defines two possible main declarations, so there is rule. 4) No, you are accessing memory out of bounds. Possible indexes are in range 0-9. Accessing memory at index 10 does not mean ‚Äúwhole array‚Äù. It means access element with offset `sizeof(array_base_type) * 10`. To wipe out whole array, use memset or bzero(BSD).
1) Flushing input streams is UB. 2) Standard defines two possible main declarations, so there is rule. 4) No, you are accessing memory out of bounds. Possible indexes are in range 0-9. Accessing memory at index 10 does not mean ‚Äúwhole array‚Äù. It means access element with offset `sizeof(array_base_type) * 10`. To wipe out whole array, use memset or bzero(BSD).
please stop BS around. Its an official "recommendation' of every big C developer, books and the people behind C development!
&gt; #ifndef x86_64 &gt; &gt; #error fuck you &gt; &gt; #endif lol. ARM64 too tho. 
Tell you how you don‚Äôt speed up memcpy... with a modulus operator in a hot loop! Am I reading that right?! That‚Äôs 90+ cycles right there. This is a horrible implementation on quick glance.
What is a graphic textbooks? You mean something like this: [https://www.reddit.com/r/C\_Programming/comments/8x2iez/implementation\_of\_graph\_in\_c\_directed\_and/](https://www.reddit.com/r/C_Programming/comments/8x2iez/implementation_of_graph_in_c_directed_and/)
Something like this? (Same book, different links) https://github.com/jagregory/abrash-black-book https://www.gamedev.net/articles/programming/graphics/graphics-programming-black-book-r1698 
Responding to a week old comment. The point being he said it was not allowed, rather than not recommended. Not allowed by who or what? Who or what enforces this rule? Since there isn't someone standing behind you as you write your code with a big ruler to whack your hands if you do it, the only thing that makes sense is that the language or compiler enforces the rule, which is doesn't. I was pointing out he was incorrect that it was not allowed, simply that you should not do it, that is to say, it is not recommended. It was a clarification, not a refutation of the statement. I saw no reason to be overly pedantic with my statement. Please get out your urge to lecture people in some other venue, it does not belong here.
You should probably pick a library first and consider carefully what you mean by "graphics." Is your goal to make a GUI application, or are you trying to make a video game? For GUI apps I recommend GTK+, for video games I prefer Vulkan, but there's nothing wrong with OpenGL. Once you have a graphics library picked out you should be able to look up a textbook with keywords like "OpenGL textbook in C" or whatever library you've chosen. Personally I'm cheap so I tend to stick to online tutorials, and while I agree you see a lot more video game tutorials in C++ translating them to C isn't as hard as you'd think. Good luck, hope this helped.
Why is that confusing? It especially makes sense given a `char[]` that the max size fitting in `size_t` is also useful for iterating over the arr.
That loop is word-aligning the copy. It's performed, at most, 3 times. 
Reddit as Stackoverflow is a source of info for begginers, someone will read such a BS and ignore warnings as the one discussed! 
i mean the implementation of 3d rendering engine. i know translating them to c++ wont be that hard, but i want to know the best practices.
In addition to that loop being for word alignment, any half decent compiler is going to turn that x%4 into an x&amp;3. See for yourself: https://godbolt.org/g/Qbza5K
You will likely want to use OpenGL or Vulkan. The latter is much lower level than the former, but both are completely serviceable and cross platform. As far as best practices go, API best practices don't really change from one language to another in my experience. You tend to end up having language best practices and API best practices, and knowing both the language and API allows you to design a piece of software that conforms to both. The potential struggle in translating C++ to C is recognizing language best practices and translating them accordingly. This, unfortunately, will require a working knowledge of C++, but it's not all bad news. In general the best practice for writing engines is to eschew Object Oriented Programming (OOP) in favor of Data Oriented Design (DOD). This helps to produce higher performance software by keeping in mind the nature of the machine that will run it. DOD is used to avoid pitfalls like cache misses, by organizing the data of your program for maximum throughput. It's also used in OOP languages like C++ which is why a lot of popular engines written in C++ don't tend to rely heavily on OOP and instead have code reminiscent of low level, embedded C++. What this means is that most of the popular C++ tutorials you'll find won't heavily entangle C++ best practices (OOP) with API best practices, so aside from a few classes what you're going to be looking at will be pretty similar to what your C functions should be. Hope that helps, but if you have more questions don't hesitate to ask. I'm also not an expert here, so if anything I've said is wrong or misleading please correct me.
It's worth noting that compilers are really good. https://godbolt.org/g/qsRkJ3 If you do `% N` where N is a constant power of two, GCC will never do a mod. Bit twiddling is mostly redundant - compilers know all the tricks, so it's generally better to write readable code, unless profiling tells you otherwise.
But the libraries are usually wrappers around lower-level C code like SDL or just OpenGL? A lot of low-level libraries, graphics or not, tend to be C, and that is of course also true if you look at driver code or anything else low-level.
eh. maybe. I mean, drivers might be Assembly, C, C++ or whatever the firmware/driver guys want to write in. The further you get from embedded development the less straight C and assembly you see. Plus it doesn't matter what language the driver is written in as long as you can call the API from your code, which is why C-Style functions is such a huge deal. In the end, it doesn't matter what the driver is written in. On the topic of calling conventions, DirectX documentation used to say effectively "We're going with C++ now. But if you are coding in C, you'll need to do this to make things work" (this was around DX7 as I recall), but that has since been dropped and you are just supposed to be using C++ (or compatible) now (as per last I checked). OpenGL is looking to be similar (though it's a specification, not a library... I am not too worried about the distinction right now). It looks like they were moving away from C to everything in C++ at least 6 years ago: https://stackoverflow.com/questions/10153272/how-to-learn-opengl-3-x-using-c https://stackoverflow.com/questions/20023668/using-only-c-no-c-for-opengl And their samples look to all be in C++ these days (save one or two files): https://github.com/g-truc/ogl-samples But, they are just defining an interface and behavior. You can write an openGL program in any language that can interface it (eg: https://www.khronos.org/opengl/wiki/Language_bindings) 
This is **the book** on graphics, and its second edition is in C: [https://www.amazon.com/Computer-Graphics-Principles-Practice-2nd/dp/0201848406](https://www.amazon.com/Computer-Graphics-Principles-Practice-2nd/dp/0201848406) It goes over pretty much everything that you would need to write whatever you wanted. It **does not** go over various APIs like OpenGL or DirectX.
In the open source community, which isn't really the same thing. Even in the FOSS communities people don't wan to compile absolutely everything, so having binaries is always good.
It's confusing because ‚Äúsize‚Äù can conceivably apply to both (size in bytes or size in elements). The best solution would be to have a type equivalent to `size_t` in all respects called `count_t`; then `calloc()` could be modified from `calloc(size_t, size_t)` to `calloc(count_t, size_t)`, for instance.
&gt; It is not UB if a is a pointer and a + i is within the bounds or one past the end of the same object as a. I am aware of that. That doesn't contradict what I said.
Sadly, the course is not in English. This subreddit is for content in English only. Please post elsewhere.
I forgot that :( 
No problem! Don't feel bad.
&gt; That doesn't contradict what I said. No, but it justifies the use of a signed type as an index or loop counter.
I think using a signed type is perfectly cromulent. I'd use `int` unless there was a good reason not to.
but if `size_t` is good enough to hold the size in bytes of any allocation, then why wouldn't it be sufficient to hold the count? The idea with `size_t` is that it's not big enough to hold the segment selector, and it's unsigned.
Not everything that is low-level is written in C, but as far as I'm aware all OpenGL implementations are C compatible; so it would make sense that vendors would have their C++ implementations written as wrappers of their C implementations instead of rewriting the whole thing. What I think u/BlindTreeFrog is trying to point out is that there are a number of community created support libraries for use with OpenGL that are written in C++ that are not C compatible. The one that comes most readily to mind is [GLM](https://glm.g-truc.net/0.9.9/index.html), a mathematics library written in C++. Then again, I may be wrong about their intentions, because they also made some ambiguous/misleading comments about OpenGL in their comment to you, and their original comment links a book that's 20 years old.
&gt; their original comment links a book that's 20 years old. Still a good book. &gt; they also made some ambiguous/misleading comments about OpenGL feel free to correct them
&gt;It looks like they were moving away from C to everything in C++ at least 6 years ago Who do you mean by "they?" The links you provide indicate community interest in C++ examples and tutorials, which isn't surprising as the game development community at large has a tendency to use C++ over C. If that's who you mean by "they" then I would go so far as to say that your comment is merely ambiguous, and not misleading. However, you also talk about DirectX and OpenGL in a manner that indicates to me that you could mean "they" as in the Khronos Group (the people who write the OpenGL spec) or GPU vendors (who write OpenGL implementations that are packaged with GPU drivers). In either of these cases your wording is misleading and your links don't support your claim. The OpenGL specification provides function prototypes that are ANSI C compliant so "they," meaning the Khronos Group, would not have moved away from C. GPU vendors, as far as I'm aware, are all still pushing C compatible OpenGL implementations with all of their drivers, so "they" too would not have moved away from C.
&gt;feel free to correct them Done. &gt;Still a good book. Could you explain in what capacity it's still relevant? I'm sure the linear algebra still stacks up, as that's not like to change over 20 years, but based on publication date this book doesn't cover anything newer than OpenGL 1.1, maybe 1.3 if the author updated it prior to making it freely available online. The description in the second link even makes mention that a significant portion of the book focuses on profiling, testing, and optimization which are all good things to learn, but modern OpenGL likely makes most if not all of its recommendations obsolete.
&gt; Could you explain in what capacity it's still relevant? "Graphics" is a general concept requiring learning math and concepts. He didn't ask for a book to learn OpenGL. Graphics Programming can be done regardless of library used. Why are you insisting that he must learn OpenGL for the learning to be relevant? 
[Computer Graphics C Version](https://www.amazon.com/Computer-Graphics-C-Version-2nd/dp/817758765X)
&gt; Who do you mean by "they?" Ambiguous "they". Doesn't really matter who "they" are if all of the available resources on a topic is going to be in C++ &gt; GPU vendors, as far as I'm aware, are all still pushing C compatible OpenGL implementations with all of their drivers, so "they" too would not have moved away from C. Yes, that's what C compatible means. It doesn't matter what language the driver is written in because the exported hooks are consistent with C calling conventions. This means it doesn't matter what language the driver or applications are written in because they all can talk the same function calls. Khronos doesn't care what language the driver is written in because it doesn't matter. They just want a consistent and portable interface. The writers of the drivers can do whatever they want as long as they export that interface.
I'm not insisting they use OpenGL, I was using the OpenGL release timeline as a point of comparison, but I think the more important aspect of what I'm trying to say is that I believe that this book is so dated that it will not be able to help OP create a rendering engine. There's a chapter about VGA programming, 3 chapters about optimizing for 20 year old chips, and multiple source files written in C++. I appreciate that you're trying to help, and I'm sorry that I'm coming off as rude, but I would be remiss if I didn't warn anyone reading this thread that this book is not a good starting point for someone in OP's shoes.
&gt;Doesn't really matter who "they" are if all of the available resources on a topic is going to be in C++ If the spec is written with ANSI C prototypes then there is at least one resource helpful for C programmers. &gt;It doesn't matter what language the driver is written in because the exported hooks are consistent with C calling conventions I wasn't making a claim about how the drivers are written, I was pointing out that C programs can still make OpenGL calls; you don't need to write C++ code to work with OpenGL.
I would break the problem up. First, write a simple program to practice reading in some text from a file and play around with that. Then do the same with 2d arrays, putting elements in them and retrieving values from it. Then combine the two. 
Words have meanings.
&gt; I appreciate that you're trying to help, and I'm sorry that I'm coming off as rude, but I would be remiss if I didn't warn anyone reading this thread that this book is not a good starting point for someone in OP's shoes. Didn't think you were being rude, but the more you post the ruder you are gettingg. You know nothing of OP's request other than he wants to do graphics programming in C (and later posts he wants to do a rednering engine) and it's a book you seem to have never read. And your immediate frame of reference is that is couldn't possibly be referring to a new enough version of OpenGL so it must be out of date. The basics of graphics programming don't care about the library used. From reviews of the book: &gt; Yes, it is true that a lot of the code samples are older than much of what modern developers might consider but the core methodology, insights, and domain knowledge ushered in by Abrash are unparalleled both in proficiency and professional writer ability; he knows what he's talking about through and through but also knows how to share it in a very inclusive way. I've found it rare to find both in the same person. &gt; Anyone interested in optimization, its ethics, classic 3D optimization and performance, or even just interested in refining their C/x86 Assembly code should look this over; it's insights are both technically and morally advantageous to any aspiring software engineer. I say engineer and not programmer because this book covers the former and how to excel at efficiency and best-practices rather than simply creating functionality in an abstracted development environment. --- &gt; This book is gold... it also happens to be old. This does not however change the value of the book, the author was addressing the needs of the computer industry for high performance graphics code in the 80's and 90's, but the principles and thought processes passed on in the book are just as valid today as they were then, perhaps more so since computers have become heavily layered in software abstractions that suck performance at every turn. Likely the Assembly code will be of little use to him. And no one cares about ModeX these days. That doesn't mean the other principles covered aren't still valid though.
Many of the best practices in C will be different than best practices in C++. And those that are the same will be the same regardless of language used
&gt; I wasn't making a claim about how the drivers are written, I was pointing out that C programs can still make OpenGL calls; you don't need to write C++ code to work with OpenGL. I never said otherwise. 
In using the wording that you did, you heavily implied otherwise.
&gt; But, they are just defining an interface and behavior. You can write an openGL program in any language that can interface it (eg: https://www.khronos.org/opengl/wiki/Language_bindings) Do you mean when I said "you can program in any language you want"? &gt; But, they are just defining an interface and behavior. You can write an openGL program in any language that can interface it (eg: https://www.khronos.org/opengl/wiki/Language_bindings)
Good answer. I think a good balance between the approaches is use OOP to wrap certain functionality of an API since that way you can have RAII + encapsulation of repetitive tasks. And have your main render loop have an emphasis on DOD.
EDIT: Sorry, I have deleted the original one by mistake. Original Reply: Yes, you are right. The test machine [c5d.large on AWS](https://aws.amazon.com/cn/blogs/aws/now-available-compute-intensive-c5-instances-for-amazon-ec2/) is indeed about 3.0 GHz :) In the case of context switching between standalone-stack coroutines, the context switching only need to do saving &amp; restoring about [the callee saved CPU registers](https://github.com/hnes/libaco#mathematical-induction) (via the assembly function [acosw](https://github.com/hnes/libaco/blob/caa1444e320840c4e886d6fe18404155e9802f77/acosw.S#L49)): /* 0x00 --&gt; 0xff eip esp ebp edi esi ebx fpucw16 mxcsr32 0 4 8 c 10 14 18 1c */ .intel_syntax noprefix acosw: mov eax,DWORD PTR [esp+0x4] // from_co mov edx,DWORD PTR [esp] // retaddr lea ecx,[esp+0x4] // esp mov DWORD PTR [eax+0x8],ebp //&lt;ebp mov DWORD PTR [eax+0x4],ecx //&lt;esp mov DWORD PTR [eax+0x0],edx //&lt;retaddr mov DWORD PTR [eax+0xc],edi //&lt;edi mov ecx,DWORD PTR [esp+0x8] // to_co mov DWORD PTR [eax+0x10],esi //&lt;esi mov DWORD PTR [eax+0x14],ebx //&lt;ebx #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV fnstcw WORD PTR [eax+0x18] //&lt;fpucw stmxcsr DWORD PTR [eax+0x1c] //&lt;mxcsr #endif mov edx,DWORD PTR [ecx+0x4] //&gt;esp mov ebp,DWORD PTR [ecx+0x8] //&gt;ebp mov eax,DWORD PTR [ecx+0x0] //&gt;retaddr mov edi,DWORD PTR [ecx+0xc] //&gt;edi mov esi,DWORD PTR [ecx+0x10] //&gt;esi mov ebx,DWORD PTR [ecx+0x14] //&gt;ebx #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV fldcw WORD PTR [ecx+0x18] //&gt;fpucw ldmxcsr DWORD PTR [ecx+0x1c] //&gt;mxcsr #endif xor ecx,ecx mov esp,edx xor edx,edx jmp eax For Intel386, the callee saved registers is defined in the "P13, Table 2.3: Register Usage" of [Sys V ABI Intel386 V1.1](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI), and for AMD64 is in "P23, Figure 3.4: Register Usage" of [Sys V ABI AMD64 V1.0](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI). Therefore, 10 ns is quite enough to do such simple task.
I may be mistaken, but what you describe sounds like a familiar pattern within the C++ based game development community. Personally I prefer C so I avoid using C++ unless I absolutely have to, but I definitely see the advantages of your methodology.
This subreddit exists to discuss the C Programming Language. Please redirect your question to r/cpp or r/cpp_questions. Word of advice: read the sidebars first. Smaller communities can get frustrated with answering questions that are common and already answered in a readily available area. In order to access the sidebars you may need to go to the old reddit.
As you will likely learn, C and C++ are different languages. This is a C subreddit. You will probably have better luck asking on r/cpp.
Yes you are correct I described a C++ methodology. 
Great answer, good book - don't know why you were downvoted.
There's no apostrophe in graphics.
I think they're looking for a more "bare bones" approach - ie the principles of graphics programming, rather than learning an API. Perhaps they assume C would be simpler because a common misconception is that C++ is an extension of C (without getting into the nuances of the differences etc).
have a look at fscanf(...) tutorials and documentation, does what you want.
None. Modify your second try and remove the curly braces. 2 lines. No curly. Voila
What should be triggering you here is the part where you're returning a copy of a local structure `x`.
your second example is the best one, the flow is clear, its easy to read, and the brackets are already in place so if someone has to edit the code later it will cut down on the number of potentially trivial mistakes they could possibly make. your first and third examples aren't ideal but acceptable for many people, however the rest of the examples are terrible and i wouldn't wish them upon my worst enemy. use brackets even when they don't seem necessary for everyone's sanity.
I prefer #2 but occasionally I'll do #3 if I have a lot of one-liner ifs in series.
It honestly looks so sexy when you have a bunch of 2 line conditionals. void draw(Game* game, Graphics* graphics) { if(graphics == NULL) log_error_exit("Graphics pointer is NULL. %s\n", SDL_GetError()); if(game == NULL) log_error_exit("Game pointer is NULL. %s\n", SDL_GetError()); // and so on ... } So simple. So beautiful.
Another vote for the second one. Third if you *must*. But always use braces even for a one expression body. Failing to do so has caused some serious bugs.
putting the closing bracket outside the comment code block. actual cancer.
Also relevant: [MEM12-C. Consider using a goto chain when leaving a function on error when using and releasing resources](https://wiki.sei.cmu.edu/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources)
I got into a mild argument lower in the thread about this. If OP wants to take on the challenge of low-level graphics programming more power to them. Other members of this community have posted a couple books in this thread that may be of help despite being 20 years old. Personally I'm of the opinion that people should know how to use a tool before they try to make their own.
[Don't use feof() as a loop conditional](https://latedev.wordpress.com/2012/12/04/all-about-eof/).
Why? You mean he should pass a reference to x? Wouldn't this lead to a segfault eventually?
&gt; But always use braces even for a one expression body. Failing to do so has caused some serious bugs. Why is that?
I can't stand them.
Personally I think they're fine, but I don't use them. I run into times when the line is too long and I have to split it and I'd rather have a consistent style than a compact style. I always use braces, I never do anything crazy or with bizarre formatting because it looks neat or it's compact. So I think #1 is fine, but I'd use #2. #3 is not good. braces shouldn't occur without newlines (struct literals aside), and the remaining are varying states of abomination. I also really like using code formatters and my philosophy there is "if you disagree with the code formatter, you're wrong." It's a habit I've picked up from Go (where there is a first-party code formatter and an official format) and I think it's a good one. I just don't think about it much anymore after I've configured the formatter.
I‚Äôd personally go for something like if(x.count == 0) Free(x.String); return x; Or the almighty Allman style: if(x.count == 0) { Free(x.String); } return x; Idk.
I prefer NULL-tolerant free functions and a single goto, either called **done** or **error**. That way you don't need more than one label or to check if they're NULL, if you free NULL that just does nothing. If I recall, SDL's resource free functions are NULL-tolerant so my function to get up SDL looks something like this. bool init_sdl( const char* title, int width, int height, SDL_Window** window, SDL_Renderer** renderer) { *window = NULL; *renderer = NULL; if(SDL_InitSubSystem(SDL_INIT_VIDEO)) { goto error; } *window = SDL_CreateWindow(title, width, height, other_stuff); if(NULL == *window) { goto error; } *renderer = SDL_CreateRenderer(*window, ...); if(NULL == *renderer) { goto error; } return true; error: fprintf(stderr, "%s\n", SDL_GetError()); // This one is not necessary, but I want to show the // reverse order unwrapping SDL_DestroyRenderer(*renderer); result.renderer = NULL; SDL_DestroyWindow(*window); result.window = NULL; SDL_QuitSubSystem(SDL_INIT_VIDEO); return false; } This pattern is repeated a few times when using SDL. Loading an image into a texture, for example, involves opening a file, opening it with stb\_image, converting it to an SDL\_Surface and then generating the SDL\_Texture. All those resources need to be freed before it returns the texture, so there's bigger chain there. If the resource free functions are not NULL-tolerant then the goto chain is the next best option, the worst and most cumbersome option is the "pile of if statements."
The only reason I avoid if statements without curly brackets is because it's annoying as hell when you end up needing to add an additional line to the if statement. 
What's wrong with that?
I have a soft spot for oneliners and as such I've grown to use oneliners for early return checks: foo() { if(asd) { return; } } I never remove the curlies, since I'm really prone to interpreting tabulation as scope. 
For my part I think single line if statements are ok as long the entire expression is "short". So early returns, gotos to cleanups etc. I think it is important to consider the "why" here: What is wrong with a single line if statement? The readability is one thing, having lesser lines sometimes makes the code easier to get an overview of, but that is of course very subjective. The protection against `goto fail` bugs is another thing. ```c if (foo) goto fail; goto fail; ``` So for my part I usually go with either ```c if (foo) goto fail; ``` or ```c if (foo) { /* complex code */ } ```
There are plenty of examples out there of omitted braces causing difficult to track down bugs later on (See Apple's gotofail bug). Also, not a big deal, but #2 is good for minimising changes in a diff. You can add something to the if statement or before the return without having to change any other lines. 
I‚Äôm dealing with a large c code base which has single-line if statements. I dislike them, I find them hard to spot, particularly if they‚Äôre just a little line in the middle of a much bigger block of code. I prefer your option #2, the brackets help to make it more obvious what‚Äôs going on. Though I like my open curly bracket on the line below! 
First try is nice and textbook. Don't second guess yourself, you're doing great
It might just be me, but when I look at the code and there is a `"... ? ... : ... "` part in it I close the source file and never look at it again if it isn't absolutely necessary. Like come on... is that hard to write an extra if?
C doesn't have references. It does allow you to return a struct by value, though. Nothing wrong with that.
If you talk about risk in later changes to the code, I find if(x.Count == 0) free(x.Strings); a lot safer than if(x.Count == 0) free(x.Strings); ... even though *visually*, I prefer the latter. 
Usually the standard is to be read as "should at leat fit" which makes sense to me, so while I agree this 7.19 could be interpreted that way, I wouldn't (citing 7.20.5). Possibly one could look into the C99 rationale.
Choose one. Any one (as long as it isn't the ternary stuff, which is simply evil, especially if you put side-effects in there). And then stick with it. That is the only part that really matters. Stick with it. Be consistent. The same time, every time. So everybody can read your code and know what you want to express.
Allman all the way.
Couldn't agree more. Also, happy cake day!
Agreed. OTBS for the win.
I choose 3. if (P) S does neither visually distinct the if part from the statement, nor does it save you from later forgetting the braces when editing. if (P) S Only has the second fault but worse since it basically invites just adding a next statement. Also I indent every new block, this thing breakes the rule, it's basically a single-line statement of case 1, but just broken into two lines. Ugly. Also it takes 2 lines, sooo. Everything except else except 3 is abuse of the language and unreadable. The only counterpoints for 3 I've seen here are just "I don't like it", which is really bad reasoning, but of course it's also about taste. But it does seperate the if from the following statements with a new block which is grammatically different and more clear, IMHO. It it's easy to edit and *very* clear to the eye.
This is exactly why I never use single line ifs.
It's funny because I was always taught that working with pointers as arguments was called "passing by reference". Anyways, that's what I meant. So, why was the dude complaining about OP returning the struct by value?
You will no longer have access to that memory after x goes out of scope. The OS will make that memory available for future allocations. A good compiler should warn you about this however. I believe GCC and Clang both have this ability. I usually compile with -Wall -Wextra -pedantic just to be sure.
since i started doing it that way, i've never looked back. Just becomes habit, and is the least prone to error, easiest to edit later, easiest to cut and paste if needed, etc)
Always using braces is a waste of space if you know what you‚Äôre doing. Another alternative is to check if count != 0 then return. This works extremely well when there is a lot of additional logic and you don‚Äôt want to indent all of it
OP was returning a copy of the struct. While any references to the original struct will be invalid when it goes out of scope, the copy will have the scope of the caller. `return &amp;x` would've been bad.
a pointer is a reference
It might just be me, but when I look at the code and there is a "if (bool)" part in it I close the source file and never look at it again if it isn't absolutely necessary. Like come on... is that hard to write an extra "== true"?
I don't consider that an issue at all (not even comparable to what I said) because if you have expressive variable/function names then `if (isOkay)` makes much more sense than `if (isOkay == true)` however, it's rather easy to miss and whole lot of harder to read a code that has that shortened if formula in it.
The second example is the most readable for people coming in to maintain your code. Sometimes, when I am trying to "tighten" my code I am guilty of utilizing your first example.
I started using Allman before I knew it was a thing. It's just so much easier for me to find a closing brace and run my gaze up the left side of the code until I find the opening brace. It throws me off trying to find the opening brace on the staggered right side of the code, even though I know it should be the last thing at that indent level and my editor even highlights it if my cursor's on the closing brace. It's just a mental thing, I guess. I use a lot of whitespace anyway. I've never seen the need others have for compact code. All it took was roundly cursing the idiot that wrote the code I'm trying to debug and finding out it was me to cure me of trying to write clever, compact code.
Crypto++ is a C++ library, and as such you will not be able to integrate it into a C project. This subreddit exists to discuss the C Programming Language. Please redirect your C++ based question to r/cpp_questions.
Thanks! I'm talking about the IBus_t (lib/ibus.c) and BC127_t (lib/bc127.c). I think I'm set on taking your original advice -- the types track the state of their respective modules internally and the implementation (handler.c) takes care of acting on that state.
It's ugly.
I often use `if (condition)` ` statement;` but you of course have to be sure to add brackets if you need to expand the if body. 
We are fortunate the C language gives us so many options, if only we were so fortunate if the language standardized formatting; regardless, why do you think you have to choose between them, at the exclusion of the others? All of your examples compile, thus all your examples are valid choices. The trick is picking the correct style given the context. Never forget, and I'm going to paraphrase poorly here, code is meant to be comprehended by humans, and only incidentally compiled and executed. It is up to you to decide which makes the most sense, and it doesn't always have to be the same answer.
My apologies. Question posted in the appropriate board.
Happens all the time. Thanks for understanding.
However, if you are good with this sort of thing, could you PM me and explain how to add an external library as a dependency or something like that? Or am I completely SOL on using Crypto++.
Glad to hear that. Sorry I couldn't help more with your specific case. Whatever the case, I think this is a good approach.
I am not talking about range, I am talking about intended purpose, use in APIs, and clarity for the reader. See also: Hungarian notation (apps, not systems).
Unfortunately I don't use Visual Studio and I'm unaware as to the best practices when including libraries for linking within it.
Not to add to the bike shedding... While I generally avoid single line if statements (in favor of using braces as in your second example), on rare occasions there are exceptions when the one-liner results in arguable more legible code. The example below is inspired by some code from Jon Bently's classic book, "Writing Efficient Programs.": // Binary search. Relies on any unused elements in orderedEncodings being UINT32_MAX. unsigned i = 0; if (orderedEncodings[i + 32] &lt;= encoding) i += 32; if (orderedEncodings[i + 16] &lt;= encoding) i += 16; if (orderedEncodings[i + 8] &lt;= encoding) i += 8; if (orderedEncodings[i + 4] &lt;= encoding) i += 4; if (orderedEncodings[i + 2] &lt;= encoding) i += 2; if (orderedEncodings[i + 1] &lt;= encoding) i += 1; 
Yes, but if I understood you correctly, your point was that size_t is the count in bytes because it's defined to hold the size, in bytes, of an object as returned by sizeof. But if we say "should at least be able to hold the size in bytes" (which IMHO is the intended reading) it sound less like size_t always being being something in bytes. Then 7.20.5 kicks in and supports this argument. So I'm neither going by range (although this of course, is important too) but by how the wording affects whether size_t should only hold the number of bytes or different numbers too.
&gt; But if we say "should at least be able to hold the size in bytes" (which IMHO is the intended reading) You can get any text to support any argument if you're free to rewrite it before you quote it.
It'd probably be easier to just get the size of the file by using fseek and then just allocating a large enough buffer to read the entire file into it (and to null-terminate it) so as to completely take the file out of the equation before doing anything with the data itself
That is what I usually do. I was just giving a rough idea of somewhere to start. 
C passes and returns by value (the argument or return value is copied)
Fair enough
Yea I'm an idiot. My b. Thanks for the correction
Example one is my preference
Ever heard of KISS before? Keep it simple, stupid. You're making way to much of this, just go with the basic style, hanging return and leave it at that, cause it's expected, it's clear, you or some hypothetical other person won't have to think about it. 
The only thing I would add is put your static variables to the left of the == operator as a general practice to adopt. if you miss-type it: if(0 = foo) Compilation error if(foo = 0) Enjoy your debugging
Main uses? The operating system on your computer. The router it goes through. The modem, too. Your TV. Your car. Your XBox/Playstation/whatever. Any small device you have. And much, much more.
Short answer: Yes. Long answer: Yes.
Learning C makes you a better programmer because it teaches you how to write efficient programs and makes you understand what kind of operations are fast and what operations are slow.
My main interest in C is compatibility with other languages. It is easy enough to write a C library and expose it to Python, Ruby, Go, Java, etc. I can't even say the same about C++. Regarding security, clang-tidy and the clang sanitizers really make life a lot easier. It isn't nearly as bad as many articles would have you believe, as long as you use the right tooling.
That's rude.
Obsessive-compulsive people might do better with Python-style syntax. Check out the [Nim programming language](https://nim-lang.org), which compiles to C.
so any small device is C only written? theres no more secure alternative to it?
still out of 1000 lines theres 1 bug
Why do you think writing a program in C makes it less secure?
because theres a huge pool to make mistakes
That can be said for any language. 
There's a huge pool to make mistakes in any language. It's not the language that makes mistakes.
Not every embedded system is written in C/asm but they play a big role for sure
Agreed. Almost all of the C errors (double free, memory leaks, uninitialized memory, etc.). I have fixed were discovered upfront through tooling. The errors I later found were mostly logical errors you can encounter in any language.
At least it is your mistakes, not those of the higher level library you are using ü§ì
Compared to what? The difference between C and something like C++ is that a single person can easily understand how C works from top to bottom. If an experienced programmer shoots himself in the foot with C it's because he made a mistake, not that he didn't understand some language feature or an abstraction buried 10 layers deep or something. C is what it is, you tell the computer to do things and it does it. It's all laid bare for you and this allows you to write very exacting programs that you know (and I really mean know, not strongly suspect) are correct. So no, the "pool of mistakes" you have in C is extremely shallow.
what other languages are used for modern embedded system implementations?
enough to not make it secure 
c will still compile and run a programm even when there are flaws in it, unlike other high level languages (java)
C++ occasionally (depending on *how* embedded the architecture is, typically only restricted subsets of C++ are permitted), or assembly. Sometimes custom languages like BASIC-abortions specific to the architecture. Most other languages require too much of a runtime to be able to fit onto an embedded chip and still run properly, or they pull in a shit-ton of extra dependencies that can‚Äôt be vetted/tested properly, or getting the language running might just be low-priority on developers‚Äô priority lists.
I think you've been listening to people who don't know much about C. Most security flaws aren't related to the underlying language. Consider software which is famously insecure like Wordpress - not written in C. Some languages like Java introduce a whole new class of vulnerabilities, security flaws in the language implementation itself. C doesn't have that class of issues at all.
really assembly? that sounds like pain, although its worth learning isnt it?
interesting, Ill have a look on that!
If you want to do reverse engineering, you will need to at least understand assembly.
There's some C++ but on smaller embedded systems C is still king.
I know :)
what about python?
It‚Äôs definitely worth learning (learn how the software stack works down to the transistors if you can), and it‚Äôs not too bad as long as you take it in small bites and follow whatever Rules have been laid out (ABI etc.). Typically it‚Äôs just little tidbits that can‚Äôt be programmed directly in C, with C code making up the remainder of the codebase.
sorry, not the best place to ask this question I guess :D
In a lot of higher level languages, your program will run with major bugs that a C compiler would catch. And at least, in C, your program will generally crash on those errors while other language will simply have undefined behaviors that are hard to debug.
any good tutorials on how to learn reversing? I am trying the lenas stuff currently
Java can have errors at run time too. 
python's poorly suited to smaller embedded applications since the standard runtime is very large and it runs very slowly compared to C. I've seen it used occasionally as a scripting layer on top of a system written in C.
gold.
I learned this stuff in the late ‚Äô80s, so ‚Äôfraid I‚Äôm no help for that sort of thing. But reverse-engineering tends to require a critical mass of niggling details on top of a good forward-engineering baseline, so until you‚Äôre comfortable in C and assembly it‚Äôs going to be intensely frustrating.
That's why you should use clang-tidy with most of the error checks on. Just because the compiler doesn't yell at you doesn't mean it is good or safe code.
man you are old :D
Oldish‚ÄîI started programming in 3rd grade, so I did C and assembly in 5th.
C is my favorite language because it taught me more than anything else I've used when it comes to development. It is a very easy language to write with, but what makes it difficult for most people is you need more of a grasp with CS fundamentals, such as how memory is structured. Knowing when to use the stack and when to use the heap, etc. I would use C for everything if I could, but I cannot get that delusional. C isn't the best choice for most modern development projects due to the nature of what is being developed these days. I still believe C should be the very first language all CS students learn over Java or Python.
what do you currently work on? :)
*Anton's OpenGL 4 Tutorials* is a good introduction to OpenGL in pure C see https://www.amazon.com/Antons-OpenGL-Tutorials-Anton-Gerdelan-ebook/dp/B00LAMQYF2/ . You can find some free content from the same author here http://antongerdelan.net/opengl/
Mix of stuff‚Äîhelped start a company, so I‚Äôve helped out on most of our projects in some form or other. Right now I‚Äôm mostly working on an experimental HPC architecture (targeting graph processing, among other things) and the software involved in making it work. Some C/C++ shim stuff to make it possible to mash existing software into this architecture, some C/C++/asm runtime library stuff so C/C++ code work at all, plus a bunch of stuff targeting x86 so we can test effects of various parameter changes on the code without needing an actual chip implementation. E.g., eating up memory bandwidth by mapping memory WC and throwing nontemporal accesses at it, so we can see how threads interfere with each other when on same/different NUMA nodes.
I don't even know what you're trying to say, and I don't think you do either.
oh yes I know some of these words! ;p
It's best for learning how things work because it doesnt have many libraries or already inbuilt functions as compared to Java or python to do something, so you have to write them from scratch and that's how you learn. 
Maybe he is thinking of undefined behavior and footguns? 
OK, but that goes back to my point that C has less undefined behavior, easier to understand reasons why there is undefined behavior and far fewer footguns than most other languages. Though I don't know enough about newer languages like Rust, maybe those have fewer and that's what he's talking about.
Python has a framework (? Library) called MicroPython which runs on select chips. The most common languages by a very large margin (read, not even worth discussing anything else) is assembly and C.
I honestly can't think of any practical reason for the comma operator as opposed to actually readable code. I've used the comma operator my fair share of times when playing around with obfuscated C, but never in any serious project.
I'm OK with having two variables incremented in a for-loop. That's about it.
A couple more options for you: return x.Count ? x : free(x.Strings), x; switch (x.Count) { case 0: free(x.Strings); default: return x; }
Here's one, simple, way. You could introduce another variable which you use to keep track of how many symbols you've printed. Any time that variable becomes a multiple of 10 you print a newline in a separate printf (or use `putchar`). Read up on the `%` operator if you don't know how to determine if a value is a multiple of 10.
Most of the vulnerabilities in C programs you're thinking of are due to just plain bad devs. It's really not hard to length check stuff and sanitize your strings. Protocol exploits occur no matter what language you implement the protocol in.
So one could say C is web-scale now? :D
LOL, why would someone use C in web and endanger their whole website? It is a language that hard to learn and expertize. 
 int MAXPOS = 10; for(int c = min, int pos = 0; c &lt;= max; c++) { if(++pos % MAXPOS == 0) { putc('\n', stdout); pos = 0; } else putc(' ', stdout); output(c); } void output(int c) { if(c == '\'') printf("\\' %d", c); else if(!isprint(c)) printf("?? %d", c); else printf(" %c %d", c, c); }
Most web tech is written in either C or C++ where performance matters, and the drivers and firmware for all the hardware that makes the internet work in the first place is mostly written in C. If you want to know why anyone would use C, figure out why they already do.
That was kinda the joke, but you have to remember that pretty much your whole network stack is written in C.
If won't reach the second condition. It will pass on the value of the first True condition and terminate that selection statement. 
I reasoned *why* I think the rewritten version is more close to what's intended, but I do know that this is unclear and one would have to look into the rationale or make a DR for it. And I supported my reading of the text by other paragraphs.
What does OTBS stand for? 
IIRC these are known as 'yoda conditionals' 
It probably always has been with it's speed.
[One True Bracket Style](https://en.wikipedia.org/wiki/Indentation_style#Variant:_1TBS_(OTBS\)).
This. You could also just use your i. if (((i - 32) % 10) == 0) 
&gt; something many new programmers seem to have never learned how to do. That's mostly because academia has decided that OOP and other data abstractions are "best practice". If I hadn't started studying computer science outside of my college classes, I would probably think that OOP is super efficient and the end-all be-all of programming.
...when PHP-programmers try to take a C-quiz.
Please format code blocks by placing four spaces before each line of code. I've formatted your code below: void HurricaneIdentification() { printf("The following values are the registered hurricanes, along with a unique identification number for each.\n"); FILE *fileIdentification; fileIdentification = fopen("Identification.txt", "r"); char singleLine[150]; while (!feof(fileIdentification)) { fgets(singleLine, 150, fileIdentification); puts(singleLine); } fclose(fileIdentification); main(); return; } You should not be calling `main()` in this function. `main()` is a special function that is called automatically and should be calling `HurricaneIdentification()` if anything. Personally I don't understand the point of making `HurricaneIndentification()` its own function if your program is only meant to accomplish reading in a predetermined file and printing out categories. It would make more sense if you passed the file path to the function, or if you needed to return an array of categories. I'd love to help you further, but I'm confused by the nature of your problem. It doesn't seem as though you've attempted to implement the main logic at all. Where are you getting stuck?
Tried to place four spaces in front of each line but it would't work for some reason, just took a screen shot of the code. I called main because I wanted it to return to the "main menu" I've set up a switch case their, where the user can choose one of multiple options. Is it bad practice ? As for the implementation I can't wrap my head around how exactly I'm suppose to do it. I don't know where I should start. I've drawn out a flowchart in an attempt to explain the question a bit better. [https://imgur.com/a/C7jN7ty](https://imgur.com/a/C7jN7ty)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/CDQt4aE.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
programming languages don't cause security issues, sloppy programmers do, almost no language will help the careless...
&gt; Is it bad practice ? In my opinion it is bad practice to use `main()` like this for your use case. It obfuscates your control flow in a manner that is very uncommon. There may be instances where calling `main()` in other functions can be beneficial, but none readily come to my mind. The one instance that does come to mind for calling `main()` in general is in implementing a recursive `main()`, but I don't think this is what you want. Your flowchart looks like a reasonable starting point. The entry and exit points aren't completely clear, but I think it would fit well within your `while` loop. Assuming that your input file is guaranteed to be formatted as white-space separated integers you could use `fscanf()` to read numbers into variables instead of having to parse through a `char` buffer containing the whole file. At this point it looks like you have the logic down, so I recommend trying to implement that logic as code. If you run into problems try to troubleshoot them, but if they persist you can come back and we'll do our best to help.
At the end of the day, programming languages are best viewed as tools to use, so in the end you have to make the decision. Unfortunately, and no dirt meant to the community here, people get attached and really really hooked on given languages. It's not helpful, you need to pick the right tool. &gt; all the security aspects put C into bad light The most glaring security issues in modern computation don't really come down to language I'd assert, but to the underlying hardware. Meltdown, Spectre, Rowhammer, and others coming from EM or power analysis can only be addressed so far in a PL/software context. Aside from that, a given compiler can be made more or less strict, but some languages arguably can produce safer results. That said, things have to get to the chip eventually, and if there is a rich enough prize at the end, attackers will work to find a way in regardless of how a piece of software is made. &gt; is C replaceable? In some contexts, definitely. I wouldn't want to try doing Haskell's QuickCheck stuff in C. If I were trying to make a new language, I'd probably go the FP route. But, low level stuff where I need to deal with architecture stuff, I want C. Rust, many argue, is making inroads into system stuff, but only time will tell there. I work on FPGA/HW stuff, C is invaluable for me. It's a great early target without a lot of cruft that managed languages need. &gt; What is the todays main use of C? Low level, OS, very early dev on new architectures, and embedded will be the first to come up. I'd also assert, C is still one of the heavy hitters in high performance programming (FORTRAN is really the other big boy here it seems. Some people still really like their FORTRAN)
&gt; I still believe C should be the very first language all CS students learn over Java or Python. I agree that Java is a horrible start. Python I go back and forth on. I think people avoid C because they fear pointers (I think this is a poor excuse honestly) However, I think a good argument can be made for teaching and FP language like Haskell first since going to FP after imperative is very hard (don't know of the other direction though, I can't go that way). the tricky thing is I see learning C first as teaching about the processor at the same time, which is very good. Starting with an FP end encourages students to come from a mathematical background down to PL and processor. It's a tough decision to make honestly
Not what you're asking for, but know that GNU grep (and ls to a lesser degree) is really quite complex. I'd recommend reading ToaruOS's version of these binaries first since they're pretty much the simplest and more naive possible take on these tools. Example: https://gitlab.com/toaruos/toaruos/blob/master/userspace/core/cat.c versus https://github.com/coreutils/coreutils/blob/master/src/cat.c
&gt;https://gitlab.com/toaruos/toaruos/blob/master/userspace/core/cat.c I wouldn't hold that up as an example though, it contains quite a few bugs: * Fails to exit with nonzero status if it can't write output * Doesn't detect or handle fstat failures (though they are very rare - one way to get them it in a 32-bit userspacve on a system with 64-bit inode numbers, at least one of which is not representible in a 32-bit ino\_t). * Issues incorrect message for directories with mode 0111 or 0333 * Will likely do hilarious things on read failures - in this case `r &lt; 0` and this value is passed as the third argument of write, but that argument is unsigned, so a very large value will be passed.
You need to parse each line like this: Since the id number doesn‚Äôt matter, you should tell your program to skip all the characters until it encounters spaces (or tabs idk) and then further skip all spaces until it encounters a digit. While the current character is a digit, append it to a string. Then you simply have to parse the string into a number. I‚Äôm not 100% sure of what you‚Äôre asking though. Does that make sense? 
That ToaruOS code is absolutely terrible and exhibits quite a bunch of anti-patterns (such as hard-coding error messages instead of inquiring `errno` about what actually went wrong). I would not advise any beginner to use this as a reference. If you want well written implementations of these programs, try those shipped with BSD.
Thanks. I'm just trying to better understand the reasonings behind the code. Even if it is super complex. If there is not much out there, I may start working on putting something together, and having others correct my mistakes.
You are right. This is why gcc and clang warn about not using parentheses when mixing conjunctions and disjunctions. When in doubt, start by adding parentheses everywhere until precedence no longer matters (apart from the precedence of parentheses over everything else), then apply your transformations (in this case, [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)) !(x &gt;= 3 || y &lt; 5 &amp;&amp; z != 15) !((x &gt;= 3) || ((y &lt; 5) &amp;&amp; (z != 15))) (!(x &gt;= 3)) &amp;&amp; ((!(y &lt; 5)) || (!(z != 15))) ((x &lt; 3) &amp;&amp; ((y &gt;= 5) || (z == 15))) (x &lt; 3 &amp;&amp; (y &gt;= 5 || z == 15))
Surprisingly, the GNU implementation of `cat` linked by /u/cym13 is pretty easy to read. Otherwise, I really advise you to look into the FreeBSD code which is typically pretty readable.
That is correct.
&gt;Now I know that when you negate you flip || into &amp;&amp; and vice versa, as well as the less than/greater than signs. I think we need to be more formal about this. Here's how each logical operator is complemented: |`A`|`!A`| |`A &lt; B`|`A &gt;= B`| |`A &gt; B`|`A &lt;= B`| |`A == B`|`A != B`| |`A || B`|`!A &amp;&amp; !B`| |`A &amp;&amp; B`|`!A || !B`| Your original problem is of the form `!(A || B &amp;&amp; C)`. It's worth introducing a couple extra parentheses to make the order of operations more clear: `!(A || (B &amp;&amp; C))`. If we use `D` to represent `(B &amp;&amp; C)`, this is just `!(A || D)` ... and now we can get started! We can use the table above (DeMorgan's theorem) to say that this is equivalent to `!A &amp;&amp; !D`. `!D` is `!(B &amp;&amp; C)`, which is equivalent to `!B || !C`. Combining these together we get `!A &amp;&amp; (!B || !C)`. As you can see, you are correct. That's not the only way to simplify this expression, of course. You could also rewrite it to `!A &amp;&amp; !B || !A &amp;&amp; !C` and a hundred other forms.
Your professor or TAs should be able to help you with this. Please understand that I'm not trying to blow you off here. It seems like you're pretty new to your degree program and it's vitally important that you know how to use the resources you university has set up for you. More than just getting the answers, asking your professors and (to a lesser extent) tas gets valuable face time, which shows them how hard you're working (making them a bit less critical when marking your assignments) and helps build your network. There's nothing wrong with asking questions like this online, but you should always go to your professor first. That's why they're there.
(cc /u/nderflow) It's not perfect code, that's sure, but that's why I call it a first read. If you're so much a beginner in C that you need line-by-line explainations then it's interesting to see a working implementation. What's important (and clearly I should have emphasized that more in my first post) is to then read a better implementation (GNU or BSD) to see how they differ and why. There's much more to be learned by the comparision between the naive and the correct than from just reading a "final" piece of software.
Look into [GMP](https://gmplib.org/) to start. There's [other options](https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software) out there, of course.
Thank you my kind sir.
It's not just "not perfect," it is full of things that are wrong or just really bad style. Not a good resource to learn from.
It's naive. It's exactly what a beginner would write, and because of that I find that there's much to learn from the comparison. That said I know that different people have different take on what a good learning path is and I can appreciate your way.
GMP is probably the best one to start with. I've never stopped with it though; it's highly capable. 
What is the problem that it requires these large numbers however? Very curious
I might have made a pretty big math-related discovery and I am quickly going through the process of trying to see if it's true. Then if it is, write up a thingy on it and publish. I gotta do a wack-load of calculations though lol.
If you need a hand, I can get you started with GMP. My maths is pretty good too. Pm me if so. 
This is really cool!
Oh and I have a question. Why does it only work with https? 
It doesn't only work with TLS, but by default it will use TLS since there's no reason your site should be going over plaintext in 2018. Kore will actually give you automatic sane ciphersuites with full PFS for all major browsers. It also isolates your private keys in a separate process so they can't leak from your application code. But you can produce a build without TLS in case you are running behind a TLS termination point of sorts: `$ make NOTLS=1` 
Very interested on what you may discover, post about it here or in r/theydidthemath or r/math when you finish please!
Thanks!
Sure thing, I might just make a new sub-reddit or small community for it since there is a lot of work that might need to be done! Fingers crossed this turns out to be something cool.
Yeah let me know! Need something new to work on! 
I've already got some code typed up, but maybe be prepared to do some CUDA related stuff (I used nVidia's default install for Windows 7, and VStudio, but it's one very simple .cu file, so technically you could probably just cmd line compile it on any OS), and some basic C (I use Pelles C, it's pretty compatible with GCC&amp;Microsoft stuff).
[Understanding Unix/Linux Programming](https://www.goodreads.com/book/show/688354.Understanding_Unix_Linux_Programming?from_search=true) goes through writing several of the classic utilities.
You can't with those function signatures.
I'm a big fan of number theory. 
Sure thing! I might make a new community/subreddit since, if this whole thing pans out, there will be lots &amp; lots of calculating to do to find really really big primes, perfect numbers, etc.
quintillions might take a while. Like, a month or two.
Good luck!
No. But if you want to die mathematics with C then yes.
IMO you'll only really need math (*along with other tools*) if you're working on something with a serious performance bottleneck of some type. In most cases you'll be able to just kinda brute force your way through with whatever code comes to mind but when shit hits the fan you're going to wanna use all that fancy maths to help find and write an elegant, focused solution to your problem.
Learning from what a beginner would write leads to programmers who feel validated that their na√Øve style of programming is correct. Learn from masters, not apprentices.
Add. Subtract. Divide. Multiply. Less than. Greater than. Equals. Boolean logic (NOT !, AND &amp;&amp;, OR ||), bitwise operations (&amp; | ^ &lt;&lt; &gt;&gt; ~) That's all you (mostly) need. 
Do it in one dimension first so it's easier to follow (and less typing). Let's pretend `tailX` starts off as an array [1, 2, 3, 4, 5]. Then a new `x` value of 0 is introduced. Before the loop begins, you now have `tailX` is [0, 2, 3, 4, 5] and `prevX` as 1. You then go through the statements of: 1. `prev2X = tailX[1]` (`prev2X = 2`) 1. `tailX[1] = prevX` (`tailX[1] = 1`) 1. `prevX = prev2X` (`prevX = 2`) So, after the first iteration of the loop, you have `tailX` as [0, 1, 3, 4, 5], and `prevX` and `prev2X` have a value of 2. It's worth noting that, at the end of each iteration, `prevX` and `prev2X` always have the same value. The only purpose of `prev2X` is to act as a temporary variable while values are being switched (personally I think it's a very poorly named variable). After the second iteration of the loop, you have `tailX` as [0, 1, 2, 4, 5]`, and `prevX` and `prev2X` with a value of 3. After the third iteration of the loop, you have `tailX` as [0, 1, 2, 3, 5]` and `prevX` and `prev2X` with a value of 4. Finally, you end up with [0, 1, 2, 3, 4]. The loop just shifts each value down one. I think it would have been easier and clearer to just use `memmove` rather than an explicit loop.
Note that the loop runs for `nTail - 1` times. Also, you assume that `tailX[0] = 5` and `tailY[0] = 6`, yet you also have `tailX[1] = 0` and `tailY[1] = 0`, which is impossible for snake. (It should be, at least, one off, assuming it doesn't wrap around and can go diagonal). Here is an example with more real values: Array `tailX` and `tailY` (before calling the function): i 0 1 2 3 x 5 5 5 5 y 6 7 8 9 1. Iteration 1. `prev2X = tailX[1] = 5; // prev2 gets "current" values` 2. `prev2Y = tailY[1] = 7;` 3. `tailX[1] = prevX = 5; // tail[1] gets position of old tail[0]` 4. `tailY[1] = prevY = 6;` 5. `prevX = prev2X = 5; // prev gets the old position of tail[1]` 6. `prevY = prev2Y = 7;` 2. Iteration 1. `prev2X = tailX[2] = 5; // prev2 gets "current" values` 2. `prev2Y = tailY[2] = 8;` 3. `tailX[2] = prevX = 5; // tail[2] gets position of old tail[1]` 4. `tailY[2] = prevY = 6;` 5. `prevX = prev2X = 5; // prev gets the old position of tail[2]` 6. `prevY = prev2Y = 8;` 
I don't think you need math more in C than any other programming language. If you need math it's because the problem you're trying to solve involves math.
I don't disagree a single bit with that, but it misses the point which is that to actually learn from masters and not just copy without understanding you need to see how what they do differs from what beginners do. Especially when the difference spans thousands of lines for what could be expected to need less.
&gt; Especially when the difference spans thousands of lines for what could be expected to need less. I honestly doubt that a beginner can implement the same feature set as GNU cat in significantly less lines. If you want a short implementation, check out the [code from Plan 9](https://github.com/0intro/plan9/blob/master/sys/src/cmd/cat.c). While slightly different from the Unix versions due to the different API, it's very readable.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [0intro/plan9/.../**cat.c** (master ‚Üí 7524062)](https://github.com/0intro/plan9/blob/7524062cfa4689019a4ed6fc22500ec209522ef0/sys/src/cmd/cat.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e28wuwt.)
It definitely helps having a solid mathematical foundation, but as many programmers manage just fine without such, I don't think you are going to have huge problems.
If you need to call a function that takes a `va_list` from a non-variadic function, you have to wrap it in a variadic function: StringRef CreateWithFormatWrapper(const char *format, ...) { StringRef sr; va_list ap; va_start(ap, format); sr = CreateWithFormatWithVAList(format, ap); va_end(ap); return sr; } If you're only going to use it in this one location, make it `static inline`.
I wouldn't recommend starting with `grep`. Modern implementations are extremely complex, while older implementations are likely to be poorly written by modern standards. Unless you can find a well-written implementation that only supports ASCII and POSIX basic or extended regular expressions and does not perform complex optimizations...
&gt; I honestly doubt that a beginner can implement the same feature set as GNU cat ~~in significantly less lines~~. FTFY
Hell no. I honestly think I have math dislexia... Really all you need is basic algebra, and a solid understanding of basic variables.
I'm skeptical. Snipped from Amazon reviews: &gt; Unfortunately, the examples are in desperate need of adherence to best practices. If you turned in something resembling the example code into your professor he would fail you. &gt; The content is outdated and only good to learn the basics. Many examples no longer compile or work. &gt; There are typographical errors in exemple code.
If you want to advance your programming skills, you should focus on computer science fundamentals. Algorithms, data structures, design patterns - that sort of thing. If you want to solve tough engineering problems, you'll need more math. Most software that is written is not solving a tough engineering problem. The majority of code is App/OS/glue/library code. Engineering problems that require a lot of math are things like compression algorithms, video encoding, 3d modeling, etc. Do you want to write a new compression algorithm from scratch yourself, or do you want to write an app/utility that uses zlib/brotli/whatever? You don't need to know the math behind brotli to use it. 
`grep` is a bad example as well because its algorithms are intrinsically very complicated, even when not going for the more esoteric optimizations. If you don't have a solid grasp on language theory, you won't have a chance to understand wtf is going on in the code.
I don't agree. If you stick to ASCII, basic regular expressions, or extended regular expressions without character classes, are easy to understand and easy to implement (albeit inefficiently) as an FSM.
Of course. But to understand that, you first have to understand what finite state machines are, what regular languages are and what their relationship is. You should also have a basic understanding of Thompson's algorithm. Which is just what is said: If you don't have a solid grasp on language theory, you won't have a chance to understand wtf is going on in the code.
I don't get why people are so fixated on interview questions. It is much more frutiful for your career to hone your skills in general rather than hoping that the interviewer randomly asks a question whose answer you memorized. 
You don't *need* math to be a programmer, in the sense that it's not a prerequisite. However, there are concepts that math and programming share, like functions and variables. The idea of things happening in logical steps, where if A is true then B is true, is a lot like doing geometrical proofs. I'd say math and programming draw on overlapping skill sets, so proficiency in one helps in the other. You probably won't find too many programmers (at least in C or assembly) who hated math in school, though I'm sure there are exceptions. If you passed the classes you listed, I wouldn't think your math skills would hold you back. Is there anything in particular that you think you're not getting? I was a very good math student, but it took me a while to really get recursion or double pointers -- probably because those aren't about math, they're just concepts you have to get your mind around.
Apparently I've been doing this for too long...
Agreed while some try to memorize, others are trying to get a feel for the questions to see if they have enough skill to can handle them. It can boost their confidence and give them practice which can help them in the interview. 
For me, it is a piece of cake, too. But teaching beginners C has taught me that most of them had a lot of trouble trying to understand it. Some eventually accepted that it is magic and stopped trying to understand the idea. Never assume that what is obvious to you is also obvious to other people unless you have strong evidence that it is. Especially don't make this assumption when teaching beginners.
Getting a feel for interview questions might help you dupe an interviewer, but it won't really help you in the grand scheme of things. A better plan might be to pick up a programming project to improve your skills, so you get some experience with how all the pieces fit together. If you draw your confidence from being able to impress interviewers, there is a decent chance that you are going to have a lot of problems once you sit down at your desk and get your first tasks assigned. In an interview, you can get away just fine with handwaving and coarse explanations, but these won't help you write good code. Remember: an interview is a filter to preselect applications. It is not a ticket to a programming career. If you are good at your job, you shouldn't have a problem passing it. If you are bad at your job, you are likely not going to survive the first few months at the company.
I think Go might be fairly good as a beginner language because it has pointers, but it also has enough training wheels to make your program predictably crash if you do something wrong, reducing one of the larger sources of frustration in C programs. FP as a first language is a good idea. Our neighboring university does that so all students start at the same level, even those with prior programming experience. It also helps you think like a mathematician, which is always a good thing. 
When I was in college I figured C was the "best" language, so when Numerical Recipes in C came out I bought a copy. A few years later I find out about all the bugs in that book. I don't think you need to be a math whiz to program. You probably need to be able to think symbolically or in some abstract fashion. Many programmers entered the career [from the field of linguistics](http://www.ppig.org/news/2006-06-01/linguistics-and-programming-languages).
I usually like these threads because it helps when I have to interview an applicant. 
I mostly agreed with what you said, but duping the interviewer is no one's fault but the interviewer's. Interviews are a lot like test taking. It doesn't matter how much you mastered the course materials if you don't know good strategies for taking tests. To even have a chance at the job, you have to clear the interview hurdle first. Interviewees do need to understand that the interview is clearing the first hurdle, not the last, to a successful career.
It really depends on what you want to do. As long as you are enjoying what you are doing and getting better, you will be fine, don't get depressed over things you do not enjoy or good at.
&gt; Interviews are a lot like test taking. It doesn't matter how much you mastered the course materials if you don't know good strategies for taking tests. I have never developed strategies for taking tests. When I take a test, I start to answer questions from the beginning, skipping questions I can't do. Whether I pass or fail is very strongly correlated with how well I understood the course material. I expect interviews to work the same way; learning tricks to improve the outcome even though you haven't actually gotten better at the subject matter won't really help you in the long run.
Some of my favorite questions for C developers are: * Write an algorithm to count the number of bits in an integer This is one of my first questions. This is just to see that they know how to even write syntactically legal code at all and can convert a simple problem into code. Most all candidates that can do it will write me an O(n) algorithm. I asked them if they can improve it to O(log n). This lets me know if they know big-O notation and if they can come up with a better answer. * Write me an example of syntactically legal code, but semantically illegal code In C, semantically illegal code leads to tons of bugs, and unlike syntactically illegal code, they are not often caught by the compiler. This question lets me know if they understand the difference between the two and how semantically illegal code bites you. * Give me some examples of implementation-defined behaviors and undefined behaviors Understanding what makes C code non-portable is a huge issue. Knowing these boundary behaviors help when trying to write portable C. Just because code "works" when you write it today on one system doesn't mean it'll continue to work tomorrow after a compiler upgrade or migration to a different system. * Tell me about a nasty bug you debugged and how you debugged it This is one of my favorite questions and is often my last one from my list so it can be open-ended to fill the remaining time. If necessary to fill time, I'll ask them to tell me about another one. How the interviewee answers it tells me more about them than most any other question I'd ask. It's both a skills question and a personality question. What techniques were used and how they cracked it tells me about their skills. Does their face light up? That tells me how motivated they are when things don't go their way and are faced with adversity. I'll ask many followup questions to make sure they're not trying to BS me. When you debug a problem, that event gets burned into your memory more than any other. It's details are not something easily memorized by someone just practicing interview questions.
That string literal is getting pulled up into a string constant section of global. Disassemble your executable and you will find it. But, not good practice.
String literals like `"456"` are allocated in static storage. They are allocated at the start of the program and only released when your program terminates. Thus your code is perfectly fine.
Your program invokes undefined behavior. This does not mean that it will crash, just that you can't predict what it will do. In this case, it happens to ‚Äúwork‚Äù, in the sense that it produces the output that someone who does not know C very well would (incorrectly) expect.
You do realize that skipping questions you don‚Äôt know _is_ a test taking strategy? The same thing happens interviews with how a candidate handles questions they don‚Äôt know. Do they get hung up on them and just waste time, or explain to the interviewer that they don‚Äôt know the answer (or just do the best they can) and then steer the question towards a related topic they can answer?
In case you‚Äôre being serious, this is considered a real learning disability called [dyscalculia](https://en.m.wikipedia.org/wiki/Dyscalculia), and you can look into it if you feel that it‚Äôs having a negative impact on your life. 
Non-Mobile link: https://en.wikipedia.org/wiki/Dyscalculia *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^199939
Not at all. You just need to understand English well.
Calculus is plenty enough math most of the time for most people... For most people, who knows how much you need however.
On average, no. If you want to do something that requires complex math then maybe.
If you're planning to actually write a function like `foo` that returns a pointer to a string literal you'd be better off declaring it as taking a `const char **`. Otherwise, the caller, in this case `main`, might feel free to modify the `char *` it gets back. E.g. char* a = NULL; foo(&amp;a); a[0] = 'x'; printf("%s\n",a); return 0; The above code attempts to modify a string literal resulting in undefined behavior. If you changed `foo` to take a `const char **` you should get a warning from the compiler.
Programming usually doesn't involve anything more than basic math. The most difficult thing I wrote involving math was a function to estimate the distance between two long/lay cords and it worked by estimating the distance on an elipsoid. I didn't even write the actual formula I got it from a blog and implemented in python. 
Reading this, one can feel the underlying expertise and experience your text is radiating with. Beautiful answer. Thank you so much.
Thank you.
In college I interviewed for a sys admin job. My boss gave me a quick c quiz to see where I was at because I wasn't a comp sci major and the only question I didn't know was one I always though was kind of cool: int a = 1; int b = 2; int c = a+++b; What is the value of c? It's not really a complex question, but it was the first time I had been exposed to the idea of undefined behavior.
I know, I have looked into, and it's comorbid with ADHD, which I've been diagnosed with. AFAIK there's just not anything else to do? I quadruple check my math, but beyond that ¬Ø\\_(„ÉÑ)_/¬Ø
The `if (i)` part is if i is greater than 0, so you're truncating the first byte unconditionally, do you mean to do that? the value of `arr` is the first element of the array, you're looking at the byte before the array, and you're looping to even further in front of the array there... 1: Yes, the space in the while gets intrepreted as an integer, which is teh default code page for the compiler, which will be some form of ASCII or Unicode, which are equilivent for the first 127 codepoints so it's always 0x20 (unless you're using some weird shit like EBCDIC or something, but that's hella rare) Why? I don't really know how to answer that, it's just how it is... 2: Does compiler interpret every logical expression as an integer? I haven't read the standard in depth, but I believe the default is to interpret things as integers (int specifically) unless otherwise specified, like, by casting.
Well, if you're dealing with string in C you've probably realised that they only really are an array of number and that they are corresponding to character following the ASCII table. If you're curious you can't totally see the numerical value of the character by printing it as a number with printf. Secondly, what is a pointer ? Same here you can see the value of the pointer by printing it. In the end you're just comparing two number that do not have the same size.
I mean it's a style issue, it's subjective. That said, I don't write this way because I scan for opening and closing brackets to find the start and end of blocks (loops, functions, etc) and it's harder to see if it's on one line.
&gt; What happens if we compare a pointer and an integer? Anything. The standard says that if you use the `==` operator then &gt; One of the following shall hold: &gt; &gt; ‚Äî both operands have arithmetic type; &gt; &gt; ‚Äî both operands are pointers to qualified or unqualified versions of compatible types; &gt; &gt; ‚Äî one operand is a pointer to an object or incomplete type and the other is a pointer to a qualified or unqualified version of void; or &gt; &gt; ‚Äî one operand is a pointer and the other is a null pointer constant &gt; In your code, none of those cases are true. Hence the warning.
Thanks all. I'm not a beginner, but nowhere near an expert. But the way some code is written, like grep, is still pretty cryptic to me. I would say the preprocessor parts were kind of hard to read and just following along in general is difficult. Mostly, I just want to further my understandings on how the "greats" did it. I want to understand the reasonings behind it. This can be done with research of each part, but thought I would just ask if there was already someone that had picked it a part.
"Would you be okay with this huge amount of money?"
Read the docs for [strcpy()](https://en.cppreference.com/w/c/string/byte/strcpy) and you'll see that using it with overlapping strings like you're doing is undefined behavior. So don't do that for starters. (Also, `' '` doesn't get converted to an int. It *is* an int.)
&gt; Write an algorithm to count the number of bits in an integer What does this mean, and how would you do it worse than O(log n)?
In C what you'd do is put the `...` at the end of the parameter list in the function's declaration, then you'd init a va_list type, then in the downstream function that is called by this top level one, you'd put va_list as one of it's parameters, and pass it off that way. Here's some code so it makes more sense: void B(va_list List) { // Use va_copy, etc here on List } void A(...) { va_list List; B(List); }
Yes, it is.
Python is really just a giant wrapper around C in the first place...
Here's the [Geeks for Geeks](https://www.geeksforgeeks.org/count-set-bits-in-an-integer/) solutions for both O(n) and O(logn).
' ' is a character (char type). they are integers.
I would walk away from such an interview. It means that senior developer asking me the question doesn't know what a "bit" is. I assume he means "numbers of bits set in a integer"
You're right, but the tech industry is hell bent on making everyone pass these white board questions. The only way to get your foot in the door realistically is to pass these trivia questions now.
what does giant wrapper mean?
That's not UB. I read about this in Expert C Programming: Deep C Secrets on page 53. The Ansi C Standard uses what's called a "maximal munch" convention for matching tokens when there is more than one possibility for a match. So given the choice between (a++)+b and a+(++b) matching from left to right (a++)+b is picked. It's 6.4 in the c11 standard they don't call it maximal munch there but the index references it as maximal munch. The examples they mention there are similar to this but with more plusses. It's an interesting example for sure.
The answer is 4 right? The compiler reads from the left to the right, so it'd see "+++" as A "++" "+" B?
 No, it‚Äôs 3. The post increment is applied after the expression has been evaluated.
But have you used the math library for stuff like absolute values, square roots, log, sin? I just think I‚Äôm an inferior programmer if I don‚Äôt utilize the math library for next level programming.
"next level" is solving more complex problems or building larger systems. Sometimes that used more advanced math but not always. If you're doing video games and/or graphics you'll like use those. If you're building a service to handle requests and write to a DB, then no. 
Pointers, the answer is pointers :D
I'm on my third software job and I never had this kind of interview question before and I actually don't know anybody who ever had to pass one.
Please observe the topic. Memes are on topic as long as they are about C, but general programming memes are not.
Is there even such a thing as 'semantically illegal'? Does this question share the same answer as "write code that may be found suspect by a static code analyzer"?
Well it could also be a language-lawyer question about signed ints. Signed ints are not required to have all their bits contribute to the value of the represented number (i.e. trap representations are allowed). So, you can't just assume that the number of bits in an int is `(sizeof(int) \* CHAR\_BIT)`. Likewise INT\_MAX may not be 2^n-1
Sure. For example: a = b++ + b++; The code is syntactically valid, but is semantically illegal because it is modifying the same object twice between two sequence points. Code like that will often have one behavior unoptimized and a different one optimized. Yes, a _good_ static code analyzer will often find a lot of these problems, but not always. It's a good idea to just not write semantically illegal code in the first place because you know the rules rather than relying on tools to hopefully find your misunderstandings and mistakes..
Interesting; the term 'semantically invalid' is new to me. Is the set of _semantically invalid_ code the superset of _undefined behaviour_ and _implementation specified behaviour_ code? Would something like a double-free or the access of a wild pointer be considered semantically invalid?
Why is this (the if-else ladder) better than a switch statement here?
"There is this issue in our bug tracker." .oO( That I selected because it should be easy to fix and does not require too much knowledge of our software) "Let's do pair programming for a few minutes and try to fix it." That way I can see if the candidate has the technical skills, the *Get It Done* mind set, and the communication skills when she interacts with a colleague (me).
I don't know the real answer, hopefully someone else will chime in with that. But I've always assumed it was so the variadic argument system (?) could get the address of the first argument, and with that, I assume that it's null terminated too.
in order to know where the args are you need an 'anchor', that 'anchor' is the first arg
I may have my history wrong (please correct me), but to the best of my understanding: Once upon a time, there was no standard way to do variadic arguments. People developed their own macros that (grossly) worked around the problem by calculating offsets. Note that in order to develop these macros, people would have had to predict precisely how the compiler was going to lay out all arguments, which is why I say "gross". In order to calculate where the variadic arguments were going to be laid out in memory, they used a starting point, which was the last named parameter. For example, imagine: int foo(int x, int y); And now imagine calling that function with too many arguments: foo(3, 4, 5, 6, 7, 8) These days we'd cry "undefined behaviour", but undefined behaviour had not been defined (ha) in those days. So, anyway, how do you get access to the last three parameters inside the function? Well, suppose you know that `x` is located at sp+4 and that `y` is located at sp+6. And suppose you have intimate knowledge for how the stack frame is laid out by your compiler, and so you calculate that the last three numbers are at sp+8, sp+10 and sp+12. The only problem is you don't have direct access to the sp register from within C, so how do you figure out where your stack frame starts? Well, if you know the address of `y`, then it's easy to calculate where the next three parameters are located even without knowing the stack pointer: they're at `&amp;y+2`, `&amp;y+4` and `&amp;y+6` So people made macros that required you know the address of the last named parameter. Variadic arguments were eventually standardized, in ANSI C. The philosophy in standardizing C at that time was to avoid introducing *new* stuff to the language, if possible, in favour of codifying what people were already doing out in the wild. Since people were already using macros that required a named parameter, the standard reflected that. These days, there's no technical reason for why `va_list` should *need* a named parameter to get started, but it's always been done that way, and it can't be changed now. Breaking backwards compatibility in C is not an option.
A function with just a variable argument list is useless because it would have no way of knowing how many arguments it was passed. int var(...) { /* what can I do here? */ } int main() { var(); var(1); var("bernard","cribbins"); }
How would you know how many arguments were passed, if any? You have to pass that information.
Mostly because how assembly works. The first argument of a function (if any) is putted in a specific register of the cpu for easy access, but this can't be done if the type or if there's gona be an argument there is not previously known. Assembly is the language that the machine can understand and is translated to when compiling code. A register is like a variable, but in the cpu (normally variables are in ram). The cpu needs to have all the data that is processing in a register. Hope this is clear c:
Okay I think we're referring to the same thing with different names. What you call semantically illegal I would call unspecified behavior.
&gt;What is your git(hub/lab/etc) account? Think about it. Do you want to hire the one who is better than you in areas you don't know well?; or better than you in areas you know well?. (or do you want to hire the one you can control?) When you are making questions, you get to say what is important and what is not. If your ego is fragile, then your creed is going to get in your way. You are going to sound more like an obtuse snob rather than someone others could respect and work with. If you really need test someones C skills, then have them write a simple statemachine, parser, or something else in a way that forces them to do something that involves function pointers, pointers, bitwise operations and other stuff in a one go. At least in this way, it is also fun for the one taking the interview as they don't have to have experienced the same gotcha's as you have for them to feel respected by you; nor do they have to parse your snob CS vocabulary you abuse whenever you got the chance. You C? C programming is about having an attitude while being wholesome working with people of various disciplines. There is no room for the snob shit. Thanks. \-Keep it simple. (I'm on my second and a half beer. So if the above gremmer doesn't make sense, then just send a reddit pull request.)
&gt;What is your git(hub/lab/etc) account? Think about it. Do you want to hire the one who is better than you in areas you don't know well?; or better than you in areas you know well?. (or do you want to hire the one you can control?) When you are making questions, you get to say what is important and what is not. If your ego is fragile, then your creed is going to get in your way. You are going to sound more like an obtuse snob rather than someone others could respect and work with. If you really need test someones C skills, then have them write a simple statemachine, parser, or something else in a way that forces them to do something that involves function pointers, pointers, bitwise operations and other stuff in a one go. At least in this way, it is also fun for the one taking the interview as they don't have to have experienced the same gotcha's as you have for them to feel respected by you; nor do they have to parse your snob CS vocabulary you abuse whenever you got the chance. You C? C programming is about having an attitude while being wholesome working with people of various disciplines. There is no room for the snob shit. Thanks. \-Keep it simple. (I'm on my second and a half beer. So if the above gremmer doesn't make sense, then just send a pull request.)
Some of the most extensively used software is written in C: * os kernels (Linux, Windows, Mac) * web servers (apache, nginx, lighttpd) * programming languages (python, perl, ruby, php) * version control systems (git, subversion, cvs) * databases (Sqlite, PostgreSQL, redis)
I usually just start with some questions about the resume to gauge how much they understand about their previous projects. If they fumble through it, I'll ask some questions about some problems they seemed likely to have encountered. But one of the main things I look for are eagerness to learn. I also look for passion about the previous work. If you have those things, we can probably bring you up to speed. 
If you can count to 1 you'll be okay. As long as you started at 0.
It's exactly to get the address of the first argument. That's why you have to pass the last non-variadic argument to the `va_start` macro.
I'm not convinced that this solution is O(logn). It's just using tail recursion, right? It's runtime is identical to the iterative version
Interviews get or lose you jobs. 
I'm happy that I can answer this question (since I'm an amateur self-taught programmer). But honestly, I don't think this question is hard. It is like asking 2 + 3 \* 4 = ? If you know the rule, you will know the answer.
I think most people read these question to see if they are lack of knowledge in which area; not to remember the answer. 
&gt; Tell me about a nasty bug you debugged and how you debugged it This is my absolute favourite and let's me throw out my war stories. Best one is how I designed a PCB a while ago with an MCU and a SWD interface to flash it. I checked and rechecked the PCB, but there was a very tight deadline and I had to send it out ASAP so we would get the PCB fabbed and back in time. So I rushed through it after two reviews with others and moved some things around on the PCB. In comes the PCB, powers on and no magic smoke, great. Even the LED's for power turn on! Time to flash the MCU with a blinky. I write a blinky, get the scope probes (just a while loop with a bunch of NOP's), and get the programming dongle. Get some jumper cables, plug in the debugger, and, hm, it's not detecting it correctly. I am getting back some unkown ARM Core. That's weird, maybe I got the pins wrong. So I double check the PCB, the jumpers, and the dongle pinout. Nope, it's right. Ok, maybe one of the cables are bad, jumper cables have bitten me in the past. So I swap out all of them. Nope, same issue. Let me try flashing another PCB, maybe it was a soldering issue during assembly. Nope, same thing. Let's try another module that defenitly works to ensure the debugger still works. Works fine, hm, so it's something with the design. But there's so little to go wrong. :ets get the scope on the SWD_DIO and SWD_CLK lines and see if we are getting anything. Yep, we are getting activity. By eye it looks like the CLK and data lines are moving alright, with the clock and data not being flipped. By eye it looks like the data is correct, but I can only see the beginning because the scope has so little memory depth and the time wise offset is so small. Time to bring out the big guns, a logic sniffer. I load up Sigrok and look at the SWD connection. Hm, nothing is being sent back from the MCU. That's weird. Maybe the connection is bad and integrity check of the packet is failing? Doing a check by hand (can't seem to verify integrity via the decoder at the time) says it's fine. Ok, maybe something on the PCB is bad. The lines aren't long, but they also aren't sub wuater inch, and default SWD speed for the debugger is a few Mhz. So let's bring it down to a few khz, and same issue. After a few hours of pouring over the data sheet for the MCU looking if I messed up the boot pins, reading up on the SWD protocol, and other shenanigans, I figured it out when looking at the gerber and datasheet. Turns out when moving things around on the PCB I flipped the SWD header and Kicad didn't rotate all the silk correctly. So everything flipped except the words CLK and Data, meaning I had CLK and Data swapped on the silk screen. Swapped it back and viola, worked fine. Dumb mistake, wasted a few hours, but it was a great educational experience because I became intimately familiar with the SWD protocol and knew the ins and outs of the boot procedure on the MCU. I also say up front that I tend to make dumb mistakes, but the side knowledge I gain when figuring it out tends to make up a ton for lost time.
I agree somewhat. It's important in that maximal munch is supposed to be part of how the compiler decides what to parse into which tokens. I could see it being a good way to test the candidate on how they handle ambiguities and known unknowns? Idk though I'm no pro.
Is that not still (a)1+(b)2 =(c)3 and then c++ to equal 4? 
It wouldn't break backwards compatibility to add this feature. It could be added that `void f(...);` is a prototype, and a new macro e.g. `_Va_start_void(ap)` that initializes a `va_list` for such a function.
There could be a sentinel value for the end of the list, like `exec` family. 
What would it be though? void printIntegers(...) { } int main() { printIntegers(-1,0,1,42,INT_MAX); } There's no integer that can be reserved as a sentinel.
Pick your favourite integer to be a sentinel. If you don't want any sentinel then don't use this technique .
duh .. may have solved my problem ... warning: integer overflow in expression of type 'int' results in '-2147483648' well there is the problem
Your call to malloc requests a pointer to a block of memory size 2147484000 bytes. Not 100% sure but I think malloc'd blocks require a header to store metadata on the heap, which includes the size of the chunk, such that it can allocate the next chunk 2147484000 bytes along (+ header size). This header, might look like this struct header { int blockSize // size of chunk in bytes int status // ALLOC or FREE } since the maximum number an int32 can store is also 2147484000, it can't physically remember that your malloc'd chunk is 2GB. It won't let you allocate the block because it wont be able to store its metadata when dynamically allocating memory. Also, malloc stores this unfo in RAM so even if your HD has 256GB of space, you could only ever malloc &lt; 4GB or whatever your ram size is. Hope this helps :)
Actually that's a good point! Pitch it for inclusion in C2x!
Actually it was something trivial .. didn't see it until after I post of course ( always the way ) but I need to use a size_t type for malloc and that is 64-bit proper and not an issue thus : #include &lt;malloc.h&gt; #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(int argc, char *argv[]) { uint8_t *buff; size_t one_meg = 1048576; size_t mem_size = ((size_t)8192)*((size_t)1048576); fprintf(stdout,"sizeof(size_t) = %i\n", sizeof(size_t)); fprintf(stdout,"will now malloc %llu bytes\n", mem_size); if (mallopt(M_CHECK_ACTION, 3) != 1) { fprintf(stderr, "mallopt() failed"); exit(EXIT_FAILURE); } buff = malloc(mem_size); if (buff == NULL) { fprintf(stderr, "malloc() failed"); exit(EXIT_FAILURE); } /* flip bits of all memory in the buffer */ fprintf(stdout,"set all bytes to 00000000b ...\n"); memset( buff, 0x00, mem_size ); fprintf(stdout,"done\nset all bytes to 10101010b ...\n"); memset( buff, 0xaa, mem_size ); fprintf(stdout,"done\nset all bytes to 01010101b ...\n"); memset( buff, 0x55, mem_size ); fprintf(stdout,"done\nset all bytes to 11111111b ...\n"); memset( buff, 0xff, mem_size ); fprintf(stdout,"done\n"); free(buff); fprintf(stdout,"free()\n"); exit(EXIT_SUCCESS); } runs just fine : $ ./malloc sizeof(size_t) = 8 will now malloc 8589934592 bytes set all bytes to 00000000b ... done set all bytes to 10101010b ... done set all bytes to 01010101b ... done set all bytes to 11111111b ... done free() yep .. twas just a datatype issue .. as usual. 
Oh great, glad its fixed :)
yet another thing I stared at for .. oh .. an hour or so plus a coffee plus some harsh words and then .. yeah .. okay .. fixed.
Probably isn't, but I got stuck on a switch statement bug recently... There were other bugs besides that but the switch statement had me stumped a long time. No idea why. The code above was easy to cut &amp; paste a bunch of lines.
You might not be able to fix this in C directly, but you can cover it up with macros! Declare the real implementation function with one named arg and a `_` after its name, and have the macro-use of it pass in a dummy value. Problem solved. ;)
No, there is no `c++`.
Would you mind providing some background on what your company does, and what an ideal candidate for you would be like?
Are you on a 32 bit system? that's why. If not, use the Large File Extensions, by defining the following macros: `#define _FILE_OFFSET_BITS 64` BEFORE you include stdio.
Fixed it, waypoints array wasn't big enough and was getting written over in the for &lt; 4 loop. Is this an example of two seeming equal and equally undefined behaviors implemented differently?
Also, do you really need one big chunk of memory that big, maybe its a situation you can use mmap, or break the problem, and memory requirement down a bit ? Its a big system requirement if you want other people to use it.
Reminded me of ‚Äòapproaching‚Äô operator: ``` int i = 10; while (i ‚Äî&gt; 0) printf(‚Äú%d\n‚Äù, i); ``` 
It could be stored in a global variable.
The compiler could to well without it.
&gt; Are you on a 32 bit system? no
&gt; do you really need one big chunk of memory that big? yes
a++
you're missing a "-" dash
I was just going to say, if that struct is on the stack and you write outside of bounds then you'll clobber your stack variables if not crash the program if you write past the end of the stack. &gt;Is this an example of two seeming equal and equally undefined behaviors implemented differently (gcc7.3.0)? No, this is just what happens if you clobber the stack by not checking bounds. All compilers will act more or less the same in this respect
How come the #else doesn't clobber?
And how would I programmatically detect the presence of "trap representations"? 
Interesting. Was that introduced in C11? If so, then that standard would not have been out when I interviewed, but C99 would have.
I guess it depends on your seniority and the company. As a new grad, almost any application that got even remotely noticed I had to do a hackerrank or coderpad with an engineer.
But the original implementation of varargs had no compiler support, it just took the address of the fist element and applied manual offsets to find the others. That practice was then standardized, and requires a first argument to find the address of the parameters stack.
I have graduated from university less than half a year ago. Even before I graduated, no company ever demanded a stereotypical whiteboard coding interview.
https://stackoverflow.com/a/51080
&gt;This algorithm goes through as many iterations as there are set bits. So if we have a 32-bit word with only the high bit set, then it will only go once through the loop. In the worst case, it will pass once per bit. An integer n has log(n) bits, hence the worst case is O(log(n)).&gt;I'm not convinced that this solution is O(logn). It's just using tail recursion, right? It's runtime is identical to the iterative version [Stackoverflow](https://stackoverflow.com/questions/12380478/bits-counting-algorithm-brian-kernighan-in-an-integer-time-complexity) 
c++ btw
That's interesting! Are you based in the US? I've sent over 200 applications since last fall, so the distribution is pretty spread for me (lots of spray and pray here though), and have done interviews for Big N as well as tiny startups. Granted, I guess it depends on the type of job youre going for, though I've had whiteboard interviews for roles ranging from firmware, to SDR, to web dev (ugh).
It would really help if you used proper reddit code formatting but I will attempt to help. It is clearly going through every character in the string up until the array size (100) or until '\\0' (= 0, The null terminator). I = current index in the string.
I'm based in Berlin, Germany. I got all my jobs so far through my personal network. But even without the personal network, coding interviews aren't really a thing in this country.
That is surprising to hear as it's a really popular form of interviewing in the US, with Cracking the Code Interview being sort of a cult following. It sucks as it's taken on the mentality of standardized test prep, and says little about the actual abilities of an engineer. Out of curiosity, how do interviews go there, from screening to final offer?
&gt; Out of curiosity, how do interviews go there, from screening to final offer? Generally speaking, the company tries to ensure your prior experience by looking at the degrees you have and the projects you worked on before. In Germany, every employer gives you a performance report when you leave the company. Companies check the performance reports from previous companies you worked at to judge how good you are. The interviewer might ask you about your previous work and might ask some high-level technical questions to judge your general aptitude, but that's far from being the focus. Interviews are almost always face-to-face, there rarely is any kind of pre-screening or pre-interview (I've never heard of such). Usually, a member of the worker's council attends the interview to make sure you are being treated fairly. In many entry-level positions there isn't really a salary negotiation as we have collective bargaining agreements almost everywhere. I'm probably a bad person to ask about this kind of stuff as all interviews I took and all the CVs I sent were just a formality. The decision to give me the job was made in advance because I used my network to find someone who was willing to hire me and convinced of my competence.
Not entirely sure how this is relevant to the sub...
This subreddit is for programming in C only. Since your post is neither about programming nor about C, I have removed it.
Thanks for the insight. It's pretty interesting to hear how other countries perform their hiring process. There are similarities and I have to say that it's not as strictly coding related as it may seem, but for almost any large company it's expected to have some whiteboarding interview as it's an easy and cost efficient way to screen people who can't code out of a paper bag. With Big N companies, there are multiple rounds of these type of white boarding questions ending with an invitation to meet onsite to meet future potential coworkers, as well as more whiteboarding. Some of these questions go more into practical problems such as system design.
According to amazon that book came out in 94 so pre c99 I think. It seems totally arbitrary but apparently it's some principle for matching certain language constructs with regexes in compilers https://en.m.wikipedia.org/wiki/Maximal_munch which explains why it would end up in C I suppose.
Non-Mobile link: https://en.wikipedia.org/wiki/Maximal_munch *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^200199
**Maximal munch** In computer programming and computer science, "maximal munch" or "longest match" is the principle that when creating some construct, as much of the available input as possible should be consumed. The earliest known use of this term is by R.G.G. Cattell in his PhD thesis on automatic derivation of code generators for compilers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I think a major difference is that if you have a German degree, companies can generally assume that you are a capable programmer (but perhaps not an experienced one). German companies generally trust the degrees you have and don't see the point in verifying your skill set. If you are incompetent, you won't survive the first few months anyway, so not too much harm is done if someone slips through the cracks.
This isn't stack overflow
You are missing a brace in your reverse function and it isn't returning anything. Why write *(p+l+1-1) when you can simply write *(p+l)? Think about how you might reverse a row of blocks, the algorithm you use to reverse a string of bytes is much the same. Swap the position of the first and last, then the second and second-last etc. You only need a for loop iterating over half the string length truncated (middle char unmoved). I don't know why you have a local copy of the string in c[40]. I hope that was just for debugging and you weren't planning on returning that. 
this isn't unspecified behavior, this is undefined behavior, and the two are very different.
this is undefined behavior and the compiler can do whatever it wants. what it will normally do is the path of least resistance. it will take the value of your pointer, which in pretty much all implementations will be a large number (a memory address), and compare it against the int value of ' ', which is 32, and just run that comparison. if you have optimizations on, it might realize that this is an 'illegal' operation and just omit it all. bottom line, compiler is free to do whatever it wants to do.
There's 3 algorithms listed on that page. They correctly claim that the iterative version takes O(n) (where n is the number of bits). They then claim (incorrectly) that a recursive strategy is faster and changes the runtime to O(lgn). Finally, they list Kernigan's algorithm, which runs in Theta(k) where k is the number of set bits (which is equal to O(n)).
Why do you write `*(p + i)` instead of the much clearer `p[i]`?
Style tip: Don't use 'l' and 'i' as variable names. That's confusing and makes your code very hard to read. 'i' and 'j' are fine, or 'x' and 'y', or 'ii' and 'jj'. Also, add some comments! Start by writing a few sentences in English of how the function is supposed to work, then implement the code. 
And why?
Because I want to understand the concept of pointers, I know that it is same as writing \`p\[i\]\` but, I wanted to see if it really works and how it works. 
That's what am doing. Swaping the position of the first and last, then the second and second-last and so on, by the the for loop ` for(i=0;i&lt;l/2;i++) ` am dividing it and then comparing first block with last and second one with the second last by ` *(p + l + 1 - i) `. And yeah the local copy of the string in c[40] was part of debugging.
Thanks, that was most interesting and well laid out!
The l variable denotes the length of string. The loop ` for(l=0;l!='\0';l++) ` calculates the length of string that is why I named it l.
Then call it 'length'. It doesn't cost you anything to name your variables descriptively.
I think I'm always in a hurry, but yeah I am working to improve to write readable code. I just want to learn pointers in depth.
_always_ document the code you're writing, and use descriptive variable names. It is a good habit to start with, especially while you're learning.
Arrays and pointers are interchangeable in this case, and you should use whichever makes your code more readable. p[i] is much more concise.
Why use ptr when you can just use string.
Please do not post photos of code. Instead, post your code as text so other users can compile and edit it. I have removed your code so you an try again with code as text.
Ah okay, I'm new to this subreddit, sorry
Really though, you should never ever take a photo of your screen and post that on a website. If you absolutely have to take a picture, at least make a screenshot so it's legible. But if you can, always post text, not pictures.
Some context on [memcpy() with OOB or null pointers](https://stackoverflow.com/q/29844298/417501).
Er.. yeah, sorry about that. I was using the app on my phone, that did look atrocious, lol
I never thought about that situation before. It's actually kind of irritating since this otherwise logical code could technically misbehave due to `memcpy()` quirkiness: void copy_unused(char *dst, const char *buf, size_t len, size_t fill) { memcpy(dst, buf + fill, len - fill); } This seems like it should reasonably work correctly when `fill == len`, but it wouldn't due to the wording of the rules. 
Oh hello, I'm sorry to disappoint you. Now that I can actually read your code, I see that it is actually C++ code. This subreddit is about programming in C only, C++ is off topic. Please post C++ questions to /r/cpp_questions instead. I'm terribly sorry for removing your post once again, but reposting it to /r/cpp_questions is easy: Just click edit and copy the entire post, no need to re-type all the text.
No problem! Though I'm sorry for not having caught your question being about C++ sooner.
No problem, thanks for all the help :)
Depends on the CPU. System V for x86-32 does *all* function arguments on the stack.
Does this even compile? I don't see where the L in i &lt; l/2 is defined.... Or is it 1/2 as in 0.5? (Yes it's obvious, but hard to visually tell the difference) I also can't see why it would work. Can you give an example input and output because it just looks like you're making random swaps repeatedly. E.g the character it the first position gets swapped multiple times. The way I would write a reverse function is to 1st calculate the length. Then, interating from the beginning through to the middle of the string, swap with the corresponding character in the 2nd half. Also I don't see why you return anything. The whole point (no pun intended) of pointers is that you are providing raw access to that location of memory. The location of memory should be the same at the beginning of memory as the end, and therefore there should be no need to 'update' the pointer.
The correct answer is "don't do that" followed by this quote from the great Donald Knuth : Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do. Rough translation .. delete that mess and rewrite it such that the intent is clear to a human. 
Best question that I had in an interview with a fortune 100 software company : so who do you think will win the Stanley Cup next year?
So are you saying that a+++b is really just a+b? 
That's very old behavior, it's defined since at least C89 (section 6.1 paragraph 4): &gt; If the input stream has been parsed into preprocessing tokens up to a given character, the next preprocessing token is the longest sequence of characters that could constitute a preprocessing token. (Preprocessing tokens are converted to tokens after all preprocessing is done, so the above applies to normal language tokens.) The exact same text appears in both C99 and C11 (but in section 6.4 paragraph 4).
Seems to be promoting tis-interpreter. Sounds like it's better than Valgrind and UBSan. Does anyone have experience with it? How much to use it commercially?
This is the solution that worked for me (I pass a tuple from my .py to this wrapper which is parsed out): static PyObject* CreateWithFormatWithVAListNative(PyObject* self, PyObject* args) { const char* format = NULL; va_list arguments; PyArg_ParseTuple(args, "s(items)", &amp;format, &amp;arguments); StringRef ret = CreateWithFormatWithVAList(format, arguments); return PyLong_FromUnsignedLong((unsigned long)ret); }
The standard string libs also return a pointer when they manipulate strings. It allows you to do things like dosomething(reverse (string));
Oh yeah good point lol!
Yes, except for the side-effect that `a` will have been post-incremented after the expression has been evaluated.
Ah, you're right! According to the standard, "f a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, and they are not potentially concurrent (1.10), the behavior is undefined".
Thanks, fixed it.
That‚Äôs really strange. I didn‚Äôt know anything like that existed. Thank you for helping me out there.
If you really want to write a reverse function using pointers, then use two pointers: one initialized at the start, one at the end. Walk them towards each other until they collide. Swap each character along the way. Much more clear than these two for loops combined with pointer notation.
I don't know, you should step through with a debugger if you want the answer to that question.
Oh this is what u meant. From how the problem was stated I thought you wanted to know the size of the integer data type in c or to literally enumerate through an integer in binary form to count how many 1s there are but this is quite straightforward.
Oh look at you down there.
I always go with the second ‚ë† and if the dangling return annoys me I add a single line comment to stretch it out.
You are calling `vsnprintf` twice over the same `va_list`. This is undefined behaviour, since the first call to `vsnprintf` will have consumed all the variadic arguments.
Of course, thank you good sir!
I get a feeling this was first implemented in Windows called CRITICAL_SECTION. I had used it in 2002/03 when developing a function call tracing and profiling for win32 applications.
RE: the pointers They are annoying. From your code: char string[40], *ptr; /* some code */ ptr = &amp;string[0]; You can just write *ptr=string*. *string* is a constant pointer to the beginning of the array. Also I don't see a need for the string header as I can't see any functions from it are called, and you haven't referred to the NULL macro. In the reverse function you have referred to "l" in the second for loop, that variable has not previously been declared or defined. This should mean it doesn't compile. Check everything is declared and defined within the correct scope. I've been a complete asshole since I haven't written C in over a year and I needed the practise. [Here](http://codepad.org/F3PWj46z) is a solution. It uses the method u/docholiday mentioned above, but all stuff occurs in main(). I haven't defined any new functions like you have been doing. 
Simple text editor: https://viewsourcecode.org/snaptoken/kilo/ This page also links to similar tutorials, iirc. Simple language interpreter: http://www.buildyourownlisp.com Rewriting some bsd shell commands: https://m.youtube.com/channel/UCcFVlUyZm22BB6-pPqxZSMg This also leads to a website selling similar webcasts. You need to register to even see the price - which is WAY too high in my opinion...
Or just call va_start again .
&lt;3
&gt; Or just call va_start again . That wouldn't be possible inside `msg_genstring` since it's not the variadic function.
&gt; I think and believe that I am stuck at the beginner level unless I don't have mad Math skills. Is this true? Yes, being a good programmer requires good math skills; but, probably not in the way you think. Math is more than just arithmetic and manual computation. You are probably better at math then you realize. I see you mention working with math.h as a potential progress marker. Did you notice that you had to pass -lm to your compiler when including math.h in your program? That is telling the compiler to link the math library to your program. You have to tell it to do this because the math library isn't linked with the rest of the standard library object files which get automatically linked in by default. Seems a little odd doesn't it? Well, this was done because back when machines didn't have copious resources every byte counted, this was the environment C was created in. The original authors of C decided to leave the math library separate since it was used so infrequently it would needlessly waste memory. So what kind of math do you need to be good at? Certainly not calculus or statistics unless you do a lot of scientific work. Boolean algebra and set theory come up all the time no matter how simple a program you write - all those expression you put in your if statements and while loops - math. When you think "advanced programming" what comes to mind? Professionally, the process of figuring out what a client needs, converting it into an abstract problem and manipulating that abstract problem to get an abstract result that must be interpreted in the context it is being used sounds an awful lot like solving a word problem for your math class. While the abstract problem manipulation (code vs arithmetic) is a little different, the overall process is very similar. Academically, (and even professionally if you want to be more than a code monkey), a solid foundation in computer science is required. Computer science is a branch of applied math. But it can be totally different than the "regular math" most people think of. While your calculus and statistics classes where probably proofs based and very focused on the theory rather than the applications, a good undergraduate computer science program will be primarily focused on applications, the courses should be a lot more hands on. As you start to get into the more advanced computer science topics you do have to dig into proofs and theories but the basic foundational stuff is all you really need for day to day programming. 
Nice approach! What I usually do is something similar, but using some extra macro trickery to create a 'with'-statement akin to what Python has: https://repl.it/repls/RoughCircularPerimeter This allows you to be more free with your scopes. I'm sure this idea can be extended upon to introduce a keyword that auto-unwinds all nested blocks (so you can do an 'early return' which is currently not possible).
that's really smart, I will use that too!
Yes. I should have said, "count the number of bits _set_".
I like the basic idea but would prefer a lifetime object that cannot fail to construct. It would save you a failure mode. Can you use a fixed size array on the stack as the destructor stack? 
That's actually a pretty interesting idea! I'll think about it, thanks!
Very smart! 
That looks interesting! Thanks! I'll take a look into this.
What are you thoughts on using defer in C? I think it basically addresses everything you need in a quite clean way. I use: `/*` [`https://twitter.com/spudowiar/status/993069519336824833`](https://twitter.com/spudowiar/status/993069519336824833) `*/` `#define defer _defer0(__COUNTER__)` `#define _defer0(X) _defer1(X)` `#define _defer1(X) _defer2(s##X,f##X)` `#define _defer2(S,F) auto void F(void* _defer3); __attribute__ ((__cleanup__(F))) int S; void F(void* _defer3 __attribute__((unused)))` And use it like: `FILE* f = fopen(....)` `defer { fclose(f); }` `int * a = malloc(....);` `defer { free(a); }`
Ingenious mechanism indeed! Very interesting! I might try this very soon ;D I usually introduce reference count mechanism (or frankly speaking, the entire object system) to my code. I‚Äôm curious, (disclaimer: haven‚Äôt thought about it deeper and might sound stupid) what if the each LT frame also holds refcount along the dtor and the resource? Because, there might be a scenario where a thing I have added to LT stack gets borrowed by another function and does not return until this very owner function ends; then effectively the ownership moves to that borrower so original owner function should not destroy it. Maybe this is why RELEASE_LT exists?
I think it's great! Unfortunately, uses a GCC extension which hurts cross-compilerability. But if you can afford to stick to GCC-only I think that's a good solution. :)
I highly recomend this book if you are interested in assembly basics: https://www.amazon.com/Assembly-Language-Step-Step-Programming/dp/0470497025
Nice. Im gonna sub to this guy. I dont do C dev but these low level approaches are always nice to learn about.
The macro is not very readable, of course. If you want some more information on how this works, I wrote an in-depth explanation and a commented version of a similar macro that lets you write `try { ... } catch(error) { ...} finally { ... }` in C99: https://github.com/Qqwy/c_exceptional 
Some release functions in C (i.e. `free()`, `fclose()`) do no harm if passed a `NULL` pointer so the basic `goto` technique can be used in a pretty simple-minded way and still work in alot of cases. But *everyone* has thought of writing a framework like this, but @tsoding actually did it. Give him credit for that.
See [`execl(3)`](https://www.freebsd.org/cgi/man.cgi?query=execl&amp;sektion=3).
What's he using as editor? It looks like emacs but it seems embedded in a Chromium tab or something like that. Does anyone knows? Now, when you get to the point where you implement a whole stack frame unwinding framework, with heap allocations to match the stack, perhaps you should consider using C++, even if only constructors, destructors and exceptions (which also seems to be somewhat implemented in the game code).
 sockfd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin6_flowinfo = 0; serv_addr.sin6_family = AF_INET6; inet_pton(AF_INET6, "::1", &amp;serv_addr.sin6_addr); serv_addr.sin6_port = htons(9002); This might be something of a pet peeve of mine (because it's a leading cause of C programs that don't work with v6), but try not to write code that looks like that. You shouldn't be hardcoding AF_INET or AF_INET6 anywhere; in general you don't know in advance whether a given string is going to represent a v4 address, a v6 address, some other new address type, or a hostname that might be any (or all) of the previous. In fact `getaddrbyhost6()` is all kinds of crazy -- you do a v4-only DNS lookup, convert the result to text, pick it apart with string parsing, convert the parts to integers, do some mod math on them, then printf() them into a v4-mapped v6 address which you then use with a v6 socket. `getaddrinfo()` is your friend! It'll take a string and give you back all the stuff you need to create a socket of the right family and get it connected, without ever needing to know any details at all about the address that's in the string. void *start = strstr(rbuff, "Host: ") + 6; void *end = strstr(start, "\r"); int len = (int)(end - start); strncpy(host, start, len); My C is terrible, but doesn't this put your bounds checking fully under attacker control? This seems like a good way to get a security vulnerability. strcpy(prt, start); As does not doing any.
Holy shit thank you for telling me about this!
Yeah, I would have done it by simply modding the value continually by 2 (incrementing every time a non zero remainder is found), store the truncated half value of it and repeating until the value is 0. In retrospect this is a pretty stupid way to do it. I‚Äôve always avoided using binary operations when possible (excluding left or right shift) but with how easy to understand your given solution is I would be remiss to not try and learn how to use them. Thank u
&gt; What's he using as editor? It looks like emacs but it seems embedded in a Chromium tab or something like that. The editor is emacs, and I believe it's running inside an [i3](https://i3wm.org/) tab.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://i3wm.org/) - Previous text "i3" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I once implemented a very similar method to this for user input ctrl-z/y undo/redo functionality. You can see how the method could be extended to add a "lt_undestroy()" which would put the last item dropped back on the stack. Not that you would want to, as it would require lt_push() becoming a bit unwieldy (as you would need to pass it the data required for lt_undestroy() to re-create the resource), but it's a method I've found useful in the past. That being said, why not stick with the goto, but drop the labels by just checking if the memory is safe to deallocate? Here's sort of the format I use: int code = EXIT_SUCCESS; FILE *f = NULL; int *xs = NULL; /* code which allocates, and might fail somewheres with "goto exit;" */ exit: if (xs) { free(xs); xs = NULL; } if (f) { fclose(f); f = NULL; } return code; } I prefer that approach due to the reduced overhead and the closer resemblance of the code to standard C, which is always preferable for when someone needs to work with your code who doesn't know your custom methods.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define error_if(condition, message) if(condition) { perror(message); goto done; } int f(const char* filename) { int return_code = EXIT_FAILURE; FILE* f = NULL; int* xs = NULL; f = fopen(filename, "r"); error_if(NULL == f, "Could not open input file"); size_t n; error_if(EOF == fscanf(f, "%zu ", &amp;n), "Could not read array size from input file"); xs = calloc(sizeof(int), n); error_if(NULL == xs, "Could not allocate int array"); for(int i = 0; i &lt; n; i++) { error_if(EOF == fscanf(f, " %d ", &amp;xs[i]), "Could not read from input file"); } for(int i = n - 1; i &gt;= 0; i--) { printf("%d ", xs[i]); } printf("\n"); return_code = EXIT_SUCCESS; done: free(xs); if(NULL != f) fclose(f); return return_code; } int main(int argc, char* argv[]) { f(argv[1]); return 0; } I prefer to handle this similarly to the goto example, but with some differences. * Start with EXIT\_FAILURE. You should prefer to fail safe, and only when you are sure that you have succeeded set the exit code to success. * Use only one goto label. Managing all those goto labels sucks, so don't do it. I use a consistent label called done. * This has the bonus side effect of requiring your to declare all your resources at the top of the function since you can't jump past variable declarations and still use that variable. You can also tell at a glance what resources there are. * It also means all resources have the opportunity to be (and should be) initialized with an invalid resource handle. There cannot be a code path where the function gets to done and the resource variable is uninitialized. * I like to use a simple macro that handles repetitive if statements and error reporting. I understand some people don't like those, but I do. * Since there is a single goto target, you can't skip over unnecessary resource frees. * However, many functions that free resources are NULL-tolerant, like free. If there isn't, you just need a simple if statement to check if it's NULL or otherwise an empty resource, like with fclose in this example. * There is the added overhead of a function call to free a NULL resource, but that's usually only when something went wrong, the most common case should be successful allocation of all resources. * It is macro-light or macro free if you choose not to use error\_if. Macros are the devil, they should be used sparingly. You state that there are two problems you want to solve: * The growing length of the resource freeing code being duplicated. * The complexity of the goto targets. But my code has none of those problems. And has no dependencies. And I can see how it works at a glance. And it solves all the same problems. You already had a solution to your problem, you just needed to tweak it a bit. It seems like an overly-complicated solution to a simple problem. That said, the lt solution will work across functions where this certainly will not. It's not without problems though. * You don't need your wrapper macros. You don't need to cast to void\*, and casting to lt\_destroy\_t disregards type information with a warning instead of an error. C's type system is weak enough, it doesn't need to be weakened further. * I would also argue that RETURN\_LT and RETURN\_LT0 are unnecessary. Just destroy\_lt and return instead. * The implementation is spread out over 6 files for no reason I can see when 2 would suffice. * The naming of functions is inconsistent. * It includes irrelevant functions to quit SDL and close files. * There is no way to tell if a resource has been freed or not. Instead of returning a void\*\* when you insert a resource which can be passed to other functions, you blindly throw resources into the system and hope nothing tries to use a resource after it's been freed. Take this simple scenario. If Alice was given a void\*\* to the resource, Bob could know it's been freed. * Alice allocates resource R. * Alice gives Bob R to use. * Bob does not know Alice's job, and that she will soon go home and free R. * Bob has no way of checking R is still valid, so Bob continues to use R. * Segmentation fault. * It's very malloc-heavy. Why is lt\_slot\_t a double pointer? It only needs to be a single pointer and set it to {NULL,NULL} when you've released that slot. Since this structure is so small, I might even pre-allocate the whole thing and make frames a flexible array member so the entire thing is a single allocation, overallocating would be a waste of mere kilobytes of memory. It just seems like an over-complicated data structure is being used for no reason here. * This won't work well for long-running programs. There's no easy way to reuse a slot which will cause the slots array to grow and grow over time.
I don't really understand what you mean. 
Very interesting read! Simple question: what you mean with void\*\* is that your "allocator" would return a void\*\*, which points to a void\* that's the actual resource pointer, and that using the destructor on the void\*\* would set the void\* to NULL allowing any other pointer (void\*\*) to that resource to check whether it's been freed, correct? Second question: what do you mean when you say &gt; That said, the lt solution will work across functions where this certainly will not.
len is not quite as lengthy as length and is used pretty much universally in C and C++ (see strlen() )
You're right, I stand corrected.
if you can afford it, before asking this type of question, running your code through valgrind will catch a lot of problems and save you a lot of headaches, it will report accessing arrays out of bounds, reading uninitialized values, and will also report memory leaks.
I'm new to C so could someone explain why he is using macro's instead of normal functions?
You are not supposed to do that from a signal handler. See man signal for a list of signal-safe functions. One thing you can do is just set a flag in the signal handler and break out of the recv loop to clean up and exit
Great idea! Thanks. 
Please someone correct me if I'm wrong but I think by checking if(buffer!=null) you can check and free the memory. For multithread just lock the mutex before the if statement.
This doesn‚Äôt work because buffer will still be equal to some pointer, it‚Äôs just it doesn‚Äôt point to available memory, The following outputs 1 (true) int main(){ char *buf = malloc(1); char *savedAddress = buf; free(buf); printf(‚Äú%d‚Äù, buf == savedAddress &amp;&amp; buf != 0); return 0; }
Yeah but if you follow good practice and after free set pointer to null, you are fine.
The problem isn't tracking which buffers have already been freed; the problem is doing so inside a signal handler, wherein you cannot call `free()` or lock a mutex. The correct solution, as mentioned above, is to set an atomic flag within the signal handler that you can test once control returns to your program and do whatever you need to do safely.
You‚Äôll need some sort of mechanism that will inform the other threads that the process is going down. This can be done by some sort of middle man object that will be responsible for watching for that signal which then propagates it to other threads that currently have a handle to that object. 
I'm an EE student right now, and I am definitely interested in learning more about MCU programming. However, I am always hesitant when checking out a new tutorials because inexperience and misinformation is everywhere. I think it would benefit your site to put up a portfolio of your work. I also want to thank you dearly for creating this site. I have benefited so much from generous people like you giving back to the community. Someday, I too would like to contribute back:)
I've also wasted so much time researching specific topics and got misled or shocked by realizing that I've been following malfunctioning instructions! These painful experiences had helped me a lot when it came the time to be an online content creator. However, I'll definitely consider adding my portfolio for those who are interested. You're welcome dude! This is the least I could ever provide for our lovely community. Good Luck :)
&gt; what you mean with void\*\* Your allocator should return a resource handle of some type, this is usually in the form of a pointer. When you insert it into the data structure the data structure makes a copy of that resource handle and stores it. The data structure should return a pointer to its copy of the resource handle, a void\*\* or a "pointer to a void pointer." If we go back to the scenario it now looks like this: * Alice allocates a resource R and gets back a handle to R called HR. * Alice inserts HR into the data structure and gets back a pointer to the data structure's copy of HR called HHR. * Alice controls the lifetime of R, he she is free to use HR. * Bob does not control the lifetime of R, so Alice gives him HHR. * When Bob wants to use R, he first dereferences HHR to get a copy of the data structures handle to R. * If Alice has not freed R, HR will be a valid resource handle (a non-null pointer) * If Alice has freed R, HR will be an invalid resource handle (a null pointer) * Bob doesn't dereference an invalid pointer, and doesn't crash the program. But ideally a void\*\* is not ideal. That means it can never reuse that slot for other resources. Instead, you could pass around a handle to a resource like this. typedef struct { lt* lt; size_t idx; int version; } resource_handle; This is a struct of 3 values you'll need to query an lt for a new copy of a resource handle: a pointer to the lt itself (which you must assume still exists), the index into the slot array and the version of that slot. So then you have a function like **void\* lt\_get(resource\_handle);** that will look up that resource and return a handle to it. However, the advantage to this is that each slot has a version, it can be reused for future resources and when that occurs the version is incremented in lt. If you query with a resource handle with an incorrect version, lt knows that you have an old resource handle referring to a resource that's been freed and can return NULL. Also, a note about names. I can't remember what lt means at this point. I even had to look up at my old post to refresh myself on what the name even was. Short name and good name are not synonymous. As for the solution working across functions, the goto method only works within a single function, or at least with multiple functions calling each other. I can't keep a copy of a set of resources around for the lifetime of the program, pass them into other functions easily, etc. With the method presented in this video you can pass an lt around to other functions, letting them add resources to it, and have finer control over the lifetime of the resources allocated.
You have a typo on ...... kidding. Just kidding.
&gt;getaddrinfo() Thank you so much for the feedback! :) I just added in getaddrinfo() -- replacing getaddrbyhost6()
If you're exiting the program, why bother freeing memory?
 You had me at "those goto labels suck".
Oh, so it is automatically freed from OS? Anyway i will do it for sake of 'formality'.
OMG! XD
No. The signal might fire while `malloc()` or `free()` is running and you'd end up trashing your heap. Very few library functions can safely be called from within a signal handler. The common idiom is to define a global variable of type `sig_atomic_t`, initialize it to zero, set it to some non-zero value (e.g. the signal number) within the signal handler, and have your main program periodically check it.
&gt; The if (i) part is if i is greater than 0, so you're truncating the first byte unconditionally, do you mean to do that? Where am I truncating the first byte unconditionally? &gt; you're looking at the byte before the array, Where? 
&gt; In the end you're just comparing two number that do not have the same size. Same size or the same value?
&gt; Read the docs for strcpy() and you'll see that using it with overlapping strings like you're doing is undefined behavior. All of the answers in the exam use `strcpy()` on the same array. Literally, all of them, in the same place (in the body of that `if`).
There's a lot of really crappy, flawed material out there, yes.
Interesting project. I guess if you want to improve it, you probably need to write out some kind of context-free-grammar that explains how symbols fit together. So like: expr := expr operator expr | expr operator number | number operator number operator := '+' | '-' | '/' | '*' number := '-' numbers | numbers numbers := digits | digits '.' digits digits := digit | digit digits 
Actually you do have a few typos in your ‚ÄúIntroduction to Embedded Systems‚Äù link. In the first paragraph I found 2. I would suggest you having someone read out a printed page and highlight the mistakes so you can fix them.
You're right jeffsnff ! They should be clear now. Thanks so much! Creating everything on my own was really overwhelming. Maybe that's why there still some typos here and there. I'll be chasing them down as soon as possible. Do you've any feedback concerning the content itself ?
Both functions are terrible wrong. The first one because you never actually allocate an `Image` for `image` to point to (thus `image` points to a random memory location, crashing your program). The second one because you return a pointer to a variable (`image`) whose life time has ended. `image` is an automatic variable; it is automatically deallocated at the end of `WrappedLoadImage`. Accessing deallocated memory is a huge no-no, don't do that. Here is a correct implementation: Image *WrappedLoadImage(const char *fileName) { Image *image = malloc(sizeof *image); /* allocate memory for *image */ *image = LoadImage(fileName); /* write the image into *image */ return (image); /* return pointer to malloc-ed buffer */ } This works, but you need to remember to call `free()` on `image` once you are done with it.
Neither of the examples are working as intended. Your C-compiler should display a warning in both cases. If you want to return a pointer then you have to allocate the struct on the heap, you can't return a pointer to a local variable (second case) or assign the struct to an uninitialized pointer (first case).
That makes sense. Thank you.
For starters, limit variable scope to when you actually use them. You can avoid using globals.
To be honest, C is lacking almost everything out of the box, at least if you compare to other mainstream languages, like Python, Java, or even C++. But one has to remember what C was designed for: be a portable assembly. You don't have much out of the box with assembly. That's why sometimes I feel C is "over used", and when you start doing complex abstractions (like a runtime stack frame for RAII, or an object system) I feel people should just move on to languages with better abstractions. One thing that really bothers me is the lack of basic data structures and algorithms in C standard library, particularly dictionaries/hashtables and a linked list, so everyone has to implement their own bugged version of them.
It was a nice read. I‚Äôm still learning programming and trying to figure out what I want to do, though I believe I want to do robotics. Figuring out what micro controllers are though does help.
I have a micrcontrollers class next sem, I'll have to keep this bookmarked 
Yes. And to be honest, the biggest challenge is finding them.
Hi! It's great that you're doing this, and please don't be discouraged by what I'm about to write. These are just some things I noticed as I started to check out the project. First, right near the top of your README, &gt; Intsallation Then I tried to build and run it: $ make cc -c -o src/main.o src/main.c cc -c -o src/diskfrisk.o src/diskfrisk.c cc -c -o src/display.o src/display.c cc -c -o src/config.o src/config.c gcc -o bin/find src/main.o src/diskfrisk.o src/display.o src/config.o $ ./bin/find [2] 12080 segmentation fault (core dumped) ./bin/find Okay, so probably some platform differences if it works for you but not me. Let's fire up `valgrind` to check what the bug is: $ valgrind ./bin/find ... ==12143== Conditional jump or move depends on uninitialised value(s) ==12143== at 0x10A8EF: build_cfile_path (in /home/tavianator/code/parkerduckworth/diskfrisk/bin/find) ==12143== by 0x108F2F: main (in /home/tavianator/code/parkerduckworth/diskfrisk/bin/find) ==12143== ==12143== Invalid read of size 1 ==12143== at 0x4C2FD79: strcat (vg_replace_strmem.c:307) ==12143== by 0x10A952: build_cfile_path (in /home/tavianator/code/parkerduckworth/diskfrisk/bin/find) ==12143== by 0x108F2F: main (in /home/tavianator/code/parkerduckworth/diskfrisk/bin/find) ==12143== Address 0x0 is not stack'd, malloc'd or (recently) free'd Hmm, this would be more helpful with line numbers. You can add debugging information like that by passing `-g` to `gcc`. I edited your makefile to add that but it didn't help. Notice how the `make` output above says `cc` while your hand-written rules say `gcc`. This is because `make` is using its own built-in rules to make the object files since yours don't match. Your rules make things like `main.o` but find depends on `src/main.o`. You can fix all of this up with "pattern rules": all: bin/find src/%.o: src/%.c gcc -g -c $&lt; -o $@ src/main.o: src/extern.h src/sysdep.h src/diskfrisk.o: src/extern.h src/sysdep.h src/display.o: src/extern.h config.o: src/extern.h src/jsmn.c src/jsmn.h bin/find: src/main.o src/diskfrisk.o src/display.o src/config.o gcc $^ -o $@ With that fixed, we get some line numbers from valgrind: ==12301== Conditional jump or move depends on uninitialised value(s) ==12301== at 0x10A8EF: build_cfile_path (config.c:150) ==12301== by 0x108F2F: main (main.c:14) ==12301== ==12301== Invalid read of size 1 ==12301== at 0x4C2FD79: strcat (vg_replace_strmem.c:307) ==12301== by 0x10A952: build_cfile_path (config.c:152) ==12301== by 0x108F2F: main (main.c:14) ==12301== Address 0x0 is not stack'd, malloc'd or (recently) free'd That points us to this function: /* Allows config file to be accessed from within any directory */ char *build_cfile_path(char *path) { // You must free 'abspath' when passed to another function char *abspath = malloc(sizeof(char) * PATH_MAX); char *user = getlogin(); strcat(abspath, HOME); strcat(abspath, "/"); strcat(abspath, user); strcat(abspath, path); return abspath; } Two problems: the first `strcat()` is operating on uninitialized memory from `malloc()`, and should probably be `strcpy()` instead. Second, on my computer `getlogin()` returns `NULL`. You can do this to get the current user's name instead: uid_t uid = getuid(); struct passwd *pwd = getpwuid(uid); if (!pwd) { return NULL; } const char *user = pwd-&gt;pw_name; Now we get further, but still an error: ==13013== Invalid read of size 4 ==13013== at 0x4EB0011: fseek (in /usr/lib/libc-2.27.so) ==13013== by 0x10A535: pull_file (config.c:55) ==13013== by 0x10A406: set_config (config.c:25) ==13013== by 0x108F7F: main (main.c:16) ==13013== Address 0x0 is not stack'd, malloc'd or (recently) free'd You are trying to determine the size of a file with: fp = fopen(fname, "r"); fseek(fp, 0L, SEEK_END); sz = ftell(fp); But if the file doesn't exist, `fp` will be `NULL`. You need to check for errors like this. In my case `fname` was /Users/tavianator/diskfrisk/config.json which doesn't exist because I'm on Linux without `/Users`. But if you wanted my home directory, all you had to do was use pwd-&gt;pw_dir which should be portable. After making that change (and putting `config.json` in the right place -- I'll leave that error handling to you), I get $ ./bin/find Enter a file name $ I.e. a shell prompt again -- your `find` has quit early without giving me a chance to enter a file name. At this point I checked your README and discovered that I ought to be running this tool through the `dfstart` shell function provided in `bin/exec.sh`. That's a bit of an unconventional installation method, but okay: $ . ./bin/exec.sh $ dfstart DISKFRISK INITIATED ____________________________________________ Enter search, or "settings" for more options DISKFRISK$ search DISKFRISK -- VERSION 0.0.0 Searching for: [search] Search type: Exact match Case sensitivity: Off Search user files: On Search system files: Off Permission errors: On Auto-open: Off Permission denied: /Users 1 result, in 0.00 seconds. ____________________________________________ Enter search, or "settings" for more options DISKFRISK$ Anyway, that's it for me at this point, but I hope this has been constructive.
Same size, as you're comparing char and int.
But look at the other answers, my C background is quite small and old. I might be mistaken.
Windows critical sections can only synchronize threads within a single process. Futexes described in this article (just like mutexes in POSIX and Windows) can be used to synchronize threads between different processes.
The problem is that "modern" features would quickly become outdated, and a few decades later the standard library would be full of obsolete cruft that cannot be removed or updated because that would break existing code.
I can't agree more. That also makes C entry level to be quite high. Especially when you come from a language which provides common data structures. Many people claim that you're not a real developer if you don't know how to implement linked list, but doing this *properly* is difficult.
Why do you wrap your returned expression in parens?
If you are using gcc you have to build it with \`-fno-stack-protector\` flag.
The reason I used globals was because if I defined them in main() they seemed to be unable to be used in the other functions. I suppose I could do it like this?: addition(x, y, z){ z = x + y; return 0; } main(){ int ans, num1, num2; addition (num1, num2, ans); return 0;} (On mobile so hopefully that formating works) Or is there a better way to do that? Is using global variables considered bad form? 
Typically the idea goes that you should be able to work out what the program is doing just by reading the function titles. So 'Add' would take two numbers, and return a number that's their sum. If you have globals, it messes that up, since there's stuff going on behind the scenes. In general, if you have a really clear flow, you have an easier time debugging. 
That function would not work the way that you want it. Functions are pass-by-value in C. You would need to pass a pointer to the result. In general, globals are not a good idea.
You need to read about what scanf's receive as parameters.
i forgot to add "&amp;" this before the float names
Yeah, so what C library gives you templates?
scanf() takes a pointer as its second parameter. So you need to use the address of operator (&amp;). scanf("%f",&amp;b);
That's BSD `style(9)` formatting style. Also known as KNF (kernel normal form) or Bill Joy normal form.
Question about this would be: How to control the size of such a stack-allocated array? How do we keep it small for small programs but allow it to grow large for big or long-running programs? 
What bugs me the most is that C does not have proper first-class support for functions (and related, anonymous functions and closures), which would really help with implementing any kind of higher-level abstractions. As-is, any kind of higher-level algorithms require casting back and forth to void-pointers all the time. It is very difficult to write non-leaky abstractions in C: (almost?) all the libraries out there require the programmer to manage certain pre/postconditions _for_ them. Breaking those rules might frequently lead to runtime errors, or worse; undefined behaviour.
The result: every semi-serious project ends up containing a badly-documented, bug-ridden implementation of half of common lisp ;-P
You're correct, but notice what I said about the design of C: it's supposed to be a portable assembly. When you start to need those kinds of abstractions, C is the wrong tool in my opinion, the best approach, IMHO, is the Numpy approach: use a higher level language for the abstractions and a lower level language for the heavy lifting core functions. Perhaps with Rust we can have a middle ground between C and Python, without the complexity of C++.
&gt;Image \*WrappedLoadImage(const char \*fileName) {Image \*image = malloc(sizeof \*image); /\* allocate memory for \*image \*/\*image = LoadImage(fileName); /\* write the image into \*image \*/return (image); /\* return pointer to malloc-ed buffer \*/} I may be confused, but doesn't this just leaks the memory that was malloced, and the program still continues with the same issue that it had before? `LoadImage` returns a copy of `struct Image`. If you allocate the memory for the pointer on the current context, than overwrite it with the return of the function the allocated memory was leaked. The temporary object created by the return of the function will also be freed when the function goes out of scope, so its data will also be lost. I believe a better solution would be: Image *WrappedLoadImage(const char *fileName) { Image *image = malloc(sizeof *image); /* allocate memory for *image */ Image tempImage = LoadImage(fileName); /* temporary object to hold the struct allocated by LoadImage */ memcpy(image, &amp;tempImage, sizeof Image); /* copy the data from the temporary to the allocated memory */ return (image); /* return pointer to malloc-ed buffer */ } The note about remembering to free the memory later is still valid, on this case.
&gt; as malloced, and the program still continues with the same issue that it had before? LoadImage returns a copy of struct Image. If you allocate the memory for the pointer on the current context, than overwrite it with the return of the function the allocated memory was leaked. Note that we assign to `*image` (i.e. what `image` points to), not `image`. Thus, not the pointer is overwritten but rather the pointee (i.e. what `image` points to). The whole `memcpy` dance is entirely useless.
Not OP but excellent advice! I would have been delighted to receive feedback like this on my earlier programs.
Right, my bad, I didn't notice that the assignment to the dereferenced pointer.
Check the manual of your libc implementation. On Linux that would normally be the Glibc. It offers some non standard extensions like hashmaps and trees.
I mentioned it in another comment but it's worth to check out the manual of your libc implementation. Glibc for example offers some non standard extensions like hashmaps and trees.
With C11 your compiler can give you basic support for datatype based dispatching (in compile time though). Look up `_GENERIC` and the `tgmath` standard library which uses this form of dispatching.
You could still pass function pointers as an argument to other functions, but that‚Äôs pretty much it. 
I can't think of anything more encouraging than solid feedback. Thank you for taking the time to write this! If you look in `/src/sysdep.h` you will see where the macOS file structure dependencies are defined. I think the problem can be avoided if the definition for `HOME` is replaced with `/home` , or whatever your linux distro requires. On my TODO is to read the user's os and inject dependencies based on what is returned. The README isn't clear enough, I believe. Something I need to work on. The idea is to use `dfstart` as the command to open the application. The Installation section in the README explains that it is a good idea to shorten this command for ease of use,( I use `f)`. It goes on to provide the source that should be added to `.bash_profile` (`.bashrc` for linux?) , enabling `dfstart` (or whatever alias is chosen) to be used from any cwd. I am now more acutely aware of the system dependencies currently restricting this project. Thanks again for the help!
Advice like this is absolutely invaluable. I am very grateful [tavianator](https://www.reddit.com/user/tavianator)'s guidance.
Please explain what ‚Äúdoesn't work‚Äù means in this particular case.
It does work. It reads the next character waiting to be read. Print the value of `choice` to see.
Hello, the first code works perfectly, it asks for operator, then I input the first and two numbers then it spits out a result. while the code below just exits after it asks for the 2 numbers and operator. I found out it's because printf(" Enter the first number:"); scanf("%f", &amp;num1); printf(" Enter the second number:"); scanf("%f", &amp;num2); . needs to be below: printf("Choose Addition or Subtraction:\n"); printf("[1] Addition\n"); printf("[2] Subtraction\n"); scanf("%c", &amp;choice); but idk why. 
the 1st code works and spits out results, but the 2nd code just exits after it asks for input
because scanf doesn't consume the newline character when you press enter. You have to scanf one more time or scanf 2 chars and discard the newline ('\n').
hmmm, interesting, adding 1 more scanf("%c", &amp;choice) made the 2nd code worked even with the \n still in it printf("Choose Addition or Subtraction:\n"); printf("[1] Addition\n"); printf("[2] Subtraction\n"); scanf("%c", &amp;choice); scanf("%c", &amp;choice); Could you explain further why would it need another scanf? my prof just changed "char choice;" to "int choice;" and use %d to fix the code I want to know why it didnt worked and why it needed another scanf so i can understand the language better.
the float scanf parses the number into the variable, but the \n is still in the queue, so when you do the first scanf it automatically consumes the \n (because it's a char, that's why it doesn't bug with ints and floats), with the second, since the queue is empty, the terminal waits for new input and replaces the previous content of choice which was \n with the actual user input. If you did a third scanf("%c") it would also get a \n and not wait for input. I'm not too familiar with terminal IO but there's probably a cleaner and more understandable way to discard the character, this however is a good workaround.
The lucid way to fix this is to use ‚Äú %c‚Äù instead of ‚Äú%c‚Äù.
Use scanf("%f") to be able to get longer numbers, read the documentation to figure out how it works. It will also save you from doing ugly character subtractions to convert chars to ints. You also seem to be using this construct if (useChoice == 'y') { ... }; if (useChoice == 'n') { ... }; if (useChoice != 'y' &amp;&amp; useChoice != 'n'); you can save a lot of trouble by using the `switch(choice){case y:...}` construct, try searching for "switch case in C" into google. Aside from that, all your functions return ints, but they can only return 0 and you don't check for the return value, that's a sign that those function should be declared `void func(){...}` and not return anything
addition should be something like int add(int a, int b){ return a+b; } and convert something like int convert(char c){ return (int)(c-'0'); } And you would have to call it like this: num1 = convert(num1); num2 = convert(num2); although as I have pointed out in my reply to the main post, converting chars by hand is probably a bad idea, at the moment it's entirely possible to enter any arbitrary character and get weird results. Also, yes, using globals is generally considered bad practice. In C, functions have "scope" that means that they only have access to the variables that are declared within them, and they can return only one value, when you want a function to modify an existing variable you have to play with pointers but that is an advanced topic, and everything that you do in this program can be done without globals or pointers.
&gt; Could you explain further why would it need another scanf? The Enter you press at the end of an input is mapped to a '\n' character that it's inserted into the buffer along with your actual input. So if you enter: 1 and press Enter on the buffer it'll be 1\n You may ask how, since '\n' is 2 char's long, and the short answer is that it's ASCII's symbol convention that maps to a number that when interpreted by the "OS", it jumps the cursor to the next line. So handling of this is explicit in C, and it's usually done in 3 ways across the IO functions in C: it's discarded, stored, or left as is in the buffer. Using the "%c" specifier like this only reads one char, but that char may be the '\n' left on the buffer by a previous input reading function. The 2 simplest ways of preventing that from happening are using `"%c "` or `"%c\n"` as format specifiers. The first has a whitespace char following 'c'. This causes the function to ignore any whitespace/new line/tab ( ' ', '\n', '\t', among others not important ) character you might throw at it. The second one acknowledges the '\n' character at the end of the input, and ignores it, but only it. Since `scanf` handles escape sequence characters differently depending on which format specifier you use, you should either learn them, or use the 2 options I mentioned above every time you use the function.
Read about fflush. Calling a fflush(stdin) between your scanf statements will make it work. 
Calling fflush() on an input stream is undefined behavior. Don't do it.
Thanks a lot. I was not aware of it. Just read about it after you pointed it out.
I guess so. The question is "Which functions removes the leading and the trailing blank spaces in a string?" Here are all the answers. Which one do you think is correct? I'll label them a) through e) and put the functions underneath each label : a) void trim(char *array) { int i = 0; while (array[i] != ' ') ++i; if (i) strcpy(array, &amp;array[i]); while (*array) ++array; while (*(array-1) != ' ') --array; } b) void trim(char *array) { int i = 0; while (array[i] == ' ') ++i; if (i) strcpy(array, &amp;array[i]); while (array) ++array; while ((array-1) == ' ') --array; array = 0; } c) void trim(char *array) { int i = 0; while (array[i] == ' ') ++i; if (i) strcpy(array, &amp;array[i]); while (*array) ++array; while (*(array-1) != ' ') ++array; *array = 0; } d) void trim(char *array) { int i = 0; while (array[i] == ' ') ++i; if (i) strcpy(array, &amp;array[i]); while (array) ++array; while ((array-1) == ' ') --array; } e) void trim(char *array) { int i = 0; while (array[i] == ' ') ++i; if (i) strcpy(array, &amp;array[i]); while (*array) ++array; while (*(array-1) == ' ') --array; *array = 0; } I would say that `e)` looks "most correct", that is, it logically makes sense. `a)` doesn't "trim" the array. Neither does `d)` among other things. `b)` compares pointer to an integer in the third `while` body and `c)` "goes to the right" in the third `while` loop, instead of "to the left".
&gt; have I got it right? Do all your tests pass?
`_Generic`*
If you use `&amp;&amp;` instead, you'll get a failing test when one string is shorter than the other. Let's say `str1` is `Test` and `str2` is `Test2`. When you hit while ('\0' &amp;&amp; '2') You'll drop the `while` and return `0`, which is obviously incorrect. That being said, you should probably check for `NULL` before comparing, just to be robust.
No. If the strings are a different length, you will increment either pointer past the end of that string and then dereference it, invoking undefined behavior. int strcmp(const char *str1, const char *str2) { while (*str1 != '\0' &amp;&amp; *str2 != '\0' &amp;&amp; *str1 == *str2) str1++, str2++; return (*str1 - *str2); } 
I thought so at first too, but I don't think this is true, since if we're in the case where (without loss of generality) `*str1` is `\0` and `*str2` is not, then they are different, and therefore it will return in the body of the while loop (since one is less than the other). I wouldn't write the code the way written because it looks like it is problematic (even though I don't think it is).
&gt; No. If the strings are a different length, you will increment either pointer past the end of that string That's not true. If the strings are different lengths then the function will have returned in the previous iteration since '\0' is &lt; what ever character is in the other string.
Then it gets a lot more trickier in terms of keeping track of stuff and tidying up. Since I'm on mobile now I am too lazy to type but you should read some doc about thread cancellation / pthread_kill / pthread_join / pthread_cleanup_(push|pop). I think a lot depends on your use case
They all call strcmp() with overlapping arguments so they're all wrong.
Yes, you are right. C is able to perform the role of 'portable assembly' reasonably well, although there are some people that find C a bad portable assembly because of parser abmiguities, the lexer hack, and the fact that a lot of higher-level type-information has to be thrown away when compiling to C. An example would be 'popcount': there is no standard C instruction to do this, so to keep compliant, higher-level languages need to compile to a function with a loop, while GCC and Clang are attempting to catch all of the variations these functions might have to replace them by a single assembly-instruction again. Of course any alternatives (like LLVM, like Rust) miss one important aspect of C: How wide-spread C already is. And this still makes it the most adequate choice for portable assembly, I guess ^^'.
You're right, I didn't pay attention to the `return`s.
You're right, I didn't pay attention to the `return`s.
You're welcome! &gt; If you look in /src/sysdep.h you will see where the macOS file structure dependencies are defined. I think the problem can be avoided if the definition for HOME is replaced with /home , or whatever your linux distro requires. Yeah that's true. But you shouldn't really be assuming anything about where home directories are, especially at compile time. I can create users with their home directories anywhere I want to. That's why you should use `pw_dir`. &gt; The idea is to use dfstart as the command to open the application. Yeah I see that now. Generally when programs have a shell driver, the driver will just be a shell script that can be put on the PATH, instead of a script defining a function that needs to be sourced. The user is then free to do `alias f=dfstart` as they wish. &gt; I am now more acutely aware of the system dependencies currently restricting this project. Great! I think this is important because many open source developers will not be using macOS. If you want to do some testing on other platforms you could use a virtual machine or a cloud service like Travis.
The `NULL` check is the responsibility of the caller IMO.
&gt; unambiguous No not really. 1 + 2 + 3 + 4 has at least two derivations: expr expr operator expr (number operator number) operator (number operator number) 1 + 2 + 3 + 4 expr expr operator number (expr operator number) operator number ((number operator number) operator number) operator number 1 + 2 + 3 + 4
Xcode is very cool I think. There's also Qt Creator or you can learn to use CMake or makefiles with sublime. 
If you can bear the price, you can get Xcode from the App Store. 
&gt;probably, I'm no expert I just came up with the above while writing the post. The point is, if you want to write a calculator, it makes sense to work out an unambiguous grammar.
Just tried Xcode for about 20 mins. Looking great so far, bound to be stable since it was originally made by Apple.
Xcode is free. 
- vim - Xcode - visual studio code 
thatsthejoke.jpg
If you want to read a single non space character, try `"\n%c"`. The newline will consume blanks and throw them away. 
Thx wasn't sure anymore. 
This subreddit is for C, not C#. Try asking [here](https://www.reddit.com/r/csharp/).
My bad, I will
Xcode supports C natively thru Clang.
It would be easier to tell if there is a fix for this if you could tell us what the ‚Äúcomments‚Äù dropdown says. It probably contains the actual error message.
‚ÄúWelcome to the ‚ÄòC‚Äô Hyper-Reference, also known as CHaR because I say so‚Äù :D
Nothing I use that is made by Apple is stable :/
Are you training for the 42 exam ?
I suggest looking into [CLion](https://www.jetbrains.com/clion/). You can get it for free with a university email.
It's called "Using Xcode". it's not that damn hard.
The Unfortunate Truth. High Sierra, and now Mojave are terrible on the CPU if I do really anything for more than 10-15 minutes.
I never want to develop in vim ever again
Why?
Usually `static` is what you want, not `extern'. * `static inline` means each .c file is can have a separate copy of the function, without conflicts. The compiler may choose to inline the function always, in which case it will not produce code for this function (separate from other functions). However, if it chooses to, it may produce code for the function using `static` visibility. * `inline` means that an external copy of the function exists somewhere, in a different .o file. If the compiler chooses to inline this function entirely, it will not need to generate a reference to the function. However, if it chooses not to, it expects the function to defined somewhere else. If it's not, you have an error (the one you saw) * `extern inline` forces the compiler to produce code as an externally visibly function. The compiler may also inline the function, if it chooses to, but it must produce an external definition. Basically, in normal use cases (99%) of the time, you have two reasonable options: 1. Put a `static inline' in a .h file. Every .c file can inline that .h file with no conflicts. 2. Put a `inline` in .h file and put a matching `extern inline` in exactly *one* .c file. Usually people go with #1 because it more closely matches what they want from an inline function.
thank you for the explanation!
I am no expert - that site looks thorough .
https://stackoverflow.com/questions/6312597/is-inline-without-static-or-extern-ever-useful-in-c99
You can‚Äôt quit it, right?
In the example it is just about having elegant cleanup code within a function. So for the examples given it would only need to be an array of three or four. Ideally the code might be able to be made such that the compiler could warn if the size of the array is exceeded.
It is highly unlikely that a Docker container would have a full development environment. Most distributions don't even include it out of the box for a full server or desktop install.
Thanks for your reply, I agree with you. I was thinking in adding the source code myself with the rest of my code, so for example I took (dlfcn.h)[https://download.samba.org/pub/unpacked/lorikeet-heimdal/lib/kafs/dlfcn.h] and (dlfcn.c)[https://download.samba.org/pub/unpacked/lorikeet-heimdal/lib/kafs/dlfcn.c]. Now it asks for `sys/ldr.h`, and you know... this looks like a rabbit I will have to follow to hell. Maybe someone knows where I can download all the necessary files, or another way to achieve the goal (load functions from files).
It's like a street gang man, blood in no out
* please, I beg you, don't enforce smooth scrolling on your site * your site menu is doubled (?) * sometimes, the topics become quite specific * there are only c code examples (as far as I see), what about assembler? E.g how would the c code block look like in asm ... would be helpfull * I subscribed to your rss feed, will watch your blog
You have to include a complete development environment (at the very least, the equivalent of `libc-dev` or `glibc-devel`) that matches the libraries included in the container. See if you can find Docker images for Varnish, which does something similar to what you want (configuration files are translated into C source code which is compiled and loaded at runtime).
I will check the scrolling options again. Yes, the top menu kind of wiered. So it'll be fixed as soon as possible. ASM code is generated in situation dependent manner as the XC8 compiler does a really good job in this area. However, i prefered to focus only on c-code with the beginners in mind. We need to get them started with us to be able of investigating in this area. But i will consider this for sure. Many thanks for your feedback. It's so helpful for me ^^
You generally can't just add single files until it works. Try installing a proper development environment instead.
So other people are saying you really need a full development environment, and I totally agree with that... but your post has me a bit confused. It seems like you've already got _some_ kind of development environment: you've got a C compiler, and you presumably have both `stdlib.h` and `stdio.h`. But this mustn't be a POSIX environment, otherwise you'd also have `dlfcn.h`. So do you know what kind of environment you have? Maybe it has some alternative to POSIX's dynamic linking facilities.
The environment is from a company which develop a firmware for microcontrollers. They provide a docker image so you can compile your source code. I'm going to download a fresh one and edit it, hopefully installing `libc-dev` as /u/a4qbfb suggested is enough. I'm not familiar enough with compilers to dig into alternatives by myself, at least not for now.
C++ is off topic in this subreddit as this is a subreddit about C, not C++. Please post C++ content elsewhere, e.g. to /r/cpp.
Hi! I'm the author of the video. Thank you so much for such a detailed post! I learned a lot from it! My goto example is indeed extremely unfair. I'm planning to make another video to fix that and respond to your post. But making a single video usually takes 1-2 weeks for me plus I do all of that in my spare time. And the next video is already planned to be on a different topic. So the ETA is around first half of August. :) I'm gonna post to this subreddit again when I'm done. Thanks!
Source code for the microcontroller, you mean? Microcontroller firmware is usually statically linked and does not have the ability to load additional code at run time.
How often does this code execute? Code that executes one time every few weeks does not need to be "fast". Code that executes millions or billions of times a second does. The first rule of optimization is "Don't Optimize". The second rule of optimization is "Don't Optimize Yet". The third rule of optimization is PROFILE PROFILE PROFILE 
This is really a nice application for X-Macros. See [http://www.drdobbs.com/the-new-c-x-macros/184401387](http://www.drdobbs.com/the-new-c-x-macros/184401387) for an explanation.
i personally use X-macros: #define LIST \ X(foo)\ X(bar) #define X(e) e, enum list { LIST _total }; #define X(s) #s, char* list_str[] = { LIST "" }; which produces enum list {foo, bar, _total}; char* list_str[] = {"foo", "bar", ""};
I try to avoid switch statements. If your enums are consecutive, you could just look up the string in a `char**` table, which will be very fast.
Under what circumstance are you going to need a string name for an enum in which that loop will be the slowest part? Unless you have thousands of enum values the IO you're almost certainly about to do will be much slower than the lookup loop.
When using C99 and non-negative enums, I like to use a designated initializer approach: enum quality { Q_TERRIBLE, Q_POOR, Q_MEDIOCRE, Q_FAIR, Q_GOOD, Q_GREAT, Q_SUPERB, }; const char *const quality_names[] = { [Q_TERRIBLE] = "Terrible", [Q_POOR] = "Poor", [Q_MEDIOCRE] = "Mediocre", [Q_FAIR] = "Fair", [Q_GOOD] = "Good", [Q_GREAT] = "Great", [Q_SUPERB] = "Superb", }; 
A tl;dr of what the article says: 1. The switch statement is quite a good one. 2. If you have multiple different conversions, you could use the array version, which means you only have to maintain the array, rather than each of the separate conversions. So the array version is helpful if you need more conversions to happen as well, for instance when you also want to convert back.
That's a very cool and succinct way of doing it. Took me a minute to understand what was going on, but I think it's great.
I hope they are not. If so, any other option I can look for? I've opened the docker image, and run `whereis dlfcn.h`, which gives me `dlfcn: /usr/include/dlfcn.h` As you can guess, after `apt-get install build-essential` I got: Reading package lists... Done Building dependency tree Reading state information... Done build-essential is already the newest version (12.1ubuntu2). 0 upgraded, 0 newly installed, 0 to remove and 30 not upgraded. I hoped it wasn't included in the docker, but it is. Any ideas?
I would divide it into two loops! 1. `int length;` 2. `for(length = 0; str1[length] != 0 || str2[length] != 0; length += 1) {` 3. `if(str1[length] != '\0' &amp;&amp; str2[length] == '\0') {` 4. `return str1[length];` 5. `else if(str1[length] == '\0' &amp;&amp; str2[i] != '\0') {` 6. `return -(str2[length]);` 7. `}` 8. `}` 9. 10. `for(int i = 0; i &lt; length; i += 1) {` 11. `if(str1[i] != str2[i]) {` 12. `return str1[i] - str2[i];` 13. `}` 14. `}` 15. 16. `return 0;` This is cleaner, doesn't make any assumptions, and can be read quite easily ... Yes we do loop two times, but it should not matter in the grand scheme, especially for smaller strings... Readability &gt; Performance! Also, make those pointers constant
usually the enum value name is the same as the string but if you want them to be different you could do #define LIST \ X(foo, "Foo")\ X(bar, "Bar") #define X(e,s) e, enum list { LIST _total }; #define X(e,s) s, char* list_str[] = { LIST "" }; which produces enum list {foo, bar, _total}; char* list_str[] = {"Foo", "Bar", ""};
No. You don‚Äôt need to learn c before c++
It doesn't matter, if you're going to use c++ then learn c++.
I think for any embedded programming, I'd start with C. It's simpler
mine : int ft\_strcmp(char const \*s1, char const \*s2) { size\_t len; len = ft\_min(ft\_strlen(s1) + 1, ft\_strlen(s2) + 1); return (ft\_memcmp(s1, s2, len)); } int ft\_memcmp(void const \*s1, void const \*s2, size\_t n) { int res; t\_byte \*ps1; t\_byte \*ps2; res = 0; if (s1 == s2) return (res); ps1 = (t\_byte\*)s1; ps2 = (t\_byte\*)s2; while (n-- &amp;&amp; !res) res = \*ps1++ - \*ps2++; return (res); }
&gt; Why am declaring the variables in the main function, but obtaining the user input within the appropriate a_rect, a_square, etc function? Probably just to practice how pointers work.
Speed isn't really important in this case, since if your enums *are* consecutive, your compiler should optimise a switch statement down to the same code that looking it up in a `char**` table does. That is, if you put a `__builtin_unreachable` as a default case, since an out of bounds enum in the switch statement doesn't return anything but isn't strictly UB (unless you use the value), while an out of bounds index of the array is UB, regardless of if you use the value or not.
That is what I am struggling with. How do I assign a value to these variables within the appropriate functions using pointers?
 void foo(int *i) { *i = 42; } int main() { int i; foo(&amp;i); printf("%d\n", i); }
&gt; your compiler should optimise a switch statement down to the same code that looking it up in a char** table does. Holy Godbolt, you are right! Even if I add small gaps, the compiler fills them with "empty strings". This is cool, but I still don't like switch statements. ‚ò∫
If you can optimize linear time into constant time by chaning `{ foo, "foo" }` to `[foo] = "foo"` there's no need to hesitate
What operating system are you programming on? I typically advise beginners not to use IDEs because this sort of thing can happen and it's usually pretty intransparent what exactly happens, so finding the problem is hard.
Can't say Code::Blocks is high on mine (or many peoples) recommended editors
I'll take any recommendations, I just saw a few people mention it on here in a few threads for beginners
 enumerator &lt; sizeof(lookup)/sizeof(*lookup) ? lookup[enumerator] : NULL
Windows 10. I know nothing about linux, should I try and get into it?
Linux is much easier for developing programs in C and knowing how to use Linux is a useful skill. Try it and see if you like it. On Linux, you invoke the compiler like this: cc -o binary source.c where `source.c` is the name of the source file and `binary` is the name of the binary. Note that on Linux, binaries don't have a file extension unlike on Windows, where they have a file extension like `.exe`.
I'm not sure where to even start, do I have to install Linux on my computer using a virtual machine? Or over windows 10?
You could start with WSL, the Windows Subsystem for Linux. This gives you a Linux-like environment on Windows. It should be good enough to give you a taste of what Linux is like. You can also install Linux in a dual boot configuration. WSL is easy to install, look at the internet for details.
Thanks a ton
C originated as the language for the UNIX operating system. Linux is a UNIX clone, so C works very naturally on it. In comparison, the C environment on Windows is pretty fucked up and not fun to develop with. On Windows, you need to use the Win32 API which is weird and broken in a lot of ways. All the useful POSIX functions are unavailable and neither are modern language features. In comparison, programming in C on Linux is pretty straightforward and just works.
I would argue that your version is far shittier code. The enums value will change any time you recompile. How is that better? 
What's the difference between a readonly array (the char\*\* array) that describes an enum and a function (the switch statement) that describes an enum? It's purely architectual, the actual code generated is the same.
Thanks again, appreciate it
What do you mean? The same enum declaration will always compile to the same values. "My" version doesn't even touch the enum declaration itself, only the lookup array.
I've had good success with CodeLite. Try it out, it's similar to Code::Blocks so it should be quick to get up and running for you. If you run into issues let me know and I'll try to help.
That old Dr. Dobbs article is exactly what we're talking about! I only ever seen this used to set up complcated tables consistantly... Like in an interpreter where you want to implementing function and function name to match... You redefine the macro and `#include "table.inc"` after each macro-redefine. Do people *really* get fancy with enums or is that just the favored example of technique?
Offtopic, but Lars Wirzenius isn't Linus Torvalds. :-)
It's a good library that's been battle-tested. However, it's in maintenance mode. And the following comment from the lead maintainer does not inspire confidence: Kai Engert (:kaie:) - Comment 10 ‚Ä¢ 9 months ago Comment on attachment 8914723 [details] [diff] [review] bug_cancelIO_nspr_v1.patch Thank you for removing the temporary code. I cannot review this code for correctness, but Honza's review is sufficient for that. You're only changing code for the Windows platform, which I personally don't worry much about, because there are probably only few consumers of NSPR besides the Mozilla applications. Nevertheless, you're changing code that will affect all consumers of NSPR on Windows. I don't know if your code could cause any surprises or regressions for them. If you've decided that you create general code at the NSPR level, you probably should have tests inside the NSPR test suite, that verify this code is correct, or at least, that it doesn't cause regressions to those who don't use your new mechanism. Although NSPR has its own test suite, it's currently not being executed anywhere. A good place to do so is probably the NSS CI environment. I've recently started some preprations to make that happen, see bug 1385039, but it's not yet completed. It would be nice to get some help there. Lacking automated tests, please run the NSPR tests locally on your Windows machine. r=kaie because you aren't introducing any new APIs, you aren't changing existing APIs, so your change is safe from the API perspective.
All you have to do is sort by quantity putting the most commonly ordered items as close to the door as possible. It‚Äôs extremely simple.
I know they are all wrong, but now I'm wondering which one is the least wrong among them. I'd say `e)`.
So my function is good?
This is an exam question and I've run some cases on the top of my head. They all seem to pass.
Perhaps you should try [Apache Portable Runtime](https://apr.apache.org/).