Ah yes I was drastically overthinking the error.
the fibonacci function, if I were to write it as its own function works. Theres something I'm doing wrong when I am trying to call it that it messes up.
 119 result_fibo = fib(user_fibo); 120 printf("%d\n", user_fibo); The call is fine. The answer is stored in `result_fibo`. The compiler is warning you that although you write to `result_fibo` like on line 119, you never use that result for anything. You should use it on line 120, but you aren't.
And line 34 + 56 - It's not technically kosher to call `main()` in a program (IIRC it's undefined behavior), that and it will eventually lead to a stack overflow if you end up calling `main()` too many times. It's a bad practice anyhow, so I recommend using a loop of some sort. EDIT: Quick Google search reports that it is technically valid C, but invalid C++. Given that you can still run into issues with the stack overflow, plus being a very uncommon practice, it's still a bad idea.
... And it doesn't let you define new operators. Some languages do, but not C++.
I've found that in the programming/Computer Science realm, a lot of people pick on beginners, or refuse to help and share knowledge. At my university TA's are always in trouble for disrespect and unwillingness to help students. As long as someone is trying on their own before asking for help, it shouldn't be an issue.
Don't feed the trolls, /u/FUZxxl! It might help to put something in the sidebar about whether beginner questions are ok or not, though. I personally think this subreddit would die without beginner questions. There would be like 3 posts per week.
Ubuntu. 
Type `apt-get source eglibc` (preferably in a fresh directory) to get the source code of the glibc. This also contains the source code of the functions in `stdio.h`. Beware though, the glibc is huge and very complex.
I think that having such questions are fine, but that it needs to be clear that we aren't going to 'just do it for you' - you have to be an active participant in the solving of the problem, including 'due diligence' before asking. [See my top level comment](https://www.reddit.com/r/C_Programming/comments/45xyyb/to_the_person_reporting_another_one_of_these_posts/d011atq). I think that's part of the reason those kinds of posts are being reported - that people asking the questions are being lazy, not necessarily that the questions are beginner questions.
Thanks for the recommendations! I've been reading about this stuff all day.
You're welcome. I'd be happy to give you some more recommendations or explanations if there's anything you have more questions about.
And that worked too. Thank you for all the resources. 
&gt; Clearly these functions are candidates to be static functions, but they're already not presented to other units, so what's the gain? They are not presented in the header files but they are still visible to other translation units. You could still use them in any other .c file in the same project by simply declaring them in any other .c file (with their correct names and argument types) before calling them. &gt; Is it a hint to the compiler to perform certain optimisations on them? It's an **instruction** to the compiler to not expose these functions to other translation units. Otherwise you would e.g get a name clash if you defined another function with the same name in any of the other linked objects.
seconded!
The advantages of static functions: 1) Reduce linker namespace pollution 2) Hint to the optimizer (which may decide to inline a large function if it is static *and* called just once) 3) Can be detected as dead code when it is no longer used 4) Intention of locality is documented (Thanks /u/Heavyweight87)
This sounds like an "A-B problem". What are you _actually_ trying to do, that makes you think you need to "get glib working with mingw"? Post details.
I'd say the closest thing would be `writeIORef`.
A game using SDL. Currently implementing a sort of pseudo-terminal pseudo-emulator in SDL because I hate myself.
[Clover](http://sourceforge.net/projects/cloverefiboot/)
A Unix character terminal-based warehousing, manufacturing and order processing system with barcoded stock control. ANSI C, approximately 100,000 lines application code. Each one lovingly crafted by myself :-) 
And how would i do that? This is my first seg fault ever.
Is there a newline character at the end of your input file? Your code is expecting one.
did you see http://pastebin.com/pxWFykA0 it prints the grid but it doenst print the done.
That really should be working. Are you 100% sure this code is the same as what you're running? Have you tried recompiling in case you have an older executable sitting around?
Did some editing and seems to work just fine now : [http://pastebin.com/RcfZRkLX](http://pastebin.com/RcfZRkLX).
gdb is a debugger that (I think) comes with gcc. So, if you compile the program as such: gcc -g wordfind.c which will create an a.out executable, which you then open with gdb: gdb a.out From there, you can issue a "break main" command, and then "run", and gdb will trace through your program one step at a time (using the "next" command). There are plenty of tutorials and the like online, if you want more info. It's an invaluable tool
&gt; I'm writing a POSIX-compliant portable userland for UNIX-like systems. How does it compare to something like BusyBox? What license are you using? Will you write your own shell, too? &gt; I'm writing a FUSE file system to mount possibly compressed tar-archives How does this compare to [archivemount](http://archive09.linux.com/feature/132196)? Can you elaborate on the bad output from GNU tar? I didn't know about this. 
Ooh, this is probably the issue. Because the "done" string doesn't contain a newline, it will likely be buffered waiting for more text. In the meantime, the program continues and tries to write data to an invalid memory location. I didn't notice this because I skipped over that line.
I am writing a C compiler in C, not C++ (what I usually use). I want to have a portable library with different backends (which will be non-C implemented).
Two things really: 1. [Protura](https://github.com/DSMan195276/protura), a Unix-based kernel. Fairly Linux-like at this stage, and 32-bit x86 only for the moment. 2. [nclyr](https://github.com/DSMan195276/nclyr) a generic "music player client". Currently it has two backends, one for `mpd` and one for `pianobar`. I use the current version daily.
I don't really do personal projects that much anymore. I'm working on one just to have something in my portfolio to show off (for when I eventually look for a new job). For that, I'm making a FAT filesystem analyzer, something for engineering forensic analysis when you have a corrupted filesystem and want to figure out what broke in it. (I've had to do that by hand before staring at hex, which is where the idea came from.) Professionally, I work on embedded VoIP systems. We run entirely our own code (except for SSL libraries). Own RTOS, own TCP/IP stack, own everything else. On the products I maintain, it's about 700 KSLOC. It's all written on top of abstraction layers so it can easily run on Windows, Linux, or several different RTOSes. I've gotten my hands dirty with pretty much every component except the core networking stack; that one is *very* complex, and used by a lot of customers, so it's not something I'm comfortable touching lest I break something in it.
[http://linux.die.net/man/3/scanf](http://linux.die.net/man/3/scanf) Everything in C is passed by value. The only way a function can change an external variable is by passing the address of that variable.
The "bootstrap it" part is what makes me think OP is doing more work than necessary. OP: There are glib binaries for windows.
This works on *my* terminal: #include &lt;stdio.h&gt; void get_input(char * dest){ int i=0; printf("&gt;&gt; "); //optional, tells the user that they're supposed to type something. while(1){ char c = getchar(); if(c == '\n'){ dest[i] = 0; break; } else { dest[i] = c; } i++; } } /* Optional */ char in[256]; #define input() get_input(in) If this breaks, see `man stdio` and replace "getchar()" with your function that gets one key from the buffer. If you want to print to the console: char in[256]; main(){ get_input(in); printf("%s \n",in); return 0; } 
&gt; How does it compare to something like BusyBox? My software is going to care more about standards, is going to be more complete and less feature-rich than BusyBox. Basically, I only implement whatever POSIX mandates. &gt; How does this compare to archivemount? Archivemount is terrible and demonstrates that the author has zero clue about both the libarchive and the tar file format. If I understood the software correctly, it re-reads the archive from the beginning every time parts of a file are requested (this is the only mode of operation supported by the libarchive) and is thus horribly slow. My software creates an index (stored in a sqlite database) to the tape archive and uses that to look up files with blazing speed (hopefully). This also makes supporting write access possible. &gt; Can you elaborate on the bad output from GNU tar? I didn't know about this. In 1988, the tar file format was standardized to *ustar.* You can find the documentation of the format in [POSX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html), section “ustar.” This standard is a careful expansion of the historical V7 UNIX format and is backwards compatible to old tar programs. It is identified with the magic number `"ustar\0"` and version `"00"`. We are talking about an old-ass standard that everybody should support by now. The GNU tar people implemented ustar based on an early draft of the standard with magic number `"ustar \0"` (there was no split between magic and version in that revision) and small differences (like leaving off the devmajor and devminor fileds in records that aren't for special files) that are large enough to throw off a tar parser that is written to the letter of the standard. While they implement proper ustar by now, they don't produce standard archives by default. You have to add an extra option for GNU tar to actually stick to the 28 years old standard. This looks awfully similar to vendor lock-in a-la Microsoft “but we do implement the standard, you just have to select ‘yes I want to use the standard’ in a menu hidden five layers deep.” Now ustar was designed to be extendable. There is a byte in the header that describes the file type of a record. Types 0 to 7 are used for the various file types you find on UNIX, lower case letters are reserved for future standardization and everything else is fair game for vendor extensions. GNU tar implements a lot of these, some of which are useful, others not so. The standard has a simple rule to make extensions cooperate with tar implementations that do not support them: The file size field in the header should report the size of the file in the archive so unsupported file types can be skipped or treated as regular files. Of course, GNU has an extension that does not stick to this concept. GNU-style sparse files (typeflag `S`) set the size of the unpacked file in the header but store the file in an encoded format with holes removed. A program that doesn't support sparse files is not able to correctly unpack an archive with sparse files as it isn't able to skip to the next header due to the bogus size field. In 2001, ustar was expanded to the pax format to get around some of its limitations. For example, ustar doesn't support files larger than 8 GB (the file size is stored in 11 octal digits). pax works by using special extended header files with typeflag `x` or `g` to store extra metadata in a key-value scheme. Unrecognized keys can be ignored by programs that don't understand them and programs that don't speak pax unpack the header as an ordinary file which is usually the right thing (except if an over-sized file has been stored with a size-override in the extended header). GNU tar supports most of its extensions in a pax-compatible way by means of special extended header keys. Many of the common GNU tar extensions (like long [&amp;ge; 256 character] file/link names) are redundant as they can be implemented using pax headers yet GNU tar still defaults to its own non-standard format that breaks unpackers that don't expect GNU tar archives. As a bonus, the GNU tar [documentation](https://www.gnu.org/software/tar/manual/tar.html#SEC132) talks about making the pax format (there called posix format) the default in a future version. I'm not sure for how long this text has been in there, but it's probably more than five years. Meanwhile, pax is a standard for 15 years now with wide support.
If this thread blows up I'll pin it for a day or two. However, I don't see it leaving the top of the front page anytime soon with the way inter week traffic is.
You could just get the gcc source code and change it.
`sudo find / -name stdio.h` ... but on 99% of UNIX-like systems it's /usr/include
A DNS daemon. Currently do not plan to support recursion or TCP so xfer won't be available either. This is just a means to learn C in a non-trivial fashion. Currently can receive queries and parse them and respond back with a very broken response. Not in GH yet as it is very non-functional.
I signed up for a class at a community college. I like classes better than books. There are online classes (MIT openware, edx, udacity, etc...) or video lectures on YouTube.
I would still recommend testing the return value of the `fopen` call. It's good practice, and getting into the habit will likely save you a lot of time.
Thanks! will do!
Its Dutch btw \^^ for something like done.
How do I use them with mingw? I'm using sublime text and compiling with the command line, how would I link to the library?
No problem. I also recommend following up on on other advice: * compile with as many warnings as feasible (e.g. `-Wall` in gcc). That was how I first new to hone in on that line * learn to use a debugger. There are graphical front-ends to gdb that might make it less threatening 
That's why it's "doing it wrong": you get undefined behavior by giving the wrong number of arguments to a varadic function (like `printf`). 
http://pastebin.com/y8i1P6kV the input is the same. If you see something i can improve or do better also let me know
I made a simple tetris clone in SDL a while back, but it is slacking in some portions. PM me if you want to see it or some general guidance. I really loved working with it.
That's how it was designed back in 1979. Every header field contains text or octal numbers (people liked octal back then as it was fast to parse). Numeric fields are terminated with a space or NUL so you can use `scanf` to parse them (I don't for broader compatibility).
To add to what /u/wgunther said: Undefined behaviour means that everything can happen, including * what you expect to happen * a program crash * silent data corruptions * dæmons flying out of your nose
OK, thank you two for your answers. That makes me feel better, I was beginning to feel like I was doing it so wrong I couldn't even do it wrong correctly.
Have you considered just using gcc on linux under a virtual machine? It will be _much_ simpler, and you'll get up to speed much faster.
I'm only dabbling so I'm sure that someone will be able to chip in with more information. My understanding is that you have a bunch of individuals, let's say their aim is to get to the highest point on a hill at 100m. Each will have a different height value because of their different positions on the slippery slop of the hill. This difference between the maximum height of the hill and the individual height is the fitness, so a lower difference indicates a higher fitness. Then a selection is taken from your population of people on the hill with a weighting towards the fittest individuals (roulette wheel). A certain number of the selection is mutated and crossover happens between them and will give you a new, slightly different population of people on the hill. Hopefully this time with more people closer to 100m. Rinse and repeat. 
I appreciate the reply! I actually have a weird problem with clover where if I enable USB3 on my mobo I get an error and clover doesn't load properly. I'd partly like to contribute for selfish reasons to see if I could fix that! But also just to give back to the community. Thanks again. 
&gt; I appreciate the reply! I actually have a weird problem with clover where if I enable USB3 on my mobo I get an error and clover doesn't load properly. No problem. Just see the [wiki](https://clover-wiki.zetam.org/Configuration/Boot#boot_debug) to enable the debug mode and post your log file with your problem description [here](https://sourceforge.net/p/cloverefiboot/tickets) 
I used to use pianobar years ago when you could skip as much as you wanted without ads.
In addition to the classes mentioned already, try to read as much code from mature projects as possible.
Game about a camel that's made of cactus for with SDL
&gt; FreeBSD's ln doesn't seem to have -T yet. But what about a simple Oops, I was reading the wrong man page. You're right, it's still just GNU. It's more like `[ -d $target -a -h $target]` and, if true, `rm` the target before invoking `ln`. For correctness that's necessary for every `ln` invocation in a script, since otherwise the link may be created in an unexpected place. This is a little contrived, but a perfect an example of where pure POSIX can't solve the problem and a GNU extension does. If a different user is allowed to create a symbolic link at the target, then `-T` solves a security issue. Suppose after the script executes the test and removes the existing symlink, the other user (now compromised) dives in and replaces it with something malicious (ex. `ln -s ~victim/ $target`). `ln` won't be aware of the desired constraint ("use the target literally") and will follow the malicious symlink to make a symlink under it. The malicious user got to control where the victim created a file. In the `-T` version, while the test still isn't atomic (i.e. imagine a test-and-create), it's been instructed not to follow the malicious symlink. On a pure POSIX system, the fix is either never create a symlinks where another account can write, or use a custom-made program instead of POSIX `ln`. 
vim is not a compiler, it's a text editor. The compiler you most likely use is gcc, this is also very likely to be the compiler you use in conjunction with Code::Blocks . Posting the code would help. Have you tried compiling with -Wall ?
a lot of segfaults I see tend to be related to pointers or memory allocation.
You...I like you
Trial and error You can read all the code that you want but that's where it really clicks. There were a few things that I read about but never really understood until I had to use them.
308?
Sorry, yeah that's what I meant, and yeah they are both using gcc. I can't post the code because it is for an assignment and would probably ly be considered cheating, and I'm on mobile
Certainly better than /r/learnprogramming :0
210.
Then you're not using the debugger to its full potential. Remember to compile with -g to get symbols and then use the debugger to investigate the crash. What address is being accessed? Is it being accessed for read, write or execute access? Do you get any call stack?
What are the types of those 2 things and what the compiler's error message?
Why not post it here for everyone to see and potentially learn from? 
I thought I posted the code.. apologies
as stated above, I thought I posted code, apologies
What are the compiler error messages? The 1st one should be line 28, since `BEmployee` isn't a defined type. Anything after that can be ignored until it's fixed.
What Channels?
I don't know dude, maybe a link to a pastebin or just put the relevant section right here, but at least for me I can't help with that description
Incompatible type assignment.. But BEmployee is defined as a type 
Not until line 47
glib is _much_ easier to use on linux. Once you've got that working, then you can try using it in windows again. I'd strongly recommend that you spend your time learning it in an environment where it fits in, instead of trying to shoehorn it on to a Windows system. Once you're more familiar with it, you'll probably have an easier time getting it working on windows.
I am currently working on a interactive shell for visualizing different data structures and algorithms using the curses library. This is mainly for me to practice concepts that I am currently learning from the book Algorithms by Sedgewick &amp; Wayne. Here is the link to the repository. https://github.com/siva82kb/C 
Okay, so show us that code. Your compiler error should include a line number for the error. At least show us the code at that line.
I'm currently working on a simple shell that handles IO redirection, some built-in, signal handling, and job control. It is more out of a need for class, but it is oddly fun. 
Honestly, none. I'm currently just trying to finish K&amp;R with its exercises.
I just skimmed your repository, but the code looks really clean and the project is interesting. Nice work!
I spent a few days this week writing a basic Snake clone. Here's a [gif](https://i.imgur.com/8vpN19e.gif) of it in action (it runs a bit slower than that, I think my gif recorder dropped some frames). Here's the source [repo](https://github.com/nerssi/snake) if you were curious. Now I've started version 2 (as a completely new project) with the knowledge I gained. It is structured and coded much better, and will be much more than just a clone! I've got some interesting gameplay ideas that I can't wait to implement. And sound, sprites, text, menus... It's gonna be fun!
I've done this before; have you done the DNS "compression" parsing yet? What a crazy bit of questionable protocol engineering. :) For extra fun, integrate the DNS server with a DHCP server.
[Pick one or two books from this excellent list.](http://stackoverflow.com/a/562377/253056) 
Yeah sorry, we can't solve your problem if you are so vague. Could you possibly make a [Minimal Completele Verifyable Example](http://stackoverflow.com/help/mcve) of your problem so we can look at that?
Reading through TLPI and doing the exercises.
Hi! Here is my output: /home/pacov/dev/include/plugin/plugin/plugin.h:67:36: erreur : ‘PluginInitFunction’ redeclared as different kind of symbol PLUGIN_API PluginExitFunction (* PluginInitFunction)(ApplicationFunctions const * const applicationFunctions); ^ /home/pacov/dev/include/plugin/plugin/plugin.h:53:33: note : previous declaration of ‘PluginInitFunction’ was here typedef PluginExitFunction (* PluginInitFunction)(ApplicationFunctions const * const applicationFunctions); ^ I compile it with CMake and SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -W -Wall -Werror -pipe") SET(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} ${CMAKE_CXX_FLAGS}") In the end I would like to integrate (if possible) both Python and Haskell plugins to my work. That's why I look a bit more into details. Thanks in advance!
Looks like you are not compiling the same code I see on the site. Have you modified it?
Ok cool, I'll take a look at their course outlines. I asked, because just yesterday I was looking for courses that focused on networking. I've been interested in learning how switch vendors implement ASIC drivers etc. Routers are also interesting to me. Thanks!
I only renamed functions to make me more comfortable with the naming convention I use.
The really cool part about GAs is that if you follow the algorithm (pick the fittest, crossover, mutate) and your fitness function is correct, there is no "hopefully"about getting increased fitness with each generation. Convergence is not guaranteed, but progression is
Professionally, I develop a [Fortran integrated development environment](http://simplyfortran.com/) which is written in C (mostly). Recently, we've gone cross-platform, offering both Windows and GNU/Linux versions, and we're native on both platforms: Win32 on Windows, GTK+ 3 on GNU/Linux. In my spare time, I've been doing some light work on [Open Watcom](https://github.com/open-watcom/open-watcom-v2). In the past, I implemented all the missing C99 math functions in the runtime library, and I've fixed/added some Windows API stuff. Lately I've been trying to improve the Linux runtime library. I've just fixed the "clone()" interface as a precursor to attempting a pthreads implementation.
Could you take a look im staring blind on the problem and cant seem to find it. It is a wordfinder but it finds 2/4 of the words http://pastebin.com/y8i1P6kV I use the same input as i did before.
You typedef after the function implementation though. It technically doesn't exist as BEmployee yet EDIT: You also try to make a fixed array dynamic? char[] is different from char*
I am just starting to learn C and this is what I have found so far - **Books** * C Programming: A Modern Approach, second edition seems to be the "best" book for a beginner. * K&amp;R second edition is "the bible" but not all that beginner friendly. It is an excellent reference for the C90 language. The biggest reason to get K&amp;R for a beginner is to do all of the exercises in it. * Head First C looks to be very good if you enjoy the Head First informal style. It covers more than just the core C language with things such as networking and threading. It isn't for a total beginner in that it expects some programming experience. * 21st Century C, second edition seems to be well liked for the most part. The first edition had some negative comments but these seem to be addressed in the second edition. It is something to be read when you are more comfortable with the language. * Understanding and using C Pointers seems to be "the bible" for really understanding all the little bits regarding pointers and ways they can be used. Also of mention should be Beej's guides. They are *fantastic*. The networking in C guide is probably one of the best guides available. Highly recommended! **Videos** CS50 is a very good online course. It is linked in the sidebar. I like Derek Banas' C videos on YouTube although not everyone does. **Reference resources** I *love* http://en.cppreference.com/w/c It is so good. I also use Zeal which is an offline documentation browser available for Windows, OS X and Linux. It has docsets for so much stuff, check it out! **Compilers** (mostly for Windows, on Linux use GCC or Clang) * TDM-GCC is a widely used build of MinGW-W64 and some related tools (gdb, the GNU debugger for example). It is a graphical installer for the command line GCC tools and MinGW-W64 implementation. * nuwen.net MinGW build is slightly more bleeding-edge than TDM. It is a personal build by /u/STL who is a Microsoft STL (C++) developer. He updates it often and it is widely used and respected in the /r/cpp community. It comes with a handful of C++ libraries and tools however it can be used just fine for C. * Pelles C is a Windows only C toolchain with a stable but not feature-full IDE. It is very nice for a beginner though. * Code::Blocks is a very well known C and C++ IDE with support for loads of things on all the major platforms. It can be a little "rough around the edges" but it is stable and widely used. Nice that it works on Windows, OS X and Linux as well. * Qt Creator is mostly aimed for Qt/C++ development but it works well for C as well. It isn't quite as "big" as Visual Studio but has some nice features. It looks and works a little "weird" compared to everything else but it is very good and free in the open source version. * Visual Studio 2015 Community is a freeware (with some restrictions but nothing a home developer needs to worry about) version of Microsoft's development beast that is Visual Studio. The C++ compiler supports C99 (or at least nearly all of it I think?). The debugger is very good although it might be a little "too much" for a beginner to get to grips with. **Editors** I personally use Sublime Text as I have a license for it and I am used to it however you can also use things like Notepad++, Notepad2, Atom, etc. Pretty much every "programmers" editor has support for C syntax highlighting and some offer build systems to make basic compilation easier. Some will say use Vim or Emacs and that is great if you already know them but if you don't just stick to something easier rather than overload your brain with learning a complicated new editor as well as C at the same time! **Windows? Linux? What?!** A lot of people prefer Linux over Windows when developing with C. This is usually because Windows isn't quite as nice as Linux for C development. Microsoft's own tools have kind of forgotten about C in favour of C++ whereas C is king in the Linux world. Generally it is just easier to work with C on Linux compared to Windows. I am of the opinion that if you are happier on Windows then just stick with it and deal with some of the weirdness you will encounter. You won't be the first person to hit these problems so you will most likely find a solution within a few minutes of searching. It is annoying but such is life. If you want to give Linux a try then you can either run it in a virtual machine such as VirtualBox or dual-boot. All the main Linux distro installers will make dual-booting easy. I personally dual-boot Windows 10 and Ubuntu 15.10 and it all works fine. I work in both often though and do find things a little smoother in Ubuntu. I could work just fine in Windows only though so don't feel you *can't* do C on Windows, you can it is just a little weird at times. Hope that helps :)
Thanks!
 if (chainage &gt; 190 &amp; chainage &lt;= 662) { Also, replace these with two ampersands. Single ampersands are a bitwise AND operation, two are a logical AND. EDIT: Also, you might want to use `else if` statements instead. EDIT EDIT: Also, you need to remove the ampersands from the variables in your print statements, otherwise you're printing the variables' addresses. printf("%d m is the datum at %d m", &amp;datum, &amp;chainage);
Your code alignment is awful. Please reindent so it is readable.
`show()` returns a pointer to a variable whose life has ended, a so-called dangling pointer. You invoke undefined behavior by dereferencing the returned pointer, which means anything can happen — data corruption, random crashes, etc. And yes, your indentation is atrocious and needs to be fixed. 
It's not that you've done anything wrong with the sub-specific formatting, but you aren't consistent in how many spaces you use to indent in the code itself Some things are indented, some aren't, some are indented inconsistently, etc.
Beginner error... Many thanks!!
You can only have one function named main() in a program (Same for any function). You have two or more.
This looks like a linking error, not a compiling error. Check to make sure any libraries you're linking into the code do not have a main() function
We need more information, like what's in the makefile and maybe the file main.c
I haven't done this for a while, so you have to hold me a little by the hand here. Where do I find the link command line when compiling via console?
the makefile: http://pastebin.com/4jJcywsv main.c: http://pastebin.com/J639W0sh
 cc $(CFLAGS) main.o $(OBJS) $(OBJS) already has main.o in it. You can remove `main.o` from this line. Also main ~~should~~ must be `int main`, not `void main`
That did it! It compiled now! Thank you so much! That really saved me some trouble just now.
Let's pin this for a week or so.
&gt;The C language is very good at doing exactly what you say. Just on a bit of a tangent: do you think this was a good design decision? I read there are 191 kinds of undefined behavior in C99. Why did they allow this? Are there any benefits for having so many ways to mess up your code? Edit: I just want to add that I started programming in earnest about 8 months ago and these are honest questions, not an attempt to put down C.
It's to allow compliant C compilers for different architectures, like an 18-bit 1's complement computer with 9-bit chars to be written (not that such an architecture is common now, but it once was). Undefined behavior can also give compilers latitude when it comes to aggressive optimizations. Also, the were many C compilers in existence when it was standardized in 1989, and many of the implementation details (like whether a bare 'char' declaration is signed or unsigned) were different from compiler to compiler so as a compromise, some stuff was left to the compilers to define. Basically, forty years of history. 
A big part is that there's nothing extra happening behind the scenes. Let's look at Java as an example. In Java, if you try to access out of bounds of an array, you get an exception. For that to happen, every time you access an array element, it has to check that the index is valid. C, on the other hand, assumes you're not going to try to access out of bounds of an array. Accessing an array element in Java requires your computer to read the array length from memory and compare that to the index before it goes and computes the memory location of that element and retrieves it. Accessing an array element in C just requires your computer to compute the memory location and get it. That's basically half the work. 
exactly! much easier for the developer to handle...
I can't tell if you are being /s or are really considering this easier.
I guess that's not untrue, but... if it's 2d, is there any reason to use that kind of character?
I really think that sprites are much easier for a developer to handle. With 2d spritesheets, you're basically copying a block of memory (the current frame) to the screen. With true 3d, you have to convert the 3d coordinates of each vertex to the 2d screen coordinates, determine which surfaces are (partially) hidden by others, shadows etc.
I'm not a expert at all so take any thing I say with a grain of salt. Using a raspberry pi I did ADC and I would take 4 samples and includ the previous result and average them together. If you are expecting your data to slowly go up and down you can average your samples with with the previous reading.
You can use a simple recursive (IIR) filter, like this: y = k * x + (1.0 - k) * y; where x is the latest input sample and y is the filtered value. k is the time constant, which determines how much smoothing you have - it's typically a small value, e.g. 0.1. Be sure to initialise y to 0 before you start filtering. The advantage of this type of filter is that it requires no additional storage other than the last filtered value, and it has low latency (you don't need to wait for N samples). It's also very simple to implement, as you can see. See [this answer on StackOverflow](http://stackoverflow.com/a/2272556/253056) for more details. 
Oh look, a spammer. Buy some targeted ads if you want to tell people about this.
This doesn't seem to be related to C programming. Putting “for your next C game” in the title does not necessarily establish a relationship to C programming. I removed this post for being off-topic.
While I personally haven't read it, I've always heard good things about [Pointers on C](http://www.amazon.com/Pointers-C-Kenneth-Reek/dp/0673999866). It covers pointers a lot more than K&amp;R, and pointers are a pretty big deal in C.
21st Century C is pretty decent.
I recommend "Expert C Programming: Deep C Secrets". It is a great book for learning why things are like they are and how to avoid pitfalls. It is also available for free (just google it).
"C Traps and Pitfalls" is a short and fun read. It's more of a what not to do book.
Modern C by Jens Gusdest (spelling?) is wonderful, and not that long a read either.
Maybe a bit out of context but if you're on a Linux machine "The Linux Programming Interface" is an incredible book. Yes you will learn the Linux interface but more importantly you will get real world experience writing C if you follow the samples and do the suggested exercises.
Professionally embedded automotive, mostly BLDC controllers on CAN. If I had personal time I'd probably work on some Android apps (sorry, not C).
$130.00 US? Anyone wanna spot me this book for a month or two?
You can take a look at this list: https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
If you re not worried about the science behind it and you can use the standard library within microchip's mplab the have a look at 'liquid dsp' project. [take your pick of filters](https://github.com/jgaeddert/liquid-dsp/blob/master/src/filter/src/) 
This isn't a private homework solution forum. Post your code for others to read and learn from or this post will be removed. 
Uhm... I'll review your code for a $1 a line. Otherwise post it publicly so everyone can benefit.
You have the wrong number of `=` on line 26 Or post the code if you want a real answer.
Please consider posting your code directly. Asking for a PM is bad style.
if the .c files of the .h files are not in the machine how can the programs run?? 
Yes, that was my initial intention, but I wanted to know and try other methods as well.
C
Linux / Unix operating systems might be the way to go if you want to make C programmes. Linux comes with a compiler called GCC and is easy to use.
.. u srs rn? Really though, this looks like you literally copy pasted your homework without even attempting to try it first, and didn't even try to hide it. Spend some time on Google. 
In practice, I believe so. In IEEE 754 format, 0.25 can be represented exactly, as can 0.5, 0.75, and 1.0, so there's no reason this wouldn't hold true. But from a pedantic language point of view, I don't think this result is guaranteed at all. I would also be very careful about drawing a general conclusion beyond this specific example.
Follow up question. Let's say the only thing I care about is that `i == 1` after 4 additions to `d`, and I have no idea if I'm using IEEE 754 floating-points. Will this guarantee the result? double d = 0.0; d += 0.251; d += 0.251; d += 0.251; d += 0.251; int i = (int) d;
Up vote for C: A Reference Manual. Always to hand and always provides the answer. 
You almost certainly are. All the main CPUs use it. If you really need to know for sure, your compiler may help. GCC has a preprocessor macro __GCC_IEC_559 that is non-zero if IEE754 is used
Why not just round your result instead: int i = (int) (d + 0.5);
You're virtually guaranteed to be using IEEE 754 floating point numbers unless you're using something from a computer museum. A number is exactly representable if it can be expressed as X/2^(N) where both X and N are integers. (There are specific limits to X and N but I don't feel like figuring out exactly what they are. For double precision, they're roughly -2^(53) &lt; X &lt; 2^(53) and -1024 &lt; N &lt; 1024.) 0.25 is 1/2^(2) and consequently has an exact representation. But 0.1 for example does not. The closest approximation (again, assuming double precision) is 3602879701896397 / 2^(55) which is 0.1000000000000000055511151231257827021181583404541015625. That's the actual value you're working with if you ever write `0.1` in source code. All representable numbers end in a 5 digit, btw.
Can you work in fixed point instead? 
Have you checked the one in the sidebar? I feel that "The C Programming Language" is good for people who have prior higher level programming experience, even though you may find the first few exercises trivial.
Please read the sidebar, among the other post here on the front page asking the same thing. I'll leave this up for ~2hr and then take it down so you can get a few more links. As to properly answer your question, if it's just syntax you want to learn, cplusplus.com has great references for the C standard library. Book wise I suggest KN king followed by 21st century C, or possibly K&amp;R if you happen to have a copy near you. Harvard's CS50 course seems to be popular among some of the new users here also. 
Please fix your formatting (your include and comments)
Yes, much better. Thank you.
The wiki page (and references therin) is pretty good: https://en.wikipedia.org/wiki/Fixed-point_arithmetic as is : http://www-inst.eecs.berkeley.edu/~cs61c/sp06/handout/fixedpt.html so for example if you have a "Q24", that would represent 0.25 as 0x00400000, and four of those add up exactly to get 0x01000000, which is 1. 
Thank you for your help. so when shifting right (crc &gt;&gt; 1 or data &gt;&gt;= 1) that is the same as dividing (by 2) correct? And that is what is shrinking the data down to fit into the 16bit checksum value? 
C Interfaces and Implementations is one book that was most directly useful to me, it provided data structures that are essential but not in the standard library.
This one is real hard to find though I've heard a lot of praise
One of the largest reasons I don't read this forum frequently is because it feels like more than half the posts are people asking for help with their homework. Worse still... the questions are often *extremely* simple, easily solved with some googling. There is a reason myself and other c programmers avoid this sub, and it's because there is truly a lack of quality content.
The k and the 1-k terms are the other way round on the StackOverflow post - it's effectively the same thing though, so k is a small value in the expression above, whereas. 1-k is a small value in the StackOverflow example.
I seriously doubt that you can get that level of low-level access without being in a device driver on any modern OS. That is exactly the kind of fun thing you could do in MSDOS when you had no real multitasking and full control of the hardware but that makes no sense when multiple applications are trying to live peacefully together. So I bet you need to find a device driver to talk through to get to the serial port and allow you to control it (if one exists). Or run some other operating system like FreeDOS. Or get a Raspberry PI or some other system (an Arduino perhaps) made for low-level control and hook that up to the Windows computer through USB.
indeed linux is being considered as well. The program is javafx ui, so it's portable. What I find kind of weird, that the pascal or DOS-compiled program work fine in Windows 7. I would expect that windows would kill the process that is accessing hw in this manner
It's a bit more complex. Windows has a ton of subsystems, one of them emulates DOS. Device accesses in DOS code are caught and then sent through to the appropriate drivers.
Read K&amp;R once again, believe me, there is a lot that you have missed first time around and a lot will click way better now that you know more about the language. In parallel, you can start reading already mentioned "Expert C Programming" which is fun and clever read. If you are serious about programming in C, be sure to get yourself the "C: A Reference Manual", which is a much better reference than K&amp;R. comp.lang.c FAQ mentioned in the sidebar is also a great resource, definitely check that out. You will also benefit greatly by reading up on classic algorithms and data structures used in every program out there. For that I can highly recommend [Algorithms in C](http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structures/dp/0201314525) by Sedgewick. Make sure to at least read the introductions to the basic idea of algorithms and data structures presented there. But most importantly, if you want to really learn C and programming, start making real programs and start reading code that is used in real world. Pick a library/libraries that you find exciting and try to employ it to help you make a program that is useful to you in some way. Pick a moderately complex project and try to improve it in some way useful to you. Really do anything outside of contrived examples presented in most books, solve your own problems. This is where you will learn the most and no book can give you the kind of knowledge you will get by making your own mistakes and learning from them! Be patient, there is a *lot* to learn, and good luck.
You don't even need to be root to get this permission. You just need to have the `CAP_SYS_RAWIO` capability. Basically, an x86 CPU has a bit mask for the ports you are allowed to access. The `ioperm` system call allows you to manipulate that bit mask. If you fear a device driver might interfere with your code, why not unload the affected device driver while you manipulate the hardware?
Yeah, but I didn't say that because technically any non-repeating decimal number can end in a zero, e.g. `0.1` is the same as `0.10`. I guess I need a better way of expressing that. 
Here is a compact version: [http://pastebin.com/BTCKV9s5](http://pastebin.com/BTCKV9s5). Avoid using multiple switches/ifs like that, it leads to spaghetti code and it's very hard to make changes. What if you have change a particular rate? Then you'd have to go all the way down to the correct branch just to do that.
Oh, I actually do have one more question. &gt; &gt; How to get my grandTotal variable to work properly. &gt; &gt; Initialize `grandTotal` to 0.0 at the start of the program. &gt; &gt; Every time you go through the loop, update it. I would do this just after line 110 or 116. &gt; &gt; grandTotal += totalBill; Why/how does this work? I can't wrap my head around the logic. lines 110 and 116 are both within the `while(!finished)` loop, so I was worried that putting `grandTotal` within the loop would cause problems, because the totalBill variable gets overwritten with each loop, right? I was thinking that `grandTotal += totalBill` would only ever equal 0.00 + whatever the latest `totalBill` was. However, I'm wrong of course, because your suggestion works just fine (I set the very last `case 1:` around line 137 to contain `finished = 0`, even though I'm not sure it was necessary, as I mentioned in the other comment). I just don't understand why/how it works.
The `+=` notation is equivalent to the following command: `grandTotal = grandTotal + totalBill;` The first time you reach this statement, `grandTotal` will be 0.0 so you'll end up with: `grandTotal = 0.0 + totalBill;` If `totalBill` in the first case is 10.5, you'll have: `grandTotal = 0.0 + 10.5;` Which results in: `grandTotal = 10.5;` The next time you reach that loop, with e.g. `totalBill == 20.3`, you'll have: `grandTotal = grandTotal + totalBill` `grandTotal = 10.5 + 20.3` `grandTotal = 30.8` This will continue for each loop, always increasing the value of grandTotal 
http://web.archive.org/web/20130105120307/http://www.antlr.org/wiki/display/CS652/How+To+Read+C+Declarations
Haha, that does look a lot more compact. We're learning `do while`s next week, so not 100% sure how they work yet. Also noticed a few other things in your compact version that I do not (yet) understand. But that's very helpful for later use when I have a bit more experience, so thank you! You chopped off more than two-thirds of the lines. But for now, I'll stick with the spaghetti code; it's probably all that's expected at this point for this assignment.
I see, well feel free to use whatever version you find the most comfortable.
Don't call callbacks. That's nasty to program with. If you cannot operate due to an OOM condition, return an error code from your library function. Then the program can react as it wants.
Again, it was just a quick example as it's not even started yet. I plan on using this in a memory pool (which may, or may not be necessary, but that's another story). I'm just curious as to whether or not there's better ways to handle this.
Thanks for the feedback. What makes it nasty in this situation? Just wondering so I can avoid it in the future.
The callback doesn't have the context of the caller. It can't know what has already been done by the program. It's much easier to gracefully handle error conditions in the code that calls into you library as that code knows what it did before and what needs to be done to handle the error. An OOM condition isn't automatically a fatal error. Programs can react gracefully to such a condition, e.g. by freeing unneeded data structures or choosing a different algorithm. If your library only calls a callback on OOM, it's almost impossible to do any of these things as you don't know where you called into the library. The only meaningful thing a callback can do is terminating the program. While that's good enough for many applications, your library shouldn't restrict usage to just those scenarios where OOM is a fatal error.
Oh please don't use memory pools unless you measured that they give a significant benefit. Memory pools inhibit debugging tools like valgrind and can become a major security problem. Be careful what you trade them for.
But if you need C++ features, we have C++ for that. The only reason most people have for choosing C over C++ nowadays is because they specifically want the simpler language and the more explicit code, so purposefully trying to complicate the semantics like this seems counterintuitive. Nevermind that ISO C cannot do this -- was never designed to do this! -- and this relies on a vendor-specific language extension that would not work on any other compilers.
Note that on modern systems malloc may not return NULL in out of memory situations. The kernel overcommits and allocates pages just as needed. For the programmer there is not way to handle this 'gacefully'.
That's actually pretty cool, I'm glad it exists then, that implementation actually looks pretty simple and easy to use, and very powerful. I especially like how he's returning a pointer to what's inside of the struct so he can easily get the original struct by using simple pointer arithmetic. Genius. I always wanted to recreate a memory allocator, and this definitely seems like the way I'd do it, too.
 double mode[sizeof((double)maxCount)]; This isn't your bug, but it is incorrect. sizeof(double) is a constant. printf(" %.3lf ", &amp;mode[i]); You bug is on this line.
Alright, so should I just be changing it to `double mode[sizeof(maxCount)];` Also as for the bug, unfortunately I have no clue as to what it actually could be
 double mode[maxCount] Makes an array that can hold maxCount doubles. No sizeof needed in C++. &amp;mode[i] is the address of the number, not the number itself.
Bingo. As for your expressions must be a constant issue, it sounds like whatever compiler you are using is in the ANSI C standard, as it does not support variable length arrays. To fix this you can 1) use the modern standard with (for gcc) -std=c11. Or 2) use a preprocessor define for max count and pass that as the array length. 
Or 3 malloc, obviously...
I'm using Visual Studios, I'm assuming that the Visual Studios compiler is like that
I updated my code, it's still having issues if you wouldn't mind taking another look at it
Now you have switched to malloc, mode is a pointer so sizeof(mode)/sizeof(mode[0]) isn't the length of your array. You can use maxCount - this is the number of elements in the array
I did as you said and now my output is even worse I did a 10 element array, it's contents were, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9 and it printed mode(s) : &lt;2.000, 0.000&gt; Is the logic of my code even in the right ballpark of what I want it to do.
You're printing the address of mode[i] again near the end of your code... Edit: ignore, I looked at the old code. One moment while I write up a little logic for the problem
I don't understand why you would need to use `malloc`. You are calculating the size of the array with `maxCount`. Use that to initialize the mode array. double mode[maxCount]; Then, when you loop over your array later, all you need to do is keep i below the maxCount. for (int i = 0; i &lt; maxCount; i++) And use `mode[i]` in the `printf` statement. printf(" %.3lf ", mode[i]); 
[here](http://pastebin.com/3m446CB5) is an incredibly inefficient implementation of finding the mode of a given list, and only one of the modes if there are more than one. If you still are having problems, try to follow the logic of this code and tighten some of the low hanging optimizations that can be done like finding the unique elements of a first. Hopefully that will help
I actually meant to have the condition as scanf("%d",&amp;i) != -1, but that's still wrong. What I wanted to do is check the value of 'i' with -1. Now I realise that I have to set the variable before running check. Thanks for the help! Slowly getting more used to C :)
Thank you, I know that writing the code with separate functions is better but I forgot to tell that I have to make it only with main(). 
Keep in mind that the scanf() function can do more than read into variables. Here's a version of the program : [http://pastebin.com/7iM6Bxc1](http://pastebin.com/7iM6Bxc1) that tries to read as many numbers from input as possible until -1 or EOF is reached.
You didn't post enough code to give a useful answer... How about a link to where this came from? 
(not (x less than or equal to (n divided by 2)) So if n is 10 and x is 6 you get !(6 &lt;= 5) 6 &lt;= 5 is false so not false is true so (!(6&lt;=5) = true 
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main() { int x; int n; scanf("%d", &amp;n); if(n&gt;=2) for(x=2; x &lt;= n/2; x++) if((n%x)==0) break; if(n&lt;1 || n&gt; 100){ printf("The number %d is outside the range [1;100].\n ", n); }else if (n&gt;1 &amp;&amp; (!(x&lt;=n/2))){ printf("The number %d is a prime number.\n" ,n); } else{ printf("The number %d is not a prime number.\n", n); } return 0; }
Thanks :)
It uses modulo to test if n is divisible by x. If n%x is 0 then it's divisible and not prime. We only need to test x's up to 1/2 of n because anything higher is guaranteed to have a remainder. So when we're done testing x's we test to see if we exhausted the list of possible x's. If we've incremented x to a value greater than the maximum possible value of n/2 we must have been unable to a find divisor that works, therefore the number is prime.
Thanks a million I just couldn't get my head around it. It's only my first day doing loops and we were kinda thrown in at the deep end with no applicable explanations
ty
Try looking into [fopen](http://linux.die.net/man/3/fopen) and [fgets](http://linux.die.net/man/3/fgets). `fgets` works like `gets`, but reads data from a file you opened with `fopen`.
Please post the code you have tried, so that we can look into what is not working.
You shouldn't be using gets now, use fgets with the file that fopen returned to you. Your error checking is wrong too, by the way. You should check if FILE returned by fopen is NULL or not right after calling it.
And... which is the error or problem you encounter? I'd say for a start that you'll have troubles with your `recs` and `db-&gt;recs`: when you do `recs=realloc(recs,...)`, you update the `recs` pointer but not the `db-&gt;recs` pointer. So `db-&gt;recs` will always refer the address and space that was allocated with the first `malloc()`... You can get rid of your `recs` variable in your function and use straight `db-&gt;recs` instead, for the `malloc()` and also the `realloc()`.
Another problem that would have been easier to spot if using the idiom `realloc(p, N * sizeof(*p))` 
It would be a good idea to check for malloc failure, especially in the second one where you read the size from the file. (Reading a uint32_t like that is non-portable) 
Nope, it should be: db-&gt;recs = realloc(db-&gt;recs, sizeof(struct record) * db-&gt;num); or: recs = realloc(recs, sizeof(struct record) * db-&gt;num); db-&gt;recs=recs; but not a mix of both, which would just work one more time than the original listing and fail after the second iteration.
I fail to see how.
That's the main reason why I wanted the King book because there were some parts in the K&amp;R book that I thought could have been explained in a bit more detail. C is my first real programming language so it would be nice to go over a few more books targeted at beginner level before moving on to more advanced topics. 
I took a lot of notes, but I will probably re-read it though in the near future just to get it to sink in a bit more. The algorithms book sounds good so I might look into that one, thanks. 
I like the look of C: A Reference Manual so I might get that one as well, thanks. 
Pedantically (and/or if you care about being able to clean up after an error) you should assign the result of `realloc` to a temporary variable in case `NULL` is returned, otherwise you lose the original pointer and can never give it to `free`.
You can also redirect the stdin/stdout when calling the program: cword.exe &lt; in.txt &gt; out.txt This puts the burden of opening the files on the shell, instead of the program.To the program everything is the same as before, there is not way for it to tell where stdin comes from (keyboard or file).
Not “on modern systems,” only Linux is that braindead to overcommit by default.
I wrote a terminal tetris game some time ago and had to solve the same problem. I extracted the relevant parts here: http://pastebin.com/0si2TU8G. 
Yeah, I was just kinda raging in this post, but what you said it's true. It's very easy to just blame the compiler instead of looking for errors. I'm doing pretty well in setting up my codes, but very often the problem comes from a function from string.h/stdlib.h that I don't know how to properly use.
Still no luck. You thought I'd give up, didn't you?
The correct type of pointer for making a table nxm with malloc is 'int (*p)[m]', not 'int * *p' this is used to refer to an array of pointers to int.The function "createtable" should return a pointer of this type, the declaration for the function is: int (*createtable(int,int))[]; Here's the fixed code : [http://pastebin.com/18dwBJHX](http://pastebin.com/18dwBJHX). There are some things that you should take care of though: don't ignore the result of scanf for one thing.
Thank you, and yeah I've never gained a proper grasp on pointers. I'm actually surprised that I was at least somewhat on the right track. Comparing your code to my original is helping me to start to understand it more. Oh and I wasn't ignoring the results of the scanf, that K value is meant to be used later on in the assignment (it's the total number of potential colors). Appreciate the help! Now I got to work on the recursion part.
The FreeBSD kernel supports overcommitting, but it's turned off by default as to not compromise system stability. That's why I said “only Linux is that braindead to overcommit *by default.*” I suppose OS X and HP/UX also don't overcommit by default.
&gt;Makefile This. Shell scripts don't scale well. Learning to write them yourself is something you should endeavor to do but ultimately I recommend a Makefile generation program like Premake.
OK - So I deliberately don't use typdefs with structs as a kernel developer I know told me you should never do it, because it hides type information. I don't know if this is sage advice or just preference. As for the `make` part, I know how to use makefiles, but generally I use a shell script until the program has grown a little bit. Once the necessity arises I'll make a proper makefile.
I've never used a makefile generator - I may have to look into this. As to not having a makefile currently, see above. It's just something I do when the program is first born.
Thanks for the link - I'll give it a read. As for the passing using pointers, the reason I'm not doing this is so that the original struct isn't modified and a new one is returned. I prefer the idea of keeping the data structures immutable, though perhaps it might be inefficient?
You can indicate that using `const`, but again, it depends on how you want to design the API.
I agree that doing something like `typedef unsigned int counter_t` is silly. However, I don't have a problem with `typedef struct foo foo_t` (yes I know `_t` is 'reserved' for kernel stuff) if it makes the code more readable. At the end of the day, it's a personal preference, and doesn't matter as long as you're consistent with the existing code base (and if there isn't one, then yourself).
Not sure if your "include" policy was intentional but seems good according to http://stackoverflow.com/questions/1804486/should-i-use-include-in-headers
Using a pointer to a const struct would prevent you from being able to do that. I think the way you're doing it now is actually quite nice. Taking the struct by value is good for a few reasons: 1. It's simple. This is always good. 2. It makes it very clear that the caller's struct won't be modified 3. You never have to worry about being passed a null pointer
typedef has its place when working with declarations that are nuisance to use all the time. For example instead of typing : int (*foo(...))[] //function that returns pointer to a row of integers It would be more natural to do the following: typedef int (*introw_t)[]; //typedef a pointer to array of int introw_t f(...); //function that returns a pointer to a row of ints: a 2D matrix Or function pointers for example : typedef int (*cmpFun)(const void *,const void *); //type of comparison function used by qsort So now you can do: qsort(v,len,sizeof(char*),(cmpFun) f); //sorting an array of strings The function f can now be declared as : int f(char **a,char **b){ return strcmp(*a,*b); } Instead of doing those pointer typecasts in f.
Depends on what exactly you want to program. Games programming is wildly different from systems programming is wildly different to driver programming is wildly different to... Yes, there will be a lot of overlap, but there are still lots of sub-domains, each with their own domain-specific stuff.
Read through some big C projects. Glib/GTK for instance. Or Busybox or Sqlite. Or the Linux kernel. All good. Wine is good (and relavent) if you are stuck on Windows.
It is initializing the structure forcing a cast. I'm quite sure this is bad and you should initialize on declaration to prevent the cast AND maybe specify the field you are filling, so in case you are gonna change the struct you don't get crazy to find the old/new initialization. Edit: I'm wrong
pthread and the whole idea of multithreading 
hope is going to give some good base to understand how to organize things.
No. That's not what is happening. There is no cast, this is *compund literal* syntax.
Pick a random piece of hardware, attempt to write a driver for it.
A good book is *21st century C.*
Never thought about this - thanks for the tip.
I disagree. I can't think of an instance of a use of typedef outside of standard or language implementation that doesn't make things trickier.
This was good advice.
Agreed. His `BOOL` is not 100% compatible with `&lt;stdbool.h&gt;` and isn't a good replacement. Definitely either use the actual `&lt;stdbool.h&gt;`, or just use an `int` and don't call it a bool.
Much appreciated, thanks!
Your use of structs to encapsulate state is... interesting. I suppose it makes sense, although since I have no idea what kind of math/simulation this code is doing, I'll have to take your word for it. The name `GSSADef` is odd since you always call it `system`. Should it not be named `GSSASystem`? You have `struct systemConf` (which you didn't put a `GSSA` in front of, I note) but you don't use it as an input parameter. Why the inconsistency? If it was good enough as a return type, it should be good enough as an input type, too. (Except that you seem to only use `systemConf.state` from the returned value, in which case why bother returning `systemConf.system` if you don't need it?) Your functions consume and return whole structs. C uses pass-by-value and return-by-value, so that means the whole struct has to be copied to/from the stack. It looks like you're going for a kind of pure/functional style of coding, where you don't mutate the arguments but instead return a fresh copy, but in C that involves a lot of memory I/O and isn't idiomatic. A stylistic complaint: I don't like the multiline printf. It may be slightly more efficient, but that doesn't matter unless you're doing millions of them, and it's harder to read.
`static struct gps_data_t* data` isn't what you wanted to do. This is creating a file-local (`static`) variable in each file that includes that header. `static` has no place in a header file, since it means "file-local". If something is `static`, it doesn't need to be in a header file since it could never be used by anyone else anyway. Variable definitions in headers should be `extern`, which forces you to then choose a single file to provide the declaration of that variable (the *one* instance that isn't marked `extern` and will thus create storage space that gets associated with that variable name). In this case, you really just wanted a static variable in piGPS.c. Or just a regular variable in `main()`. I applaud you for being diligent with your function comment blocks, but... there's too much freaking information there, most of which doesn't belong. * Date - I can find that out from source control. * Revisions - I can find that out from source control. * Designer - I can find that out from source control, and/or I don't care. * Programmer - I can find that out from source control. * Source file - I know the name of the file I'm looking at because I clicked on it and it's displayed on my screen; no need to tell me again. * Function - I can scroll down and read the name of the function. No need to repeat it. * Interface - Good, although usually this is called "parameters". No need to repeat what the function declaration already says, though; I can scroll down and see the types of the arguments. All I need is the description of what they represent and how to use them. * Returns - No need to tell me if it returns `void`; I can scroll down and see that. Omit this unless the function actually returns something. * Notes - This is the important one to have, which you've done a good job with (except on `main()`). Normally it's called "description". You define constants for `QUIT` and `FAILED_TO_READ` and `FAILED_TO_OPEN`. These should be `#define`s in your header file, so that when I get back `1` from your function, I know what that value represents. `while(PIGS != FLY)` is funny, but not idiomatic. It would probably be confusing to anyone who doesn't speak English as a first language and doesn't know the saying. Just write `while(1)`.
On a 64 bit machine, pointers are 64 bits long. On a 32 bit machine, pointers are 32 bits long. You read a different amount of memory to read them correctly. The format strings do two things: tells printf how to format the memory and (the important one here) how much memory to read (or in the case of %n to write)
Yes, derp. fixed.
Sorry doesn't fix that you post a screenshot. Post the screenshot as text, there is an edit button below your post so you can edit that in. Don't forget to put four spaces in front of every line of code so its readable.
We need an actual testcase, not a snippet. Any number of things could be wrong. 
It is computing the remainder perfectly well; what it is not doing is calling any functions, because you forgot the argument lists.
Why do you think it is not computing the remainder? You could try printing it out to make sure it is calculating what you think it is. How many parameters does you printStars function want? How many are you giving it? 
 printStars; This isn't calling printStars with the parameter n. It's not calling the function at all. To call a function you need `()` SomeFunc(); // call a function that takes no arguments printStars(n); // call a function that takes 1 argument, --- Once you've called printStars(n) with the correct argument, you'll need to make printStars use it. At the moment it prints 1 star, regardless of the value of `n`. You will need to use `n` in a loop 
Good point. I tend to forget about inline functions because I don't use them much in my job.
There are a few ways you could go about this; I would either use an output parameter or return a tuple. // the user passes in a pointer-to-pointer that you will point at the array, and you return the size size_t output_param_mode (double *input, size_t size, double **output) { /* . . . */ *output = num_modes ? malloc (num_modes * sizeof(double)) : NULL; // fill *output with the modes return num_modes; } -- or -- struct mode_info { double *modes; size_t size; }; // the function returns a structure that contains a pointer to the array as well as its size struct mode_info array_tuple_mode (double *input, size_t size) { /* . . . */ return { .modes = array_of_modes, .size = num_modes }; }
So basically it looks for an array with the same name and points to it?
No, you tell it where to point. At the end of `findMode`, you have an array containing all of the modes, right? You just make `*output` point to that array and then return the number of modes you found. That's it. Then, because the caller supplied that pointer, he now has access to that array and its size (the return value). Edit: What you figured out on your own won't work in general, because how is the caller supposed to know how many modes are in the array it returns? One? Fifty? None? You need some way of reporting both the array and its size.
&gt; I was trying to figure out how to do this loop and could not do it. Show us what you've tried and we can go from there. As a general rule of thumb, if you want a loop that runs N times, you should start with the pattern: for(int i = 0; i &lt; N; i++) { ... } The important parts are that the loop variable starts at 0, and that it's compared against N using less-than. That results in a loop that runs N times, and that is the idiomatic way of writing such a loop. Try to avoid other forms, such as starting at 1, or using less-than-or-equals. It's of course possible to write such loops correctly, but it requires more thought and it's very easy to get wrong. 
Noted. The reason I do the date/revisions/designer/programmer/source file in the comment headers is because that's what I was taught. My teacher was a software architect on multiple teams, and he insists on doing that, so it's become a habit of mine. I do suppose though that he was doing that in the industry way before source control/git were a thing (he has been an instructor for 25 years), so perhaps that's why he goes overkill with it. I'll switch to just the important parts (parameter description, return description when there is one &amp; notes). Thanks for your feedback!
Thanks, it's appreciated :)
Whoops, I've completely changed my reply to this because some new things came up. My bad. And kinda, we did learn about it in class but I haven't been able to 100% wrap my head around it yet
The easiest way is to look up 'for' loops.
What is 'n' set to? And `$` can't be assigned like that. In any case, think about the condition of that while loop. `i == n` will never be true since you just set i equal to 0 and n is presumably the number of times you want to loop. Your loop runs zero times. 
 if ((double)size / max != uniqueNum) { double *mode = malloc(maxCount); //makes the mode array the right size to store all the modes number = a[0]; for (unsigned i = 1; i &lt; size; ++i)//loop to determine what the modes are { if (number == a[i]) { ++count; //if the numbers the two numbers compared are the same, count is increased by 1 } else { if (count == max) { mode[elementNum] = a[i - 1]; ++elementNum; } //Count is set back to 1 as we are counting a different number count = 1; number = a[i]; } } return mode; } else { double noMode[1]; noMode[0] = a[size] + 1; return noMode; } } There is an error here. You can't return a pointer to something that is not either allocated ( via malloc ), declared static ( which means that the value pointed to will change every time the function is called ), or a global ( same issue as static ). You should use malloc() even if you're only returning a pointer to one entry. You also need to figure out how to tell the callee how long your array is. This would be a good candidate for a struct like: typedef struct { unsigned int size; double *value; } tDoubleArray; Now you can allocate tDoubleArray and allocate the values. The caller knows exactly how long the array is and can free both it and the pointer.
&gt; I do suppose though that he was doing that in the industry way before source control/git were a thing (he has been an instructor for 25 years) Hmm. I suppose 25 years ago, CVS was relatively new and probably not widely known or used. But that's no excuse. If he's going to teach programming or software engineering, he needs to get with the times. There's no need to maintain 25-year-old practices when we have other options that are objectively better in every respect. Ultimately, you don't always get a choice. If your schoolwork requires a certain coding standard or commenting format, you do that because you have to. If the project you're contributing to, be it closed- or open-source, requires a certain coding standard or commenting format, you do that because you have to. But, when you go around asking for opinions about style, opinions is what you get, and my opinion is that large comment blocks aren't helpful. Since they contribute *nothing at all* to the functioning of the code, there's very little incentive to maintain them, so you want to make it as easy as possible lest others (or yourself) get tempted to skip it. Giant blocks that get people in the habit of scrolling past them to get to the body of the function are bad. Information that has no relevance to understanding the code (such as authorship) is bad. Information that could be found easily and in more detail through other means (such as revision history) is bad. Duplicated information that requires pointless repetition and could get out of sync with the code it's documenting (such as the filename or function name or types of parameters) is bad. (By the way, the principles are what's important here, not the exact rules. Those may change with the project or language. In weakly-typed languages like Lisp or Python, commenting the types of function parameters can be essential, because there's no other way to know it. But in C, where the languages requires you to explicitly state the types of function parameters? There's nothing gained from also putting them in comments, and it just takes more time and effort to maintain.)
Look at the "noMode" case. You can't return that.
Please post your complete code, and tell us what is not working. Do you get a compilation error? Does it not execute the other program? Does it crash?
Avoid `gethostbyname`, which is no longer POSIX, and instead use `getaddrinfo`, which has the added benefit of being address family agnostic (if the hostname resolves to an IPv6 address only, then yours will fail). Also, you check for the number of supplied arguments *after* already attempting to use two of them. The check should be moved up. If you don't want "external dependencies" then just statically link the required libraries.
You are using `execv` incorrectly. Here is what the man page says: &gt; ... The execv(), execvp(), and execvpe() functions provide an array of pointers to null-terminated strings that represent the argument list available to the new program. The first argument, by convention, should point to the filename associated with the file being executed. The array of pointers must be terminated by a null pointer. What is inside the `proc` you are giving it? Since you are not passing any arguments, the second pointer in `proc` should be a NULL pointer as noted in the docs, but you are giving it something else.
Well since i have to be able to run it on background if i tell it to I thought i could use the prog[1] to put an &amp; to run it on background. If i wanted to run it without args i thought at least it had to have `./exec` or `exec` on prog[0] 
I removed the post as the link has no relationship to the body of your post and is not related to C programming either. Lastly, I can guarantee you, asking others to implement something for you is not going to have an amicable result for you.
&gt;Out of interest how would one get into driver programming? It helps to have a background in electronics, since much of the time you're fiddling with bits in hardware registers.
Learn a real assembly language, such as x86 or ARM. Study the compiler's assembly output for your C programs at different optimization levels. Observe how various C concepts map onto the underlying hardware. Write assembly code that interacts with C code. Make it complicated enough that the compiler's optimizer starts giving you problems, then figure out how to fix it. Learn how threads interact at this level. Try making your own raw system calls. Learn how shared / dynamically linked libraries work, what visibility, exports, and imports mean. Study how your programs and libraries are loaded and linked. Experiment with hot patching. Try writing some C programs without a libc. 
As a newbie myself I would be interested how you solve this problem. Its certainly been helpful to look through and trying and understand it. 
In place of snprintf? The data is integers stored in an array, it has to be formatted to a string first.
You should post the code that has the declarations for that array as well then, since I assumed it was characters. 
&gt; What could I possibly be doing wrong here? Taking a screenshot of your code is one of them. Just paste the code into pastebin, or paste it straight into your Reddit post (remember to indent each line with four spaces though). It's a lot easier for people to help if they are able to copy and paste your code and/or run it themselves.
Do not post code as images! Post text.
This depends completely on the logic of the code block in question.
A good alternative is `strlcpy` but due to Ulrich Drepper's idiocy it hasn't been adopted by the glibc. 
Oh I didn't actually have char_printed in there at all to begin with, I was just using it to check what value it would be assigned when snprintf returns for debugging reasons. It will be removed (or maybe used for error handling) once I have this figured out. It never gets set by snprintf, though -- and strcat is never called.
Spam ? I can only see a news site 
What does your current code look like? what isn't working with it?
&gt; My functions do copy by the stack a lot - I accept that this may be inefficient, but as you said I quite like the functional style. &gt; What would you say the preferred idiom would be? So, the thing with functional programming like that is that in a good functional language, when you pass around explicit state like that, the compiler can recognize that at each step you will gain a reference to the new state and lose the reference to the old state, and it can optimize based on that. To do that in C, the compiler would have to be very good with very strong interprocedural optimizations, which is pretty new and not too widespread yet. I'd say the most common idiom in C is to simply use mutable arguments and state. In your case, you'd have `void GSSAStep(struct GSSAState* state, const struct GSSADef* system)`. In that function, `state` would be an in-out parameter (it gets mutated, and that's how you get the result of the function) and `system` is only an in-parameter (it's a pointer to const struct, so it can't [easily] be modified by the function). The in-out argument has to be a pointer, because that's the only way it could be used to mutate the underlying struct to return a value. The in-argument is a pointer so that you don't have to memcpy so much data every time the function is called. The pointer indirection doesn't make it any slower, because CPU caches will make up for it. If you prefer a somewhat purer function, you could separate the in-out parameter. For that, you'd have `void GSSAStep(const struct GSSAState* stateIn, const struct GSSADef* system, struct GSSAState* stateOut)`. Now there are three parameters: `stateIn` (in-param, constant), `system` (in-param, constant), and `stateOut` (out-param). Again, it's pointers for all three because `stateOut` has to be and the other two are more efficient that way. In this case, the function would do all of its calculations, and make `stateOut` look like a copy of `stateIn` with the appropriate changes applied. The advantage is that now it's up to the caller to allocate storage space for the input and output parameters. The inefficient way, of course, is to allocate one structure for each step (either on the stack or with malloc) and never reuse them. (Although if you do that on the stack, the compiler will realize that you don't reuse them and optimize it very easily. It's still a pain to implement, though, since you need as many temp structs as you have steps. The malloc way is fairly inefficient no matter what.) You could do the same optimization yourself by having 2 structures: an "old" one and a "new" one, and going back and forth between them at each step. (Do that by swapping pointers or by having local structs `a` and `b` and using them in turn, not by copying the entire contents of the struct.) Or, if the function is written to allow this, you could have just one struct and pass it as both the input and output parameter; the function just has to be aware that they might be the same and make sure that it doesn't write any values to the output struct before it's done using that that value from the input struct.
Probably. Post has been removed.
Ah. That wasn't me.
I've not suspected that someone to be you and I don't care either. I think that this was the best place to put this public service announcement.
A nice way to do it may be something like the following. Note that I haven't actually tried this to be positive: // Assuiming arr is an array of 10 elements void smoothing_average(float *arr) { int i = 0; // Make an array: {a[0], a[0], a[1],..., a[8], a[9], a[9]} float new_array[12] = {0}; new_array[0] = arr[0]; for (i = 1; i &lt; 11; i++) { new_array[i] = arr[i - 1]; } new_array[11] = arr[9]; // Now do the smoothing calculations for (i = 0; i &lt; 10; i++) { arr[i] = (0.25 * new_array[i]) + (0.50 * new_array[i+1]) + (0.25 * new_array[i+2]); } } Edit: Impressive! Someone tries to be helpful and then gets downvoted. Way to encourage participation on the sub!
Note that in subs like this we usually try to guide OP to an answer rather than just give it to them. This forces them to learn rather than rely on the internet for quick answers they don't actually understand.
The Linux manual page documents the changes that cfmakeraw() does to the termios structure: termios_p-&gt;c_iflag &amp;= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON); termios_p-&gt;c_oflag &amp;= ~OPOST; termios_p-&gt;c_lflag &amp;= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN); termios_p-&gt;c_cflag &amp;= ~(CSIZE | PARENB); termios_p-&gt;c_cflag |= CS8; (it's a convenience function). In the code I have, the other change I make is: raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 1; What this does is causes the read() function to wait until at least one character is ready, and if one character is ready, wait up to 1/10 of a second for subsequent characters before returning. This allows you to read (in one call) both keys like 'A' or (for example) the Up arrow key (which on most terminals these days will return "&lt;ESC&gt;[A" (that is, the Escape character (ASCII 27), the left open square bracket, then upper case 'A')). This also means you'll want to pass sufficient space to the read() call to read in escape sequences (I pass in a buffer of 16 bytes, which is enough space for xterms I've found). 
translate the chinese characters
That's a neat trick but be careful: remote connections (e.g. SSH) may send both parts of the key press in different packets and the second packet might be delayed indefinitely. It's better to actually implement a state machine to parse special keys. This also has the advantage that the user can emulate special keys he doesn't have by means of entering the sequence manually. That's much more complex to implement though. I believe vim uses the first approach. For an editor that uses the second approach, look at ved.
An approach I tend to take is: char large_putput_buffer[LARGE_BUFFER_SIZE]; char *pbuf = large_output_buffer; size_t size = sizeof(large_output_buffer); int len; len = snprintf(pbuf,size,"format string",blah,blah,blah); if (len &lt; 0) error(); pbuf += len; size -= len; len = snprintf(pbuf,size,"other format string",foo,bar,baz); if (len &lt; 0) error(); pbuf += len; size -= len; snprintf() returns the number of characters written (a negative value is returned upon error) so using the fact, I can keep bumping a pointer and decrementing the size as I write strings to a buffer. 
This doesn't catch the case when `snprintf()` truncates the string and does garbage if that occurs.
Truncation is an issue, but what do you mean by "does garbage"? snprintf() (note the 'N' in the name) will stop when it hits the end of the buffer and ensure it's NUL terminated. sprintf() (note the missing 'N' in its name) will scribble all over the place.
Before doing the state machine I would test with SSH first. Yes, it may be an issue but so far I haven't seen an issue with SSH. [1] [1] That's not say it's NOT an issue, but in my case, it's not SSH that is causing the problems, but Synergy (program to share keyboard/mouse between different computer systems). And believe me, reading ECMA-48 [2] is not an easy task. [2] http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-048.pdf 
`snprintf` returns the number of characters that would be printed if the buffer was sufficiently large. Thus, if the buffer is exhausted, you set `pbuf` to a pointer past the buffer and `size` to a negative value which is interpreted as a huge positive value in the next call. I don't think that's what you want. Lastly, `snprintf()` returns an `ssize_t`, so the type of `len` is inappropriate.
The C standard gives a return type of int (I just checked). You are right about what it returns though, which is different from sprintf() (why? Oh, I know, so you know now much memory you need to use ... sigh). Off to check my code ... 
Ah sorry, I'm wrong here. I thought it would return `ssize_t` but of course it can't as it's part of standard C which doesn't know `ssize_t`.
thanks for the replies, i actually went to bed after i posted this and figured it out in the morning. but i appreciate the help. 
Null characters (\0) appear at the end of strings after the last normal character. The guard condition (str1[i] != '\0') terminates the loop the first time the condition becomes false. That would mean that it would terminate when str1[i] = '\0'. Since arrays use 0-based indexing and s1 has 5 normal characters, that means that '\0' appears at index 5, so the guard fails when i = 5, and the loop terminates. There is no overlapping here, since at the start of the second loop, i + j is 5. Hope this helps.
Not exactly. I have to make some guesses, because you never actually show a call to concat with arguments, but... Remember that the arrays are 0-indexed. If I just did this right in my head quickly while drinking, then the space at the end of "Test " is index position 4 (because it is the 5th character) and then i gets incremented once more to 5. This time the test (i != '\0') fails, and the loop exits. The second loop does work like you said though, mostly. It adds the 5 (length of previous string, location of the null at the end of it) to the current character position in the second string, so we are indexing into the result from where we left off. Does that answer your question?
Yeah, I should have done a prinf (%i, i); in the loop... Thanks! edit: printf ("%i", i);
Thanks! 
Right now, `intprod` is uninitialized; set it to 1 before the loop, and this code ought to work.
Thanks! Like I said, it's been a few years (okay, maybe a bit over a decade), so I didn't recall the details. Makes me feel better about my continued use of them in such situations.
OK, this clears things up A LOT! Thx
Sure thing, glad I was able to help :-)
So what is happening?
That error means the linker can't find is_prime. It's helping you by telling you that main, in main.o, is the code that needs is_prime Is the other .c file part of the project? Does it contain is_prime?
Is it being compiled?
What was the unrelated problem though?
It needs to be compiled. All source files containing code you want to be executed need to be compiled.
I actually had two segments like this. I fixed this one, but my input actually tested the other.
How would i go about compiling that? Do i just build it on codeblocks and then build and run the main file ?
The string termination didn't occur to me, thanks for catching that. That would end very badly I imagine.
Embedded systems would be worth learning if you're looking for a job programming in C. There's a [MOOC about embedded systems](https://www.edx.org/course/embedded-systems-shape-world-utaustinx-ut-6-03x) that recently started up again.
 /*This code will loop for 1000 clock ticks -- which is variable from platform to platform, and should be defined in time.h. That said, granularity is often 1,000 ticks per second, so this code *may* loop for 1 full second on your system. Other's mileage will vary. My time.h has this: #define CLOCKS_PER_SEC 1000 */ #include &lt;time.h&gt; long start_t = clock(); while(clock() &lt; start_t + 1000) { /*optional code in here */ } 
That's why I don't like when beginners use IDEs: They don't understand how the compilation/linking process works because they never see it in action. --- I've never worked with Code::Blocks. I think you need to add both files to the same project and then build the project.
Do not post code as images!
If [/u/PacoVelobs](/user/PacoVelobs) is *designing* an API, what you suggested about the `void*` is abscolutely correct, however: &gt; If you are dealing with a third party library that doesn't provide such a mechanism and you can't change it, you are pretty much stuck with saving the user data yourself in some global variable. This is not true! You *have* other options! You might be able to use a [trampoline](http://linux.die.net/man/3/trampoline). This code is pretty portable (IIRC it comes from [clisp](http://www.clisp.org/)) so you can grab it and drop it in your application if you're not on Linux. GCC also supports [nested functions](https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html), and clang supports [blocks](http://clang.llvm.org/docs/BlockLanguageSpec.html) (although I'd recommend avoiding clang, since the code it produces is horrible).
Hi. Thanks for the answer. I understand the way it works but I feel uncomfortable about giving access to my library internal storage with the `void * userData`. But if it's the only solution in plain C I'll do my best with it. Thanks again! Paco V.
Hi. Yes, I try to make a plugin API and I want to hide the piece of memory allocated by the plugin manager to the plugin itself. But I need the plugin to have a way to register types and/or functions so I need a way for the plugin to tell the manager where to wright them. I know it's also possible to have a static map to keep the records but it won't allow to have multiple "instances" of plugin manager. And I want to keep this possible as I want my applications to have GUI plugins separated from Core plugins and so on...
&gt; I try to make a plugin API and I want to hide the piece of memory allocated by the plugin manager to the plugin itself. Don't do that. It's not "internal memory". It's just memory. It's real. Plugins will be interested in telling your managers apart. The future version of you that wants to debug this will want to compare the pointers to make sure things are implemented correctly. Other C programmers will want to see it. Debugging *through* trampolines is a nightmare- like using a C-only debugger with a C++ codebase: All the functions are mangled, code references variables that has nothing to do with the code, and you jump into bits of random assembly all over the place. Just don't do it. The `void*` recommended is fine. You can call it `PLUGINMANAGER*` or something else if you want with typedef/struct [as /u/Nimbal suggests](/r/C_Programming/comments/47bqgn/c_stdbind_like_in_c/d0bszaq) but it's the same thing. &gt; But I need the plugin to have a way to register types and/or functions I think you're thinking of doing something like this: m = new manager(); p = new plugin(m); and plugin will go: plugin(m) { m-&gt;register("callback1", callback1); m-&gt;register("callback2", callback2); … and you might do something like: m-&gt;call("callback1", arg1, arg2); and it will execute all the callback1, the first callback1, or chain them or whatever. Right? And you're trying to translate this pattern into C, so you've got a: m = new_manager(); p = new_plugin(m); and the plugin will go: plugin(m) { manager_register(m, "callback1", callback1); manager_register(m, "callback2", callback2); … Right? This isn't necessary. The [dynamic linker](http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html) can do this for you. Just do: m = dlopen("plugin", RTLD_LAZY); c = dlsym(m, "callback1"); c(arg1, arg2); and be done with it.
The worst someone can do to an opaque pointer by accident (i.e. without explicitly casting it to another type to manipulate the data) is to free it. If you are really paranoid, you can even prevent that by not giving out the opaque pointer directly. Instead, cast it to an integer with the same size as the system's pointer size before giving it to the user. Before you use it, cast it back. In any case, at some point, you need to trust your users to RTFM and not do something stupid.
I come from a C++ background and I'm used to it: never show what won't be used. Thus, if my plugin only registers types and functions using a function, it does not need to know where and how the information got stored.
The C approach: Never make things implicit. If there is state, carry it around explicitly. Don't attempt to make state invisible. That only causes a complete clusterfuck when someone tries to do non-trivial things with your code. About the trampolines: Don't use them. They are not portable and they come with considerable security issues as they require pages or the stack (depending on which trampolines you use) to be writable and executable at the same time. This tears a large hole into the security concepts that exist to prevent various kinds of exploits.
Got it for the trampoline. I nevertheless decided to use an opaque pointer to carry the data address I need to manipulate later on. It might be a bad idea but I can't help thinking about not showing my `struct` inside the plugin.
This is strange.. because the TA is able to run main.c straight off his code::blocks on his ubuntu computer
Footnote: I tried some stuff like: #ifdef main() /*do stuff*/ #endif and #ifdef PROPERLY_COMPILED //defined in main.c /*do stuff*/ #endif
Alright. I'm kinda paranoid about people not reading the instructions. thanks anyways :)
How are you compiling it? 
The compiler is unaware of the other file when you're compiling the main.c file. Your options: 1. Compile the sort code, bundle it as a library, link with the library. If you weren't clearly a beginner, this is what I'd recommend. But it's overkill for you, and I don't even really think theres a reason for me to go into the steps. Reply if you want me to. 2. Compile each file separately, link them together. This is the most common path and not a bad one, but is tedious if you aren't using a Makefile or some other build automation. It basically looks like gcc $(YOUR_CFLAGS) -c -o sort.o sort.c gcc $(YOUR_CFLAGS) -c -o main.o main.c gcc $(YOUR_CFLAGS) $(YOUR_LDFLAGS) -o my_program main.o sort.o You'd then run your program with `./my_program`. If you don't know what `$(YOUR_CFLAGS)` should be, `-Wall -Wextra -g` is a fine choice for beginners. If you don't know what $(YOUR_LDFLAGS) should be, you can probably leave it blank. The important thing to note there is that you pass in an extra flag `-c` to make the compiler create an object file (with extension .o), and then you tell it to combine all of the object files into a executable. You can also directly invoke `ld` for the last line, but I didn't, for the sake of simplicity. 3. Just pass all the required files into the compiler. This is what I'd recommend if you're just starting, probably. A simple `gcc $(YOUR_CFLAGS) -o my_program sort.c main.c` should do the job for this route.
yeah, that did it. Thank you again for your help 
I have created the 3 object files for the library being: Generate.o, used as a random number generator for the bubble sort to perform on. Sort.o, used for the bubble sort code. Search.o, used to search for the next number to be sorted. Then using: gcc main.o generate.o sort.o search.o -o test which is what is returning the error I mentioned above.
Order matters here, try putting main.o last.
This assignment presumes you are familiar with first year calculus and differentiating equations. My calculus is too rusty to help you. Math forum is your best bet.
&gt;&gt; #define CLOCKS_PER_SEC 1000 &gt;Why are you defining CLOCKS_PER_SEC!? It's already a macro defined in time.h (platform specific macro)! He isn't defining it in there - it's still a part of the comment - he's just showing in the comment how it's defined in time.h
It would be helpful to have list.h and node.h as well so I can just throw this in my compiler and see what it gives me.
There's a missing definition of `struct node` but that's not your core issue. There's an extra } in your code at lines 200-203. But what's really going on is with these lines of code: if(currentList-&gt;head == NULL)// If head is empty Node newNode = createNode(value, currentList-&gt; head, currentList-&gt;head); //If it is empty. We want the previous to point here too. Declaring a new variable like that is meaningless, hence the error. I hesitate to suggest a fix, because I think you need to work on that function a little more. But not declaring a variable will help: if(currentList-&gt;head == NULL)// If head is empty newNode = createNode(value, currentList-&gt; head, currentList-&gt;head); //If it is empty. We want the previous to point here too. 
Thank you I am just trying to edit a code I was given to implement it from single to doubly circular linked list.. I fixed the two errors.. I took out the if statement... Thank you 
Thanks for all the help. I'm still confused as to what the variables will represent. You set dt=1 but not when it is multiplied by gravity on the right side of the equation. Why? does v(0)=0? Assume p=100, therefore p(0)=100. How do I solve for time?
Okay so that kinda solved my problem, i wasn't sure if the -i had to be an argument. thanks alot! sorry i'm such a noob XD
It's all good. Don't be afraid to ask questions. That being said, you may get some angry people telling you to Google search things first, but oh well.
I think you meant `strcmp( argv[i], "-i" )` Won't `argv[i] == "-i"` always return false? since it compares two pointers?
Don't forget to check it against 0 because strcmp returns 0 when the strings are equal 
Yes, yes you would. That's 300% my bad.
You should do: if (strcmp(argv[i], "-i") == 0) // do your things That's my fault.
Yeah. Make Kelvins a double or cast it. Also, the declaration of a, b, and R -- b and R will be ints, not doubles. 
For math, in C, you will lose precision if you multiply by an int. You can either change the declaration or cast ints to doubles. Easiest route is to just make everything doubles. Just note there is a very small memory cost for doing that. For a one-off project, it's not important. 
Post your current code? Did you apply what I said about your declarations of b and R to part two and part three?
Right -- b, R, parttwo, and part three should all be doubles, but that's not what your code does. 
Second this, great course to start your baby steps into the embedded programming domain. 
For many kinds of hardware, you can get datasheets if you search long enough.
No doubt, but it's like asking him to learn swimming in the ocean than in a swimming pool. He will either drown or become one of the best. 
If `i++` attempts to increment `i` past `INT_MAX`, then you invoke undefined behavior, and anything can happen. If you try to convert a value greater then `INT_MAX` to `int` (such as by casting) then the result is implementation defined, although it's also allowable for a signal to be raised. If you are converting to an unsigned type then you get modulo behavior rather than implementation-defined behavior.
Why are you printing the address of N instead of it's contents?
Your best bet is to put a few breakpoints on your main function in your IDE of choice, and launch it. It's a million times easier than running gdb.
?
X11 is a portability layer, so if you want to draw without X11, you are looking for something non-portable. You're probably interested in [libsdl](http://libsdl.org/) which has a framebuffer-only implementation so it doesn't require X11. It might not be as portable as X11, but it has been ported to almost every modern platform with a screen (including OSX and Windows). However if you really want to know how to draw pixels on the framebuffer on Linux, the basic pattern is: #include &lt;fcntl.h&gt; #include &lt;linux/fb.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;inttypes.h&gt; Open the framebuffer (it's just a file): fd = open("/dev/fb0", O_RDWR); Better: let the user pick the device as an argument/environment variable. Then get the dimensions of the screen: struct fb_var_screeninfo vs; ioctl(fd, FBIOGET_VSCREENINFO, &amp;vs); With this, you'll know how big the screen is in bytes: int nbytes = vs.xres * vs.yres * vs.bits_per_pixel / 8; and then you can use `mmap()` to get a pointer to the frame buffer: char *b = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); Whenever you want a pixel, you have to translate it to a linear address: int offset = (x+vs.xoffset) + (y+vs.yoffset) * vs.xres; And then write the pixel data. Consult `vs.bits_per_pixel`: If it's 32, then you'll want: uint32_t *b32 = (uint32_t*)b; b32[offset] = 0xffffffff; /* packed color */ If it's 16, then you'll want: uint16_t *b16 = (uint16_t*)b; b16[offset] = 0xffff; /* packed color */ If it's 8, it's more complicated because you'll need to create a palette: unsigned char red[256], green[256], blue[256]; struct fb_cmap pal = { 0, 256, red, green, blue, NULL }; … ioctl(fb, FBIOPUTCMAP, &amp;cmap); then you can just set pixel values `b[offset]=index` where `red[index]` contains the redness, `green[index]` contains the greenness and `blue[index]` contains the blueness. 
I'm an idiot, nvm. I read scanf as printf for some reason.
That's actually really interesting, I've looked up the L4 microkernel before and always wondered how much trouble it would be to port it to OS X to replace Mach?
:) I wondered if that were the case, no worries.
I highly recommend [SDL2](https://www.libsdl.org/). Simple, easy to set up, cross-platform (graphics, I/O, and audio), *super* easy to get a canvas/framebuffer (either full-screen or in a window) at whatever resolution you want.
[Here](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=28) is a huge amount of judged programming challenges. ANSI C is one of the valid language options
Great thanks! Glad I asked.
You sign up for an account, and the site itself is 100% free. Another great site is [project euler](https://projecteuler.net/). However, it tests more mathematics (and computational gemoetry / number theory in the later problems), but is still a fantastic set of problems.
thanks man. appreciate it.
You can check out leetcode.com if you want to inprove your algorithm skills.
http://codegolf.stackexchange.com Be aware though, the competition is fierce.
What do you think happens when two processes write to the same area of memory? Or did you think the frame buffer was something other than memory?
Great list, very helpful. Saved and thanks
What platform are you working on? There are two major subsystems for serial connections: Windows has a system I'm not familiar. Almost all other systems use the UNIX design where serial connections are terminals. You can configure them with *termios.* It's a bit messy but not really all that difficult.
The page he should have linked is [Serial Communications](https://msdn.microsoft.com/en-us/library/ff802693.aspx). That has sample code for everything you need to do: opening a serial port, doing blocking and non-blocking reads and writes, and setting the settings like baud rate. You just need to look up details for the handful of API functions they mention.
Would Python be acceptable on the Windows side, too? It looks like PySerial supports Windows just fine.
I don't want to get into a heated argument here. I pointed out that I wasn't sure. In general, I don't believe it's possible to multiplex operations to a serial port, due to its nature. There are also a huge range of operating systems with different goals. DOS absolutely did allow you to do this, as do other real mode operating systems. It appears that protected mode does not. I haven't needed to fiddle with a COM port directly in a *long* time, and since they are generally used exclusively anyway, I thought it was possible that direct access would be allowed. I'm not surprised that it isn't. If it was possible I just thought it would be easier than the Windows API. I suppose theoretically you still could if you bothered creating a VXD or something and establishing ring 3 privilege, but that doesn't seem worth it. Edit: I meant ring 0 privilege.
&gt; I don't believe it's possible to multiplex operations to a serial port, due to its nature True; that's why Windows and Linux implement exclusivity. You have to do something (open a file descriptor or terminal) to claim access to the serial port, and if someone else already has access, it fails. &gt; If it was possible I just thought it would be easier than the Windows API. "Easier"? I dunno about that. Maybe it makes getting *one* byte to the serial port easier... assuming your serial port is memory-mapped, which isn't the case if you're using a USB-to-serial dongle, and assuming it's already configured with the right baud settings. It doesn't make writing *many* bytes very easy, cause wouldn't you have to poll for the serial port's buffer status or somehow gain access to the hardware interrupt, so that you can keep filling up the buffer? Compared to that hassle, I don't see what's so bad about using the fairly straightforward `CreateFile`, `ReadFile`, and `WriteFile`. It handles all of the buffering for you, blocks for however long you want trying to read or write data, and works with all kinds of serial ports instead of only ones baked into your motherboard. It's extremely well documented and easily maintainable by any C programmer. Edit: P.S. Thanks for the civil reply. I may have been a bit harsh with my criticism, for which I apologize.
I was able to send your code into an infinite loop by giving it the following input: double test_array[] = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 }; When implementing a recursive algorithm, you should be able to *guarantee* that the size of the input given to the recursive calls is smaller than the original input size. Normally, in quicksort, this is done by excluding the pivot element from both recursive calls (since you know it's already in the correct position). Your code does not do this.
You have a couple of issues. You need to take a look at the documentation for strcmp and fgets. In situations like this it helps to print out intermediate results and return values to help you figure out what is going wrong. The return value of strcmp is 0 for equality and the fgets command includes the newline character in your input buffer. Your command string is going to contain "load\n" for example if you type the word load.
Look up what strcmp actually does. It doesn't work the way you're using it.
I'd use strftime() for printing dates instead of making assumptions about time_t. %s would be useful here.
More info: In ISO C, time_t may be integer or floating point; in POSIX it must be integer. Also it's implementation-defined whether negative values are allowed. So using `long long` as you suggest seems reasonable .
Looks like code written by a C++ developer. I don't like how you stick `likely` and `unlikely` all over the place. Are you sure that this is an improvement? Are you sure that you are smarter than the compiler? Because more often than not, programmer's ideas about what branches are likely are not really congruent to reality.
Why can you specify a custom free function but not a custom allocation/realloctaion function? What is the benefit of defining your own free() when using the standard malloc()?
Are you sure it's fast? Did you benchmark it? Where are the benchmarks? I'm suspicious about whether this is what I would consider fast: Indirect function calls are pretty slow in my experience. realloc is pretty slow in my experience. Why is having a `free_func` unlikely? Are all vectors object-vectors? If so, what's the point of `element_size`? It should always be `sizeof(void*)`. If not, why is `free_func` unlikely again? You should look at the assembly output of your library, and compare it with a professional offering like [kdb's c.o](http://code.kx.com/wsvn/code/kx/kdb%2B/l32/c.o?op=revision&amp;rev=1442). K x=ktn(6,0); int i=0;for(i=0;i&lt;10;++i)x=ja(x,&amp;i); //faster:x=ktn(6,10);for(i=0;i&lt;10;++i)xi[i]=i; for(i=0;i&lt;xn;++i)printf("%d; ",xi[i]); You might get some real ideas about how to make a performant library, rather than just reimplementing `std::vector` in C (which isn't particularly fast to begin with).
There is a lot more wrong with your code, but the error you cited occurs on this line: printf ("*** Invalid entry. Grade must be 0 to 100. ***:); Do you know what you did wrong? Carefully read the error message.
Hmm that is true, I didn't think of that. I will remove the sticky then
typo
Thank you for that
It's more complicated. Protected mode contains a bitmap to specify what ports are accesible. On some system, like Linux, you can manipulate that bitmap with a special (privileged) system call.
http://bradconte.com/sha256_c
There are C routines in openssl. In a terminal type man 3 EVP_DigestInit It's more complicated than python, but openssl is very trustworthy and has lots of other features so it's worth the time to learn how to use it.
Good idea, thanks!
Do you have any code written to try and do this? If so, please post it, otherwise don't expect people to just give you an answer to your problems.
[OpenSSL is not trustworthy](https://www.openssl.org/news/vulnerabilities.html).
[NaCL](http://nacl.cr.yp.to/hash.html) contains SHA256.
Do you know of any analysis done by compilers whatsoever to figure out likelihood of branches? People attribute a lot of intelligence to compilers all the time, but in my experience, they're often quite dumb.
Compilers have heuristics for which branches may be chosen and which not. For example, gcc assumes that a branch to a function that does not return is rarely chosen. The compiler also obeys attributes placed on functions. Some compilers (notably icc) simulate the code with random input to see which branch is taken how often. gcc allows you to run the program once with special profiling code inserted. This generates a file with hints that allow gcc to optimize branches even further.
#include &lt;stdio.h&gt; int main(void) { //setting Variables int answerDigits; int guess; int i; //int y; //prompting user to input Digits for Answer printf("How Many digits do you want the code to be (2-6)? \n"); scanf("%d", &amp;answerDigits); //checks for Valid input while((answerDigits &lt; 2 || answerDigits &gt; 6)) { printf("Invalid input. How many digits do you want the code to be? \n"); scanf("%d", &amp;answerDigits); } printf("You have entered %d\n", answerDigits); int answer[answerDigits]; //Secret Code Table/assigning answer for(i = answerDigits - 1; i &gt;= 0; i --) //loop to fill integer array { answer[i] = i + 1; } //prints answer //for(y = 0; y &lt; answerDigits; y++) //{ // printf("%d\n", answer[y]); //} printf("You Won!\n"); return(0); }
I'll try and figure out how to do that soon. It'd be nice to have some concrete set of resource to point the newbies too. 
Try adding '\n' to the end of your strings. For example. while(fscanf(file, "v %f %f %f\n", &amp;x, &amp;y, &amp;z) == 3)
This reads like homework, so I'm going to be a little more towards the pseudo code and vague side of things but basically... What you have: 1. Open both files 2. Read each file line by line 3. For each line pair, compare to see if they match. 4. If nothing matches, report same, other wise report which line you are on This doesn't sound like your task though. What you want to do: 1. Read in file/data set 1 2. Build an array of data containing all of the codes and the associated weights 3. Read in file/data set 2 4. For each line in the set, look up the code in the table that you read in earlier (from set 1) and compare the weight 5. If the weights don't match, you print out the lines that don't match. In your research search for a "map table" or "hash lookup" and you should find more info. "Pigeonhole sort" is a similar idea that might give you ideas.
The loop is still never entered.
Grey: the funnest of colors.
It's definitely a possibility. I'll think about how to do it with proper filtering and update this thread if I figure it out.
Could you point me in the direction of this gcc feature? That sounds super useful.
 system("cat file1 &gt; file2");
Thank you, but I want to have more control. Like being able to only copy one part of the file or appending to a file. Edit: This may work if I can append to a file (don't know if it's possible)
You are probably looking for strtok: http://www.cplusplus.com/reference/cstring/strtok/
Why do you need to have a Unix file descriptor in specific? Why can't you use the generic standard library's I/O functions? Also, regardless of how you access those files, doing a character-wise copy, while slow, won't break anything.
I don't think `fdopen()` is needed when you want to use `read()` and `write()`.
I wonder how well mmap() and write would work.
It's called [Profile-guided optimization](https://en.wikipedia.org/wiki/Profile-guided_optimization). Here is an explanation about [how to use it](http://stackoverflow.com/questions/13881292/gcc-profile-guided-optimization-pgo).
In fact, almost all other compilers reject code that does arithmetic on a `void*`. Only gcc allows this, the behaviour was a bug originally but was never fixed for compatibility reasons.
to be honest, every time i read a file i go and reread the input functions to remember how they work. If the data is well formatted (Which it looks like it is in this case), scanf() should work fine. Conversely, if you know is that it will be "&lt;label string&gt;&lt;space&gt;&lt;weight number&gt;" you could read the line with readline(), and use strtok() to break the line into the two fields, but this requires some understanding of pointers and might be beyond what you are currently supposed to know/play with. However, that last step can also be done with how you are currently doing it, namely read character by character and build a string yourself and just watch for the space character (' ') to trigger a change in processing
&gt; I'm on Linux `sendfile ()`
The best way that I have found to do it is to create a structure that can be used for line parsing. I usually call it LineLocation or something similar. The structure itself holds 3 elements. * A pointer to the start of the parsing location. * A pointer to the end of the parsing location. * The length between them. struct LineLocation { char* start; char* end; int distLength; }; Once you have that structure set up you can use strchr to position your start and end of the parsing location appropriately. You then use strncpy to copy from the starting pointer using the distlength. The problem with strtok is that it returns a NULL ptr whenever it finds the location your looking for. This means it can get alittle iffy to parse. By creating a construct that you implement yourself you have a bit more flexibility. I know its more work just for a split but its how I would do it. That's my two cents. Feel free to ask any questions. 
 while (*environ) { n++; c = *environ++; }
What error? It's a *lot* easier to debug things when you know what you're debugging, **especially** when the code is posted as screenshots so you can't run it yourself without typing it out. You should post the code somewhere, like pastebin, or even in the body of your post (prefix with 4 spaces to format it as code). **Edit:** Actually, the error is pretty obvious without the error in this case. Line 15, where you call `choice`, what is the type of `occupancy[11]`? You should really turn on some warnings in your compiler, this should have been picked up.
Hey there! Your problem comes from the way you are calling choice1. You have declared it with an array of integers and a single integer as parameters. Under case 1, however, you call "choice1(occupancy[11], room);" Passing in "occupancy[11]" doesn't pass in an array, but instead only passes the integer stored at index 11 of that array. You should instead call it like this choice1(occupancy, room); This should fix your runtime issue. Additionally I would say since "room" is only used to be passed into your function, I would say it would be better for "choice1" to not take in an int argument, and just declare the int inside of the function itself. Apologies for poor formatting, I'm super tired.
Yeah it turns out I had something wicked there but it's all good now thanks bro :))))
Arrays know nothing of their length. When you send an array into a function, you're actually just sending in a pointer to the first element on the array. Most of the time, you want to couple this with another parameter that is the length of the array. So if you only want to see the first four elements, you tell the function that the length is 4.
My bad. And yeah, `strtok_r` might be better I keep forgetting about it.
What kind of graphics are we talking? Because you might want to look into OpenGL and libSDL 2.0 if you want to do advanced 2D or 3D graphics. There's not really an "easy" way. Just different ways, depending on what you want.
Please refrain from posting source code as a screenshot. That makes answering your questions really hard. Please paste the code to a paste service of choice or inline into the question.
`-L` specifies an additional linking search path. `-l` specifies something to link to (from the search paths) and `-I` specifies a place to look for header files
won't `-I` ruin the default header location (where `stdlib.h` and stuff are)?
Sorry bro! Will do. ;))
OP asks for an easy way, I agree there is not a too easy way that you implement with 2-3 lines of code, but OpenGL is a terrible advice. You have to study a lot to understand how to properly use OpenGL. SDL is a good advice, you can create simple graphics from the first day with it.
The malloc should be before the loop .. You only need to do it once. You need different variables to walk through the 2 strings. One which advances by 1, and one by 2
SDL 2 is a pure C portable 2D graphics library, you can probably start drawing simple shapes in less than one hour (if you follow a good C SDL 2 tutorial).
When I started out on RISC OS it was very cool, single command. "Set screen to resolution and depth and give me screen address". Then use address to write to screen. Ah, them where the days. But today, yes, cairo, opengl or SDL are good.
Thank you!
Don't forget to free what you malloc'd. There won't be any difference in this case but it's a good habit to have, especially for when you'll be writing more complex programs
Thanks for chipping in. The assignment was not to simply print out the environment variables. I needed to read them in and print each out in tabular form using the '=' sign as the delimiter. The output needed to be sorted alphabetically either forward or reverse depending on the value of the FORMAT variable.
Why do you need to divide the array? If you have a function that does something to four consecutive characters just pass it a pointer to where you want it to do it's thing. Add four and call it again.
I just submitted the assignment but I will keep that in mind for next time. What exactly does freeing it mean?
Not if you want doMath() to be able to change array, this only sends it copies of the values in array. For doMath() to be able to make changes to array you have to pass it a pointer to array. Brush up on the difference between passing by value and by reference. You're going to have to do more than while(array) to decide what to send it too. You need to know how long array is and somewhere you're going to have to handle the fact that length might not be an even multiple of 4. 
Part of the assignment is that the length will always be a multiple of 4. Are you saying i would need to pass the entire array by reference, rather than just the 4 values?
I respectfully disagree. Like in literally every aspect of software development, C (combined with a higher layer like lua/python/perl/tcl/bash/scheme/lisp) blows C++ out of the water in graphics programming.
At the end, after using 'palin' for the last time free(palin); It's the opposite of malloc and "gives the memory back".
linux and gcc. for some reason programming C or python in windows feels really uncomfortable to me
&gt;If the caller is handling the loop then it passes a pointer to the start of array to doMath(), increments the ptr by four, calls it again, and so on for the sake of argument, is this valid? int i=0; while(array){ doMath(array[i]); i+4; } Or can I only pass the array in its entirety? Would i run into an issue in doMath trying to work with indexes 0-3? 
I too am a minimalist (https://github.com/robertmeta/nofrils), and spend the majority of my time in Vim, Tmux, Zsh on Ubuntu 14.04 LTS... it isn't the most up to date, but most all the issue are well sorted and you can find help for them online, and if you need something fancy you can generally just add a package source. From a hardware setup -- if I was buying a fresh (and single) setup, it would have to be a Mac just because it is the only solution that out of the box, and without ridiculous hacks can run all three operating systems and let you explore the environments of each.
 /r/C_programming is very much *nix and GNU(gcc) -with a decided leaning toward ANSI-C. Posting windows and similar OS-specific code isn't forbidden, but will likely garner you a lot of downvotes. As a practice, those of you who *must* code platform-specific stuff for their work or apps might consider keeping core routines separate from routines needing platform/application-specific code, and those (separate) core routines and related discussions will generally be welcome here. In example, you might need to perform some color-manipulation on a 32 bit pixel. So, the code for that mite be welcome and discuss-able, but a clever implementation for accelerating your pixels to the screen in the Windows OS might be slightly discouraged and downvoted to oblivion. This is simply my observation and experience. I'm certain that the rules are flexible enough to allow lots of latitude, but I'm learning not to press any limit. As for me, I love c on any platform, yet there *is* something beautiful, useful and respectable about platform-independent design whenever possible. For one, more people can use it - a broader audience. 
Linux hands down. Windows is ok too, OSX is the worst.
I go out my way to not work on Windows. It's just too unbearable to be on Windows. No package management. No Bourne Shell. Second class platform to most open source projects. And I know Win32 and NT's guts. It isn't pretty. Finally the UI is different from the days I used to use Windows. Just to rub salt in. Though I never liked Windows, I'm from RISC OS...
I've literally never seen anyone downvoted here just for discussing C development in Windows. There are lots of good reasons that most users here develop mainly (or even exclusively) in Linux, but they're not cultists about it. FWIW, I mainly develop C in Windows. For all MSVC's weaknesses, it does have a very good debugger.
append is just: cat file1 &gt;&gt; file2
Excellent, thanks. I am very green in terms of development on Windows, especially in C, having worked mainly on Linux developing for microprocessors in the past. Do you have any resources for getting started with these libraries?
I also use OS X and Ubuntu. With Homebrew you can get most if not all of the important command line tools. Honestly I prefer OS X because it "just works" without driver issues and random error messages that I have to Google to solve. And it is just so much more polished. As for text editing, I use Vim on Linux and Vim and Code Runner on OS X. Code Runner is a really nice little native app for OS X, although it doesn't have the advanced features and speed that Vim has.
Honestly, most of the code you write can/should be platform independent unless you're specifically working on applications that are heavily tied to a target OS. Even most GUIs should really be a thin layer of UI on top of a platform independent chunk of "business" code. Even better than the cross-platform capability, it will be test-able if you do that.
I prefer Debian, developing with Emacs, GNU make, gcc+bintuils, occasionally clang, global, and other creative tools as needed. Often enough I have to work in Windows, in which case I live inside of Cygwin with emacs-w32 (Emacs built against Cygwin but with a win32 GUI). In either case if I need to target Windows specifically, I'll compile with Mingw-w64 and on Linux I'll run/debug with Wine. 
vim and gcc/g++ on OSX. I typically use cmake to generate a makefile so my stuff is easily compilable on linux/osx (and windows if libraries are available). Windows is a general pain in the ass to program on. OSX and Homebrew, and Linux and apt-get (or other package managers) just makes live so much easier. And once you're used to vim it's hard to fathom why people code in anything else.
&gt;Honestly I prefer OS X because it "just works" without driver issues and random error messages that I have to Google to solve. And it is just so much more polished. Exactly the reason I use OSX over linux. If I enjoyed/wanted to dick around with all the stuff I needed to do get linux working right it would be great. But I don't have the time for that.
&gt; sendfile() is not portable That why I quoted OPs “I’m on Linux”. &gt; at least one of the descriptors has to be a network connection. Not anymore SENDFILE(2) […] In Linux kernels before 2.6.33, out_fd must refer to a socket. Since Linux 2.6.33 it can be any file. If it is a regular file, then send file() changes the file offset appropriately. 
linux, emacs, gcc and clang
I'll have to disagree with your disagreement. I love me some C, but for larger graphics programs C++ holds some major advantages. Classes allow for easier abstracting away of lower level details that while possible in C are more clumsy to implement, imo. I think the selection of language comes down to the preferences of the team and the paradigm one wants to follow. 
I work with all three, and osx always causes the most problems. For example if you want to build android you have to create a case sensitive file system because hfs+ is such a joke. nfs support sucks. Want to build a binary on 10.10 that runs on 10.6? Good Luck. VNC on headless mini macs is unusable. If you need a lib with many dependencies, you could spend a few days getting everything to work. I can't tell customers to just install brew or whatever. OSX is ok for small projects and if you do things "the apple way". As soon as you push the boundaries you'll run into massive problems.
Mostly eclipse BSD/Allman Always use blocks, even on single line conditional blocks, and in case statements. Personally not one for always typedefs, but everything is typedef'd where I work. There was a rule about mo `#include` lines in header files.. Then someone had to figure out which 7 files to include, and the correct order when writing a new module. I see something changing to prevent that work again. Working in embedded, there's no using stdio, floating point or dynamic memory allocation. We're going to move to 4 space indentation, from 3. The 80 character line length is rarely enforced, most long MACRO heavy algorithm lines, seem to go 100 to 110 characters wide. Mostly what makes the algorithm (or struct initializer) easier to visually follow. Old code isn't touched until there's some reason to modify it. If the modification is small (dev's opinion) use the standard that code was written to. If the modification is large, refactor the formatting, commit that version then make the code changes. By performing two steps reviewing is easier.
* Allman * always use blocks for conditionals * no hard tabs * 4 space soft tabs * non-Hungarian * camelcase variables * very few typedefs (typedefs are great for obfuscating code) * no #defines of previous #defines * all include files have a preprocessor wrapper * include files include all files needed to build them so that you don't have to know what dependencies they have.
Mostly GNU style at work. Something that Wikipedia calls 1TBS for personal projects.
Virtual machines. Doesn't terribly matter what platform your main host is on, you can just set up your development environment on a VM and install nearly whatever you want.
&gt; but they're not cultists about it. Oh yea, didn't mean to imply that. Also, to love *nix and hate Windows isn't culty, it's just human, lol. I've simply noted that, per votes, my most appreciated posts have been platform-independent code/discussions. Most downvoted -- when I strayed from that. Could there be other factors that affected voting? Sure. (definitely) But comments that (seemingly) chided me for posting code that 'cannot be used anywhere but one OS' helped me to understand unwritten taboos in a very explicit way. For the record, I'm totally OK with it, and by posting here I infer my compliance and agreement to the notions of what the apparent majority feels to be best practice. And those notions of best practice are completely reasonable (and I don't know of a better programming sub on reddit -- r/C_Programming is tops, to me). I would simply spare others from learning the hard way, as I did.
If you want to make use of the Raspberry Pi itself, maybe Python is your best bet, as there are libraries for the GPIO and such like.
&gt; mass refactoring and renaming and moving files into different folders ( breaking current make files and include headers ) Nothing should break because you more or rename files. If it does, you neglected to do part of your job. Supposing you change the name of a function, you need to find all places that reference that function (even in files/functions that are used on other platforms than your dev machine, places where it isn't currently enabled on your dev environment because of an #ifdef, and ideally places where it's mentioned in a comment rather than code) and change them to match. Renaming or moving files is no different. You need to find all the source files and project files that reference that filename, and update them to match.
As you are in a class, you should also be asking your professor and/or TA for said class.
Your "question" is very vague. What confuses you about that part?
usually we have for loop like: for (int i =0; i&lt;0; i++) now we have for(int exp=1; m/exp&gt;0; exp *=10); this line what does that mean?: **exp*=10** 
I forgot one enter before the 4 spaces. thank you 
dum question...makes sense... 
I spent the last ten years writing objective-c on apple desktops so, yeah it's an MVC pattern and in theory the model classes could be used outside of the platform they were written on... but you'd have to find a non-apple objective-c project that needs signal analysis code. Not once was I actually asked to do that. There was talk once of doing a windows tool for a client but like I said before, if that project had gone ahead I would have been on a windows machine or vm for a couple months. It's not like I could choose to use linux on that project cause I think it's cooler or something. If you're building a windows tool you have to use windows. That's life.
A few small errors There are 52 cards in a deck, not 50 `% 51` is wrong The reason you'd see `12 of Hearts` is because `printf("%d ", (popCard(&amp;deck_size,deck)%(13)));` The correct solution there would be to store the popped card in a variable before the switch. Your overall implementation does not remove unique cards If the first card drawn is Ace of Clubs, your program will remove the King of Diamonds from your list, next it'll remove the Queen of Diamonds... etc You should've been taught lists (and possibly linked lists) now. You'll want to remove the drawn selected card from the list. Otherwise dealing two identical cards is likely. Then error handling if size*numberOfHands &gt; 52 you'll get weird errors.
A) You should add void to any functions prototypes/declaration that don't take arguments `void display_card(void);` BTW that'd be cleaner if it took the card # as an argument. B) You should be using deck_size everywhere instead of hard coding 51,52. (Except for re-initializing) C) Out of bounds array access when j=size, and j=size-1 for (j = 0; j &lt;= *size; j++) deck[j] = deck[j + 1];` D)`display_card` prototype should take card number as an argument, and %(13+1) will allow you to print `13 of ...` when you'd want of `Ace of Next suit` E) Compiler warning in `popCard`, it doesn't change the value of size... which means even the first hand can give repeat cards F) After fixing E You need to reset `deck_size` at the start of a game, fixing just E causes: In this session- WINS:2 LOSES:3 TIES:0 Would you like to run the program again?(YES=1:NO=0):1 Your hand: 3 of Clubs 3 of Clubs 3 of Clubs 3 of Clubs 3 of Clubs Computer's hand 3 of Clubs 3 of Clubs 3 of Clubs 3 of Clubs 3 of Clubs F) `create_deck` doesn't create a King of Diamonds G) The hardest part to do well is `shuffle_deck`. I wouldn't worry about being a viable casino routine. EDIT: It does shuffle 0. So your implementation is probably sufficient. I) I wrote my own `display_hand` to get your code to run MORE EDIT: Basic logic: J,K,L... Good programmers can be Lazy: M,N Magic Numbers (52,13) suck: O Simple optimization: P I wish ~~you~~ ~~would~~ people would use `stdint.h`'s types FYI this is valid syntax: case 10: case 11: case 12: .... break; But try to avoid fall-through, compilers are good at implementing it when they see repeated code. But fall-through may be needed for simplicity, readability or manual optimization exposed by profiling. case 10: &lt;some code&gt; /* Intentional fall-through */ case 11: case 12: &lt;more code&gt; break;
This is the sort of task [OpenMP](https://en.wikipedia.org/wiki/OpenMP) is really good at. EDIT: int nums[10000]; #pragma omp parallel for for (int n = 0; n &lt; 10000; n++) { nums[n] = (n+1) * (n+1); } Parallel squaring of a bunch of numbers? Done by adding one line to the scalar version. Hard to beat that. Though this particular task is better suited to SIMD style vectorization than threading IMO. 
Allman
I really like this answer. I'm going to see if I can make some things click with it.
&gt; objective-c Not useful anywhere else. That's a bummer.
Oh sure, but this week's lesson and homework is for pthreads
Sorry, the first is probably overly specific, but reflects a very bad experience I had at a job a few years ago. I worked on a code base where the original developer had misunderstood the purpose of object oriented programming. He had a large number of #defined values, but in every module he felt the values needed different names, so he would redefine them. First file: #define module1_widget (85) Second file: #define module2_widget module1_widget Third file: #define module3_widget module2_widget This would have been bad enough, but the names weren't nearly that consistent. And, there were thousands of the root definitions which seemed to be randomly scattered around. Not only were there constants, like in the example, but all variables and functions used the same mechanism. Working on this horrible mess was like a constant scavenger hunt. As a contractor I wasn't allowed to clean it up in any substantive fashion. The typedefs comment is really pretty much an extension of that same thing. I don't have a problem with #defines or typedefs until they start hiding what is really being referenced to the point that the code is unreadable.
Raspberry Pi probably won't help you at all, because it introduces many features to the C language, but you need to learn _plain C_. You may want to read "The C programming language" by Dennis Ritchie and Brian Kernighan to familiarize yourself with C more. 
What operating system? On UNIX systems, traditionally, you simply open `/dev/dsp` and start to write audio at 48000 samples per second. Sadly, most Linux systems do no longer ship that audio driver, but you can emulate it with `padsp`.
We have tons of computations that are based on previous computations, all of which have to be compile-time values, which means `#define` unfortunately. `constexpr` would be a welcome addition to C so `#define` hell can be avoided.
Is `padsp` the only method to achieving this?
You could also load the appropriate driver (OSS?) to get a `/dev/dsp` device file Or you could link with a shared library to output sound. Or you could pipe into `aplay` which does the right thing and expects the same user interface. I'm pretty sad that they killed `/dev/dsp`. Such a great interface.
Then why don't you use C++?
SDL [includes audio routines](http://wiki.libsdl.org/CategoryAudio). And it's portable!
You might want to check out csound: http://csound.github.io
Because it has too much stuff, a lot of which each of us dislikes. The set of things we each dislike is not fully overlapping, so we wouldn't be able to agree what subset to use. It would also complicate the toolchain, static analysis stuff we do, and more.
I'm using a really strict coding standard, check my github (Garuda1) for detailed examples (check the recent projects, like `my_lib` or `new-game-of-life`). **There also is a python script (not from me, and in french) in the `deepthought-check` repo, which will tell you if you have mistakes in respecting the standard.** - my makefiles have to be named `Makefile`, and should all be like that: \#\# \#\# Makefile \#\# \#\# by Thomas Murgia \#\# login &lt;thomasmurgi@hotmail.fr&gt; \#\# \#\# Started on ?? Feb ?? ??:??:?? 2016 Thomas Murgia \#\# Last update Thu Feb 25 07:39:48 2016 Thomas Murgia \#\# CC = gcc RM = rm -f NAME = gol SRCS = main.c \ world.c \ cell.c OBJS = $(SRCS:.c=.o) all : $(NAME) $(NAME) : $(OBJS) $(CC) -o $(NAME) $(OBJS) clean : $(RM) $(OBJS) fclean : clean $(RM) $(NAME) re : fclean all - Maximum of 25 lines between the brackets of a function - one instruction per line - No comment inside a function - spaces are mandatory after keywords and commas (`sizeof` is the only exception) - `printf`, `scanf`, and most of the standard lib is prohibited: you have to make your own lib - `for`, `switch`, `break`, `goto`, `continue`, and `do` are prohibited to promote structured programming - this: if (condition) do_something(); or: if (condition) { do_something(); } is illegal, and should be replaced by this: if (condition) { do_something(); } or: if (condition) do_something(); - Maximum of 4 function per file - 2 space indentation - Every file should start like that: /* ** main.c ** ** by Thomas Murgia ** login &lt;thomasmurgi@hotmail.fr&gt; ** ** Started on Tue Mar 1 19:37:16 2016 Thomas Murgia ** Last update Tue Mar 1 19:37:16 2016 Thomas Murgia */ - maximum of 4 arguments per function - return values of system functions (like `malloc`) should always be checked - All variables shall be declared WITHOUT BEING INITIALIZED at the beggining of the function. A blank like after the declarations is mandatory. - The name of the function, the name of the files included with `#include` and the names of the variables declared at the beggining of the function have to be alligned on the same collumn - Pointer dereferencing (ex: `my_putchar(*(str+i));`) is okay but it is recommended to use `my_putchar(str[i]);` instead.
I'm not sure I can agree with an extremely strict coding style. There are no exceptions whatsoever? No comments in functions? I'm assuming it's to force you into breaking it into smaller functions. The 25 line limit seems insane though. Why can't you use for loops? How does prohibition of its use promote more structured code? No do while loops? Do they forbid their use in macros too? If you have to check success of allocations, which I 100% agree with, why can't goto be used for cleanup like in the Linux kernel? struct example *t; if((t = malloc(sizeof(*t))) { if((t-&gt;arr = calloc(100, sizeof(void *))) { // etc. } else { // long block of deallocation } else { // Deallocation } } Did that on mobile so it prob is badly formatted. Do you assert on each allocation instead? 
What the hell `__dead void something` :D
I'd like to do it multiplatform in the future, but I'm keeping it to Linux for now. I've looked into the couple of tools that you've listed, but I've not seen any examples on how to simply, "Play a buffer" in anything other than SDL, so I feel like I'll write my own mixer, have the inputs be modulated merge the contents of ALL the buffers into one play that buffer Part of the issue is that I haven't been able to find a multitude of documentation regarding other software synths. The feeling that I get is that a FOSS kind of software synth doesn't exist. In which case, I have to go and invent a bunch of things.
`/dev/audio` has been depreciated. At least, that's what I've found, and what some others said. Also, I haven't been able to get `padsp` to work. Maybe it's my specific machine, I'm not sure.
&gt; I'll write my own mixer, &gt; have the inputs be modulated &gt; merge the contents of ALL the buffers into one &gt; play that buffer Oh, well... yeah, I'm not surprised. I thought that's what you intended to do all along. For games, there are libraries (I imagine OpenAL covers a lot of this) that let you load up sound clips, position them in 2D or 3D, and trigger sound clips polyphonically, and the library will handle all of the panning, gain, and mixing. On iOS and Android, there are similar APIs for loading up audio clips so they can be played on demand quickly, e.g. so that you can have sound feedback when a button is pressed. But I don't know of any good libraries or APIs for dealing with streaming audio, where you generate the audio real-time, as opposed to having the whole audio clip available in advance. (If there were any, I'd love to check them out, since I do Voice-over-IP and have to deal with real-time streaming audio on every platform.) You generally just have to do pretty much exactly what you said: generate the audio, mix it yourself, and play the downmixed stream. There may be some APIs that let you generate multiple streams (as many streams as you have polyphony) and give each stream to the audio system to mix for you. DirectShow or DirectSound seem like maybe they might have this, but I don't really know anything about them. But all other APIs just expect you to provide a downmixed stream. The good news is, downmixing a stream is the easy part. All you have to do is take your individual input streams and sum them. If you want stereo, you just apply gain to the input stream to get different values for the left and right channels that you add when summing the buffer. I don't know how much more work you were expecting these APIs to save you. Since you're implementing a software synth, I assumed you wanted to implement your own algorithms for generating the sounds at the desired pitch and volume/velocity, your own effects, reverb/decay, etc. So the only part that it seems like a better API could do for you is summing the buffers, but I'd say that's so trivial as to not really be worth fighting over. The difficulties in using the various APIs, getting adequate buffering and low delay out of them, portability, etc., ought to be a much bigger influence on your decision of which one to use.
I hate to lecture, but there are a couple things here that are bothering me. The first is pretty minor, but please properly format your code; as it is the contents of each function are readable, but the function names not being in the code section bugs me a little. The second is somewhat less minor, but it'd be really helpful if you could provide us with some input and output to illustrate *how* your code is misbehaving. Your code is short enough here that it's not a big deal, but for future reference it can make a huge difference. &amp;nbsp; This is more of a personal preference and stylistic choice than anything, but descriptive variable names like `MAX` instead of `N`, `BGN` and `END` instead of `L` and `R` respectively, or `CTR` instead of `I` can be really helpful in illustrating what certain variables are meant to do. The more descriptive your variable names the easier your code is to read. If you insist on keeping one letter variable names, you could at least put some comments in to show the purpose of vague variables, but this can sometimes make code even less readable if you need lots of comments. Also note that sometimes it's okay to have a single letter variable name; the use of `i` in the for loop of `main` seems appropriate to me because it's just an index used in a simple manner, whereas `I` in `PARTITION` is a running total of array elements smaller than the last element of the array and isn't as straightforward. &amp;nbsp; Here are some minor changes: * The line `int main(void) {` appears twice; probably just a typo, but in case it isn't you ought to change it. * The variable `Q` is declared and filled with a value via `scanf` but is then never heard from again. If you don't need it, delete it. * If you change the for loop in `PARTITION` to use `J&lt;=R;` instead of `J&lt;=R-1;` you can save a few cycles by avoiding the calculation of `R-1` with each iteration of the loop, *and* remove the three lines immediately after the loop because these are effectively a special case of `J` being equal to `R`. Moreover, since you use `I+1` in each of those lines and the return statement, having the `I++;` done in the loop when `J` equals `R` yields the same results and allows you to `return I;` instead of `return I+1;`. This is to some extent personal preference, however I think it makes the code much cleaner and more efficient. &amp;nbsp; The biggest problem seems to fall within your `QUICKSORT` function and how you think it should work. [Quicksort algorithms](https://en.wikipedia.org/wiki/Quicksort) are predicated upon the use of "pivot points" and the recursive application thereof. Commonly the first pivot point is chosen as the last element within an array. You do this just fine with the assignment of `MIDDLE` to the output of the `PARTITION` of the entire array. From here however, you only run `PARTITION` on the part from 0 up to `MIDDLE-1` and from `MIDDLE+1` to the end of the array. What this does is produce pivot points within each of those partitions, but it doesn't necessarily complete the sort. In order to ensure that the sort is completed you need to have your `QUICKSORT` function run `PARTITION` an arbitrary number of times on certain portions of the array until it's sorted. To do this you'll need a way to see when the array and portions thereof are in proper order and then you'll need a loop in `QUICKSORT` to run `PARTITION` on a specific range if the array is not yet fully sorted. [This gif](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif) from the right margin of the wikipedia article linked above illustrates it better than I can with words. I'm going to be honest with you, I've never written a quicksort algorithm before, so I'm not entirely sure what the best way to go about this would be, but I can try to help guide you if you keep asking questions. Good luck! &amp;nbsp; **EDIT:** formatting, clarification. &amp;nbsp; **EDIT 2:** You could also construct `PARTITION` as a recursive function. I would do this as a function that first checks if the array between the given indices is properly ordered, if it is it does nothing, but if it isn't it produces a pivot point as your current `PARTITION` function does, then it uses the index created from this (what you have as `I` by the end of the current `PARTITION` function) to call itself from the lower bound up to that index minus one and again from that index plus one to the upper bound. I think recursion is probably the easiest way to understand and implement this function, and I hadn't initially thought of it because I was trying to conform to your original structure, but it should be possible either way.
I learned C from *C for Dummies* with all the appendices and thought it was excellent. I gained good habits from the examples it gives and truly think it was a great instruction manual. Dennis Ritchie's *The C Programming Language* is also a must read.
I found The C Book by Banahan et al. (linked in the sidebar) to be a solid and in depth introduction to the language, especially because it's freely available for download. If you insist on owning a physical book or don't trust free ones I have only ever heard good things about the K &amp; R book (also linked in the sidebar), but I've never personally read it. There's also a fair amount of support for CS50 (see again: the sidebar), a free online course offered by Harvard.
`#define` uses untyped syntax. It is also extremely ugly. It also creates a separate plane of existence for code (`#define` level vs. function level). And everything must be lifted to `#define` to be usable from that context usefully (as a compile-time value). So an absurd situation that to gain readability and type safety, you have to write the code as a static inline function (or such). To gain compile-timeness of the value, you have to use a #define. I don't want to choose between safety, readability and compile-timeness of values. I should have all 3.
Did you have a look at our sidebar? → Please research before asking this question. It has been asked numerous times in the past.
&gt; but i need floats Why? I consider using `float` a mistake. There are niche cases when it can be a good idea, but those are not cases that a beginner is likely to run into. Life is much easier if you consistently use `double` everywhere and pretend that `float` does not exist. There are numerous problems associated with using `float`, the most significant of which is a very limited dynamic range (only 24 bits of mantissa) which makes roundoff errors much more likely to bite you. All you have to do to use `double` is to use `%lf` instead of `%f` when using `scanf()`. For `printf()` it doesn't matter because the default argument promotions cast `float` arguments to `double` anyway, so `printf()` will never actually see a `float` value. But you can use `%lf` with `printf()` if you want for symmetry, but `%f` works equally well. Then you can remove all the casts and all the float literals. 
The only difference between a float and a double is that a double takes up twice the memory of a float. For this reason, doubles are much more precise. Here, there's no reason *not* to use a double - in fact, don't even worry about floats too much, because you won't really find a use for them until much, much later. Your code looks good, but it's very verbose, and with a lot of repeated calculation and unnecessary edge cases. I might write `solve_eq()` like this: void solve_eq(double a, double b, double c) { double discriminant = b * b - 4 * a * c; if (discriminant &gt;= 0.0) { double res1 = (-b + sqrt(discriminant)) / (2 * a); double res2 = (-b - sqrt(discriminant)) / (2 * a); printf("%lf \t %lf \n", res1, res2); } else printf("Complex roots.\n"); }
I don't think I've seen a single job posting here in the last eight months... If we somehow pick up a lot of recruiting posts I'll add one then.
Well, I know ALSA, so I can explain that one. It's pretty simple: 0. Use `snd_pcm_open()` to open a device for playing raw wave audio. Try `snd_pcm_open(&amp;handle, "default", SND_PCM_STREAM_PLAYBACK, 0)`. 0. Optionally, set parameters on the handle. You may want to control the number of channels (1=mono, 2=stereo, etc.), access (interleaved samples or not, only matters if you're doing stereo), format (16-bit, endianness), sampling rate, etc. You need to do `snd_pcm_hw_params_any()` to get the current parameters, change them with functions like `snd_pcm_hw_params_set_channels()`, then set the parameters on the device with `snd_pcm_hw_params()`. 0. Repeatedly use `snd_pcm_writei()` or `snd_pcm_writen`() to write data to be played (depending on whether you're using interleaved or non-interleaved). It just needs a buffer and number of samples (which ALSA calls "frames"). The only tricky part is, this is writing to the driver which is in turn writing to the hardware, so there's very limited buffering, probably only a few hundred milliseconds. So you need to provide however much data you have, check the return value to verify how much was written, and try to write more later. (If you're generating sound in small chunks that are smaller than the size of the buffer, it will simply start playing when the buffer is partly full.) It's your job to keep filling up the buffer as fast as it empties; if it becomes empty, you have to use `snd_pcm_recover()` to get things back into a sane state, and there will be a glitch in the audio as playback is temporarily halted. That's pretty much it. There might be some more fine-tuning, but just taking a buffer full of audio and pumping it to the speakers is relatively simple. I imagine SDL is equally simple, once you figure out what the APIs are.
Ok thanks. One more question: is it bad if i change all floats to doubles but i keep the floats literals?
In the strings? I am not too sure if it would matter as mentioned by \u\Rhomboid, but I would just convert everything to doubles and save yourself / your TA any possible headaches. 
I thought it would return a void pointer :P Anyways, thanks! Serves me right for accidentally using http://www.cplusplus.com/reference/cstdlib/malloc/ for reference :s
Yep I wanted to `free ( temp )` thanks for the spot! And yeah, I should probably do that as well :P
Yeah, you shouldn't use C++ references, because even in the areas where C and C++ overlap there will be differences like this. In C++, after all, you have to cast the result of malloc. If you're using Linux, `man 3 malloc` (or any other function) will show you documentation for C, including return types, possible error values, etc.
Oh! Good spot. Hmm. So what is the correct way of doing it?
The main reason is to interface with C code. Like if you use `strdup`, you have to use `free`. Or if the C code is going to take responsibility for freeing some memory, you have to use `malloc`.
&gt;And I am on Windows :( Which compiler? If you're using GCC, you can still rely on the man 3 documentation, which you can simply Google. There are a couple sites that have the man 3 pages reproduced in their entirety. If you're using MSVC, you'd be safer relying on the MSDN documentation. You can just Google "MSDN malloc", for example. In general I prefer Linux's man 3 documentation, but there can be differences in implementation, so like I said, it's safer to use the documentation for your particular compiler.
When I google "man 3 malloc", the first result is [this](http://linux.die.net/man/3/malloc), which happens to be my usual first stop for basic C documentation.
Okay. I was hoping this would be a, "if you provide it, they will come" kind of issue. It doesn't hurt to have the tag laying around for eventual use.
It isn't a big feature, it's just allowing functions to run at compile time, if they have no problematic effects. Tag them as constexpr and validate that only use compile-time available values. Kill one of the most superfluous uses of the preprocessor.
Did a more general review in case it helps. Readability: * Use NULL instead of 0 for your pointers and pointer checks * Recommend only using single letter variables for a very limited scope e.g. loops. They can be hard to follow in larger functions. Memory Management: * I would use calloc instead of malloc, because it will fill the allocated space with zeroes before returning the pointer. * If you use calloc I don't see any point in the list_node_init function as "node-&gt;next" will always be zero. However, if you want to keep the function it should probably be static. Because right now its exposed and if its called on a node in the middle of the list you will lose all the nodes after and they will leak as you don't have the node pointers to free anymore. * Mentioned in another comments * don't cast the pointer to the allocated memory. * missing * in sizeof in list_push_back * free conductor instead of temp in list_erase General: * You could add a static list_get_node_at_idx function that finds a specific node number instead of having to write a new loop each time. (As you haven't used pure C before, static functions are like private functions in other languages. A static function in a source file is not visible outside the file) * In the list_erase function you are essentially doing the same switch and free code. You could move this to a function to avoid the code duplication. static void erase_list_node (Linked_List *list, struct List_Node **current_node, struct List_Node **next_node) { struct List_Node *temp = NULL; temp = *current_node; *current_node = *next_node; free(temp); list-&gt;nodeCount--; } * A bit picky but I would rename "where" to "index" as you usually work with indexes in linear data structures 
If you change your data from an int to a void*, you can reuse this code for a variety of things.
I'm a little confused over that. Does it mean that one shouldn't cast `malloc` on C but they have to on C++? I'm making a program in C++ and each time I use `malloc` I get a warning (or an error that refuses to compile - can't remember which) that said can't assign `void*` to `int*` (or another type pointer).
&gt;Does it mean that one shouldn't cast `malloc` on C but they have to on C++? Exactly. 
&gt; Surely a non-static function defined only in a .c file is not visible outside of that Unfortunately, no. The `static` keyword (for functions. For variables it means something different entirely) is the only way to make a function private. 
Strange :P I just tried it, using my list_node_init Set a node to be 5 and it prints out a random number o_O Plus I get a warning for doing it "warning: implicit declaration of function 'list_node_init' [-Wimplicit-function-declaration]| " struct List_Node node; list_node_init(node, 5); printf ( " node num %d \n", node.data);
I sure have. I don't have time to read 5 books. I need a suggestion for the best. Hence why I'm posting. EDIT: Also I can find plenty of C books, but the thing is I want one suggested to me.
I wonder how deep that can go. Would eventually end up with stuff like int******** i = ********j; or the likes of that?
Thanks for the explaination I got my function here ( I don't see the need to pass the list itself in when it isn't really touched in there) But I am getting an error: error: request for member 'next' in something not a structure or union| static void erase_list_node ( struct List_Node** node) { struct List_Node* temp = NULL; temp = *node; *node = *node-&gt;next; free ( temp ); } I guess I just need to pass in the next node as well... That compiles, I now have this: static void erase_list_node ( struct List_Node** node, struct List_Node** next) { struct List_Node* temp = *node; *node = *next; free ( temp ); } and it works! thank you !
You can have as many pointer to pointer levels as you want :P It really depends on what you want to pass e.g. If you want to pass the address to a 2 dimensional "array" it would be ***
Damn that's pretty crazy :P
Swap the meaning of row and column. So your array will look like 3 1 2 3 2 1 3 3 1 2 4 4 2 2 3 2 Read the number of "columns" (4) and allocate 4 int*. Read the number of "rows" for "column" 1 (3). Allocate 3+1 int and put the 3 in the 1st element. Etc for each "column" 
I've never seen anything like this before, but if you include some more code and output I think we might be able to help you. I say this for two reasons: * Your `printf("Head is NULL");` line doesn't contain a `\n` but your output shows it formatted as if it would. This shows me that you're paraphrasing your output, which leads me to my next point... * If `head` is truly `NULL` then trying to access `head-&gt;data` should throw some sort of error, as should `head = head-&gt;next_node;` because those values aren't defined. So either there seems to be some disconnect between what you think is happening behind the scenes and what is actually happening, or you should be getting some errors that you're not sharing with us. If you update your content I think we can help you, but as it is I'm not sure how to proceed. I hope this helps!
Then K&amp;R is not the right book as it assumes some previous knowledge about programming. The C Book is likely better suited for you.
Can you show us the whole code?
I'd imagine that you aren't allowed to change the format of the input. If you are allowed then it makes the problem easy regardless of the solution and you don't even need to store anything since you're getting the column in consecutive numbers and can just multiply them together as you go. 
The **static** keyword tells the compiler that the function / variable etc belongs to the specific source file. So the compiler can do optimization based on this and it will avoid function clashes in the project and the compiler will not generate anything in the symbols that the linker can link with.
Thank you so much for the patience, attention and most of all thanks for the explanaitions! I'll pay attention to your tips, especially for the variable ones (this quicksort has so many auxiliar variables that It's being hard to remmember it one application with these generic names) You are right, I made the function but didn't applied it recursively. Now I'm doing it and my code is working :) Again, thank you so much!
I'm a bit confused. Is this a joke, or an actual recommendation of the book? Why is it a pdf file of an image instead of just the image itself? I took the time to copy and run the code, which was mostly just silly.
It's a propaganda poster in the style of these old Soviet posters. After some research I found that it was posted [here](https://np.reddit.com/r/ProgrammerHumor/comments/48is3x/c_propaganda/) first.
I would change the way `show_eq()` is implemented. If I understand correctly you want to avoid showing adding negative values and instead want to show subtraction when the coefficients are negative. Your existing implementation has some bugs that are typical of code that has a lot of repeated structure with the minor differences. For example here's some incorrect outputs your implementation can produce: -2x**2 - -2x - -2 -2x**2 + 2x + -2 -2x**2 - -2x + 2 Here's how I'd avoid that: void show_eq(float a, float b, float c) { char b_op = b &lt; 0 ? '-' : '+'; char c_op = c &lt; 0 ? '-' : '+'; printf("%.0fx**2 %c %.0fx %c %.0f\n", a, b_op, fabs(b), c_op, fabs(c)); } Notice now that the handling of `b` and `c` is now independent, so if the logic for a negative b works when c is positive, it should also work when c is negative, and vice versa. Making these conditions independent also avoids the exponential explosion of conditional statements and the need to repeat everything over and over.
Several questions to answer here, but the key here is a solid understanding of hex. In C ( and most other languages that I know of ) any numeric literal preceded with 0x is interpreted as hex. If you're not aware already, hex is just a way of representing a number in base 16 ( same as binary being base 2 ). Since a single hex digit can have 16 values, 0-15, this can also be represented as 4 binary digits; the corollary being that 2 hex digits is a byte ( 0xFF ). Hex is used a lot since it's a nice shorthand way of writing binary and once you get used to it, it's pretty easy to eyeball a bit pattern from a hex value. The #define you have in your example sets up the base address of that port, and each pin is mapped to a bit in that register. The pin in question is by setting pin 5 apparently, and pin 5 is set with 0x20 since the binary equivalent is 0010 0000 ( each hex digit is 4 bits remember? 2 in binary followed by 0 in binary ). PA5 = 0x20; PA5 = 0b00100000 This is also equivalent to PA5 = ( 1 &lt;&lt; 5 ); With the '&lt;&lt;' being a left shift. ( The value 0b1 shifted left 5 times ) If you're interested I'd highly recommend reading up on digital logic, truth tables, and bitwise manipulation. The last part of your post I think was supposed to mean \^ which is the C operator for a bitwise XOR. If you don't understand why that toggles that bit, google 'xor truth table' and see if that helps. Edit: words-n-such
Use a debugger or strategically placed printfs to narrow down where it is crashing
Tells the linker, not the compiler.
You can cut the string short by setting a character in the string to null (null termination), thus getting the first of the two strings. You can then get the address of the next character to get the string starting from there, giving you the second string (since a string is just a pointer to the first character in that string)
The compiler will mark functions and variables in the symbols as either global or local. The linker will then use the information in the symbols.
&gt; You have both too much error checking, and not enough. Checking the return values of memcpy and memmove is pointless; if they fail, the program will crash. Wow. He actually does check the return value of `memcpy`. For everyone who doesn't know: `memcpy` and `memmove` don't perform error checking. The return value is always equal to the first argument.
Another really big question. If I block signals when I enter a critical section this allows the thread to not jump to a signal handler until after it is called, correct? By default mutexes are not signal safe, but by temporary blocking signals it does become signal safe, yes? I'm very interested in learning new things and this seems like a way to say the code is "thread and signal safe". Is there any overhead from this?
It's for a library I'm writing to get that hang of C ( since practically there's so to choose from as is ) hence I want it to be as configurable as possible. So do you know if there's a lot of overhead to blocking all but the most severe signals (I.E SYSSEGV)? 
How reliable is this and how many projects use it? I have seen it before but I've heard the biggest issue is memory leakage. Heap allocated variables don't get cleaned up. I suppose if you went this route you can use the __cleanup__ attribute, but seems dodgy at best. I love implementing stuff like that but only if it's reliable.
The `cleanup` attribute is not going to help. `longjmp` does not unwind the stack as exceptions do. It directly jumps.
 printf("%s - %d - %d - \n", a, b, name); Your format specifiers don't match your variables. Also %s will read the whole line which is why `a` and `b` are 0
You're right, I wrote it down wrong. But now, the output is Marlkvin,12,77 - 0 - 0 So what can I write instead of %s ? Have strings to be at the end of the file? But then, what if I have several names that I want to read from a file? Do I have to use "" to do it right?
You'll need to parse the string you read in (the `%s` format specifier in `fscanf` will continue until it encounters whitespace). Maybe look at [strtok](http://linux.die.net/man/3/strtok) (or strtok_r depending on your requirements) EDIT: updated reference link, the one from tutorialspoint wasn't very good
As others have pointed out, your fscanf reads everything up to the first white-space character, including the numbers that follow the string. You could replace the %s format specifier with `%[^,]` which means "read, as a string, everything that isn't a comma". Even better would be `%8[^,]` because now fscanf won't read more than 8 bytes, so you won't overrun your buffer like you did here.
There haven't been many important changes in C11. I recommend you to learn the C99 book and then read about what new things C11 brings.
C99 is still the most important standard, unless you're doing certain embedded applications where only ansi c is available. C11 is cool, but you don't need to read a book to get it. 
I do COBOL for work and I really grew to love vertical alignment (something the COBOL guys have done forever) and brought it into my other personal coding. I'm talking about this (fake COBOL): MOVE SPACES TO VAR1 MOVE '001' TO VAR2 MOVE 0E0 TO VAR3 SET FLAG TO TRUE And carrying it forward to other languages: Dim t_Row_Start As Integer Dim t_Row_End As Integer t_Row_Start = g_Row_Start t_Row_End = g_Row_Start These examples make it look dumb but in real code it is great to quickly communicate that you are setting 3 or 4 variables from one place to another place, or to the same value, or something like that.
This looks like a _much_ safer / manageable solution. http://man7.org/linux/man-pages/man2/signalfd.2.html signalfd - create a file descriptor for accepting signals SYNOPSIS #include &lt;sys/signalfd.h&gt; int signalfd(int fd, const sigset_t *mask, int flags); DESCRIPTION signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7). 
'BF_safe_atoi64' is a (not very good IMO) macro that expands out following preprocessing. The last line of the macro is `(dst) = tmp;` , which will assign a value to c1 etc. So following the macro the values won't be undefined. Taking as example `BF_safe_atoi64(c1, *sptr++);`, the first line `tmp = (unsigned char)(src)` would become `tmp = (unsigned char)(*sptr++)`. As this is postfix increment, it means that tmp is assigned (following a cast) the value that sptr *currently* points to, then the pointer is incremented.
Ha, I figured this would come up. My interest is purely academic. I can call .dll's from this language, but doing that is nowhere near as satisfying as implementing it myself. That being said, it's proving a major pain in the butt.
I assume you're referring to lines 376 to 407 specifically, so that's all I'm going to talk about. &amp;nbsp; `BF_safe_atoi64` is a macro and not strictly speaking a function. What this means is that when it's called it basically gets inlined where it's called. This results in perfectly acceptable behavior for `c1`, `c2`, `c3`, and `c4` because if `BF_safe_atoi64` works according to plan they will get assigned a value as per line 382. If it doesn't go according to plan the `return -1;` lines at 379 and 381 will ensure that `BF_decode` returns a value of -1 because `BF_safe_atoi64` is a macro and not a function so those `return` calls are executed within `BF_decode`. &amp;nbsp; As for the use of `++` in pointer arithmetic, I am assuming that `*dst` and `*src` are pointing at arrays, so `*dptr` and `*sptr` should also be pointing to arrays. What this means is that `*dptr++` and `*sprt++` calls will return the current value being observed by `*dptr` and `*sptr` and then increment them as per the usual postscript `++` operator. For pointers pointing at arrays this will mean that `*dptr` and `*sptr` start at `dst[0]` and `src[0]` respectively and incrementing them results in their pointing to `dst[1]` and `src[1]` respectively. This form of pointer arithmetic allows for the easy traversal of arrays when using pointers without having to use extra variables for indices. &amp;nbsp; So just to be as clear as possible, line 393 (`BF_safe_atoi64(c1, *sptr++);`) will call the `BF_safe_atoi64` macro, passing `c1` as `dst`and `*sptr++` as `src`. You will notice that the macro only uses `src` once so as not to increment `*sptr` more than once, and instead uses `tmp` to store the value. `*sptr` just as a reminder points to `src[n]` where `src` is the pointer passed into `BF_decode` and `n` is indicative of an arbitrary index that will change based on the iteration of the loop, but because we pass `*sptr++` into the macro `tmp` will be `src[n]` while `*sptr` will now be `src[n+1]` due to our incrementation. I hope I made that clear, but if not please ask questions, I'd be happy to clarify. &amp;nbsp; Similarly, line 395 (`*dptr++ = (c1 &lt;&lt; 2) | ((c2 &amp; 0x30) &gt;&gt; 4);`) will assign the value of `dst[n]` (again where `dst` is passed into `BF_decode` and `n` is an arbitrary index) to what is returned from the right side and then increment `*dptr` so that it now contains the value of `dst[n+1]`. As for the right side, it does a bitwise left shift on `c1` of 2 (so if `c1` contains a binary value of say 110, the shift will add two 0's to the right, making it 11000, because it is passed a 2), then it takes `c2` does a bitwise and against the hex value 0x30 (110000) then does a bitwise rightshift of 4 on that (`c2` has to be less than 63 because of how the macro is designed, so it can at most be 111110 or 62, when we bitwise and it with 110000 we get 110000, 100000, 010000, or 0 depending on whether or not `c2` is larger than 48, 32, 16, or less than 16 respectively, the resulting rightshift will remove the trailing 4 0's and leave us with 11, 10, 01, or 0) and those two values are then bitwise or'd against one another. I hope that wasn't too confusing either, but again I'm happy to clarify as needed. &amp;nbsp; I'm not the best at explaining things, so if you're confused or I didn't cover something you wanted me to please ask. Also, I might be wrong about some of this stuff, because I'm not nearly as versed as some of our fellow redditors. If there are any inconsistencies or blatantly false claims above please let me know, I don't want to be a source of misinformation. &amp;nbsp; **EDIT:** I forgot that bitwise ands can result in 0. My bad.
You still haven't responded to the posts from the [last time](https://www.reddit.com/r/C_Programming/comments/48qc0j/cant_use_graphicsh_in_codeblocks_ep/) you posted. If you're not willing to put in some effort, neither is anyone else.
Sorry! This is my code, it crashes if I include &lt;graphics.h&gt; but I made this code at school and it works perfectly. #include &lt;stdio.h&gt; #include &lt;graphics.h&gt; int main() { initwindow(640, 480, "Window"); rectangle(100, 100, 200, 200); getch(); closegraph(); return 0; }
This is my code, it crashes if I include &lt;graphics.h&gt; but I made this code at school and it works perfectly. #include &lt;stdio.h&gt; #include &lt;graphics.h&gt; int main() { initwindow(640, 480, "Window"); rectangle(100, 100, 200, 200); getch(); closegraph(); return 0; }
Thank you
Sorry, I didn't know how to comment with code. I've replied to them.
I'm closing this post as the question has already been asked [here](https://www.reddit.com/r/C_Programming/comments/48qc0j/cant_use_graphicsh_in_codeblocks_ep/). Please respond to OP there.
And are you sure that you are compiling with a C compiler and not a C++ compiler? Because `initwindow` takes “default parameters,” which is something the C language doesn't have.
I already tried changing from. c to .cpp but it was the same, then I did replaced the libbgi.a with the new one they said in the comments... It doesn't work so yeah, maybe I'll use Turbo C++ just for this project (I have to make a game drawing cubes and stuff using &lt;graphics.h&gt;). I just have one question, does Turbo C++ has the same syntaxis that C? Because I don't know how to program in C++ till' next year 😒
So, in my school they use gcc so why I can't use it in my laptop? Everything is the same, same program, same version, same compiler and everything.
It might be that you used g++ (the C++ compiler in GCC) on both without knowing. Also try what AlexeyBrin said.
I see. Can you try to compile the following program and tell me what it prints? #include &lt;stdio.h&gt; int main() { printf("%d\n", (int)sizeof 'a'); return 0; }
http://i.imgur.com/j2kDBIJ.png?1 it prints this
A peer to peer chat/file passer w/ Libressl/Gtk. Also a game with Vulkan. 
OK, I *solved* the problem (I think) :). I can compile and run your code from Code::Blocks now http://imgur.com/4gKVOug , the setup process is a bit more involved than the one described in the linked video. Follow these steps: ===== * Install the latest Code::Blocks from http://www.codeblocks.org/downloads/26 use the codeblocks-16.01mingw-setup.exe ===== * Download and extract my compiled version of WinBGIm (compiled from the original sources with gcc-4.9) from https://dl.dropboxusercontent.com/u/56297644/2ew1fe2g3r3545t/WinBGIm6_gcc_4_9_2.zip ===== * Find where Code::Blocks was installed Program Files or Program Files (x86). - Copy graphics.h and winbgim.h to CodeBlocks\MinGW\include - Copy libbgi.a to CodeBlocks\MinGW\lib ===== * Be sure that you link with: -lbgi -lgdi32 -lcomdlg32 -luui -loleaut32 -lole32 
That means you are using a C++ compiler.
Really? So what should I do?
I'll let you know if it works, thank you.
It worked! But now look at the time to build a program is like 30s or 60s. That is okay? 
This is a video about C++ not C
Worked!
Nice, make a copy of the compiled winbgim I've sent in case I delete it from my DropBox. Happy coding :)
Anything goes except I fucking hate this... if (NULL == K) Gross. Yea, you put the NULL on the left to avoid the common K = NULL bug but you don't need that NULL there anyway. if (!K) is perfectly well-defined, as is if (K) It's like writing for (int i=0/1; i&lt;10/1; i += 1/1) ... I KNOW the integers are rational numbers but THAT'S NOT IMPORTANT RIGHT NOW!
Ha! Rear insertion.
When qsort actually calls int f(char \*\*a,char \*\*b) you'll have undefined behavior. http://stackoverflow.com/questions/559581/casting-a-function-pointer-to-another-type It's probably better to write a comparison function as int f(const void \*a, const void \*b) and then cast the arguments in the body.
So in a singly linked list (I was given a program that I had to convert over...): it would be like this: setNext(currentList-&gt;tail, newNode); currentList-&gt;tail = newNode; So I presumed I needed to update the head since I did not have a tail. I tried in my previous implementations doing setNext(NULL, newNode) or setPrevious(newNode, NULL) but wouldn't get the result I wanted either. //In my code I would call it setNode not setPrevious tho. (I don't get to pick function names...) ... SOlved it... I did take your advice but was also a big error in my test file.. I feel so stupid been trying new methods and going through for past 3-4 days... I learned a ton tho. 
/u/uwfperson - It's generally considered rude to delete your post. This makes it so that future readers who could have gained something from seeing your post can't do so.
If the lock is protecting 2 different resources then you should have 2 locks. Otherwise f2's "dostuff" should be in a separate functuon that f1 and f2 can call
I don't know if this is "correct", but one pattern I've seen is to write a non locking version of f2 and call that from f1 then have f2 just lock and call the new function.
What's so bad about a recursive lock?
pthread_mutex_lock doesn't support recursive acquisition.
And I just read your username and see that we share the same opinion on Java. 
Sorry /u/dragon_wrangler didn't realize. Just wanted to close it. Thanks for info. 
Upvoted for solidarity, not because I'm reveling in our shared suffering.
There is not much info about C11 threads available at the moment, other than by reading the C Standard obviously. They are not supported 'out of the box' by any major compiler. Your [first link](http://stackoverflow.com/questions/24557728/does-any-c-library-implement-c11-threads-for-gnu-linux) links to two libraries implementing C11 threads, maybe see if they come with examples or documentation? 
I searched through the Musl documentation and wiki, but couldn't find anything pertinent. What was the other library? I only see that Musl supports it and that hasn't gotten me anywhere. **EDIT:** punctuation. **EDIT 2:** I went back and now realize that Pelles supports C11 threads, but I had disregarded it as it seems to be closed source and only available for Windows. My bad, I basically only develop on Unix-like systems so I hadn't considered looking into it. Thank you for your answer! Sorry for my flippant indiscretion.
They're slower than non-recursive locks. (But they have their place of course).
It's quite common to do this, where a public "outside world" function gets a lock before handing over to the private function to do the work. 
Pthreads is the industry standard threading API, standardized in IEEE 1003.1 (POSIX). C11 threads are castrated pthreads designed as to be implementable on a wide range of platforms. They fail to make many of the guarantees POSIX threads make and aren't supported. I recommend every beginner to use pthreads instead, which is a very portable API with a long track-record of stability. Everybody knows pthreads and you can get answers to your questions easily.
Google Doug Schmidt's paper on 'Thread Safe Interface Pattern'. Implement a C version by defining a set of interface functions which only deal in mutexes and condition variables. These delegate all the business logic to private - i.e. static in your case - implementation functions which can assume single threadedness and contain no synchronization code.
Pelles C on Windows is the only implementation that I know of that has complete support for C11 (including threads). [Documentation](http://en.cppreference.com/w/c/thread)
Sure, using a recursive lock takes more CPU than splitting out functions into a version that locks the mutex and a version that you call when you already have the mutex locked. But that alternative takes more developer effort, and sometimes may be difficult or impossible due to design and crossing layers of your software architecture. What I really wanted to know is, is there a *design* reason to not allow recursive mutexes? In a quick Google search I came across a link to [this argument](http://www.zaval.org/resources/library/butenhof1.html) from a designer of Pthread mutexes, who basically says "Recursive mutexes are a sign of bad design, and you should never need them." But I think that's a bogus argument. In modern programming where getters and setters are commonplace, why can't I have /** Set `foo` and `bar` without letting anyone see the in-between state. */ void setFooAndBar(int foo, int bar) { lockMutex(); setFoo(foo); /* locks mutex recursively */ setBar(bar); /* locks mutex recursively */ unlockMutex(); } Yes, I *could* split those into `setFoo()` and `setFooWithLock()`, but that's a lot of bloody work to do for every setter. It also provides *less* guarantee of correctness; using a recursive mutex, I'm guaranteed that the mutex will always be correctly locked, but if I expose (even internally) a set-with-lock-held version, I have to *manually* verify that it's only ever called by someone who's holding the mutex. So, my question stands: what's so bad about a recursive lock? As you say, they have their place... would someone like to convince me otherwise?
/u/YoungSith, please don't remove your posts after receiving an answer. We all took time to help you, when you delete your post, that help is no longer available to future readers. Please don't make life difficult for future readers.
Can you clarify a bit, I'm not sure what you mean but vI'm assuming you want to just read the numbers from the file? Open a file stream (fopen) to the file. Use a while loop until the buffer string from reading the file is not null to read every line. In the while loop use fgets to read each line from the file. Tokenize the string with strtok to get the string of integers. Then use atoi to convert the string of integers to an integer if you'd like the number as an integer. Use "man fgets" strtok, atoi etc. from the command line to see the arguments of any of the functions (function prototypes), hope this helps :)
They are supported on FreeBSD 10 and above "implemented as a light-weight layer on top of existing interfaces (pthreads)". There is a [manpage](https://www.freebsd.org/cgi/man.cgi?query=thrd_create&amp;apropos=0&amp;sektion=0&amp;arch=default&amp;format=html) listing the equivalent pthreads functions and the few differences.
I don't necessarily understand pointers. And the calculations are completely confusing me. 
I'm not asking anyone to just do it for me. I could use google and copy and paste for that. I'm sort of not sure what questions I need to ask. I'm very confused. The if statement that I have, if minute out is less than minute in then add 60 minutes to it and subtract one hour. I'm not sure if that's used appropriately. I also was supposed to define constants globally, like CAR_FIRST_RATE=0.0, CAR_SECOND_RATE=1.50, and I'm not sure how to apply those into the calculations.
Hmm... so it's defining a function on the fly, then calling that function? And the function name is made up, somewhat, of the address of the a4 string passed originally? How does the [8][8] apply to the a4 string? The layers of pointers are killing me.
 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; /* The main functions gets two arguments, the number of command line arg and the command line args itself. argv[0] is the name of the program. */ int main (int argc, char **argv) { if (argc != 4) { fprintf (stderr, "Usage: %s OUTPUT-FILE NUMBER INPUT-FILE\n", argv[0]); return EXIT_FAILURE; } /* argv[1] should be OUTPUT-FILE, argv[2] a number (as a string! use `strtol' or similar to parse it, and argv[3] the input file. Do shit here: [...] */ return EXIT_SUCCESS; } 
A general note to you: Writing “NEED HELP URGENT” into your post is the best way to not get an answer. Instead, try to put the question into the title (for example, “How do I ...?”) and cut out how urgent your question is. Your emergency is not ours.
What should I type into google to find out how to bring in a text file and output a text file into a program in one command line? My googling has had little results
You will also have to account for 24 hour looping, eg you go in the garage at 23:00 (11PM) and come out at 1:30 (1AM), so its a 2 and and a half hour stay. The car rates are, I think, for variable parking charges, so a high hourly rate for short stay (say up to 3 hours) and lower rate applying for hours after that. Something like $10 per hour for up to three hours and $5 per hour thereafter. A more complex version would be adjusting rates for certain times of the day (peak/off-peak) but I dont think thats what the question means, because there would be start time and end time constants in there as well.
I'm usually pretty good at googling stuff, at least I think so. It's just this particular one I am having a hard time finding online and in the book we use in my class http://www.ime.usp.br/~pf/Kernighan-Ritchie/C-Programming-Ebook.pdf
This is what I was afraid of. I really like pthreads, and haven't had any problems with it, but I was wondering if C11 threads might be more portable. The answer, as I've found out, is a resounding no, not only because of the maturity of the pthreads code~~base~~ I've been able to find, but also because of a lack of implementation on the side of C11 threads. Thank you! Despite my disappointment, this has been an incredibly educational experience. **EDIT:** clarification
&gt; maturity of the pthreads codebase There is no “pthreads codebase.” There is a [standard](http://pubs.opengroup.org/onlinepubs/9699919799/) and every operating system has its own implementation of the API specified in that standard. I'm happy that I was able to help you.
Cool. I didn't know that, even though I'm running FreeBSD on my workstation.
&gt; Is it more efficient to use pointers? Does the latter do the same thing as using pointers? If not then what's the difference? Well, for the operation you listed, it hardly matters, since you're only dealing with integers. The actual raw bytes of the pointer is going to look an awful lot like the raw bytes of the integer, so there's hardly a difference in this case. But imagine this scenario. You have a giant system of drawers, 100x100 drawers. There's a book in one of the drawers. Your friend tells you she wants to read the book. You can do two things: 1. take the book out of the drawer, copy it word for word with a pencil to a blank book. This will take about three days. When you're done, put the original book back in the drawer, then give the copy to your friend. 2. Tell your friend which drawer the book is in by pointing to it. She just goes to it and reads it instantly, no waiting. From that example, you can see that one benefit is you don't end up copying data -- you just point to it. Another benefit: in C, every time you pass something to a function, it's by value. So say you are having a wedding and you want your friend to RSVP for it. If you do this by passing the value of the note directly, your friend gets a copy of it. They modify the note by writing "Yes, we'll come!" But you never see that because you sent them a *copy* of it. Your original note doesn't have their RSVP on it. Instead, you pass them the location of the note. They find the note and modify it to by adding "We're coming! We want the fish." You check the note later and see that they changed it. Okay, that example is a bit more far fetched. But the code would look like this: void rsvp(Note note) { note.append("we're coming!"); } Note note; rsvp(note); // they got a copy of this note.areTheyComing(); // false, they modified the copy. Ignore how ugly this code is please haha, bad design. void rspv(Note * note) { note-&gt;append("we're coming!"); } Note note; rsvp(&amp;note); note.areTheyComing(); // true!! they modified it in place. To use the previous "book in drawer" example, if your friend took the book and wrote notes in it or highlighted passages, it would only affect the copy if you passed by book value. If you had passed by pointer, it would have modified your original book. To conclude: using pointers, you don't need to wastefully copy data. Additionally, you can use pointers in a way that functions can have side-effects on the data you pass in. If pointers didn't exist, functions could never affect the data you pass in, since they'd always get copies. With pointers, you can change things outside the scope of your function directly.
None of those links show how to do the command line part which is my main problem. I'm currently following the advice of the other three people who replied told me and also trying to implement what localhort showed me. But thank you for your help. The links you showed me are actually all links I found when I googled on my own ironically.
Page 128 of the K&amp;R book: Command line arguments. Start reading! Edit: https://hassanolity.files.wordpress.com/2013/11/the_c_programming_language_2.pdf You might want to download that version as this pdf is text; you can search it.
Your problem is you're getting ahead of yourself. Focus on defining the problem first and then breaking it down into chunks. And then start filling in the details! So, what does your program ultimately need to do? Calculate the total cost for a vehicle parked in a garage for a certain amount of time right? Ok so let's break that down further. We need to calculate how much it costs each vehicle based on the time spent parked for: 1) xx hours and 2) yy hours So what's the best way to do this? How do we the duration a vehicle has been parked? Well, obviously there should be a start and end time right? So that means: duration = endTime - startTime Now we're getting somewhere! How should we organize this? What about a function that takes those two times, and returns the duration? But, since we can only return one value in c using return, that means we need to pass in variables that can be changed by our function and hold their new values once our duration function has exited. Since variables are passed by value as default, their values won't be changed if we can't figure this out. Hmm, I wonder if we can use pointers to accomplish this? Allright so we tentatively have the rough design for our duration in place, what else do we need to do? I guess we have to figure out how much it costs to park there right? So, a function that takes our duration, and our vehicle type, should be able to compute the cost? And since we have a few vehicle types, we'll need some sort of way to figure out how to match up the different costs with each type. Hmm. I suppose we could use an enum for the vehicles and a switch statement for this? I'm sure there's a few ways to structure this if we really want. What should our branches do once they figure out the vehicle type? Well, we need the cost for the first xx hours and yy hours so... That means we must have 2 different costs right? What about we have two variables firstCost, secondCost, but how do they get their values? What I do know is once we have those, then it seems pretty easy to figure out the total cost. Maybe something like durationFirst * firstCost + durationSecond + secondCost? 
Great examples, thanks. 
Is part 1 a different executable? And your passing files that it generated in as command line arguments? ./analyzeRecords output.txt 100 sorted.txt then you extract the name of these arguments internal to your program. char *inputfilename = argv[1]; int num = atoi(argv[2]); char *outputFileName = argv[3]; File *fl; // fl = fopen(inputfilename, "r"); char *buffer[1000]; //make it large enough while (fgets(buffer, 1000, fl) != NULL) printf("This is one line of the file: [%s]\n", buffer); You can also use standard in file redirection ./analyzeRecords output.txt 100 &lt;sorted.txt In which case you don't need to make a file pointer for your input, nor open it. Just put stdin as the 3rd argument of fgets. I have not compiled or checked any of this. This is merely a heading for you. I can check back later. There are certainly some caveats and dangerous areas to many of these libraries. Which require you to use them exactly right. But I've found fgets to be pretty safe and powerful for what I need.
I'll add. fgets puts a c-string in buffer. Meaning it's terminated with the null character '\0'. Which is nice because you can use strcpy. It delimits on new lines, but it also doesn't consume the newline. So it places it at the end of the c-string, right before the null character. You'll have to loop through yourself if you want to change this.
As far as the assignment to c goes, the results are the same either way: c gets the value 1. Without further context, there is nothing in particular one can say about efficiency. The C language specification gives an abstract model for how C programs are supposed to work, but a compiler is free to interpret the code however it would like as long as the result is *observably equivalent* to what the abstract model says. If the body of a function was *entirely* either one of those, a C compiler would be free to simply elide the variables altogether, as there's no way to observe their creation or values; nothing depends on them. If the function was not declared with external linkage, calls to it could be completely elided as well. Now, as to the idea of a variable and what it means in C: A variable binds a name (such as 'a', 'b', and 'c' in your examples) to a *storage location*. The C language does not say anything about where the storage location will be, in particular, but does talk about its *lifetime*, or what part of the program text in which it is valid to refer to it. In fact, unless you do something in the program that constrains the compiler to do otherwise, the location may well be a register rather than memory. When you refer to a variable in an expression, the variable may evaluate to one of two values depending on its context. These two values are named according to the positions they are in when you look at an assignment expression: `&lt;l-value expression&gt; = &lt;r-value expression&gt;;` An r-value expression evaluates to the value stored at the storage location that is bound to the variable's name. But an l-value expression evaluates to the *address* of the storage location. So the expression `c = a` means "fetch the value stored at the location named a, fetch the address of the storage location c, then store the fetched value at the fetched address" The `*` and `&amp;` operators just provide a way to turn l-values into r-values and r-values into l-values. C is somewhat unique among languages today in allowing you to do this uniformly. Another language that had an interesting take on this was BLISS, in which all variable expressions evaluated to their l-value, and you had to use the `.` operator to turn it into an r-value when that was desired. Apparently a lot of people found this a bit confusing, but I'm not sure whether the situation with C is any less confusing in general. Anyway, turning the l-value into an r-value via `&amp;` and then manipulating it or passing it somewhere is one of those things that can prevent the compiler from using a register reference as the l-value of a variable. So, this can cause the compiler to need to allocate some extra storage for it that it may not have otherwise needed to. But if all you do with the address is store it in another variable and then turn it back to an r-value via `*`, then this is observably equivalent to just using the register reference as the address and storage in memory may not be necessary. Anyway, I hope this sheds some light on the actual processes that the compiler will go through when translating code using `*` and `&amp;` into machine code, but the end result will vary greatly depending on the particular compiler, the optimization flags you use, and even the version of the compiler. This isn't really one of the things C gives the programmer tight control over.
[Relevant xkcd](http://xkcd.com/1651/) (not that it's much help to you)
[Image](http://imgs.xkcd.com/comics/robotic_garage.png) [Mobile](http://m.xkcd.com/1651/) **Title:** Robotic Garage **Title-text:** But listen, if getting your car out from under the pile is REALLY important to you, we do have an axe you can borrow. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1651#Explanation) **Stats:** This comic has been referenced 6 times, representing 0.0059% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d0pdogr)
I don't know how helpful it will be to you, but I've always like http://www.tutorialspoint.com, I tend to use it as my goto C reference. 
Damn, I never expected someone to write this much for my post. I appreciate it (get some sleep after that all nighter). It's going to take me some time to see through this in detail. 
thenewboston should not be watched, he frequently says incorrect things in his videos, and in general, will also not help you really dig deep and understand what it is that you are programming.
Let's see. Let me give you the 5 cent explanation for some of those. Pointers, literally, these point to a memory location allowing you to modify a single copy of something, instead of making many copies. Pointers don't have much use until you start working with functions. int b = 0; //integer int *a; // defines a pointer a = &amp;b; //&amp; = address of (in this case b) *a = 0; //* = value of (changes value of b, which a is pointing at) Arrays in structs, like arrays, but in a struct. Take up as much space as the number of elements times the data type length. Nothing much to these, ask if you have a more specific question about them. Function, like methods in java, except they are not part of a class, they know only what you tell them. They are used for separating and reusing specific bits of code. Files, the only difference between binary and text files in C is that with text files it may do some automatic processing for you (like line endings and so forth).
Thanks for the write up, it was very helpful. 
I also watch the CS50 from Harvard
http://shop.oreilly.com/product/0636920028000.do This book was so awesome helping me understand pointers. I would recommend it if you have the bucks for it.
The conditional operator cannot be used as an lvalue. I don't know where you got that idea, but it's wrong. The standard explicitly says as much in &amp;sect;6.5.15/4: &gt; The first operand is evaluated; there is a sequence point after its evaluation. The second operand is evaluated only if the first compares unequal to 0; the third operand is evaluated only if the first compares equal to 0; the result is the value of the second or third operand (whichever is evaluated), converted to the type described below.^(92) If an attempt is made to modify the result of a conditional operator or to access it after the next sequence point, the behavior is undefined. Where footnote 92 is: &gt; 92) A conditional expression does not yield an lvalue. 
I'm not sure what videos those are but try other videos. https://www.pluralsight.com/courses/c-lang-fundamentals
C++ let's you do this, but C doesn't. You might be able to do something like: *(right_plus_3 ? &amp;pair[0]: &amp;pair[1]) += 3; But I'm in mobile, so I didn't test it to make sure it's OK.
Please do not post text as images. Do not post source code as images either. Post text as text. Use a paste bin if you like.
I'm sorry, but your code is nigh unreadable in this format. Please never link pictures of your code, not only does it result in arbitrary splitting of functions, as is the case here, but it also forces us to write out lines we want to discuss with you instead of being able to copy and paste. For future reference, you should either copy and paste your code here, with proper formatting, use a [paste bin](http://pastebin.com/), or use a [github gist](http://gist.github.com). Your code here is short enough that you could easily have posted it with your plea for help. This would also be a great help for the project specifications, specifically the line: "The program output should look exactly like the examples below..." which is followed by no such examples. Finally, I have no idea what *the* "redeclared later" error is, because when I try to search for it I get a plethora of options. Please include output and error messages as they are given to you, because otherwise it can be impossible to tell what you're talking about. Now on to helping you. For starters, I don't see a single loop which is an explicit requirement of your guidelines, and the only way I can think of implementing error handling as you are meant to, but you may be adding that once you fix your other problems. You seem to be seeding `rand` so I'm not sure why it's giving you the same value over and over; as far as I understand it shouldn't be, but I have next to no experience with this function in C. Your score pointers aren't being written in the `run` function as far as you've shown; the temp variables you declare get counted up appropriately, but without assigning any values to the pointers you pass that doesn't help you. I suspect the error you get is a consequence of this, because you don't provide them with initial values either, so your `printf("\nUser score is %d", userScore);` line is trying to print an undefined variable. I'm confused by the declaration of `r`, `s`, `p`, and `q` in `getChoice` because after declaring them you don't use them. If you provide me with more info (full source, errors, output, guidelines, etc...) I'd be happy to help you more, but for now that's all you'll get out of me. I hope this helps! **EDIT:** formatting.
I love easy stuff
In `getChoice`, your loop condition is incorrect, and will always result in an infinite loop: 73. }while (numChoice != 1 || 2 || 3 || 4); 
I suggest you check again. The discrepancy is with the fscanf statement missing the '\n'. When corrected, your code compiles and runs with your data set and yields w = 12 vertices for the first loop and w = 15 faces for the second loop.
 if(choice == 'q' || 'Q') You can't do this in C. You need to do: if (choice == 'q' || choice == 'Q') If you do it like the first one, it will check if 'Q' is true, and it is a non-0 integer so it will accept it as true.
&gt; They have the same representation but different values. This is a good point, and similar representations which have different meanings show up quite often. For instance in int array[2][2]; int (*p)[2] = array; int *q = array[0]; it is quite possible that `p` and `q` have the same representation, but `p + 1` is naturally different from `q + 1`. Same with a pointer to the first member of a struct, which is likely to have the same representation as a pointer to the struct itself.
Signed in just to upvote, cheers for this!
doing gods work! thanks a ton :)
Hey check out a YouTube channel called Bluefever Software. Pointers, functions are really explained well there, if you are into learning through videos. You can also refer to this https://www.cs.cf.ac.uk/Dave/C/
I am good in learning through videos. I will definitely check it out. 
1. Depends on the definition of `t` 2. The AMD64 SYSV ABI uses registers. Zeta-C uses the heap. *Conceptual* support is the key: What is the concept that you discussed in class for how a function is called? Pay close attention to the verbs used, and then think about which of the potential answers defines those verbs most succinctly. 3. What do you think "strictly-typed" means? Try using a popular Internet search engine to look up the wikipedia pages for each of these, and note that one of them doesn't have a wikipedia page. Reading the pages might be helpful as well.
i think time is the answer. Its give the current time as seconds. I don't need the current date
More accurately, you can find the current date by passing the result of `time()` into the `localtime()` function.
&gt; y[ii] = arrayvalue; More like "Where is `arrayvalue` even declared?" And where is `arraysum` declared? Seriously, OP, you need to read the output from your compiler. It should *definitely* be giving you some errors, and strongly hinting at what you need to do to fix it. Also, try running this code mentally in your head, or with pencil and paper. See if what you wrote matches what you wanted it to do.
 y[ii] = arrayvalue; What do you think the value of `arrayvalue` is the first time you hit this line of code?
&gt; so it's defining a function on the fly, then calling that function? No... it's not *defining* a function on the fly. C doesn't have that capability (unless you're running some crazy elaborate thing that has a compiler built in to itself). It's taking a pointer, offsetting that pointer, and the value of that offset pointer is a function pointer (the address of a function's entry point). The offsetting would happen if the function pointer is part of a struct. (Or it could happen if you had an array of function pointers, and need to get an element other than the 0th.)
You could simulate a cache
:P i was hopping for something fun lol but not a bad idea...
It isn't particularly hard to implement [Conway's game of life](https://en.wikipedia.org/wiki/Conway's_Game_of_Life), and would be a fun little experiment in cellular automata machines (CAM). Reading out the "board" of cellular automata could be done a few ways: 1. With writing out a [PPM](http://netpbm.sourceforge.net/doc/ppm.html) file ever 50 or something iterations, then writing a bash script to compile all those images to an animated gif. See [this](http://unix.stackexchange.com/questions/24014/creating-a-gif-animation-from-png-files) 2. The non-stupid way would be to use [SDL2](https://www.libsdl.org/download-2.0.php) to create a window and update it every iteration at some fixed frame rate. There are quite literally an infinite number of SDL2 tutorials on the Internet, and it is super easy to pick up. [Here](http://www.willusher.io/pages/sdl2/) is one that seems to cover everything you ought to need.
This is a good idea. If it's too much for OP to develop the image/GUI side of this, he could look at doing any sort of simulation where the visual aspect isn't the most important output. I had a final project years ago (not in C), that required determining the optimum number of elevators that should be installed in a given building given the size, floors, number of occupants, etc. 
Cross posting is okay, but please note that there is no language called C/C++. If you are programming in C++, ask in /r/cpp. If you are programming in C, ask here.
i have never even touched gui. the teacher is expecting something to run in the command prompt
I do both.
You could write a simple MIPS (or other RISC ISA) CPU emulator.
I'm interested in that. Where would I start? Writing a switch case with all the assembly language commands?
You could do the [8 Queens Puzzle](https://en.wikipedia.org/wiki/Eight_queens_puzzle). You might have to be creative to use some of the more complex requirements (2-d array of pointers, nested struct) -- maybe have flashy features to store results, change the size of the board, change pieces (max number of knights?), or something. Edit: a calculator or mathematical expression elevator might fit the bill, too. 
No GUI required. Several of the images on the Wikipedia page are black and white. You could just print the "board" every iteration.
Yeah! I like it! Thanks!
You could also write your "board" to the command prompt. I recently used [ANSI Escape Sequences](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes) to clear the terminal-output before 'redrawing' the output of my script. So basically you clear the command prompt with something like printf("%s", "\033[2J"); // '\033' is the ASCII ESC character And then write the output representing your board to the command prompt again.
www.cplusplus.com/reference/cctype/toupper
Write a ray tracer that renders a scene from a simple geometric description (sphere of color RGB, radius R, at XYZ, etc.). Make sure the internal data structure describing the scene involves all those required elements, unless you used them in the parser. Use [Netpbm](https://en.wikipedia.org/wiki/Netpbm) for output, to keep it simple. I don't know what's meant by "automation" or "source decomposition."
Please do not link to C++ documentation for C code. Even though `cctype` is supposed to be equal to C's `ctype.h`, there are some times subtle differences in behaviour and specification between the C and the C++ versions of these headers.
0b isnt standard? Huh well that's useful information thanks.
"value of" should read "value pointed to by". The value of `a` is the address of `b`. The value pointed to by `a` is the value stored in `b`.
I did an original gameboy emulator as a final project once, would not recommend unless you have done one before.
What's your error? How are you invoking gcc?
In general, if something goes wrong when you try to build/compile your program, you should provide at least the error message and the compile command that is ultimately executed - there's a surprising amount of information there. With that out of the way, it sounds like you have what's called a linker error rather than a compilation error (the distinction is important, but you can worry about that later). In simpler terms, you may have simply forgotten to mention `file_a.c` when compiling your program, and so `gcc` couldn't find the actual function `swap` because it didn't know to look in `file_a.c`: it couldn't *link* the function call in your main source file to the function body in `file_a.c`. So more generally (ignoring Makefiles and a few other things to simplify the example), something like gcc -o program_name program_name.c where `program_name` is the name of your program won't work if `program_name.c` uses anything defined in `file_a.c`. Instead you should have gcc -o program_name program_name.c file_a.c 
If you want to keep it all as close to what you have now I would recommend making an (integer) array of 5 elements, each corresponding to one option, and initializing all of them to 0. As an option is picked by the customer you can increment that element, allowing you to keep track of if they want more than one of anything as well as if they purchased one at all. If you're unfamiliar with arrays or can't use one for this project, you could just make 5 integers all initialized to 0 and increment them accordingly, but it's up to you. Personally I would change your design to rely on an array to track your number of components. You can write an input function that accepts this array and increments accordingly. Then have a special input that calls for a total and summary to be given. This could be accomplished with a summary function that uses a constant array containing prices with indices that correspond to your component array's indices; if you format it correctly you can print a table with number of components at a base cost with subtotals for each and a grand total at the bottom. Hope that's not to confusing, but ask if you have any questions, I'd be happy to answer them. Hope this helps!
I only recommended arrays because they can save you some typing, but if you're not comfortable with them you can just have 5 separate integers, such as `int SPACE_ENGINE_COUNTER = 0;`. Then you would increment each within your individual cases, so `case 1` could look something like this: case 1: totalPrice += SPACE_ENGINE_PRICE; ++SPACE_ENGINE_COUNTER; break; Then outside the loop you could either make some if statements to avoid printing lines for things that are not bought or list them as having 0 corresponding orders. I'd personally opt for the latter, but I'm not sure how pretty your output needs to be, and I'm very lazy. So for instance, it could look something like this: printf("Number: Name: Individual Cost: Subtotal:\n"); printf("%d Space Engine %.2lf %.2lf\n", SPACE_ENGINE_COUNTER, SPACE_ENGINE_PRICE, SPACE_ENGINE_COUNTER * SPACE_ENGINE_PRICE); /* The rest should follow in a similar pattern */ printf("Total: %.2lf\n", totalPrice); **EDIT:** note that I did not space these appropriately. Like I said, very lazy.
You can make an `if` statement that checks for a given value of a variable and executes a `break;` statement to end a loop preemptively. Can you be more specific with the manner of problem you're experiencing with `scanf`? **EDIT:** Alternatively, you could have a running total that you check with each iteration of the loop along with `day`. I'm not 100% sure how your code is supposed to work, but I'm assuming that `penny` is such a running total, and as such you could modify your loop like `while (day &lt;= 31 &amp;&amp; penny &lt; 1000000)`. I hope that I got that right and I hope this helps!
I've been staring at code for most of the day and my eyes are beginning to get tired. I had removed my "if/break;" statement because when I had it set to "endBalance" - which would have been the user inputted balance of 1000000, my code would not run at all. while (day &lt;=31) { printf("%3d %9.2lf %9.2lf\n", day, deposit, penny); penny *= 2; ++day; deposit = penny - deposit; if (pennies &gt;= endBalance) { break; } }
It may be a typo, but `pennies` is not a declared or defined variable that I can see anywhere. Have you tried using `penny` instead?
Also, my apologies if my code is hard to read or what I'm saying isn't making much sense. I will do my best to clarify what I'm trying to say and ask, but I'm really new to this and will take any help that comes my way.
Don't worry about it; I've made much bigger mistakes, I was just hopeful it was as simple as that :P What sort of input are you feeding it and what kind of output are you receiving? I don't see anything inherently wrong at a quick glance but I'll keep checking it.
Most definitely helpful!! Honestly, just having someone kind of go through it with me is great. It more or less reinforces what I'm trying to learn.
That seems awfully strange. I recommend plugging in a line that outputs `endBalance` to ensure the value you pass it is the value it stores, and then posting back here with an example input and output.
Don't worry about it, I'm glad I could help and congrats on getting it working :) I'm not sure why the white space would make a difference, but it apparently does. If anyone who knows reads this please leave me a reply, I'm honestly curious. 
Was it too hard?
Your question got caught in our spam filter. I unblocked it right now. I'm sorry that it was invisible before.
MinGW includes a printf wrapper that handles the C99 formats. You should try a different MinGW distro because the distributor is supposed to patch out/remove the gcc configuration that tells it that `ll` isn't supported, which was true before that wrapper was in place. (I use the mingw.org packages and they emit no warning for your testcase.) Or just use `PRId64` and disable that warning. 
Thank you, I had forgotten about that while trying to figure out why I couldn't get my code to run correctly. I will do that. :)
I'm pretty sure that Visual Studio will work just fine with MPI debugging if you use MS_MPI https://msdn.microsoft.com/en-us/library/windows/desktop/bb524831(v=vs.85).aspx . Just create a C++ command line application and put your code in there. If you prefer to use C, just change the extension of the generated file to .c from .cpp and the compile will switch to C mode. Be warned that VS 2015 support for C is not stellar, they support most of the C99 standard. If you use any C11 functions you will probably need to adjust your code for Visual Studio. 
First off: format your code by inserting four spaces in front of each line. Copying and running your code I get the following: $ gcc -o merge merge.c $ ./merge Enter the number of elments : 10 the elements are : 5 3 21 4 9 6 8 5 0 -19 sorted order of the elements : -19 0 3 4 5 5 6 8 9 21 which actually looks correct to me. Do you have a sample input which fails? 
Your code is perfectly fine. It is both readable, efficient, and does what it should. The only thing you might need to change is the `scanf()` invocation.
Pretty good in general - just a few minor comments: Try to avoid globals wherever possible - I would suggest that you move the definitions of `nRows` and `nCols` inside `main()`. The formatting could use a little improvement too, e.g. use 4 spaces for indenting (not a tab), and be consistent about your placement of braces and your indentation. Try to remove excessive white space - a single blank line to separate chunks of code is fine, but more than that, or unnecessary blank lines, can make the code hard to read. 
It looks good. My complaint would be it's not very reusable. Try to rewrite magicsquare to take in the matrix variable as a parameter, and return the boolean value isMagic instead of returning void. Avoid all printf and scanf inside magicsquare - just do the computations and return the boolean. All the scanf should be done before magicsquare to fill up the matrix variable, and all the printf done after. This separates the input/output and allows you to reuse the magicsquare function in other situations. 
Oh! I forgot to mention that I did a change to your loops, check it out.
Yes it will. As I said, I'm looking for something other than visual studio. One reason is that it is difficult to write for openmpi and C++ in visual studio, and be able to compile the same code with mpicc/mpicxx for linux. 
Pretty good overall. As another commenter mentioned, scanf should generally be avoided. This is because someone could feed a huge number as standard input which would cause overflow (undefined behavior in C). You can add a width specifier to scanf so that you'd only read say the first 4 digits, which would guarantee that there'd be no overflow. Generally, however fgets and strtol. The former gets a line of input and the latter converts it to a `long` handling overflow and other stuff like that for you.
&gt; This is because someone could feed a huge number as standard input which would cause overflow (undefined behavior in C) How does this apply to `scanf()`?
you have void tablePenny() declared 2 times. Didnt do C in a while is return valid for void
Cool, thanks. The reason I've chosen C as a first programming language is efficiency. Most of my peers picked up python and moved onto higher level languages. But I've stuck with C and just want to be super efficient, I mean that's one of the main reasons people program in C right?
So the general consensus is restrict scanf() to positive numbers aka unsigned int? (correct me if I am wrong). Or else use fgets/strtol?
What if you want to write a program that reads 20MB of vector data from disk and POST a status update to a web server? Your function is hard-coded to read from the keyboard, and write to the console, even if you don't want it to. 
scanf() invocation, what do you mean by that?
What alternative method could be used as apposed to scanf? I know I can read from a textfile, not sure if that requires scanf
From the standard section on scanf (7.21.6.2p10) &gt; "Except in the case of a % specifier, the input item (or, in the case of a %n directive, the count of input characters) is converted to a appropriate to the conversion specifier. If the input item is not a matching sequence, the execution of the directive fails: this condition is a matching failure. Unless assignment suppression was indicated by a *, the result of the conversion is placed in the object pointed to by the first argument following the format argument that has not already received a conversion result. If this object does not have an appropriate type, or __if the result of the conversion cannot be represented in the object, the behavior is undefined.__
`magicsquare` should be declared static since it doesn't require external linkage. Same goes for `nCols` and `nRows` if those were to remain globals (which they shouldn't). 
Thank you so much! This is really detailed.
You have two good options. The first is to read the file character-by-character using `fgetc`. You convert the character you get into a digit using some basic ASCII arithmetic. When you read in the '\n' character, you're on the next line, and when the function returns `EOF` you're at the end of the file. The second method is to read a line at a time into a character buffer using `fgets`. You can then parse this line however you want to extract the digits.
Also, this could be implemented much more easily with one char tokens like 'A', '2', ... For the numbers and suit, then use a lookup table to map to the strings. 
Your Card structure has two pointers. A pointer only has enough storage associated with it to hold a memory address of where to find something. A pointer is not a buffer - it cannot hold the content, it can only hold the address of where to find the content. So your major problem is when you are trying to strcpy into the pointer. Because the pointer does not have any memory for holding content - remember it only holds the address of where to find content - you cannot strcpy in this way. There are a couple of ways you could fix this. One way is to change the definition of Card so that 'value' and 'suit' are char arrays that have enough space to hold the longest string plus terminator. A second way is to just do a simple pointer assignment instead of a strcpy call. In this approach, instead of copying the content you are just setting the memory addresses of where to find the strings. The strings will be located at a fixed spot in memory, and the Card pointer will just have that proper memory address. This will work because when you use string literals in the code, the compiler places them at a static memory address, so you know the location in memory will remain unchanged during execution. A second lesser problem is that your list of strings for each rank has an entry called "One" which should not be there. So you actually have 14 ranks in your array of strings instead of the expected 13. EDIT: Similarly your definition of "deck" is also wrong. You are declaring deck to be an array of 52 pointers-to-Card-structures. What you actually want is 52 Card-structures.
This does not do what you think it does. Your text file does not need to be inside the Visual Studio project. You need to include the full path to the file in your fopen() call, or pass it in as a command line argument and use that.
I'm actually an `ed(1)` kind of guy.
You would have to consult the calling convention of your platform. If it's anything like x86_64 Linux, the parameters are passed in registers and not the stack, so the contents of memory is totally irrelevant. The call site will attempt to load 'a' converted to a double into XMM0, the string literal in RDI, and 1 into RAX. The function will expect an integer value in RSI, so whatever random garbage was there before the call is what will be printed. 
It's totally possible! You'll need two tools: `/` and `%`. For example, `23923 % 10` gives you the last digit: 3. `23923 / 10` produces `2392` ... which you can then do the first operation on to get that last 2, and so on in a loop. Now, this will get you the digits backwards, right to left. If you need to get the numbers left to right, the process is similar, but with other numbers besides 10.
Here is my answer from Stack Overflow: On AMD64 with the [SysV calling convention](http://www.x86-64.org/documentation/abi.pdf) (used by nearly every system but Windows), the first few arguments to a function are passed *in registers.* That's why you don't see them on the stack: They aren't passed on the stack. Specifically, the first few integer or pointer arguments are passed in `rdi`, `rsi`, `rdx`, whereas the first few floating point arguments are passed in `xmm0`, `xmm1`, and `xmm2`. Since `a` is passed in `xmm0` but `printf` attempts to read a number from `rsi`, you won't see any correlation between the number you supplied and what is printed out.
The part I was stuck on was "Should I increment the reference before or after passing". I'm assuming that it should be incremented before passing it to another thread. Hence, it is the callers responsibility to increment the reference before passing to the callee, and the callee's responsibility to decrement the reference when they are done. Also, a quick question, how do you know isValid will always work? As soon as release is called the reference count is decremented to 0, it will be destroyed, hence isValid would be attempting to access invalid memory. Hence, is there a reason for such a check?
I think this is the right way to do think.
I was thinking of wrapping malloc and calloc for something like this which will make it easier. I've seen it done only once before, but I believe it had something to do with this... struct ref_count { /// Destructor void (*dtor)(void *); /// Atomic Reference Count _Atomic int refs; /// Pointer to start of data void *data; } This way it can automatically destroy itself safely. There is also very little overhead. While the above may not look special, what the example did next (at least to me) was. void *ref_malloc(size_t size, void (*dtor)(void *)) { // Note we allocate past the end of ref_count ref_count *rc = malloc(sizeof(*rc) + size); if(!rc) return NULL; rc-&gt;dtor = dtor; rc-&gt;refs = ATOMIC_VAR_INIT(1); // Data now points to the allocated region outside of the struct rc-&gt;data = rc + 1; return rc-&gt;data; } And due to this, getting the original ref_count metadata can be done with simple pointer arithmetic void ref_free(void *data) { if(!data) return; // Obtain original ref_count ref_count *rc = data - sizeof(*rc); rc-&gt;dtor(data); free(rc); } Hence, through this, I could atomically increment and decrement the reference count easily enough. void ref_inc(void *data) { ref_count *rc = data - sizeof(*rc); atomic_fetch_add(&amp;rc-&gt;refs, 1); } And decrement void ref_dec(void *data) { ref_count *rc = data - sizeof(*rc); int refs; /// Asserts refs &gt; 0 assert((refs = atomic_fetch_sub(&amp;rc-&gt;refs, 1))); /// Note above we capture the previous ref count from atomic_fetch_sub, hence safe to use. if(!refs) { rc-&gt;dtor(data); free(rc); } } Would this be on the right track for making a simple reference counting memory allocator? Edit: Was thinking, would it be safe to remove data pointer as a whole? As the data pointer CAN be used to assert that pointer passed is correct (since any random pointer minus an offset will hold garbage values at that location anyway), there are too many ways for this to go wrong anyway. If it isn't a valid pointer, then it's accessing bad data, and could result in a segmentation fault. Yet, then again, if it isn't a value which points outside of the heap, the assert can in fact prevent some memory corruption. Hm, in fact, it could even prevent the double-free issue as well. Lets say the data gets decremented twice, right? Then most likely the data is in valid memory in the heap, hence this check to compare rc-&gt;data == data, would work fine since rc-&gt;data would be garbage and wouldn't point to the same address data would. So an assert check whenever we increment, decrement, or free data could save hours of frustration and debugging... Edit2: Moved fetch_sub to replace atomic_load in assertion. Edit3: Captured the atomic return of fetch_sub
So what does the -g flag do? In the man page it says it creates the debug symbols, but where? Inside the executable?
He is not telling to not use scanf. He is just saying to not use it inside the function. Have it separate. Have one function that creates the matrix and then pass that to the magic_square function. Try to have one function do one thing.
What output are you expecting? The code you posted didn't produce the output you posted. The code you posted prints 't' and has undeclared variables triangleslope and altitude.
&gt; triangleslope = alt / base; This is doing integer maths. So 5/3 = 1. or 10/20 = 0. To avoid switching to floating point you should calculate the length of the bar at each step, doing multiplications before division. while(two &lt; alt) { int len = some calculation involving alt, base and two for (one = 0; one &lt; len; one++) { printf("*"); } printf("\n"); two = two + 1 }
I had for (int i = 0;i &lt; alt;i++) { int len = (base * (alt - i)) / alt; for (int j = 0;j &lt; len;j++) { printf("*"); } printf("\n"); } e.g. with 5, 14 it gives ************** *********** ******** ***** **
It is easier if the caller increments and the callee decrements, yes. This means that even if the caller releases their reference before the callee even runs, there's still a ref count of at least one so the object will be valid. And it obviously makes sense for the user to clean up after themselves and call release. In C++ you have smart pointers in the standard library which implement ref counting for you. They're really nice because they make this whole process almost automatic if you use them instead of naked pointers. I'm sure you could implement something similar in C but it probably won't be quite as clean without automatically called destructors and RAII. As for isValid() after thinking about it more, you're right. I'm not really sure that serves much purpose and may or may not tell you anything useful in this situation. It should just be the callers responsibility to pass you a valid reference. It's either redundant in the case where the caller ensures they provide a valid reference, or possibly inaccurate in the case that they don't.
Before printing out whether it is a palindrome or not, print out the value of `f`
it keeps counting after every iteration, so how do i get it to reset. i think thats the problem
 f=0;
Hey, good start! It looks like your `answer` variable isn't actually necessary in this version. Also, most of your `if` statements should be `else if`. A couple of options for expanding this program, of varying difficulty: * Put the program body in a loop, so someone can run multiple calculations * Accept a file name on the command line where you will write out a log of all the calculations * Accept more than two variables (so the user can sum a list of 10 numbers, for example) * Accept a string entered by the user and parse out the operation (so the user could enter `9+3`) * Let the user enter multiple operations in their input (like `4+3*2` - don't forget to account for the [order of operations](https://en.wikipedia.org/wiki/Order_of_operations))
It always works. "if" compares a value of scalar type to 0. A zero int and a null pointer always compare equal with zero. This is true even on machines where the memory address 0 is a valid pointer and NULL is something else.
thnx :P
thanks for the feedback man really helps 
Just need to think of your requirements and then come up with an equation that fulfills them. So for 3, you want 3 wide at te widest point, but decreasing outward from that. * row 0 = 1 * row 1 = 2 * row 2 = 3 * row 3 = 2 * row 4 = 1 So what can cause something to suddenly rise and then fall, well an absolute value can do the opposite if you subtract, so let's do that and then just subtract that from our maximum number. So let's try, *3 - |2 - row|* * row 0 = 3 - |2 - 0| = 1 * row 1 = 3 - |2 - 1| = 2 * row 2 = 3 - |2 - 2| = 3 * row 3 = 3 - |2 - 3| = 2 * row 4 = 3 - |2 - 4| = 1 Perfect! Got it on the first try. Now you need just to generalize the solution for any maximum value.
It was just hard enough the deadline would have made a wooshing sound as it flew past. But I did get very far. I instead made a simple brick breaker game in a day instead near the end of term. Which sadly was still heads and toes above everyone elses final project.
I'm a little confused, in that I can't figure out if you're just spamming links to coursehero or actually looking for help. If you do want help with this problem, post the code you've come up with so far and ask specific questions about parts you don't understand. This is not somewhere to find someone to do your homework for you.
why would i be spamming im literally desperate. i cant get my code to run and that doc would be helpful to see if i went wrong someplace or not. and my friend has actually been posting these questions-i even told him NOT to post on this sub because its not the appropriate place to. like i said desperate. No need to be berating.
Post your code and any error messages you're receiving.
The language isn't especially important, but it would be a good idea to stick to one as you start out. Otherwise you are going to end up confusing yourself. I looked up the "Mario Problem". I suggest you try solving exercises by thinking through how you'd do it yourself. In fact with this problem it's pretty easy to do it manually. For anyone else reading this who isn't familiar with the problem, given the number of rows, you have to draw a triangle like this: ## ### #### ##### ###### You are only allowed to print spaces, # symbols and line terminators. If I were having a hard time figuring out how to do this programmatically, I'd open a text editor and try to replicate the pattern (like I did above), by just typing spaces, #'s and carriage returns. I'd count the number of spaces and #'s I had to type in each row and try to figure out a pattern. Then, pretend you are telling another person how to do what you just did and write out instructions for them. Once you have that done you'll have a much better feeling for how to complete the task. Try breaking each step down into something you know how to write a bit of code for. Once you can do that for each step, put all the pieces of code together. There are many different ways to work through algorithms. For example I have used my fingers to work out surprisingly complex solutions. They have the advantage of being available wherever you are. Trick is to find a technique that works for you and to break problems down into extremely simple repetitive lists of instructions. Another technique I often use when I can't figure out how to write a big complicated program is to break it down into smaller pieces and write a little program to just solve that part of it. For example, write a little program that given the line number just prints out a single line of the triangle. A very specific suggestion I'd make for this problem is to replace the spaces with something else like a period. Printing multiple spaces makes it a lot harder to tell exactly what's going on. I often use variations of this technique in my everyday coding. Hopefully this doesn't require a TL;DR, but if it does: TL;DR The specific language isn't important. Divide and conquer to solve any problem.
Right, that's the number of rows I mentioned.
If you consider the first iteration of the loop, i=0. You change 0.25\*B [0], 0.50\*B [1], 0.25\*B [2], and store it in arr [0]. The title implies that for the first element at index 0, you want 0.25\*B [0] + 0.5\*B [0] + 0.25\*B [1]. You'll have a similar case at the end of the array, but in general it seems you are accessing the wrong elements. Aditionally, the array "arr" and "B" aren't declared. Those are the most glaring issues from my interpretation of the title. Edit: Also there's a missing }, unless I missed it. And see /u/_ArrogantAsshole_ 's comment for a possibly more clear explanation of the array indices.
1. The question asks you to use each numbers two neighbors. These are B[i-1], B[i], and B[i+1], not B[i], B[i+1], and B[i+2] 2. You will need to worry about edge conditions. B[i-1] when i is 0 is undefined, since i-1 is -1 and B[-1] is invalid. The description tells you what to do here. Same is true of B[10]. 3. Given (1), you will need to be careful when calculating the weighted averages, since A[i-1] will pick up the calculation from the previous iteration of the loop and you probably want to use its original value. You may need to use additional storage.
Can't you do something like, int tmp = -1; for (i = 0; i &lt; 9; i++) { if (tmp &lt; frequency[i]) tmp = frequency[i]; } printf("%d\n", tmp); I guess you should use amount, but can't you just iterate over all of the things, and if you find a number with more 'hits', replace it as the biggest number. If that didn't solve your problem, I think you'll need to clear it up more for me.
Just a little bit. But hey, check out `ved(1)`, it's a cute little editor.
How would you solve the problem if you weren't bound by C11 atomics? Perhaps you are missing some feature you did not expect them to have?
By using the same lock around `ref` and `unref`. ref { lock(obj-&gt;reflock) increment reference count and do overflow checking unlock(obj-&gt;reflock) } unref { lock(obj-&gt;reflock) decrement reference count, do underflow checking and potentially free the object unlock(obj-&gt;reflock) } **EDIT:** Note that you'd need to keep a reference to the lock in `unref`, just in case you have to free the object. Or the `object_free` function could unlock `reflock` before destroying it, which also means `unref` should not unlock it in case `free` gets called. There should also be some check in `ref` just in case it's waiting on `lock()` while `unref` is actually running and about to free the object. This stuff is hard... Or am I overthinking things? Or are there safe assumptions which others are making that I am not?
Ah, that can be the case, too. In my opinion it's tedious to do reference counting in C as copies spring into existence in thousands of situations and it's really hard to keep track of them unless you watch very closely.
No reason for two loops when one will do. for(x = 0; x &lt;= 9; x++) for(i = 0; i &lt;= 99; i++) if (response[i] == x) frequency[x]++; should simply be: for(i=0;i&lt;100;++i)frequency[response[i]]++; ----------- for(x = 0; x &lt;= 9; x++) if (frequency[x] &gt;= frequency[x+1]) What you actually want here is to have a test value, and compare it to each value, keeping track of the best one: int tmp = 0; for(x = 1; x &lt; 10; x++) if (frequency[x] &gt; frequency[tmp]) tmp = x; At this point, `tmp` is the most popular value, and `frequency[tmp]` is its frequency. 
Where precisely would a double free result from this? Due to the assertion wrapped around fetch_sub (lets say I fix it so that refs is initially 0, not 1, so it would work correctly), if another thread attempts to decrement, it will fail that assertion because it would be 0. So, lets say count is 1, since someone else pointed out that reference counting refers to other references to the same object. T1: asserts that count != 0, decrements from 1 to 0 T2: asserts that count != 0, fails since it is already 0. It is true that if the ref_count is freed while the thread is inside and before the assertion check, it will invoke undefined behavior, however that comes down to the caller's responsibility to correctly managing their reference count. Anything else I'm missing?
Start by deciding how you want to store your set. Maybe an array or a linked list? Or if you're really keen, something like a binary tree? This would depend on how advanced your class is. Then build your structure and typedefs, at least with an initial guess. Write your header file using these structs and types. For coding, I would start with the `add(set, ElementType)` and `setdisplay(set)` because they complement each other and should be quite simple. Next, I would do `equals()` and `belongto()` since they should build on the initial effort. As you go through these, you may need to make some modifications to your structures and types. Once you've completed those, `union()`, `interset()`(should be intersect?), and `symmetricdiff()` should be easy, if you leverage the earlier functions.
The previous comments are correct. However, you should clarify your requirements. Should the value of the neighbors be considered before or after they've been updated? For example, if you have `{20, 40, 60}` then the first element should be replaced with 25, but should the second be 40 (neighbor evaluated before correction) or 41.25 (neighbor evaluated after correction)
&gt; int set aset, bset, cset; That line seems wrong. Start by defining what `set` is (that is, it's some `struct` (or probably, a pointer to some `struct` considering how it's being passed around) with particular backing fields). Then define initialize. Then define the interface value. There are many ways to do backing for a set of numbers. You could use a binary tree (advanced: a self-balancing tree). You could use a hash table. You could use a linked-list or an array and do search operations (this is probably the easiest, although the binary tree isn't much harder for probably better results).
I'll just add, don't use that main.c for testing as you develop. Fill the sets with known values so you can predict the results in advance and confirm that they match what you're getting.
Because if I want to link the `.o`'s to use them in another program, I don't want to move them all in the same place manually. I want `gcc` to look for object files in only one folder (the `obj` folder) instead of looking for a specific file 3 folders further.
&gt; typedef struct Node{ ElementType data; int link; boolean occupied; } node; &gt; &gt; &gt; &gt; typedef node linkedlist[MAXLENGTH]; That's really not how how to build a linked list. What is `int link` supposed to represent? What is `boolean occupied`? &gt; typedef int boolean; Consider using `&lt;stdbool.h&gt;`
Do you mean something like this? SRCS := $(shell cd src &amp;&amp; find -type f -name '*.c' | sed 's/\.\///g') OBJS := $(patsubst %,obj/%.o,$(basename $(SRCS))) obj/%.o: src/%.c $(CC) $(CFLAGS) $&lt; -o $@
 void initiate(linkedlist p){ int i; p[0].link = MYNULL; for(i=1; i&lt;MAXLENGTH; i++) p[i].occupied = FALSE; } Will this work? 
RES guessed your output to be: **** /* 4 characters no spaces */ * ** /* 4 characters 1 space */ * * /* 5 characters, 3 spaces */ But I can't find a pattern in that which matches your example, nor any constraints on the values in input. If limited to small values you could use a pattern array, for larger values you'll want a nested for loop, and conditional processing void runConditional(int input[], int numEntries) { int idx; char* pattern[]={"****","* **","* *","* "); for(idx = 0;idx &lt; numEntries; idx++) /* sizeof(input) is invalid, expected to return the sizeof(int*) */ { printf("%s\n", pattern[input[idx]); } } void runConditional(int input[], int numEntries, int charsOnALine) { int inputIdx,patternIdx; for(inputIdx = 0; inputIdx &lt; numEntries; inputIdx++) { for(patternIdx = 0; patternIdx &lt; (charsOnALine-1); patternIdx++) /* -1 allows for the last character to be a * */ { if(patternIdx &lt; input[inputIdx]) { printf("*"); } else { printf(" "); } } printf("*\n"); /*If the last character must always be an * */ } }
How about this for creating your object files: &gt; CFLAGS += -c &gt; $(CC) -o $(NAME) $(OBJS) $(CFLAGS) -o build/ and to link your binary &gt; $(CC) $(wildcard build/*.o) $(LDFLAGS) -o bin/foobar 
&gt; for(x = 1; x &lt; 10; x++) if (frequency[x] &gt; frequency[tmp]) tmp = x; Hallejuh! This is the golden line right here! I should've known I'd have to do another loop. Thanks man, your explanations were on point and I understood all of it.
Note that `VPATH` is a feature of GNU make, [standard make](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) doesn't have it.
I did do what you said and it worked swimmingly, thanks!
A WAV file provides a header which includes stuff like the samplerate, sampleformat and channels. So first you need to parse this header and extract the raw audio stream. The most simple library for this is [libsndfile](http://www.mega-nerd.com/libsndfile/). The only problem you have now is that the audio streams could have a different "format" (sample rate, sample format or channels differ). The task of normalizing the audio is called resampling. Here you have some libraries which can do the sampling: https://ccrma.stanford.edu/~jos/resample/Free_Resampling_Software.html If both streams have the same format you can append one stream to the other and create a new wav file by prepending a header. It's not a super easy task if you're new to digital audio, but you can do it. If you want an all-in-one solution I would go with ffmpeg, which supports loading, saving and resampling. It's just a bit more complex library, but also a very cool one :P Feel free to ask.
[libsndfile](http://www.mega-nerd.com/libsndfile/) looks like it might be useful.
I'm not sure I fully understand the nature of your system and equation, but based on the line: &gt; each feet below 8 add 0.00300 to rateofgrowth I sort of assume that if the user gives 8 there is no change to `rateofgrowth` while each subsequently lower integer value adds `0.003` to it. As such I think you could do something like this: double rateofgrowth = 0.1 + (0.003 * (8 - input)); Assuming that `input` is the variable storing user input, and obviously this should be placed after input acquisition, but before the line assigning the end value to `totalpopulation` (as per your line above). If I misunderstood the constraints of your problem please clarify. I hope this helps.
I would do this: for( int i = 0; i &lt; 3; i++ ) { printf("+---+---+---+\n"); printf("|"); for( int j = 0; j &lt; 3; j++ ) { printf(" %c |", grid[i][j]); } printf("\n"); } printf("+---+---+---+\n"); You may need to rearrange some of the code depending on your axes. 
You're going to want to read up on [printf](http://pubs.opengroup.org/onlinepubs/009695399/functions/fprintf.html), which is a function that takes a format string (which is a string with argument conversion specifications) and arguments, and prints the formatted string (the format string with the conversion specifications replaced with the corresponding values of the arguments. There is a format conversion specified `%c` which will replace a character, then for each box you will have an argument that will either be `' '`, `'x'`, or `'o'` depending on the corresponding array value.
Let's assume your WAV files have the same sample rate and frequency (16bit/44khz most likely), then you can do this: Sum the PCM values together, and divide the sum by the number of channels (in your case, 2). It is that simple. If that doesn't sound right, you can reduce the 'gain' of one or the other or both channels by using a multiplier for every sample. *1.0 = no gain, &gt; 1.0 louder, &lt; 1.0 quieter. Think of 1.0 as 100%.
when manipulating data in an array, is it proper syntax to do it in pointer arithmetic or with the array syntax. Or is it all just up to personal coding preference? 
Personally, I have never seen anyone do *(ptr + 1), besides for instructors/professors making sure you know what you are doing. If I found it in real code though, I'd be mostly pissed at the unnecessary complexity. Now, that's not saying the pointer arithmetic is not used, and it has MANY uses. As I showed in my test file, you can easily read past an offset, x, by doing (ptr + x). Also, the most commonly used is when you iterate through a cstring, like such... char ch; while((ch = *ptr++)) do_something_with(ch); Which the above will post-increment ptr to the next index, and retrieve the value at the current index. Hence, it will increment itself after retrieving the character at the index, stopping once it reaches a null terminator '\0'. Or my personal favorite, making a substring using pointer arithmetic and printf precision. char *str = "Hello World"; printf("%.*s", 9, str + 1); Which would read beyond the first character in str, and only 9 letters, so just "ello Worl". [Seen here](http://ideone.com/M86GVV). Now, note that these examples do not do what your professor most likely wants you to write. *(ptr + 1) is unnecessary, and IMO ugly. It CAN be a personal coding style preference, but most likely it's a bad practice, so no, you won't be using it outside of class most likely. Both are proper syntax, as they are legal C. Edit: Had so much fun I missed the point of the question. No, SHOULD use the array syntax for things like... for(int i = 0; i &lt; 100; i++) arr[i] = i; // NOT *(arr + i) = i
Tons of programmers said that and we had a tons of programs for which the volume didn't scale on a logarithm scale. 
So it sounds like your difficulty is with `hasWonDiagonal()`. There are only two ways to win with a diagonal line, top left to bottom right or top right to bottom left. To check the first case, you only have to look at cells `[0][0]`, `[1][1]` up to `[BOARD_SIZE - 1][BOARD_SIZE - 1]`. Hopefully you can come up with a quick loop for that. For the second case, you'll need to look at cells `[0][BOARD_SIZE - 1]`, `[1][BOARD_SIZE - 2]`, up to `[BOARD_SIZE - 1][0]`. There's a pattern here as well, so that's just another loop. Note that for these you don't need nested loops.
`*(ptr+1)` would in fact designate `'e'`, a `char`. &gt;all arrays decay to their first element in C They decay to a pointer to their first element. And only sometimes. &gt;*ptr would yield "H" `'H'` again. Another thing maybe worth mentioning is that `*ptr` is an lvalue whereas `ptr+1` isn't: you say "yield" equally in both cases, however in the first case `*ptr` yields the memory location currently containing `'H'`, not the actual value of `'H'`. It does not retrieve the value unless you use it in a context where the value should be retrieved. For example, `*ptr = 'X';` never yielded `'H'` at any point. (ignoring the string literal issue for a moment) 
&gt;Is it just a learning lesson in how pointers work I'd say it's more importantly a lesson in how arrays really work. They're showing you that the array syntax does no magic. The name you refer to the array by is really just a pointer, and the array[i] syntax is just a shorthand way to say you want to move that pointer along i number of values. array[1] literally means *(array+1). In a sense, there is no array. It's a convenient fiction we use while writing code to think about a block of nameless memory and the pointer we use to interact with that memory. By behaving like an array is a real thing we also make it possible for the compiler to warn us when we write some simple mistakes, so it has value both as a mental picture and as a bug prevention tool. Eventually you'll come to see that *everything* in a program is just numbers in memory locations, and all the seeming structure of your programming language is an illusion like this lesson about the array. Even the instructions you write to look at and manipulate these numbers, those instructions are ALSO just numbers in memory. All your code is. You'll learn function pointers soon and see that too.
#include &lt;stdio.h&gt; int main(void) { // your code goes here int i=0; int sum; int flag=0; int arr[5]={0,1,0,4,2}; while(flag!=1) { sum=0; for(i=0;i&lt;5;i++) { if(arr[i]&gt;0) { printf("*"); arr[i]=arr[i]-1; } else { printf(" "); if(arr[i]&gt;0) arr[i]=arr[i]-1; } sum=sum+arr[i]; } printf("\n"); if(sum=0) { flag=1; } } return 0; } return 0; } got the answer:: thanks everyone
`foo-&gt;bar` is a more convenient way of writing `(*foo).bar`. Any time you have a question about an operator with an unpronounceable name, google "&lt;language&gt; operators". If you do that for "C operators", then you get [a nice wikipedia page](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B), assuming you rightfully ignore the first few hits on some garbage `tutorialspoint.com` spam-blog. 
`a-&gt;b` is a shorthand for `(*a).b`.
You mostly use it for accessing variables in a structure. So if you had: struct something { int variable1; char variable 2; } typedef struct something Something You would access variable1 using Something-&gt;variable1. Do understand this you would need to know about pointers, structures and malloc. Hope this helps. EDIT: formatting
There are precedence rules in C/C++. For example, `x + y * z` is `x+(y*z)` not `(x+y)*z`. For the operators `.` (accessing a field in a `struct`) and `*` (derefrencing a pointer) `.` is done before `*` in `*a.x`. However, it is incredibly common to have a pointer to a `struct` in C, so writing `(*a).x` everywhere is not only annoying but makes the code illegible. So, a shorthand, `a-&gt;x` was invented. In C, `a-&gt;x` is the same, by definition, as `(*a).x`.
First, you're using typedef incorrectly, and secondly that's incorrect. The `-&gt;` operator acts on the pointer to a structure, like this: struct something { int variable1; char variable2; }; struct something *my_something = malloc( sizeof(struct something) ); my_something-&gt;variable1 = 2;
&gt; The exceptions are when the array is the operand of a sizeof or &amp; operator, or is a literal string initializer for a character array. I found this bit rather interesting. I've never tried passing an array by reference before: #include &lt;stdio.h&gt; void pass(char words[]); int main(void) { char foo[] = "i am an array"; pass((char*) &amp;foo); return 0; } void pass(char words[]) { int i; for (i=0; words[i]!='\0'; i++) printf("%c\n", words[i]); }
Back when I knew Basic and Pascal, I decided to learn C. So, being pre-internet, I bought [Power C](http://mixsoftware.com/product/powerc.htm) for about $20 (this was about 1988). It had a pretty good book/reference manual. I started entering the sample code before reading. I first saw the `-&gt;` operator and thought it was a typographical error. I typed in the sample code, omitting the `&gt;`. It didn't compile, so I put the `&gt;` back in and it worked. That finally motivated me to actually read the book. Doesn't answer the OP question, but it's a relevant story about the "good old days". 
It's exactly like the "." operator, just used when you have a pointer to an object instead of the actual object.
What makes you want to learn C or C++ first? There are certainly other programming languages out there that are more accessible to beginners either due to their syntax or how much they do for you as a programmer. I would certainly recommend python as a first programming language if you are finding C particularly difficult.
Presumably in the header file you have the forward declaration of the function 'swap' that you have defined in 'file_a.c'. If the program runs when you do not include the header file, the function is only used after it is declared and therefore the compiler does not need the forward declaration. Therefore, if it complains when you do include the header file, have you used types in the forward declaration which are different to in the definition or a different return type? As others have said, it is quite difficult to debug a problem when we do not know the error that was returned.
I'd write it more like that: int iterator[2]; int grid[3][3]; iterator[0] ^= iterator[0]; iterator[1] ^= iterator[1]; while (iterator[0] ^ 3) { puts("+---+---+---+\n"); putc('|'); while (iterator[1] ^ 3) printf(" %c |", grid[iterator[0]][iterator[1]]); putc(10); } puts("+---+---+---+\n");
After giving it some thought, I finally noticed you weren't saying there was an issue with the assertion, but the block further down where I again atomic_load, which definitely would result in a double free (or any amount of frees). I made the change to capture the return of fetch_sub and use the conditional based on that, I apologize if I misinterpreted your response. 
Well, to start with, `struct my_vtable` does not contain pointers to functions. Trying to assign pointers to functions to those pointers won't work, at least not the way you want it to. Beyond that - whoever wrote that standard deserves a punch in the face. Several times. That is *horrendous* practice to make a hacky `switch` replacement, all for the equally bad reason of essentially 'because I can'. Insult to injury, the code is messier and harder to understand that way. OP, I suggest that you try to take this up with whoever is enforcing the standard, because it likely has other brain-damage that makes writing and maintaining code a mess.
It's the coding standard of one of the best (if not the best) computer science school in France, I have to use it. I hate the lack of `switch` but at least our codes look all the same.
Might be good at teaching CS, but it sounds horrible at teaching programming.
&gt; It's the coding standard of one of the best (if not the best) computer science school in France Obviously not if they insist you don't use language features because "I can create my own inefficient and brittle version!".
Right, and I have and things seem ok. I just want to confirm that the behavior is defined, before pressing forward under the assumption it is, and then walking past that 128 bits and have succesive calls to va_arg() give me garbage.
&gt; you should add some kind of constructor function If you do this, also add a destructor function. You should never `malloc()` in a library that your users are expected to `free()` since they might not be able to access your implementation of `free()` (think about library overrides)
They allow you to bypass those rules, you just need to comply to the standard in some cases
I think you're confused about how pointers work. [This might help generally](http://grisha.org/blog/2013/04/02/linus-on-understanding-pointers/), but I'll point out some specifics anyway: int s_pop(stack **st) { if (s_empty(*st)) printf("Stack is empty!\n"); int value = (*st)-&gt;s[(*st)-&gt;top]; (*st)-&gt;top--; return value; } Notice how all uses of the argument are loads from `*st`? This means you can use `int s_pop(stack*st)` and remove all those asterisks. --------- I also see you do this: stack *stack_test = malloc(sizeof(stack)); Why not use the stack to allocate it? It will be freed automatically when you're done: stack stack_test; Are you sure you want to initialise this below the bottom of the array? stack_test-&gt;top = -1; --------- Most professional C programmers (that are not Java programmers writing in C) do not usually create data structure helpers like these. For example: Linked lists tend to get threaded into the data structure instead of encapsulating the data structure. Imagine I have a user amongst a bunch of user objects, I might: struct user { struct user *next, *prev; char *name; And then have something like: struct user*find_user(const char *name) { struct user *p; for(p=top;p;p=p-&gt;next) if(strcmp(p-&gt;name,name) == 0) return p; return 0; /* or error? or new user? */ } But then, I'll *really* be thinking about *is a linked list the right way to access users? Will I have a lot of users? or a few users?* Maybe I'll be reading users from the disk, or maybe I'll have a memory mapped database. *This routine* is where I'll make those decisions -- I won't leave this up to the consumer of my user module. --------- void push(node** link, int value) /* in http://pastebin.com/2BFxYF8s */ Has a redundant `if` statement. *You never dereference* `\*link` *so it doesn't matter if it's NULL or not*. Try to remove all redundancies. It will make your program smaller and make bugs harder to hide. 
Thanks buddy, that clarifies things. Cheers
As well as the other problems mentioned , you are doing the wrong cast in your compare function. The arguments to `compare` are pointers to the elements being sorted. You are sorting an array of `struct team *` elements (not `struct team` elements). So you need to convert `a` to `struct team **`, etc. &gt;I am fairly sure that that I have created a list of lists, as opposed just a list. I guess you are referring to the fact that you made an array of `numberOfTeams` pointers, each of which presumably points to one Team. Instead you could have made an array of `numberOfTeams` objects, which is simpler. 
So to convert a to struct team **.. would I write: int compare(const void **a, const void **b) { int low=((struct team *)a)-&gt;busts; int high=((struct team *)b)-&gt;busts; return (low-high); } or int compare(const void *a, const void *b) { int low=((struct team **)a)-&gt;busts; int high=((struct team **)b)-&gt;busts; return (low-high); } 
I just tried: int compare(const void *a, const void *b) { int low=a-&gt;busts; int high=b-&gt;busts; return (low-high); } And it didn't work. I very much appreciate your patience in helping me with this problem by the way. I also tried using: int compare(const void *a, const void *b) { int low=team[a])-&gt;busts; int high=team[b])-&gt;busts; return (low-high); } Didn't work either. How can I access the field in the team which is pointed to by the pointer that is pointing to? 
Ok, so this is what I have written as my comparator function. int compare(const void *a, const void *b) { const struct team **p2 = (const struct team**)a; const struct team *p1 = *p2; int low = p1-&gt;busts; const struct team **p4 = (const struct team**)a; const struct team *p3 = *p2; int high = p3-&gt;busts; return (low-high); } And still it is outputting an unsorted list. Some of this stuff is a little overhead my head, I won't lie, so where am I going wrong? 
p3 should be *p4, not *p2
In C, it's usually good to understand the restrictions of what you are doing before attempting to do that as undefined behaviour has the nasty property of often doing exactly what you intended to do.
This destructor function should be called from the library itself then? Making users work for things is what I am trying to avoid the most while implementing these so a constructor and a destructor functions sound pretty good to me. Thank you for the help!
Here's where my first confusion about pointers happened. I was trying to pass a file as an argument to a function and then edit it in that function. That didn't work out I don't really remember why but I remember finding a SO post saying I should use double pointers when I want to edit something's value and that something is already a pointer( FILE* file get sent as &amp;file and received as ** file in the function). When I thought about it it made sense - I edit variables such as int by sending a pointer to them, it only made sense to send a pointer of a *type*(type being FILE* which is a pointer itself) and then edit it. So when I first tried working with data structures I tried sending a structure without sending it as a double pointer. It didn't work out so I made it a double and it worked. Since then I've been treating structures the same way I treat files when modifying them in a function. Is this way of thinking wrong? &amp;nbsp; Oh yeah and that redundant if you asked about works fine if I try to send a null struct to it. My struct is defined as: node* head = NULL; so it's essentially a pointer. To me it makes sense that if I need to edit it in a function I should send it as a double pointer and only dereference once since the struct acts as a pointer. Don't know if this makes sense to you but it actually works. I wasn't able to break it when I finished building it. I'm not home now so I can't really check again but I'm pretty sure it worked ok when I last tested it. &amp;nbsp; EDIT: forgot about that -1 initializing. That's just how the tutorial I kept looking at did it and it looks pretty neat. I mean there can be no harm done because functions will check if the queue is empty before trying to access anything in it. Or at least that's how I last left it in my compiler. I may have left some of the empty checks out if that peaked your interest as a flaw. I mean if I initiate it at 0 it's like the queue contains something (At that [0] element in the array) but it really doesn't at first. 
That doesn't make sense. When is the library going to call the destructor function itself?
it'd be X= (20*.25 +40*.5 + 60*.25 )= 40 i still can't get it to work :(
Yeah you're right I'm trying too hard to make libraries seem like magic, sorry. Now that I actually think before typing it makes no sense. There is no logical event that would require for the freeing of space unless the users decide to do that themselves after they don't need the structure anymore so having a destructor function would be giving them that option. Thanks for bringing it up though. I'm still new so I don't have the habit of thinking how it would look in code before actually typing things down.
&gt; I remember finding a SO post saying I should use double pointers when I want to edit something's value and that something is already a pointer. … To me it makes sense that if I need to edit it in a function I should send it as a double pointer and only dereference once since the struct acts as a pointer. There is no "double pointer". This is a confused way of thinking. A `T*` points to a `T`. If you want to modify a pointed-to node, then you do not need any more levels of indirection than that. A `T**` points to a `T*`. If you want to return a new `T` that can be pointed to, you might do something like `*x=malloc(sizeof(node));` in which case `x` is a `node**`. The compiler produces an extra load/store combination on `T**`, and it introduces a memory barrier where one might not otherwise exist. Other programmers that read your code will assume things are happening that aren't. That is to say, it's slower and confusing: Don't do it. &gt; but it actually works. Writing code that only accidentally "actually works" will get you in a lot of trouble, and it will put a ceiling on your ability to improve as a programmer that you will find it very difficult to work around. Furthermore, I wouldn't hire someone who defends code that accidentally "actually works". It's one thing if you don't know what you're doing and try to get better, but it's another thing if you try telling me *I* not knowing what you're doing is somehow a good thing because it "actually works".
Is there a way to emulate epoll on other systems through poll? Just wondering in case I would need to do so in the future.
The ancient standard for pending on multiple events is select. BSDs have poll, Linux has epoll. I strongly suggest you look at [libevent](http://libevent.org). It automatically picks out the best available selection mechanism depending on the parameters you set. It also has extra functionality for dealing with sockets. At least, you could look at the libevent source code to see how they do it. 3) The traditional way to do more than one thing at a time was to use multiple threads. Threads are painful in their own way, so non-blocking routines can make it possible to manage everything from the same thread. 5) In a perfect world, you'd never do any synchronous blocks in the UI thread. However, most folks don't worry about small reads or writes to local files and do it inline with the UI. Bonus Question) See libevent's bufferevent concept.
what if it's typedef'ed?
Folks have already covered portability, so: 3) Sometimes all you need is to transform input from one source to output on another source, blocking fds are great for that. It's the unix philosophy 4) Set a timeout on your polling mechanism or use signals/setitimer() to periodically wake 6) You have to check for EOF manually; read() returns zero on end of file, write() returns an error with EPIPE if the other end is closed. Bonus Question) Yes, handling output buffering to account for untrusted clients and networks can be very tricky, and doing it wrong can lead to [slow DOS attack vectors](https://blog.qualys.com/securitylabs/2012/01/05/slow-read). Resource management is hard. I might be wrong, consult your manual pages for specifics.
I think you mean BSDs have kqueue(). Everything except possibly Windows has poll().
I am of the opinion that the best place to find this information is the [gcc man pages](http://linux.die.net/man/1/gcc), or type `man gcc` into your terminal, but I think I understand what he's doing and the corresponding equivalents. `-I` followed by a directory will allow you to include certain header files in that directory (the equivalent of `/I` in his example). Note: you don't need this for headers in the current directory or system header files. `-l` followed by a library name will search for that library within system library directories or directories specified with `-L`. This one is closest to `/link` but in gcc you need to specify each library with the `-l` flag before it, whereas the man in the video seems to be able to list several after specifying the `/link` flag and the `/LIBPATH`s. `-L` followed by a directory specifies a directory for `-l` to search in. This is effectively `/LIBPATH`. `-g` enables debugging. You can specify a level with a trailing number such as `-g3` or `-g1`, but `-g2` is the same as `-g`. So an example makefile might look like: CC=gcc CFLAGS=-g -Og -Wall -Wextra INC=-I/path/to/SDL2/include LIBS=-lSDL2 -lSDL2_image LIBDIRS=-L/path/to/SDL2/lib -L/path/to/SDL2_image/lib Program.exe: Source.c $(CC) $(CFLAGS) $(INC) $(LIBDIRS) $(LIBS) -o $@ $^ Please note: these library names and directories are simply examples and the real ones may be different; I've never worked with SDL. Moreover `-Og` will enable all optimizations that don't conflict with `-g`. I like to use it, but not everyone does. I hope this helps! If I misunderstood or have anything wrong please someone let me know! **EDIT**: formatting.
Then it works.
I strongly recommend you to write a separate function which determines whether a number is prime or not. On the other hand there are some problems here. * x, p and p2 are uninitialized. * you check if p == 0 in EVERY iteration, but you should chek it only once, after the for loop. * you should set p = 0 before every prime-checking, if you didn't do it, p would remain the same * you should handle 1 * your first for loop is wrong. If you check x == 0, then why do you check it again? And why do you increment x? You should use a while loop instead. To skip the negatives, you can use continue, or: if (x &gt; 0) {/*do whatever you want*/} +1: you can speed up prime-checking if you write: for (i = 2; (i &lt;= number / 2) &amp;&amp; ((number % i) != 0); i++); and if i is bigger than than number / 2, then number is a prime.
 if (x &gt; 0) { continue; } Are you sure that it's good? You want to continue when x is less than zero. { p = 0; p++; } What is it supposed to do? If i (or c in this case) is bigger than number / 2 (or x / 2 in this case) then number is a prime.
Oh whoops, my bad mixed up &gt; with &lt; Ive still got an issue, im getting wrong results, i cant really tell what is the issue Is it the counter "total", is it necessary to be there? or should i just print "c" http://prntscr.com/aefaga 
You told it to draw six rows and it drew six rows. There's no bottom on the square because you told it to only draw a full row of stars on row 0 and row 9. A six row square never gets to row nine, so no bottom.
 { total++; } This shouldn't be there. As you can see the loop is already closed, no loop body is needed. The only thing you need is to check whether c is bigger than c/2, if it is, then increment total. Put it after the inner for loop: if (c &gt; x/2) { total++; } Another thing: you have to handle 1, if you don't do it, then 1 will be counted as a prime.
Not dumb at all! They're pretty hard to google answers for :P `$@` will insert whatever you have written on the left side of the colon from the line above, so in this case it inserts `Program.exe`. `$^` will insert everything from the right side of the colon on the line above, so here it would be `Source.c`. It's important to note that `$^` will insert *everything* on the right, meaning it can insert multiple source files. So if you have a recipe like `Program.exe: Source.c Lib.h` (where you want `Program.exe` to be recompiled when there are any changes made to either `Source.c` or `Lib.h`) you wouldn't want to use `$^` because you probably don't need to compile a header file. Instead, you may want to use `$&lt;` which will use the leftmost name from the right side of the colon. I think (though I've never used it) that you could also use `$&gt;` to use the rightmost name from the right side of the colon, in case you format your makefiles differently. On the other hand if you have something like `Program.exe: Source1.c Source2.c` then `$^` can be really useful. I hope this helps!
Excellent, I'd never known any of that. Thanks for the explanation! 
If you happen to be running on a platform where `sizeof(int)` is equal to or greater than `sizeof(int *)`, then it will allocate sufficient memory. But that's just dumb luck; it won't always work out that way. There's nothing that requires that relationship. Your instructor is just wrong about the cast. It should not be used, and unless there's some other mistake in your program, it should not affect the behavior. One of the main reasons that it should not be used is that using it masks other errors, so if you take it away and your code fails to compile, then that indicates that you have some other problem (such as neglecting to include `&lt;stdlib.h&gt;` such that `malloc()` has not been declared.) The only justification for using the cast is if you're writing code that has to be able to be compiled both as C and as C++. 
Thank you. That's exactly what I thought it would be! But on my system, sizeof(int) is 4, sizeof(int*) is 8, so it shouldn't work out.
+1
I've a question regarding the configuration objects for each data structure. How common is this, and is it a good practice to do so? They look extremely useful, and I love how it has both init and create blocks as well to allow both stack allocated and heap allocated initialization and destruction safely. In the configuration object, how often do you see people use callbacks like that for custom allocators, and is it best practice? Configuration Objects definitely look better overall than use preprocessor defines to determine which to use, as they allow certain instances of objects to do one thing, while other instances of the same type of object to do another. Edit: Also as well, I notice this collection isn't thread safe either. No locks protect it from concurrent access, and the iterator has no algorithm to detect if the node has already been removed by another thread, or even another call to the list. For example, if even in the same thread, you access the iterator, clear the list, then do iter_next, it directly gets the data from the node, even if it has already been freed. It doesn't traverse the list to determine if it is still currently in the list.
[Nasal demons.](http://www.catb.org/jargon/html/N/nasal-demons.html)
No r* trees?
&gt; (such as neglecting to include &lt;stdlib.h&gt; such that malloc() has not been declared.) Since 1999 this must give an error. &gt;The only justification for using the cast is if you're writing code that has to be able to be compiled both as C and as C++. There is no justification for writing "multi-language code" IMO. Well, except for frivoloties like the IOCCC. They once had a program that was valid C and valid Perl. 
The one that will actually work like you want.
Yes it can: void (struct list L, struct node *node) { if(L.size == 0) { L.head = node; L.tail = node; L.size++; } else { node-&gt;next = L.head; L.head = node; L.size++; } }
Have you tried that to see if it works?
This will happen to work (because the address of an array is just the address of its first element), but `foo` and `&amp;foo` have different types, so don't do this in general. Here, `foo` decays to `char *` while `&amp;foo` is `char (*)[14]`. That's a pointer-to-array, which you don't see often and is *not* the same as `char **`.
I would use the one that would actually do anything.
I hope others don't help you. Next time don't wait until the last minute. 
yeah fair enough 
can someone help please :( 
That won't compile. What error is your compiler giving you? Do you understand anything about the error?
and then print it at the end
Process terminated with status 0 (0 minute(s), 2 second(s)) 0 error(s), 1 warning(s) (0 minute(s), 2 second(s)) 
i didnt understand your answer
In the code you pasted above, your `average` function is nested within `main`. This isn't allowed in C.
nested?
You haven't understood any of the five answers that have been posted between this thread and your last. Face it - you won't understand this in time and your only hope of finishing the assignment is if someone else does it for you (which I can only assume is why you keep posting it and begging for help). I can do it for you. I accept PayPal. 
Your definition of `average(){}` is within main's {}
whats the %d for a float?
%Google
-.- im starting to think you dont want to help
i give up 
sorry for wasting time
I recommend picking up a good book in c for beginner programmers. One of my favorites is Ivor Hortons beginning c, it is a great introduction to programming and does a great job at explainjng things for someone without any vocabulary. I don't think you need to drop the class or anything but you really need to put in some personal time into this. I read /u/arrogant... answer for your previous thread, if you cannot understand that answer then I'm afraid you have a lot of catching up to do. Luckily, with the right motivation, it shouldnt take a long time to do so, programming is one of the easiest things to self teach, and there are resources everywhere.
If you don't understand an answer, ask for clarification. Don't waster our time and ask the same question again. The answers you are going to get won't be any different.
`fgets` is probably what you want. If your input happens to work with `scanf` better, then you can put a maximum width specifier for the %s, e.g., `scanf("%4s %d", s, &amp;x)` (use 4 instead of 5 because the maximum field width specifier for scanf does not include the NUL terminator)
I can't claim very much competency in this area, but I'll try talking it through with you if you'd like. From what I see of your code, it seems to be in shape. If the ALU does all the addition/subtraction/etc. then the CCU can coordinate how the numbers outputted by the ALU will work in the whole system. I imagine you can think of the whole thing within the framework of an MVC (model-view-controller) architecture, except with many models. Does that help?
Really, worst case scenario with any code is that you go back and redo some things, and learn from your mistakes. I've always gone by the philosophy that if development is going smoothly, then just keep going and figure out problems later. Best of luck!
Note that the OP has completely copied your code, changing a few variables names (to be worse) https://www.reddit.com/r/C_Programming/comments/49mqon/whats_wrong_with_my_code_the_questions_q2_input/ &gt;Edit: Impressive! Someone tries to be helpful and then gets downvoted. You aren't being helpful, you are literally being the opposite of helpful in every way
You literally went onto a 19-day-old post to basically say "told you so!". How productive.
If you have room for 5 why stop at 3?
Maybe they want to add control characters or '\0'?
I don't quite understand what's going on here, but I like it.
Safer to only read in exactly what you need. If you only need a single character, then read in a single character. Buffer overflows due to poor sting handling are the most common exploits.
I agree; hence my mention of control characters beyond just '\0'.
Wow, thanks for explaining this, the diagram really helps to make sense of it! This is super cool.
for loop?
So you're saying that `char` is better to use when dealing with characters than `int8_t` because it better indicates what the data is being used for?
I don't mean to pick on you, but this is bad advice. Let me give you an example. You are coding for an Arduino Due, cost $50. Tomorrow you decide, hey the Arduino Uno is cheaper ($25) and smaller and fits your needs better. Problem is you coded a loop like this: for(int index = 0; index &lt; 40,000; index++) { //do something } Do you see the bug? Let me explain it. You now have an infinite loop in your code. Refer to [here](https://www.arduino.cc/en/Reference/Int) for the extra details. What happened is when you went from the Due to the Uno, the max size of the `int` went from 2,147,483,647 to 32,767. Why is that so important? Well your loop goes to 40,000 and the `int` can never satisfy `index &lt; 40,000`. Its called an Overflow error. You would take the exact same software from one board to the other and cause an infinite loop and a system you cannot debug without print statements. Talk about a headache. How could you have fixed it? Used `int32_t` instead of int. 4 keystrokes could save you all that time. And if you say I'll just make everything the biggest possible (uint64_t)! Well the Arduino Uno only has 2k of RAM. Meaning if you make everything in your code huge, at max you could have ~512 integers at the same time. So if you have some array you are averaging over, storing, waiting to communicate over wifi, etc, you have really limited how much data you can have because you coded without thinking what you really need, you went with what was easy. Sure you can get away with it in your own use. But your application can't waste RAM like that on the servers your code will run on at a job, or the embedded micro your company wants to make as small as possible to save cost.
&gt;I feel the author is promoting very bad and dangerous programming style Why is it bad and dangerous to use specified-width variables when possible (with the exception of types that have a specific use, like `char` or `size_t`)? Doesn't it just make your code more portable? Instead of your `int` possibly overflowing on a different system, just make it an `int64_t` from the beginning, and that solves it. edit: forgot an a
For 4, wouldn't an [eventfd](http://man7.org/linux/man-pages/man2/eventfd.2.html) be better for a Linux-specific alternative?
Yes thank you! Editing now.
If you are working in integers then write a loop. If you are working in floating point, use the `pow` macro. 
Are you running the program from within Visual Studio? If so, it sets the working directory to the project directory, not the directory to which the exectuable is built. Ie. Move file_a.txt 1 directory up.
you would be better to split the magic square function into three functions: eg: read_coeffecients // reads in the values to create a matrix, this would also allow values to be passed to the function in another way. calculate_magicness // calculates the various states, whether the square is magic and so on. print_results // prints the results based on the calculations, this is better as a separate function because the results may not always be printed (can convert to graphical, web based or whatever later) also from the looks of it, as the values of the matrix does not change after the initial population, then the loops that calculate sumR, sumC, sumD and sumD2 can be done in the same section: eg: for(k = 0; k &lt; nRows ; ++k){ sumD += matrix[k][k]; sumD2 += matrix[k][nCols - k - 1]; for(p = 0; p &lt; nCols; ++p){ sumR += matrix[k][p]; sumC += matrix[k][p]; if(sumR != sumD &amp;&amp; sumD2) isMagic == 0; if(sumC != sumD &amp;&amp; sumD2) isMagic == 0; } // you can exit at this point if all you want to know is if there is a magic square or not. if (!isMagic &amp;&amp; onlyNeedToKnowIfMagicOrNot) break; as mentioned, I would not print the values in the loops because it might be that someone wants to use your function to just calculate if this is a magic square or not. However, you could store the info in a struct or something for printing later, because it would allow a 'printing' function or a different function that did calculations, graphical output or whatever. 
i put that in so if they input 4 or 5 on accident nothing would happen and 4 and 5 its ignored anyway.
It's probably better to just truncate whatever input they provide at the number of characters your program expects.
&gt; I'll also disagree about the use of pragma once; the GCC manual specifically says you should use the older syntax instead. The GCC manual doesn't even mention pragma once. That leads me to believe it is incomplete, or trying to be standards compliant to a fault. pragma once almost universally supported ([wiki](https://en.wikipedia.org/wiki/Pragma_once#Portability)), and is less error prone than include guards. What issues have you ran into with pragma once that cause to to recommend include guards?
One argument against `char` is that many programmers still think of it as a single character in a string. That was fine in ASCII times, but nowadays, strings should really be treated as a bunch of bytes with an associated encoding. For some of those encodings, most notably UTF8, there's no simple mapping between bytes and characters. Furthermore, "simple" operations like finding the n-th character or transforming cases are much more complicated than simply indexing into an array or adding an offset to some bytes. Using uint8_t instead of char reinforces the need to treat any text as opaque binary data. 
No, it doesn't make it any more portable. And I think this highlights the "dangerous" thinking: &gt; Instead of your int possibly overflowing on a different system, just make it an int64_t from the beginning, and that solves it. Using `int64_t` doesn't solve this! You talk as if an `int64_t` isn't going to overflow, which is not true. An `int64_t` overflows in exactly the same way that every other integer type overflows. Maybe for your specific application you know that an `int64_t` won't overflow. (Or, more likely, maybe you *didn't* know that and you just dangerously assumed that, in which case at the very least you probably should have used `intmax_t` instead, though that didn't actually solve the problem). How did you know that an overflow wasn't possible? The only possible option is that you did some quick analysis/guesstimating and determined that the value of that variable would always fit into 64 bits. If you've gone through that analysis, then you've already determined that `long long` is an appropriate type for you. So, why not just use `long long`? Why would you use `int64_t` over `long long`? I have no idea. Maybe to save 3 keystrokes? Here's a good reason why you should use `long long` over `int64_t`: it actually exists! Unfortunately the `int64_t` will not exist on platforms without a 64-bit type. So, to answer your question: &gt; Doesn't it just make your code more portable? No, sadly, it does the opposite. It makes it *less* portable. So, you say, well that's what `int_least64_t` is for! Yes, it is. Or maybe `int_fast64_t` is more appropriate: you're not really sure. Are you interested in saving memory or are you interested in speed? Sometimes you know the answer to that. Arguably, in many cases, this depends on which platform you're on and I think the compiler is in a better position to make this decision for you.
Char is not necessarily 8 bits in C. Char is necessarily 8 bits in POSIX. EDIT: bytes -&gt; bits
Post your code to github or any other site. Without code, we can't help you.
I don't quite agree with that article. Many of the things they want you to do are wrong. Read [this](https://github.com/Keith-S-Thompson/how-to-c-response) for a good response.
&gt; Why not code them so they are always the exact size required? The problem with `uint8_t` and friends is that they specify an exact size. On some platforms, some type sizes can be slow because arithmetic of that size is not supported. For example, this is the case with `uint16_t` on ARM. It is better to use `uint16_least_t` (or whatever it is called) so the platform can pick an appropriate type. It can also be possible (though it is unlikely) that these types are simply not available on platforms that don't support them. For example, there is no guarantee that a platform has an `uint64_t`, but an `unsigned long long` must always be provided.
I don't understand the authors point. UTF-8 was designed to be a byte-encoding (i.e. the unit of information is an octet) as opposed to UTF-16 which is a 16-bit encoding, so the type of an UTF-8 encoded string must be `char[]`.
The bug is that your loop never runs because the loop condition `index &lt; 40,000` is always false. Also, the compiler should warn you when there is an overflow in an integer literal. Why don't you listen to it?
It's not dangerous but it forces the compiler to use a specific type which might be less efficient than another type. Just use an `int` or a `short` or a `long` if you need a type with appropriate size guarantees. Don't prohibit the compiler from picking a larger type. I know at least one platform (MSP430X) where `size_t` is a 20 bit type. An `int` has 16 bit (too small) and a `uint32_t` is horribly slow as it must be emulated.
Well, if you use a variable instead of `40,000` and the variable is set at run time, the compiler can't warn you. But in the example I created you would receive the warning, nice call.
Better upvoting the reply above for visibility, than downvoting the original, flawed, `strlen()` advice.
You need to start repeatedly pruning / commenting out code, then reproducing the error. When you get to the bare minimum code size to reproduce it, you either found the error, or are ready to discuss in greater detail. 
Its just with the comma for reading. But also true.
There's no necessarily right or wrong way to do it, whatever works for you is fine. For example, I took a different approach in my own emulator (for a Motorola 6809, an 8-bit CPU): https://github.com/spc476/mc6809
No. I'm using xcode. But the solution is similar to what you described. Thank you!
I don't play the up down vote game. Ask a question, get an answer, profit. Plus *I* might be wrong in some way... so it's also a way to double check my thinking. 
Thanks. As an amateur/beginner C programmer, I wasn't sure what to make of the original article, but this one cleared some things up and gave me some more material to read up on.
Can someone give me a compelling reason to use coroutines in C?
&gt; "The first rule of C is don't write C if you can avoid it." I think this would be better said as making sure you know why you're using the language you're using for the project you're using, and this goes for any language, not just C.
If you can find a good coroutine implementation, then coroutines give you a means of unifying stream, array, iterator, function call, and exception handling concepts under a single umbrella. E.g., if you want to be able to feed data into your API, you can either set up separate functions for feeding from buffer, callback, va_list, etc., or use a single one taking a coroutine/+args as its parameter(s).
He’s pretty wrong in a lot of places. First of all, `char` is neither signed nor unsigned per the standard, and is an entirely distinct type from both `signed char` and `unsigned char`; most compilers permit `char`’s signedness to be toggled at the command-line, even (though it’s usually signed by default), so you really have no idea whether it’s equivalent to `int8_t`, `uint8_t`, or something else. Any time you’re dealing with a non-wide/-multibyte string, you should use `char`, because that’s what the C compiler gives you an array of when you create a string constant, and any C programmer worth his weight in sand would see `char *` or `char[]` and immediately guess that it refers to a string. Also, C isn’t guaranteed to use ASCII for its string representation, so making assumptions about `CHAR_BIT` being some particular number like 8 would only hold (or be remotely purposeful or meaningful) if you have a basline guarantee like POSIX would offer. Second, the types (`u`)`intXX_t` do not necessarily exist, unless you have specific prior knowledge about the compiler/platform in question; they’re optional C99 extensions that have very specific size, padding, and alignment requirements that not all platforms/compilers/ABIs can handle, although the more common ones usually have no problem. `uint_leastXX_t` or `uint_fastXX_t` are generally what you’ll want to use if you need a specific minimum range that wouldn’t be covered by the built-in types; (`u`)`intXX_t` should only ever be used if you really, honestly need an exactly-`XX`-bit integer aligned to `XX` bits, no padding, no more, no less. You should probably also wrap specifically-sized types up in a `typedef` so the size (an implementation detail) isn’t exposed outside your API headers, which allows you to change things at will later in case you decide you need more/less bits. Third, the built-in types are not necessarily represented in two’s-complement when signed, and so although `int`’s informal *minimum* (not guaranteed!) size would run from ~16 bits up, its actual range is only required to be −3276**7**–32767 instead of the mandatory `int16_t` range −3276**8**–32767. On such a platform, it may even be necessary to use `long` to represent `int_least16_t`! No built-in type is ever guaranteed to map perfectly to any (`u`)`intXX_t` type per the standard, even if you assume that they must have exactly their minimum sizes. And of course, things like `size_t` or `ptrdiff_t` (which *are not* necessarily the same as `uintptr_t` or `intptr_t` or anything else, and like `NULL` come from `stddef.h`) should be used in preference to either built-in types or `stdint.h` when appropriate—don’t make any assumptions about pointer size or representation if you can help it, or the bugs’ll come out of the woodwork as soon as you try to port it.
&gt; It's entirely possible that in some cases Matt is right and I'm wrong. Otherwise, if he doesn't state this, then it's impossible he is wrong.
The original is rubbish really. I have to applaud Keith for reading on past the opening statement: &gt;The first rule of C is don't write C if you can avoid it. Statements like this (about any language!) are invariably followed by a pile of misconceptions about the language. 
This is the same thing without coroutines, the algorithm is more messy to be sure, but it's not jumping all over the place. I can see the point of coroutines, but they are not very 'C' like. #include &lt;stdio.h&gt; struct iterator { int x,y,max_x,max_y; }; void init_iterator(struct iterator* it, int max_x, int max_y) { it-&gt;max_x = max_x; it-&gt;max_y = max_y; it-&gt;x = 0; it-&gt;y = -1; } int iterator_next(struct iterator* it) { it-&gt;y++; if (it-&gt;y &gt;= it-&gt;max_y) { it-&gt;y = 0; it-&gt;x++; } return it-&gt;x &lt; it-&gt;max_x; } int main() { struct iterator it; init_iterator(&amp;it, 3, 3); while(iterator_next(&amp;it)) { printf("%d %d\n", it.x, it.y); } }
&gt;Keith appears to recommend: &gt;&gt;printf("n = %jd, u = %ju\n", (intmax_t)n, (uintmax_t)u); &gt;for printing pointers, however that may cause undefined behaviour. for pointers, always use `%p`.
kinda new to C and not understanding exactly what this is doing. is it sort of like using the 'static' for a variable so that it remembers next time the function is called? 
I love how this post bashes [this crap](https://matt.sh/howto-c) again. John Regehr knows his shit.
My feeling is that coroutines are too abstract for C. Usually the reason why I'm using C (or at least a major reason why I'm using C) is that I want a lot of mechanical sympathy. I want to be able to glance at a line of code and immediately imagine what machine code is being generated. setjmp/longjmp are very heavy operations and hiding them away to give a pretty way of repeatedly "calling" and "yielding" makes me feel like I'm trying to do something that would be better written in a more abstract language.
To note here the code is not finalized nor complete and I'm going through so many code style and implementation idea changes, the overall code may look like a bit messy so I hope the pseudo code above is enough, however I will reluctantly post the code for what I have thus far if asked ( responses may be late and corrections delayed due to extremely busy schedule ). Edit: Googling for "iterator node correction" yields nothing. Googling for "linked list concurrent iterator" yields nothing but Java or my question (lol). Is this not possible or not as useful as i think it would be?
Thanks. That's a great reference to have, but I guess it was more of a syntax-type question. I have a struct with an ID. I also have an array of pointers to struct. I have another struct that I want to contain an array of those IDs. Kind of like school classes each have an ID, then each student has a list of classes, so you get the ID from the student's list and use it to find info on the class. I'm new at C and structs over all.
So the same COMMON_DATA struct acts as ID for both classes and students?
Oh God I can't tell you how thankful I am for this. It was driving me crazy. 
Oh my god... Pardon my language but holy shit... I had no idea that malloc suffered from the ABA problem... I've so naively figured that since I'm freeing nodes and allocating them this avoids the ABA problem... But then, even though I used malloc in my lock-free stack with hazard pointers ( temporarily until I implement a mostly lock free one ) to avoid the ABA problem, any allocator I use could potentially get back the same memory... Anyway to stop rambling, while it is impossible to access invalid memory, the nodes, due to the ABA problem, we could ( extremely low chance but still possibly ) end up in a random location inside of the list.. Which pretty much is undefined behavior in it's own rite... I suppose by having the iterator contain a reference to curr_node, prev_node and next_node, we can avoid this. In fact I will no longer need prev_node nor next_node because curr_node is always valid. I can place an extra atomic bool to determine if it is valid instead, making it O(1) again. If it is not valid we easily reset, otherwise we advance and return the value. Any downfalls of this way? 
This article is chock full of bad advice written by someone who thinks they know a lot about C. Rules of Optimization: 1) Don't optimize 2) Don't optimize yet 3) Profile! Telling people to use the 'register' flag because it's faster and to only use unsigned integers is not just useless, it could actually make things worse.
&gt; having the iterator contain a reference to curr_node, prev_node and next_node Yup, I think that's the cleanest solution. As long as the node you're tracking stays alive, all your previous assumptions hold. &gt; I can place an extra atomic bool to determine if it is valid instead, If this is strictly an optimization and you aren't dependent on the bool for correctness, then that should be fine. By the time you react to the value of the bool, it may have changed. And if it's only an optimization, you can be more relaxed about stores and loads on the bool, without the (possibly expensive, lock-prefixed) ordering constraints on the compiler and CPU. But if in doubt, go for correctness. 
The author started to touch on this (in the "Where it is needed?" section), but stopped well short of the full story.
&gt; Te author seems a bit confused here The author is correct. Imagine anyfunc() is defined like so int global_data[10]; void anyfunc(int x, int i) { global_data[i] = x; } And you call func1() like so: func1(global_data); The problem is, as far as the compiler knows, anyfunc() may modify the buffer pointed to by `data` in func1(), so it has to perform a load each time around the loop. 
Truly appreciate this, you drastically helped me out here. Seriously, from O(N^2) to O(N) for traversing the list. And yeah, I suppose the atomic bool is overkill, since once again, it will only be updated while the writer lock is acquired (hence no readers can detect an incomplete value).
As far as I know it's only available as a [PDF](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=57853), but you can ask them to send you a CD if you want.
I'm sure you can take the PDF to any print shop and have them print and bind it for you. 
This is just all kinds of broken. First of all, you declared `get_input()` as taking three parameters, but when you call it you don't pass any. That shouldn't have compiled, at least not without a warning. But even if it did, this still wouldn't work at all. You're modifying a copy of the variables inside the `get_input()` function, so those changes will have no effect on the variables in `main()`. If you want to modify variables in a function, you need to pass a pointer to them to the function that's doing the modification. It's the same reason that you have to pass a pointer to `scanf()`. Your `get_input()` function is in the same exact position as `scanf()` in terms of wanting to modify a caller's variable. 
A local printer is best for a [one-off](http://www.print-my-pdf.com/), but maybe they have an arrangement with [Lulu](https://www.lulu.com/).
Link please?
does sprintf output like printf? because im getting a weird output error, i just need to concatenate these strings and char '^' with label later on and sprintf is not working
Seems like I'm wrong.
What are you attempting to do this way? What you are trying to do is a horribly wrong way to do marshalling. Please never ever send structs over the network. Write proper marshalling code instead. In your case, the problem is likely that there is no `packed` attribute in the inner structure. Please also note that this kind of code is not going to work on platforms with strict alignment requirements like MIPS, SPARC, or ARM. Do not write code like this.
“is not working” is not an error description. Please give us enough information to actually help you.
What do "get a wierd error" and "not working" mean? There is plenty of documentation available, but basically sprintf does the same as printf but puts the formatted output into another string instead of to stdout
Please don't link to C++ documentation for C questions. The right page for C can be found here: http://en.cppreference.com/w/c/language/escape
According to [this answer](http://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents) to a question on stackoverflow, you can buy PDF from ANSI and download the draft in PDF for free. But, I have no idea about whether printed ones exist or not.
Your space is redundant as `%d` consumes leading whitespace anyway.
What type of C programming is this? Like whats this for and where would I learn this?
&gt; To a certain extent I'm looking at the Linux kernel networking code for some guidance. The Linux kernel code can make a lot of specific assumptions about structure padding, memory layout and stuff like that. It is also not an exemplary example for how to do C programming the right way as there is very little quality control and almost no rules. &gt; To your first comment, which is (sort of) an answer to my first question. What would be constructive is the reason why it shouldn't be done like this, and a suggestion as to a better method. You can write code in the way you do, but then it's going to be unportable/crappy: * packed structures are not part of standard C. While many compilers accept them (if they generate proper code is another story), they do not play well with a lot of other tools. You should not use non-standard constructs in your C code. * packed structures have inherent problems on platforms that don't support misaligned memory access. Many platforms besides x86 have this property. For example, taking pointers to members of packed structures generates pointers to misaligned data. Dereferencing them causes crashes. * if you overlay a structure over a buffer you got from the network, you make a lot of assumptions so the two overlap. Some of these assumptions can be wrong (like type sizes, but you chose the safest approach already), but most importantly, you suddenly have buffers with data in the wrong endianess. Getting this right is arduous and error prone. If you do it right, you should never have to convert data from little to big endian and vice versa. Also, you start to depend on byte order which you really shouldn't. It's likely that you don't find problems with your code until you test it on a platform with a different byte order, but when do you do this? A better way is to lay out the structure you want as it suits you best from a programmer's perspective. Then write marshalling code to assemble values from the bytes. Never cast `char` pointers to other pointers, do the conversion explicitly. You can use a set of routines like [these](https://github.com/fuzxxl/memf/blob/master/src/fiddle.h) to ease your life. You could also try my experimental [`memf` routines](https://github.com/fuzxxl/memf) to make parsing binary data as easy as calling `scanf`, but they aren't really tested, are probably buggy and likely do not perform well.
Thanks, I appreciate the detailed response.
The last one would be great, but that particular implementation idea sucks. Use named loops like perl and Java, and break on the label name, not a cryptic number that might get invalidated by later modifications to the code.
That's what you have to do now, but it's ugly, especially if you're mixing break and continue in nested loops... You have to have multiple labels. Plus a goto doesn't signal intent as clearly as one of the other loop control keywords.
&gt; It's good that you're noticing this, trying to understand what impact it has, and seeking additional opinions about whether it's good practice or not. It's what I'm doing a lot more since I'm studying at a university. I try to understand the everything as good as it gets, and when there's something I'm curious about or it grabs my attention, I dig as deep as I can. Once I heard someone saying "Im Studium geht es darum fragen zu stellen und neue Interessen zu wecken.", which basically means "While studying, you have to ask questions,dig deep and arouse new interests." That's basically what I try to do every day.
 #define breakloop goto
&gt;Also, no keywords like "array" please, as that would break a monstrous amount of code. They'd probably add keywords like "_Array" and a "stdarray.h" which would contain "#define array _Array". That way legacy code is insulated from changes, unless they include that header. Still, most changes usually get rejected; e.g. [this one](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1875.htm) from a recent meeting. 😁
Aren't those both undefined? `1` is of type `int`, which cannot be formatted with `%u`, and the `-1L` is `long int` which cannot be formatted with `%lu`... Edit: I see, the wording for the `l` modifier isn't clear...
I don't like the idea of classes in C anyway. Classes in my opinion just hide a little of the complexity of stuff we can already do with structs+function pointers.
Something I would love to see are C++'s lambda's or Apple's blocks. I don't care which, I just find such a feature too useful to be omitted, and often use C++ instead of C just because it has lambdas.
A wart is that you sometimes want to index a pointer by a negative amount (when the pointer points partway through an array, of course). Someone posted about a bug in live code a few months ago where it turned out that the code effectively did `p[(unsigned)-1];`, although it was not totally obvious from the code that the index had an unsigned type - it was a result of usual arithmetic conversions - , and the program worked fine in 32-bit and then blew up as 64-bit. 
Yeah. Many people feel that using signed `int` with `%u` *should* be well-defined if the value of the int is non-negative, because other parts of the standard guarantee that non-negative `int` has the same size and representation as the same value for `unsigned int`. 
Lambdas are very hard to implement on many platforms.
`break` and `continue` already violate that principle. They're just another way to do a `goto`. But there's a big difference: scope. `break` and `continue` can only ever refer to the current loop you're in, and with a specific meaning for each. `goto` might be anywhere in the function, up or down. Having named loops is just a continuation of this idea, but now you can define *which scope* you're talking about. It's a very reasonable and logical extension on existing language capabilities.
While you are right, the convenience of `break` and `continue` automatically choosing the correct target to jump to is great. I don't see that with a labelled `break`.
The label is optional. Leave it out, and they act just like always.
It's not a matter of automatically choosing the destination, it's providing a restricted usage with strictly defined semantics, not "go somewhere else in this function."
So basically this? blockstart: { if(something) goto blockend; if(somethingElse) goto blockstart; } blockend: ; I am sure we could get something like this working like the break/continue stuff via the CPP or some other pre-processor.
That's what you have to do now, yes. It's ugly and unclear compared to simply supporting named loops/blocks. I'm getting tired of repeating myself, so to summarize: Using goto for control flow in a loop bad unless you have no other choice. Linked proposal for a numeric argument to break/etc. bad. Named loops and control flow keywords that work on them, good, with plenty of precedent.
What Harvard architectures already have standards-conforming C implementations?
Indeed, clarification on that matter would be good! (and same goes for your concern on array views)
PIC for example. Many DSPs. It's not particularly difficult to implement C11 on a Harvard computer. All necessary provisions are there.
A single quote, what do you mean by this? `999'999`? I agree in principle with making `void f()` equal to `void f(void)`, but only so long as `void f(void)` is still valid as well. `nullptr` this can be done easily with a define. `auto` isn't really hurting anything and is entirely irrelevant, no need to do anything with it in my opinion.
&gt; lambda's are annoying in that they can use variables defined within the scope of the parent function (iirc a closure). That's exactly the best feature of C++ lambdas IMO (that they can capture variables). In C++, variables can either be captured by reference or value, but since C doesn't have references, all variables would simply be captured by value. Although in C we already have function pointers with context parameters, lambdas and closures are more concise. E.g. instead of this typical pattern: struct context { int someVar; char anotherVar; }; void MyCallback(void *context) { struct context *myContext = context; printf("%d, %c\n", myContext-&gt;someVar, myContext-&gt;anotherVar); } int main() { struct context myContext = { 123, 'c' }; // have to make sure lifetime of context exceeds lifetime of callback registration APIRegisterCallback(MyCallback, &amp;myContext); APIDoThings(); APICleanup(); } You could have just the following instead (assuming C++ lambda syntax without capture list) int main() { int someVar = 123; char anotherVar = 'c'; APIRegisterCallback((){ printf("%d, %c\n", someVar, anotherVar); }); APIDoStuff(); APICleanup(); } No need to worry about the lifetime of some arbitrary context object since all variables will be captured.
Changing `void f()` would actually remove functionality, so I don't see that happening. For example, you can have a callback system where `void (*p)()` holds a pointer to various functions with arguments (and other code to ensure the correct arguments are passed). It is acceptable in C++ because you can use a variadic template or a `bind` or lambda instead. `constexpr` for C seems plausible. What are "annotations" ? 
It'd be nice if they made it easy to use and support UTF-8. ASCII is ridiculous at this point.
As far as I'm concerned, you'd better know damn well what you're doing when you're telling the compiler to use registers. I don't feel like I know enough about how it works, so I avoid it. Also, it just screams premature optimization to me.
You have to sign in to read the VLA link?
That's why you put it in a special header like `&lt;stdarray.h&gt;`, so only code where it's safe will get the new pseudo-keyword. That's what C99 did with `_Bool`, `bool`, and `&lt;stdbool.h&gt;`, for example.
Frankly I don't care what a compiler I don't even use says. ALL modern, widespread compilers support #pragma once. I do use backup include guards as well, though.
The point, I think; is that UTF-8 may take up multiple bytes and the only way to tell is by reading the first nibble for which bits are set
Why not just write out the individual fields so the padding doesn't matter? No h8, but you're clearly going about doing this the wrong way
I use the smallest int I can. If I know my loop will run less than 256 times no matter what, I'll use `uint8_t`. if less than 65536, `uint16_t`, and so on.
Why not just use a variable length array and stop when it reaches the EOL (aka NULL)?
What code would it break? It's not legal now.
Verify that it is in fact a wave file (by checking the magic number) read the sample rate and sample width (16 vs 24 bit per sample I mean) make sure they're the same, find the data section, and then just copy everything after DATA to the end of the original file. Easy peasy.
44.1khz*
I'm currently reading Modern C by Jens Gustedt. It's not written in a book style, more of a reference style, but I find it much easier to look up exactly what I'm trying to understand, rather than reading 43000 words about how the author's grandma thinks it should work, with another 11000 words dedicated to bitching about why it shouldn't work the way it does.
There's a reason C++ went with `999'999`, because it won't break anything. I challenge you to write a line of valid C whose meaning would change or fail to compile. Commas, however, are problematic. Even in simple cases: int i = 999,999; This is valid C11, and `i` is initialized to 999 instead of 999999. Oops. Besides, separating digits with an "upper comma" isn't unheard-of, not to mention that some countries use the comma as the radix separator, so we don't need that confusion.
OMG! I'm amazed someone else has even heard of it! I'm reading it too!!!
Of course! Loads of people on here are willing to help you, but most of us are not mind readers, nor do we want to do your homework for you. Your project sounds like a lot of fun, and I'd be happy to help you, but I have no way of knowing what your specifications are, what libraries you're allowed or required to use, hardware specifications (beyond using an rPi), etc... The more specific you can be with your problem the more we can help. The more code you show us the better idea we have of what you're trying to accomplish. The more effort you put in the more effort you'll likely get from us. I recommend you search around the internet, because this sounds like it'd be a relatively common project. Get some inspiration from [github](http://www.github.com), or [stackoverflow](http://www.stackoverflow.com). Once you have a good idea of your specifications, think about your implementation, plan out what all you want it to do and how you think this can be accomplished. When you hit a wall come back with code (or at least pseudo code) and ask us why such and such isn't working as you expected, or how we recommend working around some bug you're experiencing. I assure you no question is too small, and even if we just point you to another link, or chastise you for not searching around enough, you will always learn something. However, there are questions that are too big, or too broad, and one such would be "Does anyone think they could help me with [making a piano on the raspberry pi] happen?" I hope this was helpful! Please keep us up to date.
Would closing 0 firsthand set the input instead?
what's wrong with wchar_t?
dup2 like you mention is a better approach.
&gt;no, no, no! that's what bool is for (#include &lt;stdbool.h&gt;) Sorry, the use of standard libs is prohibited :D I'll have to make my own, but to make my code lighter I prefer to just use `uint8_t` as I rely on `my_stdint.h` in about every single .c I produce