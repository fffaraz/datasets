Okay. So after the recursive call is done. It will go back to the caller and basically the next line of code after I did the recursion should be to go into the next directory. And then this would repeat. I think I got the logic. Thanks for the explanation and patience. 
Thanks, your explanation did help a ton in terms of understanding it. I think I've got the logic down.
Thanks for taking the time to check it out. So, let's see: 1. As I mentioned before. It's just a `typedef` to avoid breaking the code when you need/want a bigger string length. 8, 16, 32 or 64 bytes long will be up to the user. 2. Yes, I know. I though about that. I made it like that because I was thinking in multiples instances of string. So, you will eventually need a pointer to it. But, yeah. Maybe it should be users choices to do so. 3. Are you talking about the function that just returns it or the growth? 4. The macro is there just to save lines from repetitive code. `string_init` is suppose to allocate memory for a copy of `string`. So, yes. It has to be freed with `string_destroy`. About `string_find_raw`, it does return an allocated pointer. It's an "in hold" thing. Since I could return that or just use a fixed-size char array instead. Same for `string_substr_raw`. Advice? 5. Thanks, that made me realized I forgot about a feature there. 6. Are you talking about the use of `strncat`? Thanks, I think `strncpy` will fit better there. 7. Now that you mentioned... I'm wasting some memory and performance there. Will it be better to use two variables as buffers and that's it? 8. Sorry about that. I meant to just point to `temp`.
I know that `strcpy` is unsafe. Isn't `strncpy` "safer" as long you use the right size/length to be copied?
No. Honestly, the function should go the way of gets(). It was added back in the days when Unix was being written to fill in fixed width char arrays in kernel data structures, not for copying one 0-terminated C string to another location that also needs to be a C string. That's why if you use it to copy a string that's longer than the length you give, it doesn't 0 terminate the destination. If the source is shorter, it pads the remaining space with 0s, but they just as well could have chosen 1 or 2 or some other character as long as it's not supposed to be a valid value to put in the destination array back then. All this makes it needlessly inefficient at best, bug causing at worst, and always a pain, when trying to copy a C string to another C string with a maximum length. Trying to use a tool meant for one purpose to do something else is rarely desirable. snprintf() or implementing something yourself is probably your best bet at a portable way to do what people *think* strncpy() does. Or BSD's strlcpy()... One thing to consider when copying potentially not a full string, no matter the method, is if data loss from truncation will do anything bad. Say you're copying a file name. You might end up with a completely different file than intended if the destination isn't long enough. 
Some more rambling: To safely copy (or append) string A to destination array B, you need to know A's length, and B's capacity (and current used length for appending). If you know it'll fit, you already have all the information needed to just memcpy() A into B (or strcpy() if you know the maximum possible length of A but not actual length). If it doesn't fit, you have to figure out what to do: grow B, indicate an error, live with truncation, or something else. In the truncation case you again have all the information you need to just memcpy() what you can from A and manually 0-terminate B. 
You can but don't, use return values.
It’s not a very good pattern to follow. It has several obvious problems, the biggest of which is that detecting failure is a completely voluntary endeavor. It’s much better to signal using explicit return values, wrapped opaque data that can encode error values, or, as a last resort, sentinel values indicating failure. C has less type expressiveness as similar languages, but compilers can do enough static analysis where it can detect not handling an enum value in a switch or throwing away a return value of a function. 
Converting an int to a string is done by repeatedly dividing the int by 10, generating one digit each time. At this point, you might just as well repeatedly divide the int by ten and be done with it. int ndigits(unsigned int n) { int i; for (i=0; n&gt;0; ++i) n /= 10; return i; } Or if there's a good chance that n will be very large: int ndigits(unsigned long n) { int i; for (i=0; n&gt;100000; i += 5) n /= 100000; for (; n&gt;0; ++i) n /= 10; return i; } 
So would I want to return my error code and use a passed pointer as what the function is actually supposed to return? So instead of: float divide(float a, float b); do: divide_error divide(float a, float b, float &amp;out); where divide_error is some enum (that might contain, for example, a divide by 0 entry).
Wouldn't it still be voluntary in that case to check the return value? Although, at least with your method, the function signatures will explicitly have the error type listed as the return value, so it does sound like a better option.
This is exactly correct. It *seems* like using floats would be a good idea because they kind of look like dollars and cents (1.25 makes you think of a dollar and a quarter) but as hegbork said, it's actually a terrible idea. As a general rule, "If you can count it, use integers" isn't at all a bad one (and you can count money, obviously).
Depends, but it is probably still voluntary, but slightly less since, as you say, things are in the signature and that allows for more static analysis. For example, if you are returning a `bool` or `enum` which encodes an error message, there is likely a way to get the compiler to warn if that value is ignored (for gcc/clang, see the ignore-result attribute). There’s also the pattern of emulating an option type. This would involve exposing a function to get the data, check if there is an error, get an error code. Although the called wouldn’t need to do those other things, it’s self-documenting that there’s something going on since you aren’t just returning the value directly. For sentinel values + errno, these are pretty idiomatic, and are slightly better of a pattern particular when 1) returning a pointer and you can indicate failure using a null pointer, and 2) the particular error is probably not so important since all errors are mostly unrecoverable. This is because the nice thing about dereferencing a null pointer will probably result in a run time crash (although it isn’t mandated to by the language) which is probably what you want. C makes use of this of course with`malloc` and family, and others, where failure probably means there’s no memory to get, and the program crashing is often not wrong. 
&gt; 1) 8, 16, 32 or 64 bytes long will be up to the user. I think you are confusing bytes with bits here. Also why not use `size_t`? This will give you the longest possible strings without any drawback except on exotic systems. &gt; 2) I made it like that because I was thinking in multiples instances of string. So, you will eventually need a pointer to it. struct my_string { char *data; size_t length, capacity }; struct my_string strA, strB; No need for a pointer in multiple instances. &gt; 3) Are you talking about the function that just returns it or the growth? The former. &gt; 4) Advice? In line 84, if the malloc in the macro fails, you forget to free the memory allocated in line 78. That wouldn't happen if you just used a plain structure as given above. &gt; 6) … No. Here is a problematic call: `string_push_back(NULL, 'A')`. &gt; 7) Will it be better to use two variables as buffers and that's it? void string_swap2(string dst, string src) { if (!dst || !src) { return; } char *tmp = dst-&gt;content; _UINT_ skjddf = dst-&gt;size; *dst = *src; src-&gt;content = tmp; src-&gt;size = skjddf; } More issues: 9) Btw, the latest version has another problem in line 433. 10) Why are you limiting the possible character set in push_back? `if (!self &amp;&amp; (!isprint(c) || !iscntrl(c))) {` Btw, this check is wrong. 11) `string_resize` Try to avoid `push_back` in a loop. 12) Please try the llvm static analyser on your code. It will give you details on your mistakes. 
The biggest issue I have with all str*cpy variants is that they don't tell you how much they actually copied‽ After doing one copy I would potentially add more data at that point, without having to resort to strcat.
cheating with the fact that argv[] is contiguous in memory, you even get: main(int c,char**v){for(char*s=v[1];*s==45&amp;&amp;c--;s++)while(*++s)puts(s);}
I agree that’s a shorter way of doing it, but sprintf works just as well, albeit it’s less simplistic.
Your right, but the new string would have the length of the number of digits + 1, because of the terminating null char.
&gt; log_100(100) = 2 log_10(100) = 2
Yup, stupid typo
Think about it: `d_name` is the name of a file/directory, but your `listDir` requires a path for `opendir`. You have to append `d_name` to to path in the recursive call. Also: using `d_name` isn't portable, make a call to `stat` to get the type.
I would make the function signature `void updateFile(char * fileName, char * searchWord)`, but I'm not sure if that will solve your problem.
does replace.c include text.h?
https://www.reddit.com/r/AskProgramming/comments/7u74pt/c_why_isnt_recursion_working_here/ 
The problem is likely in replace.c which you haven't shown. Do you have #include "text.h" In replace.c?
that seemed to be the problem but i don't understand, if it was included in text.c, why do i need to include it again? thank you for the answer
The C preprocessor works at the translation unit level, each `.c` file given to the compiler will be preprocessed separately. No `#` directive will have effect in a file other than the one being processed, with the exception of using an `#include`. The `#include` directive literally pastes the contents of another file into the current one. 
Got it thanks!
you didn't have to delete the post lol. maybe others are facing the same problem
I deleted it basically it's essentially the same post as what jedwardsol linked. Doesn't seem necessary to have two of them.
The return value of sprintf excludes the null character, so will be the number of digits, which is also what strlen would give. I prefer the log10 solution for the original question but wanted to point out that there was no need to use strlen after sprintf.
The log10 version is simpler. Thanks for the input though!
Have you tested what happens when you do allocate such a big array? Does it return NULL? Or does it allocate a mammoth array and everything slows down and you feel like you're wading through treacle? Have you tested it on a couple of different machines with different ram / and swap sizes and ulimits? You are also assuming you're hitting malloc returning NULL because someone forgot the --join flag. There are a hundred other reasons (memory leak, too tight ulimit, running on a small machine...) In which case quite likely _every_ malloc will fail, not only the mammoth one. Did you know some implementations of printf invoke malloc()? So do some of the pthread'ing primitives? So which other things are going to now be failing on you? Hmm. I probably have a copy of libc on my box, let's see what's in that err() thing. Ah, you might be lucky, it will try alloca() space on the stack, (which is a gnu special good luck porting your code) otherwise it realloc()'s. And invokes printf's.. Conclusion: Your code is flaky and will work sometimes as expected. 
Of course, simplicity wins. However malloc() isn't simple if you are operating in the region when "sometimes it returns null, sometimes it slows to a crawl". It is only simple under the assumption you are always operating in the region where it _always_ fits in the available ram. It's like C int's. We know they are crap. We know if they overflow we're in "nasal daemon" territory. But we use them. Because it's simple. And works (most of the time.) 
Actually I saying something stricter than that. I work on programs that are _required_ to work at all times (or it imposes unacceptable risks on people already operating in hazardous environments). By work I mean there are required and designed for maximum loads and resource requirements and the software prevents the system from going outside of those.
The older I get the more I preferred the pattern... * client to service (or library whatever): I want to do X, how much of what resource do you need? * service to client: I need N of M to do that. * client: Allocates or has preallocated or has a statically allocated that much resource. * client to service: Do X with this resource. Why is this good? Because it decouples the resource allocation / management strategy from the library ( or service). You can statically allocate (which is a Good Thing because you get to know that you don't have enough resource at link time, not 12 months later in the field), or use a specialist resource allocator.
haha, that was funny... I do not love C but I like it, I think it is necessary for a programmer to learn C to have a better understanding of computer and programming.
The other response is good. Here's a higher level explanation. replace.c needs to know what updateFile is. Is it an enum, struct, function? If it's a function what are its arguments and return type? Without including text.h, it has no idea.
Books?
C &amp; Lisp &gt;
I did that for a while too, but it gave me hell too, I don't remember exactly what it was tho, I switched that out about 6 months ago or so.
I thought this was going to be about all of the Indian blogspam we'd been getting. 
You're so full of shit
A piece of art right here 
As noted in the [strtok](https://linux.die.net/man/3/strtok) man page, `strtok()` modifies it's argument. If `content` and `pathTokens` both point into the same set of characters, both will be affected. Standard practice in this case is to create a copy of the string and use that one in `strtok()`
Does content point to the same memory as pathTokens?
content isn't a pointer, it's a char array. 
So does pathTokens point to it?
In your other reply you mentioned that `content` is a char array. What is `pathTokens`, and where is it created? If it is a char pointer (`char*`) pointing to the same memory location as `content`, then when `strtok()` changes `content`, `pathTokens` will also be modified.
i don't know, how can i find that out? i'm sorry this is new for me
how can i prevent it from pointing to the same location?
this was amazing
By looking at your code? The snippet you posted doesn't show how either one are defined or initialized or anything.
 char* pathTokens; char* paths; paths = getFilePaths(); pathTokens = strtok(paths, "\n"); updateFile(pathTokens, argv[1]); updateFile() is the code in the original post. and `token` and `content` are defined like so: static char content[1024]; static char* token; 
You should post a Minimal Complete Example instead of fragments.
**All** the code, not fragments.
even if i a variable other than `content` in the strtok, it still doesn't work properly
https://pastebin.com/dWWJrhHM 
More like (&gt; (&amp; C Lisp))
**All** your code. 
dammit i'm sorry, i forgot getFilePaths() https://pastebin.com/63uiyT3b
Hmm `traversal`, `searchword`, `numchanges` ... is this the same task some other user was having trouble with yesterday: traversing a directory tree with a given string and replacing occurrences in text files or something? lol
Having everything commented out makes it harder to tell what your actual code is doing. But it looks like you use strtok() to split one string up in a loop that then calls a function that uses strtok() to split another string up in a loop. So when you use strtok() in the inner loop it overwrites the state saved by the strtok() in the outer loop. If you only use it once in the inner function, the loop in the outer one starts using whatever string you gave it in the inner one. It's not a reentrant function; you can only safely use it in one place with no other uses in anything that first use ends up calling. 
Not that experienced in C so a few questions, why `#define _CRT_SECURE_NO_WARNINGS` and `define PAUSE system ("pause")`? What books are you researching? Your code formatting is pretty bad. Have you tried to compile this? Does not look like it will compile... This is a simple math problem, solve it first, then try to change it to a computer program. You are also more likely to get help if you have a more descriptive title and format your code better. 
How portable? I use syslog() myself. As for the ANSI sequences, just get rid of them. You can always pipe the output to another program that does the coloring (I have code that does that for syslog output). And one more thing about the code---you do know that vfprintf() exists, right? No reason to waste stack space for vsprintf(). 
&gt; How to master Turbo C
&gt; shitposting in c You mean my last few commits
Set the console output codepage to utf8 Use utf8 strings with `printf`
You mean, with chcp 65001? #include &lt;stdio.h&gt; int main(void) { printf("ΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩ"); return 0; } still returns ???????????????????
 #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; int main() { SetConsoleOutputCP(CP_UTF8); printf(u8" \u03a9 \n"); } 
Oh, thank you very much. 
*also valgrind gprof!!! 
Ah. This makes me remember my wedding! The toastmaster had found a version of “Let I be” called “Write in c” Hang on, let me fire up google... There we go When I find my code in tons of trouble, Friends and colleagues come to me, Speaking words of wisdom: Write in C. As the deadline fast approaches, And bugs are all that I can see, Somewhere, someone whispers: Write in C. Write in C, write in C, Write in C, oh, write in C. LOGO's dead and buried, Write in C. I used to write a lot of FORTRAN, For science it worked flawlessly. Try using it for graphics! Write in C. If you've just spent nearly 30 hours, Debugging some assembly, Soon you will be glad to Write in C. Write in C, Write in C, Write in C, yeah, Write in C. BASIC's not the answer. Write in C. Write in C, Write in C Write in C, oh, Write in C. Pascal won't quite cut it. Write in C. 
Learn the unix syscalls and the C stdlib. From there it should be easy to figure out how to implement the basic functionality of the unix coreutils.
As already said, start with something easy like `cat`. You can read through the POSIX spec for `ls`, usually there are things like "prints the information about as A as returned by the function F", so now you no you need to use F and can look at its spec.
&gt;Question is, how do I go about doing so without just copying the source code verbatim? Use a tracing util such as `ltrace` or `strace` to figure out what functions/syscalls are being used by the util you want to write. Research the ones you don't understand and implement your clone based on that knowledge. Alternatively, think of a feature that hasn't been implemented and implement it. If you're not creative enough to come up with features, just pick one from GNU `ls` and port it to a more stripped-down version of the same tool, like busybox `ls`. 
startpage.com (or similar search engine) start actually coding, then search for your answers (you should have lots of questions!) if you get stuck try reddits like this or similar for those learning C...
Things that come to mind: Deleting lock files, releasing shared semaphores, orderly shutdown of sockets…
The whole time I was thinking "this is circlejerk material", but then came the last frame.... That's hilarious. 
W. Richard Stevens' classic Advanced Programming In The Unix Environment is a good starting point.
There's a lot of problems with this, as already pointed out. It won't even compile as it is right now. First of all write this problem down by hand. Then think about how you would do that in C. Some other things: - You declare weight to be a double, but when you're setting it with `scanf` you're telling `scanf` that it's an int, not a double. The same with distance. - You don't define `shipcharge` anywhere. - Why do you use a float for `total_charge`, but use doubles for `weight`, `rate` and `distance`?
I did the same project. I read the POSIX standard and tried to implement exactly what the specification says. I can send you my implementation of some common utilities, including `ls`, if you are interested. I even encountered some POSIX bugs in the process which is nice.
What was your first program? What resources did you use?
POSIX bugs? Like what?
[What does `ls -R` without `-a` do when hidden directories are present?](http://austingroupbugs.net/view.php?id=1023) [Is `chmod()` allowed to silently ignore `S_ISVTX` on regular files?](http://austingroupbugs.net/view.php?id=1024)
No one is perfect! 
I prefer Mungo C
You forgot a post asking a C++ question.
you forgot about `C/C++`
meh
That book brings back memories. I still have my copy kicking around somewhere. I got that exact version for my 15th birthday.
Nice
Thanks for keeping up with me. 1. Yes, bytes I meant. I guess you're right. It shouldn't matter that much waste a few more bytes, right? 2. I'll look into that later.I'll have to do some overhaul. 3. So, you mean `string_length`? There are four different functions for that. `string_size` will give you the current value of `size_t size`; which is the size allocated for `content` including null termination.. That's O(1). `string_length` will give you the current amount of non-null characters in `content` starting from 1. So, yes. That's O(n). `string_capacity` is like `string_size`, but it doesn't include null termination. `string_length_raw` is like `string_length` but starting from 0. 4. Thanks for pointing that out. I had it right before, but forgot after implementing the macro. 6. Thanks, I realized that my conditions were not updated. I left them like that even tho I changed the logic. 7. That's what I realize I had to do. But, thanks for leading to it anyway. 9. Fixed, I believe. 10. I though the same at first. Then realize that it's how that string function behave in C++. `string_append` will push back a string. While `string_push_back` will just push once character. 11. Thanks, you're right. 12. I completely forgot about it. I was concern about memory issues and was just using sanitize and valgrind. Forgot about non-memory related issues. There's an update if you want to keep on with me still. Thanks again.
I think the ohm symbol is U+2326, whereas the letter omega is U+03A9. Usually the same grapheme, but a different codepoint.
Huh. That's... interesting.
Indeed. Was mildly amusing, then the last frame made me LOL.
You might want to write some library routines first that you will need in any utility program you create, like `getswitch()` for parsing switches from the command line. Then you could write your own utility; for example, one that converts line delimiters in text files from/to CR, CR/LF, and NL. You'll want to learn C and become familiar with finding system calls in the `man` pages, line `man -s 2 chdir`. Read `man man` also.
It's because ohm the unit label and omega the letter are two semantically different things that we just happen to represent with the same symbol. If we ever decide to represent ohms with... a bird or something, Unicode would have your back. Or rather, your font vendor would. Assuming you used the correct ohm codepoint and not the omega one. TLDR: Unicode is a glorious bitch.
You can also set your editor to utf8 and encode your source files in utf8 as well to be able to write unicode characters into the source code itself without a need for string or character prefixes. I find that it's much more readable that way. You should still include the code snippet you were given above to switch codepage from within your program as a conditional compilation directive on Windows. Its standard terminal (commandline) throws a hissy fit with utf8. Also keep in mind that most utf8 codepoints take up more than one byte in memory, so string handling might be a little quirky. You can work around that, or if you can't be bothered C11 standardizes that for unicode. C99 provided similar facilities through "wide characters", but they're more trouble than it's worth, so I'd avoid them if possible.
In that case it's a contract of the function like how a char * to strlen is NUL terminated. You have to weight the pros and cons of doing it in such a way.
Your numbers got messed up. 1) Please look into structure alignment and padding. You are wasting time, effort and memory with `uint8_t`. 3) So you now have four functions that return some type of string length? That is atleast two too many.
Easy to learn c++ programing for beginner
You're in the wrong part of town, son
C++ is off topic in this subreddit. Please post C++ content elsewhere.
&gt; like getswitch() for parsing switches from the command line. Why not use `getopt()`?
I was using malloc but the teacher said I should not do it this way or I will lose points. I can allocate 1000 but maybe the user will enter 1001 and this will cause a trap 6 error.
This line: strcpy(array, lectureEntree(array, maxCarac)); causes undefined behavior because you're using `array` as both the source and destination. You can just remove it because it wouldn't do anything anyway. &gt;I was using malloc but the teacher said I should not do it this way or I will lose points. &gt; &gt;I can allocate 1000 but maybe the user will enter 1001 and this will cause a trap 6 error. Those are the only two options you have: either restrict the maximum input size or use `malloc` (or another function that allocates memory dynamically). If your teacher says that you cannot use `malloc` then you can probably safely assume that the user won't enter thousands of characters.
&gt; I can allocate 1000 but maybe the user will enter 1001 and this will cause a trap 6 error. There won't be an error because `fgets` only reads as many characters as your array can hold. However, without dynamic memory allocation, it is not possible to solve this problem at all as for each array size you allocate, the user could just enter a longer string. For some problems, algorithms can be found that do not need to keep the entire input in memory. These algorithms are called *online algorithms.* If you could explain what exactly your program is supposed to do, perhaps I could explain how to solve your problem with an online algorithm. Given the fact that the teacher explained not to use `malloc`, I suspect that he wants you to just allocate a sufficiently large array. You could also be cheeky and allocate memory by some other mean, say, using `sbrk()`. However, it is possible that he is going to dock you points anyway.
&gt; As a simple fix, just make your arrays larger than any possible line could be. 200 characters should be sufficient This is how exploits are born ...
That line should be replaced with `lectureEntree(array, maxCarac);` 
Add a variable `highestDay` and `lowestDay`. Also you should initialize the `highest` value to something low, and the `lowest` value to something high, so the first entry automatically goes there.
It would be better to give hints and tips instead of directly giving a solution.
I didn't give him any code.
I understand what you're getting at, I already used variables lowday and highday, but just lost as to how to get my program to find which day # had the highest and lowest temp
Clearly not since he's still struggling with it.
* All open named semaphores are automatically closed on process termination. * flock's and lockf's are automagicallly release on fd close (ie. on process exit) * Why do you need to orderly shutdown network connections? The OS closes them all on process exit. The older I get the more "crash only" software makes sense to me. Sooner or later your program _is_ going to crash. Even if your code is perfect, somebody is going to trip over the power cable (or something). So if you really care about writing robust software, you write and test your software under the assumption it _will_ crash, and _must_ be able to be restarted and Just Work.
The key to learning new skills is to persevere through feeling a lack of progress. Keep reading, keep doing exercises, or go through a top tier universities' online resources. Just as long as you keep putting time in you'll make it, even if you switch learning mediums.
In general, every programming book builds up chapter by chapter. So it is important that you get the early stuff in case they are used in the later chapters. How about you ask your question here? What are you having trouble with. Many of us have read K&amp;R and practically know the book cover to cover. Make sure when you ask your question you give an example of what you tried and show that you put some effort in, everyone in this subreddit is ready to help.
As far as I know is chapter 2 dealing a lot with bitwise operations and I can Imagine that it´s not easy if you dont know yet how a computer really works. Currently I am reading this book too and I did every task but even for me (I am studying computer science) I needed 2-3 hours to understand and finish the task in Chapter 2. The thing is that the chapters after are getting mostly more complicated so its important that you really understand what is happening the chapters before. So I recommend you to do EVERY task and if you are stuck, read up a lot, ask question and then compare your solutions 
for the last 30 years I've been meaning to read that book.... but then I came from having learnt z80 and 6502 programming first, so a lot of the low level stuff was kinda obvious... I kinda feel sorry that there isn't an assembly language learning platform, when you had just a cpu memory and a memory mapped display then it was much less complicated that on modern systems...
probably not most efficient but a quick and simple to understand way is to have two arrays which store the high and low temps. As you get user input, you compare those temps. to the ones in the arrays. Then, if it’s the lowest/highest or whatever, just set the variables like highestTemp, lowestTemp, highestDay, and lowestDay accordingly
1. In variable argument functions, `float` gets promoted to `double`. But `float *` doesn't turn into `double *`. Thus the need for "%lf" in scanf(). Personally, I'd rather have float use "%hf" to match short and int, but it's a little too late for that...
Ok so basically, I'm going to make a while statement then? I think that's where I might have gone wrong, over-thinking on my part.
Right
`getopt()` is for shell scripts. I'm talking about parsing switches from a C program. I don't know of any system call or Standard C Library routine that does that, so I wrote my own. I also like being able to use keyword switches like `-dir` as well as single letters so allowed for that as well.
&gt; How do I shrink this list to define just once for multiple names? You don't. Why do you need to shrink it? Just put it in a header out of view if you don't want to look at them: #include "mydefines.h" 
If you want to be able to use all the macros then the list cannot be shrunk. The only way to shrink is if you were to replace the usage also to just one set of macros, ex: you use A1 everywhere you want 1. Are you trying to shrink because of aesthetics or that you are worried about introducing a bug with mismatched values? If it is the latter then there are other options like assign one macro to another or use enums and keep the same values next to each other and assign the enums that need to have same values to a macro or another enum.
If there's logic to those names and you might have more of them then you could have a script that generates the header for you. 
What do you mean by "`%hf` to match short and int" ?
The rationale for these sort of things is "What Kernighan &amp; Ritchie decided to do on their PDP-11 in the early 1970s". And by the time standardization rolled around there was so much existing code that it would have been a failure to try and tell everyone to change their code. 
I need to have that first sentence framed up on my wall sometimes. Thanks! I can attest to the truth too. I kept leaving and coming back to C and now things are clicking!
He's talking about this [getopt()](https://linux.die.net/man/3/getopt) function from POSIX.
It's just taking up a whole screen at the top of my file. This gives me an idea to put it all at the bottom, though it probably does need to be above the values which are being replaced. I tried putting five on each line but that wouldn't be accepted. Unless I just don't know the character needed to space them, I only placed a space between each so maybe a comma? I don't know. #define A1 1 #define A2 2 #define A3 3 #define A4 4 #define A5 5 I don't want to create a separate file. I want my code to be an easy copy-paste for other new and amatuer Arduino users. Thanks for the response though, I hadn't realised you can do that.
Initialize lowest to a very high value and highest to a very low value Each cycle, if low &lt; lowest, lowest=low if high &gt; highest, highest = high
printf statements
You should talk to [your classmate](https://www.reddit.com/r/C_Programming/comments/7vq430/how_to_display_highestlowest_temperature_on_what)
&gt; getopt() is for shell scripts. Note that there is both a `getopt` command in the POSIX shell and a POSIX library routine called `getopt` to parse command line options in programs. &gt; I also like being able to use keyword switches like -dir as well as single letters so allowed for that as well. Be careful with that. Multi-letter options do not mesh well with combining single letter options.
The reason for that is [call by value](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value).
Edit your .bashrc and add whatever you want or you can download cowsay and use that.
You don't seem to understand variable scoping or argument passing. Try reading your book again or asking your teacher.
The variable x in your function is not the variable test in main, but a copy of it. Changing it inside the function only changes this copy and not the original. If you need to change the original variable you need to adjust the function to take a pointer to the variable and dereference it, e.g. void function(int *x) { *x += 1; sprintf("%d\n", *x); } ... int test = 0; function (&amp;test); ... I'm on my phone so the code isn't complete but you should get the idea.
Okay, but doesn't a promotion to `double` possibly change the value?
1. (and 2.) Hm, but that's more well-known, however it seems that the wrong assumption about floating point literals is more common. But I see a problem with your points a) and b), since both might change the value. In fact, doesn't this mean that you cannot print a `float` without promoting it to `double`, possibly changing the output? I mean, in the `%c` case, the value is casted back, but for `%f` there's no such option because noone knows whether the passed value was a `float` or a `double`. Good catch with the `sizeof` etc. operators though, this makes it even a bit more difficult. 3. The problem arises when there are characters `c` returned which are `CHAR_MAX&lt;c&lt;=UCHAR_MAX` -- in that case, a cast to a `char` would change the value. It's not relevant for most architectures nowadays but it to me comes as an unneeded limitation.
You don't seem to understand that you're condecending garbage, try giving a helpful response like: "Look up calling by reference".
But sometimes there's somewhere a record of why they did that ;) Why has nobody new introduced floating point literal suffixes or the `%hf` specifier? At least 1. and 2. could be changed without breaking existing code.
It exists in C and for scripts, just like printf or exit. To display all available manpage sections, use $ man -f getopt ... (3) getopt (3p) getopt You'd get a list of different man page sections containing an entry for getopt. For usual Linux, 3 are system functions, 3p are system functions as written in POSIX.
I like to spend 1-1.5 hours per exercises I can't understand. half an hour thinking about the solution on paper, half an hour coding it up and then if I don't have a break through, half an hour looking at other peoples solutions online and coding theirs up and really thinking about what their thought process was.
If you are looking to emulate gui in a terminal screen, you might want to look at ncurses.
I don't know what you mean that "VS requires a function `getchar` while CodeBlocks does not" but here are some things I've found: 1. provide a prototype for main/setplayer/...: int setplayer(void); int main(void) { /* code */ } An empty parameter list does not provide a prototype, thus the compiler will not (read: is not allowed) to give you errors if you pass arguments to this function. 2. First user-input loop: Use do-while, to get rid of redundancy. 3. *Please* don't use so many global variables. 4. Make all compile-unit-local functions `static`. 5. Use a code style, especially this killed me: do{ /* code */ } while (/* cond */); 6. Initialize `rand` with a seed at startup, often `srand(time(NULL));` is used. 7. in winner you have much redundant code which's reason I cannot comprehend without trying to understand the program logic, but it can be at least cleaned up with `switch-case` a bit. 8. In huge if-else blocks where at the end of the first block you could also just write `return;` because that's what follows after the else block immediately, do so -- and then get rid of the else. With huge blocks you have to keep track of the first block still being there and knowing that it'll jump over the else block.
I can't be as savage as /u/raevnos. Your average will be wrong [Hint: Check the scope of your for loop]. You're not saving the temperatures entered for their respective days. How do you know which day was it? [Hint: You have copied this code. Use arrays and "int i,d".]
There's no need for either of those things. %f and %lf exist , what's to gain by adding %hf? And if you did add it then you have the new problem that any code using it won't work ok any compiler that hasn't implemented it yet , which could be forever due to it being a library issue. Some implementations don't even support %zu yet.
yeah but you need actual hardware, connected to a real screen and ideally a joystick.... makes learning more fun and when its fun it stops being "learning"
You could print `float` w/o promotion that might alter the value. Also, only `%f` = `double` and `%Lf`= `long double` exist.
`%lf` exists and it prints double. I don't think promoting float to double can alter the value? (floats ought to be a strict subset of doubles, although I'm not sure if the standard guarantees that). 
oh man
WinAPI always felt more homogeneous to me: there's `CreateProcess`, `CreateThread`, `CreateFile` etc ... most return handles that are similar to fds in Unix. Both `CreateThread` and `CreateFile` return handles for example, this allows you for instance to wait for a thread to exit or a file op to complete with the same function `WaitForSingleObject`. Or if you want to wait on both at the same time there's `WaitForMultipleObjects`.
&gt;mainly so I can use the Windows UI, rather than that god awful GTK+ library There is something god awful wrong with that statement.
Hm you're probably right, but those functions all need (probably, didn't look them up) billions of arguments, which you'll have to look up because you can't memorize them, i guess. Another thing I don't like in the WinAPI is the PascalCase everything's written in. **C is snake_case!** Java may be Pascal- or camelCase, but Java isn't C. I know that's just a small detail but it really bugs me. It makes all your files look inconsistent, because either you stay with the standard library's snake_case or you adopt the PascalCase from the WinAPI. One way or the other, you'll have two types of cases in your program.
Easy to learn c++ program
The man page for execvpe is pretty well detailed and should explain what each argument is. The file argument should be is the path to the application you want to execute. [0] is the name you want to give the new process. Typically this is the same as the file argument. This explains why your instructor probably wrote something like this: execv("ls"/*file*/, "ls"/*argv[0]*/, NULL); The final argument to execvpe should be an array of environment variables ("key=value" strings) to pass to the new process. This array should also be terminated by NULL.
From the linux `man execvpe`: (formatting and emphasis mine) &gt; The `execv()`, `execvp()`, and `execvpe()` functions provide an array of &gt; pointers to null-terminated strings that represent the argument list &gt; available to the new program. The first argument, by convention, &gt; should point to the filename associated with the file being executed. &gt; **The array of pointers must be terminated by a null pointer.** &gt; The `execle()` and `execvpe()` functions allow the caller to specify the &gt; environment of the executed program via the argument `envp`. ** The `envp` &gt; argument is an array of pointers to null-terminated strings and must be &gt; terminated by a null pointer.** The other functions take the environment &gt; for the new process image from the external variable `environ` in the &gt; calling process. From the `man environ`: (formatting also mine) &gt; By convention the strings in `environ` have the form `"name=value"`. If you don't need to specify the environment variables manually, just use `execvp`, which uses the global `environ` variable, holding the current process environment variables. (Which is probably what you want so you're "transparent").
Nope. All floats can exactly be represented as doubles on all platforms I know.
Give him topics to read about? That's exactly what I did, idiot.
So, would "env" be the file you are trying to execute? I do need to specify my environment in this project. What I've gathered so far is that this is what I need to do. To preface, my command line when running the initial program is supposed to look like &amp;./leaktest &amp;./test_file with "test_file" being specified by the user (so cannot hard code the name) char *args[] = { argv[1], NULL }; char *env[] = {"./shim.so", NULL }; excvpe(argv[1], args, env); Does this look right? 
I remember this question. Didn't you already post somewhere else a few days ago?
Please put four blanks in front of your code example so it comes out readable.
That does not look right. The environment is supposed to be a list of strings of the form `variable=value`. `./shim.so` is not of this form.
The way he told us to do it was to set the LD_PRELOAD. Would it then be correct to put in the environment `LD_PRELOAD=./shim.so`? Because, when running a program, the command line looked like `$ LD_PRELOAD=./shim.so ./shim_test` when we were learning about using shims.
Yes, that's correct. The variable is called `LD_PRELOAD` and the value is `./shim.so`. If you are ever unsure about environment variables, remember that you can use the `env` command to list all variables in the environment and their values.
Hm, by 6.3.1.5 par 1 the standard only demands equality "if possible". However I'm not sure if this "suffices", as I've outlined here: https://www.reddit.com/r/C_Programming/comments/7vrros/questions_regarding_the_design_of_the_standard/dtvekff/ The idea is: Might the "fake" new precision of doubles change the decimal representation in a way that gives misconceptions about the actual result?
&gt; The idea is: Might the "fake" new precision of doubles change the decimal representation in a way that gives misconceptions about the actual result? I don't think so. However, if you need all digits a float provides to be exact in your printout, it is likely that you already chose an insufficiently imprecise datatype. In practice, it's going to be hard to find a platform that does not use IEEE 754 and on IEEE 754 platforms, all floats can be represented as doubles exactly with the caveat that the mantissæ of NaNs are mapped in an implementation defined manner. Though, this rarely matters anyway and `printf` does not distinguish NaN values from each other.
&gt; I don't think so. However, if you need all digits a float provides to be exact in your printout, it is likely that you already chose an insufficiently imprecise datatype. That's true of course, though I'm not sure whether this'd even be needed but I'm too tired right now for doing the maths to try check if there's a way to do what I want. Maybe some other day.
Thanks for the clarification -- I just missed it in the man pages. Nevertheless, I decided to write my own function for a couple of reasons... so I could use keyword switches as I mentioned previously, and so I could add switch validation features to the function; for example, missing required switches, invalid switches or arguments, etc. I accomplish this by setting up a switch table (array of `struct` descriptors) which describe each possible switch, including flags that specify validation requirements (like "must have a numeric value"). The more of that housekeeping stuff the function can do, the less I have to do in the programs I write. I realize that this design conflicts with combining single-letter options, so my solution is to simply not support that -- that's a tradeoff I'm willing to accept.
That's how the code should to look. #include &lt;stdio.h&gt; void function(int *x); int main() { int test, i; test = 0; printf("%d \n", test); for (i = 0; i &lt; 10; i++) function(&amp;test); return 0; } void function(int *x) { *x += 1; printf("%d \n", *x); }
Pascal- vs Camel-case is a preference thing isn't it? Follow the standard for the environment you're coding in: casing, tabs/spaces, number of spaces, curly positions, etc. and your code will look good no matter what the convention. "Windows bad, Linux good because different conventions" is just harsh.
&gt;Follow the standard for the environment you're coding in Yeah, as I said, the standard c library is written entirely in snake_case, but the C-WinAPI is PascalCase. A lot of libraries to that too, like the WiringPi-API for Raspberry for example, so the WinAPI is not alone. Of course, that's just a detail and its not important at all, but it still bothers me a lot.
Windows predates standard C.
You can try out [libc-test](https://wiki.musl-libc.org/libc-test.html); it has some malloc tests. I've used it a little for testing for my work and it was easy enough to integrate and use.
The ultimate test is to `LD_PRELOAD` it into normal applications and use them.
Yes there is. Project Options -&gt; linker -&gt; system -&gt; subsystem = "console"
Depends a bit on how forgiving you are of weird behaviour. I have seen old long time existing programs.... * malloc 0 bytes. * free whatever malloc'ing 0 bytes gave them. * free pointers which are offset into the region that malloc gave them. 
You can't put multiple preprocessing directives on one line. But how about ``` enum { A1 = 1, A2, A3, A4, A5, A6, B1, B2, B3, B4, B5, B6 }; enum { Ared = 1, Ayel, ... ```
&gt; C is snake_case No, C is "omit as many letter as you can until the function's name is unrecognizable". That's why we have `strcat`, `memcpy`, and my favorite, `creat`. Snake case as a widespread convention didn't come along until much later than the creation of the Windows API.
&gt; The `CreateProcess`-Function needs a billion argument while in Linux, `fork()` needs none. That's disingenuous, because `CreateProcess` can do quite a few things in one fell swoop, while `fork` can only do one. To do the same work as `CreateProcess`, you actually need to use a combination of `fork`, `exec`, `chown`, `setenv`, and `setpriority`. (There are probably a few more that I'm not thinking of.) A lot of that work has to be done by the child, so for instance if you're implementing a shell, your work isn't done after you `fork`; *your* new process has to modify your environment, change directories, close files, and then `exec`, whereas `CreateProcess` would do most or all of that for you. A much better comparison would be between `CreateThread` and `pthread_create`. 6 arguments versus 4, but one of them is an out-parameter, and the other is encompassed by the `pthread_attr_t`. So really, they're not all that different.
I would make a function called 'live' that tells you if something at a set of coordinates is live or not, and reuse it everywhere.
Ah, great point: Thanks for the suggestion! :)
And you're posting this question in a C programming sub why? 
This is a sub for the C language, C++'s predecessor, so we won't necessarily know how to help you. Probably /r/cpp (I think) will serve you better. Nonetheless, you probably will need to download a C++ IDE, which you can look up yourself (Visual Studio, for example). As for the best language for microprocessors, I do think C++ is a good option, but I don't know about that.
Because as a beginner he probably don't know the difference between C and C++... Which is normal I think.
Say you have a 2D array and you want to find out what a square has. You can do this: if( array[ x ][ y ] == something ) { } every time you want to test it. Plus you throw in making sure x and y are safe to even index, and it turns into something like this: if( x &gt; -1 and x &lt; XMAX and y &gt; -1 and y &lt; YMAX and array[ x ][ y ] == something ) { ... } every time you want to do something. Or you do something like this: if( fun( x, y ) == something ) { ... } Because you do all that other junk inside the function. int fun( int x, int y ) { return x &gt; -1 and x &lt; XMAX and y &gt; -1 and y &lt; YMAX; } You could use a macro: #define FUN(X,Y) ( ((X)&gt;-1) and ((X)&lt;XMAX) and ((Y)&gt;-1) and ((Y)&lt;YMAX) ) It might be even faster, but it's not really better. So I'd just use a clean little function to tell me: int live( int x, int y ) { return x&gt;-1&amp;&amp;x&lt;XMAX&amp;&amp;y&gt;-1&amp;&amp;y&lt;YMAX&amp;&amp;array[x][y]==something; } Because it's just intuitive when you see it used: neighbors = live( x-1, y ) + live( x, y+1 ) + live( x+1, y ) + live( x, y-1 );
Use %p for pointers, it will print the native pointer size. On 64 bit there are three address regions, user, non canonical, and kernel. You will never get a VA higher than user mode cap 0x7FF'FFFFFFFF
Try %p and cast stressed to a void pointer
Yes I don’t know. I’m finishing up physics, but have hardly touched programming
Well...compilers are used on ides, you just don't see it. 
Mostly this. Also you can link to the windows C GUI libraries from any c compiler on windows. Personally I use mingw-w64 from msys2. I don't want to pay for VS 😅
C++ is an awful programming language (imho) that we don't talk about here, we use C which is a different language albeit the roots of C++ lay in C. Microcontrollers also are mostly written in C. However,if you've never touched programming, it's usually a good idea not to at first specialize in a language. Although you don't want to "learn them all", it's helpful to look a bit further than just one language, I'd say. Learning programming is however much different from learning a programming language. MATLAB is a language that's quite different from C/Java/PHP/... because it's specialized for one purpose and breaks many "norms" that many languages share, although still being an imperative language. But if you've already worked with MATLAB, Python might a be a bit better as an introduction, because the workflow is a bit similar and numpy (a library for Python) is often used nowadays as a "modern" MATLAB replacement. There's also Julia of course. --- Programming languages are mostly the same from the theoretical standpoint, they can be used to solve problems (in a mathematical sense) and any language that's seriously used can solve any problem ("Turing completenes"). The differences are in the programming paradigm, the way how you execute the programs, the toolchains, the syntax, ... . You have declarative and imperative languages, the former is rather similar to maths, the latter is mostly used in the field you want to go into. For completeness, declarative languages work by the programmer stating "what should be", like in maths where you say eg. "S is a set of natural numbers, such that holds: for each s in S: s is even". In imperative languages you'd say "Start with S = ∅. Go through the numbers from i=0..N, if i is even, add it to the set." The difference is that you state "commands" how to do something, rather than what -- that's where the name comes from. Now we have compiled and interpreted languages. You are mostly already comfortable with the latter: You might even have an IDE/Editor in which you code MATLAB and then execute it by the press of a button. The computer doesn't know however, how to understand MATLAB code, so actually the computer executes a program in a language that it understands (machine language) which serves as an interpreter that reads your code and instructs your CPU what to do in it's native language, live. So, if there's some syntactical error in your code, you might not know it even after executing, because that specific code path was not executed, thus the interpreter didn't try "translating" and also didn't notice the error. The alternative is compiled languages. Fist, obviously we can never have only interpreted languages because we always need a program in machine language that can interpret the rest. Basically, the CPU works as an interpreter in hardware for machine language and translates it into other things to do the magic it does. However machine language is... 1s and 0s after all. If you'd do so, you'd usually use a different base for editing, but the basic idea is to edit bytes, because the numerical values are interpreted. That's where the assembler comes in: Assembly is a language with a really simple direct mapping between bytes and human commands like "ADD", "SUB", ... . So one might write a program like this: global main main: MOV rax, rdi SUB rax, 1 RET And the assembler creates an object file mostly just containing this code in machine language. However, machine language is so close to the hardware, that it's not only different across CPU architectures (x86 in your PC, ARM in your mobile, x86/SPARC/POWER/... in servers) but also sometimes dependant on what devices you use etc. And because assembly is a direct translating of bytes into "mnemonics", writing this is tiresome in the end. Compilers were invented. Compilers can translate a source language to an output language, most commonly assembly or machine language. The source language does not need to be hardware-specific anymore, you can write C for x86,ARM,POWER,... you name it. It can also be more complex, syntax-wise: int main(int argc, char *argv[]) { return argc-1; } However, in languages like C, you still need to care about the hardware -- but from a program logic level. Java is the last notable mention, because the interpreter of Java serves as a virtual-machine with its own machine language (Java Bytecode) and the Java compiler compiles to that Bytecode, and the machine executes it. Thus the execution is almost completely the same on every PC that has the same virtual machine (in compiled languages) installed -- you (mostly) don't need to care about the "real" hardware, even on the logic level. Compiled languages again though: When you write code, you save it into eg. .c files, this is the code that gets translated by said compiler. Usually, bigger projects have multiple source files, so we need something to "glue them together" -- this is called a linker (note that you also need a linker for just one file, but that's a different story). Mostly though, the linker is executed silently by the compiler. The idea is, if you have 2 codes, A and B and A has a function f and B a function g st. f calls g, then the compiler takes note when compiling A that it calls an unknown function g and, when compiling B, it provides a function to the "outer world" called g. The linker resolves those references, given all the objects. That's it, mostly. Back to C: You need to care also for the OS, C is primarily dominant on Linux, Microsoft just recently caught up on a "modern" C compiler, before it was good old C89. You should familiarize yourself a bit with the command line, going through directories etc. You can call the compiler like that (provided, one is installed, usually GCC or Clang). For a single code, compiling, assembling and linking can be done like this: $ cc input.c -o program Executing: $ ./program *Read up on how to enable warnings etc., you should care about them!* You can edit the input.c file with any editor you like, the shell can be "your IDE". I especially advise that for beginners, however you might change to an IDE lateron -- but then you should know what to look for. I find Visual Studio Code with appropriate extensions or QtCreator not bad. There's also CLion but I've scarcely touched it, I'm a command line guy.
The rand function could be used to get a random number between 0 and the max value you send it. The max value would be the number of nodes you have. Each node carries an artist name and a song so why not also give it an int value to save its position. Song 1 in Node 1 references Song 2 in Node 2 and so on. The last node is Song N in Node N where N is the length of the entire list. With the rand function you can pick a random number between 0 and N. Now you have a random Node position you want to move. But where to move it? Call the rand function again to decide its new position. Now you could have a separate function that takes a whole list, a node position value to be moved, and a node position for this node's new destination. Repeat this process N or so times so that a list of length N has its nodes re-ordered N times. Hopefully this is clear. 
Hm, you're probably right. I didn't take a such a deep look at the WinAPI and I bet it may also have its advantages. But in the end everybody has to decide for themselves what they want to use. The possibilities are on both systems infinite.
There are essentially two parts to this problem. Firstly, you need to determine a random order of the songs. Let's say that you have a doubly-linked list of N songs. Your first task is to determine a random permutation of the first N natural numbers (1, 2, 3, ... N). Use the Fisher-Yates shuffle to do this. (https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm). Implement this shuffling algorithm by making an integer array of N elements, and fill the first element with the number 1, the second with the number 2 and so on and so forth. Secondly, you have to traverse the linked list. Say you have run the shuffling algorithm and have the permutation (2, 7, 3, 5, 1, 4, 6). You will need an integer variable to keep track of where you are in the list. You start at the head of the list (position 1). Look inside the permutation array. You want to play song 2. Go forwards in the list once, and increment the tracker variable. Play the song. Look inside the next element of the permutation array. Now you want to play song 7. Go forwards in the list 5 times and increment the tracker variable each time you step forwards in the list. Look inside the next element of the permutation array. Now you want to play song 3. Go backwards in the list 4 times and decrement the tracker variable each time. Repeat this until we have played all songs in listed in the permutation array. Of course you can determine the amount of times you need to step forwards or backwards by the value of the tracker variable and the song number in the next position of the array. Sorry for my English, it's not my first language.
'K&amp;R - The C Programming Language', 'Stephan Prata - C Primer Plus', 'Zed Shaw - Learn C the Hard Way'. C language is very simple. It has only around 30 keywords, so it's not to hard to learn C syntax. But all other information you should to find in other books and in different documentations. And first of all, you have to get a good idea for some project on which you would work and learn other cool C stuff.
Im using programming in C by Kochan... I think as long as it has plenty of exercises and you actually do them is the key.
C (the language this sub is about) is not C#, and asking for people to do your homework, without trying yourself, is generally frowned upon on Reddit (on this sub or elsewhere).
C# is a different language from C. You won't find C# help in this subreddit. Also, just posting the text of your programming assignments will generally get you a very bad response anywhere. Most programmers who hang out in these sorts of places hate the idea that someone might get through one of these courses by having assignments done for them, and will only help with specific questions where the asker has shown that they understand the question and are really working at it. If you don't have a very narrow question and need broader help then you should get it in person from a TA or maybe discuss it with another student (under whatever guidelines the class or school has for student help).
C++ is off topic in this subreddit (so are Java and PHP). Please ask C++ questions elsewhere, e.g. in /r/cpp_questions.
No one mentioned this yet: you can't do this in-place, the new cell state has to be stored somewhere else. If you store the next cell state in the same location then its neighbors won't update properly. Now you're using `char`s so an idea would be to use another bit in the char to keep track of the new state. At the end of `lifeRules` traverse the matrix once more to update the cell states to the new states.
It may be best to refer to the correct spec. WG14/N1256 Committee Draft — Septermber 7, 2007 ISO/IEC 9899:TC3 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- 7.20.3 Memory management functions \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- 7.20.3 Memory management functions The order and contiguity of storage allocated by successive calls to the calloc, malloc, and realloc functions is unspecified. The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object and then used to access such an object or an array of such objects in the space allocated \(until the space is explicitly deallocated\). The lifetime of an allocated object extends from the allocation until the deallocation. Each such allocation shall yield a pointer to an object disjoint from any other object. The pointer returned points to the start \(lowest byte address\) of the allocated space. If the space cannot be allocated, a null pointer is returned. If the size of the space requested is zero, the behavior is implementation\-defined: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object. [7.20.3.1](https://7.20.3.1) The calloc function Synopsis #include \&lt;stdlib.h\&gt; void \*calloc\(size\_t nmemb, size\_t size\); Description The calloc function allocates space for an array of nmemb objects, each of whose size is size. The space is initialized to all bits zero. Returns The calloc function returns either a null pointer or a pointer to the allocated space. [7.20.3.2](https://7.20.3.2) The free function Synopsis #include \&lt;stdlib.h\&gt; void free\(void \*ptr\); Description The free function causes the space pointed to by ptr to be deallocated, that is, made available for further allocation. If ptr is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the calloc, malloc, or realloc function, or if the space has been deallocated by a call to free or realloc, the behavior is undefined. Note that null need not be the same as the representation of floating\-point zero or a null pointer constant. The free function returns no value. [7.20.3.3](https://7.20.3.3) The malloc function Synopsis #include \&lt;stdlib.h\&gt; void \*malloc\(size\_t size\); Description The malloc function allocates space for an object whose size is specified by size and whose value is indeterminate. Returns The malloc function returns either a null pointer or a pointer to the allocated space. [7.20.3.4](https://7.20.3.4) The realloc function Synopsis #include \&lt;stdlib.h\&gt; void \*realloc\(void \*ptr, size\_t size\); Description The realloc function deallocates the old object pointed to by ptr and returns a pointer to a new object that has the size specified by size. The contents of the new object shall be the same as that of the old object prior to deallocation, up to the lesser of the new and old sizes. Any bytes in the new object beyond the size of the old object have indeterminate values. If ptr is a null pointer, the realloc function behaves like the malloc function for the specified size. Otherwise, if ptr does not match a pointer earlier returned by the calloc, malloc, or realloc function, or if the space has been deallocated by a call to the free or realloc function, the behavior is undefined. If memory for the new object cannot be allocated, the old object is not deallocated and its value is unchanged. Returns The realloc function returns a pointer to the new object \(which may have the same value as a pointer to the old object\), or a null pointer if the new object could not be allocated. \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- end of 7.20.3 Memory management functions \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
I'd use &lt; and &gt; rather than == to account for values like -2 or 2345. Your counting neighbors function you should first write so it's easy to understand (clean), and then worry about saving space or optimizing it. 2D arrays as arguments are a bit tricky. You would use something like this: int cln( char grid[20][20], int x, int y ) { ... } You need to specify the size of the array being passed to the function. (Technically you can leave out the first size, but since you know the actual size, it's best to specify them all). Then you'd call it like this: something = cln( grid, x, y ); I would have had the wrap check inside the live test, because that way I don't have to type it a hundred times.
With optimization (`-O1` is enough for gcc and clang), [both ways produce the same code.][godbolt] [godbolt]: https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:___c,source:'%23include+%3Cstdio.h%3E%0A%0Avoid+ifs(char+*flag,+int+y)%0A%7B%0A++++%23if+DOVAR%0A++++char+letter+%3D+flag%5By%5D%3B%0A++++%23define+LETTER+letter%0A++++%23else%0A++++%23define+LETTER+flag%5By%5D%0A++++%23endif%0A++++if+(LETTER+%3D%3D+!'a!')+%7B%0A++++++++puts(%22Alpha%22)%3B%0A++++%7D+else+if+(LETTER+%3D%3D+!'b!')+%7B%0A++++++++puts(%22Beta%22)%3B%0A++++%7D%0A%7D%0A%0A'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:38.059181897302,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cg72,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'0'),lang:___c,libs:!(),options:'-DDOVAR%3D0+-O1',source:1),l:'5',n:'0',o:'x86-64+gcc+7.2+(Editor+%231,+Compiler+%231)+C',t:'0'),(h:compiler,i:(compiler:cg72,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'0'),lang:___c,libs:!(),options:'-DDOVAR%3D1+-O1',source:1),l:'5',n:'0',o:'x86-64+gcc+7.2+(Editor+%231,+Compiler+%232)+C',t:'0'),(h:diff,i:(lhs:1,rhs:2),l:'5',n:'0',o:'Diff+x86-64+gcc+7.2+vs+x86-64+gcc+7.2',t:'0')),k:61.940818102698,l:'4',m:100,n:'0',o:'',s:2,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4
As u/Neui said it makes no difference in speed. I setting a variable though just because it find it slightly easier on the eyes.
I chose C89 because it's a good "lowest common denominator" for C implementations. If you want to refer to a more recent spec, you may as well cite [the C11 version](http://port70.net/~nsz/c/c11/n1570.html#7.22.3). NB: You can find hyperlinked versions of all the C standards at http://port70.net/~nsz/c/.
You mean a command line argument to your program, right? You need the two parameter version of main(), and then check argc to see how many elements are in argv, and act accordingly.
1ish. A `float`→`double` promotion shouldn’t change the value unless there’s a change-of-base or something (e.g., binary to decimal). But within a single ABI AFAIK you’re just going to right-pad it with zero digits and re-bias the exponent. `FLT_RADIX`, `FLT_EVAL_METHOD`, and `FLT_ROUNDS` are all singly-defined. 2\. The value *may* change iff `char` is signed, but as long as you consistently look at the thing as an `int` or `char` or `signed`/`unsigned char` (e.g., putting it in a buffer of `char`s), you’ll see a consistent value. And you wouldn’t(shouldn’t) cast it to `char` or `signed char` unless you knew it were inside the allowable 0–`UCHAR_MAX` range first, because it could be some noncharacter return otherwise. Either way, if you’re dealing with characters outside of the usual 7-bit range, you’re probably going to want to use `unsigned char`, since you can’t safely do bitmath on the value otherwise.
No speed difference with any optimization whatsoever and if you marked it `register` there’d probably be little difference even without. I’d tend to say stick with the second version for the sake of DRY (or NRY, whatever fits there). That way, if you ever need to change it to `[y++]` or `[y+1]` or `*p` or something else, there’s only one site to change/debug.
`%[` necessarily matches a non-empty sequence. Sorry, that's life. You're going to have to do it a different way. I would recommend using a library like libcsv since it's done the hard parts for you. CSV is actually incredibly difficult to parse (much much more difficult than JSON, XML, etc.). It's a little bit deceiving because it was made to be simple and looks sort of simple, but the corner cases are a nightmare. If you know you're only going to be dealing with simple CSV files with no oddities in them (no quotation marks, no commas, etc.), then I would recommend using `strtok_r` instead of `fscanf`.
I actually ended up changing %[^,]%* to just %c for the empty commas and keeping %[^,]%* for the rest. I feel like it's a sloppy fix but all the data files have the empty commas in the same place so it works for this application. 
Incidentally, why do you say `%*c` instead of just `,`?
I think the auto-translate mangled this article a bit too much. 
 dup2 (logfile, pipefd[0]); This closes the read end of the pipe and associates the file logfile is attached to with that descriptor. So when the child process tries to write to that pipe, it'll fail with an EPIPE (And get a SIGPIPE delivered, which will probably cause it to exit -- don't remember if sh has a handler for that signal). If you want standard output to go to write to a log file, set up your file descriptors that way before execing. Or use a read/write loop in the parent. (If on linux, also look into the splice() syscall).
You’re duping the read side of the pipe, you want to do the write side. That being said I would think there’s a chance for data to be in the pipe after you switch it over to the file. I think you need to acquire a lock on the pipe and drain all the data, write it to the file, dup2 the handle and release the lock
Just do as the other poster said and put it in it's own header file. Name is something generic, like PROJECTMacros.h, boom, you only have to read that ugly code when you actually need to do something with it.
Please stop spamming this crap
'register' has almost no effect these days. I'm pretty sure that, at least GCC, ignores it entirely.
At `-O0`, a non-`register` variable will be spilled to memory with every write, whereas `register` variables are only spilled if there’s some good reason to do so. E.g., with for(i = 0; i &lt; 100; i++) printf("%u\n", i); for `register unsigned i`, GCC will stash `i` in RBX and leave it there across the `call` to `printf`; for just `unsigned i`, it’ll stash it at `-4(%rbp)`.
&gt; You can also set your editor to utf8 and encode your source files in utf8 as well to be able to write unicode characters into the source code itself without a need for string or character prefixes. I find that it's much more readable that way. printf("ハローワールド\n"); Of course. UTF-8, no BOM. 
C++ is off topic in this subreddit. Please don't post these.
SQLite supposedly has a stellar test suite, but the test suite is one of the bits they don't open source.
1\. I don’t think that’s possible. The way “number of digits” is calculated within the standard is such that a round-trip conversion (e.g., to decimal and back) would preserve the original value. E.g., the way C11 defines `FLT_DECIMAL_DIG` &amp;al. is &gt; number of decimal digits, *n*, such that any floating-point number with *p* radix *b* digits can be rounded to a floating-point number with *n* decimal digits and back again without change to the value, &gt; ⎧ p log₁₀ b, if b is a power of 10 &gt; ⎨ &gt; ⎩ ⎡1 + p log₁₀ b ⎤, otherwise The way formatting is done is a little wishy-washy because of alll the dazzling possibilities the standard leaves open, but &gt; For `e`, `E`, `f`, `F`, `g`, and `G` conversions, if the number of significant decimal digits is at most `DECIMAL_DIG`, then the result should be correctly rounded. If the number of significant decimal digits is more than `DECIMAL_DIG` but the source value is exactly representable with `DECIMAL_DIG` digits, then the result should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings *L* &lt; *U*, both having `DECIMAL_DIG` significant digits; the value of the resultant decimal string *D* should satisfy *L* ≤ *D* ≤ *U*, with the extra stipulation that the error should have a correct sign for the current rounding direction. So as long as you’re within the limits for `double` (or `long double`, with modifier `L`) you can keep on increasing the output precision and you’ll just get closer and closer to the represented value, zero-padding or no. After that, you’re only guaranteed something that will convert back to the same `double` value if rounding is mirrored. 3\. `char` can occupy more than a byte in the general case (e.g., there are some abominable ABIs where `char` occupies 64 bits), but yeah, aside from a possible off-by-one in non-two’s-complement representations, you’re going to have the same number of values representable by `unsigned char` as `signed char`. That off-by-one is a potential source of glitches, though—an 8-bit ones’-complement `signed char` might treat 255 as −0, for example, which is why it’s better to stick with the `unsigned char` treatment for `getchar`’s return value.
My C/POSIX knowledge is especially handy when it comes to understanding how stuff actually works. In general, you have to pay a lot more attention to detail when working in C, where in more modern/"easier" languages, you just assume things are going to work in obvious ways. In practice however, this is sometimes just a reflection of the underlying POSIX API, with all it's pitfalls and tricky bits that are a lot of the time caused by the language it's originally targeting - which is plain C. Just yesterday I helped out a colleague that had trouble with a multi-threaded application written in Python, giving him unpredictable behavior when it came to signals. I knew registering a new signal handler returns a function pointer to the old-one if one was present in the POSIX api, so I immediately suspected a race condition somewhere, probably a library setting a signal handler, and then something else overwriting it - or the other way around, and pointed him into that direction - which ended up being the source of the problem. Would he have been able to find that without my help? Sure, but it would have taken up a lot of time. Constructions like these aren't natural in more modern languages where it's expected to "just work". In Go for example, this is translated into channels, where the runtime implements a signal handler which just dispatches them to everyone who wants them. Now I like writing C code, but these days it's use is only for testing small stuff like the example in the article. For larger things, I quickly grab Go or Python, the amount of boilerplate code and setup is just insane when you want something larger compared to the mentioned options, which is not limited to code, it's also the build system.
Thanks for your answers! So what you are saying is that dup-ing the pipe to the file's fd isn't possible at all and a read-write-loop is the correct solution? I'm trying to keep this code free of any Linux specific syscalls as I need it on BSD too.
What about the [`test` folder](https://www.sqlite.org/cgi/src/dir?name=test) in the (online) repository? 
That's a separate, less comprehensive test suite AFAIK.
you mean like this? int logfile = open("/tmp/test.log", O_WRONLY|O_APPEND|O_CREAT, 0600); flock(pipefd[0], LOCK_EX); char buf[4096]; int n=read(pipefd[0], buf, 4096); write(logfile, buf, n); dup2 (logfile, pipefd[0]); /* &lt;-- TODO: this doesn't work */ flock(pipefd[0], LOCK_UN);
That's correct. A pipe is a pipe and can't be directly connected to a file.
Since it seems that someone else has addressed your problem, I'm going to address something else (more of a coding standard). typedef struct airPdata { char *x; } airPdata; should really be defined this way in my opinion: typedef struct airPdata_s { char *x; } airPdata_t; That way when we read your code, we know that `airPdata_t` is a `typedef struct`. It just helps in terms of readability I'm happy to see that there are `header guards`. Not sure if this is a personal preference as well, but maybe after the `#endif` you comment beside it like so `/* AIR_PDATA_H */` Also I'm sure there are more efficient ways to `"eat"` the information you don't need as opposed to having `char *uselessN` defined everywhere. In your main program file, I find `128` to be a `magic number`. From looking at it I can tell you're looping up until the `sizeof(line)`. 
Thanks for the tips!
`n((*x)+0.5*f)` You forgot a `*` here, after the `n`, so the C compiler thinks you're trying to call a function named `n`.
&gt; the test suite is one of the bits they don't open source. Huh, I've never heard this before, but I also can't find any evidence for it. Where are you seeing this?
See [this page](https://sqlite.org/testing.html#harnesses) and the description of [said testsuite](https://sqlite.org/th3.html)
i see it now, thanks man 
Got it. Thanks!
Yup, i had this before. Try turning off optimization 
Please use /r/cpp_questions for C++ questions. (but see http://en.cppreference.com/w/cpp/numeric/random/discrete_distribution for a sample of what you want to do)
This, check valgrind, use a linter, add -pedantic and -Wall to your compile flags. You're doing something wrong and the printf is just covering up the problem.
How would I have it so I don't need char *uselessN?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
&gt; For larger things, I quickly grab Go or Python, the amount of boilerplate code and setup is just insane when you want something larger compared to the mentioned options, which is not limited to code, it's also the build system. I don't seem to have nearly so much aversion to making a Makefile and doing a limited amount of boilerplate as some people, and I'm not sure why. I mean, if it's something really quick and dirty then I'm going to use `curl` from Bourne, not libcurl and sockets. And if it's something more complicated that does legitimately have a lot of boilerplate, then you're more than justified in grabbing some of your old code as a starting point, or someone else's code. I don't know if I don't work on things that are in the sweet spot for something like Python, if I never got into the idiom of Python and therefore don't miss it, or if my pique at Python runtime and dependency issues simply make it unattractive to me in general. (Go mostly doesn't have those issues and is more and more striking me as a better Python, which seems weird for a compiled and strongly typed language, but there you have it.) For the linked article, the C works perfectly on my freshly installed desktop, the Go is having a dependency problem on Debian that's going to be a pain to sort, and I'm afraid if I even tried to do it Python someone would tell me to use virtualenv and I would start grinding my teeth. 
wss:// is WebSockets, so probably [libwebsockets](https://libwebsockets.org/), but I see [three other C implementations listed here](https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations). 
**Comparison of WebSocket implementations** The WebSocket protocol is implemented in different web browsers, web servers, and run-time environments and libraries acting as clients or servers. The following is a table of different features of notable WebSocket implementations. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Of course it would be possible. It would work in the same way `%hd` works: The `double` argument is converted to `float` and then printed.
Well python runs on pretty much every modern OS, and is installed by default on almost every Linux distribution. I use it mostly when I feel a bash script is getting out of hand, since inevitably at a certain point you start to fight the shell itself. Escaping, value returning, ... all becomes a bit too much and it’s simpler to just use Python at that point. And while go has a ton of libraries and an impressive eco-system for it’s young age, python still has the upper hand here, and offers other advantages. Python’s dynamic nature for example allows you to quickly target something like a (hopefully old) SOAP api by just pointing it to the WSDL. There is no such quick and easy thing for Go. Go has other advantages - and is more an alternative to C from my pov. They complement each other nicely.
If floats would survive a round trip through double, then printing the double is the same as printing the float.. E.g. in decimal, printing 1.2345 is the same as printing 1.234500000 if you specify the number of decimal places or significant figures etc., the same principle holds in base 2 as base 10. 
Is there a vim plugin for c that can manage includes like with go? I realise things might be declared in multiple files or there could be conflicts but there must be a lot of straightforward cases as well.
Here play around with [this](https://gist.github.com/crucialmuzic/08f42f405e18c5e1ca6469d9d1765913). It's quick and dirty, but see if that's kind of what you're looking for. /u/KmNxd6aaY9m79OAg mentioned using `strtok_r` so this is what I found on [stackoverflow](https://stackoverflow.com/questions/12911299/read-csv-file-in-c). Hope that helps.
If you have to ask, you can't afford it.
I just finished authoring a client for the [facil.io](http://facil.io) micro-framework. No SSL/TLS (easily achievable using an SSL/TLS tunnel or a bit less easily achievable using the read/write hooks in the socket layer). I still have to complete the documentation on the website and the cookie parser (the query, body and JSON parsers are already in place), but the headers should have plenty of documentation. The client implementation is very fresh and it's part of the 0.6.0.beta pre-release, which is why the Wikipedia wasn't updated just yet.
Can you prove that?
Can you give a specific counterexample? I think such an example would be required to demonstrate the need to change the standard by adding %hf. 
If you have any locks before a fork, I'd expect both processes to have the same locks. Indeed, from the linux manpage for fork: &gt; The child does not inherit process-associated record locks from its parent (fcntl(2)). (On the other hand, it does inherit fcntl(2) open file description locks and flock(2) locks from its parent.) 
Thank you! That's what I've been looking for.
Are you using Hoare partition scheme? I am confused with your choice of pivot. Do you want to always choose songs[MAX_SONGS/2] as your pivot? strcpy(pivot, songs[MAX_SONGS/2]); 
If there is a function with like new, alloc or so that returns a pointer and has a corresponding free or destroy function, then I think it is clear that I would have to use that function to clean it up. Otherwise I'll just look at the documentation.
The first line in the csv file you've provided is different than all the other lines, so I'm really not sure which column is the `Tower` column. I took a guess, but you will have to play around with this [line](https://gist.github.com/crucialmuzic/08f42f405e18c5e1ca6469d9d1765913#file-air_data-c-L18) in order to skip the useless ones.
I think you should start with a simple case rather than strings. Change your program from two dimensional char array to one dimensional int array. That way, you don't need to care about your string manipulation and focus on algorith itself. See whether it works. If it doesn't, modify your post text and post the simple case here.
Generally, if you have a function that creates something with malloc(), you should provide another function that free's the result. myWeirdType *WeirdTypeCreate(.......); void WeirdTypeDestroy( myWeirdTYpe *); See? 
I don't know how many songs there are. I only know for sure that it has to be more than one and less than max_songs.
yes...the *Create* should provide the necessary hint
I remember asking a similar question when I was first learning C. There are a number of situations: - The memory allocated needs to persist longer than the routine it was allocated in [e.g. elements of a linked list are typically mallocd, since linked lists are often fairly globally scoped] - you don't know the size of the thing you need to allocate memory for - the thing you need to allocate memory for is large (the stack [where local variables live] has a more limited amount of memory than the heap (where malloc gets its memory). I'm sure there are more.
Right, the module that does the malloc()'ing ought to do the free()'ing, too. That also gives the module a chance to handle any more complicated cleanup that needs to be done. You might use an opaque data type to enforce this.
Trace its execution on paper.
Just take it slow, step by step. For the remainder, modulus is the name of the operator and is typed like %. so 10%3 =1, 9%3=0 etc
No, this resize (less), PSET-4. They say you can use malloc() if you want, and I suppose I can, just don't see any real reason to.
Correct, you don't need to. I passed the BMP image resize pset fine. I believe it's check50 that's grading you, not a human.
Well I've initialized the arrays so I know pretty much everything about them except what they contain, which is because that's up to the user to fill them.
Sooo, what is written is a odd way to declare a function, but it is declaring a function named `alloc_node` which takes in no input and return a `struct list_node*`. It's odd for 2 reasons: * functions are, by default, `extern`, so declaring a function `extern
`alloc_node` is a function that accepts no parameters (`void`) and returns `struct list_node*` (aka a pointer to a `struct list_node`). `extern` is a storage-class declaration specifier that just says that there is a variable (in this case a function) with this name outside of the (current) translation unit (aka when you compile a file). For functions, this already implicit, so in this case the `extern` isn't necessary.
Sooo, what is written is a odd way to declare a function, but it is declaring a function named `alloc_node` which takes in no input and return a `struct list_node*`. It's odd for 2 reasons: * functions are, by default, `extern`, so declaring a function `extern` won't have any effect, (so it's like declaring a local variable `auto`). `extern` is describing the linkage of the function, saying the function has external linkage (meaning, it can be used by other code when linked against it). This contrasts a `static` function which doesn't have external linkage. * using `void` in the parameter list is weird. In modern C, you would write this as `struct list_node *alloc_node();` Anyway, I guess the point is either this providers a function which constructs a `list_node` pointer for you, or it's asking you to implement such a function (you probably know more about what you have to do since you're looking at the assignment).
Ah I see. Thank you for the clarification. That clears up one problem. 
Thank you for you help. Yeah it's strange, I couldn't find alloc_node declared anywhere...but it works so it must be haha. 
I can think of three scenarios: 1. Convention. For example, "the allocator deallocates". This is for example the case with functions where you pass in e.g. a pointer to a struct and the function fills some stuff in. The same goes for hierarchical memory models where new allocations become children of a parent allocation. For example, libtalloc implements a tree allocator which makes such a convention easy to follow in your code. In this case, you'd pass the function a handle to a context and whatever the function allocates and doesn't free would automatically be freed if you free the parent context. A sign for conventions are consistent patterns in function signatures across functions of a kind, or pairings of functions (list_new, list_destroy, set_new, set_destroy, …). 2. Documentation. For example, when you read the man page for a libc function, it'll tell you if you need to free or not. From a function signature, you can't immediately tell what the function does with data you pass in and what it returns but need to rely on documentation or code to find out. Nor can you rely on functions even from the same group of functions to behave conistently (asctime, mktime,...). 3. Mixed. Common case. This happens when using different libraries or inconsistent code bases in a project. You have all kinds of conventions and sets of documentation and need to find a way to bring them under the same umbrella (your program, your job). As a side effect, you make up your own conventions and/or documentation.
&gt; is large in size From an embedded standpoint, what is considered large? Over 1024? 
good eye!
Yes I consider 1K to be large for stack. There is no fixed value that I use for reference. Changes from platform to platform. Most platforms I have worked on has had at least 2k of stack. So I would consider anything that takes over one fifth of stack as large variable. One thing you should note is that typically functions end up calling other functions which end up calling other functions and it is not uncommon to see 6 deep or 8 deep calls. So when you think about stack space you will have to consider the depth of calls and what those functions might be allocating. Recursion is also another problem area if you have a large variable on stack. 
For `1` you can also use static variables, those get place in the `.data` section. Unlike the stack there are no restrictions on its size afaik.
Yes. Static or global should do the trick too. 
[NASA C style guide](http://homepages.inf.ed.ac.uk/dts/pm/Papers/nasa-c-style.pdf)?
OpenBSD's style manual page is nice. https://man.openbsd.org/style
Just learn how Linked Lists work in general and then see how others implement them online swing as how people answered your question. 
not knowing the upper bound on the size of something is the biggie. if your program works fine without, don't use it. you should avoid using malloc without good reason - it complicates things and introduces room for bugs.
So, I compiled your code with `-Wall -Werror` to hopefully show you all of the errors associated. You should probably fix all of those, and set up your compiler to show those errors. [http://termbin.com/1rcs](http://termbin.com/1rcs)
Read Kernighan &amp; Plauger, *Elements of Programming Style.*
It’s a convention used in popular C programming books such as - particularly - in K&amp;R. JavaScript commonly uses this brace style and I’ve seen a number of C++ projects that do as well.
Thx! I fixed all of them but it still won't run :( This is the updated file https://ufile.io/vthz0
I feel like aligning the curly brackets vertically makes things stand out more. I do so in C, C++, C# and whatever language I use.
do you then also do this for, for, if, structs, etc too?
Wherever possible.
Sounds about right. One of my criteria is also how often the memory is allocated and deallocated. I deal a lot with packet-based communications so packets are always getting passed around in buffers, but I do not like dynamically allocating memory for them. There's too much potential for memory leaks and heap fragmentation, and I don't like non-deterministic allocation times. For things that happen all the time as part of the core function of the device, I prefer not to use dynamic memory allocation at all. At best, I may allocate a set of fixed-size buffers at startup based on the configuration. For example, flash write-back cache is something I can always throw more RAM at, so I can allocate buffers to fill up whatever is available - but I won't dynamically allocate them on the fly. I make much greater use of malloc() in interactive code and stuff that's not running all the time, like an update downloading task or a configuration editor. If interactive stuff fails, at least the user can see a message and do something about it. I can't have that happening to core functions in a device that might be installed on a mountaintop that's not accessible for months out of the year.
I agree. For my core functionality I avoid malloc too. Some modules my module interacts with don't even know how to handle failure. It is a pain to handle these error gracefully without degrading user experience so I try to avoid malloc when possible. There are some things my module does at boot up and shutdown and it is not executed during normal operation. Malloc works great for these functions. 
&gt;Malloc works great for these functions. Yes, and the straightforward use cases are a lot easier to analyze properly for correctness. Allocate at point A, deallocate at point B. If your allocated object has a complex life cycle, it gets to be a huge pain to prove it's handled right in every circumstance.
Es macht keine Sinne, Ihnen die Antworte einfach zu geben. Sie sollen dass, was Sie hier eingestellt haben, selbst lernen und verstehen. Wir koennen Ihnen hilfen, das zu erreichen. Aber muessen Sie uns es, womit Sie Problemen haben, erklaeren.
[NetSurf](http://www.netsurf-browser.org/developers/StyleGuide.pdf) has a great style guide with pictures and examples.
[LLVM Coding Standards](https://llvm.org/docs/CodingStandards.html#style-issues) is another one...
Hint: why do you need 2 nested loops to print one single bar?
This is okay. One for loop prints the columns, the other adjusts the row. The mistake is in line 54's if statement
It looked to me as if he wanted to print one single bar for the longest word or all bars up to the longest word (I could not decide). My hint above should direct the OP to find the mistake without pointing at it. As he wished. In your chosen case, it's still the inner loop that needs to be rewritten. It should probably use the appropriate boundaries instead of using if.
pointers are vital
Do it everywhere or else you're not legit like me. 
The formatting style you use for braces is personal preference really, as long as you can easily see where blocks of lines begin and end, especially when blocks are nested. I like this style, which is probably not common: while(...) do { ... } Make sense to me to put the `{` at the end of a line instead of on a new line, and line up the `}` with the indentation of the block it goes with.
This is how I write arduino code!
Python. 
I don't really like it either, that's kind of why I made this post. I go along with it because consistency is good, but I've always found it weird that almost every popular style guide (linux, bsd, nasa) all use this convention while simultaneously not treating things like for loops the same way
Your style is apparently [called "Ratliff"](https://en.wikipedia.org/wiki/Egyptian_brackets#Brace_placement_in_compound_statements). I'm more of a 1TBS man, myself
for a concrete example suppose you want to make a linked list... each node could contain a pointer to the data you want to add to the list and a pointer to the next list node (optionally the previous node too) you could allocate a chunk of memory to hold a number of nodes, every time you need a new node use that chunk of memory. Once they chunk is used you can then grab another chunk of memory.... (you could allocate each new node but that would be less efficient) the data you're adding to the list is also more than likely allocated too... 
Take care with type ranges. Signed char is [-128;127], unsigned char is [0;255]. As written, with unsigned char, it should be 127*sin() + 127, not minus.
Oh! I didn't realize I had the time of osc set as a char instead of an int. After compiling with the change, the issue remains. In terms of other bugs, gcc isn't revealing any issues with 'gcc main.c -lm'. Is there something I'm missing?
Always compile with warnings (`-Wall`) turned on. If you turn on optimizations (`-O2`), too, the warnings get even better.
After compiling with -Wall and -O2, the only warning I got was the possibility of time being used uninitialized. after changing the declaration of time in main() to 'int time = 0', I didn't get any warnings afterwards. What particular bugs are you seeing?
&gt; c++ and c# programmers don't do it Ahem, I'm a C++ programmer and I use this style. I find it much easier to scan visually.
We all know there is only one valid bracket alignment in c: if (foo) { while(bar) { if (baz). { return err; }} continue; }
the K&amp;R style ('{' on the same line) made sense 30 years ago when 25-line textmodes were a thing and you needed to be space-efficient. this habit survived to this day somehow
I have not yet looked at your program at all. My advice is of the general kind.
Please add some paragraphs to your post, it is really hard to read right now. To format code as code, indent it with four blanks. Read the [formatting guide](https://www.reddit.com/wiki/commenting) for details.
There is only one place where the opening brace gets its own line and that's with function definitions which look like this: extern char * strchr(const char *s, int c) { ... } And that's because in K&amp;R-style declarations, the function arguments are declared right before said brace, making this more consistent: extern char * strchr(s, c) const char *s; int c; { ... }
No, that would be mad.
&gt; for(i=0;i&lt;=(n+1);i++) Are you sure this limit is correct? It seems like you are overrunning the length of the array by two. Make sure you understand how arrays work in C. An array `a` of length `n` goes from `a[0]` to `a[n - 1]`, not `a[1]` to `a[n]`. &gt; int a[n][n],b[k][3][3]; Stack space is limited. Make sure to allocate large arrays with `malloc` so you don't run out of stack space.
I'm surprised it took this long for someone to give the actual historical reason.
and apparently no space between operators and after semicolons, *smh*
Yeah seriously, who does this guy think he is?!
Its simply visually better, its disgusting to read code where the curly brace is on the same line as the statement. Unreadable. 
that's not even an expression. It doesn't conform to C syntax at all. Also, why can't you do your homework yourself?
its a n expression and every space returns to a new line, though syntax is not in c btw. cant do coz cant understand....
Maybe try `-Wall -Wextra -pedantic`.
not for for loops no need, I do for assignments and if statements, but hey thats just me
An IDE is more than an edit box, a couple of buttons, and a menu xD
Makes it easier to read. I hate it when assholes will do something like this: for (i=0;i&lt;getsbuf[1];i++) { // &lt;--this is the shit that pisses me off. *buff = *sptr; buff++; sptr++; } 
Not to mention the awful code dir1='C:\\' # Windows only! file = open("testfile.c","w") # Hard-coded filename os.system("gcc %s"%("testfile.c")) # Potential venerability and very ugly, and can't see if compilation even failed os.system("abc.bat") # Actually executes the ouputted a.exe file... webbrowser.open(" some linkedin url that I just censored ") # Open the webbrowser.. webbrowser.open(" some other linkedin url that I just censored ") # TWICE!
This is very cool! I thought it was impossible to run C webassembly without an emscripten environment. This has a lot of potential for lightweight fast-loading (procedural?) games!
This hurts to even joke about
80 cpl should be enough for everyone... but this doesn't mean one has to do *this*!
I've actually thought many times that I should switch to this style: while(...) { ... } Then I would be more consistent with other languages I use, such as Ruby: while ... ... end I always line up the `end` with the line that begins the loop or if -- if would be dumb to do otherwise. So why don't I do the same in C? Just a habit I got into long ago and now it's very hard to break. So what is 1TBS style?
Thanks for all the suggestions!!
Can confirm, am Python dev. def abs(x): #{ if x &gt;= 0: #{ return x #} return -x #}
Can this be deleted? OP mentioned the question is not relevant to C--why's it here?
Good answers here.
Because I'm trying to print a vertical bar graph.
Trying to print a vertical bar graph.
Trying to print a vertical bar graph.
In this case, the one loop should run along the word lengths (vertical), the other along the chosen length up to this given length (horizontal). You don't need an extra if and you should not modify the calculated length to avoid confusion. Use one new loop variable for the inner loop that counts the pipe characters.
the problem is ,that i have a problem with pointers and lists... thats why i cant get a 100% answer of what will i get from printf functions!
Your program causes undefined behaviour by using an uninitialized variable `time`
I do a lot of C and C++ and I typically only do that where I have a statement signature that are longer than 80 characters. If the signature wraps around, then I give the { a new line. Otherwise I keep it on the same line.
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) 
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) 
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) 
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) When I try tosave it format is getting spoiled. uma1966
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) I am trying to encrypt plain text message to cipher text using caesar's method and python language. I will produce relevant results and part of my code My results ~/workspace/pset6/caesar/ $ python caesar80.py please typemessage hel lo wor ld hel lo wor ld 13 hel lo wor ld 13 ury ury yb ury yb jbe ~/workspace/pset6/caesar/ $ Part of the code from my caesar80.py file if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(ord) I am experiencing the problems using my code. 1. If there are no breaks in my plain text message, I obtain no output. for symbol in (message): if symbol.isupper(): symbol goes through the loop of all characters in my input plain text ,checks using if symbol.isupper(): and exits without encrypting at all. 2. If there are breaks like white spaces,other characters like, exist till the last break point,it encrypts correctly except for the characters after the last break. 3. The results are printed in several lines each line corresponding to the encrypted characters before each break point. While I understand the behavior of my code, at present I do not know how to fix these problems. If I can add an extra character at the end of my plain text message that might fix some of the problems,but it will not solve printing of my results in different lines depending upon the breaks in my plain text message. Since I am really struggling and stuck with these problems, I have reached a stage where I have to seek assistance either from other more capable students or Staff of the CS50 Course uma1966 
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) I am trying to encrypt plain text message to cipher text using caesar's method and python language. I will produce relevant results and part of my code My results ~/workspace/pset6/caesar/ $ python caesar80.py please typemessage hel lo wor ld hel lo wor ld 13 hel lo wor ld 13 ury ury yb ury yb jbe ~/workspace/pset6/caesar/ $ Part of the code from my caesar80.py file if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(ord) I am experiencing the problems using my code. 1. If there are no breaks in my plain text message, I obtain no output. for symbol in (message): if symbol.isupper(): symbol goes through the loop of all characters in my input plain text ,checks using if symbol.isupper(): and exits without encrypting at all. 2. If there are breaks like white spaces,other characters like, exist till the last break point,it encrypts correctly except for the characters after the last break. 3. The results are printed in several lines each line corresponding to the encrypted characters before each break point. While I understand the behavior of my code, at present I do not know how to fix these problems. If I can add an extra character at the end of my plain text message that might fix some of the problems,but it will not solve printing of my results in different lines depending upon the breaks in my plain text message. Since I am really struggling and stuck with these problems, I have reached a stage where I have to seek assistance either from other more capable students or Staff of the CS50 Course uma1966 
for symbol in (message): if symbol.isupper(): num = ord(symbol) num =(num-65+ key)%26+65 translated += chr(num) elif symbol.islower(): num =ord (symbol) num =(num-97+ key)%26+97 translated += chr(num) else: translated += symbol print (translated ) uma1966
My recommendation would be to conceptualize what is being done, rather than focus too much on the particular syntax of C. To this end, drawing pictures of what is being done helps greatly. Draw boxes for each variable, grouping boxes together if they're in the same structure, etc. Then, draw arrows from a box to another if the first contains the address of the second (i.e. - the first is a pointer to the second). Use this to progress through the program, one line at a time, creating new boxes when memory is allocated on the heap, drawing new arrows to reflect what your pointers are pointed towards, etc. You may need to go through the entire program like this, and that is fine. Once you understand what it is you are trying to achieve through using pointers and dynamic memory, the syntax will come naturally. (Do you feel more comfortable speaking in English or German? Granted, my German is a bit rusty, but my first impression from reading your program was that you may be a German / Austrian / Swiss student).
&gt; extern char * strchr(s, c) const char *s; int c; { ... } what the hell, I didn't know this was even possible
Apparently it's everything in braces even if 1 statement if (true) { foo(); } (that's not me), but the braces create and close the indent like you just posted... I do like to use one liners when applicable if (true) foo(); Maybe I'm closer to linux/bsd, but I don't new-line my function braces I keep them inline just like everything else (see samples in the line I posted above)
He does allocate arrays. Look up *variable length arrays,* a C99 extension.
Instead of posting your text again and again, please edit your post by clicking *edit.*
Yeah I got that. I haven't tested it myself, but it looks like the problem is with your if statement (well two problems now that I look back at it)
my best guess is the missing return at the end of main, but i can't find a way to make gcc complain about it (according to a stackoverflow q i've just closed, but you can easily find, it's only an issue pre-c99 and means that the value returned to the OS is undefined).
install visual studio if you are on windows or xcode if on mac it will help you narrow down the issue by using debugger 
God damn, you got me.
I use shm_open, ftruncate, and mmap and then cast the returned void* to my struct pointer, and then call init which mallocs one of the members. When I add a string I calloc that index of the malloced array
I saw this recently and had to chuckle: http://www.usrsb.in/How-Old-School-C-Programmers-Process-Arguments.html But these days, you probably want to use getopt() or getopt_long() - the latter more so on systems based around glibc. https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Option-Example.html
Water is wet. Undefined behaviour is undefined. I would consider OP lucky that it does segfault.
You need to store the temperatures in an array, if you want to write them all back out again. Also that looks awfully like a potentially-infinite `while` loop. If somebody gives you a bogus temperature, you can probably do --day; continue; after kvetching and be just fine. Or if you should trash everything, do `return 1` if it’s all in `main`.
You have to reserve room for the `struct` and everything it references inside the shared region. `malloc`/`calloc` allocate things in *your* address space, using pointers that make sense only there. Even if the other program can use the pointer values without crashing, they’re to nothing useful in its address space.
I tried every possible configuration of &lt;, &gt;, and = in line 54 and it still doesn't work. Could you test it?
I was just starting to think that I needed to do some math with the print statement, but unfortunately I have spoilers off so too late now. Here's what my output looks like. Height: 8 8 . 7 6 5 4 3 . 2 . 1 . I was under the impression that a bar graph had to have characters all the way down, which is more complicated and i think requires another else if. Not sure how exactly to do that though. And this isn't homework, I'm just teaching myself C via K&amp;C.
Thanks for the tip on M_PI, I didn't know about it before.
Still no warnings. 
Do you mind pointing out a few of the bugs you see?
No. Not the inner loop. It unnecessarily runs to MAX_LEN and you try to interrupt it inside the loop. It's not very hard to formulate the loop condition so that it counts up to the count, instead of MAX_LEN. You don't need this if inside then. Also don't use the calculated values as counters. Use them as upper bound for the inner loop.
Upvoted because I feel bad for you. Don't submit things like this to reddit unless you're ready for the criticism. People see "IDE" and they expect more than a small Python script. Not that what you have is bad for a simple Python script, but... reddit is not very nice about these kinds of things.
Did you post the whole code/assignment, or did you just paraphrase? I'd be interested in how this exercise is actually worded. Where does each pointee of result point to? The text of your assignment seems to guarantee that result points to a valid chunk of memory that can hold result_max strings (i.e. pointers to char), but it does not mention that each of them already points to valid memory. You're probably expected to dynamically allocate memory for each result[0] ... result[result_max - 1] so that each char pointer will point to valid memory. Something like result[totalIterations] = calloc(strlen(tree-&gt;data) + 1, sizeof(char)); // note: sizeof(char) is always 1 /* never use strcpy in real life */ strcpy(result[totalIterations++], tree-&gt;data); Take this with a grain of salt, but maybe this points you in the right direction (pun may or may not be intended.)
Pascal &amp; Ruby (and probably some others) use BEGIN and END instead.
&lt;code&gt; type func_name(type argument, type argument2) { &lt;/code&gt;
When you're creating something new and it's size is not a compile time constant
Absolutely not. Exercise examples are universally boring as shit, if they don't hold your attention, feel free to explore on your own. this isn't like in school where you had to force yourself to do every dumb little thing yo were told.
not german, but i study in germany (both languages are ok :P) and i find it hard to understand this sort of questions becausei have huge problem with lists , i honestly can't determine what comes first, or what should i do etc... if you know a program that can help also that will be great and thank you for the tips
Yup, a bunch of printfs depending on how fancy you want your CLI UI to be.
Your post got caught in our spam filter. I apologize for the inconvenience.
Your code link doesn't seem to work.
I believe you're wrong about C#, because afaik Visual Studio inserts a newline for { by default
don't ever use `os.system(...)` (or the C equivalent, `system(...)`) they're both insecure and platform specific. Instead, in C you can use [execve](http://man7.org/linux/man-pages/man2/execve.2.html) on linux and I'm not sure what can be used on Microsoft VC
Without going and using google to look it up, my recollection from when I used it was that the pointer points at the physical memory location and mmap maps it into your process memory addresses (virtual address) which is, of course, a different address (number).
You can think of `shm_open` as an abstraction that translates the given object name into a file name and opens that file. `mmap` is needed to actually map the file into your address space. This is a separate steps as there are a bunch of settings you might want to configure when mapping a piece of memory (such as the base address) and there is no need in duplicating all the options already present in `mmap`.
/u/dragon_wrangler's right, putchar is similar to printf. However, in the future please refrain from using variable names like `c`, `d`, `e` etc... Using `c` is ok when you're using it as a temporary variable to refer to a char, but for the others, I have no idea what the variable means unless I look at the rest of the code. **Always come up with a real variable name**
No, I mean “open the file” as in “call `open()` to get a file descriptor for the file.” If you are unfamiliar with this concept, it might be useful to understand the concept of a *file descriptor* and the functions `open()`, `close()`, `read()`, and `write()` first.
I don't think that's quite right.
So if I have a string array that has a dynamic max size that is set at run time and a max string size of 80, how could I accomplish this? If I had a set size of the array I could just reserve room for 800 chars if it was size 10, but the dynamic part is what's throwing me off. Basically I need the child to be able to write to it and the parents next children to be able to see it.
Not related to your problem, but: int main() { char taster[5]; while(toupper(taster[0]) != 'Q')//prvi karakter pretvara u veliko slovo `taster` is not initialised, so you don't know what may be inside. There could be anything, including a `'Q'`. -------------------- Same thing in `Start()` for `oblast`: you check its value although it is uninitialised. ------------------- function `UcitajPitanjaIzDatotekeProgramiranje()` while(fread(&amp;pitanje,sizeof(struct Pitanje),1,fp)) { strcpy(pitanja[i].pitanje, pitanje.pitanje);//string copy, kopira b u a ako je strcpy(a,b) strcpy(pitanja[i].odgovor_a, pitanje.odgovor_a); strcpy(pitanja[i].odgovor_b, pitanje.odgovor_b); strcpy(pitanja[i].odgovor_c, pitanje.odgovor_c); strcpy(pitanja[i].tacan_odgovor, pitanje.tacan_odgovor); i++; } If there are more than 10 structures in the file, you will overflow your `struct Pitanje pitanja[10]` capacity and overwrite whatever memory lays after (possibly the struct Pitanje shuffle[10], or anything else). You should control that you do not read more than 10 structures. while(n&lt;broj_pitanja){ int r = rand() % broj_pitanja; if(strcmp(pitanja[r].pitanje,"")){ strcpy(shuffle[n].pitanje,pitanja[r].pitanje); You don't know what is inside all the `pitanja` structures, they have not been initialised, and not all of them may have been filled afterwards. Thus, if there something different than `'\0'\ at `pitanja[r].pitanje[0]`, you will execute the `strcpy()` part even if you think the structure is 'empty'. 
If I mmap a regular a file vs a posix shared memory object, there is any difference? Why should I prefer using shm obj and not a regular file for working with a shared memory? 
The coolest one: https://www.gnu.org/prep/standards/html_node/Writing-C.html Haters gonna hate! GNU FTW! 
Well as I started to use it I realized that you rarely grab just one component. As the example shows above you have to write a lot of code to grab those components. Also when you are iterating over all your entities, you would need to grab all the components for each entity so you would be calling ecs_get_component() 3 - 5 times per entity and you may have 100+ entities. I feel like that is a lot of call overhead. I don't have any data to back it up.
what exactly is your question and what does it have to do with C? 
Here an example from [The Open Group](http://pubs.opengroup.org/onlinepubs/9699919799/functions/shm_open.html) &gt;Creating and Mapping a Shared Memory Object The following code segment demonstrates the use of shm_open() to create a shared memory object which is then sized using ftruncate() before being mapped into the process address space using mmap(): &gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; ... &gt; &gt; #define MAX_LEN 10000 struct region { /* Defines "structure" of shared memory */ int len; char buf[MAX_LEN]; }; struct region *rptr; int fd; /* Create shared memory object and set its size */ fd = shm_open("/myregion", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR); if (fd == -1) /* Handle error */; if (ftruncate(fd, sizeof(struct region)) == -1) /* Handle error */; /* Map shared memory object */ rptr = mmap(NULL, sizeof(struct region), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (rptr == MAP_FAILED) /* Handle error */; /* Now we can refer to mapped region using fields of rptr; for example, rptr-&gt;len */ ... 
This sub is for C, not C++. If you repost it somewhere more appropriate, fix your formatting first - four spaces in front of every line to format code for Reddit.
100 entities × 5 components × 100 fps = 50,000 calls/second. One CPU core can do about 100 million calls/second, so your interface will use 0.05% of a CPU core. But I would consider replacing or augmenting the interface with separate functions for each component. E.g., position = ecs_get_position(ecs, index); // and the other four That's simply less typing than your version.
(disclaimer: I don't know what an ECS is.) if the components are user-defined, then you could define those helpers in user code. static inline struct ecs_comp_position *ecs_get_position(struct whatever *ecs, size_t index) { return (struct esc_comp_position *)ecs_get_component(ecs, index, ECS_COMP_POSITION); } 
Yea, I think that is a good idea. I might make a function that takes pointers to all those structures that does the code. I listed in the original posts. That way it cleans up my loops.
You probably need to make your own little scrap-allocator for the shared region, something like static struct sharedRegionInfo { void *base; void *nextFree; void *end; void *nil; } sharedRegionInfo = {NULL, NULL, NULL}; void sharedRegionInfo_init(void *base, size_t size) { struct sharedRegionInfo *const p = &amp;sharedRegionInfo; assert(base &amp;&amp; size); p-&gt;base = p-&gt;nextFree = base; p-&gt;end = (char *)p-&gt;base + size; p-&gt;nil = NULL; } void *allocShared(size_t amt) { struct sharedRegionInfo *const p = &amp;sharedRegionInfo; void *ret; /* Forbid allocation of zero; return NULL. */ if(!amt) return NULL; /* Align the size to the size of a pointer. This isn’t necessarily a good * way to to a general-purpose allocator, but it should suffice here. */ if(amt % sizeof(void *)) { /* (Make sure we aren't overflowing `size_t` in doing this.) */ if(amt &gt; SIZE_MAX - (sizeof(void *) - 1)) return NULL; amt += sizeof(void *) - (amt % sizeof(void *)); } /* If `amt` is bigger than the remaining space, return NULL. */ if(amt &gt;= (char *)p-&gt;end - (char *)p-&gt;nextFree) return NULL; /* Set up the return and bump the next-free pointer upwards. */ ret = p-&gt;nextFree; p-&gt;nextFree = (char *)p-&gt;nextFree + amt; return ret; } #define sharedOffs(ptr)((size_t)((char *)(ptr) - (char *)sharedRegionInfo.base)) #define sharedPtr(offs)((void *)((size_t)(offs) + (char *)sharedRegionInfo.base)) When you map the shared region in, you set call the `init` function, which sets the pointers up. When you need memory in it, you call `allocShared` just like you would `malloc`. The first thing you allocate will probably be the struct, and then after that you can allocate and fill in strings. Make sure you use `size_t` for the in-shared string “pointer” type, and apply `sharedOffs` to any pointers you get into the shared region. On the other side, apply `sharedPtr` to convert the `size_t` to a real pointer. The only catch is that the shared segment has to be big enough in the first place, but your allocator could theoretically increase the size if there’s not enough space left. OTOH if you know the dynamic size before you set up the shm segment, you can take that × 80 and, as long as you’ve checked for overflow and all that good stuff, you should be fine doing the following: 1. Align `80` up to `sizeof(void *)` in the same fashion as the `allocShared` function. You shouldn’t need to check for overflow, of course. (Is 80 the maximum *length* or *size* of the string? If length, your max string size is really 81 because you need to account for the final NUL.) maxStringSize = 80; /* or 81 */ if(maxStringSize % sizeof(void *)) maxStringSize += sizeof(void *) - (maxStringSize % sizeof(void *)); 2. Check for overflow against `SIZE_MAX`, then multiply the result from (1.) by the dynamic array length. Overflow check for unsigned multiply: if(maxStringSize &gt; SIZE_MAX / arrayLength) theres_an_overflow; 3. Align the size of the base structure: baseSize = sizeof(struct whatever); if(baseSize % sizeof(void *)) baseSize += sizeof(void *) - (baseSize % sizeof(void *)); 4. Check for overflow on the upcoming add, then sum `baseSize` and `maxStringSize`: if(baseSize &gt; SIZE_MAX - maxStringSize) theres_an_overflow; totalSize = baseSize + maxStringSize; 5. If you’re not doing a flex-array structure, you’ll need to add in the maximum size of the array too: if(arrayLength &gt; SIZE_MAX / sizeof(char *) /*possibly - 1*/) theres_an_overflow; totalSize += (arrayLength /* possibly + 1 */) * sizeof(char *); If you need a `NULL` sentinel at the end of your `char *` arrays, you’ll need to apply the possiblies; if not, don’t. Depending on your base structure, you might need an additional `sizeof(size_t)` bytes to tell the child how big the segment needs to be, in which case your initializer and allocator ought to take care of filling those in and you’ll need to add it into your `totalSize` calculation. So once you’ve `shm_open`ed the segment, you `ftruncate` it to at least `totalSize`, you `mmap` or `shmat` it, and you call the above `init` function. After that you’re good to go. Just `assert` that the pointers you get from the allocator are non-`NULL`, because that would indicate something’s wrong.
You won't be able to `memset
&gt; error: variable-sized object may not be initialized double u_temp[m][m] = {0}; Tells you everything you need to know: you can't initialize variable length arrays. You can use `memset` though. Not really a good idea to use 2D VLAs in this case, they are placed on the stack and the space requirement is of course quadratic in `m`. You can use `calloc` like this: double (*u_temp)[m] = calloc(sizeof(double) * m, m); `u_temp` here is a [pointer to array of double](https://cdecl.org/?q=double+%28*u_temp%29%5B%5D), it works exactly like your `u_temp[m][m]`, except when it comes to `sizeof` because it's a pointer.
Here is my "clean" code that I use without my memcpy trick. I have tried it with optimization. It does not do much but my guess is because the code I'm using to clear it must accept dynamic sized arrays and will not be known at compile time. void ClearRoom(RoomBase * room) { int fullSize = room-&gt;width * screen-&gt;height; memset(screen-&gt;room.spaces, 0x00, fullSize * sizeof(uint32_t)); while (fullSize &gt;= 0) room-&gt;distance[fullSize--] = FLT_MAX; }
&gt; I ended up making a new array that was already set to FLT_MAX and using memcpy to reset the old one. Honestly, that's not a bad way to go, and without knowing more about your application it might be the absolute fastest option. If you don't mind using a GCC extension, this might be a possibility: float array[] = { [0 ... 255] = FLT_MAX }; [Under the hood](https://godbolt.org/g/WWHHsL) this does what you're doing manually: the compiler creates an array full of `FLT_MAX` and `memcpy` is used to initialize the array.
Iterating backwards through an array is usually a fairly bad idea. Also, use `size_t` instead of `int` for indices so the compiler does not need to account for `fullSize` being negative. Try the simple loop size_t i, fullSize = room-&gt;width * screen-&gt;height; for (i = 0; i &lt; fullSize; i++) room-&gt;distance[i] = FLT_MAX; This should yield decent code. Make sure to compile with a reasonably modern compiler and with optimizations turned on. If you could tell me what compiler you use, this would be even easier. I uploaded the code to [Godbolt](https://godbolt.org/g/KsqxHp) so you can fiddle around with it yourself.
Reminds me of this article Applying Linus Torvalds "good taste" to code - https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a
&gt; If I mmap a regular a file vs a posix shared memory object, there is any difference? As far as I know, there is no difference. &gt; Why should I prefer using shm obj and not a regular file for working with a shared memory? POSIX shared memory is an abstraction to make programming easier: You don't have to find a place to store your shared memory file and don't have to consider the properties of the file system you write that file to. For example, having a shared memory file on an NFS share might cause some interesting performance issues. With POSIX shared memory, you can assume that the system does the right thing. It's just easier to use.
Thanks for your reply, I followed a stack overflow link using memset and that worked but might change it to this method if it would be faster computationally? However Im running into another error now error: subscripted value is neither array nor pointer nor vector getting this most times an array is mentioned, I did some research and think it has to do with needing to make my arrays pointers instead? For example in this code float central_diff(float u,int i,int j,int direction) { if (direction == 0) { if (j &gt;= sizeof(u[i]) - 1) return (-1 - u[i][j-1]) / 2; else { if (j &lt;= 0) return (u[i][j+1] + 1) / 2; else return (u[i][j+1] - u[i][j-1]) / 2; } } if (direction == 1) { if (i &gt;= sizeof(u) - 1) return (-1 - u[i-1][j]) / 2; else { if (i &lt;= 0) return (u[i+1][j] + 1) / 2; else return (u[i+1][j] - u[i-1][j]) / 2; } } return 0 } I get the error specifically about u. My knowledge of pointers is a bit rusty. If you can't answer that's totally okay, thanks for your help!
`float u`, `u` is just a float. You can't use it like an array.
&gt; I'm using Visual C++ 2017. I'm doing it in 32bit. Ah yes, that might slow down things. Visual C++ is a shit compiler and 32 bit code is generally slower than 64 bit code. Try enabling SSE in the compiler settings, this might make the program a bit faster still.
Hehe, I never hear good things about Visual C++. Do you have recommendations for other things on Windows. I have kinda just been sticking with the easy default because I'm lame.
I would use clang or (if you can get it), the Intel C compiler. I strongly advise you to create a 64 bit program, too. Or at least enable SSE in the compiler options so the compiler won't be forced to use the outdated x87 FPU.
There are differences in how changes to memory are dealt with, for starters. In C if the memory region is marked `volatile` or you otherwise cause the compiler to spill everything (e.g.,`__asm__ __volatile__("" ::: "memory")`), then all you have to do is assign to the memory like any other address (`*p = foo`) and everything else with that shm mapping will see it shortly thereafter just by reading from it (`bar = *p`), pretty much as soon as the store hits whatever level of cache or physical memory things are actually being shared on ⊗ it reads from the appropriate region of memory. For an `mmap`ped file, anything that happens to be mapping that file on the same host *may* see changes in the same fashion as shared memory, but there’s Officially no guarantee changes will be seen elsewhere unless `munmap` or `msync` is called. (E.g., if you’re mapping and modifying an NFS file, your pages might not be flushed across the network unless you tell the kernel to do so.) I don’t think the same holds of reading from a mapping (you should see changes the kernel knows about), though I’m not sure about the networked side of things. Things like atomic instructions and (AFAIK; when supported by impl, via `pthread_set*attr_pshared`) Pthreads synchro primitives are only guaranteed to work over actually-shared memory, not mapped memory more generally. This makes shm or shared anonymous memory a better option for use as a low-latency communications channel between processes, vs. mmapped files which are nasty trickses that get the OS to do your buffering for you so you can treat a file like an in-memory array. If you’re using `mmap` to write out stuff you want to be retained (e.g., for `mmap`ping in and using later), then what you write won’t be killed at powerdown/reboot (unless in /tmp or similar). Files are also less potentially-limited in number; shm devices (see /dev/shm) are created as a consequence of `shm_open`ing with `O_CREAT`, so depending on the platform there may be a small, finite number of mappings available for everybody on the system. Finally, there is some additional difficulty imposed by shm in terms of ensuring the name matches up for everybody, but doesn’t collide with other unrelated processes’ names. If you want to support multiple independent process groups, you need to come up with a way to distinguish and compose your shm names. For files this tends to be a bit easier—you can make a temporary directory and `open`+`mmap` to your heart’s content, and you don’t have to worry as much about colliding with other processes’ names. It’s also easier to coordinate group behavior over the filesystem because you can use directories (e.g., ~/.foo/pid or /var/run/foo.pid in simple cases).
Open with `O_WRONLY` or `O_RDWR`; map with at least `PROT_WRITE`; set `addr[i]` just like you would any array. `msync` if you’re paranoid about flushing, though `munmap` flushes too.
Same author from an earlier date, yet he seems to have forgotten about the Torvalds example which is way easier to read.
Thanks again for your help! I changed the float u to both double *u and double u, no success on either. 
Ha! Did not notice that. Too funny.
Another "good taste" explanation - https://grisha.org/blog/2013/04/02/linus-on-understanding-pointers/
Actually, it looks like the compiler is smarter than we think\*. The compiler optimized it into a four instruction inner loop: LBB0_2: movq %rdi, %rax movq (%rax), %rdi testq %rdi, %rdi jne LBB0_2 \* Apple clang-900.0.39.2, flags -O3.
What's the problem?
 (*tree).data You know about `-&gt;`, right? Makes accessing members of pointers to a struct a lot cleaner looking.
/dev/shm is persistent? After a reboot or process killing?
Are the char arrays of your tree nodes initialised and zero terminated?
You can do that with `_Generic`. But may I ask, *what* you are trying to do?
Yep, I've heard Clang is now even shipped with the new VS versions. I wonder how MinGW would do for Windows in comparison.
Really liked the article. I'll doubt it has any effect on the performance because of the current fast hardware and smart compilers. Also creating more readable code is also worth something :)
&gt; and what else do you need for this basic program? 
I see you've already gotten help with this issue, next time check out clang's address sanitizer or valgrind. They rub your programming problems in your face 😅
in a c sub...
that is certainly the least of the issues
&gt; how the linux OS know my filesystem? If it's implemented as a kernel module, the filesystem is registered on module load. If it's implemented in userspace using FUSE, it has the FUSE kernel module as a middleman. &gt; Are these unmounted ones recorded in some place in the OS? Filesystems known to the kernel: cat /proc/filesystems Predefined mount points: less /etc/fstab 
https://en.wikipedia.org/wiki/Filesystem_in_Userspace
If you want to use C++, then you have arrived at the wrong subreddit. Please post C++ questions to /r/cpp_questions as this subreddit is about C only.
I want to be able to start with C because I actually know that but thank you I'll go there then
I'm aware the main focus of this question was finding a way to use my voice to text program to program at all
Oh yeah it's totally fine to reuse them. Encouraged even, it saves a little bit of memory on the stack, because you're reusing memory. And of course it's more readable.
Not across reboot, should be (from the shm object being persistent) across process killing.
You want the guys over at /r/cpp for C++ questions. This sub is for C.
Try using a debugger to find out the problem. Here is the problem: ^(^([How i got there](https://pastebin.com/raw/JYy36vjs)^) choice = '\n' Aka from the `print_menu` function, you read a new-line-character (`\n`). Because it isn't a valid action and it isn't `Q` (which exits the loop), the while-loop just repeats (to ask you again) and you hit `print_menu` again, printing the manu again, but now waiting for "actual" input. By default, `scanf` [skips white-space characters first, *except* when there are certain specifiers](http://port70.net/~nsz/c/c99/n1256.html#7.19.6.2p8), including `%c`. You can fix this by adding a space before the `%s` in `scanf`, so [white-spaces are properly skipped](http://port70.net/~nsz/c/c99/n1256.html#7.19.6.2p5).
I did a few test and the coordinate changes in the right way... the programm just doesn’t read the if else function
Show your code.
Without seeing your code, it is difficult to say what exactly went wrong.
I don’t know how to post it... a pic ?
So the convenient part about this is that there is only one place in the code that prints the menu. If we look at the places where print_menu is called, we can see that the only way for it to be called repeatedly with nothing else printing in between is for an invalid character is entered. Inserting the following line before the return statement in print_menu: ```printf("Character entered: %d\n", option);``` shows us that when we enter B (not implemented in the switch statement, making it easier to see what's going on) 66 ('B') is the first character. After the switch statement is completed (in the case of B, instantly, in the case of something like D, after the operations inside the case are executed) a second character is received, 10 ('\n'). Scanf reads from the stdin buffer and doesn't clear information from the buffer after is gets what it's looking for. There are a lot of ways to deal with this, but a simple and intuitive one is to enclose scanf in a loop: do{ scanf("%c",%option); }while(option == '\n') 
Under no circumstances post a pic. You can edit your post to add your code. Make sure to indent every line by four spaces so it gets formatted correctly. You can also use a paste service to upload your code and then add a link to the code to your question.
Copy paste it. Format it using three ` (backtick) in a row. Like this ``` #include &lt;stdio.h&gt; function main(int argc, char* argv[]) { printf("Hello world!"); } ```
D:\Documents lmaoooo
I think by mistake you substituted `%c` with `%s`, because with `%s` if the input is multiple characters for some reason, it is going to lead to stack smashing if he tries to store the input in a single char. Other than that, even with `%c`, multicharacter input is still going to lead to a similar behavior. A more compatible but still problematic solution would be something like this. char option, input[50]; scanf(" %s", input); option = input[0]; 
&gt; I think by mistake you substituted `%c` with `%s` Oops, good catch. It is indeed a mistake, just fixed it.
Better yet, use a pastebin or a gist.
Are you using threads? 
Did you try changing `void arrayProduct(double v[500][500], double u[500][500], mwSize n)` to `void arrayProduct(double *v, double *u, mwSize n)`? You're trying to pass pointers into a function that's declared with array notation, so it expects an array. In my opinion, using pointer notation in the function signature is more appropriate anyways since the array notation can be misleading. You might think you can use `sizeof(v)` inside the function, but you can't.
just copy paste your code, if you can't do that, might as well give up
When you do a division between integers, you have the result and the remainder. Like 14/5 is 2 with a remainder of 4, because 5*2 is 10 and you need 4 more to get to 14. Or in other terms, subtract 5 as many times as you can before getting lower than 0. 14 -5 is 9, -5 is 4 Please write the equation using newlines, it's kinda hard to read in one line only
I did but im on mobile and kt kinda acrewes up hang on
Fixed
J%K is basically J-K in this particular case. The result is correct. Remember that a division between integers in C will give the floor integer (Example 10.7 is 10)
How comes?
I messed up and did the *5 last right before the / 2
Hm. I think you'd have to rewrite `arrayProduct()` to use pointer math instead of subscripting. If you just want to get it working as quickly as possible, you could go back to array notation in the function signature and use an ugly cast to call it like so: `arrayProduct(((double (*)[500])v, ((double (*)[500])u, ncols);` You'd typically want to avoid a casts, but if you don't want to rewrite `arrayProduct()` to use pointer math instead of subscripting, I'm not sure you have many options.
Unless it's a pic of your K&amp;R copy... ez karma
Well to be fair while that specific book hasn't been updated for a long time the C standard itself was updated in 2011 so it's not exactly an abandoned language. I think he's trying to exaggerate its unfashionable nature but [TIOBE ](https://www.tiobe.com/tiobe-index/) still considers it the second most popular language in the world.
If you ever forget and are on a *nix machine, ```man operator``` is your friend.
I have no idea what any of this means I just started yesterday
Thanks ill look into when I learn a bit more
I miss-interpreted that haha thanks
```man``` is the command line tool for "manual." Most *nix commands are more thoroughly documented there (much more than you get with the ```--help``` option, or whatever. There are also entries for other things, like this. It's the C operator precedence page and tells you which operators are evaluated first, and in what order.
I havnt done any coding yet I don't even know what software to use I presume Visual Studio right now im just learning terms 
Alright thanks I eventually want to move onto C++ as well 
Try hiring C developers. I am right now and it's very difficult. We get people who know C# or some C++, and have maintained some C code. But to find people who can write new C code, yeah, difficult.
Forsaking C is the fastest way to end up with really REALLY unsecure operaring systems... There is a reason why inferno, linux, minix, bsd and other systems were written in C. It is an wonderful language, and direct memory access is a strength, not a downfall, as I hear a lot of new programmers say. It just requires that you understand computer architecture, whixh is also never a bad thing. It remembers me as well that time people asked the creator of curl why he still maintain the tool in plainc C instead of moving it for Cpp, and the reply he gave.
Oh I'm not saying you are wrong. All I'm saying is, in response to OP, that yes C is very, very unpopular. Perhaps not among the Linux Kernel Devs, but in commercial software development, it's really hard to find anyone qualified, much less wanting to do it.
So should I redo my data structures class in C? Is this a good way to learn C? 
[removed]
reason 1 is definitely not true. maybe in the embedded industry
TIL. I would always type in the literal operator, it never occurred to me to just type in the word operator.
Looking for C jobs is just as hard. I got lucky with my last 2 it seems
Learning C before C++ is much easier than the other way around, you'll deffo be able to do that.
Did you know the latest version of C came out in 2011?
Hey man, I get the opposite, hiring managers that think C = C#, or C++ tho that's a lot more forgivable.
Except it's not. OO wastes a shit ton of memory, but what does it actually provide? Not really a whole lot.
Maybe one or two of the non-trivial structures, but go deeper with them. Try using them on a really large data set so you can see the strengths and limitations of C. Record results and find every way you can squeeze improved performance. Then try making it generic (say, abstract binary search tree), add in multiple implementations (say, AVL or random), and enjoy the headaches that come from self-managing C's type system.
The firmware / embedded software industry is struggling to meet hiring demands. No one is learning C anymore or just doesn’t want to work in it. Most of our work is still in C. I was talking to an old company of mine that was trying to fill some spots and they said everyone just wants to do apps now. 
It's more like, yeah know your data structures and all, but be able to write a C function on the spot that does some data manipulation in memory. Be able and willing to read through a LOT of existing code and fix/extend it; that part usually breaks people because it's sort of shit work and difficult to do, requires you to document what you find and map a system, then be able to know where and how to fix/extend. Pointer jungles abound, along with bad practices of the 90s and near-zero documentation. It takes a lot out of you.
Yeap, that'll be my retirement work I feel. I'm in my mid 40's now and good at what I do. I think they'll still be looking in 10-15 years. We have some folks working on COBOL still (financial industry) and there's no shortage of work for them yet!
I love embedded systems. I find C a lot of fun to work in and it's not just maintaining legacy systems like COBOL/FORTRAN are these days. You're still developing new, really cool things. C and to some extent C++ are going to remain the dominant languages for smaller microcontrollers for quote some time.
I think you linked the wrong program. I skimmed at your program and saw that you have two exact modes for two "different" cases based on a lowercase/uppercase letter. Having said that one thing you can do in C is: `case 1:` `case 2:` code_goes_here break; And when `case 1` and `case 2` occur, it'll fall within the same `case` block. For your case (no pun intended) though, you can just read in the character and either make it always lowercase or uppercase and handle it the same way. So if a user enters in `'A'` or `'a'`, for example, it'll be handled the same way since you'll either make it always lowercase or uppercase. I'm going to bed now, but I'll try and see if I can help you after work tomorrow with what you really need.
Try r/cpp_questions and be a lot more specific next time 
Nicely written, but you aren't answering the question in the title - what would be the cost of forsaking C? Also, the facts about the C state of progress are quite misleading. The K&amp;R book wasn't updated, but the language is updated periodically by a standards committee. Updates include the C99 (practically implemented everywhere and C11 (which has optional features that aren't always implemented, making things a bit of a headache at times). We're also expecting a C21 or C2x... though C loves stability and minimalism (unlike the constantly changing and expanding C++ mutant), so I'm not sure how many changes I would want to see there.
This reply is actually accurate. I am working on web apps at my day job and can program in C (Strangely half of my coworkers are old C developers from Sun). The issue that I have encountered over multiple jobs is that only a minority of the workforce knows OOP. The people that know it, know it poorly. As a result, what they code with OOP absolutely does not provide any benefits and does waste a shit ton of memory. If you have a team of people that know OOP, it does in fact provide a lot of benefits. The problem is that people that know OOP well are the exception, not the rule.
I got my current job because I know C well and my company was desperately looking for low level firmware C devs and not a lot of students finish their studies knowing how to C.
I’ve been programming in C over 6+ years professionally. I work in the Telecom and Embedded area. I prefer C over C++.
That's what I experience too from a Uni perspective, most people simply don't wanna do C and go into the details of OS and/or CPU. Finding TAs there is difficult. But those who go there are basically guaranteed a job. Of course, a big influx is people who want to be game devs or app devs and soon quit because they are totally not able to study computer *science*. And those people already "know how to program", mostly C++ or C# fanboys. But if you look at what they produce, you see that they only can type things that compile, not design a program.
The 80s where a different time though, both languages have developed and while C has improved much with C99, C++ has just become a feature whore that's umaintainable.
afaik the next version will basically just be a bugfix.
C is lovely and will stay there, at least for glue between other code -- but for now also the main code will be in C. There's Rust which I hope will eventually take over (especially in the sense "if someone takes over, not a weird other language"), mostly in security stuff first. But it still has some issues that need to be ironed out. Go is also a nice candidate, especially for really fast, almost script-like development but I never got around doing more. But that's it. C++ ain't no better, especially when it comes to security. I hope it dies fast.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
&gt; There is a reason why inferno, linux, minix, bsd and other systems were written in C. And that reason is "because UNIX was". Pretended it's about any other reason is a bit misleading. &gt;It just requires that you understand computer architecture, whixh is also never a bad thing. It can end up being a bad thing as it might mislead you into thinking that C actually models this computer architecture you've learnt about, when infact C models it's own abstract machine based on a hellish combination of "what was available in the 1970s" and "undefined behaviour that compiler vendors have managed to shoehorn into the spec so they can exploit and optimise it to beat benchmarks". e.g. on an x86 -- and this has been true since the 1970s release of the 8086 -- you can do some arithmetic and then say "hey, did that operation overflow?" with extreme ease. If you try and do that in C you're invoking undefined behaviour and the compiler will just eat your entire arithmetic operation and replace it with something it prefers, so instead you have to follow a bunch of [bloaty steps](https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow). So understand computer architecture can HURT when you write C. The only "safe" thing to do is to learn C's computer architecture. 
&gt; Try hiring C developers. I am right now and it's very difficult. On the flip side, I've always found it hard to be hired as a C developer, there are very few jobs going for it. Where are you based? I would ask for a link to apply but I doubt you want to associate your reddit username with your workplace ;)
I made a quick little benchmark with different techniques of making an float array fully `FLT_MAX`, you should always benchmark when trying to improve performance, else you might end up making the code slower, not faster. I suspected that using another array of only `FLT_MAX` and using `memcpy` would be slower, because you just end up unnecessarily loading the same value from memory for each float, if the values are more complicated, (not all the same) I'd give it a chance of being faster, depending on how complicated the calculations would be. [Here's my benchmarking code](http://coliru.stacked-crooked.com/a/3e69aefa0b134379), it's in C++ because I wanted to benchmark it's [&lt;algorithm&gt;](http://en.cppreference.com/w/cpp/header/algorithm) header, and [&lt;chrono&gt;](http://en.cppreference.com/w/cpp/header/chrono) makes it easy to measure time, I see no reason why these measurements wouldn't translate back to C. On my PC I see this: [Copy from another array using a for loop] took 127.037ms [Copy from another array using memcpy] took 163.373ms [Copy from another array using std::copy] took 163.482ms [Assigning using a for loop] took 88.5609ms [Assigning using std::fill] took 66.2871ms Seeing these results, I suggest using a for loop in C and using `std::fill` in C++, but you should try running this code on your own machine, you might get different results. ^(Note: I've only tested the code on Linux with Clang and GCC, I'm fairly certain it wouldn't work on Visual Studio, sorry if that's a problem :/)
&gt; I eventually want to move onto C++ I won't hold that against you ;-)
&gt;And that reason is "because UNIX was" and "because that's what was available to programmers in the early 90s who were writing UNIX clones". Pretended it's about any other reason is a bit misleading. No, it wasn't. Most operating systems prior to unix were actually not written in C, but in Assembly. Unix itself were re-written to C (it was originally made in Assembly for the PDP-10). There were actually several other languages, some, even with abstractions (though not as much as C), like B, BCPL, etc. &gt;It can end up being a bad thing as it might mislead you into thinking that C actually models this computer architecture you've learnt about, when infact C models it's own abstract machine based on a hellish combination of "what was available in the 1970s" and "undefined behaviour that compiler vendors have managed to shoehorn into the spec so they can exploit and optimise it to beat benchmarks". Ok, ok, I'll give you that... In fact, there are differences in both. I spoke more in a newbie perspective when learning to program in C. Python, Pascal, Lua and other languages that don't allow you to work with memory directly make the student learn programming but not the basics of architecture. I have been meeting new programmers that entered the market recently that don't know how a memory works, or a black box, or that are capable of doing boolian math operations, even the basic one's. At that level, learning and using C for some projects actually forces you to understand how to deal with positioning since the beginning. This is one of the reasons I don't recommend the CS50 course to some people. the CS50 C library they used on their course make things too easy for people getting programming from scratch. &gt; I wouldntt say that. I would say that they must be learned side-by-side. C programming in one class, and generic computer architecture in another. This way the student can understand how "von neumann architecture" works and how C understand this same architecture. PS: Forgive-me if I had some problem communicating. Eng isn't my native language. PSII: Also, put a "BIG ASS" IMHO before everything I say, as I always talk from my own basic knowledge. I have actually left C behind some time ago and migrated to Lua, Micro python and TinyPy for embedded development (which is also where I started seeing people using those languages to program hardware without understanding basic concepts in hardware architecture that could have helped them greatly). 
the fact the language is stable and doesn't keep having new fads to it is a major positive ! 
This may be the pedagogical disaster that Joel Spolsky wrote about in his article [Back to Basics](https://www.joelonsoftware.com/2001/12/11/back-to-basics/)
He is talking about "the authors".
http://pages.cs.wisc.edu/~remzi/OSTEP/ is a free online book on modern OSes with coding examples/exercises in C if that interests you.
 while (k!=0) { printf("\nEnter the bingo call you would like to have checked,0 to exit: "); scanf("%d", &amp; k); if (k != 0) { If you input `0` at this place, `k` is `0` and thus the `if` and the `while` isn't executed. (Probably a cleaner way to do is to do `if (k == 0) break;`, where `break` exits the loop). However, as you might notice, you never set `k` again, so the next time you choose `2` on the main menu, it checks the loop condition (`k!=0`), and since `k` is still `0`, it is skipped. The easiest fix would be putting something like `k = 1` just before the loop.
IMHO, Rust and Go aren't a wonderful C alternative. Both Rust and Go are heavily typed OOP languages with a big STL. Although designed for systems programming, I find them both uncomfortable and bulky. They don't feel to me as bloated as C++, but they also aren't as light as C. As much as I love OOP and enjoy the comforts of an STL, I can't help feeling that C is superior to both Rust and Go by leaving these features out. I know it's a matter of style, but I like the idea that all types are just memory blocks (and that they can be treated that way). I also enjoy the functional interface. C offers me amazing separation of concerns by helping me create little black boxes that are far more isolated than anything OOP can offer. The fact that I can roll my own OOP with a "price tag" that matches my use case is a comfort. Sure, C is not for everything and it can be harder or slower to code in. I love Ruby and other languages that offer me ease of development and take a load of my shoulders by offering me a huge STL... but when I need something robust and secure, I always return to C. Anyway, my 2¢.
C is my strong preference and my main language,yet I am so tired of working with bad code I am considering even switching to web dev! 
They're both not really OOP, the "structs can have member functions" is just syntastic sugar, the system behind is just structs that also just have this exact memory layout and they're just kept track of by the compiler to augment them with functions. There's no virtual function table, no inheritance, etc. And both don't have a standard template library (STL) ... . Go lacks generics completely and Rust doesn't have templates but again uses type parameters just as syntastic sugar, it's a trait-based type system behind. You can treat everything as a memory layout and in rust can even say that it should resemble the C memory layout. Also at least Rust can be used perfectly fine without a standard library, I've written a small kernel in it and it honestly was fun and really elegant. Because, as you say, everything was just memory. I had MMIO, so I made a struct that resembled the registers that were mapped at a certain address, and then I could access it simply as struct members -- just like in C. But, just additionally, we had small wrappers around it like `RO&lt;u32&gt;`, `WO&lt;u32&gt;` or `RW&lt;u32&gt;` that assured by compile time that we didn't read or write a register that we weren't allowed to. This was compile-time checked so no run-time overhead.
Firstly, your pointer `data_bytes` (meaningless name) is uninitialised so you're writing over anything and returning garbage. Secondly, what do you want this `byte_arr` (another meaningless name) for? If you allocate some memory for `data_bytes` then this already contains the byte-swapped data if you start using the `cnt` variable when writing to it.
Which is retarded because C has been designed by commitee since the original book.
&gt; It remembers me reminds
Without being able to judge the quality, I think that might be exactly what I am looking for! Thanks a ton!
&gt; Be able and willing to read through a LOT of existing code and fix/extend it That is my pastime...I read a lot of o SLOC of projects I use as curl, git, emacs...
Is it easier to formally verify Rusty than C? Sorry, I'm not a big formal methods guy, I do computer architecture, but I invite formal is often a big deal in securing bit loaders and hypervisors
Yes, I'd definitely say so, because it imposes many restrictions, if you want to go farther you need to explicitly state that. The Rust compiler can even guarantee you that there'll be no null dereferences, or other unwanted stuff -- if you don't use `unsafe`. Of course this doesn't cover everything but the language features provide a nice starting point for formal verification. Formally verifying C code is really tedious in comparison.
the intention was to be able to index into the array to pick out specific double words
&gt; elegant C code is elegant too: https://github.com/emacs-mirror/emacs/blob/298275c595f6ca9e77f8131d34dda2b58fe1faa5/admin/alloc-colors.c#L80
I'm very sorry, but this subreddit is about C, not C++. Ask C++ questions in /r/cpp_questions.
Well this all gets me excited, since I'm a sophomore and C is my favorite language 
You need an array of integers. int *byteSwappedOutput = malloc ( XXX * sizeof(int)); Then memcpy from data-&gt;d_buf to byteSwappedOutput Then, for each integer in the array, correct its order. Then you can print them, and return the array (for the caller to free when it is done with it)
I loved Rust "package", looking for it. Maybe in 2020, I will learn it! Go seems a better alternative for C for now! 
&gt; Not my native language... Learned from tech manuals and movies Same here.
You English is better than mine than :D I try my best, and thanks for correcting me. Trully.
Non-Mobile link: https://en.wikipedia.org/wiki/System_programming_language *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^148811
Whoa, Your source actually presented some conflicts with my sources! I remember seeing an interview (sorry, I would need to dig up it again from youtube to give you the sauce, but the B language on Wikipedia ENG also mention's it as being the language of the first versions of Unix for the PDP 7 and PDP 11) with Brian Kernighan and David Brailsford discussing Unix and C and how they started developing Unix on BCPL/B (being B just a stripped down version of BCPL) and at some point, evolving the OS was impossible, and they felt the need to develop it's own language (C) to implement what they wanted (including piping). Anyway, specifically regarding direct memory manipulation, the ability to treat memory directly sometimes help avoid collateral effects in functions (if well used), because languages without direct access will generate undesired effects that are hard to track after hundreds or so lines of code. Actually, the functional programming paradigm was developed originally rules to avoid just that, side effects in functions caused by "dirty functions". Unfortunately, FP was way ahead of it's time and implementing it correctly on a machine with 64 or 128k of memory is a nightmare. Today we have finally the chance to drop this horrible thing called POO and head to FP hahaha. Direct memory manipulation is a two sides blade, can make things very very bad really really fast, but the power to do some amazing things are severely increased with it, in the case pointed early on this message, in large procedural source codes, the amount of locally created variables inside functions can be easily avoided by manipulating the data on it's memory location all together. Anyway, as always, IMHO.
Also, If I'm not mistaken, BS2000 came before UNIX V6 (the first one that was entirely rewritten in C) and he was also made using the C language.
Sorry, I kind of lost track of the relevance of this link, care to elaborate /u/NotInUse? Again, sory.
Should be `uint32_t` or something along those lines—without picking a specific target ABI, there’s no telling what `int`’s size or alignment will be.
Operating systems were written in many languages other than C or assembly. The link lists a few alternatives that have been used throughout the years.
Oh, ok. I know about that. I also know that most of the ones written in anything else than C had failed :D 
Good article! We *do* have a C class, but it's only one semester and we do it after two semesters of Java. Then there's optional courses which are about low level (C) implementation (for example we have smart card programming, fast asymmetrical crypto implementation and then there's also practicals) but you have to choose only 3 out of 6 and there's four courses which are not low-level and most students choose one of these (XML/Webdesign, data recovery, etc). And the fact is that even after these courses it's just too little stuff. If you don't like doing low level stuff in your free time you won't know how to C. In fact out of all the people I know who were still with me at university in my last semester, I was the only one that knew how to C and I dare to say I was the only one who knew how really to program in any language (this is not meant to be /r/iamverysmart), that means the others could write python scripts and some bash for simple problems, but I was the only one that could really program. The other guys were very good in their respective areas and helped me out in their areas of expertise (I am bad at maths and proofs and theoreticals), but I was the only one graduating who knows how to program.
If you're teaching pre-ISO C you don't even have basic types that were common in Pascal dialects in the 1980s which were added in the 1999 C standard under &lt;stdint.h&gt;. This is why the kids of the day defined IP addresses as "long int" even when there were systems for which this was a 64-bit value. Another common mistake is assuming all opaque parameters could be cast to an "int" instead of using a union so when pointers became 64-bits on a 32-bit system (they missed the fact that there were 32-bit pointers on 16-bit systems) what should have been a recompile became a multi-million dollar port. Are the two points above or a thousand other perpetual usage errors due to C being "low level?" **No.** C provided the same basic features as most other structured programming languages of the day (hence the comment in the article about C being below anything else you work with is false. The amount of self-modifying Pascal in the world should disprove that.) The problem is the culture which has become self perpetuating.
You're going to have to give us some more details on how what you're ending up with is different from what you're expecting. I don't see any obvious errors in the code itself, though you definitely have some potential issues. Generally the easiest way to see what's not working is to step through it with a debugger. That should help you see where it's going wrong. As for those potential issues, I see the following: * Check the return value of *malloc*(). It can fail and if you don't check you may try to dereference a null pointer. * Prefer *strncpy* over *strcpy*. That puts a maximum bound on the number of characters copied in case your source is not null-terminated or is larger than the destination. * Along with *strncpy* use #define MAX_CHARS 10 and then use MAX_CHARS instead of putting 10's all over the place. This make the intent clearer and allows you to make a change in one place if you want to use a different number later. * Recursion relying on global variables is not good practice, it's too easy to screw it up. Prefer passing in your pointers differently.
C developer here :) just 4 years outta college...there are not many like me but there are some..
&gt;All I know of Lips is what my functions in Elisp. If you want to learn lisp, try Common Lisp or Racket. Emacs Lisp is a rather ugly lisp for diverse reasons. In the early 80s there were two main Lisp dialects: Common Lisp, the industrial-strength Lisp, packed with features &amp; ready for industry, commercial and scientific use, and Scheme which was used mostly in the academic community. Later Scheme got more and more features so these two stereotypes aren't so marked. Racket is a very interesting evolution of Scheme. Currently the most used Lisp-family languages are Emacs Lisp, Common Lisp, Racket/Scheme and Clojure. I personally favor Common Lisp for it's great performance, portability and for the many implementations available -- and also because it's an ANSI standard just like C.
I mean, you could set your input and output buffer to uint32/64_t (I'm not exactly clear on what you mean by "double word"), then you could copy them as that to the other array, then cast that array as an array of bytes. I haven't tried that, but it seems like it would work. 
open(), fread(), printf()
The K&amp;R book is one of many resources that covers this topic very early. 
BAHAHAHAHAHAHA! I'm only laughing because I was once a C developer and was forced to higher level languages, so I completely get where someone coming from a higher level language to C would be like WTF. Check this out, it's pretty good. http://www.cs.bu.edu/teaching/c/file-io/intro/
I want to believe this is just a troll post, but did you even try to Google this?
That said… for being a high level language, Python’s file IO is the thinnest of thin wrappers over the C implementation.
I modified the test you gave to be close to what I was using and it seems like gcc does better memcpy with -O2 and lower and the for loop with -O3. My guess is VC++ on default release only does as good as a job as -O2. I do think it makes sense for the for loop to be faster since im sure the cpu can generate the data faster than copying it from ram. I guess its all down to settings.
I did and I didn't really understand it. I'm in an intro to Computing class and we have to learn C.
http://en.cppreference.com/w/c/io
Interesting, I didn't realize this - by chance have a link to anything related to their design. After years of avoiding Python I'm finally biting the bullet and trying to learn it. It's been painful coming from someone who has a C, Java, and C# background. 
I think you mean fopen() for this situation. 
Yep, that's what I noticed to, I'm so glad at our (a different probably) Uni they're also starting out with Haskell &amp; ASM in the first and Java,Python &amp; C in the 2nd Semester. I think it's a nice combo
&gt; with Brian Kernighan and David Brailsford discussing Unix and C and how they started developing Unix on BCPL/B (being B just a stripped down version of BCPL) and at some point, evolving the OS was impossible, and they felt the need to develop it's own language (C) to implement what they wanted (including piping). That's pretty much what that source says! They started writing UNIX in assembly/BCPL/B, but they hit a lot of constraints, and so evolved BCPL/B into C. Then they re-wrote everything and everything in C. It's a fascinating document that everyone should read, as it leaves you understanding why C has a lot of the problems it now has.
Only if you consider tens of billions of dollars of systems revenue over time to be a failure. Strip away UNIX and its clones and there aren't a huge number of actively supported systems written from the ground up in C either.
Oh come on, Elisp is not that ugly. But anyway, I think it will be a great experience learning CP as hobby not to work with! hehe
`fopen` is a bit easier to use, but `open` is fine, at least in a POSIX compliant environment.
Open a file with `fopen()`: FILE *f = fopen("filename", "r"); `"r"` indicates that you want to open a text file for reading. Next, check if the file was opened successfully by checking if `f` is a null pointer: if (f == NULL) { perror("cannot open file"); exit(EXIT_FAILURE); } Next you can read from the file. Relevant functions are: fgetc fgets fscanf Make sure to read the documentation for these functions before using them. Finally, close the file using `fclose`: fclose(f);
&gt; C code is elegant too: And you've linked to C code written in the freak GNU style? 
Yeah, I agree, but chances are if you're asking how to read text from a file on an internet forum, you're probably looking for fopen. No dealing with the FDT as a new dev.
&gt; GNU style Freak? I actually like GNU style. It is clear and simple! 
&gt; Stallman always says that Lisp is the most beautiful PL! I'm something of a Lisp fanboy but I woudn't say it's beautiful, actually sometimes it looks a bit ugly. What it is, it is *extremely* powerful. It drugs you with power until you become a vicious junkie. If you know what you are doing, most of the time you can write very readable code, and i'd guess that's a beautiful thing. But you can also write in "line-noise" mode if you want... 
&gt; you prefer to spend nights at the Lisp REPL instead of attending that bachelor party. haha
&gt; I actually like GNU style. It is clear and simple! Wow, really? Weird indent? Complete lack of braces? Those braces that are present are at a half-ident? Space between function name and parameters? It makes my eyes and brain bleed.
I would like to add that if you are allowed to use POSIX and not just C standard library, `getline()` is very easy to use if what you want is read a text file line by line. And that's often what you want. http://rosettacode.org/wiki/Read_a_file_line_by_line#C Unlike `fgets()`, `getline()` takes care of the whole buffer management so you don't have to scratch your head to come up with a strategy to handle lines with arbitrary length. * fixed "line" length, binary data =&gt; `fread()`; * fixed line length, text =&gt; `fread()` or `fgets()`; * variable line length with a known upper limit, text =&gt; `fgets()`; * fully variable line length, text, POSIX =&gt; `getline()`; * fully variable line length, text, C stdlib =&gt; `fgets()` + extra code; 
For writing you could, sure
What's FDT?
Ehem... actually, the `FILE` structure you get from `fopen` is just an abstraction over the file descriptor you get from `open` and a bunch of buffers to make IO faster. `fopen` calls `open` internally to open the underlying file. A `FILE` is most definitely not the actual file you opened.
ok
I think you have no concept of the phrase "for all intents and purposes". The OP clearly is a new C developer, and the FILE struct (which, I agree, I used the word "pointer" instead of "structure", so, my bad) is, FOR ALL INTENTS AND PURPOSES, the file object as it would exist in a higher level language like Java or Python. In this context, saying a FILE struct is "just an abstraction over the [FDT]" is equivalent to saying "you're right, and you answered my question, but I want to also be right, so let me correct some minutia about what you said."
It is important to understand that the `FILE` is an extra abstraction with extra buffering. Operatings you perform on a file descriptor have a direct effect on the file itself whereas operations on a `FILE` are delayed until the buffers are flushed. This behaviour can be surprising if you where taught that a `FILE` is exactly the file you just opened. For example, this frequently trips up beginners who do something like this: printf("Enter some data please: "); fgets(buffer, len, stdin); and wonder why their prompt isn't printed.
Fair enough, and I agree the distinction is important when you put it that way. But the question was about reading text from an input file, and I think we may have fallen too far into the weeds here. Haha
C++ is offtopic in this subreddit. Please post C++ questions to /r/cpp_questions.
No blog spam please.
Yes, sorry for the lack of detail this time around guys, I was in a rush and I had to get my assignment done soon. As it turns out, my preorder function works fine, but my insertion function does not. I still do not know why, but I will continue to research and post here when I become stumped again. Thank you all for the help. 
Please...dont C++...You will hate programming. Do C# or Java but dont C++
I'm temporarily removing this unless you can can clarify how this is related to C programming. I only accept jobs posts looking for C programmers, so if you write this into your job offer, I'm going to approve your post.
Hey, I'm looking for a CTO with C language experience.
Wow, thanks! This really changes the way I thought about Rust!
I used C++: Programming from Problem Analysis to Program Design by D.S. Malik during my first year of university. It helped me a shitton and I think the concepts are explained terrifically.
C++...lame
From personal experience, I've found Alex Allain's "Jumping into C++" a good primer. Although, honestly, you can't go wrong with any of [these books](http://programming-motherfucker.com/become.html#C / C++).
First of all, unless you want to learn C don't learn C first. It doesn't help. There are many things you *absolutely* need to know as a C programmer, that you can, and largely *should* ignore as a C++ programmer. For example, in C you should allocate memory dynamically using malloc and free. In C++ you should do it using new and delete, or, in the case of arrays, using std::vector. Or, C++ had 2 syntaxes for the *for* loop, and if you start using both from the start, it'll be better. Learning C first is not the fastest way to become an effective C++ programmer. Secondly, assuming you don't know any other language, I would highly recommend Bjarne Stroustrup's "Programming: Principles and Practice using C++". It's a book made with the intention of teaching you how to program effectively, not teaching you C++. It's also made by the guy who invented C++, so that should count for something. 
Scroll doesn't work if js is blocked, what a joke.
Er, the C standard has a new update roughly every decade... It doesn't evolve *fast*, but it does...
Standard did evolve few times already. You can find more on Wikipedia. The pace of standard evolution is definitely "slower" than other languages (say C++ or Rust, for example). This pace is, in my humble opinion, one of the reasons that give the language the "stability" and "dependability" that are among its main features.
[removed]
So as a complete ignoramus to LISP, what about it makes it so powerful?
I deal with nested structures a lot. `(*top).inner.element` feels better to look at for me than `top-&gt;inner.element` 
if else isn't a function, it's a statement.
&gt;So as a complete ignoramus to LISP, what about it makes it so powerful? Automation is all the rage nowadays. In other languages, you program by writing code. In Lisp, you program by writing code; but you also can program by writing code that writes code for you. There is one part of the power. Also, you can extend the language easily and almost in any direction - you can implement almost whatever feature you need. No need to convince Google, or Oracle, or the Benevolent-dictator-for-life than you need feature XXX (and then wait for the new compiler to arrive). You can just implement it using Lisp straight away. Lisp is sometimes labeled "the programmable programming language". Another powerful feature - in regular languages you often: a. write the code b. compile it c. run it. In Lisp this is an interactive process. You can compile small parts of your code and watch them work in the program that is already running. Or you can write code that writes code -while the program is running-, compiles it and runs it -while the program is running. 
The author wrote the language, so OP should start there!
probably won't help, sorry, but i may actually use this, thanks.
I like to make cli debugging cheatsheets. I finally got around to making the gdb cheatsheet. Perhaps others can use these as I do. Jumping around between a handful of languages and debuggers, my brain can get mixed up. Glancing quickly at a cheatsheet is enough for me to re-familiarize myself with the debugger-at-hand.
FORTRAN is not legacy. If you go into physics it’s still no. 1 in new projects. Mostly because physics folks tend not to be very good at programming but excellent at math, so it’s a nice language to work with.
yes , C is one of the most popular and influential programming language in the programming world.Actually C is the God of all the programming language .Yes, C is not about software development and careers. But if you expert in C then you can expert in any language. C is just depends on your logic .If you are good in C language ,you can make good software developer and make a good career in IT.
There are exceptions but it’s mostly legacy these days
There's a large one in `gdb/doc/refcard.tex`.
Working in physics, I wish it was legacy. It's just so good at what it does. Example: I had a problem where I had a mathematical expression that in recent years had got some nice theoretical improvements, and now the best way to compute the problem should be known. I already had an implementation of a naive solution to the problem in F77 from way-back-when. I worked with some people that had made an implementation in C. Turns out, the F77 solution was 3X faster by default. You had to turn on compiler optimizations that made LLVM and Intel unable to compile the code for this to change. (At that point the C code was 500X faster, living up to the promise --- 1800 minutes computing the problem went down to just above 4 minutes.) This makes C useless when working with people with no programming background. So while programming is really important for what I do, and we own one of the worlds fastest super-computers to run our stuff on, we still need the physicist to be able to read the code to make changes and additions to it as knowledge progress. So Fortan is required. (In fact, the latest standards with modules and what-nots is actually quite nice to use. It just lacks any support from good IDEs...) You cannot really say that it's 'mostly legacy' when it runs on some of the fastest computers that there are. (What I am really against, I guess, is that a language and a compiler ought to just focus on speed, yet they have security checks in there that just slows things down. It's madness and quite horrible to deal with these things, and you always have to work around them in C whereas Fortran just deals with it.)
There’s certainly new uses but your case is the exception not the normal. The vast majority of people who do fortran are maintaining legacy systems at this point. 
Post code, not photographs of code. And pick an indentation style instead of starting every line in column 0. Makes it much easier to read.
`sizeof(sMessages[num])` is `sizeof(char*)`, so you're getting the size of a pointer pointing to a character. You want `strlen(sMessages[num])`.
It's as simple as printing the variables to see what values they hold. It's such a bad approach when u don't even try to debug your program and the first thing you try to do is post it on the internet.
Stop posting these.
Thank you! This makes sense. So in this case it printed `Good day` just because it was a coincidence since pointer size is 8 `bytes` and this sentence has 8 `chars` as well? 
Exactly!
much appreciated, I feel what would be most use that would really drive the development is for people to be actually making examples with it, so I can debug issues and add new features as needed...
much appreciated, I feel what would be most use that would really drive the development is for people to be actually making examples with it, so I can debug issues and add new features as needed...
even that is a help, please do feedback any issues ideas or requests!
Ah nice thanks for the heads up! I like the short cheatsheet that covers 90% of my usage. For the other 10% that I rarely use, something like that larger one is a great resource. Thanks!
I realize I'm a few days late, but I am curious... What industry and what location? I've been thinking of getting back in to C professionally. I haven't started looking at C-specific job postings yet, but I am interested in learning what sorts of opportunities are out there. I spent 6.5 years in the embedded space. I'd be hesitant to move back to embedded, but I'd love to work on systems stuff at this point in my career. I still write C for fun, though I haven't undertaken any large personal project in in C in many years.
I don't think this actually a problem, but is there any reason why you're re-creating the socket on every iteration?
He's not doing that?
Try playing with the code below (but definitely listen to what others have already said): #include &lt;stdio.h&gt; int main() { char sex, ms; int age; printf("enter sex, martial status and age\n"); scanf("%c %c %d", &amp;sex, &amp;ms, &amp;age); printf("sex: %c | ms: %c | age: %d\n", sex, ms, age); if ((ms=='M')) { printf("you're insured\n"); } else { printf("not insured\n"); } } 
Formatted incorrectly too
Except line 15 which starts at column 1. #consistency
It's hard to say for certain without knowing the details of the code and the one billion arguments. You can simplify the case statement quite a bit, though, if you want to go that route: for (int i = 0, j = 4; i &lt; j; i++) { int directions[] = { North, East, South, West }; int tempXvals[] = { *x, *x + 1, *x, *x - 1 }; int tempYvals[] = { *y - 1, *y, *y + 1, *y }; int direction = directions[i]; int tempX = tempXvals[i]; int tempY = tempYvals[i]; .... }
&gt; checkAllNeighors(int* x, int* y/*a bunch of args*/) Can you post the actual code, not the watered-down pseudocode? Why are `x` and `y` passed as pointers btw? &gt; for (int i = 0, j = 4; i &lt; j; ++i) { &gt; switch (i) This version is actually the [loop-switch antipattern](https://en.wikipedia.org/wiki/Loop-switch_sequence), it's just the same sequential code posing as a loop. And why do you need to store the upper bound in `j` when `j` remains constant anyway? Just use a macro definition. &gt; checkAllNeighbors() , with arguments including 1 matrix, 1 array, 4 integers, and 1 queue. Do you find yourself passing the same args to most of the functions? Then that's a sign you should pack them in a structure. If not then it's probably just a case of bad abstraction, and so you're treating symptons, not the actual cause. Why don't tell us more of what you're solving in the first place? What do the data structures represent? Judging by the queue, i'd guess it is some sort BFS traversal of a grid. 
**Loop-switch sequence** A loop-switch sequence (also known as the for-case paradigm or Anti-Duff's Device) is a programming antipattern where a clear set of steps is implemented as a switch-within-a-loop. The loop-switch sequence is a specific derivative of spaghetti code. It is not necessarily an antipattern to use a switch statement within a loop—it is only considered incorrect when used to model a known sequence of steps. The most common example of the correct use of a switch within a loop is an inversion of control such as an event handler. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Correct, I am working on a BFS maze traversal algorithm. I figured that since it only uses a main function and 2-3 helper functions that I could get away without using a structure. It saves space at the expense of ugly code, but I've figured it out now, thank you.
This is the sort of code I wrote when I was teaching myself C as a first programming language -- it works as a toy, but it's not an adequate resource for really learning the language and getting something useful out of it. The formatting is lazy (and [occasionally a little crazy](http://www.decodeschool.com/C-Programming/Pointers/C-Program-to-find-the-sum-of-array-elements-using-pointers)), the explanations just regurgitate the code, the standard library is halfway ignored in an inconsistent fashion (the first section is entirely about printf and scanf formatting, but the section on strings almost completely ignores string.h), and the bread-and-butter of C (pointers, structures, and functions) are only briefly glanced at, to a very inadequate depth. I urge that if the author wants to really learn programming that they sit down with some books and try to implement larger programs, since otherwise they're just destined to burn themselves out and quit the hobby altogether. The books don't even have to be on C; I myself was picked up from [Learn You a Haskell](http://learnyouahaskell.com/), and basically owe the fact that I'm still programming to that book and the other (more advanced) resources it urged me into. What's here instead of a good resource is more just a plateau of a half-driven attempt to learn programming. I was there, I wrote all this same code, and I wouldn't reccomend it to anybody else. Find a way to break the ceiling, instead of embracing it.
Your understanding of atomic is flawed, and that code very much isn't, and is probably exhibiting a lot of undefined behavior. Some stackoverflow discussion on [atomic structs](https://stackoverflow.com/questions/38317513/atomic-load-save-on-c-struct-gcc-questions). You're better off using a high quality RNG like PCG that supports multiple streams derived from the same seed, and/or a separate RNG instance per thread.
Also contains some questionable choices such as http://www.decodeschool.com/C-Programming/Arrays/C-Program-to-Merging-two-arrays . I don't have my compiler handy but afaik this segfaults due to not malloc()ing.
This site really looks like it's nothing more than a collection of solutions for exercises in some guy's class (possibly for his fellow students). Usually I remove these, but this one doesn't have advertisements and actually looks pretty decent, so I'll admit it.
I can respect that. As much as a vietnam flashback I apparently had, other people seem to be enjoying the resource, so I might've misjudged it a bit.
I don't see how that stackoverflow discussion applies to my code. I'm not accessing the atomic struct's members directly, I'm loading a copy of its data into a local variable, modifying it all at once, and writing it back using a CAS loop. &gt; is exhibiting a lot of undefined behavior and race conditions. Care to elaborate? Example?
I'm a student and that solution was weird, I was under the impression that declaring an array of a not known value variable was wrong/would give a compile error isn't that the case ? I always went with malloc when the size was not known beforehand.
No, I agree. These programs are poorly written and don't provide much of anything past basic syntax usage. No good practices, weak explanations, bad algorithms, no error checking, bad formatting, etc.
This would be great, except I configure the C compiler to reject `//` style comments as they are not part of ANSI C.
In C89 (aka "ANSI C") it doesn't compile, but in C99 it's allowed.
It should work if you're using C99 or later, IIRC only some compilers support that feature though (I think clang in particular does not).
That's an odd preference to have I guess, but then make a suggestion to PVS-Studio about it, if you wish to use their product.
Can you draw a picture of how you want the signal to look? I don't understand your description
Then it's a sensible choice and not a preference for sure. I still think it might be a good idea for you to contact the viva64 guys about this, it seems very reasonable to either also support /* */ syntax or simply use that syntax instead.
C99 is almost 20 years old by now, and that added // comments to C.
Some of the systems my code should run on don't support C99. Some don't even support ANSI C.
Maybe something like [this](https://www.desmos.com/calculator/apjwzqqgx8)?
Similar, but not quite. Do you see how, at the origin, rather than remaining smooth, it bends? I'd like the transition to be smooth as well. 
Hmm i see... yeah, r/math seems the right place to ask this.
That just lowers the function down a bit. 
Hm, so if I were contributing to a big non-personal opensource project (st. they'd need to buy a license) but I'm personally definitely seeing it as my project... what's then? Say I fork said project X and add all those comments for me, make fixes, and let them cherry-pick those or create bug reports? I don't see how this'd not evade that regulation.
copystruct was allocated as follows: struct Main_Struct *copystruct; copystruct = (Main_Struct *) malloc(size of(*copystruct)); Are you saying that this would also allocate example too, a field inside copystruct?
You seem to be using a C++ compiler. Are you looking for a C answer or a C++ one? Memory allocation is different in C and C++ and you can't really use a C++ compiler to write modern C code.
Sorry I misread in my deleted reply, although you can't normally cast like you do here in C, only if you have a `typedef`. Anway, yes, the array is of static size and allocating a `Main_struct` will allocate all the space for the array as well. Note that each element in the array will initially be an invalid pointer though and you have to allocate memory for each `My_struct` you wish to store in it.
I made a mistakes in the cast I posted. It should be (struct Main_Struct *) instead. So I have to loop through the array and allocate space for each struct My_Struct, and then copy them over individually (having a copy of the array is my ultimate goal)?
Sounds like you're looking for a bignum library.
You cannot really make assumptions about stdout, but you might try and see it \b (backspace) works for you.
&gt; see the null character, and then terminating What gave you the idea that printing a null character would terminate anything? If that were the case, programs outputting binary data to stdout wouldn't work.
You could use fwrite to get a null byte into the buffer, but it's not going to work like you describe
I don't think that this is possible. Assumption: You have to call flush to be sure that your content gets copied from a temporary 'transfer-buffer' to the destination frame-buffer (in this case). So 'you win' and 'you lose ' are stored in different transfer-buffer. In theory that scenario is a race condition. Because it depends on the execution order of flush and that 'you lose'-Printf - call, when it gets written to the framebuffer. The write function (underling to Printf) is race condition proofed by the kernel. 
I have no idea if this is what you are looking for, but while doing my homework, I noticed that the shape of this function looks similar (wider at one half-cycle, thinner at another) to what was shown in your pic. The equation is e^sin(t). You may have to shift it on the x-axis to get it the way you want it. Hope it helps.
You shouldn't be casting malloc at all, ever. As they're arrays of pointers, "a copy of the array" would still point to the exact same My_Structs. If this is what you want, you only need to memcpy the array itself. If you also want to copy the My_Structs so that the new array points to its own My_Structs, you'll have to loop through the arrays, alloc and copy each My_Struct as you describe. (deep copy)
It's not a race condition, the strings will be appended to the same buffer, in the same order that printf is called. This is handled by the stdio userspace component, not the kernel.
How about this? https://www.desmos.com/calculator/apjwzqqgx8
Well, I don't get why are you using an array of pointers in the first place. I mean you could just use a pointer and allocate as much memory to it and then dereference it as (pointer + i). for eg. struct sub_struct { int temp; } struct main_struct { struct sub_struct* sub_pointer; } And in main(), you can allocate as main_pointer-&gt;sub_pointer = (struct sub_struct* ) malloc(sizeof(struct sub_struct) * SIZE); Now, you can reference any value as (main_pointer-&gt;sub_pointer+i)-&gt;temp where i can range from 0 to SIZE 
This article warms my heart. I first learned C in 1985. Over the next 15 years, I wrote about 1 million lines of C code, and have software that is currently running in thousands of sites around the world. I stopped writing software full time around 2001 to pursue another career, but find that I can return to C projects every year or two when times are lean. Long live C, the language of the gods.
bruh
:/ I wasn't trying to be rude. I think at this point "googling" is a really important skill.
http://lmgtfy.com/?q=find+consecutive+numbers+in+array+in+c
You don't need a conditional or a semicolon for your else. The basic structure is: if (condition) statement else statement or if(condition){ statement } else{ statement } When you have the format else (miles &gt; 500); Then the else statement is improperly executed.
This definitely resembles what I'm looking for, much better than a lot of other solutions, but I'm not 100% certain it's what I want. I'm not too familiar with this kind of function. 
Shouldn't it be in line 9 `if (prev == arr[i - 1])`? I think your brace slipped a bit ;)
Make sure that you are pulling out the entire extra statement. For example, this: else (miles &gt; 500); { total = (miles / 500) * shipCost; printf("Total shipping cost is: %.2lf \n", total); } should look like this else{ total = (miles / 500) * shipCost; printf("Total shipping cost is: %.2lf \n", total); } The entire (miles &gt; 500); section should be removed. I sent you a larger sample piece of code through PM.
Oh, is that what consecutive numbers mean? I legitimately thought that numbers had to be incremented like 3, 4, 5. I fixed it.
Oh I think that's what he meant.. I may be wrong... I didn't even think of that way ;)
The rest is 4-Modify your class by adding data members to better manage the dynamically allocated object.(number of object available, next object to be used etc...)
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
PuTTy is a terminal emulator - a program that contexts to another computer to send &amp; receive (usually text) data. you can launch apps like text editors that will talk to it. You can run different text editors (nano, vim, emacs...) and they'll behave differently, which probably will make editing easier. you can use other terminal emulators, but I believe PuTTy's the best on Windows. and your coding experience depend much more on the selected text editor, anyway. As you seem to be working on remote machine, it might not be possible to access the files directly unless you use PuTTY to connect via network. but it may be possible to edit files locally with a graphic editor probably and than copy them on that machine in order to compile... or even compile it locally. 
You are likely using PuTTy to connect to another computer, on which you compile your source code. What commands do you type in? You don't need to use putty. You can for example use visual studio.
You can use an IDE like codeblocks for windows. Another option is to use a Linux OS and text editor/terminal to compile and run your code. It would be similar to PuTTy. You can dual boot Linux or use a virtual machine, you should be able to find some Linux virtual machine that's free for students somewhere online.
Although your else is valid syntax, it's not doing what you expect it to. When you say: if (weight &gt; 50) printf("We cannot ship packages over 50 pounds. \n"); else (weight &lt;= 50); { printf("Enter the number of miles your package needs to be shipped: \n"); /* more code, truncated for brevity */ } ... what you're actually saying is: if (weight &gt; 50) printf("We cannot ship packages over 50 pounds. \n"); else (weight &lt;= 50); /* useless comparison that effectively does nothing */ printf("Enter the number of miles your package needs to be shipped: \n"); /* more code, truncated for brevity */ So the block asking for the number of miles will always be executed regardless of what `weight` is set to. If you have your compiler warning set to an appropriate level you would have got a warning about this. I did this with a simplified example: #include &lt;stdio.h&gt; int main(int argc, char **argv) { double weight = 0.0; int rc; printf("Enter the weight of the item: "); rc = scanf(" %lf", &amp;weight); if (rc != 1) { fprintf(stderr, "Invalid weight\n"); return 1; } if (weight &gt; 50) { printf("Too heavy\n"); } else (weight &lt;= 50); { printf("%f is ok\n", weight); } return 0; } When I compile this (with gcc) I get a warning: $ gcc -g -Wall -pedantic -std=c99 foo.c -o foo foo.c: In function ‘main’: foo.c:17:18: warning: statement with no effect [-Wunused-value] } else (weight &lt;= 50); { ~~~~~~~~^~~~~~ $ I think what you wanted to do was: if (weight &gt; 50) printf("We cannot ship packages over 50 pounds. \n"); else if (weight &lt;= 50) { printf("Enter the number of miles your package needs to be shipped: \n"); /* more code, truncated for brevity */ } However in this case we know that the weight has to be less than or equal to 50, so a simple `else` will suffice: if (weight &gt; 50) printf("We cannot ship packages over 50 pounds. \n"); else { printf("Enter the number of miles your package needs to be shipped: \n"); /* more code, truncated for brevity */ } Personally, I prefer the early return style, so would do something more like: if (weight &gt; 50) { printf("We cannot ship packages over 50 pounds. \n"); return 1; } printf("Enter the number of miles your package needs to be shipped: \n"); /* more code, truncated for brevity */ This reduces the level of indentation and makes the code easier to read, though like everything there are differing opinions on this. 
Rather than storing the player position in pixels, I would store in in 'blocks,' so that x can range from 0 to 9 and y can range from 0 to 7. You can still animate the transitions, in a separate loop. But that way, when you detect a joystick action, you can test whether the target position (now in the same coordinate units) is occupied or not, by accessing the corresponding element of env. Impressive work for less than a week's exposure to C. One way to tighten it up a bit would be to use modular arithmetic for the screen wrapping, but it's probably a matter of opinion whether that would be clearer.
I know that, but I'm no good at explaining things :( so I decided to kinda cut the explanation... 
GNU Emacs 
Integer math: divide, block position by 16 to get where it is in the maze, before committing to any move. 
A barrier in concurrent programming, is a synchronization method where all processes/threads that need to be synchronized will not pass the barrier until a number of processes/threads have reached it. In see, there's [pthread_barrier_init](https://linux.die.net/man/3/pthread_barrier_init) will initialize a barrier, and 'count' is the number of processes that will need to wait on it until they can pass that point of their execution. [pthread_cond_wait](https://linux.die.net/man/3/pthread_barrier_wait) is the function that each thread will call to wait on the barrier, and when 'count' processes call it, they will then be able to pass the barrier.
So, the user enters homework, lab, and midterm weights and averages, and we have to print what they enter and the create the table below. The bottom table consists of the final grade if the user has a final exam score of 100, 0, or equivalent to the midterm average, and we are to determine the grade from there. I am not allowed to discuss specific algorithm here, and ask that y’all respond generically as much as possible, but was wondering if someone could tell me how to declare variables for functions that I need to print (e.g. do I put those variables above int main(void) or inside main, or both; where in the program do those variables show up, etc.), how to print the “-=-=-=-...” in between the variable print statements (e.g. in or outside main), and where to place the function identifiers.
Hey, thank you for responding, but actually my tutor just texted me. I’m taking the post down. Best!
I believe that some people in here will hate me for this, but for C, the one that helped me the most was KDevelop, and I still use it today. As a beginner I liked the colorization range on variables, global ones being darker and local ones lighter in color, as well as the range of colors it could use for different variables. It helped me focus on the issue at hand because I could get a vague idea of what was going on without confusing similarly named variables. That combined with the very verbose Clang output, allowed me later on to teach C to my sister who is a physics major, in a matter of a few weeks.
You might need to use the "Developer Command Prompt" (in VS2017 it is in the start menu, which executes a `VsDevCmd.bat`).
It worked. Thank you very much for your help!
Ed
pthread_barrier_wait(), not pthread_cond_wait().
Yes, you are right. Thanks for correcting me!
You mean C, not see, right?
pico
To sophisticated
You need a new temp grid, since you can't edit the original grid during the tick computation. Assuming you're using int for each cell, I suggest you do a function like this int** tick(int** mat){ int **next; //compute the next mat using the rules, writing in "next" return next; } So you can call: mat = next(mat); To execute a single tick. As for computation, I'd just evaluate every position for the "next" matrix using the data from the given matrix.
If you don't want to use a temp mat, I think you can do some trickery. Your mat won't have just 1/0 values. It will allow any &gt;0 for "alive" and any &lt;=0 for "dead". First, you evaluate the cells by writing the info needed for each cell in the cell itself. For example, cells that will be born in the next tick will have "-1" value. Alive cells will have the number of alive neighbours. Example Current mat 0 1 0 0 1 0 1 0 0 1 1 1 0 0 1 0 Evaluate: (i'll write * instead of -1) 0 2 0 0 2 0 4 * 0 3 4 3 0 * 3 * Next tick: 0 1 0 0 1 0 0 1 0 1 0 1 0 1 1 1
Max would be 24 elements.
How is “must appear more than 5 elements away from the element that is the same as it” defined? Is 5 the difference in indices or the number of different items between? You could compute how probable it is to get an admissible array from a random shuffle and then just try shuffling until you find an admissible permutation. This might be a bit slow but has the advantage of being unbiased. Another method is filling in one pair of items at a time such that the condition is met. However, this method probably introduces a bias. Let me think if I can find a better way.
yeah I tried filling in pairs at a time but then there is no randomness to it.
Well, duh, you are supposed to fill in the pairs randomly.
This has nothing to do with C programming. Ask /r/algorithms or /r/compsci
should've specified I am doing this in c so i need an answer that takes c code into account.
Please insert four spaces to the beginning of each line of code so that reddit will properly format it. What's the nature of your problem? Could you be more specific with what the code should be doing and what it is doing?
Your problem is algorithmic. When you've figured that out and you're having trouble with the C syntax come on back.
First of all, I don't think there's any need for the char buf[] array in the first half of the if statement. I think you can just put the ch straight into the temp buffer. Also, I think the line "strncopy(ary[i], temp, strlen(ary))" doesn't specify the right string length to copy. It should be: strncopy(ary[i], temp, strlen(ary[i]) 
thanks Stark- will I need to realloc space afterwords as well? 
yes, you'll need to do that. You might also consider using the c string tokenizer, strtok() http://en.cppreference.com/w/c/string/byte/strtok 
A text editor with syntax highlighting is about as far as you need to go for c program editing. It's also useful for any ancillary files, such as makefiles. For Windows, I use Notepad++. For Linux, I use kwrite.
Read the second paragraph of my edit above. `strncopy` is not defined, so the linker is throwing a fit. I believe you meant to use `strncpy`. You are likely not allocating memory properly, but until we can get your code to compile and link, we can't know.
It's nice to see someone put into words what I usually can't when talking to Ruby/Go/Rust fans who think that C is dead or that its history or utility are overstated. Sometimes there's no arguing with those guys. 
This subreddit is meant to discuss the C programming language. For C++ related posts please see r/cpp, r/cplusplus, and r/cpp_questions.
vi editor + gcc compiler = happiness or headaches
What are possible use cases for this? 
Perhaps do a while loop that runs forever. When u get to where u need to stop do a break to get out of the loop. Or u can do a for loop. When ur energy reaches zero it breaks out automatically. 
Its conways
For arrays with less than 12 elements, you can't do it. For 12 elements you have one soln: a[0], a[1], a[2], a[3], a[4], a[5], a[0], a[1], a[2], a[3], a[4], a[5] For 14 elements you have: a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[0], a[1], a[2], a[3], a[4], a[5], a[6] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[1], a[0], a[2], a[3], a[4], a[5], a[6] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[1], a[2], a[0], a[3], a[4], a[5], a[6] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[1], a[2], a[3], a[0], a[4], a[5], a[6] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[1], a[2], a[3], a[4], a[0], a[5], a[6] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[1], a[2], a[3], a[4], a[5], a[0], a[6] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[1], a[2], a[3], a[4], a[5], a[6], a[0] a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[0], a[2], a[1], a[3], a[4], a[5], a[6] ... The right half looks like the left half except each element has the possibility to be moved one left or further right. Proceeding from this pattern, I think an algorithm for 2n elements is something along the lines of: - Fill in elements 0..n-1 with unique values, shuffle them - Fill in element n..2n-1 with copy of the elements 0..n-1 - for (i = n; i &lt; 2n; ++i) swap a[n] with a random element from a[n]..a[2n-6] I believe this will only produce legal permutations. But, unlike fisher-yates I can't tell if all legal permutations are equally favored - likely not. Note what's going on with the right half is somewhat reminiscent of bubble sort. 
Butterfly wings!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
edited- thank you 
I appreciate the example. Thanks! 
I might use this approach! Thank you.
One possible use case could be that you have a number of threads that all read a whole shared data structure and then each thread has to perform updates in a separate region of that same data structure. In that case, the threads could synchronise using a barrier so that all of them read the same data from the data structure, and then all perform their updates at the same time. It could even loop around and you'd always have all threads read the same state before updating the data structure. I can't think of something more specific, perhaps Google can help you there if this post doesn't help much.
clearly a C++ issue but cout &lt;&lt; vers[4][40] &lt;&lt; endl; clearly look like you problem `vers[4][40]` do not mean "all 4 lines of 40 chars", it mean the char at line 4 ( where it should be 0 to 3 ) at position 40 ( where it should be 0 to 39 )
there is a lot missing, like how the performance is read ( or is it random ), or do you have to find the performance that give the best score ? 
I can C the wave of protons moving and pushing the bits thus assigning the value TRUE to the bool variable! 
hey you, release bobby the bear back into his natural habitat or your circus is going down, punk. us animal welfare cats dun look too kindly on circuses an we ain't afraid of usin force to get our way
Here is a list of threads in other subreddits about the same content: |Title|Subreddit|Author|Time|Karma| |---|---|---|---|---| |[Reading bits in far too many ways (part 1)](https://www.reddit.com/r/programming/comments/7ym5tk/reading_bits_in_far_too_many_ways_part_1/)|/r/programming|/u/turol|2018-02-19 19:57:51|7| |[Reading bits in far too many ways (part 1)](https://www.reddit.com/r/bprogramming/comments/7yteok/reading_bits_in_far_too_many_ways_part_1/)|/r/bprogramming|/u/bprogramming|2018-02-20 13:05:41|1| |[Reading bits in far too many ways (part 1)](https://www.reddit.com/r/cpp/comments/7ym9u2/reading_bits_in_far_too_many_ways_part_1/)|/r/cpp|/u/mttd|2018-02-19 20:20:53|39| ---- I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20user&amp;message=semi23)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20subreddit&amp;message=C_Programming) Now you can remove the comment by replying delete! (op only) 
didnt know
You are most likely passing an unterminated string to your LDAP library.
Perhaps, but all I've done in the second implementation is declare a new vector. The LDAP code, to that point, has not changed. It's not until after the search is made that it tries to add entries to the vector.
Thanks for your response, but I'm not sure I follow. I have not reached that point yet. That's at line 141 and that code only applies after the ldap_search_ext_s has successfully executed on line 127.
I am not familiar with LDAP library you are using, but crash with SSE mentioned just screams "alignment" to me. 
Undefined behaviour is undefined. Regardless of the optimization level, if you are segfaulting then you are doing something wrong.
Be more specific. Don't just post your homework while writing 'pls help' and expect us to do it for you.
I agree with you. It has to be something that I'm doing wrong, and I'd love to use the argument you suggested to try and figure it out, but I'm living in the dark ages. The GNU compiler on that system is 4.4.7 (almost 6 years old now). The -fsanitize is for 4.8 and higher. I still think your point is valid and that I should find the highest version of GCC I can get to work on that host, and recompile with -fsanitize. Thanks for the hint. 
Fun small educational project: If you want to learn how to work with units smaller than a byte, implement Base64 from scratch. It’s really fun! 
You are not running into a bug in libc. You are allowed to ask that question after debugging for 2 months and actually reading the code to libc where your problem happens. At most you could be running into a bug in the ldap library. But probably not. What I think is happening is: char *retattr[2]; ... retattr[0] = calloc(10, sizeof(char*)); This doesn't smell right. len = snprintf(retattr[0], S_SIZE, "cn"); The size argument to snprintf is definitely wrong. This then gets passed down to this function call to the library: rc = ldap_search_ext_s( ld, basedn, scope, filter, retattr, 0, NULL, NULL, NULL, 1000, &amp;result ); So what is retattr? Google helps: &gt; The attrs parameter is a null-terminated array of Oh. Where's your NULL termination? And yes, ldap_search_ext_s is in the traceback. You sent garbage into as function that expects strings or NULL. It crashed. Not really sure if this is the bug, but it looks like the most likely candidate.
It's a perfectly normal version of strlen that kicks in on SSE machines so that things can be a bit faster. It does not have alignment issues.
Thank you for your input, but retattr is null terminated. I checked it with the debugger, and the man page for snprintf and tried it with strcpy, and I printf'd it. It it weren't null terminated, I would have core dumped during the printf.
So I guess GLM stands for "Generalized Linear Model". I'm rather inexperienced in these stuff. Can you explain a bit more about your project in terms of theory and application? Also, is it usual to use C for these math analysis problems? Isn't MATLAB or some_python_wrapper_over_C++ or C++ itself a better approach?
afaik glm stands for opengl mathematics. the real reason it was created is because I was following an opengl tutorial that ended up using glm and since I'm too stubborn to switch to c++ or use any other libraries I decided to make my own since I couldn't find another one that used SSE. I'm not sure what you mean by the last part but I didn't use matlab because it costs money and I believe it is slower. Also I don't imagine it has opengl support.
Thanks for the info :)
no problem :D
you're confusing two different things. one is that retattr[0] is a null terminated string. the other is that retattr is an array that is null-terminated, so retattr[1] must be null. you should initialize that array like, for example: ``` char *retattr[2] = {}; ```
No, it isn't. retattr[0] is, retattr isn't. Even if it might happen to be in some situation, retattr[1] is not initialized and the function expects an array where the last element is NULL.
Use valgrind then.
Thank you. 
C is pass by value, passing by value is sufficient even for structs. You pass by pointer if you need the called function to modify what you are passing. Pointers are passed by value, so if you want a pointer modified you pass it by pointer, so on and so forth.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [j-shilling/ipd/.../**mail.c#L30** (master → edfff34)](https://github.com/j-shilling/ipd/blob/edfff3446e5be0874708d2f4081e52a0cacdc99f/src/mail.c#L30) ---- 
https://github.com/zee2200/glmc/blob/master/glmc.h#L296 You're not doing a swap here.
can't believe that slipped past me or that I did it in the first place, thank you for that!
I thought that was really clunky when I was writing it, but I don't have a good grasp of c idioms. Could you give me an example of what you mean if you have time? I'm having trouble picturing it.
 int str_move(str_t *str1, str_t *str2) { if (str1-&gt;str != NULL) { free(str1-&gt;str); } You don't need the test, `free(NULL)` is OK: it does nothing. (Although the version with test may be a bit faster in cases when `free()` is not called.) --------------- str1-&gt;str = str2-&gt;str; str1-&gt;len = str2-&gt;len; str1-&gt;cap = str2-&gt;cap; Since you copy each field of the structure `str_t`, `*str1=*str2;` is shorter and does the job. ---------------- int count = 0; { char *dest = str1-&gt;str; char *s_ptr = str2-&gt;str; dest += str1-&gt;len; while ((*dest++ = *s_ptr++) &amp;&amp; ++count &lt; str2-&gt;len); *dest = '\0'; } I think you are mixing to ways of checking the end of the source string there. `(*dest++ = *s_ptr++)` already checks that you reach the terminating NUL character; you shouldn't need to use `count` at all. `*dest = '\0';` should not be needed then. -------------------------- int str_compare(str_t *str1, str_t *str2) { char *s1 = str1-&gt;str; char *s2 = str2-&gt;str; while (*s1 &amp;&amp; (*s1++ == *s2++)); return *s1 - *s2; } `s1` and `s2` have been incremented when you return them, they do not point any more to the same characters which were used in the test and compared false. Test `str_compare()` with strings `"a"` and `"b"` to make sure. I think it will erroneously return 0. --------------------- int str_resize(str_t *str, int len) { if (len &lt; 0) len = 0; char *tmp = realloc(str-&gt;str, (sizeof(char) * (len + 1))); /* ... */ str-&gt;len = len; str-&gt;str[str-&gt;len + 1] = '\0'; You write this `'\0'` out of bounds of the allocated space, you should write it at `[str-&gt;len]`. ----------------- Test `str_erase()` with a longer chain, with more characters after the erased length (for pseudo-example: `str_erase("hello world", 2, 2)`. Pretty sure it won't work as expected. 
This sub is for C, not C++.
You can just run multiple tool passes; it's not important which component finds and flags the problem. 
Well on second thought, what you have is fine as you need to format the strings anyway. So they way I would think of putting them in an array would be doing what your doing with one extra step, so it isn't a big deal IMO. If they were just string literals all you would do is something like: char * my_strings[3] = { "hello,", "world", "!" } int i; for (i = 0; i &lt; sizeof(my_strings)/sizeof(my_strings[0]); i++){ write_function(my_string[i]); }
This sub is for C, not C++...
Because &amp;&amp; is a sequence point. So i is 2 when compared with 1
what's a sequence point? 
A point at which the effects of previous expressions are guaranteed to have been completed. https://docs.microsoft.com/en-us/cpp/c-language/c-sequence-points 
Capacities and lengths are expressed by `size_t`. Using `int` (even though the standard suggests that in places) is so 1980s.
You may want to try /r/learnprogramming and use pastebin.com 
Thanks :)
Wow. This is good
I'll take them out, I wasn't sure if it was best practice or not to remove the type if its length is 1. Thanks for your help!
Hey, thanks for the quick reply! I should definitely add my defence of that decision to the bullet point. My thinking is this: I've always read that type promotion in complex statements involving signed and unsigned values can be confusing, compiler-specific, or even lead to undefined behaviour, so I wanted to promote either signed or unsigned ints as the "default" type to use. I went with signed because - long long signed int is big enough for most purposes - many library APIs use signed int return codes - signed int is, in general, more multi-purpose than unsigned int I used the verbiage "when you can use an int" to imply that there are times when unsigned ints are useful, such as interfacing with certain library APIs, working with bitmasks, or storing very very large values. But I'd be curious to hear your thoughts.
Why? Passing a pointer is usually 4 or 8 bytes depending on the architecture of the platform running the code. Passing a struct by value is less efficient as soon as you exceed the size of a pointer. It also helps by creating IN, OUT #defs (that evaluate to nothing) to show that an input parameter that is a pointer is expected to be modified or not (which can also be done with the use of pointers to constant memory). What clarity is lost by passing a pointer to a union or struct?
Whoops, sorry
I'd prefer to be more explicit with regards to intent when possible. Do you know if the multiplied by one would be optimized out by the compiler? If it doesn't effect performance, I think I'd prefer the malloc/realloc with sizeof(char).
4 spaces, you disgust me good sir
so he just need to change the order between o++ and i==1?
To each their own, lol. Are you on team tabs or team spaces (but just not 4)?
I think removing these comments aftee running the tool is an interpretation of the rules in bad faith.
&gt; Always initialize variables when declared to 0, even if they’re on the stack and the value will be overridden on the next line. Doesn't this just suppress diagnostics (compiler warnings and ASAN/undefined behaviour checkers) in the situation that you accidentally forget the real initialization?
`unsigned` has worse performance than `signed`, as well, almost always. Many of the optimizations that compilers can do to simplify integer arithmetic are illegal to do on unsigned integers because of how the standard defines overflow behaviour.
I spot at least 3 errors. Your compiler isn't complaining loudly about at least 1 of them?
so far it's only segmentation which leads me to believe there's something wrong with space allocation More errors will probaby pop up 
Several void read_line(char**ary,int*size,FILE*fp){ char ch; int i=0; ary=malloc(sizeof(ch)*1000); //ary is char**, I suppose you're passing a pointer to the array. So you should assign the malloc to *ary, not ary itself. while((ch=fgetc(fp))!=EOF){ if(ch!='\n'){ //you're only saving newlines in the array ary[i]=ch; printf("Array at %d:%c\n",i,ary[i]); i++; } else{ continue; //completely unnecessary } } } 
My warnings are enabled on gcc(used through my mac) but in this instance, only: Segmentation fault (core dumped) is occurring 
ISO C forbids empty initializer braces. I think you meant char *retattr[2] = {0}; Either way, that did not help, neither is valgrind in this case, but I do appreciate you looking into it.
Thank you so much for the corrections! Even with the adjustments I'm still getting segmentation errors, so I will keep investigating why this might be. 
There's a typo on line 4.
I'm not an expert, but test your pointer fp at the beginning of your function: if(fp != NULL) And why the hardcoded value in the malloc? Correct me if I'm wrong, but malloc(sizeof(ch) * (*size)) should be better. (You have a pointer to the size, so unreference it :-))
Another reason to use pointers is to create data structures that dynamically grow in size as needed.
Meh. I can only speak for myself, but I prefer `sizeof(char)` or `sizeof(char) * len` instead of `sizeof(1)` or `sizeof(65535)` or whatever. I find it more explicit when reading code (like warmwaffles says: it's a type hint).
You both disgust me :) Tabs for indentation, spaces for alignment!
You wrote that there might be something wrong with space allocation. What problems do you think there might be?
It's context-dependent. The Linux kernel, for example, is written in C and consists of millions of lines of code.
So I shouldn’t stress about having over 1,000? Ok
i wrote that it's context-dependent. If, for example, your program is a single file of 1,000 lines of code which does nothing more than print "Hello, world!" to STDOUT, then yes, that's a problem.
Ok, the program is a personal project to develop a simplistic calculator, and I’ve been expanding its abilities since I got it to fully work, that being said upon considering this context what do you think?
Passing bigger structs by value as parameter or return value is frowned upon, just like allocating them on the stack. It doesn't really matter for a 16 byte structure, it seriously matters for a 2000 byte structure. In the embedded/os environment it's very typical to require all structs passed by pointer, primarily due to the limited stack size.
That might well be reasonable, depending on things such as how extensive your calculator's functionality is, the type of UI it provides, etc. Unless you're trying to write something for an Obfuscated C contest, SLOC isn't necessarily more important than code *readability* and *maintainability* (including the case where the future maintainer is only likely to be you).
So true. Genomes often enough exceed 32bit.
Most likely, yes, I cannot imagine that it wouldn't.
Yep. And it serves no purpose at all. It feels like people really take "always initialize" a bit too serious.
I dislike the zero-initialization, I see no purpose in it other than confusing the compiler. I dislike the huge load of comments, look much like noise. I have the comments usually highlighted bright because they're important. I also like `/* */` comments much, because of the flexibility, but that's mostly taste. I dislike PascalCase, but also it seems like this is much borrowed from an object-oriented programming style, and I dislike OOP. When OOP really does make much sense and I "need" it, ie. I have a struct that really could be used similar to a class, I also use PascalCase. I also like abbreviations, they usually do not much harm. I also usually use int, but sometimes -- when I want to be sure the value is non- negative I use unsigned despite an int being okay too.
For reference, i just ran sloccount(1) on the version of xcalc included in Debian stretch; it comes out as around 1400 SLOC.
You *are* using the other. The function expects the last element of the retattr array to be NULL. It isn't. In your case it would be retattr[1] that should be NULL. Just add `retattr[1] = NULL;` before the call to ldapquery and see if it helps. I'm 99% sure that it will.
1000 lines for a program unto itself isn’t a problem. I can point to many 1000 line functions nested dozens of levels deep and riddled with gotos which have driven decades of bug fixing with no end in sight, in part because the clients in different business units can’t agree what they were supposed to do in the first place. The UNIX philosophy of no error checking and handling persists while its idea of small well defined units of functionality died.
yeah he could have done int i = 0 and then when evaluating i == 1 it'd be true edit: if he's doing what i think he's doing, it would probably be better to have two septate integers to evaluate in the if statement, reusing the same one is likely to cause headaches
My company went to a standard requiring an automated code formatter, and it's glorious. It's enforced by pre-commit and pre-receive hooks. I haven't had to spend a brain cycle on formating since. 
I'd consider a C program with less than 1000 lines to be a short program. The program I'm working on at my current job is around 200,000 lines of code.
You're allocating enough space for 1000 chars, so you may want to make sure you're reading fewer than that when you load them from the file. You also don't have a line in this function where the file is actually loaded into ram, so make sure you're doing that as well. Either of those issues would cause a crash.
You don't need to stress out over the total lines of code of the program. However, remember to use functions, if a single function is like 100 lines, you can probably subdivide the function in more, simpler, functions.
`sizeof ch` is 1 by definition.
In scientific computation you pass around huge typedefs, copy in and copy out would absolutely kill your performance if passing by value. Optimization is the first and foremost thought we have when thinking about pointers.
Then sizeof value is known at compile time. It will be optimized out.
Will do, thank you!
dereference *. OP is already has size unreferenced ;)
YOU DA MAN!!! Thank you. That did it! Appreciate all your help on this.
I did not know about that trick. Using your %p trick, I was able confirm with gdb what /u/hegbork was telling me was correct thus resolving the issue. Thank you very much.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
&gt; In the functions that take a char * such as str_cappend, would it be safe to assume that the char * is null terminated, and do without the int length parameter? Well, it depends what you want. C strings are NUL-terminated sequences of characters by definition/convention. So if you say your function parameters must be C strings, you can expect them to have a terminating NUL character. I thought your functions meant "use a maximum of `len` characters from that C string". But if you want to pass arrays of characters that do not obey C string convention, and have a separate `len` parameter indicate their length, that's your design choice.
Thanks!
yeah, its very strict use asdvasdcasdc
 if( !(field-&gt;field = malloc(sizeof(struct Cell) * rows * cols)) ) { This malloc returns a 1D array. It should be assigned to a Cell*. It can only be dereferenced with a single set of `[ ]` struct Cell **field; This is an array of pointers to an array of Cells. The 1st `[ ]` will return a pointer to a Cell. The 2nd `[ ]` will dereference that pointer and return a Cell. You have 2 solutions 1. Change the malloc so you allocate an array of pointers, and for each allocate an array of cells. This will make the allocation scheme match the type of the `field` member 2. Change the field member to Cell* and then change the VAL macro so that it treats the contiguously allocated array as a 2D array. ie. `n-&gt;field [ X ].value` where `X` is some calculation involving `i` and `j`
i'm confused how this didn't help, since it seems like it would fix the issue you described (it places a null at the end of the array).
Ohh that makes sense, i didn't even think of that! Of course you are right, i will go ahead and allocate memory for rows and cols seperately i think and make a real 2D array. Thanks :) //EDIT: On second thought I think i will try to come up with a 1D solution, since depending on the amount of Rows this could slow down the program by alot allocation memory for each Column
Thank you too :)
What are your starting values for `Monthly` and `LoanAmount`? Are they ever equal to each other?
I went back and commented out setting *retattr[1] = NULL;* and instead declaring *char *retattr[2] = {0};* as you suggested, and it actually **worked** this time. My only explanation as to why I thought it didn't work before is perhaps I was doing too many trial and errors and had other things changed as well. My apologies.
Yea that is right, i am comparing to Floats. Well i originally tried that but it didn't initialize the loop.
You will never enter the while loop if they enter a non-zero LoanAmount
But you don't change LoanAmount inside the loop, so the loop will run for ever once it started.
 Year == Month * 12; You should compile with warnings enabled, even though you aren't actually using `Year` for anything right now. With floating point numbers you never really want to test for equality. Test for &lt; 1 or something instead. They have issues with precision. `LoanAmount` never changes inside the loop, so when will your loop end?
Currently, as it works, the loop will ONLY run when `Monthly` is equal to `LoanAmount`.
True, sorry :-)
ah, that's ok. thanks for the update. i was more worried that it didn't actually work (i thought {} was valid C, but it's only C++, so was wondering how much more i had mistaken....)
Right okay, i am trying to make it end once The Loan Amount goes down to 0 by the number allocated for Monthly. So i thought that would work.
Right okay - that makes sense, thanks. I am trying to make it end once the LoanAmount hits zero, subtracted by the amount from the Monthly variable.. although i was not sure how to do it.
In your second bullet point under dos and don'ts I think proceeded should be preceded.
 while balance &gt; monthly payment subtract monthly payment from balance if balance &gt; 0 and balance &lt; monthly payment final payment is balance Something like that. It's often handy to sketch your code out like that, in actual words of what you want to do. If a sentence sounds like it has more steps than a single one, you can turn it into multiple ones: while not paid off calculate payment Here calculate payment c/w/sh/ould be broken further into steps.
Think about it this way, a function is easier to read if the whole thing fits on your screen.
So it sounds like you want it to end when the `LoanAmount` hits 0. A better comparison might be `while (LoanAmount &gt; 0) {do stuff}`
Could've also done it just like this: int i = 1; if (i++ == 1) { printf("i = %d\n", i); } This evaluates the `++` after `i` is compared to `1` and will print `i = 2`. Even though I would put the i++ not into the condition at all for readability.
I've found that this is an effective way to get my code in sync with my mental model. When writing a function, I write the pseudo-code as a series of comments first. Then I go implement each one of those steps in code leaving the comments in place. It gives a nice outline of what's happening, makes it easier to spot logic errors and then leaves behind a record of what you intend the code to achieve.
I’m going to recommend two things: 1. Use a debugger and step thru the code to find out where it is segfaulting, if you can share with us that much then someone might be able to help. Learning how to debug your code is extremely valuable. Knowing where it segfaults can help you find out why. 2. I would recommend purchasing O’Reilly Mastering Algorithms with C. This book is well written and solid, that I not only use the data structures and algorithms in my work but also there’s at least one iOS app by a major company that use code from this book that I copied.
Well, `gettext` is going to be standardized soon. So just use POSIX localization stuff, I guess?
Compiling with warnings turned on (`-Wall -Wextra -Og` for gcc and clang; edit: some warnings only happen when optimizing and `-Og` avoids stuff that messes with debuggers - also compile with `-g` to use them and other tools like valgrind) will help you see the problem too.
Sadly I don't think gettext is an option for this project because it's GPL. Or am I missing something?
Thank you! I didn't initialize temp, thinking that this line *temp = *ptri; would serve that purpose. But that's just a value, so it makes sense now that it didn't. Thank you again. [edited for formatting and because I keep finding that I want/need to elaborate:/]
Thank you for the book recommendation. I did step through with gdb, and went through the results with a developer friend, and he told me there wasn't any helpful information there. I'd paste the stuff here, but raevnos's comment solved my problem.
I am learning C as a university student...haha I am to create/maintain system softwares as coreutils, windows managers...! haha
Now that you have the problem solved, I'd recommend The C Programming Language, by Brian Kernighan and Dennis Ritchie. It's still the best book on C imho.
That one's definitely on my list:)
That's a very good point. I'm going to rethink my stance on this. Thanks.
Yes, exactly. Remember that defined behaviour = fewer opportunities to optimize. Consider a slightly contrived example like: if (n &lt;= 0) return -1; n++; x[0] = a; x[n] = b; return x[0]; The final load can be optimized if `n` is signed (because it's undefined behaviour). It *cannot* be optimized if `n` is unsigned (because behaviour is defined, so x[0] and x[n] are assumed to be possible aliases).
That's exactly what i did :D Thanks anyways!
This is an excellent tutorial btw.
A pointer is a variable like any other variable and has an address in memory like any other variable. Variables store values of a certain type (int, char, etc..) at their assigned memory address. Pointers store memory addresses of a certain type (int, char, etc..) at their assigned address. So, when you declare a pointer in C the compiler finds a memory location for that pointer and when you instantiate that pointer it stores at that memory location the memory location of a variable of a certain type as defined when you declared the pointer.
http://cppcheck.sourceforge.net/demo/ says Cppcheck 1.82 [test.cpp:5]: (style) Variable 'temp' is not assigned a value. [test.cpp:14]: (error) Uninitialized variable: temp Done! I can't believe that a C compiler does not print any warning. For gcc the warnings are here https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html. With gcc use at least -Wall.
Yes. The best one out there IMHO.
I have a struct for matrices, which looks the following. typedef struct Matrix { unsigned int cols; unsigned int rows; float** data; } Matrix; I create a matrix with: Matrix zeros (u32 m, u32 n) { Matrix mat; mat.cols = n; mat.rows = m; mat.data = (float**) calloc (mat.rows, sizeof (float*) ); unsigned int i; for (i = 0; i &lt; mat.rows; i++) { mat.data[i] = (float*) calloc (mat.cols, sizeof (float) ); } return mat; } And then I can access the entries with: Mat.data[i][j]
And, this answer begs the question, "can you have a pointer that points to the memory address of another pointer?" The answer is yes! You can have any number of indirection (pointer to pointer to pointer to...) This is how you can have multidimensional arrays. You create a pointer to an array of pointers that each point to an array.
The fuck is so funny?
Our software is (mostly) written in C - which is why we're looking for C programmers. But it's not about writing on a C compiler or anything like that, sorry if it was confusing. A list of our current projects can be found here: https://ccextractor.org/public:gsoc:ideas_page_for_summer_of_code_2018 If any of those sounds like something you could want to work on please get in touch with us. 
Careful: `int` is signed, `size_t` is not. I may matter depending on the use.
I brought up clarity just in case that was another reason why you preferred passing by value over passing by reference. You and I must come from completely different worlds. I've worked on an embedded system where both time and space is critical. Doesn't make much sense from an embedded system to not pass in pointers.
It is his choice, but it's REALLY not worth it, if a user of his library uses it expecting a terminating NULL, he's fucked, and that goes for using pretty much anything written to handle strings since C was invented.
Are you planning on handling Unicode or just ASCII code pages?
I'm REALY impressed with how thorough your post is dude, great job! &gt; Multiple variables can be declared on the same line except in structs. I disagree, declare variables where you use them, except the return one which has to be declared at the top. &gt; Doxygen tags should be proceded by an ‘@’, not a ‘\’, i.e. @brief is good, \brief is bad. I agree. &gt; Use snake_case for variables, PascalCase for structs and NameSpaced_PascalCase for functions. Fuck no, I use PascalCase for pretty much everything, tho in StringIO I am using NameSpaced_PascalCase for the functions, but only because the various Unicode formats require such similar operations. &gt; Prefer calloc to malloc, unless the allocation is very large and it’s being called in a performance critical area. I mostly agree with this, tho I'm more militant about it, I refuse to use malloc at all. &gt; Try not to initialize variables when declared to 0/NULL/etc… if those values are not directly used later on. This prevents useful compiler diagnostics regarding undefined behavior from being suppressed. Good point, I NEVER remember to do that tho. &gt; Always prefer DescriptiveFunctionNames(…) to c_hakr_fnames(…). I agree, I do try to minimize the length of the names tho, I've used a thesaurus a few times to help... &gt; Never used unsigned when you can use an int. The reasoning behind this is that type-promotion in complex statements involving signed and unsigned values can be confusing, compiler-specific, or even lead to undefined behavior. long long signed int is large enough for most use cases, and signed ints are more versatile in generaal than their unsigned counterparts. Note that there are times that unsigned values should be preferred, such as storing very large values, interfacing with certain library APIs, or working with bitmasks. I disagree with this, I NEVER used a non-u/intX_t type (well, except bool, and my own types I guess...) I try to approach this thinking about what i'll need, like if it's an index into an array or I otherwise know it will never be negative, it's unsigned, for more general math functions (like integer versions of Pow, log2, etc) I tend to use int64_t. &gt; Never use /* block comments */. I try to not have any comments in my code except as placeholders while building something, I comment my code in the headers, and it's extensively commented there. Using descriptive names helps an absolute fuckton. Also, I usually add some whitespace between "blocks" in a function to help separate out when one process starts and ends from the next. &gt; Indentation: Use 4 spaces, not tabs Yup, I tried using tabs for a while but honestly it completely destroys the formatting of my code, so I switched back to spaces. While we're on the topic of formatting, I like to have my headers function declarations line up, so I'll space out the widest function's return type and set all the other functions to match it's width so everything in the file lines up, I'm kinda anal about header formatting ngl... &gt; Max 79 character line length Nope, I write functions so that one operation takes up to one line, occasionally there is some overflow, but then I try minimizing the variable names and whatnot to get it to fit, and I'll stop and let the overflow stay before it compromises the readability of my functions and variables. &gt; Opening braces on the same line, closing braces on their own line… I agree. &gt; …except when it comes to functions NOPE. &gt; Always use braces with control structures Absolutely. &gt; Max 3 control-related indentation levels of the same type, 2 of different types Nahh, that's too meticulous for me, I write the damn function, if it requires 4 levels of control statements, that's what it takes, I'm not gonna redesign an algorithm to stick to such an arbitrary rule, tho I'd probably try making it easier to read with some of the other tricks I already outlined. I mean if you stuck to this rule, how would you read a 4D array? &gt; Both ‘switch’ and ‘case’ share the same indentation I disagree, tho I tend to avoid switch statements anyway, if/else just flows with the way my brain works more. &gt; Indent subsequent lines of long statements that are not in control structures once I don't do this, I tend to wrap long lines in parenthesizes. &gt; Also, in your example you show you using the not operator, I know everyone circlejerks about that being the one true way, but I find using `X == (true|false)` to be easier to read, fire away boys. &gt; All parameters of long function signatures get their own line, indented twice No, I fucking HATE that, I'll rename variables or even use a struct before I do that. &gt; /////////////////////////////////////////////////////////////////////////////// /// I fucking HATE that too, I do: /*! @header StringIO.h @copyright 2017+ @version 0.8.0 @brief This header contains types, functions, and tables for Unicode support, including UTF-8, UTF-16, and our internal format, UTF-32. */ Also, I put `#pragma once` before header guards, they're just a fallback for me. Oh, and I wrap all of that in: #ifdef __cplusplus extern "C" { #endif // Blah #ifdef __cplusplus } #endif Also, I tend to put types at the very top of the actual code section (not pragmas, macros, the header comment, etc), followed by structs (and not the whole struct, just a typedef defining the name) and enums, then function declarations. As for the source file layout, I generally follow what I just outlined, but I'm going back and forth on organizing the functions by their return type (should all the UTF8 functions be first followed by the UTF16 ones, etc; or should all the GetCode(Unit|Point)Size) functions be together, etc. So, idk what to call that, organizing by return type vs what the function actually does? BTW Here's a good example of how I declare my functions /*! @abstract "Gets the number of Unicode codeunits in the UTF8 string". @param String2Count "The string to get the number of codepoints in the string". */ uint64_t UTF8_GetSizeInCodeUnits(UTF8 *String2Count); &gt; I encapsulate global static variables in a struct named global and initialize them immediately. If they require more complex operations to set/clean up, I add functions named StructName_Init and StructName_Quit that should be called first and last when using the API. That's interesting, I've got a couple global variables, I have them declared as static variables in the source file only, and use Setters on them for internal use, but I don't put them into a struct. for example in my logger I've got: `static FILE *Log_LogFile = NULL;` `static UTF8 *Log_ProgramName = NULL;` &gt; Function definition layout For me, I set all my functions up so that the structs are the first variables, followed by the most consisent ones to the most variable from left to right that way you only have to scan the end of the function call to see what's change. As for the source layout, I make sure none of the structs or arrays are NULL first, then check that all the other variables are in a sane range, then write the code in that block. then when the block of code is done, I go ahead and set up all the error calls because I figure that erring out really shouldn't happen much, so let's not postpone the code from running (that probably doesn't matter much, but I figure being consistent helps the branch predictor) 
No. Your program will take up exactly the number of lines it needs to accomplish it's task with the tools you have available. Just remember to put your reusable code into libraries and call them, instead of hard coding the same stuff over and over.
There are 2 main categories of pointer use. 1: Arrays. 2: Structs and types in general. 3: This kinda goes into structs, but when you want to access data that you only have 1 copy of, or you don't want to copy a whole damn struct, etc.
I am graduating this summer and don't have a job yet. Can I still join?
Here is a list of threads in other subreddits about the same content: |Title|Subreddit|Author|Time|Karma| |---|---|---|---|---| |[How do you debug on MacOS High Sierra?](https://www.reddit.com/r/c_language/comments/7zc2dj/how_do_you_debug_on_macos_high_sierra/)|/r/c_language|/u/tehcyx|2018-02-22 12:16:51|1| ---- I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20user&amp;message=tehcyx)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20subreddit&amp;message=C_Programming) Now you can remove the comment by replying delete! (op only) 
Your include is fine. You are missing a close bracket, check your code.
I'm aware, but not the help i was asking for, but thank you.
Your code compiles and runs fine otherwise, so I'm not sure what you're asking for
You need to make 2 arrays; one for high, and low. Indexed by `i`, then at the end where you print your stats, put the 2 stats instead in a for loop which then recalls each array index for min/max respectivley
Yes as long as you are enrolled in uni on April 23rd. That's the cut off date.
I used C for HPC and currently desktops. Memory usage never been as much of an issue as locality to me.
Xcode is free and is my preferred IDE. When you run from Xcode you run in the debugger.
You can use 8 tones to represent each bit, DTMF tones for example could work if your recorder has the fidelity. Not sure what this has to do with C. You'll need to use FFT to extract the bands or use bandpass filters
ANSI C = Embbed software C99 = System software C11 = Personal projects and small projects ( please no)
Will check that out. Can it use my Makefile or does it run CMake?
You're incrementing i every loop but aren't filling in s[i] every loop.
The point of this project is to record in high fidelity, but allow for an insane amount of data decay without loss of data. I was hoping to have every 100 milliseconds be one bit. I'm looking for the most redundant way to store this possible. Thanks for the input!
Why does it have to be 100ms? &gt; My plan is to use magnetic tapes, but the only way that I can think of to get the information onto these magnetic tapes is by playing it through sound. That's legit. Very early PCs used cassette tapes and modems transferred data over analog phone lines using sound. Have a look at this: https://www.soundcardpacket.org/ -- looks like it might be a good place to find inspiration.
Hi, You can use lldb on mac. [this](https://lldb.llvm.org/lldb-gdb.html) might be useful.
Go with C99 or C11. C89 lacks useful things like being able to declare variables at point of use, designated initializers, and a bunch of other stuff.
you need a modulation scheme for converting digital bytes into (initially) a PCM sound file of fixed length, ie: (16 bits * 44100khz)/10 = 100ms. Once the pcm files are written they can be converted into a lossy but perfect quality mp3. the decoding process would read the series of audio files in sequence via a line-in audio card input, demodulating each chunk back into its original digital format. Dig into PSK and the gnuradio source for some ideas, this is a fun and rewarding project.
Oh, I thought &gt; into a series of 100 millisecond long tones, Each of which represents one byte meant 100ms tone = one byte. You need to edit your post
Why not C11?
100ms per bit? One tone for 1, another for 0. Or any sound and no sound.
C99 is the only reasonable minimum. The big leaps were between pre-ANSI and ANSI and then to C99. On the other hand, every reasonable compiler supports C11. But the differences between C11 and C99 from the point of view of a beginner are not huge. The things you might run into as a beginner in C11 are anonymous structs and unions, pretty much everything else is too subtle or specialised for beginners or no one uses it (like annex K or threads).
ANSI C = nowhere except extending legacy codebase. C99 is definitely a good place to start.
Embedded software engineer here; we use c11 (c99 + anonymous structs and unions really) on ARM Cortex-M w/ GCC. Really no reason to use ANSI unless you're on something ancient or really want old compiler compatibility for a lib. Designated initialisers and such are just too useful.
The differences don't really matter for an absolute beginner. The extensions are mostly extra library functions and a few extra language features. They are easy to learn and don't really change how you write programs.
What you are trying to do is a a well-researched topic. It's really not easy to find a good encoding that accounts for the following problems: * noise * tape stretching * resampling at different points Read [this article](https://en.wikipedia.org/wiki/Compact_Cassette#Data_recording) and [this one](https://en.wikipedia.org/wiki/Magnetic_tape_data_storage) for some ideas. Note that it's unlikely that you are going to be able to store more than a megabyte of data on a cassette tape.
I don't know enough about SSE instructions to contribute much to review, but a SIMD matrix library for C is definitely the sort of thing I'd use once it's done. The full maths libs like GSL or clapack feel like overkill for 3D graphics, and kazmath, while otherwise a fine, easy to use library, doesn't use SSE/intrinsics at all. 
The majority of differences are small but useful quality of life improvements, like safer library functions and more flexible initializers for structs and unions. You won't be missing some huge, paradigm shifting language feature, like you would be in higher level language like Java. Even MSVC, which has notoriously bad c support has tentatively moved on from c89 with features like declare-anywhere and stdint.h, and since visual studio can debug clang now there's no reason to use it anyway. Use a decent compiler like GCC or Clang, and use all the language features you want/need. The differences are not huge.
I dare say ASCII C is outdated, there are things like not being able to declare counter variables in for loops that make it seem really old. I'd suggest learning C99 plus there are some great books out there that are a bit cheaper since they're older. 
do you have any suggestions on what else should be added? I'm not sure what else to put in it. 
Its no surprise... Of all the different languages I've tried over the decades, C is probably one of the few genuinely portable compiled languages. While the OO paradigm is seductive in the long run its a largely unnecessary abstraction, (I've yet to see a CPU with an OO instruction set) While a whole raft of languages are scrambling to add the latest fad feature, C has remained stable, and oh look I think is still working as well as it has for decades 
I'd say perspective, orthographic, and lookat matrices. And unless I'm being dense (very possible) I can't see rotations, or vector cross-products there either, which would be essential. [KazMath](https://github.com/Kazade/kazmath) might be worth cross checking against, it has everything I've ever needed.
It's a simple and nice language. Minimalistic. It's however very easy to create hard to detect bugs and security vulnerabilities in larger code bases.
thank you, I'll work on getting those done as soon as I can. I appreciate the feedback!
I've not got time to look at the whole program right now but I think you should look in to `isspace` in `ctype.h`. Another thing you might find helpful is to use character literals instead of their numeric representation, e.g. if (c &gt;= 33) /* Not very easy to understand */ if (c &gt;= '!') /* Fairly easy to understand */
No problem, best of luck with the library!
I disagree. Declaring inline variables (C99+) makes a huge difference, especially if you've tried other programming languages before learning C.
And sometimes it causes subtle bugs.
What you mean?
Having seen the leader snap off on everything from old 800bpi reels to DLT tapes along with the tape in cartridges ripped out and crumpled your approach to storing 80 bits per second (didn’t the ZX81 do 300bps?) is highly unlikely to be “extremely robust.” If you spend some time reasearching the topic you’ll see many systems have evolved to spread redundant data at high speed over a much larger surface area to tolerate significant media defects, and even then you’ll need significant experience in error coding and authentication to make sure what comes off the tape is really what went onto it. Even the systems designed by industry leaders have problems in practice. By all means, study up on the evolution of backup over the ages, but this may not be a decades old wheel worth reinventing.
100 milliseconds is just an arbitrary length of time that I figured it would be somewhat redundant just because of the amount of time that the sound would be played. It's just enough to account for some static.
Well, I'm not trying to reinvent the wheel. I did do quite a bit of research on this, although not as much as you're showing above. Just expecting this to store a couple kilobytes of data per tape, and I was going to have three redundant tapes per upload. I figured that way if I don't have the absolute best error filtering program, I can still account for at least 30% loss of data.
Ah. Have you looked into Modified Frequency Modulation yet?
That breaks really quickly when the tape stretches. You need a way (e.g. Manchester coding) to recover the clock signal.
This was going to be cold storage. Write once and leave like a digital time capsule. The research I've done leads me to believe that it could last 50+ years if the storage box is built right...
Paper (or even better, parchment) is projected to last more than 1000 years if stored dry (not the most difficult condition to achieve).
It's just a run-length encoding scheme that would probably work reasonably well for that sort of thing. At one time, most hard drive controllers used either RLL or MFM encoding. Iirc, you probably have to choose between phase-shift keying and frequency-shift keying and select a run-length encoding scheme. There is a ton of literature available but most of it will be quite old. The ACM digital library is a gold mine if you have access to it. 
I'll take a look, thanks!
Sounds like a fun idea! I'm looking forwards to your progress reports. I'm always for quirky ideas just for the fun of doing them.
I think I've spent under $15 so far, and I have all the hardware except for the cassette tapes and a box to store them in (which I'm actually going to hand-make to be very protective by having it wine and unwind the tapes once a year to prevent them from sticking to each other and hold them vertically). Overall the project should cost less than 30 bucks total. :)
Stretching tapes is half the difficulty of recording data on tape. It's a really difficult issue to work around.
Yikes... There are solutions though, correct?
Yeah. You can use encodings that allow clock recovery, like Manchester coding. 
Alright, cool! I'll add that to my list of readings.
What if you stick to a standard like misra c? Wasn't it designed for provable correctness?
So C99 + custom libraries. Most C99/11 features are easy to mimic on C89. To be fair, most of those are pretty much-known way before c99/11. They just made it a "standard"! 
Arduino isn’t straight C++ though...you can write C code on it as well.
Not for provable but for easier checking. There was also Checked C by MS Research.
^* people who have no idea how to properly do embedded stuff. Also they don't have *that* big of a share, especially for relevant code, most is just toys.
It's realtive. It's easier to create bugs and security vulnerabilities in C compared to Java. 
Looks like the recommended book on the sidebar is for ANSI C, do you have any C books using the C99 standard that you recommend?
Hi Andrew. I think Zig is really cool! My language will be a little more like https://bitbucket.org/purelang/pure-lang. It's just an idea for now, but it would be cool to build a meta-language that makes something a bit like Zig.
As far as I can tell, ANSI is still the primary in Automotive Embedded. Was recently working on a PowerPC chip, and used ANSI. Recently switched to Infinion Tricore, and still used ANSI. Whether that was becuase we were used to ANSI, or finding newer validated compilers is difficult.
I would recommend using a C99/C11 compiler, but sticking with ANSI syntax. Outside of the desktop world, there are still plenty of places where ANSI is used. By sticking with some of ANSI's oddities, you won't be confused if you're dropped into an ANSI situation.
&gt; (I've yet to see a CPU with an OO instruction set) [Java processors](https://en.wikipedia.org/wiki/Java_processor).
&gt; (I've yet to see a CPU with an OO instruction set) [Java processor](https://en.wikipedia.org/wiki/Java_processor)
I wouldn't worry about it too much. Resources that apply to ANSI C89 generally carry over well to later standards. There really isn't *that* much new above C89. Not when compared to changes between Python 2 and 3, or different Java version. One note about C11: while compiler support is generally good, library support is still a bit spotty.
*and there by leaving garbage data in the string. The garbage data is likely to be a bunch of zeros, aka. null terminators, which are used to mark the end of a string in C.
There's no such thing as a random fixed value, it's pulling that data from somewhere. And as everyone else says, post more or all of code.
The gold standard for a newbie that wants to learn c99 is [K.N. King's "C Programming: A Modern Approach"](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504). 
If you use a modern version of gcc and don't set a standard, then it defaults to `-std=gnu11`, which is C11 with GNU extensions. Personally, I almost always set `-std=c99` for when I'm forced to use gcc. I may be wrong here, but I think clang's default is C99. I always set it regardless.
Are these song lyrics or something?
I really want to like Rust. [But the syntax makes no sense.](https://orangehattech.com/semicolon) C has a lot of weird and wonky syntax too ("return (0,1,2);" is valid C) but most of the weirdness is less serious, and easier to avoid.
haha...yep, song's name is: "You arrived too late" by C_Master_Race featuring Assembler King_of_Machine 
`getchar` returns the character code of the character it reads; for the computer, the character is just its character code. If you want to interpret the input as a number, you have to do so manually, either as /u/boredcircuits said or by using a function such as `atoi` or `strtol`.
I think they need to work on their lyrics.
This article (PDF warning) has a compelling argument for why C dominates. https://www.cl.cam.ac.uk/~srk31/research/papers/kell17some-preprint.pdf
Looks like you haven't looked at Rust after it reached version 1.0 (when its syntax was finalized). That article doesn't apply to Rust anymore, most of its "valid" examples don't compile. For example: fn example() -&gt; i32 { let x = 5; if x==5 { x + 5 } x } gives the error: error[E0308]: mismatched types --&gt; src/main.rs:22:9 | 22 | x + 5 | ^^^^^ expected (), found integral variable | = note: expected type `()` found type `{integer}` The obvious fix is to add `;` to the end of that line, which makes it very similar to C's syntax. 
Use the gdb program. It’s the defacto tool for C debugging. For memory errors, also use valgrind. C debugging requires a knowlege of memory and low-level function calls. 
Indie band, you how they are...lame!
&gt; Some Were Meant for C +1 
That sounds plausible. The number "0.9" sounds familiar. I'll put updating this article on the Todo. I do like the update you mentioned, that seems like it simplifies the semicolon rule.
As already mentioned before, Rust had (and still has!) some quirks but they were mostly ironed out in 1.0 are are by now, the syntax is actually really beautiful.
I know this is not completely serious, but the points raised aren't really true anymore. Because there are not many learning or willing to learn C anymore (sadly, imho) -- but this is different on the Rust side (that's actually good!). I know people who are paid well for their Rust job and many new projects are starting with it, especially in the security dept. But not, it's not gonna be in a year or so.
I’d prefer [strtonum](https://linux.die.net/man/3/strtonum). Hard to use incorrectly. 
nor in 5 years or so! 
But not a standard function.
Walk through the example please, because I don't see where being signed or unsigned makes a difference. Unless I'm mistaken, this will only be true if x == 0, and it doesn't make a difference if x is signed or unsigned. 
There it goes. I changed the texts to "Something" just to avoid people using Google to find it.
Nope, will try to do that. Thanks for your help.
Q tipo de arquivo esta sendo lendo?
Tu ta usando algum editor com lint ou notepad da vida? Provavel q nao seja soh isso mas tem esse erro aqui printf(Something.\n"); E duas variaveis unitilizadas(isInRanger e bestMonth) Recomendo GNU Emacs! 
Go ain't bad too, but it's a different aim. 
Nope. Goland fits the gap between Java/C++ and C/Rust...
tô usando gedit mesmo grato pelo link e pelo toque das variáveis!
That doesn't mean it will take you longer to create a bug or vulnerability.
Vei recomendo tb o Atom. Eh um baita editor facilimio de usar ! 
I don't work with anything automotive, more automation and iot (mostly LoRa/LoRaWAN right now), but that's interesting to learn. We're pretty much exclusively ARM, so availability of modern compilers isn't an issue at all. Verification and certification would definitely be reasons to stick with ANSI if they're required and hard to find, but as you say, it could also be the momentum of the existing codebase and what everyone is used to. It's not a huge change, but you still don't want to upend things on people without a good reason.
GDB is indeed the debugger, but it is often easier just to printf the stuff you want to see, especially if you don't already know how to use gdb.
Find the length of the file (with seek and tell, O/S specific calls, etc. Process the file knowing its length.
To quickly go to the end of file, use `fseek` with `SEEK_END` and offset 0, e.g. fseek(file, 0, SEEK_END); This seeks right to the end of the file. I hope I understood your question correctly.
I started with Python and then Java. Most universities are worthless though, they teach you the absolute basics on 3 or 4 languages and you never learn anything useful. Java at least has a huge standard library that could literally build a curriculum around, instead we're learning the basics of 2 niche functional languages.
sizeof(char) is not garenteed to be 1 i think the only thing that is missing is some tests, most of the issues you are talking about are actually optimizations, and you know what they say about premature optimizations! 
Somebody recently asked me what array2D[x,y]; does, as the compiler did accept it. For people that come from languages with built-in 2d arrays, it is absolutely not obvious what this does, why it compiles and then does weird things.
&gt; They are teaching Python, PHP, and Goland here. I am studying C by myself! hehe
I took a university c++ course (in fact I did two, but I only remember the exercises from the first one really and this was years ago) I now work with C and these would work fine in any language really, we did things like: - an algorithm for checking if a year is a leap year - converting units and or currency - noughts and crosses (tic tac toe) which involves printing to screen, taking input from a user, and arrays and logic. This can be extended to something more complicated like battleships (two human player, but I didn’t get it to work!) - read in some data, do something to it and output. I think this was in the context of a ‘picture’ (numbers 0-9 representing white to black in grey scale as a text file). You had to invert the greyscale and turn it upside down, but that can be extended. Obviously other than the first ones these are a bit advanced! But hopefully some ideas 
char filePath; scanf("%s",&amp;filePath); Take a good look at these two and figure out what's wrong.
To continue my rant, you could build a curriculum around Java by teaching classes on Java File I/O and the new I/O libraries, concurrency, network programming, Android development, and GUI design/development. I'm sure anyone with advanced knowledge of other languages can throw together a curriculum on them as well. Instead we learned how to do the same basic bullshit in several languages - breadth with no depth. I can write a for loop in Java, C, C++, Bash, Python, and Javacript but I was never taught how to use a ZipInputStream correctly and the ways it can sometimes fail to read (and how to prevent that from happening). The waste goes on and on. If everyone already knows Java, why spend 5 weeks going over stuff that is 85% the same syntax in a 200 level class on C or C++? Why not point out where it differs from Java and then move on the important things? 
Eh, so you say Go "fills the gap between Java/C#/C++ and C/Rust" and when I say "Rust could replace C" -- how do these statements contradict each other? It's a different aim then -- Go fills the gap between, Rust replaces. I mean, I don't agree that Go fills the gap -- but I don't see how you are arguing against me there. Also I'd say Rust also replaces C++ and some of C# ... (hopefully!)
Unless you're using a 1-user operating system with no background services, the file can change length while you are reading it.
So get to know better the tools used by a specific PL is more important than learning another PL basics. Do are all Java tools proprietary and require license to use?
I didn't say you said anything against Rust... . But what I'm wondering is: Me: Rust is trying to replace C. &gt; Go ain't bad too, but it's a different aim. You: &gt; Nope. &gt; Golang fits the gap between Java/C#/C++ and C/Rust... So you argued against me saying "Rust is trying to replace C and Go has a different aim" by saying "Go doesn't try to replace C but to fill the gap". This doesn't make any sense to me honestly. ---- Also there ARE jobs available.
&gt; Also there ARE jobs available. lmaooooooooo
`sizeof(char)` is also a lot more meaningful and explicit than 1.
As I said, people are working for good money here. So yeah, please derail this further, I guess?
&gt; sizeof(char) is not garenteed to be 1 Yes, it is. From the [C99 standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf), section 6.5.3.4, paragraph 4: &gt; When `sizeof` is applied to an operand that has type `char`, `unsigned char`, or `signed char`, (or a qualified version thereof) the result is 1. Although I don't think it's terribly bad to multiply by `sizeof(char)` if you really want to convey the idea that you're allocating space for chars. 
Show a minimal complete example of your code, and remember that C has no boundry checks.
He's saying `dynstr_cmpr` is "broken" because it sorts "bee" before "albatross" (because of the lengths), while everyone agrees that "bee" should come after (because of the first letter).
I'm just going to drop Beej's guide here and walk away whistling... http://beej.us/guide/bgnet/
You would like to write a program that allows you to type and edit an encrypted message. You would also like to write a program that decrypts the message so the recipient can read the message. The encryption program must provide the ability to enter multiple lines of text, delete a previous line of text, and finally end entry to this message and commit the text to a file. All lines must end in a single newline when written to file. The program will include three commands: /add [line of text] This command adds a line of text to the lines to be written to file. /del This command deletes the previously entered line and does nothing if there are no lines to be deleted. /end This command ends transmission of text and all lines entered are written using rot 13 on the text to a new file. The decryption program takes one argument, the file to be deciphered, and writes it to standard output with the original text that was written by the sender. ——***—— Optionally: Forbid printf and/or scanf family of functions. Forbid using FILE types and associated functions like fread, etc. Remove the encryption and second program for recipient. Please let me know if something is unclear or if you need more information.
Consider a 32-bit integer. If `x` is 1073741824, then `x == x * 5`. This behaviour is guaranteed by the standard because of how overflow is defined for unsigned types. I.e., `x == x * 5` *must* evaluate to true when x is 1073741824 on a 32-bit system. That limits the optimizations that a compiler can do when trying to optimize that expression. For a signed int, overflow behaviour is undefined. That means, when the compiler is trying to optimize an expression like `1073741824`, is it allowed to *only* consider values where `x * 5` would not cause an overflow. There is only 1 possible of x where `x == x * 5` would be true *and* where `x * 5` would not cause an overflow, which is where x is 0. That allows the compiler to optimize more aggressively.
55%7 is 6 so it has to go case 6: 
x % 7 -&gt; 55 % 7 = 6 The value of your switch statement is 6, therefore case 6 is being executed.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
This subredddit exists to discuss the C programming language. Please direct questions about C++ to r/cpp_questions. That being said the answer is 17 because of the nature of switch statements. Because `num` is 4 you start at `case 4:` and execute every line until the next break. So you end up with `10 + 3 + 4` or `17`.
Forgetting to initialize them, too. It's too bad turning on maximum compiler warnings isn't like lesson 2 in C classes.
The current implementation only supports ascii. Perhaps supporting unicode strings could be added in the future. Pull requests are welcomed!
Pointer and Arrays could have a simple exercise like _print an ascending staircase using only one `for` loop_. On the face of it this is a no brainer and relatively simply task, but the caveat of only one `for` loop means you have to use pointers to print the staircase correctly. It's also a great opportunity to learn about the power of `printf`! Example code: #include &lt;stdio.h&gt; #include &lt;string.h&gt; void answer(const char *text){ int l = (int)strlen(text); for (int i = 0; i &lt; l; i++) { printf("%*s\n", l+1, text + (l - i - 1)); } } void no_brainer(const char* text){ int l = (int)strlen(text); for(int i = 0; i &lt; l; i++){ for(int j = 0; j &lt; l - i; j++){ printf(" "); } for(int j = l - i; j &lt; l; j++){ printf("%c", text[j]); } printf("\n"); } } int main(const int argc, const char* argv[]){ (void) argc; // silence warnings no_brainer(argv[0]); printf("------------------\n"); answer(argv[0]); return 0; } And example output: e ee ree tree ttree nttree inttree rinttree printtree /printtree ------------------ e ee ree tree ttree nttree inttree rinttree printtree /printtree ./printtree
Quick note: `getchar()` can return any value 0 through `UCHAR_MAX` (usually 255), *or* `EOF` if it hits end-of-file/-stream. `EOF` should not be mixed with `char`s, and you should always check for it so you don’t end up with a bunch of garbage input.
There is a common subset of C and C++ that you can use with any C or C++ compiler. The Arduino IDE uses the g++ compiler, and while the Arduino standard libraries don't use a *lot* of fancy C++ features, some C++ stuff is fundamental to it.
"A Tour of C++" by Bjarne Stroustrup
The superior race of C programmers shall never corrupt themselves with the disgusting taint of C++ heathens. Take your query elsewhere, you object-oriented mutant.
lmao, harsh
sorry to taint the greatness of the K&amp;R with the gibberish of C++, but when your going for an internship and they want C++, you refresh your C++. thanks for speaking my (real) language. 
For realzies tho... “A tour of C++” is legit. It was written by the guy that wrote C++ and is in C++11 standard. It’s pretty much a C++ mirror of K&amp;R.
ordered it, thanks for the advice. 
&gt;&gt; very similar &gt; let, i32, returning without the return keyword, `-&gt;` meaning something completely different
What's everyones opinion on [C2](http://c2lang.org/site/introduction/code_fragments/)? I want to like it, but I'm not a fan of the `func` keyword, `i/uX` for int sizes I could get used to, and a bunch of other more minor syntax issues.
lol no generics