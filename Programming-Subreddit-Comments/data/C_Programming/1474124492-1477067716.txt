Hey, sorry about that, I've updated the post with the code.
Just updated the post with the full code. 
I'm working on an implementation of hierarchical state machines from uml 2, or statecharts or whatever you want to call them. All the implementations I found were very simplistic, no internal or deferred events, no transition actions, no state history, etc. Also, I'm targeting embedded, and as a rule refuse to use malloc/free. So yeah, trying for a full implementation of an HSM library, that allows static allocation of objects with full data hiding. Still need to implement forks (should just be a transition with multiple target states), joins (trickier), and final states (really just an implicit join). Needed (well, wanted) to hide the implementation details while still allowing objects to be statically allocated by the caller, so I made a little adt.h helper that creates a void* array element to hold the private data in whatever public struct, then provides a dereferencing macro for the private data and a couple helpers to make sure your void* array is the correct size. That was fun... can't use sizeof in the preprocessor, so made another helper, cassert.h (compile-time assert), that evaluates a boolean expression and uses it to dim an array named with file/line macros, basically tries to size it as [2 * !!(b) - 1]), which then fails compilation if b is false. A simple HSM implementation with recursion can be done in well under 100 lines. Fully featured with no recursion is turning into quite a bit more... 
Looks like you're right. I'm not sure when I started using the braces but it was quite a long time ago. Guess it's time for a refresher. 
Pointers are a fixed size, but can be used to access massive data structures without copying the data structure. They can even point to themselves. This makes them fast and powerful.
I write pretty much everything in C, so that's what I use for small programs. I'd be much slower using anything else.
gdb can do that. Set `disassemble-next-line` to have that behaviour.
Just about every debugger has that option.
Yes, but not every time. I like the idea of "One program solves one problem in a simple way.", for example CLI-programs. But some problems are better solved if you don't write many small programs.
I believe that is TUI (text-user-interface) mode which you can enable by typing `tui enable`
Not an IDE, but extremely cool: https://gcc.godbolt.org/
can it show the memory addresses used as well?
http://www.delorie.com/gnu/docs/gdb/gdb_56.html https://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_chapter/gdb_9.html
You lose the `const` qualifier with the `p=&amp;a;` statement. GCC 4.9 outputs that as a warning at the default warning level. Try using both `const int *p;` and `int* const p;`. The former will error on `(*p)++;`, the latter on `p=&amp;a;`.
It's not that the peice of memory that stores your '10' is const, it's that the name 'a' is const. Anything you do to 'a' is protected by const, but as urisma says, when you use 'p' instead you loose the protection.
Of course. Just try it out!
&gt; why afterall both 'b' and 'a' point to memory address of array Because you don't change either of them? Note that you can't add to `a`. `a` is an array, you can't add to arrays. `b` however is a pointer. You can add to pointers to change where they point. Under most circumstances, an object of array type is implicitly converted to a pointer to the first element of that array, but the result is not an lvalue, so you can't assign to it. I hope this explains your confusion.
`a` is an array. It sounds like your mental image of an array is a pointer pointing to some memory block. However that is wrong. The array is actually the memory block itself, there is no pointer. edit: -3 for truth, this sub is amazing sometimes. 
`p=&amp;a;` is an error. The output of programs that contain errors is meaningless. Pay attention to compiler messages. Treat any message as an error unless you are 100% sure that it is not.
```const int *p;``` is a pointer to a constant int. The pointer can be changed, but the value at the pointer can't. ```int * const p;``` is a constant pointer to an integer. The value at the pointer can be changed, but the pointer can never be changed.
I mean I made a go fish game for fun last semester? My programming lecturer said it was the biggest code anyone had ever shown him in this paper
 *(b + i) is actually the same as `b[i]` and is commutative. The zeroth element of an array is a pointer to itself. b=b+1; is valid, because a pointer to array was passed in. However, since the declaration of `a` in the main block, is declared as fixed, you cannot change that. Hence adding 1 to `a` will fail. But if you assign a pointer variable to `a`, then add one to the pointer variable, it will work. int a[5] = { 1,2,3,4,5}; int *p = a; p = p+1; // Guess what happens there? This is about declarations vs definitions. Important topic of C to understand, and that is the pitfall there in the code, in your attempt to understand it.
The type of `a` is `int[5]`, but the type of `a + 1` is `int*` because an array will "decay" to a pointer in certain cases, one being if you try to do pointer arithmetic on it. You can assign an array to a pointer, but you can't assign a pointer to an array because it has no way to check that it's pointing to a block of memory that is the right length. 
Thank you very much!
Thank you !
Thank you !
I have been using this so far but was interested in seeing memory addresses. Also have been using Vim to convert C into assmbly
Musl is great, but it is no where near as well used. Least not in any GNU/Linux system I've dug into. Lots GNU extensions used in lots of places, so it may not just work swapping. But Musl is much smaller and has a stable ABI, so it's quite cool for embedded work.
Why would you want to do that? You should not depend on any particular standard C library being used. That said, I program on FreeBSD, so I use the FreeBSD libc.
I wrote "maybe". musl isn't allways faster, but sometimes. But the binaries are much smaller. I know there are many features which are missing. musl isn't perfect, but it is very interessting as an alternative to glibc. 
My archlinux uses uClibc. That works well, but has some differences to glibc eg. `malloc(0)`.
Sadly, yes
A *trivial* statically linked musl program that is. Most of the size of a modern Linux binary comes from padding and the metadata needed for dynamic linking.
yeah... I still find that one amusing. Palm's general attitude was to not do anything unless the app told it to. This is great for battery life, but awful for up to date information unless the needed app is being used at that time. That didn't work for what we were doing and we had some partnership with Palm so we learned that there was actually a background thread like thing that we maybe could use. So I wrote an application that ran on that thread and every now and again would poll the server at a rate fast enough that it was useful (Might have been about every 30 seconds, maybe 180). As you might guess, this did affect battery life just a tad. I brought a T5 down from about 2 weeks per charge to 10hrs. Management was fine with it because it still cleared a work day, but they were aware of the impact and the value of push updates was more useful than battery at that point. Plus, our software suite pretty much took over the entire deivce (new launcher, all of the apps were ours as much as possible/reasonable, etc) so we had a bit of leeway Was a fun project in general. One of the most fun things I've worked on professionally. 
Say you run a service for painting fancy patterns on people's locker doors. Would you: * (a) ask for their locker number so you can go paint the door * (b) have them bring their locker door into you for you to paint 
Sounds like an impossibility. What is the exact wording of the question? If the ints are limited to small numbers , you can use a 3 dimensional lookup table.
&gt; I need your suggestion about what libraries can make C internet-ready for use in IoT applications. What exactly is ‚Äúinternet ready‚Äù for you? &gt; Is there some drawback to making exec calls to other utilities like curl or wget compared to using a library with similar functionality? The only drawback I see is that when executing other utilities you must be careful not to have argument injection attacks. For example, consider you use `wget` to download files for the user. Now the user specifies `-O/etc/passwd` as one of the file names to download and overwrites your `passwd` database. You need to avoid this, e.g. by passing `--` as an argument before all user-supplied operands. For HTTP interaction, consider linking against the libcurl. For the rest there are also many stable libraries. You should get used to every library having a slightly different API style. That's just how you program in C.
Thanks!
&gt; What exactly is "internet ready" for you? For now, I want a library that supports requests over HTTP, HTTPS, MQTT and logging over network (HTTP or MQTT etc., syslog, for now,doesn't serve my purpose) &gt; You should get used to every library having a slightly different API style. That's just how you program in C. :) Thanks! I was mainly wondering if there was an alternative which I didn't know about. I'll try libcurl, thanks!
HTTP [Kore](https://kore.io/) [Balde](https://balde.rgm.io/) JSON [Jansson](http://www.digip.org/jansson/) [YAJL](https://lloyd.github.io/yajl/) (Yet Another JSON Library) [jsmn](http://zserge.com/jsmn.html) XML [Expat](http://expat.sourceforge.net/) [Libxml2](http://xmlsoft.org/) [Mini-XML](http://www.msweet.org/projects.php?Z3) [ezXML](http://ezxml.sourceforge.net/) by order of preference. 
I am pretty sure doing this kind of thing is a bad idea.
&gt; maybe faster That's unlikely. Glibc has many speed optimizations that a library targeting embedded environments won't bother with.
It could be that your program runs as root.
We don't know the user running this OP's application. Also, I suspect that `/etc/passwd` was just an example to demonstrate a point. 
I'm curious why you want to use C for this? Is it just to learn C better? Your requirements don't really match up with typical use-cases for C (Speed requirements, bare metal environments, no existing support etc) What you're asking for is one of C's weakest points, using it to tie together multiple high level concepts is doable, but often much harder than using a higher level language. You might want to take a look at using python, it is supported at least on the Pi and ESP8266, and will have easy to use consistent APIs.
Here is the original Prompt: Given the length of the three axes that comprise an ellipsoid calculate the volume of the object and determine whether the shape is a spheroid (D), sphere (P), or a scalene ellipsoid (C). Course standards prohibit the use of programming concepts not yet introduced in lecture. For this assignment you can consider all material in the first three chapters of the book, notes, and lectures to be acceptable for use. ‚ó¶ The use of any logical operators, relational operators, or selection constructs would violate this requirement and result in no credit being awarded for your effort. ‚ó¶ The math.h library may be included and used only to access the M_PI constant. No other functions from this library are necessary to solve this problem. 
I've got the volume part down, its just the determination.
Sadly, bitwise are also banned. We are only allowed to use concepts we have covered in lecture, and that is not covered until chapter 4. 
Ah
Don't start with K&amp;R, it's not for beginners. The ultimate answer to this question is C Programming: A Modern Approach, by K.N. King.
I completely disagree (about K &amp; R^(1)); what version are you reading? The book breaks C down into its syntactic parts and uses very simple language; there's even a syntax tree at the back^(2) if you want a deeper understanding of how the syntax works in a logical way. * * * ^(1)Clarification about which book I'm referring too. ^(2)Spelling correction.
We do something like this at work. It only takes a union of the different packet types, and a way of telling which type each instance is. I fail to see the benefits of the preprocessor abuse here.
What do you mean by "deleting with 2 son"? We'll need a clearer explanation before we can help
The C Standard (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators) states: &gt; Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a string literal used to initialize an array, an expression that has type ‚Äò‚Äòarray of type‚Äô‚Äô is converted to an expression with type ‚Äò‚Äòpointer to type‚Äô‚Äô that points to the initial element of the array object and is not an lvalue. The zeroth element "decays" into a pointer of type denoted by the array.
I would very much argue that if you're learning to program for the first time you don't want to know about your compiler, or how linkage works. The whole beauty of _The C Programming Language_ is that it only brings those things up to give a little bit more context to what its suggesting. They say themselves^(1): &gt; C is not a big language, and it is not served well by a big book. __Chapter 4: Functions and Program Structure__ is a good introduction into how you should begin to think about writing applications and the book is littered with minimal examples basic enough to read without needing to understand what a computer is doing. While I am not suggesting that _C Programming: A Modern Approach_ is a bad book (I made no comment on it and I am, in fact, off to acquire a copy now), I am suggesting that people should learn to walk before they can run: a language and basic concepts before a full-blown analysis of a program start to finish. That is where K &amp; R shine most brightly. It certainly is not a book for intermediary readers. *** ^(1)Correction of grammar.
I believe the ternary operator would count as a selection construct.
Nope. It's slightly ridiculous.
As the guy says: &gt; Even for C, the trick is suspicious: it uses the preprocessor to define new syntax. C programmers have learned through bitter experience that inventing new syntax confuses maintenance programmers, and therefore causes bugs. He then says: &gt; I think, however, that the benefits in this case outweigh the potential problems, since the amount of repetitive code saved is so great. Personally, I disagree with this. If I were going to do something like what he is doing I would use [google protobufs](https://github.com/protobuf-c/protobuf-c/wiki/Examples) Or if there wasn't enough code to justify doing that, just code the structs by hand.
For the absolute beginner, go for the [coolest book on c](https://www.amazon.com/Head-First-C-David-Griffiths/dp/1449399916) 
How about this code: void reddit_test(int i1,int i2,int i3) { char * cc = "DDCCCCPP" ; int k = ((i1-i2+1) % 2)-((i1-i2-1) % 2) ; k += ((i1-i3+1) % 2)-((i1-i3-1) % 2) ; k += ((i2-i3+1) % 2)-((i2-i3-1) % 2) ; printf("%c\n",cc[k]) ; } 
&gt;When you're dealing with web requests, the performance bottleneck is almost entirely from waiting for the network, rather than the speed of code execution. Not true. Ever wrote a high-performance web application that needs to serve a high amount of users? Few languages allow you the kind of scalability you can reach with C.
We haven't covered how to access elements either, sadly. I may end up just taking the bullet on this one.
This is IoT we're talking about here.
What have you tried so far?
I used to use short cut for sqrt(x^2 + y^2) (to determine distance in games). The shortcut is abs(x) | abs(y) and is within 20% of the actual value most of the time but was much faster to calculate.
I was hoping there was an easier way, thanks man.
Using your array backwards isn't that bad: nlogn time if you keep your array sorted and use a good algorithm.
For file I/O like that, think about using stat() to get the file size and then either 1) allocating a buffer of the same size as the file or my preferred solution 2) using mmap() to map the entire file to memory, which lets you read/write/whatever to the file using a pointer without doing any of the I/O yourself. Using mmap() lets you manipulate files of arbitrary size without concern for memory constraints, eg you can mmap() a 1TB file on a host with 16GB of memory and still essentially treat the file as if it's all in memory. 
O(log n)*, for a search within a sorted array.
Changed the last line: void reddit_test(int i1,int i2,int i3) { int k = ((i1-i2+1) % 2)-((i1-i2-1) % 2) ; k += ((i1-i3+1) % 2)-((i1-i3-1) % 2) ; k += ((i2-i3+1) % 2)-((i2-i3-1) % 2) ; printf("%c\n",'D'-k/2+(k/6)*('P'-'A') ) ; } 
Well, I'd imagine you'd run into cache misses iterating backwards. Also, I'm not sure why backwards would be algorithmically better than forwards. edit: Yes, I'm drunk and misunderstood what /u/Ubertekk meant. You'd have to sort your array, which is nlogn, and then find the value: logn. Whether this is a good solution compared to a O(n) iteration on an unsorted array depends on how often you're changing your array vs looking things up in, as well as table size. Personally, I'd just put it in a hashmap. Keep an array to look it via index, and look it up via probability in the hashmap.
Not sure how good of an idea it is, but I decided to round the probability to a bool, so no matter what number it is, it'll only take half the time to reach it.
Binary search (or anything related) is simpler. For small arrays, say, up to a few dozens of items, just a linear search could be acceptable, speedwise. For string searches, with lots of common prefixes, there are also [tries](https://en.wikipedia.org/wiki/Trie).
Yup, I'm an idiot. Correctly my comment to reflect said fact.
Note that with `mmap()` you should make sure that the file is mapped `MAP_SHARED` lest someone modifies it and the operating system actually needs to allocate RAM for it.
"Head First C" is my recommendation. The book isn't very long, the examples are clear, the text is precise and beginner friendly and the exercises are actually fun to do. That said I can't recommend C as first language, it's rather low level and you need some knowledge in computer systems to help able to be efficient. Still, if that's what you want, go for it and ask any questions you may have :) 
Maybe you could get the best of both worlds, with native extensions: https://docs.python.org/2/extending/extending.html Just write yourself a simple C library for drawing to the screen etc. and call it from python. I'm not sure if you can do that on the ESP, but you definitely could on a Pi.
Thanks that was indeed the problem and now I can proceed to the next part. Still really confused when it should be n = y or y = n as I was told you should read the equations from right to left instead of left to right to make it simpler :/
In C, the thing you assign to is always on the left. Just remember this simple rule. Mentally, you might want to read `=` as ‚Äúis now,‚Äù so read `n = y` as ‚Äú*n* is now *y*.‚Äù
Thanks that does make it easier to visualize. I tried to write the rest of the program but I can't seem to be able to make the last number not print out a X . For example if it's 6 it will always be 2 x 3 x instead of 2 x 3. Is using if else the only way to make it not have an X on the last digit? 
My dad had one of the pre-ANSI editions. I loved the writing style and humor, but trying to use the book with Visual Studio 2003 just didn't work very well. I got C++ Primer Plus (5th Edition) and that went much better, but I imagine that 5th edition of the C version is just as good.
Thank you for your help and explanation! I was trying to see if I could make it work by using while loop but that seems to be impossible as I have to make a choice and it would only be possible with if - else.
Well, you can put an if-statement inside a while-loop just fine. I don't see why you can't use a while-loop.
That's likely wise, and I'm glad you have the caveat "as much as possible". Sometimes (not too often), it's the best solution. Like the classic "`fork/exec`" for starting a child process (I'm thinking there are better, platform dependent, solutions for starting a child process but I haven't had to do that in a while). 
Yep, sorry about that. Got my sorting and searching mixed up
Yeah, it doesn't really make sense when the buffer size is a constant. I find that's really only useful when you might be resizing.
apparently um this can be done by the first 2 chpaters of k&amp;r according to someone...
I don't know shit about calculus. Is there some kind of calculation you need to do with the variables? You can rearrange characters pretty easily. 
Consider reading the documentation. the autotools have [very good documentation](https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html), but most time you don't need them.
I suggest you avoid K&amp;R as a first book since you don't have a programming experience. Instead, get into the K. N. King book, which is beginner friendly and has a lot of solvable exercises. For German speaking people, I don't know. Yoi should probably pick some book yoy get comfortable with. You might find it in Amazon. 
I honestly couldn't tell you about using VS with C, I've only ever used it with C++ and C#. I personally use gcc to compile C, but assuming that Visual Studio supports C, you shouldn't need to do anything special besides just installing VS. (Not making any promises though.)
Yes you need a compiler, for example, GCC, or clang, or Pelles etc.
I might be wrong, but Python is an interpreted language, and that means you don't have to Compile your code . In C, you need a software that does that to you, this software is a compiler. It takes your .c file and transforms it into code that the processor understands. I usually use Clang compiler, but gcc is also a good choice.
^ What he said. Your OS is important here. If you are already coding in Python, I'm guessing you are using Linux. Linux is great, but I prefer Windows for C myself. EDIT: And here come's the Linux fanboys again.
I've been learning C for the past few months and recently made the jump to Linux. What is it that makes you prefer Windows?
I was able to make a sample project to make Python access C-files, it's definitely much easier than I thought! Like you said, for platforms that support Python, this is a good option. In my opinion better than finding *consistent* high-level libs for C Thanks
As far as the linker is concerned, objects and static archives are identical. You just give it a list of inputs. I don't know what that `+` is doing there, that's not needed. The makefile won't work for other reasons, namely you can't use wildcards like that, you have to expand them somehow. (But that would be better asked in the relevant subreddit for makefiles.) 
Usually you handle wildcards like this, assuming GNU make: SOURCES := $(wildcard *.c) OBJECTS := $(patsubst %.c,%.o,$(SOURCES)) That's because if you just use a wildcard for the .o files, it won't work properly the first time because no objects exist yet. Also, make has built-in rules that cover things like how to make a .o file from a .c file of the same name, so you don't need to write rules for that. All you really need to do is tell it which objects need to be combined to make the executable. It will figure out that it needs to make each object from the fact that the .c files exist. Also, the executable should depend on the library, and you should consider using `$^` to mean the list of all prerequisites; and you also need to specify an output, which you should do with `$@` which is the name of the target of the rule, e.g. $(EXECUTABLE): $(OBJECTS) $(ARCHIVE) $(CC) $(LDFLAGS) -o $@ $^ 
Start here: https://autotools.io/index.html
Thanks. What is the difference between := and =?
which part of the code gives the width? The \* part?
`-o` in `LDFLAGS` looks fishy. Have you read the man page of your compiler?
Written by one of the creators of C : &lt;https://www.bell-labs.com/usr/dmr/www/chist.html&gt;
&gt; I might be wrong, but Python is an interpreted language You're not.
Great read. Thanks for the link!
Yep! It starts off pretty basic, but accelerates fairly quickly. I went into it with front end experience, some exp to Java/c#, and I learned quite a bit, including lots of important small stuff
You should show a complete working example of your code.
On mobile so I can't check the code, but if you are running on som unix system (Linux) I would run the program with gdb, and inspect where it crashed and the state of the variables. Alternatively, enable core dumps with ulimit-c, run the program until it crashes, then run gdb &lt;program&gt; &lt;core file&gt;, and inspect the stare. Remember to compile with debug symbols, -g. 
Also you can try narrowing the problem to see where is crashing. 
Sorry...i guess i should be clearer in the question. I am more interested in learning how to debug this rather than how to solve this. It's definitely an issue in my code, but i have no idea where it is spawning from. So what i want to know is how i can identify that.
Good idea, edited the original post.
Thanks. I will try that later today.
I wish my programs were as cool as everyone else's. I'm fairly new at programming. Anyways my favorite program I build was for my Internet security class. I had to read a full, strip all non alphabetical letters, change upper case to lowercase , and encrypt the result using a Vigenere cipher as a block cipher and using the Cipher Block Chaining mode of operation. 
Sorry, this subreddit is about programming in the C programming language. Please post content on rappers elsewhere.
I don't know, I've never followed a book and I've never used ‚Äúdebug headers‚Äù or whatever that is. `assert()` and `printf()` is everything you need for basic debugging. Then, learn how to use a debugger.
No, there's no standard. Yes, it's frustrating to have to learn things that are specific to a particular book/author when what you really *want* to learn is C. There's not really a good solution, unfortunately. Error handling in C is often verbose and cumbersome to do correctly. Some authors, like K&amp;R, simply omit it from examples; others, like Zed Shaw, come up with their own debug macros. Both choices have advantages and disadvantages.
I feel like during the examples im having a hard time to difference between C-stuff, Linux-stuff and the debugstuff. Avd fear that i will have a hard time after this book and feel lost without the headers. I belive the best for me to do is to write a similar solution to the example but only include what is native
[Solution here](http://pastebin.com/PcNkjDEv) if I understood the problem. 
Wow thanks i tried something similar to that but i was not num_symbols in the correct spot the second time around, much appreciation
What kind of thing do you mean anyway? I'm not really sure.
 if(num_symbols % 2 == 0) What are you trying to do with this check? Do you know that the `%` operator does? printf("* ",j); You don't need any additional parameters to `printf()` here, because you haven't included any conversion specifications. You're keeping track of the current row number with the variable `i`. For each iteration of the loop, you need to determine if `i` is even or odd, and based on that call `printf()` a different number of times. Do you know how to find out if a number is odd or even?
Please could you provide a little more information on what you are trying to do. We can't tell you how you should do something if we don't know what you are trying to do.
I find Windows incredibly irritating for programming C.
Perhaps a function which takes an error code as a parameter, or some other custom data, and exits in such a way (printing the information to `stderr`) and then exits. None of the above functions provides exactly that functionality, which is why you would need to write a wrapper function.
I've never needed this. I just call `fprintf(stderr, "message")` and then `exit(EXIT_FAILURE)`. If you are really fancy, you can use the `err()` family of functions from BSD but it's not that you need them for simple programs.
UTF-8 can show all of the characters in Unicode. It's a multi-byte sequence, it isn't limited to 256 possible values. edit: My apologies, I now realize that's not what you were referring to. The problem with wchar_t is depending on the platform the byte length varies. With char you at least have a fixed byte length. Unless he's aiming to do legacy stuff, which considering he picked UTF-8 I don't think so, I think UTF-8 is the most painless way to go to represent Unicode characters as you can just use char after setting the locale.
&gt;I've never needed this. Me neither, but I can see why people would want such a thing.
Are you taking that class at TESC?
Unless absolutely necessary, I would stick with just UTF-8 even if it was comparatively easy to support several encodings. At this point, I'm somewhat confused why other encodings even continue to be used (other than in legacy systems).
Thanks for this...I ran the address sanitizer and it helped me figure out which buffer was overflowing. After that, it was a simple fix.
Awesome, I'm in your class! Small world.
Do you get the `printf("Running %s\n", line);` output twice for the last command? That would indicate whether it's a problem with reading the file, or a problem with the fork process. 
Not a damn thing...lol You?
I actually spoke with another student in the class and he asked the same thing. I combined some code from the class and an example from the professor. Now I understand they don't need to be pointers. 
`parseline` has some problem: * It overflows `middleman` for long input * If the input starts with `;` (or contains `;;`) then `middleman[j-1]` reads out of bounds of the buffer (and may write out of bounds too) * After the semicolon is found, you set `j = length;` and continue the loop. This means that you never null-terminated `middleman` (and some other weird behaviour may happen that is too big to summarize in this bullet point). Instead, set a null terminator and then `break;`. So I suspect this function is the source of your problem. To verify that, add in a debugging line just before the call from `parseline` to `parsecommand` that shows the command it has parsed out. ---- It'd be better to not use `commandcount` and just have `parseline` handle all cases, with the outer loop breaking when the end of the line is reached. Also, `middleman` is unnecessary; you could instead do this in a loop: * Find `;` * Replace with `'\0'` * Call `parsecommand` * (Optional) Restore `;` * Continue from next character. 
&gt; In C, the left-hand side of an expression is commonly referred to as an lvalue This is backward - whether an expression is an lvalue or not is determined by other rules that do not take into account the context of the expression. Then, the left-hand side of an **assignment** expression must be a modifiable lvalue. Lvalues can also appear on the right-hand side of expressions; and non-lvalues may appear on the left-hand side of some other expressions (e.g. in `2 + foo`, `2` is not an lvalue, but `foo` is). 
No, the array's name decays into a pointer to the zeroth element. The zeroth element does not decay (unless we are talking about an array of arrays!) 
It is free. Check it out. you can also pay $90 for a degree of completion. Might be pretty good to hang on your wall. https://courses.edx.org/courses/course-v1:HarvardX+CS50+X/info
That sounds like a word processor.
All of those except `gedit` come pre-installed on ~~OS X~~ macOS. `nano` is the simplest choice, but by far and away the least powerful. BTW, TextEdit will save as plain text if you tell it to: Format menu -&gt; Make Plain Text.
TextEdit works just fine as a text editor. To make an open document plain text, go to [Format &gt; Make Plain Text][1], or press ‚áß‚åòT (Shift+Command+T). (If the document is already plain text then "Make Rich Text" will be available instead.) Now when you save the document the default extension will be `.txt`, and TextEdit will not complain when you change the name in the save dialog to use a `.c` extension. You can also make plain text the default document type for new documents: [TextEdit &gt; Preferences...][2] &gt; [New Document &gt; Format &gt; Plain Text][3]. --- TextEdit is fine as generic text editors go. Thanks to the fact that it uses generic OS X UI components it's got all the generic text features built-in to every OS X text field: spelling and grammar checking, text substitutions and transformations, text-to-speech, rectangular selection, vertical and right-to-left text support, basic emacs key-commands, customizable shortcuts via the OS X's systemwide settings, access to OS X "Services", etc., etc. But despite all that it's not a programming text editor and so it's missing some things that are fairly important when you're doing more than the simplest programming tasks. Syntax highlighting and auto-formatting are the most important such features. These features are really useful when you're starting out and don't know the language you're working in well. They improve the readability of your code with colors and formatting, which can help you better see some kinds of mistakes common among new programmers. Slightly more advanced features are live errors/warnings as you edit, which provides more pointed messages when you mess up, and a command directly within the editor to build and run your code. These provide really big productivity improvements, however these features depend on a bit more configuration to make the editor understand your code well enough to correctly process it. Advanced text editors like Vim or Emacs can be set up with very powerful editing features, but are software ecosystems unto themselves, with unique command syntaxes that do not follow any of the usual OS wide standards, and many, many available extensions, which all gives such programs a somewhat difficult learning curve. I'd recommend making a serious effort at learning an advanced editor at some point, but perhaps not when you're just starting out and have plenty of other things you need to learn. For day-to-day work when you're starting out having the live errors/warnings is a huge help. A relatively easy way to get these working is to just use an IDE such as Xcode. If you want to work on OS X then I'd recommend going ahead and getting Xcode. You can install it via the App Store. --- There are a couple caveats. First, IDEs are pretty big programs with their own learning curves, and they can hide a lot of stuff from you, preventing you from learning some important things if you always let the IDE protect you from the details. Before you start using an IDE for day-to-day work, go ahead and figure out how to write code using a basic text editor like TextEdit, how to compile a couple source files into a single program in the terminal, and how to run that program from the terminal. Once you can do that, then you can move to an IDE for day-to-day work. Second, there are always slight variations between toolsets on different platforms. You can get things working on one platform such as OS X and then run into errors you don't understand when you try to get the same source to build and run on a different platform such as Linux. If you're going to develop on OS X, don't leave it to the last second before a deadline to try the program out on the platform it will be graded on. You should try your work-in-progress on the grading platform at least every day you work on it, and you should probably leave a day or two after you 'finish' the project at home to make sure it works on the school's computers. [1]: https://dl.dropboxusercontent.com/u/7511537/Post%20Content/Screen%20Shot%202016-09-23%20at%201.15.48%20AM.png [2]: https://dl.dropboxusercontent.com/u/7511537/Post%20Content/TextEdit%20Preferences%20Menu%20Item%20Screenshot.png [3]: https://dl.dropboxusercontent.com/u/7511537/Post%20Content/TextEdit%20Preferences%20Format%20Screenshot.png
You're correct. wchar_t is compiler-dependent (or more likely, libc-dependent). It's 16 bit with Microsoft's compiler on Windows, for example, but 32 bit with gcc on Linux, so if you want to write code that's portable between those two, UTF-8 is still the safest route. Because at least with a char you know where you stand, in terms of its size.
There are reasons for other encodings, Unicode has design defects relevant for Chinese, Japanese, and Korean so users of these languages some times use other encodings. That said, C has a facility to deal with multibyte characters in a completely encoding-agnostic way (i.e. `wchar_t`), so why not use that?
`whcar_t` is a generic mechanism to deal with multibyte encodings. It works with any encoding, which makes it so useful. &gt; The encoding used by wchar_t or multibyte conversions isn't. `wchar_t` uses whatever encoding was set in the locale. So if you set a Unicode locale, then `wchar_t` contains Unicode characters.
A `wchar_t` contains a *decoded* wide character. In the case of a UTF-8 locale, that is a single Unicode character. There is a pair of functions `wctomb` and `mbtowc` to de- and encode wide characters. Note though that you often don't need these functions, it's easier to always operate on strings of encoded characters.
Please post your source code as text instead of an image. It's very hard to debug source code you can't edit or compile.
It appears that you have been shadow banned. Please talk to the reddit admins to rectify this issue.
Well, if you need such very specific functionality, then of course there is no way around a proper Unicode library. However, in most cases people merely want to be able to process text with Unicode characters, in which case the locale mechanism is more useful as it works with all encodings supported by the platform.
You can't reliably do anything non-really-trivial with Unicode text without taking things like combining characters into account. How do you handle them with wide strings and the standard library?
For most purposes you actually don't need to take them into account. Use the functions from `ctype.h` to detect punctuation and whitespace and remember to always operate on strings, not individual characters. Then everything works out. Can you give me a real-life example for a mundane situation where you need to take combining characters into account?
And for what real-life purpose do you need to do that? I can't even think of a single useful application for that.
Ah, I see. I am not very familiar with the details of UTF-16.
Some actual help for your problem of printing too many trailing zeros, would be for you to research how to format the numbers in the `printf` string. `printf("%f", i);` will print the variable `i` formatted as a floating-point number, with the default number of decimal places. I think there are plenty of other problems, but if you can reliably print stuff, it'll help you in sorting out the other problems for yourself. For example the default `%f` can be changed to `%.2f` to change the number of decimal places to two. Naturally the manual will explain in more detail all the fancy ways of printing numbers you can have. Hint as to one of your problems: You declare `i` and `APR`, then you immediately try to calculate `i = APR/12;` What, exactly, are the values in those variables at the exact time you are attempting the calculation?
instead of `%lf` in your format specifier, use `%.2lf` (or however many decimal points you want.
Available doesn't mean that you should use them. In this particular case though, it should be fine.
 scanf("%e",&amp;a)&gt;max the number that is entered is put into `a`. scanf *returns* a count of the successful reads it did - in this case `1`. Secondly if(scanf("%e",&amp;a)&gt;max){ max=scanf("%e",&amp;a); This snippet is calling `scanf` twice, so it will read 2 numbers. You need to scanf into a variable. Yours is called `a` but there must be a better name than that. Then use `a` for the comparison and the assignment
Every time you call `scanf()`, you're getting new input from the user and overwriting the value of `a`. You should call `scanf()` once at the start of your loop and just use the variable `a` after that. if(scanf("%e",&amp;a)&gt;max){ `scanf()` does not return the value that was read in, it returns the number of variables updated (in your case this will be 0 or 1). if(i=1){ A single equal sign is an assignment operation, so in every iteration of your loop you're resetting `i` to 1. To check for equality, use `==` Once you've solved these problems, your solution looks like it should work.
You're on the right track. However you're comparing the return value of `scanf()` instead of `a` of which is the actual input value: if(i=1){ max=scanf("%e",&amp;a); } if(i&gt;1){ if(scanf("%e",&amp;a)&gt;max){ max=scanf("%e",&amp;a); } } Should be doing: if(scanf("%e", &amp;a) &gt; 0) { if((i == 1) || (a &gt; max)) max = a; } 
Thanks for the solution.
 /* * TKDestroy destroys a TokenizerT object. It should free all dynamically * allocated memory that is part of the object being destroyed. * * You need to fill in this function as part of your implementation. */ void TKDestroy(TokenizerT * tk) { free(tk); } You should `free(tk-&gt;token)` before freeing tk itself. 
Yes, in tkcreate you malloc for tk and then you malloc for tk-&gt;token, so token is actually just a pointer to wherever in memory the string is being stored. When you free tk you free the memory for the variable holding this pointer(tk-&gt;token), but not the actual memory holding the string.
Yes, free the allocated memory that the `token` field of the struct points to. In `TKCreate(char * ts)`, you have allocated memory for it: tk-&gt;token = malloc(strlen(ts) + 1); So you should free it at some point. Before freeing `tk` if `tk` is the only way to access it.
One case, where you would like to reverse a string is the [reverse complement](https://en.wikipedia.org/wiki/Complementarity_%28molecular_biology%29). But the DNA alphabet consists of only four characters, all ASCII.
 while (*ptr != '\0') { if (!isdigit(*ptr++) || (*ptr == '0')) { return 0; } } * Not sure why you `return 0` when the digit is `'0'`? * Mixing incrementation and logical operators in an operation where you reuse the same variable is dangerous. EDIT: err... you changed it since I started typing my message? :-)
&gt; Still trying to figure out how to properly identify a decimal and a octal. In `printToken()`, just move the `octal()` test above the `decimal()` test in the chain of `if` / `else if`. This way, if your token was tested positive for an octal number, you don't test it for a decimal number.
 //check if digits are between 0 and 7 *ptr++; while (isdigit(*ptr) &amp;&amp; *ptr &gt;= '0' &amp;&amp; *ptr &lt;= '7') { *ptr++; You just want to increment the pointers: `ptr++;` instead of `*ptr++;`.
You changed the tests but not the content of the display :-) Also: //String contained non-octal values return -1; should be `return 0;` (-1 is a *true* value).
&gt; Any tips on how I could make input like 07?0 invalid What catches it at the moment? &gt; Like say -3 is entered it should probably still return decimal even though its negative. In `decimal()`, check the first character separately (it if is a `isdigit()` or a `'-'`, then proceed to check the following characters as you do now, else return 0).
Actually, all the comments in this code are just from the teacher! 8\^y
You should comment for all your future selves.
You are quite right! Re-reading my sources I skipped over several key sentences and got myself confused. I've corrected my post to reflect your comments. Thanks!
&gt; Float seems to be the only one catching it. &gt; &gt; Invalid: '0700?8237169421' &gt; Decimal: '43212312903811273198273' &gt; Float: '3.1?1231231231231' &gt; Invalid: '0x3f?dad' &gt; Invalid: 'hy' &gt; Invalid: '-3' Oh? OK, then there is no problem with `07?0`. Yes, in `float()`, you just check that the string starts with a number, followed by one of "eE.". You don't check what happens afterwards, so "123.QWERTY" matches. You should check that what comes after "eE." is a number too. EDIT : can't reply to your comment any more, so I add this to my first reply (I don't know what happened to your comment). &gt; I changed decimal to this, &gt; int decimal(char *s) { char *ptr = s; //check if char is not digit or starts with 0 while (*ptr != '\0') { if (isdigit(*ptr++)) { return 1; } } return 0; } &gt; And it is catching it now, however that seems to have made non digit characters be picked up in other ones. Now you return 1 as soon as the first character is OK, which is not what you want to do. Try something like this: int decimal(char *s) { char *ptr = s; if(*ptr=='\0') return 0; //check that it starts with a digit or a minus sign if(*ptr!='-' &amp;&amp; !isdigit(*ptr)) return 0; // check other digits ptr++; while (*ptr != '\0') { if (!isdigit(*ptr++)) { return 0; } } return 1; }
Great, all the messages from OP have disappeared and the thread is deleted. What the fuck happened again???
He posted his homework to get review and once he was satisfied he deleted it.
For most programs you don't even need `wchar_t`, you can just operate directly on UTF-8. (In fact with the right library you can do pretty much everything directly on UTF-8.) Generally if you can't operate on UTF-8 then `wchar_t` also is insufficient. For example splitting a string can go wrong on `wchar_t` strings just as it can on UTF-8, such as splitting right in the middle of the representation of a character. (And note, I'm not even talking about UTF-16, I'm talking about UTF-32.) Unicode is fundamentally variable length regardless of which Unicode encoding is used. `wchar_t` is not designed for that and so there's little value in using it. [What's ‚Äúwrong‚Äù with wchar_t? What are some alternatives to wide characters?][1] [1]: http://stackoverflow.com/a/11107667
Woah woops, thanks! Just fixed that though and it's still giving me the same problem :S
I can't figure out what the question's asking either‚Äîit reads as though some parts have been left out. If what you posted is accurate, and not just the result of a copy+paste mistake, you should ask your instructor for clarification.
it just asks me to fill in the body of the function 
With respect to using a switch statement versus a function lookup table, I've read cases for maintaining a switch statement (function lookups being data accesses and not taking advantage of instruction prefetch). Can you or anyone else offer any additional insight into this? Thanks
just did it
It's asking you to implement a function that takes the number `num` and create a string that has different representations of it (as ASCII) in the buffer pointed to by `buffer`. It asks for the "fields" to be the number in decimal, the number in (big-endian though they don't say it) hexidecimal with some amount of zero padding, and the number in little-endian hex (again with padding). These fields need to be separated with '|'. Suppose the number is (base 10) 1337, then your program would end up printing the following string into the buffer: "1337|0x00000539|0x39050000" To do this, you're probably going to want to use snprintf, with the appropriate format string.
Quality post! Your explanations are great!
A switch is static and will be optimized by most compiler, a hashtable seems something dinamic or initialized at runtime. It could be hard to set up and maintain properly. Defenentely switch, KISS
The compiler doesn't do any of that. I think you mean the terminal. If so, I think PDCurses is your best bet on windows.
What I meant by function lookup table was how op did it in his code below: array of similarly prototyped functions, not a hash table.
&gt; if you're in control of the enum I am.
Thank you very much for such a comprehensive answer! It has helped me alot to unravel the mess I made in the code and hopefully understand scanf. Not at all patronising - 100% helpful. I have barely started coding and any help is more thank appreciated - thank you!!!
Thanks! It seems to be a number of syntax errors and misunderstanding the use of scanf overall. The 4 responses from this sub have been brilliant and I am slightly overwhelmed that people went out of their way to give such comprehensive answers - thank you!!
Is this a MISRA application? This might be the first time I've felt like production code was over-commented. 
+1 for jsmn for parsing. Fast, no heap. For generating JSON I actually like the JSONTREE implementation in the Contiki project. Takes some getting used to but overall pretty fast and clean IMO. For MQTT, I believe IBM maintains a fully featured C library. And of course if you do need an IP stack there is lwip. The problem with using wget is perhaps performance, but I'm not very familiar with its internals. In the past I've used Joyents HTTP parser which is pure C and pretty fast, and you can register callbacks to do certain routines at each stage of parsing (host, headers, body, etc)
It's a step forward. It reduces the cyclomatic complexity and reduces the number of unit tests needed to get code coverage. But to play devil's advocate, it's easier for novice programmers to understand the original code, as function pointers is a more advanced concept. Also you have to really make sure the table is set up correctly for lesser used routines.
Lol.... What a shit mistake üòÇ yes I meant terminal. I'll look into pdcurses but have any idea where I should start?
&gt; any idea where I should start? Read the manual.
[This](https://github.com/claytonotey/qiano) will do it. Play it as-is or modify the source however you want. Good luck!
We use the MPLAB XC8 compiler for our older products. I'm not a fan - the errata makes for horrifying reading sometimes (e.g. code that will compile under standard mode but not PRO mode). Just to give you an idea of what the optimisation performance is like: * Free mode = 54.0 kB * Standard mode = 45.7 kB * PRO mode = 37.4 kB We've moved to ARM and GCC for new development.
I always find it nice to use a typedef for function types. E.g. in your case you seem to use different functions to handle different message types: typedef void (*message_handler)(const uint8_t* const); message_handler function_lookup_table[N_PID_MODES] = { /* ... */ };
Yes, that is output twice as well. I'm quite sure its a problem with the forking because of this. And.. to me, it looks like that the execvp doesnt go through with "lssss" and thus the if statement returns -1. For some reason that child process doesnt then exit with exit(EXIT_FAILURE); and then continues on to mimic what the parent process would do.. which is calling the ls command on the next line of the text file in it's own process, just as the parent does.. which creates the double ls response. So really, I just need to kill the child process if it fails to run a command in execvp.. but for some reason that's not working.
Maybe I'm misunderstanding, but why can't you just do int checkDivisible(int num, int p) { if (num % p) return 1; return 0; } ??????
I'd say it is easier for *every* programmer to understand the original code. 
Basically because I understood nothing at all from your comment. *googling intensifies
Is the program supposed to guarantee that the factor you entered is indeed prime? What if the number is 30 and the prime factor is 10?
The operation (n % m) returns n modulo m, the remainder of n when divided by m. If n is divisible by m, then there is no remainder so this returns 0.
I'm guessing you haven't actually tried running your code. All the scanf calls makes me think you don't understand how scanf works. Apart from that, as /u/Schwiftytime points out, if you know the factor is prime, then this should just be a one-liner: return number % primeFactor == 0; That seems too trivial to be correct. As /u/LydianAlchemist points out, what if they don't actually pass you a prime number as primeFactor? Are you expected to handle that? I suggest reading up on Euclid's algorithm for greatest common divisor. https://en.wikipedia.org/wiki/Greatest_common_divisor#Using_Euclid.27s_algorithm
I took your advice and rewrote the program with parseline() only. http://pastebin.com/dam2JMjW The double output after an incorrect command has been fixed, and many of the different combinations of commands + spaces, semicolons, and \n's are also fixed. ( ;; and ;ls do not work still however as I haven't dedicated time to addressing that. ) My only main issue left is that is a space is at the end of the line or the user input. For example (without quotes) "ls " Stops the output of that command altogether. Trying to get the length of the command itself yields no results (as in no output.) It doesn't seem to enter the first for-loop in parsecommand() whatsoever, which I'm thinking is related to the face that trying strlen(line) shows nothing output, therefore i cannot be less than it, and it wouldn't enter the loop? I'm not exactly sure why that is?
Note that intrusive data structures are almost always a better approach than duplicating code for different types (as in your gcl here), in many different aspects. If you want, I can expand on it.
You're telling gcc to overwrite the C file, bacause `code.c` is right after the `-o`. The command you want is gcc -o code code.c 
Or: gcc code.c -o code
You declared a buffer of size 8 but then tried to read 16 characters into it, which invokes undefined behavior. Also, if you really are piping stdin to this program (as opposed to redirecting a file) then stdin will not be seekable, as pipes are not seekable, only files. But I can't understand why you would need that seek anyway. If the goal is to read 16 bytes and then the rest of the file, then there's absolutely no reason for it. (Also the offset is wrong ‚Äî if you seek to offset 15 you're overlapping the last byte of the nonce by one byte.) 
There is the manual. It's very good.
`-o` means "output". `-o code.c` means the output will be written into a file called `code.c`. It erases any old output file before trying to make a new one.
info gcc will give a lot more detail.
A percent is a number between 0 and 1 Your final mark is your percentage on a test * that's test % of your final, plus homework * homework %, plus exam * exam percent, etc.
I always suggest [look at the ccan project](https://github.com/rustyrussell/ccan) for inspiration. Specifically look in individual subproject `_info` files on how the modules are used. Also read the [section at the bottom](http://doc.cat-v.org/bell_labs/pikestyle) on include files. That should hopefully answer your question about one large include file.
See where it says scanf? The code there is specifying what data type it expects. You can use %s for string, %f for float, and %d for double.
%lf for double. %d is for int.
Please do not post code as a picture. Post text instead (and remember to indent it by four spaces so it comes out readable).
Sure. This library was just a POC, but I'd gladly learn how to make something actually useful out of it.
Intrusive data structures could be useful as a (BSD) library, actually. The only intrusive data structures out there in the open (in C) that I know of are in the Linux kernel, so are GPL licensed. Intrusive data structures: * Don't require code duplication for differing types. * Support better asymptotic timings in many circumstances. * Are easier to program with (than macro-based approaches). * Have less indirections and runtime costs (better constants) The general idea is that you make your data structure have non-movable items that appear to have no data. Then, the user places these items as nested fields in their own structs. Using a single macro `containerof`, and ordinary field access -- the user can map objects of their own struct type to the item and back (without indirections). This also means the data structure need not worry about allocations, removes all error codes from the API, etc.
I have a question, if you don't mind! If your library links to / uses other libraries, how do you handle that? I know it's more of a design question. Would you rather hide implementation completely within your library or expose 3rd party library to client (as in client of lib)? If exposing, at least parts, would you pack 3rd party lib into your own so client needs to link against one library only or provide your lib along with instruction for client to link against those 3rd party libs as well?
I didn't expect a talk nearly this interesting. Thank you, Dan.
thank you! 
I've been writing C since the early 90s. I can keep the whole of the language and standard library in my head at one time. C++ by comparison is *enormous*. I can't keep it all in my head at once. I don't know if that means my brain is too small or C++ is too big, but it's a problem...
Definitely. No doubt the most holistic way to retain your newly/long ago learned skills is to continue to utilize them and yes seeing different methods in full context probably gives the best memory embedding effect. However, I would liken bite sized study (flash cards, etc) to musicians practicing scales. Granted I'm not a musician so I may be talking a little outside my depth, but I can't imagine any world class musician only practices by running through entire pieces they learned/wrote in the past. I know for myself I tend to get locked into "the way I do things" and can sometimes lose sight of different approaches that might be more appropriate for a situation. I think keeping methods in a deck could spark your mind to think of them as a solution you may not otherwise from just studying the way you've done it in the past. Again, I think what you're saying is definitely spot on and certainly accounts for the biggest way I refresh myself. I'm just trying to come up with a way that maybe keeps my mind a little fresher day to day.
I'd also advise just storing it as a 1D array (i.e. `int*` allocated to `width * height * sizeof(int)`). Allocation and freeing is going to be much easier, in addition to what /u/warmwaffles has already said about memory continuity.
[GNU make manual](https://www.gnu.org/software/make/manual/make.html)
I see what you mean. What i really wanted is to have a dynamically allocated 2d array that is no different from one declared as `int [][w]`. So that if i have a function `int matrix_multiply(int hA,int wA, int A[][wA],int hB,int wB, int B[][wB])`i don't have to write two different versions one for regular stack declared matrices, and one for dynamically allocated matrices. 
The talk was ok - I can't complain too much since it was in CppCon, so I'm not really part of his audience. IMO, the timer example perhaps shows why I don't really like C++. There's no reason you couldn't do that same interface from the C++ code in C: struct timer_registers; struct timer_registers *timer_get(void); void timer_disable(struct timer_registers *); void timer_enable(struct timer_registers *); void timer_count_set(struct timer_registers *, count_type c); count_type timer_count_get(struct timer_registers *); This functions basically identically to the C++ class version - with the advantage that nothing about the internals of `struct timer_registers` is ever exposed in the header (even as 'private'). Additionally, there's no worry about accessing the register's address directly through the `struct` because the members aren't even in the header. In addition there there's no worry about the `class` not mapping directly to the underlying hardware's memory mapping due to virtual functions or etc. And if you want to later-on, you could make them `static inline` and have the C code access the registers directly while still using the same API (This require putting the definition of `struct timer_registers` in the header, but at that point it isn't nearly as big of a deal). I also echo the sentiments of others - Being able to understand the whole language at one time is a huge boom. When I program in C++, I always seem to forget some weird cases creating lots of slowdown, or have to use some inane syntax like how streams overload the `&lt;&lt;` and `&gt;&gt;` operators and make it impossible to really understand what your output is going to look like. In comparison, while C lacks things like operator and function overloads (Which I don't consider a bad thing), it means that the syntax of C is very consistent. Even badly written C can be understood after a little reading, because there's only so much going on. Badly written C++ is a nightmare in comparison - stuffs happening in tons of innocuous places, and you would never know unless you actually read the details of the objects being used.
Very good points. Sometimes I think of C++ as a write only language. When you're in the zone you can use C++ features to really write performance based code quickly. After a few months when you need to debug that code there is a very real readability tax you must pay before you might understand the problem you are trying to solve. 
This is the right answer. Start with the second section, [_An Introduction to Makefiles_](https://www.gnu.org/software/make/manual/make.html#toc-An-Introduction-to-Makefiles); it's written to be accessible to beginners.
I have just started K&amp;R to broaden my access to embedded. What do you all think of understanding C to journey into embedded given Dan's points?
The error message isn't helpful? Have you looked at line 72 to see why the compiler might be complaining about something called `big_` ?
If you mean "standards" as in C11 -&gt; C99 -&gt; C89, C99 is for the most part just as good as C11. The newest standard introduces some nice bells and whistles, but nothing really integral to the language. 
I would agree. His examples and explanations were pretty weak IMO. His 'copy_int_10', 'copy_int_20' functions are both impractical, unnecessary, and generally useless. It only works if you write functions that only take pointers to fixed-sized arrays - and at that point the extra checking isn't really that useful More-over, you don't have to write that many functions - just check that the `sizeof` result for both entries is the same, which could be done via a macro and a static assert at compile-time (Of course, both of your pointers have to be pointers to arrays for that to work).
Yes, the information is stored somewhere. But it's an internal implementation detail of the heap manager. It's not exposed publicly. In theory if you took the time to study the internals of your particular libc, you could write code that extracts that information. But it would be a terrible idea, because internal details can change without notice, so your code might break one day out of the blue when you upgrade to a new libc version. Moreover, it won't work on any other platform or libc, so it makes your code horrifically non-portable. As to why the standard chose not to make the information part of the public API, I do not know. Not having to make that information available means you can write a blazing fast heap manager that doesn't keep track of it at all, such as a simple bump-the-pointer scheme where `free()` is a no-op. That's obviously only practical in certain niche cases, but when you need it you need it, and it wouldn't be possible if the standard wasn't written the way it is, so one reading would be that they didn't want to constrain the implementation. Besides, if you do need that information you can just keep track of it yourself. 
Yes I talk about ISO C11. Also talking about the prev article the author references a standard from the open group http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html to use better integer types for example. So things like that became distracting, because you dont know what is the "good" approach but at the end of the day producing reliable software is the most important value. So why is not widely used? What do you think about it?
I downloaded the file... convert_big_endian_to_little_endian(little_endian,big_ endian); This is the error. Easily spotted. Why is it an error? *A newline counts as a whitespace*, so that "big_ *newline* endian" is interpreted as "big_ *space* endian" which is different to "big_endian".
aninteger, Can you tell me which C++ conferences are "driven by companies, mostly Microsoft"? I think I know a bit about C++ conferences, but I don't know of any one in existence that is "driven by" Microsoft. The ACCU conference is not explicitly C++, but it has enough C++ content that it can be considered a C++ conference. It is driven by the ACCU which is a non-profit user group. It does have sponsors, but almost all conferences have sponsor. That isn't evidence of "being driven by." (Bloomberg is sponsor, not Microsoft.) Meeting C++ is driven by Jens Weller an independent C++ community evangelist. He also has sponsors. It would be funny to see what would happen to their sponsorship if any of them tried to "drive" his conference. (JetBrains is a sponsor, not Microsoft. The top sponsor is a non-profit.) C++Now is driven by Boost Libraries. Again sponsorships. Again a non-profit does the driving. (JetBrains is a sponsor, not Microsoft.) CppCon is driven by the Standard C++ Foundation. Again sponsorships. Again a non-profit does the driving. (Finally, Microsoft is a sponsor. Along with eight other bronze sponsor and below three gold and silver sponsors. But one of those is Google.) I can only guess what Jens would do if a sponsor tried to run his conference, but I don't have to guess what would happen at C++Now or CppCon if a sponsor tried to run one of those conferences. We appreciate our sponsors very much and sometimes we solicit their advice, but I've never had one even hint at changing the conference policy or practice in any way. I will give you the Audio Developer's Conference. Also not explicitly C++, but with enough C++ content to attract audio programmers using C++. It is driven by JUCE which is owned by ROLI a startup focused on music-making devices. It has a sponsorship in which Google sponsors 10 tickets. Other than that, the last C++ conference that I know of that was driven by Microsoft was was Going Native, which only existed in 2012 and 2013. Either you are grossly exaggerating, your data is out of date, or I'm overlooking something. Can you let me know what I'm missing? Jon Kalb Conference Chair, C++Now and CppCon 
when ++ is after the variable name, then assignment happens first. For example int a = 0; int a_post = a++; // a_post is still 0 printf("a_post = %d", a_post); Conversely replacing a++ with ++a would change it so a_post is 1 You should google info about the C increment operators
Prefix increment evaluates to the value after it's been incremented, whereas postfix increment evaluates to the original value, and the increment happens at some unspecified time before the next sequence point. Postfix increment has higher precedence to make it easy and idiomatic to write loops like: while(len--) *dest++ = *src++; This relies on postfix increment having higher precedence than the dereference operator, which sits at the same precedence as prefix increment and all the other unary operators. If that were not the case, then `*dest++` would be incrementing the result of dereferencing the pointer, which is not what's desired. 
&gt; better integer types These new types aren't ‚Äúbetter.‚Äù People did the same thing these types provide before by rolling out their own types. They just provide a standardized way to have fixed width types.
My BSD (FreeBSD 10) doesn't seem to have this function. Instead it has `malloc_usable_size()`.
It appears that you have been shadow banned. Please talk to the admins to rectify this issue. I have a approved your post for now.
I see. Perhaps it's just on OSX then. I was fooled because the manpage says "BSD Library Functions Manual"! Seems like `malloc_usable_size()` is the same thing though. It also exists on Linux.
It may be so. Its implications are interesting though - it returns the number of "usable" bytes. What does that mean? Could it be that when using `malloc_size()`, you get the full allocated space, but the allocator may use some of the bytes for metadata? Then by using `malloc_usable_size()`, one may get the "safe" sublength of the space, excluding those bytes.
A byte is usable if you can use it to store your own data. I believe `malloc_size()` returns the same figure but the function must have been renamed.
I'm not entirely confident in my C-skills, but I can answer this one. Feel free to correct me. The (pseudo) assembly code may look like this: void changeariable() { &lt;put 5 on stack&gt; &lt;store address of var b in static variable a&gt; } Since you don't do anything with your stack, after you change the variable, the value is still on the stack - because no other program interferes with your stack. This is why it still prints 5 as the correct output, if you were to do the output like this: ... printf("It is "); printf("%d\n", *a); ... The value will be something else - presumably get a segfault. (not as a value stored, but you know...program crash, etc.) You are right that if you use malloc, the value will still be there after you do something with your stack, because the value will be stored in the heap. (EDIT: formatting.)
I'm new to C too so hopefully the downvotes/upvotes will tell you if my understanding is correct. Your thinking is for the most part correct. Pointers can point to any memory address that's allowed by the underlying platform (so for example the OS will limit you to your own program's memory space). The first instance is completely legal because it's doing exactly that: a is pointing to a memory address within the program's space, but you shouldn't rely on the value at that address always being 5. Because the underlying value no longer has a reference to it, the garbage collector is free to reallocate that memory for usage elsewhere. When using malloc and its ilk you reserve that address until you specifically free it, so it won't be reallocated until you call free or realloc.
The signature of the entry point is int WinMainCRTStartup(void); In particular, its calling convention is cdecl, not stdcall, so `WINAPI` should not be there. If you make it stdcall, then its assembler name gets decorated with `@0` at the end, and it no longer matches what the linker expects for an entrypoint, and so the linker decides to set the entry point to the first function it sees which is almost certainly wrong (in my testing it happened to be `WndProc()` since that's the first function, but it could be anything.) 
The first invokes undefined behavior. `a` is a dangling pointer (i.e. a pointer to an object whose lifetime has ended) and it's invalid to dereference it. It absolutely cannot be relied upon to work. It could summon nasal demons, etc. The second is fine, because the lifetime of the allocation only ends when you explicitly call `free()`, which you didn't do, so it's still alive at the point where you dereference `a`. 
You could keep your API in library "A" and use it like a factory to create an implementation. When you do your "Init" call, you can do a dlopen() or equivalent to load up either SDL or OpenGL (or return if the library is not there). The function then returns a context or handle pointer that you pass around to your other functions. This will abstract away the underlying library. This makes the context a rather large struct you're passing around and makes your implementation more complicated. I'd advocate for two separate libraries with two separate headers for the SDL/OpenGL implementations. You can think of your "add-on" libraries, not as addons but as the final product. Both of which import your "common" library with common-like functionality. Basically inverting the linking chain. This would not allow the user to swap out SDL for OpenGL easily, but is that something that is common or required? Secondly, doesn't SDL use OpenGL under the hood? Maybe your problem is moot?
&gt; This would not allow the user to swap out SDL for OpenGL easily, but is that something that is common or required? I want to do that for personal reasons, I'm experimenting with libraries so I get used to using them, so I don't focus on things used by users or not. &gt; Secondly, doesn't SDL use OpenGL under the hood? Maybe your problem is moot? That is true, but I used these libraries as examples, I want to make it in such a way that it will support future graphic libraries without many problems.
use makefile and make command (tools-&gt;build system)
X-Post referenced from /r/programming by /u/always_programming [How I wrote a client-server app in two minutes flat (in C).](https://www.reddit.com/r/programming/comments/54kl3s/how_i_wrote_a_clientserver_app_in_two_minutes/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
&gt;When running it in GCC it compile fine without any (relevant) warnings/errors You can't always count on the compiler to warn you about undefined behavior you've invoked. You should compile it with /Wall if you haven't already, though in this case I suspect you still won't get a warning about it.
&gt;Hi, I'm trying to write a program that reads in multiple strings from stdin and stores them in a single node of a linked list. So each line of input goes into just one node. I'm running into problems with mallocing the struct, I'm still trying to wrap my head around malloc and pointers. The error I'm getting right now from the compiler is: &gt; error: field has incomplete type 'char *[]' &gt;&gt; char *data[]; &gt;This is the program: &gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; &gt; typedef struct _Node { char *data[]; struct _Node *next; } NodeT; data needs to be a fixed size in order for the compiler to know the size of struct _Node.
Hi everyone. It's my article. Code critiques and constructive criticisms are welcome. This project started out as an exercise to create a simple card game over the network, and while refining the code, it started to look like I had a kernel for a basic framework. So I just kinda went with it, continued refining, and finally released what it is now. I'm hoping others will find it useful.
Could you explain?
I downloaded MinGW according to the link. How do I compile manually or use CMake?
A segfault is quite improbable. The value of `a` isn't modified and the protection of `*a`'s page is unlikely to change.
In C, it is customary to refer to a string using a pointer to its first character‚Äîwhich is to say, a variable of type `char *`. You can see examples of this in the standard library. Functions like `strlen` and `strcpy` take pointers to characters (`char *`) as their arguments, rather than pointers to arrays of characters (`char (*)[]`). Note that `char *[]` means something else entirely. Because the `[]` (array access) operator has a higher precedence than the `*` (pointer dereference) operator, the declaration `char *data[]` makes `data` an _array of pointers to characters_. You should change your code to use variables of type `char *` for dynamically-allocated strings, and parameters of type `char *` for strings passed to functions.
&gt; This project started out as an exercise to create a simple card game over the network, and while refining the code, it started to look like I had a kernel for a basic framework. So I just kinda went with it, continued refining, and finally released what it is now. I'm hoping others will find it useful. The correct way to write code IMO, set out with a goal in mind, make the thing, then generalise the useful &amp; usable code you have into something others (or yourself) could use in the future.
You can just do: switch(variable) { case 1: case 2: case 3: printf("1 to 3\n"); break; case 4: case 5: case 6: printf("4 to 6\n"); break; default: printf("Something else\n"); } 
You need to google how to compile files. Tutorials will do a much better job at explaining it than me.
I'll be honest I don't how this is supposed to help it. Edit: To what I have I mean. I know what it says. 
Does anyone know a better alternative than make and Makefiles? Something a little more robust?
&gt; So c is gonna increment 5 times and send "beat" when the function is called, after which it is gonna increment but not send? Not sure I understand what happens here. Hello. That is precisely correct. The example program is meant to illustrate the use of the four function types. It is not meant to do anything functionally useful. I stop sending the "beat" command after the fifth one to also illustrate the idle disconnect feature. It is documented here: https://github.com/bartobri/spring-server#example
Oh sorry should have read, really cool! Also nice colde all around, besides the preprocessor magic (well, besides that, there isn't even that much code).
Thanks! This is my first project where I've made heavy use of modules. Maybe too much in some cases. Not sure. But it generally helped make the code easy to follow and keep clean. If you have any suggestions to improve the preprocessor stuff, let me know.
Some small/large suggestions: 1. Make use of the OS' lower level event loop if possible. If you don't want to get into the murky details make use of one of the various libraries that handle this for you: (libuv, libevent, libev, etc.) 2. If possible try not to use sprintf. snprintf is better if you know the size ahead of time. If not use asprintf. 
Put simply, `||` does mean 'or' but you are misunderstanding its actual use. Given the expression: a || b The expression evaluates to 0 when both `a` and `b` are zero, and evaluates to 1 in all other cases. Since in the statement `A||a=3.00;`, `A` and `a` are uninitialised, it is a useless operation (their values will be random). Also, since `||` yields either 1 or 0, that is the same as writing `1 = 3.00` or `0 = 3.00` which you cannot do.
Get Cygwin and use gcc
This is super helpful, thanks for this. But I'm still not sure how I'd go about storing multiple strings in a single node, would it be a case of changing the struct or something in the makeNode function?
Hm... I'll try working on this.
There is a Makefile there, so you need to run "make" on a Unix like terminal. Based on that screenshot, it looks like you're using Windows, so I'd suggest installing Cygwin or the newer Linux userspace support for Windows. 
My notes on the subject (#10 and 11): http://electronics.stackexchange.com/questions/104264/embedded-applications-software-testing-life-cycle/104304#104304
He may have built the program using cygwin or mingw (msys) ... these environments provide make on Windows.
The statement inside the loop's body doesn't change the value of `selection`. So it will loop forever printing the same message
Probably not, because that will try to call a function called `currentTime` but you also have a variable called `currentTime`
Maybe have another look at your `scanf` format strings, because it looks like the number of format specifiers doesn't match the number of arguments you're passing in (6 vs. 5 in the first call, 3 vs. 4 in the second). Also, for the two `%f` formats you've supplied a variable that doesn't look like a pointer. `scanf` requires a pointer at which to store a variable. Also, is there a reason you're calling `fgets()` and then `sscanf()`, as opposed to just using `fscanf()`?
I gave CMock a go but didn't like it as it's all written in Ruby - as someone who doesn't know any Ruby, it was a pain to install all the Ruby dependencies. Then, once I had it all installed it wouldn't run and was spitting out Ruby errors which stumped me. fff looks nice, would be keen to hear what you think of it if you try it out!
There was also a Windows Sdk which contained a make version called nmake IIRC.
We currently use CMock for unit testing our projects, can't say I've used the others though. Aside from getting the ruby environment and build system set up (which isn't that bad really), writing and executing tests is pretty straightforward. Pros: - After setup, development and execution is straight forward - mocking interfaces are intuitive and make sense - execution is simple, just call `rake` - Isolates each unit completely. Each test file will rebuild an executable with just the required/tested source for the test functions within - Runs off-target. Integrates nicely with CI tools/build servers. Also nice for systems where there's not enough memory to run on target. Cons: - Runs off-target. I'd like to be able to run on the hardware, since there are differences in how things compile down and whatnot. - modifying the test runner does require ruby knowledge. - By default the runner will execute ALL tests, so during test development it's a pain to debug just that test module you're writing. The workaround is to move files out of the test directory so the build system doesn't find them.. - uses a rake/YAML build system. We tend to use Makefiles, so integrating the two was kinda hacky in order to autogen YAML with the source files, include paths, and defines. For simpler projects (don't require mocking), I'd require just using Unity (same devs as CMock). It's a nice and thorough library, but easy to integrate into the project (2 headers and a source), and runs on target.
There is also `nmake` for Windows, part of Visual Studio, I think.
What is the question?
Ok cool the error's fixed, but I'm not sure how to go about storing multiple strings in a single node. Could you please clarify how to solve that issue?
What does the testing library provide that main() + assert() do not?
Did you read the attached article? :P Some things you don't get with assert statements: * ability to easily mock functions * ability to check what arguments functions are called with * easy asserting of things other than == (for eg. Memory equality, if a value is in a set, if a value is in a range) * test output consumable by build systems for regression tracking
&gt; How I Wrote a Client-Server App in Two Minutes Flat... &gt; yesterday 3 min read Ironic?
Learn C the Hard Way (there's an online pdf) is a fairly good resource that explains makefiles decently enough to get your feet wet. As a first book on C I would say hell no but if all you care about is make then it would be fine. 
`int main()` is what it needs.
You mention two situations. Booting from thumb drive or ran on the OS. Case 1 CMOS knows to boot thumb drive bootloader, you pick partition to boot on thumb drive and then what? the OS loads from the partition or your code works without bios calls and loads utility programs that works without bios. I assume the first option because the OS does stuff. /etc/inittab I think loads a program on startup on windows autoexec.bat now does the booted os support the format? ntfs fat32 etc? case 2 if you got this far you can easily do this. Either case CMOS password sounds best
You mentioned in your original question that "each line of input goes into just one node". Is there a reason you've changed your mind about this? In any case, you can't have variable-sized structs in C. If you want to put an array in a struct, it has to either be a fixed-size array, or a pointer to a dynamically-allocated (`malloc`-ed) array.
it gives the same error. void main () (or any other valid return type) will avoid the error. The error is of course a soft error and does still compile/run; it is just stating that as you didn't specify the return type, it did i(n)t for you.
The original K&amp;R code does things that are legal, but considered poor form, these days. One of those things is assuming the type of a returned value. The reason that's considered poor form these days is it's more often human error than a voluntary choice; mostly when one of those is omitted it's because someone forgot. In order to support better code, even though that's legal, compilers still choose to warn developers, since it's reasonable to expect that that's a mistake. However, yes, implicit types are legal C. Incidentally, you can get fixed-width formatting by putting four spaces in front of your stuff. That way you don't have to fake spaces to get by.
It's important to distinguish between warnings and errors. This is a warning, not an error. Something isn't an error unless it's illegal (or unless a developer has smartly promoted warnings to errors.) Warnings are things that are undesirable or probably wrong. Errors are things that are definitely wrong.
No, not really. An array by definition is a fixed size throughout its lifetime, so you can't change it as you go. At your level, the normal way to do this would be to declare a sufficiently large array (but check those limits). For example, how likely is it that a user of your program will enter more than 1000 characters? char array[1024] = {0}; //Declare and zero a 1k char array int i = 0; //Loop counter while (i &lt; 1023 &amp;&amp; ch = getchar() != '\n') //Check limits of array array[i++] = ch; //Assign char and increment i 
void is not a valid return type for main(). Only int is.
[This guy](https://www.reddit.com/r/learnprogramming/comments/54dabj/c_reading_data_from_a_text_file_into_a_struct_and/) must be a classmate. Watch out for his issue so it doesn't trip you up too. You might want to turn up your compiler warnings if you're not seeing problems with the sccanf format and arguments.
But what if it *is* likely? What workaround would be preferable?
Allocate the array on the heap, then reallocate if you need more space.
In C, a pointer and array are very similar. For example, assuming the pointer and array are accessing the same size thing (e.g., a byte), then pointer + 5 would be the same as array[5]. In this way, you can use the pointer solutions from Stack Overflow except with the array syntax.
thank you, I'll do it normally
You cannot becuase string literals are stored in a read-only section of memory. To change what is held in a string, the pointer should be in read-write memory by using the malloc and realloc functiins and strcpy function to modify strings. char \*stringLiteral="hello"; Char \*safeToWrite=malloc(size of(char)\*strlen("Hello")); safeToWrite=strcpy(safeToWrite, stringLiteral); safeToWrite=realloc( safeToWrite, size of(char)\*strlen(Hello world); SafetoWrite=strcpy(safeToWrite, "Hello world"); Attempting to write to a string literal will produce a segfault becuase you are trying to write in read only memory
ok, I'll try it,thanks
I wasn't sure about if it could even be rewritten. I think I need to brush up on my strings/pointer knowledge. Thanks for the tip.
Improved the formatting a little bit and gave a slightly better example. On my phone in a bus so sorry if it's not perfect but I hope it helps!
Alright I can see that this works. However doesn't that conflict with what /u/johntmssf said? Sorry I'm still really new to dealing with pointers/memory, especially with strings.
This clarifies it a little bit, thanks! Would you say in general, it's better to use char[] or char*? I'm planning on making a small text adventure game as my first """"big"""" project, and so far have a structure like this: typedef struct{ char* name; char* description; } Room; Wondering if it'd be better to declare the name/description for each room as an array instead? Thanks again for your help.
The short answer is no. The long answer is yes. An array needs a fixed size at compile time in order for the program to allocate enough memory. Other people's answers are helpful in this respect. You can, however, declare an array with no size as the last element of a struct: struct message { int len; char data[]; }; When using the example above, you can provide a subscript. Consider the following data at location p in memory on an x86: +--+-+-+-+-+-+-+-+-+-+-+-+-+--+ |12 0 0 0|H e l l o W o r l d \0| +--+-+-+-+-+-+-+-+-+-+-+-+-+--+ struct message *msg = p; &gt; msg-&gt;len 12 &gt; msg-&gt;data[6] W Be careful that the memory you are reading is the memory you want to read.
You can always implement a memory pool. Increment the size of the pool (by some factor) and copy the new data over if the bounds are exceeded. Advantage: Use only the memory you maximally need. Keep the heap from getting too fragmented. Disadvantage: Performance penalty for reallocating memory and copying.
I thought the most convincing argument was the templatized array bounds checking. It made me smile. It's kind of a red herring, though. You would never really do this in C++ since there are better options such as vectors.
In many ways, this is true. I have spent way too much time trying to analyze how some (very elegant) template applies SFINAE or other such magic to accomplish something that really should be part of the language. In comparison, GO eschews these fancy bits in favor of productivity. I get that argument, but I do enjoy the elegance of some of the C++ solutions for their own sake. If I were managing a team and had tighter deadlines, the GO argument would be a lot stronger.
`void main()` is not a declaration of `main` described in the C standard. Your compiler can allow it but it's not portable and its effect is not predictable either.
IMO I didn't really find it extremely convincing. The problem with what he was attempting is that the `size` has to be static. You can 'get around' that via using templates, but the code bloat will be massive since you'll get an entire new 'pipeline' of functions for each size of array (The compiler might fold them into each-other, but I'm not sure I'd really count on it), and none of the functions would be usable by code which doesn't know the size at compile time. IE. Any type of dynamically allocated array. That makes them fairly unusable in a lot of circumstances. Vector's are generally better in a decent amount of cases, but can't be used in every circumstance that normal arrays can, so it is what it is.
Fixed point and interpolation of lookup tables.
The expression `(ch = getchar() != '\n')` will assign the result of the `!=` comparison to `ch`. You probably want `((ch = getchar()) != '\n')` instead.
Huh. I just compiled this (-O3): #include &lt;iostream&gt; template&lt;typename T, size_t val&gt; T accumulate(T (&amp;someArray)[val]){ T result = 0; for(auto x:someArray){ result+=x; } return result; } int main(){ int foo[] = {0,1,2,3,4}; int bar[] = {9,10,11}; int x = accumulate(foo); //&lt;-- 10 int y = accumulate(bar); //&lt;-- 30 std::cout&lt;&lt;x&lt;&lt;'\n'&lt;&lt;y&lt;&lt;'\n'; } 0x100000ab9: movb $0xa, -0x1(%rbp) ;&lt;--The value '10' is calculated at compile time. 0x100000abd: leaq -0x1(%rbp), %rsi 0x100000ac1: movl $0x1, %edx 0x100000ac6: movq %rax, %rdi 0x100000ac9: callq 0x100000dae ;&lt;-- cout 0x100000ace: movl $0x1e, %esi ;&lt;--The value '30' is calculated at compile time. 0x100000ad3: movq %rax, %rdi 0x100000ad6: callq 0x100000dd8 ;&lt;-- cout Both template functions were elided and the scalar result of the template functions were determined at compile time. Of course, I had to try something similar in C and I got similar results (with -O3 again): c-test`main at main.c:10: 0x100000f50: pushq %rbp 0x100000f51: movq %rsp, %rbp 0x100000f54: leaq 0x33(%rip), %rdi ; "The answer is:%d" 0x100000f5b: movl $0xa, %esi ; &lt;-- Compiler figured out the answer statically. 0x100000f60: xorl %eax, %eax 0x100000f62: callq 0x100000f6c ; symbol stub for: printf 0x100000f67: xorl %eax, %eax 0x100000f69: popq %rbp 0x100000f6a: retq Edit: Admittedly, this is quite a bit contrived, but it does demonstrate that reality doesn't *always* match expectations, for better or worse.
I get the same warning.
Using anything other than int is a violation of the standard.
Oh damn my tired mind. I meant void main() not main(void). Thanks friend. 
I haven't changed my mind, I probably just explained it poorly. The program's supposed to print for user input and then scan the whole input into a single node. The input will also be made up of multiple strings. The program will eventually be a text editor, but I'm just implementing this basic functionality first. For a solution to this, I'm going to try scanning in each individual character of input into a fixed length array, and then using makeNode, create a single string from this array and turn it into a node. Hopefully it works. EDIT: ok wow it worked, can't believe I didn't think of this before.
No need to be sorry!
Personally, I haven't and see no reason to.
I would highly recommend reading certain sections, specifically on undefined behavior and signals across architectures if you develop for multiple platforms :) 
While I would not necessarily recommend someone set out to read the entire contents of ISO/IEC 9899:{_1990_,_1995_,_1999_,_2001_} cover to cover, it is definitely something I would suggest everyone have easy access to (a copy on a shelf, a PDF in your files somewhere, etc). It is a long document that is not easily read; it is written to be unambiguous, not pleasant. That said, _I_ found it a powerful learning aid. It is possible to read small sections very specific to a part of the language and doing so every now and then, about something relevant to current work, can quickly provide a deeper understanding of what you are doing without making your eyes gloss over. If nothing else the concise descriptions of grammar are very, very helpful. As an aside: the book [C: A Reference Manual](http://www.careferencemanual.com/) is a very nice annotation of the ISO document that provides quality examples, and descriptions. If you don't feel that reading standards documents are for you, this might be a nice alternative.
File system access is much improved with C++17 or the [filesystems TS][1]. [1]: http://en.cppreference.com/w/cpp/experimental/fs 
I have read the entire thing. It's a very complex document but reading it clears up a lot of misconceptions, for example regarding how the preprocessor works. You don't need to read it but you should be able to find your way around it when you have specific questions. If you work on UNIX, also consider having a copy of the [POSIX standard](http://pubs.opengroup.org/onlinepubs/9699919799/) at hand for reference.
Yes, that's why I picked it out specifically. Very exciting!
tl;dr All of this would work. Long explanation: First of all pointers are just normal variables like int and char, too, that simply store memory addresses (as you probably already know). So in that sense you can reassign those address values the same way you could reassign an integer value to a respective variable. Secondly there's a distinction between stack and heap memory. Those strings in your example are allocated on the stack (memory region for temporary values) because by definition their scope is limited to the function they were allocated in and as such are not automatically preserved until your program terminates. They are being released as soon as the function exits. This has two implications: 1. If you assign the address of a stack allocated string to a pointer variable and you try to access that string (via the pointer) after the function has exited you have no guarantee that it will still be there 2. If you know you need to retain a string that is being created in a function you will have to manually allocate memory from the heap beforehand via malloc. Two example functions to illustrate: char *get_stack_string(void) { char *string = "Stack String"; // will be null terminated return string; } char *get_heap_string(void) { char *string = malloc(6 * sizeof(char)); string[0] = 'h'; string[1] = 'e'; string[2] = 'l'; string[3] = 'l'; string[4] = 'o'; string[5] = '\0'; // null-termination byte return string; } int main(int argc, char **argv) { char *string = get_heap_string(); printf("%s\n", string); string = get_stack_string(); // no guarantees here printf("%s\n", string); // could result in gibberish } The fact that you don't have to allocate every string manually and fill in character by character is basically 'syntactic sugar' :)
Second this. If you want C to be your goto language for everything, then researching how it works under the hood wouldn't hurt. You might find some functionality that you didn't know about before, or a way to exploit something that it does that's been bugging you lately.
Having a variable called `p` set to `1` doesn't mean that a users entry of the letter `p` will use the value `1`. The name of a variable is meaningless except to the human reader.
In C string length is the distance from the pointed to location to the next null character in memory. In other words a string is terminated by all binary 0's
I am not sure what you mean. `fopen()` gives you a pointer to a new `FILE`. Can you give us an example?
&gt; Can I open and close the same FILE pointer multiple times in the same program? Yes. FILE *fp; fp = fopen(...) fclose(fp); fp = fopen(...) fclose(fp); is fine. 
Arrays are like labels, pointers are a variable. char ar[] = "abcd"; char *pt = &amp;ar[1]; pt = ar; Notice pt or the char * can be reassigned. It can also be incremented. pt++; That's cause it is a variable just like other variables. It is just of type char pointer. There is a level of indirection with pointers. The variable pt has an address in memory, I go to that address and interpret it's data as another address. As opposed to ar which is a label to an address. When I type ar... I'm essentially writing a hardcoded address, except it has a name to make it easier to remember. When passing an array to a function, the ar decays to a pointer. You can mostly use them as the same thing. But a char * pttoar[]; is an array of type char pointer.
If you mean opening and closing the same actual file multiple times, it will work, but you should think about if you really need to do that. If you mean you want to use the same variable to hold the result of another fopen call, as long as you already called fclose on it, you won't have any problems. When you call fopen, it allocates it for you, and it's freed when you call fclose. 
&gt; If you mean opening and closing the same actual file multiple times, it will work, but you should think about if you really need to do that. Yes, this is what I want to do. Unfortunately this is the only way I can think of to write my current program because of memory constraints. Edit: I've edited my original post to FILE stream.
There are too many uses for a pointer to say why all you would use it. But essentially you use an array if you know it is small enough amount of memory that the operating system will allocate enough space for, and you don't want to manage the memory. If it is too large, your process will be terminated for overflowing the stack. The allocation of the array would be setup as the os creates the process, usually on the stack. On unix based os, you can type ulimit -a and you can find out how large your stack can be.
The file being open won't affect the memory use of what you've read from it. The `FILE*` variable just holds a pointer to some structure that holds the information the standard library needs to be able to access that file. I assume you're allocating a buffer for the data with `malloc`, reading with `fread`, and then freeing the buffer with `free`, right? You can also use `fseek` to jump around in a file; you don't have to read everything sequentially.
Remember how number systems work and use code like this: num = (a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d) where `a`, `b`, `c`, and `d` are the bytes that make up the number you want.
Beware alignment.
Exactly. Try `%llx` to print the number in hexadecimal.
Oh and you might need to cast each part to unsigned long long before.
Yeah, I saw that being used in linked lists. I could easily extend it to tree-based structures and hash tables, but I can't figure out an effective implementation for cache critical data structures (i.e. vector). The point of the library was an object oriented approach similar to what is done in C++. It's not particularly efficient in terms of executable size, but it does make the code cache friendly, and (debatably) easier to read. I need to put some more time into it to find a good compromise.
I am still learning this myself, but from what I understand you start off a function with what you want to return. For example if your function returns a int your function will start: int foo(); As for the bottom you just return something if you are changing a value.This is prob. not correct though.
The basic role of a function is to take some values(integers, floats, or whatever), do some computation with them, and produce a result. This is exactly the same concept as functions in mathematics. The "void", "int", "float", parts of the function declaration is just stating what kind of variable the function creates. Declaring your function as "int userfunction()" means that the function will compute an integer. Declaring the function as void is just saying "This function does something with the values, but doesn't actually give anything back". Void functions are usually used for things like printing to the screen, saving files, etc, where it not make sense to give a value back. The "return" statement at the end of the function is your way of saying "I'm done calculating. This is the final value." You input values into the function using the function parameters, which are the variables declared in the brackets of the function declaration. So say we wanted to make a function that computed the length of the hypotenuse of a right-triangle using the Pythagorean theorem. Then we'd write it like this: #include &lt;math.h&gt; /* contains the definition of sqrt. */ /* * "A function that calculates the hypotenuse that takes two floats and * returns a float." */ float calculate_hypotenuse(float a, float b) { /* Pythagorean theorem states that c*c = a*a + b*b */ float csquared = a*a + b*b; float c = sqrt(c); /* * You could also combine these two lines to * "float c = sqrt(a*a + b*b);" */ return c; /* "c is the final result" */ } Then when you want to calculate a hypotenuse of a triangle with side length, say, 6 and 8, you would call the function like float x = 6f; float y = 8f; float hypot = calculate_hypotenuse(x, y); 
I can't imagine writing native software on Windows.
Embedded terminal and job control, which vim only just got.
That does help. Thanks!
fgets reads until a new line is found. Your strings include the new line and it shows up when you print the string.
I believe fgets() is taking in the name and the newline that is typed also. So what's stored in firstname is "gr33n3r2\n" instead of just "gr33n3r2" as you would expect. So when you call printf() with the firstname as a format parameter, it substituted the %s with "gr33n3r2\n" instead of "gr33n3r2", and the \n (as I'm sure you know) causes the output to skip onto the next line. If you search for the \n char in the string and set it to \0 instead, it will cut the string off at that point for printing purposes.
Do not post code as images. Always post text so we can edit the code and test things.
There's no such thing as an "intrusive vector", you are right :) A [growing] vector can be kept a vector, it's efficient and great. The non-intrusive ("container") approach to hash tables, lists, trees is not only inefficient in executable size - it is also *less* cache-local because of extra indirections you will need in many cases. For example, if you want your data indexed by two hash tables simultaneously, you're forced to use an extra indirection in at least one of them in the "container" approach. It is much more cache-friendly to have 2 intrusive hash nodes inside the data structure. It is also more asymptotically efficient. Worst-case deletion of an element you've already found (via any of the hash tables or any other way) intrusively, is a cheap O(k) where k is the number of the hash tables/lists it is in. Worst-case deletion from k containers (even assuming hash tables, not lists) is worse. Lastly, the container approach requires dynamic allocations in the container code, which also ruins cache locality, performance, and perhaps worst of all -- inject error cases you will have to test (or pray) all over your code.
&gt;I was more getting at the point that a lot of C++ programmers wouldn't know if what he did was even valid in the first place - and after that, which changes would cause it to stop being valid and which wouldn't. IMO, this argument is somewhat supported by the fact that during the talk (directed at people familiar with C++), he says that it's valid and then hand-waves over the details. The reason he glossed over virtual dispatch is that most of the people at the conference are very into C++ and are (generally) good at reasoning about code written in it so they can already understand why it works. In addition, I can't think of a good reason why you'd ever want to use inheritance for that kind of thing anyway, let alone virtual inheritance. Should he have mentioned it? Yes, I think it's an interesting point to mention. &gt; In C, such a worry never even really comes up unless you have to consider padding (Which is a problem for both languages) - everything is syntactically separate from the `struct` to begin with, and in C the compiler isn't going to 'add' any extras to your `struct`. Fair enough. 
The idea is to have the `void` pointer point to the object you want to store. The idea is not to use the value of the pointer to store an integer. If you apply this concept, it's easy to see why having a structure of `void` pointers is a good idea.
You can actually limit this with scanf, using something like this: char s[20]; scanf("%19s",s);
No problem. Some times it's useful to have somebody else look over your problems when you got stuck.
Yeah, thanks anyway got it working now with unit tests.
If you have a set of fixed strings, and you want to switch a pointer to refer to different strings while the program is running, you can do something like this: (At the top level in the file) static char const str_1[] = "string 1"; static char const str_2[] = "string 2"; Then in your function: char const * str_p = str_1; ( then later ) str_p = str_2; Note a few things: first I have declared the arrays to be of type constant character. This is because I want the compiler to warn me if I try to change their contents. The compiler may put strings in your program into a read-only part of memory and trying to change that memory would cause undefined behavior (likely a crash). This just sort of makes the code explicitly say that it should be treated as read-only. This assignment (from an array type to a pointer type) takes advantage of the fact that when you reference an array like I'm doing, on the right-hand side of the expression, the type "decays" from an array type to the type of a pointer to element type of the array. The result is a pointer to the first character in the array. In other words, it takes on the type of &amp;array[0]. You could write that explicitly, but it isn't necessary and C programmers generally understand what it is doing. Lastly, note that I have not specified the size of the arrays. I left the brackets empty. The compiler took care of it for me and also put in the terminating zero character in each string for me. Note that this only works when you initialize a character array from a _literal_ string in your program! It does not happen if you declare a character array of some fixed size and fill it up later, or initialize it differently. If you need the actual size, you could use sizeof(). Oh, and it is just my particular style to write "char const" instead of "const char" -- in these cases you can reverse them and it does not change the meaning. It only matters whether the const is to the right or the left of the *. For example if I had written: char const * const str_p = str_1; The compiler should _not_ let you change it later because you have declared the pointer itself to be constant, as well as the type of data you are point to.
I'm sorry. First post on subreddit I should of taken the time to actually read. I've been learning non-stop C for the past 2 days and I'm on Chapter 8 where we start learning about if checks.
Good luck! Have fun learning!
My book will probably teach me that but I've just reached if checks in chapter 8.
How do I search for \n character in the string and set it to \0?
Thank you. I originally tried this but it didn't work for some reason so I typed 15 instead and it ran the program. I think it's because I originally didn't have CHRLIMIT as const int. Had it as something else instead, can't remember what.
Thank you! I thought learning C before I go to community college for programming in c++ or c# would be super beneficial.
Good idea! Though C# is unrelated to C.
fgets is not guaranteed to include the newline if there isn't enough space for it. You need to check that `firstname[strlen(firstname)-1]` actually is a newline first.
C# is Microsoft's response to Java. It's a Java clone called C# (as in C++++) to grab the attention of C++ developers. It's by all means not a C-like language. However, Objective C is C like, so you might also want to look into that.
So it's checking if the last character in firstname-1 is \n, and if it is to replace it with \0? That's how I'm understanding it right now. You guys are also introducing me to the strlen function. Which I assume means string length. I also learned I needed a new header file in order to use this.
&gt; the -1 is subtracting a character off the end of the stdin. Technically, the -1 is substracting the position you want to edit inside that string by referencing it via the brackets. Practically it delivers the effect you described. You can use &gt;firstname[position] to select the character at the *position* location and do whatever you want with it. You can use this to search inside the string for whatever character you desire with a for/while &gt;for(DWORD i=0;i&lt;len;i++) &gt;{ &gt; print("this character %c has this position %d", firstname[i], i); &gt;} Try the above to see this in action. Also note that /u/crossroads1112 used the variable *len* which I mentioned above to set the condition of the for's cycles to while *i* is smaller than *len*. Using *len* to store the result of *strlen()* is important because it saves time when using the character string with the same length. Using the function strlen inside references of character positions as you did above &gt;lastname[strlen(lastname)-1] is only useful if the length of the string changes and you wish your code to adapt. In production code you will want to keep sizes inside separate variables and update them if necessary. &gt;So it should of been put after the fgets because the char firstname and lastname isn't defined until then. Yes, keep in mind though that *strlen* is a function which has specifications and it does have limits. Strlen will stop once it reaches the '\0' character which you *can* put inside your strings if you so choose to. This means that you will obtain an ending of your string before you reach the end of the data it contains. This means that should you use strings and encounter many \n and/or \0 characters you will want to use a cycle as described above to wipeout all \n characters it contains and end your cycle at the CHRLIMIT you defined for the strings. 
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { const int CHRLIMIT = 16; char firstname[CHRLIMIT]; char lastname[CHRLIMIT]; printf("Type your first name: "); fgets(firstname,CHRLIMIT,stdin); if ( firstname[strlen(firstname)-1] == '\n') firstname[strlen(firstname)-1] = '\0'; printf("Okay, %s, now tell me your last name: ",firstname); fgets(lastname,CHRLIMIT,stdin); if ( lastname[strlen(lastname)-1] == '\n') lastname[strlen(lastname)-1] = '\0'; printf("Pleased to meet you, %s %s.\n",firstname,lastname); return 0; } 
As the ISO C standard (C99) says, `size_t` is an unsigned integer type of at least 16 bit (see sections 7.17 and 7.18.3). `size_t` can store the maximum size of a theoretically possible object of any type (including array). It is defined in `stdlib.h` and `stddef.h`.
Exactly. Well it appears to look and work OK... or does it? Why not test it with a nice twenty character firstname, and see if you can figure out what it does and why.
&gt; for(DWORD i=0;i&lt;len;i++) The compiler doesn't allow me to use the for function. Says it's only ran in C99 or C11. Tells me : error: unknown type name 'DWORD'| error: 'for' loop initial declarations are only allowed in C99 or C11 mode| note: use option -std=c99, -std=gnu99, -std=c11 or -std=gnu11 to compile your code| error: 'len' undeclared (first use in this function)| note: each undeclared identifier is reported only once for each function it appears in| &gt;Strlen will stop once it reaches the '\0' So since fgets automatically puts \n at the end, I can use the ifcheck another user suggested so it will always read the stdin? if ( firstname[strlen(firstname)-1] == '\n') firstname[strlen(firstname)-1] = '\0';
Why the need to focus on c like languages, learn Scala
Well I was told that if I want to be a programmer I should learn older languages so that if I ever run into a program with an older language I will know what to do, and not have to be that guy that says I have no idea.
it will be good enough for basic input, yes. It won't cut it if you insert more than one '\n' into the input though. as for errors, sorry, i'm too used to working with windows api. &gt;typedef unsigned long DWORD; you can just use *int* and it should cut it. as for the "for" loop, it's just a placeholder for a while cycle anyway: #include &lt;string.h&gt; int main() { const int CHRLIMIT = 16; char firstname[CHRLIMIT]=""; int i=0; printf("Type your first name: "); if(fgets(firstname,CHRLIMIT,stdin)) { len=strlen(firstname) i=0 while(i&lt;len) { print("this character %c has this position %d\n", firstname[i], i); i++ } } } has the same effect. (i hope this'll cut it for your compiler, i haven't used a different one in years). If you write the above and use more than 1 \n in your "firstname" input notice what happens. Now use "len=CHRLIMIT" instead of "len=strlen(firstname)" and see what happens. This won't happen for the if proposed earlier. Now use some '\0' in your input and see what happens with both limits in this code.
So is it possible (I don't know how to do it but theory crafting) to make an ifcheck that if firstname &gt; 16, skip the program to a seperate section made in the program that does printf("Name is too long for this program, please limit it to 15 characters."); prior to the original printf that uses firstname, then use a command to send it back to asking for the users first name (Say line 1 of the program)?
Yes it is possible. You will soon encounter the joys of loop constructs for sorting out repeating blocks of code and how they will flow.
Well I already bought a C programming book. But it's only the beginning C language so once I'm done with this which I'm a quarter way through I'm just going to attend community college for programming.
This is actually exactly what I did. Spent the last 2 months or so learning C with *C Primer Plus* by Stephen Prata, and I just started CC this past Monday. I'm taking an intro to C++ course and we've only covered data types (int, strings, char, double, etc.) but I'm really glad I had the practice with C beforehand. Very beneficial, good luck and happy hacking!
Yeah I knew it was setting to 0 since it had just decremented, just didnt know if there was a way to reset it. Thank you.
~~Uhh... recursively calling `main` *definitely* invokes undefined behavior...~~
Just make a while scanf() != -1 loop, if I understand the return codes from scanf properly. At least, read() will behave that way. scanf() may be different. To handle higher amounts of variables, you may need to malloc() to store the data. Hmm. Or maybe a struct with a pointer to the next (previous?) element. Something like that.
If the user can enter as many numbers as they like, you'll need to use a linked list or allocate a dynamic array on the heap. Here's a simpler example with a hard coded maximum: float numbers[MAX], next; int i = 0; printf("Enter values, Ctrl+D to end: "); while (i &lt; MAX &amp;&amp; scanf("%f", &amp;next) == 1) numbers[i++] = next; EDIT: Probably should also print MAX to let the user know. printf("Enter up to %d values, Ctrl+D to end: ", MAX);
No more than `MAX` numbers can be stored in the array `numbers[]` with the code there. If you want more, you'll need to use `malloc()` and `realloc()`. Note the importance of `i &lt; MAX` in the `while` loop. Omitting this is a vulnerability. 
This video covers that very question: https://youtu.be/1uRLdP-m6nM
I assume you mean floating point numbers, not floating point "ints" (int is short for integer, which does not have a floating point) 
You can use `realloc` the whole way without special initial procedure: `realloc(NULL, `... behaves the same as `malloc(` ... 
Not mentioned yet: when writing a function body, the code before the `{` counts as a declaration. So you are in fact declaring `main` at the same time as you are defining the body for it. 
This is my solution which is a "bit" obscure but does the job. #include &lt;stdio.h&gt; int main(void){ int l; scanf("%d", &amp;l); l++; printf("+"); int i, j; for(i = 1, j = 1; i &lt; l*2; j &lt;= l ? j++ : (i++, j++) ){ printf(j &lt;= l ? j==l ? "+\n" : "-" : i &gt;= l ? i == l ? "+" : "-" : "|%*c%*c%*c\n", i &lt; l/2+1 ? i : l-i, l % 2 == 0 &amp;&amp; i == l/2 ? '\0' : i &lt; l/2+1 ? '\\' : '/', i &lt; l/2+1 ? l-i*2 : l % 2 == 0 ? (i-l/2)*2 : (i-l/2)*2-1, l % 2 == 0 &amp;&amp; i == l/2 ? 'X' : i &lt; l/2+1 ? '/' : '\\', i &lt; l/2+1 ? i : l-i, '|'); } printf("+"); return 0; }
posted it there too, no reply
If anyone is curious why, I think it's because very old C++ compilers used to handle the problem of calling static initializers / global constructors by emitting the code to do it at the beginning of `main()` before the user code. If you called `main()` recursively that code would run again. Modern compilers don't do that, they have stuff in the runtime startup objects (`crt*.o`) that runs before `main()` to handle it. And of course in C, static initializers must be constants so this doesn't really pop up. 
'return' outside function. i am getting this error sir.
This subreddit is about programming in C only. Please ask Python questions elsewhere. I have removed your question for being off topic.
So the -1 is just incase they reach the limit it will still add a \0 at the end?
Okay thanks for that. Much appreciated. Can't wait for my next days off so I can hit the book again.
Happy programming! :-)
Two concepts here loop till &lt;ctrl-d&gt; while loop will work for this. Data structure to hold input numbers could be static large array MAX size or could be dynamic linklist 
When you have `int a[5];`, type of `a` is `int[5]`, or in other words a is a static array of 5 ints. When you have `int *a;`, type of `a` is `int*`, it's a pointer. Size of a pointer is platform dependent - usually 4 or 8 bytes. Size of a static array is the number of bytes in that array - in your case its 20 cause we have 5 ints each of which is 4 bytes long. So, sizeof works by determining the type of its argument and array size is part of the type definition for static arrays. Usually, static arrays and pointers both are used in pointer arithmetic which can confuse some to believe both are same. The value of a static array variable (which is the address of that array beginning) can never change, while value of a pointer(i.e. address its pointing to) can and usually does change.
Yes, but can I print out/see the bits of the characters/variables in an easy way? All I have been able to do is print it as "normal" text, which doesn't help much.
No, I didn't expect the values to be different, they are all pointing to the same memory location. The problem is that I need to find a way to store each iteration of i without the problem that all elements on the stack are pointing to the same memory location. So you should do something like this: stack_push(struct stack_t *stack, void *data) { ... // create a new element and add it to the head of the stack // pseude-c like allocate memory and add the data stack-&gt;head-&gt;data = malloc(sizeof(data)) stack-&gt;head-&gt;data = data }
The problem with this is that "stack_push" doesn't know how big the thing pointed to by the (void *) is. You need to handle that _before_ you call stack_push(). 
Thanks, for you input. I'll try to fix that problem. What about the rest of the code, is it any good? XD
The compiler is telling you that there's something wrong on line 16. Look at line 16...do you see anything wrong with it? 
I tried fff on a simple program to get my feet wet, it's just a simple header and the unit test code flow seemed more intuitive compared to CMock. In FFF: You call the target function, and then assert stuff In CMock: You tell it what you want to assert, and then call the target But it *seems* like CMock + Unity is a big advantage once you get to know it. 
This is line 16: x = logical_right_shift; Isn't the value returned by the function an integer? I should simply get a 32 bit value as a result, then print it. 
How do you call functions in C? 
Oh shit you're right, I didnt even do the thing. As I said, very new to C. I added y = logical_right_shift(x, k); printf("%04x", y): It fucking worked.
To an extent, I think as long as you are comfortable in any scripting language you should be fine. My goto is always Python, so I'm not terribly well-versed with Ruby and was able to make some customizations (changed up the build/config process, print out some versioning info to the report). More than likely you only need to modify one file (`rakefile_helper.rb`) at the project root so you don't need to dig through the library too much, unless your changes are much more extensive
sizeof works well with predefined types, not so well with void pointers.
When you create a new element inside the `stack_push` function, it simply assigns the data to `element-&gt;data`. The stack's elements retain a pointer to `i`, even as it goes out of scope for every iteration of the for loop. This is undefined behavior that can cause major security vulnerabilities. A possible solution in the example is using a 4-element array to store the numbers pushed in the stack.
One thing I noticed is that you use `assert` for basic error checking. All assert calls are disabled if NDEBUG is \#defined (e.g. most production builds). In C, you really need to handle program errors on your own: asserts are best used for debugging programmer errors, not a replacement for exceptions in other languages. 
Awesome, thanks for letting me know! Will have to give it a go sometime.
One thing to keep in mind is while `int a[5]` on line 12 is an array, the function parameter `int a[]` on line 3 is a pointer equivalent to `int a*`. When declared as a function parameter, arrays ["decay"](http://www.iso-9899.info/wiki/Code_snippets:array_decay) into an ordinary pointer. As a result, the `sizeof(array)/sizeof(*array)` trick does not work if `array` is a function parameter (it will produce a size of 1).
There are many contexts where you *want* a type's size to vary with the platform, in particular it is very common to want a size that tracks that native machine word size. `long` sort of works for that if you restrict yourself to Unix and Unix-like systems, but it's completely out when it comes to Windows. What you really want is `size_t` (if you need an unsigned type) and `intptr_t` (if you need a signed type) when you need something that tracks the native machine word size. Wanting a type that tracks the native word size is really what you want whenever you are dealing with sizes or indices. So using `int32_t` as the iteration index of a for loop when you're going to index into an array, or the size of a buffer that you're allocating, would be a complete disaster. It would lead to all kinds of issues (like overflow vulnerabilities) when you try to port your code. You definitely do not want to do that. The only times you want sizes to be fixed is when you're reading or writing fixed format data, such as binary files or network protocols. 
Using fixed-width typedefs also means using those unwieldy printf/scanf macros, like PRIu32. Unless there's a specific need for a fixed size (like a binary file format), they probably aren't worth it.
`uint32_t` isn't large enough to represent all possible valid indices/sizes on a 64 bit system. For example, if you wrote something like: void clear_array(T *ptr, size_t size) { for(uint32_t i = 0; i &lt; size; i++) { ptr[i] = 0; } } (Yes, obviously you'd use `memset()` for this, but assume this is a simplified example and there's more in the loop in a real program.) `i` could overflow, causing an infinite loop and denial of service vulnerability if `size` is under an attacker's control (which it usually is for anything network connected.) There are all kinds of related problems, like calculating the size using too narrow a type: int num = get_num(...), len = get_len(...); T *some_ptr = malloc(num * len); You can search the vulnerability databases and find hundreds of cases of things that boil down to this that result in remote code execution and all kinds of very bad things. 
What error do you get?
Ah, thank you for correcting me!
yeah but in C!
That "vulnerability" exists even if you use `unsigned int` instead of `uint32_t`. If you used `int` and it was a 16-bit system you'd run into the same problem. You use `uint32_t` if you are sure that you need 32 bits and don't need more than 32 bits. Also `uint64_t` is also available if you need it. Simply using `int` does in no way safeguard you from the overflow errors you are referring to.
fixed width types restrict your software to the platforms that support those integer types. consider a potential host environment with 8-bit chars, 24-bit shorts, 24-bit ints, 'n' 48-bit longs ... you got int8_t, int24_t, int48_t available, but not int32_t. compilers/libraries implementing standards earlier than C99 may not supply &lt;stdint.h&gt; at all, so people targetting older platforms may not have fixed-width types at all. keep those limitations in mind. now say you're writing an emulator, and you want to implement an addition operator which adds the value in a 16-bit register named "b" to a 16-bit register named "a". with fixed width types this looks like this. #include &lt;stdint.h&gt; struct cpu { uint16_t a; uint16_t b; /* ... */ }; void operator_add(struct cpu *p) { p-&gt;a += p-&gt;b; } standard integer types, you got the following implementation, which requires more work on the programmer's part. struct cpu { unsigned a; unsigned b; /* ... */ }; void operator_add(struct cpu *p) { p-&gt;a = p-&gt;a+p-&gt;b &amp; 0xffff; }; so you can evaluate the trade-off in this particular situation for yourself. edit: just to comment on why I chose this example ... for general-use case there's no real advantage to using fixed width types. each standard integer type has a minimum required range. (see http://port70.net/~nsz/c/c11/n1570.html#5.2.4.2.1p1 for those.) if you adhere to those ranges and don't exceed them, the types are interchangeable. ([u]int_leastN_t is often preferable wherever you care about conserving storage, BTW) with data serialisation, you're converting an external representation to an internal representation. there's more factors to it than the above example making it a bit more complicated to illustrate, however since you get to decide the internal representation, it boils down to a similar thing: you can support all the cases with more software, or you can emphasise situations where both representations line up and you can rely on type-punning ... with emulators you're supporting a bunch of different operators. think about how this trade-off would scale to subtract, multiply, etc. not only on registers but on immediate data, addressed data, etc. and you can see that it's a fairly reasonable use-case for fixed-width types, and one situation where using loosely-defined types (or even arbitrary-precision types) can be cumbersome.
I never advocated int. That's just as broken. I advocated using types that track the native machine word size, which int does not. 
&gt; uint32_t isn't large enough to represent all possible valid indices/sizes on a 64 bit system. ‚Ä¶ search the vulnerability databases and find hundreds of cases ‚Ä¶ x86_64 is considered a 64-bit system, but only allows 48-bits of physical memory. If your objects are 64kb each *or larger*, you can *and should* index them all with a 32-bit unsigned integer. This is also important in protocol design. The biggest reason we have security vulnerabilities is programmers not thinking about what they're saying carefully enough. DJB's thoughts on security [ten years after qmail](https://cr.yp.to/qmail/qmailsec-20071101.pdf) boil down to *make less bugs* and *make less code*, so I think it is important we try to be as clear as possible *at least in our minds*.
The signature for that function (from [here](https://www.postgresql.org/docs/9.1/static/libpq-exec.html)) shows that `PQexecParams()` takes 8 parameters, but you're passing in 10. I haven't used this library, but it looks like you should be building an array of pointers to pass in, instead of just throwing the `buffer-&gt;` arguments in. Function Signature: PGresult *PQexecParams(PGconn *conn, const char *command, int nParams, const Oid *paramTypes, const char * const *paramValues, const int *paramLengths, const int *paramFormats, int resultFormat); Also, I'm not sure if this was just a cut and paste error but you should probably have a line continuation within your string argument, or just have it on the same line. Something like this: PGresult* res = PQexecParams(connection, "INSERT INTO person(first_name, last_name, age) \ VALUES($1, $2, $3)", 3, NULL, buffer-&gt;person.fname, buffer-&gt;person.lname, buffer-&gt;age, NULL, NULL, 0); You should be getting errors about this though.
In "C Interface and Implementations" (David R. Hanson) the author uses assert a lot to implement checked runtime errors. Lot of people said it was a good read to become a better C programmer. But it's written in 1996 so maybe some advice in there is outdated or just plain wrong. But to solve this, it would be better to use: if ( !stack ) { return; } instead of: `assert(stack);`
Well, to be fair, the essence of Go is a long way away, including automatic garbage collection, interfaces (templates), *language* constructs for threads &amp; thread comms, multiple return values, etc. 
Not sure why you got the downvotes. It's an interesting little challenge and your code works.
This is really interesting, thanks for sharing. I bookmark this and will use it instead of PHP for my next project on my home server.
&gt; you can and should index them all with a 32-bit unsigned integer. Why *should*? Not trying to be antagonistic, genuinely interested. Incrementing a 64-bit instead of 32-bit int shouldn't take any more time on a 64 bit machine, storage of the indices shouldn't matter for 99% of the situations unless you're storing a large list of indices. I like ints where possible due to no stupid unsigned/signed casting warnings but that's a pretty terrible reason.
&gt; Why should? As a programmer you should strive for clarify of thought, and for the ability to say what you mean. Coding around warnings usually means you have neither. &gt; storage of the indices shouldn't matter for 99% of the situations unless you're storing a large list of indices You should not think about memory as so inexpensive you can be wasteful with it. [Knuth wrote](http://www-cs-faculty.stanford.edu/~knuth/news08.html): *It is absolutely idiotic to have 64-bit pointers when I compile a program that uses less than 4 gigabytes of RAM. When such pointer values appear inside a struct, they not only waste half the memory, they effectively throw away half of the cache.* He's referring to the fact that your CPU likely has only a few kilobytes of RAM -- everything else comes from a serial device we call "main memory", and it has a speed of about ten gigabytes per second. That's pretty fast when we're talking about hard drives and network interfaces, but it's got nothing on the on-chip RAM (often called L1)
That's great! I mainly use Python too, so I guess I should be able to use CMock well enough then 
So I went through your code last night and came up with a list of all the good / bad design decision you made, and how they could be improved. Good: * Documentation. The readme gives nice examples and tells us what you were thinking in the design process. These sorts of documents are very important * Full unit test coverage * Generic data structure through `void*` paramaters Now onto the things that could be improved... * `stack_t` is a bad name, as all `*_t` names are reserved. Choose a different name * You reveal the entire implementation of the data structure with zero benefit. In stack.h you should only have an opaque pointer declaration to (I'll rename your stack structure to s_stack) `struct s_stack*;` and all your functions should go through that pointer (which your functions already do). This also lets you move the declaration of `element` outside the header file, perserving global namespace. * Linked lists are good for infinite series, but things are rarely infinite. Consider moving to `malloc`'d arrays and using slab allocation to drastically increase performance. Ask me more if this is unclear. * In stack.c, just include stack.h so that you don't need to repeat all the definitions in the header file. This simplifies a lot of things! * You need to check for `malloc` fails. * For `stack_pop` you should also check for `size &gt; 0` * As of right now, `stack_free` is dangerous and can cause massive memory leaks. Consider the following. s = stack_new(); int* arr = malloc(sizeof(int) * 32); stack_push(s, arr); stack_free(s); As of right now your structure allows this and the free function will drop any heap allocated pointers into the abyss, making it fairly useless to clean the stack. If you have any other questions feel free to reply.
How did you get on with this? I find myself in the same position...
Thanks a lot for the code review! The lessons where we learned C at my university of applied sciences were bad. The teacher was a math teacher by trade and explained C poorly, he also didn't understand pointers so he had this vague mathematical explanation that nobody understood. I "learned" pointers from The C Programming Language book that I bought from a friend of mine. So my knowledge about C is probably outdated. I have lots of question so lets answer each bullet point. 1. Didn't know that *_t was reserved, I knew about int8_t etc but not that *_t was reserved, will fix that. 2. About include the whole stack struct, I use stack-&gt;size for example in the unit tests. Could I fix this by creating an additional header file that will only be used by test_stack.c? 3. Never header of slab allocation so I read a bit about them on wikipedia. From what I understand you allocate a bunch of memory and with multiple slots which can hold a piece of data. When the data is not needed anymore the slot will be used for another piece of data without using free() to freeing the memory. 4. Didn't know about this little trick, thanks. 5. Completely forgot to check if malloc() returned NULL. 6. Will fix that too. 7. To be honest I was quite proud to implement stack_free(). It worked the first time and valgrind said everything was fine and no memory was leaked. But your right when pushing pointers on the stack that point to memory there will be memory leaks. Some other questions: * Should I just remove stack_free() and assume that the user of the stack will use stack_pop() until the stack is empty? * How can I free memory when somebody pops an item from the stack that holds a pointer to allocated memory: s = stack_new(); int* arr = malloc(sizeof(int) * 32); stack_push(s, arr); // with stack_pop we just leaked 4 * 32 = 128 bytes of memory stack_pop(s); stack_free(s); Thanks in advance
No idea either, the OP's attempt was more than likely what the teacher was after. Best I could manage was this low-tech approach which like totally has no loops but all the if's you want, well his teacher and the guys here probably disagree... #include &lt;stdio.h&gt; int main(void) { int rows, midpoint, odd, lc0, lc1; printf("Enter whole number for the number of internal rows: "); scanf("%d",&amp;rows); if (rows%2 == 0) odd=0; else odd=1; midpoint = rows/2; lc0=1; printrow: if (lc0 == 1 || lc0 == rows+2) { putchar('+'); lc1=1; tpbtminr: putchar('-'); lc1++; if (lc1 &lt;= rows) goto tpbtminr; putchar('+'); putchar('\n'); } if (lc0 != 1 &amp;&amp; lc0 != rows+2) { putchar('|'); lc1=1; printinner: if ( lc0-1 == lc1) { if (odd == 1 &amp;&amp; lc1 == midpoint+1) putchar('X'); else putchar('\\'); } else if ( lc0-1 == rows-lc1+1) putchar('/'); else putchar(' '); lc1++; if (lc1 &lt;= rows) goto printinner; putchar('|'); putchar('\n'); } lc0++; if (lc0 &lt;= rows+2) goto printrow; return 0; } 
dear god why
Will try to implement what you suggested, some things are little vague but I will take that as part of the learning process. If I'm done with the changes or have questions I will notify you. Okay? One question I immediately had was that if malloc returns NULL how do I notify the user that there isn't enough ram to allocate his data. Because currently stack_push returns nothing. Something like: * return 0 is success * -1/1 if error ((L)unix uses a positive integer if there is an error, so it is expected by a lot of C programmers that a positive integer is an error, right?
Yeah feel free to PM me or comment here. Your idea for stack_push sounds good, +1 is the more common choice.
Note: typo in my declaration in stack.h. You'll want to define the abstract data structure as `struct s_stack;` with no `*`.
Already figured that out XD. Make didn't like it.
&gt; My goal is to recode Malloc. I did it. But i observed that my function always allocate 'too much' memory. When i do : sbrk(sizeof(char)); &gt; &gt; the char * return can be a array of 8 length like my example... so why ?! By the definition of the function, it shouldn't be possible.. 
Sorry, i thought it was clear... I just dont understand how sbrk() works... Cause i recode a malloc, but sbrk(sizeof(char)) (which return a char * of 1 length array, can be used with 8length array...)
&gt; It would appear that the call to printf in your example causes 0x21000 bytes of heap space to be allocated false &gt; which means the first 0x21000 loop iterations are sucessful false &gt; If I remove the printf line, it segfaults in the first iteration - however OP's example runs just fine. Because the behavior depends on so many variables, that it's pretty much unpredictable when it will work and when it will crash.
Could you post the exact source you are using? The program you posted won't even compile for me.
The result is i can always access of the data of test, event with the free... - last print of 'test' is : kajjjjj How is it possible ? Because of page ? 
I checked with GDB, this is definitely what's happening. Comment out the printf and try yourself. If you use GDB, you'll see it crashes on the first iteration. 
cannot post all, too long and too much dependencies :-/
It's an advanced topic...[Wikipedia](https://en.wikipedia.org/wiki/Memory_segmentation). The last address is the first pointer outside of what your program is allowed to write to.
Uhh, I don't see any `sbrk` in there...
Formatting is bogus; read up on Markdown before you do too much posting. This works because you‚Äôre lucky. `sbrk(0)` gets the end of the program‚Äôs data segment. On most systems, memory is divvied up into contiguous segments (sometimes backed by CPU protections, usually backed by paging protections) that are easier than trying to manage individual data structures flung about indiscriminately. Traditionally, your memory layout was either [CODE][DATA][STACK ‚Üí‚Üí] free [‚Üê‚Üê HEAP] or [CODE][DATA][HEAP ‚Üí‚Üí] free [‚Üê‚Üê STACK] depending on whether the CPU incremented or decremented its stack pointer register (respectively). The latter one is by far the most common and a teensy bit more elegant, although it‚Äôs vastly oversimplified with regards to any non-embedded or DOS-based system currently in use. Anyway, this is the model `brk`/`sbrk` refers to: - *CODE* above refers to ¬±the machine code generated by the compiler/assembler. In a binary object or executable file, this is typically represented by the `.text` section. (How object and library files get mashed together to form an executable or in-memory image is a whole other topic of its own, well over the 10K character limit. \^_\^ Either way, note that I‚Äôm using **segment** to refer to a contiguous in-memory zone, and **section** to refer to the data in files that gets loaded into segments. The two concepts should not be conflated, although they are related.) - *DATA* refers to the static data referred to by it (e.g., string or array content; large constants like vectors or floating-point numbers; `static` or global variable values). The data segment typically includes at least two sections, `.data` and `.bss`, with `.data` containing initialized data and `.bss` containing uninitialized or auto-zeroed data. Example later. Usually there‚Äôs an additional `.rodata`/similar section for constants, so that paging or segmentation can mark them read-only. All told, a fully composed data segment typically looks like code‚Ä¶ ][RODATA][DATA][BSS][ ‚Ä¶heap - *HEAP* refers to the space used by dynamic memory allocation, such as `malloc`/`free`. In this (terribly oversimplified!) model, if there‚Äôs not enough space in the HEAP to satisfy an allocation request, the end of the heap is bumped upwards towards the stack, hopefully not actually into the stack itself. The heap starts at size zero, and in order to help track the heap size the kernel keeps a ‚Äúbreak pointer‚Äù that can be incremented and (theoretically, but almost never in practice) decremented; heap_size = brk ‚àí end_of_data basically. - *STACK* refers to the area used for temporary LIFO allocations, most typically including function activation records (i.e., scratch space for executing functions). C calls this the ‚Äúautomatic‚Äù storage area, which is the basis behind the super-useful keyword `auto`. The stack size is determined by the architectural stack pointer register and usually recognized as a special auto-expanding zone by the kernel so the program doesn‚Äôt segfault when entering a new page (page fault ‚Üí allocate so it won‚Äôt happen again). As function calls are made, the stack pointer decreases towards the break pointer; as returns are made, the stack pointer is increases towards machine infinity. I‚Äôll mark up where you‚Äôd expect to see things in the following, for illustration: int integer; // ‚Üí .bss const int mebi = 1048576; // ‚Üí .rodata static const char *message = "Hullo wurld"; // message ‚Üí .data // *message ‚Üí .rodata char other_message[] = "Olluh dlruw"; // ‚Üí .data int func( // ‚Üí .text int x) // ‚Üí [STACK] or register { const char foo[] = "FOO"; // ‚Üí [STACK] or register static const char bar[] = "BAR"; // ‚Üí .data struct stat st; // ‚Üí [STACK] register int *z = malloc(abs(x)*sizeof(int)); // z ‚Üí register or [STACK] // *z ‚Üí [HEAP] ... free(z); switch(x) { // [jump table] ‚Üí .rodata case 0: case 1: case 2: case 3: case 5: case 8: case 13: case 21: return -1; // ‚Üí register or [STACK] case 4: case 16: case 256: return 0; // ‚Üí register or [STACK] default: abort(); } } All that aside, when your program first starts up you have no reasonable expectation that there‚Äôs any heap space actually mapped yet, whatsoever, even though you do have all that free address space. Assuming you‚Äôre abiding by C and POSIX standards and all the traditions thereto appertaining, calling `sbrk(0)` will get you the end of BSS, which may well be unmapped. You then start poking willy-nilly into it, which will either kill you immediately via segfault or bus error, or trash whatever‚Äôs already there (possibly setting up a later crash) if it succeeds. This is well into undefined behavior territory, in other words, and it‚Äôs only due to a wise and generous kernel that it runs to completion. Furthermore, I don‚Äôt recommend expending too much more brainpower on this: `brk` and `sbrk` are entirely vestigial at this point, and deprecated per recent POSIX. If you want to look at the actual layout of a running program and are on Linux/Android, run `cat /proc/self/maps` in the shell and you‚Äôll see the `brk`-based `[heap]` nestled amid a whole bunch of other stuff, most of which is dynamically allocated without making any use of that `[heap]` area. Typically *if* the break pointer is used, it‚Äôs used under the hood (special-cased in the kernel) and only nudged around to carve out space for smallish allocations. Bigger ones are typically maintained in a different area due to lifetime and granularity differences, and might be allocated entirely on a page-by-page basis rather than byte-by-byte, or even make use of different page sizes (e.g., 4-/2-MiB pages on x86). Your `malloc` may vary. These allocations are requested via the super-useful `mmap` function, which lets you allocate entire pages at once with all sorts of useful options (e.g., large pages, setting permissions, mapping in file contents), and then `malloc`/`free` carve out their own byte-wise blocks from inside the pages they‚Äôve set aside. The linker/loader also uses `mmap` to place thread-locals (TLS) and dynamic libraries well out of the `sbrk` range, and it‚Äôs used to throw the stack(s[!]) up there too, even if the first one is lined up right after the break-heap. (With all these sections plus a big chunk taken for the kernel and I/O windows, you can see why having a 64-bit address space is a useful thing. 32-bit gets crowded fast, even if the segments aren‚Äôt fully used internally.) Also you didn‚Äôt return a value from `main`, which is a bad idea. Also, if anyone else is reading your code, best just to use `argc` and `argv` for `main`‚Äôs parameters. ‚Äôs basically an idiom, a tinny echo from dear mainframes bygone. (sniff)
fwrite allocate memory too or juste printf ?
I'm not sure. Any function called between `sbrk(0)` and the `test[foo] = bar` could potentially be allocating heap space.
Yeah i run it on OSX and Ubuntu 14.04, and it works :-/ 
it is on my malloc function.. But the result is the same as on my original post
There's your issue. Other C functions that you might be using for debugging are also using the default malloc() implementation - This is essentially causing heap corruption. You should either: 1. Not use any C library functions that make use of malloc() internally 2. Use `mmap()` to ask the kernel for your own block of memory.
Thanks for your complete reply. Let me check that.
mmap() does give you full control of the memory. See /u/nerd4code's answer, it's very well explained.
I understand the memory segmentation, and 'where my variables goes'. But i dont understand why i'm lucky : just because i have free heap memory allocated by default ?
On CPUs with native word size 16-bit, `size_t` can be 32-bit. 
in that case you selected the wrong type altogether ... lol
Try adding a print statement inside of the problematic for loop to get a better idea of what may be happening.
&gt; strcmp codeblocks doesn't recognized this
It's declared in `&lt;string.h&gt;`. Did you include that header? 
Either the kernel started you out with some `brk` space (at least one page mapped), or something before `main` was called set that up. You‚Äôre guaranteed neither.
Unless you have the original source code to the program ‚Äî which you almost certainly do not if the people selling it intentionally crippled it ‚Äî then it doesn't matter what language it's written in, because that information is gone. It would be like asking for people that can read French to analyze a cookie recipe that you think is written in French, when in fact you don't have the recipe at all but only the cookies. At that point you'd be looking for someone to reverse engineer the cookies, not for someone that can read French. It sounds like you want to commission a programmer to write a program for you from scratch. There are certainly places out there where you can do that, but this subreddit is not one of them. And it really doesn't matter what language you use, in fact doing it in a dynamic scripting language like Python or Perl would almost certainly be less costly than doing it in C. Any general purpose language is more than capable.
Thanks so much for the reply. I"m a very "techy" person but have never really delved into programming, so I totally understand what you're saying about the source code. I never thought about it like that but it sounds exactly correct. As far as python goes, I've read that C would allow the program to work faster than python or an equivalent would, and when literally milliseconds matter, I need the fastest program I can get. There's 100% chance that that statement could be entirely incorrect, but like I said, that's just what I read. I am not at all attempting to argue with you, so please don't mistake my tone. As far as getting someone to write a program for me, do you have any idea where I could find somebody to do that? A subreddit? A website? 
This isn't a unique request. Programmers get propositions for the "next killer app" constantly. There's never any promise of money up front, and the deal is always sour for them at the end - despite having done all the work. Honestly, this sort of thing isn't hard to scrape together. Have you considered learning to code yourself?
Well, forgive my inappropriate title. I have absolutely no intention of baiting and switching anyone and payment would of course be provided up-front. Nevertheless, thank you for your reply. I have absolutely considered learning to code myself and will probably end up doing that if I can't find anything else. However, with school, law school apps, and other obligations I'd like to avoid adding programming lessons to the list. 
Have you heard of strcpy()?
That's exactly right, but i could still potentially be in need of your services as well. Thank you very much for the reply and if I end up needing you, I will be sure to reach out. Thanks again! 
If milliseconds really matter, then it seems like the location of the machine that runs this code matters more than the language. In other words, Python is certainly capable of responding within a few microseconds (if not hundreds of nanoseconds ‚Äî modern CPUs are extremely fast) but that hardly matters if the time it takes the request to traverse the network is 50ms - 75ms (possibly more), which is like three to five orders of magnitude larger that the time it takes a program to respond/process. It would make more sense to rent a server in the same building as the remote machine than to worry about the speed of the program. 
What have you done so far?
#include &lt;stdio.h&gt; int main (void){ int var1 = 0; double var2 = 4.2; char var3 [] = ""; printf("please input an integer: "); scanf("%d", &amp;num1); printf("please input a character: "); scanf("%c", num3); printf("%d%lf%c", &amp;num1, &amp;num2, num3); return 0; } 
When calling printf, don't use the '&amp;' sign before variables. The last printf should be: printf("%d %lf %c", var1, var2, var3); 
I really like your approach, I find your loopless solution very creative. Thank you for posting it!
Strings are arrays. When you check equality of pointer types, it checks if the pointers are equal, which is the same as saying if the locations are the same, not the contents. You'd have to check that the contents are the same, one byte at a time, until you get to the 0 at the end of one or both strings.
i dint get
You didn't post code so it's a little hard to know what you are doing, but if you declared the struct in the header you just need to include the header in file2 and file3.
I have now also officially implemented FastCGI to work with CHL.
&gt;Does the function prototype need to be the same as the function definition when it comes to the # of arguments? I realize we can do without the variable in the prototype but how about the # of arguments? Yes, all the arguments must be the same in the declaration and definition. The only reason you can leave the variable name out of the declaration is because the compiler doesn't need to know/care about that. &gt;Can the number of inputs be less, when a function is called, than the number of arguments a function definition have? If a function definition has 3 arguments, would it be possible to just call he function giving it two inputs? No, not really. If you defined a function to take exactly three arguments then you must pass it exactly three. The only exception to this rule is variadic functions using the `...` operator which will allow you to pass as many arguments as you want at your own discretion. This is what `printf` uses, because it can't know in advance exactly how many arguments you will want to pass without looking at the format string at runtime.
int main (int argc, char *argv[]) C does not really follow rules. You can point to locations at random, pass arguments that are not used or use arguments not passed. Its called chaos. If you want the program to actually work and do something constructive you may not want to do that. The above main has an int called argc that says how many strings will be passed in the character array pointer argv. Its kind of like claiming ownership of land at the bottom of the Atlantic ocean. You probably wont get an eviction notice but your pot plants won't grow very well there.
C doesn't require that array bounds are checked. The result is undefined behavior -- that is, *anything* can happen. Don't do it. C will not normally stop you from doing silly things like this; you have do your own sanity checks.
It may or may not work depending on how the compiler and operating system lay out memory (i.e., where variables and function arguments/return values are stored). Typically memory is allocated in 4KB chunks as that's how most common hardware works. Since your program is less than 4KB, and only contains a main function, it is not causing any problems. If your program had more functions and variables in it then it could overwrite either the variables or function stack. If it overwrites other variables in the function, then the array accesses past x[9] would read/write from an area of RAM that is also being accessed by other parts of the program and you will see strange results when comparing or printing variable values (depending on which ones the compiler put next to it in RAM). This type of bug is one of the hardest to catch and fix in large programs. Your program could also overwrite the stack where addresses are stored for function calls and return locations. If this happens, you likely did not write a valid virtual address into the corrupted memory, so the program will just crash. If you put printf calls before and after the function call, then you will see that the function is called but doesn't return. If you put a printf inside the function on the first line, then you will see that although the function was called, the first line (i.e., your printf) doesn't get called. This also happens if your operating system doesn't give your thread enough stack, usually if you have really big arrays/structures (multiple MB/GB) inside a function instead of as global variables. If you completely overrun your 4KB of allocated memory, then you will likely get an access violation.
Array declarations require a size that is fixed at compile-time. But what if we don't know how many elements the user will need? Let's solve this problem by implementing a dynamically growing array! Wanna try skorbut yourself? https://github.com/fredoverflow/skorbut-release
Hi again. So far your code is looking much better, you've done a great job! I'll step through each topic separately. ## Block allocation So the problem with using a standard heap allocated array, or allocating and freeing things all the time is that both `malloc` and `free` are slow. To get around this, we need to be a little more creative about how we actually allocate and relase our data. Consider the following scenario: We have some program that must allocate **up to** `N` elements onto the heap, where `N` is (relative to the system) large, say a few MB. If we don't want to request a large percentage of whatever system we're working on, we can't just allocate the whole thing at once and be greedy, especially if we only ever need `M` heap allocations for most of the program execution. This is exacerbated if `M &lt;&lt; N`. To alleaviate this problem, we will define some cutoff constant *a priori*, say `SLAB_ALLOC_CUTOFF` to some reasonably small value. This value is based solely on personal preference and system resources, so it would be a great example of something you could put in a configure script and prompt the user for at compile time, with some general default value. For our example, I'll set it to 256. In the function `stack_alloc(1)` the user must supply some maximal value for the stack height. This is `N`. Now, if `N &lt; SLAB_ALLOC_CUTOFF` we can simply allocate up to `N` spaces in a flat array with `malloc(1)`. However, if `N &gt; SLAB_ALLOC_CUTOFF` we will only allocate up to `SLAB_ALLOC_CUTOFF` space initially, saving some of the runtime resources for other parts of the program until we need them. This complicates our data structure a bit, forcing us to keep track of another size variable, `size_allocated`, the current allocated amout of space for the stack. Now, if the size of the stack reaches `size_allocated` and we need to push a new value, we need to allocate another `SLAB_ALLOC_CUTOFF` worth of space for the system. This is repeated on requirement until we hit the maximum stack size, where an error would be thrown. However, in most cases that won't happen and the stack will begin to shrink. Then, `if (size &lt; size_allocated - x * SLAB_ALLOC_CUTOFF)`, where `x` can be decided by you (must be larger than 1 (why?? you tell me!)) , we must free the unused space and any content left inside the stack. This means all we have to do to pop a value off the stack (usually) is return `size--` and that's it. When pushing, if the datafield is already used (i.e. we were using it to store something already, but haven't gotten around to freeing it yet) then we simply free the element there and then put our new pointer in. This also solves some of the performance hits with `stack_pop` that you mentioned. The key takeaway is that you aren't using a linked list, but a flat array that you dynamically stretch and compress in size as needs require. I apologize if it is still a little unclear, if so I'll try and find some literature to point you to. EDIT [here](http://pastebin.com/Crd0yLni) is a rough example I had sitting in an old abandoned project. It implements the idea I just mentioned but may be riddled with some shitty bugs, so read it as an example, not an emulation. Fox
I assume you are double clicking an icon to run it? Try opening a DOS box (command prompt) [I assume you're on Windows as you mention .exe files] and running it from the command line. The output in the command prompt window will still be visible until you close the DOS box.
C hasn't changed all that much in the pat 17 years from C99, so anything published past then is a pretty safe bet to be "modern". [Advanced programming in the unix environment](https://www.amazon.ca/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739) is agood book, as is [expert c](https://www.amazon.ca/Expert-Programming-Peter-van-Linden/dp/0131774298), and essentially anything off of [this](http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list) list from the intermediate and above sections. Looking at code is always a great idea when it comes to learning "idiomatic C". [I posted this](https://www.reddit.com/r/C_Programming/comments/47mk4x/compilation_of_c_software_design_principles_and/) compilation of books, articles, and example FOSS code bases that was well recieved, so maybe take a look at that also.
Write #include "abc.h" at the top of file2 and file3 
Thanks, will probably take a look at some open source C projects to get a better grip on how people write C that is viable in the real world.
Not an ISO C function however. Also, only really works for English case.
ABC x,y; this Declared in file1...in file2 and file3 how its available by just declaring header file
Awesome. We just need a tutorial to use it with SQLite.
* Can you read properly above reply,fuck off(I know basics). * in file2(without declaring ABC x,y,as per your suggestion only including header file how its possible) * Suppose if i declare same thing ABC x,y in file2 its become duplicate. * My aim is one prototype declartion in file1 and i should acces structure in other fileN(n number of files)
Rewrote it using std::vector-- works great, thank you. Still wonder how I was corrupting memory...spent a couple of hours in gdb..no idea..
Just in time! I'm using C11-like threads with tinycthread, but I have a need for structured threading. Exactly as described here - http://libdill.org/structured-concurrency.html#what-is-structured-concurrency My concern is if this is portable? With what does it work under the hood? (I'll have to go through code, obviously). edit: for those of (us) that use std=c99 and pedantic in gcc. Use std=gnu99 for asm and -isystem instead of -I for libdill location, if you still want to use -pedantic. It uses "braced-group within expression", meh.
You could try using some of the [unicode](http://www.fileformat.info/info/unicode/block/geometric_shapes/list.htm) characters
What will happen? *Anything* could happen. Here There Be Dragons. Enter At Your Own Risk. Ever read the back of a Burning Man ticket? Every book on C should come with the same warning in the preface. In practice, your code will go stomping into memory beyond the end of the array, and whatever the compiler allocated into those memory locations will get clobbered. This could be anything, including the return address on the stack for your own function call. Once you clobber the return address, the `return 0;` statement could go anywhere and anything could happen. C was basically invented as a replacement for assembly language. It lets you do whatever you want and doesn't try to protect you from yourself. A better compiler, with warnings turned on, would have alerted you to your mistake, but you're still allowed to do this if that's what you really want. Arguably this is C's biggest weakness: it lets you overflow array bounds anywhere you want. Most software security holes are caused by this. If you're going to be a C programmer by profession, you need to adopt a very paranoid attitude to possible array overflow situations.
Also, name[] was either undefined or filled with zeros the first time it was tested. A better construct would have been: do { ... } while (strcmp(name, "quit") != 0);
SDS is pretty great. I did [something](https://github.com/tavianator/bfs/blob/master/dstring.h) [similar](https://github.com/tavianator/bfs/blob/master/dstring.c) when I wanted dynamic strings without any external dependencies. But for larger projects I would just use SDS.
Hmmm. I may be jumping the gun on what your professor has taught you, and maybe you should just stick with that. I may be talking about things you'll get to later. If you want to stick to scanf(), you could do: scanf("%254s", name); This will keep scanf() from overflowing name. But for now, probably just stick to what your professor's teaching.
Without reading your code too carefully, I suspect you have done something like this: struct A { void *data; int foo; int bar; }; int main(void) { A *ptr = (A *)malloc(sizeof(A)); // data, foo and bar are all uninitialized/garbage at this point // You need to call malloc again on data if you want to use it ptr-&gt;data = malloc(sizeof(something)); ptr-&gt;foo = 0xF00; ptr-&gt;bar = 0xBA5; // now you need to free both pointers free(ptr-&gt;data); free(ptr); }
&gt; Hint: display code by indenting four spaces in front of every line. That's annoying. I wish Reddit would just use Markdown instead of this weird format.
I solely use sized ints, they're easier to understand the purpose and size.
This VERY MUCH depends on the type of loop. I'm not sure what kind of code you write, but I've NEVER had to loop anywhere near 4 billion times in a single loop...
You need to look at the return value of scanf
Yes, "Canis" and "Lupus" would be two different entries. But it wouldn't get stuck, as I thought earlier.
bstring ?!
Lol only an absolute madman would write hello.c in ~. 
Sounds similar to the learnbchs.org 'stack' 
Another vote for antirez's SDS. ICU4C in the mix sometimes as well.
There are two "string" libraries I can recommend: [¬µstr](http://www.and.org/ustr/) and [vstr](http://www.and.org/vstr/). Very high quality, and clear design goals. There are other good things about [libowfat](https://www.fefe.de/libowfat/) that if you were using it anyway, I think it would probably be okay to use its strings. Strings are usually wrong though. What you usually want is a better array interface (since strings are naturally a byte-array). KX's [c.o](https://a.kx.com/q/d/c.htm) is an excellent array interface.
Havn't used them myself yet, but planning to use them for an upcomming project.
C11 threads are castrated POSIX threads. There is no reason to use them, the whole thing is a terrible idea.
Okay, now I know that pthread is almost supported by anything, I'll use pthreads instead of c11 threads. Thanks!
What are you doing that you don't know the size of the loop? for example in AVC, if it's 3D you'll have to loop twice, otherwise once. When writing that loop, you know damn well how many times you'll need to loop. Speaking of strings, I'm writing a UTF-8 string handling library, and my max "code unit" (byte) size is 65535, so I just use a uint16_t to index that loop...
Include `&lt;string.h&gt;` and use `strlen(char *)`. `strlen("32c")` would return 3 (3 characters, `3`, `2` and `c`), so you subtract by one to get your desired 2, the index for the lastest character in an string. This isn't python. With `input[-1]`, you would access the memory BEFORE the string. It is equalent to `*(input + (-1))` (or just `*(input - 1)`).
Negative indexes point to memory **before** wherever your pointer is pointing (arrays are effectively pointers). Generally speaking a negative index will be incorrect. What you want here is something along the lines of: int len = strlen(input); scale = input[len - 1]; // last character in string
Implement Gau√ü' algorithm. It's the easiest one and fine for most purposes. If you get stuck somewhere, come back and ask!
I know nothing about threads in C, but I noticed pthreads on cat-v harmful. The raitonale behind this might be a reason to reevaluate ones opinion.
Ok. Thanks for taking the time to enlighten me :)
To be a little pedantic, recursion is considered idiomatic in many functional languages and Tail Call Optimization is mandatory in a few like Scheme, but in imperative languages like C this is almost always best handled with a simple loop. 
It's a pleasure to me. Just as every nerd, I just can't stand if there is something wrong on the internet.
Couple of hints: Check the braces {} match, I think you have some missing/in the wrong place. Be consistent with indentation so it's easier to see if things don't match. You seem to have two functions called main, the one at the top likely has the wrong name. The top one returns a value (the float max), but the function is marked as a void - these need to match. That should cure a few of the errors/warnings you should be seeing. 
Thank you. It seems that I have been misinformed in this regard. Still, it boggles my mind that they left in these few minor incompatibilities to POSIX.
&gt; So Windows had threads for at least 2+ years (probably a lot more given development time) before pthreads was a real standard. Also, they were in direct competition with UNIX platforms in server space at this point. Windows threads aren't special in this regard. There have been many predecessors to pthreads, in UNIX-land as well as elsewhere. Pthreads were created to solve the problem of having to use different multi-threading on each platform. As far as I am concerned they weren't modeled after a specific threading library but rather distilled from the advantages and design deficits of what was available back then. The result is a very solid design. Note that Microsoft took part in the standardization process back then (as far as I recall). You can't say that pthreads steamrolled Microsoft's ideas. &gt; Beyond that, POSIX has never been a C standard, and never will be. POSIX is based on UNIX and is not OS agnostic -- C is a programming interface that wants to be everywhere. POSIX is separated into two parts: utilities and system interface. The latter part is pretty much an extension to the C standard library. POSIX has been specifically designed to be implementable even by non-UNIX systems. Even Windows has a POSIX compatibility layer (though Microsoft has purposefully made it pretty useless), saying that pthreads can't be chosen because they aren't OS agnostic is a very poor argument, they could have torn out all the POSIX specific parts (e.g. the details of signal masks) and everybody would be happy. &gt; I'm probably not qualified to say whether or not the design of C11 threads is "good" or not --- but I can tell you that having a platform-independent API for them in the language certainly is a good thing, and that complaining that they didn't use pthreads is just silly. I wouldn't have complained if C11 threads actually did something in a different manner. But even careful reading of the standard document hasn't yielded anything other than that C11 threads are just pthreads renamed, castrated, and with minor incompatibilities as well as some extra implementation-defined behaviour added. Not that there is a macro to find out what behaviour the implementation chose, that would be too easy. So this begs the question: Why not standardize (a subset of) pthreads instead of rolling out your own pthreads clone?
Isn't Dinkumware supplying C++ Standard library for MSVC though? Hence why OP blamed Microsoft.
Looks like a good candidate for a recursive function
Might actually implement SQLite. Pretty thorough, should not be a problem as far as I know.
Yes, I am not creating a new Go. That would be totally overkill.
good enough for me. 
This is quite a broad question. What have you tried/thought of so far? 
It seems you are not converting integers to strings. Rather strings to another format of strings. So strlen gives you the significance of the characters.
Place an `extern ABC x, y;` in "abc.h" and include it into the other files.
If you're having trouble understanding the algorithms, watch them animated: http://www.jamisbuck.org/mazes/
I wasn't asking people to do my homework I was asking for guidance in the way functions...
Listen to this guy
I think you might be having trouble because you're looking at it from the wrong point of view. I would first focus on the data-strictures involved - write them out and work-out how they work. Once you get the data-structures working, writing the algorithm will make more sense. As a note, Prim's can be implemented using a priority queue of edges and a list of 'flags' marking which edges you have already used. There's lot of optimizations you can do, but I wouldn't worry about it too much until you actually get things working. For Kruskal's, it's actually a decent amount of the same. You can use the same priority queue of edges. The 'sets' can be implemented by simple linked-lists of nodes. You make an array of 'heads' of linked-lists, and when you combine sets you combine some of the lists together and then mark the other set empty (For example, by setting that head to `NULL`) so you reduce the number of sets. If you make an attempt on the structures and are still stuck, post them here and I could give a little direction.
&gt; That is why I needed a solution in C Actually it's because you're cheating at homework
Ha good one, you act like I haven't tried that. If you think reading a tutorial and someone explaining how to use a function in your circumstance is equivalent, you are sorely mistaken. Also this may be of interest to you /r/im14andthisisfunny
Thank you for providing some guidance, unlike some others...
If you have a specific question, ask it. "How do I C" and "How do I use functions" is well documented all over the internet. You either need to do some research on your own, or you need 1 on 1 tutoring. Nothing in this subreddit will help you. 
Yes and no. You're getting into it undefined behavior territory. The C standard specifies that you can legally access the elements of the array, and you can perform pointer math on the addresses of elements within the array bounds, and you can form expressions that point one element beyond the end of the array. But you can't form an expression referring to an element before the start of the array. It may work in some implementations but it is not guaranteed to work and technically means undefined behavior. That means the program can crash or wreak other havoc and you're to blame, not the compiler. So I would always recommend programmers avoid practices like this. Of course, if you want to use a negative index with a pointer into an array, you can do that, but staying within bounds of your array is entirely on the programmer. Algorithms doing kind of thing, accessing previous elements, more commonly keep a pointer that lags an element or two behind another pointer, doing pointer math to get their difference, rather than using explicit negative indices.
Edit: Ack! Never mind
Look at this line of code in your stirling2 function: fact = fact * (1 + (1 / (12 * n))); In your parentheses, you have 1 + (1 / (12 * n)), where n is an integer. Since all of the values in that division are integers, C will do a thing called integer division, which is to say that it will take 12 * n, divide 1 by that number, throw away the remainder, and evaluate to the quotient, meaning that (1 / (12 * n)) will ALWAYS evaluate to 0. Let's say n=5. We will get this progression: fact = fact * (1 + (1 / (12 * 5))) fact = fact * (1 + (1 / 60)) fact = fact * (1 + 0) // That is, 1 / 60 == 0 with a remainder of 1 fact = fact * 1 fact = fact
I'm not sure about a "fuck ton of if statement," my soln uses only 8 if statements - and recursion. I suggest thinking hard about this problem in terms of how recursion will help you. As a first pass you might think of solving the problem for numbers less than a thousand. Armed with that you know how to print out the words for you number % 1000. Now you have to deal with the rest, your number / 1000. This is just a rough outline of a general approach. Solving it correctly will require you to refine your code and handle various special cases. I don't want to give too much away and deprive you of the enjoyment of solving it yourself. Here are a couple of points: Numbers less than 20 are a special case - think about all the teens. Numbers less than 10000 are a special case. - 2000 should be "two thousand" not "twenty hundred" - 2100 should be "twenty-one hundred" instead of "two thousand one hundred" Also, some test cases which you may, or may not, find helpful: PrintNumber(UINT64_MAX); PrintNumber(9999); PrintNumber(2100); PrintNumber(2000); PrintNumber(2021); PrintNumber(200); PrintNumber(201); PrintNumber(20); PrintNumber(2); PrintNumber(0); PrintNumber(1999); PrintNumber(1201); PrintNumber(100000); PrintNumber(100001); PrintNumber(101200); PrintNumber(18446744073709551615ULL); PrintNumber(17999999999999999999ULL); PrintNumber(3430); Output from my program - not formatted per your specs (the parenthesized numbers are word counts). 18446744073709551615 = 'eighteen quintillion four hundred forty-six quadrillion seven hundred forty-four trillion seventy-three billion seven hundred nine million five hundred fifty-one thousand six hundred fifteen'(31) 9999 = 'ninety-nine hundred ninety-nine'(7) 2100 = 'twenty-one hundred'(4) 2000 = 'two thousand'(2) 2021 = 'two thousand twenty-one'(5) 200 = 'two hundred'(2) 201 = 'two hundred one'(3) 20 = 'twenty'(1) 2 = 'two'(1) 0 = 'zero'(1) 1999 = 'nineteen hundred ninety-nine'(5) 1201 = 'twelve hundred one'(3) 100000 = 'one hundred thousand'(3) 100001 = 'one hundred thousand one'(4) 101200 = 'one hundred one thousand two hundred'(6) 18446744073709551615 = 'eighteen quintillion four hundred forty-six quadrillion seven hundred forty-four trillion seventy-three billion seven hundred nine million five hundred fifty-one thousand six hundred fifteen'(31) 17999999999999999999 = 'seventeen quintillion nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine'(37) 3430 = 'thirty-four hundred thirty'(5)
No feedback on the code yet, but I would HIGHLY suggest removing that header from your post. Not only does it reveal your identity, but on the off chance that one of your classmates is also lurking on this subreddit they could straight up steal your code and then you'll have a mess of a situation. 
What is the problem with translating the pseudocode to a C program?
[github.com](https://github.com/)
Anyone know the answers to these questions? Thanks if anyone can help out.
Please post the question and whatever you already have as text instead of an image. Images are useless for blind readers and can't be copy-pasted to reference them. --- That said, what have you tried so far? Where are you stuck? Note that this isn't a ‚Äúdo my homework‚Äù service, but we are always happy to help when you misunderstood something.
I have very limited knowledge on the political side of things, but I keep reading here and there that Microsoft's C compiler is even missing proper (or full?) C99 support. Why would they be interested in whatever is happening in C11 and beyond, and why would they even be allowed to make proposals?
&gt; Teacher expects us to know C for some reason Well, this looks like a programming-related test, so why is it that strange to know C?
this ? https://github.com/vadz/libtiff/blob/master/libtiff/tiffio.h
I'll give you a hint; you'll need a conditional loop 
use int functions if you need a return value. EX adding a list of numbers use void functions if you don;t need a return value. EX; sorting a list of numbers 
I wouldn't recommend this, as this isn't cross platform. Using getchar(); has the same effect, and is part of the standard library.
Ok, thank you. :)
This is not an answer to your question, just a small suggestion. It's great that you're writing comments; comments are awesome! That said, writing a comment like `// setting again equal to true` above `again = TRUE` conveys no additional information to anyone reading your code. The same principle applies to writing `if the number is lower than zero` over `if (n &lt; 0)` and many of the other comments in your program. Comments shouldn't translate every step in your program into English -- they should explain what's going on in more complicated/non-obvious areas of your program and perhaps explain why something is done a particular way.
As far as time complexity goes, yours is about the same as their second solution, better than their first solution. I don't believe it is possible to beat O(n) for this. Both of their algorithms are O(n), as is yours, but their first solution's actual runtime is around 2n, because it loops through twice. As far as space complexity goes, your solution is worse. Your algorithm will create a new array, while their solutions work on the original array.
Oh! Thanks a lot , is there any way that even i can use one array for my solution?
Do these books describe methods for handling memory leaks &amp; stack corruption? Realizing that I'm not so savvy in looking out for those kinds of things...
Gah, yes, of course I was. Fixed.
Absolutely. The King book is closer to a traditional C book in that it doesn't focus too much on what is generally accepted practice much beyond the C spec. But 21st Century C goes well beyond this, showing you how to use GDB and Valgrind (this one is essential if you're using dynamic memory IMO), and goes into detail about modern practices to minimize having to malloc all the time.
Have a look at *Numerical Recipes in C*, it is a pretty good book with detailed implementations for all the algorithms described (linear systems solvers too). I agree with FUZxxl, implement Gauss with partial pivoting. It is a good learning exercise and will test your C skills.
Thanks for the recommendation + info! 
I like https://learncodethehardway.org/c/ by Zed Shaw
Learn C The Hard Way is terrible IMO. It is rife with bad advice and undefined behavior. Seriously though, C is really easy to learn wrong and Learn C The Hard Way makes it even easier.
I've found it rather careful and good in that regard, but I've read some chapters a year ago when it was far from finished and thus neglected a few things as being unfinished. I can't remember anything much bad though, can you give a specific part that was bad?
Writing one line of code at the top of each file is not much of a headache. What was your question anyway?
Note that `'a' + (25 - (c - 'a')` is just `'a' + 'a' + 25 - c`. Furthermore note that the C standard does not actually specify that all letters are adjacent in the encoding (e.g. on EBCDIC that's not the case).
Library operands (i.e. `-l...`) are only used when linking. The default operation mode of the compiler is to preprocess, compile, assemble, and finally link. You can make the compiler stop at each of these steps with the flags `-E` (preprocess only), `-S` (preprocess and compile) and `-c` (preprocess, compile, assemble). Only if you specified none of these flags the library operands are evaluated or actually needed. That said, if the presence of `-lmylib` doesn't make a difference during linking, it's likely that your program either doesn't use any of the symbols in `mylib` or that all symbols you use are provided by another library you link to (e.g. the standard C library; `-lc` is implicitly provided to the compiler). So in your build scripts, only include library operands at the linking stage. &gt; Does this also mean that I "force" any developer that uses mylib to include all dependency libs by hand? The answer to this question is ‚Äúit depends.‚Äù When you link to `mylib` statically, then you have to provide all dependencies by hand as a static library doesn't contain any dependency information. When you link to `mylib` dynamically (i.e. `mylib` is a shared object) then you don't need to, the shared object pulls in all dependencies it needs.
thanks a lot! this solves a lot of confusion in my head there's still one thing that I haven't understood yet, my library uses opengl (it includes gl.h) and that means it should need the `-lGL` when compiling, however when compiling my library with `-shared` (to make it shared) if I don't include `-lGL` it still works, why is that happening?
Line 19 is `scale = scale_input[0];` , this does not correspond to your description.
You entered "f" when you were supposed to enter the temperature. 
I would add "C in a nutshell" 2nd edition, By Peter Prinz and Tony Crawford, published by O'Reilly Media. The best book on C I have ever read. And remove "The C Programming Language", 2nd ed, by Brian W. Kernighan and Dennis M. Ritchie. Terrible book. Terrible code, no comments, doesn't explain clearly, no code highlighting. Argh.
http://hentenaar.com/dont-learn-c-the-wrong-way This post goes into some details you mind find interesting. 
[removed]
You're right on both accounts, of course. I hoped the formula I included would be a little more clear (/u/acwaters did a better job). Also, this should work about as well as OP's existing code.
Exactly, they are different types. It would be like trying to equate an apple and an orange!
`*d = 20` is an error, because `*d` has type `int *`, but `20` has type `int`. Your compiler should mention this.
Edited in/out :)
Type \\\* to get \*. Or use backticks for code formatting.
except from the opengl dependency, it contains no other dependency, and that confuses me :/
That is indeed very strange. I need to see your build scripts to understand the problem.
How about: char *have = "abcdefghijklmnopqrstuvwxyz"; char *want = "zyxwvutsrqponmlkjihgfedcba"; if (islower(c)) { size_t idx = (size_t)(strchr(have,c) - have); c = want[idx]; } No longer dependent upon ASCII, and perhaps a bit clearer in intent (also, want can be changed to use a new encoding). 
When producing a shared library, you don't need to link to the libraries it needs. You have these options: 1. Link your shared library to the libraries it needs. 2. Don't link your shared library to libraries it needs. In case 1, you don't need to link to those other libraries when you create an executable using your shared library. In case 2, you must explicitly link to those other libraries when you create an executable using your shared library. However - some recent linux toolchains might use different default linker flags, and as such require you to always explicitly link to the dependencies of your shared libraries when creating an executable, regardless of case 1 or 2 above. 
Ah! Now I see! Just like a static library, a shared library is allowed to have unresolved symbols. If you don't specify that you link against `-lGL` when building the shared object, then all references to the openGL API are just seen as unresolved symbols (use `nm -u` and `nm -D -u` to verify this), so you have to provide `-lGL` when linking the application that uses your library. If you provide `-lGL` when linking your library and your application does not otherwise use the openGL API, then you can omit `-lGL` when linking your application.
Those pesky pointers, man
This explains why the library compiles normaly. I guess that's to be expected! &gt; However - some recent linux toolchains might use different default linker flags, and as such require you to always explicitly link to the dependencies of your shared libraries when creating an executable, regardless of case 1 or 2 above. So, in order to support as many compilers as possible, it would be the best idea to add the libraries when linking my shared library? It sounds like the best solution.
Oh, I see, so the "normal way" would be to compile all shared libraries without linking to libraries, and when compiling the final executable to link all libraries with it ? Thanks for the help! I think I understand it more now, time for more experiments :3
I would very seriously ask around before taking advice from someone who describes what many consider to be "the c Bible" as "terrible". While it is true that K&amp;R C has been more less replaced in common practice by ANSI C, to say the book is terrible is a very, very unpopular opinion.
I'm afraid I don't follow. We don't use the term divisor, at least in my class. Floats are made of the sign bit, the exponent part, and the fractional part. What is the divisor? What is LU? And where is this value of 128 coming from? 
I already account for that. I have a check if that happens. Plus, the number I mentioned in the OP isn't the largest negative number possible, which is 80000000. Regardless, I've solved the issue more or less, so I'll mark the OP as solved. 
Just files that will contain information about what an icon will do. For example if I use a cli torrent which does not have a tray icon, I want to make one by myself. The program I'll write will have to read a file, for example: torrent-icon.conf Which will contain a path to image to display, when to show on the system tray, etc.
a divisor is the right operand of a division operator such as / or % ... you take the fractional part of the value (in relation to `1LU &lt;&lt; 30`), then you add 128/2 to it and divide by 128 to perform a rounded integer division. 128 is obtained from the second last line of my post. it has nothing to do with the IEEE-754 format itself.
I updated the post with my solution. Not in code, but in concept. Professor ran through it this morning since several people were stuck. 
[Programming Language C - C2x Charter](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm)
[Rust?](https://www.rust-lang.org/en-US/) which is being used to write [Redox?](https://www.redox-os.org/). Both are open source, you can help make it happen.
Well Apple provides Xcode. I've personally not tried it, but its free, supports compiling multiple languages, etc.
Very cool and exciting.
Don't need any book just go fr my site.codificare.in/history/
I almost mentioned Rust but I'm fairly ignorant about it. Thanks for the links! I will definitely check it out. I've got a lot of other things I would like to write code for so I'll have to ponder that a bit.
I rather like [this](https://ramblings.implicit.net/c/2014/05/03/do-not-trust-random-websites-about-c.html) post which details a few of the issues.
Xcode, it's by far the most featureful, easy to use IDE. The ONLY downside is Apple's insistence on shipping 328 simulators, and SDKs. Unify the simulator, and the SDKs Apple, this shit is just ridiculous at this point.
B becomes the address of A, aka where in memory it's stored. To get the VALUE of A (aka 5) you'd want to use the pointer syntax. `B = *A`
Sounds like rot13 twice...
This subreddit is about C only. C++ content is off topic.
Vector operations are interesting but I hope they agree on a better syntax. Perhaps they should take some ideas from APL. My preference would be a new keyword `vector` (or `_Vector`) that declares an array with vector semantics. These are: * the vector size must be an integer constant expression * subscribing behaves as with arrays, subscribing an array or vector by a vector loads the desired items into a vector of the same size as the subscript * vectors are passed by value to functions * vector elements cannot be addressed individually (unsure) * vectors can be subject to all operators, if both operands are vectors, the operation is applies to each element. If one operand is a scalar and the other one is a vector, the scalar is applied to each element. * a new `reduce` operator can be used to reduce vectors, e.g. `+reduce v` sums all elements of `v`, `-reduce v` computes the alternating sum of the elements of `v`. * a set of standard library functions is added to compute common vector operations. These should be type generic. * the sizeof operator can be used to compute the number of elements in a vector, typedefs for recommended vector types (i.e. those the architecture natively supports) exist. * syntax for declaring a vector: `int foo[vector 8]` or possibly using a different keyword: `int foo[register 8]`.
I read it already but I think this not a valid argument since any such big change introduces errors. Rather than changing a huge code base to _s functions one should only use them when trying to produce secure code. And when doing so, one is in the responsibility to be careful not to introduce errors. While changing a huge codebase of 50M LOC one cannot maintain the needed concentration. However there are situations where I thought, while programming, that I'd like to pass the length of the buffer I'm writing into -- and then remembering that many functions sadly do not provide said functionality. In critical parts, this, imho, is really important. Imagine a small "parse" using scanf, eg a string like this: `"%d %s %d\n"` should be parsed, and the second argument be written into a `char *buf` whiches size is runtime-dependant (maybe on earlier user-input) but I have it's size ready at at hand. Using the "normal" scanf I cannot check bounds easily although this'd be a trivial change for me. Something that startled me completely: One point the authors of the report raised was that using scanf_s required to compute buffer lengths -- imho, if computing the lengths is too complex for the programmer to achieve, then the code is too complex for the programmer and I'd say it's likely that the original code is prone to buffer-overflows. If I cannot point out the length of the used buffer without minute-long analysis, this code should've never been written (that is, in contexts where security matters of course) tl;dr: One big bad thing that happened was MS effectively deprecating the normal functions and creating a bunch of hysteric overly security-sensitive programmers that use _s functions always but incorrectly, shedding a bad light on those who use them sparingly but when needed.
I haven't used it for a long tie, so I can be completely wrong but shouldn't you specify number of threads?
[yes, mathematicians who work with computers don't know what they're talking about](https://en.wikipedia.org/wiki/Gerald_Jay_Sussman)
For C programming on a Mac you could use: Xcode, Code::Blocks, Eclipse, CLion (non-free) and probably many others ... Personally, I tend to use Xcode because it works really well with Clang.
A couple of (unrelated?) questions about your version of the code. I've not had my morning coffee, so please pardon me if I'm missing something obvious. 1. you wrote `double *a = malloc(N * N * sizeof(double));`, while the OP wrote `a = malloc((N) * sizeof *a);`. This looks like you're allocating more memory -- if so, is there a reason that I'm overlooking? 2. you wrote `a[i*N + j] =`, while the OP wrote `a[i][j] =`. If I recall my early CS classes, those two are equivalent. Is there a more technical reason you chose your implementation? Again, I'm reexamining what I thought I knew based on your implementation, so my questions aren't criticisms. 
I'm allocating same memory, the OP uses an array of pointers to create a 2D array. My code uses a linear array to achieve same result. Not really need it in this case, but it tends to be more efficient in general. Here is the original code corrected: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;time.h&gt; #include &lt;omp.h&gt; int main() { clock_t t0, t1; int N = 10000,i,j; double (*a)[N]; a = malloc((N) * sizeof *a);printf("Preallocated a\n"); double (*b)[N]; b = malloc((N) * sizeof *b);printf("Preallocated b\n"); double (*c)[N]; c = malloc((N) * sizeof *c);printf("Preallocated c\n\n"); //give arrays specific values for(i=0; i&lt;N; i++) { for(j=0; j&lt;N; j++) { a[i][j] = sqrt((double) i+j); b[i][j] = sin(sqrt(a[i][j])); } } printf("a,b values assigned\n\n"); ////////////////////////////////////////////////////////////// /* No openMP */ ////////////////////////////////////////////////////////////// t0 = clock(); for(i=0; i&lt;N; i++) { for(j=0; j&lt;N; j++) { c[i][j]=b[i][j]+a[i][j]; } } t1 = clock(); printf("ans0: %.5f\n",c[N-2][N-2]); double t = (double)(t1 - t0) / CLOCKS_PER_SEC; printf("time: %.5f\n\n",t); ////////////////////////////////////////////////////////////// /* An OpenMP implementation */ ////////////////////////////////////////////////////////////// double start = omp_get_wtime(); #pragma omp parallel for private(j) for(i=0; i&lt;N; i++) { for(j=0; j&lt;N; j++) { c[i][j]=b[i][j]+a[i][j]; } } double end = omp_get_wtime(); printf("ans1: %.5f\n",c[N-2][N-2]); t = end - start; printf("time: %.5f\n\n",t); free(a);free(b);free(c);//happy independence day return 0; } and the results: Preallocated a Preallocated b Preallocated c a,b values assigned ans0: 140.78240 time: 0.71662 ans1: 140.78240 time: 0.18922 
Thank you. The coffee finally kicked in, and I see my problem: double (*a)[N]; declares `a` to be a pointer to an `N`-element array of doubles, so a = malloc((N) * sizeof *a); allocates `N` copies of an `N`-element array. The syntax of the declaration was confusing me.
The OP error was to use *clock* to measure the time spent in a parallel region. *clock* measures the combined CPU time for a parallel region.
You can write C99 code in MSVC now.
**Thanks a Lot!** I works more or less for me although I am getting a speedup of only 2x rather than 4x probably because I have 2 cores and 4 logic processors. (My understanding/grasp of these things is not strong) I tried the following to see if any speedup can be gained if number of threads is greater than 2. omp_set_num_threads(8); As such speedup isn't getting better than 2x. I think with I can cut a day of simulation time. (ET to simulate ~54hours).
Just make sure that the path contains no slashes and that it is neither `.` nor `..`.
With a web server I would personally build an internal representation of the accessible directory structure internally on a file request, and then resolve against that rather than the actual directory structure. Doing this not only allows you to prevent access outside the desired directory structure, but prevents access to server only files within the directory structure, such as .htaccess on apache. Just don't add it to your internal representation and your program will not even try to server it up since it is not found.
Use realpath function to get absolute path( should help with . And .. and ~ and symlinks) Check if this path starts with proper parent path. But do create a proper user dedicated for the server
~ is not a symlink. ~ is resolved by the shell, it shouldn't matter to your web server unless you pass paths to the shell.
This looks the best way. Thanks. 
Thank you. Though, I liked your comment. You said something very important.
Hm... good point. What helps me when programming in C is to always think about the problem at hand in the simple-most terms. Do what you think is needed to solve the problem, not what is needed to fulfill any weird sense of structure. That means for example: If a class is not a good fit for a certain part of your program, don't write a class. Just write what comes naturally, keep it simple.
https://codility.com/programmers/
The command line is the best IDE ;)
This code: while (choice == 'q') printf("Goodbye."); Probably does not do what you think it does. A while loop runs everything in the next statement (or `{}`) so that code actually just prints "Goodbye" ~~until~~ as long as `choice == 'q'`, but since `choice` never changes within the loop body it enters an infinite loop. As for the 'x is not a number' issue, you should remember that `scanf` returns the number of format specifiers converted. So if you do `scanf("%d", &amp;myInt);`, that will return 1 if the int was successfully converted, or zero if it wasn't. You just need to check for zero and print an error if it is. 
design and implement new languages. (write compilers/interpreters) design and implement new libraries. (for C or other langs ... u can always write a replacement for &lt;stdio.h&gt;, &lt;string.h&gt;, etc. then use them in your own programs) don't update old standards for languages that *you didn't design* in the first place ... it's very simple and anybody can do it. if u have good ideas, they can stand alone, just bring 'em into existence ... no need to leech off other ppls work and struggle to maintain backward compatibility, when u can just go in a different direction altogether.
Writing whole new languages is by no means easy. Not to mention the fact that those new languages would take a while to build up their infrastructure, whereas C already has more libraries than you can shake a stick at. People will still be using C even 10 or 15 years in the future, so why not at least *try* to improve things?
&gt; until `choice == 'q'`. You mean "as long as", not until.
Yeah, if you're using hyperthreading you're not going to see any improvement to CPU-heavy tasks by going over the number of physical cores. You might even get a performance downgrade. 
nested if statements edit: nvm , sounds like a really stupid and pointless exercise or maybe not? 
Yes, I did. Thank you.
For ctype functions it is recommended that you use translation tables and implement them both as macros and functions (as a fail-safe for when macros are redefined). For 8 character classes you would use a table of 256 unsigned chars where each entry corresponds to an ASCII character and the bits are used as flags. This way you can check, say if 'A' is a letter by doing something like `ctype['A'] &amp; _ISALPHA`. Clearly this can be easily implement as a macro. A good reading material (albeit advanced) for implementing the C standard library from ground up is Plauger's 'The Standard C Library'.
Funny, I'm the other way around. I hate trendy stuff like JavaScript (so much extra setup around it, npm, react etc). Recently I stared exclusively programming in C. Programming websites in PHP or Python is just boring. I like C for it's simple syntax and rules, all those simple rules can get complex when you combine them but it's a lot lot clearer than PHP for example (the code that I have seen from my peers.... My soul has been getting darker every time I think about it)
You are asking questions about a language (even if it is a computer language) yet you don't seem to care much about the language you ask the question with. How can you expect to have a computer, others, or even your future self understand you, unless you start using it properly?
Hah you did the exact same piscine as I did in paris I think... lol! I was the dude wearing the funky hat. I'll bet you got in too if that's the code you wrote for your hand-in's
directly through the command line, I plan it to be run as a daemon. About the x-icon.conf files, shouldn't I put them in $HOME directory?
Pretty cool project. You should probably document some of the functions, especially those which their functionality isn't obvious like [this one](https://github.com/R4meau/libft/blob/master/additional-funcs/ft_striteri.c). Also please avoid producing side-effects in your loop condition like [here](https://github.com/R4meau/libft/blob/master/additional-funcs/ft_strmap.c#L26) or [here](https://github.com/R4meau/libft/blob/master/additional-funcs/ft_striteri.c#L21). It might feel less verbose but you're creating code that's extremely bug prone and unmaintainable. These functions are too small to have to worry about something like that, but try avoiding it in bigger projects. Code like that makes debugging a living hell.
I see, I think I can do that. I just wanted to make sure that I don't reimplement something that already exists. Thanks for the help!
That's a pretty cool idea for efficiently returning character attributes like alpha, numeric, lower, upper, etc. 
I agree, I won't be doing that in bigger projects. Thanks! **EDIT:** About the functions, the only functions that are not documented are the personal ones. The others can be found in the project instructions. I will add documentation for the personal functions soon. Cheers! 
Haha, congrats on being accepted. This is not my piscine code tho, this is my first project during the program.
That's rad but at 42 we are limited to the stuff we can do. There's a norm (a coding standard) that we have to follow. And thanks, I will definitely check this book.
Oh gerp I was looking at the dates in the header file and they lined up perfectly with the september piscine. &gt;.&lt; We didn't do the whole of libft but yeah our excercise were for the most part replicating some of the simpler libft functions.
Thanks, this is what i need.
Use the source Luke. If the documentation fails that is. It's good source though. :-)
Are you sure int is 64 bits on Windows? That doesn't sound right.
I think I got. It was much easier than I thought. Thanks.
Sorry, I was confused. Indeed, Windows has a LLP64 model while Unix has a LP64 model! Why I wrote this shit is another question...
These should help explain it a bit http://www.cprogramming.com/tutorial/lesson11.html https://en.wikipedia.org/wiki/Type_conversion#Implicit_type_conversion
Like you know, i can break the compatibility of the code. And it is the last thing a programmer's want.
`APSPMatrix` is not a type, it's just a `#define`. There's nothing to cast to/from, as the compiler sees them in exactly the same way. For example: #define type_a type_b typedef int type_b; type_a foo; /* These two are exactly the same since the */ type_b bar; /* preprocessor expands 'type_a' to 'type_b */
If the dir path isn't always static, but limited and known ahead of time. You could also use a counter. Lets say 10 dir paths. filename0 for the 1st dir path, filename1 for the second etc. so "filename" isn't a unique filename, but it is in a different dir.... "filename0" and "filename1" are now unique for the cost of one char.
I didn't mean do anything more than read to see what it does. I looked at the code before and it is good, so nice to read. But sounds like you need a per thread handle to the sqlite database. Which is probably is just the support for multiple processes openning the sqlite file.
http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform
Hmm I saw that before when I was googling this...I was hoping there was a way other than check if a file exists, like maybe a built in command that checks if a string matches the parameters needed for a file. But I suppose the check if file exists is more generalized so a better overall approach. Thank you!
Yeah, but then you have to take that as a parameter, and have to deal with a hundred billion tables, I'd much rather deal with code points and code units directly.
Check the return value of scanf(). 
Check if the string matches all the other option switches e.g `-l, -c -a` or something. If it isn't any of those then you can assume it is a file. If there is no file on disk with that name then print an error message to the screen and exit. That's how most programs work.
Actually it's not that bad. Unless you really need to operate on Unicode-specific things the generic functions are usually good enough.
With C that's the case. In all the other opencl algorithms I'm not seeing any memory allocation or freeing being done, there is apparently an equivalent to malloc/free but for whatever reason they're not being used for the algorithm methods.
Sorry, I perhaps didn't communicate it well. I am brute forcing the end of the directy path with several characters to hash filenames(game assets). It's like providing the prefixes like `password?d?d?d?d` wjhere the last 4 ?d could be any number, but `password` will be swapped with various paths after it exhausts the digits in this example. The program has already combined the prefix and random characters that I'm brute forcing to me with a array of 32-bit values(contains byte value of 4 characters at a time). It's not clear what the prefix is or where it stops without iterating through it and checking each step of the way. I could do as you say and precalculate it and append, but I'd have to hard code this in and compile each time I want to change the path prefix which defeats the purpose a bit. Actually, although my code has to run in a loop that provides these values, I guess I could just start it in another loop that iterates through the prefixes :) I think there is a part before the required loop starts that I can precalculate everything. I wanted to contribute the algorithm with a cache for it to be worthwhile to others(it's a fairly common/popular hash algorithm used for dictionaries/hashmaps and bloom filters), but I guess pasting in 8k paths to calculate as prefixes works too. EDIT: Just learnt that I could possibly pass these in as a salt value(additional compute value some hash algorithms use to prevent cracking effectiveness).
Yeah, I'm writing a few functions and a type for that, the trouble is in handling locales so they can be sorted and whatnot.
in certain languages, the accented latin letters are sorted before, after, or at the end of a list of strings, compared to the standard latin alphabet. and each language does it differently, so it's kind of a PITA. and you have to take that into account.
That's a 1-&gt;1 relation though right? Not a 1-&gt;many? I think the data structure that I'm doing is similar to a trie which is used for things like search or spell checking, they build an index based on the string char as well with it's leaf nodes as the next available string char in the sequence to match.
Seems everyone here was right about not getting much of a performance gain back, I should have tried this before but it turns out that **removing all my logic for the algorithm so it's an empty function call** the performance drop is still down to 647 miion/sec from the 470 million/sec with my code. **I feel pretty stupid right now wasting all this time ha.**
Memory allocation cannot be done in kernels, you must do all allocations on the host and pass it to the kernel. For OpenCL 1.x that's either a buffer obect or an image object, 2.x adds SVM... but that's harder to explain. You really ought to learn normal C before diving into OpenCL, it will make your life much easier.
&gt; Just i have to open database file with SQLITE_OPEN_FULLMUTEX flag. Then i use the same database handler in all threads. Note that this won't be particularly fast as only one thread can use the database connection at a time. Better use a separate connection in every thread.
Im glad to be able to help. In general, if there is no unique reason to use pthreads "directly" (OpenMP relies on phtreads as well), always use the solution that provides the most amount of functionality for the least amount of code. OpenMP is a good example of this. With only a couple of pragmas or statements, you can parallellize code with relatively little change to your code. However, working with the guts of pthreads gives you more detailed control over each thread. In a system where thousands of threads are active at any given time, fault tolerance becomes an issue that might not be solvable with OpenMP. Edit: cheers for the downvote to someone who is really just trying to be helpful. 
I never intended to cache with a linked list as far as I know? I've implemented the Trie based on the link I provided on this thread and it seems to achieve what I was after. Unfortunately I've found out that a large bulk of the performance loss is due to the way the generated strings from the software is parrallelized on the GPU, as I was testing with a fixed prefix(1 of 8k) instead of letting the software generate the first 4 characters I was only getting 1 thread/core(?) effectively. All I know is that I get about 64x(500 million to 32 billion) more speed if I let the software generate the first 4 chars, but that greatly increases the key space when I know it's unlikely to contribute any improvement to cracking the hash. Without any logic I can get a max of 8 trillion iterations a second with full parallelization. From experimentation I think I can only get 600MH/s as the top speed that runs my logic per thread/core that it can execute on. The cache might still be useful since at 56 char lengths it slows down to 160MH/s. Similar to the suggestion you've provided I've been thinking if I can precompute all 8k paths into an array outside of the looped function(would have to be hardcoded in unfortunately) that I could take advantage of the parallelization by looping through all paths for each generated string. The cache could still be useful to implement to support longer generated strings.
Xcode is very slick, as long as you're writing in Apple 'supported' languages: C/++, Objective-C, Swift.
You could malloc a new array of 8 elements, loop through x[2] to x[9] adding them to the new array, then free x
Usually people doesn't do it. To avoid leak you can just store original pointer and later use it to free memory. If you systematically remove elements from the head and want to free that memory you should consider other data structures like lists instead of array. Alternatively you can create new smaller block, copy tail of array(memcpy) and free original block. There is also realloc but i'm not sure it can be useful in your case.
Yeah, you are right. I overlooked the most obvious solution in pthreads. Thanks for pointing that out.
Oh I was experiencing them, I know better than to prematurely optimize ;) Yes I've become more familiar with C code now, can't say I like working in it with memory management, I much prefer working with Rust when possible if I need similar performance.
You DO NOT want to muck with the pointers returned by malloc. Implementations of malloc typically prepend hidden information at negative offsets from the pointer, see http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=malloc/malloc.c;hb=HEAD for example. If you attempt to later "free(y)" after the "y += 2" increment, bad things will happen. You have a couple of options if you really want to save space. The simplest as suggested is malloc a new block and copy the data you want to save to that block, the free the old one. Or you can shift the data down and realloc the block. 
First, a signal is handled in one thread that the system choose. you can make a simple trick - block the signal from all threads except one (using pthread_sigmask) and the only thread will get it. next use a simple data structure (array for example) to save all running threads id and use a loop with pthread_join to wait for them
Privacy/image obsessed redditors: deleting important context from threads since 2007
It does not. You can easily see that by the pidgeonhole principle: If `RAND_MAX` is not a multiple of three (as it commonly is), you cannot divide the range (0, `RAND_MAX`] into three such that each has the same amount of numbers in it. Thus uniformity is not preserved when `upper_limit` is 3 and is not preserved in general.
[pthread_join()](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html) is what is desired.
Thank you for your input.
https://www.youtube.com/watch?v=aQiWF4E8flQ
http://www.cprogramming.com/tutorial/computersciencetheory/hash-table.html
Why are you linking me to a hash table? The specific hashing algorithm that I'm running on the GPU is for a common one used for dictionaries/hashmaps and bloom filters, even if I could use a hash table on the GPU it'd essentially be doing the exact same process. Hence why a Trie seems a more appropriate data structure. Regardless, I don't think it's required right now as I have mentioned here I don't think this is the correct optimization anymore, the performance problem appears to be due to me not originally understanding how the parallelization on the GPU was being done by the software I'm using. I'm working on fixing that now to get a 64x performance boost. Thankyou for your help/advice :)
A BTree if I'm not mistaken, takes a value and then has two options which splits the tree in half, and this is the same case for each new node you traverse reducing the search space by half each time. A Trie is more targeted as instead of only having 2 options at a time, I have a direct lookup of the child node I'm seeking, take the example from before HEL is three traversals from the root node, I then have L or P which I again know exactly what one I'm going to ask for. As those nodes grow, I could have 26 nodes per parent(lower alpha), or 106 for the full ascii text range. My lookup will still be 4 traversals, I don't think that's the case with a BTree? I'm not doing any removal, it's a cache, only need to insert a child node to the currently active parent node that I'm keeping track of, so insertion is fast, no need to shift backwards, when the next loop iteration(new word/string) starts, I set the current active parent node var to the root node of the Trie, my lookup happens skipping calculating however many traversals * chars a node represents(1 letter in this case, could be 4) and then I begin calculating and inserting again. So to clarify, a hash table likely defeats the purpose of optimizing with a cache(it has to hash the entire string to do it's lookup, eg a 56 byte string needs to be hashed into a 32/64 bit value) and the data structure of my string doesn't help either since it's an array of 32-bit values(4 characters and they happen to be in reverse, so {LLEH, O}). With the Trie I can lookup with the H(with some bitshifting and &amp;0xff to isolate) or with LLEH as my index key to find the relevant node. Remember I'm doing this hashing process 32 billion times a second, if it was a regular program that didn't need to achieve that rate such an optimization is likely moot. This was to be run in OpenCL(Kernel), where I apparently can't do memory allocation like in C, I had it working in C but didn't go forward with attempting to port to OpenCL as this was the wrong optimization to make, hashing long strings over and over wasn't the cause of slow down(if it was it was minimal in comparison).
`typedef natural unsigned int` is an error. You'll get better responses if you show the real code in the question instead of having everyone dig through the github to find the relevant parts. Also, try debugging your code.
However, you could preserve uniformity by throwing away values that are greater than the greatest possible multiple of three and recalculating. Note that it then becomes possible, though almost impossibly unlikely, to end up throwing away values for an arbitrarily long amount of time. 
The last 3 have badly needed fixing for a long time. All published standards are inconsistent and bizarre in those areas. Looking forward to further discussion. But N2091 seems to not mention the "wobbly values" issue. (Edit: N2089 actually addresses that, so N2091 doesn't need to rehash it).
This very same function is used as an example for the [clockwise/spiral rule](http://c-faq.com/decl/spiral.anderson.html) &gt; signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning nothing (void)
Thank you! It was an abomination, and now slightly less so :D
From "Expert C Programming: Deep C Secrets" (A great book, IMO): "signal is a function (with some funky arguments) returning a pointer to a function (taking an int argument and returning void). One of the funky arguments is itself: void(*func)(int) a pointer to a function taking an int argument and returning void." 
For the future: This is C++ documentation. While C++ claims to contain the entire (?) C standard library, there can be small differences. Always read C documentation when talking about C functions to make sure that you got the right facts. That said, I can spot a mistake right off the bat: `signal` is multi-threading safe, no idea where they got this sentence from: &gt; Undefined: calling this function in a multi-threaded program causes undefined behavior.
C might not be "trendy", but professional C usage is rising.
You can't pass an array to a function. If you write `T []` as a parameter of a function, it gets silently rewritten as `T *`. So the parameter that you're defining in your example has type `int (*a)[col]`, i.e. a pointer to an array of 'col' ints. (And in this case, you're saying that it's a pointer to the *first of three* such arrays of 'col' ints.) The `static` modifier trick thing can only be used when describing the size of an array parameter (before it's decayed to a pointer.) In other words, the 3 in your example describes the required size of the array before it decays to a pointer. The 'col' dimension does not have anything to do with that and so you can't use `static`. The 'col' is part of the type of the pointer, not the size of the array argument before decay. 
Yeah this is a good one. The key here is the concept of function pointers. A function pointer can be declared as follows: +-- name of the type of function it points to | void (* funcPtrName)(void) | | | +-- arguments for the function it points to | +-- return type of the function it points to The name is completely arbitrary and simply helps to define the signature as a type. Now what's going on in the signal function signature: void (*signal(int sig, void (*func)(int)))(int); The symbol name is obviously 'signal'. However since the return type is also a function pointer we get the same syntax as you see above. The function signature expected for signal as a return type AND the second argument is: void (* funcPtr)(int) The tricky part is that the int argument of the return type is attached at the end which makes the signature look completely insane. It's function signature inception! What are function pointers good for? Event based programming and interfaces. Also OOP concepts benefit a lot from it.
Is there any reason you can't do the challenges in r/dailyprogrammer in C? I only read a handful of them, but the ones I read look amenable.
It would be more geared towards the low level programming C is suited for. E.g.: writing an utility that reads an archive in the zip format and the removes a file from it. Scripting languages have plenty of libraries that do that in 2 lines of codes. 
Try tackling the /r/dailyprogrammer challenges from a low level, and in a C idiom (e.g. like you might see in K&amp;R). Write a solution that doesn't use heap allocation, or that uses a tight, bitwise data structure.
Thanks! What resource would you recommend as a go-to C documentation, for quick look-ups and such? My top google searches always end up coming from cppreference, or cplusplus, and such.
Let me check (I don't often change my Vim, hah). Apart from what comes with it, I use: * CtrlP 'ctrlpvim/ctrlp.vim' * NerdTree 'scrooloose/nerdTree' * NerdCommenter 'scrooloose/nerdcommenter' * Fuzzyfinder 'FuzzyFinder' * Zenburn theme (usually) 'jnurmine/Zenburn' * CtrlP Funky 'tacahiroy/ctrlp-funky' * YouCompleteMe 'Valloric/YouCompleteMe' * Minimap 'severin-lemaignan/vim-minimap' * DelimitMate 'delimitMate.vim' * Ultisnips 'SirVer/ultisnips' * VimSnippets 'honza/vim-snippets' * Supertab 'ervandew/supertab' That's about it. Minimap is probably the one I use most rarely. Everything else is used all the time. I'm experimenting with different gdb integrations at the moment. I do all my compile / make and gdb in another shell, but am thinking of integrating if it will show itself useful.
I'm pretty sure what you are looking to do, is work with a pointer to an `int`: void scan_ints(int *array, int len) { for (int i = 0; i &lt; len; i++) { printf("Value of number %d: ", i+1); scanf("%d", &amp;array[i]); } } void print_array(int *array, int len) { for (int i = 0; i &lt; len; i++) { printf("Number %d has value: %d\n", i+1, array[i]); } } int main() { int array[5]; int *p = &amp;array[0]; scan_ints(p, 5); print_array(p, 5); return 0; }
I too think that you should just go ahead and post them in r/dailyprogrammer and just mention that it is meant for C (and maybe in some of them mention exactly what includes you are allowed to have, like they do in cs courses). I know that as a young programmer I would have liked to be steered in that direction. I'm sure some starting dev who only experienced js would be glad for that in a couple of years time.
Thanks for taking the time to answer, this is what i was looking for! Going to have to spend some time reading about pointers and arrays though.
inverse tanget of x/y then AND x doesn't equal 0. So I'm guessing sets it to 1. I commented it out before this post and now it gives the answer in radians so 5 66 gave something like 0.075.
etags, M-x compile, and M-x gdb Everything you need comes with it.
I see. Instead of y/x the function calls for 2 variables.
Yes. It does the division and handles cases where x is 0 so you don't have to. Also handles negative values of x and y properly.
What have you tried already? What are you stuck on? I don't think anyone here will do your homework for you, even though I know a lot of us could do this in a minute or so.
You're quite welcome! I'm still trying to wrap my head around them, myself. 
i have to use srand(time(NULL)); and I am stuck on how to initialize that.
I started with floats and just left them as floats. Still learning where and what to use.
Congratulations! You've reinvented [nohup](https://linux.die.net/man/1/nohup).
I would also add an isfactorial() function wrapper to check for -1.
the computer creates a random number and you input a number
That sounds like what I want to do, but I actually have no idea how to establish that concept at this point in time. Can you give me a quick example?
In C, recursion is very rarely used in real programs. Iteration is almost always better and less likely to cause problems with things like running out of stack space. For bonus points though, try implementing it both ways!
Definitely, yes. I'd volunteer as a mod.
Honestly, there no real reason to use a macro over an enum, or regular function. By doing it this way, you're just making room for bugs, confusion, and trouble.
Another benefit of posting solutions to r/dailyprogrammer in C is you spread the good word about C to the masses, and show that it can be clean and understandable. 
Hey, this looks like my function. I had it return a -1 to let me know a factorial wasn't possible, then used that information to print a "NONE" next to the number, in the main. This won't work with your main, because you always have it print: (the number)! So if the number isn't a possible factorial, you're main will print: -1! Which is nonsense
&gt; Spacemacs Spacemacs C layer sucks. It uses clang-complete instead of irony and does not use rtags. It is better to use config of your own. Use irony, flycheck and rthags.
Please! That would be so awesome.
I think those statements about how often they're used depend very heavily on the type of application. For safety critical applications, you're more likely correct and any recursion that is written (when allowed) is typically heavily guarded to ensure that the stack doesn't blow up. I think it would not be unusual to see recursion in typical, desktop-oriented software. You are correct, however, that iterative solutions are often as readable, more easily understood, and more easily analyzed for their impact (e.g. stack usage). Edit: clarity. When I said in desktop software recursion would be "more frequent", I meant "more frequent than in other areas". 
No i wasn't stuck on that idea. I appreciate the example, and yeah I've only barely started the c book that I'm reading, and I just wanted a little break to try a problem.
**My** function ended incorrectly? int findRevFac(int userNum, int divisor) { if (userNum%divisor != 0) { return -1; } else if (userNum/divisor == 1) { return divisor; } else { divisor++; return findRevFac(userNum/(divisor-1), divisor); } } This works perfectly for me. And it seems almost exact from the one you have. Using one parameter for this type of recursion is pretty difficult because you have to pass in two *changing* values into the function: the quotient of number/divisor , and the increment of the divisor. For a regular factorial recursion function, it is much easier, because you only need to enter the number that needs to be multiplied as a parameter. Such as: int factorial(int n) { if(n = 0) { return 1; } return n*factorial(n-1); } My findRevFac() function works. It returns the reverse factorial (if there is one), or "-1" (if not). Don't knock it. 
I've read somewhere that *sometimes* using srand/rand functions will yield the same results (same random numbers) every time you run the program. Will this example be susceptible to this issue?
Modulo five results in a number between zero and four. You want Modulo six for a number between zero and five.
haha, I understood. I didn't mean to sound offended. 
&gt; There are exceptions to this, such as parsing/traversing recursive data structures like trees. I tend to use those kinds of data structures at times, so I see them more frequently. &gt; I'd recommend learning how and when to use iteration versus recursion. Try both and see which works better for you. Excellent advice, which I apply (regardless of which language I'm in). 
It's solely my observation
Please put four blanks in front of every line of code so the code is readable. Please also copy/paste the error into the question so we can tell you what is wrong. Saying ‚ÄúI've got an error‚Äù is completely useless unless you also say what error you got.
Hey baconation, I don't want to just write the program for you but I'd love to offer some input. If you're wanting to compare results from trial to trail I'd suggest a few things. 1. Declare an integer array of size 50 that you will pass to a function along with the desired index, and the desired number. 2. Create a function, lets call it runTrial for now, that accepts 3 parameters, the array, the current index, and the desired number. 3. Accept the input in the main function and store that in another integer variable that will be passed. 4. Create a for loop starting a index 0 that will increment not to exceed 50. Each time the loop iterates, you need to call the runTrial function and increment the index. 5. Within the function, create a do-while loop that doesn't break until the comparison is accurate (desiredNumber == randomNumber). Generate the random number within the loop repeatedly and compare it to the input. Each time this loop iterates, add 1 to an integer counter. This counter will be assigned to the array at whatever index you are currently at. 6. Once you runTrial 50 times, you should have an array full of the number of attempts that the comparison took each time. You can then do a bunch of things with it such as computing means, and modes and all that fun math shit. Let me know if I need to clarify and sorry if it's redundant. SOURCE: Currently a CS Student (Still a novice)
Perfect! I'm assuming that you have a basic understanding and didn't want to spell everything out too much.
So here is my code, but I'm having compiling issues, am I messing soemthing up with time_t t;? #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;stdlib.h&gt; int main() { int n; int count[50]; time_t t; printf("enter a number : "); scanf("%d",&amp;n); int c,turn; for(int turn=0;turn&lt;50;turn++) { srand((unsigned) time(&amp;t)); c=0; while(true) { c++; int x=rand()%100; if(x==n)break; } count[turn]=c; c=0; } int sum=0; for(int i=0;i&lt;50;i++) { sum=sum+count[i]; } printf(" number found in average of %d turns ",(int)(sum/50)); return 0; }
The example I linked to will not, unless the program is run at the exact same time. Random numbers are generated from a seed number; if you use a static seed, such as 1, every time you run the program, all the random numbers will be the same, in the same order. Since the generation is seeded via the current Unix time (time since 1-1-1970), the only way to get the same number consistently is if both times it was run the machine thought it was the same time. It should be noted that seeding with the time for most applications is fine, but for security it is not, as it is fairly easy to set a machine's clock to lower the entropy of the program.
Get rid of the `else`.
Just a couple of tips. Not sure if it's just reddit messing with the formatting but try to work on indenting so that code is easier to follow. Also, I do my best to declare all variables in the same location so that I know exactly what I'm going to use in the program. Also, C is a very liberal language so I like to name my variables by their actual function to the program. For instance in this case, "int n;" could be renamed "userInput" or "numberToFind" to make your code sound more like English. What is the compiler message?
 if (choice == 1 || choice == 3) doThing1(); if (choice == 2 || choice == 3) doThing2();
Your compiler might be warning you that t is an unused variable. If you call use `time(NULL)`, it just returns the number of seconds. Also, you initialised `turn` twice.
 Edited it. It aint even done. This is our program in development and I need help to program it
Awesome! Thanks for the response and clarification!
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/C_Homework: Come here if your C programming question is specifically related to a homework assignment. We will not provide you with answers, but we will try our best to guide you in the direction you need. The best resource is your classmates, professor, TAs, etc. --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
It sounds as if the "testers" checked for MISRA compliance but the code was not actually intended to be MISRA compliant... so the check is worthless. 
instead of: for(current = head; current-&gt;next != NULL; current=current-&gt;next) you'd do: for(current = head; current != NULL; current=current-&gt;next) This way the loop will terminate as soon as you reach the end. 
This is correct. The important part is that IskaneOnReddit did NOT say `else` before the second `if`. So the program executes the first if statement, then it independently executes the second if statement.
 declare struct here struct myStruct { //members }; main{ get the number of people you want (assign to variable n) myStruct yourStructName[n]; }
That's a very unusual and atypical way to indicate the end of a linked list and should be avoided without really good reason. What's the rationale? You'd have to see if the current node is equal to the next node, though.
Thanks!
If it is directly or indirectly in control of over mission critical components, it should be certified. From those numbers, it was clearly intended to be 'close' to MIRSA - many of those metrics in the article balloon for normal code. I ran parts of the linux kernel through a safety-critical static analyzer at my previous job to make a point to management (worked on avionics), the resulting warnings flood is pretty much unmanageable. I think the Toyota story simply points to the need for more oversight on SW in cars. The system in place for avionics isn't perfect, but it's a lot better the honor system that exists in automotive. 
Well said.
That's a bit weird /r/Cprog thinks homework is should be forwarded to /r/C_programming and you want to forward it to /r/C_Homework. So what is the roll of this sub??? Only anwering interesting questions? I get that it's not always fun to answer them but it's part of this sub.
What kernel or OS do you guys use in cars?
Which code sample do you mean? I haven't found any exhibiting what you mean. Note that the only authoritative source on C questions is the C standard and perhaps the POSIX standard. cppreference is a page that tries to explain the standard in ‚Äúeasier‚Äù (i.e. less clear) terms and some times fails at that.
This is incorrect. Homework-style questions are explicitly allowed in here. Please do not make public service announcements without informing yourself about the subject matter. I have deleted this thread because it is misleading to visitors of this subreddit. If you want to have (yet another) discussion about homework on this subreddit, do that. Bear in mind though that apparently most users are interested in answering homework questions on this subreddit as indicated by the last survey.
Did they give you feedback on why it doesn't work? It seems like the lecturer didn't see your recursive call to `contains`. Please complain. Ah, now I see the error after /u/AngusMcBurger pointed it out! Always compile with warninigs turned on!
Cygwin is always generating 32 bit binaries as far as I'm concerned. Though, that doesn't make a difference, both on 32 bit and 64 bit x86 systems, the return value is placed in `eax`.
Well what's keeping you from iterating through your list until you hit z and then proceed to do whatever it is you need to do with that dummy node outside of the for loop? This of course can be highly inconvenient depending on what the purpose is but you wouldn't miss it since you know that your dummy node is the last node.
Windows + Unix, x86 + x64 all use eax for the return value. Likewise on ARM I believe r0 is always used for the return value. I don't know of a platform where this wouldn't happen to work, and think it's more likely your lecturer looked at your code and saw it wasn't correct. 
 this is very cool this is very cool this is very cool this is very cool this is very cool
Looks like the JS devs have started moving to C now.
This happened 2011.
XD
Hold up Ill give it you later because Im using my phone atm. I was so busy lately due to school works and I was spending lots of time making the programs rationale and presentation.. It's a rough life when you're an ITC student you know
I'm sorry, I was on my phone and it was late. I understand what you mean about "authoritative", I just figured cppreference was close enough to expect sample code to be correct. I'm referring to the `fadd` function on [this](http://en.cppreference.com/w/c/language/array) page. void fadd(double a[static 10], const double b[static 10]) { for (int i = 0; i &lt; 10; i++) { if (a[i] &lt; 0.0) return; a[i] += b[i]; } } // a call to fadd performs compile-time bounds checking // and also permits optimizations such as prefetching 10 doubles int main(void) { double a[10] = {0}, b[20] = {0}; fadd(a, b); // OK double x[5] = {0}; fadd(x, b); // error: array argument is too small } 
I don't see any arrays with more than one dimension in this example.
(Disclaimer: this comment is based on Linux terminals, but maybe it can be of help) This is quite a challenging task indeed, but doable. Take a look at [this project](https://github.com/antirez/kilo) which is an actual text editor under 1K lines. It doesn't use (n)curses, but rather raw ANSI escape sequences. I use this project as a reference for my own an attempt of creating a terminal hex editor, for the sake of learning C and some POSIX cruft. See [my source at github](https://github.com/krpors/hx) if you're interested. It's far from finished though. It basically comes down to this I suppose: * Set terminal to raw mode (no echoing back, ignore control sequences like CTRL-C, CTRL-D and whatnot) * Read file to a buffer * Figure out the terminal size * Read key presses and process them accordingly. Like cursor up, down, right, left, page up, down, end, etc. * Use that buffer to append characters if necessary, or replace them (meaning realloc it + memcpy) * Write the buffer to the screen, but only those parts which can be viewed, based on the current cursor's position. * Rinse and repeat You can use Cygwin to fix this up I suppose. I just tried it and it works sort-of.... but the performance is quite bad (screen refresh is flickering like mad). (edit: spelling mistakes) 
Bash and inotify-tools works good for this sort of stuff if you don't want to mess with installing node and gulp.
So if you know that the input to your program is always an integer, you can simply read the entire input into a buffer. From there it's easy enough to set up a for loop and iterate through each character of the buffer, testing against whether it is '0', '1',... once you iterate to the end of the buffer, you're done!
It might also be caused by not including the time.h library?
Likely because you didn't test it enough.
the input is not an single digit, it is an no. for example 09748 and from there i have to store it in an array like arr[]={'0','9','7','4','8'}. 
Thank you very much. :-)
1. Find out, how to write a main function 2. Find out how to print an int 3. ??? 4. Profit
That's not possible since the [mmap](http://man7.org/linux/man-pages/man2/mmap.2.html) function uses size_t for specifying the length of the memory to be mapped. 
We have that. The flair is [Question].
Do you know how to print things? Do you know how to get the number of command line arguments? If you know both of those things, you can do it. Which of those do you now know how to do?
Looks like you are asking for people to make your homework. That's a big *no-no*.
Literally the [first link on google](https://www.tutorialspoint.com/cprogramming/c_command_line_arguments.htm) explains it.
Doing a free/malloc cycle for every assignment doesn't sound too good to me. You can partially get around that by using a different allocation strategy (an arena comes to mind), but there's still some bookkeeping to be done. Since you're using an enum for typing, you might be able to use unions instead. Since the union will always be at least as large as the largest union member, they can be wasteful if the types you intend to provide have very varied sizes. However, if you're not too worried about memory usage (which can somewhat impact performance at the high end), unions might be what you're looking for.
I wouldn't want to keep every variable on the stack either. I think malloc would be a good start, performance is secondary and it wouldn't be too hard to add in his own memory allocator on top of malloc after that. Unions are probably a good idea, yes.
Oh for sure, keep them off the stack - I didn't mean to forego malloc completely! I was thinking that using unions would reduce the malloc/free to once per declaration, instead of once per assignment/cast.
It is odd in isolation. It seems like it might be an attempt to find the length of a zero-terminated string. But if the first character is the zero, in other words if the string is zero-length, it will miss it and might continue marching through memory until the index overflows, which is all kinds of bad (undefined behavior, possible crash). If the index was a signed value initially set to -1 that problem would be avoided, but I'd only implement it in this strange way if there was evidence that the compiler would generate more efficient code this way, and make a comment to that effect.
That's what I mean about reading a word at a time. It reads a long and then uses a bitwise test to see if any of the &lt;four or eight, depending on architecture&gt; bytes are zero. And that's not even the most optimized version, since it's still portable C. The more highly optimized versions live under `sysdeps/`. [Here's the x86_64 version in assembler that uses SSE2](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/strlen.S;hb=HEAD). 
That code has some undefined behaviour. Judging by the initial copyright date (1991) it was probably written with no regard for the standard recently published in 1989, and depends on particular behaviour of the compiler intended to be used to compile the code. My advice would be ~~not to take that code too seriously~~ to bear in mind that the code is not fully portable, and is relying on particular compiler behaviour.
Your progrram contains undefined behavior, (it's missing a return in your contains() function as other mentioned) - the result is that a compiler can produce code that does anything. It could happen to work on your environment, but if your lecturer has any minor iota of a difference in his environment (different version of the compiler, different flags used when compiling, different OS patches installed etc.), it could behave differently. It might also be the lecturer looked at the code, saw the bug, and decided the code was wrong, without even compiling or running it. 
That strlen() is used a lot. What undefined behavior do you see? The type-punned pointer?
Crap, you're right. Thanks for the correction.
Yes, `*longword_ptr` violates the strict aliasing rule. So the code would need to be compiled with a switch to disable strict aliasing; or rely on the compiler not performing TBAA for this code. Further, this code will read past the null character if it doesn't occur at the 'end' of the long, possibly reading past the end of the buffer (e.g. `char s[5] = "abcd"; strlen(s);`). I have actually seen threads about memory checkers such as valgrind reporting an uninitialized read for correct uses of strlen due to this. A minor point is that `(unsigned long int) char_ptr` should be `(uintptr_t) char_ptr`. Also the following part of the code is weird (but not undefined): if (sizeof (longword) &gt; 4) { /* 64-bit version of the magic. */ /* Do the shift in two steps to avoid a warning if long has 32 bits. */ himagic = ((himagic &lt;&lt; 16) &lt;&lt; 16) | himagic; The `if` condition does not enter if `long` has 32 bits, so there is no need to write code inside it that defends against `long` being 32 bits. 
What platform did it crash on? It ran OK on the two platforms I tried it on, on 64-bit Windows.
&gt; The if condition does not enter if long has 32 bits, so there is no need to write code inside it that defends against long being 32 bits. But the code is still in scope so the the compiler will issue the warning, even though the actual shift would be removed by the optimizer.
64 bit windows and "bash for windows". Note that I tried a "very long string".
A spurious warning, since there is only a problem if execution actually reaches that line . (Which it can't do, regardless of optimization). But I guess it's easier to hack the code than to improve the compiler. 
Something you may want to consider going forward is developing the skill of breaking down a problem into little steps. You mention in your post that the whole assignment is your roadblock, but for sure you can break it down into smaller bits. The issue that is for a simple assignment like this you might be able to get by with others' help, but for more complex stuff you'll be SOL. Also think of it this way: when you get into the workforce and you want to develop, you can't expect people to hold your hand. Proficiency at breaking problems down is a must for any engineering field.
Good luck with that, size_t = long long aka 2^64-1 There's not enough storage space on Earth to hold such a string.
&gt; size_t is limited by your RAM size. RAM size, or address space size?
`size_t` is implementation-dependent. It might only be 2^32 - 1. Also I'm pretty sure there is 2^64 bytes of storage available on Earth. [2^64 bytes is only 18 EB](http://www.wolframalpha.com/input/?i=2%5E64+bytes+in+exabytes) and [this article in 2011 estimated a total of 295 EB of data stored](http://www.computerworld.com/article/2513110/data-center/scientists-calculate-total-data-stored-to-date--295--exabytes.html).
which hash function is good and i could understand it.
xd nice meme 
I'm just yanking your chain, dude. :) No offense.
Could you expand on that? Those three words are mostly meaningless on their own.
math concept: SET
Try to write in complete sentences. Don't think we know exactly what you mean just because you throw some keywords at us.
Sorry, I meant that naively changing the int to size_t would produce an infinite loop. I don't know that the OP would have done that, but it's one of those "gotchas" where the change of data type leads to a significant change in behavior.
Why don't you just do for (current = head; current != current-&gt;next; current = current-&gt;next) or for (current = head; current != z; current = current-&gt;next)
No problem. I thought I'd point that out just in case OP got confused and thought you meant his loop as is would never terminate. I do think what you said is worth mentioning though. I think about that anytime I'm using an unsigned type in a loop like that.
You are suggesting the compiler ignore errors in unreachable code?
Thanks, that's insightful.
Thanks!!! It is not an assignment, it is a project and our exam.. Lol
Probably live loop coding with cope more with this idea.
If the program is well-formed and cannot produce any undefined behaviour, then the compiler should not generate a diagnostic. Obviously, syntax errors and constraint violations require diagnostics. Here's another example with the same structure: void f(char *p) { if ( p ) printf("%s", p); } void g(void) { f(NULL); } The compiler should not warn about `NULL` being passed as the argument for `%s`.
I'm surprised the compiler didn't squawk about return values from `contains()`. Writing `contains()` recursively was bad practice; what if you had a string larger than your stack? The use of global `i` means that contains() can only be used once. It should have been local to contains() and initialized there. ch1 and buffer should have been local to main.
The Microsoft console is a bit different. You can directly manipulate it and it doesn't actually work like a POSIX terminal connection. I recommend you to read about it as I'm not sure about the details, too.
Well, my group mate and his cousin polished and make program, and now I'm going to finalize it! thanks for the help :)
Dude. I made everything from presentation, how exactly the program must be made and the documents. They have to work. Bottom line, I don't know how to program nor like programming. It's just that hard. I know the basics, but I just don't feel it. I took the ICT strand to learn more on computers and animation. No interest in programming/development. Sorry. 
Animation requires programming than fixing computers? lol
Not sure if this is the fix to your problem, but I think that the reason you see more memory than you really want is because your global char array is not null terminated. You can try adding a las element in the array, '\0', and see if that fixes your problem. Other thing you can try is to initialize the array with a static string, instead of using the initializer list. Static strings are null terminated already. Something like this: char arrnum[] = "0123456789"; Notice that there's no need to specify the array size when initializing like this, and your example doesn't need it either. No harm specifying it either.
you don't even have to configure make: `make &amp;&amp; ./a.out`or whatever you want (change dirs, run, pipe, whatever). 
First, the # goes after the C, it's C#, called "C sharp". Technically it is C‚ôØ like the musical note (hence "C sharp"), but it is written as C# most of the time because the # character is a lot easier to type than the ‚ôØ character. Second, C# is off-topic for this subreddit (which is specifically about C only, it is a fundamentally different language). You might get better luck asking such a question on /r/csharp instead.
Keep in mind alignment and packing. The compiler will align structures to boundaries and will insert padding so as to keep variable access aligned too. You may need #pragma pack or other such directives depending on your compiler so as you can access the struct as a byte array.
Good call on the null character. This definitely helps with not overflowing into the neighboring array. Unfortunately when I still set the variable in the function above the entire character array gets set from the position called in loop. So at iteration 1 the value gets set to point to 123456789, iteration 2 is 23456789....iteration 8 is 89. So it seems like it is dereferencing the entire array from the element I point to...hmm.
Like I said I am still kinda new to c so #pragma pack is kinda lost on me. I looked it up and kinda get it. But it isn't so much me having a problem accessing the struct so much as assigning a pointer to an element in a char array to a variable in the struct. The pointer gets assigned but ends up reading the entire array from the element I point to instead of the individual element in the array.
I think since the arrays get an assignment the size is implied, but the problem is that arrays can't be specified as "type[] name", but as "type name[]", and then all the other errors are just additional symptoms of that. tested it to verify and it works :)
It most definitely doesn't work as OP tries to parse a number (`%d`) into an array of `char`.
Are you sure you're not coming from a Java background? char[] X should be: char X[]
&gt; What functions are you talking about? As far as I am concerned, even before the _s functions, every single standard library function that deals with strings had a variant where you can specify the size of the buffer to write into. While `printf` does have the possibility to specify the number of chars to write out with `%*s`, scanf does not -- in scanf the `*` sub-specifier means that input is to be ignored. You can however specify a width within the format-string, eg. `%80s` -- this however means that format-string itself has to hold the length, so it must be either fixed size or one has to create it with eg. `sprintf`. While the first might work for many cases, the one I described is not one of those. The latter is not elegant at all. &gt; The glibc has %ms for a conversion that automatically allocates a suitably large string. Another possibility is to first read the line with getline (which automatically allocates a suitably large buffer) and then use %n to find the offset of the string: Sure, but neither is standard C. Then I could also use `_s` functions that are only available really in the VS CRT. But since I don't really like Windows and don't do much development on/for it and it's not portable, too, I won't. &gt; But anyway, if you need this kind of functionality, scanf is likely not the right function to do what you want. It's purpose is quick'n'dirty parsing of simple text files, not being able to work with arbitrarily long strings. Sure, but this was just for the sake of example, I didn't want to make it more complex. &gt; The buffer size is not readily available every time you use malloc or if you use an interface like strdup. You have to remember to pass the same buffer size to the _s function. This is error prone. Is passing the wrong buffer size more error-prone than not passing a size at all and hoping for the best? If one is working with strings in C one should always be on the guard. The `_s` functions are making it more easier -- not safe, but safer. &gt; The whole point of the _s functions is not to prevent errors that could not have been prevented before (which they don't) ... Yes. But they make it easier to build checks against those errors. Instead of writing a complex wrapper to check for lengths each time, I can just specify the length of the buffer. Basically any function that takes a buffer in C, also takes the length of the buffer. I think, those functions should not be an exception. &gt; ..., but to catch errors that come from lack of concentration or typos. And they fail horribly at that goal as the report indicates. No, as I said, I think they make it just more easier to build checks. I just have to pass a length. So yes, they don't "fix" all problems, but they are an improvement. &gt; Of course in most situations the buffer length is known by a quick look, but imagine that you are tired and accidentally copy the wrong buffer size. That's the kind of error they want to catch and they fail miserably. I don't want functions (at least not in C) that check for errors, but only functions that make it easier for me to do so. And this is something that the `_s`-functions are great at. 
thank you for testing. What editor are you using if I may ask?
Check your logic interpreting characters as digits. Note that in ASCII, `'0'` has the value `48` and `'B'` has the value 66. The computer does not know that you want `'0'` to have the value 0 and `'B'` to have the value 11, you have to do an explicit conversion, e.g. by means of a lookup table.
I tried casting value[] and number[] as an int, would that be sufficient to conver the ascii character to an int? I still receive the same answer
 if(counter = 48) There's your problem. You probably want to compare counter to 48. What you are doing is assigning 48 to counter. Comparison in C is done by the == operator. So all your if clauses should look like this: if(counter == 48) EDIT: To clarify why your code compiled (it should give you a warning though): The condition of an if-block can be any expression that evaluates to a number (char, short, int, long, etc.). "counter == a" evaluates to 1 if counter and a have the same value and to 0 if their values differ. "counter = a" assigns a to counter and evaluates to a, so the condition is met when a is not 0. Assignment in an if-clause are sometimes useful. Have a look at this example: if((c = getchar()) != EOF) { printf("%c", c); } This reads a character from the console, checks if the end of input was reached and if not the character is printed.
thanks again
 char X [] = ""; This allocates an array of char of size 1. If you attempt to write more than one character to that array (which definitely happens if you write `scanf("%s", X)`) then you invoke undefined behavior. You can't just leave off the size and expect everything to work. You need to pick a size for the array that's large enough to handle whatever you're going to do with it. 
Forgive me if I'm missing something, but it doesn't look like you're allocating space for your scanned strings. Instead of char X[] = ""; You need to do something like char *X = malloc(STRSIZE); Or allocate an array on the stack. In either case, you'll also need to ensure that whatever string you read in fits in the allocated space (if using scanf, look at the width modifier to the format directive). 
Hello, so I think there are few things off. 1. getBase() is not really getting the base of the number but actually the lowest possible base right? Let's think about it, how are we supposed to know if 101 is binary and not any other base greater then base 2? 2. basically what /u/FUZxxl mentioned. Conversion of values. 3. char X [] = ""; You're allocating an empty string here so how is it supposed to fit a word? If it works then only because part of the word did not get overwritten in the memory during run time. (also you get a segmentation fault) I would recommend to try and use either debugger in IDE that you are using, set up breakpoint and look what is in your variables, or if you can't use a debugger just use plain printf to print out values in between steps.
The Computer Science program at my school is just bad. Which is a real shame because there are a few instructors that really do try their best. But yeap, you don't get any feedback on tests/assignments/projects unless you specifically make an appointment with them to talk to them about it. In their eyes if you aren't willing to come spend the time to talk with them then you don't really care about the grade you got, which I guess is kinda understandable. They are getting better from what it used to be though so I gotta give credit where credit is due. To give you a sense they had to beg people to say nice things about the department to high school students who were coming out to see what it's like. The high school students were pretty excited but a few of the college kids pulled the ones that really seemed excited to the side and basically told them yeah... don't come here if you want to learn this stuff save your time and effort and go somewhere else. It's not that it's too hard, it's just not done very fairly to students. 
welp op deleted the code but I thought he was assigning "" to the pointer and then scanf ing into it. I believe the problem is that they didn't want to scan in an array of characters but a single character (or integer?) In which case it should have been "int a; scanf("%d", &amp;a)'". I think I was confused by the notation and assumed they were trying to scan in a string. 
Yes. What are you doing that it's not?
who studied digital electronics its more easier,better learn first basic operation NOT,AND ,OR later XOR,XNOR
If SIGCHLD is *really* the only signal you want to handle, then it's entirely possible (and might be probable) you don't need to do any signal handling at all! By default, your process will do nothing when it receives a SIGCHLD (Which is different then other signals, most of which terminate your program by default). But as long as you call `waitpid()` then it may not matter - for example, if your program sleeps on a call to `waitpid()`, then you don't really care about the SIGCHLD signal you might receive since you're going to handle the zombie anyway. It's not the running of the SIGCHLD handler that's important, it's the call to the `wait` functions. Even more useful, if you set the SIGCHLD handler to SIG_IGN (Set it to be 'ignored', rather then SIG_DFL, which sets it to 'default'), SIGCHLD is also unique in that this causes children to *automatically* be waited for by the kernel. Meaning, as long as you don't care about the return codes you don't even need to call any of the `wait` functions at all! That said, if you *do* want to use signals, then I'll talk about them below and talk about your actual question. I feel like you don't quite have a full understanding of how signals work in Unix. Signals are essentially implemented like Userspace interrupts, and `sigaction` is used to install handlers for those interrupts. That said, the simple answer is that, when you *return* from the signal handler (Like you normally return from a function), you will automatically return to the spot you left off in your program, you don't need to do anything special. When you receive a signal, the kernel pushes your current program state onto your stack, and then forces your program to start executing the signal handler from what you specified using sigaction(). From that point on, the signal handler runs, and when the signal handler returns, your code starts executing from the spot it was interrupted at (Like a normal interrupt handler does). Example: #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; void sighand(int signum) { /* Note: printf is actually illegal inside of signal handlers - NEVER do this - I'm just using it for example purposes. * If you run this code, this `printf` may not actually work and/or deadlock, and the output may very well be * garbled with the `printf` in main(). */ printf("Signal: %d\n", signum); while (waitpid(-1, NULL, WNOHANG) &gt; 0) /* Reap children */; /* Return back to where the signal handler was called */ } int main() { struct sigaction act; memset(&amp;act, 0, sizeof(act)); act.sa_handler = sighand; sigaction(SIGCHLD, &amp;act, NULL); /* Start children here */ /* Loop waiting for children to exit */ while (1) { pause(); /* Pause just doesn't return until a signal is received and handled - an efficient way to wait for signals. */ /* When we get a SIGCHLD, the code starts running for this point */ printf("We got a SIGCHLD!\n"); } } That's the standard SIGCHLD approach. If you don't care which processes exit when, then it is sufficient to ensure you don't leave any zombie processes around. To keep your initial question in mind, when you exit form `sighand` the program just keeps going where it left off. Also note the loop of `waitpid`, which can be a common source of errors. Signals are not queued, so if you receive more then one before running your handler, the handler only gets called once. Because of this, there may be multiple children waiting when you receive SIGCHLD - you don't know how many. To remedy this, you can call `waitpid` with WNOHANG, which makes `waitpid` return immediately if no more children are ready to be immediately waited on. When that happens it returns 0 or -1, depending on the condition. Normal `waitpid` returns a positive integer, so we loop until we hit 0 or -1. That said, signals can bite you hard in the butt if you're not careful with them. Generally speaking, a good way to handle them is masking via `sigprocmask`, and then using special functions that will, in one operation: Swap your signal mask, wait for a signal, and then swap it back the original signal mask. The big advantage of doing it this way is that it forces your signal handlers to only run at prescribed times. In the above example, the SIGCHLD handler can be run at *any* point after you call sigaction, even though you may not be prepared to correctly handle it (Normally, handling a signal requires run some code for it in the handler, and some code for it in your main thread) - for example, when your starting your children, if one of them exits really fast then your handler may run before you're done setting up all your children. To avoid this, you can do it this way: #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; sigset_t sigs_to_handle; void sighand(int signum) { sigaddset(&amp;sigs_to_handle, signum); } int main() { sigset_t mask, unmask; struct sigaction act; sigemptyset(&amp;mask); sigemptyset(&amp;mask); sigaddset(&amp;mask, SIGCHLD); /* * This sets our current process signal mask to `mask`. * That sigset has SIGCHLD marked, so any SIGCHLD signals we receive * after calling sigprocmask() will *not* call any installed signal handlers * until we unmask SIGCHLD. * * Note they are *not* lost, they just don't execute until we allow them to. */ sigprocmask(SIG_SETMASK, &amp;mask, &amp;unmask); /* Now we install the handler for SIGCHLD, and then start and children we have */ memset(&amp;act, 0, sizeof(act)); act.sa_handler = sighand; sigaction(SIGCHLD, &amp;act, NULL); /* Start children here - remember that SIGCHLD is still blocked, so if any children * exit our SIGCHLD handler still won't run */ /* Loop waiting for children to exit */ while (1) { /* sigsuspend() is a special version of pause() which installs a new mask before * waiting for any signals, and then restores the old one before returning. * * When sigsuspend() installs the `unmask` signal mask, SIGCHLD will become * unmasked and our SIGCHLD handler will be called if we receive SIGCHLD. * But because we used sigsuspend() in this way, during this call to sigsuspend() * is the *only* time in the program that SIGCHLD will be handled, which avoids * a lot of race conditions. */ sigsuspend(&amp;unmask); /* When sigsuspend() returns, that means we executed the handler for some signal. * Since the handler marks off what signal it was in the 'sigs_to_handle' variable, * we can check that to figure out what to do */ if (sigismember(&amp;sigs_to_handle, SIGCHLD)) { /* Handle SIGCHLD, and unmark it */ sigdelset(&amp;sigs_to_handle, SIGCHLD); while (waitpid(-1, 0, WNOHANG) &gt; 0) /* Reap children */; } /* Handle any other signals below this point */ } } (In addition to `sigsuspend`, there are also functions like `ppoll` which allow you to swap in a signal mask and also wait for a file descriptor to be ready for some action on it. Using those functions allows you to do the above but wait for other actions in addition to signals.) That approach is more complicated, but is a billion times more robust because it guarantees your signal handler will only run during the call to sigsuspend() and at no other time. This will make reasoning about your program a lot easier when you're trying to handle more then one signal, because for example it guarantees that 'sigs_to_handle' won't be modified while you're reading it in main(), since no signal handlers can run during that point (Because they're masked). Other techniques can't guarantee you won't have dataraces (Since signals can execute, and thus modify data at any time), and thus have to resort to careful usage of `volatile sig_atomic_t` to attempt to ensure they don't miss any signals. Honestly, knowing what I do about signals, I'd recommend avoiding them as much as you can. They're a necessary evil for some cases and they're decent for what they attempt to accomplish, but really annoying to use correctly and they have a number of flaws that make them unsuitable for a lot of cases.
just to clarify: I tested compiling the code, not running it, so the issues others are pointing out still stand. the editor I use is vim, but that doesn't really matter, any editor is fine.
Another option is to work out the number of rows from the given width and use your existing code.
#include&lt;stdio.h&gt; int main(void) { int i, j, blank, rows, baselength; // Declare variable 'i','j','blank',rows',baselegnth printf("Enter top-base length =&gt; "); //Promptiing message scanf("%d",&amp;baselength); //Read input in variable baselength rows = (baselength + 1)/2 ; //Compute numbers of rows (derived from Arithmetic progression formula) for(i=rows; i&gt;=1; --i) { for(blank=0; blank &lt; rows-i; ++blank) printf(" "); for(j=i; j&lt;= 2*i-1; ++j) printf("*"); for(j=0; j&lt;i-1; ++j) printf("*"); printf("\n"); } return 0; } thank you! thats exactly what ive edited it too. im guessing this is too convoluted an approach...
May i know how to write it more simply? id love to do it, i just cant wrap my head around it. 
please don't use reddit to cheat on your homework
There are a couple of cool things you could take advantage of here. Instead of using a loop to print spaces you could use printf() string formatting like this: #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { printf("Enter the number of rows: "); int rows; if (scanf("%d", &amp;rows) == 1 &amp;&amp; rows &gt; 0) { char stars[rows * 2 - 1]; for (unsigned i = 0; i &lt; sizeof (stars) / sizeof (char); i++) stars[i] = '*'; for (unsigned row = rows, nspaces = 0, nstars = rows * 2 - 1; row &gt; 0; row--, nspaces++, nstars -= 2) printf("%*.*s%.*s\n", nspaces, nspaces, "", nstars, stars); } } 
Ask your professor. There should be some sort of a tutoring or other resource available at your university that can assist with your questions, and may be more helpful in the context of where you are.
Look through the archive in this subreddit. This question has been asked countless times now.
Imo, Carl H.
Remember /r/C_Homework exists.
A locale is a collection of a lot of settings that encompass things that change from one location to another. It includes not only character encodings, but string collation rules, case folding, character classification, time/date formatting, money/currency formatting, and so on. This is incredibly complicated and involves knowing the customs of hundreds of countries. For example, for string collation in Danish, you'd need to treat Aa as a single letter and equivalent to √Ö, which incidentally is the last letter of the alphabet (which has 29 letters.) And for example in Turkish, there are dotted and dotless versions of both capital and lower case I, and the case folding rules are bizarre, as toupper(i) = ƒ∞ (with a dot) and tolower(I) = ƒ± (dotless). There are thousands of these strange and bizarre rules. It's the kind of thing that the Unicode consortium spends years working out, but the locale rules predate Unicode. The C locale is the one that you're probably familiar with, i.e. it uses strictly ASCII and no special collation rules. It's also known as the POSIX locale because it's the one defined by POSIX. It is the one you get if you don't explicitly set a locate in your environment. 
The second function has one branch per iteration and that branch is easy to predict. This cannot be said about the first one, which has two branches, only one of which can be predicted easily. Note also that both functions have a bug where it's implementation defined whether they work with negative numbers (right shifting negative signed integers may or may not shift in the sign bit, depending on the implementation). Another possible implementation is this (attributed to Kernighan): int c (int n) { int count = 0; while (n) { count++; n = n &amp; (n - 1); } } You can work out yourself how it works. Note that very recent versions of gcc and clang recognize this implementation (not sure about the others) and compile it to a single instruction if possible!
At my uni the CS courses have several programming assignments due during the semester--I've had to do as little as 4 and as many as 9 for a class. My best advice would be to start the programs as early as possible, especially before an exam. You kind of have to bang your head again a wall in order to learn programming. While studying material can help, practice is how how you learn. I'm studying engineering and CS and my engineering classes have shown me that it's all about practice and repetition. Try things.
&gt;There are machine instructions which operate on a whole byte (or word, etc) at a time, so doing n &amp; 00000001 is not (theoretically) going to be any slower or faster than n &amp; 11111111, if that was your point. It's still 'one operation'. You're right. If I just time the masking operator, I found that they take approximately the same speed to execute, regardless of whether I do n&amp;0 or n&amp;0xFFFFFFFF. I also found the same thing with bit shifting. I'm guessing that machine instruction operates on 4 bytes at a time for integers. Is that what you meant by word? &gt; Your conclusion about a being faster when N &lt; 4 I am not really sure about. I don't really see much of a reason why this would be true since you would still be executing more machine instructions for a then b. I'm starting to agree with you now. I believe the reason why *a* is faster than *b* is because in *b* we're initializing a new array *arr*. When I initialize *arr* as a global variable (so timing *b* will skip the initialization of *arr*), I found that in only one iteration, they will execute with about the same speed. When I set n to be a big integer, function *b* gets 4x faster than *a*, as expected. Thus, the reason *a* is faster than *b* when N is small is because *b* has to initialize *arr* before iterating once or twice. Slightly offtopic question, when writing new data, will this be the series of events? 1. load contents from a cacheline 2. Write array to this cache line. 3. cacheline marked dirty 4. CPU continues with the next instruction Anyways, thank you for your response. I've learned a lot from what you said and from my response! 
Read a line at a time with fgets(). Then parse that string and extract the values you need from it if it's the right format.
Even a small jump can ruin the pipeline if it isn't predicted correctly.
book: learn c by the hard way , and 21 century modern c. 
Would rewriting the if statement in the first fucntion as count += (n &amp; 0x1) get rid of this branch?
Yes. That's possible. Likely, the compiler does that anyway.
But if the array isn't in the cache, you'll pay a hefty penalty for the first load, which would probably result in the first function being quicker. A quick look at the results from [gcc.godbolt.org](https://godbolt.org/g/1aNhaj) shows us a few things. In the first function, the branch inside the loop is eliminated by rewriting it as `count += (n &amp; 1)`. In the second function, clang treats the array as if it were static const , rather than copied into the stack. gcc copies it to the stack, as written, but in each case a cache miss would mean this function would run far worse than the first. In my opinion, this is a terrible interview question; the performance depends entirely on the compiler, the optimization level and the target architecture. You can't give a right answer based solely on what you're given there. But a good answer would probably discuss the various possibilities as I've done here, while not reaching any solid conclusion. If you want to determine performance, you have to actually *measure* it.
&gt; You may have noticed that the "Enter your length" prompt never appeared either. Another point at which systems will make sure that output has actually been displayed, other than when a newline is printed or the program exits, is when the program tries to read input. The reason for this is exactly what's demonstrated in this program; when the program prompts the user for input it's important that the prompt actually show up on the user's display.
Thank you very much. Friendly people in this subreddit!
:-)
Look at bitmasking and bit-shifting. The logical and operator &amp; (not &amp;&amp;) and the bitwise shift operators (&gt;&gt; in particular).
You'll have a pattern every 40 bits. I'll write an example of a few of the 8 cycles in a clear way u8 ar[5]; // read 5 byte input 1. // mask first 5 bits u8 x = ar[0] &amp; 0x1F; 2 // shift last 3 bits, mask 3 bits, position first 2 // bits of next byte into slots 4 and 5 and | with 3 // lower bits, mask first 5 bits u8 x = (((ar[0] &gt;&gt; 5) &amp; 0x07) | (ar[1] &lt;&lt; 3)) &amp; 0x1F; 3 // shift off the first 2 (low) bits and mask 5 bits u8 x = (ar[1] &gt;&gt; 2) &amp; 0x1F; 4...8 // etc There are better ways of doing it, and terser, but I am trying to make it fairly obvious what I'm doing.
exactly, and hex is generally just easier to read into the binary representation than decimal in my opinion. Its an easier pattern. 1, 3, 7, f, 1f, 3f, 7f, ff rather than 1, 3, 7, 15, 31, 63, 127, 255... and individual bits, from lowest bit to highest 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
You ran the code in the link I provided?
If I hadn't already tried this and found the error I wouldn't have posted. I can't figure out what's wrong with it, it seg faults in the intersection but it still doesn't tell me what I'm doing wrong, I can't figure that our and that's why I posted.
if it does not work with scanf, then what does it work with?
First thing to do when you catch a segfault is to make sure you're always checking pointer parameters for NULL before dereferencing them. Next thing is to have the OS generate a core dump and load it into the debugger, it'll tell you exactly where you're faulting. Usually something like $ gdb dump.core myExecutable Then you just run "where" or "bt" at the gdb command line and you get a nice stack trace at the time of the fault.
Hey! Thanks for taking the time to help me figure this out. I just discovered that the site only takes pre-loaded inputs and then you have to run teh code. I thought that was pretty dumb and he had never mentioned that is the way it's going to work. So this whole time I thought my code was fucked. I will definitely look into the data validation part of it like you mentioned. Thanks again for your help . 
This might be too much for a beginner to grasp
Several folks told me that the redis source code is amazingly straightforward and modern. https://github.com/antirez/redis/tree/unstable/src
Don't know what half of this means, gdb, where, bt??? 
It is implementation defined whether `char` is a signed or an unsigned type. Thus in either case, there are platforms where the assignment would change the signedness of the pointer. That said, when dealing with strings of characters, you should definitely use `char` instead of `uint8_t` or `int8_t`. The latter is just more confusing.
https://github.com/nothings/stb I use it everyday!
Well the ppm file is the output so I'd hope you wouldnt make that up, but the Json file I forgot to include I'm sorry. And again I don't know what I'm doing that's why I'm coming here, I'm not sure how I would link it do you mean include the math library?
The sqlite source code is pretty nice. I recommend [xv6](https://github.com/mit-pdos/xv6-public) if you want to understand how to program a simple kernel. It's also nicely structured and documented.
I mean -lm as in linking the math .so. But I did compile and run, and did run into a couple issues. For one, there are two Object arrays. A global, and a main... 38. Object objects[128]; // Global scope .... 473. Object scene[128]; // Local main scope 497. read_scene (temp); // Passes only a FILE // Parses data into the global objects array 507. do_raycast (scene, width, height, data); // Then passes in the local scene array So this blows up when you reach the parts of the data structure that are of "vector" type... or allocated memory from the parser. But, it also blows up the same way if we change the do_raycast argument to be the global array as well. And for this... 356. index++; I have not dug into it deeply, but it appears you push the index too soon. The objects[0] is always NULL... so I changed the 507. do_raycast (&amp;objects[1], width, height, data); This does produce a ppm file. But I have no idea if the values are correct. I know what raycasting is, but I have not followed the logic of the code. And have been passing junk width and height arguments. You should really clean up the parser, and definitely decide on a global or local object[]. read_scene needs a parameter for objects[] or, do_raycast doesn't need one.
&gt; It is implementation defined whether char is a signed or an unsigned type. Hmm. Well yes, but I expected it to be either one or the other on this particular system. The warning seems to suggest that *both* are wrong. I agree about using `char`. I just ran into this while exploring, and couldn't understand it.
I think the compiler is just warning you because you could happen to write the version that is correct for this system, but which would be incorrect when you try to compile it for another system, so it's saying you really *ought* to just use `char`.
Why do you need a mathematical equation when you can make the program? Perhaps you'll find it easier to write this equation once you implement the program.
I believe you've been asked to see if array[0] == array[len - 1], and then see if array[1] == array[len - 2], etc. If that's true until the point where your left side's index is equal to the right side's index, then you've satisfied the requirement. It's not really a "mathematical equation" per se, but it sounds like what you've been asked for.
Ye but how can i make it return value TRUE in a boolean function if i have to compare more than one statement?
Um ... return TRUE; /* ? */ 
You can go through the pairs one by one, returning false if they don't match. If you get to the end, then all the pairs matched and you can return true.
I'm going to have to write array[0] == array[len - 1], and then see if array[1] == array[len - 2], etc. How can i make it return TRUE if ALL of these statements are true?
I'm gonna have to do tons of if else statements if i wanna do it for each and every element or is there another way?
Like how am I supposed to write if within an if, for example if array[0] == array[len - 1] do another check up on array[1] == array[len - 2] and so on till i get to the point that if the statement "if" is not true it returns false 
I like to think my code is great: * [libcsearch](https://bitbucket.org/manvscode/libcsearch) * [libutility](https://bitbucket.org/manvscode/libutility) * [libcollections](https://bitbucket.org/manvscode/libcollections) Let me know if you find it useful.
u8 is just because I was too lazy to type uint8_t... which is also a shorthand typedef of unsigned char in the &lt;stdint.h&gt; file. All of which is just 1 byte and unsigned. ar was just an array of uint8_t's, with a lenght of 5. So you would read in 5 bytes to the array from the file, and transform to 8 chars. x was just the temp variable name... and it'd be cast back into a char after reading the 5 bits. It was pseudo code, meaning... not all of it is implemented, just enough to try and get an idea
C is an unsafe language, proud of being close to the metal. You'll be able shoot your foot easily, multiple times. There won't be anything stopping you from mixing types, writing to uninitalized memory or running out of array bounds. There won't be your mommy with smart pointers holding your hand and cleaning your mess after your function returned. What are you waiting for? Why are you here with your feet still intact and healthy?
It's fast, if you do it right. It's not a safe language, however. If you don't know what you're doing or make an honest mistake you can end up really screwing yourself. Badly. Really badly. Like ruining everything badly. And you might not even know you've screwed yourself until you're 6 months into a project. A metric fuck load of stuff is written in C. If you want to study operating systems, you're almost definitely going to have to read source written in C. Additionally another load of libraries, codecs, databases, compilers, etc... are all written in C. It's totally ubiquitous and pretty much every desktop computer in the world is heavily reliant on code written in C. C will teach you about how computers actually work. It allows you to understand what's going on inside your hardware with a very thin (relatively speaking) layer of abstraction compared to higher level / OO languages. I'm sure there are a ton more reasons to (or not to) focus on C but these are just a few that came to mind.
I'm pretty sure you do not want to program in C on an Android device. It sucks.
&gt; void main(void) That's not the correct signature for `main`.
main needs to be int main(int argc, char **argv) and if you're on really really old windows int main (int argc, char **argv, char **argv) The other double char pointer is for some dumb windows system thing. Also, hasn't Dev C++ been like, obsoleted for a decade? You should probably start using something a tad newer. (Maybe I'm wrong, I don't even use Windows anymore)
I see, I will try with more sensible width and heighth. So the objects array is incorrectly setup, objects[0] was always NULL. So it would segfault the first time, because type=0, and the vector objects[0].plane.normalize is a NULL pointer, and is accessed. The do_raycast function takes a Object\*, so I have to pass a pointer. objects[1] is the second element in the array, and is initialized. So I am passing the address of the second element... or an address to a Object, which is a Object\*... it is just cutting off the first element. // Object array of len 128 Object objects[128]; once it gets passed to a function ot becomes an Object *obj; // of len 128 obj[1]; // an Object struct &amp;objects[1] // an Object struct * of len 127 so after &amp;objects[1] gets passed to the function... it sees.... Object *obj; // where obj[0] == objects[1]
Not the best code for linux, if you use that.
From a perspective of a native speaker- it's time that is complicated, and English is just describing it :D
Nobody will solve your homework here. It's not even the correct programming language for this subreddit. 
This subreddit is not about C++. Please ask C++ questions elsewhere, like in /r/cpp_questions. I have removed your post as it is off topic.
I think Chinese is one of the easier languages to learn. The most difficult part for me was the pronunciation.
This is the most pathetic blog spam website I've ever seen. the authors aren't even capable of filling it with content, so they instead ask others to write the content for them.
It's mostly for on the go. It's an hour to school by bus. I usually read up on the second edition ansi C text book by Dennis Ritchie. But I would like something more compact. 
Damn, I love Torvalds.
Somebody who is looking for free help over the internet doesn't have the time to check if they're asking in the right place.
Please post a sample input file so that we can run your code.
I've programmed several projects in C and Linux. The most advanced were a shell, virtual memory, and a simple filesystem. I imagine I can help you out! I've done programming tutoring before, normally with Skype. Reply or message me and let's get started.
&gt; You can send your Code or C++ file via my email. Hahh, fuck this guy.
It's not endianness, its the order that the bitfield is laid out. This is implementation defined. Persumably, your compiler lays out unsigned sig : 1, exp : 8, man : 23; as high bits low bits mmmmmmmmmmmmmmmmmmmmmmeeeeeeees ie. the 1st listed member of the bitfield occupies the lowest bits. Which doesn't match the layout of float. Also your mFloat structure will have the same size as `unsigned` even if `unsigned` is 64-bits and you're not using 32 of them. 
I know C but it has been many years. Mind if I join in? 4bb96075acadc3d80b5ac872874c3037a386f4f595fe99e687439aabd0
Not discounting the value of teachers but you're always welcome to ask here. Just try to have a well-formed question. But oftentimes (or at least if you're me) you'll probably end up using reddit as a rubber duck.
I can teach you and lay the foundation for expert C programming. I have written games, command line tools, graphics programs, a web framework using FastCGI, and many other projects. http://www.manvscode.com/
That is not correct, number is a member on the struct. The pointer is dereferenced with the [0], after that the struct is accessed normally (with the . operator.) 
Maybe this isn't the best thing to say, but I would say try to figure it out yourself. If you want to have a (good) career, a lot of your time will be spent figuring out things on your own and there won't be anyone to help you. I would first off pick a better book. I personally think that Zed A. Shaw's books are a terrible way to learn programming. I would save the money you would pay a tutor and instead I would recommend picking up a copy of [C Programming by K.N.King](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504). Read the book and do all the exercises, then read it again. This will give you a great understanding of C. For makefiles there are plenty of resources on the internet that you can find by googling. Or better yet, read the [Make Manual](https://www.gnu.org/software/make/manual/make.pdf). 
Yeah the ruby scripts are not great, but once you work through that it seems good. I'm working on factoring hard coded prefixes and paths out of the ruby scripts, trying to make it way easier to understand, so that if I use it at work, other developers won't have to deal with the learning curve. I should push it somewhere so I can share. Trying to get a sample environment/project setup with automated unit testing and mocking with unity and cmock, code style enforcement with astyle, rule checking with splint, and still trying to find a good cross platform tool for metrics and complexity analysis, and a bug tracker that can run off a network drive instead of server... (my works IT Dept sucks, have to use DVCS directly off a network drive which is over two orders of magnitude slower than a proper server would be when working remotely, piss poor VPN taking 5-20 seconds for each individual file access, vs uploading a few hashes and a few files to a server which would do all the database crap locally...) The goal is to have one project that can compile in Windows or Linux targeting either the native OS, or AVR/ARM/IAR/what-have-you.
In addition to what others have said, the typical use cases for a double asterisk are an array of pointers or an array of arrays (2D array). I can't imagine why you would want a 2D array of student structures so I would assume the first; you return a pointer to an array of pointers to student structures. Since you're returning pointers to the structures you need them to be on the heap so that they don't get expire when the function returns. Look up malloc if you're unfamiliar with it. I would have two calls to malloc, one for the list of pointers and one for the actual location of the structures.
I was in a similar situation https://ideone.com/ was great for that
Thanks, I'm going to explore other options preferably, due to the input restriction ideone has, but it's definitely a functional alternative to anything else.
I'm not terribly tech savvy at the moment, would doing that disrupt the operation of the computer the way booting an OS off of a flash drive would?
I would recommend msys2, which includes the pacman package manager and a large repository of software (both applications and libraries for development)
When I first read the title I figured you meant on your phone or something, which might still be an option to consider if you can bare the touchscreen keyboard or have a physical (maybe bluetooth) keyboard. With a GNU chroot on an android phone you can install a compiler, editors, libraries etc. through the regular package manager. There are a number of apps for installing a GNU chroot on your phone (the kernel, Linux, is already included with android). The one that comes to mind for me is lil'Debi which installs Debian. I believe some of them also use proot to not require real root access. "Hacker keyboard" gives you the characters you'll need on touchscreen.
I would recommend to run your program with valgrind (or to compile with -fsanitize=address, -fsanitize=...). I do it almost systematically when I do development. It saved me a lot of headaches...
Your post got caught in our spam filter. I apologize for the inconvenience.
Why don't you want to use pointers? Please always motivate such seemingly arbitrary restrictions. That said, it's going to be very hard to answer this question as pointers are everywhere. It's incredibly hard to do any IO at all without using pointers. For example, every stdio function that takes a `FILE*` uses pointers.
Thanks. I will just delete it. I am on mobile now and much harder to edit. 
[](http://i.imgur.com/kzRNVh1.png) [](http://i.imgur.com/DvRNhnF.png) Could someone explain this a bit more easier to understand or privide links that explains this better.
Sorry bout that. Here you go! http://i.imgur.com/yw52TQ1.png Apologies, i'm really bad at creating flowcharts.
Perfect, thanks mate! i might create a different loop to compute the digits once. I'll try it now.
Take a look at the man pages for pthread conditions. pthread_cond_signal , pthread_cond_broadcast , Etc. Instead of global Also, make sure to lock the array before modifying it... but you probably already know that since it's the premise of the assignment
This is more or less what I did in the assignment aside from still using the struct and bit fields to store the masked values. Thanks though, it's good to know I should avoid the solution I proposed.
You could find it easier to read if you break it into steps. You may find this version of getline easier to read /* a point to a character named s, tell the programmer it is an array, an integer named lim */ int getline(char s[], int lim) { int c, i; /* Copy up to lim -1 characters to avoid buffer overflow Note the -1 is required because there needs to be a NULL termination character added to a string */ for(i=0; i&lt;lim-1;i++) { c=getchar(); /* If not newline or end of string copy */ if(c != EOF &amp;&amp; c!= '\n') { s[i] = c; } else { /* The increment is evaluated before the conditions But since break will exit the loop without incrementing, the increment must be added manually */ i++; break; } } if(c == '\n') { s[i] = c; ++i; } /* NULL == '\0', and signals the end of a string in the standard string library */ s[i] = '\0'; return i; } 
Your links weren't pasted directly, but I saw them when trying to reply. In "getline" and "copy", the arrays are being passed in by reference, meaning a pointer. The difference between say "char s[]" and "char* s" is that you can't change the value of the pointer (s) in the former while you can in the latter (e.g. "*s++"). Otherwise they mean the same thing.
Originally, the `signed` keyword didn't exist and every integer type was signed by default, including `char`. This decision made sense back then as ASCII only uses values 1 to 127 (with 0 being the string terminator) and all integer types being signed by default is easy to remember and systematic. Then IBM wrote their own C compiler and made `char` an unsigned type, probably after asking the very same question you ask and finding, that a signed `char` is tricky to use with EBCDIC (IBM's character set) because it contains 255 characters, thus making use of ‚Äúnegative‚Äù values. Now we have the unfortunate situation that the signedness of `char` is implementation defined. A real pain in the ass.
This was my first post.next time i will ask right
why isn't a 'short' unisgned by default? What would be the purpose of using a negative value for a short?
Valgrind reports memory leaks and out of bound memory access. For out of bound memory access, it gives you the number of the offending lines IF you compile your program with -g ... By running your program under development with it (valgrind mycompiledprog), you can catch quickly out of bound access errors and avoid future puzzling bugs.
Well shorts can theoretically be used for 2-byte characters. And chars can theoretically be used to store values that don't correspond to characters.
Better: why isn't 'int' unsigned by default? A char is just a small int. Nothing more, nothing less. None of the types in C are unsigned by default. That's why they have the 'unsigned' key word. It would be silly to have 'char' unsigned by default when nothing else is. How would that even make sense?
Is there a reason you chose not to use an int?
I know it sounds strange, but this is absolutely fascinating to me. I'm sure I'll have more questions after work today, but for now I offer my sincere gratitude. You've been beyond helpful.
yes i see your point i have updated my question, if you still dont understand can i PM you ? 