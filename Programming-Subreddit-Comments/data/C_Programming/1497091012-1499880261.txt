How good are you with algorithms and data structures? Do you have any CS education?
That seems interesting I'll give it a try. Thanks
Thanks, I think trying to write a simple chess AI seems fun and also kind of challenging :)
With the magic of _data structures and algorithms_ (insert spongebob_rainbow.png here). Usually you see some sort of linked list deal set up so that user pointers passed in to `free()` can have some bitwise arithmetic performed on them to get to the management information. For example, if you use aligned memory then a bitwise AND can trim off the low order bytes of the address and leave you with a pointer to the start of whatever block was allocated. They can be as compact or complex as you like. Then you have to worry about if you'll do first-fit or best-fit. Best-fit puts the complexity in the `malloc()` since you'll look for the _best_ fitting block to service a request. First-fit usually makes `free()` more complicated since you'll have to coalesce adjacent free blocks to combat fragmentation of free memory. Going even lower level, in the kernel, all you are really doing is shifting the stack and heap pointers around to expand and contract memory. But for a good first project there is nothing wrong with asking the kernel for nice big byte aligned memory pages to keep the project simple. You can take a peek at the super simple first try I did in college; its basically a sort of hashtable with buckets where the byte request is used as the key. It uses fixed block sizes which limits the upper bounds of what I can allocate but also makes it a little faster and gets rid of the memory fragmentation issue entirely. https://github.com/necheffa/pgalloc/blob/master/pgalloc.c
is the size of the space in 2 versions equal also? are they just entirely the same in each page?
examining printf was pretty interesting!
##X Macro X Macros are a technique for reliable maintenance of parallel lists, of code or data, whose corresponding items must appear in the same order. They are most useful where at least some of the lists cannot be composed by indexing, such as compile time. Examples of such lists particularly include initialization of arrays, in concert with declarations of enumeration constants and function prototypes, generation of statement sequences and switch arms, etc. Usage of X Macros dates back to 1960's. It remains useful also in modern-day C and C++ programming languages, but remains relatively unknown. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
You can always scan it into the system and make a pdf for your own use. Then you can make the text as big as you want/need. 
the coding style gave me cancer
You can't cast a char * which points to a string which looks like a double to a double. You need to use strtod or strtol
Is there any single reason why writing a text editor is so hard?
[kys!](http://s2.quickmeme.com/img/8c/8cea755ed9d65bd136fcd0fafe7ea50c767e9f4ebfba95c846d6d337a247b1de.jpg)
Show your code. Something uninitialized is the most likely explanation.
I've not run it, but my 1st observation is that `romNumeral[fourth]` is accessing the array past what has been initialised.
(9/5) is 1
I have since fixed that, but my wind chill and heat index numbers are still massively incorrect. Any other obvious mistakes that I have made?
Running that gives me a massive mess of numbers. Your loops need to go from num1 to num2. You need to print a newline at the end of each line. And things will line up better if you format your floating point output more consistently (use %2.2lf everywhere) wind_chill=d1+(d2*celsius_f)-(d3*wind)+(d4*celsius_f*wind); wikipedia says that the formula is 35.74 + 0.6125 * T - 35.75 * V^.16 + 0.4275 * T * V^.16 You're using V, not V^.16 
Try to read about good practice to improve your code quality and then try to write a program by your own. C is used everywhere, so it should be easy to find something to create or to contribute to ! :)
Browse the source code of production-grade projects with 'good' (IMHO) code like: - _tcl_ - _redis_ - _github_ This allows you to gain an appreciation of how a larger codebase is organised and also exposes you to good patterns.
Please stop making new accounts for your videos. This is against reddit's rules.
I'm the lead developer of https://github.com/uTox/uTox We're exclusively str8c. And will trade deeper knowledge of safe str8c, (as it pertains to a crypto/security project) for code donations. I.e., we'll teach you to write better/safer C if you wanna help us close some issues. :D
Write C code. Work on lots of little projects for fun. Read other peoples' code, try to figure it all out, you'll learn lots of tricks and techniques.
It takes around 1,000 hours to become good at something, and around 10,000 hours to become very good at it. So: keep practising...
Checkout the [Intel 64 and IA-32 Architectures Software Developer Manuals](https://software.intel.com/en-us/articles/intel-sdm)
[What a C programmer should know about memory](http://marek.vavrusa.com/c/memory/2015/02/20/memory/) 
Hi, What are the minimum technical&amp;engineering skills requirement for participating Tox Project?
Here are some techniques: http://nethack4.org/blog/memory.html
FreeRTOS has 3 different memory allocation (malloc) algorithms and implementations. This is good for beginners as there is no MMU involved. Go through the code and ask what you didn't understand.
I thought that the Tox project is basically dead
Seems like a great article. Will check it out thanks! 
You'd rip your eyes out reading GNU source code then.
I think OpenGL might not be the right tool for the job. If you really need to use it, consider rendering the graph as a raster image and then using that as a surface.
Can you render anything at all (such as a line or a simple traingle)? Is your projection correctly done? I know I messed around a lot to get a 2D projection correct.
i managed to render a line and points, so i did something right, the issue is that i cant manage to get the right points in the graph just some random points for some reason. also i have no idea how to show the axis that im using or give them names for that matter
A raster image (as opposed to a vector image) is an image composed of pixels. The kind of image you storage as a png or jpeg file.
Ok.
Sorry if I offended you in some way. I've seen your responses in the past and respect your opinions. Was just genuinely curious about the pros/cons of the approaches since I've thought about this problem in the past.
I do not take offence. Your approach is possible, useful in some circumstances and seems like a good training exercise. However, there is nothing I can say about it as I'm not very familiar with OpenGL and you didn't show us the faulty code, so I can't even try to debug it on my own. I suggested this alternative as it might be simpler to modify some pixels in an array than to deal with 3D objects.
i posted my buggy code as a response to someone else, do you mind taking a look at it? thanks!
Can you provide me with a sample `dust.txt` file? Why do you use these weird `_s` functions like `fopen_s`?
I can't access this file. It wants me to log in but I don't use Google drive.
Okay, so [this](http://fuz.su/~fuz/files/dust.txt) is the dust file? Why did you write such a complicated parser for it? I don't really understand what this is trying to do. And the fact that you use numbers instead of character literals (e.g. 32 instead of `' '`) doesn't exactly make this easier. What's the problem with parsing the file by repeatedly calling `fscanf` like this: fscanf(dust, "(%d,%d) %d %f\n", &amp;x, &amp;y, &amp;size, &amp;intensity); Note that you can check if `fscanf` was successful from its return value. See the documentation for `fscanf` for details. It is likely that there is a bug in your parser. Did you make sure it works? 
i tryed with fscanf but for some reason it didnt work. what i did was read the entire file and enter it into a single string (buffer), from there i started extracting the info that i need into a two dimnsional array (coord) and converting the characters into integeres (thats why i used the ascii numbers, and thats the big block of text in the middle). ill try to change it into fscanf and see how that goes. from what i checked what i wrote does work, i managed to extract the text from the file and convert it into integers which i later used to calculate the distance. also in the display function i do get correct calculations when i calculate E (the energy that i was asked to calculate) i just cant seem to graph those points correctly
here you go http://imgur.com/a/3BP3X
&gt; i tryed with fscanf but for some reason it didnt work. That's not an error description. &gt; (thats why i used the ascii numbers, and thats the big block of text in the middle) Note that `'0'` is the same thing as 48 if your character encoding is ASCII. But your program is much more readable if you write `'0'` instead of `48`. &gt; from what i checked what i wrote does work, i managed to extract the text from the file and convert it into integers which i later used to calculate the distance. Okay. And you do know that you ignore the fractional part of the intensity?
There was a great one I had in college but I can't remember the name....
that did the trick, found the issue thanks so much!!
Yes, shhh, it's dead... No more work or development time going in, nothing to see here, move along.....
A handy helper is array_size once you've defined sizeof: #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr)) 
The branches/repo getting active development aren't made super public to avoid the long history of trolling. I don't like tox.chat, so I don't contribute to that blog. Tox and it's clients are still getting daily commits/code.
Its just I am trying to learn C specifically :P Thought it might be a fun little project Not to sure what else I could do I have made a calculator haha Want to move onto adding a GUI but have no idea where to start
Look into using Gtk+ to add a gui to your calculator- it's a much humbler goal which will result in much less frustration. Once you have a ui, then maybe you can make a little game like snake for more of a challenge!
Check this project: https://github.com/imatix/gsl If you check the example folder it implements a finite state machine. New callbacks are appended to the generated "c" files when they are added to the xml model. Edit: For a better explanation of the state machine generation see this project: https://github.com/zeromq/zproto.
Look this video and code for a mini game, is a good start. It's made with the SDL library. https://youtu.be/FCRmIoX6PTA And this is the part for simulate key pressed https://stackoverflow.com/a/35777725/3521007
SECTION | CONTENT :--|:-- Title | Learning C Game Programming - Simple Gun Shooting Description | https://vertostudio.com :: http://twitter.com/mlfarrell3d Game code: http://vertostudio.com/pub/learnc/contro.zip Espresso-C aided tutorial on programming shooting projectiles in a 2D game Length | 0:29:56 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
You made me discover termbox. Very interesting. I've been building a lot of CLI utilities lately and this'll be my first step towards the almighty GUI (Text based interface). Ncurses always seemed to difficult to learn. Also, fun little games. Your code is very readable, even for a novice like me. Thanks.
1: x points to *y-&gt;next 2: x points to *y 3: x-&gt;next points to *y-&gt;next 4: x-&gt;next points to *y Only values changing are that of the pointers, no new structures are being created or copied
Thanks for the source; good reads.
`x-&gt;y` is equivalent to `(*x).y` because of that, x and y both have to be pointers to `struct Node` (I'm going to ignore the use of `Node *next` being incorrect and should be `struct Node *next`)
That's certainly the most reasonable interpretation of the question, I just don't trust OP enough to assume that's what they meant :)
Thank you, hope you learned something :)
Thanks for the kind words! Pretty close. When the operating system "slaps the wrist" of the offending process for touching memory that it doesn't own, the operating system will terminate that process by sending it a SIGSEGV signal. While you could theoretically use a signal handler to intercept that signal and override the default behavior of just terminating, this isn't something that happens often in practice. Using a handler for SIGSEGV is never ever ever the solution to the underlying issue. Your best bet is let it seg fault, analyze the core dump, fix the issue, and continue on. Contrast this with an exception in a higher level language, that exception can be caught, handled, and the program can march on smartly like it never happened. One final note is in these types of exceptions, it's not generally an operating system wrist slapping that propagates all the way to a place where exceptions are handled.
You're on the right lines with a mutex. You just need to go further: use two mutexes. One to represent each of the landing spots. Then you will need some logic for each incoming plane to check whether either of the runways are free. This may well need a third mutex, which represents the next plane in line looking for a landing spot. It may not though, that's just the first idea that came to my head.
Thanks for the great feedback, everyone. Much love. :)
advanced windows debugging has a nice heap section that'll help you understand the structures packed into ram that describes heap
&gt; this subreddit is cancer coming here saying that and still not getting downvoted  ï ‚Ä¢ÃÅÿà‚Ä¢ÃÄ  î
This is a simple question with a complex answer. If you're really asking whether these two lines of code are equivalent, the answer is yes. while (c) ; or while (c) {} They both say, "while the condition is true, do nothing." I usually make the body of the loop more explicit like this. while (c) continue; But that's a personal preference. You can also use either `{}` or `;`as the body of a for or do-while loop. (The latter surprised me.) 
I buy eBooks partly because I can change the font size. You can run Kindle on any computer. You don't need any kind of dedicated tablet for it.
Great article. Only criticism is comparing a pointer to a reference. There are major differences between the two. 1. A pointer can be reassigned. 2. A pointer has its own memory address and size. 3. You can have multiple levels of indirection (pointers to pointers to...) 4. A pointer can be null. 5. You can do pointer arithmetic to access ajacent memory locations. You understand this, then you understand C.
* Your `pthread_cond_signal()` needs to happen while the mutex is locked. Your queue has a race condition as it's currently written. * You're misusing `PTHREAD_MUTEX_INITIALIZER` and `PTHREAD_COND_INITIALIZER`, which is why it seems like you need to cast them. These are only for initializing statically allocated variables. Call `pthread_mutex_init()` instead. You'll need to destroy them when you're done with them, but only if no one is waiting, which means you may also want some sort of poison value to wake up any waiting threads. * Don't explicitly cast the return value of `malloc()`. C does it implicitly. 
I really appreciate the comment, thanks for taking the time. I realize I only touched on one of your 3 points earlier and wanted to address the others. &gt; PTHREAD_MUTEX_INITIALIZER Also good call on this. I've heard similar critiques. Thank you for pointing this out. &gt; Don't explicitly cast the return value of malloc() I don't totally follow. You're saying i don't need the `(struct tiny_queue_t*)` ? I'll admit that was some copy/pasta from another stack overflow post that i've been using. I'll give it a shot without. 
If you don't use the correct formatting specifiers, behaviour is undefined. There is little point in trying to reason about this. What you observe is probably the result of your platform's calling convention, but as you failed to specify the platform you are programming for, there isn't any further information I can provide.
Regarding malloc, you do indeed not need the cast at all. C will automatically and safely cast a void * to any other pointer type. There are more reasons given for this in this [StackOverflow question](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc)
+/u/CompileBot C #include&lt;stdio.h&gt; int main(){ int i; float x; i=10; x=43.2892f; printf("i=%f x=%d \n",i,x); return 0; }
I was wrong. There's no race condition here. Since the pop thread checks the condition before waiting, all while holding the lock, what you did is safe. I thought it was a problem because signaling a cond outside of the associated lock is often a subtle bug, and I assumed that was the case here. Without the lock, the signal could fire after another thread has decided it needs to wait, but hasn't actually reached the wait yet, causing it to miss the signal, but this doesn't matter in your queue. &gt; You're saying i don't need the `(struct tiny_queue_t*)`? C implicitly casts `void *` to other pointer types as needed, and `malloc()` returns `void *`. The explicit cast is just noise.
It‚Äôs a long-standing C idiom.
Another example of why I treat warnings as errors...gcc would warn about expected types
what do you mean by platform ??
&lt;https://en.wikipedia.org/wiki/Midpoint_circle_algorithm&gt;
**Midpoint circle algorithm** In computer graphics, the midpoint circle algorithm is an algorithm used to determine the points needed for rasterizing a circle. Bresenham's circle algorithm is derived from the midpoint circle algorithm. The algorithm can be generalized to conic sections. The algorithm is related to work by Pitteway and Van Aken. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.21
It's unintuitive and hack-y. Better to use a comment, since it also prevents people from having to think about the purpose of the `(void`)0`. A comment is instantly understandable, and certainly more readable. You should be adding comments regardless, so it seems like a waste not to.
I'm sorry, that wasn't my intent. I was trying to understand what you are trying to do. I'm afraid I still don't understand. I don't know what planets have to do with the problem. It seems that either they are a part of a story problem from a class or are a translated term that I'm not familiar with. I'd be happy to help you with this. Maybe you could show us what you have so far?
This was interesting. Could you please explain further? I have probably misunderstood something, but I thought va args (and therefore also printf) used a list on the stack and that data is not loaded to registers until the list is read? 
Here's the thing: There's a binary file with information of planets (it's the subject) , this file has the code (it's like the name ) and description of each planet. My task is: add a new planet. I've got a function that receives the description as a pointer . void addNewPlanet ( char *description ) this function is obligatory for me to use it. So this function must add a new planet according to the user description of the planet and the planet's name will be the ( LAST code of the LAST planet that the file has) + 1 . My doubt is how to read it properly. I was using fseek to get quickly to the last registry(planet) and with fread store the code into the struct's field codePlanet but I think it's not working because I'm not sure how to work with the struct field being a pointer. Edit: My function's sort of this: (skipping the parts both when I open and close) structPlanets planetFromFile, newPlanet ; /* structPlanets it's the struct I defined that contains the code and the description */ fseek (fileName, sizeof(planetFromFile) -1, SEEK_END); fread(&amp;planetFromFile, sizeof(planetFromFile), 1, fileName) newPlanet.code=planetFromFile.code +1 ; printf("Insert description of the planet blabla"); fgets(newPlanet.description, sizeof(newPlanet.description), stdin); fwrite(&amp;newPlanet , sizeof(newPlanet), 1, fileName) 
It has that signature because it's being exported/called in a dll, rather than just being a callback function within the code
Ok. Stepping back from the code you've provided, it sounds like you are having trouble understanding exactly what a pointer 'is'. Everyone who learns C does intially, and the syntax for pointers doesn't aid this IMHO. I think [this lecture](https://www.youtube.com/watch?v=Rxvv9krECNw) gives a really good overview, and might help your understanding. Next. In the code you've provided, you are treating x and y like pointers to Node structs (which is great), but you need to make sure that is what they actually are. 
SECTION | CONTENT :--|:-- Title | 21:Everything u need 2 know about pointers -Richard Buckland Description | (*but were afraid to ask) Review of pointers and indirect addressing. pass by reference/pass by value. Passing arrays into functions. 3 neat things you can do with pointers: 1. pass by ref 2. dynamic data structures (to come) 3. ADTs in c (to come) the exponential growth of doubling revisited. magic trick where you are offered a choice - VS the importance of a good spec. Starting to design a suduko solver. Mars bars from Hong Kong. Length | 0:48:29 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
What happens if you print a new line or call fflush(stdout) before execl?
First off, you're passing a copy of "result" to `findCollision`, so that part is never actually used/filled. Either use a pointer/reference or return the result. Same for `getHash()`, just change the type from an array to an pointer (no code changes needed here). And now the memory problem: char *toHash = mpz_get_str(NULL, 16, key); In the [documentation](https://gmplib.org/manual/Converting-Integers.html): &gt; If str is NULL, the result string is allocated using the current allocation function On their [Custom Allocation page](https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation): &gt; By default GMP uses malloc, realloc and free for memory allocation In the example you provided never specified an custom function, so GMP is using the default C library memory allocation functions. In the function, you never return or store the pointer anywhere (assuming `SHA512()` doesn't store it in the result, wich seems to be unlikely), so you can free the pointer at the end of the function using `free(toHash)`.
It prints!!, thanks!! :-)
That looks reasonable to me. Here are some possible optimizations. 1. If this function is being called more than once while the program is running, you might store the code so you don't need to read it again. 2. Again, if you are performing this more than once, you might keep the file open since that's a fairly expensive operation. 3. If you know that the code of the first record in the file has a particular value, you wouldn't need to read the last record. You could just use ftell() and calculate the code.
Actually the function is called once and through the terminal. I mean, in the terminal you run the app and call the function while opening to use the function (there are other functions but this one is giving me issues). We haven't been taught ftell, I know I should google it and everything will be explained, but how do you suggest me to use it?When you said I know the code of the first record has a particular value, what do you mean? I forgot to mention that I don't have the binary file. But when I finish coding it should work once I send the project to my professor. thanks again 
I think the problem is with your usage of `mpz_get_str`. It allocates a string for you, which you hang onto via `toHash` (usually it would just be ‚Äú`hash`‚Äù‚Äî‚Äú`toHash`‚Äù would be a function that converts something to a hash), but I don‚Äôt see a `free(toHash)` anywhere in that function, which means you‚Äôre leaking memory at least there. I think you also have to `mpz_clear` anything you `mpz_init` when you‚Äôre done with it, since a large number will surely have to have some dynamically allocated memory attached to it and that could leak too. I‚Äôm going off of [this code here](http://www.de-brauwer.be/wiki/wikka.php?wakka=GMP).
You are welcome. Sorry I came across badly yesterday.
Nah. it's all good bro. I thought you were boasting your english, but I was a little defensive. Next time my doubt's gonna be tougher I promise üòÇ
True, using the preprocessor may be a good option here. However I still maintain that writing `(void)0` verbatim is not a good idea.
Your English is quite good. If you hadn't said that English isn't your native language I wouldn't have guessed. It was me trying to read too much into your question.
Better would be: void person_free(struct person **p) { // Free any data associated with the struct free(*p); // invalidate pointer *p = NULL; } That way, you can test against `NULL` in other parts of the code to ensure you don't try to perform an operation on a `person` that was `free`'d.
A good book on Operating Systems could be an idea.
It's trying to jump to where in the code the exception is being raised, but the exception is being raise in a compiled bit of code that the IDE doesn't have access to the source for. You haven't told us what the exception is so I'm not sure we can work it out from the code alone.
what do you mean by exception? what exception?
The window in the middle of your screenshot says "Exception Thrown". You've configured the IDE to break when certain exception types are thrown, but in this case it's happening at a point in your code where you don't have access to the source code.
i know, i cant figure out why its sayin that, its not giving me any information on what the exception is. this is the Call Stack, maybe theres somethin there but i can figure it out.. &gt; ntdll.dll!_RtlReportCriticalFailure@12() Unknown ntdll.dll!_RtlpReportHeapFailure@4() Unknown ntdll.dll!_RtlpHeapHandleError@4() Unknown ntdll.dll!_RtlpLogHeapFailure@24() Unknown ntdll.dll!RtlpAllocateHeap() Unknown ntdll.dll!RtlpAllocateHeapInternal() Unknown ntdll.dll!RtlAllocateHeap() Unknown dwmapi.dll!CPortClient::SendComplexSyncRequestWow64(unsigned long,void const *,short,void *,short,long *) Unknown dwmapi.dll!`Microsoft::WRL::Module&lt;1,class Microsoft::WRL::Details::DefaultModule&lt;1&gt; &gt;::Create(void)'::`2'::`dynamic atexit destructor for 'moduleSingleton''(void) Unknown dwmapi.dll!_DwmFlush@0() Unknown ig8icd32.dll!58d16b4e() Unknown [Frames below may be incorrect and/or missing, no symbols loaded for ig8icd32.dll] [External Code] 
using the red dot in the debbuging i can tell that it crashes at glClear(GL_COLOR_BUFFER_BIT); 
nope still crashes :(
the stuff after prototype doesn't look like it shouldn't compile.
Program crashes with division by zero on integers, because integers can't express the result. With floats you have Infinity and NaN, which do have that capability, and have defined behavior when computation is done on them, so no reason to crash. 
Thank you, this was the answer I was looking for.
I'm more wondering if the code you've given us is the same as what you are running. But yes, comment them out.
yeah its the same code, and no commenting them out doesnt seem to work. i was thinking that it mght be an issue with the allocation of memory in the structure, what do you think?
Nobody mentioned that you can test for a floating point exception with functions in [&lt;fenv.h&gt;](http://en.cppreference.com/w/c/numeric/fenv).
Memoization is just saving a computed value and reusing it later instead of recalculating the value. Did you have any specific C related question?
Okay
Can you use signals? https://www.gnu.org/software/libc/manual/html_node/Signaling-Yourself.html#Signaling-Yourself
Ya, anything. I am not sure how though...
I guess I would have to make up my own signal type, and create a signal handler for it
The problem is with your program's logic not the program's code. Consider the following scenario: 1. Thread 2 enters the critical section 2. Threads 0 and 1 enter checkRunner, see that DONE is FALSE, wait for thread 2 to leave the critical section 3. Thread 2 writes DONE = TRUE, leaves the critical section 4. Thread 0 enters the critical section, sees that FROM equals TO, writes DONE again, prints 5. Thread 1 does the same after thread 1 leaves the critical section You need to make sure there is no possibility a thread writes DONE after another thread has read it and before it printed to the screen. You can use a barrier, for instance, though that's probably not very effective. You can also use signals as someone else suggested. Or you could just move the read inside the critical section? But then you don't have parallelism. In fact, all the parallelism that you currently have is reading DONE. Some minor suggestions for your code: Use `&lt;stdbool.h&gt;` instead of defines and use `strtol` instead of `atoi` (for error checking). 
But, then how can I make it without acquiring the locks, I think I put them in all the necessary critical spots. Getting rid of locks will give unpredicted results, wouldn't it?
Alternatively you could cache a bunch of values on program startup.
Please post job offers to /r/cjobs.
I use it for embedded work every day for 99% of what I do. Maybe 1% is assembly for time-critical sections. So yeah, it pays for my livelihood. 
Let's not kid ourselves, it is less relevant today than it was 20y ago for all the reasons you gave. But less relevant doesn't mean not relevant. First of all very many programs were written in C and are still in use (it's likely that most of what you use is written in C). So to understand and continue developing those programs we need to know C. This has more ramifications: if your operating system,on which everything you do is based, is written in C then it's not just something you can ignore. To interface efficiently with it you need to be able to at least understand what the properties of C are. For this reason most languages have an interface to C, so by writting in C (or at least proposing a C interface) you allow developpers from most languages to use your program easily. Also there are C compilers for almost every hardware. This means that you may very well find yourself writting code for a chip for which C is the only language available. That happens more often than it seems. Finally not all programs have the same requirements and there is no supreme language that solves all problems easier than every other languages. You mentionned Python: it's a very good language on many points. It's strict and consistent which makes it well suited to teach programming. It's concise and has lots of libraries which makes it well suited to developping programs quickly. But while its performances are acceptable for most purposes it can be difficult to bend the language when you need more than it normally gives you. C is hard to write correctly, and you won't generally be as productive as C as in Python when it comes to solving the problem quickly. But on the other hand with C you are in control. If your program is slow it's not C's fault, you just didn't use it well. If your program is fast it's not C's fault either, you just wrote it well. C puts the responsability on your shoulders without trying to catch you if you fall. It's not suited for all purposes, far from it, but it's a flexibility that is very powerful when wielded right.
Yes, it is relevant in most microcontroller firmware, Linux kernel drivers, and plenty of user space libraries. I mean, the most popular python implementation is cpython. That alone should answer your question. 
yes
Even in C++ codebases, it's still relevant. Our low level socket API's, for example, are pure C with the management of those systems built in C++. It's still a relevant language mostly because it forces you to be explicit compared to C++.
I learned: i is for "index" and well, in school we didn't really care for other variable names
It might change, but currently, your question is like : Is assembly still relevant ? It's a founding block not likely to go away for a very long time. I'd say at least 50 years, but I might be very wrong in one or the other way.
`strsep()` is non-standard, which is why it's not implemented by MSVC. Your first example is not a good learning example, because it has a memory leak. Using `strdup()` is completely unnecessary and pointless. `strdup()` is also not standard C; you really need to pay more attention to what functions you're using and consider sticking to standard ISO C. Your last snippet causes a segfault because `strcmp()` takes two strings. `'0/'` is not a string, it's a character. Even if you replaced `'` with `"`, it would still not be correct because `"0/"` is not ever going to compare equal to anything. You probably meant `"\0"` but that's also not right. First of all, a string literal is already null-terminated, so if you want an empty string you can write `""`; writing `"\0"` is really two null-terminators, and the second one will never be seen. But if you want to check if a pointer points to the null character, just write `if(*ptr)`, there's no need to use `strcmp()` in that case. However, that's *still* not correct because you should be checking the return value against the null pointer, not dereferencing it and checking for the null terminator. Those are two completely different things. Here is a reasonable example that checks for the end condition properly and doesn't contain any leaks (and is formatted properly): #include &lt;stdio.h&gt; #include &lt;string.h&gt; char* mystrsep(char **stringp, const char *delim) { char *start = *stringp, *p = start ? strpbrk(start, delim) : NULL; if (!p) { *stringp = NULL; } else { *p = 0; *stringp = p + 1; } return start; } int main() { char string[] = "words.separated by;spaces -- and, punctuation", *ptr = string, *found; printf("Original string: %s\n", string); while((found = mystrsep(&amp;ptr, " ,.;:-")) != NULL) { printf("got token [%s]\n", found); } return 0; } &gt; can anyone at least recommend an IDE/Editor for windows/linux where strsep() is defined? You've already got a version that is implemented in terms of standard functionality. Again, you have to be aware of portability issues, so you'd need that replacement anyway for your code to be portable, so you might as well just use it. 
With respect to having to modify your string.h: DO NOT. You‚Äôve found your first use for a library! # Making a library Make a directory someplace easy-to-get-to (e.g., C:\Users\YOURNAME\lib\strsep). Make a header of your own in that directory, strsep.h, with or without Visual Studio‚Äôs assistance. (Or include other stuff and name it strutil.h or something.) Put the *prototype* for `strsep` in there, not the entire function. #ifndef SOMEPREFIX_STRSEP_H__INCLUDED__ #define SOMEPREFIX_STRSEP_H__INCLUDED__ 1 #ifdef __cplusplus extern "C" { #endif extern char *someprefix_strsep(char **stringp, const char *delta); #ifdef __cplusplus } #endif #endif That will tell the compiler that the function exists and how to call it, and the `extern "C"` bits are so C++ code can get at the function properly too. Definitely don‚Äôt include a definition of `strsep` in the header unless you‚Äôre doing an `inline` of some sort. Once you‚Äôve done the header, make a new .c file in the same directory, say strsep.c and put the definition of `strsep` in there. Nothing else, and definitely no `main` unless you‚Äôre clever and `#ifdef TEST_STRSEP` it in there. #include "strsep.h" char *someprefix_strsep(char **stringp, const char *delta) { ... } Now, compile strsep.c to an object file. Do not try to link it into a .exe; it hath no `main` and that‚Äôll piss off the linker. I have no recollection of how to do this in Visual Studio proper, but you can probably either drop to the [‚ÄúDeveloper command prompt‚Äù](https://msdn.microsoft.com/en-us/library/f35ctcxw.aspx), or else Win+R cmd.exe and make sure the compiler‚Äôs in your PATH. `cd`/whatever into your directory, and once there run cl /O2 /c strsep.c If I‚Äôm not horribly mistaken, that should generate strsep.obj, which is an object file containing just the `someprefix_strsep` function. Now, in theory you can either leave it as is or make it into a .lib (static library) or .dll (dynamic library) via the linker [`link`](https://msdn.microsoft.com/en-us/library/t2fck18t.aspx). Static libraries are basically for merging multiple .obj files together, and will contribute code/data that the linker can drop into the final .exe file just like an .obj would. A .dll file‚Äôs contents will be left out of the .exe file, but it‚Äôll reference the .dll needing to be loaded when it runs. .dlls are better for when a lot of programs have to share the same code because only one copy (on disk or in memory) will ever be needed at a time. In contrast, .libs will waste a bit of hard disk &amp; memory space if multiple things use the same code, but there‚Äôs less overhead in using things linked directly into the .exe. Neither a .lib nor a .dll is necessary in this case‚Äîyou don‚Äôt need to share `strsep` with other people, and it‚Äôs not so much code/data that you need to worry about wasting space. If you ever expand it to bigger library with multiple .c files, make both a .lib and a .dll so you/others can choose how they want to build it in. That discussion aside, now when you need to use `strsep`, add the .obj(/.lib/.dll) to your project so it gets linked into the .exe, and make sure the directory containing strsep.h is in your include path. In any C files that need to use `strsep`, `#include "strsep.h"` (or `&lt;strsep.h&gt;` if it‚Äôs in your system include path), and ta-da, you can call the function normally. Note that the exact same thing happens with all the other stuff you use from C, like `printf` or `malloc`, except that/those library/-ies are included in your project automatically. # Compacting the test code ‚Ä¶which you really don‚Äôt want to include in other programs, in case that was something you were getting at. It‚Äôs just there for testing. When `strsep` is out of stuff to search through, it‚Äôll set `*stringp = NULL`, which means that `running` will be set to `NULL` in the test code. So the loop would need to be something like: while(running) { token = strsep(&amp;running, delimiters); printf("token: %s\n", token ? token : "[NULL]"); } Since you aren‚Äôt pasting `PRINT_TOKEN` over and over (and WTF, terrible idea for a macro), you can just expand it to an in-place `printf` and delete the `#define`. (Also: Note that `NULL` is a pointer-to-nothing, whereas the terminator used for strings is spelled NUL, which comes from the ASCII nomenclature. So when somebody talks about strings, it‚Äôs properly ‚ÄúNUL-terminated‚Äù, and for a comparable list of pointers, it‚Äôs ‚ÄúNULL-terminated.‚Äù Mixing the two up will break things.)
&gt; (it's likely that most of what you use is written in C) Every piece of software I use on a daily basis is written partially, if not entirely, in C.
C++ is not the successor of C.
C++ by no way is its successor. Next to being a horrible language it's mostly useful for things like UI/Userspace applications. Operating-systems that "are written in C++" usually only use a subset of C++ features and are mostly C. And all other languages don't compete with C. Then there's things like Rust but these are too new.
You're on /r/C_programming. Nearly everyone here will say "yes, of course" (me included). If you want to get a different perspective, consider asking elsewhere...
The languages you mentioned are high level languages. The C so far does not have a good alternative. The biggest strength of C it's that pretty much every statement (maybe except switch) you can guess what will look like in assembly, which is valuable when developing an operating systems or programming for embedded systems. Neither languages that you mentioned are good alternatives to C, if they somehow are, then maybe your project didn't need C in the first place. There is a new language called Rust that looks promising and has the potential to replace C. Its biggest strength is that it provides security through ownership and you can't make similar bugs that are plaguing C. You could say that other high level languages don't have these issues as well, the difference with Rust is that unlike other languages it is doing it at compile time. We will see if it will replace C. Also, of the other languages you mentioned (except C#) are written in C, so that shows how relevant it is. The reference Python implementation (what most people use) is in C, JVM (which java runs on) is also written in C. The SpiderMonkey engine (for JavaScript) that is used by Firefox is written with a mix of C and C++. Google made their own VM though called V8 which is C++ based (they avoid C themselves although code of their engine is/was in C)
I develop GUI applications in C, using the Gtk+ toolkit, that is written in C, mainly for the Gnome ecosystem, that is written mainly in C as well. Yes, for me it's relevant. Sometimes I found C even more portable than other higher level programming languages, and this is because C is still so widely used that libraries are kept updated on all platforms, something that doesn't happens so often with programming languages like python, ruby etc. The only language that is much better in portability is Java, but GUI toolkits sucks a lot. In everything is hardware and networking related C is still the great king. When you need speed, C is again the champion, but Rust may win if they keep doing a good job as they are doing. So, yes, I think is still relevant on a large scale as well.
The short answer is yes, it's still relevant for some problems. The longer answer is that it depends on what you want to do. There are now many better languages for *some* problems. Ex., you probably wouldn't write a web app in C because there are languages that are more suited for that problem. (One of my pet peeves is when teams pick a language because that's what they know, and not because it's the best fit.) But, there is still a set of problems where C is absolutely the best solution that we currently have (OS's, database, some embedded systems, etc) - where speed is critical, absolute control is needed, or resources are limited. Some languages are trying to compete with C in those space - C++, Rust, and probably many more that I'm unfamiliar with. I personally hope Rust can live up to the hype. But, even if it does and becomes dominant in the industry, C is not going anywhere. There are billions of lines of C code out there that will have to be maintained for a long time. It will out live all of us. 
Years ago people used to call C, somewhat jokingly, a "high level assembler" - not far from the truth though...
Thank you for your explanation 
As others have said, yes it its, just not the only relevant language. Others have mentioned embedded and systems software. Another area in which it's important is its consistent naming (poorly phrased, I'm sorry). It's complied, unlike Python, and doesn't do name mangling. So, you get compile time speed with easier interoperability. 
I just leave this here. http://harmful.cat-v.org/software/c++/linus. At least consider not using C++.
I use it because everyone else uses it in loops. It's 'the loop variable', and as such it's very easy to notice it. Im guessing that " because everyone else uses it" is the real answer for 99.9% of programmers.
Thank you, very interesting video. 
I'm working on the next generation of wireless network equipment and it is all written in C. So you could say C is still used for cutting edge things and is very much involved with building the future :)
Here is incomplete pseudocode for void rec_ssort if ( n&gt;0)//don't need to check first element { int Max=call max() //I really wish I had the index of Max here so I can call swap (arr, index of Max, index of last element) rec_ssort(arr, n-=1)//recursive call }
A mainstay of ruby infrastructure, rvm, is written entirely in tens of thousands of lines of bash. (For one example)
&gt; templates Using `#define` macros, particularly with GNU C extensions, makes doing basic templating bearable. I would agree that C would be aided by a basic templating system though. `_Generic` was added in C11 but it's kind dumb and not really that good. &gt; or destructors GNU C supports some of the roles destructors fill through the `cleanup` attribute. It can be used to create scoped files/locks/memory/etc. that have the proper function called on them to free them once you exit the scope they are declared in (Regardless of how you exit the scope). I personally like to wrap this functionality in a macro (in a similar vein to [C# Using statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement)), but lots of projects just use it on it's own. It has some quirks, but it's still effective for what it does and easily the best way to achieve this type of functionality. Also, from one of your comments down below: &gt; Why must I implement a min/max function per type? With GNU C you can implement a generic version that works for all directly comparable types (IE. the primitives): #define max(a,b) \ ({ __typeof__ (a) _a = (a); \ __typeof__ (b) _b = (b); \ _a &gt; _b ? _a : _b; }) If you have some `struct`s or strings or whatever obviously this probably won't achieve what you want, but in those instances I'd rather see a direction function call anyway. There's normally not one way to compare two objects, so I'd rather just call a function that makes it clear what is being compared. With that said, you could modify that definition of `max` to accept a comparator function rather easily.
i think it means iteration.
With a modern compiler there likely won't be any speed differences, in fact it will probably generate the same machine code.
Gtk is an example of how C is becoming less relevant 
Can you expand on this?
Tell us how you really feel
Are there any good implementations of one that are popular? One where u can use char ** as keys or char[] ideally
C is a subset of CPP but learning c before learning CPP is not a prerequisite. Some argue (and I agree) that it is a very bad practices
Oh boy. You're really out of touch aren't you? Have you ever even programmed an embedded system? Also, a lot of us know a hell of a lot more than just C. I'm not going to build a web application with C, just as much as I'm not going to program a tiny MCU using JavaScript. Right tool for the right job. For the record, new != better. 
I agree with your point, and I'm a C programming myself, but that graph doesn't look healthy with respect to your statement. Or am I misunderstanding the data?
And what makes you think C++ is not the right tool for embedded programming?
I think C is the most relevant of all languages, still. Yes, it is quite old. Yes, it demands more in-depth knowledge of the programmer. But, it is one of the fastest and robust languages out there. I program in C almost every day and I think most back-end programmers do. So yeah, imho C is pretty damn relevant :)
I didn't do any DSP on the microcontroller because the sound chip generates everything, it just has to do a couple of register writes on every IRQ the chip generates. That might be considered ASIC (even though it's an ancient N-MOS chip consuming 1W). Simulating sound chips and doing bandlimited resampling is not at all heavy on modern computers but I optimized using SSE intrinsics and NEON assembly so that part is not pure C. I have no idea whether it is possible with Javascript... But I just wanted to say that the code controlling the chip/simulation is the same.
Fair enough, I stand corrected.
Yeah "developers like you" that insist on C just because they are used to it. Desperately looking for reasons why C++ "is a mess" and why "real embedded developer" should use C.
You're welcome! :) Hope you do well next time...
While not directly programming oriented, you might still find operating system or low-level developer conferences appealing. There's occasionally some great, albiet high level, presentations at various yearly *BSD cons. AsiaBSDCon/BSDCan just happened, but EuroBSDCon and vBSDCon (Verisign) are upcoming. https://2017.eurobsdcon.org/ http://vbsdcon.com/
Also, those functions you mentioned (`glfwInit`, `glfwTerminate`) are probably making OpenGL calls or other operating system calls, which would mean the state is mostly maintained by the OS / OpenGL driver.
I write device drivers for a living. Linux, MacOS, iOS, Windows. Plus the daemons that talk to them and the utilities that talk to the daemons. Also the window system drivers. And embedded systems. Every line of code is written in C or C++. When I *do* work in other languages, it's usually either Python or Java. Guess what you find when you open the hood on those languages? C or C++. C isn't just relevant, it's the *most* relevant language in the industry.
It's certainly *a* successor of C.
This is exactly what I came here to say. AFAIK, this is 100% correct.
Hungarian notation has its place, but it's almost always misused.
I want to add `SIGWINCH` to POSIX so you can find out if your terminal changed its size. Additionally, two functions `tcgetsize()` and `tcsetsize()` are added to `termios.h` so you can query and set the terminal window size. You can find the corresponding bug report [here](http://austingroupbugs.net/view.php?id=1151).
I'd definitely appreciate it if someone let me know about any good low-level development conferences like the BSDCon ones posted here.
&gt;C is a subset of CPP Categorically ***FALSE***. If C were a subset, then C code would compile on a CPP compiler, which it will *not*. CPP makes several changes to the C language which are *not* backwards compatible.
Don't forget about all the books! You have books to teach you the language, then more books to teach you which parts to avoid. And the new 3-year release cycle means even more books!
It's not a strict subset, but it's pretty close.
As C progressed past K&amp;R, then ANSI &amp; ISO, then C99 and C11 ... there really isn't *that* much to talk about WRT the *language* of C. Changes and learning curves are pretty minimal. C just is what it (and was). I would expect, maybe, to have C-track or C-content sessions at, say, an embedded systems conference or an OS (specifically, RTOS) conference. The topics may not *be* C, but they'll be *in* C. So maybe look into the Linux or BSD kernel teams and their scene. If there are meet ups (and they're generally looking to bring more programmers/maintainers into the fold) ... that might be interesting for you. That would be a large concentration of C programmers in one place.
I agree, I'm not a guru but feel that I'm stuck, precisely I mostly work on embedded systems and feels like most of the examples are stuck on C99 or even before. I don't know any C meet ups in my city, I'm based on Mexico, there's even a Rust meet up here but nothing in C. Will check the BSD and linux conferences, feels like is time to start learning modern C++ for embedded.
I want to put a linear search somewhere in the rec_ssort function but that seems impossible. 
The fact that OP has a decent idea of how many keys they will store makes a hash table really attractive.
Thanks, for the answer. Things are changing a lot in the GTK ecosystem and the fact that Canonical is dropping unity for Gnome shell, it's more than positive. In the past is true that the Gtk project wasn't friendly, but today is not the case anymore. While before I wanted to move to another toolkit, now I'm more and more convinced that I'm doing it right. 
You can also use a block inside of a case, much more readable and less error prone... switch(a) { case 0: { int x = 1; break; } case 1: { ...
Note that this requires C99 to work as ANSI C does not allow you to mix declarations and statements. The reason why this is necessary is that there is a ‚Äúlabelled statement‚Äù grammar rule but no ‚Äúlabelled declaration‚Äù grammar rule in C. You can also declare variables in switch statements like this: switch (a) { int foo; case 0: ...; } since what follows `switch (a)` is just an ordinary block. You could also do something like this: switch (a) case 0: do_something(); but that's just weird.
Oh haha. Good luck. "C is hard" is actually a misconception. It's a relatively small language (compare it to C++/D/C#/Java/Rust/Haskell) to master. The difficulty comes only if you think you are restricted with C (which is not true).
This isn't quite the same because you've changed the scope of `i`. To keep variable scope as small as practical, I often do this.
That's because `printf` is linked to a different, mostly unpredictable address in each program.
If you think that's odd, you should look up Duff's Device for some real switch abuse.
&gt; C is not for maths This has nothing to do with what I said. I picked min/max as a random example. There are many many simple examples where templates avoid a mountain of work/duplication. &gt; For what C is used, generics are just not so much‚Äã necessary This is just... factually untrue. C programmers just willfully live without them because tradition. &gt; So yeah, stop asking the same question twice, I already answered it. You really didn't.
Enable all warnings and fix them.
I agree. Also, I wonder what convoluted logic it takes to get an output value.
https://repl.it/Is6G/5 #include &lt;stdio.h&gt; int g(void) { printf("Inside function g\n"); } int h(void) { printf("Inside function h\n"); } int main(void) { h(); g(); } 
You should not declare variables in switch statements without using braces around the case body. This is because failure to limit the variable scope to a single case body allows the switch statement to skip initialization of the variable. In C++ skipping initializers becomes a compiler error so you have no choice but to use braces.
Switches are often quicker. 
And never use it because the obvious code is quicker on modern compilers. 
If you linked against a shared libc, then all modern operating systems use some form of address space layout randomization, so you can't assume that a shared library will always load at the same location. If you linked against a static libc then any minor change in the contents of `main()` (or in general the phase of the moon) could cause the linker to lay out memory differently and put `printf()` at a different address. In summary, you can't count on the address of something being fixed across different programs or across different runs of the same program. 
It totally depends on the compiler. I think nowadays they are smart enough to generate jump tables on large if-else if sequences.
Test Code: #include &lt;iostream&gt; int main() { int arr[10] = { 1, 2, 3, 4, 5, 6, 4, 4, 3, 2 }; // Pointer style for (int i = 0; i &lt; 10; ++i) { printf("%i ", *(arr + i)); } for (int i = 0; i &lt; 10; ++i) { printf("%i ", arr[i]); } return 0; } Pointer style assembly: mov eax, DWORD PTR [rbp-4] cdqe lea rdx, [0+rax*4] lea rax, [rbp-48] add rax, rdx mov eax, DWORD PTR [rax] mov esi, eax mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf Array style: mov eax, DWORD PTR [rbp-8] cdqe mov eax, DWORD PTR [rbp-48+rax*4] mov esi, eax mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf As you can see, the pointer style calling convention was slightly faster, barely though. However as predicted, once the same code was compiled with optimizations on (-O3), the assembly output was identical. Pointer style again: mov esi, DWORD PTR [rbx] xor eax, eax mov edi, OFFSET FLAT:.LC2 add rbx, 4 call printf Array style again: mov esi, DWORD PTR [rbp+0] xor eax, eax mov edi, OFFSET FLAT:.LC2 add rbp, 4 call printf 
What part of Mexico are you in? I just got back from there
I do this by default with switch statements. I find it more syntactically consistent.
You can write many simple things that are better with generics but are usually simply not in the scope of C, like maths. I have not seen much use for templates in Operating Systems development. Never had the urge for generics. I answered it in the way that I said I'm against all those features since they are not appropriate in this language. You "answered" by restating that you miss these features. I can just reiterate that these features are not needed in what C is for. If you think otherwise, you have to back it up -- you took maths as an example, which was bad because that's not what C is for.
Pkease show us your code.
&gt; Premature optimization is the root of all evil I used to think this until I had to maintain software designed by people who actually think this. That's when I learned the true meaning of "death by a thousand cuts". Sure, you shouldn't break your back putting in a ton of unreadable optimized code everywhere, but if you're not considering the time impact of what you're writing you can very easily end up with a program that runs uniformly slow everywhere by its very design (meaning you don't just have a small handful of hotspots to fix).
Templates is the wrong word, I meant generics.
Haven't tested but my guess is that "0xb" is being treated as a constant and not as a macro argument. You don't need to prepend "0x" to your number. Bitwise arithmetic is the same for binary, decimal, hexadecimal, whatever. A number is a number. 
Wait ... you can still get apps written for GTK+ to build? Ubuntu dropped support for that library a decade ago, I thought. I certainly haven't been able to compile or release packages for it in a long time.
Yes, I aint even gonna explain this.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Re-post from r\/C\_Programming](https://np.reddit.com/r/coding/comments/6ijtmw/repost_from_rc_programming/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Of course! Gtk+ is widely used and Ubuntu didn't drop Gtk and neither Gnome, that is written in Gtk. They have just wrote their DE, but now they're going back to Gnome and therefore to Gtk
Firstly, here's a way to accomplish exactly what you're going for (regardless of whether that's a good idea or not): /* ... */ #define BIT_ON(val, bit) (val) |= (bit) #define CMDSIG_BIT_ON(bit) BIT_ON(CMDSIG, bit) #define QUIT_FLAG 1 /* ... */ With that said, I'm gonna hop onto my soap box and give you an unasked-for code review. Many of my points are subjective, and I'm mostly trying to give you some good for thought. In approximate order of decreasing severity: # Losing Events / unnecessary global I see two possibilities for how your system is structured overall: - You're calling `mp_input()` and `mp_update()` in a main loop. In this case, I'd recommend ditching `CMDSIG` as a global variable, and just passing it to `mp_update()` explicitly. - Your functions are being run in different threads, are callbacks, or in general are doing asynchronous things. If that's true, all sorts of concurrency issues rear their heads, most obviously (to me) being that you've got the potential to lose characters if more than one `mp_input()` happens between two `mp_update()`s # Macro obfuscation I see, in general, how you're trying to avoid repetition and write cleaner code, but to some extent you're accomplishing the opposite goal with generating this stack of macros. `#define`ing your special values like `QUIT_KEY` and `QUIT_FLAG` is great. However, hiding an operation on a global variable behind an opaque macro (your original desired syntax being `BIT_ON(QUIT_FLAG)`) is asking for confusion down the line. For that matter, constructs like `value |= bit;` are very idiomatic C, and in my opinion read better than an unknown `BIT_ON()` macro. # Unnecessary ORing Since you clear `CMDSIG` each time you read a character, your code could be simplified and clarified to be something like: unsigned int mp_input(void) { switch (getch()) { case QUIT_KEY: CMDSIG = QUIT_FLAG; break; /* ... */ default: CMDSIG = 0; break; } return CMDSIG; } or, if you can get rid of setting a global CMDSIG: unsigned int mp_input(void) { switch (getch()) { case QUIT_KEY: return QUIT_FLAG; /* ... */ default: return 0; } } # Flag Definition My personal preference is to declare single-bit flags with constant but shifts. So instead of #define QUIT_FLAG 1 #define FIND_FLAG 2 /* ... */ #define KEY_RIGHT_FLAG 65536 I would generally do something like #define QUIT_FLAG (1 &lt;&lt; 0) #define FIND_FLAG (1 &lt;&lt; 1) /* ... */ #define KEY_RIGHT_FLAG (1 &lt;&lt; 16)
Yep, they are great in Rust.
man, thx! i am actually new on this and you gave me some ideas, one more thing, about the last piece of advice, why to use shifts instead of the constant? wouldnt it be the same?
[Here](https://github.com/kloetzl/biotwiddle/commit/e210f4a5153655663a5b4f98904a6134b1fb2b56) is a case where a switch statement is up to 50 times slower than the semantically identical if-else. Just clone and run make. Then `./bench_revcomp.g` gave me the following numbers. Benchmark Time(ns) CPU(ns) Iterations ------------------------------------------------------- revcomp_twocase 121693 122064 5833 revcomp_twocase_switch 5117049 5125926 135 With clang the two times are nearly identical.
the error happened when i defined `QUIT_flag CMDSIG, 1` and passed it as an argument to `CHECK_BIT(a,b) if(a &amp; b)`
&gt; Java, but GUI toolkits sucks a lot I know people had emotional distractions from AWT and Swing, but JavaFX is awesome!
Okay, that won't work as `QUIT_FLAG` is expanded after `CHECK_BIT` is, thus `CHECK_BIT` only sees a single argument. One way to make this work is to define an auxillary macro to change the evaluation order: #define apply(f, x) f(x) Then you can write apply(CHECK_BIT, QUIT_flag) and that should work. However, I recommend you to avoid such tricks. It took me quite a while to even suspect what you are trying to do with #define QUIT_flag CMDSIG, 1 as that's very unintuitive C code.
I use JavaFX mainly to display slices of 3D medical images, so I didn't have the need to use clipboard in my application yet. However, there is a [Clipboard](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/Clipboard.html) object designed for that and I see no reason why it shouldn't work on Linux. I use Linux Mint and I had no issues with JavaFX so far and I enjoy using it. It seems too few people know about JavaFX. Everytime I see debate about desktop GUI options here on reddit, only GTK, Qt and maybe wxWidgets get mentioned.
Well, there are for sure misconceptions, but if I'd have to run a JVM for each application I use in my day to day workflow, I'd need a huge amount of RAM. My application run with only 1.5MB of RAM, doing the same in Java I'd need at least a JVM of 64MB, but I'm not sure, probably much more for all the library I'd need to import. In C, thanks to the compiler optimization we can keep the memory footprint really low. I use Java for enterprise level applications and I'd not change it with anything else as I can change the OS guest as many time as I want without bothering to build again the application. Regarding GUI applications I'd like to give it a try, but I'm afraid most of my users won't appreciate the move and will keep using the C/Gtk one. Than, as I said we miss a full Java Desktop Environment that works and that is light. There was one developed by Sun, but it wasn't exactly what I mean. A Java Desktop Environment should work more like a J2EE container, where you've one (or more for high availability) JVM that run all of your applications, deployed like we do in middleware environments. Other implementations would fails for the above reason (one JVM for each application) and the lack of a full integration with a desktop environment, that is not done only implementing DBus (https://dbus.freedesktop.org/doc/dbus-java/)
It's the same value but declaring it this way means there's a lot less chance of making a mistake. It's easy to add another flag later and it also makes the intent much clearer to anyone reading the code, in that the values are to be used specifically as bitmasks rather than for their general numerical value.
Sounds like you're using a BSD-style `ps` command, which lists only processes in your current tty by default. Try `ps a`
I use `ps aux` in solaris and `ps -ef` in Linux and Windows. Because I always did it that way, I don't even know what the options mean!
I would agree, in general. However, the people here are the ones who know WHERE it's used. Ask somewhere else, and they may say, "I don't know anyone who uses C", not realizing that all the tools they use are written in C.
Isnt the Oracle JVM c++? E: according to some stack overflow I found it is. Which is probably the most popular jvm by a mile. Plus the Java compilers is java
I would add one more thing: avoid putting statements like 'if' inside a macro. if (CHECK_BIT(CMDSIG, 1)) return;//QUIT is much more clear.
That really worked. ...And there are two sets of linux commands? What other are there? Is this BSD -style another system?
Handy! 
On Linux there's only one `ps` command you're going to find (part of the procps package, which follows BSD conventions a lot). Other Unix operating systems (especially older ones) use different conventions with some utilities.
sorry .. yes. tons of cpp. I may be thinking of the early versions way back when Java was pure. http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/d4f4a9915357
The first rule you might want to learn: you haven't found a bug in the compiler. 
Well, rule of thumb, and I agree overall.
Sure. https://pastebin.com/YVRj4wTH Just changing the order or size and len gives a different behavior. It's odd...
 if(the_vec-&gt;len = the_vec-&gt;size) I think you need a "==" there. 
So when you change the order of the fields, which specific source lines do you alter? 
You don't seem to be updating the_vec-&gt;size when you reallocate the array. 
Welcome to the stultifying world of C programming!
You can't safely allocate your `struct vec` on the stack and return it from `new_vec()`. It might happen to work because the compiler will probably inline `new_vec()` in `main()`.
Isn't it just returning by value, and I still have my arr on the heap?
You could use designated initializers to avoid this problem. 
What is compute\_transpose\_matrix supposed to return? How are the arguments of matrix\_multiply used? Edit: also plate3 should be MAXN by MAXN.
whoops I don't know why I put the transpose function instead of the matrix multiply function, so I edited my post with the correct function. the transpose function is supposed to return p which is the second column. The arguments for the matrix multiply are used to print out what c[I][j]? Sorry I'm new to programming in general.
But I assume that there were no difficulties optimizing it then, apart from being slightly tedious and repetitive. That's a better outcome than being too overly concerned with micro-optimizations and writing bad code as a result. Your case does illustrate the point that a balance needs to be struck, though.
the for loops should repeat n times per m, so 10x10? but they repeat 1300 times? I'm very confused
To add to what the others have written, libraries like `libc` are compiled as 'Position Independent Code', which is just a fancy way of saying that the code is compiled to only use relative offsets rather then absolute addresses. This means that the compiled code can be loaded anywhere in memory and it will still run correctly (Unlikely code linked to a specific address, which wouldn't run correctly if loaded anywhere else in memory). Because of this detail, the kernel/loader will happily place that code at any random location in memory, and it won't matter because none of the `libc` code is dependent on being loaded at a specific memory location. This has the consequence that you can't rely on it being at the same place through successive runs. That said, your actual program code is likely linked to a specific address. So while you can't call `printf` that way (Unless you statically link `libc`), you could reuse the location of a static/global variable or function across multiple runs. Obviously you would never want do this in practice, but messing with stuff like this is a nice learning experience.
That might not be the only bug, but it should definitely be `&lt;`. With that said, I assume that `print_matrix` is display the correct information? Also, something I noticed. Shouldn't the second `for` loop in your multiply go until `p` and not `m`? I didn't notice that in the comparison to my algorithm, but my algorithm only does square matrices (Where `m == p`, so it doesn't matter). And with that, the output should be a `m` by `p` matrix, not a `n` by `n` matrix.
Why?
The `%p` specifier only works with `void *` argument. Function pointers have a different type. You often see code using `%p` with other object pointer types, this is also undefined behaviour, but on common systems it usually behaves the same as if the pointer had been cast to `void *`. But even on common systems, the function pointer sometimes doesn't share that property.
The matrix cells are integers. Perhaps overflow?
Cool, I didn't know that. Thanks.
I think you misunderstand what global structure means. Here, you've defined structure called movie_show, it however is not global, since there isn't any declaration for instance of this structure in global scope. You later define instance of this structure in function RatingMovie, but as it is, it's only going to exist within this function. You also attempt to create structure array with variable size on stack, which isn't possible. You can either define static size for this array and then check/hope that program won't require more, or you have to dynamically alocate memory needed for this structure array. Also for some reason I believe you cann your RatingMovie() function twice, once from within the NumMovie() and once from main. You also ask for movie name twice? Edit: Maybe I'm missing something, I expected the code to not even compile since since of array isn't given at compile-time. Edit 2: Okay, guess it's just online compiler being funky or having some extra features for array allocation. Problem happens in VS2017.
RatingMovie() takes an argument. You call it once without giving it one. You're lucky all it does is crash. Turn on your compiler warnings. Pay attention to them.
What runtime error do you get? I think you forgot to remove the fgets call before the scanf, and the RatingMovie call in the main(). You should enable the compiler warnings, and read the warnings. I recommend you to do function prototype declarations, or move the function definitions before calling them. Further suggestions: When writing function prototypes, `void foo()` is different from `void foo(void)`, and the former is an ancient style declaration that takes an unspecified number of parameters. scanf for strings should be used with field width to prevent buffer overflow, for example `"%49s"`. And I think using VLA with the size specified by user input can be dangerous because there's no way to handle if it overflows the stack.
That is a surprise to me, I'm fairly certain that's not the case in C++? I know some compilers provide it as an extension, although it's not portable. EDIT: [From Wiki on VLA:](https://en.wikipedia.org/wiki/Variable-length_array) &gt; Programming languages that support VLAs include ... C99 (although subsequently relegated in C11 to a conditional feature which implementations are not required to support...).
VLAs are not part of C++, no. Use std::vector in it. This is a sub for C, though, and C++ is generally off topic.
I was actually incorrect in my answer if you read the reaction from u/raevnos, your method of creating array is valid, although I'd still call it unsafe for cases where the created array is huge and you don't limit user in how many items it's going to contain. :) 
Slightly unrelated: Definitely use `size_t size, len`!
Okay, so first off the bit `node* remove_front(node* head) {` defines a function, of type `node*` named `remove_front` that is passed a parameter of type `node*` named `head`. The star after node means that both the returned and the passed parameter are addresses (or pointers) to a struct called node. This struct contains at least one value, a pointer to a `node` called `next`. This'll come up later. `if(head == NULL) return NULL;` means that if the pointer we were passed, which represents the head of a linked list, is empty, so there's nothing to remove. Return nothing. `node *front=head;` defines a new pointer of type `node*` and sets it equal to the value of `head`. `head=head-&gt;next` sets the value of `head` to the next item in the list. If there was only one item in the list then `head` will now be equal to `NULL`. `if(front==head) head = NULL;` this is a check to see if the value of `front` and `head` are still the same. If they are, then `head` is an empty list, so set to `NULL`. `free(front);` destroys the memory stored at the address of `front`, which was previously the first struct in the list pointed to by `head`. `return head;` returns the new value of head to the function that called this function. Hope that helps! Just let me know if I can clarify anything.
For your own sanity, you need to read up on block comments. http://syque.com/cstyle/ch4.6.htm
W.r.t. your last question, `a-&gt;b` is syntactic sugar for `(*a).b`, so no.
And is that because linked lists are essentially struct's that use memory location (hence the pointer to memory locations)?
I agree, and certainly relevant.
This works here with gcc and segfaults with tcc: #include &lt;stdio.h&gt; void main(void) { int (*func)(const char *, ...) = 0x400400; (*func)("hello world %p\n", &amp;printf); } No idea why, I'm still investigating.
So where and how do we usually see next (or whatever you decide it to be) defined? Is it defined with `struct node *(whatever you want, in this case next);` within `struct node {}`, as in the third code block down [here?](http://www.cprogramming.com/tutorial/c/lesson15.html)
Yes exactly. Wherever in your code you define struct node{} you must put struct node *next; inside if you want the struct to be a linked list. 
That's cool! Though, I tried to adapt the code for fuzzing the verification tool [Frama C](http://frama-c.com/) and the code base turned out to be very difficult to modify. Shows how C++ is not inherently better for making maintainable software than C :-P
Read the sidebar and search the archives. This gets asked at least once a month.
My goal here is to fill in the array C[1‚Ä¶15] where C[i] is the minimal number of operations needed to get i on the primitive calculator using C/3, C/2, C-1 on doing that i got this table below eg to get 10 i did this 10/2 = 5, 5 - 1 = 4, 4/2=2, 2/2 = 1 so 10 prints out 4 because it takes 4 operations. [1, 1, 1, 2, 3, 2, 3, 3, 2, 4, 4, 3, 4, 5, 4] My code is not doing that.Thank you.
Some things I spotted in the ceasar cipher implementation: You don't need the second inner `for` loop in the `decrypt` function. You can actually work out the index of a letter into the alphabet by doing: int index = ch - 'a'; // Assumes lowercase So to shift `str[i]` by `shift` characters you can just do: str[i] = alphabet[(str[i] - 'a' + shift) % 26); Which is much more efficient and clean than using a linear search. You can also do a similar thing in the `encrypt` function too, I'll leave that for you to work out :) You also don't need any of the `strdup` calls in your brute force function. If you want to keep the original text then you can just use one `strdup` call, something like this: void brute_force(char *input) { char *s = strdup(input); int i; for (i = 1; i &lt; 26; i++) { decrypt(s, 1); // Shifts it by one every time printf("%s\n", s); } free(s); } You should also remember to free the memory after calling `strdup`. Finally, with the ceasar cipher you can actually get away with reading one character at a time from the file. This is much more memory efficient and I think it makes more sense. You can use `fgetc` to read a character (from the input file) and `fputc` to write a character to a file. You might need to collect the characters again for decrypt if you want to run some analysis on each generated text, but for encrypt it should be sufficient to just use something like this: void encrypt_from_file(char *in_path, char *out_path, int shift) { FILE *in = fopen(in_path, "r"); FILE *out = fopen(out_path, "a"); char c; while ((c = fgetc(in)) != EOF) { c = tolower(c); char encrypted = "abcdefghijklmnopqrstuvwxyz"[(c - 'a' + shift) % 26]; fputc(encrypted, out); } fclose(in); fclose(out); } Generally I would advise against using the system calls directly, since that makes your code less portable. The `f` family of functions (`fopen`, `fwrite` etc) are much more portable and they offer the same functionality. I didn't test any of this, so it might not work.
Thank you for the detailed response :) I will for sure improve the code upon this directives. edit: Updated the repo, the BruteForce function doesn't work without the strdup inside the for loop, because it seems like 'text' is treated like it was passed by reference, which is strange because i'm passing it by value.
If you've never programmed before, I recommend starting with Python instead of C. My rationale is: 1) Python handles a lot of the more complicated things for you while you learn the basics, so if you're brand new you have less to wrap your head around. 2) Developing Python requires much less knowledge of systems. IMHO the best way to learn C and similar low level languages is to use text editors and command line tools for compilation and debugging. There's nothing wrong with using an IDE, but I found it getting in the way of my education more than anything. Python on the other hand can be easily installed on Windows/Mac/Linux and you can even use [IPython](http://ipython.org/) for similarity across platforms. Once you're more comfortable with programmatic thinking you can move onto learning how to use the command line, and ultimately how to program in C. 3) Python requires much less buildup in order to get something interesting going. That's not to say you can't do cool stuff in C, but the amount of code required is much higher. If your goal is to do full-stack web-dev you'll almost never be using C. My concern is that the amount of work required to get tangible results from a C project would be discouraging. I'm not saying that you should never learn C. It's an unbelievably enriching experience and will make you a better programmer all around in my opinion, but with as many modern alternative starter languages as there are today it's much more rare for it to be a starter language. With all that out of the way, I notice that you haven't listed [Sublime Text](https://www.sublimetext.com/) as an option that you tried. Technically speaking Sublime is a text editor, but it has a sizable following, is cross platform, and is completely capable of being an IDE with some customization. It may be worth checking out, though in fairness I've never used it beyond the base configuration. Another option is [NetBeans](https://netbeans.org/) which is also cross platform, and is a full blown IDE. I don't like it, but I know several people who made it their main IDE after taking a Software Development class at my college. I hope this helps, and if you have any other questions I hope you continue to ask!
In general your `while` loop will need to wrap all of your I/O and validation since I imagine you'll need to repeat this process until a certain input is received. Based on what I can tell this will require it to start just after your variable declarations, and end just before your `return` statement. Without knowing more of your specs it's hard for me to say what you need to do explicitly. My suggestion is to try putting the loop in there somewhere and play around with it until you have something that looks close to what you want. If you get stuck come back with more specific questions and newly formatted code and we'll do our best. Hope this helped!
Aside from compiler warnings, it‚Äôs also to tell the reader (or the programmer, in a second read) ‚ÄúYes, I know that these return something but I don‚Äôt care.‚Äù Note also that `(void)x` does nothing to compiler warnings about unused values on GNU compilers. Things like `write` are marked with `__attribute__((__warn_unused__))`, which tells the compiler that the return value must be done with. If you want to discard it, you can do something like if(1) { register const ssize_t k = write(...); (void)k; } to cancel the compiler warning. Qua macro: #ifdef __GNUC__ # define DISCARD(x)(__extension__({\ register __const__ __typeof__(x) DISCARD__0 = (x); \ (void)DISCARD__0;\ })) #else # define DISCARD(x)((void)(x)) #endif
Ty, I can use textEditor like Sublime, Atom, Brackets or VisualStudioCode/ - they all the same in a way... but VSCode should be best right now. The issue is - how can I run my program there? What compiler should I install and all of that. With IDE I just click RUN button and it works :) Both me and my friend finished in past some web-based programming course like codecademy and other on Python and Javascript, html, css. Though it was more then a year ago ... + we read some books for sure. So, we know what is var, int, float, function, oop and all that... but sure, we forgot syntax, .. You don't recommend C as a start, and I eggy with you, But CS50 is one of the coolest courses out there and its made for absolute beginners.. yes, beginners from Harvard and Yell but I'm sure I can handle it. )) 
Don't use an IDE! Use a text editor and a compiler (like Visual Studio Code + gcc)
WEll, How about CS50 course? it's highly recommended all over the place. It's 12 weak (200 hour) course, And they learn C form 1 - 8 week, then cower Python and JS. Thats a reason why I going for C now. I know - I won't use C in y life, I get it. But what a heck. And I know Python and JS a little. I'll try vim+gcc. 
Yes, Like I said, we installed CodeBlocks on Windows, its works like it should. On mac it has issues and last Mac version made somewhat in 2013.
Not related to the code but you don't need to chmod the files produced by make, they should already have the executable bit set.
Visual Studio is generally considered to be an IDE.
Visual Studio Code is a text editor. Visual Studio Community/Professional is the IDE that you're thinking of, but they're not the same.
TY for encouragement, no worries I have huge CAN-DO attitude. The only sad thing is that I'm not going to work in this field for more then 1 - 1,5 years. My plan is to show people that average person can become average programmer in todays world. It's not that hard like it was 12-15 years ago, when I was setting with huge PHP5 book and could not configure Apache server for weeks... because book had so many mistakes and so on and on. Today it's way simpler. But people often don't believe they can! 
yes, problem is thats a course for Harvard and they have their own ide in a cloud for students only )) or u have to register with a credit card for it.. Im not sure. 
I agree. Keeping includes limited to the scope that explicitly needs it makes intent clear, and more modular - a refactor has fewer impacts, for one thing. 
thank you for your response by the way. Your while loop works, but if the user enters 0 I need to not only get the program to ask the user to enter another number but I also need an error message to be displayed. *edit* Sorry your code worked for everything! thanks so much! 
Don't compare floating point numbers for equality. 0.2 cannot be represented exactly as a floating point number and 0.2 + 0.2 + 0.2 + 0.2 + 0.2 isn't exactly 1 but rather something very close to one.
Why? Edit: The output for i = 1 Is I=1 like intended, the only problem is with 2. Why isn't 0.2 * 10 exactly two?
Because when you print i is 2, it isn't, it is `1.999999999999999777955`. And when you cast that to an int, it becomes 1. &lt;https://0.30000000000000004.com/&gt;
&gt; Why isn't 0.2 * 10 exactly two? Because there is no floating point number that is exactly 0.2, thus, multiplying that number by 10 doesn't exactly yield 2.
Thanks a lot man, really appreciate it.
do while loops are useful for input validation: do { int valid; printf("Enter the number of miles: "); scanf("%i", &amp;miles); if(miles &lt;=0) { /* error */ valid = 0; } else { valid = 1; } } while( valid ! = 1);
You can make a small helper function e.g: int float_equal(double a, double b) { const double EPSILON = 0.001; if (a - b &lt; EPSILON) return 1; else return 0; } Which means you can instead do: if (float_equal(i * 2, (int)i * 2)) { /* they're equal */ }
I use the IDE that was recommended by the David Malan (the CS50 Professor) [Cloud9](https://cs50.io/dashboard.html) it doesn't matter if you're a student right now or not. 
In C and a bunch of other languages, the Boolean `true` and integer 1 are synonymous, likewise for `false` and 0. Thus if the function returns 1, you can assume (in this case) you can assume it's just returning true. The reason the language is built like this is because true Boolean values arrived to the party a little late. Thus, to use a bool explicitly, you'd need to include `stdbool.h`. A quick google of the subject will tell you more.
[I agree with you completely.](https://ih1.redbubble.net/image.108756255.6023/raf,750x1000,075,t,322e3f:696a94a5d4.u5.jpg) Honestly, even if you don't stick with it it's a huge boon on your resume. Even if you're applying for a job that doesn't require any of the skills of a full-stack engineer, the utility you present will lead to you outshining other candidates.
Thanks, good to know!
Thank you too =)
Thanks for the explanation guys, I've learned that 1 = true and 0 = false but I'm still struggling to understand its use in 'custom' functions. I'm on my first CS semester and we still haven't been properly introduced to separate functions (we do pretty much everything on int main, still learning to handle data types well, if, switch, for, etc.) but have stumbled upon it on my studies. I think I'm starting to assimilate the concept. Thanks. 
What amount of maths is necessary for creating games? 
You don't need to flag the standard library (libc) because the compiler automatically does it for you, because without it, your program can't do anything (unless you want to call the kernel yourself).
Just because it would be inconvenient to force you to link in libc all the time, I think. gcc has an option called `-nodefaultlibs` in case you don't want libc in there, but I think it makes sense to have it linked in by default. Also, the functions in stdio are not in the stdio library (there is no such library). Most of the standard functions are a part of a library called libc. Many platforms will put math-related functions (e.g., sin) in a different library called libm.
Look at this section: for(x=h;x!=NULL;x=x-&gt;next){ x = h-&gt;next; printf("executing the free...\n"); free(h); } You `free(h)` but you never change `h`. So the second time through this loop you try to free the same pointer again and that's where it gives you the error. There may be more problems but this is the first one I stumbled across.
You'll learn about functions soon enough. They are by far the most fundamental building blocks upon which all programming language abstractions are built from. I presume you have a textbook for your class, they will definitely have a section on functions in C and why they're useful.
Well, okay. Let's see where that h comes from. It's the `head` pointer in the `list` structure, and it is set to the return value of the newNode function. So then we look at newNode to see what it returns. Ultimately what it returns is the value of `x` which is set in this line: linker x = malloc(sizeof(linker)); Now let's see what this line does. It allocates memory and sets `x` to point to that allocated memory. How much memory does it allocate? Well, whatever `sizeof(linker)` amounts to. What is `linker`? It's a pointer to a `struct node`. So that malloc allocates enough memory to store a pointer to a struct node. Is that what you meant? I suspect not. I suspect you want to store a struct node, not a *pointer* to a struct node. So how much memory should you request instead? (Reading this back I realize this might come across as snarky. That's not how I meant it. I'm just trying to illustrate my thought process as I investigate a problem like this).
Ok I get your point, I tried running the code allocating sizeof 'struct node' instead of the pointer and I still get the same error. linker x = malloc(sizeof(struct node)); I've been stuck for quite some time on this problem because I don't understand how to traceback the memory error. Also, I appreciate your help :)
No problem. Are you sure you get the *same* error? Because I don't :-) If you're on Linux what you do is, first make sure you are compiling with the -g flag (this includes useful information in the executable). Then when you get a crash and a coredump you start gdb using this command: gdb linked_list core gdb will tell you where the error occurred when it starts up. If you want a full backtrace the command in gdb is `bt`. What I get is an error on this line: for(x = h; x != NULL; x = x-&gt;next){ which almost certainly means that that `x-&gt;next` dereferences a NULL or otherwise invalid pointer. The problem here is that you assign to x twice: once in the for statement and once inside the loop. Either try adding prints in the code, or if you're feeling adventurous try to use gdb to find out what's going on.
Both exist. nostdlib prevents anything (including CRT objects) from being linked automatically.
Wow didn't really think of that. I'm now calling free once for each variable, that should avoid memory leaking, tried like this and it works pretty well. void ClearList(list *l){ linker x,h; if (l-&gt;head == NULL) { fprintf(stderr,"Head is empty\n"); return; } for(x=l-&gt;head;x!=NULL;x=h){ h = x-&gt;next; free(x-&gt;site); free(x-&gt;id); free(x-&gt;password); } l-&gt;head = NULL; } I know about Valgrind, when I discovered it I didn't understand too much but I'll get into it for sure. To destroy the list would something like this suffice? void DestroyList(list *l){ free(l-&gt;head); free(l-&gt;val); }
Your `ClearList` looks good. Your `DestroyList` should also call `ClearList` I think, to make sure the list is empty before it is freed. And you don't have to call free on `l-&gt;val`. That's an int, so it doesn't point to any memory that needs to be freed. The general rule is that you need to free the memory that you allocated, which means, in practice, that every `malloc()` should be paired up with a `free()`. You didn't get `l-&gt;val` from a malloc, so you don't have to return it with a `free()`. (By the way, kudos for properly formatting your code. We don't see that as often as we'd like on this sub.)
Cool, fixed all. Thank you, I try my best :) I have one unrelated question, what is the best way to use a char* multiple times? Meaning that i declare a variable like so: char *str; str = malloc(N * sizeof(char)); And I need this variable for multiple scanf, but each of it is in a switch,case. Would be better declaring a char* for each use or doing something like this before using the string? (or doing malloc every time?) str = strdup(""); Or maybe this is bad and there is a better way? 
Your call to `fwrite()` looks fishy. You sure you didn't mean to use `fprintf()`? Did your compiler print any warnings when compiling this code?
Indeed http://en.cppreference.com/w/c/io/fwrite http://fr.cppreference.com/w/cpp/io/c/fprintf
I used fprintf() and I type fwrite() here by mistake. The code works and is still running on my computer. My bad
Oh thanks. I'll try that. By fflush(output), do you mean the argument should be the FILE * variable that I'm using in fprintf() (output_file in my case)? EDIT: Nevermind, figured it out. Thanks
The problem is in the line 18, I don't how I can have access to the id.
It's a lot more difficult for me since ive never actually considered a career in CS til a few months ago. I'm barely on my second week and it's tough. I personally love the way he teaches! He's very charismatic and is able to explain well on how things work. I'm sure reading a book would help you out, but i feel like CS50 is better since he explains it in a way that will help you to see how something works. A book basically says what the syntax or functions are used for, but it doesn't really tell you why or how it works.
You're totally right. Thank you.
You don't have a message pump /thread You have a hook in place but you don't have anything to receive the message input.
Correct your code to: #include &lt;stdio.h&gt; int main(void) { int num1 = 5, num2 = 7; if (num1 &lt; num2) { printf("%d is smaller than %d", num1, num2); } if (num1 == num2) { printf("%d is equal to %d", num1, num2); } if (num1 &gt; num2) { printf("%d is greater than %d", num1, num2); } return (0); } *Note that this code is yours but with formatting changes. It can be greatly improved but I kept it as such to make it easier for you*
What are the ways you would suggest to improve the code by? if else?
That would be a good start, but you only need two if statements because one of the three tests has to always be true (of course we know that only one of them are true because the numbers are hard coded, but if they weren't you would still only need two if statements). 
Qt should be also worth mentioning, even though it doesn't directly support C (you have to do some C++ bindings)
I'll definitely give that a go. Thank you very much
but I did mention in the question that the headers are sepearate from libraries, and libraries are the compiled ones from that contain one/more compiled .o files 
It all depends, of course. If you only need some temporary storage to hold a string for a while you could just allocate it statically, like `char buffer[N];`. If you need to store an unspecified number of strings you should probably allocate them as needed. One method of allocation is not inherently better than another. In general, you use the simplest method that does the job.
I don't really have a full answer, but I think it's good to note that C can definitely be used in an object oriented way. GTK in fact uses an object oriented model. So even if OOP is more suitable for developing a GUI that doesn't rule C out.
Your premise seems to be flawed. You are begging the question, as to why OO is better than structured programming for GUI applications based on an unsupported premise that it is. This sounds like a homework assignment, where the teacher gave his/her own opinion on this at some point, or made statements that you're supposed to draw from. Setting aside the above, I'll try to answer. C is suitable because many of the native OS APIs and windowing/GUI toolkit libraries are written in C, and natively expose a C interface. Therefore, it is possible to code directly to the native interface readily. However, many GUIs are logically composited of many smaller items, and many of these items differ only slightly from one another. These traits make inheritance and composition a natural manner of building up a GUI: something that C++ and related OO languages can do readily. C would offer composition, but not inheritance, and lacking constructors, would require more boilerplate code to instantiate instances of the various widgets.
Thank you
If you're running in Windows then you can just directly write Win32 code into your C and either manually construct a dialog/window and manually place buttons and editboxes, etc.. or you can 'design' a dialog 'form' into a 'resource' file using a 3rd party program like ResEdit (i.e. 'resource editor') which will let you edit resource files for your programs that get compiled into your program. Resource files can contain icons, dialog interfaces, text strings, images, just about everything you ever see as a part of a windows program that can't be described with code exclusively. This is the 'native' way to make interfaces in Windows, and will yield an executable that work on *every* version of windows from Win98 to Windows 10, with ZERO extra downloads for the users, like service packs, redistributables, .NET updates, etc... It will just work, like it was designed to back in the 90s. It is how you do stuff without zero external dependencies, and you have all of MSDN to give you examples and serve as a great reference for all the win32 calls that are necessary. All you have to do is add an include for the windows.h file (and sometimes a few other windows headers) and just start adding in the windows API calls themselves. This is how I write interface applications, always have and always will, because it will always work for the broadest possible user base. I would suggest starting with DialogBox(), doing a search on Google/MSDN. There is also CreateDialog() but it is for creating 'modeless' dialogs (i.e. the rest of the program keeps running parallel to the dialog box that's created). The only downside is that likely the only way you'll ever earn a living writing native win32 software is by writing your own software and selling it, which is what I do. Most companies these days want to be 'cutting edge' and require everybody to use the latest blah blah blah and so they have to use .NET and whatever else fluffy nonsense is out there. BLOAT! 
[You might find this library useful](https://github.com/andlabs/libui)
how do I do that
Something similar to following: int i; for (i=0; i &lt; 5; i++) { // put your code here. } Then you could add a 'break;' statement inside the if statement that determines if the guess was correct. 
Why do you have your own versions of standard functions like isupper()?
&gt; I included the use of 3 macros, is_lowercase(c), is_uppercase(c), and is_letter(c). While the string.h contains functions like these, I still opted to make my own as it was very quick to do. I included this explanation in my OP. Not really sure why I actually did though... Who knows
What? Am I seeing something wrong or are you setting your CHAR * to NULL then calling Free? Because that's a NOT good. Edit: I read it wrong. I'm on mobile. Anyway, looks okay. I'd need to actually compile it to give a more legitimate opinion 
In addition to the many great comments already made by my peers...: The `decrypt` function in a Caesar cypher is the exact same function as the `encrypt` function (using an inverse key). You shouldn't be repeating the code twice. You should (ideally) be implementing the `decrypt` as a function that acts like this: #define decrypt(string, key) encrypt((string), (255-(key))) 
So when does the field get created? Like the field data? Or is there jut actually no field and just a location that can store integer size and that location is where the value is stored and retrieved, but not actually making a integer data variable? As in, head-&gt;data is not the same as int data?
Suppose you define a struct containing two ints, and suppose ints are four bytes on your particular platform, and also suppose your particular platform needs no padding for this example, so the size of the struct is eight bytes. I ask malloc to allocate a region of memory eight bytes in size. It returns an address. That's it. There are no "fields" to create. Having the address of a valid block of eight bytes means I have a struct. A struct is just a shorthand for talking about the offsets of things within a larger block. In this example the first field starts at offset zero, and the second field starts at offset four. If I assign to the first field, the code generated will take the pointer value received from malloc and write a four-byte value to those first four bytes. If I assign to the second field, the code generated will write a four-byte value to the second four-byte block (i.e. it will add the offset of four to the address and access memory there.) The first field is a shorthand for "access an int at offset zero" and the second field is a shorthand for "access an int at offset four." Writing those ints is how you initialize the struct; there is nothing else to do, no "fields" that need to be created. The ints *are* the fields.
So the computer has a bunch of memory that is always there, `malloc` allocates that memory to the process (kind of) which you can then use. A `struct` is just a way of storing something in memory. In the following typedef struct { int foo; char *bar; } baz; we tell the compiler that when we talk about a `baz` we have an `int` and a pointer to a `char`, in that order. Later, we have baz aBaz; aBaz.foo = 3; Which is just asking for space for an `int` and a `pointer` to be reserved and then to take the first bit and stick a 3 in it. So what happens when you `malloc`? Space is reserved for a `node`, which is big enough for an `int` and for a pointer. Nothing more is done, you are told where that space is and it's left alone. We tell the compiler that we want to treat that piece of memory as a `node` by converting the returned `void*` to a `node*` struct node *head = NULL; head = malloc(sizeof(struct node)); Then the following line head-&gt;next = NULL; tells the compiler, "remember that bit of memory we said was a `node`? Well put `NULL` in the space reserved for `next`, which happens to be second bit." So can you see that nothing is being created? It's just reserved for a certain use. You tell the compiler that you want the space for something, but it doesn't actually do anything. Later on you ask to put something in that space and the `struct` declaration from before let's the compiler know where bits are placed in that area.
Thanks for the great reply, why do you think C++ have C++14, C++17 and C++20 standards and C had released none?
Wow thanks!! Win32 seems much easier for me to give a go as &gt; only way you'll ever earn a living I'm just a First Year Computer student and although I practice C as much as I can, this is my first attempt at making such UI kinda thing Cheers!!
C++ is a much bigger language with many experimental features which requires much more maintenance. See for instance how lambdas and constexprs changed between C++11 and C++17, or the history of auto_ptr (and friends) which got fully removed in C++17. 
It's less work and more reliable to use the standard functions... Challenge: Make your program work on EDCBIC systems.
`&lt;threads.h&gt;` in C11 is stupid because it lacks a lot of configuration options that we've learned the hard way from pthreads that we need. And it's doubly stupid because it doesn't leave the door open to be extensible and allow those features to be implemented later. It feels like people completely uninterested in the topic just bolted in on in the last minute just to shut up critics. Like for example stack size. When creating a thread in C11 it's impossible to control the stack size. And it's impossible to cleanly add a platform specific function to control the stack size (unless it operated on a global variable which doesn't feel like a good idea in a threaded environment). 
The problem isn't with desktop, but with embedded.
what he said.
behaviour of things like ÔøΩ in program source is not covered by the C Standard. To get reliable behaviour, don't do that.
Why do you want the "characters"? * If you want to know the storage requirements (e.g. for `malloc()`) then `strlen()` is returning what you need. * If you want to know how to wrap text in a console (with a fixed width font) you need a much more robust algorithm that understands that some codes are zero-width, some codes compose with the previous character, and what characters can break-words. This is a complex subject, and becomes even more complex when you want to think about different [hyphenation](https://pypi.python.org/pypi/PyHyphen/). * If you want to know how to wrap text with a given truetype font, you will need some additional sophistication (so you can deal with things like [ligatures](https://www.fonts.com/content/learning/fontology/level-3/signs-and-symbols/ligatures-2)) You almost *never* want to just know the number of "code points" that [/u/Aransentin](https://www.reddit.com/r/C_Programming/comments/6jk39g/question_why_does_strlen_fail_on_input_like/djetqyq/) talks about: They are of very little business use (they have nothing to do with the above) so I only bring them up to suggest they're probably not what you want. Very few protocols need or use code points --[twitter](https://dev.twitter.com/basics/counting-characters) being the only exception I can think of but even then, you also need to know the [normalization rules](http://unicode.org/reports/tr15/) in order to do it correctly. 
I believe one will come out when there is a need for one and not before. It's not like cars where marketing needs to introduce a new model every year.
Do not use `_t` as the suffix for your type names. `_t` is reserved as a suffix for system types and should not be used for application types. Otherwise, this looks very nice.
 if (len == 0) { char *empty = NULL; empty = calloc(1, sizeof(char)); empty[0] = '\0'; return empty; } is completely redundant, as is `new[len] = '\0';`, `calloc` will automatically fill `new` with zeroes. Your code will be functionally identical if you remove those. I guess the latter one could prevent a bug if you at one point decided to replace `calloc` with `malloc` but I can't see any value to separate case for empty strings when it doesn't do anything different from the general case.
Thanks, we haven't made them yet. We might be doing this in the future.
Consider using a documentation tool that can generate man pages and html documentation from the same source. Though, I usually write my manpages directly in troff. [Looks like this](https://github.com/fuzxxl/dobutsu/blob/master/dobutsu.6).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [fuzxxl/dobutsu/.../**dobutsu.6** (master ‚Üí 614926a)](https://github.com/fuzxxl/dobutsu/blob/614926a4d5185a8195f1ef20d344cabf927f918a/dobutsu.6) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djey56z.)^.
&gt; #define decrypt(string, key) encrypt((string), (255-(key))) I think you mean (26-(key))
No, try it. You can't reference a typedef before it's been declared. 
I started learning C in 1992, when ANSI C support was still a pretty new thing. Now, a quarter of a century later, I'm *just* beginning to consistently use C99 in my embedded programming. I doubt I'll be using C11 by 2020.
Does it change with different optimization levels?
Unrelated to the point, but you don't know how pleasant it was to see a correct usage of begging the question for once. 
https://www.reddit.com/r/C_Programming/comments/6jie1h/next_c_standard/djf2cbq/
What you're showing seems perfectly reasonable to me. Your first write is setting one bit in a variable you passed in. So gcc tries to avoid setting or clearing any other bit in that variable. To do that, it has to read it first, set the bit and then write it back. Your second case sets a bit in a local variable and then writes the entire variable to the variable passed in. So, the compiler knows that only one bit needs to be set in the local variable and that you're fine with overriding every other bit in the variable passed in.
Thanks! And yes, it may look like that, but I'm in the habit of setting my pointers to NULL first before allocating memory for them, for some reason. From what I reason, when just declaring a pointer like so: char *ptr; will assign it memory that is random (at first). Doing this: char *ptr = NULL; will zero out the pointer first. Am I correct in assuming this, or should I not bother with setting my pointers to NULL before allocation?
:-)
You are correct, it's the same reason I call RtlZeroMemory (C WinAPI) before I do anything with a structure.
doesnt run on everything and btw i kinda dont care i was trying to be quirky and make a controversial statement
My view is that I'm assigning the value on the RHS to the LHS in both cases. In particular, here's an interesting wrinkle: void write1(struct fields *f) { *f = (struct fields) { .b = 1 }; } generates write1: movl $0, (%rdi) movb $2, (%rdi) ret This amounts to: *(uint32_t*)f = 0; *(char*)f = 2; which looks like a very curious failure of optimisation. 
I agree with you. Now it may be that we are using somewhat older compilers, but for a lot of the TI stuff I've seen (ARM, DSP) the compilers support ANSI C and C++-03. They're not open source but often accept GNU extensions. But turning on strict ANSI checking bumps you back to C89 not C99. It will be some time before every vendor updates their compilers and libraries to support newer standards.
yeah thats whay i said &gt; for now you should write ANSI-C (c89) code.
While very interesting, this article is not about the C language. I have removed it as it is off topic.
&gt; (But even that is not a given; C++11 was referred to as C++0x for a long time as it was expected to be ratified before 2010. The schedule slipped considerably The joke was that 0x was just the hexadecimal prefix. So the final version really was C++0xB.
Thank you! I wasn't sure if the null-terminator byte **'\0'** was the same as **0** (or NULL). Therefore, I had always just done that to be safe. Thanks for pointing that fact out for me! As for the redundant code, I just wanted to be extra careful and cover all my bases. I wrote that without realizing that my general case already covered it. I should probably check that in the future before adding extra code! I edited OP to include the revision (Revision #2).
I changed from my macros to the use of **isalpha**. Thanks for the suggestion! This is Revision #1 in OP (at the bottom of the thread).
Thanks for catching that! I updated my code in OP accordingly (Revision #3).
Sure thing üëçüèª
last i checked cross compilation was not a silver bullet
`sizeof(struct fields)` is 4, as expected (it's a messed up `uint32_t`).
Oh. It actually was hardware registers. Yeah, I wasn't kidding about putting things behind a wall of optimization defeat devices. This is what operating system kernels do for a very good reason. I wouldn't trust gcc to not screw it up otherwise. After spending a few months debugging a problem that turned out gcc being clever and reordering my code from "block interrupts; fiddle; unblock interrupts;" to " block interrupts; unblock interrupts; fiddle;" I developed a healthy skepticism for how well it handles volatile. I don't want to toot my own horn on SO (I hate reputation farmers on that site), but it actually is relevant to you if this wasn't a theoretical question: [here](https://stackoverflow.com/a/44670334/939410)
gcc 4.4.7 is very old, have you tried using 7.1 at least?
Google Spreadsheets in the Google Drive suite. Almost all the functionality of Excel.
[Creately.com](https://creately.com/creately-start) is another
flow chart that plan the program before we start to code 
where have you been all my life? its lonely being the only voice of reason most of the time. 
Huh, no mention of emscripten or wasm?
That isn't even a complete sentence.
Does any one have experience with this Cello? Is it good? If you want the functionality it provides should you not just use C++?
I'm certainly not a web-dev, but I like [this](https://kore.io/) very much, what do you think?
I did the upvote also. For obvious reasons.
Why are we bringing back an article from 2013...? feels like "Back to the Future". Newer platforms are definitely ignored, not to mention the fact that C programmers are often proficient enough to mix and match source code and libraries to tailor an optimized solution. I'm not even sure we're the type to use a pre-made solution without digging into the code and making sure we agree with every decision made. Not that I mind frameworks, but when I needed a C powerhouse, I ended up writing my own framework that supported Websockets, clustered Pub/Sub, Redis connectivity and other things I needed ([facil.io](http://facil.io)). 
Look at the date, the article is from 2013... this is recycling at it's best (or worst, actually).
&gt; Two in particular most of you visit maybe once a month at least. Alright, I'll bite, which sites? 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/downvotedbyretards] [programming: "for now you should write ANSI-C (c89) code for portability."](https://np.reddit.com/r/downvotedbyretards/comments/6jx68w/programming_for_now_you_should_write_ansic_c89/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
If i were to start a web prj in C (or C++), id look towards writing it either using the apache portable runtime or as an apache module.
ITT: noobs who dont know about BCHS, who read articles written by other noobs who dont know about BCHS. https://learnbchs.org/
Cloudbleed was caused by programmer error. Not anything having to do with programming in C.
I don't understand your argument... Obviously there was programmer error, but there will _always_ be bugs, and the potential of these bugs to leak private data is greatly reduced when using a language that doesn't rely on programming perfection to avoid accessing uninitialized memory.
Not checking your bounds is programmer error, not an error within the language. Doing error checking is not programming to perfection, it's doing your job. It doesn't matter, though. I can't see using any other "modern programming language" to perform reverse proxy on Cloudflare's edge servers and I don't think it can be done in any language but C (or assembly) where performance is critical.
Reddit tip: indent your code 4 spaces to format it as code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { // Prints game instructions printf("Welcome to the game of Guess It!\n"); printf("I will choose a number between 1 and 200.\n"); printf("You will try to guess that number. If you guess wrong, I will tell you if you guessed too high or too low.\n"); printf("You have 5 tries to get the number.\n"); printf("\nOK, I am thinking of a number. Try to guess it.\n");
you too are from India?
fossil-scm.org the webpage you see at that website is coded in c. checkout the timeline page to see how to can spit out javascript in c
XD
iranian. good guess though. :D
[Here's something](https://news.ycombinator.com/item?id=7231407) you might want to read. This comment author uses a similar approach to what /u/icantthinkofone describes. [In a different comment](https://news.ycombinator.com/item?id=4964144), he says he uses the general architecture found in the [following book](http://www.amazon.com/Practical-UML-Statecharts-Second-Event-Driven/dp/0750687061) all the time for server software. Maybe you can start there?
I've looked into libuv a bit, but imo it seems that apache already covers most of this functionality (apache has multiple threading models, number of workers supervision), as well as functionality outside of the libuv scope, like virtual hosts, fine grained access control, and lots of TLS options (client side certs FTW). Don't get me wrong, libuv seems pretty dope, and if I was writing something that needed to be event based but NOT a web server it'd be one of the first tools I'd evaluate. I've actually been meaning to do a custom apache build w/ lua, and tweak it heavily... one of these days (after my other projects pan out).
I've got better things to do than try to guess at what point you're trying to make.
Your `min` value will always be either the the first or last value from the array. You need to "prime" `min` outside of the while loop. You also need to be consistent in whether `min` denotes a value or an index - you're using it both ways in your function. while(j&lt;size[i]) { min=e[i][0].lattitude; if(e[i][j].lattitude&lt;min) { min=j; } j++; }
so should I add another min=e[I][0].lattitude outside the while loop then change the min=j to min=e[I][j].lattitude. Then change the print statement to print min instead of e[I][j].lattitude? Im getting different output but its still incorrect for the minimum. Thanks so much.
What part specifically are you having trouble with?
That doesn't sound quite right. You should post your updated code. You could also try adding some `printf` statements to confirm your variables have the expected value as you run through.
Try `const int (*sequences)[100]` for the type. This should work.
Please be civil.
The Java pattern here is to wrap the array in some immutable structure such as an Iterable. Curious what C programmers would do here.
The best example for web development in C is probably [this blog](http://blog.fefe.de). Has about a million hits per day and runs on a single machine, no caching, no other fancy shit. I've never seen any delay when loading this site, even when I'm on the shittiest connection imaginable. The blog posts are stored in an LDAP database managed by the author's own LDAP implementation. He submits new posts by sending mail to a certain address, triggers in the mail server call a hook in his blogging software to enter the new post into the database.
so I'm resetting min to a[0] when I should be resetting it to the previous min every loop. Would that be something like this? Do I just take out the second min=a[0]? I'm still getting the wrong output. min=a[0] while(j&lt;5) { printf("j=%d\n", j); if(a[j]&lt;min) { printf("Old min is %d\n", min); min=a[j]; printf("New min is %d\n", min); } j++; } printf("Min of a is %d\n", min);
Excuse my n00bishness. By the light of our C Fu, Are const arrays mutable via value assignment? For coders interested in introducing a language-level enforcement against variable modification, as opposed to a mere convention? `x[i] = y;` And the same for const pointers? `*(x+i) = y;` If I remember correctly, Java similarly allows value modification of final arrays, minus the explicit memory arithmetic. Would the above snippets succeed in modifying a value referenced by a const array or pointer in C? What happens if a C array's elements are const?
Cast at the call site? `call((const int**)array);`
I don't want to be rude, but please don't do this if you don't know what you are doing. Your ciphertext isn't authenticated in any way, so I there's no way of knowing what you decrypt is some form of valid data. The way you invoke the openssl binary basically gives you this: Your cryptographic key and IV are derived from your user supplied passphrase using EVP_BytesToKey() which generates key material, which is going to generate data using HASH^count(D_(i-1) || data || salt). OpenSSL doesn't have any sane defaults, which is why that'll use MD5 as the hash. Additionally no salt will be mixed in either. All of this is going to give you not so great key material. Talking about your C code, I'm seeing a lot of unchecked malloc calls, no consideration of wiping the user passphrase from memory anywhere. What will happen when I enter data that goes over N bytes (which you defined as 100) for site, and user? This is from only a 2 minute look at the code and usage of openssl. Please don't use this. EDIT: It seems there really isn't any error checking what so ever in any of the code. This is horrible. 
&gt;True, but how do you recognize if the encrypted text is valid without the passphrase? This could be done using an HMAC in your case, you could even derive the HMAC key from the user supplied passphrase using a KDF of sorts. &gt; I am in no way an expert on AES encryption, so in a way I trusted openssl to do the encryption part. I'll look into a better setup/solution. The OpenSSL API is horrible, so be warned. It's really helpful at making you shoot yourself in the foot but that's about it. Maybe consider using another crypto library that provides a cleaner interface for several primitives or cipher constructs. Take a look at https://download.libsodium.org/doc/ for example. &gt; The struct does get wiped upon exiting. Maybe I am blind but I can't see your code doing this. DeleteSession() just removes some stuff from the filesystem but never touches on the user data structure which includes your passphrase. &gt; Buffer overflow will happen, I think it could be fixed by first getting the length of the user input and then assigning the needed memory with malloc. Or you could consider using calls like snprintf(), strlcpy(), etc which are length bound. &gt; I'm getting some memory managment errors Maybe related to the fact you never free the user data structures nor any of its members. &gt; Could you point out what type of error checking is particularly lacking? popen() could fail, or scanf() may not return what you think it does. I'm not trying to shit on your attempt here, I really am not. It's always great seeing people build things from scratch and trying to learn new things. edit: I really cannot spell.
ok. editing it out.
Thank you for your cooperation.
With your version, I still had issues until I initialized j to 0 before the loop. int min, j=0;
Basically you have to use an ugly cast. This is a design flaw in C.
I think the real answer here is to not use C for your UI. The way I would approach this is to consider what you have already written as a command line application that is going to stay that way. I would look into different UI frameworks available, regardless of programming language, and create what is essentially a wrapper around you're initial command line application. 
Ugh, of course it is I honestly can't remember how to handle casting for multidimensional arrays so I just fall back to pointers and hope for the best.
Did you install `pkg-config` and `cairo`? Assuming you want to compile with MinGW64: pacman -Syu mingw64/mingw-w64-x86_64-{pkg-config,cairo} ^((Untested, because I also installed other stuff (gtk) and I already had pkg-config installed)^) I used then the same command as in the question (but just with different filename and using the `$()`-style) and [it just worked](https://puu.sh/wxp22/4a175f5d3c.png). Make sure you start the MinGW64 'setup', as that setup has the correct paths.
You provide a good example, as well as a very concrete reason why this kind of (unfortunately prevalent) pattern can be really bad. However, I do have one nit to pick: &gt; If we needed to rely on being able to safely assign to it, we would have needed to allocate example_array on the heap, with either malloc or calloc. This is patently untrue. Stack and heap allocated values can both be mutable. In fact, the very reason that the segfault happened in the first place is because the array was moved *off* the stack into a different memory region.
&gt; You provide a good example... Thanks. &gt; This is patently untrue. Stack and heap allocated values can both be mutable. In fact, the very reason that the segfault happened in the first place is because the array was moved off the stack into a different memory region. I wasn't trying to state that stack and heap values can't both be mutable. But "stack" (automatic) variables declared const *may* be allocated in the .rodata section. Attempting to subsequently modify them will cause the segfault we observed in my example. Now, if we had not declared the array const, it would not have been allocated in .rodata, but if we had allocated the memory dynamically, it would clearly not have been in .rodata. My point was that you can't guarantee where const auto/stack variables will be allocated, so modifying them is potentially unsafe. Not that stack variables in general are immutable. If there's something I'm missing, or that you disagree with about the above, please clarify.
Use memset.
Ahh ok, I understand. All working now -- thanks!
Ah, thanks for the clarification. I'd misunderstood your comment to mean that any stack data was immutable.
NULL cannot be `1`. It must be an integer constant expression equal to `0`, or that cast to `(void *)`. The code is incorrect because if NULL is `(void *)0` for example then it's the wrong type of argument for the `int` parameter.
IMO, passing `NULL` obfuscates the type of the elements of `p_node-&gt;children` and, despite any complaint from the compiler, will work identically to passing `0`. Edit: Bring on the downvotes. I get paid to write C. I do this on the regular, and so does the rest of the C devs in my department. If you don't like this approach, give me a compelling reason to change.
/u/sebgggg‚Äôs response was wrong in a couple ways‚Äîyou can‚Äôt assign arrays like that, and the wrong type was in the `()`. It was the correct basic idea for C99/C11, but it won‚Äôt work in C89. The `memset` thing is only valid by a different standard; per ISO C alone, if you read one of the pointers after `memset`, you‚Äôre inducing undefined behavior just as if you‚Äôd set the pointer to `0x03030303` or some other arbitrary value. If you‚Äôre fine with POSIX, then no problem; if it needs to be straight C, you should either use a `for` loop (‚Üì) to initialize the pointers properly (always works): /* (up top somewhere:) */ /* Count elements of an array: */ #define countof(x) (sizeof(x) / sizeof(x[0])) /* Get a NULL pointer to a specific type * (won't work for function/array): */ #define nullof(T) ((const T *)NULL) /* in `new_node`: */ const size_t NR_CHILDREN = \ countof(nullof(struct s_trim_node)-&gt;children); size_t i; for(i = 0; i &lt; NR_CHILDREN; i++) p-&gt;node.children[i] = NULL; or use a C99+ trick like what /u/sebgggg said, only initialize the *entire* `struct` at once (you *can* assign `struct` values): *p_node = ((const struct s_trim_node){ .translation = NULL, .children = {NULL} }; IMHO that‚Äôs the easiest and cleanest one if you‚Äôre allowed to use it.
Because it's UTF, not ASCII...
Yep, it did complain and I switched it to 0. Thanks for the help!
OP wants to compile on Windows. Hurts my linux side. 
I'm not sure how you expect this code to work. length is always overwritten with the second argument, if you only pass one argument, behaviour is undefined as you try to evaluate more arguments than you supplied.
Ah, I see. To be honest I have no idea what I expected. Now that I look at it it doesn't make any sense at all. How would I set the length to [SHA512_DIGEST_LENGTH] if no second argument is passed? Can I do something like `if (va_Arg(args, int) != undef)`? Edit: Or I'll just put a if-else there.. 
The idiomatic way of doing this would be creating two separate functions, hashToStringN(char* hash, int n) which would convert only the first n bytes, and hashToString(char* hash) which would just be a call to hashToStringN(hash, max_n). Also in C you usually don't return arrays, but use them as a parameter, like this: void hashToString(char* hash, char* hashAsHex), because it gives the caller the choice to allocate the string on the stack or on the heap. So you would have to call the function like this: char out[128]; hashToString(hash, out); printf("%s\n", out);
Really, you can't. C doesn't support optional arguments and there is no way to find out how many arguments were actually passed. Think of a different API design.
okay, I guess I'll create two functions then, seems a lot easier. Second: makes sense. Is there a convention regarding the order of the parameters? GMP puts them at the start, but OpenSSL (at least the sha512 function) puts them at the end...
I'm not aware of any convention, I usually put them at the end but now that you mention it most of the standard library functions put them at the beginning.
Check if there is a standard library function with the same kind of data flow as your function and copy the argument order. For example, you could take the argument order of `memcpy()` for your code.
wow, thank you for the detailed and long answer. I think I'll just use two functions or pass SHA512_DIGEST_LENGTH. That seems a lot easier to me. &gt; You should generally not use signed types for sizes Does this also count for counters and such? When I iterate over an array I'm not going to use negative integers, so I could just use an unsigned integer. What difference does it make when i compile it? (if I remember correctly signed and unsigned just differ in the first bit which is used for the 'signedness') &gt; mark it `const` Should I mark everything const if I'm just reading from it/not going to change it? Is it just so I don't accidentally modify it? &gt; Since you don‚Äôt actually know that hash will have at least `SHA512_DIGEST_LENGTH` elements What do you mean by *actually*? When I call `hashToString()` I pass an `unsigned char hash[SHA512_DIGEST_LENGTH]` to the function. I'm not using any other hashes in my program. Is it just the *right* way to do, because other people might not use a hash[SHA512_DIGEST_LENGTH] if I would publish the source files? You're right with `strlen` in `concat`, I'm calling it two times with one `malloc`. This is the code, which I shamelessly copied from SO: char* concat(const char *s1, const char *s2) { const size_t len1 = strlen(s1); const size_t len2 = strlen(s2); char *result = malloc(len1+len2+1); memcpy(result, s1, len1); memcpy(result+len1, s2, len2+1); return result; } &gt; prototype code means stuff I'd put in the header or at the beginning of my *.c file (before the first call of the function)? And just so I get the code right `output++` iterates over the output string/array and then we do *hash AND 0xFFU ( does the `U` stand for `unsigned`?) and shift that by 4(*), but why don't we iterate over the hash array? Where do we assign length anything? And why do we need the `input` variable, if it's not used? (*) with &amp; 0xFFU we take the last 8-Bit shift them right by 4, so we have only 4 bit left. This i going to be the first part of the hex. And the second is basically taking only the last 4-Bit. Right? But i still don't understand how we get the next byte.. Sorry to bother you with all the questions, I'm still new to `C` and I really appreciate your help. 
Do it in two passes. Use scanf to read in the first number, then read the rest in a loop. #include &lt;stdio.h&gt; int main(void) { int len, tmp; scanf("%d", &amp;len); for (int i = 0; i &lt; len; i++) { scanf("%d", &amp;tmp); printf("%d\n", tmp); } } 
Declare the typedef in a header foo.h that you include in your public library headers. Define the struct in a private header foo_impl.h that you include in your source files. Edit: Nevermind, I just saw the edit at the top of your post. :-)
Thanks anyway! Given what the preprocessor does, the solution should've been super obvious to me when I was typing &gt; then I have to define the struct in each .c file 
/r/suggestalaptop is better subreddit for this question.
&gt; Does this also count for counters and such? If you‚Äôre counting down to zero, you can either use `while(n--)` or `for(i=n; i&gt;=0; i--)`. In the first case, `unsigned` is fine. In the second case, you need `signed` only for breaking out of the loop, since without negative numbers you‚Äôll wrap around when it decrements `i` from 0. If you‚Äôre counting up, or generally counting things, `unsigned` is a better bet. If you‚Äôre dealing with pointer differences, `ptrdiff_t` or `size_t` is your best bet. On two‚Äôs-complement machines (most of them by far), the most-significant bit of a signed integer is basicaly the sign bit, and ‚àí*n* = 1+\~*n*. In C, signed numbers don‚Äôt deal with overflow, division/remainder, or bitwise operations as cleanly (implementation-defined and undefined behaviors abound), and those are often quite important when it comes to sizes and counts. (E.g., will this fit in memory after I multiply it by 4? How many things of this size fit? What space is left over? What‚Äôs the size if I pad it? All common questions, all harder to answer safely without sign-checking and/or use of unsigned types.) This is mostly because C treats it as a distinct possibility that an implementation might use ones‚Äô-complement or sign-magnitude integer formats. &gt; What difference does it make when I compile it? For example: if(((i+3) &amp; -4) &gt;= MAX_BURP) error(); What this looks like it does: Round `i` up to the nearest multiple of 4 and bounds-check. If `i` is signed: The right operand to `&amp;` is negative, which causes implementation-defined (IIRC not full UB, but I could be wrong) behavior, so no telling what code‚Äôll actually get generated. Worse, if the `i+3` overflows, that‚Äôs actual UB IIRC. What happens depends on optimization and what situation the compiler finds the code in. The check might be deleted entirely, as mighy anything known to end up there. If `i` is unsigned: `i+3` causes the `-4` to be ‚Äúpromoted‚Äù to unsigned, and the only problem is that `i+3` could overflow and give too small a result. It still doesn‚Äôt work, but it *fails reliably* up at high numbers, in a way not dependent on the wind speed at compilation time. &gt; Should I mark everything const if I‚Äôm just reading from it? Opinions differ. I tend to prefer to mark things `const`, although C89 has more limitations on the usefulness of this than C99. Pre-C89, `const`‚Äôs existence was not widespread, and most compilers offer a `__const` or `__const__` alternate spelling in case you‚Äôve kicked them into ‚Äútraditional‚Äù mode. (Ditto `volatile`.) C89 does not guarantee the ability to initialize a variable to a non-compile-time-constant value and you had to declare everything before any non-declaration statements, so marking a local variable `const` was kinda purposeless 99% of the time; post-C99, I use it liberally but this chafes some people. Marking a prototype parameter (itself, not what it points to) `const` has literally no effect (like marking it `register`), so don‚Äôt bother there. You can mark parameters `const` in the function definition, however. `const` is also useful if you‚Äôre setting up BEGIN/END macros for some complicated function-embedding machinery; you can use it to force particular identifiers to show up with the right value, and if you combine it with `register` you make it nigh impossible to get around the compiler to change the value. Inner scopes can override, of course. &gt; Is it just so I don‚Äôt accidentally modify it? That‚Äôs one reason. Another is so that the compiler knows you won‚Äôt modify it‚Äîthis is especially useful for functions, where the compiler might not be able to see through the call to how the arguments are actually used. Another is so that a reader looking at your code will know it won‚Äôt be modified, and another is so that the reader can guess at how the parameters are used. If there‚Äôs some void foo(const char *a, char *b) then it *probably* reads `a` and writes `b`, and because `*a` is `const`, we know that parameter can safely take a string literal like `"ABC"` or an array like static const char MESSAGE[] = "error: it's not you, it's me"; which the compiler‚Äôd rightly kvetch about handing off to something non-`const *`. &gt; What do you mean by *actually*? Partition the code in your head between what‚Äôs in the function and what‚Äôs outside. You cannot exist as both caller and callee at the same time. If you live entirely in that function, you can‚Äôt see how the arguments came to be, you can only see their values. If you live outside the function and are calling it, you can‚Äôt see what it does with your arguments, only that you passed them and it returned to you. That‚Äôs how the compiler sees a call between compilation units, and to a lesser extent within a compilation unit. When you declare an array-with-length in a parameter (which I don‚Äôt recommend in general), you‚Äôre declaring that the array passed in should/must have at least that length, if not more. (The compiler might be able to check that against a proper array, but it wouldn‚Äôt against a pointer.) When you take an additional length parameter with it, you‚Äôre only going to end up using `length` bytes of the array regardless of `length`‚Äôs relationship with the declared array length, so there‚Äôs no reason to require all the extra characters. (Hence my `size_t len, const unsigned char buf[len]` suggestion.) So there‚Äôs no actual need for the array to have more bytes and you‚Äôre unnecessarily impeding the caller by requiring that. E.g., if you have `length = 8`, why shouldn‚Äôt they be able to pass in something allocated with `malloc(8)`? Furthermore, if the caller passes in a length &gt;`SHA512_etc.` (which, again, there‚Äôs no real reason not to allow; it‚Äôs just a bytes-to-hex function) then when your read pointer (or `i`) reaches the end of the *declared* parameter array, AFAIK you‚Äôre entering undefined behavior territory. You can‚Äôt access before or after an array, and at most you can represent or compare/subtract pointers from `array-1` to `array+len`. So yes, mostly in case anybody else ever has to use it, but for your own sake if you ever want to reuse or modify the code, and so some of it doesn‚Äôt disappear during optimization. Cinching down the types properly is an art in C; if you don‚Äôt cinch enough, you‚Äôll make an uncaught mistake, and if you cinch too much you‚Äôll hit undefined behavior sooner or later. W.r.t. `concat`: YEESH. Each time through that loop you‚Äôre allocating a brand new chunk of memory, for a grand total of ~`n¬≤/2` bytes allocated for a `n+1`-byte string. You‚Äôre also never freeing those chunks and you‚Äôre not maintaining a pointer to any of the leftovers, so you‚Äôre leaking memory quite rapidly. You‚Äôre also never checking the result from `malloc`, which could be `NULL` for various reasons, and accessing `NULL` like that would be ten kinds of UB. Let‚Äôs just‚Ä¶ kick that function into a closet at the back of the basement and scoot this old dresser in front of the door. Then burn the house down and salt the earth. Strings in C are decidedly not fun, but if you can guess the size ahead of time it‚Äôs trivial to allocate, fill, and drop the buffer. If not, you‚Äôll want to make a little pseudo-OOP buffer `struct` that will start out with some spare buffer space and expand automatically. That approach also gives you the length immediately, without having to `strlen` your way through O(*n*) bytes. W.r.t. prototypes: Prototypes are declarations of functions that don‚Äôt give them a body, like int printf(const char *format, ...); or even printf(); at global scope but that‚Äôs old-school, don‚Äôt do that. Usually those are found in headers, but `static` prototypes are commonly in the same file, and `inline` functions include the body in the header, not just a prototype. &gt; Just so I get it right &gt; `output++` iterates over the output string/array Yes. `output` is the index finger scooting along the output array; postfix `++` adds 1 to the variable after its use, so `*(output++) = x` is roughly identical to *output = x; output = output + 1; &gt; then we do hash AND 0xFFU ( does the U stand for unsigned) Yes. `0xFF` has type (`signed`) `int`; `0xFFU` has type `unsigned int`. There are other suffixes as well, L (`long`), UL, LL (`long long`), ULL, F (`float`), LF (`long double`), plus some others in newer standards/compilers. Masking (`&amp;`) with `0xFFU` ensures we‚Äôre acting on unsigned values 0 through 255 only, in case we‚Äôre targeting some godawful architecture where `CHAR_BIT &gt; 8` or the hash array type ever changes from `unsigned char` to `char`. Shifting right by 4 gets the high nybble=hex digit. (I masked before shifting because the compiler‚Äôs more likely to be able to optimize it away there than after the shift. On a normal architecture that `&amp;` shouldn‚Äôt happen.) &gt; Why don‚Äôt we iterate over the hash array? Ope, you‚Äôre right, the first `*hash` should be `*input` and the second should be `*(input++)`. Earlier version had `hash` as a pointer that was updated, but I decided you might want to return the original `hash` value so I switched to a separate `input` pointer. &gt; Where do we assign `length` anything? In the earlier block, size_t length; do { va_list args; va_start(args, hash); length = va_arg(args, size_t); // &lt;&lt;&lt; va_end(args); } while(0); Glad I could help; ‚Äôs a fun language once you get into it, even if it does require lawyer-skillz to check code against the standards.
A quick search for "sudoku game C github" found [dhiachou/sudoku](https://github.com/dhiachou/sudoku) - however, I haven't tried compiling it so I can't comment on whether it works or the quality of the code. &gt; Like is everything written in one file? Entirely up to the developer. A sensible developer will split their code into multiple files when it makes sense to (logically distinct modules with their own clear, concise interfaces). In the case of the above implementation, there's multiple files. &gt; how many line of code (approx.) is required? Again, it depends on what exactly you end up implementing. The project I linked supports both a GUI and command line interaction, so if you were doing less than that, you'd *probably* have less code. On the other hand, I'm sure you could make a much more complicated implementation of sudoku.
Don't worry, when you're learning there isn't a thing like a stupid question! I'll not really answer to your question, but I have just a recommendation: if you want to code a simple game, do not start with a sudoku. It may seem easy, but in the C language, or any imperative language (a language in which you state what the computer must do, instruction by instruction), it may be a little too hard on a beginner, or at least very tedious. If I were you, I'll take a look at the "Hunt to Wumpus" game, or at least a simplified version.
Try using Docker to make yourself a dev environment. You might get away with just installing Docker Toolbox directly to Windows, and skipping the VM.
You could try [Cygwin](https://www.cygwin.com/), which is a POSIX-env in windows. Also install [apt-cyg](https://github.com/transcode-open/apt-cyg) to get an package manager that you can use while using cygwin. I'm not sure if it is faster than a VM. It looks like `libisoburn` `grub2` is not in their repositories so you have to compile it by yourself (sorry). I'm not sure what you use `grub2` with and if it even works with cygwin.
&gt;It looks like libisoburn grub2 is not in their repositories so you have to compile it by yourself (sorry). I'm not sure what you use grub2 with and if it even works with cygwin. Shook. I need those to produce `.iso` files (OS development)
As others have mentioned it's up to the developer for how many files. For instance, let's pretend your equation program had a simple GUI in GTK. Perhaps you would have a main.c, GUI.c, and an equation.c where the main function would be in main.c which calls the GUI and the GUI, in turn, calls the actual logic located in equation.c. So people can split up the program like that in any number of ways; this was just a quick example.
I have a different implementation for a multi threaded queue (using a circular buffer). You are welcome to critique my code. [queue.c](https://hastebin.com/ucurivizak.cpp) [queue.h](https://hastebin.com/eqedizobis.cpp)
This question is not related to C programming and thus off topic. Please ask elsewhere. I have removed your post.
I don't see how this question is on topic. It doesn't seem to be about C programming or directly about a tool used for programming in C. In fact, there are so many degrees of separation from this question to the C programming language that I don't see how it is on topic at all. Please ask elsewhere, e.g. on Super User or /r/linux.
You are looking for `mkisofs` from cdrtools or (in case cdrtools is not available) cdrkit.
That's not lock-free, which is the whole point of the way OP implements the queue.
I use CLion from JetBrains. It has a beautiful interface and the some really great features. For a simple text editor, I just use Emacs. As a side note, in my opinion, you need to study something for more than two years in order to be considered an expert.
Do you wanna learn graphics? I'm not sure what your interest in making a game is. Or do you wanna make your game terminal based? Which I recommend if you are newer to programming. 
Carefully count the number of equal signs in that first if. 
lmao, I'm so sorry. Jesus did I mention this is my first programming class? Thank you so much and sorry.
What‚Äôs the asm for the callback setup, and is the setup code PIC? Curious if it‚Äôs doing LEA [RIP¬±] or just hardcoding the callback address. Alternatively, did the `Api.RegisterRawInputDevices` call turn into `RegisterRawInputDevices(Api, &amp;Rid, 0x01, sizeof)` and bork the arglist? Also, might try /r/lowlevel or /r/osdev, deader but might be a little more up on this stuff.
Enable all warnings; that should‚Äôve been pointed out by the compiler.
Sorry if my memory is fuzzy, I'm on my phone at the moment. There isn't any ASM code for the callback. It's still native C with RegisterWindow with SendMessage, TranslateMessage and DispatchMessage. All of the callback code is position independent too, yes. &amp;&amp; I don't believe so. Do you know what RegisterRawInputDevices wraps to?? 
The same editors and IDEs suggested the last 128 times this was asked...on reddit...today...
Great advice; I'll chime in with the flags to enable more warnings: At a minimum, - `-Wall` - `-Wextra` I'll also often use `-Werror` to make warnings into errors. Helps keep me (and my co-workers) honest. 
No I meant whatever the C assembles to, either before or after having been dumped to whatever binary file. Instructions and operands and all ‚Äôat. A comparison of the two might show what‚Äôs going on. And unfortunately I can‚Äôt be much help for `RegisterRawInputDevices`. I‚Äôve done some lite and only-accidentally-deep hackery here and there, but I‚Äôm mostly familiar with Linux/POSIX down to the metal and Windows on the metal‚Äîhence my questions about the ABI interactions mostly. Programmed on Windows waaaay back in the day; thankfully only a vague feeling of exasperation remains from that time. Have not hacked on Windows, seemed unsporting.:)
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://www.toyeskies.com/Abby_10wks_1.jpg)
`-Wextra` tends to include a few things that‚Äôll throw up false positives, especially in older or non-(GCC|Clang) compilers, which would be my only objection. I use `-Wall -Wextra` while in development/unstable, disable occasional false positives with `#pragma`/`_Pragma` and `__attribute__` in the appropriate files, and then drop down to just `-Wall` for builds otherwise, especially once something‚Äôs been packaged and handed off. But any automated build should be `-Werror` IMO‚Äîtoo much code almost doesn‚Äôt build, or wouldn‚Äôt work if the compiler had noticed that speck of undefined behavior and deleted the entire basic block, or wouldn‚Äôt work if the `printf` argument didn‚Äôt happen to have a spare zero word sitting after it in the stack.
I disagree about `-Wextra` enabling too many warnings, but I concede that's a point of style. Personally I tend to write pretty stylistically-conservative code, so I guess the trade-off of being more constrained in what I can write feels like a worthwhile trade-off given how many times warnings have saved my butt (or at least saved me a great deal of confusion). Edit: I see what you were saying about "non-gcc/clang." That's a fair point, though one I (thankfully) don't have to deal with very often. In that case, I'd likely default to `-Wextra -Wno-whatever` for the offending false-positive thrower.
I use Oracle Developer Studio or Eclipse CDT
I made 2048 clone for the console, called [2n](http://github.com/bart9h/2n) ( as in 2^n ). The first playable version had around 250 lines of code. The "final" version is a bit over 500 lines. You can check not only the source code on github (on the link provided). Not only the source code, but the [history](https://github.com/bart9h/2n/commits/master) too, so you can see the progress of the code. For example, [this](https://github.com/bart9h/2n/commit/b99944bf57cd45faaade23e24692b23293d1e1be) is the commit that added the feature where you can choose the board size. I also made (with the help of others) [a modest 3D game](http://github.com/bart9h/cave9) in C. It's a bit over 3,000 lines of code. ([Here](https://www.youtube.com/watch?v=rjsrBZPeltA) is a gameplay video of the game, so you can get the idea without having to compile and run it. It's not from the most recent version, tough.) These are simple examples. Most games have a lot more code than that. [EDIT: fixed commit link]
See, useful `-Wextra` comes so late in my career it usually isn‚Äôt helpful‚ÄîI‚Äôd already gotten the standards-lawyering down before GCC 3.0 days, so it only kicks when I‚Äôve made some major, fucking stupid error that would‚Äôve caused the program to shit itself instantaneously anyway, or at a false positive. Useful on other people‚Äôs code, though. Disabling the warning with pragmata‚Äôs my preferred approach for false positives, since the warning might turn out to be useful elsewhere in the code and if nothing else it‚Äôll stop other people with the same compiler from seeing it.
That is good advice - I oughta start silencing warnings that way. I'm a relative baby by C developer standards - I've been at it five-ish years, professionally for two. Seems cooing my teeth on late 4.x releases was a different experience :P
Thanks for all the advice guys. Helped me a lot. 
I use `ed` and `nano`. At the end of the day, it doesn't really matter what editor you use. 
Sorry that it took so long for this answer. First of all thanks again for your help. I think I understand most of it now, but I still need to learn a lot more about memory management and complexity. Do you happen to have some book suggestions specifically for C? I read (on reddit) that the book from the Original C Designers is very good? I do have an older Book for C++11 at home, which I bought years ago but never actually made it past the first few chapters... &gt; Strings in C are decidedly not fun Tru dat
Nothing can even come close to QtCreator/ClangCodeModel combination.
I have to bother you again.. This is my hashToString Function now: size_t hashToString(char *outBuf, char *hash, size_t length) { const unsigned char *input; char *output; input = hash; output = outBuf; while(length--) { static const char DIGITS[] = "0123456789abcdef"; *(output++) = DIGITS[(*input &amp; 0xFFU) &gt;&gt; 4]; *(output++) = DIGITS[*(input++) &amp; 0x0FU]; } *output = '\0'; } (Basically what you wrote except that I changed the hex digits to lowercase, I also ditched the optional parameters, they do look nice but thats way too complicated for some eye candy.) When I call the function once and print the result everything works just fine, but if I call the function twice the first few bytes are missing. hashToString(K1asHex, sharedSecretK1Hash, SHA512_DIGEST_LENGTH); hashToString(K2asHex, sharedSecretK2Hash, SHA512_DIGEST_LENGTH); printf("K1:%s\nK2:%s\n", K1asHex, K2asHex); K1:602dac64951e5421333333333333333333333333333333333333333333333333333333333333333800a85732ff8168876e429d1007d87b236a097e2dac012e9339cef964397952b2 K2:333333333333333333333333333333333333333333333333333333333333333800a85732ff8168876e429d1007d87b236a097e2dac012e9339cef964397952b2 this only happens if I call the function with `SHA512_DIGEST_LENGTH`. #define MAX_BYTES_TO_MATCH 4 hashToString(K1asHex,sharedSecretK1Hash,MAX_BYTES_TO_MATCH); hashToString(K2asHex,sharedSecretK2Hash,MAX_BYTES_TO_MATCH); printf("K1:%s\nK2:%s\n", K1asHex, K2asHex); K1:602dac64 K2:602dac64 Calling the function with something small works just as intended. If you want I could also give the complete source, but it's pretty dirty.
I have been using [valgrind](http://valgrind.org) for this. edit: included link to http://valgrind.org
Just don't forget to free what you malloc. C doesn't give you any hand holding. valgrind does help narrow down sources of leaks, but you still have to figure out where to free that memory. However, you could use a [garage collecting malloc](http://www.hboehm.info/gc/) library instead of the system one...
Valgrind is a really good tool for that. It will check for memory leaks but also other memory error. Unfortunately it has a big cost on performance. For some application this would be a problem. Another tool that have a very small impact on performance is LeakSanitizer. (You may also like to test you application with other *Sanitizer like AddressSanitizer or UndefinedBehaviorSanitizer). Both of them are dynamic analysis tool, they check what happen at runtime. This means that if your application doesn't trigger the case where the memory is leaked, you wont find out. Having great tests may help. Using fuzzing may also help. Another family of tools are static analysis tools. They can analyze the source code and find some issue, including memory leaks. These tools wont find all errors but they may help find more errors. The ones I already used are [scan-build](http://clang-analyzer.llvm.org/scan-build.html), cppcheck and splint. All these tools are not magical. They may help you find problems but they don't replace a good understanding and careful analysis of the code.
Not the most helpful advice, but things like this are why I finally went back to C++ (after a horrible dev job scared me away from the language for years). Destructors are wonderful things. Dealing with complex data structures in C are not. :( *Clarification: Not only does C++ provide deterministic object destruction, but `shared_ptr` and `unique_ptr` mean you don't even have to manually call `delete` to free your data.*
As other posters have pointed out, Valgrind is handy in these situations. But it causes a massive slowdown, which means that it can't be used on a complex program requiring user input in real time. And when you don't know the source of the leaks in such a program, designing automated tests can be a pain. Clang's leak sanitizer, however, *can* be used in these situations. It can also be combined with Clang's address sanitizer to catch most other forms of memory error. These tools cause a slowdown as well, around 2x slower, but that's at least an order of magnitude faster than Valgrind.
I don't understand why you're being downvoted. C++'s destructors are an elegant solution to OP's problem
Personally, I believe this is misleading. My understanding of C++ (**please correct me if I'm wrong though!**) is that C++ you still have to free up heap memory allocated using `new`. I agree that the destructor provides an easy way of knowing where you can use `delete`. If I was using C++ I'd use something like a [`shared pointer`](http://en.cppreference.com/w/cpp/memory/shared_ptr) which would make it even easier to manage the allocated memory.
In addition to the wonderful comments made by my peers, I would point out that I sometimes stress-run my applications over time and manually test for memory growth using the OS (`top`, "Activity Monitor" etc'). This isn't always possible, but when writing tests that also stress-test the system, issues such as memory leaks often reveal their existence. Another, somewhat less related point: I would guess that the root of the issue is actually high code entanglement between the different data storages (The Hash Tables, the dynamic arrays and the structures). Objects shouldn't really "know" that much about each other. It would make more sense if a "destructor" function pointer was used in the Hash-Table to allow it to call the Array's destructor without having any knowledge about the Array itself. It would also make more sense for the dynamic Array to save a "destructor" function pointer for each object or each Array instance, so it could call the item's destructor without having any knowledge about the item itself. Another solution would be to reverse the hierarchy, so that Items extract themselves from the storage (this is the public API) and storage objects (array / hash table) self manage their memory. This isn't possible in all cases.
You're partially correct. In C you almost always have to allocate stuff on the heap, in C++ even complex objects can be allocated on the stack, and if the object itself need to allocate stuff on the heap it does so "automatically" inside the constructor. In the same way, when the object is allocated in the stack the destructor is automatically called to deallocate anything the constructor allocated. It's actually a really bad practice to `new` most objects in your program. A really common pattern in C++ is creating "wrapper" objects that are allocated on the stack and takes care of allocating and deallocating the necessary heap. Google for RAII for a better understanding.
&gt; If I was using C++ I'd use something like a shared pointer which would make it even easier to manage the allocated memory. Exactly. Shared and unique pointers allow for automatic deallocation thanks to constructors. I don't actually remember the last time I used `new` and `delete` directly in a program, which is why I recommend C++ over C for projects involving non-trivial data structures.
That depends on your toolchain. Traditionally, the entire object file is linked in. For this reason, many libraries define each function in a separate source file so the linker only takes what is really needed.
Thanks.
I recommend reverting your input to `const unsigned char *hash`, even if you have to cast the pointer on the way in. Not strictly necessary, but probably slightly more semantically-correct. (If it annoys you to type `unsigned char` over and over, make a `typedef unsigned char Byte` or `DigestElem` or something, possibly also a `typedef DigestElem SHA512Digest[SHA512_DIGEST_LENGTH]` for the entire hash.) Not seeing anything else borken-looking about the function, except that you‚Äôre not returning the `size_t` you declare as its return value‚Äîchange to void or save some `const size_t ret = length+length;` and `return ret`. What‚Äôs `sharedSecretK2Hash`coming from? Also declarations and, if applicable, allocation of backing buffers, that sorta thing, wanna see where the bytes are ending up and coming from.
I think your parenthesis are being a little nefarious right now. Remember, the parenthesis indicate a priority in terms of how the compiler (and other people) will read and execute parts of the expression you wrote. In your case, the`*` is not being read as a data type that exists and it's not syntactically valid for a variable to have a `*` in its name. struct A* array[8]; Will create an array of 8 A pointers. edit: sorry, formatting on mobile 
Have you tried: struct A; struct A { int number; struct A (*array)[8]; };
That does work, thank you. Just wondering though, what does int (*A)[5] do? I can compile it as it is
It doesn't work, looks like the problem was with the position of the asterisk
I would recommend against the older C books^(*). I learned C in 1993 from reading the Turbo C compiler manuals so I have an aged copy of *C: A Reference Manual* and that‚Äôs all I work with that‚Äôs not a manpage or compiler infopages. You might want to try Kalichara (*C by Example*) or Yun-Hsiang Lu‚Äôs book (*Intermediate C*) for some basic memory management stuff, although both of those have some pre-C89 crap leftover. Might want to look at Advanced UNIX Programming or something along those lines as well. You‚Äôre probably at the point where you can use man-/infopages, Wikipedia, and Google to work yourself forward about as well as you would with a book. You might also want to peek at the standards (you can either shell out an obscene amount of money for them, go piratical, or get the free-of-charge pre-ratification drafts), but stop reading if you notice your eyes start to bleed. W.r.t. algorithmic complexity, I wouldn‚Äôt know where to start in terms of pointing you somewhere. I learned it as part of a 200-level Data Structures course, although you can get a feel for it without needing to go at it formally. You‚Äôd need to brush up on your logs, probably on your limits and *n*-ary summations, and then ‚Ä¶Idunno, [Wikipedia](https://en.wikipedia.org/wiki/Big_O_notation) or something? No idea. Once you get a feel for it it‚Äôs not too hard, though recurrence relations are always fucking miserable to bang on. O(*n*¬≤) roughly means you have a pair of nested `for` loops whose iteration counts are both ‚â§ *Cn* + *D* for some *C*, *D*, and O(*n*) means you only have ‚â§*C* such loops for some *C*.) ------- \*I have is Ésues with the old C books. C89 is the horizon of compatibility now, and most compilers will warn you about pre-C89 crap if in strict mode‚Äîand they should always be in some sort or strict mode. Most C books start you off with a pre-C89 no-return-type no-parameter-list `main()` for some reason, and the oldest books are pre-C89 entirely so you‚Äôll learn a lot of really bad habits. Definitely get a copy if you want, definitely don‚Äôt learn from them. Somebody under the age of 73 needs to write a C book one of these days.
cdecl is a lovely tool. [Online interface](https://cdecl.org/?q=int+%28*A%29%5B5%5D). 
Yeah, the Clang-GCC rivalry really heated up around 2012 IIRC, and since that they‚Äôve both been improving in leaps and bounds, with Intel toddling along behind. So many ICEs in pre-3.0 GCC, and ICC‚Äôs internal assembler always fucks something up.
Wow, thanks
So, the underlying problem: You're trying to declare array as a pointer to an array of 8 `struct A` objects. At this point, the compiler doesn't know how much space a `struct A` takes up because you're still in the middle of defining the structure. Even though the field is just a pointer, the compiler still wants to know how much space the array it points to takes up. Since it doesn't know that, it gives you an error. EDIT: In your other similar declaration in a comment, the compiler knows the size of an int, so it works.
One caveat: You can't use array as an identifier in declarations it explains. That page could benefit from a link to the [documentation](https://linux.die.net/man/1/cdecl).
&gt; int (*A)[5] declares A as a pointer to an array of five integers. Compare int *A[5] which declares A as an array of five pointers to integers.
You have a race condition with breakFlag (it needs to be atomic or protected by an omp critical region, but I bet the cause of the crash lies in one of the functions you call also not being thread safe in a more dangerous way.
Valgrind is great. Someone already mentioned Clang sanitizers; gcc has sanitizers too. I always built and run my tests with all the sanitizers on. 
Great explanation
You need to turn on one of the optimization flags for gcc to trigger some errors.
&gt; in C++ even complex objects can be allocated on the stack I‚Äôm curious what you meant by ‚Äúcomplex objects‚Äù here. The compiler can optimize away a `new`/`delete` pair, but a C compiler could optimize away a `malloc`/`free` pair just as easily. Otherwise, C++ classes aren‚Äôt any more complex than C structs, except that non-POD member layout is ABI-dependent. You can‚Äôt allocate a flex array on the stack in either language, and anything else I can think of wouldn‚Äôt enter into decisionmaking about stack vs. heap allocation.
Without the context and declaration of the variable in question it‚Äôs somewhat hard to tell what‚Äôs happening, but if the variable‚Äôs out in the global scope or declared `static`, then it‚Äôs zero-filled at startup‚Äîthis isn‚Äôt an error. Reading an uninitialized *local* variable is a different matter.
&gt; it (C) gives me a feeling of challenge It's actually the other way around. clarification: it's more challenging to practically make things work in production on virtual platforms (like java, c# etc.)
That's a good thing! If you like writing programs like this, you are destined to become a good programmer.
&gt; in the struct there was a character array that I needed to free as well the symptom would likely be memory leak. You could use valgrind but imo it sucks for memory leak. The best tool for memory leak is compiling your own jemalloc with heap profiling enabled, let it hook malloc at startup, let it collect logs and analyze those logs with jeprof.
An uninitialised variable is not an error *per-se* and the C language allows you to have such variables. However, using a variable while it is uninitialised is undefined behaviour which usually causes the compiler to emit a warning. Do keep in mind though, the compiler cannot always perfectly determine if a variable is really used without initialisation and without optimisations turned on, the compiler might not be able to give good warnings either.
try the UndefinedBehaviorSanitizer tool
That's good to know, using gcc sanitizers is probably the simplest debug step I can do since I'm using gcc to compile it anyway.
all the pro's I know in personal life use vim. I use visual studio because I like the hardware-graphics rendered fonts, syntax coloring, code folding, fast grep &amp; the debugger. I've also written some personal extension for the VS to do simple things like always open a text file in read only mode etc. Earlier it was easier to add personal stuff to visual studio using VB based VSmacro but retarded PMs at Microsoft decided that VB doesn't sound fashionable enough to impress their managers/directors and thus removed the great Vsmacro infrastructure and kept the idiotic C# based full blown extensions that took a day for me to write instead of 15min it takes for writing the old macros. The same thing is happening with firefox now. They're removing their native extension and doing retarded things like chrome extension which are completely useless and weak in functionality. Don't get me wrong I don't use the 99% VS's functionality, eg. the shitty msbuild (you know xml based project management used to compile projects yuck) or intellisense/search or other crap. I just open the C file and start editing. No project n shit. For build I use makefile on linux &amp; nmake or simple-bat-file on windows instead of the shitty msbuild. edit: there is also this https://4coder.handmade.network/ which I would've tried had it not been behind a pay wall.
a good and a *valuable* programmer
Older linkers mix entire object files together to form a final executable binary; newer ones tend to be able to act on specific sections or subsections individually, because different ones require different actions to be taken. You can get a highish-level view of what the linker does by looking at the linker script: echo 'int main(void) {return 0;}' | \ gcc -Wl,-verbose -o /dev/null -x c -pipe - | \ awk 'BEGIN {i=0} i&lt;2 &amp;&amp; /^=+$/ {++i; next} i==1 {print $0}' | \ tee default.ld (That‚Äôll leave you with default.ld for later reference. What it does, so you don‚Äôt just blind-paste: It `echo`s a minimal C file into `gcc`, which compiles that and passes its output with the `-verbose` option to the linker, causing *that* to dump a ton of shit as it works. One of those things is the linker script, preceded and followed by a rule of `=`s. The `awk` script waits until the first rule, dumps until the second rule, and ignores the rest, leaving only the script. The `tee` invocation saves the output to a file as it prints.) The usual data/code sections from different objects are first grouped by section name, then concatenated together from each object file to form the final image, usually (all code)(all rodata)(all data)(all BSS) in that order. Some adjustment is made for alignment to avoid overlapping protections; typically, code is rx, rodata is r, and data/BSS are rw, so there have to be at least those page breaks. If an object is included, all of its content will usually show up in the output, because the linker neither knows nor cares what specific internal bytes are needed, and it only has an informal idea of where compiler-generated things start and end. It needs to be able to support hand-coded assembly as well, which might not define boundaries at all. BSS (=uninitialized data) is the odd man out when compared to text/data/rodata, as it consists only of (label, alignment, size[, flags]) tuples in the object file. In the final binary, BSS can be reduced to a size value, and the loader ensures that many bytes/pages are mapped before calling `main`. VM-capable systems usually wait to zero BSS pages until they‚Äôre used. Older systems started the heap at the end of BSS, and bumped a single `brk` pointer to allocate more memory. There plenty of metadata sections as well. GCC typically uses the `.note` section to indicate ABI variants where necessary; for example, if stack trampolines are necessary, the compiler will add an empty `.note.GNU-stack` subsection, which is ‚Äúmerged‚Äù with any other objects‚Äô `.note.GNU-stack`s and converted to an appropriate `.note.ABI-tag` section in the binary. There are also sections that are discarded entirely before linking, and sections that stick with the binary but don‚Äôt need to be loaded at run time, like `.comment`s that describe the build toolchain. Exception handling sections (GNU: `.eh_`\*) describe register and stack usage sth a running program can carefully unwind the call stack when an exception is thrown up until an appropriate `catch` block is found. There‚Äôs also debugging information (GNU: `.debug_`\*), which tells a debugger where in the source code things are defined, what formal types are used (e.g., `struct`s, `class`es, `enum`s, `typedef`s), and how stack frames are laid out. Thread-local (TLS) data goes in a special section (`.tdata` or `.tbss`) that isn‚Äôt used directly by the binary. Instead, it‚Äôs cloned once for each thread. Whenever a new thread is created, ‚â•`sizeof(.tdata)+sizeof(.tbss)` bytes are allocated, `.tdata`' is filled in from the binary‚Äôs reference copy, and `.tbss`' is zero-filled. Then the new TLS region is tied into the thread state according to ABI requirements before booting the thread callback or `main`. On x86, the FS or GS segment register is used to get a base pointer for the thread data area, so it can be accessed quickly; other ABIs use different techniques. Some ABIs don‚Äôt support TLS sections at all, so programmers have to manage TLS via manual calls to `pthread_key_create` and `pthread_get`-/-`setspecific` or similar. References to static constructors and destructors‚Äîa C++ feature also supported by most C dialects‚Äîare given their own section (GNU: `.init_array`, `.fini_array`). Typically, rather than putting an entire ctor/dtor function into a ctor/dtor code section, the function is emitted as normal code to `.text` and a reference to its symbol is dropped into a read-only ctor/dtor section. When the binary/DLL is loaded, ctors are called in order before calling `main`; when a exiting normally, dtors are called after `atexit` handlers have run. Position-independent code (PIC) is needed for DLLs and some executables (‚ÜíPIE) because they can be loaded any-old-where in the address space. Non-PIC bses the `.text` section at a fixed address (e.g., 0x40000) or keeps a special (per ABI) CPU register aimed at the base address. Code can generate references within a PIC object by getting the IP/PC and adding a relative offset to it; on x86-64, there‚Äôs an RIP-relative addressing mode for just such occasions, but some architectures require reprehensible kludges to do the same: call 1f 1: popl %ecx movl thing-1(%ecx), %edx ... thing: .comm 4 (‚ÜëIA32 version; RISC may have to jump-and-link in a similar fashion.) Symbol references between PIC objects (especially inter-DLL or DLL‚Üîprimary image) typically require an autogen function call, since the compiler and linker have literally no clue where the target symbol might live. On Linux, GOTs and PLTs and all kinda crap have to be set up; on Darwin, call sites have to leave space so the target address can be filled in. GNU compilers use PIC features to enable load-time fixup, which can replace a symbol‚Äôs linkage with any old run-time pointer, typically for host-specific optimizations. This makes it appear to the programmer as if the function itself has been replaced, although the original target and any alternatives remain resident in memory/binary images whether or not they‚Äôre used. Inline functions and instantiated (C++) templates‚Äô static and function members usually get dumped into their own subsections, so that the object files contain a lot of replicated data. The linker can name-match the subsections and cull duplicataes, so that later link stages don‚Äôt bitch about duplicate symbols. Without subsection support, it‚Äôs considerably more difficult to get C99 or C++98 to work properly. Some ABIs support symbols of different ‚Äústrengths,‚Äù which are another way to get multiple instances of the same symbol in the output; however, in that case the weaker symbols are overridden by the (single) strongest symbol, but the object(s)/section(s) containing the weaker symbol(s) typically remain in place unless no references to it/them remain after the strong one has taken over. Weak symbols enable neat tricks like including a default `main` in a library that can either be used as-is or supplanted by client programs at their discretion. The linker *may* be able to do a little better than subsection granularity if link-time optimization (LTO) is enabled‚Äîalthough it‚Äôs a new feature, and only supported on a few toolchains. Enabling LTO causes the compiler to dump extra bytecode (GIMPL for GNU toolchains‚Äîanother Turing-complete language) along with the assembly/machine code output, which the linker can use to do late inlining and other cross-module optimizations that the compiler can‚Äôt do. The GIMPL is left in `.gnu.lto_`\* subsections in object files, which can be omitted in the final binary. Even without high-level LTO support, most linkers can do some low-level optimizations; e.g., reorder object-sections to minimize space wasted by alignment padding in the final image. Static libraries are usually souped-up object file archives (hence UNIX extension .a and library tool `ar`). Some libraries (e.g., glibc IIRC) will place a single function in each compilation unit‚Üíobject file, which then enables the linker to pick and choose what to include in the executable at a fine grain, without resorting to full-blown LTO techniques. Dynamic libraries work very differently from static ones‚Äîthey‚Äôre usually just a step away from being full executables, so they can‚Äôt be used piecewise. If you‚Äôd like to poke at all this yourself, you can use `objdump` to see exactly what the compiler‚Üíassembler emits for the code you give it. (Works on object, library, and executable files alike.) Common invocation forms: # List section headers: objdump -h FILE # List all headers: objdump -x FILE # Dump only SECTION as binary: objdump -j SECTION -s FILE # Disassemble only SECTION as code: objdump -j SECTION -d FILE If debugging information is included in the file (GCC option `-g`), option `-S` will mix the original source code in with disassembly. (‚ÜêNigh useless if you optimized.)
Challenge gives you a feeling of C?
Yeah, `const unsigned char *hash` makes more sense, the hash I pass to the function is unsigned anyway. What would I do with the `size_t` I get return when I'd call the function? Or why should I return the size instead of just using `void`? `sharedSecretK2Hash` comes from my `getHash` function, which takes a mpz_t number and returns the sha512 hash. void getHash(unsigned char result[SHA512_DIGEST_LENGTH], mpz_t key) { unsigned char *hash = mpz_get_str(NULL, 16, key); SHA512(hash, strlen(hash), result); free(hash); } These are the declarations for the variables and how they are used. mpz_t sharedSecretK1, sharedSecretK2; mpz_inits(sharedSecretK1, sharedSecretK2, (void *) NULL); unsigned char sharedSecretK1Hash[SHA512_DIGEST_LENGTH]; unsigned char sharedSecretK2Hash[SHA512_DIGEST_LENGTH]; char K1asHex[6]; char K2asHex[6]; mpz_powm_ui(sharedSecretK1, publicA, counter, prime); mpz_powm_ui(sharedSecretK2, publicB, counter, prime); getHash(sharedSecretK1Hash, sharedSecretK1); getHash(sharedSecretK2Hash, sharedSecretK2); complete Code here: https://gist.github.com/julianveerkamp/db8ef006b6d862239505dca903c1362f I'm not really sure why I wrote `char K2asHex[6];` and why it works when filling it with a complete hash in hex form... 
I'll check out those two books about memory management. Regarding Complexity I already have a [book](https://www.amazon.de/gp/product/3827428033/) on algorithms, data structures and complexity for my "Algorithm and data structure" Uni course. I took the course two years ago, but I still have to write my exam for it. I get the theory but actually using it when writing code... Thanks again for your help and those recommendations. 
Okay marking it shared is not enough then. How could I make the functions thread safe? Is there an easy way using an omp pragma or does it depend entirely on the function itself? The culprit is going to be addToHashMap. writing a uthash table is not threadsafe, so I have to do some locking... Could you direct me in the right direction for locking with openmp? 
I understand what you mean. Languages like C and C++ make me feel more geeky. It gets my geek juice flowing more than something like Python. 
He gives C a feeling of challenge?
Yep, C is awesome, and I love crafting code with it too! I just wanted to say that if you have a more appropriate tool for a project you _must_ do, do not hesitate to use it! As much as I love taking my time and challenge myself, being a perfectionist sucks sometime when you do not have enough time. Anyway, that's just an advice, have fun, hack away!
I've known plenty of C programmers whose code gave me an (unwelcome) feeling of challenge.
If you return `hash`, then you can do something like puts(hashToString(result, input, count)); without needing to break it up into hashToString(result, input, count); puts(result); If you return the final value of `output`, you can do strcpy(hashToString(result, input, count), "!!") ‚ÄîIMO is one of the more useful things to return (see also `stpcpy`), and it‚Äôs easy to get an O(1) length from it. If you return the length of the resulting string, then you can do size_t len = hashToString(result, output, count); strcpy(result + len, "!!"); len += 2; As I noted, all of these are things that can be derived readily from one or more input parameters, so there‚Äôs no real need to return anything. It‚Äôd be customary were the output length less predictable, or were there some result outside of the buffer. Here there‚Äôs nothing objectionable about returning `void`. The output buffer size is nowhere near big enough AFAICT. SHA512_DIGEST_LENGTH should be 64, right? So the maximum number of characters that could take in hex is 2√ó64+1 = 129, including the final NUL. ‚â•That should be your output buffer size, preferably using that macro I pooped out in my first reply to calculate it instead of the explicit 2*n*+1 form. (Maybe you got 6 from 2‚Å∂=64 or lg 64=2?) It‚Äôs quite possible what you were seeing was the result of a buffer overflow, where you wrote across the stack from one buffer into the next, and then something accidentally terminated it by writing a 0 word at some point. It‚Äôs at least undefined behavior, if nothing else. [Also, just in case you care: Your meat-name is tagged in your file and in your github account name, so you‚Äôre leaking identity.]
Maybe I'm missing a free() somewhere, but it looks like the frames are leaking
This will keep me busy for awhile. I appreciate your in depth explanation. 
Frames are reused and are destroyed automatically after an EOF.
Look into the `omp critical` pragma. Or C11 atomic types for simple values.
Me2. When achieving something in C it feels like you build a car with only a screw driver. 
I love programming in C, but I am little bit scared that I'll have to travel a lot to get a good job with C.
C also gives you a much better intuition about how computers and compilers work under the hood (short of writing assembly). This knowledge comes in handy even as you move up into higher level languages.
My point is that in C if you have a complex object that needs a "destructor" function (not a simple free), even if you allocate the object in the stack *you still need to remember to call the "destructor" function*. In C++ the destructor is automatically called by the compiler if you allocate it in the stack. You don't need to explicitly call the destructor (actually you shouldn't!). Also, if your object is composed by many subobjects, the compiler calls the destructors recursively, in C you have to do it by hand. In short, C++ handles stack allocated objects better than C, because of destructors.
ah, I see it now
I see what you‚Äôre saying. I thought you meant there was some miracle-trick to where you could use something with a non-compile-time-constant size. GNUly compilers do at least have the ability to do unload-time and return-time cleanup in plain C, former with `__attribute__((__destructor__))` on a function and latter with `__attribute__((__cleanup__(func_to_call)))` on a local variable, both using the same mechanisms as C++ did so (e.g.) a cleanup function would still be called if called-into C++ code threw an exception through your C. Nowhere near as convenient or clean(-ish) as C++ dtors, but a little easier to slap together an a proper dtor scheme with that than in proper-C.
Look at embedded programming. A lot of that is still done in C. Source: current job
C is all I ever needed to make anything happen, but then again I only ever wrote embedded and natively-running desktop programs that were highly performance-sensitive and needed a fine touch to milk every last CPU cycle out of the machine. If you don't care about machines, or what they are doing, then yea the 'higher' languages are there for that.
X-Post referenced from [/r/fuzzing](http://np.reddit.com/r/fuzzing) by /u/grajagandev [Repository for materials of "Modern fuzzing of C/C++ Projects" workshop](http://np.reddit.com/r/fuzzing/comments/6l0u2f/repository_for_materials_of_modern_fuzzing_of_cc/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Welcome to the systems programmer and embedded/firmware development crowd. C's not flashy but it runs the world. If you like this kind of work you should definitely stick with C, you won't hurt for work though it may not be the kind of Javascript-fueled, app and web centric programming your peers gravitate towards.
I understand what you mean. However, C gets annoying once you need generics (relevant for library development) and use void * or macros. It's hacky, inconvenient and unsafe. Copy &amp; pasting like legacy OpenGL did it (glVertex2f, glVertex2i, glVertex2d, glVertex3f, glVertex3i, glVertex3d... you get the idea) is a solution but have fun remembering to apply modifications in one function to the others as well. I like to think I get my memory management right and Valgrind doesn't seem to complain but I would probably mess up sooner or later in ways I don't understand yet. Also, the standard library is suboptimal. I mean it's fun and interesting to reimplement your own data structures but once you have done it a few times... Sometimes I just want an std::vector and be done with it. I have written my own C vector (i.e. dynamic/flexible array) implementation using malloc where I would allocate a new array and memcpy the old array into the new one. It outperformed std::vector in special cases, for example I'd choose a bigger allocation size so I'd have fewer allocations, so my vector would basically converge to an array, but I wasn't able to do that in the general case for all possible inputs and data. In addition to that, there are many useful C++ libraries out there which you can't use from C without writing a wrapper if there is none (have fun with that), while you can use practically every C library from C++. I used pure C (as my main language) for some time but my current project is in C++. I generally avoid obscure features and program with the KISS principle in mind (i.e. I don't use advanced features unless it provides significant benefit). I would also not combine C functions with C++ constructs (stuff like memcpy on std::string, which is AFAIK implementation-defined because you can't rely on the internal data being continuous) since that apparently opens the gates of hell and according to some C++ fanboys, that isn't necessary anyway.. I don't know about that. So far, I haven't been burned too hard by it and I think it's sometimes actually more readable than C. Use all this template and OOP stuff only if you have to. EDIT: By the way, if you like doing things yourself, why stop at C? You can write everything in Assembly as well. ;) That's actually on my list... writing a simple 2D game using Assembly and SDL2. EDIT 2: Actually, I looked at my vector implementation again and had the idea of introducing a new size_t member in my vector struct that stores the amount of elements that get allocated every time the vector grows. So by exposing more complexity to the user of my implementation, I could mitigate the drawback of inefficient allocation growth in the general case.
for assembly i highly recommend using an older platform like the c64 or amiga. There's a complete tetris game which you can follow along [here](https://devdef.blogspot.nl/2015/02/tetris-in-6502-assembler-part-1.html) and for the amiga i found the tutorial from [scoopex](https://www.youtube.com/watch?v=p83QUZ1-P10&amp;list=PLc3ltHgmiidpK-s0eP5hTKJnjdTHz0_bW)(ah the good old times! :) very interesting. It's way more fun than just calling predefined functions in modern times imho.
SECTION | CONTENT :--|:-- Title | Amiga Hardware Programming 1 - Use the Assembler and wait for left click Description | The first steps from getting an Amiga or emulator to run an Assembler, to something that moves on the screen! :) All you need to get started, including the sources, is on http://coppershade.org/articles/More!/Downloads/ - I've used Asm-One 1.02+, but you can also use 1.20, 1.48, or AsmPro - or AsmTwo (which is basically Asm-One 1.02+++ :)) The Asm-One 1.02 Manual and the Amiga System Programmer's Guide are available as PDF on archive.org - linked from Coppershade. May the source be with you! ... Length | 0:02:53 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
Thanks for the recommendation. Do you also have experience with DOS Assembly programming? How was that?
only minimal... i played a bit with dos 'debug' to be able to figure out where the game digger stored it's life counter. That was on an xt machine but i found the segmentation highly confusing. That pc was my dad's while i had an amiga at the time which was imho much better. Well, i used it mostly for gaming but 68k assembler is really neat compared to x86.
Many thanks! It worked with mingw64.exe! :)
C gives you all power without intermediaries. Offers you the harsh reality without stupid abstractions for lazy programmers.
I'm having trouble getting my head around the buikd system. autotools vs plain make vs ninja vs meson vs etc... How did you get past that?
&gt; I would also not combine C functions with C++ constructs (stuff like memcpy on std::string, which is AFAIK implementation-defined because you can't rely on the internal data being continuous) since that apparently opens the gates of hell and according to some C++ fanboys, that isn't necessary anyway. If you do need to access a C++ string in a C context you can call `std::string::c_str()` on it.
You could also consider learning something like AVR assembly, which has some modern-day relevance and is fairly simple. Although x86-64 assembly has a ridiculous number of opcodes and quite a few gotchas, it's worth learning enough to be able to follow what the compiler outputs, which only uses a small subset of the opcodes (because the hybrid CISC/RISC architecture of modern processors means there isn't much point to using that many crazy instructions). This is because at some point, you'll write something with undefined behaviour, and need to understand what it actually did.
Yes, reading is fine but according to [cppreference.com](http://en.cppreference.com/w/cpp/string/basic_string/c_str) you may not modify the data returned by c_str(). Quoting: &gt; Writing to the character array accessed through c_str() is undefined behavior. Also, &gt; Returns a pointer to a null-terminated character array with data equivalent to those stored in the string. does not imply that the pointer returned from c_str() is a pointer to the *actual* data of std::string. That would be strange, given that std::string data apparently may be non-continuous, so how would you get a raw C array from that?
Yes, if you need to go the other way, C string to C++ string, you should create a new C++ string and pass the C string to the `std::string(const char *s)` constructor.
That's what I meant with *not* using C functions with C++ constructs. :) The way you suggested is the idiomatic one and I suspect a lot of trouble in C++ starts with actually trying to do funny stuff like using memcpy to modify/create an std::string.
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://i.imgur.com/EVKJvRI.jpg)
Since you are printing too many newline characters you should locate all the lines which print a newline and determine whether it is correct
jedwardsol beat me to it ... but here are some bonus tips: Each number is four or five characters wide. It would make sense to make the decimal points in each column line up. Read up on printf format strings to find out how to automatically put a space in the tens place for numbers &lt; 10.00. Now that all numbers take up 5 characters, this leaves a single space in between columns to make the total column 6 spaces wide. &gt; if ( i == 9 || i == 19 || i == 29 || i == 39 || i == 49 || i == 59 || i == 69 || i == 79 || i == 89 || i == 99) This is needlessly laborious ... &gt; //(((i+1)%10) == 0); ... oh, you already were on the right track there. Looks like it should work. Could be simpler, though: i % 10 == 9. &gt; system("pause"); If your teacher told you to do this, fair enough. But in case this is the result of googling how to wait for user input, I'd take that line out. It's non-portable (only works on Windows), and spawning a process to do something this simple is a bit silly anyway. I guess the problem was that the window with the output vanished immediately? Just run your program from the command line instead. P.S.: Thanks for caring about proper formatting! `&lt;rant&gt;`There's too much unreadable gibberish here.`&lt;/rant&gt;` Screenshotting code would be a bad idea for a whole boatload of reasons. You did the right thing anyway, but if you ever can't get code to show up properly, I'd recommend putting it in a suitable pastebin (you can easily find ones with nice syntax highlighting and line numbering) and linking to that.
&gt; I don't understand why you're being downvoted. Probably because this is a C sub not a C++ and so the advice could be construed as disingenuous. 
Feelings give him a C of challenge. 
I also love C like a motherfucker! Don't get me wrong, when at work, I mainly work with python to "just get shit done", but I love C and the feeling it gives me that I'm making something fucking awesome... A tip: try to create a software to do factorial in a function that call herself. The first time I saw one I was fucking mental! It ia beautiful, gorgeous, magnific!
Thank you foe your help, ill update you once im able to get it to work.
For*
I just want to add that gcc is known for not always warning for uninitialized variables. There are many bug reports filed for this behavior. Maybe you want to take a look at [Better Uninitialized Warnings](https://gcc.gnu.org/wiki/Better_Uninitialized_Warnings). Clang seems to do a better job at detecting uninitialized variables in my experience (with -Wall).
I think I'll just return void then. `2 * SHA512_DIGEST_LENGTH + 1` does make sense for the size... Regarding the buffer overflow. If I declare two arrays one after another are those back to back in the memory? if so then could it be that he fills `K1asHex` with the first hash, overflows and then when i print `K2asHex` he just starts in the "middle" of `K1asHex`? I think I originally put 6 in there since I only care about the first 6 Byte of the Hash, which is still wrong since I'd need `2 * 6 + 1` or `2 * MAX_BYTES_TO_MATCH + 1`. &gt; Also, just in case you care: Your meat-name is tagged in your file and in your github account name, so you‚Äôre leaking identity. Thanks for letting me know. But I'll change my reddit in the near future anyway so it's not that important. 
Because of [data structure alignment](https://en.wikipedia.org/wiki/Data_structure_alignment) I guess.
**Data structure alignment** Data structure alignment is the way data is arranged and accessed in computer memory. It consists of two separate but related issues: data alignment and data structure padding. When a modern computer reads from or writes to a memory address, it will do this in word sized chunks (e.g. 4 byte chunks on a 32-bit system) or larger. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I'm sorry to all the Linux users here, I've been testing on Mac the whole time. Just fixed the program for Linux users.
Yup, that `double` is 8 bytes wide, so the compiler is going to give it 8-byte alignment by placing padding after `a`. Similarly, the 10-byte `name` field is going to be padded out to 16 bytes to give the whole struct 8-byte alignment.
`a` needs 4 byte alignment. `b` needs 8. So the offset of `b` inside the struct must be 8. The union needs 4 byte alignment because of `c`, but must be at least 10 bytes long because of `name`, but is actually 12 because of the alignment (we'll come to that later, it doesn't change anything). The offset of the union in the struct is 16 (because `b` is aligned at 8 and 8 bytes long), the end of the union is at least at 28 (16+12). The size of the struct (and a union) must be a multiple of the alignment of its most strictly aligned member, which is `b` with 8. 28 is not a multiple of 8, the nearest is 32. So that's the size of the struct. The document describing those rules is here: https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf
No. `name` only has to be 10 bytes and it is. The union `x` is 12 bytes.
Technically true, but what I meant was that `name` is what's responsible for the whole struct being 32 bytes instead of 24 bytes. If `sizeof(name) &lt;= 8`, then the struct would instead be 24 bytes.
Just a note for those who weren't aware of the continuous memory problem with strings and see this: after C++11 strings are guaranteed to be continuous.
Most C and C++ programmers who are looking for live help would do so on one of the few IRC channels that are pretty popular. It is a nice gesture to create a discord, but don't expect it to be too popular for this reason.
I just ignored everything and used make. It works everywhere and is simple.
&gt; If I declare two arrays one after another are those back to back in the memory? This is a question with no fixed answer. If you declare them in a `struct`, then yes, modulo padding. If you declare them as globals, then it‚Äôs undefined but the compiler will probably just dump them one after another unless there‚Äôs some hot/cold analysis factored in. If you declare them on the stack it‚Äôs again undefined, but the compiler is much more likely to put them anywhere it feels like. The slightest optimization could shift, reorder, or eliminate them. Because access outside the bounds of the array is undefined behavior, and because the array arrangement is undefined, I can‚Äôt say for sure what happened, especially if the compiler/linker could see through the function call at all. Certainly one of the strings was NUL-terminated too early, but any number of things could‚Äôve done that, including just call/return since code addresses typically have at least one zero byte. You could always disassemble it and find out for sure, of course, or single-step it in the debugger.
That type-punning example is a bit off as it's one that isn't practical. Why would you store a union double value (typically 8 bytes memory size) and then return the union integer (typically 4 bytes memory size) in function f()? That's not useful in anyway. I really hate stupid examples like that as those who aren't familiar with C programming will come across it and get confused thinking it is doing something important or useful to learn from that they should use in their own code. So they'll get frustrated with trying to understand the point of the example which there isn't one in cases like that other than to show what the dialect will let you get away with. However if the union used float instead of double it would have made sense for cases when you need to say for example send a float down a serial protocol that traditionally only supported integers and on the receiving end you know it'll be a float for this specific value so you do the reverse, as I've done in the past. 
Good point. I usually try to think about such things, but I was lazy and took this example directly from the GCC manual... I'll update the blog post.
Embrace your love for strong types, awareness of memory allocations, etc. BTW, there will always be a future in C, but you may also find you enjoy Rust. (Bonus: your high-level/dynamically-typed/garbage-collected friends will probably dislike it, also!)
finally got my code to work properly https://gyazo.com/e9edccc254a471aa1053f9abb6ee114f
Hi, I'm a bot that fixes Gyazo images for mobile users. Direct link: https://i.gyazo.com/e9edccc254a471aa1053f9abb6ee114f.png Imgur mirror: http://i.imgur.com/OBtIEHp.png ^^[Sourcev2](https://github.com/Ptomerty/GyazoBot) ^^| ^^[Why?](https://github.com/Ptomerty/GyazoBot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/u/derpherp128) ^^| ^^[leavemealone](https://np.reddit.com/message/compose/?to=Gyazo_Bot&amp;subject=ignoreme&amp;message=ignoreme)
We have 100+ members and it was created last night 11pm 
You can dynamically allocate memory according to the number of variables you need to store into the array. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int *p; int dim, i; scanf("%d", &amp;dim); p = (int*) malloc(dim * sizeof(int)); for(i=0; i&lt;dim; i++){ fscanf("%d", &amp;p[i]); } free(p); } 
IIRC, Discord is a software dedicated to gaming purposes. C programming is completely unrelated, and many of us prefer to: 1) Search for similar issues on the Internet 2) Search StackOverflow 3) Ask on StackOverflow But it's a good initiative to help others!
Together Java, the discord for r/learningJava has helped over 1K+ people.
&gt;If I were you, I'll take a look at the "Hunt to Wumpus" game, or at least a simplified version. I'd also suggest an [NCURSES based Game Of Life](https://github.com/Garuda1/gol) I did this ages ago. It's very rewarding, takes no longer than an afternoon, and if you're into challenges (I'm not... check my repo) you can implement new rules, to expand the game even more! My implementation saved a lot of memory by using each bit in a one dimensional array as a variable, effectively creating a matrix from an array. This project is, I think, amazing for a begginer, as one can go around those tricks and make a dumb GOL, or follow the challenger's path and create a diabolically optimized and arcanic piece of software.
isn't that more of a math problem? if it's just about precision, maybe https://gmplib.org can help you
It's definitely a CS problem. Never in maths you'll see someone using logarithm approximations instead of logarithms themselves. gmplib does help with precision, but at the expense of insane computation times, memory usage, and verbose code compared to other solutions. The point here is to discussion the best way to implement a logarithm function in C. My first thoughts were to use the `ln(a*b) == ln(a) + ln(b)` relation, but I'm not sure if that's a good idea as the computation time would increase.
Consider adding some `printf` statements that use `offsetof` and `__alignof__` to understand what's going on better. (Note that `__alignof__` is a GCC extension and isn't supported in all compilers.) Edit: or use C11, `stdalign.h`, and you can use `alignof` as standard.
Is this memes?
:)
Increase by how long? What's the input size? Is there a noticable (more than a couple of seconds) change with using gmp or some other method? Algorithms have their ups and downs from various use-cases. For example, quicksort works well for most things, but if you need to have determined time without a limit on space, you might use merge sort instead.
You almost got it, since ln(2*a) = ln(2) + ln(a), you can precompute ln(2) and then find the most accurate range for the taylor ln aproximation, let's say below 1 like the exp example, and then the code would be while a&gt;1.0 { a = a/2.0; result += ln2; } ~~Well this actually feels like cheating because if you change 1.0 to 0.0000001, the taylor series step becomes innecessary.~~ (there exists an optimization like that but it's too long to fit in this margin). Whatever, I don't know if this will improve accuracy, so here are some tips about performance: I don't know how good is your implementation of pow but `pow(-1, i)` looks like a bad idea, just use a temporal variable and do `sign = -sign;` every loop or something. The same for the other pow, if you look closely you call pow(x,1), then pow(x,2), then pow(x,3). You can transform this into `xtmp = xtmp*x;`.
Personally, this helped me a lot. http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/
Hey champ, mathematician here. Just wanted to point out that these are largely considered mathematical issues by working numerical mathematicians. Entire theses are written about slightly improving rational approximants for exactly these kinds of computations. 
The input size is a constant (128 bits floating point) it's just that gmp won't help unless I decide to crank up the `iterations` argument to ridiculous values, which still yields inaccurate results really quickly. This isn't a DSA question, really
Thanks for the detailed answer! This solution seems to work quite well, except for one little thing: `x` is reduced to [0,1], but when `x` reaches values close to 0 the results get really nasty even woth ridiculous Taylor series... 
Please keep the discussion civil in here.
Note that instead of `pow(x,y) * k`, you should really use a [Horner scheme](https://en.wikipedia.org/wiki/Horner%27s_method). It's faster and the precision is better.
**Horner's method** In mathematics, Horner's method (also known as Horner scheme in the UK or Horner's rule in the U.S.) is either of two things: an algorithm for calculating polynomials, which consists of transforming the monomial form into a computationally efficient form; or a method for approximating the roots of a polynomial. The latter is also known as Ruffini‚ÄìHorner's method. These methods are named after the British mathematician William George Horner, although they were known before him by Paolo Ruffini and, six hundred years earlier, by the Chinese mathematician Qin Jiushao. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I recommend you to compute the binary logarithm instead (e.g. [like this](https://en.wikipedia.org/wiki/Binary_logarithm#Calculation)) and then convert the base of the logarithm by multiplying with a constant. You can efficiently scale the argument using `frexpl` from `math.h`. Also see [this thread](https://www.reddit.com/r/C_Programming/comments/67a1f0/compute_expx_with_6_digits_of_accuracy_without/) where i provided an x86 assembly implementation of the exponential function. You can implement logarithms similarly using the `fyl2x` (compute `y * log2(x)`) instruction.
Out of curiosity, what CPU are you using that supports a 128 bit floating point type?
The hardest part of C definitely isn't the syntax. I'd assume that any exam on C would mostly be about how the computer actually stores data in memory and other stuff closer to the 'metal'.
While Pascal will give you some solid background (If you have implemented some basic data structures like linked list, where you got data from txt file packing it in some structure you defined), I think with C things get hairy because you go level beyond that. It's not just about syntax, nor even pointers, it's actually about how computer works. It took me 2 years believe it or not to finally have that eureka moment with C. While it won't take you nearly as long as that to pass the exam, if you continue doing work in C you we'll see what I talking about. Exam you can prepare in a month or so without too much hassle. But in order to really understand it you will have to stretch your goals. What helped me personally the most is reading about UNIX and getting into Systems Programming. There I learned the most about computer and how data gets stored and flows. So grab a book (K&amp;R for example, or some tutorial on internet if you prefer it), start small, learn basics, go over exams and similar questions like on exam, and you'll be good to go. You have more than enough time.
Im in electrical engineering and this is a second semester exam so while i am aware that C is way more complex then pascal especially with the memory allocation problems im assuming this is relatively basic level programming. Thanks for the answer tho ill be definitely be learning a lot more about it over the next 4 years but for now i have to pass the exam so i dont fail the year. I cant really only do C since i have like 4 more exams that are probably require more effort to prepare so im just trying to make a timetable for myself. Thanks for the answer though i appreciate it!
Surfacially, this looks very similar to what AFL (American fuzzy lop) does.
You know, not long ago you could replace `muslim` with `christian` in the code and it would be just as true. Perhaps we should try to understand how christianity became more tolerant and try apply the same (or something better) to islamism, so they become (more) tolerant too.
Intel Core 2 Duo U7500 Yeah, it's an old brick, but suprisingly it still works! EDIT: Realised the 128 bits are in fact 64+16 bits in 8 bytes alignment... 
That only has 80 bit via the x87 fpu. Anything more has to be emulated in software. And depending on OS and compiler, long double might only be 64 bits like a normal double, not that 80 bit extended precision type. Edit: and let's not even get into other issues with the fpu. If you want more than double precision, use mpfr or gmp or the like.
Hmm that's interesting, I had exact same courses at the same time as you... and you said on some other post that you are interested in signals and systems and how hard it is to get there, which is basically the story at the faculty I was at... May I ask you what faculty are you enrolled in currently? :)
The general political truth is that you can do the replacement for any government seeking to expand itself by force. But what you cannot do is find any authoritative NT source to prop up the C source code core loop for Christianity. At best you can only say "The Pope told us to do it." (a thousand years ago). Meanwhile, for Islam, you have more than a few authoritative references in the Quran and Hadith that are the essence of the core loop. This makes Islam particularly different, given that none of these source texts have been abrogated - i.e. they still carry all the weight they did 1400 years ago - and that's the problem.
**Bill Warner, PhD: Jihad vs Crusades** - https://www.youtube.com/watch?v=I_To-cV94Bo This is for those of you who've been falsely led to believe that the Crusades were somehow an equity for the history of Jihad. The science and the historical data do not lie, as the scholar in the video adequately explains.
Yes but you can find OT sources to prop the Christianity core loop. And as far as I understand, the OT is still very relevant to Christianity. The point you make about governments seeking expansion is the real root of this. Once the religion is adopted by the government as a mean to control it's subjects (and drive expansion), you get the same thing. Judaism had it's day with King David and many others. As did Egypt, Greece, and almost every conqueror in history (with the exception perhaps of Ancient Rome, which some say is why they managed to create such a large empire for so long). They all adopted *and changed* religions to suit themselves and their objectives. The real difference in Christianity is that the changes made by the Roman Church were not adopted in the Bible, but could have been easily done (as they changed *a lot* the biblical texts).
You just compared Apples to Oranges. Here's why. In your mind, the OT is somehow an equity with anything in Islam. At face value we can agree (mostly). But what you cannot do is find any group of Jews or Christians who are living out the law of Moses word for word in it's original Bronze Age form. And this scientific fact breaks everything you're motivated to say using the OT as fuel to indict Jews and/or Christians. Meanwhile, would you care to discuss how many places in this world are currently practicing the 1400 year old psychological equivalent of the OT known as Sharia - that is powered by the textual authority of the Quran and Hadith? Rome destroyed Jerusalem and the last OT temple in AD70 and that tradition has not returned in 2K years. And yet you just behaved in a way incongruent with history as if that just didn't matter and the Bronze Age tradition of Moses is still everywhere in the western world. You need to upgrade your thinking.
As long as it takes but no longer.
Can we assume you've learned assembly?
Also, since nobody has mentioned it yet, since you're using long double, you should use functions like `powl()` that take and return them (or the tgmath.h equivalents). Otherwise you're loosing precision.
Short history note: as far as I know, they are Google's sanitizers that were build as plugins and then mainlined. Then ported into GCC. As of Clang 4, maybe earlier, leak sanitizer was folded into address sanitizer.
&gt; And this scientific fact breaks everything you're motivated to say using the OT as fuel to indict Jews and/or Christians. How is this a ‚Äúscientific fact?‚Äù I don't see the scientific method being used anywhere. It also doesn't follow how it is impossible for such a group of people to exist. It also doesn't follow how this makes the claims in the old testament any less egregious. Note that in much the same way, a great amount of the worlds muslims have a pretty *laissez-faire* attitude about their religion and holy book, seeing it more as a moral guideline than an actual law.
Like most Microsoft publications, you have to click around on their links to try and figure out what they're talking about. Even then, you won't find out what they're talking about cause the result is like, "What's an Algebraic Effect?" -&gt; "An Algebraic Effect is an Algebraic Effect".
Wildly inappropriate. Why is `earth` a global variable, aside from the obvious pun? Make it local and pass it to `wage_islamic_jihad()`. Then again, that's assuming that function (which isn't declared, defined, or seemingly included anywhere) is meant to alter the contents of `earth`. As it's written, this program has no reasonable end condition, since we have no way of knowing how `earth` is modified or if it is at all. Presumably, `wage_islamic_jihad()` should attempt to conform `earth` with `muslim` based on the condition of your `while`, but this would mean that `return earth;` is returning `1` instead of `0` or `EXIT_SUCCESS`. Your best bet is probably to change your `#define`s so that `muslim` evaluates to `0` and `non_muslim` evaluates to `1`. Based on the obvious implications of this post that's probably how you see the world anyway, so I'm more than a little confused as to why you chose the values you did. In short, your code is sloppy, poorly documented, and is in dire need of more than just a few cosmetic touch-ups. Come back when you have something that will at least compile, or with specific questions as to why it won't.
I made a claim that meets the criteria for a null-hypothesis that can be falsified by finding instances of Jews or Christians practicing the Bronze Age form of the law of Moses word for word. The claim is scientific and falsifiable.
Then `long double` is probably an 80 bit floating point number. `sizeof(long double)` returns 16 because of padding.
:) I was hoping somebody would actually talk source code. Thx for the reply. I appreciate it. 1) It will compile. But will not link without the code for `wage_islamic_jihad()`. 2) Islam is famous for monotheism (i.e. God is 1), and thus the `#define` as it is. I wanted terseness in the interest of readability for those who do not understand C as we do. 3) Yes `earth` is global data and yes the pun is wanted in part. 4) In the context of humans getting out into space, you're correct, the code would better reflect this from the POV of islam where the planet (`'earth` or `mars`, etc.) is a param to the jihad function. 5) That the normal return code behavior is a (0) as the status quo exit condition, carries the desired impact to the overall message here given that an an actual exit will return a 1. 6) In a greater systems context, the Jihad process will complete or it will get killed by a process with more systems privs. I love your final sentence because of the pure focus on the code itself, not batting an eye to the political/religion involved. Thx.
&gt; It will compile. This depends on your standard, compiler, and flags. C89 allows this behavior for backwards compatibility. C99 and C11 don't, but most compilers will ignore it unless you have proper flags set. I never said it wouldn't compile, but just because it can compile doesn't mean it should be written that way; see my final point below. &gt; readability for those who do not understand C as we do. This is the C_Programming subreddit, you should assume everyone here knows C. If you intend to share this with a larger audience that doesn't understand C then I recommend not writing this as C source. &gt; [Points 3 through 6] Jokes are not reasonable justification for poor programming.
Thanks, valgrind looks like a pretty good solution.
&gt; laissez-faire Your laissez-faire comment is accurate for most Muslims living in America. My neighbor is a Somalia born Muslim - who BTW agrees with the core loop of islam.c. He left Somalia because of how violent it was (because of a literal interpretation of his religion). His attitude is anything but laissez-faire. He believes every word of the Quran. But he is currently benefitting from a nation with a healthy 1st amendment. And his family exhibits all of the classical signs of traditional old-school Islam including the manner of dress for the women. The main problem with the laissez-faire argument is that it asks us to ignore the whole scope of the issue because the vast majority of Muslims (in the west) behave in a manner that conforms with your laissez-faire comment. What is ignored is the statistically significant higher probability that any random Muslim will eventually decide to act upon the literal form of the Quran and Hadith. That skew is demonstrably greater than any statisic for a Jew or Christian who suddenly decides to live the OT in a literal fashion. Arguing that any Jew or Christian could do this is not the same as measured data that indicates they do not (near zero value), compared to the very non-zero value for a Muslims world-wide. A yield of only 1 in a million Muslims per year, choosing to go full Jihadi and act upon the literal words of the Quran and Hadith, can disrupt all of civilization. Europe is feeling the truth of this right now. The Muslim meme has never been abrogated in it's 1400 year history, the same way the Judaic meme was in AD70, or the Catholic meme was by the protestant reformation and American revolution. The capital of spiritual Islam (Mecca) has never been overthrown, unlike Jerusalem and Rome have been several times. And the holy texts have never been abrogated - i.e. Islam does not have a New Testament. From it's POV, it is the final solution for the Earth and you can find the Imams and teachers saying exactly this every day in Mosques all over the world. - Video Recorded Inside a Muslim Faith School in the UK - https://www.youtube.com/watch?v=UMwwvDcR-VE 
&gt; or the Catholic meme was by the protestant reformation and American revolution Note that you got something wrong here. Luther published his theses because he was for treating the bible as the literal word of god. He protested the practice of the catholic church that treated the bible more like a moral guideline that an absolute law. In a certain sense, Luther made Christianity worse for his followers as you can clearly see in the batshit-insane evangelicals in the bible belt. On the other hand, protestant Christianity has mellowed out in Germany, leaving a very lenient religion where dogma becomes less and less important.
Try passing `-lsqlite3` when linking, e.g. cc -o prob1 prob1.c -lsqlite3 Note that libraries need to be passed as the last arguments in the linker invocation. This tells the compiler to look for a library named `libsqlite3.a` or `libsqlite3.dylib` (`libsqlite3.so` on Linux or `sqlite3.dll` on Windows) in the usual places (i.e. where the OS usually places libraries) and link it into your program. It should probably be in `/usr/lib`. This is all that is needed to link with a library if the library is in the usual places. If it isn't, you need to pass the path where the library is to a `-L` operand, i.e. if the library is in `/usr/local/lib`, type cc -L/usr/local/lib -o prob1 prob1.c -lsqlite3
Yes Luther did exactly as you've described. But noticeably absent from his view was a tenet of faith that provided a sole means of salvation via murder suicide as is the case in Islam. It's not a crime to be dogmatic about some religious view. Only Islam has a Dark Gospel where to gain guaranteed salvation, you must commit murder suicide. - https://sunnah.com/bukhari/56/6 - https://sunnah.com/bukhari/63/155 If you care to see the truth of this laid out in a logical statistical manner, watch this video that describes why the problem is NOT going to just go away. - https://www.youtube.com/watch?v=k6ePVxRLDM0 This is the single best explanation for why the laissez-faire argument fails completely in the context of Islam. 
That worked - thanks! What if the library wasn't on my computer? Would I generally download the source code for the .c library and .h header file, then compile the library, put it in the same folder with my code and then include that same linking command "-lsqlite3"?
:) I suppose the single greatest weakness is the absence of a forward declaration: `void wage_islamic_jihad();` somewhere above `main`.
 Yeah, that would work. Though, you need to pass `-L.` so the compiler looks right here for the library and you need to pass `-I.` so `&lt;sqlite3.h&gt;` is found. When you compile sqlite3, you get an object file `sqlite3.o` which you could link into a shared library or pack into a static library, but you can also link it in directly like this: cc -o foo foo.c sqlite3.o You can also link static libraries directly like this: cc -o foo foo.c libsqlite3.a but that is not recommended as this will link in all of `libsqlite3.a` even if only a part is needed, though for the specific case of sqlite3, there shouldn't be a difference. 
Ok great, this was very helpful.
&gt; null - hypothesis *noise:* null-hypothesis should be NULL POINTER
Coming from Pascal, the syntax of C won't be your biggest challenge. The concept of *pointers* might be. Pointers to primitives. Pointers to structs. Pointers to pointers. Pointers to functions. Etc.
:) haha! ... awesome. So true.
Or right. I assumed it was 128bits... It's because it's aligned on 8 bytes, right ? In any case, 80bits is more than enough in my opinion.
There is an image meme for islam.c - http://i.imgur.com/rrdTNhR.png 
it's amazing. Learning how to use valgrind and gdb will make your life better. Trust me. Debugging becomes fun. 
strangest post ive seen on this sub in a while
&gt; C++ was written to help professional C# developers learn modern C++ programming. The aim of this book is to leverage your existing C# knowledge in order to expand your skills. Sure sounds fake to me.
Looks like it would be worth buying for the comedy.
A bit too verbose for my taste but it's a pretty good introduction (actually more than an introduction).
I used it for a class, and it's the most helpful C book I've found so far.
It's the best.
I'm not really sure what this is supposed to be, but it makes me...extremely tired. I suppose I was naive to think it was going to be interesting. Or about C. There's a reason I stay off the big subreddits.
[...]On the other hand, "C a modern approach" is incredible explicit, and have quite a bit of overhead making sure there's no C stone left unturned, so if you come from Javascript of have some prior modern knowledge of any programming language, you will probably find the book too damm verbose (the book is 805 pages long), but in my experience so far, I'm already at Chapter 10 (Program organization), and I'm starting to have enough confidence in myself to feel somewhat familiar in C. REMEMBER that I had zero idea two months ago. But that's because the book really tries to explain everything to the last detail and that's an incredible big plus when you start from square zero. So in my opinion, yes, "C a modern Approach" IS a fantastic resource to learn C, and I will and must recommend it to anyone interested in C, even if its a totally beginner, since I can attest the validity of the method. And I will recommend Modern C well over K&amp;R which I find it quite advanced, condensed, and outdated method to learn real-world usable C (and by actual I mean C89)
I started with it and learned so much. Explanations are easy to understand and there are good examples.
It's actually all right. But I still recommend this approach for beginners: Start reading "Absolute beginners guide to C". // Read it through in one sitting. It's easy digestible, not long, and gives you a perfect start to understanding what C is. Optionally you can write the sample code shown, for better understanding. There is no exercises, but it's well good put together. Next "The C Programming Language 2nd edition (kernighan, Ritchie)" // Go through it slowly and with attention. Do EVERY exercise, and than do them again, and if you can't do it in your sleep, do the same exercise again. When you done with this, which can take some time, you'll have a sound foundation. 
https://www.amazon.co.uk/d/cka/C-Programming-Modern-Approach-K-N-King/0393979504/ref=sr_1_4?ie=UTF8&amp;qid=1499335785&amp;sr=8-4&amp;keywords=c+programming+a+modern+approach this book?
Yup
cool, thanks. 
Is this the "Absolute beginners guide to C" you were referring to? [https://www.amazon.com/Absolute-Beginners-Guide-C-2nd/dp/0672305100/](https://www.amazon.com/Absolute-Beginners-Guide-C-2nd/dp/0672305100/) 
Yes!
Nice.
Clean book recommended
It's how I learned C. Do the exercises they help a lot
Thank you, LidarAccuracy!
The post is about reducing the core loop of Islam to simple C source code. Was that not clear in the OP?
&gt; Optionally you can write the sample code shown, for better understanding. Perhaps not every sample, but I find typing them out sets the knowledge a bit firmer.
Are you able to read the status register or dose the return 0xFF as well? 
By far, my favorite C book. Learned C from this book while in school and still use it occasionally in my career. 
[K](https://www.youtube.com/watch?v=MFeaQduiNoI)
The status register always returns a zero. I currently have a scope probe set up. The chip select is triggering and the SPI_SCK is active over the the period of the chip select being low. But when I hook the scope probe to the MISO and the MOSI GPIO pins, the MISO is always high and the MOSI is always low. I'm thinking now that SPI is not configured correctly.
Do yourself a favor and get a [logic analyzer](https://www.saleae.com/) if you're going to be debugging SPI stuff. You should be able to find working SPI demo code for your platform. Doesn't matter what kind of external device the demo is for, you just need something to get the port set up properly first.
Thank you, I'll look into it.
Dude. Read your code.
&gt; for (i = 0; i &lt; 100; i++){ sum = sum + randnum[i]; avg = (float)sum / i; } What do you think this code is doing? It sure isn't calculating the average.
You never print out the average after calculating it, you're printing it before generating the array.
so the first for loop generates the array, should i just get rid of the second loop since it would be redundant?
When do you print the average and when do you compute it? 
i had the print avg on line 11 but to calculate the average it was after i set the printf statement. i just adjusted the placement of my printf and that shouldve fixed my problem
this better? im actually getting now what i think should be the correct average #include &lt;stdio.h&gt; int main () { int randnum[100] = {0}; int i; srand(time(NULL)); float avg; int sum = 0; printf("Random values\n"); for (i = 0; i &lt; 100; i++){ randnum[i] = (rand() % 101 +1); printf("%d \n", randnum[i]); } for (i = 0; i &lt; 100; i++){ sum = sum + randnum[i]; avg = (float)sum / i; } printf("Average of all random values %.2f\n", avg); system("pause"); return 0; }
then i solved my problem now? #include &lt;stdio.h&gt; int main () { int randnum[100] = {0}; int i; srand(time(NULL)); float avg; int sum = 0; printf("Random values\n"); for (i = 0; i &lt; 100; i++){ randnum[i] = (rand() % 101 +1); printf("%d \n", randnum[i]); } for (i = 0; i &lt; 100; i++){ sum = sum + randnum[i]; avg = (float)sum / i; } printf("Average of all random values %.2f\n", avg); system("pause"); return 0; }
Looks better. Other things: * For `time()`, you need to include `time.h`. * For `srand()` and `rand()`, you need to include `stdlib.h`. * You're calculating the average (variable `avg`) at every iteration in the last loop, but you never use/read it in the loop, so it is more efficient to put it after the loop (but before printing it, because you use it there). * You may want to use the number `100` directly instead of using `i` when calculating the average. Not necessary, but I think it better to say the number explicitly, rather than implicit.
Try replacing this line: randnum[i] = (rand() % 101 +1); With [this](https://xkcd.com/221/): randnum[i] = 4; And see if you get the results you expect
You fixed **a** problem. Does your program work the way you expect now?
&gt; like 1 rolled 4 times printf("The value [%d] was rolled %d times.\n", i+1,dice[i]); You're printing the value of the 1st roll, not counting the number of 1's rolled.
Yes, it runs, no errors show up and the avg calculates
How would i be able to count all the rolls, add count++, but how can i add it so its syntax correct
Multiple ways. You could count the number of times 1, 2, etc. appear in that array... Or change the design to have an array of 6 ints, incrementing the appropriate one each time you generate a random number, and then display those totals.
You are calculating a new value for "avg" on every iteration of the loop (i.e. 100 times). There's no reason to do it more than once.
Nope. :( Your final result is sum / 99 when it should be sum / 100.
Then i should have sum / 100 (place 100 constant) instead of sum / i?
Yap. And you can place it after the loop, no point in computing it over and over again.
Ok, thank you!
logic analyzers are important, albeit expensive, pieces of debugging equipment when one leaves the realm of logical programming to dwell into the depths of embedded programming. I worked with one once to debug RS-232 connections. They're truly amazing devices.
wow.. amazing work for someone so young. very clean and manageable code. interesting project choices as well! a pet peeve of mine is functions that are way too long. you nailed it. good commenting as well. i had assignments in college to build an OS, raytracer, and C library. in college. at princeton. one of my professors was kernighan. so I'd say you have some serious talent. btw.. C is my favorite language too! love K&amp;R.
I love C, still the language I use most and prefer cause it can do anything!
C makes you see the world
Well that's quite a truckload of compliments! I don't really consider my code clean - I put an emphasis on using an extremely explicit style, distancing myself from `int`, `double`, etc. to use `size_t`, `long double`, `uint8_t `, etc. according to the variable's purpose. It makes more sense to me but newcomers may find it weird or disturbing. Manageable? That's my main objective! I never start a project without having a good layout on paper - with every folder, file, and function. If I can't easily modify something, my project layout isn't modular enough and therefore invalid and I won't start working on it. I also try to comment more, I find it increasingly harder to clearly understand some tricks after not looking at them for a while...
It makes you C the world
Check out subreddit sidebar.
Probably The C Programming Language by Dennis Ritchie and Brian Kernighan aka *K&amp;R*. It was many, many peoples' introduction to C. See the first link under Resources on the sidebar to the right. But if that book feels impossible, then I recommend C Programming: A Modern Approach by K.N. King. This book has more modern practices, and goes much more in depth over many chapters, exercises, and programming projects. It's a comprehensive college textbook whereas K&amp;R is dated and terse.
Can you provide the source code for the most orgasmic skyrim female?
Have you considered cross-posting this to r/farcraft? I know we over there would certainly derive some enjoyment from this.
You can't go wrong owning the Bible (K&amp;R's *The C Programming Language*), but that's really more of a reference book than a step-by-step instruction manual. I had decent results from an Amazon Kindle book, *Linux + C*. There were some errors introduced by formatting, apparently, but there's also a link to the original code which compiles fine. Using books like that alongside K&amp;R works pretty well to teach you the basics. After that, you just need practice and experience. There are a lot of ways to really mess up your code and ways to make life easier that just come from experience.
These are all excellent points so far. I'd say the syntax isn't really an issue, because they kept it pretty simplistic. You don't worry about whitespace, every executable line of code ends in a semicolon, every if/else/while/for loop is enclosed by curly brackets, that sort of thing. The harder things to learn are (in no particular order): * The list of basic functions you use a lot (printf, fgets, malloc/calloc, etc) and how their arguments are structured. * The different types of built-in variables (int, uint8, int16, char, etc) and what they represent on your machine (e.g. int can be 32- or 64-bit, depending on the system) * struct vs. union vs. typedef * How pointers work (even many employed programmers seem to have trouble with them) * Heap and stack memory Honestly, I think with your background in Pascal you could pass with a week's study. If you want an A, perhaps two or three weeks.
I only skimmed the header but two things occurred to me. Is the buffer member meant to be accessible by the users of the API? If it should be hidden you may want to forward declare it in the header and use pointers too it in your finding declarations and then define it in the c file. If not then I'm not sure what the get function is for. Either way you will likely want a larger collection of string functions. This actually reminds me vaguely of the UNICODE_STRING struct in Windows drivers, except that your version handles memory allocation/reallocation as well. Edit: you may also want a version for wide/Unicode strings
&gt; I only skimmed the header but two things occurred to me. Is the buffer member meant to be accessible by the users of the API? If it should be hidden you may want to forward declare it in the header and use pointers too it in your finding declarations and then define it in the c file. If not then I'm not sure what the get function is for. Either way you will likely want a larger collection of string functions. The buffer isn't meant to be accessed by users of the API, none of the struct properties are. I should document that only the `str_*` functions are to be used to interact with the structure. Maybe I should prefix each property name with an `_` to make this clearer. &gt; Edit: you may also want a version for wide/Unicode strings That sounds like a good idea! I need to study up on how to handle those.
I just prepared a hot pocket, and i'm pretty sure it changed the world. I mean I like C too, but have you tried a pepperoni hot pocket?
This is awesome
Agree, it also improves your typing speed and gets you more familiar with the keyboard language you have chosen. 
Pff you made me laugh Dennis Roberts Ritchie did change the world
Good job dude 
I think what txmasterg is getting at is that if the user of the API isn't meant to access struct members, you can make it so they *can't* access struct members by changing the `struct Str` definition in `str.h` to a forward declaration and moving the definition into `str.c`. I also think you could benefit from moving all the includes out of `str.c` and into `str.h`. This helps to document what your API relies upon. As a final note, you should use a more unique identifier for your include guards as I imagine `str_h` is something that comes up a fair amount. Personally, unless I'm coding for as portable a project as humanly possible, I prefer to use `#pragma once` since it's supported by all major compilers. **EDIT:** for clarity, I'm suggesting you change the beginning of `str.h` to look like this: #pragma once // or include guards #include "fatal_error.h" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct Str Str; /* All your function declarations */ while modifying `str.c` as follows: #include "str.h" struct Str { char *buffer; // actual character data size_t size; // size of buffer in memory size_t length; // length of actual data size_t chunk_size; // amount to grow buffer by when necessary }; /* The rest of str.c */ Hope that helps.
C Programming Language, 2nd Edition (K&amp;R), C Programming: A Modern Approach, 2nd Edition, C: A Reference Manual, 5th Edition, The Standard C Library There are other great books of course ("Expert C Programming" for instance).
That's nice! I suggest you if you are interested in this subject to learn Posix Standard (programming with threads or multiple processes, semaphores, syscalls etc..). If you already know everything about that, you can contribute to open source Unix projects.
- `str_append_char` grows the string linearly, when called repeatedly, but should be exponentially. - Your error handling should respect `errno`. See `perror`. - As you already have the length in line 19, you can se `memcpy` in 24. - check for NULL in line 35 - also everywhere else - line 111: there is no point in having a by-value parameter marked as const.
Did you have a question? Also, whatever you're intending, the bit of code you posted won't do it.
It's my pleasure to help you.
Looks like you have a bright future ahead of you! Will have to take a look at your GitHub, would like to see how that stuff works.
 You're going to first want to get the threadID for each program/executable running that you want to send your output data to, and have a message pump cycle going on to process windows messages.. Use PostThreadMessage() with the WM_COPYDATA message. EDIT: Alternatively if your other EXEs have their own windows, and thus HWNDs, you could just use SendMessage()/PostMessage() with the window handle, and not have to go the level deeper to get the threadID by scanning for process EXEs by name. EDIT: Also, what's this for? Maybe there's a different way to go about achieving your over-arching goal. 
Wow beautiful, P.S:if i open Application6 i should get array6 data from main file through dll, I will connect this application to microcontroller
solved
solved
Great stuff, although I wish you'd used a license other than GPL for your code (MIT would be ideal).
I mean, nobody's ever going to use my programs, soooo
Then you have nothing to lose?
And nothing to gain either
Cool.
First of all, I understand, and share your enthusiasm. There are platforms for organizing open source projects that come and go all the time, but none of them really stick around. I think one of the reasons for this, is that finding a group that shares your enthusiasm for your project is hard to do without providing incentives for staying, especially within the world of games. As far as Reddit goes, there is /r/progether, /r/programmingbuddies, and /r/codetogether. If you look in the about section of each of the subreddits you may find additional resources to reach out with. I'm always looking for projects though, so if you get anything started let me know and I will help out as much as time allows. I'm partial to the back-end side of development as well. 
Congrats.
Great work man! Your code is very clean, but you seem to only be using 'while' loops. Take a look at 'for' loops, the syntax is more compact. I use while loops for things like flags. EDIT: Also, in ned/source/main.c, I notiiced that you use a cascade of 'else if' statements. Look into the 'switch' statement; it's more appropriate in contexts like these.
 scanf("%lf", &amp;prices[i]); scanf("%i", letters[l]); scanf must be passed a pointer Also %i is for reading an integer. If you type `a`, that is not a number.
I mean, I literally made an OS, I know what `for` and `switch` are. I, for a while, stuck with a rather terrible coding standard, which among other things prohibits functions longer than 25 lines, `for` loops, `switch` statements, and other nightmares. I ended up distancing myself from it (have a look at `unixlib`, I started replacing my `while` loops with `for` ones in the `source/math` folder) but some things still stuck like the two-spaces indentation.
oh yeah I forgot to put that back on because I was trying something else. But what can I use then for letters?
%c reads a single character. You'll need to pass a pointer to char, not pointer to int.
Why distance yourself from 'for' loops?
meaning i need to declare my array as a char? Thats what I tried to do and I got a weird error and my program wouldnt run.
Yes, the array will be `char letters[SIZE]`
No, I'm distancing myself from the coding standard I was following, which prohibited for loops. I don't know why they weren't allowed. All I know is they're less verbose and convey another intent than while loops which should make their use mandatory when it makes sense to do so. 
okay so for some reason its actually running now but I'm still having a problem. It skips the input for a letter. ill take a picture and show you. Here it is http://imgur.com/a/Pv0zC
When you type `a[enter]` you're providing 2 characters. The `a` and the newline. There is a line in the [documentation](http://en.cppreference.com/w/c/io/fscanf) which tells you how to deal with this problem.
I'm not sure thats the issue because when it ouputs what I entered for each spot I didn't get to put an input it outputs a "0" because thats what I set the array to.
I was a little curious about this too because the same thing happened to me and I stumbled upon [this page](https://stackoverflow.com/questions/14994271/scanf-is-skipped-even-if-using-fflush) which was helpful. The scanf line needs a space before the %c: scanf(" %c", &amp;letters[i]); It seems a little stupid to me, but meh..
OH MY GOD THANK YOU. That worked thanks so much!
no problem!
"Nobody should start to undertake a large project. You start with a small trivial project, and you should never expect it to get large. If you do, you'll just overdesign and generally think it is more important than it likely is at that stage. Or worse, you might be scared away by the sheer size of the work you envision. So start small, and think about the details. Don't think about some big picture and fancy design. If it doesn't solve some fairly immediate need, it's almost certainly over-designed. And don't expect people to jump in and help you. That's not how these things work. You need to get something half-way useful first, and then others will say "hey, that almost works for me", and they'll get involved in the project." - Linus Torvalds ([Source](https://en.wikiquote.org/wiki/Linus_Torvalds#2000-04)) That's also how Linux became the success it is nowadays. IIRC, Linus was writing a software to access his university's system from Minix but that required to rewrite a few drivers. That developed into a hobbyist operating sytem project and became more serious once more people joined (and he accidentally wiped out his Minix partition). The success wasn't planned, in fact hadn't BSD been in this lawsuit situation at the time, he wouldn't have bothered taking Linux seriously ([Source](https://en.wikiquote.org/wiki/Linus_Torvalds#Attributed)). Moral of the story, start small. A lot of projects start too ambitious and land nowhere because of that. Writing (non-trivial) games is a time-consuming and difficult activity and MMORPGs are probably the hardest. Finish many small projects, attempt larger and larger projects and build a reputation first.
That's great. But remember, [don't fall to the dark side](https://www.reddit.com/r/cpp).
Definitely
Thanks! Well, yeah, what I hope is that sooner or later people will gravitate towards the project if I can start something interesting. I'll definitely keep your name in my mind! :)
That's a good quote from Linus, I know what he means. I did some small project, mainly to entertain myself, that's why I want something more serious, but you are right, I should start it from something small.
I believe the standard allows some parts of stdlib to be implemented in the compiler itself. Meaning, you could include a header which contains the relevant declarations but the compiler will insert some code before it even gets to the linker. The fact that the standard library is implemented as a shared library on most platforms is just an implementation detail, it doesn't have to be this way in all platforms.
This subreddit is about C, not C#. I have removed your post as it is off topic. Please ask elsewhere, e.g. on /r/csharp.
 int answer; scanf("%i", &amp;answer); switch (answer) { case (1): printf("you selected 1\n"); break; case (2): printf("you selected 2\n"); break; case (3): printf("you selected 3\n"); break; default: printf("you picked something else\n"); }
owh okeii thx will try it out
No problem, man, let me know if you need help with anything else.
can i know the format? i mean i dont quite understand 
Just wondering, what's the difference using **%i** or **%d** . The **d** stands for decimal AFAIK, the **i** for integer or what?
Yea, exactly. They're interchangeable when it comes to printf. It's scanf where it actually makes a difference. [Sauce](https://stackoverflow.com/questions/1893490/difference-between-format-specifiers-i-and-d-in-printf)
Thanks for the info and the laughter ("sauce") :)
You mean from 10 to 1? for (size_t i = 10; i&gt;=1; --i) { /* something */ }
Sorry, will do
Sorry, will do
Or using a while loop: int i = 11; while (i-- &gt; 1) { printf("%d\n", i); }
&gt; --i c++ much? :p edit: ment to reply to the other comment
Why yes. Some of us have *real* programs to write. :D ^(*No wait DON'T KILL ME AAAGHHHgghhhh.....*)
Predecrements are just fine in C.
I don't mean to sound like a dick, but if this is the type of question you turn to an online forum for, are you sure you want to be learning C? This sounds like a first assignment in a C programming class. There's nothing wrong with asking for help when you're stuck, but you haven't said what part you don't understand, which makes me think you were given an assignment and didn't read or listen to what you were supposed to. My very first job, 24 years ago, was tutoring C programming and I can guarantee that if you don't make an effort to read and understand the materials on your own, you're not going to get very far as a programmer. If you're just taking a mandatory class and don't care about learning C maybe you'll muddle through, but you'll annoy a whole bunch of people online by having them do your entire semester's assignments. If you google 'learn C' you'll get a number of good tutorial sites. Some of them let you edit and run code so you can tinker and make sure you understand what you're doing. If you've never programmed in any language before, make sure that you understand first what loops are and why you use them, and look at the differences between the types of loops in C. If you have prior programming experience (we learned to do reverse loops in BASIC on the Apple II in elementary school and the concept is the same) and just need to understand C's syntax, take a look at one of the online language references. If you're stuck, you can post "I'm trying to do ___ but I don't understand how ____ ...". It gets old having a bunch of posts that basically say "here's my homework, do it for me."
I came here to find something innovative reading the title and then I just went meh. No offense but read good C books
Wow! I wonder about the kind of withdrawal issues that someone with such a tenure would go through. For me, the first six months after I handed over and left a codebase I owned was tough! And that was after only 4 years of work in it, and Roland has done glibc for 30 years
I want the last word in this exchange. edit: Why do you prefer MIT to GPL?
Haha. I mean the point of putting your code on GitHub is to get as many people to use it. To actively work against that because there is "nothing to gain" is pretty funny and I'd argue against the UNIX (and its successor BSD's) spirit. FSF fans, of course, will disagree. I mean the GPL is a great license if you don't want anybody to use your code. It can work for complete applications like an operating system (Linux) or some other user software, but makes no sense for libraries ([with few exceptions](https://whispersystems.org/blog/license-update/)). OP is using it for a libc implementation, which basically makes it unusable. They should at least use an LGPL license if they wish to go that route. Even Linux ‚Äî the most famous example of GPL ‚Äî refuses to switch to version 3 due to its increased restrictiveness. Perhaps OP is being a bit over-cautious, but are they really worried about someone running off with their toy programs? Using GPL is like having one foot through the door of open source ‚Äî you want to share your code while dictating how everyone uses it. I like MIT because of its simplicity. There is only one version of it (unlike BSD) and it does the job well while being very concise (unlike Apache).
&gt; * if you don't want anybody to use your code * which basically makes it unusable How does the GPL make code "unusable"? &gt;you want to share your code while dictating how everyone uses it Isn't the only 'restriction' that it and all modifications of it must remain free software? That doesn't limit the usage of the software, it just ensures that it never becomes proprietary.
It forces you to GPL ALL your code because you use (in code) a single piece of GPL software. For something like a library, this is a huge restriction. For apps, as I mentioned, it's less of an issue.
Start by breaking it down in pieces. What do you need for tic-tac-toe? Display a board, display X or O depending on turn, some way to select board slots, etc. 
Yeh, I guess I should've spent more time thinking about the project. Its just that I sat down to start, looked at my text editor and was like "now what?". I think the best thing you can do is just break it down like you said. And if you don't know how to do one part, you just gotta keep breaking it down right?
touch myProject.c 
Yep, that should do it. 
I'd start by thinking how you want to represent the board. It has 9 squares each of which can be in three states (empty, X, O). You could represent it as a 2D-array of ints or enums. Speaking from experience, you may eventually find it advantageous to represent the board more compactly. When implementing the computer player, you might want to do some search - having a compact representation of the board will help make your search efficient. Each square's three states can be represented with 2 bits. This means the board's of 9 squares can fit into 18 bits. A `uint32_t` could hold the whole board. Once you settle on your board's representation, write functions to perform basic operations: The most primitive operations are: - Return the state of a position on the board. - Set the state of a position on the board. In principle, if you change your board representation you should only need to change these two fns and everything else should continue to work. In practice, knowledge of the representation might leak into other parts of your code. E.g. the evaluation fn (see below) can probably be implemented most efficiently by accessing the board directly, rather than repeatedly going through the get method above. Other operations you'll need: - print the board - evaluate the board to see if X or O has won Your initial computer opponent could simply pick a random empty square. This would be enough to test your code. When you want to do better read up on [Minimax](https://en.wikipedia.org/wiki/Minimax) and, later, [Alpha-beta pruning](https://en.wikipedia.org/wiki/Alpha‚Äìbeta_pruning) for further optimization. Way back when, when I was reading through the first edition of "Artificial Intelligence" by Patrick Henry Winston, I found it extremely gratifying to write tic-tac-toe and implement Minimax/Alpha-beta pruning. I think it's an excellent choice of a project.
**Minimax** Minimax (sometimes MinMax or MM) is a decision rule used in decision theory, game theory, statistics and philosophy for minimizing the possible loss for a worst case (maximum loss) scenario. When dealing with gains, it is referred to as "maximin" - to maximize the minimum gain. Originally formulated for two-player zero-sum game theory, covering both the cases where players take alternate moves and those where they make simultaneous moves, it has also been extended to more complex games and to general decision-making in the presence of uncertainty. *** **Alpha‚Äìbeta pruning** Alpha‚Äìbeta pruning is a search algorithm that seeks to decrease the number of nodes that are evaluated by the minimax algorithm in its search tree. It is an adversarial search algorithm used commonly for machine playing of two-player games (Tic-tac-toe, Chess, Go, etc.). It stops completely evaluating a move when at least one possibility has been found that proves the move to be worse than a previously examined move. Such moves need not be evaluated further. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I have a several friends who find [Test-driven Development](https://en.wikipedia.org/wiki/Test-driven_development) to be really helpful for shaping their ideas into code. In general you'll need to break down the problem into smaller pieces, and TDD can help not only in realizing what those pieces need to be, but it also provides a method of ensuring that your code has accomplished what you want. One of my favorite lessons from this sub is that complexity should stem from the coupling of simple parts. This isn't always straightforward. Many times it's easy to create a monolithic myProject.c, a single struct, or only a handful of functions to get the result you want. This isn't, strictly speaking, wrong but it is generally seen as bad practice. This is because when you have to maintain long term projects you want to have changes to one portion affect the others as little as possible; you should never have to rewrite the whole program in order to accommodate a change to a single part. There aren't exactly hard and fast rules to determine the best process for modular design, but practicing on smaller projects is a good start. If you're looking for more specific "best practices" I've found [C Interfaces and Implementations by David Hanson](https://www.amazon.com/gp/product/0201498413/ref=oh_aui_detailpage_o03_s00?ie=UTF8&amp;psc=1) to be a really nice guide for some particularly common problems. As for your specific project I think it would help you to consider the mechanics of TicTacToe as a game, and how you can change them while still keeping it familiar. For instance, my first thoughts are: * grid size: 3x3 is standard, but a larger grid could change how the game plays out without changing win conditions. * player number: 1v1 is standard, but having 3+ player free-for-all matches or teams could make it completely different. Now what I'm getting at here is that for the purposes of learning best practice it could help to design the program to allow for different rules, changing individual parts without it requiring a complete overhaul. If you can build it to change these things without recompilation so much the better. In general I look at this method as an analogous measure of scalability; can the program handle an increased load, how much of one, and how readily will it handle it. In allowing for modular rule changes you'll build a modular project. As a final note, bear in mind that there is a limit to modularity. Eventually trying to make a program handle every eventuality can be paralyzing. Learning where the limit is and what you feel you can handle is almost purely a matter of experience, but I think the most important thing is to never let the scale of your project deter you from completing it. You control how the program is designed so ultimately it's your decision, and if that means just sitting down and writing out something that works so be it. The perfect is the enemy of the good. I hope that helps.
Only if it's 18 years or older^1 and consenting.^2 ^(1. Age may vary by your region.) ^(2. Permission denied means permission denied.)
Yeh man that helps a lot! I'll definitely check out that guide and TDD. Taking the time to type what you said is much appreciated.
Thanks for you detailed breakdown man. Much appreciated, it really helps when I understand how others would go about problem solving. I think I'll also checkout that "AI" book or another edition. Just recently learned prolog last semester. Might be a good practice to do the project in different languages.
I dont have an answer, just wanted to say I feel for you. I'm learning C and I find my biggest disadvantage relative to the more experienced is they know how to plan ahead and break the project into pieces before starting, while I just stare at a screen for a week before I finally get anywhere near an actual starting point
Yeh, I hear you. Its actually just coding in general. I've always just been given a prompt of what the program should look like and what's it gonna be. It really shows you how much know, so better to start now than later right? I think like with anything, its just practice, practice, practice . Start small and let time do its thing.
Well, first you gotta know what you want to build. Then what i do is research some libraries that might come into being useful (like libev, for example). Make sure I know how to use that library (write some simple program to get the hang of it). Then I jot some notes on paper concerning the layout of the project, the features in v1, as well as create a tree mapping out the projects organization. Then get to programming and figure out everything else on the way. Doing personal projects is a learning experience. That's just my way of going about starting something, but everyone developes their own method. Dont worry about it so much. Just #include stdlib.c, create a main function and start coding. Pretty soon you'll be in the thick of it.
Sudo touch myProject.c?
It can help to write down high-level pseudocode to start, too. You know you need a big game loop somehow, and in it you need to grab a move from a player - getMove () - and apply it to a board - checkValid(), updateBoard(), etc. Just sketch out what happens in your big loop - and any functionality you're not positive how to write, just abstract it to a made-up function call and write it later. This approach usually helps me get my bearings in a new project, and as I go deeper in each one of these inner functions too.
As a novice or at least I consider myself still there, I always start with the idea and the extrapolate what goes into the idea into data structures that closely match their equivalents in life, in your example tic tac toe is a predominantly 2 player game played on a 3x3 grid using the characters X and O to denote the different players so obviously first things first in order to play you need players struct players { char token; int choices[5]; //5 is maximum number of choices // depending on who goes first } you need a grid 3x3 or 9 spaces int grid[9]; Then you need mechanisms for checking if a spot is taken int spot_in_use(struct players * player, int spot); You also need to check for winning conditions int game_ended(int * grid, struct players * player_one, struct players * player_two); Optionally add a menu to start new games, option to save and load games, feature scoreboard/high scores, optionally work in a gui toolkit for graphical play like qt or gtk or opengl or direct x(if you want to deal with a headache imo) or opt for SDL which is perfectly suited for 2d games. Being able to extrapolate all the necessary details as well as optional details and possibly extra features allows you to visualize the data which allows you to follow a sorta pseudo cookbook for the implementation which makes writing from scratch easier.
I'm assuming this is a learning project. If so, 'kill' or 'killall' do this natively so have a look in the util-linux repo if you want to see that method for comparison. If you are looking for feedback, a table-based lookup for sig name to value would be much cleaner. It avoids that huge to_sig function and is less error prone. Consider in a professional environment the test coverage of to_sig with a lookup table vs cascaded logic. Maintenance is also more intuitive.
Thanks for the feedback! 
Start with this book: C Programming Language, 2nd Edition Paperback ‚Äì April 1, 1988 by Brian W. Kernighan (Author), Dennis M. Ritchie (Author) You can get it off Amazon. If you are on a Mac, you can start programming straight off a terminal window. I would follow the examples in the book. Type them in, compile and link. 
What do you mean by, "Double pointers?" You mean like, "char **"?
Yea like a pointer to another pointer 
I feel we answer this question a lot. I like Head First C it has a good basic of imbedded and software projects and is quite informative.
u/hydraloo is not in the sudoers file. This incident will be reported.
Depends on the project. With simpler projects, I just start to write the code. When the project gets more complicated I add additional source files and additionally a Makefile. Whith complex projects, I start by writing header files with all the data structures and interfaces I want to use. I write comments documenting every interface, data structure, and design choice I make. When I am satisfied with the structure, I start to implement the interfaces I laid out before.
There are two common use cases. First, to pass an array to a function, you typically pass a pointer to the array, not the entire array: main(int argc, char **argv) In this case, "argv" is a pointer to an array of char pointers indexed from 0 through argc-1. A second use case is to pass pointers by reference to a function. This is where you want the pointer to be modified by the caller so that the callee will see the change. int find(char \*str, char c, char \*\*where) This (hypothetical) function searches "str" for "c", returning the position in "str" if found and setting "where" to point at it, or returns -1 if not found. For this function, we would need to return two variables, a position index and a string pointer, so I chose to return the position as an int and use call by reference for the position pointer. Code for this function would look. Like this: https://pastebin.com/D8fAtK2W 
That sounds like a great method man. I can definitely work with that.
I would also recommend "21st Century C"
https://www.reddit.com/r/C_Programming/comments/5nah7m/double_pointer_as_function_parameter/
If you are learning, I did sololearn Www.sololearn.com However, this just teaches you he theory. It is far from perfect but it should get you moving
+1 for K&amp;R. Concise, yet clear. Do the examples in the book, understand them well, and that's a good start, OP.
This is a great book if OP already has some programming experience. K&amp;R can be a little difficult for total beginners.
Deitel and Deitel book
I don't think (just) learning C will help you understand a PHP interpreter, it's probably a bit more complex than that. The book I read at the uni when we were building an interpreter was [this one](http://ieeexplore.ieee.org/xpl/bkabstractplus.jsp?reload=true&amp;bkn=6267321). I can't really recommend it but in the absence of anything else it's better than nothing. If you want to understand PHP better I'd say it's best to read the standard than to try to understand the inner machinery of the interpreter. 
First learn about c++ or another POO language, because that is the fundament of GUI. I suggest you GTK or QT tutorial, but si you have money use Visual Studio.
I reviewed that book and, whilst it's an interesting read, it's aimed at existing C programmers with some experience. It does not teach you how to start writing C, but more how to use the C ecosystem (Autotools, libraries etc.) once you're already comfortable with the language.
I think you accidentally translated una word.
jajajajaja yeah, i'm From Colombia
I think I've always had a problem with pseudo code because I would wtite it to be too general. I gonna focus more on the details to visualize it more like you were sayin. Thanks for your layout also, good to see a different way of going about it.
Most portable, higher level GUIs are not in C, mainly Qt is in C++. GTK uses C with GObject to make up for C not being object-oriented. All C GUI libraries are usually close to the system and usually not what you want, sadly.
Can someone teach me a better way to do this? #include &lt;stdio.h&gt; #define LEN(x) (sizeof(x) / sizeof(x[0])) char *obj[] = { "he/him", "C", "feelings", "challenge" }; int main(void) { int i, j, k, l; for (i = 0; i &lt; LEN(obj); i++) { for (j = 0; j &lt; LEN(obj); j++) { for (k = 0; k &lt; LEN(obj); k++) { for (l = 0; l &lt; LEN(obj); l++) { if (i != j &amp;&amp; i != k &amp;&amp; i != l &amp;&amp; j != k &amp;&amp; j != l &amp;&amp; k != l) printf("%s gives %s a %s of %s\n", obj[i], obj[j], obj[k], obj[l]); } } } } return 0; }
If you are using Windows then download and use CodeBlocks.
output $ vi gives.c $ cc gives.c $ ./a.out he/him gives C a feelings of challenge he/him gives C a challenge of feelings he/him gives feelings a C of challenge he/him gives feelings a challenge of C he/him gives challenge a C of feelings he/him gives challenge a feelings of C C gives he/him a feelings of challenge C gives he/him a challenge of feelings C gives feelings a he/him of challenge C gives feelings a challenge of he/him C gives challenge a he/him of feelings C gives challenge a feelings of he/him feelings gives he/him a C of challenge feelings gives he/him a challenge of C feelings gives C a he/him of challenge feelings gives C a challenge of he/him feelings gives challenge a he/him of C feelings gives challenge a C of he/him challenge gives he/him a C of feelings challenge gives he/him a feelings of C challenge gives C a he/him of feelings challenge gives C a feelings of he/him challenge gives feelings a he/him of C challenge gives feelings a C of he/him Condensed version #include &lt;stdio.h&gt; #define LEN(x) (sizeof(x) / sizeof(x[0])) int main(void) { int i, j, k, l; char *obj[] = {"he/him", "C", "feelings", "challenge"}; for (i = 0; i &lt; LEN(obj); i++) for (j = 0; j &lt; LEN(obj); j++) for (k = 0; k &lt; LEN(obj); k++) for (l = 0; l &lt; LEN(obj); l++) if (i != j &amp;&amp; i != k &amp;&amp; i != l &amp;&amp; j != k &amp;&amp; j != l &amp;&amp; k != l) printf("%s gives %s a %s of %s\n", obj[i], obj[j], obj[k], obj[l]); }
This.
http://harmful.cat-v.org/software/
Loving C like a motherfucker. Hi five
I don't need a high level, portable solution and don't mind using the Windows systemcalls, I just want to know if that book would be too out of date.
Let `ptr` be a pointer to a `char *`. This kind of variable, a *pointer to a pointer*, is often encoutered in argument parsing as an example. You can pass shell arguments to a C program by updating `main(void)`: int main(int argc, char **argv) { return (EXIT_SUCCESS); } Why is `argv` a `char **`? Because it is a *pointer to an array of pointers, each holding the memory location of a string*. In our case, if we compile this program and run it using: $ cc test.c -o test.bin $ ./test.bin I am a potato the content of `argv` will be: argv = {"I", "am", "a", "potato"}; I like to parse the arguments myself. Here is a parsing routing from my [raytracer](https://github.com/Garuda1/raytracer): `raytracer/source/args.c`: void parse_args(t_args *args, int argc, char **argv) { int i; i = 1; while (i &lt; argc) { if (!strcmp(argv[i], "--coords") &amp;&amp; ((i + 3) &lt; argc)) { args -&gt; sphere_coords.x = atoi(argv[++i]); args -&gt; sphere_coords.y = atoi(argv[++i]); args -&gt; sphere_coords.z = atoi(argv[++i]); } else if (!strcmp(argv[i], "--radius") &amp;&amp; ((i + 1) &lt; argc)) args -&gt; radius = atoi(argv[++i]); else { my_puts("Syntax: raytracer [--coords x y z] [--radius r]\n"); exit(FAILURE); } ++i; } } Please note that `t_args` is defined as: typedef struct s_args t_args; struct s_args { t_vector sphere_coords; double radius; }; *(the `args` structure is initialized in another routine)* Anyway, notice how I am iterating through the `char **`, I am accessing every pointer just like I would with a normal array. I'm bad at explaining pointers, but just consider a pointer **a variable that contains a number, generally 8 bytes long, and represents the memory location of another variable**.
AFAIK the Windows API didn't change that much due to legacy code needed to be supported. The principles should still hold, for the exact documentation and modern interfaces just have a look at msdn
I read his list. It's kind of funny in some entries. Like yeah emacs and vim and intellij are bad. Sam (what?), Acme (wow...), and ed (now you are just plain joking) are the way to go. Ooookay. 
I guess this is a chance for me to get a better unterstanding of how interpreter works and get familiar with another programming language. And as PHP developer I think the best choice is the PHP interpreter ^^
This very helpful. Thank you. It should help me a lot for my upcoming exam. 
Still new to Reddit, and I wasn't this question was asked already. Im very great full for the link to this comment thread, my friend. 
I liked how you integrated argv and argv. I do most of my assignment on VIM on our Uni's Linux servers, and servers as a great example of how could use double pointers down the road. Thank you my friend. I am also a fan of potatoes. 
Regarding your last statement: to be fair, the same could be said about C itself.
This isn't a podcast, however [Handmade Hero](https://hero.handmade.network/episodes) is a great live stream about creating a professional quality game in C/C++. He uses very very few features of C++ so it's essentially C, I like it a lot and have learned a lot from watching.
A last note: *Coding* (also called *encoding*) is the task of typing a program into the computer. It's the least creative and most menial task of developing a program. Do you really want to reduce what you do to a data entry job? I never understood why people want to call themselves ‚Äúcoders.‚Äù It's literally that shittiest part of programming there is.
Out of curiosity, what do beginners find hard about learning C? (serious question). I've been programming C for a long time, so I am out of touch with this.
C isn't really for GUI, but for console programs. 
√âvite de mettre des virus belges dans le README, quand m√™me, √ßa ne se fait pas.
&gt; Consider in a professional environment the test coverage of to_sig with a lookup table vs cascaded logic. Well, at least with the `if` cascade you are sure every single signal value will be tested, instead of just testing 2 or 3 of them and calling it a day.
Floats allow you to use decimals, and while yes, using that for the age of somebody doesn't make much sense, it does allow for plenty of uses
There's a long thread here which may give you some additional ideas (e.g. IUP) https://www.reddit.com/r/C_Programming/comments/5py0hh/is_it_easy_enough_for_a_beginner_to_make_a_gui/
It all starts with an idea and breaking things down to what there essentials are. Grass needs soil water and sunlight, games need lots if stuff just pick your favorite and pick it apart
https://www.reddit.com/r/IAmA/comments/6mah37/iama_2d_art_director_for_a_indie_mmorpg_game_ask Ask this guy for advice?
Use switch and case then or be a cheeky bastard and use the ternary operator which is technically if statements but if he didnt explicitly say if and ternary he forgot hes a C teacher and that we are cheeky like that
How would I go about using a switch? switch (scores[i]) { case 90, 91 ,92, 93, 94, 95, 96, 97, 98, 99: a++ }
Just kidding I figure it out, thats a lot of cases. But its the best thing I got so im going with it. Thank you! 
No problem also look up the ternary operator!
Divide mark by 10 and just check if result is 9.
A lookup table guarantees the same, but test cases can be run at a more abstract level rather than having a function and it's unit tests require intimate knowledge of the signal names as opposed to a table. Its likely that a program like this would have unit and system tests so its easier to manage the concept of a signal name at a system level rather than unit level. I appreciate there is no one way of doing it, its just my preference :)
this is good for linux too
Being cheeky will probably yield you a wrong answer in the eyes of your teacher. You can use a jump table instead of IF/ELSE or SWITCH statements. All you need is another array with 6 elements since that's the number of grades. Since ascii values are in order we can store 'a' 'b' 'c' ... into slot 0,1,2... of the array. We can then use a very simple operation to decide where each grade goes into. for (int i = 0; i &lt; SCORES_COUNT; ++i) { grades[scores[i] - 97] += 1; } Here I'm using lowercase letters therefore 'a' corresponds to 97. If we subtract 97 from each value stored in the 'scores' array we would get the slot in our grades array that corresponds to that letter. We then increment that value by one, at the end of the loop we should have the total amount of a's b's, c's, d's, and f's. 
Well for ages if someone is 1 year 6 months old 1 or 2 would be quite a bit off in terms of accuracy. Floats would let you do something like 1.5 or whatever. Use it whenever you need accuracy beyond an integer value. The way you would avoid floats for ages is to store everyone's age in seconds or milliseconds something. But then reading and using those values gets kind of annoying. For me, lots of sensors I connect to return value that are easier to understand as volts vs. counts. Eg: An I2C sensor that returns an integer, but would be really unusable in my actual code because '1.564v' is much more informative than '49427324' counts. I had the same issue when first learning about floats. But I quickly realized that there isn't a really simple way to explain a floating point number in a computer. And if you go with a 'simple' explanation for it you can end up using it incorrectly and getting floating point errors. Give it a solid day to read over and really understand how it works. It'll benefit you in the long run since floats and doubles are very important types.
I started learning GTK last week, it uses C. Check it out and if you are interested in cooperating, PM me.
The book's code should still compile and run, but the api has been updated and some of the functions and data types are deprecated. If you check MSDN docs for the various types and functions you'll see handy links to the uodated api versions of those functions. The newer api stuff is generally pretty similar to the old stuff, just with some more features and new functionality available. The basic process of creating a window, widgets, menues, and the window procedure are pretty much the same. Learning the 'old' api will give you most everything you need to figure out the newer stuff. There are certain things, like DirectX, that are more suited to c++, tho, and that library in particular is pretty commonly used for user input devices and audio as well as graphics. You can do it with c, but its a good deal more work. Moreso than just the standard win32 api.
Bless your heart, man!
A hint for the next time: You can make your programming questions slightly less ignorant by putting the gist of the question into the title. This way, people can immediately see if they want to look at your question or not. The way you did it, you have to read the question to know that and many people just won't bother if they don't know ahead of time what it is about.
Find aims. I like [Project Euler](http://projecteuler.net) for that. 
While I've never used that book, it probably would be fine for getting started. The basics of Windows programming really haven't changed much since... well, forever. Some specific API calls used in the book might be deprecated (but still working) in modern Windows, but the architecture of a Windows application really hasn't changed. You really just need to learn how the message loop and all those SendMessage calls actually work, and you'll be able to use even the newest API calls quite easily. When you are finally writing code, microsoft's online documentation is fantastic. You'll just need to keep a browser window open to look up a few API calls. I still write and maintain an application that uses Windows API calls and attempts to maintain compatibility with Win2k, and it works great in Win10. The Windows API is extremely stable.
Strings are going to be a bit of a problem for people coming from HL languages. Pointers and memory management generally can be problematic. 
Quick Question. I am still unable to produce data output on the MOSI line or even assign a value to the SPI handle data register. I have been looking at the hardware configuration and have noticed a pull up resistor on the data input pin where the recommended design spec from the manufactures show a pull down resistor. Is it possible that this resistor could be causing the EEPROM not to function as intended? 
mmm, you would have to dig through the data sheets to see if the output is open collector / drain. &gt; I have been looking at the hardware configuration and have noticed a pull up resistor on the data input pin where the recommended design spec from the manufactures show a pull down resistor. on which device?
`float` is a *floating point* data type. Floating point variables are variables storing values using the formula `a*b^c`, resembling a scientific notation. To the programmer, however, it is completely transparent. While you can do things such as `float var = 3E4;` (30,000) you can also affect decimal values, `float var = 3.14159265;` However, the `float` data type isn't considered valid in modern programming anymore. 5 years ago, you could probably still use it, but nowadays unless you're going low level (e.g. memory optimisation or embedded softwares) you should use `double`, which as its name implies, is a *double precision* data type. It's more accurate.
Its custom. M95M02 Is the eeprom. I'm attempting to send data from the STM32F7 microprocessor. From the ST website, the EEPROM data sheet shows a recommended SPI configuration were there is a pull down resistor to ground on the data input line. The current wiring has a pull up resistor to Vcc between the GPIO pin on the Micro and the data input pin on the EEPROM. The only thing I can think of that would differ is the data input pin would be in a high state all the time, which is measured, versus a low state without data transmission. I'm reworking the wiring to match the datasheet. Ill update, if it fixes the problem. I'm just confused why I cant assign a value to the data register, It always reads zero. For example... *((__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR) = 0x06 //WREN Will not assign 0x06 to the register, The register will remain zero. 
If you no want all the OOP crap i recomend Nuklear: https://github.com/vurtun/nuklear It's based in the Immediate Mode, explained here(from the great Casey Muratori): https://www.youtube.com/watch?v=Z1qyvQsjK5Y
Another good source is this talk: https://www.youtube.com/watch?v=443UNeGrFoM
&gt; pull down resistor to ground on the data input line. I don't think that will have an effect, the EEprom just needs a defined logic state (as all cmos chips) If the output of the STM32 is not push pull, thats is when you would need a specific pullup / pull down. &gt; *((__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR) = 0x06 //WREN Will not assign 0x06 to the register, The register will remain zero. Well there's you problem, you need a ';' befor the comment ! \s How do you know the register is not taking the value? I can't speed for the stm32, but a number of other processors share the register for SPI io. As in write to the register to start a transaction, poll some bit or wait for an interrupt, read the same register to get what was returned. SPI by nature is bidirectional even though most chips i have worked with do not use this feature (have to send dummy bytes to acutely transfer data. 
Sorry, yes the ';' is there i just forgot to type it. I am assuming the data register was not written to since the register value remains zero in the debugger and the scope probe on the GPIO pin shows no data transmission. Im assuming the WREN command 0000 0110 will show simething like this... __ _____/ \_ during the clock cycle but the GPIO pin just remains high. 
you are right, you should see some wiggle on the MOSI. At this point I would take a step back and review the SPI hardware. Is the pint have any other alternate uses? ie is is stuck in GPIO mode .
The GPIOB pins 12-15 are dedicated to the EEPROM for SPI2. I have it set for Alternate function 5. The GPIOB pins 10-11 are used for USART with alternate function 7. The debugger shows MODER13-15 as Alternate Function Mode. MODER 12 (chip select) is in General Purpose Output Mode. 
&gt; is every function available to every file? Every non-static function, yes. &gt; how does it know it exists It doesn't, that gets handled later when the object files are linked together. &gt; the lex.yy.c file includes all these files. Those .h files are only specified there so that lex.yy.o has them as dependencies, which means the object file gets rebuilt whenever the header changes. &gt; does the order of the .o files matter? The traditional behavior is for the compiler to search for definitions to the right of the object file that is being processed, but nowadays it doesn't matter. 
You could use the win32 API , I'm sure it's not great since it's pretty old but hey at least you don't need to install anything. But please consider these options first: If you want a native UI, take a look at IUP. One downside is that apparently it doesn't support Mac that well. If you don't care about native looks, nuklear and gtk are pretty cool.
Lol....serious? 
If I understand your question correctly you could return a pointer to a struct like the following: struct Data { unsigned type; void *data; }; Use an `enum` to create a bunch of named constants for your types; then just check `p-&gt;type` before casting and dereferencing `p-&gt;data`.
So if I get your idea right I should make the enum to hold examples of types so i can compare to what i've got. But the pointers i have don't hold values they only hold types - how would i compare an actual variable with just a type?
 &gt;But the pointers i have don't hold values they only hold types - That makes no sense. A type is not something you can store in a pointer. Pointers hold the addresses of values. 
The `enum` is just to create named constants so that your code is human readable. switch (type) { case 0: ...; break; case 1: ...; break; case 2: ...; break; } vs switch (type) { case INT_TYPE: ...; break; case STR_TYPE: ...; break; case FLOAT_TYPE: ...; break; } But you are saying you are calling a library function that returns this pointer so you can't really implement my idea, right? Could you post some code samples so people can see what you are working with?
 FOR_EACH_DEFINED_FUNCTION(node){ printf("First parameter type.\t\t\t%p\n", DECL_ARGUMENTS(node-&gt;decl)); printf("Function return type.\t\t\t%p\n", DECL_RESULT(node-&gt;decl)); printf("Function type.\t\t\t\t%p\n", TREE_TYPE(node-&gt;decl)); } All of those have a return that from my understanding is the pointer to the very basic variable types within the compiler. Typedef I guess. https://gcc.gnu.org/onlinedocs/gccint/Functions.html Thats what I used for most of the macros.
that entirely depends on what you are doing
this ++
or just i &gt; 0
This is rubbish and full of mistakes
This is surely a joke... * `#include &lt;conio.h&gt;` ‚Äî non-standard header * `void main()` ‚Äî pretty much valid only on [Plan 9](http://doc.cat-v.org/plan_9/programming/c_programming_in_plan_9) * Does not validate input * Useless call of non-standard `getch()` * A tutorial just on `if`? 
Please stop. 1. These tutors are misleading and overall wrong. 2. Locals do already know that, this subreddit is for intermediate/professional level.
this title cracks me up, literally sums up my adulthood
I'm pretty sure this is a product of India, where Borland Turbo C is still widely used for unknown reasons.
If you're talking about big numbers, just use an arbitrary precision library like GMP.
I think some people actually use acme and sam. I've read about people having VMs for plan9port just to run an editor.
The whole point is to do it myself. Also, I don't like GMP... too verbose for me. EDIT: also the problem here isn't the memory usage but a decent algorithmic implementation of order N operations
If you are not able to use a 64 bit type how do you plan on calculating a number that large in order to store it in a string in the first place??
Dynamic strings. If the number gets too large, increase the string's size by let's say 128 characters. Using a 128 characters string, we can store numbers ranging from -(10^127 ) to (10^127 )-1, which is gigantic. For the operations, simple: implement functions like `add(char *a, char *b)`
How do you propose to do arithmetic functions on 2 strings? At some point you will need integer types.... and will need to convert anyway to do the math. With that in mind do you not think something like below would be a better way of handling your numbers?: typedef struct { int64_t high; int64_t low; } int128;
A character is a digit between `'0'` and `'9'`, consider a string of digits a number. Another solution is base 255. I'll provide detailed explanations later, I really have to go! Sorry
Yes but with my above data structure your algorithms for arithmetic would be more simple and not require any sort of conversion to translation... not to mention the ability to store even larger numbers using an 8th of the amount of memory. Unless... I am missing something that you are able to demonstrate your intentions with some example code or even pseudocode?
No time for detailed explanations, but the point is to perform operations on numbers infinitely large, your structure can't store 2^512 as an example 
interesting. What makes acme and sam stand up to vim?
* No indentation
Make it bigger then...or dynamically add 64bit ints as required (as you will have to reallocate with you 'dynamic' string anyway)... the point I am trying to make is if you make this decision now you will have a much nicer, more professional program... that is much much much more efficient.
Look at it this way: Problem: My number that I want to do arithmetic functions on is too big to store in usual data types for numbers, I need to store the data somehow. Solutions: A) Store data in array of integers. This is a numeric type and arithmetic functions can be performed on them.. of course we would need some work to translate the array of numbers but binary arithmetic makes this fairly trivial. B) Store data in a char array, this would use up 8 bits per digit (total memory hog on larger numbers), cannot carry out integer arithmetic and would require conversion to some integer type to carry out the maths, translation between string, integer and results of arithmetic function would result in expensive operations and a sore head after coding. 
You could also do this much more easily with bash aliases. EDIT: In fact you can do this in pkill anyway with --signal. 
I wouldn't worry about an O(n^2 ) operation if it is the only way to get the job done. [Exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring) may be what you want to do as it is roughly O(log(n)) operations. If you are interested in speed however, I would highly recommend GMP as others have mentioned. Many of their bignum operations are inlined with assembly to be as fast as possible. If you want to learn this stuff on your own, don't use strings. The operations may be easy but all your operations will be on the order of the number of digits. That will be your bottleneck well before inefficient exponentiation methods. Packed bit structures are really the way to go here.
**Exponentiation by squaring** In mathematics and computer programming, exponentiating by squaring is a general method for fast computation of large positive integer powers of a number, or more generally of an element of a semigroup, like a polynomial or a square matrix. Some variants are commonly referred to as square-and-multiply algorithms or binary exponentiation. These can be of quite general use, for example in modular arithmetic or powering of matrices. For semigroups for which additive notation is commonly used, like elliptic curves used in cryptography, this method is also referred to as double-and-add. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Storing the values isn't the problem I've got that covered. The question here focuses on the algorithm to perform order N operations.
I'm seconding this, with a bit to back it up. Though not strictly in the purview of C (though still sort of touching it) GPUs are better geared for single precision, so when using CUDA or possibly openGL (I wouldn't know with openGL for sure) single precision is preferable from a performance point of view if they can be used. A second point would be SSE/AVX instructions. You can naturally pack more floats than doubles into a single vector instruction
I understand that that is the question you have asked...However I, as the person who suggested using an arbitary precision library, picked up that another part of your concept is problematic and am seriously trying to help you along the way. You can choose to ignore my advice if you want, I believe you are a fool for doing so, unless as I asked earlier I am missing something in your method. In regards to this I await a commit on your github because I am absolutely intrigued as to what you think is a good solution to this as conceptually using a string baffles me. The algorithm that you are asking for wont change if you wrote it in a language that allowed big number, so how would you go about that? Figuring out the algorithm should be as simple as breaking down the problem... So: ^n x = x ^x .. ^x (n times) So: ^4 2 = 2 ^2 ^2 ^2 = 2 ^2 ^4 = 2 ^16 = 65,536 (I hope that superscript formatting is ok) So you need to find the power that x must be raised to. To do this you need a loop that operates n times where y is initialized to =x. Each loop y = x^ y, when your loop is done y will hold your result. (assuming im not off by one, not working that out) Hope I have helped you.... Good luck. EDIT: BTW my math sucks and I didn't even know what tetration was until a minute ago and figured that algorithm out as I typed it so if i didn't understand tetration properly then sorry. 
Wow... Exponentation by squaring.. Just got excited by math for the first time in ever... makes me wanna a) re-learn all the stuff i failed to retain from school and b) work with more math. 
Yeah the string method is absolutely garbage, and ineficient for both the memory and the processing time. But it's kind of a requirement. Basically, I want to make several "versions" of this calculator: one with numbers as strings, one with GMP, one with `uint64_t` and a last one with a structure of `uint64_t`'s forming 2048 bits. The point is to check the computation time differences, and the leave the fastest one on Github. I'm aware it's not much of a problem nowadays, it's more about code quality. I went with digit strings because someone told me a bit more than a year ago to try and make an RPN calculator storing numbers this way, it's just an arbitrary decision! ----- Anyway, for the algorithm, well I recreated the first 4 order operations using an elementary operation, the addition. So in the end, `2^^4` is just a massive series of additions with a time complexity of O(n^4 )... Pretty inneficient. But the point is that I managed to find an algorithm for order N operations, making it theoretically possible to compute values that can't even be represented in our universe... given an infinite amount of available memory though ([Graham's number](https://simple.wikipedia.org/wiki/Graham%27s_number)) [Here's the link to a gist](https://gist.github.com/Garuda1/b781c268ce59500d83193968c850aa66) Now for the order N operation `O(n, x, y)`, I simply do this: if (n == 1) return (x+y); for (uint64_t i=0; i&lt;y; ++i) x = O(n-1, x, y); So an order N operation is defined by an iteration of ordern N-1 operations. But there's a problem. I need an initial value in the following algorithm: uint64_t order_n(const uint64_t n, const uint64_t a, const uint64_t b) { uint64_t res; if (n == 1) return (a+b); res = 0; for (uint64_t i=0; i&lt;b; ++i) res = order_n(n-1, res, a); return (res); } I just initialise `res` to 0, but it doesn't work... I'm absolutely lost.
Well yeah it's obviously a shit ton of additions. That's what multiplication is for... the trick to tetration is to figure out the order of your exponent then use an efficient exponentiation algorithm, as mentioned in my other comment. So if you have 2^^4 you figure out what the exponent would be in normal exponentiation then just multiply things. I'm not sure why you're getting hung up on the "order" (do you mean precedence?) Of your operators as the method of calculation for them is independent of that fact.
Your post got caught in our spam filter. I apologize for the inconvenience.
Casting 99 out 100 times is a sign of bad design choices, 1 out of 100 it is the simpler and cleaner solution. There are several solutions I can suggest ranging from redesign to using *typeof* and unions. If you can post a code example and explain in more detail your challenge, I believe we could suggest a solution that fits you best.
You do understand that tetration grows that fast that for practical reasons you can only compute ^n a for a &lt; 6, n &lt; 6. ^6 2 is 2^(2^65536), that's 2^65536 bits long... 
I do understand that Storing the values isn't a problem 
Well the average computer has around 2^35 bits of RAM, that's 4GB, even if you take external storage into consideration a 4TB hdd has 2^45 bits of memory. Regardless, how did you get O(n^2 ) for tetration? Call T(a,n) := ^n a, let N(a,n) be number of multiplications required to compute T(a,n). Even if you use exponentiation by squaring you have: N(a,n) = log(T(a,n)) + N(a,n-1) //you must compute the exponent T(a,n-1) then compute a^T(a,n-1) This grows really fast ! The log in front T(a,n) doesn't do much, because the numbers are really big... EDIT: Another way to reason about it, the algorithm that computes T(a,n) must at some point write the result to memory, so it means that it must take at least log2(T(a,n)) write operations. You can easily see that log2(T(a,n)) is O(T(a,n-1)). To compute T(a,n) you need at least O(T(a,n-1)) operations! 
Structural regular expressions (theres some papers on cat-v.org). It's also adored by people who think ansi escape code and all the hell with terminals is an annoying piece of crap.
 if( parameter != enumvalue1 &amp;&amp; parameter != enumvalue2 &amp;&amp; parameter != enumvalue3) { abort(); }
Enums are just integers. If your enums are like `enum { zero, one, two, three };` (continuos) and not like `enum { a = 3, b = 6, c = 9, d = 10 };`, then you can just check if the number is within the range of the enum. (eg. `x &gt;= 0 &amp;&amp; x &lt;= d`) I've seen enums that also has a entry for the end (eg. `enum { zero, one, two, three, END };`), that makes it very easy to determine the end of the enum without modifying the code like above, so the checking-condition would be like this: `x &gt;= 0 &amp;&amp; x &lt; END`. Also, if you're doing something on a per-enum-value basis, you can just use the `else` (if doing `if ... else if ...`/`default` (if doing `switch(x) { ... }`. Example: switch(x) { case zero: return "ZERO"; case one: return "ONE"; case two: return "TWO"; case three: return "THREE"; default: return "???"; } 
nice idea having an END member on the enum, maybe in my case (I'm using enum instead of #defines for describing registers addresses on a integrated circuit) using INVALID instead of END is more readable?
I can wrap this inside an static inline function and use it inside the function the user will use, thanks for the idea, I was trying to avoid writing a lot of code but seems one path to consider.
Here is a simple trick to know. Enumerations always increment by one unless you give them an explicit value. An enum can be given the value of a previous value. So when I am making an enumeration, I always create a minimum and maximum value, something like: typedef enum { COLOR_RED, COLOR_FIRST_VALID = COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_LAST_VALID = COLOR_BLUE, COLOR_INVALID } Color_t; Then you can easily check against the max and min valid values with &amp;lt;= and &gt;=. The COLOR_INVALID is a special invalid value you might use if, for example, you are creating a file-scope, static-lifetime variable that is supposed to be read from a file. You could initialize it to COLOR_INVALID and check it elsewhere in your code, to help catch a condition where it has not been properly read. The only downside is that if you change your enumeration, you might have to update the special last and first values.
Good post! To add some of the enums in code I've inherited from subcontractors did similar things but instead it would be typedef enum { COLOR_RED = 0, COLOR_GREEN, COLOR_BLUE, NUM_COLORS, INVALID_COLOR } Color_t; That way NUM_COLORS could be used to define arrays (C++), instead of having a #define e.g. int ColorShade[NUM_COLORS] = {0.0} I never thought about having a FIRST_VALID to easily find the 0th element. Most of my code used the first value name, since it was unlikely to change.
and they would be right. that's why emacs gui is for.
Thanks!
Don't. Don't compare pointers to NULL, don't validate enums. The user wants to shoot himself in the foot. Let them. If you happen to switch on an enum and get an unexpected value - `abort()`, but don't go out of your way doing that. Get an invalid pointer? Dereference it and crash. This makes your code debuggable. Returning error values on validation is much less debuggable than a simple crash you can trivially catch in a debugger. Crashes are error returns too. Error returns where we have developed decades of tools to see exactly where, when and why they happened. No matter how advanced your error handling is it has no chance to match the simplicity and clarity of a crash and a debugger. And most likely your error returns will just be ignored which leads to misbehaving programs that are often much worse than not working programs.
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;openssl/sha.h&gt; #define MIN_SIZE 16 #define LOW_SIZE 64 #define MID_SIZE 128 #define MAX_SIZE 256 int to_hex(char *src, char *result); int main(void) { char input[MIN_SIZE]; // variable for combined input input[0] = '\0'; // initialize it for strcat later char part_one[MIN_SIZE] = "Levi"; // part one of input char part_two[MIN_SIZE]; // empty part two of input // for some reason 81 does NOT work. //int num = 81 int num = 80; // int part two sprintf(part_two, "%i", num); // convert int to char strcat(input, part_one); // store part one in input strcat(input, part_two); // store part two in input input[strlen(input)] = '\0'; // null terminate string printf("%s\n", input); // show it on the screen //-------------------- size_t len = strlen(input); // length of input unsigned char md[LOW_SIZE]; // message digest unsigned char message[LOW_SIZE]; // OpenSSL SHA512 requires unsigned char memcpy(message, input, len); // copy the input to the unsigned char printf("%s\n", message); // make sure message contains input SHA512(message, len, md); // Get the hash and store it in md char sha_result[MID_SIZE]; // Need to store the message in a reg char memcpy(sha_result, md, LOW_SIZE); // copy the unsigned md to signed char char hash[MID_SIZE]; // Variable to store hex to_hex(sha_result, hash); // convert sha result to hex printf("%s\n", hash); // display it on the screen return 1; } int to_hex(char *src, char *result) { int digit; char *src_p, *buffer_p, *buffer_end_p; char buffer[MAX_SIZE]; buffer_p = buffer; buffer_end_p = &amp;buffer[MAX_SIZE - 2]; for(src_p = src; *src_p != '\0'; src_p++) { digit = (*src_p &gt;&gt; 4) &amp; 0xf; *buffer_p++ = ( digit &gt; 9 ) ? digit + 'a' - 10 : digit + '0'; digit = *src_p &amp; 0xf; *buffer_p++ = ( digit &gt; 9 ) ? digit + 'a' - 10 : digit + '0'; // safety net if(buffer_p &gt;= buffer_end_p) { break; } } *buffer_p = '\0'; strcpy(result, buffer); return 1; }
&gt;Returning error values on validation is much less debuggable than a simple crash you can trivially catch in a debugger. Not sure about that. If your code only runs one path of execution and you end up getting a crash every time, then that would be true. But let's say you are relying on undefined behaviour somewhere else in your program which means that you pass an invalid input to the function only very rarely - it's going to be a nightmare to debug that. When you use error codes, sure the user isn't always going to catch the error but in the case that they have inserted error handling code it's vastly better since they can deal with things themselves. If they didn't insert error handling, then it's still their fault anyway.
Not too familiar with OpenSSL, but aren't there some initialisation functions you ought to call first?
I bet you're going out of bounds of the hash array. Hint: SHA512 and SHA512_Final don't add a trailing nul to their output argument since it's not a string. (You should use SHA512_DIGEST_LENGTH for the size of that array, btw)
Woah.... just spent some time understanding this stuff... I don't still... then understanding what your order_n function needs to do.. I am baffled as to how you achieve it like you are frankly... I thought I was on to a winner a couple of times only to realise it wouldn't work beyond 3 and possibly only for the number set I was using. Seriosuly good luck with figuring that problem out will be intersted to see for sure. 
Thank you so much! It works now :) #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;openssl/sha.h&gt; #define MIN_SIZE 16 #define LOW_SIZE 64 #define MID_SIZE 128 #define MAX_SIZE 256 int to_hex(char *src, char *result); int main(void) { char input[MIN_SIZE]; // variable for combined input input[0] = '\0'; // initialize it for strcat later char part_one[MIN_SIZE] = "Levi"; // part one of input char part_two[MIN_SIZE]; // empty part two of input int num = 80; // int part two sprintf(part_two, "%i", num); // convert int to char strcat(input, part_one); // store part one in input strcat(input, part_two); // store part two in input input[strlen(input)] = '\0'; // null terminate string printf("%s\n", input); // show it on the screen //-------------------- size_t len = strlen(input); // length of input unsigned char md[LOW_SIZE]; // message digest unsigned char message[LOW_SIZE]; // OpenSSL SHA512 requires unsigned char memcpy(message, input, len); // copy the input to the unsigned char printf("%s\n", message); // make sure message contains input SHA512(message, len, md); // Get the hash and store it in md char sha_result[MID_SIZE]; // Need to store the message in a reg char memcpy(sha_result, md, LOW_SIZE); // copy the unsigned md to signed char char hash[MID_SIZE]; // Variable to store hex to_hex(sha_result, hash); // convert sha result to hex printf("%s\n", hash); // display it on the screen return 1; } int to_hex(char *src, char *result) { int digit; char *src_p, *buffer_p, *buffer_end_p; char buffer[MAX_SIZE]; buffer_p = buffer; buffer_end_p = &amp;buffer[MAX_SIZE - 2]; src_p = src; int i; for(i=0; i&lt;SHA512_DIGEST_LENGTH; i++) { digit = (*src_p &gt;&gt; 4) &amp; 0xf; *buffer_p++ = ( digit &gt; 9 ) ? digit + 'a' - 10 : digit + '0'; digit = *src_p &amp; 0xf; *buffer_p++ = ( digit &gt; 9 ) ? digit + 'a' - 10 : digit + '0'; // safety net if(buffer_p &gt;= buffer_end_p) { break; } src_p++; } *buffer_p = '\0'; strcpy(result, buffer); return 1; } 
I only need to call an init function if the data can't be stored in memory^1. Then I have to call `SHA512_Init`, `SHA512_Update`, and `SHA512_Final`. Since my data fits in memory, I can use the abbreviated function `SHA512`. [1. Reference](https://www.openssl.org/docs/man1.0.2/crypto/SHA512.html)
If I understood correctly, the second option is correct. For example if you want to modify a 2-dim array sending it to a function, the function must be f(char ***array) 
Why are you allocating inside the function? If you have some existing array and you want to change its contents, you just let the array decay to a pointer and pass that, as in your first example. If you have a pointer to char, and you want that pointer to point to a new array, but you want the function to handle allocating and populating the array, then you need to add a layer of indirection as in the second example. The second example does not work if you already have an array (as opposed to a pointer.) 
It's must-to-read, but you'd better start with something else. K&amp;R is a bit outdated here and there, but in retrospective you may find some useful information with already knowing C from some other source.
Nice read but outdated, better choice, C Programming: A Modern Approach, 2nd Edition
At 200 pages versus 900 pages, I'd stick with K&amp;R for a beginner's first read. This book still sits in my place of honor on my bookshelf
Yeah, I used K&amp;R and I never even read that cover to cover. My biggest gripe is less that it's C89 but that it uses outdated assumptions of being on an old unix system. But I wonder... It might be better to learn C from some OpenCourseWare lectures then use C Prog: A Modern Approach as a reference document. To jump to the sections that are being introduced in video. That's basically what I did with C++ and Python. I used lecture videos then supplemented with The C++ PL, 4th ed or the Official Python Docs. Of course this is if you have already learned one language. Worked better for me at least.
&gt; I'm assuming the end user doesn't care about the warnings root of all evil end user is usually you or your peer or some programmer who can read your puny code &gt; C++ take care of this kind of problems with enum classes, complete bullshit...strong enums make the code safer is a joke. Useless things are being pushed and celebrated as progress 
That book is terrible. Lots of examples are wrong or incorrect, and the author doesn't seem to care. I'd suggest picking up literally any other C book than that one. 
Rely on undefined behaviour and not expecting a crash.. that's some sort of religion?!
The question is whether you're trying to modify str (a pointer) or the array of characters str points to. From the body of the functions you wrote - it's seems that you're trying to do both. This means the second example is the one that "works." However, this is a really odd design. You'd be better off having your function simply return str as its value - and giving it a name that indicates it's allocating memory so that a caller knows they're responsible for freeing it. char *str_alloc(void) {char *str = malloc(SIZE); str[0] = 'a'; str[1] = '\0'; return str;} "Just because it works, doesn't mean it's not broken."
&gt; Not sure about that. If your code only runs one path of execution and you end up getting a crash every time, then that would be true. My systems (development and production) reliably generate core dumps. Core dumps are trivial to debug and really good at catching one off errors. Reliable reproducible bugs are trivially deubggable by anyone using whatever method they want (I once used the speaker in the computer to send me beeps to debug the code for the console). &gt; it's going to be a nightmare to debug that. There is not much difference in code required to reliably crash vs. return an error value. Except that you have a whole operating system to handle the crash for you vs. you have to write the error handling yourself in case of returning error values. Error returns should be reserved for actual enduser errors (permissions, etc.) or hardware errors (bad disk, out of memory). Stuff that requires operator intervention. Programming errors should crash.
&gt; `char**` would be an array of char arrays. No, it's a pointer to a pointer that points to type char. &gt; *(a+1*sizeof(char)) = 'y'; `sizeof char` is always one.
&gt; tl;dr The first one char* is the correct one. Sorry, but no it isn't. A pointer is passed in to the function, which means the function gets a *copy* of that pointer. That copy is changed, and the memory that it now points to is changed. But the new value of the copy never gets out of the function. The caller has no idea of its new value and no way to access the memory that it points to. So not only does this not work, you've also leaked (an admittedly tiny amount of) memory. The second version gives the function a *pointer* to a pointer to a char. It is in effect telling the function "here is the address of a pointer that I'd like you to change." And when the function returns, the caller can look at that address and see the new value of the pointer.
Well I just spent a night thinking about it and turns out storing numbers will be a problem. Pentation cannot run on my laptop. It only has 3GB of memory. Even my workstation with 32GB will be extremely limited. So, for now, I'll limit myself to a series of `else if`, which will initialise `res according to the provided order. --- I was being ridiculous. I wanted to get too mathematical and ended up losing reason. Pentation would kill my laptop, I won't go higher than that (and to say my function supported order 2^64 operations...) The bottleneck here is how the function works. It essentially turns any operation, even exponentiation, tetration, etc. into order 0 operations, or incrementations. I'll be better off making 6 separate functions, one for each order up to pentation, and optimise each function individually. 
I Started K&amp;R as beginner. But I couldn't get any far as I find it difficult to understand. Started Modern Approach, it is much simpler than K&amp;R for me. And now to Head first for some development of games and apps through C.
Well just looking at this function I can guess you are calling it in a loop, in which case it would be better to simply use a loop inside the function so that you don't have to depend on the value of variables that aren't in your scope for no reason (i). In general static variables within functions are perfectly ok as long as there is a reason for it but I see no reason you'd need to use it to achieve what you're trying to achieve, your approach is probably wrong because you're overthinking it.
If you are going to be calling `get_random_shape` multiple times, why not simply declare a global `const` array with the letters? I don't see any real use of declaring that `char` array as `static` in this context.
Because what their code does is shuffle the array, then return its contents one at a time, then shuffle it again, etc. OP, a better solution would be to have a static const string with the letters for all the pieces (`"IJLOSTZ"`) then each time your function is called, get a random integer less than the length of the string and return the character at that position. You can easily tweak the code to make some pieces more likely to occur by having multiple copies of their letter in the string. For instance, if you want the bar and the square to be twice as likely to appear as any other letter, use `"IIJLOOSTZ"`.
The problem with this approach occurs when you have a multi-threaded program. Imagine two programs executing `get_random_shape` at the same time with `i == TOT_SHAPES` at the beginning. If they execute just the right way, both attempt to call `shuffle_array` at the same time, messing up `shapes_letters` pretty badly. However, if your program is single-threaded and you don't plan to change that any time soon, functions can use `static` variables just fine. Some people say that's bad program design, and it is bad just in the same way a global variable is bad. As a rule of thumb, `static` variables are okay if they are also `const` at the same time (i.e. immutable). For example, if you never modify the content of `shapes_letters`, you should definitely make it `static const` as making it only `const` still causes the compiler to put it on the stack frame on every call.
*The C Programming Language* attempts to teach programmers how to C. It does not attempt to teach you how to program or what to do with the tools the C programming language provides you. If you are fine with that, then it's the right language to learn. Other books are longer because they attempt to target absolute beginners at the same time.
This won't do the same thing OP's code does: Namely, returning every possible piece once and then starting over.
This is amazing. A single file, [clio.c](https://github.com/dmulholland/clio/blob/master/c/src/clio.c) of the implementation is over 1500 lines and compiles into 26 kB machine code on my machine. The code uses dynamic memory allocation and non-standard features (e.g. `#pragma once`). The programmer apparently forgot what `const` is and doesn't mark any function arguments in the interface as `const`, even those that really should be (e.g. those where string literals are typically passed). To configure the argument parser, you need to call a bunch of routines, producing many hundred bytes of code. The example code is 76 lines long (though most lines are comments), calls 12 times into the library and doesn't even do anything meaningful with the options it parsed. It doesn't even release the memory allocated for the parser. The parser cannot reliably tell you if an argument was not provided at all. While I understand that this code provides a high amount of features, I must wonder if it's really worth the complicated implementation and usage.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [dmulholland/clio/.../**clio.c** (master ‚Üí e330c25)](https://github.com/dmulholland/clio/blob/e330c25f840d1af6cdc0c7bde5a646190ed9d86a/c/src/clio.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk42uq8.)^.
That's exactly my point. What OP's code does it not how the original Tetris works. But I see now that OP is working off a spec which (stupidly, IMO) requires this behavior.
In this case `_Thread_local` would be an easy fix for thread safety. 
C Primer Plus by Stephen Prata, baybee!
`_Thread_local` would change the behaviour of the function, so not a good fix on its own.
Not really, unless quirky race conditions are part of it's design.
You would have guessed that parsing command line arguments is a [solved problem in 2017](https://twitter.com/kloetzl/status/875029947991040000).
&gt;I saw it was published in 1988 Oh hey you've got the new version! More seriously, this book will teach you C; it won't teach you how to program. If you are a beginning programmer you may want to start with something gentler.
Yep, a count is useful too, just as you described, although again the weakness is that the special values have to be changed manually if the enumerations change, and I've seen that lead to bugs when a program is modified and the person modifying it wasn't careful about the enumerations. It's also important, in my view, to have a naming convention that makes it clear whether the min and max values are inclusive (valid) or exclusive (not valid). As a consultant doing code reviews I once caught a bug in a medical device, an array access bug, which would have stood out immediately, and probably never been written, if a clearer naming convention had been used.
This is seriously wrong: you're allocating memory without keeping track of the previous address. Try calling `change_str` twice: you won't be able to free the previous address...
What's good about the K&amp;R is that even if it's really old, the POSIX interface stayed about exactly the same, and the UNPOSIX interface part is quite an important chunk when learning C.
unsigned int i; //self descriptive signed int i2; //self descriptive int i3;//signed by default
I can't speak for the other languages supported, but python already has a really rich argument parsing library as a part of its standard library. What's this offer that python doesn't already provide?
I noticed that a few hours ago, I can see my mistakes now, I've more experience with garbage collected languages.
Can you recommend any?
See the side bar for plenty of recommendations!
it is an interview question. if you dont know the int declare
https://stackoverflow.com/questions/22497382/how-to-find-out-if-a-variable-is-signed-or-unsingned/22498104
Not a book per se, but a online PDF - a Yale CS C course. Chapter 5 is data structures. [Here is the PDF](http://cs-www.cs.yale.edu/homes/aspnes/classes/223/notes.pdf) 
[This](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1499870290&amp;sr=8-1&amp;keywords=introduction+to+algorithms+clrs) is what my instructor constantly used in class despite my CS department requiring different books for the course. It's seems to be very popular, and in my experience it was very instructive. **EDIT:** don't let the title fool you, there's a lot about data structures in this book, not just algorithms.
Data structures are typically taught together with algorithms. My two favorite books here are Sedgewick's *Algorithms*, and Rivest et al's *Introduction to Algorithms*. Knuth's *Art of Computer Programming* volumes are also excellent, of course, if rather advanced in places. I don't have any recommendations off the top of my head that teach *just* data structures, independently of algorithms, but others may.
Are you saying that you know the bit representation of the integer in memory, but not the declaration? Without any other restrictions on the allowed range, deciding whether that memory pattern represents an`int` or an `unsigned int` is both impossible and meaningless.
I don't know if this is possible to do in general because architectures vary but if you're on a two's complement machine, something like this might work: #include &lt;limits.h&gt; #include &lt;stdio.h&gt; #define N_BITS(item) (CHAR_BIT * sizeof(item)) #define IS_SIGNED(x) \ (((x) | (1 &lt;&lt; (N_BITS(x) - 1))) &lt; 0) int main() { unsigned uzero = 0; int izero = 0; unsigned uone = 1; int ione = 1; printf("uzero: %s\n", IS_SIGNED(uzero) ? "signed" : "unsigned"); printf("izero: %s\n", IS_SIGNED(izero) ? "signed" : "unsigned"); printf("uone: %s\n", IS_SIGNED(uone) ? "signed" : "unsigned"); printf("ione: %s\n", IS_SIGNED(ione) ? "signed" : "unsigned"); return(0); } 
Well to be fair it's not like argp.h has a nicer interface. But yeah, bad implementation.
1) Show your code. 2) When you print a float with `printf("%f")`, the [default precision](https://stackoverflow.com/questions/32117254/what-is-the-history-of-the-default-precision-for-printf-floats) is applied. You may get different results with something like `printf("%4.10f")` 3) It sounds like "Float before atof" is actually a string (`char[]`). When you actually convert it to a float, you have [limited precision available](https://stackoverflow.com/questions/5098558/float-vs-double-precision). You can also play around with the IEEE-754 format [here](https://www.h-schmidt.net/FloatConverter/IEEE754.html).
Your instructor was smart to ignore the department. This is by far the best book on data structures/algorithms. Weighs maths and theory with applicability very well. Good balance between TAOCP and Skiena's Algorithm design.
`argp` is definitely more usable than this. Hell, if your system is complex enough that `getopt` or the GNU extended version isn't enough for you, you may as well roll your own parser for the specific use case.
Yeah, I've pretty much only heard good things about CLRS. I found it to be helpful, especially since I couldn't find one of the other "required" books.
Already solved that, thanks a lot anyways.
There are 2 ways to answer the question 1. Measure it. 2. Look at the generated assembly and guess if it is "better". But the real answer is "it is very, very, unlikely to matter"
The compiler is probably smart enough to put `dude-&gt;age` in a register and access it from there, so it's not going to matter really. However, as with any performance related question, you should benchmark it and see if it makes any difference.
Might be true. Thanks for your answer, will do it :)
https://godbolt.org/g/j7TUVq For -O1 or higher, gcc generates the same assembly for both, showing that it applied the optimization you've shown. When I am writing something like this, I generally assume that the compiler will perform this optimization because it usually needs to load the value into a register anyway, meaning it will likely keep the value in a register for other operations. It should be noted that the two have different behaviors if the struct can be modified by another thread.
Alright, thanks for your answer :)
If all you need is a random char i.e. shape you don't need to shuffle the array. Also if you do what I suggest you wont need the static **i** variable. With my approach you don't have to worry about thread safety. I'd do something like this: char get_random_shape(void) { static const char shapes_letters[TOT_SHAPES] = { 'I', 'J', 'L', 'O', 'S', 'T', 'Z' }; int i = rand() % TOT_SHAPES; return shapes_letters[i]; } I guess using rand/srand/rand_r is not an since you need some randomality to shuffle the array.
Ok so I have a question for you - I've implemented big ints with an array of unsigned ints to hold the bits before for fun. Arithmetic operations were all reasonably efficient, etc. But what I couldn't figure out how to do was (efficiently) convert a very large integer stored this way to a string to display. How would you do it?
Maybe they're getting at the fact that a binary operation promotes signed values to unsigned. E.g. printf("%s\n", (i - i - 1) &lt; 0 ? "signed" : "unsigned"); 
Thank you for the explanation! At the moment the program is single-threaded and I guess it will remain this way for ever. Actually, while implementing this and other functions, I wasn't really thinking about multi-thread and related stuff (I'm a beginner) so thank you, again, to make me notice this. &gt;As a rule of thumb, static variables are okay if they are also const at the same time (i.e. immutable). For example, if you never modify the content of shapes_letters, you should definitely make it static const Well the contents per se are never modified, rather the "position of the contents" inside the array it is (with `shuffle_array()`). Would this behavior still "fit well" for a `static const` variable?
&gt; Would this behavior still "fit well" for a static const variable? Not really as you can't modify const variables.
By order he is talking about hyper operations. So potentially pentation and beyond, uncomprehensible numbers. 