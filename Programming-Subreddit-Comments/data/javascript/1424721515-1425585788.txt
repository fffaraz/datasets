&gt; It's production ready. I'm not sure where this meme comes from. It comes from iojs releasing a 1.0 that they called unstable.
In this post you will find the most recent information about JavaScript gathered during last week! I hope you will find it wery usefull!
I love using it as a loader in webpack. That way I get absolutely painless ES6 and JSX support out of the box.
So it's React+Babel VS Angular+Traceur. Interesting times, indeed. I recently made an Angular+Babel app. In-browser compilation didn't work, but offline compilation did (well, 99%). It was so much fun using ES6 with Angular 1.4.
Webpack looks pretty cool.
Ah, interesting. I agree in general that it seems stable, or at least as much so as node currently is, but you can't really blame people for thinking otherwise.
Hey, gitlet owner, learn to spell license
I don't follow.
http://en.wiktionary.org/wiki/licence
I'm a bit sad you had to write this. It's like a comedian explaining his joke to the audience after they didn't laugh because they didn't understand the humor. Here, you are explaining your parable in detail because its message was subtly conveyed. (An important message about hiring/interviewing I might add.) You have to beat the reader over the head with the points in a detailed breakdown because most people weren't savvy enough to pick it up the first time. I really liked the first story, because it makes you reflect on it for a while to figure out what it is about. Once you have that "a-ha" moment it sticks with you for longer, as opposed to the essay/article form which the reader may forget about in a week.
You don't say
I'm using Babel with Angular and it's been rather nice.
Oh wow it really is that easy to just drop it in, awesome work dude! 
Do many people still use JSDom over Cheerio? 
I want to like Ember. There are many developer's who I respect who love Ember. I feel like it's *my problem* that I have trouble with it. But the learning curve is so damn high, and the knowledge stales so damn quickly. Oh, *this tool* is soooo 9 months ago and you should use ember-cli now instead. So when I go looking for information about how to do something, I'm getting nine month old info that's no longer relevant. People complain about the new-framework-every-three-weeks problem in JavaScript, and I don't think that's what this is. This is the same framework moving faster then documentation and references can support. I develop with Ext.js at my day job, and that has a wicked learning curve too. But it builds atop browser's built in developer tools. It doesn't take running Grunt to do background compilation, running its own server, forcing you to proxy to your data server. This isn't an "Ext's better" argument- it's not. But Ember has such a high upfront cost, and the upfront cost is paid again and again and again. I just want to find a way to actually learn and use Ember- not learn and use Ember's flavor-of-the-month tool. And maybe if ember-cli actually fixes all this now, because frankly I don't know if it does- perhaps they need a name change. The ember developers aren't responsible for all the dated information out there, but as a framework-user I need to be able to find relevant information, and with all the generations of ember out there I don't feel confident I can. Might not be the ember developer's fault there's dated information, but they're really the only ones who can fix it. /rant
If you inspect objects and arrays in the console while they're being modified it can look like weird things are happening because it's done by reference rather by value. The intermediate state isn't reflected. You can get around this by `JSON.stringify`ing the array. Change your logs to `console.log(JSON.stringify(arr));`
&gt; might not like it, but those who have used it or familiar with how React works all agree that React.js is the best thing to happen to front-end development in a very long time. There is no real content in this comment, only opinion - like my comment
Oh my god wow thank you very much I was about to do exactly this for another project ! Thank you for the license too ! I am going to make one pretty calendar generator and thank you in the footer !
You could just make your own: elem.className.split(' ')
Is that wise? React might be fashionable right now, but opinions change. It seems like an es6 (or es2015 or whatever) transpiler should focus on converting the newest versions of the language into older, more widely supported versions. What if a rival to react emerges that also adds syntax? What if several do? Solid extensibility hooks seem like a better investment than baking in support for a particular currently popular language extension.
I would suggest you publish a pre-transpiled version to npm so people can `npm install` and `require()` it. Also, you can omit the @jsx pragma comment since React 0.12 :)
Another thing implemented in Javascript for no reason. Atwood's law continues to hold. 
 var classArray = [].slice.call(elem.classList); ES6: var classArray = [...elem.classList]; If you only want to join them, you can just use `elem.className`. (That one is as-is though. It may contain duplicated class names. It's not a set.) Kinda sad that they fucked all those APIs up. There are array-*like* objects everywhere. Dart did this right. All list-like things are lists.
I made some demos showing off some of the more impressive improvements we have made in this release. http://samccone.github.io/marionette-2.4-demos/
&gt; pared down FYI
Ask StackOverflow.
It's my understanding that you can enable and disable individual transformations, including JSX. So if you don't like JSX, add it to the blacklist. If a JSX rival comes out, add it to the whitelist. Babel is very configurable. 
The Carpenter has written the most es6 code I've ever read. const, default parameters, arrow functions, let, Symbol, destructuring assignment, generators, computed property names, template strings (ie backticks), for ... of, and maybe some more I missed.
He explained very well his reason
I stopped reading at the example and started skimming. Why? It felt like a pointless exercise to me. I know the guy is intelligent, but it began to feel like a "gloat". Also, in all the years of development I've never heard Halt used in JavaScript. I suppose you could have a halt in Node, but there's really no such thing in browser code unless you consider a crash a halt. The second point was the confusing wording. The first paragraph explains that the tiles have arrows that show the direction the checker should move, but the second decides to toss that all aside and expects the user to call out directions based on the rules of a board they can't see?? Maybe I'm reading it wrong, but it feels like a trick question.
I think it may have been unclear in this article that it's actually a follow-up to this article: http://raganwald.com/2015/02/21/interviewing-for-a-front-end-job.html It's clear from there that most of that code is meant to exist already, and he was simply being asked to fill in some lines to make it work.
&gt; Deprecate Marionette.Controller, Use Marionette.Object instead. I *love* how they make changes from release to release that force us to refactor all of our applications we want to update to a new version. It began with thinks like the renaming of `Layout` to `LayoutView`, the (indeed correct) idea to remove `Region`s from `Application`, the renaming of `itemView*` to `childView*` and so on and so on. We are not that happy over here.
just be glad you don't have to upgrade from angular 1 to 2.
I solved that problem by not using angular 1 (anymore) lol
harsh!
Yeah... It felt like he was talking about an interview that had occurred.
It's very nice! Thanx!
Err... Marionette follows semantic versioning. This is just a deprecation notice rather than a feature-breaking change. Breaking changes only occur in major-version revs. https://github.com/marionettejs/backbone.marionette/blob/master/src/controller.js Controllers still exists until v3.x
Not sure why you weren't able to get in browser compilation working but it's a bad idea to do that 99% of the time. Edit: Also it's not really a versus situation, the JavaScript community needs to drop this work-against-each-other mentality.
Ember CLI is a successor to Ember App Kit, which was a skunkworks project, and was fairly clear about that. Its point was to figure out the requirements for Ember CLI. Ember CLI is the officially blessed path forward, and will be incorporated into the official guide docs, replacing the Ember Starter Kit global namespace stuff, in the near future. The basic principles of the framework haven't changed much, though, and you could use Yeoman generators, and Gulp builds, or whatever you want, and that's not Ember the framework getting in your way. Whichever way you do it, it hooks into the Ember resolver, and you're still architecting your app the same way even if your files are arranged a little differently. Tooling is always going to change and evolve, but nobody's holding a gun to your head to adopt the new stuff. You can keep a project pinned down to a specific version of Ember and whatever tooling you use, and it'll be stable for as long as you decide not to upgrade. You can always manually patch in changes for security or whatever. But when you start a greenfield project, and it's time to update your tools, because you want the new features, that's always going to be a cost to pay, and maybe it's not worth it every time. Everyone's still figuring out the best ways to do this stuff, and tooling is going to reflect that. Ember CLI offers a suite of tools that are curated to work well together that suits common workflows. Having a separate frontend server that has mocked out API responses, or can proxy a dev backend server is a nice feature. So are partial rebuilds and auto refresh. To my knowledge, other frameworks aren't developing tools to package all of this functionality as neatly. Installing Ember CLI and doing an `$ember init` is a pretty smooth way to get started if you ask me. But Ember the framework has been more or less API stable since September 2013 or so, and the API docs are generated from source, so they're always up to date. If you've learned to use Ember the framework, Ember CLI is a nice convenient package, but is just kind of details. If you haven't learned to use Ember the framework, the tooling isn't going to make any difference. --- That all said, they are deprecating ObjectController and ArrayController, and are trying to figure out how to transition to routable components for Ember 2.0 right now, so I guess this isn't the most compelling time to say all this stuff. But there's a migration path planned that isn't big bang rewrite your whole app, so that's something.
You should be aware that the timestamps inside event objects are often different than the ones that could be collected with new Date(). Also, if event.stopImmediatePropagation() is used, you might lose the event if you use bubbling. If the page was using jQuery for events exclusively, I would overwrite the jQuery event triggering with my own function to collect all event data and then trigger the event with the original arguments in its original scope.
Interesting move for them to force people to use iojs if they have so many organisations/developers that rely on it. They'll stick with node out of fear of stability issues with iojs, and ultimately move to a different package I guess 
lead developer?
&gt; bobHasedSecret You may want to do a quick edit and name it `bobHashedSecret`.
Chrome has `monitorEvents` in it's Console API, [docs here](https://developer.chrome.com/devtools/docs/commandline-api#monitoreventsobject-events). You can see the source [here](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/inspector/InjectedScriptSource.js&amp;l=1781). Looks like only a couple of functions needed, `monitorEvents`, `unmonitorEvents`, and `_normalizeEventTypes`.
Console.log breaking with different "this" values is extremely annoying when you want to pass it to a function just to see what's going on. Instead of stuff.then(console.log); you have to write stuff.then(console.log.bind(console)); EDIT: Another example I have in mind is [my rant about Ember.js's decision to add if statements in the template engine](http://www.reddit.com/r/javascript/comments/2v7obo/emberjs_110_released_with_htmlbars_block_params/cofw44j?context=3)
I think you misunderstood. OP was asking about using Array.prototype methods on a classList. I am using `join` in my example because that's what OP mentioned in the question. I was not suggesting that the result of this operation would be an array, merely that this was a way of achieving what was explicitly asked in the question (calling `join` on a classList). The method I've shown should work just as well with nearly any of the array methods (e.g. `map`, `filter`, `indexOf`), although some or all of the mutating methods, like `push`, `pop`, `forEach`, etc., likely won't work (as well they shouldn't). OP didn't give any details of what they're trying to do, so I can't speak to their specific requirements, but generally it's going to be better to just make use of the Array.prototype methods as I have demonstrated, instead of actually converting to an array. E.g. // convert to array var classArray = [].slice.call( elem.classList ); // classArray === ['foo', 'bar, 'baz'] elem.classList.add('qux'); // classList is updated, but now classArray is out of date classArray.push('quux'); // classArray updated, but classList will not reflect these changes
To give MS some credit - the IE technical preview has the best ES6 support of any of the browsers right now.
I wished we could use ui and region inside all types of views instead of having to initialize them myself.
/r/learnjavascript They have a list of resources on the sidebar IIRC
I blame Lisp, Haskell and CoffeeScript, languages that make it seem as if these things are normal, everyday features, and that any programmer can merrily use them without worrying that their colleagues will state blankly at the code.
I don't know the compatibility of this code, but my guess is browser support.
I opened the article expecting another stupid JavaScript wart, as in "Why? Because JavaScript" and was pleasantly surprised to find an astute mathematical reasoning behind it. 
$.Deferred ()
This looks a lot like my [Task Runner](http://bvaughn.github.io/task-runner/) library. Both are new. Any interest in collaborating?
Sigh.. point entirely evaded.. 
Haven't read it, but O'Reilly's “Speaking JavaScript” looks good and can be read online for free: http://speakingjs.com/es5/. You can also dive directly into the the upcoming version of JavaScript with “Understanding ECMAScript 6”, also free for online reading: https://leanpub.com/understandinges6/read/
I think that "filter" demo should be case-insensitive. I was typing names wondering why nothing was coming up, until I realised it needed a capital. That's not good UX. :)
I agree. What do you think it should return? NaN? undefined? If this were any language other than JavaScript (or maybe Perl) I'd say throw. In this case, I'm leaning towards NaN, since people are likely to do some math with the result, so if you used undefined, that would just become NaN.
Yes, that's actually what the article goes on to explain, so your post is like a tl;dr
How large are your numbers and how many decimal places? I usually just convert to int then back to decimal: &gt; 1.01+1.02 2.0300000000000002 &gt; (101+102)/100 2.03
`NaN` would make perfect sense, since `Math.max( undefined )` returns `NaN`, and when an argument isn't supplied it is undefined, for example: function typeofArgument( arg ){ console.log( typeof arg ) } typeofArgument() // undefined So there's no reason to make `Math.max() !== Math.max( undefined )` other than implementation details as outlined by the article.
Either your opinion of yourself is far higher than merited by your experience as a developer or you sadly underestimate mediocre JS developers (who are able to unobfuscate even heavily obfuscated code with relative ease and therefore obviously better than you at JS). Either way, you're wrong.
She
In my mind tl;dr was just this line &gt;Math.max() is *not* Number.MAX_VALUE. It is for comparing a list of numbers and returning the largest. It naturally follows that it *must* return *the lowest possible* number if no argument is given. And vice-versa for Math.min(). I just can't believe that till today, and even after coming across this "paradox" many times I didn't know Math.max()'s *purpose*. I just thought it was one of those javascript "quirks". So really, the tl;dr should simply be "Math.max() is a function! with a very specific purpose. What value it returns isn't what one might stupidly assume is analogous to what its name suggests."
wrong sir, why u mad? Perhaps this place is more towards your personality /r/circlejerk 
"Best". Heh. All of them are slow and ugly. Without operator overloading, they never will be pretty. Just use this one: https://github.com/MikeMcl/decimal.js/
Hence why I asked what your limits are. JS is accurate to 15 digits (almost 16, 9E15 or so), so assuming reasonable currencies: ( x*1E5 + y*1E5 ) / 1E5 will allow numbers up to 90,000,000,000 and give you 5 decimal places to work with. There's not a currency in the world that uses more than 4 decimal places, so 5 gives you accuracy to that. Considering that the lowest value currencies in the world are on the order of ~25,000:1USD, this gives you ~$360,000 USD in _any_ currency and significantly more in most (if you intelligently modify the exponent based on the currency (it's _almost_ always 0 or 2 digits except for like 3 currencies)), this limit is $360M USD in _any_ currency. If you need numbers larger than that you can use any number of "large decimal" libraries, but most of them are insanely heavy. I'd suggest rolling your own for what you need.
&gt; setInterval(shoot, 10); I totally beat your puny score!
In chapter one you correctly state that JS doesnt have block scope, but then in chapter two you go right ahead and write something that kinda looks like block scope for (var i=0; i&lt;names.length; i++) { var name = names[i]; That's not a good way to write that and I think it can cause some confusion. It gives the impression that the name variable will be declared 4 times and each block will have its own name to pass to the callback. But because of hoisting what actually happens looks more like this: var name; for (var i=0; i&lt;names.length; i++) { name = names[i]; This form helps the user see that the name variable exists outside of the block and will itself change before the callbacks run.
This was originally developed to support another project at work where we primarily use mocha. Now that it's open source I agree it would make sense to be compatible with other testing frameworks/libraries. Pull-requests welcome :)
I prefer the style of having each Grunt task as a separate file in a `tasks` directory, and then loading them via the Gruntfile with `grunt.loadTasks('tasks')`. This keeps your Gruntfile clean, and prevents you from mixing things between tasks or having to have some massive God-hash to configure stuff. [Here's an \(untested\) example](https://gist.github.com/zakangelle/3e191f4f73382fdfdf45) of how I would write a task to compile a set of SASS files to different locations, given a list of brand names.
One could conceivably accidentally pass undefined, which would result in max() returning NaN. This seems like a better default return if arguments is empty. -Infinity is a number, and this behavior seems likely to cause runtime errors or weird bugs.
Updated post with link to page with demos
Way to try and outshine my response, sam. ;) 
It would also be handy in events if defined as part of a factory called in the callback. Say for example you have 2 buttons and want to animate up and down. You could use jQuery libraries and all, alright, but what if you want to do it only with vanilla JS? you first declare a function that will handle the animation: parallaxEffect: function() { var move = document.getElementsByClassName('parallax-group')[0], point = 0; // closure eh // allows us to access var point at the previously updated state, always in the same scope return function(dir) { var orientation = dir === 'down' ? -1 : 1; point += orientation * 500; // reset scrolling when we are back to home page if (pageName === pageOrder[0]) point = 0; if (point !== 0) { move.style.webkitTransform = 'translateY('+ point + 'px)'; } else { // allow time to hide the transition back to 0 setTimeout(function(){ move.style.webkitTransform = 'none'; }, 300); } }; }, then you assign that function to another one, that will keep your scope alive within that function: closure. animateParallax = parallaxEffect() animateParallax is now a reference to the innerFunction (you can pass the argument) but alive in the scope of the outer function (you can access its variables) then you can call on click or other events/trigger: animateParallax('down') or animateParallax('up') The interesting thing with this is that you only have one function for the whole animation process, and your point will be consistent and kept alive whether you slide up or down. 
I 'd like to add that this article, while very technical and heavy to digest, really explains well the whole process of the closure: http://jibbering.com/faq/notes/closures/ and especially in the way functions are declared * Activation object * arguments * scope * variable: parameters (to arguments) &gt; inner functions &gt; variables which are first assigned undefined. That's where hoisting can happen * this
 var max = Math.max.apply(Math, array_of_numbers_from_elsewhere) And that array could turn out to be an empty array.
Yeah that's a good one. One issue that I have with it is that it suggests an *inner* function must be *returned* from its original lexical context in order to form a closure. I prefer a broader definition of closure that is basically synonymous with functions. All functions are closures.
This is when: &gt; Math.max.apply(Math, [1,2,3]); 3 &gt; Math.max.apply(Math, []); -Infinity So if I'm building an array, and using its Function.prototype.apply to pass in multiple arguments via the array, if that array's empty then I get -Infinity. So if my code's like this, I could be in for a surprise if my set is ever emptied: function smallestVsLargest(arr1, arr2) { var min1 = Math.min.apply(Math, arr1); var max2 = Math.max.apply(Math, arr2); return min1 &lt;= max2; } In this example, we're checking if the largest from the second array is greater than or equal to the smallest from the first array, e.g. `smallestVsLargest([1,5], [2,3])` returns true. We get some odd behaviour if I say `smallestVsLargest([], [2,3])`, that's now false, even though you'd think the minimum of nothing should be less than 3. Furthermore, if we say `smallestVsLargest([], [])`, you'd think they'd be equal, so it'd be true, but it's actually false because somehow a maximum is `-Infinity` and a minimum is `Infinity`. Personally I think it ought to just return NaN, but I think the reasoning they have is similar to how `1 / 0` is Infinity, which would make mathematicians cringe, but for programmers that often makes perfect sense. All that aside, I think most of these would be edge-cases that you ought to just check for in the first place -- look for an empty array before passing it to Math.min or Math.max.
This is pretty slick!
I read from your article: hiding/encapsulation solves the interface/export issues. Don't fret too much though, I most likely don't read your articles patiently enough, forgive me, more a visualize person myself, too much wall of code, would like some core concept graphics for entrées.
Done! good catch! many eyes make for better crypto!
Technically, there is a [#0](http://puppydev.com/2015-02-14/d3-js-layout-tutorials-prologue) too.
Transpilers work very well for ES6--&gt;ES5, so I don't think it's the same as previous eras.
Your error is here: max(min(), max()) = **min()** 
Suppose you have a function that returns the sum of all its arguments. Call it Math.sum. What should happen when you call it without any arguments? It should return the additive identity; i.e., the number that, when it is included as an additional argument to an existing Math.sum call, it does not change the output value. `Math.max() === -Infinity` satisfies this behavior. If you call `Math.max(num_1, -Infinity)`, you always get `num_1`, as there does not exist a number n such that n &lt; -Infinity. ~~Showing the same for Math.min is left as an exercise to the reader.~~
Variables declared with `var` even as part of a `for` statement don't have block scope: var array = ["a", "b", "c"]; for (var i = 0, element; i &lt; array.length; i++) { element = array[i]; } console.log(i === 3); console.log(element === "c");
https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md Huge list of free books
Nice! requirejs has the `onError` method and you can override it to send errors to ga too.
Thanks for your informative answer! &gt; use a tcp socket to connect to google.com:80 How do I use a tcp socket? What does this entail? 
The difference between my comment and your comment, was I went about things a little bit more constructively. I detailed why I use it and how many of my colleagues and developer friends have moved away from heavy SPA frameworks to the simplicity of React.js.
This may not be exactly to your taste in learning styles but the Mozilla Developer Network is a very deep and authoritative source. In particular here is a page that nicely serves as an exhaustive list of all the APIs you may have access too: https://developer.mozilla.org/en-US/docs/Web/API
If it makes you feel any better, it is given that the Carpenter is an experienced developer, and we can tell from the story he was comfortable with ES-6. He may have put that on his resumé, and Christine would have known that he was experienced and comfortable with ES-6. Perhaps with someone else she may have asked, “Are you more comfortable with ES-5 or ES-6?” before writing out the template. That seems like a reasonable way to go about things if you accept the premise that a coding test is a good idea at all.
Not necessarly. Let A be the nonempty set [5]. Then min(A) = 5 max(A) = 5 but then `5 ≮ 5`, so the intuition you stated above does *not* hold.
It's probably because web technologies are extremely accessible. All you need is a browser to run your program.
Considering Web development is easy to get started (at least), People who wants to code right away get in the Web. Plus, there's a lot to Web development for it is more open in nature (cf. Platform-specific development, e.g. mobile apps).
&gt; In JavaScript, you don’t find the class keyword You do in modern JavaScript (ES6). It's just syntax sugar for prototypal inheritance though. 
&gt; Second, the function being executed in setInterval gets executed regardless of whether or not the previous call to the function has completed. This is bad for animations and AJAX calls that have to wait for a server response. Is the author seriously suggesting to block the page while waiting for a server response or animation to finish? because the code in the article does not wait for any callbacks the executed code might have.
Use requestAnimationFrame for animations. https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame Use a polyfill if you support IE &lt; 10.
Great point, if it is possible to use CSS3 animations it should drop in the appropriate info but I have to support older browsers as well and this performs for IE7+ Additionally, I don't have to have some gif to load I can just create elements and size appropriately. Thanks for the feedback and I'll look into adding something like that for the next version.
Author here. Let me clarify the point you've quoted. The issue setInterval encounters is when you've given a callback function that may take longer than the time specified in the delay. In this case, setInterval will run its callback function again, regardless. With a recursive setTimeout, there is no overarching process adding to the call stack. It is the current invocation that decides if and when to add another setTimeout to the call stack. While this may not give you a perfect interval each time, it will prevent the callback function from executing prematurely.
This is an awesome reference Thanks
who the fuck has ever posted to reddit for an actual purpose?
&gt; this performs for IE7+ A valid point. Though, we're fast moving into a world where the old IEs (8 and under) are becoming widely unsupported (a lot of major sites are supporting only one version behind). That said, one always has to take into consideration user base and client concerns.
The post the started the 'with' hate: http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful/ This guy doesn't seem to think it's bad. http://webreflection.blogspot.com/2009/12/with-worlds-most-misunderstood.html Of course, he also seems to think long chains are a good idea. Take it for what its worth. I don't personally have any strong opinions on the matter as I've never felt compelled to use 'with' for any reason.
Yup, Promises are better than callbacks (at least in my opinion) but they still leave you wanting more. Not sure why this discussion is getting down-voted, but... such is Reddit.
It's C/C++, not JavaScript. Or more precisely: C/C++ -&gt; Asm.js -&gt; some bytecode. Also, modern JS VMs already do compile JavaScript. V8 doesn't even have an interpreter.
&gt;Fourth, stopping setInterval using clearInterval() works, but does not tell you when it’s actually stopped. As soon as betterInterval has stopped, you can check execute.stopped to be sure. Huh? after clearInterval returns the function will never get called again -- it is "stopped" immediately. The whole "stopped" concept is slightly off, the function is not "running": JS is single threaded. It's more properly "scheduled" or "queued" to run, and clearInterval unschedules or dequeues it. The only way I can see that this would matter is if some subroutine the interval function calls is trying to cancel the interval, but in this case the behavior is the same for both cases: the call stack finished unwinding always. The plus to clearInterval is that the function is not ever invoked again. This design leaves the timeout scheduled and simply aborts scheduling itself again when it's finally called. That's slightly less efficient.
This is not recursion. It is a function that re-schedules itself. Like calling requestAnimationFrame from inside the requestAnimationFrame callback to get called on the next frame.
So... C-&gt;JS-&gt;bytecode+interpreter-&gt;JS Engine? Clearly got it the first time. So at least two layers of compilation. Awesome. Brilliant. Let's just make browsers general purpose vm managers ffs and stop wasting our time. This is fucking absurd. 
Nitpicking here? Intuition suggests for nonempty A min(A) &lt;= max(A) but never min(A) &gt; max(A). OK?
Basically it's showing a implementation detail, m=-Infinity; if value &gt; m, m = value. The initial value is -infinity or +infinity. However, it does not do anyone any good ever to call these functions with no-args. 
An important characteristic of max is that it is monotone. Given two sets A and B, then max(A) ≤ max(B) whenever A ⊆ B. Since the empty set is a subset of every singleton set {x}, we must have max(∅) ≤ max({x}) = x for every x, which forces max(∅) = -∞.
Java != JavaScript. They are only barely related only in that they are both programming languages. They have completely different uses and very little in common.
I kekd when I saw "x-post r/java"
There's no benefit in OOP in prototypes than classes - and they're a damn sight less intuitive too. 
In fact, the keyword itself has always been there. Just not used.
Correct. The scope of the parent is inherited, which works as well in the global scope (what you're referring to) as in an "inner" scope, in another function. Ultimately, it's the same thing and makes more sense to call all functions closures, since it's a hierarchy that starts at `window` (in browsers), or `global` (in node).
It's because you can't tell what it does. Each time that `with` block is hit, it can do something else. function func(obj) { var foo = 5; with(obj) { console.log(foo * bar); } } func({bar: 3}); // 15 func({bar: 3, foo: 7}); // 21 - this foo shadowed func's foo func({}); // ReferenceError: bar is not defined It also prevents that function from getting optimized.
&gt; every other language I've used, classes... So what you're saying is: You didn't use a lot of difference languages..? There are plenty of languages that don't use classes or have a non-C-struct-inspired class design. The way Java (and to some degree C#) implement classes is *not* objects sending messages to each other (OOP), it's based on the hacky way C++ implemented OOP because C++ was constrained by compiling down to C (in the very beginning). Calling Java out as "how OOP should be done" is interesting to say the least.
Shouldn't we be recommending babeljs or any other ES6 compiler at this point? Starting new code today using some oo lib seems weird.
[Mirror](http://webcache.googleusercontent.com/search?q=cache:I58BNV-HedYJ:jibbering.com/faq/notes/closures/&amp;hl=en&amp;gl=us&amp;strip=1) in case anyone else has issues accessing the site like I did.
I use [Kramdown](http://kramdown.gettalong.org/) + [CodeRay](http://coderay.rubychan.de/).
&gt; We'd get MUCH better quality JS if it followed basic class OOP! Do you have any proof of that at all? Actually, classes are hardly intuitive unless you're an entomologist. Classes are good for *classification* of things, but not so much for modelling processes. And our brains are much better at understanding things by analogy and difference ("this thing is like that one but with this characteristic") than by classification ("this thing is a kind of that thing which is a kind of that other thing").
Firstly, json will be much easier to parse than a text file. If you can make it json, do it. Secondly, it sounds like you have access to the data, so why not past it into the console and save it as a var? (Assuming it's json) If you don't want to paste it in you'll need to run a local web server to serve your file so you can dynamically pull it in. If you're in a Mac or Linux environment this is fairly easy, I'm not sure about doing on a Windows box.
I thought the same. There are plenty of other form validation libraries that are smaller than this if that's all you need.
It mostly comes from Douglas Crockford's designation of *with* as a 'bad part'. Crockford's argument is that *with* is slow (though it really isn't in the grand scheme of things) and that its behaviour is unpredictable. I can see the rationale for that. In any case, *strict mode* forbids us using *with*, so I guess any discussion now is academic.
Agreed. They should rewrite async so that it would be modular and you could just require the methods you actually need. Some promise-libraries ([Bluebird](https://github.com/petkaantonov/bluebird) for example) offer methods to convert callback-style functions to promise returning ones. `var fs = Promise.promisifyAll(require("fs"));` 
Accessible from a superficial standpoint (you can 'run' a web application by writing a .html file and opening it in your browser,) but the conceptual gap between that and building an actual useful (and usable) application, and figuring out how to deploy and scale it is fucking huge, and fractal in nature. I'd argue that some of the trickiest problems in computer science today are being solved in the web realm.
Is it really worth it to use Backbone based frameworks when *insanely* better alternatives exist; i.e. React.
Hey, I had a look at ES7 async/await...it's nice! http://jakearchibald.com/2014/es7-async-functions/ Why didn't EcmaScript come up with it before :D?
Depends on what your looking to get out of it...like the article said, ES6 classes are syntactic sugar. Libs like this still provide features that don't exist in ES6 classes: private properties, multiple inheritance, python-style classes.
Try node.js to communicate with the remote server directly?
If you can run a local script, then just put your JSON data in the same script.
jq is an excellent tool. I often wish there was a similar tool for YAML.
It looks like there's no way to have it *not* pretty print its output.
If indexOf returns -1, ~indexOf() will return 0 (falsy). In all other conditions where an index is returned it will be truthy. There doesn't seem to be much of a performance difference. http://jsperf.com/array-tildeindexof
&gt; that it suggests an inner function must be returned from its original lexical context in order to form a closure. Also, if they're arguing that a literal return is required (which they seem to be), this isn't even correct. No returns required. E.g.: var foo; (function bar(){ baz = 'hello' foo = function(){ console.log(baz + ' world') } })() foo(); // prints 'hello world'
This code is pretty nonsensical as JavaScript and doesn't even purport to scroll. The function's name is `zoomImage`. JavaScript statements are delimited by semicolons so why not break that statement up by semicolon and then try to understand the code. Ask yourself, what are `gt`, `lt`, and `obj‘.
&gt; They're both simpler conceptually and far more powerful. That's subjective. I disagree with both those sentiments. But to each their own, yes?
Sincerely curious when you do not want pretty printing. Also there might be some old Unix utility like fmt or sed that can do what you want.
Is there an `.all()` function? I was not able to find it in the [jQuery Deferred object API](http://api.jquery.com/category/deferred-object/) documentation.
you should be able to pipe it through uglify.
- `name` is the field that will be submitted to the server when the form is submitted. `id` is a unique identifier - `name` doesn't have to be unique in all cases. If you aren't submitting to a server, I don't think you need `name`, but I'd check out the docs. - Instead of binding `calculate()` to `onchange` manually in every function, bind it to the onchange event of all `myform#form input[type="number"]` elements in one line.
Gotcha. Now I've got some direction. Thanks.
`data.val` is accessing the property `val` on your object, _not_ the named property, e.g. `communicatie`, like you are thinking. `data[ val ]` is what you want, which actually evaluates the string `val`
That's a really unfortunate, egotistical response to the whole thing. I'd also suggest it's more or less inaccurate. The term 'isomorphic javascript' was coined by a dev and then the term spread. It's that simple. For anyone to use a different term to refer to the same subject now would just introduce confusion. At a point it's just the most effective way to communicate. If you are a graduate of a math program (as opposed to studying currently) and still have these sorts of responses to things I'd like to suggest, respectfully, that you might benefit a bit from taming/observing your own ego. Maybe give a try to meditation and see how it might help you. The human in me hopes you stop looking at things exactly the way that you do right now. edit: It would also be worth mentioning that the word isomorphic has its own definition outside of mathematics. Furthermore, there being a contextual meaning for the term in computer science or software engineering is perfectly reasonable.
http://jsfiddle.net/ovyydwm9/2/ See this. The way events work is an event is emitted from an element., and unless you have an event listener that explicitly stops the event propagation, the event will will be emitted for the parent element, then the parent of the parent, and so on until we reach the document level. Listening higher up means fewer event listeners, which will help performance. In this case, we can just listen to events in the form#gutter.
It's because `document.querySelectorAll('form#gutter input');` returns a `NodeList`, so I loop through it to get each Node in the list so that I can use the `Node#addEventListener` method on it. However, I just recommend using jQuery. It's a popular Javascript library that exposes a `$` object that makes DOM manipulation much simpler as a beginner. It's also much easier to get help with jQuery -- easier to Google for. Here's the same example using jQuery: http://jsfiddle.net/ovyydwm9/3/
Awesome. This is a bit easier to understand. Thanks for your help. Cool name, BTW. I'm a Jacob too. 
Thank you again. Yes, all the answers I found were for jquery. Good advice.
Blog author here. Good points. As to performance: There's only one Nashorn engine created on server start. Also the vendor scripts get evaluated only once. Nashorn compiles the script to bytecode so executing the script is quite fast. I don't think creating the HTML as a single String is much of an issue performance-wise. But that might depend on how big the rendered HTML is. One thing to keep in mind is that Nashorn is only thread-safe as long as the evaluated script doesn't share state. I'm not entirely sure if that's true both React.js and Showdown.js as used in the example.
It's less versatile but if you just want to view pretty json in your browser for web development, tools like [JSONView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) for Chrome do a great job.
There are builds for Windows too, I think.
If you're already an expert Dev, I think you could learn a lot more from reading the code for an open source project like [Ghost](https://github.com/TryGhost/Ghost/) than with any tutorial.
from the man pages: --compact-output / -c: By default, jq pretty-prints JSON output. Using this option will result in more compact output by instead putting each JSON object on a single line. 
I use node-webkit (nw.js) to write cross-platform desktop applications, with angular 1.x as the front-end framework. It is so flexible that I can write angular directives, controllers, services that leverage nodejs functionality. You really should check it out, webviews for the type of thing you describe sounds annoying. Using react or angular 2.0 won't magically fix the problems you will have using webviews, but nw.js probably will.
Yes, someone else suggested your method as well, and that's what I'm using. Thanks.
Hi /u/msanand, please read reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. In short, you should post from a variety of sources, and not just `anandmanisankar.com`. **Consider this your only warning.** Continued posting of only a single source will force us to take action. Thanks for your understanding. domain submitted from|count|% :-|-:|-: [anandmanisankar.com](/search?q=%28and+site%3A%27anandmanisankar.com%27+author%3A%27msanand%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|44|100%
I can live with that. Just to show my perspective, if you're curious, here are some links: This seems to pop-up in every prototypal vs classical discussion. It's a good read: http://aaditmshah.github.io/why-prototypal-inheritance-matters/ The paper that started it all: http://www.selflanguage.org/_static/published/self-power.pdf And this classic stackoverflow discussion: http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical/16872315#16872315 Feel free to pass along anything that you think supports your position as well. I haven't found much, so I'd be interested to see what's on the other side.
&gt; Do you know any tuto where I can really learn what makes javascript a different language? Not a tutorial as such, but the Crockford YUI talks, while old, are bloody good. https://www.youtube.com/watch?v=JxAXlJEmNMg Watch those, then leap forward in time a few years and watch [this](https://www.youtube.com/watch?v=PSGEjv3Tqo0).
Accessibility experts will tell you not to do this. There is no way to describe the value of an attribute or structure its content with additional meta data.
More of an HTML question then, yes? MDN to the rescue: For the list (multiple) https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select or (type checkbox) https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input For the table: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table You can build all of those easily enough in JS, should you be required, with document.createElement, Node.appendChild(), HTMLSelectElement.add(), etc.
That depends greatly on the application, doesn't it? The 'why' matters an awful lot here.
I appreciate the response and helpful links, however, could you perhaps show an example of it, using a list of items to be chosen, such as: Sword, Shield, Bow &amp; Arrows, etc? I'm having a hard time translating what I see on those sites to what I need specifically.
I don't take the position that classical inheritance is superior. I disagree with your sentiment that it is inferior. The burden of proof is on you. 
The question was very very general, there's still legit reasons to add image to text. 1. If you're pushing image + captions to S3 from a mobile device. 2. If you created a photo application in the web that people can add text to, and save on their desktop. 3. A visual fallback for older browsers that cannot render things like drop shadows. Use something like Fahrner image replacement for this.
checkout http://rawgit.com
what if said 'feature' made a image self documenting and you never saw the ugly pixels that represent the data.. then it wouldn't be a accessibility issue but a issue of why you didn't think of doing this in the first place.
What happened to it is you posting opinions to support an argument. If that counts as proof...
Also, there's already money in Node anyway, Joyent is not a charity.
At 44K compressed and minified, it does not seem to really make that much of a difference and can be used for many other things, such as ajax for example. If the libraries mentioned are jQuery plugins, we are looking at about the [same footprint](https://www.airpair.com/angularjs/posts/jquery-angularjs-comparison-migration-walkthrough)? You mention other libraries that would give the same functionality, can you point me to one that you recommend for this, and would they would give the same functionality of showing messages/enabling disabling buttons as we type? 
&gt; first AJAX request. lolz. Just use jQuery. Nonsense. The vanilla way is ridiculously simple, and does everything the jQuery version can do. The difference? It's a single, very small, function that anyone can easily write and customize to the needs -- not a bloated, buggy, slow, general purpose library. I don't see the need for bootstrap in this context either. Though, to be fair, I don't see the point of using bootstrap in *any* context.
Does jq load the entire JSON file to memory? 
The point is made, you agree that jQuery is unnecessary. I suspect that you'll also agree that it's ultimately worse for the end users. (Please don't say CDN, you surely know better than to use that long-debunked argument!) On CSS, yes, I always write that myself. It's easier than trying to get a generator or other tool to produce what you want. (The resulting code is usually much cleaner and simpler as well.) It's difficult to dispute that CSS is ultimately better for the users than using JavaScript to apply styles. Not just for performance, but accessibility as well.
i just double checked, it was already using your code but mozilla doesn't want to zoom larger... with your jquery code, chrome and opera is fine... zoomImage = function(e) { e.originalEvent.wheelDelta &gt; 0 || e.originalEvent.detail &lt; 0 ? obj.ratio*=1.1 : obj.ratio*=0.9; setBackground(); } this is the rest of the code below that obj.spinner.show(); obj.image.onload = function() { obj.spinner.hide(); setBackground(); el.bind('mousedown', imgMouseDown); el.bind('mousemove', imgMouseMove); $(window).bind('mouseup', imgMouseUp); el.bind('mousewheel DOMMouseScroll', zoomImage); }; obj.image.src = options.imgSrc; el.on('remove', function(){$(window).unbind('mouseup', imgMouseUp)}); return obj; }; jQuery.fn.cropbox = function(options){ return new cropbox(options, this); }; }));
&gt; Why are you so adamant that it is "better" in the absolute? I wasn't, that seems to be all in your head. But it's true that it is better, objectively better. As per my assertions: I claimed that it was conceptually simpler, which is objectively true as there are fewer concepts you need to understand. I claimed that it was more powerful, which is also objectively true as there is nothing classes can provide that prototypes cannot, yet there are many things that prototypes can provide that classes cannot. I've provided evidence in support of those assertions, as I thought you'd be interested (was I ever wrong!).
Here you go: https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers
Would you care to provide a proof that your server-side and client-side Javascript are in fact isomorphic? 
setInterval might be the easiest one for you to understand, as all you do is pass it an interval and a function to call every tick. As tiny an example as I can make: var elapsedTime = 0; var startTime = Date.now(); setTimeout(updateStuff, 1000); function updateStuff() { timeElapsed = Date.now() - startTime; } It's not my personal preference, but it'll do the job. Ed: If you want to display the time on the site, you'll also what to update that when you update timeElapsed 
&gt; please provide a rigorous treatment on why isomorphism is the correct term You can't show working out which was never there in the first place. That's the term the first person to do a significant/popular blog post about the concept happened to coin for the concept, so that's now the term most commonly associated with the entire concept, for better or worse, regardless of how technically correct and/or accurate the term, was, is and will be. See also "ajax" for the concept of making HTTP requests for content which almost certainly isn't XML.
lolololol
Well technically you could implement operator overloading: http://www.2ality.com/2011/12/fake-operator-overloading.html
Similar to how `sed` would not commonly be used in a production application, this is a tool useful during development or debugging. For example, if you have a test fixture of JSON data and you want to set all of one field to one value (e.g. clearing out sensitive data).
It's still happening. Development is ongoing, with 1.9-dev available to download (complete with async/await support!!!!). I think we may now have a situation where Dart programmers are too busy coding and not so busy hyping. Don't worry, I'm sure the hype train will get moving again soon.
*Second-hand info, take with a grain of salt* i have several friends and acquaintances that work at Google doing primarily Angular/Python work that all say something along the lines of "Dart is going downhill, nobody uses it except the Dart team." Does not give me a lot of faith.
&gt; That's not too much to ask from JS devs, right? Yet again, you're really showing your ego in your post. You're being diminutive of others and it comes across like you have a vendetta against "JS devs" as if the whole of them have some property you don't like or an inherent flaw. Whilst I understand a desire - or even eagerness - to point out the "misuse" of a term, I'm not sure why your demeanour is the way it is. If you're angry, you're probably better of suppressing your anger in your posts and you'll get better responses. If you're not angry, you give the impression that you are and should do a better job communicating. Also, from Merriam-Webster: &gt; isomorphic: being of identical or similar form, shape, or structure &lt;isomorphic crystals&gt; I understand that you have a bias towards the meaning of the word isomorphic aligning exactly with what you've come to understand it to be, within the context of mathematics, but the reality is mathematics as a field or a context has no absolute ownership over the word. You seem like someone who perceives themselves to be intelligent and is bothered, one way or another, by the notion that others think themselves intelligent or are happy regardless. I'd suggest using your intelligence to analyze the sources of your mood and behaviour and become a better person for it. You communicate really poorly and you seem like an asshole.
I agree. Instead of spawning bash, why not use native libgit2 bindings? https://github.com/nodegit/nodegit
Thanks for the tip, but almost all requireJs errors can be easily detected on distribution building step.
If you put it that way... you're right. But it might be useful to detect wether someone has timeout errors if you leave a couple of libs off to be loaded asynchronously.
document.write() simply appends stuff to the page once. What you want to do is select an element on the page and change its value each time you run display(). You're already doing this with document.d.d2.value = ... The simplest way to update your stats would be to make them like this: example statistic &lt;span id="stat1"&gt;0&lt;/span&gt; example statistic &lt;span id="stat2"&gt;0&lt;/span&gt; example statistic &lt;span id="stat3"&gt;0&lt;/span&gt; Then INSIDE display() have document.stat1.textContent = seconds*5; document.stat2.textContent = seconds+37; document.stat3.textContent = milisec/Math.PI; Or the slightly better // Outside display() startTime = Date.now() stat1 = document.getElementById('stat1') // Inside display() stat1.textContent = (Date.now() - startTime) + " milliseconds since page load" **Edit:** Here's a JSBin of what I'm talking about: http://jsbin.com/sadarafafe/1/edit
Oh, yep, it might be really useful for requireJs-based projects to detect such cases.
* **These are just my opinions.** * 1. Only chrome ̶h̶a̶s̶ ̶a̶ ̶b̶u̶i̶l̶t̶-̶i̶n̶ ̶will have Dart VM.No other browser vendors will probably ever implement the Dart VM. 2. Dart feels like Java. Not everyone is fond of class based OOP. 3. Vanilla JavaScript itself is very flexible and good enough for everyone else. EDIT: Dart VM in Chrome is in development https://www.chromestatus.com/features/6682831673622528
Seems like it lost. I believe the original intention was to build it from the ground up with features that made it easy for the VM to optimize so that it could execute faster than JS. However, it seems like people generally think that JS on V8 and SpiderMonkey is "fast enough" and it's not worth the trouble to invest in another VM.
There was a recent [discussion on the Dart mailing list](https://groups.google.com/a/dartlang.org/forum/#!topic/misc/1NGgpXaxru0) that shows the kind of force the Dart has been against now. Mostly, Microsoft created TypeScript and is supporting TypeScript in their VS.NET toolset. Now Dart has lost its thunder. With most support for Dart coming only from Google, it's much more difficult to make Dart relevant to a greater community. Google competitors may have been all too happy to make Google to eat humble pie with Dart. It seems that the industry as a whole is all too happy with "evolution beats revolution." Even in the design of Dart that was probably a little revolutionary, they adopted a lot of evolutionary ideas. They borrowed a lot from ECMAScript 6 ideas so Dart was more like JavaScript. So in the end Dart was neither evolutionary nor revolutionary. That's why people may dislike it too. :-) ECMAScript 6 brought about a lot of changes. JavaScript is a big language. Dart is a smaller language. That's why people are also happy with Dart and may try to use it for other purposes outside the browser. Dart gives them a platform that could have the feature of just being more stable than the competition. Java, JavaScript etc are being further developed. With Dart they could just sit on it forever and just tweak the backends. I don't know what it will happen.
That won't do the trick. It can't even do: decA = decB + decC &gt; \+ only works with primitive values and thus needs to convert obj1 and obj2 to primitives. It does so by invoking their valueOf() method. Fake operator overloading is much less useful than real operator overloading: You don’t get access to both operands at the same time and you can’t influence the value returned by +. The _ setter trick at the end of the article also doesn't really make this stuff usable.
The strategy of designing it before releasing it as a standard seems to have backfired; without an active community outside of google, Dart continues to lose momentum the less google cares about it. It has all the disadvantages of a relatively obscure language (harder to find developers that are already familiar with it, fewer resources), and the fact that the main production target is transpiling to javascript makes you lose out on most of the advantages of using it in the first place. People just aren't really looking for another javascript. (Now, if the dart project had been to create a universal bytecode for the browser allowing a slew of new languages as is often wished for, maybe people would be excited. But a language-specific VM with no support outside google is pretty sad.)
What you are missing is that the used object can come from anywhere. In practice it does, because using `with` with an object, which was declared just above, isn't very useful. To understand what the code inside of a `with` block does, you have to know all the objects which are currently passed to it and all the objects which will be passed to it in the future. As /u/itsnotlupus mentioned, the properties of an with'd object can shadow *any* identifier in that block. In my example, "console" can be shadowed as well. You simply cannot reason about the code in a with block, because you don't know where any of the used identifiers came from or where they are supposed to come from. This is very different from lexical scoping or function scoping, where the inner stuff shadows the outer stuff.
What is the point of spending all that effort on something that compiles to another language? It's a catch 22. If it compiles to JavaScript, then JS is good enough - so why do we need Dart? It may as well be CoffeeScript. If it doesn't, then it has no browser support, so no one will ever develop with it. Was doomed from the start.
We need Dart just like people need TypeScript, BabelJS etc. JavaScript is hard. Browsers have differences that can be difficult to deal with every time you start a project from scratch. It helps to have a language or a library that deals with the differences so developers don't have to. Also, before Dart people would already write JavaScript in a format that was good for the Closure Tools that Google used for linting, minification etc. Dart just does it all by default. While Dart sounds great if we put it in those terms, the reality is that debugging is still hard. They are now [experimenting with a new compiler](https://github.com/dart-lang/dev_compiler) that would produce JavaScript code that was more idiomatic so it was easier to debug it for other browsers that don't support the Dart VM. Ultimately though, I think the world needed a language that was public domain or close to public domain. Java was difficult because it was owned by a company that was suing people who wanted a slightly different Java for their platforms. C# is also owned by Microsoft for the most part. [Dart has been standardized.](http://www.ecma-international.org/memento/TC52.htm) The Dart implementations also have open source licenses. [Dart is now on GitHub.](https://github.com/dart-lang) And Dart could do away with a lot of baggage that JavaScript had, while JavaScript is still changing to be "modernized". So yes, now that mobile platforms are stealing the show, it is good to have languages like Dart that you don't need to pay royalties to use or to license them for every phone/device being sold. But that also makes other companies to hate it.
Obligatory http://www.google.com/trends/explore#q=%2Fm%2F0h52xr1%2C%20TypeScript&amp;cmpt=q&amp;tz=
Not everyone likes OOP..? People prefer procedural? 
Everything ultimately compiles down to Assembler/machine language, therefore Assembler is good enough. So why do we need other programming languages at all?
Hi /u/mi6crazyheart, it looks like your post/comment was caught by the spam filter because you used a URL-shortener. Please repost without the shortened URL.
There are many programming paradigms, not just the two. And in some cases procedural is a good fit. With Linux for instance, procedural programming has arguably resulted in better performance. But, I also suspect that the OP was specifically referring to Class based OOP. Because JS itself is actually Prototype based, a different kind of OOP. If you aren't aware of the other styles, worth checking them out and the pros/cons of each. http://en.wikipedia.org/wiki/Programming_paradigm
It's making steady progress. It got async/await and enums recently. Yield, async\*, and sync\* will be there soon. Isolates (~actor-like concurrency) are about to get *much* nicer to use. Regexp got a lot faster. Server sockets can now be shared. (**Edit:** across isolates!) There is now an analysis server which will make it much easier to get things like auto-complete, call-tips, and error checking in other editors. There is now a new and improved code formatter. There are probably a few other important things which were improved. These are just the ones which are relevant to me. Anyhow, Dart isn't just an alternative to JavaScript (i.e. client side scripting). Since it has its own VM, which can be used standalone or embedded in other applications, you can use it for anything you want. ES6 certainly doesn't make it obsolete since ES6 does very little to improve the tooling. Maybe ES8 will add things like optional types and operator overloading, but I won't be too optimistic about that. I still view Dart as the best currently available scripting language.
It's closer to C#. Also, TS isn't all that different. It also got optional types and classes (oh no!).
&gt; Why bother when they already have Go? It's not like everyone wants to use Go. I certainly don't. If I were to write some low-level code, I'd rather use Rust. &gt; [Dart] is pretty slow in its current form If you compare it to all the other scripting languages, it's in the top group. It's much faster than PHP, Python, Ruby, or Perl.
I'm not sure what I said that makes it seem as though I'm projecting insecurities, but all is fair in reddit comments! Sorry if I misjudged, I'm sure you can see how if I thought you were the same person following up to the other post it'd have come off as "more of the same". Your argument is fair, I guess. I think at a point once a term has a certain meaning in a given context there's not much sense in trying to unroot it.
The sed metaphor holds well here. Most use of jq is going to be interactive shell one-offs as part of a pipeline. Web APIs often return JSON, and it's a common config file format. JavaScript doesn't need to be involved to parse or emit it. Would an example help? 
&gt; The strategy of designing it before releasing it as a standard seems to have backfired Huh? Is there any other language which was created the other way around? Of all programming languages, a few have a language specification, and a few of those are also standardized. Dart was actually kinda unique because it had a language specification right away. &gt; harder to find developers that are already familiar with it That's actually not a problem. You can just hire C# developers.
Does Firefox say anything [on the console](https://developer.mozilla.org/en/docs/Tools/Web_Console) ? You could also set a breakpoint using the developer tools in each browser an compare locale variables, e.g. values stored in `e` and `obj`.
It's really quite simple: It didn't occur to me until you brought it up.
Wow, that's some horrible abuse of React right there. *Cringe*
No. More. Fucking. Flux. Implementations. Even Facebook realized that Flux was a bad idea; hence the abrupt about-face and move to Relay (which does away with the notion of user defined "stores" entirely in favor of declarative queries at the level of components): http://facebook.github.io/react/blog/2015/02/20/introducing-relay-and-graphql.html 
ah ok, that makes sense
Wow, that top commenter sounds really desperate: &gt; of the languages that you mentioned are either very very early, only exist in a presentation deck Uh, if he's referring to ES6; he should know that half the fucking javascript world is using some form of a transpiler and writing ES6 already. In production.
How about we took javascript and made it completely object oriented? That's how I felt when first hearing about it.
no nothing, I can see that it tries to zoom out for a micro second then it seems like it changes its mind and starts shrinking the pic
No matter how difficult this problem is, you don't release a version 1.0 without fixing it. Firefox users had to wait some time until Dart 1.6 fixed a bug. (By the way: the release notes of Dart 1.6 failed to mention that every Dart program needed recompiling.)
"..offer methods to convert callback-style functions to promise returning ones." That is quite useful.
He was referring to SaneScript and SoundScript.
For V8, tabs are probably the best option with the "inline a function" optimization limited to 600 characters. I haven't tried it yet, only saw the announcement. Since it's a rewrite I hope he fixed that awful `for (var` is a stop error.
Nodejs is not only used for web servers. I've written git front-ends in nw.js before. It's not a security concern if nodejs is being used as a back-end for a desktop application. 
idk i use it in production. I have never personally come across an extension that works with node 0.12 and doesn't in io.js ([node-sass included](https://github.com/sass/node-sass/issues/653)). Furthermore I think by "production ready" most people are wondering if io.js is going to crash on them. Compatibility problems don't really fall into that bucket, as far as I can tell if it it's compatible, it's stable, or at least as stable as you'd expect node to be.
`for (let ...` should work fine. I'd also expect that indention doesn't count towards that limit. Well, since it's just some heuristic, it probably does. This won't affect minified code though.
It just looks like there's a bit more work to be done on iojs to make it and the node ecosystem usable in Windows 8.1.
&gt; No matter how difficult this problem is, you don't release a version 1.0 without fixing it. Right, because every 1.0 had zero open issues. Also, it's not like this kind of problem doesn't exist with JavaScript. Every library update can break your project and every piece of code on the page (even ads or analytics) can break your code. Dart does successfully guard against a lot of that. Just not against browser-sided class renaming yet. For actively maintained projects, this really isn't much of a deal. It's also not like they randomly rename some classes which each browser update.
Functional programming feels more native in Javascript rather than strict OOP. Actually good JavaScript code will implement a mixture of both designs.
Does not, *yet* https://www.chromestatus.com/features/6682831673622528
including whitespace, according to unsourced sources. Really interested in learning about those arbitrary restrictions.
Gotcha, I'll just say "Hit Ctrl + D" to bookmark
Why is it good Not to use semicolons I never will understand (mind the missing "," and ".") :/
Oh Dart has features like optional types, method cascades, classes that work as interfaces and many more. I think for example people would rather Dart made types mandatory like in other languages, that it had macros like in other languages, that it had interfaces like in other languages. Often people want features that are already present in other languages. It takes a lot of bravery not to just copy C# and call it a day, say. :-)
Funny you ask, I stopped using it a week ago, uninstalled ... Even though Dart was a revelation to me and I really like the features it brings, it will never make it to another browser than Dartium. ES6 is almost there and tools like babel make it easy to use right now.
Looks like you answered the question but files actually don't need the .js extension. For example, name.php could generate a JavaScript file and send back the content with a JavaScript response header. The name and extension is simply for the client-side request.
You're missing the point. Is Dart easier to code in than Javascript? Does coding in Dart &amp; compiling down to Javascript give you potential debugging issues? There's value in coding in a language abstracted away from Assembler.
If only! Front end webdev coding in Python would be a dream. It'd be like CoffeeScript but good.
15 years or so ago, doing that via window.external.addFavorite (or something like that) was kinda popular. Well, putting it on a page was. Today's browsers don't seem to support it anymore. Even IE doesn't.
You need to show your code for us to help you. Try posting it to something like [pastebin](http://pastebin.com).
here is a question: if you like Dart, why did you stop using it? e.g. you seem to be fine with using JavaScript compiler like Babel which gives you features that are potentially year(s) away from being adopted by all browsers. so what was the show stopper for you?
This is IMHO. Dart was born out of frustration at Google with JS and mess caused by the ECMAScript 4th edition debacle. Things have changed in the last couple years and the evolution of JS is in top gear. The landscape is very different now and Dart today simply has too few advantages and too many disadvantages compared to the competition which is mostly TypeScript and related projects like AtScript. (To be honest I can't think of any major advantages of Dart over TypeScript.) AtScript, SoundScript and SaneScript projects at Google are evidence that Dart is losing mind-share at Google itself. 
20 years ago, it even didn't require any user confirmation ^^^^^Which ^^^^^meant ^^^^^a ^^^^^few ^^^^^surprises ^^^^^after ^^^^^browsing ^^^^^porn ^^^^^sites ^^^^^:)
+1. My comment makes no sense you're right, I might as well go back to using Dart
I still use it, but then I don't use it in an automated capacity. The white space thing is largely irrelevant for me. If I am dealing with some code that does not pass the JSLint white space test then I pass the code through a beautifier before linting.
I think [ScalaJS](http://lihaoyi.github.io/hands-on-scala-js/) has more future than Dart these days.
Microsoft is not a competitor in this area, specifically the web, so they have near zero affect on Dart's success.
I think there's a really important lesson here for new languages: 1) Pick a killer feature that no one else has. 2) Focus on it absolutely and make it fantastic! 3) Profit. For go, it's a great concurrency story. For rust, it's the GC free memory management. For Dart, it was never really clear what the hell it was. It was just all round a bit better at most things than javascript, but you had to transpile it into javascript to use it, so it was never any faster or actually particularly better. So, seeing that wasn't really working, they started trying to make the dart story 'one consistent language on the frontend and the backend' ...but with emscripten and other compile-to-javascript LLVM based languages, and you know, *node*, that was a non-starter from the beginning; plenty of competition in that space already. So then they said, ok ok, so we'll make our flagship UI library in it, and that's the killer feature, it's not the language, it's the ecosystem with angular and polymer. ...except then the angular guys flipped them off and decided to write it in AtScript instead, and the whole web components thing is all over the place now, with webcomponents.js officially declaring it only cared about evergreen browsers (so screw using this in any business setting anywhere) and react (which *does* support IE8) massively gaining traction. ...what astonished me most is the absolute denial that anything is wrong. Seriously, if you work on the Dart project *WAKE UP GUYS*. Your project is directionless and floundering. There's still time for Dart to become a serious contender... but it's fading fast. You've probably got one last chance at I/O this year to really *really* impress people with something that no one else can do... but that's probably about it. 
If you're building this for a company _or_ if you want a more thoroughly tested framework with more middleware, etc choose express. If you want a framework that's much nicer to work with, don't mind writing more of your own middleware, and don't mind running node with `--harmony` enabled, choose koa. note: I don't _necessarily_ see koa living that long, but the code base is so light that this isn't as big of a deal as it is with other frameworks. The best technology doesn't always win :( I've been running koa in production for almost a year now, no issues with it. &gt; The underlying co library relies heavily on Promises but the JS community seems to be quite divided on them. The JS community isn't divided on promises, the node community is divided on whether they should be the default async method in node. I completely agree with the "official" stance that no, they shouldn't be. Node made the decision years ago to use callbacks and let the community implement whatever other async methods they want on their own.
Well, if you have a large codebase which uses tabs for indentation because your company's style guide says so, then you certainly won't change all of that because Crockford thought this personal preference is the only one that matters. That's just not how it works.
That, and JavaScript is just still really popular. Probably as popular as it's ever been in my estimation. TypeScript and Dart and just fighting for scraps from the JavaScript table. Not really something you can build a business around.
Technically, if you use Babel, you aren't using vanilla JS either. JS is of course being used. Writing larger applications in plain JS is of course also possible. It's just needlessly difficult, because your machine will provide very little assistance. It won't even be able to identify the dumbest errors. Imagine you update some library, because you really need some new feature. You didn't read the changelog too closely and you missed that there was one breaking change. The signature of one function you are using has changed. With JavaScript, you'll need at least one unit test which exercises at least one of the lines where this function is called. Otherwise, you won't be told about this problem. With static analysis on your side, you'll always have this safety net. You can be a lot more confident about the code, if you know that you always pass the right amount and the right types of parameters. You also know that you aren't doing something with some return value which you couldn't do, because the analyzer will remember that this thing you stuck into that `var` came from a function which returns a particular type. You should of course have plenty of unit tests for every project, but do you actually have plenty of unit tests for *every* project? Probably not. Having more information right at your fingertips is also very convenient. I'm using jQuery for almost 10 years now and I still have to visit http://api.jquery.com/ to look the most mundane things up. Those settings/options objects are really terrible. You always have to check the code or the documentation for that. With named arguments you don't have that problem. Your editor can tell you what's available and what the default values are.
&gt;I don't _necessarily_ see koa living that long, but the code base is so light that this isn't as big of a deal as it is with other frameworks. The best technology doesn't always win :( I had a similar feeling but it's only a gut feeling. Curious what got you to a similar idea the Koa might not live that long? Is it because of what you mention below about promises? &gt;the node community is divided on whether they should be the default async method in node. I completely agree with the "official" stance that no, they shouldn't be. Node made the decision years ago to use callbacks and let the community implement whatever other async methods they want on their own. &gt;but the code base is so light that this isn't as big of a deal as it is with other frameworks How can you code your Koa application to make it less tied to the framework, so that if you had to move to another one like Express it would be less painful?
&gt;the node community is divided on whether they should be the default async method in node. I completely agree with the "official" stance that no, they shouldn't be. Node made the decision years ago to use callbacks and let the community implement whatever other async methods they want on their own. Curious on what's your opinion on what will become the more popular way of doing async once ES6 and ES7 become widely used? I don't have much practical experience with JS yet so I'm not sure how unpleasant it really is to use callbacks for production apps. How do people using Express generally do async, is it using libraries like caolan/async?
I completely agree and I am not advocating such. I tend to put a throw away beautification step before linting, because some of the code I analyze is horrendous.
Why not post the code online for multiple to examine? * https://gist.github.com/ * http://codepen.io/ * http://pastebin.com/ * http://jsfiddle.com/ * http://plunkr.co/
&gt; It was just all round a bit better at most things than javascript Or PHP, Python, Ruby, Perl, Lua, ... Dart isn't just about doing things in browsers. It's a very fast general purpose scripting language with excellent tooling. &gt; emscripten No one is going to write frontend code in C/C++. If you have a game engine, sure, excellent use case. Interacting with the DOM? Hell no. &gt; then the angular guys flipped them off and decided to write it in AtScript instead The design of 2.x is heavily based on AngularDart's. Keeping two codebases in sync is very problematic. Using AtS and compiling that to JS and Dart makes a lot of sense for that project. This move will actually vastly improve the Dart version since it's now the same as the main project. Before, it was just a side project. &gt; polymer Still a "developer preview". The JS version, too. 0.8 will break a lot of things and it will also remove some features. &gt; webcomponents.js officially declaring it only cared about evergreen browsers Well, that's just the general direction of the web. Spartan will be an evergreen browser, too. We only have to wait for the older IE versions to bite the dust. Then it's evergreen party time for everyone.
Of all the things you could build as a client-side JS app, why on earth would you choose to build a content-heavy, interaction-light *blog* as one? I mean tutorials are good, but you should always choose the most appropriate tool for the task. For a blog you have a site full of static content that should be individually-addressable, easily accessible to users and SEO-friendly. A traditional, progressively-enhanced site does all that straight out of the box, and you have to go *out of your way* to implement most of those things in a client-side JS framework. AngularJS tutorial: great. Choice of worked example to build an AngularJS tutorial around: terrible.
Dart has types and is a saner language. That is the benefit. In dart you can say a method takes 2 parameters and one of those parameters is a horse object, the other is an integer. Now everyone that calls that method must provide a horse object and an integer. They can't leave off a parameter or add an extra parameter (like javascript). They can't give the method 2 Fish objects. They must provide a horse and an integer. Dart has modules built into the language and it has tree shaking to remove methods from the compiled javascript that aren't used. The end result is that you can used a nice large set a libraries and have the outputted javascript end up being pretty small (if you don't use mirrors....). Dart's debugging capabilities aren't really that bad either. The ide and dartium work well together. It is easy to set breakpoints, inspect variables, etc, like you would most languages. Beyond that, it has decent auto complete. And then the JS produced by dart is pretty spectacular. It is, generally, just as fast as what you would hand write. There is very little overhead in it for using the dart language. Dart does a lot of things well, IMO. The problem I have with it is that google looks like it is pulling a lot of support away from it. Development has definitely slowed down on the IDE and the VM. The push to get it into chrome seems to be vastly diminished. Google sponsored libraries and APIs are few and far between. One telling aspect of this is the performance page that dart hosts. Once upon a time, the performance difference between the VM, the generated JS, and the output JS was huge. The VM was roughly 2x faster than the compiled js. Well, it just sort of sat there. Now the native and generated JS are nearly as fast as the dart VM. To me, that says that there aren't many people working on VM performance at this point. Which means, to me, that they VM has less support than it did in its heyday.
Yea, C# is just the closest one. Dart certainly is very easy to learn since there aren't any weird gotchas. The scoping works as you'd expect, `this` is always what you think it is, there is no type coercion, tool-tips show you around, and most errors are immediately caught. The biggest gotcha is probably that enums are more minimalistic than one might expect. Usually, you can at least assign integer values. Well, JavaScript doesn't have any enums at all. I don't think we'll see those before optional types. Enums only start to make sense when you can express that some function takes some enum's value as argument.
&gt; Imagine you update some library, because you really need some new feature. You didn't read the changelog too closely and you missed that there was one breaking change. The signature of one function you are using has changed. Imagine you're using Babel and the same thing happened. Imagine you use any product and the same thing happened. Too many people rely on helpers to avoid knowing the basics. They can't add without a calculator. 
&gt; it needs a community of people excited about it or just stuff it into the browser alongside javascript.
&gt; if (!!err) wtf is this? why not just use if (err) instead? sorry for possibly dumb question, I've just started to learn JS.
&gt; Not everyone likes OOP..? People prefer procedural? ever heard of functional programming?
&gt; google looks like it is pulling a lot of support away from it. We really aren't. The team is as large and active as its always been. It looks quieter for a couple of reasons: 1. **We've recently gotten a lot more internal customers at Google.** That means more of the Dart team are supporting those folks, which isn't publicly visible, unfortunately. But, as you can imagine, it's really important for Dart's success. There are more people using Dart at Google today than have ever used it. 2. **We're doing a lot of infrastructure changes.** We've moved a lot of packages and subprojects that we maintain out to [separate GitHub repos](https://github.com/dart-lang). Unlike [bleeding_edge](https://github.com/dart-lang/bleeding_edge) which is just a mirror of the svn repo, most of these are canonical repositories for packages. If you just watch the main svn repo, activity has slowed. But that's because people are spending their day committing to lots of separate Git repos. For example, several people are hacking on [**fletch**](https://github.com/dart-lang/fletch), which is an experimental Dart VM to play with different concurrency constructs. Meanwhile others are playing with an experimental [**dev_compiler**](https://github.com/dart-lang/dev_compiler) to produce simpler, more debuggable JS. [**Polymer.dart**](https://github.com/dart-lang/polymer-dart) is still cranking in its own repo. 3. **Also, a number of people in both dart2js and the VM are busy implementing async/await, generators, and async generators.** That's obviously a good bit of work. We've been publicly quieter because we're in a phase of doing some reorganization, some experimentation, and some rethinking. I think all of those are good things, and the team is more energized right now than I think we've ever been. &gt; Development has definitely slowed down on the IDE and the VM. We've shifted focus from the Dart Editor to supporting IntelliJ and other existing editors. People would rather use the same IDE or text editor that they already know and love and have Dart support added to that then learn a new IDE from scratch. These days, I use IntelliJ for Dart stuff and it's much happier in that than I was in the Editor. From what I hear, the Sublime Text plug-in for Dart is coming along too. &gt; Now the native and generated JS are nearly as fast as the dart VM. To me, that says that there aren't many people working on VM performance at this point. A lot of that comes down to V8 getting faster. Looking more broadly, that's certainly a good thing for the world. The VM is getting faster, but we're talking two of the world's fastest virtual machines. There are no easy way to improve perf when you're already at the peak like that. What we've seen is any time the Dart VM folks come up with something clever to improve perf, the V8 folks can often apply the same technique. That's great for making the world's web applications faster. It's less great for making Dart faster *relative to V8*.
 &lt;ab&gt; HAHAHA DISREGARD THAT, WRITE PROSE/GUIDE DOCUMENTATION INSTEAD (with apologies to bash.org)
This is true, but I'll note that Dart isn't "strict OOP" by your definition and is actually really nice for FP. It doesn't require you to define classes or place all of your code inside them. It has really solid block scope, lexical closures, and a nice syntax for lambdas (no terribly verbose `function` keyword, nice `=&gt;` lambdas). I'd rather write functional style code in Dart than in JS.
&gt; You are basically left to re-write everything in dart and start from scratch. We are absolutely working to improve this.
&gt; makes you lose out on most of the advantages of using it in the first place. Personally, for me, nearly all of the advantages of Dart are developer time. I think Dart code is easier to write and more enjoyable to read and maintain. It's definitely easier to statically analyze and find my way around a large codebase. As long as I can compile that to *something* that runs on user's machines, I'm happy. Transpiling to JS is a perfect solution for that.
The VM also supports ARM and MIPS. You can use it on Android. E.g. you could write an NDK/C++ game and do all of the scripting in Dart. I hope we'll see something like Phonegap with native Dart support. Or something like Impact's Ejecta. That would be really cool.
All 1s and 0s are just stored in a magnetic platter on your hard drive. Why use 1s and 0s when you can use a very small magnet and a lot of time?
Which is all great. The problem is how this looks to someone like me. Ok, internal infrastructure changes, projet shifts, etc. That is all great. The team is the same size, great. But what do I know about it looking at the mailing list or the news.dartlang.org? Nothing. It is great that more and more people internal to google are adopting dart. And I think in the future that will mean good things for the language as a whole. The issue is that you are sacrificing external adoption by having no public face to these sorts of changes. GWT did something similar. After roughly version 2.4 it sat idle externally for a really long time. While the team would say "Yeah, we are working hard here but we are supporting our internal clients" That was pretty much the end of discussion on what was going on with GWT. That hurt adoption IMO. It was in that lull that dart was born and the external perception was "Ok, looks like google is pulling support for GWT and moving it over to Dart". I guess my point here is that there isn't, IMO, very good communication with the dart and non-dart community about what dart is and where it is going. I mean, even in this thread, we still have people spouting "Dart is only for chrome".
I'm not an expert on all things Angular but the impression I got was that they want a way of adding annotations and types so that they can do run time introspection. ES6 doesn't enable this, thus the need for better language. 
I'm on the Dart team. We have more internal customers today than we're ever had. We're doing great internally right now. We have an increasing number of increasingly happy users. The only bad part about it is that it makes the team publicly look like it isn't doing as much because we end up spending more time supporting them. If I recall, the Go team went through a similar phase a few years ago.
It's not bootstrap. https://flightjs.github.io/ 
&gt; should we only hire someone who already knows Twitter Flight No. You're going to have a hell of a time finding someone with previous experience with twitter flight. You just reduced your potential pool of candidates by ~98%. Even if it was a popular framework like angular I would personally not have it be a requirement. Just hire a decent front end developer and give them 3-6 weeks to get up to speed. 
Why not just print the error in the catch block?
Yes, they really liked some of Dart's features which they made good use of in AngularDart. That's why 2.x looks pretty much like AngularDart.
Just wanted to say that I don't agree with everything in there, and a lot of it should just be taken as a guide, not a rule.
REAL programmers use butterflies. They open their hands and let the delicate wings flap once. The disturbances ripple outward, changing the flow of the Eddy currents in the upper atmosphere. These cause momentary pockets of higher-pressure air to form, which act as lenses that deflect incoming cosmic rays, focusing them to strike the drive platter and flip the desired bit. 
I would say there are lot of bad advices.
Excellent - 60% of my traffic is in Chrome, so this will work nicely, and get even better as more browsers implement it. Thanks!
How would working with Python hinder their adoption of a Javascript technology? 
Was pretty much going to echo the sentiment by /u/loz220. Back when I was looking for work, too many employers "required' Backbone experience, or Angular, or Ember, or some other-god-knows-what-else. They didn't care that I could write Javascript proficiently or that I was a quick study, only that I had a deep understanding of these frameworks, which is, quite honestly, not a good approach to hiring talent lol Frameworks are just a toolbelt to a developer, a developer should know how to wear that toolbelt but know how to learn how to use any of the tools they're unfamiliar with. 
Hmm, maybe I'm wrong. I *thought* I recalled hearing around the office that we'd done some benchmarking between node and our IO libraries and were faster these days, but I could be wrong.
Uhhh.... no. Microsoft, and their products, are a relatively minor player on the web.
True, but also you have to deal with JS's unfortunate semantics for `this` binding. ES 6 has at least better syntax so you can express what you want, but you still have to *think* about it. In Dart, there is a real distinction between methods and functions, which means it can do the intuitive thing regarding `this` automatically. You *never* have to think about it when you create a closure. It just works.
Yes, correction: mainstream language :P
We just need to realize the world is going to hell in a handbasket and accept that fact: http://www.google.com/trends/explore#q=%2Fm%2F0h52xr1%2C%20TypeScript%2C%20Coffeescript%2C%20selfies&amp;cmpt=q&amp;tz=
Actually, after testing it out, I see no reason to not just throw the error directly, [like so](http://jsfiddle.net/ccqm6fv4/11/). In Chrome, the error is expandable, and the line numbers appear on the right side. The only case I would imagine to do otherwise is if you need to report the error in a different way. For example, I have a server that emails me any uncaught errors before crashing and being restarted.
1) Strong talented programmers will be diverse and will be able to pick up new languages and frameworks with relative ease. If someone has been working professionally for 5/6 years, then it's expected that this someone will be able to program well in a handful of languages and frameworks. So if your offering salary is good, then you won't have to worry about the framework. There may be some ramp up time, and for the first few weeks results will be a bit slow, but after that it's business as usual. Junior programmers are the ones that tend to be more specialized because they haven't had a chance to spread their wings, or grow out of the of "my framework is better than yours" phase of their life. 2) If your last guy was professional, then he left behind enough documentation to get the next guy going easily. I spend between 5 and 10% of a month updating our corporate wiki with instructions on how to build, style guidelines, environment setups, coding standards and so forth. If your last guy was not professional, and left you with nothing (and I'm being intentionally disparaging as I've had to deal with legacy code with zero documentation), then it doesn't matter what framework you use, because who ever you hire will also be starting from scratch on your actual code base. 3) Refactoring costs money without generating any money. Thus, you should consider refactoring if the framework is dying, if the product is moving in a direction that the framework doesn't really support, or if you spend more time fighting with the framework then working with it. Refactoring is something every programmer wants to do, and not a single manager wants to let them do it. 4) work remotely an option? whats the salary? ;) edit: I have no idea why my text is so much bigger than everyone else's edit 2: removed pompous text enlargement ;)
The problem is that it continues to check the other items even if it already found one. On average, it takes twice as long.
(disclaimer: I'm a PM on the Dart team.) I wrote a post for O'Reilly about this very subject: http://radar.oreilly.com/2013/05/dart-is-not-the-language-you-think-it-is.html Some of of the many reasons Dart is different than Java: * Dart is a source code VM * Dart is optionally typed. * Dart has collection literals * Dart has top-level functions and variables * Dart's main() is terse * Dart supports any number of public classes in a file * Dart has closures and lexically scoped functions * Dart has mixins * Dart has async/await * Dart has operator overriding * Dart has string interpolation * Dart has noSuchMethod I wouldn't conflate "Dart has classes and semicolons" with "Bringing Java into JavaScript".
(disclaimer: I'm a PM on the Dart team.) I attempted to answer the "but isn't it just Java?" with this comment above: https://www.reddit.com/r/javascript/comments/2x6grk/what_happened_to_dart/coy0q3n
Here's the latest Tech Empower benchmarks for the server. http://www.techempower.com/benchmarks/previews/round10/ Of course, benchmarking is always tricky, but Dart VM seems to do OK.
Enormous code base == enormous refactoring cost. And refactoring is 10x harder for someone new to a code base when compared to someone who built it from the start and knows how and why he did what he did. As others have said, specific framework knowledge shouldn't be a requirement but knowledge of a similar framework would be beneficial.
You'll want to clean it up and make it more functional and all that. The gist is pretty straightforward though, just track the depth and you can open and close ul-li pairs. This doesn't function exactly as you described though. This puts Test Column 01 in its own &lt;li&gt;, and new &lt;ul&gt;s get their own &lt;li&gt; too. You'll also want to strip off the preceeding commas. /*Test column 01 ,Test column 02 ,,Test column 03 ,,Test column 03 ,,Test column 03 */ var level = 0 var lines = [ //your job to load this up in lines. "Test column 01", ",Test column 02", ",,Test column 03", ",,Test column 03", ",,Test column 03", "Test column 01a" ] function write(x){console.log(x);} function adjustTo(target){ while(level &lt; target){ write("&lt;li&gt;&lt;ul&gt;"); level++; }; while(level &gt; target){ write("&lt;/ul&gt;&lt;/li&gt;"); level--; }; } for (var i = 0; i &lt; lines.length; i++) { var column = 0; while(lines[i][column]==','){ column++; }; adjustTo(column); write("&lt;li&gt;"+lines[i]+"&lt;/li&gt;"); }; adjustTo(0);
Fair point, but tutorials by definition are intended for people who don't necessarily know much about a technology, and hence can't always be trusted to know when and how to apply it appropriately. Given that, I think it's a bit daft to showcase the technology in exactly the way it *shouldn't* be used in real life, but obviously YMMV. ;-)
my bad. I am accustomed to writing lists as #1) #2) #3) etc...
So, before it was cool.
Roger. Yeah, the documentation is kinda there but could obviously be better. The codebase was put together by a team of 4 people who've been working together for years. Yeah, working remote is definitely an option. 
You can always type \\#1) to escape the markdown syntax. 
Hi /u/GolgiSDK, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `golgi.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [golgi.io](/search?q=%28and+site%3A%27golgi.io%27+author%3A%27GolgiSDK%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|13|68%
Yes, good point.
It will definitely not run any faster. In fact it will most certainly be slower, but it **will** allow your users to continue interacting with your UI while the workers are processing the image because it is not blocking the main UI thread.
Deanonymization is not something to aside...it is the big problem. As to severity of this particular issue, not quite sure yet.
Hi /u/jomendez, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `jomendez.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [jomendez.com](/search?q=%28and+site%3A%27jomendez.com%27+author%3A%27jomendez%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|9|100%
Actually "&lt;?php echo htmlspecialchars($secret); ?&gt;" would be even better ;)
&gt; JavaScript had lambdas before C#, or basically any language. I guess they meant fat arrow functions. In C# they are called lambda expressions. C# had those several years before JS or CS. https://msdn.microsoft.com/en-us/library/bb397687.aspx
I completely understand your sentiment around more Flux implementations. Our problem with Flux frameworks is that we don't want to buy into one person's interpretation of how Flux should be implemented. Instead, we want to be able to iterate on the idea ourselves to find what works best. Hence, keeping Flux flexible. We're providing a library, not a framework. There is one construct that is pretty consistent across most of these interpretations, i.e., most implementations keep around the concept of a store that subscribes to some events and mutates some internal state. We're not trying to offer a complete Flux implementation, rather a piece of that architecture so that those who don't want to buy in to a one-size-fits-all solution can build the way they want while reducing some boilerplate. I'm familiar with Relay; I was fortunate enough to nab a ReactJS Conf ticket and discuss the topic at length with other attendees as well as FB engineers. I don't think it's accurate to say that Relay does away with the notion of user defined stores entirely. Instead, data stores are replaced with a single data store (most likely provided and managed by the Relay framework itself) while the Relay consumer is still responsible for deciding how to store other misc application state, e.g., isSideBarShowing, playerScore, etc. A quote from the blog post you sent me: &gt; At Facebook, we have apps built entirely using Flux, entirely using Relay, or with both. One pattern we see emerging is letting Relay manage the bulk of the data flow for an application, but using Flux stores on the side to handle a subset of application state. Even if Facebook was to realize that "Flux was a bad idea", it's not a good idea to blindly follow another company's technical decisions. At HubSpot we experimented and found that Flux really does solve some data flow problems for us. Are we potentially solving these problems just to introduce others? Maybe but we're OK with playing a little whack-a-mole until we find what works best for our use cases. 
Thanks for the response. I have used dart for some command line apps with success. It will be nice to have better js interop, then the AngularDart, PolymerDart, &lt;InsertLibHere&gt;Dart projects can just simply go away.
This is a crazy, but awesome idea.
Making a bookmarklet is as easy as making a link, starting the href with `javascript:` and then your code. Wrap it in an IIFE to avoid naming collisions. Drag whatever is inside the anchor tags to your toolbar and you have a bookmarklet that executes your code on the page you're on. Have a look at [this simple example](http://codepen.io/handyCAPS/pen/MYvJMZ) I made to make badly formatted pages more easy to read. In order to make one work with this font, you would have to have the font (in several formats) on a server somewhere and then load it into the page. Hopefully they'll put it on Google webfonts soon.
I posted the code I am having issues with to pastebin at this address http://pastebin.com/Jfc1qvHf Thank you everyone for your suggestions so far I hope to come to a understanding of JS and Ajax soon
http://pastebin.com/Jfc1qvHf Here is the code
anonymous functions were in the C# since the beginning (in various forms &amp; syntax), the lambdas were added later as a syntactic sugar (same as in JavaScript)
`javascript:(function(){var cssCode = document.createElement('style');cssCode.innerHTML='@font-face{font-family:SansBullshitSans;src:url(https://dl.dropboxusercontent.com/u/200262/SansBullshitSans.ttf);font-weight:normal}*{font-family:SansBullshitSans !important;font-variant-ligatures:common-ligatures;-webkit-font-feature-settings:"liga" 1, "dlig" 1;-moz-font-feature-settings:"liga" 1, "dlig" 1;-ms-font-feature-settings:"liga" 1, "dlig" 1;font-feature-settings:"liga" 1, "dlig" 1;}';document.body.appendChild(cssCode);}());`
We may even want "&lt;?php echo htmlspecialchars($secret, ENT_QUOTES); ?&gt;" 
This is a huge problem which effectively makes it useless for any high profile person to use WebRTC, unless they take additional steps to ensure their safety. For instance in the streaming and esports communities where DDoS attacks are running rampant, this is a pervasive attack vector for would be script kiddies.
It's just another way to write the `then` clause without it's first argument (the success case). From that same page: &gt; The catch() method returns a Promise and deals with rejected cases only. It behaves the same as calling Promise.prototype.then(undefined, onRejected). `Promise.prototype.then(undefined, onRejected)` is the same as `Promise.prototype.catch(onRejected)` tldr - Just convenience.
 replacing parseInt(x) with ~~x.
Dart is a revolution, ES6 &amp; 7 is an evolution. I think the latter is going to win.
Ok, you're right. https://github.com/bendc/frontend-guidelines#brevity That code with attributes values without quotes - looks like terrible idea. What's reason behind that? &gt; The box model should ideally be the same for the entire document. A global * { box-sizing: border-box; } is fine, but don't change the default box model on specific elements if you can avoid it. I don't see why using both box-models would be bad, as long as it done right. https://github.com/bendc/frontend-guidelines#selectors &gt; /* good */ [src$=svg], ul &gt; :first-child { Not best example, minor benefits for worse readability, and I'm not sure if such general selector wouldn't impact performance (but I'm not 100% sure). &gt; Overriding styles makes selectors and debugging harder. Avoid it when possible. &gt; &gt; /* bad */ &gt; li { &gt; visibility: hidden; &gt; } &gt; li:first-child { &gt; visibility: visible; &gt; } &gt; &gt; /* good */ &gt; li + li { &gt; visibility: hidden; &gt; } Again, nice trick, but not guidelines material also it's weird to claim that this would make debugging easier. &gt; Prefer English over math. What, why? &gt; If you need transparency, use rgba. Otherwise, always use the hexadecimal format. Because? &gt; Favor readability, correctness and expressiveness over performance. JavaScript will basically never be your performance bottleneck. Well you could be surprised.
`.catch` is nice because you can catch errors in your `.then` statement. i.e. apiCall() .then(function () { throw new Error('uh oh'); }) .catch(function (e) { console.log('this will catch the error'); }) apiCall() .then(function () { throw new Error('uh oh'); }, function (e) { console.log('this will not catch the error'); }) 
It's not working for me. Could you do me a favour and put itinto the jsfiddle? http://jsfiddle.net/drhnu3rh/8/ I'd really appreciate it
Edit: accidentally applied the class to the td instead of tr. Fixed now http://jsfiddle.net/drhnu3rh/10/ Second Edit: added classes for example to show that it works http://jsfiddle.net/drhnu3rh/11/
My problem with Javascript is that it's a very small language feature wise. That's why even the most simplest things get reinvented every year.
You should add meteorpodcast.com, I really like it.
There's something wrong with these two lines var token = str.split(","); var length = token.length; http://jsfiddle.net/drhnu3rh/12/ It says str is not defined. I donno. EDIT: It looks like you already solved that! Thanks!
Dart can be used as back end as well.
You can use the Dart VM, or any other VM which works on x86/x64/ARM/MIPS, on Android. E.g. some C++ game engines use Lua for scripting. Since Android allows JIT, you can also use Dart for scripting. Phonegap/Cordova does work if you compile to JS, but I hope we'll see something like that with native Dart support, because there are a bunch of benefits to that. Most notably: faster startup and SIMD. [Ejecta](http://impactjs.com/ejecta) is more game-centric. It's not a web view. It's just the bits you need for Canvas/WebGL games.
Let's be honest here guys. No one here really thinks JavaScript is an ingeniously beautifully designed language. JavaScript is really a language that is forced upon us, whether we like it or not. Even though ES6 has a lot of cool features, it doesn't solve any of the fundamental problems of the JavaScript language itself.
Why don't you grab a copy of the source from GIT? 
What do you mean already got the ones? Provide sample code of what you have tried.
No, they aren't the same. See this fiddle: https://jsfiddle.net/x9bjmwo2/4/ Behaves the same in all mainstream current browsers (Chrome 40, Firefox 36 and Safari 8.0.3) that have ES6 Promises built in. The message "this will not catch the error" does not appear. I also added a third example that shows a `catch` tacked on after a `then` that tries to handle the error (but again, does not).
Which goes directly against the spec. .then's second argument is for failure While you're correct its just baffling that Firefox doesn't do what mdn says it should D:
Not quite. .then() returns a new promise that will be rejected if an error is thrown in the success handler. So the equivalent of: &gt;.then(successFn).catch(failureFn) is actually &gt;.then(successFn).then(undefined, failureFn)
Yes, the second argument handles failures. No one is disagreeing with that. The point made by the above comment/examples is that it doesn't handle errors emitted by the resolve handler (first argument) of the *same* `then`. The ES spec is about as human-readable as a 100 page regex, but one thing that seems clear is that for a single `then`, only one of its handler functions will be executed. If the promise is resolved, it will run the first argument (the resolve handler). If that produces an error, the returned promise (a separate promise) will be rejected. You therefore need to listen on that second promise to catch the error. You can do that with a `catch` or another `then`.
I agree entirely. Thankyou for putting it so well 
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Group Project&lt;/title&gt; &lt;script&gt; function binaryCode(){ var dataNumber = document.getElementById("dataNumber").value; var aNumber = Number(dataNumber); if (aNumber &lt; 0 || aNumber &gt; 255) alert("ITS WRONG DUMMY!!!!"); else { var numString = aNumber.toString(2); while(numString.length &lt; 8) { numString = "0"+numString; } var fullAnswer = numString.substring(0,4) + "" + numString.substring(4); document.getElementById("binary").innerHTML = fullAnswer; var onesComplementString = onesComplement(numString); document.getElementById("onescom").innerHTML = onesComplementString console.log('Original: ' + numString); console.log('1\' complement: ' + onesComplementString); } } function onesComplement (bNumber) { var onesComplement = ""; for (var i = 0; i &lt; bNumber.length; ++i) { var b = bNumber.charAt(i); if (b == '0') { onesComplement += '1'; } else { onesComplement += '0'; } } return onesComplement; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" id="dataNumber" /&gt; &lt;button onClick="binaryCode();doMore()"&gt;Click Me&lt;/button&gt; &lt;p id="binary"&gt;This binary number will go here&lt;/p&gt; &lt;p id="onescom"&gt;This onescomplement will go here&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; sorry if it looks bad. this is my first course
Perfect! Thanks so much. Enjoy your cakeday and your GOLD!
Ugh why is mdn wrong then :(
Wait until he types "what's my IP" in to google. He's going to have a melt-down. I assume that he'll go off-grid, and live off the land once IPv6 is significantly rolled-out. As for the local address, well, I don't really see the issue there at all either. If you're relying on NAT for security, you've already failed.
Oh oh Apple doesn't want to implement pointer events - because they're not open to discussion. Oh, wait, google doesn't want to implement pointer events either. So the only good guy is Microsoft then. Of course. So obvious.
&gt; It's a very fast general purpose scripting language with excellent tooling. That's my point. It's Just Another Language, which isn't special in any meaningful way. That's not how you win at this game.
You didn't eat god. Happy?
sweet
Here's some more podcasts: The Frontside https://frontsidethepodcast.simplecast.fm/ JS Code Winds http://codewinds.com/podcast.html 5 JS https://fivejs.codeschool.com/ Ember Hot Seat http://emberhotseat.com/episodes/index.html The Meteor Podcast http://www.meteorpodcast.com/ 
Sure, I charge 30$ an hour. Just PM me the money
This is absolutely fantastic. The original dev deserves a beer!
This is also a great resource: http://tagtree.tv/expressjs-middleware 
I didn't expect Dart really to have that much in common with Java. But working in a more functional language like JS and you see that Dart page you see nothing that relate to working with JS. If I had been working with C++ or Java it would be relevant to my weeks work. I think JS people would be looking for something with Ruby features being promoted even if Dart has interesting OO features 
Getting the two's complement is as simple as adding 1 to the one's complement http://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement 
I'm curious how the performance on this is, compared to vanilla CSS. I can only imagine it's worse.
I agree. This is serious over-engineering and to worse results than doing this all server side. I get that it's a tutorial but why not pick a real use case for a client-side MVC framework? No shortage of them. If you want to teach, you need to teach more than how to use something. You need to teach when to use it.
&gt; Vanilla JavaScript itself is very flexible and good enough for everyone else. Not sure what this means, but I don't think it's true. There's TypeScript (which is awesome), Closure, Dart, Flow, Coffeescript, Babel/Traceur... and that's just to name a few. I really enjoy working with JS but I think vanilla JS (especially when you consider older browsers) leaves a good bit of space for improvement at the moment.
&gt; I still view Dart as the best currently available scripting language. Curious if you've tried TypeScript. I haven't really given Dart a spin yet but I'm really enjoying TS.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 6. [**Languages supporting prototype-based programming**](https://en.wikipedia.org/wiki/Prototype-based_programming#Languages_supporting_prototype-based_programming) of article [**Prototype-based programming**](https://en.wikipedia.org/wiki/Prototype-based%20programming): [](#sfw) --- &gt; &gt; &gt;* [Actor-Based Concurrent Language](https://en.wikipedia.org/wiki/Actor-Based_Concurrent_Language) (ABCL): [ABCL/1](https://en.wikipedia.org/wiki/ABCL/1), [ABCL/R](https://en.wikipedia.org/wiki/ABCL/R), [ABCL/R2](https://en.wikipedia.org/wiki/ABCL/R2), [ABCL/c+](https://en.wikipedia.org/wiki/ABCL/c_plus) &gt;* [Agora](https://en.wikipedia.org/wiki/Agora_(programming_language\)) &gt;* [Cecil](https://en.wikipedia.org/wiki/Cecil_(programming_language\)) &gt;* [Cel](https://en.wikipedia.org/wiki/Cel_(programming_language\)) &gt;* [ColdC](https://en.wikipedia.org/wiki/ColdC) &gt;* [ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) &gt; &gt;* [ActionScript](https://en.wikipedia.org/wiki/ActionScript) 1.0, used by [Adobe Flash](https://en.wikipedia.org/wiki/Adobe_Flash) and [Adobe Flex](https://en.wikipedia.org/wiki/Adobe_Flex) &gt;* [E4X](https://en.wikipedia.org/wiki/E4X) &gt;* [JavaScript](https://en.wikipedia.org/wiki/JavaScript) &gt;* [JScript](https://en.wikipedia.org/wiki/JScript) &gt;* [Falcon](https://en.wikipedia.org/wiki/Falcon_(programming_language\)) &gt;* [Io](https://en.wikipedia.org/wiki/Io_(programming_language\)) &gt;* [Ioke](https://en.wikipedia.org/wiki/Ioke_(programming_language\)) &gt;* [Lisaac](https://en.wikipedia.org/wiki/Lisaac) &gt;* [Logtalk](https://en.wikipedia.org/wiki/Logtalk) &gt;* [LPC](https://en.wikipedia.org/wiki/LPC_(programming_language\)) &gt;* [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language\)) &gt;* [MOO](https://en.wikipedia.org/wiki/MOO_(programming_language\)) &gt;* [Neko](https://en.wikipedia.org/wiki/Neko_(programming_language\)) &gt;* [NewtonScript](https://en.wikipedia.org/wiki/NewtonScript) &gt;* [Obliq](https://en.wikipedia.org/wiki/Obliq) &gt;* [Object Lisp](https://en.wikipedia.org/wiki/Object_Lisp) &gt;* Omega &gt;* [OpenLaszlo](https://en.wikipedia.org/wiki/OpenLaszlo) &gt;* [Pauscal](https://en.wikipedia.org/wiki/Pauscal) &gt;* [Perl](https://en.wikipedia.org/wiki/Perl), with the Class::Prototyped module &gt;* [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)) with prototype.py. &gt;* [R](https://en.wikipedia.org/wiki/R_(programming_language\)), with the proto package &gt;* [REBOL](https://en.wikipedia.org/wiki/REBOL) &gt;* [Self](https://en.wikipedia.org/wiki/Self_(programming_language\)) &gt;* [Seph](https://en.wikipedia.org/wiki/Seph_(programming_language\)) &gt;* [SmartFrog](https://en.wikipedia.org/wiki/SmartFrog) &gt;* [TADS](https://en.wikipedia.org/wiki/TADS) &gt;* [Tcl](https://en.wikipedia.org/wiki/Tcl) with [snit](https://en.wikipedia.org/wiki/Snit) extension &gt;* Umajin &gt; &gt; --- ^Interesting: [^Ioke ^\(programming ^language)](https://en.wikipedia.org/wiki/Ioke_\(programming_language\)) ^| [^MOO ^\(programming ^language)](https://en.wikipedia.org/wiki/MOO_\(programming_language\)) ^| [^ColdC](https://en.wikipedia.org/wiki/ColdC) ^| [^JScript](https://en.wikipedia.org/wiki/JScript) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+coyqio2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+coyqio2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 6. [**Languages supporting prototype-based programming**](https://en.wikipedia.org/wiki/Prototype-based_programming#Languages_supporting_prototype-based_programming) of article [**Prototype-based programming**](https://en.wikipedia.org/wiki/Prototype-based%20programming): [](#sfw) --- &gt; &gt; &gt;* [Actor-Based Concurrent Language](https://en.wikipedia.org/wiki/Actor-Based_Concurrent_Language) (ABCL): [ABCL/1](https://en.wikipedia.org/wiki/ABCL/1), [ABCL/R](https://en.wikipedia.org/wiki/ABCL/R), [ABCL/R2](https://en.wikipedia.org/wiki/ABCL/R2), [ABCL/c+](https://en.wikipedia.org/wiki/ABCL/c_plus) &gt;* [Agora](https://en.wikipedia.org/wiki/Agora_(programming_language\)) &gt;* [Cecil](https://en.wikipedia.org/wiki/Cecil_(programming_language\)) &gt;* [Cel](https://en.wikipedia.org/wiki/Cel_(programming_language\)) &gt;* [ColdC](https://en.wikipedia.org/wiki/ColdC) &gt;* [ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) &gt; &gt;* [ActionScript](https://en.wikipedia.org/wiki/ActionScript) 1.0, used by [Adobe Flash](https://en.wikipedia.org/wiki/Adobe_Flash) and [Adobe Flex](https://en.wikipedia.org/wiki/Adobe_Flex) &gt;* [E4X](https://en.wikipedia.org/wiki/E4X) &gt;* [JavaScript](https://en.wikipedia.org/wiki/JavaScript) &gt;* [JScript](https://en.wikipedia.org/wiki/JScript) &gt;* [Falcon](https://en.wikipedia.org/wiki/Falcon_(programming_language\)) &gt;* [Io](https://en.wikipedia.org/wiki/Io_(programming_language\)) &gt;* [Ioke](https://en.wikipedia.org/wiki/Ioke_(programming_language\)) &gt;* [Lisaac](https://en.wikipedia.org/wiki/Lisaac) &gt;* [Logtalk](https://en.wikipedia.org/wiki/Logtalk) &gt;* [LPC](https://en.wikipedia.org/wiki/LPC_(programming_language\)) &gt;* [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language\)) &gt;* [MOO](https://en.wikipedia.org/wiki/MOO_(programming_language\)) &gt;* [Neko](https://en.wikipedia.org/wiki/Neko_(programming_language\)) &gt;* [NewtonScript](https://en.wikipedia.org/wiki/NewtonScript) &gt;* [Obliq](https://en.wikipedia.org/wiki/Obliq) &gt;* [Object Lisp](https://en.wikipedia.org/wiki/Object_Lisp) &gt;* Omega &gt;* [OpenLaszlo](https://en.wikipedia.org/wiki/OpenLaszlo) &gt;* [Pauscal](https://en.wikipedia.org/wiki/Pauscal) &gt;* [Perl](https://en.wikipedia.org/wiki/Perl), with the Class::Prototyped module &gt;* [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)) with prototype.py. &gt;* [R](https://en.wikipedia.org/wiki/R_(programming_language\)), with the proto package &gt;* [REBOL](https://en.wikipedia.org/wiki/REBOL) &gt;* [Self](https://en.wikipedia.org/wiki/Self_(programming_language\)) &gt;* [Seph](https://en.wikipedia.org/wiki/Seph_(programming_language\)) &gt;* [SmartFrog](https://en.wikipedia.org/wiki/SmartFrog) &gt;* [TADS](https://en.wikipedia.org/wiki/TADS) &gt;* [Tcl](https://en.wikipedia.org/wiki/Tcl) with [snit](https://en.wikipedia.org/wiki/Snit) extension &gt;* Umajin &gt; &gt; --- ^Interesting: [^Ioke ^\(programming ^language)](https://en.wikipedia.org/wiki/Ioke_\(programming_language\)) ^| [^MOO ^\(programming ^language)](https://en.wikipedia.org/wiki/MOO_\(programming_language\)) ^| [^ColdC](https://en.wikipedia.org/wiki/ColdC) ^| [^JScript](https://en.wikipedia.org/wiki/JScript) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+coyqj10) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+coyqj10)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Prototyping is fucked up..... look at all these mainstream* languages... http://en.wikipedia.org/wiki/Prototype-based_programming#Languages_supporting_prototype-based_programming I see them on job adverts *all the time*! /s When one language in your stack uses prototyping - it's going to be the language that doesn't get practiced as much, and code quality suffers. I'm saying it should support classes because that's what people are comfortable with.
What a well researched and written question, I sir would be happy to take an indeterminate amount of my day to help you, after all you did provide a wealth of information.
Really? Not python, lua or perl? Most of those languages predate javascript anyway. Self is one of the languages that javascript originated from
No, sorry. You were making a particular claim. That if it followed "basic class OOP" we'd get "MUCH better quality" code. And the only basis for that is your opinion. You also claimed that it "ISN'T INTUITIVE" without any justification. Now you seem to indicate that from now on, forever and ever in the future of programming, the reasonable thing to do is make all programming languages class-based "because that's what people are comfortable with". So, fuck innovation, for starters. Fuck progress, also. Because job adverts! I'm sorry, but your arguments are too weak.
my friend said I should just $( "#myDiv" ).is( :visible ); and $( "#myDiv" ).is( :hidden ); to test if its display:none what do u think? 
Why not? You can try also JavaFX2, it works great.
Hard drive? nope, the are signals in the cpu 
Use css animations. 
&gt; which isn't special in any meaningful way. Eh? Having a fast VM (which works on x86, x64, ARM, and MIPS) and having excellent tooling is special in the most meaningful way. The other scripting languages do not offer this. What would it have to do to make it special for you?
Omitting the html, head, and body tags doesn't seem like a good idea: http://stackoverflow.com/questions/5641997/is-it-necessary-to-write-head-body-and-html-tags 
I am the author of that blogpost, and wish to thank you for your feedback. I agree the examples needed some improvements, so I have revised the blogpost with the following: for(int i = 0; i &lt; array.length; i++) { if(array[i].something === something) { return array[i]; } } And array.find(it =&gt; it.something === something); :)
Play stupid games, win stupid prizes. That code is atrocious and you know it. Writing atrocious code and then complaining because it contains a subtle bug is stupid and has less to do with the language you use and more with code quality. The same error would have happened in any number of other languages, including many other mainstream languages.
Uh I can safely assert that this kind of error could never happen on Haskell or similar. Javascript dead and simply introduces a ";" on the place of the "+" and considers the rest an statement which pretty much just calls the functions and add them because yes, and them does nothing with the result. That kinda violates Haskell's typing rules.
Where is it wrong? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then 
Yeah, JS is not a strong typed language.
change blah.js to blah.php and point script src to blah.php also. You shouldn't really do it this way though
React uses string based templates? 
That's what JSHint is for
I'll repeat. Microsoft is a minor player on the web. Microsoft doesn't matter and is only an annoyance (ala IE). 
You could also just use `Array.prototype.indexOf()` if you're searching for something by identity, as these examples suggest. 
Can someone please explain what is meant by &gt;making sure your links and buttons are marked as such (no &lt;div class=button&gt; atrocities)
Uh I can safely assert Haskell isn't a mainstream language, nor does its behaviour invalidate my claim. To put it in formal logic terms, if my claim had been `∀ language: hasThisBehaviour(language)` then your argument `∃ language: ¬ hasThisBehaviour(language)` would have disproved it. But that wasn't my claim, so your assertion is irrelevant. kthxbye
Am I correct in assuming that you should use &lt;button&gt; instead?
[Image](http://imgs.xkcd.com/comics/real_programmers.png) **Title:** Real Programmers **Title-text:** Real programmers set the universal constants at the start such that the universe evolves to contain the disk with the data they want. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/378#Explanation) **Stats:** This comic has been referenced 315 times, representing 0.5884% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_coyvdjv)
Thank you.
If Page X belongs your server... In Main page, let the FORM HTML element post the data to Page X. JavaScript is optional at this stage. In Page X, simply navigate to Page Y using JavaScript. e.g.: `location.href = "http://my.site.com/pagey.php";`. As when it does that, it is entirely up to you. Alternatively, you can use AJAX to post the form data to Page X in the background, then after it finished, simply navigate to Page Y. If Page X belongs to other server... In Main page, use an IFRAME HTML element to contain Page X. Make the FORM HTML element target that IFRAME so that Page X will be loaded there. Before posting the form data, handle the "Load" event on the IFRAME. Then handler code should navigate the IFRAME's parent window to Page Y. i.e. replaces Main page with Page Y. e.g.: var eleFrame = document.getElementByID("PageX"); eleFrame.onload = function() { top.location.href = "http://my.site.com/pagey.php"; }; If Page X doesn't allow itself to be served in an IFRAME, then you can't do wat you want with only JavaScript. You'll have to use server-side script (e.g. PHP) to receive the form data, load Page X, then issue a HTTP redirection to Page Y.
means url
This is the code that I wrote , but I do not understand how to display data from page x to y by ridirect: &lt;html&gt; &lt;head&gt; &lt;script&gt; window.onload = function() {function getURLParameter(name) { return decodeURIComponent((new RegExp('[?|&amp;]' + name + '=' + '([^&amp;;]+?)(&amp;|#|;|$)').exec(location.search)||[,""])[1].replace(/\+/g, '%20'))||null } myvar = getURLParameter('searchbox'); console.log(myvar); document.getElementById('field').value = myvari; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="land.html" class="form-wrapper cf" method="get"&gt; &lt;input type="text" placeholder="Search here..." name="searchbox" &gt; &lt;button class="searchbutton" type="submit"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;
CodeNewbie is a great show that I recently found and enjoyed. The subjects and guests keep things relatable for experienced devs and noobs alike. I'd like to see it on the list! http://www.codenewbie.org/podcast
The performance of what? The result is still vanilla CSS.
That is the problem I do not have to use it php ajax,because otherwise I created a database and ended them by connecting the page
You could simply change the IDs to statistic1 statistic2 etc, give them a style of "display:none" and then just do: var id=Math.floor(Math.random()*5)+1 // 1-5 document.getElementById("statistic"+id).style.display="block";
I take it you're not thinking of linting tools as something you should always use in every project (no excuses)...
This is the correct way to do it. You seem like a beginner, so I'm gonna say it in case you don't know. You need to put `:visible` and `:hidden` in quotes. Like this: `$( "#myDiv" ).is(":visible");`
Just tried to make the same thing in CSS animations, and got even worse screen tear! The only thing tearing more than the screen is me tearing my hair out! Am I doing something hugely wrong? ;-p
Do you have any specifics to back up your claim that JavaScript is more "functional"? Both languages support first class functions, higher order functions, anonymous lambdas, and one day JavaScript will even have a short function syntax similar to Dart's. Dart additionally has tear-off methods with lexical 'this', so you don't have to use bind(this) all over the place, and it allows you to easily define immutable data structures.
Try the z-translate/transform trick to enable hardware rendering. Also, do you have the same issues on any random site that uses animations? 
Same, I built my first Cordova app out of nothing but JQuery, vanilla JS, and Handlebars. It was a long process and in my opinion not as easy to maintain as my rewrite in Ionic/Angular has been. I'll never go framework-less again.
People have not been excited for MS web technologies since forever. Web developers, even less. While TypeScript seems succesful and visible, it's actually a very small minority that uses it. 
I'm only familiar with these in passing. Why did you stop reading? 
React is not a single page application framework, In an MV* framework, you could define it as the V, as in its only purpose is to define the layout and logic of the components that your application uses. That's actually a very good reason to use React with Backbone, since unlike Ember.js for example, Backbone has no templating engine incorporated, so React would be ideal to provide that functionality (As Marionette did).
i really like [morris charts](http://morrisjs.github.io/morris.js/). If you can convert your query output to JSON you'll love it.
I don't get it.
Not totally sure of the context of the problem, but something like $('.key-container div').count() Should do the trick in the short term. In the long term, information about the number of elements stored and validation logic should be done a in a model somewhere, and not coupled directly to your rendering logic. Whenever an item is added, update the model. Whenever a user drags over another item, check the model to see if that is a valid action. Hope that helps!
Change the src of the image using javascript.
I mean, it looks pretty simple, but you know when you're new to this stuff how your mind tricks you lol.
 document.querySelectorAll('.key-container div').length
The context of this discussion is Dart vs. TypesScript. Not TypeScript vs *.
It's quite funny to me how feverishly people will support or condemn frameworks. You guys take it all so personally. If you like frameworks, use'em. If you don't like frameworks, don't use'em. Simple as that. No need to get all up in arms over your preference. 
If you work by yourself, sure. If you work on a team or other people have to maintain your code then different opinions on the issue can become a real problem.
Yes, but that's a problem between you and your team, not a problem between your team or you and the internet at large. That's why I don't see the reason for people 'duking it out' here over frameworks. No one commenting at anyone else here is working together on a team (at least, not that I can tell). It's just argument for the sake of confirming your own preference. That's silly and childish, because your own preference is just that: Your *preference*. Your argument will not affect my preference. You might make me *consider* something else, but that's about it: My preference is established by years of working to establish it. Not by some internet commenter. Edit to be clear: Confirming your preference is childish because *your preference* is its own confirmation. If someone says 'I like chocolate better than vanilla', they don't have to confirm that with anything. They simply do. 
It's a motivational image. At first I thought it was a syntax highlighting concept. Then I thought we were being pranked because the Jay-Z link and syntax highlighting didn't make a connection to me. Finally I read the code in the image and concluded that it's a motivational thing. My motivation each day is I have to get stuff done otherwise I’ll probably get fired.
Well rewrite is always easy; with or without frameworks. Your app is defined, apis are complete, design is set, interactions are matured. I spend almost 10 hours selecting a font, and font size for main page. Few hours/days to get color right across all devices/OS. Love to see your work that uses iconic. 
You can also listen offline in the Android App (Free for a limited period): https://play.google.com/store/apps/details?id=com.airingpods App has a very good cloud supported search facility, so just search for "Javascript", you can reach the podcasts 
* You're directly injecting declarations into elements on runtime. That will never benefit from caching. * You have to manually create/wrap states and pseudoelements * You have to manually listen for browser events, such as resize, etc. Those and more will adversely affect performance.
&gt;My preference is established by years of working to establish it. Not by some internet commenter. You can look at them as 'some internet commenter' or you can look at them as a professional colleague that might have to work in your code, or vice versa. I've probably wasted hundreds of hours wading through someone else's cryptic 'preferences' after they were long gone.
Hi Seth, in general I really like Dart and read a lot of what you publish - but isn't the whole point of the linked issue that Dart's compilation has potential problems for _future_, as opposed to existing, browsers? I must admit the fact that such a fundamental issue exists, and that "fixes" like publishing a required compatibility script are even being considered, really worries me. I'm definitely starring the issue, and more or less steering clear of Dart until it's properly resolved.
I find that to be an extremely arrogant view. Just sayin.
Besides the React misinterpretation, the author seems to present this as some kind of evolution. Backbone, Angular and React all still exist, are being actively developed and used in projects, along with a bunch of other libraries/tools/frameworks.
Re-read both pages get you now. Oh i've read the spec for sure. .catch isnt on it. Hence the confusion. I had an issue with the top line on the catch page: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch The .then page is fine. All good now! /u/skitch920's reply answers it clearly for me :)
Re-read both pages get you now. Oh i've read the spec for sure. .catch isnt on it. Hence the confusion. /u/skitch920's reply answers it clearly for me :)
You might want to take a look at the response [here](http://stackoverflow.com/questions/16596429/display-bootstrap-modal-first-time-page-loads). You might want to mix your modal (ex.: Twitter Bootstrap) with local storage or cookies (to remember selection). 
This has been proven to be incorrect many times over. The React approach has the best set of tradeoffs for synchronizing the state of the DOM with the state of your data model vs competing data binding approaches. If you don't want to use a tool to sync this automatically, then you can of course get better performance, but it'll be difficult to scale.
It could be useful to be able to supply a regex as the value to match against. I can see myself using this for regression testing APIs with a tool like Postman/Newman
Which wasn't my point.
There's a difference between choosing to use a framework and not being able to function without one though. I've known JS developers who only knew how to code with jQuery, and that's fine as long as jQuery covers all their needs and its solutions are viable in context, but as soon as they need to deviate from what jQuery offers out of the box -- which inevitably happens -- they're either forced to compromise or to look for outside help. By all means, use libraries and frameworks, especially if someone else might inherit your code eventually, but having a firm enough grasp of the language that you could roll your own if you needed to definitely makes you a better coder.
If you can't scratch your own zeros and ones into a hard disk platter...
&gt;Making a Single Page App Without a Framework Awesome let's just do a single page app written in spaghetti code. If you're not using a framework, you will just end up reinventing the wheel. It's inevitable. And will make it hard to onboard people if it's a large application.
Yum!
Has nothing to do with reddit. It's human nature, and a childish one at that. We all want to believe our tastes and preferences are objectively *correct*, when in reality, there's definitively no such thing as a 'correct' preference. It's kind of pathetic really. Arguing preference as objectively 'correct' is exactly what highschool kids do over music. As an adult male, I will look my punk-rock/metal friends square in the eye and proclaim "Fuck you, I *like* Ariana Grande's singing." Back in highschool though, as a pathetic little kid starved for affirmation? Hell no, I'd never admit such a thing (Grande also was like, 10 years old and unheard of back then). 
I agree with you; the anonymity seems to amplify the polarity of people's opinions. I never experience, IRL convos, people so ardently standing up for their preference which is clearly that...a preference/ a personal choice/opinion. Instead of arguing, people should be amazed we've gotten to a place that there a plethora of solutions to any one problem (in the case of apps/webapps) I agree with you...I probably shouldn't have phrased it that way, it's just often been my experience in many subs..
Well put.
How do you glue libraries/components together then?
I don't particularly care for frameworks, but the code on your site makes me cringe. Tables all over the place, all kinds of inline css, javascript isn't at the bottom of the page, etc.
Four years of work, or more, thinks change often, of course in the nexts years i make a new version. thanks :)
Dude der's something known as CODE EDITOR, if you would have used it then maybe before running it would have told you. Still no CODE EDITOR, have you heard about Browser Developers tools??? Seriously learn something and then blame javascript or best dont code javascript.
Just... why?
By using them. A familiar example might be the use of jQuery, which most would consider to be a library with a plugin framework. If you're writing plain-old JavaScript, something as simple as `$(body)` is gluing your application to jQuery. A longer explanation is much more nuanced and heavily dependent on how OP architects his code.
Initially, sure. Google went on to make AngularJS. Facebook went on to make React and Flux. Doesn't that kind of prove the point that you will eventually grow into needing a framework?
No. The standard Alert dialog is not customizable except its message. You should replace it using `window.showModalDialog()` if you need a modal dialog and want more customizations. It takes an URL that points to the dialog contents which should be the dialog message along with the checkbox. Store the checkbox state into a cookie or local storage. Check the cookie or local storage before calling `window.showModalDialog()`.
How do you scale without a framework since a framework provides architecture?
You're passing the "value" attribute of the option into the onchange, so I think you just need to add value="helprequest" into the first option.
The problem is that we don't get to choose. If a significant number of companies are on the AngularJS bandwagon, and recruiters require AngularJS, then you'd better learn AngularJS - regardless of your preference or the technical merits of AngularJS. Preference is for your side project, not the real world.
Personally, I don't like this approach because it makes portability lower. Yes, you can design it really well (event though it's harder to keep it will designed), but in the end, it's proprietary. A programmer that has never seen the code before has to spend time learning how you do trivial things (like connecting the view to the model), where in other frameworks this is abstracted. Anyone that knows Angular knows what a module is, what a scope is, ng-controller, and other abstract concepts. Yes, you have to learn the framework in the first place, but after you do that it's easier to move from project to project using that framework. My $.02.
Pretty cool idea. I would love something that can output my tex files optimized for the web. That would be a cool thing to have.
You make your own architecture.
/r/java
You should take a look at https://github.com/sunesimonsen/unexpected Given your example code in your README it already produces a [pretty nice error output](http://imgur.com/i5MOrew) A diffing tool based on the same output formatter: https://github.com/papandreou/uninspected
&gt;Yes, a framework is necessary but it does NOT have to be one already created for you. I've often found that the most performant apps are the ones with bespoke micro-frameworks specific to their application That has been my point the whole time. **A framework is necessary**. I *never* suggested a fully bloated framework like angular or ember, just that a framework is crucial in an application to provide some sanity. There's already good micro-frameworks out there so why not use them rather than start off with no framework and later down the road waste time retrofitting your custom framework. Of course you can *always* create your own architecture from the start, but again that's still a framework.
localstorage is a good shout
Into the option tag, so &lt;option value="helprequest" selected&gt;Help Request&lt;/option&gt;
According to merriam webster, framework is synonymous to architecture.
This would be a lot more useful if the clustering logic were completely separate from the canvas code.
The only canvas code is in the `KMeans.prototype.draw` method.
I believe that when you write a big application, or any application, you end on writing your own framework through an API whether you not use or extend/override the used framework.
And the canvas initialization in the constructor, and the logic in the `run` function for redrawing it periodically. The class that you've presented doesn't have a single responsibility, and presentation logic that isn't relevant to the actual algorithm is mixed in with the k-means code. If your intent is to teach the algorithm, those two concerns should be isolated apart.
If you're only using gulp to build two things, then no, you probably don't need it. Personally, my gulp files never have just a couple tasks.
No, you define the best suited architecture for you are your project with the help off the framework, you cannot impose architecture with a framework alone.
Developers (at least the ones who do it as a career) live their lives on the shoulders of giants whether it be abstracted languages, frameworks, automated processes that a "better coder" would otherwise do on their own. We are pretty much dumbed down from the programmers of the past yet using frameworks is somehow our biggest fault?
Yes you can.
&gt; Yes you **can't** FTFY.
OP/blog was talking about backbone, angularJS and other 3rd party frameworks, and about not using them. I care too much care about performance. I prefer my app to be super fast or as fast as it can be. Also prefer to tweak design to my liking. I have used angular at my previous company and know about backbone and ember. I felt they all very slow, and won't work or do what you want to do. Specially for mobile spa, these frameworks are huge and slow. Bootstrap is super huge. I use jQuery, and micro templates. Number of places I use jQuery is also very small. Found jQuery to be slow compare to vanilla JS. Example: $(element).show() and $(element).hide() are like 30 times slower compare to $(element)[0].style.display = 'none/block'; You can say, I have written my own framework. It doesn't do much. Its more like how I write my app. I write all my API related code one place. More like Angular Factory/service. Even if I have used angular JS, I would have written same line of code. It also does local/session storage caching. Well I will have to write then in angular too. it has async and sync interface. Angular factory is only async. So I will have to write my own code for that. View are pretty much generated using API response, and micro template. Angular would have provide for loop and if conditions but slow rendering. Micro template way faster compare to Angular view rendering but I have to write my own for loop and if condition. There is no use of two way data binding in my apps or 99% of the apps. AngularJS rerenders when you go back to a view. I hate that. Try my app in mobile, and see what happens when you go back to a list view from a comment view. My app sends 21 KB of gzip css. 14 KB is for icons, and 6 KB for everything. Bootstrap alone is 13K (Gzipped). I would have probably used 5% of the code, probably had to overwrite most of the default style. and on top of that my CSS. FYI: My apps works on iOS, Android, Firefox, Windows Phone 8.1, all desktop browsers including IE10+, and available as a native in the iOS app store and Android play store. https://itunes.apple.com/us/app/hacker-news-yc/id713733435 https://play.google.com/store/apps/details?id=com.premii.hn 
I will take your feedback into consideration.
Nice work. Smoother than butter on bacon reader... That's a first for me.
Now a days inline CSS is hip and back in fashion :)
I thought Frameworks provide architecture for your app. How they differ?
loved them, reddit should hire you :P 
I feel like their demo is a good example of a website that should *not* be a single page app. Making a store like that a single page app makes it impossible to do things like opening up multiple products in browser tabs when comparing, or booking marking items. Web browsers convenient and familiar interfaces and that has a lot to do with what makes the web work so well. It's nice to have tabs and back buttons and unique URLs, and you lose all that if you make an app that only exists on one single page. Single page type apps work well if you're making something highly dynamic like a game, a drawing program, or an online word processor. But not for an online store.
The use case for a text editor is very much unlike the use case for the apps that React was designed around. If you really have to dig into the guts of a framework in order to get "good enough" performance from it, you are often better off just maintaining your own code. It is ok that the library that I really like for my work is not appropriate for everyone, and it is important to recognize that I don't have to make excuses for them.
Text editor seems like the perfect use case for immutable data + react to me.
Cool. Swipe here http://reddit.premii.com/#/r/news 
Perhaps an inappropriate response to this type of article, but... I've recently been experimenting with a lightweight JavaScript framework that does *no DOM manipulation* but instead focuses on how to organize and compose vanilla JS code ([Task Runner](http://bvaughn.github.io/task-runner/)). I think it's one of the least satisfying parts of the main frameworks like Angular, Ember, etc- they all focused on DOM-manipulation but people often end up writing a fair amount of spaghetti code. Anyway, I mention it in this context because I'm curious what someone with OP's point of view thinks about such a framework.
Haha, thank you (I think?) ;)
The fuck are you talking about?
Didn't knew about it. Thanks 
Muphry's Law holds true.
Let me give you an example. [This is the gulpfile for my boilerplate repo](https://github.com/ChiperSoft/express-boilerplate/blob/master/gulpfile.js), it's the repo that I use as a starting point when I want to quickly prototype an idea. From top to bottom it does the following tasks: 1. JSCS and JSHint linting 2. Clean task (removes all files generated by gulp) 3. Cachebuster clean task (removes the files generated by the cachebuster versioning) 4. Bootstrap AMDification (turns the raw bootstrap jquery plugins into AMD modules for lean loading) 5. Lodash assembly (uses lodash-cli to construct a custom build of lodash with just the pieces I want. 6. jQuery assembly (uses gulp-jquery/jquery-custom to construct a custom build of jquery that doesn't have things I don't use). 7. Frontend lib duplication (I use NPM to install my frontend libraries, so this task copies them from node_modules into the public /vendor path) 8. Fontawesome import (copies just the font-awesome font files into a public /fonts path) 9. Main RequireJS optimization (generates the main.js file that has all of the site-wide common libraries) 10. Secondary requirejs optimization (generates all the individual page level JS files containing non-global modules) 11. Dev level main requirejs build task (used during watch process, contains a stripped down version of main.js from step 9 which only has requirejs and its configs). 12. Dev level secondary requirejs build task (simply copies the page modules to their respective live locations so that I don't get 404 errors during development). 13. LESS compilation &amp; css minification 14. Dev level LESS compilation (doesn't minify and includes some extra files that are just for dev) 15. Handlebars backend template compiling (converts .hbs files into commonjs modules) 16. Handlebars frontend template compiling (converts .hbs files into AMD modules) 17. Handlebars component template compiling (same as above, but different folder structure) 18. Cachebuster file collection, duplication, path replacement and cataloging. 19. Watch task which drives all the dev level parts described above 20. Watch task which simulates a production build 21. Default task which does everything above in a very specific order. This is a highly tuned set of processes and tasks designed to create extremely optimized websites that can be scaled up with ease, and having it makes my life a whole lot easier. To do all of this with npm I'd have to write at least 10 standalone shell scripts, many of which would involve replicating what these gulp plugins do, and then fill up my package.json with over a dozen hard to maintain script directives. Now, granted, if I was using browserify instead of requirejs, some of these tasks wouldn't be needed. If I was using webpack, it would handle 80% of this (with probably just as much configuration as gulp) under fewer commands. But I don't like using commonjs in the browser, so I don't use either of those. I'm not saying your article is invalid, quite the opposite, just that the use case you're describing is limited to pretty small architectures.
You certainly don't need to use Gulp. If your needs are very simple, running a couple of command line tools directly is absolutely fine. If you reach a point where running those commands manually every time is becoming a chore, you automate. Whether you do that using shell scripts or makefiles or NPM scripts or Grunt or Gulp doesn't really matter, as long as your chosen tools are reliable and efficient for your project. Personally, I tend to use Gulp for current web projects if I get to that point, simply because there's such a large ecosystem around it now. Many common build requirements literally only need one `npm install`, one `require`, and one line in the relevant task. There's also some decent architecture for widely useful features like maintaining source maps throughout a pipeline or watching for changes and then live-reloading browsers. You *can* also break out of Gulp's usual patterns if you need something more customised -- Browserify is the most common cause of this at the moment, in my experience -- but if you're doing this more than occasionally then possibly the Gulp ecosystem isn't the best choice for your project. That said, the example in the article is not exactly a typical gulpfile or playing to the tool's strengths. There isn't a single `gulp.src()` in the entire file and there's only one `.dest()`! It's as if someone was trying to manually reimplement the basic functionality gulp provides, instead of doing something more idiomatic along the lines of: var rework = require('gulp-rework'); var reworkNPM = require('rework-npm'): gulp.task('reworkcss', function() { gulp.src('index.css') .pipe(rework(reworkNPM())) .pipe(gulp.dest('build/build.css')); }); Edit: Fix typos.
I would say they as I do try to achieve the same goal, handling large data. I believe there is more than one way to achieve it. this is my attempt at fixing issues Ive been having with store as a service and their subset. It probably won't work for everybody (likely) but there is room for more than one solution :). To answer your question, I'm not sure we address the issue from the same angle. I can only speak for myself, I'm trying to achieve a code base easily maintainable, simplify subset of data without duplication, relational truncate and fast paginated table rendering (using generator and partial sort). I need eyes and critical ones. Please feel free to wonder on the code and raise any concern you may encounter ;). 
I think it depends on your needs, preferences, and what you would call a framework. If I were starting something small today that might grow, I'd probably just pick React+Flux (for View/State respectively). A couple of years ago that would have been Backbone+jQuery+Handlebars, which covers the same requirements. I'd hesitate to call either a 'framework', though they provide some architectural tooling. And in-fact I've migrated a project I started several years ago on that latter stack (~50-60k lines), over to React+Flux, and it was fairly painless to do. (Handlebars-&gt;React first gradually, then Backbone-&gt;Flux a long time afterwards). I tend not to like libraries/frameworks that aren't easy to adopt or swap out piecemeal when something better comes along, or when their capabilities start not matching the requirements. If your initial framework choice restricts your choices later on or makes it much harder to adapt to new requirements, then I'd say it isn't helping you down the road versus a less opinionated choice of helper libraries/tooling.
It's not though, arguing on the internet is a way to change the culture - so if I argue that writing an application like this is utterly terrible, which is, it decreases the likelihood that I'll have to work with an abomination of a codebase such as this. I actually thought the tutorial itself was quite good as a fun thing, but god help any developer that actually writes things like this.
Which is great in personal projects. An utterly stupid idea if you working for a company and need to hire people that can actually work with it.
I do love your HN reader site/app thing. However, looking at the source code, there are *four files*. Do you think your approach would scale to even a mid-sized application? Just looking at [this](https://github.com/premii/hn/blob/master/a/js/ui.js). I would not want to work on this or expand it in any way.
Wrong answer. If you work in an environment where you may have anything to do with the hiring process, and have to work with people that you hire, then you absolutely should learn to judge other people's code. I look at this tutorial and go, if this is what someone likes to produce, I would absolutely not want to work with them. Obviously this is just one tutorial, so I reserve judgement.
It's opinionated, it's good to be opinionated as long as you stay rational. Arrogant? Well maybe, but also, what's wrong with considering your opinion correct-er than someone else if you fundamentally disagree with them? Is it arrogant to argue for gay rights because you're presuming you're right about equality?
+1 for trend analysis.
I've had your HN app bookmarked on my phone for at least a year now, and I check it most days. As web apps go, it's smooth, fast, and nice to use. Best of all, it works fine on mobile Firefox. Thanks.
You really don't think we can seriously answer this question for you, do you? Rather than ask us, I suggest making a simple application such as a todo app in each framework, and see which one you enjoy using more. My guess is if you do that, you'll figure out which one you'll want to focus on.
JavaScript is like Ruby, but the syntax is different enough that it can be a little difficult to remember how to do things in the other one. JavaScript's syntax is more mainstream, so it's easier for those who also have to use languages like Java, C#, etc, to task switch between them. With Ruby it's not as easy. Plus, JavaScript is used for scripting the browser so people must use it anyway. The momentum behind node.js is greater than the momentum behind Ruby and that should continue. I see no reason to change from node.js to Ruby, even more now that ECMAScript 6 will soon bring node.js closer to Ruby. Go is a compiled language. It is fast. If all you want to do is to stream JSON, Go could be a great choice. I think Go is also a big deal to help with deployment in the cloud. But if your server needs are simpler and having a simpler server setup is one of the reasons to use node.js anyway, you could just keep using node.js. Maybe just don't use Express if you don't have to, and you could improve the performance of your JSON streaming server. :-) Async programming like that of node.js is a very good idea. While it may not solve everything, it's a good standard to have in any language. The abstraction provided by it frees the developer from even having to think about async programming. That's why node.js is effective enough. And while other languages like Go may have a similar model, the differences are still noticeable. The JavaScript engine behind node (v8) is set to get some improvements in 2015 with an update called TurboFan that started out as a way to optimize for asm.js, but that could bring other kinds of improvements to JavaScript as a whole. And v8 is still getting improvements in general. It's impressive what they can do with JIT compilation. And given JavaScript's dynamic features, there will never be another solution just quite like node.js. Cheers!
Use the one that solves your problem the best. If you don't know what problem it would solve, then you don't need any of them.
This is how you bind and unbind events. function myClickHandler() { /* ... */ } // Plain JS myDiv.addEventListener('click', myClickHandler); // Bind myDiv.removeEventListener('click' myClickHandler); // Unbind // jQuery $(myDiv).on('click', myClickHandler); // Bind $(myDiv).off('click', myClickHandler); // Unbind jQuery's `unbind()` should take care of it though. Are you sure it's applied to the correct elements ? If you want to check what a user clicks globally, you can do something like $(window).on('click', function(ev) { console.log('User clicked', $(ev.target)); });
Thanks for this excellent reply! Is $("li").unbind('click'); not the right way to capture the &lt;li&gt;s? I guess the issue is that the &lt;ul&gt; elements only have the click-function because the div they're contained in have it. So is it not possible to remove the click function just from the &lt;ul&gt;s?
You have to remove the event from the element it is bound. So for example the &lt;li&gt; clicks are detected using $("ul").on("click", function() { /* Find which &lt;li&gt; here */}); you'd have to do: $("ul").unbind("click");
[Here are some slides from a great talk on the topic](https://github.com/groner/CV.js-make-slides) - these are what got me thinking in this direction in the first place. The author is actually working on a project that's doing a pretty complicated build process for their app with multiple targets.
Sure! http://jsfiddle.net/67spmL0/ Basically, I want the pane to move when I click on it, but I don't want it to move when I click the links on it. Yaknow? Thanks for the help!
So basically you want to block the event that is triggered when you click on a &lt;li&gt; element ? $("li").on("click", function(ev) { ev.stopPropagation(); }); 
And if you're interested in how this works, check this out: http://www.quirksmode.org/js/events_order.html
I've found the opposite to be true. I've seen too many projects get convoluted and bloated as developers try to force the application to fit within the limits of whatever particular library and framework was too quickly applied. We just went through a rewrite where we ripped out every third-party library and framework. The resulting code was smaller, easier to understand, and noticeably more performant. I'll be recommending the same for some of out other internal apps.
that trend for Django is probably because of the movie though http://www.imdb.com/title/tt1853728/
I don't see promoting a view of best tools and practices as any more arrogant than leaving your client with an idiosyncratic codebase which they'll have to pay more for someone else to replace or learn.
The word "scale" is meaningless. It's just there to frighten people. You see comments like "Oh, it won't scale without bloated library X" though you never hear any actual, technical reason why it won't "scale". Four files or four-hundred -- I've seen cases where code should have been broken up in to more files (trivial) and code that spanned hundreds of files reduced to just a few. Bad code is bad, framework or not. The only difference, of course, is that it's easier to fix framework-free code over time than it is to remove a poorly-selected framework.
Node is not a language ;).
I'll disagree with the bold point. It seems that everyone forgot about concepts like modularity sometime around the OOP craze in the 90's. (They were under the misapprehension that OOP magically gave you modularity for free.) There are no large applications, just applications with too much interdependence. If you start by assuming that all large applications are just collections of smaller applications, it's much more obvious how you should design your project. Popular third-party frameworks seem to revel in allowing you to create deep and complex interdependence between unrelated parts of your application. No thanks. 
I'm not a big fan of Ruby. I think "end"s are inelegant and prefer bracket syntax. Additionally, Ruby has serious performance issues. But I understand some people really love it. Go seems alright but I haven't tried making a project in it yet. It's certainly very fast. Some of the syntax choices don't agree with me but I'm old, so I prefer standard JS over CoffeeScript. I ilke Node/IO because it lets me write JS for both the application side and the backend. Which means less context switching. And they are pretty fast on a low end VPS with only a couple cores available. Obviously, though, Go is faster. And if you are developing something that's really going to need the absolute highest performance available Node/IO is not it. That said, most people who THINK their platform is going to be their bottleneck are wrong.
Might not be the popular answer, but I'm a huge fan of Ruby on Rails and recently, Elixir + Phoenix. The community support with Rails is great, tons of gems to take advantage of, lots of resources to learn, and is generally structured well and makes writing applications easy/fast once you get used to it. Phoenix has a concurrency/fault tolerant advantage over both Ruby and Node since it's built on the Erlang vM. I love JavaScript, but I feel like writing web apps with it is incredibly broken since you're always running into an issue with npm, a (long awaited) node update breaks something, or library incompatibilities. And just to throw it out there, building your app with libraries instead of a framework isn't always the greatest idea, especially when you have to work with others (and Express isn't a framework).
This is quite nice. One of the problems (arguably) with Google Analytics is that it's quite a big application, and not everybody can use it efficiently. I think a lot of my clients would really appreciate a simplified, personalized approach that they can access in an admin page on their own site.
Browser Disco &lt;3
Agree ! In many occasions, we need just two or three vital statistics on our product on a daily basis. This embed API could help setup a custom page like that with "just the needed numbers", on the admin page of the product. 
Very 1996. I love it.
As a novice/intermediate web dev myself, but in JS/Python, the feedback from my peers is: * Get Node experience (you already have that), * Keep an eye on Go, since it's performance is amazing, however there's no go-to web framework for Go yet (as Django for Python or RoR for Ruby). In your case I don't think you would benefit from learning more about Ruby/Python/whatever glue language + web framework. Stick to learning about new JS/NodeJS solutions and Go.
I never use any of this crap. I just run a windows batch file that concatenates my javascript, minify it online, and upload that shit. 
I think this is a good bit more accurate, http://www.google.com/trends/explore#cat=0-13&amp;q=Django%2C%20ruby%20on%20rails%2C%20%2Fm%2F0505cl%2C%20%2Fm%2F06y_qx%2C%20Rails&amp;cmpt=q&amp;tz=
You don't!
&gt; highly specialistic Or 'special', as normal people say.
google.com doesn't use AngularJS and React and Flux aren't frameworks. They're using AngularJS for satellite websites but not their main product. But yes, I'm sure the code base is large enough that you could describe portions of it as its "framework", but that's the point: they are better served by their own purpose-specific framework than by a generic one, even a generic one that they created based on their experience.
Programming isn't politics. You can't fundamentally disagree with my app or website if it works properly and efficiently, no more than I could fundamentally disagree with a road or highway. There are many ways to accomplish programming tasks, and again, it comes down to preference. Claiming your preference is objectively more correct, yeah, is arrogant. By the way this has zero to do with gay rights, so bringing it up at all just shows how political, and non-objective, your stated view here is.
The point is, it's not Angular and it's not any generic framework. Without fail, large websites find better performance in building their own purpose-specific framework. Which IMO speaks poorly not of generic frameworks as a concept but of the existing options.
My impression: people who dislike CoffeeScript dislike it because its syntax is so different from JavaScript’s. I’m only seeing positive reactions to Babel (née 6to5). One advantage of ES6 transpilers is that you eventually won’t need them, once ES6 is supported natively everywhere.
Coffeescript gets a some extra hate because it's weird (syntax can be ambiguous at times) and it doesn't provide much benefit besides saving a few keystrokes. I have seen much less hate for things like ES6 transpilers and Typescript, which are not weird and actually provide a lot of benefit. Also, JS itself gets a ton of hate, so it's not surprising that things built on top of it do too.
I was not sure what to do UUID as part of the lib but that last argument made a good case to remove it. Also this was a short fix around collection with more than one primary key. Since the library handles multiple PK it is not relevant anymore. Thank you :)
I use Haxe for all my javascript code, but god I hate coffeescript, tried it some years ago, the syntax is awkard and I couldn't get into it.
Well I can't speak for the Atom devs (and I don't use it myself, although I think it looks very good) but my understanding is they wanted a code editor that was easy to modify and extend in a language that a large pool of users is familiar with.
What is "better tooling"? I'm struggling to think of what needs to be better.
To not drop frames on an average monitor you need to hit 60fps. That's only 16ms, and it includes responding to input, updating your app state, updating the dom + browser doing styling, layout, and rendering. With react one of those steps (updating the dom), was taking over 50% of the time. This means that the rest of the steps will most likely exceed the 16ms required for full-framerate.
I think I dislike anything that just tries to skin a cat in another way. I like vanilla JS transpilation (especially ES7 -&gt; ES6 -&gt; ES5), but after using LESS/SASS for most of my career I have started to have a distaste for it. Now I use Myth, which transpiles plain CSS to plain CSS, in a browser-compatible way, so I get to use features like CSS variables. Transpiling a newer version to be compatible with an older version is generally a safe choice.
Yeah, but I think it would have been a significantly better approach to still use JavaScript and instead use native UI widgets rather than a web browser. 
While the talk looks quite interesting, the **awful** sound makes it very, very hard to follow.
Not quite. The benefits gained from handwriting assembly are not going to be as nearly as significant as this style of update.
It will be until the equivalent decades of compiler optimization research has been applied to React! 
Odd, the consensus seems to be that golang is too damn slow. It wasn't supposed to be, sure, but that's what developers are reporting.
Is it at all reasonable for a text editor to run lower than 30 frames per second, though? 60FPS is child's play for nearly any non graphics intensive application (text editors included). Edit: wrangled with the English language
Main reason I like Jade _is_ the whitespace bit. Maybe it comes with experience, but I spent way too much time tag-matching (broken HTML due to a misplaced closing tag) before Jade. Other than that, I love the programatic HTML - mixins, repeats, etc - really helps DRY. For the most part, that latter bit is less required these days as most use an MVC (Angular can do all that). Then again, I haven't played with the less cute HTML transpilers, so maybe that's all commonly supported (sans whitespace)?
Then why the hack are they using HTML to render the stuff? Using javascript is understandable and, js is not slow by any means, and certainly not slower than elisp or vimscript. But rendering a text editor to HTML is slow... I would be much happier if they would build it so it's front end agnostic, so if i want i could use a terminal with it.
Coffeescript doesn't belong in "serious" projects. It has not been widely adopted and ES6 will marginalize it even more. 
Jade isn't anything special. Take a look at Jinja's docs, for example: http://jinja.pocoo.org/docs/dev/
Hey! That's not fair. After we all moved on to things like `qmake` or `cmake`, we all agreed to never talk about autohell again. ;-) A lot of build tools use `make` as an underlying engine. (But I'm sure you knew that already.) Yes, `make` works well for what it does. It isn't the perfect build tool though. I've certainly been around long enough to know that. Just to get a bit meta for a moment. I see a lot of activity in the JS world reinventing things which have existed before, but poorly and without the wisdom of experience that comes from using and learning these older tools/systems. It gets frustrating because I really want better tooling but I'm often seeing history repeating. 
One aspect that hasn't been mentioned yet is that if you generate lots of garbage your update might be fast enough but sooner or later the GC will have to do its job and this can result in a much longer update. For the user typing text what they see is that the typing is uneven. Characters will appear quickly and then there will be a big pause. It is choppy and not comfortable. 
Much appreciated!
That was first prototype I created to see how good/bad it works on the mobile. That codebase wouldn't scale at all. It was not written for maintenance. This is how my current build looks like http://i.imgur.com/YgkMafG.png There are more HTML templates not listed there. Both apps are generated from the same codebase. Only app related templates/CSS and JS (/page/*) are different. Right now there are on average 99 lines of Javascript code per file. except last 4-5 JS files, everything is written for unit test. 
I wouldn't mind selling them my app :)
That first sentence mostly makes sense, but damn is it convoluted. &gt; Is it really unreasonable for a text editor to run at any lower than at least 30 frames per second, though? which I read as &gt; Is it ~~really un~~reasonable for a text editor to run ~~at any~~ lower than ~~at least~~ 30 frames per second, ~~though~~? No, it's not reasonable because most people probably type a lot faster than that. If 1 frame = 1 keypress, then my WPM (visible at least) would be capped at like 6. That's nonsense. However, asking a web browser to do a complete digest cycle at 60fps is different. This isn't Crysis. 
Do people actually write source files that are tens or hundreds of thousands of lines long? Granted Atom wouldn't be my first choice to edit a massive CSV data dump, but neither would Sublime, Visual Studio or Eclipse.
I just looked at my source code again. * Most anonymous functions are self contained. You can break it down in its own file based on what it does. * lib.js is third party libraries like jQuery, and fastclick. * data.js I don't control APIs/backend. Content is coming from two different source. I had to normalize to make it work for me. So it gets content, handles caching, normalize it. That's less than 500 lines. * helper.js you can break it down in many files. Those are just simple plugins. Most are like you provide some sort of input and you get result back. * ui.js handles stories, comments, article, profile and settings page. Less than 600 lines. If you break it down by feature, you will get 5 files. Roughly 120 lines per file. Base on this, you can add 20 more different pages/components, and it will grow roughly by 3000 lines in 20 files. Tell me now, you can't handle that? 
I disagree, i find it quite elegant. I find coffeescript gets really hard to read with chaining function calls.
No, I do not. But sometimes you have to open files that have been generated, like a large concatenated Javascript file to debug. 
Out of curiousity, what dom operations would be optimal? At work we haven't really glued ourselves to a framework yet, due to short lived projects, and we need to get training up on a framework as well. So i've done more single page app type features using handle bars and just my layer of JS on top. I would just re-render the template when changing something (so innerHTML = template()), as I found using jquery to change/update the dom to be very heavy to manage.
&gt; ES6 still has the problem of not being a very pretty language Programming languages are *functional*, they are never *pretty* or "*beautiful*". A girls face may be "pretty", but using the word to describe computer commands on a screen is just wrong, and the same goes for the word "ugly". Many people find Coffeescript is more difficult to read because of its lack of delimiters, and the ambiguous syntax. That is neither pretty or ugly, but it is frustrating and a clusterfuck. But to say that ES6 isn't "pretty" is just asinine. 
Haskell is pretty. Python is pretty. Go is pretty. C is ugly. Ruby is ugly. JavaScript is ugly. This is all subjective, though. JavaScript isn't exactly a conventional functional language. It's my favorite programming language, but it's not pretty and other functional languages are in my opinion. The only thing obviously asinine here is the way that you are handling this discussion.
Well, arguments always go to the last function - but I think that these issues are usually due to trying to do more than is necessary in one line.
Its a fake site and all those testimonials are all fake. You can view the source here View Source by copy pasting this in your browser URL &gt;view-source:http://privateinsta.com/ It does not make any requests to instrgram or twitter.
You can be snarky about my language when your Dutch is as good as my English.
The good news is that the JS world is evolving and maturing very quickly at the moment. TC39 is doing a good job of filling out the language with useful features (and not just design by committee). Tools like TypeScript, AtScript and Facebook's Flow demonstrate great interest in the industry in making JS suitable for programming in the big. As more programmers move from the back-end into the front-end the level of general experience and maturity in the community will increase as well, and we should see much better tools appearing. I'm optimistic. 
Way to entirely miss my point dude. All I was saying that it isn't arrogant to have a view and fight for it.
Sure, as I said... context is everything. If you're creating a POV/VR game then 60 fps may be important. For RTS, scrollers, and nearly all non-game apps then 60 fps isn't important. Horses for courses. Anyways, it's awesome when people like the author(s) measure and share so the rest of us can decide if this matters for our own projects.
&gt; My motto is 'wait until it's proven to work and likely to stick around' which usually means 'wait 5+ years before touching it'. But what about learning for the sake of it? I almost always take away something worth knowing from the experience of playing with some unfamiliar technology. Very often, the idiomatic patterns of new languages can be transplanted back into a mature mainstream language, so you get most of the benefits without the cost of making any kind of big switch-over. Language designers are always looking at other languages (including the cutting edge) to see if there are any good ideas they can steal... uh, be inspired by. So by familiarising yourself with patterns in languages that you don't use day-to-day, you may get a head start on the new features in your favourite mainstream language. Re: golang specifically, it's up against rust, which is *very* impressive if you really want that kind of thing.
Various places, though mostly stackoverflow and google groups. Don't get me wrong, I like what go is trying to accomplish. It just never really got there. 
You completely missed my point about "functional" vs "pretty". I in no way was talking about "functional programming languages". By functional, I meant that all programming languages in essence are simply a list of commands. You are saying that a list of commands writen one way is somehow prettier than writing the same list of commands a different way. The result of the commands may produce art, which may be seen as "pretty", but if you are saying that a list of commands is "pretty" then something has gone wrong in your head. 
Slow compared to what though? As a C/C++ replacement sure, for those things you'd use those languages for (e.g. games, image processing), perhaps due to its GC. For web development, when you're up against JavaScript, Ruby, PHP etc on the other hand, have you heard any serious complaints?
It's just a joke. I thought you people were supposed to be laid back.
Film is 24fps and **has motion blur, so it appears smoother**. That is not something we have or want on a code editor. 
Casperjs is what I use..
&gt; there's no go-to web framework for Go yet There's been a few stabs at a full-stack framework (Revel IIRC being the most complete) but what I've mostly seen is low-level libraries like Gorilla on top of Go's builtin packages. I think we're unlikely to see a successful full-stack framework emerging in Go, partly due to the nature of the language itself (static typing, lack of generics etc) but mostly due to the things people are using Go for - it seems to be used a lot for microservices where you need speed and reliability. Your front end is going to be a native platform or SPA (or other services). Whether this is again a limitation of Go, or just the general direction of web development away from the need of a soup-to-nuts full-stack framework when Go started to gain popularity, I don't know.
This isn't a webapp. It's a desktop app... but for some reason they decided to introduce massive performance penalty by building it on top of Chromium and using javascript. In a web app, of course squeezing every ounce of performance you can makes sense. You don't have a choice - these are the tools you're stuck with. However, when you build a code editor in an offline browser, you're already magnitudes slower than your closest equivalent. It's like focusing on tending to a papercut when the patient has a gaping chest wound. Again, I'm not saying they shouldn't bother. It's just funny to see people talking about a project being performance minded when their own fundamental architecture decisions are, by FAR, the biggest performance issue.
Depends on how picky you want to be. This is enough to make sure that the address follows the "address@domain.domain" pattern: [^@]+@[^.]+\..+ It matches any character that isn't an at-sign one or more times, followed by an at-sign, followed by any character that isn't a period one or more times, followed by a period, followed by any character one or more times. My favorite regex sandbox: http://www.zytrax.com/tech/web/regex.htm#experiment
this blog is garbage
Learn for fun all you want. Just don't put [shiny new tool] in to production and expect it to still be around a few years down the road.
Makes sense. Most of Atom's DOM updates will be single character inserts and deletes, so skipping the overhead of the virtual DOM is totally doable. I wonder if using React for the past half year has gotten the rest of their architecture to the point where doing this non-premature optimization is clean and straightforward.
If you're copy-pasting a very large set of data for instance or scrolling across a large file that *7 difference in rendering speed is surely significant. VIM has a similar problem
So, React Native? :)
Yes!
I'd say you suffer from head problems since you fail keeping the discussion civil. I don't think it's that important but you should know, since you're interested in programming, that many considers it an [art](http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming) and thus don't find it wrong to use aesthetic words when discussing it.
They have the PHP complex going on.
I don't think it is quite that bad. JS engines have to be backwards compatible, but our linters and transpilers can ban or deprecate many misfeatures in the language. There are still some tricky things, like arrays with holes in them for example, which are harder to fix. The new symbol feature in ES6 for example is a useful mechanism for adding properties to objects in a way which won't break old code. JS objects may still acquire useful features like built support for toString() or hashCode() methods. New "use strict" style modes are also another possibility. 
I've been programming for over 30 years and while I appreciate *clever* code, I wouldn't say I've ever seen an example of "pretty" code. So you would compare pages of computer instructions to your girlfriends face? I'm sure she would approve of that discussion and it would remain civil. Or maybe you've never had a girlfriend (or boyfriend), or experienced true beauty, or even been to a museum. If so then I'd feel sorry for you. In any case you are anthropomorphizing, you're probably wired differently, but it does seem odd to call a list of instructions "pretty". &gt;pret·ty &gt;ˈpridē/ &gt;adjective &gt;1. attractive in a delicate way without being truly beautiful or handsome. &gt; "a pretty little girl with an engaging grin" &gt; synonyms: attractive, lovely, good-looking, nice-looking, personable, fetching, prepossessing, appealing, charming, delightful, cute, as pretty as a picture; More &gt;noun informal &gt;noun: pretty; plural noun: pretties &gt;1. an attractive thing, typically a pleasing but unnecessary accessory. &gt; "he buys her lots of pretties—bangles and rings and things" used to refer in a condescending way to an attractive person, usually a girl or a woman. &gt; "six pretties in sequined leotards" &gt;verb: &gt;pretty; &gt;3rd person present: pretties; past tense: prettied; past participle: prettied; gerund or present participle: prettying &gt;1. make pretty or attractive. &gt; "she'll be all prettied up and ready to go in an hour" &gt; synonyms: beautify, make attractive, make pretty, prettify, adorn, ornament, smarten; 
That's not arrogant: Remember the goalposts, and lets keep them where they are. Its perfectly acceptable to argue the merits of your methodology. What's arrogant is thinking you need to "educate the masses" *because* you have a certain methodology. Thinking we should all adopt your view because *you* find it works best for *you* is yes, very pigheaded and arrogant, especially in the face of so many varied solutions available. 
I've tried both Ember and Angular lately, and Angular has been far less problematic. That doesn't leave too many options. 
You can listen to the event on the container and check the event target (1st solution), or you can prevent the click event from the li to bubble to the parent (2nd solution) : // 1st solution : $('ul').on('click', function(event) { if (!$(event.target).is('li')) { // the div was clicked but not on a li element. } }); // 2nd solution : $('ul li').on('click', function(event) { event.stopPropagation(); }); $('ul').on('click', function(event) { // the div was clicked but not on a li element. }); 
What? I'm not using Angular but you seem to build some straw man about this subreddit that I don't think anyone here recognizes.
http://kangax.github.io/nfe/
Firefox on Android.
If you make an Angular directive, it can easily be dropped into another Angular project. A proprietary design will have bits and pieces that will probably be harder to get working with other projects. If you have a lot of projects in a company and they all commit to Angular, it's much easier to share parts. This is what I mean be 'portability' -- code portability. Hopefully that helps. :)
Its server side, Not controlled by JS. Disabling the popup will not give you more photos because the server knows you have not completed an offer. I would suggest you stop stalking. Some of those sites might harm your computer. 
Not sure if this is a useful answer or not, but I wouldn't bother trying to validate them at all. Sure you can look for a xxx@yyy.zzz format, but missing @ and . characters aren't going to your problem, it'll be those that look valid but don't reach the right mailbox. I'm pretty sure email addresses aren't strictly required to even have a TLD. It's a minefield of caveats, and you're probably more likely to block users with obscure email addresses than catch any genuine errors. For example, I find many forms that try to validate email addresses still won't accept the xxx+yyy@gmail.com format, even though it's a perfectly valid address and useful feature of the service.
This. Send some kind of email to verify the account. Let the user pick whatever they want and if they don't get the email, tough cookies. Better someone mistypes their address than you disallow a user from signing up.
&gt; Out of curiousity, what dom operations would be optimal? React uses a diff algorithm to determine that. It has 2 sets of DOM tree's, and does an internal calculation for 'path of least resistance' for DOM manipulation (because DOM re-re rendering is the most expensive computation a web-app probably makes). The performance is so drastic that anyone could probably compute a fake DOM tree 1000 times in javascript (without rendering) in the amount of time it takes to re-render the DOM. Javascript is much faster than people give it credit, and these tree-comparison are a lot cheaper than people assume as well, that's really the 'revelation'. JS is fast now, and if you compute data before rendering data, it doesn't matter if you're using React or Jquery, it's all about minimizing DOM renders (which are order of magnitude more expensive CPU / GPU tasks). 
&gt; 'technically' everything React does could be implemented via normal JS React is built with JavaScript, so ... no shit.
Thanks for your quick response. I'm a hobbyist in JavaScript. Is it worth learning Angular 1 seeing how the Angular 2.0 is — I'm told — going to be radically different syntactically?
Anytime you scroll... It's a complete redraw, if I recall correctly. 
You must be using a bad linter, jshint + SublimeLinter is instantaneous for me (background mode). I've found even loading a large number of files (regardless of files) is problematic with Atom, while Sublime handles that with ease. 
"Buried" in this document is the only real negative I know of and would want to point out: named function expressions are pretty broken in Internet Explorer 8 and older. Not a big deal for most people nowadays though :D
Going deep into directives and templating is where Angular gets dirtiest. I've come to realize that it's generally better to 'do it the long way' than hack around with directives / compilation / linking processes. Still it never hurts to mess around with that stuff because it only improves your understanding of the framework, I just wouldn't use it in the real world. 
If you don't want to use React for some reason, you could effectively get pretty close to it by using building a fake dom in js in a document fragment and appending. InnerHTML can be a bad way to go, especially for re-rendering. Like the post below me says: do as much work as humanly possible in the javascript before you touch the dom. And then only touch the dom once. And only if you absolutely have to, where you have to, in the least intrusive way possible (no innerHTML). Personally, unless you've got some highly specialized app like Atom, just use React. The code to do the above is pretty straight forward, but requires a bit of discipline to keep structured, and even then it's pretty verbose compared to React. http://andrew.hedges.name/experiments/innerhtml/original.html http://jsperf.com/appendchild-vs-documentfragment-vs-innerhtml/62 http://www.slideshare.net/x00mario/the-innerhtml-apocalypse
This looks great but will it ever be accessible without facebook and twitter?
I agree with you, but I probably call it "code reuse", not "portability"
I don't like LESS and SASS, seemed overkill for me to have to learn another language to have variables and functions in CSS, plus it mangles the hell out of the CSS. After my second false start at learning LESS/SASS, I decided to cobble together a Javascript CSS hybred: [CjsSS](http://opensourcetaekwondo.com/cjsss/) and for good measure one that runs under Angular: [ngCss](http://opensourcetaekwondo.com/ngcss). 'Course... my experience with these thus far just proves your point; Everyone seems to love LESS and SASS and I've had a heck of a time getting anyone interested in these projects despite their use of already known technologies, small weight (sub 5k min'ed/compressed) and ability to use ANYTHING already under the Javascript sun rather than just features and plugins developed specifically for LESS/SASS. So... sigh... yes... does it seem webdevs *LOVE* CSS transpilers...
I wrote something very similar to this last year, down to the name. http://github.com/thestorefront/DataCollection.js We use it in production at http://thestorefront.com/ and we're launching a new app soon that makes heavy use of it. **Edit:** Also note that it has 100% test coverage. :) Completely ready for production use.
Some valid points there. I don't see myself using frameworks much anyway — I just want to learn them as a time-saving contingency for any bigger and/or time-limited projects in the future. P.S. Why's someone downvoting our comments?
Don't laugh too hard, I've seen more than a few comments suggesting that you couldn't do [insert thing] in JS without using jQuery. I find it baffling. 
&gt; That's because there are more than likely tons and tons of edge cases that React handles in their abstractions I hear this all the time about *every* framework and general-purpose library. I'm pretty sure it's a myth, having dug through quite a bit that mythical code myself. 
Works fine in Firefox for me.
See jQuery 1.10+ vs jQuery 2.0 and the edge cases they dropped.
I'm running on a five year old machine now (!!), but I only get ~24fps in Firefox, and the result is very much pixellated as compared to Chrome and Safari (presumably due to differences in their resizing implementations). Still not bad, but not the 60fps I get on Safari / Chrome (desktop and iOS).
Not against using React by any means. It's more the lack of time to ramp other devs up while a project is being worked on.
Honestly it isn't much different than most other IDEs that build off of java. I'm sorry but atom actually way out performs netbeans and others. Maybe the bigger issue is not the framework used but the way things are built. Using any interpreted language will lead to performance loss, but no one can question the way things are advancing. Every day.. it's becoming less important to develop low level, because high level software is the key to progression. 
Check out comp.lang.javascript and you'll think much differently about that. It's pretty bad.
You haven't seen much code produced by large organizations. It's amazing how bad the results can be. You can't guarantee good code with money. It's simply not possible.
very cool, thanks for sharing
It's quite nice to read the function name and just ignore the body though. Like `records.filter(function newerThan30Days { ... })`. Just allows you to be lazier when scanning thorough.
My personal coding style is always "all variable definitions at the beginning of the block, NFEs further down", as in var one, two; one = function one() { return "one"; }; two = function two() { return "two"; }; Chrome Canary [just added improved stacktraces](https://plus.google.com/+AddyOsmani/posts/DdWkiKsvbA2) though, so using NFEs should become less important for debugging in the future.
That is quality! There is a fine line between good commenting and bad commenting. For example: // Subtract 1 from i i--; This is, of course, completely useless. However.. // The user enters the value between 1..n, where we store the data from 0..n. // So, decrease i by one to reference the correct data. i--; So while we're still commenting a really obvious line of code in terms of what it does, we're explaining *why* we're doing that.
I feel the same for most cases, but one example I've found hard to figure out with Make is watching for changes and automatically building and live-reloading. Sure you can use fswatch (or similar) to trigger the build commands, but that needs to load up whatever environment each command needs which is slow. Gulp et al load everything into a Node.js process which keeps running, so rebuilding everything takes under a second. It's not so much of an issue if you are just compiling a few CoffeeScript files, but if you then need to minify and uglify them with templates, vendor libraries, and whatever else then it is going to be slow. Sure it's only on the order of a few seconds, but I find that breaks my flow, so I don't really like it.
Image filters like these, that have to iterate over all pixels, run much faster on the GPU via WebGL. Try https://github.com/phoboslab/WebGLImageFilter or https://github.com/evanw/glfx.js Seeing this in pure Canvas2D with all the computations done directly in JS instead of in a Pixel Shader is pretty impressive though. Edit: I was wondering how the linked demo could iterate over all pixels this fast. The answer: it doesn't. It downsizes the Canvas before blurring. Neat! However, knowing that now, it's easy to spot artifacts with the moving red box where the downsizing becomes apparent.
Are you certain you're actually in safari and not just in the web view of a reddit app? I tried it in safari on my iPhone and the blur worked at around 24fps. 
Some older browsers (MSIE) don't like it if you try to use a named function just as an anonymous function. It'll barf on something like return function foo(x) { return 2*x }; Though this is fine: return foo; function foo(x) { return 2*x } So, I recommend doing the latter.
The FPS counter changes so rapidly that it's hard to tell but it looks like I got ~58 FPS in Chrome in my HTC One M8. Pretty impressive.
There's already a standalone version of that plugin. It's called "using Sublime Text".
That and Ruby is just a better language than Node in general, at least on the back-end. It's just so much more enjoyable to work with and the ecosystem isn't totally broken.
Is there a practical reason for saving a NFE into a variable with the same name? I though that saving an anon function into a variable was just another way of giving it a name: var one, two; one = function() { return "one"; }; two = function() { return "two"; }; And if I understand [Function Hoisting](http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html), this would also be the same right?: function one() { return "one"; }; function two() { return "two"; };
It doesn't really matter for the tiny project I'm doing now. But I was thinking if I had a stacktrace that went through a five or more anon functions it'd be nice to see at a glance each name. So I thought that naming these functions might make both stack traces and the source code nicer to read. 
This looks really excellent. Good job! 
I really like this. Simple code for a sharp looking result. *** Question: ~~Why are the colors labeled 'lorem', 'ipsum', 'dolor', etc., instead of 'red', 'green', 'blue'? I see it in the example code, but also in the '`.color-scheme-default`' style.~~ ~~Is the '`.color-scheme-default`' style a place holder itself? Are users supposed to override it too?~~ Nevermind, that was a dumb question.
Yup. http://www.gantt.com/
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Differences) shows the differences between variable assignment and function name quite nicely. I mostly use it for the sake of consistency with other situations, such as inline callback definitions (`.done(function done() {})`) Yeah, the primary difference between function declarations and function expressions is hoisting, which is why I use the latter. For me, hoisting is not a good thing - in most situations where it would make a difference, it's a strong warning sign that my code is structured badly.
There is a multitude of reasons you should be careful about transpiled languages, like Coffeescript. They are an abstraction; a layer between the programmer and his product. Usually, transpiled languages are used through-out the entire codebase. So the cause for concern is typically a large one. Transpiled languages require maintenance, community support, up-to-date feature sets, but also are prone to their own set of bugs. Say one day, Jeremy Ashkenas stops developing Coffeescript for some reason or another. Well obviously you'd just transpile one last time to Javascript, and move-on, but the past has shown us it's not always that easy... I'm not saying there's anything wrong with Coffeescript's implementation or usages, but any extra steps between the programmer and his code is also more maintenance.
I would probably do something like toZeroBasedIndex(i) { return i-1; }
This guy's got some massive depression from that bad luck if he spends 1.25 years watching Lost season 4, then spends another 0.25 years watching it again while he's already watching it. Maybe those were the recap episodes?
I wonder if they are going to give Marionettejs a shot or maybe even Angular?
Of course, I was just highlighting commenting with the simplest possible example.
That's cute. It makes my cursor go crazy when hovering over the links.
Tap and family isn't on the list? ;)
There is a big difference between film and computer graphics. In film that 24fps includes motion blur due to the physical nature of the recording, and it's non-interactive. In computer graphics and in particular UI graphics, you generally don't have motion blur, and if you did that would have a negative impact on responsiveness. On top of that, it's interactive so the response time between input and visual response needs to be as low as possible. In my experience 30-50ms feels unresponsive. At 24fps your frames are over 40ms apart, so dropping even a single frame puts you over that limit. That can happen quite easily because input is captured at the beginning of the frame, so if input comes in shortly after that you will have close to 2 frames of input lag before the effect is rendered, even if everything else is as fast as possible.
CSS classes should not describe representation of the object (e.g. red, big, floated). They should describe role of the object (e.g. navigation, task). I am guessing thats why.
Very familiar with typed arrays. I published [this](https://medium.com/@keithwhor/nbeam-how-i-wrote-an-ultra-fast-dna-sequence-alignment-algorithm-in-javascript-c199e936da) last week. :) Thing is, Uint8ClampedArrays are pretty effective because you don't have to worry about min/maxing out specific byte values. Also, the bottleneck in my implementation isn't even the box blur itself (that's absurdly fast), it's the .getImageData and .putImageData calls for grabbing the canvas pixel array and placing a new one down that seem to be resource hogs.
Great work! I was just looking for something like this to use in one of my projects
It's a good start though. Ruby had #{xxx} for ages and it seems `${xxx}` is implemented in a very similar way, and this at least solves basic templating problems. I've never felt I need to use printf unless I needed to pad the variables of different lengths to get a pretty output. I don't see how your example is complex at all, it looks really clear to me. We could write rolePath like this though: var rolePath = (user, role) =&gt; `${userPath(user)}/roles/${role.name}` *much clearer than var rolePath = function(user, role) { return userPath(user) + "/roles/" + role.name } 
Your first example does seem somewhat cleaner, but it's not as simple as doing something like: var userPath = '/users/${user.name}' var rolePath = userPath + '/roles/${role.name}'; rolePath.format(user, role); The fact that you need to define a function, to me, adds unnecessary complexity. For instance, if you expanded the userPath function to 6 arguments: var userPath = (user, a, b, c, d, e) =&gt; ... // whatever here var rolesPath = (user, a, b, c, d, e) =&gt; `${userPath(user, a, b, c, d, e)}/roles` var rolePath = (user, a, b, c, d, e, role) =&gt; `${rolesPath(user, a, b, c, d, e)}/${role.name}` The functions just seem really unnecessary as a building block pattern. Compare all that to: var userPath = "... 6 variable string", var rolesPath = userPath + '/roles'; var rolePath = rolePath + '${role.name}'; rolePath.format(user, a, b, c, d, e, role); **Edit** Although now that I think about, I wonder if it's possible to do this... var userPath = "... 6 variable string", var rolesPath = userPath + "/roles"; var rolePath = rolePath + "${role.name}"; // user, a, b, c, d, e, role are in scope here... `${rolePath}` **Double Edit** Nope, TypeScript nor Babel, handle that case.
I love coffeescript and wouldn't have got this far without it. The reason I moved to JavaScript was: * several modules were derived from js modules and so I had a mix of languages * no es5 get/set support * all my pull requests came from js developers that didn't know coffeescript The worst thing about porting to js is that now the code looks pretty ugly, but I'm slowly reformatting it :)
Thank you! It's been a blast playing with modern web technology plus node on the backend :)
Why does everything have "cursor: pointer" if nothing is clickable?
Why do you capitalize the 'rest' in 'rest parameters' as 'REST parameters'? You do realize it has nothing to do with REST the architectural pattern right?
There is no practical difference,on the shortrun. Your code will still need to be transpilled 5 years from now,trust me.
Haml and Jade are templating languages,not fully featured replacements to javascript.
This error occurs when React is expecting plain javascript but gets JSX instead. To resolve this make sure to precompile your JSX. You can use jsx compiler present in react-tools.
how would this even work? var userPath = '/users/${user.name}' var rolePath = userPath + '/roles/${role.name}'; rolePath.format(user, role); our rolePath is '/users/${user.name}/roles/${role.name}' but how does the function arguments automatically become variables inside the function? It seems you would need to call it as: rolePath.format({user: user, role: role}); on the other hand, if you have all of this templating inside a function belonging to an object, you won't have to worry at all about functions with too many arguments. what I mean: function User(name, a, b) { this.name = name; this.a = a; this.b = b; } User.prototype.somePath = (c, role) =&gt; `${this.name+this.a}/${role}/${c}` From my personal experience I rarely need 6 or 7 variables in one string formatting function. For html generation, I already use underscore/lodash or whatever the frameworks give me, so this isn't a big problem for me. *Edit: the article says this whole thing is a proposal. let's wait until it's done before being critical, I doubt this is the final version. I'm honestly ok with these changes, but obviously there will be people who want String.format and other features. Essentially, it's all syntatic sugar right now, not much more. 
With Typescript I can change the file extension from .js to .ts and compile the results. Most of the time it works with no additional changes. You can't just copy a block of JS into a cs document and compile it. Coffeescript is aesthetically different and not fully compatible with JS.
Forgive me if I missed it, but is there a way to pass in data that isn't JSON? If not, that's a pretty significant limitation that disallows passing in any data that's created client-side, at least without calling JSON.stringify() every time. Some minor notes: If selector is always an ID, why require the #? And there are quite a lot of exclamation points on the home page. Overall, great job creating an alternative to chart.js!
Ahh correct, it would have to be wrapped in an object with named keys. Actually the article is about 2-3 years old briefly edited.
At first I agreed, but on second thought, I'm not so sure. A Gantt chart has a specific domain (project scheduling), whereas this project looks to be more of a generalized timeline library (all Gantt charts are timelines, but not all timelines are Gantt charts). Yet, I think Timesheets.js is still unfortunate, since [timesheets](https://en.wikipedia.org/wiki/Timesheet) is a widely-used term in business, and the traditional timesheets are nothing like what this project is intended for.
No, /u/kangax_ is.
There's also the [Similie Timeline](http://www.simile-widgets.org/timeline/), which has been around for a number of years. It's not inherently flashy, but it can do quite a bit.
W3schools !! Don't forget the s in schools... Unless you like Christian poetry 
On my desktop iMac it looks great, good work :) I had originally assumed that the red box was suppose to blur the background behind it. Now I realize that the blur is on the sheet at the bottom. I'm still not seeing any blur on my iPad, however (iPad Air 2, 8.1.3), nor on an iPad mini running 7.1. Let me know if you want me to check other devices. 
Yep or its working perfectly then 2000 people are let into the expo hall and the Internet goes berserk. Next time offline mode for sure... 
Referring to ES6? I highly doubt that. IO.js already natively supports a lot of harmony features, and most browsers have standardized many of their implementations as well. You'll still need transpiling if you're supporting non-evergreen browsers, but that's no reason to ignore the benefits of ES6.
Or you could be a jerk and down-vote silently.
Very good distinction but I felt like the article was too short. TDD vs BDD is a concept that feels unclear to me. I've worked on codebases that weren't clear on which style they were using. I was none the wiser. 
I'm more curious about the implementation here. Choosing the framework is the easy part. Do you go with canvas? SVG? Something else? How do you store the data? Meteor is best for the live data aspect, though. Can't recommend it enough.
Came to say this. Simile Timeline is more a dynamic widget with scrolling, zoom, detail views and other features. It's quite powerful.
Thanks for the feedback! I based much of my ideas on how PHP loads classes (which is based a lot on how Java works) and how that plays a role in how Laravel (A PHP framework) resolves services out of it's container, which essentially fallbacks to trying to create a new instance of that class if theres not a service for it. I'm currently not sure how to make something like that work with CommonJS. Although ES6 modules look interesting. I'll take a look at that since I'm already using Babel for the library. I guess I'm trying too hard to make JS work like PHP instead of embracing JS best practices ;D
Yep, so mainly JS for all of the tools with canvas partially. Drawing with SVG is on the table, but there's a bunch of factors to account for. However it's rendered, the challenge is to get brushstrokes to look and feel fluid without segmented updates despite how the data's sent. Here's a [demo made in Meteor](http://blackboard.meteorhacks.com) and if you opened that up in two windows you'd see the other client's brush updates in jagged segments, not smoothly as a continuous stream. Aside from some hiccups in delay, it's otherwise not bad. And yes, Meteor's looking very promising for live data. As a full stack it comes with MongoDB, but [Meteor Streams](http://arunoda.github.io/meteor-streams) could circumvent that for some of the more sporadic data.
That's very common and something most programmers do when starting out with another language. There's nothing wrong with doing DI in JS like you've done, but I think you're going to have a hard time selling it to experienced JS developers. Soon enough you'll find yourself banging your head against the wall because OO in JS doesn't work like in PHP or Java, and then you'll probably either give up on it, or embrace it. :-) 
What a cool thing to know! I had no idea you could name them like that, great! Here's a quick test I did: http://jsfiddle.net/4xcrvb3r/3/ 
&gt; So, have a nice day, thank you for smoking I was going to congratulate you until I saw this message. I don't like the product you're *really* pushing.
Woo..
Great!
A lot of the courses I've seen are geared to people getting to grips with the basics. They do a fine job of that, but for the next level up (I'm not too far ahead of you) the resources aren't quite as plentiful. Check out the Crockford YUI talks on Youtube, or mebe [this one](https://www.youtube.com/watch?v=v2ifWcnQs6M). They're old, but really good. From there, go on a journey through Youtube's other suggestions. More Crockford, JSConf, Addy Osmani, Fluent, Jake Archibald, etc. You'll soon get an idea of what to look out for, and there's a TON of good stuff to watch. A doer, rather than a watcher? Me too! However, stick with the vids, I've had so many eureka watching them. For me they were the missing resource. In fact, I don't watch telly in the evenings any more, I just watch JS videos. ;)
Kids these days. Don't know DHTML if it bit em in the ass...
Thanks very much! Yeah I really should do mechanical tests with a sensor to know for sure, I think that's the only way since it's about external physical events; I know the technical department somewhere I worked did that once, but that was for Flash. I'm going to email them to see whether they ever did it for Javascript. I'm planning to ask people to close all other programs and tabs. I didn't know about the fast mode and dictionary mode, thanks very much for that! Otherwise the task should (in most cases) be "quiet" while waiting for the response, there'll have been an image sent to the canvas and then it's just waiting for the keydown. So that should minimize problems. Thanks again! 
Thanks for the feedback. I'm planning on expanding on the concepts later with more examples. For example, there's whole another side to BDD with "user story" based testing :) Which part of BDD vs TDD feels unclear specifically? 
Try `setInterval(runClock, 1000)` and `clearInterval(clockId)`.
Testing the logic is never the hard part. It's testing proper page flow that is the hardest. I guess you can call it BDD but I like to refer to it as UX testing. Do certain elements only load at a specific time? This is where things get tricky because you now have to account for odd user behaviors. It's easier with things like angular but much more harder with other libs. 
Will do! Edit: I found this for compatibility (edit 2, although there seem to be some possible issues with combining the time according to timeStamp with the time according to Date.now() since they might use different zero-times; I'm going to log both versions for safety): if ('timeStamp' in event) { var timeStamp = event.timeStamp; } else { var date = new Date (); var timeStamp = date.getTime (); } 
That's not true. Sure, at my last job we had to support back to IE8, but we now build for internal systems and are able to easily target evergreen browsers (hell, even Canary). Why should we be restricted because the majority of the web world is still stuck supporting outdated tech?
Ah I see. That kind of testing is typically called functional testing, acceptance testing, full-stack testing or E2E (end to end) testing. Yeah, lots of different terms for the same thing :) In my experience those kinds of tests tend to become a bit difficult to maintain, so you might not want to have so many of them. But they can definitely be useful for testing main use cases (eg. let's say "user can register an account and log in" could be one test) The BDD user story based testing I mentioned can actually be quite nice for this. I think it also can help make your tests easier to maintain. I wrote a bit about about its pros and cons here: http://codeutopia.net/blog/2013/07/28/why-use-user-story-based-testing-tools-like-cucumber-instead-of-other-tddbdd-tools/
Disclosure: self-submission. Cross-posted from /r/angularjs http://www.reddit.com/r/angularjs/comments/2xnkd9/angular_classy_10_released_add_structure_to_your/
Anytime you assign a function to a variable, it is a function expression, and there is also the function declaration (your last example). In general, they function (pun only half intended) the same, but there maybe be very subtle differences (see /u/elektroholunder's answer), like where they can be defined in the containing function. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Defining_functions
So let's say I wouldn't care about emerging markets, the low number might as well be ~30ms (let's say 20 on my machine)?
`requestAnimationFrame` and `setTimeout` do the same thing, except `requestAnimationFrame` waits until the next video frame happens. They're both async operations so they don't "waste" any time. The user being able to "still interact with the page" *between* frames is nonsensical. How do you propose that happens? The entire idea is that you're not wasting cycles throwing frames at the screen that the user will never see. To OP: You could time the computation of each frame and adjust accordingly (dynamically). You definitely do want to use `requestAnimationFrame`. One way to time it would be to check the differences between the timestamps passed to the animation handler -- if it's more than ~16.7ms, you know you're skipping frames.
Also as an aside, if your pixel processing is something that can be done in a semi-isolated environment and is rather computationally expensive you would actually be able to use WebWorkers for this. Essentially you would send the pixel data to the worker and any other information it needs then allow it to do its thing (you dont need to split it up as it acts as a separate thread - although not technically). Once it has finished get it to send the result back to your main application which can just swap out the image data. I dunno how feasable this is in your current setup nor if it would actually give you any performance benefits (depending on if its the processing of the image data or the drawing of the data thats slowing it down).
I've thought about this, but the slowest part is currently the drawing. (Takes at least 10x longer than the data processing) The fact that it's slowly building the image for me is also a good "loading..." indicator to users, without having to resort to extra markup.
Hey you can use json as well as csv
ki85squared You can use json object, json stringified, csv strings and xml data too. Also, we appreciate for your feedback on the selector id. We will check on this and try to make the necessary changes in our next update. 
&gt; In other words, as things are checked into the server, . What do you mean checked into the server? Checked in and pushed to git? You could use a continuous integration service like travis-ci to run test scripts on every push. &gt; the tool automatically checks the code and if the new code doesn't pass the validation rules it causes an error Validation rules meaning coding style or unit/integration tests? For style rules, use jshint, for tests, use a js testing framework like Jasmine (there are many alternatives). You may want to check out examples of how to configure these - yeoman's webapp generator provides some good examples. &gt; I don't want a tool within visual studio during development, I want it automated on the server. Again I don't know what you mean by 'on the server'. It might help if you described how your project is laid out more, or provided a link to source code.
I can't provide source code, but I'll try to explain better how we're setting up. We're looking for something to enforce a coding style/standard as we develop our products. For our web applications, we're building everything out in Visual Studio and then when we push things out to a server and run the application, we're hoping to find a tool that enforces a consistent style or standard and causes an error if those standards aren't met. I do know someone who uses jshint, but I thought that just worked within visual studio. Am I wrong? Thank you for your help. I hope I am making sense. 
I think one of the reasons so many go with Angular is because Google is behind it, hoping that at least *this* framework is here to stay. I know 2.0 will change a lot but still, some of us need to build actual websites from these frameworks that will last more than a year. I'm also tired of all the new *Angular, but better* frameworks that pop up all the time. Most of the time, those only implement the 10% of Angular the inventor happens to use and thus presents no real alternative anyway. It's also amazing how many JS programmers out there feel the need to make, publish and actively promote their new superstar JS-framework that differs 1% from the existing 67 similar frameworks. It's like when blogging exploded and we suddenly had to hear the thoughts of every single person on the internet, no matter if they actually had anything interesting or different to say. I think what we need is a much more strict module and dependency system for frontend JS. It works for NPM, it works for Linux and it could work for this too. At least that would provide some kind of maintainability and promote working across projects instead of the silos we see today. End of rant... sorry.
The jS ecosystem is just chaos right now... I'm building a new front-end layer right now and even choosing the build system you want to use is pretty baffling (grunt, gulp, webpack, etc etc), and that's before you've even chosen the framework(s) you want to use. You just have to choose whatever seems to meet your needs best at this very minute and accept that someone somewhere is already calling the tool you just chose out of date (probably recommending v0.0.1alpha alternative instead). ETA: Removed bower from my list because it's possibly not a build system 
What I like most about the comparison is that they don't advertise their own library as the single best solution, but make an equal case for all available solutions.
Use jshint. You want to use a task runner like grunt or gulp, or make file. Whatever works for your flow. It should run jshint and fail the build if syntax errors are hit. More so, each engineer should be running it before committing code. Consider using Arcanist &amp; Phabricator to help with that. 
Bower is a package/lib manager. Gulp and Grunt takes up 95% of the build tools ^(that is written in javascript) used in open source projects on GitHub (percentage entirely made up with the help of my vigorous endeavors). It's really not that bad.. also, could you expand on the etc. etc. without using Google?
After 10+ years as a JS dev, my personal experience is that most of the whining about JS, frameworks, libraries, and all that stuff is just a repetition of the same old complaint: "it's not the way I suppose it to be". It's not supposed to be the way you suppose it to be. It's just the way it is. Deal with it. Which is what most people on here do most the time anyway. It's not a big deal.
&gt; I do know someone who uses jshint, but I thought that just worked within visual studio. Am I wrong? JSHint can be used as a stand alone command line application, making it available to scripts or however you'd like to run it. &gt; we push things out to a server and run the application How does this work? How does code go from a developers computer to running on a server? Do you want to throw errors during application startup time? That's probably a bit late. You may be interested in something like codeship. If you want to enforce a style, though, you may want to use a build system that throws errors before code is even checked in. That way your developers never check in 'broken' code. Does that make sense? 
Not within a normal browser environment, no.
While I'd prefer gulp over grunt, no, using gulp is silly.
&gt; Bower is a package/lib manager. Bower is some kind of frontend to git. NPM is an actual package manager.
&gt; could you expand on the etc. etc. without using Google? Sure, then you get into the various options that your backend framework may provide (obviously dependent on language / platform etc). For instance, the project I'm referencing, I've ended up using Assetic (PHP asset manager integrated w/ Symfony) for building / including bootstrap css from less (because it requires data from storage to construct the theme mixin), and Webpack for React jsx transpile and other js assets (because Assetic doesn't yet have stable jsx support). Obviously this may not apply if you're running a node / other js stack, but many (most?) apps aren't and still need frontends in js. 
Not sure about CSS, but you can run HTML through an HTML validator. I imagine there are css linting tools,though .
I honestly thought this was on /r/nottheonion. 
reminds me of backbone a bit. I should disclose that I dislike backbone quite a lot. Nevertheless, thanks for doing this, might sway some backbonists for angular I guess.
Cool. Thanks a lot for your time and talking it over. This isn't really my job description, but I'm really interested in learning this stuff and this discussion helped clear things up for me.
Have you worked in any other languages or native environments in that 10 years? Just because javascript can be finagled to work doesn't mean it works well or uniformly. It has a terrible regex implementation lacking lookback, it requires active client compilation with every request, it has the worst parts of php's implicit typing and equality problems going for it. Doing something as simple as comparing object equality requires either a large framework like underscore.js or for you to write all of your own comparison loops checking JSON keys and values. And I hope you like binding, because without angular you will be doing a lot of it. In short I think "deal with it" is a very stupid suggestion which yields no progress. These things are problems. They've been solved. Browser politics keeps us from a solution.
Slapping the Google name on it actually scares me, because they're so big they can freely abandon projects, and frequently do after a couple of years. I'd just started a personal project using Firebase, and then Google acquired them, and I didn't know what to do. I have more confidence in something like Ember, because it's built by people who use it and depend on it. I remember listening to interviews with Misko Hevery and hearing him say that he hadn't built anything substantial with Angular, and it scared me away from the framework, even before the no migration path to 2.0 debacle. 
PHP, or *insert arbitrary language*, asset managers have nothing to do with the Javascript ecosystem (well, depends on how you look at it) which the topic is about though. There are a lot of stuff happening in the JS community but there are, at most, 2-4 well-tested, generally used solutions for every paradigm in the language, so you shouldn't have any problems finding a solution to whatever problem you're trying to solve.
I started out with going through the book [Javascript: The Good Parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742). It's fairly straight to the point and goes over the parts of Javascript that differs from other classical OOP languages pretty well. As the book title suggests, it doesn't go over everything in Javascript, but only the practical parts. Great short read. 
Not sure if you ever used jQuery (a framework–I think), but imagine writing code using jQuery: What kinds of patterns are you using? Are you even using a pattern? That's your architecture from what I understand. Check this out: http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html
You want to do something like http://jsfiddle.net/jghez6ck/ . I'd advise against `window.quizclock.value = seconds`, because it's not a standard. Also, whilst jQuery and Angular are great libraries, they are a huge overhead when all you want to do is update one or two elements, although it doesn't hurt to experiment with them!
Why is make silly? It's not a constructive argument and won't lead to a productive discussion. Unless you actually provide some argumentation against it, it sounds like you're just repeating what someone told you once upon a time and have done no research or reasoning to come to that conclusion. I'm all for discussion, but the arguments against that this article has raised have mostly been something along the lines of "make suxxors bcz my bddy tld me"
I know lots of .net devs and .net companies that put huge effort resources and money into WPF, silverlight, etc. LOL. Nothing is more sad to see than a .net guy with huge WPF/Silverlight experience. Atleast they know c#.
Thanks, that's indeed a fair point.
I agree. All these micro-libraries and micro-frameworks are starting to drive me fucking crazy. You can barely keep up anymore, and most of the differ in one very slight/minor way. It is insane.
Make it solarized and with Source Code Pro = greatness http://ethanschoonover.com/solarized https://github.com/adobe-fonts/source-code-pro
&gt; the slowest part is currently the drawing what? I'm guessing you're using canvas, right? You should just be dumping pixel data, it's a very fast operation
Fix the code formatting (without forcing me to download a pdf) and I might actually look at more of this I will point out a common mistake I noticed, however: _absolutely everything_ in JavaScript is passed by reference. The confusion comes from the fact that JS has immutable objects: strings, numbers, booleans, undefined, null. If you try to change one of these you actually get a new object, you don't change the old one. So they "act" as if passed by value.
It's legacy code. Currently all pixels are drawn individually using putImageData. I still have to update that part.
Frankly, if you want to avoid this type of problem, avoid frameworks that tie you into a specific asset pipeline system - or just avoid using that system. Assetic has always been my least favorite part of Symfony.
This is what the code was doing. I've implemented setTimeout and will get on with drawing in one step. Edit: Or in fewer steps, depending on how fast it is.
Angular "won" not because it was good, but because it's owned by Google. Ever since it was revealed that Angular 2.0 was a complete rewrite coupled with the emergence of React, Angular has really been losing favor. I expect that downward tick towards the end of the google trends chart to keep going. Thankfully React isn't "just another browser framework", it's not even a framework. It's a completely new approach that seems to have merit. Even if React itself loses favor, I have a feeling the ideas it brought forth will stay with us for a long time.
Ah, thanks for the idea; haven't got into node yet. But for what I'm planning I want people to do it on their own computers online though. For work in a laboratory setup I'd use specialized task-programming packages that are supposed to be pretty optimal in terms of timing. 
The fact that you think JSON stringify is a valid means of equality comparison says everything. Please please do not be so prideful as to spout ignorance. (P.S. the reason it's not a valid means of equality comparison is that it does not output "true" when child property order is different, a pretty basic requirement of any non reference equality operation)
What resources would you recommend for learning design patterns? Preferably ones that are specifically useful for web related work.
I concede that the objects have to be assembled in the same way to be comparable with JSON.stringify. But in those two cases that I ever needed an object comparison, that wasn't an issue as I had complete control over the creation of said objects. The fact that you think that JSON.stringify cannot be a means of equality comparison at least in some cases says everything. Please do not be so prideful as to shun possible solutions before you even defined your actual problem.
have this one on me: http://addyosmani.com/resources/essentialjsdesignpatterns/book/
&gt; I ended up importing 17 packages just to make it work without any bugs. &gt; [...] but it would really help not to build your own fucking package for every little extra &lt;insert package function here&gt; that you miss and work together with the packages that are already there... Node does have a **very** modular nature ^\*cough\* ^sindresorhus). It's not in everyone's flavour, personally I like it. Getting packages to work together should not be a problem at all due to how Node delegates a local dependency tree for each package.
This is **not** a problem that can be easily solved, because the problem is more behavior than technology. For newbs the problem is the DOM. For many veterans the DOM is either OK or fantastic (depending upon who you ask) but is rarely a problem. For veterans the nearly universal problem is modularity and decomposition. You can't solve both of those problems simultaneously without sacrificing something. The most common current approach is to use a preprocessor to build an app from a framework on the command line for use on the web that is then not compatible with command line use. The framework of choice determines the architecture and style of the code. Newbs that aren't willing to solve problems and dive "under the hood" need frameworks. These people will always be the majority and will always be a problem, but fortunately they don't make important decisions for many organizations so we can remove them from discussion. Veterans need frameworks to appease the newbs and solve the modularity problem. Since frameworks determine how the code is written perhaps more than anything else, and thus how code decisions are managed, this can be a very big deal. This is the only important problem to solve. Even if your code is destined to operate against only one API (the DOM) for consumption then you still need a framework to build the application against a preprocessor. **There is no native IO in JavaScript and no static compilation mechanism.** The mega old school vanilla way is script tags in the HTML, but forcing a user to download a script file per module (imagine 300+) is insane on the connection overhead. This needs to be built properly into the appropriate structure (not just a flat merge), which is the real benefit of a strong framework, so that you serve as few files as possible in the most appropriate way possible. The solution to the problem is to extend the language with an official IO or a static compilation mechanism. If there is a stand IO then code can request other code dynamically and build itself without an external mechanism. This is how most other languages decompose naturally into a plurality of files. Additionally, most other languages have a static compilation mechanism so that they compile from code and the compiled stuff is all that matters at execution time. The benefit there is that you can have 4000 code files that compile into a single binary file. JavaScript does not have static compilation. JavaScript dynamically compiles into the JIT at execution time, so even if you had 4000 code files that compile to 1 file of byte code you still have to serve the 4000 code files for them to compile.... unless you use a framework and preprocessor. If anybody addresses the DOM in this discussion they are likely a newb who does not actually get paid to make these kinds of decisions, so ignore them. Because these people are most typically the majority and the squeaky wheel this is the noise that dominates this discussion. So long as this stupidity continues the problem will not be solved. The problem will not even be addressed. **This is actually a valid problem because adopting new frameworks every couple of years means writing the web application from scratch each time, which is expensive.**
True - and I'm not trying to bash smaller frameworks and components. Actually, I'd really like the bigger ones to use smaller ones as dependencies like in other forms of software development. For instance, Angular is kind of a pain if you need anything *else* in the project besides Angular. But, being an Angular developer myself, it gets tiring to always spend time checking out *this new awesome Angular replacement* and then it can't do half of what Angular does.
Relevant xkcd: http://xkcd.com/927/
Good article! &gt; Indeed, I mentioned innerHTML is fast. if you just need change a attribute but replacing all DOM nodes with innerHTML completely, it would be obviously inefficient. The innerHTML approach is typically faster than the DOM way for bulk writes compared to high frequency writes, and the opposite tends to be true as well. In old browsers the DOM was always generally fast to process instructions but a bottleneck to access the actual *document* object at the high level. In modern browsers DOM access is supremely well optimized. There is a cost to frequently touching any external resource, but the DOM is optimized to accept this challenge. The advantage to the innerHTML approach is that while it is slower to access the DOM than the DOM methods its nodes are all created and destroyed by native code that executes faster than JS code.
Please use different headings :) It's hard to tell what are headings and what are sub-headings - your `// Returns undefined. No warning` piece is wrong (you're missing a line break to actually make the code break like you intend ;)) - lower case `eval` &gt; Debugging can be more challenging (no line numbers, etc.) you can actually fix this with source maps &gt; Constructor ... No way of checking for this issue um... `if( this.constructor === Foo )` &gt; Simple types "Primitive", not "Simple" &gt; Usually implemented as hashtables Eh, not really :) Objects are generally only implemented as hashtables if you destroy the class lookups (generally by using `delete`) &gt; Instead, make an array containing the names of the properties in correct order Use `Object.keys` &gt; Delete _do not use_ unless it's on singleton objects. Destroys class lookups. &gt; Encloses a set of statements, and each function creates a new execution context (this) Unless you use `new Function` ;) I actually have an "isolate" method that serializes and deserializes a function so that it no longer has a closure. &gt; Literal the `return` in your code has a capital `R` &gt; IIFE Please use `!function(){}();` instead. It prevents errors if you miss the trailing `;` gtg... :)
Adding new versions is simple enough. Just file an issue or ask for a version here and I'll do the commit and publish it on npm. Also, haven't been tested on Windows.
Only 16 minutes? 
I considered changing always here but I felt it was often enough to get my point. And even if it's not possible to contribute upstream, you can almost always take what's there and modify locally, if nothing else. I can't imagine there are too many employment situations where you can't modify third party FOSS whatsoever to make it fit. And again, this is still primarily edge cases. Most modules I see in the ecosystem are easy enough to just shim directly.
Who is billing it as an "Angular replacement"? The authors? Or community hype? I haven't really seen too many real examples of this happening
look at SonarQube: http://www.sonarqube.org/
Exactly. Trying to stay on the cutting-edge, hoping to not miss a second of the next-big-fad, is a fools errand.
&gt; Simply add this package to your dependencies at the version you want to enforce, e.g. &gt; npm install --save npm-version-check@2.6.1 &gt; If someone installs your package without having a version superior to the one specified, installation will fail. so if I say I want version 2.6.1 and version 3 is available, it'll still work?
:)
A jsperf test being implemented wrong and giving false results? Color me surprised.
A simple solution to nesting is to use a recursive function. Then context is maintained by the stack memory that calling the recursive function creates.
Publish / subscribe is one of the design patterns I have used most in web applications. Now ES6 code will have Object.observe which does a similar thing.
Hmmm, I don't really see the Backbone comparison, perhaps it's just the fact that it constructs the controller from an object literal. I definitely took inspiration from projects like [Vue.js](http://vuejs.org/) though.
I think what I'd want to do is: 1. 1 in the CSV, count the commas in the line, up to a digit or letter (this is what I think lines 6-10 does in here http://jsfiddle.net/crev32e0/) 1. remember that count, for every comma output &lt;ul&gt;&lt;li&gt; into the inner HTML, close with &lt;/li&gt; (similar to line 11 in the above example - but instead of assigning classesqith a number following the class name, it needs to add nested &lt;ul&gt;&lt;li&gt; for each indent [am i explaining that right?]) 1. if the next line is less than the line you just outputted last, add in a closing &lt;/ul&gt; so the unordered list can be outdented. 1. Finish off the whole output with a &lt;/ul&gt; I have no clue how to do this! I don't know the syntax at all, and it's so very frustrating. I feel like a toddler. It's all right there at my finger tips! classlevel assigns a number depending on what level the line in the CSV was, but instead of a number i need it to be ul's and li's, down on line 17, k counts the classlevel and adds the inner HTML, i need to figure out how to make it add in the needed closing tags. argh.
&gt;The fact that you think that JSON.stringify cannot be a means of equality comparison at least in some cases says everything. Just an FYI, the order of elements in a JSON object is not guaranteed unless they're arrays. In theory, the exact same object can be stringified in multiple different ways and still be a valid JSON object but return false when being compared as a string. &gt; Please do not be so prideful as to shun possible solutions before you even defined your actual problem. He is not in fact being prideful, he's being correct and trying to tell you that your solution relies on a false premise that is only guaranteed to be true in extremely limited use cases (1 key on each level with the value being a primitive, string, array, or 1 key object). 
&gt; Gulp and Grunt takes up 95% of the build tools used in open source projects on GitHub (percentage entirely made up with the help of my vigorous endeavors). `make`?
Rather gouge out my eyes and pour salt in them tbh
Angular 1.0 will be here to stay and there will most definitely be upgrade paths to 2.0 even if there isn't any yet.
well, there are like 10 people paid by Google to work in Angular, the reason why there's no upgrade path is completely different.
Don't blame them for creating their own frameworks (good learning experience), blame the assholes trumping up the frameworks as the next new thing (every six months). I'm talking about the mags, dev shops, prominent bloggers, etc.. It's exhausting.
I have created a sample for you here: http://jsfiddle.net/cjc7gnc5/
Is not, calm down. Angular2 is at least a year away of being production ready. Angular 1 will have many more years of support. Many Angular concepts will continue, some others will go away, but mostly in favor of simplicity, sure, you can't auto migrate most of your code but if you're currently using Angular properly (controlleras, etc) it will be easy to do the changes you need. The folks at Google are not ill intended and trying to fuck us over, they're really nice people and are thinking on ways to help us out :) 
`npm install gulp` from a deeply nested folder. Many of the packages come with a plethora of deeply nested dependencies and it can be a pain to work with. Windows file names include the path and some of the APIs still in use use the limited length file names.
Design pattern. NPM. /thread.
Let's all take a moment to focus on the [sweet comic](http://cube-drone.com/2014_02_19-Cube_Drone_76_Many_Angular_Ones.html) that he used to illustrate his article. Maybe... click around on that cartoonist's website a little. Really let it sink in. &gt;_&gt; &lt;_&lt; No ulterior motives here, folks. 
Nice little library man. Hope you don't mind my asking, but as someone who's tried (and usually failed) to promote my own, [somewhat similar libraries](https://github.com/bvaughn/task-runner/)- how on earth did you manage to snag 100+ stars in half a day? I'd love to know your secret.
Not sure why you got downvoted. There doesn't seem to be any JavaScript in this post and it does look like JSP. This is the wrong sub for sure. For the /u/mdovey, I'd suggest a different approach. Use the user input, **validate it is a sane value** (something like a number between 0 and 100). Add that number as a limit to the query and be done with it.
Also flux and immutability are cool and semi related.
It seems I got carried away. Obviously I know these are two different things. Thanks for reading! Hope you enjoyed the REST of the post. =)
I've just started using Meteor and have literally fallen in love. 
The bank I work for was headed solidly toward Angular for the upcoming site rewrite, but when the whole 2.0 news broke, it spooked everyone, and nobody in the org is pushing for it now. Scary how fast that changed.
Wasn't Object.observed bumped to es7?
Save it in localStorage or offer it for download, or what?
Meteor is the way to go. It's the future!
On the serverside? node-webkit / node-webshot? Somewhat related I made "website thumbnailer" built on top of node-webshot called jin-thumb on github. Demo at http://cloudproto.jin.fi/ (you need to paste in full http:// urls for the upload to work)
Hey wait a minute.. you are the mustache-bob square-face aren't you?
Ah, okay, I misread at first =)
use sharp to resize in node on you're server side https://www.npmjs.com/package/sharp 
.... maybe
Why all the angular hate? Once you get the hang of it, its a lot better than nothing.
While I commend your intentions and effort... Don't you think it could be more helpful if you wrote a little article somewhere explaining how to create an easing function? I'm saying this because... "full list"... well, there can be infinite functions that can work. So I think explaining how to create and tweak your own function would be more interesting. You could even explain when to use a symmetric function and when an asymmetric one, why use higher or lower powers, how to combine different basic functions... you could draw little plots to aid your explanation...
You are right.
God knows, it did briefly hit the front page of Hacker News :)
Oh. Well that's an impressive feat man. Congratulations. :)
This is JavaScript. If it's not Microsoft's fault, it must be Crockford.
It's slow as dogshit and doesn't use npm. Pass.
FYI: all implementations of JSON.stringify I have ever tested (all major browsers, including mobile, plus JSON3) yielded the same order when the objects were composed in the same order. I'm not so naive as to assume such things before using such a solution.
&gt; There's no excuse to take the half baked short cut Your alternative is as half-baked. You forgot recursion inside the objects, to check for hasOwnProperty and to avoid infinite loops for recursive Objects (which requires a stack), e.g. a = {}; a['a'] = a; JSON.stringify does both of these - granted, for object comparison, it only works for a limited set of objects (those composed in the same order). And you get me wrong, I don't try to explain the limitations of JS away. I just say that instead of whining all the time what you haven't got, you better make do with what you got.
Remove the returns from within the if statements : function myFunction() { var age = prompt("Enter your age: ","enter your age"); var price = 9.00; if(age &lt; 4) { price = 3.00; } else if (age &gt;= 4 &amp;&amp; age &lt; 17) { price = 7.00; } document.getElementById("demo").innerHTML = "Your total is $" + price; return price; }
I think you are confusing ES5 with ES6. `.map()`, `.filter()`, `.forEach()` etc are [Array functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) added in ES5. These are all [Compatible with major browsers](http://kangax.github.io/compat-table/es5/). ES6 on the other hand is [Lacking compatibility](http://kangax.github.io/compat-table/es6/), but you can start using it with other tools e.g. [Babeljs](https://babeljs.io/) which transforms your ES6 code back into ES5. They have a [nice writeup on ES6 features](https://babeljs.io/docs/learn-es6/). However if you're struggling, I'd suggest sticking to learning the ES5 stuff before jumping straight to ES6.
Good catch. Was not looking at the age logic. Fixed my last comment ;)
For it to work we have to keep something like a textfield mostly invisible. It can have a size of about 1 pixel wide/height or so. When I created mine, I gave it a name of "input driver". I use it for some similar tasks. But it's more complicated than it sounds. Like, if we want the user to be able to CTRL+C from it, we need to keep it with the data that the user wants to copy nearly always. And if we want to paste from it, we need to detect when the user pasted something that was different than what we had before. On the plus side, it could also be used for focus control. But it's a hack. It's unusual. It's better to avoid it when you can. I will give you a tip though. To see how it could work, place a textfield element that you will control. Give it absolute positioning so that you can move it wherever you want it to be. When you want to edit a cell with it, put the content of the cell on the textfield. Then let the user edit it normally. And on the change event of the textfield, you can record any changes. The user would then be able to copy/paste from it normally. No tricks needed.
&gt; It is good to invent new things, as long as they are actually new and not a marginal improvement on something existing. Aren't most advancements built from many marginal improvements?
That's exactly what I'm doing, but I really need it to copy to the clipboard automatically.
/u/petecoopNR already covered the fact that these are actually ES5 features, but as for the rest.. It sounds like you already have a rudimentary feel for functional programming, and you could hop right on over to native functions right now with little effort. My advice is to [always check out the Mozilla Developer Network's entry on Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) before reaching for JQuery or Lo-Dash. The most basic example is the fact that JQuery.each is really just Array.prototype.forEach. In fact, native is much cleaner. var arr = [1, 2, 3, 4, 5]; $.each(arr, function (item) { doSomething(item); }); arr.forEach(function (item) { doSomething(item); }); For some of the Lo-Dash stuff, you may have to be a little creative. For example, _.uniq var arr = [1, 2, 3, 4, 5, 6, 2, 4, 6]; var unique; unique = _.uniq(arr); unique = arr.filter(function (item, index, self) { return self.indexOf(item) === index; }); So, the code in this case is not quite as pretty as Lo-Dash, but if you were pulling in Lo-Dash just to have the _.uniq function, you may be able to eliminate that dependency with just a little creativity. I think it's a very good exercise to try to figure out ways to avoid using things like underscore, Lo-Dash, ko.utils, etc.,.. It's good for the brain, and might save a lot of pain in the future if you need to upgrade and a function is deprecated or you eliminate the library altogether.
They exist where JavaScript lacks a certain feature. For example, it lacks namespacing and visibility modifiers, so everything is made inside an object inside a function. var testModule = (function () { ... })(); everything is now "namespaced" to `testModule` this design pattern is very commonly used
I think you missed what I was talking about. The tools are frameworks which fuels the problem of framework churn.
Uglify is not a framework, it's a tool. Neither is NPM or Grunt. Angular is a framework. And hey - it deals with the DOM!
Just curious, why do you hate Assetic?
I do agree that Slim is fantastic!
I read [this book](http://shop.oreilly.com/product/0636920028857.do) a few months back and it really got me into the funciontal mindset. The examples use underscore.js (basically the same as lo-dash since lo-dash is a fork of underscore I believe) but it might really help you to understand the concepts and ideas. 
I disagree about trying to avoid using libs like lodash. It is actually an amazing thing that the js community has united under a library such as this. If everybody is using the same functional styles, same argument placements, and using a library that is properly versioned and maintained... Its nothing but a giant win for us all. If I have to figure out what your code does because you wrote your own functional methods, or used a library that made up its own way, it takes time and understanding away. If I see any lodash method I know exaxtly what it does and how it performs.
I didn't mean to avoid it in all applications, but rather than just reaching for it on all things try to write these types of things with the fundamental tools provided by ES5 as a learning tool. That way you get some practice, and in the case that you do rip out lo-dash or the like in the future you'll know exactly what to do.
&gt; be maintained by the community in a worst case scenario I promise you this is what will happen. Google will move onto something shiny and abandon Angular like it has for almost all it's other products. 
I spent a good 5 minutes looking through the comics trying to find an ulterior motive. Clever girl.
the download link doesn't even work!
FYI, this is called a closure.
Scrolljacking on a docs page of all things. 
The only reason I had to make this from scratch is because the AJAX modal windows wouldn't let me attach DOM events to them because they were being loaded after the DOM was being traversed. I see the appeal behind AJAX. But sometimes people want to do something so simple. And AJAX is a bit restricting at times.
I don't think it's unlikely that google will formally stop supporting Angular, but even so, I think a lot of the core contributors will continue to contribute, just on a smaller scale. In my eyes, the biggest concern of such a large open-source project is that it becomes such a bloated mess that isn't maintainable except by a team of full-time workers - but I'm not too worried about Angular.
That landing page is horrible, it tells me nothing and moves the links for no reason. The documentation page is also horrible to navigate through. Would hate to browse that on a phone. 
Exactly. I hate to sound so negative, but after 20 seconds on that website and the performance of trying to click/scroll things.. I wasn't impressed at all. Edit: After refreshing, it wasn't as choppy the second time. Weird that it acted so strange upon the first visit.
Assuming the code is runing in a browser, you could debug the code in the inspector and check the variable's value that way.
I think I understand what may be wrong now. On the browser's textarea, lines have a standard line ending of "\n". On Windows, the standard line ending is "\r\n". By uploading the file directly, the lines may be ending in "\r\n" and that may be confusing it for you. I just tested it on Linux, and it seemed to work OK. Because on Linux the standard line ending is "\n" like in the browser. So when I saved the sample file it picked up the line ending that the program understood. I will take a look.
I'm starting to really love this language. Of course, there is so much potential to write idiomatic, unmaintenable code that it's frightening.
Yes this is a serious problem with pretty much all languages but especially the front end because of how many designers dabble in or transition to dev. jQ and plugins really put the final nails in the coffin there by letting people make stuff work without having any idea what is really going on. Non developers getting into programming ass backwards makes them spend years running around like a chicken with their head cut off and thinking they know what they are doing without having a clue. A solid understanding of programming and especially javascripts quirks (prototypes, lack of types, first class functions) is all you need to do pretty much anything you want in js. But in my experience 8/10 "javascript guys" couldnt tell you what a callback, closure, or object literal is. 
Sure, *this* small example doesn't need jQuery. But chances are that this is a part of a larger app. Based on the nature of the question, the developer is probably new to JS and needing to Get Stuff Done(TM), and I think a popular framework like $ is likely to be a good way to do that and to find compatible code examples and plugins online.
Yup that fixed it on windows. It's weird that text areas use different line breaks than file inputs. Stupid UIs.
&gt; If you are a Web 2.0 developer Err, not a great start... edit: looks like "2.0" was edited out of the article
Hi /u/gonzalo123, please read reddit's rules @ http://reddit.com/rules, as well as our [guidelines](http://www.reddit.com/r/javascript/wiki/index) regarding promotion &amp; self-promotion. In short, you should post from a variety of sources, and not just `gonzalo123.com`. Thanks for your understanding. domain submitted from|count|% :-|-:|-: [gonzalo123.com](/search?q=%28and+site%3A%27gonzalo123.com%27+author%3A%27gonzalo123%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|47|69%
Just came to say I really like the idea of doing a table fallback, what a creative solution :) Good work! 
Thanks! I felt support for non canvas supported browsers was essential. 
Brice, pls
Thank you! I'll read up on this and make a commit fixing it pretty soon! 
What?
JSP = JavaServer Pages. /r/javahelp
This is very exciting. For reference, could we list the programming languages whose compilers are taking advantage of asm.js optimizations (and those we wish were)?
About your edit: You are too self-righteous by half, which is currently reflected in the up-/downvotes. JSON.stringify was just an example about thinking out of the box. I learned from my mistake and conceded the limitations of the solution some comments ago. Also, it's not me who is foaming at the mouth - and I surely hope it's not you either. You may already be a good developer, but focusing on limitations is not the way to go with JavaScript. That's what I learned in my time. If you refuse that small wisdom, all the worse for you.
Copying over from my HN comment, if anyone is curious. I'm at EmberConf and watched the keynote. Slidse here: http://f.cl.ly/items/0t031v2Z3y001V1N0F3N/Virtual%20DOM.pdf ---- Here's a TL;DR: A handlebars template might look like this: &lt;div class="foo"&gt; {{#if enabled}} &lt;p&gt;I'm enabled!&lt;/p&gt; {{#end}} &lt;/div&gt; The usual DOM-diffing algorithm compares every single thing: "has this div changed? Has the class changed? Has the &lt;p&gt; changed?" This uses the knowledge of Handlebars to make the diffing algorithm smarter: you don't need to check if the &lt;div&gt; or its class has changed, it never will. You don't need to check if the &lt;p&gt;'s contents have changed, it never will. This means less to diff, which means more speed. This is the advantage of using a declarative syntax for templating: this analysis can be done entirely at compile time.
I was asking what languages use asm.js as a compile target. For example, if you had Python code compiled to ASM.js you would enjoy Python in the browser (and fast).
Emscripten allows you to build asm.js output from any LLVM language.
We need more LLVM languages then.
&gt; But in my experience 8/10 "javascript guys" couldnt tell you what a callback, closure, or object literal is I knew it was bad and you probably have much more experience than me but... is it *that* bad? It's so simple?
It depends on which kind of "javascript guys" were talking about. Also, im in an area with a moderately large tech sector but really bad talent (Not ny,sf etc) The "front end devs" I run into the most (when people are applying as front end devs, or even meeting fellow devs) are good designers who write okay html, messy css, and learned how to stick jquery in document ready to make things spin. Node.js has really raised the collective consciousness of the JS community quite a bit, but I still come across way way too many front end guys who dont take learning programming seriously. The 2/10 outlier is either a real programmer who got really good at js, or a front end guy who got really good at programming.
I mean I like him and all, but he's just some guy with a blog. If JS fits a group of guidelines he wrote in a blog post once... well, OK, great.
This isn't a javascript thing as much as it is a Sharepoint thing. What is this list doing, is it custom, how was it built? 
&gt; The 2/10 outlier is either a real programmer who got really good at js, or a front end guy who got really good at programming. Yeah, you're probably right. I started out programming with HTML/CSS/JS and did a lot of it for fun. Moved on to "real" programming for 5 years then went back to JS. And I sure enjoy it more than 5-10 years ago, at least. Especially Node.js is awesome, in my opinion, when used for the right things.
Go could be an option, but the "runtime" (normally baked into the executable) would also have to be compiled and sent along. This means your apps are like 3mb at a minimum.
Unless I'm missing something, setmask() and ismasked() do the exact same thing.
I'm not a fan of fat arrows or classes. They work against the language, not with it. It seems they're only there to make things feel more familiar to users of other languages. As we've learned (from new and constructor functions) they tend to harm far more than they help. Default parameters are a nice addition though. It's a shame we couldn't just have those, and leave the bad and unnecessary additions out.
Fuck yeah ember team. People may hate how in flux the front end world is at the moment, but I bet shit like this wouldn't have been happening if we stuck with an angular or backbone monarchy.
According to [CanIUse.com](http://caniuse.com/#search=canvas), the only real holdout is IE8.
https://github.com/rust-lang/rust/issues/2235 https://github.com/rust-lang/rfcs/issues/604
You make take exception with what you perceive as my arrogance, but this is a learning community and your mistake is a pervasive one. I'm sorry for making an example of you, but I feel you are a very good representation of the larger community and I want better standards for javascript developers across the board. The lack of standards within the language itself (my original point about the equality comparison) is the reason issues like this can even be done wrong in the first place and be argued about by you and I. Such an object comparison in many other languages is trivial, just like threading and a dozen other things. When you make appeals to your authority as a veteran developer at the start of your posts people look up to you. I'm sorry if I offended your professionalism. Doing one thing incorrectly does not reflect on the rest of your code.
Adding an array to the middle of another array: array1.splice.apply(array1, [startOffset, 0].concat(array2)); Faster than calling: array1.slice(0, startOffset).concat(array2).concat(array1.slice(startOffset)) Example: a1 = [1,2,3,4,5]; a2 = [21,22]; a1.splice.apply(a1, [2, 0].concat(a2)); console.log(a1); // [1, 2, 21, 22, 3, 4, 5];
&gt; Let’s put it that way, if you come from the RoR world, where convention over configuration greatly reduces boilerplating and “forces” you to follow commonly established best practice, you’re going to struggle with Flux. I just got started with React and this is the main thing I'm struggling with - how to structure things. Ok, so everyone is touting Flux as the pattern to use with React, but there's something like a dozen semi-popular implementations, all with a slightly different way of doing things, and there are new ones popping up all the time - it's too overwhelming and nothing sticks out. I don't have a whole lot of Javascript experience so I'd rather not be obsessing over implementation details that I have no conceptual reference to compare with, whether trying to evaluate frameworks or attempting to build my own. Too many options means I'm basically frozen to inaction. For that reason I'd really like an opinionated Flux framework with a concrete structure, a place for everything to go (like Rails), so I can just be productive from the get-go without having to worry so much about specific Flux implementation details. I guess this is to be expected with a new paradigm, things really haven't had enough time to mature. Regardless, I feel like I've made the right choice with React (especially with the announcement of React Native), but I just kinda wish I wasn't left to my own devices as much, because the only thing I've known up until now is MVC (and jQuery spaghetti code). For my case, at a basic level all I really want is a CRUD interface to my backend RESTful API, with the ability to do optimistic updates in the views. Are there any basic examples of this (using Flux) floating around? Currently I'm just hacking it together with all methods being in my components, but this is obviously a bad idea and getting messy fast. I kinda just want someone in the know to *tell me* what to do so I can just get over this dumb hump and build my app.
It's probably because I don't often use 'this'. Well, that is, I don't often use 'this' like I'd use it in Java or C#. In JavaScript, I find I don't often have a need for 'this'. I just don't see the purpose or appeal of fat arrows aside from making things (superficially) easier for people new to the language. The cost, of course, is the introduction of horribly unreadable syntax and surprising inconsistency. I don't think they're worth that expense.
I'd be curious to hear what makes you feel so strongly about it.
I agree with you that classes are bad, but don't get the fat arrow hate.
Well, they suck...so there's that... :p But seriously, I've actually stopped using prototypes in my js, and haven't looked back. I don't hate them, but I've found them to be less useful then other forms of inheritance, such as traits. When I do use them, I don't use inheritance. My code looks like this: var Pub = function Thing(args) { this._args = args; // do constructor things }; module.exports = Pub; // or window[Pub.name] = Pub; var proto = Pub.prototype; proto.toString = function () { return Pub.name+"[args="+JSON.stringify(this._args)+"]"; }; This pattern is super useful, both on the client side and server. The thing I really like is the constructor is only named in one place, so even the name is DRY. 
Inheritance, interfaces, constructors, all the big mainstream languages use them - so for most people JS's prototypes are the first time they come across them. A whole new paradigm. Instead, there's prototype chains, weird work-arounds for private/public methods, work arounds for inheritance. A prototyped program structure looks sloppy, like an imitation or an early idea of what a language with classes and objects should be. The "class" keyword's even getting added into the latest version - which shows the direction the language may be heading. I hope one day there's an "option classes;" 
JS to asm.js is not a really interesting scenario. Basically javascript has all of these features like dynamic everything that make it very easy to write but slow down the language. And they make it such that a JIT is the only sane way to go. At compile time it might be impossible to determine that you use your "var" as an int, but a JIT can speculate that you do (and reevaluate its assumptions if it turns out to be wrong). A C++ compiler cannot ever "speculate", because it doesn't have any code path to go down if it is wrong. It must be exact. For that reason, a JS -&gt;C++ converter would be bad, because your c++ compiled code wouldn't be able to make any assumptions about types and would always have to unwrap everything in order to do calculations. And for the same reason JS-&gt;asm.js would be bad, because asm.js is basically going to be a slightly slower version of that now very very slow c++ code (not to mention that now everything like GC will have to happen in the main execution thread). C++ doesn't have these issues, so if you write fast c++ code, you can convert it into asm.js and it will optimally be almost as fast as if you had compiled it into machine code directly. Also, it's important to understand that asm.js is not useful for normal javascript operations where you are mostly using it to manipulate the DOM. It is only useful for computationally heavy scenarios (with games being the most compelling scenario).
It largely avoids garbage collection. It can not avoid it completely. It uses very large typed arrays for virtual heap. http://asmjs.org/spec/latest/#programming-model
Seriously, is there any active development in backbone anymore?
I consider a fully fledged package manager to at least have a centralized repository, and not just point to arbitrary git endpoints.
They change the behavior of 'this'. That's what I mean by "surprising inconsistency". 'this' works exactly as you'd expect, unless you're coming from a language like Java or C#. Fat arrows, like new and constructor functions, try to serve new users, but ultimately confuse the language. Just like classes. If all they did was add some ugly looking syntax, they'd be harmless. Judging from the down-voting, people really don't want to hear anything critical about them. I'd like to know why people are so excited about them. Surely, they're aware of the problem I brought up? 
Or use [co](https://www.npmjs.com/package/co) to yield either promises or thunks or arrays of promises or thunks or POJOs of promises or thunks. Bonus: co returns a promise, itself, so you can yield a co from a co. Reading the source is educational. (Edit: huge fan of koa. Which is all about generator functions yielding promises/thunks)
Does not seem to be. Backbone-marionette is still doing some work, but it's mostly small touch-ups on established practices rather than anything revolutionary. 
&gt; I HATE _prototypal_ languages. FTFY.
It's not open to the public yet, no. It's not even finished yet AFAIK. The private repository was made available to ReactjsConf attendees.
It's still just as accessible. Every browser on the desktop has a REPL :) It's just grown up a bit. If you're doing one off jQuery snippets, and that's all you need, power to you. But as the language (and its kit) matures, of course there will be more talk about the tools that people building professional grade JavaScript code bases use.
I said, GIVE US THE THING.
Now, why would the workflow be horrible? I would imagine you write, compile, deploy and repeat as normal right? 
I've given the same response in another thread (on /r/programming): While I agree QML is awesome, last I checked (admittedly a little while ago) it doesn't actually expose the native views, such as UINavigationController on iOS, for example. For this reason, an interface built with QML doesn't feel as native as React Native will be (unless of course you're targeting Ubuntu Touch, BlackBerry 10 or Sailfish OS, in which case the native interface is QML).
You really won't go far with "one hour side projects". In my opinion, if it's something you can do in an hour you better off just learn it when you need it. This way the practice won't be in a vacuum and you will have the extra value of getting to use your code immediately. That's why I think long term side projects are better than this mini projects. You will get to learn a lot of this small thing during an ambitious side project. Even if you will never finish the project, the tools and methods you learned while working on it will be extremely valuable. 
Well, how long would a cycle take? How long does it take to compile to C and then to JS? And then the browser has to parse it and compile it once more to machine code. The next problem is debugging. How do you debug your code? For comparison, with Dart, you can just save and hit F5. Debugging can be done from within the IDE. You can just add breakpoints and step through your code. You can also break on exceptions. You can inspect the values of local variables. You can drill into maps, arrays, and other objects. You can also profile your code. "Printf debugging" really doesn't cut it anymore. Even less so if a cycle takes a while.
Months form here people here will start forgetting about Reactjs .and talking all about Ember, because trends
`co` is really nice! I especially like that you can yield objects (in addition to arrays). But it still uses Promises as the glue mechanism, which may not be necessary.
That is very helpful. I think mapping the source to the output is a problem that had been solved before in a different environment but takes a lot of time to develop.
Poor title, this is the feature of react that literally nobody can QUIT talking about. 
I feel like everyone is getting hung up on things like 'now I can use javascript on native environments', and 'titanium has had this for years' etc. I don't see many people saying 'finally I can use React to power my native app'.
&gt;One of the major themes I focused on was the fact javascript developers like myself can now easily get into the native world, and that companies only need to hire for one skill set to build and maintain their entire suite of applications. Pffffffffffffffft! Keep dreaming.
&gt;I don't see many people saying 'finally I can use React to power my native app'. Well, that's because they can't. This is kind of silly. People are extremely excited for React Native, but it's in *closed beta*. What are people supposed to talk about, how excited they are?
Well yea. There was a lot of discussion after the initial announcement.
&gt; horribly unreadable syntax I have to disagree with you there. the new syntax allows for some amazingly concise and readable code. A trivial example: arr.map(item =&gt; transform(item)); Or, creating a higher order function that returns a function with not only a closure over the scope but over the this.context as well: class Thing { doAThingWithCallback() { /* snip */ return () =&gt; { /* snip */ }; } } Now, obviously neither of these things is doing something that couldn't have been done before, but the expressiveness of the language has gone up considerably. I think that's a good thing. 
Thank you so much, I really appreciate your time and willingness to share all this. Good luck with the startup - I work for one too, and there's certainly no "not my job" when there's literally nobody else to do it. :)
This is a great idea - I want it. Make it easy to link between notebooks / notes within a notebook. 
Lots of ads and annotations. The most interesting slide: http://i.imgur.com/PUc2Zx9.png Really looking forward to SIMD. Typed objects sound interesting. Quite surprised to see user-defined operators there, too. Noteworthy bit at 19:42: &gt; `var` was a mistake. [...] `let` is the new `var`.
is this not the same as what products like appcelerator already do?
It is humbling to see the creator of the language admit that it was indeed a mistake. That being said, the man was in a rush to have the language functioning for a demo. I personally think that if he had been given a little more time, things would have been different since he would have thought deeply about the architecture of the language.
https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial
Thanks. Sounds like you would like to see more wiki-like features?
Yeah, basically. That's what I'm going to use it for. Make it easy to link thoughts and ideas. Except without the annoying need to have html markup all over the place (a la Tiddlywiki). Markdown is better. 
The behavior of 'this' is consistent, though not intuitive if you're coming from Java or C#. 'this' makes perfect sense in the context of the language. Or it *did* make sense, until the fat arrow *introduced* deeply inconsistent behavior. That's going to cause far more confusion than it could potentially alleviate, and offer the hard-line JS critics solid ammunition.
Depends on what you're doing. If all you do is game development, you can get by just fine only knowing C# for example.
Coffeescript has had it for a while. I'll probably get crucified just for mentioning it though.
Hey /u/robbiemccorkell are there any examples of a WebView in the examples they distributed in the early build? Also, has there been any chatter that might indicate React Native being released during/before F8?
Getting a function out of local storage is probably a terrible idea.
Promises also allow you to have multiple responses to a success and failure, sometimes private responses which are then passed down further in your api. Different tools for different jobs.
He's made some pretty big mistakes recently so I guess he's well practiced in the humility thing. 
If you're looking to make awesome graphs, check out D3.js. http://d3js.org/
Like what?
9:35 what a syntax error! it's ${time} not ${today} on that Template String Interpolation &lt;|8D.
If you follow the es-discuss mailing list, he often digresses on how different mistakes he made at the time affect (and often hinder) new features and proposals. 
When Mozilla prototyped generators in Spidermonkey years ago, [Neil Mix did this brilliant thread library](http://www.neilmix.com/2007/02/07/threading-in-javascript-17/), might still be worth looking at also, for the curious, or as a starting point.
He was CEO of Mozilla ... for 9 days ... until he was outed, and forced to resign ... for being a bigot http://www.cnet.com/news/mozilla-under-fire-inside-the-9-day-reign-of-fallen-ceo-brendan-eich/
I'm not sure he'd consider it a mistake.
You may want to ask more specific questions. What about canvas and events are you having trouble understanding?
Hmm, I don't believe that code (or the parent comment's code) will work because Node's `fs.readFile` doesn't return a promise.
I love react (have been using it in Web projects for a while) and agree that being able to do things the react way in native is the biggest selling point of react native. What's unclear to me though, is if we can only code the view layer in react with react native. For example, can i write my data storage code in js with react native? I don't mean I want to be able to reuse my existing code for using idb on the Web or even expect to write to the db with the same code on Android and ios, but is react native going to offer apis to reach native apis through Javascript bridge/javascript core ala native script? This would be preferable. You could use Nativescript alongside react native, but my experience with Nativescript thus far makes me... Not want to. 
Just use ES7 async/await with babel. 
Most of those people weren't trying to be CEO's of major Silicon Valley organizations
These... These are my people
One simple improvement would be to remove the hard-coded `active` class and instead reference a property of the `settings` object, such as `settings.active`. This would enable users to use a class name that is integrated with the site's CSS architecture. And I would namespace the default value of the `settings.active` property; something like `scrolltrig-active`. 
&gt;be
Yeah, very unintuitive too. C++ and Java and C# *just make sense*. You don't need to know about _prototype or prototype existing in things you instantiate, hiding behind the scenes... It all seems like an early attempt at an OO bolt on to a C kind of language to me. Ungraceful kludges...
That's not correct: console.log(Mammal.isPrototypeOf(felix)) // false console.log(Cat.isPrototypeOf(felix)) // false What you probably meant is: var Cat = Object.create(Mammal); var felix = Object.create(Cat); console.log(Mammal.isPrototypeOf(felix)) // true console.log(Cat.isPrototypeOf(felix)) // true Now you got inheritance. 
I wish. First time I've seen it come with a generic &lt;error&gt; rather than something nice and descriptive like object is undefined.
This looks quite cool! I'm missing date support thought. I also don't like that you can't store an array of functions or an object with a date parameter. You should have a look at the BSON spec, it's easy to implement and should support everything you need. Then you can serialize complex objects without loosing information. http://bsonspec.org/spec.html
What's `mammal.type` at the end of this?
Javascript is the new brainfuck!
&lt;sarcasm&gt;Yeah, because there are so many better languages available on the backend-like PHP.&lt;/sarcasm&gt;
The prototype object remains unchanged. The new object gets a reference to the prototype object. So mammal.type in the example remains 'mammal' even after felix is created.
Yes, I missed using create. Here is the correct version: var Mammal = {}; Mammal.type = 'mammal'; var Cat = Object.create(Mammal); Cat.type = 'feline'; var felix = Object.create(Cat); felix.name = 'Felix'; alert(felix.name + ' is ' + felix.type); alert('Mammal type = ' + Mammal.type); http://jsfiddle.net/rsd07yos/ I will correct the OP.
With less than 40 lines of library code, you can use objects as constructors (instead of functions). That looks as follows: Defining two “classes”: // Superclass var Person = Proto.extend({ constructor: function (name) { this.name = name; }, describe: function() { return "Person called "+this.name; } }); // Subclass var Employee = Person.extend({ constructor: function (name, title) { Employee.super.constructor.call(this, name); this.title = title; }, describe: function () { return Employee.super.describe.call(this)+" ("+this.title+")"; } }); Using the two “classes” (note that we instantiate `Employee`, which is an object, not a function): var jane = Employee.new("Jane", "CTO"); // normally: new Employee(...) &gt; Employee.isPrototypeOf(jane) // normally: jane instanceof Employee true &gt; jane.describe() 'Person called Jane (CTO)' The library (a proof of concept, not something I’d use in production) is here: https://github.com/rauschma/proto-js Caveat: ECMAScript 6 classes are constructor functions, internally. Therefore, constructor functions are more future-proof (at least if you intend to use ES6 classes).
With pure prototype oriented programming it would be something like: // Super prototype var Person = {}; Person.name = ''; // Sub prototype var Employee = Object.create(Person); Employee.title = ''; Employee.describe = function() { return this.name + ', ' + this.title; } var jane = Object.create(Employee); jane.name = 'Jane'; jane.title = 'CTO'; alert(jane.describe()); http://jsfiddle.net/6s8w6fqn/
Yea from what I've heard there will be an API surfaced for local storage. I think it's quite a tricky problem for them though because local storage is a synchronous process whereas the react native stuff is async. But they seem to be sorting it out. Interesting that you're not a fan of NativeScript! I haven't had the chance to play with it yet. However a colleague of mine said that once he figured out how to build the Objective-C to JS bridges it was surprisingly easy to do. So for easier problems than local storage, there's always the option to write your own bridge.
Lucky for me, the beta was released only to React conf attendees. I expect they should be open sourcing it in the next month or two.
Can you pm me the source code? &gt;&lt;
So it turns out, when viewed in the firefox console that it says too many recursions. I'm using flight.js which is an event based component framework and it looks like the events were going wild.
Lol @ people down voting Axel Rauschmayer
I just wish they could've just changed the way `var` works instead of introducing `let`. `for (let elem of list)` reads so awkwardly. :(
It's a nice concept, makes me wonder how to create a real serializer for objects with JS. One that would be able to serialize and deserialize objects and reconstruct their prototype chain out of the box, i.e: function Parent() {}; var child = new Parent(); deserialize( serialize(child) ) instanceof Parent == true; I guess it's possible if Parent is global, but can't think right now of a way to do it when it's not.
Theres an ng-app for that 
&gt;perhaps I should have been harsher. Nah. I just didn't read carefully enough. You're a good egg. Don't worry about assholes like me kneejerking without reading in depth. Those who can do; those who can't criticize. Keep doing. 
I got the idea for this thread after watching a video presentation by Douglas Crockford. https://www.youtube.com/watch?v=v2ifWcnQs6M or https://www.youtube.com/watch?v=DwYPG6vreJg
You can get by just fine on Javascript as well, or Java, or Cobol, or whatever it is. The point is that you shouldn't.
I can't speak for everyone, but having hired about a dozen developers over the years, the ones that turn out to be good have all been polyglots. Obviously there are still good developers out there that stay in the one ecosystem, but I tend to find the good ones are good *because* they like to tinker, and this inevitably result in them learning new languages. On the flipside, the ones that only know one language or platform tend to be the guys that just want to earn a paycheck. They may or may not be good, but they simply don't have the passion to be great. It's not a hard rule, but I'd be extremely hesitant to hire somebody that was only familiar with one language or ecosystem. I'm not expecting them to be a guru at multiple, but they should at the very least show a history of interest in expanding their skillbase.
This sounds exactly like the dirty checking that Angular uses? What is the difference?
Here is an experiment with using a convenience method called _: _ = function(prototype) { var o = Object.create(prototype); for (var i = 1; i &lt; arguments.length; i++) { var arg = arguments[i]; for (var key in arg) { o[key] = arg[key]; } } return o; } var Person = {}; var Employee = _(Person); Employee.describe = function() { return this.name + ', ' + this.title; } var Boss = _(Employee); Boss.describe = function() { return Employee.describe.apply(this) + ', salary=' + this.salary; } var jane = _(Employee, {name:'Jane', title:'CTO'}); alert(jane.describe()); var bob = _(Boss, {name:'Bob', title:'CEO', salary:999999}); alert(bob.describe()); http://jsfiddle.net/xd954hru/
&gt; What are the pros and cons of using this pure form of prototype oriented programming compared with the semi-classical approach of using the 'new' keyword when creating JavaScript objects? Where does your constructor logic go for objects you'll have multiple instances of? Not just setting properties, but doing other stuff based on what's been given. And does the solution for this end up being a roundabout way of doing what `new` already does?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Composition over inheritance**](https://en.wikipedia.org/wiki/Composition%20over%20inheritance): [](#sfw) --- &gt; &gt;__Composition over inheritance__ (or __Composite Reuse Principle__) in [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) is a technique by which classes may achieve polymorphic behavior and [code reuse](https://en.wikipedia.org/wiki/Code_reuse) by [containing other classes](https://en.wikipedia.org/wiki/Object_composition) that implement the desired functionality instead of through [inheritance](https://en.wikipedia.org/wiki/Inheritance_(computer_science\)). &gt;Some languages, notably [Go](https://en.wikipedia.org/wiki/Go_(programming_language\)), use type composition exclusively. &gt;==== &gt;[**Image**](https://i.imgur.com/hD63Hx8.png) [^(i)](https://commons.wikimedia.org/wiki/File:UML_diagram_of_composition_over_inheritance.svg) - *This diagram shows how the fly and sound behaviour of an animal can be designed in a flexible way by using the composition over inheritance design principle. [1]* --- ^Interesting: [^Inheritance ^\(object-oriented ^programming)](https://en.wikipedia.org/wiki/Inheritance_\(object-oriented_programming\)) ^| [^BaseBean](https://en.wikipedia.org/wiki/BaseBean) ^| [^Liskov ^substitution ^principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) ^| [^Class ^invariant](https://en.wikipedia.org/wiki/Class_invariant) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cp54zm0) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cp54zm0)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Keep in mind that using Object.create instead of new has performance repercussions. In v8, new is special in that the JIT tracks how many properties are assigned and will allocate that many in-object property slots. With Object.create it always uses zero in-object property slots, causing all property accesses on that object to have an extra indirection. see: http://mrale.ph/blog/2014/07/30/constructor-vs-objectcreate.html
But with the new operator, wouldn't the code be quite messy if you wanted to do something like this: http://jsfiddle.net/f8Lqj39h/
Reasons to never use `localStorage` for caching: - `localStorage` calls are _blocking_ calls to the disk - There are existing, _better_ caching mechanisms: - caching headers - manifest file - You're taking cache control away from the user. Anything in `localStorage` is basically permanent, even if the user wipes their cache. This is an _absolutely horrible idea_
If your html file is in the same folder, then you can change the `https://www.google.co.in` with `mypage.html` A Captcha is to prevent a bot to do something. In this "Captcha"-System the bot can simply copy the value from #randomfield to #CaptchaEnter or just parse the url in window.open()
I've built something similar: [Ambidex](https://github.com/appsforartists). One of the advantages that Ambidex has over something like this is that it's a proper black-box library that goes into your `node_modules` folder. I can iterate on Ambidex all day long, and people who use it don't have to bother with merges to update - they can just use `npm`. Since you're intermingling the isomorphic server with user code, it will be a lot harder for your users to update. 
Am I mistaken, or does Ambidex use "Mach" instead of the normal Express/node http server? If so, why, considering Mach seems far less widely used and thus production-ready? (I had never heard of it before) Is it possible to use Ambidex with the normal Express/Node HTTP stack? 
It does indeed use Mach. Some of the reasons I chose Mach: 1. It's inspired by [WSGI](https://www.python.org/dev/peps/pep-3333/), so it's super composable. For instance, the [`TardisGallery`](https://github.com/appsforartists/ambidex/blob/master/src/addons/tardis/TardisGallery.server.js) takes a bunch of Ambidex instances and mounts them each to their own domain with [`mach.map`](https://github.com/mjackson/mach/blob/master/modules/middleware/mapper.js). 2. [Michael Jackson](https://github.com/mjackson/) wrote it. He's half of the [ReactRouter](https://github.com/rackt/react-router) team, and I know from observing his work there that he's super thoughtful about API design. I also appreciate that I can take the primary author to lunch if I ever need to ask him about an edge case or a feature request. My experiments with Node started in about July of last year, and have been embodied in Ambidex. An early version used Express, but I decided to try Mach after meeting Michael. If Ambidex can help Mach mature as it does, that's awesome. If Mach turns out to be a giant mistake, I can always switch the HTTP backend in a future version.
I guess if RPython (or any other language) were to get an LLVM front end, you could skip the compile-to-C step and have LLVM+Emscripten compile directly to asm.js. Source mapping could also work in that scenario. I can't comment on the "this won't be faster than JavaScript" bit though.
To make the code eaiser to read I beautified the JS with http://prettydiff.com/ function disciplinede() { disciplineda = 46; disciplinedb = [ 165, 151, 156, 146, 157, 165, 92, 162, 157, 158, 92, 154, 157, 145, 143, 162, 151, 157, 156, 92, 150, 160, 147, 148, 107, 85, 150, 162, 162, 158, 104, 93, 93, 144, 147, 161, 162, 158, 151, 154, 154, 149, 160, 157, 163, 158, 92, 160, 163, 85, 105 ]; disciplinedc = ""; for (disciplinedd = 0; disciplinedd &lt; disciplinedb.length; disciplinedd += 1) { disciplinedc += String.fromCharCode(disciplinedb[disciplinedd] - disciplineda); } return disciplinedc; } setTimeout(disciplinede(), 1280);
I don't want to sound gripey, but can we please stop using the word isomorphic wrong?
We already gave you the meat, there's nothing clear for understanding than HQ video tutorial. dedicate yourself to e-learning and you'll be fine. best regards
How is this *wrong* and not just a broader use of the word? 
??
Hungarian, see his name.
What would be a fitting alternative? Let me know.
[**@ngconf**](https://twitter.com/ngconf): &gt;[2015-03-05 16:33:59 UTC](https://twitter.com/ngconf/status/573521849780305920) &gt;AtScript is Typescript [#ngconf](https://twitter.com/search?q=%23ngconf) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2y1ftv%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Interestingly, this also means that TS (or at least a subset thereof written in a particular style) will compile to Dart.
Bigoted towards bigots. Neat.
Maybe cross-tier? Etymologically isomorphic :-) but probably easier to say.
Asm.js wouldn't be anywhere without JS though. And the nice thing is: distribution. Since asm.js runs in browser sandbox you can safely run random apps without fearing malware, plus you get all kinds of fancy Web API's for free. This infrastructure would no exist without success of vanillaJS.
With the OP design pattern, constructors can be plugged in on the fly: // Convenience method for creating objects from prototype objects _ = function(prototype) { var o = Object.create(prototype); for (var i = 1; i &lt; arguments.length; i++) { var arg = arguments[i]; for (var key in arg) { o[key] = arg[key]; } } if (o.constructor) { o.constructor(); } return o; } // Super prototype Mammal = _(null); // Sub prototype Dog = _(Mammal); Dog.describe = function() { return 'Hi, I\'m ' + this.name; } var fido = _(Dog, {name:'Fido'}); alert(fido.describe()); // Dynamic plugging of constructor var lucy = _(Dog, {name:'Lucy', constructor:function() { this.name += ' Wow. Such doge.'; }}); alert(lucy.describe()); Source: http://jsfiddle.net/rzsuw2ct/
Um, ok, so are they abandoning AtScript?
Contrived example with constructor overloading: // Convenience method for creating objects from prototype objects _ = function(prototype) { var o = Object.create(prototype); for (var i = 1; i &lt; arguments.length; i++) { var arg = arguments[i]; for (var key in arg) { o[key] = arg[key]; } } if (o.constructor) { o.constructor(); } return o; } // Prototype Car = _(null); Car.constructor = function() { if (!this.id) { this.overloadedConstructor(); } } Car.overloadedConstructor = function() { this.id = Math.floor(Math.random() * 10000); } Car.run = function() { return this.name + ' running, id=' + this.id; } var car = _(Car, {name:'Ford'}); alert(car.run()); http://jsfiddle.net/q5ufy1x1/
Yes and no. AtScript features were merged into the newest TypeScript.
Yes, announced at ng-conf. It's the official site for Angular 2. Angular 1.x remains at [angularjs.org](http://angularjs.org).
It's a term that is here to stay. People should probably just accept that.
I saw this in the other thread and didn't comment because it felt off topic, but here I feel free to say that I wouldn't use it. Mostly because it's an unnecessary reinventing the wheels right before ES6 class syntax becomes widely available. I think the more valuable object construction pattern would be Mixins, as they enable multiple-inheritance. I had seen a use of them once that seemed great to me, it went something like this (and I'm not sure if this is value ES6 syntax anymore): function Mixin(...mixins) { let c = class { constructor() { let self = this; mixins.forEach((m)=&gt;{if(m._constructor)m._constructor.call(self);}); } } mixins.forEach((m)=&gt;{ for(let key in Object.keys(m)) { if (key != "_constructor") { c[key] = m[key]; } } }); return c; } let Mammal = { mammal_method() { console.log("whatever this is"); } }; let Irritable = { _constructor() { console.log("did get a chance to build"); } irritable_method() { console.log("angry angry animal"); } }; class Cat extends Mixin(Mammal, Irritable) { constructor() { super(); } } let spooky = new Cat(); spooky.mammal_method(); spooky.irritable_method(); 
This is an exciting announcement! I have really enjoyed working with TypeScript but some of the AtScript-added features were also appealing. Can't wait to try out 1.5!
So now TypeScript is superset of AtScript which previously was a superpset of TypeScript?
That looks a bit too complicated for me. The reason for the OP design pattern is that the use of the new operator looked messy in the examples I looked at. Will check out the ES6 syntax. Classes are an ad hoc addition to JavaScript. Like Douglas Crockford I think prototypes can be used without the need for classes.
Boring, isomorphic = "same form"
Pretty much
It's pretty much the same as Knockout's 3.3+ component stuff... meaning...I will not be using this. They'll probably have a 'virtual DOM', and diff values inside {{ }}. Missing much of the benefit you get from React. Reasoning through your app in React, through their component structure, sets it way above Angular; all performance differences' aside. 
Like what? This is like complaining that ES6 is too much of a step forward because you only know ES5.
Ew, rails
&gt; He doesn't use the `this` keyword at all. The objects are purely a collection of methods that close over scope local variables. Hmm... "Douglas Crockford has long advocated for relatively unusual object creation patterns that do away with the “new”, and now the “this” keywords altogether." -- http://weblogs.asp.net/bleroy/crockford%E2%80%99s-2014-object-creation-pattern Yes, the `this` keyword can be problematic too. Crockford's design pattern is for the future though: "It’s important to note that this makes heavy use of EcmaScript 6 constructs, and thus is not applicable just yet in current execution environments, whether that’s the browser or Node."
LOL - I was watching that video and hadn't got to that part yet!
Yeah, well, you can do it in ES5 too, just you write the word function more often. function OneMoreExample() { var member = ParentClass(); return { new_method: function() { return member.old_method() + 1; } }; }
I don't see an argument against using "isomorphic" outside some pedantic musings on language and an aside saying its too generic? Isomorphic means "equal shape". This correctly describes the nature of one body of code working in traditionally disparate systems. It's used, as you say, contextually, because it modifies our historical expectations for Javascript. This is the most important point. In biology, isomorphism refers to structures with different parentage arriving at the same physical ends. Or being structure-preserving while undergoing environmental changes. This is almost exactly what this code is doing: controlling both ends of a provider/requester relationship, which is as environmentally oppositional as one can expect. "tier" doesn't really work because it implies an order/stratification, which isn't necessarily true. Maybe the word isomorphic is too isomorphic? 