&gt;Unfortunately, the documentation for this library is pretty hard to read - too broken down into too many little sections. Completely agree! That actually pushed me away the first time I found the library. Once I actually started using it I noticed that the documentation is actually quite well structured. Still agree that it's annoying to have to click around different pages. Makes searching also a bit tricky. To answer your question, the 2 sub-apps would communicate for instance with [global actions](https://github.com/ioof-holdings/redux-subspace/blob/master/docs/advanced/ScopingActions.md#global-actions). If those two apps require a shared piece of data, you could store that data on a top-level reducer like you normally would and use the [mapState prop](https://github.com/ioof-holdings/redux-subspace/blob/master/docs/advanced/ScopingActions.md#global-actions) for passing it to your sub-apps. Using 2 nested redux stores [(like in redux documentation)](http://redux.js.org/docs/recipes/IsolatingSubapps.html) works fine as long as you don't have to dispatch "global" actions from you sub-app's action creators. Lets say you have a sub-app called "TodoCreator" that includes a form component for creating a new todo (**TodoCreator/TodoCreator.js**) and the logic for saving the created todo to your API (**TodoCreator/TodoCreatorActions.js**, **TodoCreator/TodoCreatorReducer.js**). You'd also want to store all created todos to `{todos: []}` list in your app's top level store. After the http-request succeeds in the TodoCreatorActions.js you have pretty much no way of dispatching the information back to the top level store 'cause now we are in the context of you sub-app's nested store. I actually [tried doing this](https://github.com/rikukissa/redux-isolated-apps/tree/substores/src) first with nested stores, but it got a bit hairy. 
Abstract: &gt; Be a normal functioning being and at least somewhat interested in the industry you work in Not sure what to take away from this article beside the above. 
I don't know.
It wasn't helpful since a lot of it was just common sense 
&gt; Learn JavaScript Talks about frameworks and libraries the whole time. 
Npm 3 isn't nested 
[removed]
Think, for a moment, about what would happen if you were allowed to assign numbers as variable names. What would happen if you tried "5 * 5"(expecting to get 25)?
Hmmmm you will memories APIs over time after repeated usage but you shouldn't go out of your way to learn them. You will also memories patterns over time. Every problem is bespoke and different. Memorising a finite amount of things will probably make you use bad or non performant solutions You should or will always have the internet at your disposal. This means API documentation. Blogs and posts about programming patterns etc etc you should not need to learn things off my heart 
Try to share with us your setup, any relevant code, the errors that might show up in the console etc. Nobody can help you if you don't provide them with enough information to help.
When?
I'm lost without my library of text snippets. Saves tons of time and less chance of errors.
All of them.
[removed]
And I was on your side. Maybe he's right. Maybe mods that are too busy shouldn't be mods.
This is in Opera. http://prntscr.com/ge04bz This is in Chrome. http://prntscr.com/ge04wa My setup is the default create-react-app . Just the app.js is import React, { Component } from 'react'; import logo from './logo.svg'; import './App.css'; import {createStore,combineReducers,applyMiddleware} from 'redux' import { createLogger } from 'redux-logger' import thunk from 'redux-thunk' import axios from 'axios' import promise from "redux-promise-middleware" class App extends Component { render(){ console.log("it works eh") const initialState = { fetching: false, fetched: false, users: [], error: null } const reducer = ((state=initialState,action)=&gt;{ switch(action.type){ case "FETCH_USERS_PENDING":{ return {...state,fetching:true} break } case "FETCH_USERS_REJECTED":{ return {...state, fetching:false,error: action.payload} break } case "RECEIVE_USERS_FULFILLED":{ return {...state,fetching:false, fetched: true, users: action.payload} break } } return state }) const middleware = applyMiddleware(thunk,promise(),createLogger()) const store = createStore(reducer,middleware) store.dispatch({type: "FETCH_USERS" ,payload:axios.get("http://rest.learncode.academy/api/wstern/users")}) return ( &lt;div className="App"&gt; &lt;/div&gt; ); } }`` export default App; 
No. All your memorization will come from usage. 
Start with Truth tables, and a good internet connection. Learn some google fu, some stackoverflow searches, and how to use a debugger (especially the browser-based built-in debuggers) and you should be good to go.
What I would try to do is run opera in incognito mode (so that no extensions or anything else would be active) and try to open the page. Maybe there is some extension that is causing the issue to load the page...
Your error messages in Opera appear to be from the Lastpass extension. Try disabling that?
Thanks from now on I will just run it in incongnito mode.
I'm betting on Go. It was designed to replace C and is a lot more friendly than Rust.
I'm not saying JavaScript will die, just that we are close to its peak now.
Nice! I already use Jest for testing Vue apps but I was completely unaware of the snapshot feature
Does it work in other browsers? 
I use Rescue Time. It keeps track of what programs you're using and for how long to give you an overview of your daily activities.
Not sure if it's default or I did it, but I can do 'mdn switch' in my chrome address bar and it will search mdn for the term switch for me. I don't memorize, I use. If you memorize you may end up memorizing shit you don't need. The stuff you use a lot will burn in and the rest you can search for. I know about 12 array methods because I use them all the time, and the others I look up on mdn
If they didn't know any of these things, I would not feel comfortable hiring them to write javascript. I'd probably give a pass if they botched #2, but 1,3,4,5 is required knowledge IMHO.
The brief time between 1995 and 1996 before Microsoft adopted it for JSCRIPT. 
Really good idea to have one. How do you have organized the snippet library? 
I'm not sure that analogy applies to open source very well.
Yes it does. The problem is answered now.
That's indeed one of the coolest things of Jest :D
IMHO opinion /r/javascript should be a place about the language (news, discussions, etc) even if that means less activity in the sub. Help posts, tutorials, etc, should go to /r/learnjavascript . It's true that some help posts might be interesting to even seasoned pros, but since it's very difficult to discern which ones I'd say it's much easier to simply move those related to learning there. My 2 cents.
Why would they send funds to each other? White text on a busy photo is really obnoxious. 
&gt; ? I just realized what codyfo meant. But the dude that wrote the blogpost never said that Javascript were, he said NodeJS were, which is true for when it began
Sorry, we'll change that when we get the chance. Anyway, using RadJav, developers can mine coins or send funds. Sending or receiving funds is MUCH cheaper using RadJav since it has its own built-in cryptocurrency. PayPal and other services normally take around 2-3% of whatever the total is. Lastly, RadJav gives developers a new way to make money. Developers can mine XRJ coins in the background, with a minimal performance hit.
So it’s an IDE that mines coins in the background? And some of those coins go back to you guys? Sounds like a bot net to me. 
&gt; Well he's right. With the growth in popularity there are also higher demands. It sounds like a great number of these demands are coming from people who dont understand why it is successful in the first place. "This whole 'the wheel' has really caught on with carts, chariots, and wagons all using it. However, we are nearing peak wheel, and 'the square' is poised for a big comeback. To survive, the wheel is going to need to have a lot more corners "
Lol, no, it's not a bot net. Think of it as a new JavaScript programming language. You can create desktop and HTML5 apps using the same code with it. Then in the app you create, you can mine coins in the background, with the user's permission of course. We don't get any of the mined coins, whatever you mine is yours.
I've been pushing hard at work for use of things like create react app. It's saved us a ton of time already. The cool (and hard) part is, if you just follow their guidelines, and don't eject, you won't have to keep up on build system stuff at all. 
Yep, feel exactly the same.
The doc says it processes the items 'maximum of limit async operations at a time.' So I am expecting 2 items at the time. But it only does 2 only. If async only process up to the limit.. that's not useful if the items are picked at random?
&gt; That said, I never actually liked dynamically typed languages. I don't think they scale well, and I can never trust them as much as I can trust statically typed languages. No, unit tests are not a replacement, they solve a completely different problem. &gt; Why not use TypeScript then?
Well that could be almost anything...
&gt; You can create desktop and HTML5 apps using the same code with it. Then in the app you create, you can mine coins in the background, with the user's permission of course. That strikes me as rather bizarre. What's the reason for doing it this way, as opposed to just making a library I could include in either RadJav, Rhino or Node? It doesn't strike me as the sort of thing you'd normally include in the run-time environment, just like how you wouldn't include a water physics engine or chess AI.
We're trying to create something that developers and end-users can install that's similar to that of the Java Virtual Machine. The goal is to give developers as many tools as possible to create what they want quickly and effortlessly. Rather than having to hunt down additional libraries or write additional code. Right now to run a RadJav application on a desktop machine, all you have to do is double-click on it.
~~Is the syntax where trailing comma is allowed, is part of ES6 specs and not in earlier versions?~~ Never mind that. I just found out that it's introduced in ES5.1. Gee... that means that after all this time, those previous browser versions aren't fully conform to ES5.1 yet.
I understand, but how does the block-chain play into that? It seems unrelated to having an easily accessible standalone virtual machine that you can fire up by a simple double-click.
&gt; "Stop hiring cis white men forever -&gt; problems with sexism solved" Oh dear god.. lets fight sexism with sexism..
Jesus christ imagine the facepalming of the serious and mature governance members have to go through every meeting. How much do you need to love your project to be able to deal with that.
IBM is left wondering what the unprofessional baby bullshit minefiled they got themselves into.
It's another tool for developers to use. It gives them another way to make money, such as mining in the background. The next version of the blockchain will allow developers to create public and private smart contracts. It'll also allow developers to create their own coins. In the future, developers will be able to submit their apps to a decentralized data center where their apps can execute.
This whole thing reminds me a lot of that Evergreen College SJW meltdown.
From looking at your github repo this looks more like a framework than a `JavaScript runtime environment`. Also, I don't like the coding style with massive indentations specifically the second last example on [this](https://github.com/HigherEdgeSoftware/RadJav/wiki/Use-JSON-to-design-a-GUI-application) page. It's difficult to read.
You never ran the callback passed in. It doesn't know that you are done work until you do so.
You gotta give, at least some input output examples, if not a description of what exactly it is you want.
We should file a code of conduct complaint at NPM: https://www.npmjs.com/policies/conduct I'm pretty sure this person is in violation of many points in the [friendly-harassment-free-space](https://www.npmjs.com/policies/conduct#friendly-harassment-free-space) section. Her behaviour on Twitter and Reddit is covered, directly from this clause and from identifiying as NPM personel: &gt; This policy covers the usage of the npm registry, as well as the npm website, npm related events, and any other services offered by or on behalf of npm, Inc. (collectively, the "Service"). It also applies to behavior in the context of the npm Open Source project communities, including but not limited to public GitHub repositories, IRC channels, social media, mailing lists, and public events. 
Hand waving nonsense. "It's a problem all over the place", while maybe true, is moot in the context of this conversation. The most vocal people in this debate, particularly the insensitive and harassing ones, happen to be the people that are expressing their gender preferences. One of the key people behind this is one of the most outspoken sexists in the entire community. She just happens to be supportive of the gay/non-binary community so it's deemed ok. If *anyone* should be removed from the having a voice in the community it's her. Fortunately she removed herself, which was an unintentional but welcome kindness.
Classifying RadJav in a way that lots of people can easily understand is difficult. It's both a framework and a RTE, especially on desktop machines. There's lots of core JS functions that are missing that still need to be added for the desktop version. I agree, we do need to change the indentation on that page. It's out of hand. We'll change that as well as soon as we can.
Except no one on the committee did that. Besides, your gender identity has no fucking business being in a professional work place. I am not going to use invented words to describe you. If you identify as a she, that's what I'll call you. If you identify as a he, that's what I'll call you. If you identify as a toaster, I'll simply avoid pronouns and think you probably need to talk to someone.
First build an array that you can fill with whatever you want (item names in this case): var legendaryItems = new Array(); or var legendaryItems = []; or just var legendaryItems = ["Tome of Arad'thul", "Orbs of the First Dragon", "Shield of the Black Iron Knight", "Spear of Vlad, the Vampire King", "Dagger of the Last Black Blade", "Bow of the First Huntress", "Ring of the High King", "Axe of the Northern Gods", "Axe of the Southern Gods", "Staff of the First Pope", "Staff of the Corrupted Angel"]; Now generate a number randomly that is between 0 and the length of the array: var randomNumber = Math.floor(Math.random() * legendaryItems.length); Then access the n-th part within the array: legendaryItems[randomNumber]; // will automatically log into console since it's not assigned to a variable And then shorten it since you don't need to define a second variable here unless you need exactly this random number later again: legendaryItems[Math.floor(Math.random() * legendaryItems.length)];
This can be done easily already with a library like Immutable (as you noted - what's the value of lodash comparatively?); https://facebook.github.io/immutable-js/docs/#/Map/setIn (state, action) =&gt; { switch(action.type) { case 'someAction': // state would be a slice that contains an immutable map return state.setIn(['someKey', 'nextNestedKey', 'anotherNestedKey'], 'hello world') case default: return state } } Also it's good to note that redux's docs in general indicate that a deeply nested tree structure is a flawed design (for both performance and complexity issues): http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html.
"Ayo girl, you wan' sum' fuck?" *manspreads*
&gt; right now, google, amazon and apple have all the money, but that is no guarantee etc etc. This is Revolution Bias. Nobody has any idea what's going to happen, but the future always favors the status quo.
What's your OS? I made one for Mac: https://qotoqot.com/qbserve/
&gt; ISO/IEC 16262 was prepared by Ecma International (as ECMA-262) and was adopted, under a special “fast- track procedure”, by Joint Technical Committee ISO/IEC JTC 1, Information technology, in parallel with its approval by national bodies of ISO and IEC. They "align", but ISO only updates its standard every 5 years, so the 2011 version is (as you can imagine) very out of date (the 2016 version is still under review IIRC). As I understand it, when they were making this happen, there was some discussion about some potentially ambiguous phrasing in the document. Once these were corrected to the satisfaction of everyone, ECMA released version 5.1 and ISO copy/pasted that as their standard. 
Google tried to introduce another language alternative with Dart. It's an ECMA standard just like JS, but it was rejected by developers.
Context please. Where did you get it from, and what for.
I'll copy my comment from the article here for visibility. First, that deeply nested update logic could be simplified just a bit by caching the lookup items at each level rather than writing the entire lookup chain each time. It would add a few more lines of code, but the lines for constructing the return structure would be easier to read. Second, per other comments, we do recommend trying to normalize your data so that it isn’t deeply nested like this. Third, using “reducer composition” and delegating the work is also an option for simplifying the process. Finally, there are indeed [dozens of existing immutable update utility libraries out there](https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities) besides `lodash/fp`, with a wide variety of APIs to choose from.
People I often use this sub for help. I am sorry . From now on I will go to /r/learnjavascript .
Hey @nickgcattaneo, As said in the article, I am not a big fan of using Immutable in the store, because you then have to deal at some point with the conversion 
prototypes used well are awesome. but you do have to keep your wits about you. very easy to hit a tricky reference/this issue and just decide to plunk the property/method into the constructor and losing the benefits. one fave of mine is to put a collection of all the objects created from the constructor on a prototype property. this gives me a direct reference to all related objects, how many have been generated, etc. it does mean i have to clean up carefully, but easy enough to have a destroy method in the prototype too.
A .1
Can you share a screenshot plz? I recommend add a screenshot or two to the readme.
OK, thanks. What about the difference between ES5 and ES5.1?
Ah! Thanks, that's exactly what I was missing. 
If you've ever used anything in the React ecosystem ReactNative is will be an easy fit. There's been some drama recently in regards the React licensing, but if it's for a personal project it shouldn't be something to worry about. I can't speak too much on the other options, but ReactNative is pretty easy to run right out of the gate. They even have a CLI that sets up all the scaffolding for you so all you need to worry about is your application logic. I don't know if you will have issues getting a production iOS app though since I'm under the impression you will eventually need Xcode. (I think this is regardless of what option you go with).
Just re-phrasing and clarifying of things to make ISO happy. Zero functional changes. Once you've made the changes, you have to retroactively add them into your own system. You can't do a "second printing" with technical specs, so they bumped up a point and re-released. You can find/download the 5.0 spec and diff it against the 5.1 spec if you're really interested. I suspect we'll see a similar thing happen with either ES6 or ES7 when they finish their review.
I'm assuming that you are planning to do some asynchronous processes. If you are just doing synchronous things you should just use the native Array constructs.
Proving my point.
You forgot to complain about all of the new frameworks and libraries that we get to use for free. 
I was turned off from using Immutable in the store 1) because I like the direct serializability of the store with plain JS and 2) because the suggestion to use Immutable is followed by a list of pitfalls in usage that I really don't feel like dealing with. Edit: I should also note that "use Immutable" is more of an architectural decision whereas "use lodash" is an additional library choice. In some cases, lodash might already be in the stack. 
`lodash/fp` and `ramda` are still basically the same, right?
JS is high-leve language, which means implementing (simulating) other high-level language with slightly different design choices will be costly and resulting simulation won't be very efficient or complete. Open source does not means that some language or library will appear and be practically useful just because it is theoretically possible. From what I have seen, all (more or less) successful alternatives to Javascript are just different flavours of ECMAScript, which is not exactly worthy difference for me.
Hi /u/goodbyemango, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I am not familiar with any of the details of this particular conflict. It is possible that these grievances have been invented for some unknown reason. If you have a link to some of the transcripts that demonstrate this, I would be happy to read them. However, I think this is unlikely. While it is a convenient narrative that anyone who complains is just looking for attention, in my experience people who take dramatic steps (like quitting the steering committee of a major open source project) rarely do so without a substantive cause. That's why I have been arguing against the dismissive hand waving getting upvoted all over this thread. From everything written in this article, it seems likely that Node.js has some real culture and governance issues. If anyone has some unpublished details indicating a third of their steering committee resigned for invented reasons, they have not presented it. I can only assume the upvotes are because this idea fits comfortably inside most /r/javascript readers' preconceived notions.
Are you talking about back-end or front-end JS? The article is about Node.JS and there are plenty of alternatives for hosting a back-end application.
Developers hate him!
Wasn't the original question about semantics?
Thanks!
For sure. For me the integration with immutable is pretty clean though; when passsing initial state during creatstore (or anywhere you want to inject a slice of state), you just wrap the object with Immutable.Map() and done. To each their own though I was just curious if there was some significant difference other than just preferences.
Were I doing an interview, and a candidate said that "$.get" is an API call, that would be a satisfactory answer, because "$.get" is an API call. It doesn't get more accurate to say it's an "application programming interface call", that's a more verbose way of saying the same thing. If you need to be specific, you can say it's a GET call to a restful API, but it's still an API call.
Yea I would never advocate using two data manipulation libraries; so that makes sense to use lodash if it's already a dependency. What pitfalls are you finding with lodash though? It's pretty good about offering both standard object/array wrapper methods (map, reduce, keys, etc) while also providing custom methods (merge, set, get, etc).
We use a custom "createReducer" function that works really nice for us. I'm not sure if I can paste it in here because it might count as "our secret company code" blah blah. But it basically simplifies things. 
https://github.com/MohammadHasham/Redux-YouOwn
React Native is a good option. Another one is Weex, which is Vue's alternative to React Native - https://weex.apache.org/
&gt; ...allows for private state... In addition to factory functions consuming an order of magnitude more memory, the private state they offer is actually *too* private. Methods need to be able to access the privates of all objects of its *type*. Imagine, for example, a hypothetical BigInteger library... class BigInteger { constructor() { this._numbers = []; } plusEquals(otherBigNumber) { otherBigNumber._numbers.forEach((value, index) =&gt; { this._numbers[index] += value; // ...handle overflow }); } } Notice that `plusEquals` needed access to *both* `this._numbers` *and* `otherBigNumber._numbers`. If we had implemented this as a factory function, that wouldn't have been possible.
From what I understand netflix uses node as a client data aggregation layer, eg [falcor](https://netflix.github.io/falcor/) while much of their "heavy lifting" is done in Java. Also, some organizations might use node to do server side rendering of their client application, but their API may remain in Traditional Backend Language X. In that case it might be accurate to say that node is used in the frontend rather than the backend although the code is not ran on the client.
I was trying to do rate limiting on about 200k items with request... but now I am hitting out of memory errors.. sigh.
I've used it for rate limiting quite a lot. I'm assuming that you are rate limiting outbound? Ie you are trying to scrape something and don't want to hammer the server? I would still take it in chunks rather than a full 200k list. You can then update your db as each complete
I figured the reality of the situation was something like that, but the way the author explained it in the actual article was lacking detail and seemed wrong when taken at face value. It seems like a weak point to make for an article with such a dramatic title. JavaScript rendering views while Java does the "heavy lifting" doesn't really paint a picture of JavaScript taking over the world. 
Isn't a blockchain expensive for a "data center"? I like many aspects of the concept, but it seems like a radical throwback to the extjs style of programming while everything has shifted to a react/angular/vue model, I think this may hinder adoption, especially since it seems to target js developers, or maybe it has a different focus. I am for decentralized everything, so I wish the best.
thanks for the tips, very helpful. I have indeed dabbled a little bit in React, so that sounds like the best way to go about it. If getting an iOS version to compile proves to be too cumbersome I might as well leave that out for now, but it's good to know that the codebase leaves me that possibility for later. Thanks again.
Thank you very much for the response! Discord.js and Node.js are what I'm using. Where can I find that library? I might have missed it.
Thanks, that's the 2nd time ReactNative is being mentioned now so I think I'll give that a try.
I could do that ... or I could directly use a language that is statically typed, like Rust. Without the JavaScript overhead underneath.
It needs to shed the ugly bits, and there are a lot of them. See the "JavaScript vs. JavaScript: the good parts" meme. Also see for example the madness that is the == operator.
"A lot more friendly" in what way?
Hi, I'm the author of this article. When I wrote about value vs. reference, I meant to say that the reference is what's copied, as this is the only thing that's possible with JavaScript. I realize the confusion my wording might have caused and I've changed the article. Thanks for your input!
I'm the author of this article! Awesome to see that it's useful. Thanks for reading!
I realize the wording I used may have been confusing for those coming from other programming languages. I've changed the article to remove discussing "pass by reference" in those exact terms. Instead, I wrote that for objects, the reference is copied and passed. Thanks for reading!
That's great, I'm glad my nitpicks were helpful. I'll revisit the article and let you know if I have anything else to complain about. ;-) Keep up the good work!
That's a common way to do it. That doesn't mean it *has to* be like that.
What do you mean isn't a blockchain expensive for a data center? In terms of power consumption? The fees? This is exactly why we're reaching out to the community, because we want to work with you guys as to what the best approach here is. We believe we can create the best environment for developers to create native desktop apps and HTML5 apps using the same code. The question is, what is it that JS developers will prefer? We know there's a shift towards React/Angular/Vue. My question to the community is, is this shift because of the way they interact with data or is it the way that you can build your webapp using HTML? What are the best aspects of these frameworks? We do have something in the works for syncing a server and it's data with the RadJav app, however that won't be coming for several more months.
The pitfalls I was referring to were with Immutable.js, not with lodash. Specifically what scared me away from Immutable was this page of the Redux docs: http://redux.js.org/docs/recipes/UsingImmutableJS.html The trade offs noted there were significant enough for me to prefer enforcing shallow reducers and avoiding deep mutation issues altogether. Enforcing Flux Standard Actions helps a lot, as well. 
create-react-native app is straight forward, set up a project, start it, scan qrcode and you have the app running. I have xcode installed but i don't remember if it's really necessary, either way, it would be a click away.
Yup rate limiting outbound, except I am doing it for my own api so that I don't overwhelm my api end points. Yeah, I am trying to figure out how I can 'stream' the list of items from the db. I guess may be I just have to use a flat file.. 
Both actually. Node is tightly bound with cliend-side JS, at least in my expirience. SSR, code sharing, etc. I would be very surprised if you show me succesful project of considerable scale with Node on back-end and anything but JS on front-end.
All good thoughts here, I've been writing recently about normalization and one of the first steps was using nested data and seeing how much more difficult it was to operate on. Can you clarify what you mean by 'caching the lookup items at each level'? In this example do you mean things like the current manufacturer/model?
I wouldn't worry too much about streaming... keep it simple. Stick a Boolean field on each record/document as to whether it's been requested/processed or not. Then split it up into chunks of say 5000. Request x (5000) records at a time where processed: false. Send these requests through your async fn, when each completes mark processed: true and call the callback. When all of x records have been processed get another chunk of records. You will also want to put in some sort of error handling for records that fail and mark them in the db so they don't get re-picked up. 
Node has never had a Monopoly on the server though, JS has only really dominated the client side without major competition.
I mean a blockchain is for secure immutable data, representing value of some sort, it seems like most apps will not require this, so the paying miners(it seems like this is just to store, not access?) seems like it could be prohibitive, as far as power consumption, I guess that depends on the success of the system and associated difficulty increase, but has an influence on fees. As far as the trending frameworks, the main aspect is the presentation as a template as opposed to doing all in code
So, here's this one: https://github.com/whatadewitt/yfsapi It says it's not totally complete, so YMMV. Then there's https://github.com/jcreamer898/fantasy-sports but it was last updated about 3 years ago, and has an open issue about just plainly not working, so it's probably dead AND broken, either of which would be a big red flag reading "don't use". If the first doesn't have yet you need, and you consider trying the second only for it to fail, you'll need to go a bit more bare bones. You'd need an OAuth library for Node, and implement it yourself. You said you're a beginner. Implementing the OAuth yourself is almost certainly too large a project, and you'd get discouraged from programming. It's more than I'd want to do, and I'm not a beginner (though still not great). That being said, it is not impossible, especially if the OAuth libraries are really good, and you take the time to learn and avoid getting frustrated. Whatever you end up deciding to do, best of luck!
Laravel &amp; VueJs All About Laravel &amp;&amp; VueJs - The latest Articles , Q/A, Trends, Video, Jobs, Services, news, tutorials, plugins, and more. https://www.laravel-vuejs.com/ 
Another templating system?
They're very similar in terms of functionality (ha). I'd say Ramda's utility functions have some deeper cuts (use with, converge, and especially lift).
A buddy with a little more experience is looking into this as well, and it looks like Yahoo requires user consent in order to gain access to whatever you're requesting. We're thinking that a headless browser might address that ... maybe. You're right though, once I started trying to dig into this, I quickly realized that I was in over my head, so I'm trying to take it slow and not get discouraged. I really appreciate the help, thanks again!
Yeah, like this: const { color, model, manufacturer } = action.payload; const {manufacturers} = state; const prevManufacturer = manufacturers[manufacturer]; const {models} = prevManufacturer; const prevModel = models[model]; const prevOptions = prevModel.options; const {colors} = prevOptions; return { ...state, manufacturers : { ...manufacturers, [manufacturer] : { ...prevManufacturer, models : { ...prevModel, [model] : { ...model, options : { ...prevOptions, colors : { ...colors, [color] : true } } } } } } } Is that still hideously ugly and hard to read and write? Yes. But, at least the individual lines are shorter, and it might be a bit easier to make out. For point of comparison, here's what it might look like with reducer composition, where we have a reducer that knows how to update a single manufacturer: const { manufacturer } = action.payload; const {manufacturers} = state; const prevManufacturer = manufacturers[manufacturer]; return { ...state, manufacturers : { ...manufacturers, [manufacturer] : manufacturerReducer(prevManufacturer, action) } } All the complexity still has to happen, but in _this_ function that additional work is being abstracted away by the `manufacturerReducer` function, which could do the same thing internally with `models`, down to `options`, etc. I actually need to add a description of this "multiple/single" pattern to the Redux docs page on [Structuring Reducers - Beyond `combineReducers`](http://redux.js.org/docs/recipes/reducers/BeyondCombineReducers.html). (Also, I don't think I want to type the word "manufacturer" ever again.)
Your handler for ```ADD_NEW_AVAILABLE_COLOR_TO_CAR``` knows about the inner structure of both ```Manufacturer``` and ```Model```. Setters should be accessible under their respective scope and called from the reducer instead of directly mutating such a nested structure. Your code will be very hard to refactor if the responsibility for updating these objects is spread around the application. In my experience, you are making your code very hard to maintain with reducers like this. Why would you even nest your objects like that? I think flattening your structure and instead letting the domain objects have reference keys will make your structure much more flexible. Like letting all Model objects stay in a model array/object where they all have a manufacturerId instead referencing to the id of it's parent relation. However, given your domain model structure, you could do something like this: case ADD_NEW_AVAILABLE_COLOR_TO_CAR:{ const { color, modelId, manufacturerId } = action.payload const manufacturer = { ...state.manufacturer, [manufacturer.id]: Manufacturer.addModelColor(state.manufacturer[manufacturerId], modelId, color) } return { ...state, manufacturer } Manufacturer.js function addModelColor (manufacturer, modelId, color) { const models = { ...manufacturer.models[modelId], [modelId]: Model.addColor(manufacturer.models[modelId], color) } return { ...manufacturer, models } } Model.js function addColor (model, color) { const colors = { ...model.colors, [color]: true } return { ...model, colors } }
I feel like this is a non-problem with reducer composition.
Sorry and yea I meant with redux. And I agree with your points; I wouldn't use redux for scenarios where it doesn't make sense to just like those docs indicate.
Nifty and great greasemonkey! 
&gt; Giving a clear recommendation to use one technique over the other is difficult here. Really? Seems the clear recommendation would be to use either `new` or `Object.create` and not the third option that is an entire order of magnitude less efficient. What am I missing?
you're going to have a pretty tough time building something like this without a good understanding of JS (or DOM, i assume). i'm not sure if any frameworks will be able to simplify this problem down enough to "hit the ground running". even if you can simplify the UI creation (via React, Vue, etc), you'll realize that you still need those fundamentals. how much of your C# experience is webdev related? have you worked with jQuery? ajax?
More like meh.js (I'm joking because of title)
This is one of many reasons why most books etc recommend you use object literals for singletons and other place we only one or a few objects are created. 
there is also nativescript with angular.
None of what I have done has been webdev related, but I usually learn fairly quickly. I have actually written an app in C# that did something fairly similar to what I describe using XAML templates on a canvas getting data from a WCF service (which polled databases and received data over TCP connections). I can take a few months to do this new project and there is a fair bit of flexibility in what my design goals could be which why it is so hard to determine what direction to go. I could read up on some basic DOM manipulation but I believe I would learn those parts better in the process of building something. I've only learned C# by taking large projects and picking apart the pieces so I was hoping to find a project where I could do the same in the JS world, but I have not found what I am looking for yet. I know this is a tall order especially with such ambiguous goals... Thanks for responding though.
Nice article on converting to TS. Not sure I agree with the conclusion of it being a no brainer. Didn't seem to be enough benefits for TS over JS for me, at least not listed. I find one of the main draws of modern js being that it's fairly accessible and not overly verbose, unless you make it so. One key point has got to be that js will likely have longevity because of browser integration which can't be said for typescript. Guess like with most language comparisons, it's down to personal preference.
This doesn't compare how using binds compares as well and unfortunately the full benchmark doesn't appear to be available? EDIT: https://github.com/marekpiechut/perf-js-closure-memory is the benchmark EDIT2: bind seems to perform similarly to closures, even when the function definition itself is only created once.
Your Welcome, I hope it helps.
&gt; The simplest case is that all routes fall back to the site.com/index.html. That means that every request to your domain (site.com/some/page/) has a response of the root index.html file. Please note that some ways are better at doing this than others. Some people like to give /index.html as the 404 page for the entire website, but this messes up 404 for pretty much anything, including completely unrelated things like missing images. It's better to maintain a whitelist in the webserver config and do server-side redirects to /index.html explicitly, only for the routes you mean to, letting 404 happen naturally for things that are really missing. Server-side redirects are "silent" redirects that serve content from /index.html (or any file you want) but don't change the route and don't give the client any indication of what they did. This can be done with mod_rewrite or with mod_alias on Apache, and I think nginx can also do that.
My point is that if the code and the development was important, the "pronoun" bit would never be mentioned. There's plenty of accounts on github where you would never suspect the owner of having tits because they want contributors to focus on the project, not how they feel. 
I believe the expo app is available for android and iOS. I think you have to "eject" from CRNA for native builds... But it isn't a mega disadvantage because you can just use the ejection procedure as a build pipeline (CRNA eject, then use react-native to build for os). Then revert back to expo for lightning fast development.
TypeScript is invaluable when the time comes to refactor. Squiggles-oriented programming.
Good luck, you're gonna need it. 
how i would start out: build out an API in JavaScript with some fundamental methods needed that create and modify the data structures as necessary (addWidget, deleteWidget, moveWidget, configWidget, etc..). then implement save/load methods that can encode/decode that data structure to/from JSON. all of this will be in JS with no DOM or UI. afterwards, pick a view layer that'll save you some DOM mutation headaches (React works, but i'd recommend using one that doesnt require any tooling or setup [1] ;) have the view layer render out your data structure. in the beginning, forget about drag/drop or dynamic re-layout or re-positioning/re-nesting of components. just focus on calling your API methods and having them insert different components at specified positions (or template slots would likely be easiest). also forget any server interaction or databases, that can be added later. [1] https://github.com/leeoniya/domvm
&gt;Guess like with most language comparisons, it's down to personal preference It's really not. Static typing solves so many issues that large projects are insane not to adopt it. Want to change the members inside an object? Change the definition in one place and you can see the cascade of places where the definition change affects. Writing tests to make sure you are passing the right type into a function? Meaningless with static typing. Tooling support also increases greatly with static types; from intellisense to the possibility of smarter tree shaking and bundling utilities. Not to mention that static typing allows for better correctness. There are so many benefits that the only people who ignore them are those that work either alone or on very small teams or those that haven't yet seen what the benefits are. You shouldn't dismiss static typing because an article that shows roughly todo level complexity doesn't display tangible benefit. By their very nature computers care very much about type correctness. Static typing gives you better control and better visibility into what already matters anyway at runtime.
I don't like the marketing that Go was meant to replace C. How can a language with a GC replace C? Makes little sense.
Smashing!
You're right, most blockchains are for storing secure immutable data. The decentralized data center of RadJav would be secure, but not immutable, users would be able to change their server-side apps code at any time, so long as they have the private key to do so. RadJav's smart contracts on the other hand would be secure and immutable. Once they are on the network, there is no changing them unless they are destroyed. As for the templating, that does make sense. I've done some Angular coding, so I know what you're talking about. We're experimenting with lots of different ideas and issues that RadJav will tackle, so we will include something like this. I'll reply with an example for one of the ideas we've been kicking around later tonight.
I dunno. It seems to more or less not do anything useful, and that's judging from their own demonstration video. The goal is nice, but I don't think that the attempted solution will accomplish that, even with better execution.
I didn't dismiss static typing, I merely pointed out that the articles conclusion of it being a no brainer was a little out of context. Just because static typing solves a major problem doesn't make my comment about the choice between js and ts not a personal preference. The beauty of our industry. Pick the thing you like the most and use it. I don't think it comes down to size of company either. Ive worked in large and small and none used TS. All languages come with pros and cons. You've focussed typescript's selling point and major pro which clearly in your opinion that makes it better. Thats cool, that's your preference. Mine will, for the foreseeable future, be to stick with JS.
I don't disagree with you on that point, just saying that the original question was about semantics, and $.get is a jQuery method that MAKES an API call
You don't have a point.
The thing is its not an opinion. Businesses especially should be interested in statically typed languages because one of the biggest reasons to use types isn't so the developer understands the system right now. It's so that the future developer can understand the system. Static types are like blueprints and maps; a form of internal documentation. Obviously anyone is free to use whatever they want. But my point isn't an opinion. My point is static typing systems have demonstrable benefits. The longer a system needs to be supported, the more developers it has, and the larger it grows the more it benefits. This isn't some selling point. This is verifiable by looking at large long running software projects and seeing how they work best.
if youre not committed to doing this project completely in JS, i'd look into .NET WebAPIs for your API since you're already familiar w/ C# and look into a framework like Ember or React for implementing the frontend. I use Ember myself at my current gig and I'm a big fan.
Can you clarify what `not working` means? It seems you have elements on the index page with ids of `home`, `about` and `services` and by clicking the link one of them shows? Does the thank-you page have these same elements? Even then, not ideal because you've duplicated the markup between each of the pages. What you probably want to do is link to, e.g.: `index.html?page=about` And in the index page add some javascript to parse out the querystring of the page, look for the `page` value and call `goto` witht the same value.
I feel like OP could probably handle using vue-cli or create-react-app to get started 
just make sure you're aware of the performance trade-offs with Ember: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html
the reason i would not necessarily recommend them is because they add tooling. and they add JSX or another non-native DSL which is either a mix of html and js without delineation (JSX) or a superset of html. if a dev does not know the fundamentals, then it's more to learn, and it's more confusing.
Cool, thanks. I'm putting something together to that end in node.js right now... Just for fun, I am making them microservices with https://github.com/dashersw/cote. It literally was as easy as it describes. (I know I'm adding unnecessary complexity and I'll likely re-tool it later; this part is just for learning.) I will experiment with your view layer and socket.io for some realtime updates. It seems I will need to wrap my head around streams too. I did start playing with dynamic types and expando objects in C# which probably made the JavaScript transition easier. I'm trying hard to break my OO mentality. I see there's even a class keyword now (ES6) but trying to do OO in JS feels wrong... whoa, guess I'm getting a bit too ADHD here, so I'll wrap this comment up. Thanks for the advice.
Okay sure, Node.js was hipster back in the day. I still don't know that means?
You are probably right, but I have a tendency to play around with too many new things at once... I actually already installed and used vue-cli and made a very simple app that I queried a MSSQL database that is used in one of my C# programs. (using https://github.com/patriksimek/node-mssql)
OO, prototypes, composition, FP, async, immutability, streams, fluent apis, single-state - they all have their place. none of them is the best solution to every problem; each has trade-offs in terms of mem performance, cpu performance, ergonomics, min/gz output size, etc. good architecture is knowing when to apply each given the task and experience at hand.
Right now, perhaps my more fundamental goal is actually to learn JS, but I may look into React... I like the concepts, I think, of React but Vue seemed like an easier one to jump into. And I haven't researched Ember at all.
I mean, it's his profile. It's not like that's the readme for the project. It seems to me that the profile blurb is the appropriate place for a description of personal values.
We're just arguing over semantics. I never said strict typing wasn't good. Far from it. It's one of the reasons the companies I've worked for recently moved to React. My point was that there are myriad factors involved in choosing a language, this being one. In your opinion businesses should prioritise that. Wasn't saying your opinion was without with sound reasoning, clearly it is. My opinion, and that of most of the people I've worked with lately, is that there is not enough of a benefit from switching from JS and React (which has a form of strict typing) to TypeScript. Anyway, I've used the phrase strict typing too much for one evening. Adios.
I find it strange that your focus is so easily diverted. If I am interested in a project, knowing that its maintainer is a woman, or trans, or a unicorn, doesn't impact my focus in any way. My focus does not depend on what someone chooses to write in their GitHub bio, not any more than it depends on what their profile picture is. I don't care about that, and I don't complain about things I don't care about. What this person put in their profile might be odd, but it's such an irrelevant and inconsequential trifle that I struggle to see why you care so much. Perhaps it is the case that this particular project is pointless and ill-advised, but to disregard it on the mere basis of their maintainer's quirks is nothing more than an ad hominem.
I use Text Expander and just use keywords prepended by three characters.
Reacts prop typing is not the same thing as typescript. Not even close. Not by a mile. My comments aren't strictly about typescript. They are about just static typing in general. Flow, elm, dart, whatever. As I said clearly everyone is free to pick whatever they want. But that doesn't mean there aren't better and worse choices. Not everything is just an opinion. Don't take this too harshly. I realize reading it that it sounds like I'm insulting you or something but that's not the way I mean it at all. I'm just speaking from a purely technical perspective.
Did you copy and paste that from somewhere? Looks like its using curly quotes (`“”`) for the prompt instead of straight quotes (`""`) which is what you want. If you open up your browser's javascript console/developer debugger you should see an error to help you identify problems with your code. Here it should mention an unexpected character or something like that.
&gt;Does the thank-you page have these same elements? No i am trying to link back to my main index page from the subpage. It does not work because my main page uses the GoTo: Java script that changes from class=active to class=off and then activates the content to be shown on click. Here in lies the problem. I can link back from the subheading but I need the event to take place onload so the users sees the correct content, not just the activated home page. I am attempting to use: &lt;a id="#about" href="../index.html" onload="goTo('about');"&gt;link text&lt;/a&gt; somthing of that nature but with no luck. maybe something like this? article id="about" class="active" style="transform: perspective(100px) rotate3d(0, 0, 0, 0deg) translate(0px, 0px); opacity: 1; z-index: 2;" href="../index.html"&gt;link text&lt;/a&gt;
Yes. Thank you for helping me. 
Yea that's what I figured... read the last two paragraphs what of what I wrote above, gives a way to do that. onload on an anchor I don't think would do anything. If it did, it would be fired when the anchor has loaded not after you've visited the index page. Once you navigate across page, your entire js context is gone.
How does the performance of this compare to just using Lenses? I imagine parsing the string would incur a significant performance overhead, whereas Lenses are just functions and can be inlined by the compiler.
Can someone give the elevator pitch on this one? Is it going to be at least twice as fast (to develop for or at runtime) than React?
Is there a plugin to simply hide all clickbait? In my experience, nothing of value would be lost.
Makes sense. I'll make sure the next post is not from Patreon. Thank you for the clarification!
Tested in only one browser.
Yeah I feel like OP is trying to solve the wrong problem. Reducer composition and you are donzo. 
This is why I like the Haskell approach of using modules for information hiding instead of private state. You can define as many (or as few / just one) big integer types and similar in a single module and allow them to access each other's internals. But no one outside that module can access the internals. It avoids issues such as having a few very similar types that can benefit from accessing each other's internals, but not wanting those internals to be public.
I would say there are some bits it could shed: I dont really have a problem with weak typing or the == operator. In fact its quite useful. But I do agree there are some ugly parts. * Deprecate/eliminate "var" * eliminate "this" and "new" keywords, generator functions and pure functions are better * the "class" keyword and associated cruft * prototypical inheritance should be simpler to set up. * get rid of the "import" syntax; its too static for js * eliminate the global scope/ make the global references file scope only That said; its never going to happen nor does it need to in particular. I can easily avoid using the parts I dont like. More important is to stop adding needless new cruft. 
I see, how could I point to that page when clicked from the subpage link then? or is there really no easy way to do this.
Not really, but it's a static templating system with a new template language embed with a fast runtime view level which you can turn it into any MV* framework if you like. So I call it a framework. Also it's not anything like React, Vue or Angular so it's pretty unique. This is not a "yet another" clone.
your firebase keys are in your code... not sure it is a good idea
It can't be twice as fast at runtime but it sometimes beats vanilla js. See this tweet https://twitter.com/ClassicOldSong/status/852235966643187713 for test results on todomvc. Here's another live demo on dbmon: https://classicoldsong.github.io/js-repaint-perfs/ef/opt.html
https://stackoverflow.com/questions/37482366/is-it-safe-to-expose-firebase-apikey-to-the-public
With minimal refactoring, here's one way of doing it. * Have all the pages in index.html have their class set to "off" by default. * From thankyou.html, link to the pages with hashes: index.html#home, index.html#about, etc. * Whenever index.html loads (windows.onload), have it immediately execute a script that checks the hash in the URL (location.hash) and switches the class on the corresponding page to "active." In particular, if there is no hash (the user just showed up at index.html), switch the class on the default page to "active." One word of warning: Internet Explorer thinks the empty hash is '#', not ''. So when you check if the hash is empty, in order to have your code work in IE you should make sure location.hash.substring(1) === '', rather than just location.hash. So make the links in thankyou.html go to index.html#about, etc., change index.html so that all the pages it contains have class "off" by default, not "active", and then add a script to index.html that's something like the following. window.onload = function() { var hash = location.hash.substring(1) // saves typing later // if there is no hash in the url, activate the default page if ( !hash ) { goTo('home') } // otherwise activate the page indicated by the hash else { goTo(hash) } } I think that's the approach you'll find minimally inconvenient to implement. 
https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3 &gt;&gt; What I don’t like is that a lot of people think that TypeScript solves a problem that it doesn’t actually solve — at least, not to any significant degree. &gt;&gt; “Whilst not conclusive, the lack of evidence in the charts that more advanced type languages are going to save us from writing bugs is very disturbing.” — Daniel Lebrero, “The Broken Promise of Static Typing” &gt;&gt; Type correctness does not guarantee program correctness.
Awesome, I can't wait to get into this tomorrow. I really have had enough of it today and hopefully a fresh take with your new info will get it working. Thanks 
"I'm a random article on medium and clearly I should be taken as gospel." Please. Of course static typing doesn't solve all bugs. Otherwise programs written in static languages already wouldn't have any. In fact I never once said use static types so bugs don't happen. I explicitly said that static typing provides other benefits. Static typing is in many ways a form of documentation. If you've ever worked on a large software product you know that comments often get misaligned as they aren't always kept up to date. But since static typing is actually checked by the compiler you *can't* get away with using the types incorrectly (for some definition of incorrectly, not all cases but it does solve a class of problems). By explicitly providing type information you enforce keeping at least part of the "documentation" up to date which means that in a year from now when you or some other developer looks at the code they can trace things and figure out what is going on far easier. The idea that since statically typed programs have bugs therefore static typing is useless is such a ridiculous argument. It's like saying "why should we mark what size screws we used? The next guy will figure it out" only then he strips the screw heads off using an imperial measurements screwdriver instead of a metric one.
Why i cudn't think of it? 😐
Typically 5-15 mins a day, but often broken up into 1-2 minute chunks dealing with items as they come into the mod queue. For Sunday, I spent 30-45 mins in writing replies and whatnot in the thread, which happens from time-to-time. There's also times when there's a high-profile and/or controversial post, which often requires 45 mins or more per day for a few days. 
I agree with all of the above. At work we have a pretty seizable code base. Most of it has been ported to TS and working with it is a joy, especially due to the great tooling support it enables. Whenever I have to delve into the depths of some old js files it's a pain. 
What? I think I'm not following. Anything you would need to be accessed by the outside you should just expose it in the returned object. You _numbers array is not private at all, it's public, anything can access it (but of course there's the underscore semantic). If you want public with that approach, you just add its key in the object that is returned. 
javascript.info and learn js the right way, a book on github. Sorry no links as I am on mobile. 
After you get the basics of programming logic (data types, control flow, looping) you should check out [this video](https://youtu.be/8aGhZQkoFbQ) about the javascript event loop.
Promises aren't broken; They solve a specific problem, and they solve it well. Its no more broken that the original callback system. Now that there is a solution to synchronizing async tasks, it's time to solve the next big problem: control flow. FLutures seem like a good stab at it. But I think proposing it as the solution to "broken" promises means that in a few years someone will solve the next problem of race cases by calling FLutures "broken". FLutures don't try to solve race case issues, and I wouldn't fault it since that's not its goal. But I also wouldn't fault promises for not having a way to cancel, just as I wouldn't fault callbacks for making synchronizing difficult. 
Is there a reason that you avoided using https://facebook.github.io/react/docs/update.html? The newer library (immutability-helper) is actually even better, but I find that update is super useful for exactly your use case, and allows modifying multiple parts of your state at once.
Yep. After writing single file components in Vue (and previously even dabbling in Polymer) I'm definitely not conceding to use a template string. The hope is that there's a build step available like there is with Vue.
Check out FunFunFunction on YouTube. All of his videos are great.
Well, I personally went with native script with angular since I have some experience with angular , the plus is that you have the same code base for both iOS and android, and if in need you just change the views and cans have the same logic on web 
The way he wrote it is how private scope works in a lot of languages: by *class*, not by *instance*. You are free to modify one instance's private state outside of that instance, as long as you do so inside the scope of its class. And that was what the example was showing.
The prefixed `_` convention indicates it's private, as you mentioned; for the purpose of his example, ignore whether it is actually private. Other OO languages allow private access between objects of the same type. There is no need to pass an object around. Here's an example in [C#](https://dotnetfiddle.net/zC40MO).
https://github.com/getify/You-Dont-Know-JS
The memory usage only becomes an issue if you're creating a large number of objects (10,000 in the article). If you're only creating a few - which is likely - then using 5MB of memory instead of 500kB is not a big deal and the increased expressiveness wins out. 
Heh, no offense, but it doesn't change the titles to "more honest titles", it seems to change the titles to an arbitrary out-of-context sentence from the article :P
http://www.communitypicks.com/r/javascript People's opinions on JS books. Seems like Eloquent Javscript is most popular.
Error handling is my only issue with Promises. The syntax could also be better, but I guess you can fix that with async/await.
JS devs drive me crazy sometimes. They are obsessed with both "premature optimization is ..." and optimizing every line of code to fulfill bizarre conditions in the most common JS engines. Given that it takes _1 million_ objects to use 490MB, and that our applications are generally not doing that, or even instantiating classes the majority of the time, and probably not holding onto those references except in the most demanding applications, considering this performance penalty is a waste of time. If we assume that this translates to 0.5KB per object, and we've created even 10,000 of these, then we're only using 4.8MB. Unless you have a really specific reason to write your code differently because of performance issues, you should strive to write the most readable and maintainable code possible.
W3schools, blogs, pluralsite... Theres loads of good free stuff on youtube. Edit: For beginners, I'd say these are all sufficient sources. This is what I get my apprentices to do and they get to grips with js quite quick; from 0 previous knowledge.
Didn't take it harshly at all, just got better things to do with my time than argue over semantics.
I cant say anything about Inferno, but if you are interested in React alternative - I suggest Preact. Actively developed, improved and there is also slack channels where you can get help.
How? By what method is it doing faster operations than the JS it is built upon?
Inferno is godlike but unfortunately some packages need new maintainers, such as the inferno-router one. Im currently working on upgrading inferno-router to the latest react-router api and will probably become the new maintainer for the router package. If you send over a github repo link I will take a look and let you know if I see anything suspicious. EDIT: soory didnt see the part where you said you used the routes of the presentation. Im having a look
&gt; get rid of the "import" syntax; its too static for js as someone who recently came to enjoy the import syntax and tree shaking, but then discovered the importance of code splitting, I feel strangely torn by this sentiment
JavaScript for programmers (my books, free to read online): http://exploringjs.com
&gt; The syntax could also be better, please show me how you could make a Promise syntax better. I am hooked to see how it could be improved.
Found the mistake. Replace "/:username" with "/users/:username". Example was from the README: https://github.com/infernojs/inferno/blob/master/packages/inferno-router/README.md
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [infernojs/inferno/.../**README.md** (master → f7c77fe)](https://github.com/infernojs/inferno/blob/f7c77fe69c4c9223c46ed9ff594acef28834723d/packages/inferno-router/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dm9ttpf.)^.
I've tried about 3 or 4 courses and I this one really clicked with me. Really clear explanations of the basics. https://watchandcode.com/p/practical-javascript 
Is this better than Eloquent JavaScript? Which one would you recommend?
are you looking for stock market news which covers stock market, fx, currencies, other topics? [Financial news API](https://www.cityfalcon.com/financial-news-api&amp;utm_campaign=KO_reddit) provides that you can check might help you :)
I'll just kick off the discussion in the comments; so the actual API would be easy to implement. My initial thoughts are; * MLab to store the data * Node.js to run an express server and interact with Mongo via Mongoose * We can host the API on Heroku, again free of charge for now. Where help is needed is collecting the data, and adding it to the API.
By batched update. ef.js tracks your modifications and executes them once you done your operation. There is no virtualdom nor any diff needs for ef to update the dom: the dom modification methods are created and bound to the right dom object it needs to update when you create the component, ef just execute them on demand. So ef could reduce operations on both hands, both dom rendering and javascript executing. You modify the data, I modify just the right place with pre-bound method. No useless operations other than what you need performed. Clean and neat, and fast. Note that there are no asynchronous methods in ef.js, so it could be instinctive while still be fast.
I didn't read that, so I can't say which one might be better. All I can say is that YDKJS was the one that just clicked for me. Even though I knew JS before, I didn't really know it (which is kinda the premise of the books). It really gave me the solid foundation to the language what's hard to obtain by reading multiple sources/tutorials on demand without planning. I'd still recommend the book if you're a complete beginner, it's really well written in my opinion. It has the classic foo-bar-baz examples, which might annoy some, but I have no issues with them.
Hmmm this is something I am intrigued by, though I've never really dabbled with mongo. I do love me some Funko Pop though! I've got about 12 or more
Excellent! Assuming you've had experience with `JSON` Mongo will be a breeze to learn. Assuming we can get the numbers, we can either discuss it on here or even set-up a Slack channel.
Yep JSON is no problem for me. For now Reddit will do until I can actually say yay or nay about committing but man that's a cool idea! Thing is I'm getting a job soon I think and I may not have time hah the ironies
Two more things you cudn't think of: - Drinking ice tea while having hot shower. - Drinking hot tea while having cold shower. ***Why*** cudn't you think of it? 😐
Not one of those demonstration headlines was clickbait. In addition, half the time the plugin replaced them with random sentences that made no sense whatsoever unless you'd already read the original headline (or in some cases, the entire article). It's a nice idea, but based on the project's own demo video, so far this is basically useless.
That's fine. The main thing we need to figure out is what information is required and then make the API. The data input can be done by anyone; developer or not.
There's a lot of doomsaying in this article. Before I go over the issues I have with it, if you agree that Promises are broken and don't want to learn Fantasy Land or FP, you can use "Observables" and streams outside-of-the-box with [RxJS](https://github.com/reactivex/rxjs) instead. #Eagerness When you call an asynchronous method, anyone reasonable would expect it to start immediately. If you don't want it to start immediately, don't call it in the wrong place. Causing side-effects with an asynchronous method is stupid. You will never be able to keep your execution state synchronized with the asynchronous method unless you block (read: defer execution, since JavaScript uses a single-threaded event loop) your code from executing by waiting for the asynchronous method to return, thus defeating the purpose of the method. Not synchronizing will absolutely introduce race conditions. #Cancellation I agree this should have been implemented, however, let's not pretend there are not ways to implement cancellation. There also exist several cancellation libraries. Even in the absence of cancellation, if you are not producing side-effects with your asynchronous code, then it's easy to ignore any results that come back. I disagree that cancellations would reduce any performance penalty with the use of `.race`. Because the asynchronous work is started simultaneously, then you have already allocated the memory, used CPU time, released the thread and CPU through the use of libev or IOCP, and are now waiting for one of the methods to finish. The only benefit cancellation would gain is releasing memory sooner, but you have a real problem if your asynchronous work is taking a long time (20 seconds is extreme for asynchronous work, and should be considered a bug). Also consider that your asynchronous methods should be doing as little CPU-bound work as possible, which will cause them to return faster. This also grants you more control over what's happening higher up the call stack. #Specialized API ###Promise Assimilation This is good. It makes code much simpler, and everyone is less likely to shoot themselves in the foot. Perhaps the actual implementation of the idea is flawed, though. If it's a genuine concern, the returned object can simply be wrapped in another object that doesn't look like a Promise. Regarding the fear of problems like this becoming more frequent "as programmers catch up with mathematicians," I believe the trend has been the opposite for decades. Mathematics were key in the early days of programming languages and logic, but that is not true now (for software developers, not language developers). Functional Programming has existed for decades, and, while the interest has increased amongst the JavaScript community, it doesn't seem like FP will become a cornerstone of JavaScript applications for a long time, if ever. #Error handling I'm not familiar with languages that force error handling, regardless of what code is executing, unless you count requirements in concepts like Pattern Matching. You don't have to wrap code that might fail in a `try-catch` block, for example, so why should we expect that we must catch Promise failures? I agree silent failures are a big problem. I would reject a code review if I saw something like `try { ... } catch{}`, as well. I think the concerns regarding invalid state are not related to Promises. This is a concern for any failure. #Mixing exceptions with failures Crashing a process because of an error is ridiculous, and it's quite unfortunate this is the mentality taken by Node.js developers. If you experience an NRE browsing a website in Chrome, the browser process doesn't crash. It catches the error and prints it to the console, then continues like normal. The concept is "fail early," not "crash early." Both of the failure examples might be considered and handled exactly the same; I don't understand what an "expected failure" is. You write code that handles errors; the application doesn't care how "common" or "expected" it is. As such, there is likely nothing further to do if a user isn't in the database, so you log an error and bail out of the process. You would do the same with an NRE. The key to using exceptions, catch, and reject together is to establish conventions with your team. This is not an unsolvable issue. #Volatility You don't need to crash your process to recover from errors.
As /u/evenisto indicated, async/await is a solve for any syntax issues. Async/await works on-top of Promises, so, in a shallow way, it could be considered a new syntax for Promises.
Eloquent is project based and teaches you how to build programs using JavaScript. YDK gives you a really deep understanding of the fundamental concepts of the language. Imo they complement each other.
&gt; W3schools lolno
I've been super happy with it so far! Currently building a 5-page SPA for a restaurant where the owner can log in and edit the gallery/menu/deals etc directly on the page without dealing with a traditional CMS backend. It's blazingly fast and the bundle size with inferno-router, inferno-compat, axios, drag and drop and all the components is just 25kb after gzip, taking 100ms to parse and render. Pretty amazing imo
As a book, I recommend *Eloquent Javascript*. [Javascript.info](http://javascript.info) is also a good source of information. And lastly, check out the docs in the MDN and avoid W3Schools.
LOL. Why didn't ECMA simply made it as v5 rev. 2 or v5 2011 rather than v5.1? It's kind of misleading, especially for software.
Ah, I see. Thanks. Looks more like a correction, tho. No functionality changes.
I've read both and I'd recommend Eloquent before YDKJS. Eloquent does a great job explaining JavaScript without going into a lot of the trivia/quirks. Also the exercises are a major key to grasp the chapter lessons. You'll be ripping your hair out while trying to complete them, but the experience/exposure will make YDKJS make much more sense to you.
It looks from initial glance like the content you can publish is indent restricted? Ie you need to format it properly, so how would you for instance handle retrieving a bit of markdown and rendering it to the browser in HTML securely?
You could parse the Markdown to the AST which ef.js uses. Currently there is no parser for Markdown to ef.js, but it's been planned. Another method is just put your parsed Markdown to an element's innerHTML, which most in-page markdown viewer does. ef won't care what you do to the component dom unless you break the initial structure. I'll release a demo on this recently. If you parse your template before publishing using webpack or rollup, there will be no indent issue becaues the templates have already been transformed into AST. 
i thought hoisting was bad form and should be avoided, i mean, it is to me :-/ edit: reading some of ur comments i wonder if u know what hoisting is edit2: hoisting is bad form because code readability.
I believe Node would not appear into existence without JS becoming popular in first case, and that would be impossible without client-side monopoly.
I feel like the author has a weird view of failures. As described in the article, an expected failure really isn't a failure though. If the operation, for example, is to fetch a user and the user does not exist, the operation didn't fail. The operation succeeded, it just didn't have the value you hoped for. Had the database been down, that might be considered a failure. The former is like making a promise of an http request and failing if you 404. The later is failing if the request itself fails. Furthermore, there's nothing stopping you from attaching multiple catch statements and using Promise.reject manually to accomplish the desired goal. I think this is where promises shine over try/catch actually, as you can have complex "sad-path" error handling in a clear and organized manner makeRequest() .catch(requestFailure) .then(processRequest) .catch(dataNoGood) As an aside, I don't see people using the two callback form of then often, but I feel as though it makes flow control with promises much more clear. makeRequest() .then(processRequest, requestFailure) .catch(dataNoGood) .then(updateUI) In addition, if promises are meant to be treated as future values, of course their eager. Complaining about that is like griping that the function you just invoked is eager, or the + operator is eager. 
I'm always hoping for new template engines because the only one that's widely used and has active development is Pug. (not counting engines coupled with frameworks) And I don't like it that much because it is indent based. Just like this one :/ I really like the way Kotlin handles UI though. 
Days since last variable scoping article... 0
&gt;Causing side-effects with an asynchronous method is stupid. you lost me there. Writing to a database is stupid?
Actually ef.js only recognizes it's AST. The core which does not have a parser embedded is splitted into a separate repo called ef-core ( https://github.com/TheNeuronProject/ef-core ). You can have any template language transformed into ef's AST with proper parser (if exists). I created EFML just because I really like the way writing HTML with Emmet.
It is. Also, var.
The ef-core part sounds interesting. I just haven't looked too much into language parsing/transforming/etc.. Which means I'm just a "user" when it comes to template engines. Currently, I don't know how I could create my own.
Ok :- ) Anonymous chatting is interesting. I would think some people (I at least) would want the possibility to have their own persisten usernames? In any case ... if it gets popular, I'm thinking you'll need to figure out some good way to moderate everynoe, ... Maybe moderation based on IP addresses? If an IP address have said 10 "evil" things, then ban that IP for a day or a week?
I'll add the document on creating parsers later. But it could be very hard to understand 😂
egghead.io 
The JavaScript Way book teaches the basics of JS and web development up to Node, using ES2015 syntax from scratch. It's free to read online at &lt;https://github.com/bpesquet/thejsway&gt;. Disclaimer: i'm the author.
[Finished Codecademy, Now What?](https://www.youtube.com/watch?v=UQLOIwKJB7U) - YouTube Codecademy does a really good job of making you feel comfortable. You get your feet wet and solve a few trivial problems. When you try and jump right into programming after Codecademy, you're going to hit a lot of speedbumps. This is normal, don't get discouraged. I recommend doing some coding challenges to help you fine-tune your coding chops. I wish that's what I did when I first got started. Instead I jumped right into building stuff. I learned a lot but I could have avoided a lot of pain by taking a more structured approach. 
I don't know where you read that but innumerable patterns use this. Who wants to keep track of the order functions are defined? That's not very robust.
&gt; The thing is its not an opinion. That's exactly what it is as long as you provide no references to studies that support your claim.
You are attaching the onclick event to the tooltip. I think you want to attach it to the A link element. Create another function instead of nesting them that receives the dom element as a parameter. In the function get the value from the parameter. When you create the tool tips and add the a link element, pass an onclick and call the function passing this as parameter. 
X-Post referenced from [/r/webdev](http://np.reddit.com/r/webdev) by /u/b_edelstein [Security Checklist for Full Stack Web Developers](http://np.reddit.com/r/webdev/comments/6wr2ms/security_checklist_for_full_stack_web_developers/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
It's useful occasionally, but should be avoided. It takes very little effort to make sure your initialization order is proper. It's also (in my opinion) more effort to go figure out what's going on when you have to also include hoisting rules. 
Agreed with this. Hoisting for variables is shitty. Never use variables before they're declared. But also, don't go full crockford and require all variables to be declared at the top of their scope, because that just makes the code harder to follow. Hoisting for functions, though, is very helpful for code clarity and organization.
Calling "hoisting" a hidden treasure is a bit... generous.
Ummm, if you think these are "hidden treasures", then you really don't know much about JavaScript. These are the most *basic* features.
If I knew the answer to why committees make the bureaucratic decisions they do, I'd be a much richer person.
We posted an example of what we're thinking about implementing. You can see it at: https://github.com/HigherEdgeSoftware/RadJav/wiki/GUI-Development For more info, or to continue this discussion further, join our Slack channel at: https://radjav-slack-invite.herokuapp.com/ We would definitely love to have your input. Oh, and sorry about the indentations...
Really? You didn't know that already? That's really basic stuff.
Parent comment is a hidden treasure
&gt; But also, don't go full crockford and require all variables to be declared at the top of their scope, because that just makes the code harder to follow. I thought this was a 'good practice' ... 
Declaring variables close to where they are used, I think, is the more useful rule of thumb to use. If your function is kept small, which is preferable by another rule of thumb, then "close to where they're used" will coincide with the "at the top of their scope".
According to Douglas Crockford, it is. I respectfully disagree. YMMV. Honestly, I'd recommend following his guidelines for a while and seeing what works for you. That's what I did. I like the vast majority of his stuff, but some of it just didn't work for me (not using `variable++` is another example of a Crockford rule I disagree with).
i've never heard that rule for rounding. the only rule i know is that x.5 always rounds up. if you want a function that does what you want: function roundToEven(n){ return (Math.floor(n) % 2) ? Math.ceil(n) : Math.floor(n); } that should do it ninja edit: wait sorry, that only works for numbers that are exactly 2.5. you'd need a little extra logic (possibly using n%0.5) to make sure that's the case, and if not, just return Math.round(n);
Okay. Thank you for explaining.
Add 0.5 to n and floor it 
I didn't realize what a treasure closures are until I had to write some stuff in c. Having closures is mana from heaven. I think a lot of js devs have grown up javascript, and haven't yet learned how the language fits into the world of software development.
Read the article then
&gt; For x.5, you need to round such that x will be an even number. ie. 1.5 rounds (up) to 2 and 4.5 rounds (down) to 4. ...wat?
When you are rounding, and the last digit (after the percision digit to be rounded) is 5 (with nothing after it) it should round to the nearest even number.. 2.4 =&gt; 2 2.5 =&gt; 2 2.500001 =&gt; 3 2.51 =&gt; 3 3.4 =&gt; 3 3.4999999 =&gt; 3 3.5 =&gt; 4 3.5000001 =&gt; 4 etc... 
Why?
I have never met a single person who rounds like that... but I looked it up, and [I guess this is a real thing](http://mathforum.org/library/drmath/view/58972.html). So TIL I guess
[removed]
I don't think I'll ever understand that argument. Purposefully waste memory when there's another option that requires no more effort to use. I definitely don't buy that one of these is any more expressive than the other either. function MyType(prop1, prop1) { this.prop1 = prop1; this.prop2 = prop2; } MyType.prototype.add = () =&gt; { this.prop1 + this.prop2 } createMyType = (prop1, prop2) =&gt; { return { prop1: prop1, prop2: prop2, add: () =&gt; { prop1 + prop2 } }; } This isn't even to mention the drawbacks that come with the factory option like no inheritance options and no `instanceof` checking. Not to mention that the author is using ES6 and seems to have access to ES6 classes, which is a total no brainer when it comes to this issue altogether.
I've tried learning JS from several different sites and books and the site where it all started to click for me was watchandcode.com almost every example is done with a practical example, it goes into debugging very early on and spends a decent amount of time teaching how to read and make sense of other people's code. I prefer videos to books and found the Udemy course Javascript understanding the weird parts covers all the topics from you don't know Javascript in video form. There's also a Udemy course I always recommend called Git a web developer job: mastering the modern workflow. It's not a strict Javascript course but it does teach gulp,webpack, Git, CSS processors, responsive development, deployment, writing modular JS and spends ~ an hour going over different ways to use JS for navigation. I liked the book eloquent Javascript, I'd love it if I could find its content in video form. 
I'm under the impression that `Annotations === Decorators`. [inversify.js](https://github.com/inversify/InversifyJS) is typescript but might help. [mobX](https://github.com/mobxjs/mobx) is a good candidate too.
because science.
lol, glad to help you out. care to return the favor ? =p
I've been trying to build something like this, but having no luck.... javascript is messy with floats and trying to do 22.0025 % 0.0005 just messes things up .. 
I think he means something like changing some global like state and then having the next line rely on that state not having been modified in that async function before it hits the next line. ie. global.val = 1; var prom = new Promise((res, rej) =&gt; { global.val = 2; res(3); }); console.log(global.val == 1); If promises execute eagerly the log is different than how they are today. The argument is that building around this behavior and trying to prevent this seems quite bad.
 function bogoRound(n) { if ((n + 0.5) % 1) { return Math.round(n); } return Math.trunc(n) % 2 ? Math.ceil(n) : Math.floor(n); } console.assert(bogoRound(2.4) === 2); console.assert(bogoRound(2.5) === 2); console.assert(bogoRound(2.50001) === 3); console.assert(bogoRound(3.499) === 3); console.assert(bogoRound(3.5) === 4);
 function round(n) { // Fractional part &lt; 0.5, round down. if (n % 1 &lt; 0.5) return Math.floor(n); // Fractional part &gt; 0.5, round up. if (n % 1 &gt; 0.5) return Math.ceil(n); // Fractional part === 0.5 and whole part is odd, round up. if (Math.floor(n) % 2 === 1) return Math.ceil(n); // Fractional part === 0.5 and whole part is even, round down. return Math.floor(n); } 
Maybe try doing some string based analysis? check the nth to last digit of a string using `string.slice(-1*n)[0]`, to get the nth to last digit of a number use `parseInt((n+'').slice(-1*n)[0])`
These articles are so tired Im generally all for people evangelizing, for writing in order to more thoroughly learn a subject. I think its a good thing. You never know who is going to click and start programming because of reading whatever. But fucking come on. Who are the 40 people up voting closures as "hidden treasures "? 
the problem is this doesn't scale for different levels of precision.. =(
the problem is, this doesn't scale for different levels of precision... =(
Ok, I did it... Manipulating floats was killing me. I did it via string manipulation https://jsfiddle.net/cvqc8crr/1/
Mh? **Edit:** Ah okay. 22.0025 etc. Well, doubles aren't that precise. Try /u/ghillerd's suggestion and do something string based.
Opps, I had 1 minor bug... https://jsfiddle.net/cvqc8crr/3/ Still testing... 
Where did you go to school? I've also never heard of this (but I've just read all about it) and I wonder if it comes from a region/country difference.
And yes, I know it is messy.. but at least it is working.. 
&gt; I am hooked to see how it could be improved Like I said, for example with async/await. It only requires you to use two keywords, compared to the entire `return new Promise(function (resolve, reject) { ... })` ordeal, that with a couple of thens and error handling quickly becomes a multiple-return indentation hell. Async/await is not perfect, but at least it gets rid of a lot of boilerplate and in my opinion is much easier to grasp.
I'm living in Canada.. Learned this in grade school... stuck with me since
The "Hoisting is bad" rule of thumb comes from things like this: var foo = 1 function bar() { var bla = foo; // person thought they were accessing the var above var foo = 2; // but they just got bit by hoisting } However, function hoisting can be a useful way to make code readable in a top-down fashion, e.g. init() function init() { doThing() doOtherThing() } function doThing() {} function doOtherThing() {} 
Thought experiment: if you don't like that the r/javascript community's posting patterns isn't focused on curated articles, then why not just leave and use another resource that *is* focused on curating articles? (e.g. javascript weekly) Or maybe cross post from those resources here to help set a tone here. I feel like modding newbie questions is not going to be effective from a perspective of effort-to-gains ratio if a large number of people asking these questions are, well, newbies who might not know the etiquette of the sub.
Those aren't "hacks", they're language features.
Hi /u/AllsWellThatsHaskell, please refrain from personal attacks. Thanks.
One good reason is cases like [this] (https://stack overflow.com/a/18869878) is why I would argue it's just safer to use x+=1 and tends to read better. Nothing is lost by using x+=1 by default ime
I realize that you were taught this way, but my question to you is, "what is the use case?" The standard for rounding is that 5 always rounds up. I'm wondering what you need this weird (but familiar) behavior for.
Well, for me, this rounding is the standard. But to answer your question, I'm building a financial app and rounding up in 5 of 9 cases (0.5 and higher) vs rounding down in 4 of 9 cases (0.4 or lower) is a bias towards rounding up. When amassing thousands and thousands of transactions, I don't want this bias to be overrepresented. 
&gt; Its no more broken that the original callback system. Either you're arguing that callbacks are not problematic or that callbacks *are* problematic but that promises are no worse. ;) The author is advocating a principled approach to managing asynchronous operations in JavaScript. Promises are unprincipled in several respects. 
Yeah if while reading someone's code, I have to stop and consider execution context that PR is getting declined.
Wouldn't almost every calculation result in significant figures beyond the third decimal place? If you're representing currency as YYY.XX, then you are rounding from the third decimal place to the second. If you have a third decimal place, then it's very likely that there's a fourth, fifth, sixth, etc It's super unlikely that a calculation ends up being 111.115000000000, so this kind of rounding behavior is a super marginal benefit.
1 million objects is not unrealistic for a browser game
Yes, but this is managing RRSPs and Mutual Funds etc.. so there are fractional units and fractional prices for the stocks and funds. we need to capture this as efficiently as possible, and display results to the user, not just by cents, but fractions of cents based on the configuration by the administrator of the app. there could very likely be number like $12.204150 with unit value of 405.20835 or whatever... 
Promises were always considered a stepping stone towards async/await. People on the committee probably knew this when they voted for promises to be included in the standard. I also agree with you that async/await is much nicer syntax than working with raw promises. I just don't agree with you that you could improve promise API itself to get a nicer syntax.
i guess this is the state of the javascript subreddit in 2017 christ thanks coding academies
Yeah, by saying the syntax *could* be better I didn't actually mean I *know* how to make it better. If I did, I would be on the ecma committee.
I think the main use is to avoid changing the sum of a list of numbers by too much. It's also known as banker's rounding. Say you sold 50 items at $1.50 and 50 items at $2.50. If you round to dollars using round half up before summing you'll get a sum of $350, considerably more than the actual sum of $200. If you rounded using round half even you'd still get $200. Assuming your numbers are evenly distributed you'll get a more accurate sum. 
There's actually a lot of standards for rounding. This one's called [round half to even](https://en.m.wikipedia.org/wiki/Rounding#Round_half_to_even). They all have use cases to avoid introducing bias into a set of rounded numbers (changing a property of the set like its sum or average by too much). 
Non-Mobile link: https://en.wikipedia.org/wiki/Rounding#Round_half_to_even *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^106415
Great article.
This all doesn't matter if you cant setup a basic project. I spent hours failing to get marko-loader for webpack to work. I kept getting error messages nobody has seen before
I guess it depends on what the clients would expect the behavior to be. I'm not sure what the standard is in finance, but in science and engineering I've never seen this kind of rounding being used. Edit: looks like in finance, so-called "bankers rounding" is used, which is the rounding you described.
If you're doing accurate arithmetic in js you might consider using a BigDecimal library ([e.x big.js](http://mikemcl.github.io/big.js/#rm). This is just the first one I found). They often have rounding method selection built in. 
Sorry you had issues. We've not seen any reports of issues with the `marko-loader` (at least none that I can recall) and I am not seeing any related GitHub issues. We have [sample projects for Marko+Webpack](https://github.com/marko-js-samples/marko-webpack) and they are working. Please feel free to open GitHub issues or ask questions in the Gitter chat room: https://gitter.im/marko-js/marko Also, if possible, please provide a sample project or some code to help us troubleshoot. It can be really hard to anticipate what developers will do with a myriad of build tools and frameworks so it is very helpful to have a sample project that illustrates the problem that you are seeing.
It seems like not using `var` prevents at least some of the unintuitive behaviors. This gives you a reference error rather than undefined. console.log(state); let state = "ready"; 
Thank you!!!!!!! http://mikemcl.github.io/big.js/#rm That's exactly what I needed!! =D =D &lt;3 &lt;3
We use it at work for its speed and permissive license(looking at you react). It's working out great for us so far!
Yup. I've decided long time ago I'll never design and implement any system of significance in a language that doesn't have at least one of: objects or closures. Both represent a way to bind state to instances of behavior and thus to basically permit configurable behavior, abstraction, polymorphism. Without these features programming is extremely inflexible, prone to duplication rather than reuse and brittle to changing requirements. You can emulate closures/objects in C, but the code becomes ugly as sin, and it's not safe at all (a soup of pointers and structs where things are tied by macros and convention). Some libraries exist that allow C to have closures, but it's not even close to what you get when an ecosystem is built around objects/closures natively.
Would love to see Inferno or Elm in this guide
why avoid W3School ?
That's true--there's a lot to consider down the line regarding optional persistent usernames and moderation. In the meantime there are some basic content filters under the settings tab.
Everything by Axel Rauschmayer is great Books http://speakingjs.com for ES5 and http://exploringjs.com for ES2015 and greater and blog at http://2ality.com/
The problem with Preact is that it might be covered by the same patents as React, and Facebook already stated some interests on those by attaching the PATENTS file. For lawyers in big companies, all those doubts just mean "no". Very sad.
it can be, but it still looks like bad form to me unless there's a reason why you have to declare the functions in the same context, which means you're using variables and/or functions from it, in which case you've already lost clarity because your declarations are all over the parent. instead i would stick to declaring everything first and keep my execution calls grouped up at the end. also with classes i dont think this is a problem that requires hoisting anymore.
In addition to "don't prematurely optimize", there's also a guideline to [not prematurely *pessimize*](https://www.safaribooksonline.com/library/view/c-coding-standards/0321113586/ch10.html). The gist is, all other things being equal -- notably code complexity and readability -- avoid gratuitous inefficiencies. And personally, I consider these two approaches to have equal complexity and readability. const createMyType = (startVal) =&gt; { let name = "Magic Object" let magic = 32 let val = startVal return { add: (b) =&gt; { val += magic + b }, sub: (b) =&gt; { val += magic - b }, getVal: () =&gt; val } } class MyType { constructor(startVal) { this.name = "Magic Object" this.magic = 32 this.val = startVal } add(b) { return this.val += this.magic + b } sub(b) { return this.val += this.magic - b } getVal() { return this.val } }
Unfortunately when I attempted to switch over to preact it was exceedingly slow.
What do you mean?
No, I'm saying callbacks did a good job of solving the first wave of problems with async. Then, once we could handle that we discovered the next level of problems. Promises solve that, and now we are on to the level after that. If FLutures solve this level, then we will get to the next level of problems. That's fine, and it's the way software development works. I'm just warning against saying that promises are broken because it doesn't solve a problem it wasn't intended to solve. 
**javascript** *javascript* javascript^^javascript
Well Elm is a hell of a migration :)
I solved. I have to update webpack and other packages :)
I'll never understand why people find it necessary to encircle with their cursor the obvious thing we're supposed to be looking at. It's distracting more than anything.
Doesn't seem right... did you file an issue?
javascript
Glad to hear you figured it out :)
&gt; The alerts no longer pop up and either does the prompt. Someone please help me. In the future try [using the JS console](https://developers.google.com/web/tools/chrome-devtools/console/). It will tell you what's wrong with your code and you won't have to wait for someone to answer.
Looks like a premature javascriptulation
That sounds a bit like fud tbh. Could you specify what patents that would be or where they are declared? I read that Facebook has no claims on JSX, which is licensed under MIT and appears to have no patents file. The React patents clause is a stub, both files, license and patents, haven't changed in over 2 years. JSX is simple XML and even JSX in javascript has prior use in Mozillas E4X. The entire v-dom is based on a single api signature and can be specified in a thousand ways. Lifecycle api's have been done for decades. If the universal principles behind React can be patented then we patent the use of functions, there is no other way to realize `view = fn(state)` and v-dom is just the nested struct that it returns. In a worst case scenario, if lawyers actually manage to patent the use of a function to establish a v-dom, not just Preact goes, most if not all of todays frameworks, even the new ones that try to cope with web components. That would also put Kotlin in danger now and many other systems. 
No, because I believe it has something to do with the synthetic events not translating well which preact does not support.
yes, thank you. I didn't realize so many ppl were unaware of this type of rounding.. if i'd known i'd have looked up the proper terminology my bad. so thank you! =)
Back when I tried using `x+=1`, I actually ran into a bug at some point that was, in fact, caused by that habit. I'd made a typo (something like `x+1` or `x=1`, I forget) that I never would have made if I'd been using `x++`. On the other hand, I've never in my entire life (32 years old, taught myself to program as a teenager, studied CS in college, professional for almost a decade) encountered a bug caused by an increment side effect. Not once. Not in any code I've written, nor in any code I've ever had to review, debug, or fix. Incrementing is such an elemental operation that arguing against its usage just feels daft to me. It's like arguing against using `push`, and saying that you should always use `splice` to append elements.
I mean if you are going to argue something is bad due to your own typos then we should just program in [Whitespace] (https://esolangs.org/wiki/whitespace) and call it a day...
I don't mind so much people blogging about JavaScript so that they get a better understanding of it. I am a big fan of the "learn, do, teach" approach. What annoys me are people self-promoting on medium talking about nonsense with the goal of getting speaking engagements. 
Good resource. p.s. affected not effected
I find that code is more readable if variables are declared upon first use. At any rate, it's becoming a moot point, thanks to `const` and `let` (although function declaration semantics are unchanged).
Maybe items should be an array? [{ "name": "MyName", "img": "linkToImg", "items": [ "name": "Copper", "found": "" },{ "name": "Iron", "found": "Uncommon" }] }]
"Effected Tech" -&gt; "Affected Tech" but otherwise a good article. 
This is most definitely the better solution unless you for some reason need to save them by names but never call them using the names (???)
Yes, there are patent concerns. No, that does not mean big companies are avoiding it. Netflix and Walmart.com, for example, use React as their UI framework along with a handful of other companies: https://github.com/facebook/react/wiki/sites-using-react.
I don't really need the names part, just the name/found within
&gt; Promises solve that, and now we are on to the level after that. The distressing thing is that promises could have solved all the problems they do solve, but without their current limitations. Promises/A+ was a missed opportunity from which the JavaScript ecosystem is unlikely to fully recover. Now that promises are baked into the language we would not be free of them even in a hypothetical future in which the entire community agrees that Promises/A+ has significant problems. 
one of the problems with the sample marko+webpack project is it is not using webpack dev server. strip out the express server and have a pure frontend only project and it would be much more clear what is going on. that is what I was trying to setup
I didn't say it was bad because of that. I said I disliked it, and I said that I *had* encountered a bug that was due to that habit. Those are two separate statements.
If your console.log('fire') is working, the fires place I'd look is in Create React App's homepage setting. And you might need to set your build folder in express.static()
IMO, MDN is more rigorous and well documented. W3Schools should be fine if you are starting, but if you already have knowledge of the language, just avoid it and use MDN.
Haha this is true.
Then you should do what he says and use arrays instead. That way you can call it like this: database[0].items[0].name 
Not sure why you need the outer array, an object should work for that. https://repl.it/F3hu/24 
yes
I'm glad someone else has the same love hate towards medium. On one hand I enjoy that people are trying to teach others, but on the other it's usually unoriginal rehashed, and sometimes straight up incorrect information from a mediocre dev that are trying to gain some following/exposure. I've seen a fair share of articles that are straight copies from articles/stack overflow from a year ago that have zero citation. The ecosystem is less about relevant information and more about self promotion.
See, that's why I don't care about this. If you're using something that FB actually has a patent on, such as GraphQL, then you might have a reason to worry. But if you're just using React, go ahead and bring a patent claim against FB. They can't use React against you because it's not patented and I highly doubt they can patent it.
Why wouldn't you make it yellow?
Hoisting for functions is a basic feature of many languages, though. It's one of those things you take for granted until you're forced to use something that doesn't have it (like C)
I don't know I just saw him put database[0] so I assumed maybe he had several databases in the array. Obviously database.items[0].name works fine if there's only the one item.
Would be nice to add a section for alternative frameworks as Ember.js and Glimmer. It's worth mentioning ember-cli as well.
To anyone wondering, rounding .5 up (the kind we're taught at schools) is technically known as "away from zero" (since it goes down for negative numbers) and the way OP describes is known as "banker's rounding". The default implementation ofter varies... for example MS SQL Server rounds away from zero, but .NET uses the banker's rounding, even though both are a part of the same ecosystem.
I have an mvc project so if I were trying to pass a list back to a javascript or jquery function, would it be able to interpret it? Or would you have to format it as Json before sending it to that function
Read the PATENTS file yourself. It says "if you [...] initiate [...] any Patent Assertion [...]". If you don't intend to bring patent assertions (and most people never will) there is literally nothing to see here. This is classical bikeshedding if I've ever seen it. 
Huh, I haven't tried using PureComponent yet, but without this article I would definitely have fallen into most of those traps. Good read, thanks! (I'm guessing your're the author. captDaylight ≈≈ neondaylight.com)
You're right, probably most of the patents are hold by IBM anyway... But the PATENTS file generate uncertainty, and I've already experienced the "no-go" by legal team several times just because of that. So, in case of Preact, same conditions apply. One way or another, why look for alternatives? It's sad technical merits are obscured by bad press.
Your title sounds like someone was expecting this 
How would you like to format it?
I may be overthinking this, but I *believe* you have your logic backwards. `chance` has an 85% chance of being less than or equal to (&lt;=) .85. With this logic, anything above .85 won't get a value set for `rarity`. Here's an example that would get you what you want. let chance = Math.random() let rarity if (chance &lt;= 0.5) { rarity = 0 // 50% chance (common) } else if (chance &gt; 0.5 &amp;&amp; chance &lt;= 0.8) { rarity = 1 // 30% chance (uncommon) } else if (chance &gt; 0.8 &amp;&amp; chance &lt;= 0.95) { rarity = 2 // 15% chance (unique) } else if (chance &gt; 0.95 &amp;&amp; chance &lt;= 0.99) { rarity = 3 // 4% chance (rare) } else { rarity = 4 // 1% chance (LEGENDARY) } You could also look into switch statements. They're not always appropriate but may be here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch Another thing to note: you should declare `rarity` as a variable once (at the top), then assign it in each conditional, like I did. 
If you have that much trust in the patent system, then by all means, go for it. But the truth of the matter is, our patent system is completely screwed up and no company or individual can say with 100% certainty that their patents might not collide with Facebook's patents at any point. So the safe way to go about things is to just stay away from React (and other Facebook open source). It's the farthest thing from bikeshedding actually.
JSON is the easiest, because there's a built-in parser in the core language: [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON). XML also isn't bad in the browser since the DOM API has a [DOMParser](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser). But javascript can be programmed to read just about anything else, including something binary. If you have something specific in mind, such as a well known format, you can probably find a library to parse it for you. And if not, or if you want to use something you developed on your own, you can [write a parser yourself](https://medium.com/@daffl/beyond-regex-writing-a-parser-in-javascript-8c9ed10576a6) (personal note: I just googled that; no idea if its any good).
You do not have to check, if the chance is greater than 0.5 AND smaller or equal to 0.8, since the first if-branch already takes care of `chance &gt; 0.5`. Just `else if(chance &lt;= 0.8)` would be enough.
Why would you ever lay out that page with React in the first place?
That's going to be the crux of any solution, random number generator, but I'd structure it a little different. function getRand(total) { return Math.round(Math.random() * total); } function randSelect(items) { const total = items.reduce((acc, item) =&gt; { acc += item.rarity; return acc; }, 0), numb = getRand(total); let tally = 0, selectedItem; items.forEach((item) =&gt; { tally += item.rarity; if(!selectedItem &amp;&amp; tally &gt; numb) { selectedItem = item; } }); return selectedItem; } const items = [{ rarity : 20, itemName : "item 1" }, { rarity : 80, itemName : "item 2" }, { rarity : 100, itemName : "item 3" }]; console.log(randSelect(items)); https://jsbin.com/fahequs/1/edit?js,console,output
Well I knew I was overthinking *something*!
Inferno is quite good, except for the TypeScript support. Which is surprising because Inferno is written in TS.
I too bought into the hype that typescript was taking over until I realized that very very few libraries actually get written in typescript. i think if one knows js well, has good TDD skills and discipline, then typescript becomes a bit of a meh. it's great though for teams of people with Java background who don't know js and can't be bothered with js quirks
Your API routes should come before your "root" route, otherwise any GET request to your API will be matched by the "*" in root, and never make it to the API routes. You will need to uncomment the static routes otherwise your built assets won't be served to the client.
Surely this would be better off at /r/reactjs ?
I too will stick to js because the pro he mentioned is actually a major major con. changing a member inside an object shouldn't lead to a cascade of effects elsewhere, that's just terrible, whatever the hell happened to encapsulation and decoupling. but that's what you get with folks who rely on static types and ide squiggles. 
Having the functions at the top level rather than in closure is a way to enforce purity (whereas having them in closures might end up with dependencies being passed in via the closures as the code grows). You can definitely reverse the order of things and mechanically things will work the same way, but what I'm saying that this coding style exists and is used often when doing top-down style programming because that's considered readable in that style.
I'll go ahead and dismiss the dogma of static typing. and his is an opinion and a potentially terrible one. static typing and an ide, aka squigglies driven development,aka change a member inside an object and a cascade of things break elsewhere, lead to terrible software. but it's cheap to hire terrible developers so it can have an economic rationale
Gah, I wouldn't use class instances for a million things. That should be a flat typed array. If you have thousands of things you could use POJOs and operate on them with functions. You might only need encapsulated state for a handful of things, in which case it's not really going to matter. It's nicer to deal with event handlers or other callbacks in a closure as you won't need to wrap them in a arrow functions.
From the point of file size yes, but from parsing/runtimeperformance maybe. It can be, cause my react project is bigger, react feels heavier, like i have less time to do my stuff. Edit: my personal opion, maybe i am too dumb to craeze efective react code 😂
Dude I swear if I see one more of these "Hey group your stuff by feature but we will 100% leave out how the features communicate, the weakness of organizing by features, etc" I'm going to flip. Redux is built on the store and the idea is all parts of the application have access to it. In the same way that different pieces of the store are not split out for you to explicitly require (even if you split them up, you still have access to all of them and this is by DESIGN), how do you then justify batching up features like this? Let's say you have an actionCreator you have in one feature, then realize you need the same one in another feature. Where does that go? Let's say you have a constant you use in multiple reducers... where does that go? Let's say you have selectors you use all of the place... where do those go? By the time you've finshed, you will have essentially built out a top level selectors, actionTypes (constants), actionCreators that are for use everywhere... but now who the fuck knows where something is at now? Are you really going to sit there and bounce actionCreators from feature scope to globalScope as you use them one place vs many places? (same for selectors, actionTypes, what have you) At that point you're just fucking around with the structure just because? Here's some advice: Split up your reducers into files (these are somewhat loosely based on feature but more so domain of concern), but outside of that, stick with the basics, unless someone actually goes out of their way to adequately explain all the perceive pitfalls of feature based development and how to sidestep them.
Let's look at everything that must be true to make being scared about this situation even remotely rational: 0) I use React. 1) I'll someday have a software patent. 2) That patent will be for something relevant to FB's business. 3) FB doesn't know that it's already patented. 4) FB doesn't attempt to patent it themselves and find out it's already patented. 5) FB violates my patent. 6) I find out that FB has violated my patent. 7) Requests to FB that they cease and desist fail. 8) The patent violation somehow hurts me financially, or triggers me enough to stand on principle. 9) I have the will to sue one of the biggest companies in the world. 10) I have the time to sue one of the biggest companies in the world. 11) I have the money to sue one of the biggest companies in the world. 12) I forget that suing them will void my React license, so I don't first replace it in my codebase(s). 13) I sue FB, voiding my React license. Now, recognize that none of you will realistically ever make it past #1, let alone to a point in the perfect storm where the clause becomes problematic for you.
It is. That comment is retarded. All variables should be declared at the top of their active scope -- this is a pattern that made both the code easier to read (you just track your variable through the closure), and made the language behavior clear (hoisting). Actually advocating a top-down read of asynchronous js code with in place variable declarations is just idiotic and the exact thing we were aiming to get away from. I suppose to some 'let' meant some allowances, but i'd be weary of any code not written to a very, very, strict standard.
Can something be truly random? I don't know. But some functions can be more random than others. I bet it is not very hard to predict what value is going to come out of a Math.random call, specially if you know the return of a previous call. Using predictable random numbers in cryptography is not good, that is why crypto libs have alternative methods for generating random numbers.
Math.random is a peudo random number generator (PRNG). A property of PRNGs is that they have a fixed internal cycle length which means once you generate a certain amount of "randomness", you go back and generate the same thing again. In order to be cryptographically secure, a random number must not leak information about what the next random number will be. Since this is not the case for a PRNG, a different source of randomness is needed (such as gathering entropy from hardware timings or other unpredictable things or hardware that measures physical properties that behave randomly).
Thanks for your comment and thoughts around this structure. If you have not yet, please take a look at the example and how the features talk to each other / share resources. Generally when arranging an application by features, you still can have a notion of shared items (like constants, for instance). Additionally, if you treat the index.js of each feature as the API to other features and export things that you want other features to be able consume, there are very few problems. I am personally using this type of structure on a very large application and have had very few problems.
I guess I would like to format at it as just ID and text if that makes sense? Here's a code snipped of both the jquery and controller method $(document).ready(function() { $('#Licenses').select2({ placeholder: "Select license(s)", multiple: true, width: 450, initSelection: function(elem, callback) { callback(chosenLicenses); } Controller method var selected = asset.Licenses; string selectedLicenses = JsonConvert.SerializeObject(selected); ViewBag.selectedLicenses = selectedLicenses;
ok I didn't notice that, my bad. It's actually not that bad. I'll reconsider it. Cheers.
That's all fine and well for solo devs, but think about the dozens of companies lol I can't even say it with a straight face fuck their patents
If you are working for yourself, you are 100% correct. However, the vast majority of people don't. The work they create represents the company they work for. Companies horde patents like nothing else. If you have knowledge of patents, you know that most of the time they overlap and are very broadly worded. The patent system in this country is horrid and needs a LOT more checks. So with that being the case, there are a LOT of companies worried that their patent will overlap with one of the thousands (if not tens of thousands) of patents that Facebook holds. The chances of this happening? You are right, probably little. But that's not how it works legally. You look if there is even the slightest chance of something like this happening, and if the possibility is even there your legal team will suggest you move away from using it. Why would a company invest a ton of resources into something that has a possibility of being taken offline? The answer, they won't. There are quite a few companies (large ones and small ones) that are moving away from React for this very reason.
"If you want a 'yes', don't go to Legal!"
haha yeah, it's cause I don't really know how javascript works all that well. I just posted some of the code above, it's coming from a controller method and I am passing selectedLicenses to the jquery function, but I'm wondering if the jquery function will be able to read/interpret/understand it? I know it says chosenLicenses in there, and thats because I have this code before the jquery function var lets = @Html.Raw(ViewBag.selectedLicenses); var chosenLicenses = lets.map(function(license){ return {id: license.LicenseID, text: (license.Product.Name + " | " + license.ProductKey)} });
btw what would you call the things inside the select2 such as placeholder, multiple, width, initSelection?
In the bigger companies, their lawyers are retained full time and have one job: don't let us get sued. When that's your job, any whiff of potential lawsuits is met with swift and ironclad resistance.
👍
what would you recommend for someone who wants to draw barcharts, pie charts and line graphs in a web application but no need for real-time? i don't have a background in js and found the js.d3 learning curve too high. i too would like to show data in tooltip mouseover and don't need to manipulate the visualisation once the graph has rendered. i'm looking for something easy to learn. thanks
Good article. Note that if you're using `react-redux` then it's pure by default because the [`connect()`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) options argument has a default of `pure:true`.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [reactjs/react-redux/.../**api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options** (master → fd81f18)](https://github.com/reactjs/react-redux/blob/fd81f1812c2420aa72805b61f1d06754cb5bfb43/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmb3zv1.)^.
That's an `Object literal`. Placeholder etc are the object's properties. 
`create-react-app` installs itself as a PWA by default already so I don't see the point of this article (aside from testing with lighthouse etc.)
wait what is an object literal? also the select2 is a jquery library right? just want to make sure. https://select2.github.io/ **EDIT ah yes okay I know now, what an object literal is
You may want to brush up on your JavaScript
from all the articles I've read on this no one has been able to confirm that any part of React is patented. 
 I've seen a number of people argue that features (and especially "ducks") should be completely encapsulated and independent, and if you _really_ want to go that way, you can. To me, it's more about just having colocated files for a given concept, which also makes imports between those files nice and simple. I'm okay with different features cross-importing from each other, and also don't overly care about having a "public API" for each feature. In my own app, I routinely have files in FeatureA that do `import {doThingB} from "features/featureB/featureBActions"`. I also do have a top-level "common" folder for stuff that truly is generic as well, such as a `&lt;Button&gt;` component.
When you're in a bootcamp, you are trying new things every day. In the real world, you will have more time to practice the same patterns over and over. As you get good at the fundamental patterns, you start to identify other, more complex patterns. This process repeats itself as you learn a programming language. You are still in step one. I've been using Javascript for 3 years and still barely feel like I know what I'm doing. What are you feeling is normal.
thanks for commenting on all my posts
I agree. Or at least change the title for /r/programming: "When to use React's Component or PureComponent". The article didn't even say React until the tag at the very bottom of the page. So much assumed familiarity.
Let's be honest: if Facebook ever started going after GraphQL users with this patent people would fight it with prior art and the fact that Facebook themselves pushed GraphQL adoption. Then if the legal challenges failed everyone would just adopt the next closest thing that doesn't violate the patent ... and then after all that Facebook would suffer a massive PR disaster among developers. It'd be a lose lose for them. I'm not saying that there couldn't be some circumstances under which Facebook brings this patent to court, and there might well be some people who need to worry about t his, but I don't think most Graph QL users do.
I'll put a Full Disclosure but it's worth noting I use all frameworks (vue, angular, preact, react, mercury). I'm trying to move away from being identified as a community member of one community and focus more on all of JavaScript in general. I just didn't want to make it so public like Kent C Dodds did when he left Angular. Same goes for the Company which changed (name) to cover all of JavaScript
This is normal and okay to feel. If you enjoy JavaScript, keep doing it. Just remember that you're learning a new language - so what you're learning right now is comparative to learning how to write in English. It takes time to see how you can use it in situations, there will be hard spots that take a lot to stick, but if you want to keep doing it I highly suggest it.
Tip: you would have give up a lot sooner if this wasn't for you. To me, it looks like you're just burned out of it. Just take some time off coding and try something else (Music, gaming, arts?) just to ease your mind. This happens to everyone, you don't have to rush yourself. What are your goals? do you feel like everything that you're learning will be that useful that the only way to reach it is by rushing through? It's impossible to be the best of all things in such a wide topic as programming, you have to learn how to learn and take your time to improve. Trust me, you'll get better at it as time passes. Sometimes I don't feel like coding at all. I just spend time doing random stuff and at some point I get sucked in back again. It sounds like magic, maybe it is, I don't know. You'll be sure that programming is for you when you're out of it for some time and you'll get this feeling that you could be learning something or improving your skills. I guess that we feel like that because programming is like having super powers, you can never grow tired of them :p. Just take some time off and, as they say: Learning programming/something new is like a marathon, not a sprint. Best of luck!
Full Disclosure added to this article. I'm adding it to the other one
We're all floundering. All the time.
The main thing that I'm wary of with Preact is the lack of the synthetic event system. It exists in React for a reason: to normalize inconsistent event behaviour across browsers (similar to how jQuery does in its domain) and fix edge cases. Maybe that's not as big of a concern these days, but I'm wondering if there are people using Preact and assuming their app works fine on IE when there are actually bugs. I think I'd rather have the extra assurance. Unless I'm completely wrong of course, in which case I'm happy to be enlightened.
Having attended a particularly selective bootcamp, you have to trust the process. At least in my situation, a lot of the things you are finding difficult now will be repeated, over and over, and built upon in further lessons. That means there will be elements of closures and recursion in most of the concepts you're learning. So even if they aren't familiar to you now, they will slowly become second nature as you have to continually use them to build upon future lessons. You have to look at it more like doing pushups. If you're just getting into doing pushups, you will NOT be able to do 100 per day. And if you try, you'll be overwhelmed and completely sore. But if the maximum you're ever required to do is 100 per day, you'll eventually get there and then be able to do other things afterwards. Everything isn't really meant to click as soon as you learn it. It's meant to stew in you with repetition until it's second nature. You'll at some point realize that the things you're struggling with now have become easy. Since you're learning new things that use the things you previously struggled with as a component, you don't realize you've been practicing them all along. It will be a surprising and gratifying feeling when you realize you're comfortable with something that used to give you anxiety. That being said, bootcamp cant still be quite difficult, so if you ever find yourself at a point where you just can't make sense of it, or need help, reach out to instructors for 1 on 1 time. If that can't or wont happen, feel free to reach out to me. I'm happy to lend a hand to someone going through your situation. There are many times when people who are very familiar with a subject teach it in ways that are more academic than people who have never experienced it before can understand. 
I've used highcharts in the past. 
I'm literally in the same shoes, minus having been at the top of my class..well..ever. Every time I'm lost (which is more frequent than I anticipated) I go through an array (pun) of emotions beginning with frustration on figuring out why something isn't working, to whether or not I made the right decision spending thousands on a boot camp and if I'll really be happy doing this as a full time gig, to taking a break and reminding myself why I decided to go this route, and finally (after break) I see where I messed up, fix my code, it works, then big sigh of relief because I figured it out without having to ask any of my classmates for help. I'm also not nearly as good as some of my other classmates, and there are times when I get to help them. It's a good reminder that everyone else in class is in the same shoes. And although a few of them don't show it, a lot of them are going through the same internal struggles as you. And I know it's cliche but..if it was easy everyone would be doing it. I constantly remind myself of this as well. Some people spend years learning this stuff, and yet these boot camps are only months long. You'll get it. I'll get it. It just takes time and dedication. The end game will be worth it.
Tip: YouTube whatever you don’t understand. Closures and recursion can make Zero sense when explained to you by 9 out of 10 people and the 1 person might explain the call stack in a unique way and you just get it. If I can learn it, you can. Sometimes you just have to find someone to explain it the way that connects the dots to you. If I have learned one thing as a programmer, it’s that I’m not the first one to have almost any question. You google until you can’t anymore and even then you probably weren’t googling the right thing. There are answers out there that make sense to you but unfortunately there’s a thousand answers that don’t.
I am a basic fact
[YrDKmaJS](https://github.com/getify/You-Dont-Know-JS/)
I failed to learn programming more than once, now I'm a software engineer. Don't get too stressed out about it. As far as recursion goes, start with the simplest recursive loop, one that is just a for loop and then expand from there. Closures can be trickier, more important than being able to build one is just understanding what they do and why, when you get to a real world scenario then you remember you need to use a closure and you can figure it out from there. Keep your head up.
I think it is getting upvoted because people in the subreddit want to learn more about hoisting and closures, not because they agree with the title
&gt; why should I continue on a path of something I suck at? Because that's the only way to learn any new skill. Ask yourself this: How many years did you study english before you were comfortable with it? Also TIP: If you reach a stage where your eyes glaze over, take a break. More often than not, your brain will figure out what's wrong with a piece of code while on the break. Another pro tip: If your eyes glaze over your own code, try breaking it up into smaller routines. One of the goals of programming is to break things down into manageable pieces and make it as readable and simple as possible. If it's not understandable, chances are that it's not designed well. EDIT: Added text
We don't use Node so I'm not aware of any backend frameworks that are actually written in Typescript, but I'm sure that there are typings for most frameworks. e.g. [express](https://www.npmjs.com/package/@types/express), [koa](https://www.npmjs.com/package/@types/koa), [hapi](https://www.npmjs.com/package/@types/hapi). So I guess the answer to your question is maybe: yes all of them (sorta). Edit: If you're looking for a popular library written in Typescript to learn from then checkout RxJS.
I disagree about the complexity and readability of those examples, but the idea of "write efficient code if all other things are equal" is fine; I apply it to my own code as well. Regarding my opinion of the above examples, I think the question then becomes one of what your team prefers.
Accept that coding isn't for anyone and just put in the hours. Its a life long enemy as much as a passion. Its painful at the beginning -- given your pointed approach I suspect its even more difficult. 
&gt; Unless you have a really specific reason ... Also check this out: https://www.reddit.com/r/gamedev/comments/3odw15/how_do_games_keep_track_of_thousands_of/cvwe5w6/
Though the internet is full of javascript tutorials, it helps to focus on one or two main sources of information. I would recommend [the MDN site information on closures](https://developer.mozilla.org/en/docs/Web/JavaScript/Closures) Also check out [this lesson from codecademy on recursion](https://www.codecademy.com/courses/javascript-lesson-205/0/1) and work through the whole section. If you still need help, post it on reddit and you will be surprised at how many folks spring up to help you out.
Correct.
&gt; The patent system in this country is horrid Perhaps, but fear alone does not make for a rational argument. It seems you are ignoring, intentionally, the logic of the issue to deliberately assert your fear. The choices here are clear: 1. Don't use React 2. Use React, but never sue FB for patent infringement Neither complicated nor scary.
Nope
No; I'm not referring specifically to truly pure functions, wherein changes to external systems is considered a side-effect. This includes things like writing to a log file or the console, writing to a database, sending HTTP data to a client, etc. If any application remained truly pure, then it would serve no purpose. I am referring to state changes to anything outside of the object's own responsibility for their own state (if they have any). /u/Akkuma provided an example of what I mean.
Thanks for the help. Does that actually work for you, even with the change? I don't mean a literal copy and paste of the README, because that won't work as-is without some additions, but I mean is a subroute like the one you mention working? I wasn't able to get any variation to work--even preceding the path with '/users'--before I posted. Do you (or anybody) have a simple working example you could post? A simple route with a nested route?
Are you using the router with subroutes? I posted below--can't get it working correctly no matter what I've tried. I've been very interested, for the reasons you've mentioned!
I use Flow in the backend. I don't know of any backend libraries that are *written* using Flow or TypeScript, but all the major ones will have type definitions for either one which you can get using FlowTyped or DefinitelyTyped. Flow and TypeScript still have a lot of usage in the backend, even if it isn't used all that much with library authors.
This is so true. 
&gt; I agree silent failures are a big problem. &gt; I don't understand what an "expected failure" is. That might be a good place to start.
Thanks for clarifying, and I appreciate your perspective on this.
Yes and I would 100% recommend using TypeScript. You don't need the framework to be written in TypeScript. Any Node based framework will work. I've built serverless (AWS Lambda) and express applications using TypeScript. There are type definitions available for most popular NPM packages but even if there isn't you can still use it (it's less useful though).
Again, that is completely fine for a solo dev or a small business with little to no patents. Any company with patents won't think that way. It's not about fear, it's about choosing what's best for the future of your company and weighing the possible outcomes. If you really want to play the "don't base it on fear" card, then you could say the same for Facebook doubling down on forcing this patent. Why don't they just let it go? Because they know that the patent system is utter shit and they are just protecting themselves. Right now they are just trying to damage control and put it in as good of a light as they can. I don't blame them really. But to say dropping React is due to fear of legal action is just plain wrong. 
This is normal, even for professionals. 
It's perfectly normal to feel that way, every programmer has felt that way at one time or another.
I feel like its a true random number generator rather than a cryptographically secure number. Why is called cryptographically secure?
&gt; Can something be truly random? I don't know. http://dilbert.com/strip/2001-10-25
People who write novels get stuck too. And who knows, maybe you don't learn well from a competitive bootcamp. I know I wouldn't.
If it gets you so depressed, it's better to stop and maybe try again in the future to see whether you cope better or not. Sometimes your brain just need some time, and if you stop for a few days or weeks then when you go back you will see everything clearly and advance faster. If not, it's probably not for you, and unless you enjoy feeling helpless you should try something else.
Maybe it isn't for you. You wouldn't be the first. Understand that all the positive replies in this thread are from people trying to be nice. That's well and good but they don't know you and neither do I. What I do know is it's quite cruel to encourage people who simply do not have the capacity. It would be just as cruel to tell unattractive (or even average looking) people they can be models no matter how well intentioned. I'm not trying to be mean. What I *am* saying is there are many people who cannot code well no matter how much they try. You might be one of them. Also, from your post it doesn't sound as though you particularly enjoy coding - which includes enjoying the struggle. That's more indicative than the actual struggle itself.
Good point.
Can you elaborate?
You really need random people to tell you why you should continue? Everyone sucks at everything, to begin with. No one is just randomly amazing unless they are the anomaly of their generation. Lots of people would kill to be in a position in that boot camp sucking and being a sponge and learning everything they are trying to teach you. Either take advantage of the opportunity you find yourself or don't. Don't look to random people to tell you why you should continue. Like, quit if you literally have no idea why you should not give up.
The API only promises to be cryptographically secure. "True random" seems to have a nebulous definition. 
Are you doing App Academy? It sounds like App Academy.
Unless you're spending all your time fixing prod. Then you're reluctantly plugging the holes in a sinking boat...
Being "gifted", especially if you grew up this way, is often a struggle when you encounter something that is truly difficult. Programming computers is definitely something that qualifies as challenging, even for somebody that has been had academics come easy to them throughout their young life. Concepts like async, recursion, and closure are **hard af**. I've met a few savants that were seemingly able to just get it, but for most of us it's a slog. It will click. It just takes some time and effort. I've seen it again and again. So, sure, you can quit and focus on easy topics, but the challenge is what makes it worth it. If it was easy, everybody would code and we'd make $8.59/h. ;)
Yeah it's supposed to be easy. You should definitely quit.
I'm the context of a very competitive coding bootcamp, talk to your mentor / guidance person about this. If they're worth a grain of salt they'll understand that burn out is real, and hopefully you can get a couple of days off. 
You should not give it up. This is the kind of thing - the conceptual, somewhat abstract concepts that go along with functional programming - that is just a different kind of thinking than a lot of people are used to. They're easy enough to understand, but you do have to think differently about them. My own problems with understanding when I was a young programmer, way too many years ago, were around polymorphism. I just couldn't get it. I used to talk to myself a lot when I was driving alone, thinking that vocalizing would help, and one day after several weeks of trying it just clicked. I figured out how to think about it in a way that made sense. It's hard to do that in a boot camp when you don't have a lot of time. Sometimes it takes time to just ruminate over things until you discover how to understand them. Not getting it in a high-stress, fast-paced environment seems completely normal. Moral of the story: talk to yourself a lot. It helps.
GraphQL is the second coming of the ORM. Writing GraphQL queries appears to be pleasing and has a sensible value proposition and elegance. But implementing GraphQL seems like a giant pain in the ass and nothing more than an impedance mismatch with your underlying data and services. "What if all data provided could fit nicely into this abstraction, then wouldn't that make things easy?". Sure, but the cost of that fitting is 0? It solves far too few technical challenges for the cost of implementing it. Maybe GraphQL subscriptions will actually be a big value add? Since the transport is actually something most people *want* abstracted when doing realtime. The hard push from both Facebook and MDG are what are propelling GraphQL. This is kind of a rambling post, but this is a technology I'd hold on for technical merit alone, not just the OP's patent concern.
The main downside I find with pures, is that (at least for now) all stateless components are by definition not-purecomponents. I keep my stores returning immutable arrays/objects and theoretically it'd probably be marginally faster if it shallow-compared the props, but it doesn't outweigh the convenience of stateless components via arrow functions. What could be cleaner and more nicely declarative for presentation logic, than a simple `const Hello = ({ name }) =&gt; &lt;div&gt;Hello, {name}!&lt;/div&gt;;`
Interesting concept, but why not include SVGs instead? Pure CSS images always felt like a hack to me, and unless I'm mistaken, SVG could be used with React.
"Using GraphQL? Why GraphQL Now Owns You"
I've added a Full Disclosure to the top of the article
I worked on a project that already had both React and legacy Angular, and some script wizards from one of those cult-like consulting companies decided to throw yet another moving part into the system, seemingly "Because GraphQL." Then they had to start fixing the performance problems (while adding even more spaghetti to the bowl).
Keep poking around and make stuff on your own time. Read articles, learn best practices, keep up to date and enjoy yourself. I felt just as confused for a few years before i learned to stop taking "Introduction to JS" courses and just *make* things.
It's a natural reaction to retreat to things your are comfortable with and already good at when faced with mental frustration. Your mind sees things you already understand as easy and new things as hard. Just be very humble, don't skip over anything. Go step by step and read every tutorial you can to see how it's done and why it's done that way before breaking off and experimenting with your own projects, especially when learning a new language or technology.
Uhh ... the spec has an [open source license](https://facebook.github.io/graphql/). How would they be able to enforce patents when they have licensed the spec to everyone without restriction? &gt; Copyright notice &gt; &gt; Copyright (c) 2015‐2017, Facebook, Inc. All rights reserved. &gt; &gt; Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: &gt; &gt; * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. &gt; &gt; * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. &gt; &gt; * Neither the name Facebook nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. &gt; &gt; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Yeah it's pretty funny that GraphQL evangelists claim a lighter weight protocol will result in better performance But you give users a pretty much arbitrary ability to query nested relationships... that won't add any load to your server... Same crap happened with ORMs but you're handing the ability to more-easily write cpu/read intensive queries to all your API consumers (instead of at least being in control of all of the bad behaving queries that you could possibly concoct with an ORM). 
There are many programming concepts I've learned where initially stared at the screen for hours, managed to turn something in that works, get an 'A' on the assignment, have no idea what I did, then totally get it a day later. Or when reading a blog post, or working out, or writing random code - perhaps totally unrelated to the concept. 
+1 Awesome. Deleting my comments. 
the person who wrote the article is a Patent lawyer so it's probably better to comment in his article
You said it yourself! This shit is hard. :) 
If coding isn't for you, it isn't for you. Move on.
I'm a former boot camp grad. Here's some thoughts (excuse brevity, my pregnant wife is sleeping on my right side and I'm swiping text with my non dominant hand). Closures are important, but they'll grow on you. They are very useful, but you really need to know at least this - they let you control how things are accessed in JS. Other languages have more explicit ways to make variables and 'scope' private. So think of closures as partitions, or even rooms, or what ever 'closed' off metonym you'd prefer. Recursion is dandy, but really not a thing people use much in JavaScript save for high level stuff - The language doesn't really need it, so of course it doesn't really click. Now say you were forced to do all loops via recursion then it'd be a different game. Or if partial application was absolutely necessary when creating functions, you'd be forced to really understand closures. The best thing you can do is not kick yourself, and work hard on everything, but even harder on the things that DO make sense, so that you can stretch your talents with these skills even further and build a fun project you can showcase. Also, when in doubt, just try to break stuff, and look at the logs. If you learn to have fun with that process, you're gonna be quite alright. TL;DR - Closure knowledge will come, but keep reading and testing it. Recursion can be fun, but not necessary in JavaScript, at least not at this point in your career. PS - I work with two super smart engineers, who are crazy smarty pants about C++, Python, PHP, and JavaScript. They know what recursion is, but don't mess with it. It's not everyone's cup of tea, and it doesn't haven't to be. Good luck! 
RandomSource.getRandomValues() doesn't have to generate truly random values, but it should offer some guarantees that Math.random() doesn't have to offer: * The seed should come from high-entropy system events (say, voltage fluctuations or time between keystrokes) * If you have a list of already-generated numbers, there should be no fast-executing way to predict the next number. * If you can capture the internal state of the generator, there should be no way to guess the numbers that were generated before that point. There are pseudo-random number generators that meet these requirements and there are pseudo-random number generators that don't.
Hey. I'm working as main lecturer in one of largest coding bootcamps in Poland. Just don't give up. That's most important thing. It took me more than 6 months to understand stupid absolute positioning but then came "AHA!" moment. You just need to wait for these moments and everything will be better.
**Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year!** \#1: [The Entire JavaScript Language in a Single Image](https://fossbytes.com/wp-content/uploads/2015/09/infographic-the-entire-javascript-language-in-one-single-image-491250-2.jpg) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/675fk4/the_entire_javascript_language_in_a_single_image/) \#2: [This pretty accurately describes my feelings on my JS learning journey so far.](http://imgur.com/zKJt5rb) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/5k71cn/this_pretty_accurately_describes_my_feelings_on/) \#3: [Github Repo with 100+ Free resources to learn Full Stack Web Development.](https://np.reddit.com/r/learnjavascript/comments/5zse5u/github_repo_with_100_free_resources_to_learn_full/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I just want to chime in with a few points. 1) For many students, there is a serious flaw with the way bootcamps work. Many of the smartest and most creative people can't work more than about 4-5 hours a day before checking out mentally. It's a flaw of logic that many think putting in 9-10-12 hour days is productive. More hours imply more production, right? Studies have shown otherwise. Productivity goes negative. This applies to learning too. 2) At the best bootcamps, you are competing against many people who have really prepared to be there. So, while this may be your first exposure to recursion or closures or whatever, it's likely many students have seen that before and struggled with it. This doesn't mean you're "at the bottom of the barrel," just that you're temporarily behind an eight ball. 3) I can't say whether you really suck at this or temporarily suck at this or just aren't enjoying it. But, if you find after studying on your own for a while and working in the field, you hate it, then there is nothing wrong with pursuing something you enjoy more. 
Hey don't give up!!! I remember having to write something and needed an instructors help after working on it for a week. When we presented everyone else's were clearly showing we were all having issues and mine turned probably the best but the entire time I was thinking I was going to fail that project. Please don't give up. 
&gt; why should I continue on a path of something I suck at? Do you want to? It took me a fucking bunch of years writing code to solve my own problems before I actually understood just wtf I was doing, beyond just following instructions and code hints. I was pretty good with graphics (AI/PS), but what I really wanted to do was write software. The key is: don't give up if it's something you really want, or move on to excel in another area if *that's* what you want.
be descriptive with what is challenging for you and break the problems down into questions you can test out in the console. if you don't know where to start, take the most common types of examples and create your own variations of it and build on it till you feel like you know what works and what doesn't. By understanding what closure and recursion can handle, you get a better sense of what they are.
You might consider a more oop oriented language before giving up on programming (Python is great for beginners in my opinion), then circle back round if you grok that. JavaScript these days is very, very big on functional programming, and depends on a lot of incremental changes to the language and libraries over the past decade. If you were programming it for the past decade, JavaScript is in a great place right now. If you haven't, there is a massive cognitive load to work your way through. In some ways, FP makes a lot more sense for beginners than OOP, but the implementation in JS is not intuitive (in my experience). There's a massive surface area in the language itself and it's normal to feel like you're navigating quicksand when learning it. On the flip side - why do you want to learn it? If you are good at other things, and not enjoying programming, you may not be wrong seeking more fulfillment elsewhere.
If you feel that you can benefit from it and take something valuable with you when you leave, then why not continue? Learning and competition are two different things. Just because you can't win doesn't mean that you can't learn. So what if the others learn faster. Maybe they have been at it longer. Maybe they have spend years learning what you have to learn in a few weeks. 
Here's a patent on GraphQL https://www.google.com/patents/US9646028 
you can create an issue in Preact with these questions
What bootcamp are you at?
Don't quit because something is hard. If you hate it, find no joy or reward in it, then quit for that reason. I'm speaking from my own experience here. I'm an average programmer, nothing special, I've never had it come easy, and I've made a huge amount of mistakes. I've been let go from roles, I've had projects suffer because of my slowness at times. But I was also promoted to a senior role. I was CTO of a startup before it tanked (for non-technical reasons), I was offered management roles. I've sort of settled with a senior architect role because that's what I enjoy most, but I still struggle to learn new things, things still don't come easily. But I love the work, I love the challenge, and I push myself to excel even where it doesn't come naturally. If you love the work, you can do the same, don't worry about how quickly you learn. Being on top of your class just means you're faster at learning. It doesn't mean you're better at learning. If you love it, you'll go even further, just give yourself the time.
What? I can't hear you from the sound of PagerDuty ringing the phone
Preact isn't infringing on React. However, if you are really concerned this would be a good question for a lawyer that specializes in these types of questions.
Check Learning how to Learn on the Coursera https://www.coursera.org/learn/learning-how-to-learn It will be hard until you understand it and pack into a "memory chunk". After that, you will use this newly acquired knowledge effortlessly. It would hlpe if you experiment in the console, node or coderunner https://coderunnerapp.com/ to understand the behaviour better. Once you understand how something works it will feel like the giant ball of the unknown in your head is shrunk to a small piece of a puzzle: "oh let's close over this to curry arguments".
From experience, becoming a great programmer takes many years!! I'm still not even close to that level myself. It is not a sprint, it's a very slow race. I feel your pain though because I have always excelled in all things IT/CS but coding take all of my patience and more time than I would like. Spend more time on mastering the foundational pieces if you're struggling with the advanced stuff. I have wasted so much time skimming through the easy stuff I felt I understood well. When I started trying to tackle the advanced topics it was very discouraging when I struggled. Schedule time for breaks regularly, work on perfecting one small thing, then take a break. Figure out what type of breaks help you to relax and stop your head from spinning. I tend to close my eyes and focus on breathing. I have a hard time with this because I tend to hyper focus on the things I do. If you're stuck on something then discuss it with other people, even if they know nothing about your problem or even programming, bouncing ideas off of others will help you to solve the problem. I wouldn't give up. I would just change your approach. Implement some strategery instead of blitzing it.
No pain = no gain.
Redux-persist anyone? 
If you don't have a backend server couldn't you just use local storage?
That is normal to feel like that. Biggest tips: 1.) Stay calm when you feel like you can't figure it out. Zen out, learn what you have to do to not get flustered and worked up. 2.) "It's not a matter of if it can be done, it's just a matter of how will I get it done." Because I assure you, there is always a way to get it done. This re enforces item 1. 3.) If you're stuck for over 45 min you need to switch projects because at this point your brain isn't going to see the syntax you're missing. Come back 30 minutes later and you'll be amazed at what you didn't realize you were over looking. 4.) Get a coding buddy. Having someone to reciprocate with is priceless. Gluck man :)
First lesson of web development: never use file:// urls to test your code, always serve it via some sort of server. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [IainMcManus/FlagAndCountryData/.../**Currencies.json** (master → daf5c4b)](https://github.com/IainMcManus/FlagAndCountryData/blob/daf5c4bb90aad977ebcf0b02f470b511e2f5dbf7/Currencies.json) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmbhd41.)^.
I want to tell you my own personal experiences. In 1997, I went to college and tried to major in computer science. I lasted a single semester, because I couldn't handle the math courses. At the same time, college was trying to teach me about the underlying theory without letting me *actually try things*. It would be like trying to become a master carpenter by studying botany. Is there overlap? Sure. Is it the most important skill? Hell no. So, anyway, I figured that I worked harder on computer science than I ever did in my entire life, and I was floundering, and I quit. I switched my major to history. Fast forward to 2014. I had taught myself HTML and CSS (actually before I even went to college) so I ended up doing some HTML and CSS for an anti-corruption group that was headed by Prof. Larry Lessig. Nothing I'd consider programming, but just stylesheets. As it turned out, (long story) when Larry needed someone to build the infrastructure of the Mayday PAC, I got dragooned into it (after everyone else said they couldn't or wouldn't.) I built the site, it raised a quarter million dollars the first day - just from googling and hacking and forcing WordPress to do things it was never meant to ever do. The site went down, of course, as it didn't scale. But a whole bunch of engineers - some working at Google and Microsoft and Amazon - got together on IRC with me, and we all came together and fixed the site. From then on, I followed their lead and worked with them to get everything moved to a static front-end and python-based backend on Google App Engine. The result was that we raised $11M to fight corruption. What was really quite interesting was that I loved it. I had fun doing it. (I also stressed myself out about it, but still, on reflection, I loved coding.) And the engineers all noticed that I was quick to figure things out, that I was asking all the right questions... in short, they pointed out to me that I was a naturally gifted software engineer -- something that I had never been told before. I eventually decided to go to Hack Reactor in 2015. And yes, I struggled at times (especially with callbacks) but I was able to move forward. I wasn't the one who was the most burnt out - my thesis teammate, Peter, was saying that he still didn't get it a week before graduation. Peter was actually great, he just couldn't see how good he was at the stuff he was good at, because he focused on the frustrating bits. Last I heard, he got on the ground floor of a startup and has been kicking ass ever since. Me, I now do occasional guest lectures at Hack Reactor and I'm working as a Sr. Front-End Software Engineer (with some full-stack work) and training to become a software architect. Which I'd probably be right now if I didn't let my doubts cloud my judgement in 1997. I will tell you that Hack Reactor is designed to be grueling. It is throwing a whole bunch of concepts at you at once, it can be very easy to feel like you don't pick them up. But you do, more than you know. And right now, if your bootcamp is anything like HR, you're being thrown into all this information, while you haven't had time to practice any of it. For Hack Reactor, the second half of the course, no new concepts were introduced - working on the greenfield, legacy, and thesis projects allowed us to see how the whole picture fit together. And I am CONSTANTLY learning - right now, I'm taking up C in order to learn more about lower level language features like pointers, and more functional programming (Monads, Functors, and the like) to figure out how to make my program more readable and robust. At the end of the day, *do you like programming?* Even if you feel you have no skill, do you *like doing it?* Because let me tell you something, the easiest way to get better at something is to keep doing it, and the easiest way to keep doing something is to like it. I HATE excercise. People who LOVE excercise really don't have a problem sticking to a regimen. People who LOVE to draw eventually become very good at drawing. If you LOVE or even just LIKE programming, you should stick with it. Talk to your instructors - I think you will be pleasantly surprised at how well you're actually doing. 
TIL Hidden Treasures are visible.
Nope, that's how it is. Pure chaos, people openly defying procedures and protocols, other people doing the opposite. If you spend all of your time dedicated to it, you'll start to see things differently. I currently have the ability to and have professionally written applications in 10+ major programming languages and at least 6 architecturally different databases in insurance, utilities, healthcare, automotive, home services, as well as a few other industries. I spend a lot of my spare time reading articles, hacking on small personal projects, taking courses online, and learning anything I can get my hands on. If you don't want that kind of commitment, then it isn't for you, and you'll be out before you ever secure your foothold. Bootcamps are intended to cram as much information as they can into a VERY short period of time. Even with the intense challenge of a bootcamp, it still won't be enough to prepare you for doing it every day reliably, but you'll get some a bit of slack to bring yourself up to speed. If you still have that drive by the time your insanity has completely taken over, embrace it, learn to enjoy it. It's going to make you one hell of a programmer someday.
Creative writing is a lot easier in some ways than programming -- not that you can easily do excellent creative writing, but you can crank it out and it doesn't even really have to make sense. Computer programs have to be correct in some respects or they don't work at all. Since people aren't perfect, it's normal to have to flounder a bit to get things precise and just exactly correct. The other aspect of this is that you have been writing English for what, 18 plus years but Javascript for only a year or two. The idea of a boot camp is actually a little questionable because there is a ton to learn and it takes years for most people. Take your time learning, don't try to cram too many things at once even if that's what the class wants. It's just not realistic. But if you stick with it and give yourself time to learn one thing at a time at your actual pace, you will definitely make progress. If you want to spend two days or two weeks playing with mainly just recursion and basic JavaScript then that is totally fine. Especially if you haven't programmed before. Just basic programming skills are enough for you to learn for months, nevermind any weird JS stuff like closures. I say take your own damn time.
closures and recursion are just a way to take the current state of the function, the variables, where it is in the processing, save it and return to it after other processing. You could do the same thing with an array, pushing the current state on the stack in a state variable, and popping it, and do an iterative function with a loop. It's basically a quick way to get a stack data structure. A closure is basically saving variables in a function you create and then using that function. You'd get much the same effect by passing a state parameter to the function with all the variables saved, you'd just have to pass a second state parameter through all the calls.
That covers distribution of the specification document. It says nothing about granting a patent use license to confirming implementations.
GraphQL has nothing to do with this topic. There are no patents on React.
getRandomValues uses a [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator) and provides values by filling a given typed array with binary data. let rand = crypto.getRandomValues(new Uint32Array(16)) This would give you 512 bits (16 x 32 bit unsigned integers) of random data. You can of course substitute any typed array and length you need. The values are considered to be cryptographically secure in that they are generated using techniques that make predicting the values virtually impossible and are suitable for use in cryptographic applications. Math.random() is not secure. It returns a single floating point number in the range 0 &lt;= r &lt; 1, specified to have an approximately uniform distribution over that range. These values should never be used for cryptographic applications.
As a solo dev you're absolutely right. The problem is for people who work for larger companies that have lawyers that care about this - any big software company would be wise to disallow the use of React because of the patents license. Even startups have to care because having their platform built with react may block acquisition by a big software company due to the patents concern. 
BigPipe https://google.com/patents/US8868637B2
Hey, this sinking boat is propping up the rest of the company I'll have you know!
Yep. I've been a very successful software engineer for 15 years, and now lead a pretty great team of them. I don't really get javascript closures, since we don't have much use for them. I have only ever needed recursion about 4 times in my career. Each time it made my brain hurt. 2 of those times were job interview problems. Don't worry if you don't get advanced concepts like that when you're first learning.
So who is that has a hate-boner for Facebook and started posting all these "Don't use it because patents" stuff recently? I've yet to see any real evidence that Facebook would actually intend to sabotage their own open-source projects like this
From my point of view, it was the natural (and perhaps only) direction for Ionic in order to create a framework-agnostic business. Relying so heavily on Angular 2 as they've done so far doesn't make sense with frameworks such as React and Vue getting a lot of attention. 
This is solid advice! Same happened with me for callback functions in JS. 9/10 people failed to make me understand the simple thing but then this graphical [video](https://www.youtube.com/watch?v=KsjrN-T3ZCs) helped me connect the dots instantly! :)
Closures are pretty easy if you have come from a block scoped language like Python and have experience reasoning about variable scope. And closures were quite useful before we got promises and such (actually still useful now). Recursion otoh is rarely necessary, but indispensable when it is.
What about a higher-order reducer. function persist(scope, reducer) { return (state, action) =&gt; { let nState = state; if (state === undefined) { nState = readFromLocalstorage(scope) } const rState = reducer(nState, action); if (rState !== nState) { writeToLocalstoreage(scope, rState); } return rState; }; }
Its just about making the points that stick for you understandable and relating them to concepts you enjoy understanding. Once you grasp that, and can enjoy it again - you will find it easier to learn. What other things do you find yourself gifted at? Lets focus on that topic and try to extrapolate from there. 
Bullshit. Vue does not have or encourage two-way data binding. Only syntax sugar in form of 'v-model' which is setting props and getting event - https://vuejs.org/v2/guide/forms.html
I wrote down a few ideas: http://2ality.com/2017/08/less-building-in-web-dev.html I’ve recently had good experiences with building slide files dynamically and on demand via a server during development. For deployment, you can build statically as usual.
A little piece of advice, be judicious in the use of cookies. Now with localStorage being [supported by basically all major/modern browsers](https://caniuse.com/#search=localStorage), it is often a better choice for data storage. Cookies are only really needed when the client needs to *share* data with the server. Their presence adds to the cost of every call made from the browser to the server.
one of the big problems with bootcamps is that computer language just takes time to get into the way you think it's like fracking, you have to let the water steep in the hydrocarbon rich substrate before you drain it out and undermine the geological stability of the region for profit. but seriously, please don't be discouraged - the best advice I ever saw on this topic is from an expedition to Antarctica one team went as hard as it could each day - longer on good weather days, shorter on bad weather days the other team went 20 miles every day, no matter how nice or brutal it was. the 20 mile team made it. They had easy days to rest and recuperate, which helped them get through the tough days. the other team all died (and got eaten by penguins or whatever). They never gave themselves a chance to rest. So just get your miles in, it may seem like you aren't doing anything, and it may seem like you're going through the most brutal shit in history. Get your miles in every day, and you'll make it there in good time.
Thanks! I have considered it but my challenge is to also deal with all the old browsers- on existing sites it's shocking to see how many old technologies are still been used.
Bootcamp != Real Life With practice, patience, and determination, anyone can succeed at this.
Cookies still have their place (notably around authorisation), and won't go away any time soon! As a possible aside; if you're looking to support locaStorage, with a fallback to cookies for older browsers, there's a [few options out there](https://www.sitepoint.com/9-javascript-libraries-working-with-local-storage/) Of course, none of these fix the issue where cookies aren't stored when serving via the file:// protocol...
PRNGs are super fast and good enough for use cases which don't involve crypto. Nowadays, most JS engines use Xorshift128+ which is very fast and has great statistical properties. It's one of the fastest algorithms which passes the BigCrush test suite. The requirements for CSPRNGs are higher and revolve around potential attacks. Of course they also comparatively slow. https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator
Who wasn't? Moving away from custom frameworks (and their learning curves) to rationalize developments around standard tech is the way forward
People here are trying to encourage you. They found these ideas difficult too, but with time have settled them into their second nature. They think you might just be suffering from the highly compressed nature of your bootcamp. But what if they're wrong? What if you really *aren't* cut out for this? Continuing would just be an exercise in suffering. You'd be wasting your time, money and wellbeing. No point doing that. Not everyone can be a programmer. Some people can... but shouldn't. I count myself one of them: after five years as a web developer, I am now looking to leave the industry. My reasons are complex, but the point is - it's not just a matter of being 'smart enough'. You might just not *suit* programming personally. But, how can you tell? These are the questions I would ask myself: 1. **Am I making progress?** How much more can I do than a couple of months ago? Take a look at your old work, things you found challenging then, and see if they still seem intimidating. You might be surprised how much progress you've made. 2. **Am I enjoying the actual business of programming?** Do I like modelling a problem and thinking up solutions? Do I enjoy finding abstractions? Do I get a kick out of seeing my program work? Pleasure is not a substitute for talent, but it goes a long way to balance out the effort and the stress. 3. **Do I still want to be a programmer?** You came into this programme with certain expectations. Perhaps you thought programming looked fun. Perhaps you thought it was easy money. Maybe you just love technology. Do you still feel that way? Have your experiences bourne out your assumptions? Or have you actually found out programming isn't what you expected at all? 4. **Can I handle the things that suck about programming?** There are a great many things to find noisome: computers are pedantic and exacting; libraries are poorly documented; programming can be an unsocial activity and most of your time is spent staring at things which *just don't bloody work*. A coding bootcamp will have put all of these problems under a magnifying glass. It might have exaggerated them, true, but these are all things real developers find frustrating. Are you still OK with that? Anyway, those would be my immediate impulses. Let us know what you end up doing - r/javascript is a very supportive community and there will always be folks available to help you whatever stage you're at. Keep in touch.
In my experience of learning to program, it was like wading out to the deep end, coming back in, then wading back out to realize I was a little taller and could stand. Repeat ad nauseam. Keep going!
I think that what you're feeling is normal, you're under a lot of stress and your mind is constantly working on new things. You should try taking a day or 2 off and do something completely different -- take a long walk if you can, i can guarantee that spending time in nature will help a lot. The hardest part for me during bootcamp was remembering that I didn't actually suck at what I was doing, that it was OK to struggle, that some things take time and a lot of practice. Some concepts will make a lot more sense when you revisit them in a couple of weeks. Talking to the other students or to a teacher/mentor can also help -- as long as they're positive and encouraging, you don't want to hang out with people who make you feel depressed. I hope this helps, good luck on your journey!
I have needed recursion an abnormal amount apparently. Hierarchal data everywhere! It still makes my brain hurt when I encounter it mostly. I remember I wrote a recursive function to find the top level parent in an epub table of contents. It worked the first time and I was shocked that I managed to pull it off.
...unless you make something that has to work offline ;) 
Chrome dev tools &gt; Network tab &gt; Check "offline" 
The title used by the author might be inappropriate but I don't understand what nonsense thing you saw in the whole article and started judging saying "goal of getting speaking engagements". It might be very basic thing for maximum well experienced people but that doesn't mean every developer has the same vision and same experience, every person has their own views and are free to share.
We do you work? Just so I know which companies (and products) to stay away from... 
Interesting bug
&gt; Again, that is completely fine for a solo dev or a small business with little to no patents. Any company with patents won't think that way I have been doing this work long enough for large Fortune 500 companies (now I am at a Fortune 50) to know this is completely wrong. I have also gone through the patent process at one of those companies myself, so I do have some background here. Most large companies horde patents for defensive purposes to that when they get sued they have patents of their own to defend themselves and possibly counter sue. **The React license says nothing about using patents in defense of a lawsuit brought by Facebook.** If this were the case your argument would be credible.
u do it because u like it, u wanna keep doing it and get good at it. if u do it cuz it's easy for u then no you can accept and give up. it's good to question ur own motivation.
&gt; worked the first time Suuuure it did
Oh, there is if you set it up right in SendGrid. I should write that up! You do need to setup the DNS for a URL so that SendGrid can act as your email server, but past that, it's all webhooks again.
Since you aren't old enough to earn an income I don't think you're going to crash the company with your boycott.
Lucky we're at the rising end of the boat.
Omg... coming from a single-threaded language (AutoHotkey), callbacks were ridiculously hard for me to understand. I kept saying "How do I get the program to just stop?" So difficult. Luckily I was already hired and had someone explain it to me that knew how to explain things really well.
Can confirm. I have fixed MANY coding problems while driving home.
Hahaha it^never^works^the^first^time
This is a very good point, actually. One of the greatest parts of writing code is figuring out the puzzle. It's why I love coding so much: its constant evolution means I'll never be sitting at my desk and think, "Well, now I know everything... time to move on." I fell like 99% of coders that truly love what they do have a similar mentality. While frustrating to not know something, it's greatly eclipsed by that feeling of when you figure it out.
Thing with coding is that if you continue to beat the concept against your head, preferably violently, it'll click at some point. I guarantee it. Don't give up
&gt; If you reach a stage where your eyes glaze over, take a break. My office has a game room for those moments. They understand fully that the creative sorts can't just plug away all day, and I can safely say a game break has sharpened my edge many times.
Yep, for react native and web - works both really well!
My current position, I honestly don't know why they hired me. They asked in the interview if I had any experience in Node. I told them I didn't. They hired me anyway. They told me I'd need to learn Node. That wouldn't be a problem, had I been on a team of developers to whom I could ask questions, but I wasn't. I'm their sole JavaScript developer. I didn't get a bootcamp. I didn't have help. I was given tasks, and I had to complete them. I had to teach myself Node. The project ran behind, because while it's still JavaScript, it's also its own language, and I had never even been a backend dev before, so I had to also learn about how to build RESTful apis as well. I thought for sure I was a failure and I would get fired and have to stick to strictly front end. Well guess what. I was wrong. I'm now extremely confident in my Node abilities. I even instituted a Diffie-Hellman crypto on our data, and I had never done any cryptography work before. It can be very overwhelming, and sometimes you'll think you can't do it. But here's the trick: you can do it. Anyone can. It's not easy, but if you're willing to put in the work, it can be done. 
It doesn't seem specific to React. Doesn't even mention a v-dom, functions, etc. It seems specific to GraphQL or server-side AJAX-like things. 
I think recursion as it's usually taught makes it seem more complicated than it is. All that's really required to exhaust a hierarchy is to append children to the same structure you are searching for children in. A self calling function does this with the call stack, but it's not clear this is what it's really doing. That's why I rarely use a recursive function to traverse a hierarchy. It's just not an explicit way to solve the problem.
Yes. I'm glad I asked and am grateful for the overflow of responses. I'm finding this all incredibly helpful. Even your comment, because in the end it isn't my friends or strangers who will be doing this, but me. But I do like to hear others' takes on it.
That's how we stored the data alright. Was far easier to reason about when rendering. However it was sometimes more convenient to just use recursion when doing operations between nodes in the hierarchy
I work for a large company that is doing exactly this, and have had contact with quite a few others that are doing exactly the same. This wouldn't be such a big issue right now if this wasn't the case. The license is vague enough that Facebook will be able to limit your React usage no matter the litigation. Believe me, I do see the insanity of it and do see that the chances of it actually happening are very slim. But I do know that the wording has enough people/companies worried that they are doing something about it. 
React encourages competing libs, they have gone through pains to make it easier for React-clones and derivatives by splitting up Fiber and cutting out things like prop-types, making them universal. This was made in an effort to allow for universal interfaces and sharing. It has so far [enabled libs like Preact to use plain React components without compat layer](https://twitter.com/mxstbr/status/855510963881115648). This was coordinated between the teams of these libs, twitter has a lot of discussion about the motives behind it. React itself does not claim patents (unless someone finally produces any evidence that it does), neither does JSX. If you wanted to patent React you would patent `the use of a function that returns a result`, which is essentially what the v-dom does. Digital computing would come to an end. Licensing issues are separate, but they do not have any bearing on Preact.
www.google.com
Makes sense. Thank you
It took me years of practice and experience with other languages before I really felt like I "got" JavaScript and understand it well. I think it's not something that can be learned as quickly as these bootcamps try to do.
There's a reason The WSJ and NYTimes are reporting on these coding camps dropping like flies.
https://www.reddit.com/r/javascript/search?q=best+course+OR+book&amp;restrict_sr=on&amp;sort=relevance&amp;t=all https://frontendmasters.com/books/front-end-handbook/2017/
Firstly JS and Java are not the same thing. Secondly if you want to learn JS, i'd start here : https://github.com/getify/You-Dont-Know-JS
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [getify/You-Dont-Know-JS/.../**README.md** (master → cef9f59)](https://github.com/getify/You-Dont-Know-JS/blob/cef9f59e812650d849533c8789b29a4f1fe9d946/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmbo1m2.)^.
&gt;link to spec? 🤦‍♀️
What I've found is that some people are just smarter than you, but generally people with more background experience pick things up faster. People who game a lot will get good at a new game faster. If you're floundering it usually means you're pushing yourself to the limit which is a good thing. If you're "working" but end up getting distracted by reddit, news, facebook, youtube, etc. then you need to figure a way to cut that out. There are browser extensions that can block websites for a period of time. For me, music makes me work slower so I turn that off as well.
New to programming in general or just those two languages? If you've got programming experience with a C-like language already, then just jump right in and build some small projects. For a best practise JS book try JavaScript: The Good Parts, it's a little dated but still a solid intro to the language. For Java books I don't know, I haven't read one since uni and I only do a little bit of Java at work. Once you get into more advanced, framework/library-specific stuff eggheads.io is probably the best resource out there.
This is the problem with bootcamps. They say that after it is over, you will be ready for the real world job market as a junior developer. The problem is that 99% of the people that come out of it aren't. This doesn't make it a bad thing though. When you come out of a bootcamp, whether you feel comfortable working a job or not, you have started on the path of development and have an idea on whether that part is for you or not. Programming and development takes years (it is literally never ending) to learn. Technology shifts so much and so quickly that we all are floundering in one aspect or another of it. However, these bootcamps makes empty promises that you are ready for the workforce right out of the gate. Many of them do get jobs, and that is where the best experience is made, however from hiring devs out of these bootcamps myself, I find they need another 6 months or so before they can be allowed to write production quality code. Some catch on quicker (and some slower) than others. It depends what the market is lie where you live too. If it is competitive, then expect to take what you learned and expand on it on your own. If your market isn't (like where I live) then you have a good chance to take a lower pay and learn on the job. I mean I had a degree in pretty much backend and application development and my first job was in front end, which I hardly knew. From there I learned it and became a full stack developer, so this is the starting point. Where you end up is based on experience. 
Why would you?
Everyone struggles at first. Getting your mind abstracted into how you should be thinking about code is a very difficult task. You can do it, it's like anything else. For instance, let's say you don't play any instruments, I hand you a guitar and show you some music and I say "try to play me something". Chances are you're going to fuck around with it for a long time til you make a decent sound. Same thing here. Your building your skills which takes time to refine and hammer out.
Anything worthwhile is hard. Keep your chin up. Take a deep breath and keep attacking it. I know it sounds like a homily, but it is true. You are afraid that you might have a weakness in some aspects of coding. That might be true. THEN DEFEAT THEM and they will never bother you again. No programmer ever stops learning their whole life. They stumble upon new and difficult things every day. It is normal.
Nobody knows what the heck they're doing when they start out. I hated JavaScript at first - hated the syntax, hated the variable scoping, hated the "type system" (or lack of it, rather). I eventually got really familiar with (and fond of) it, and it was my knowledge of node.js that was a competitive edge for me when I was job hunting a year back. JavaScript is just a strange language. Give yourself some simple applications to build, and repeat that a few times, and you'll get the hang of it.
No but seriously. If a company promotes a guy to lead after 15 years and doesn't understand closures or never found a use for recursion, then there's something seriously fucking wrong. I can't go a damn week without needing recursion. I can guarantee you this guy is writing horrible messes of code to pound his square peg into a round hole.
I am not on a computer but can it be related with that addEventListener does not have a return value? You are assigning it to a variable.
Or in the shower.
I could do it with jQuery. &lt;script&gt; $('p[id="test1"]').on('click', function() { window.location.href = $(this).text(); }); &lt;/script&gt; And add in your css #test1 { text-decoration: underline; }
I did what you told me, but [Does not working](https://image.prntscr.com/image/ivCyTv6oSCWocz1am32img.png), am I doing anything wrong?
`addEventListener` does not and will not return a value. You're correct. 
Well, `id` properties should really be unique attributes, it seems like you might want classes here. I'll assume it gets changed to `class="test1"`. You could do something like: let pTags = document.querySelectorAll('.test1'); [...pTags].forEach((tag) =&gt; { let text = tag.textContent; tag.innerHTML = `&lt;a href="${text}"&gt;${text}&lt;/a&gt;`; });
Closure and recursion!?!?! So advanced
&gt;I remember I wrote a recursive function to find the top level parent in an epub table of contents. It worked the first time and I was shocked that I managed to pull it off. Those are the days when you leave your desk and take a victory trot around your work place.
To expand, what you're doing is equivalent to: h1tag = document.getElementById("myHeading"); h1tag = h1tag.addEventListener("mouseover", ()=&gt;{h1tag.style.backgroundColor="blue"}); So h1tag is set to the result of addEventListener (which is undefined), not the element.
redux-persist works like a charm, love it.
*Hell no!* **Accept nothing!** Bootcamps are designed to show you a lot of things in a short amount of time. I tend to learn a bit differently. I like to take one thing, break it apart and learn it in and out before moving on to something else. Sounds like it just might not be your learning style. 
Yup. It worked. Upvoted+ But my question is will Google see it as links or text? Because my main goal is to tell Google it's not a link but a text.
The fact that you're here and asking about it is proof youre capable of knowing what it takes. Just gotta put in the work and keep trying, don't let other people seemingly being better at it stop you from anything
As mentioned, h1tag is no longer the element. If you need it to be the element, leave it as two lines. If not: document.getElementById("myHeading").addEventListener("mouseover", (event)=&gt;{event.currentTarget.style.backgroundColor="blue"});
Google should see this as text, since that's what it is as HTML. The JS manipulates the DOM so it becomes a link, but a bot won't see that.
Your URL in the Dialog-Options points to a txt file, not a html/aspx file. I'd guess the Browser basically shows the contents of the txt - it will not render any buttons/logic. Hint: You don't need jQuery to check if the page has fully loaded SharePoint provides a helper for that: _spBodyOnLoadFunctions.push(/*your function here*/) this will be executed lastly after all SharePoint assets have been loaded. [Use _spBodyOnLoadFunctions instead of $(document).ready](http://www.stephanrocks.com/2011/10/05/_spbodyonloadfunctionnames-in-sharepoint-vs-jquerys-document-ready/)
When it appears to work the first time, that's when you know you really screwed something up.
It's called swimming! just try to always keep your head above the water, lol 
If I recall the google crawler is now capable of running JS so that may not be the case anymore. 
Yes. You're also right. But research also shows Google doesn't always fetch JavaScript. They do sometimes but not all the times. I would like to play the odds. 😋
Genuine question - if this algorithm is consistently slower than the inbuilt (native) sort, why would I use it?
"Gifted" is so overrated. Recursion is very difficult to grasp at first, but I believe anyone of average intelligence can understand it at a basic-enough-to-use level after spending the time implementing and experimenting with it. Just like everything else, you will start to understand it intuitively in your brain, just like how you understand functions and variables and everything else that was totally confusing at first. It just takes time and practice. Also like other people said, learning something in a day or two is stupid. It takes time. The brain is amazingly good at learning if you are persistent and patient.
I am :) glad to hear you enjoyed it!
So I need to change the .txt file that just shows the actual disclaimer words to a html/aspx file? And then add html/aspx code to create buttons to either close (accepting it) or exiting?
I did not know this actually, I'll look into this and add it into the post. Thanks for pointing that out!
I agree, function components are much nicer on the eyes :) sometimes you can't avoid them though, especially if the child components are wrapped up with a lot of functionality. Thanks for your response
I did, but for some reason I got all of my replies from /r/javascript :)
&gt;why should I continue on a path of something I suck at? The problem is not about sucking at it, you *can* get better at it. The problem is: do you like the experience? If not, I'd just drop it. Programming is a creative profession. You can't be creative without being passionate about what you are doing, or without at least a little bit liking it. I learn new programming language as a hobby. In my free time. I flounder A LOT. The thing is, I **love** it. I love programming. This is my job. I program for clients and after work, I program for personal projects to rest. If I didn't love programming, I wouldn't be able to do it. It would be torture. How far can a painter go without at least liking the act of painting, composition etc... How far can a creative writer go without at least liking to read novels? I don't like reading novels. You could probably pay me enough to write one. I'd learn to get into the mindset of a novel author and probably could write one if I was paid enough. But it probably would suck in the end. And spending my time on it is waste from a personal growth standpoint except for the money I earned from it. I think programming is similar. If you don't like living in that mindset, why bother?
Yessir. A SharePoint Dialog is basically an iframe, so you need a full html page to properly work. If you're about to do the redirect using JS be aware that you need to inform the parent page about it. Otherwise you'll just redirect in the iframe. The following link may help you better. [Maybe this can help](http://brandonatkinson.blogspot.de/2012/08/confirmation-modal-dialog-using.html)
The function is a wrapper which invokes the original with the explicit `this` binding. Normally, context (`this`) is set dynamically for functions. Its determined when and how the function is called. You can override this behavior using `call` (or `apply`) when calling a function to force an explicit context of your choosing. The `bind()` wrapper - what is represented by `bar` in that first example - is what calls your function this way without you having to do it every time yourself, or in situations where you don't control the invocation, such as when you pass the function to a listener. el.addEventListner('click', handler) // &lt;- you're not calling handler In the event handler case, when the handler is called, the context is set to the event target. With the bind wrapper, this sets context for the bind wrapper function, but the original function is called internally with your explicit context, so the context set by the event handler call is ignored for the code that really matters - the code in the function called by the wrapper.
I shall try it, thank you! 
I wouldn't use YDKJS as a "how to write javascript" series, but instead "here are some interesting things about javascript" series. I use call/apply/bind maybe once every couple of months. es6/typescript have made them less relevant. edit: sometimes you want context for your function (for whatever reason), so you'll have to set a reference to `this`. Maybe you're using a class method as a callback etc. 
Apple has always touted that they want to be first when implementing new technologies. They're really putting their money where their mouth is!
If *you* don't intend to bring patent assertions, that doesn't mean that your company will never be part of an organization that does patent assertions. Most small companies hope for an acquisition.
BTW, I wasn't saying this to be nasty, I just genuinely believe that with a title like that, it belonged in the react subreddit instead!
&gt;I don't really get javascript closures, since we don't have much use for them. I'm assuming you're either programming fully functional, over the top OOP, or you're using some framework that is doing all the closures for you.
That;weird
Sorry
I have been programming for almost 40 years and Javascript makes me pull my hair out. It is a mess.
I disagree that they did a good job. They were the only tool available for awhile and people realized how terrible it was to develop code with lots of callbacks, partially due node. People then realized it still sort of sucked and created async/await. People still realize that does not handle enough and need another solution. The JavaScript community likes to invent solutions today without concern for tomorrow and then need to invent a new solution tomorrow for the problems that still exist today. JavaScript is like extreme YAGNI, where they constantly build solutions that need to be replaced/enhanced.
closure, recursion is fundamental javascript. i did one of those camps. many people including myself feel like they aren't keeping up, you might not be the top student, but trust me you're learning a ton. also everyone hits their stride at a different time. you'll get more comfortable with it.
You _can_, but that makes the reducer "impure" as it is interacting with the outside world. It will work, in that the code will run and do what you expect by itself, but that will _not_ work properly with time-travel debugging. It's also not what anyone is expecting a reducer to do. Please don't do that :)
Dude, sucking at something is the first step to being sorta good at something.
Exactly. Sucking at something is the first step towards getting good at something. That point where it feels like your brain is going to fail from trying to understand things is when you're learning ;) 
You shouldn't. the market is pretty saturated for javascript developers right now. It can pay insanely well but the odds of getting the right job have decreased from the flooding. If it ties in nicely with your career or hobbies, then yea go learn some javascript. If you're learning it because you are a server side programmer who wants a flavor of the client, or you're just interested in web design in general, you may be better off just hiring or working with a web developer rather than investing the time into learning it yourself. FWIW "why should I try if I suck" is a logical fallacy.
&gt; Apple has always touted that they want to be first when implementing new technologies. Hahaha!
Using `;` as an assignment operator was a courageous decision, I applaud Apple for their courage
[holy shit](http://www.reactiongifs.com/r/mog1.gif) lots of hodgepodge xss prevention code will be caught pants down... Edit: And wow, this is quite old. I am running on a Mac that hasn't been updated in a few months and the stock Safari in it exhibits this bug. So this has been in the wild for quite a bit of time. 
I'm going to pretend this was a meaningful attempt at a rebuttal, since my initial comment wasn't especially gracious, either. Not using closures or recursion of you don't need to is fine, obviously, but if you don't "get" them or they make your brain hurt, you shouldn't be leading anything programming-related. If it's already been 15 years, then it's probably time for a different career.
I thought the exact same thing when I read this.
You all laughed at me when I said I used [standard-js](https://github.com/standard/standard) WELL WHO'S LAUGHING NOW!? Edit: okay then no jokes allowed...
Hi /u/tpk1024, in the future, you may want to submit from `v8project.blogspot.com` instead of `v8project.blogspot.in`... pretty much all `.in` are automatically spammed, and increases the chances of reposts.
www.sitepoint.com/recursion-functional-javascript/ it's not that hard...
Exactly. Too many people seem to give up too easily. 
Not sure why the downvotes. I also was pretty surprised by this. I can only imagine this guy has been doing 15 years of CRUD web apps and is using the term 'software engineer' very loosely. I mean... 15 years.
That seems fine to me. I like that the JS community solves the problems that exist and not the problem that may exist in the future. 
Hi u/Woolwoman I think the question should be: do you enjoy X enough and can you tolerate the things you dislike about X enough for it to become a career? Remember that every career path has goods and bads (e.g. in writing, you might potentially hit walls due to writers block, or maybe you have to worry about unsteady income or tight deadlines depending on what kind of writing you do). The point is that the ups should be strong enough that the job as a whole isn't a soul draining ordeal. Ideally, the entirety of the problems are something that you face as challenges that motivate you. For example, a lot of programmers actually enjoy fixing arcane illogical bugs even when figuring out the root cause is hell, because of the high when they finally fix it. For programming in general, impostor syndrome is a real thing, and learning new things - ranging anywhere from easy to outrageously mind bending - will pretty much be a requirement for the rest of one's career. Also, the vast majority of it will be self-learning. If you enjoy self-learning but feel that there's a sort of assumption that people "should already know this basic stuff", then that might just reflect on poor bootcamp pacing rather than your abilities. People will also often blabber on and on about the technicalities of closures and monads when the reality is that using them in a real life scenario is a lot more straightforward than trying to dissect them in a theoretical explanation. One untold truth about the industry is that it is very very very bad at mentorship. Another thing, don't compare yourself with your classmates. For one thing, they might all be secretly struggling as much as you, or maybe they just aren't because they already did the struggling part earlier in their free time in high school. Focus on your own growth. Have you been finding out that there are things you didn't know that you didn't know? Do you feel that you are on course to master these unknowns eventually? etc If you do decide to quit the bootcamp, try just doing a project on your own. It could just be something simple like displaying a text editor on your browser using a library like aloha.js and saving essays to localStorage. See how it feels to have to figure things out on your own when you have the specific goal in mind. A programming job is more or less like that. If that's enjoyable, then it might be for you, if it's hair pulling, then it probably is not.
Is this a joke? This is a joke, right? I mean, you never know these days...
Web developers tend to have a chip on their shoulder about anything even remotely considered "academic". God knows why, but mentioning that a developer should know recursion is enough to get them all to freak out and squawk at you like you're some sort of heathen. I'm just putting this out there: # If a person thinks they don't ever need recursion for anything, then I can guarantee you their code is bad. Front-end devs, man. Bane of my existence. Cocky shits who know far less than they think they do. 
On the toilet.
&gt; Edit: okay then no jokes allowed... Funny jokes are.
Recursion is easy to understand! But first you have to understand recursion.
And here I thought I was a funny guy! well this sucks...
You should really add the word "React" to this article for people that aren't familiar enough with it to know what you're talking about
[Programming in a nutshell](http://www.threepanelsoul.com/comic/on-infinite-loops)
"Language avoids at least one error in the language it compiles to" -- very useful title...
Ugh, I hate when people use the same name for a bunch of files (e.g. an `index.js` for every component). Makes doing global search in my editor _and_ Chrome dev tools harder for like very little benefit.
No. It's too early too decide it's not for you. Closure and Recursion aren't easy concepts to grasp that you'll understanding in one or two passings. These are the level of concepts that you have to actively try to learn it putting much more efforts than usual. And in every single field of expertise, there are tons of concepts like this that requires tremendous efforts just to learn. So if you give up whenever you encounter such difficulties, you'll never go far in any field.
That's bullshit. For a while I didn't "get" currying. I understood it, I knew what was happening, but if I ever encountered it I'd slow down significantly and have to think through each step of what was happening. I'd be much less productive, much less confident, and I'd be afraid of making changes to a part of a codebase that used a lot of currying. Then one day it finally clicked, and now I can say that I "get" closures. For me it just took seeing some really powerful use cases for them and seeing them used correctly to great success before I finally understood why they would want to be used vs just passing around an array of arguments to apply to a function later. I can see someone feeling the same about closures. In many codebases you don't really use them, and creating a function which contains a bunch of inner state that is kept around seems confusing and can be hard to follow. He may fully understand each part of what makes a closure, but when put together they get overwhelming and to them other solutions seem much easier or better. That doesn't make them a bad programmer, it makes them unfamiliar with a style of programming. Somehow I bet you wouldn't get how to quickly determine if a dependency graph is a DAG or not, that doesn't mean you couldn't learn it if you needed to, or that you don't already understand most of the basics, it just means that you've never had to deal with that before.
Does telnet 192.168.2.128 1883 make a connection? 
Promises can't shine over try catch because try/catch is literally baked into every step: it's unavoidable. It takes away exactly the control that should be left up to the use case. This is even why papering over the problems with Promises to enable cancellation bubbled into trying to further complicate try/catch.
Not to mention they are suprisingly difficult to secure correctly. Don't want your cookies to be readable by your CDN? don't set them on the root domain! Also feel free to use the path argument for some extra security, but be warned that it will make future url changes a pain! Also make sure to set that Secure option, otherwise you'll be broadcasting those cookies to the world! All it takes is one mistake and whoops now you've sent login credentials to some other location that allowed session hijacking attacks to be carried out!
Just to make things clear it's not algorithm it's a library that under the hood uses native JS sort. Because of that overhead it has to be slighty slower then native js sort. The thing is that this library is considerably faster then other tested sort library (which can be seen in benchmark results on fast-sort page). Highest difference in benchmark is 44 time faster then sort-array library (something to be aware of if using sorting library as some of them are really slow on some occasions and can hurt your code performance). It's also 2x and more faster then popular lodash sort that is used by thousand of peoples every day and it has same functionalities as lodash sort. The reason why to use this library or any other sort library when they are slower then native sort is: 1) Easier to write and understand than native sort. let's take an example: sort(tenants).asc((person) =&gt; person.firstName); here it's easy to understand (and write) that we are sorting array of object by person first name in ascending order. writing the same thing with native sort is different story (equivalent of above is) tenants.sort((a, b) =&gt; { if (a.firstName == null) return 1; if (b.firstName == null) return -1; if (a.firstName === b.firstName) return 0; if (a.firstName &lt; b.firstName) return -1; return 1; }); As you can see this is much harder to understand (read) and to write 2) Handling undefined and null values by default and sort them to bottom no matter if sorting is ascending and descending (need to take care of yourself if using native sort) 3) Easy sorting by multiple properties for e.g sort by first name and then by last name (not supported by native sort) And when you take benchmark results in real light for example sorting of 1000 items (and it's most common scenario to sort less then that rarely more) it takes fast-sort 0.44 ms to sort and native sort 0.1862 ms. That is less then half milliseconds for thousand items! That is something that in 99% of cases won't be noticeable in your system so do you want to compromise code readability for micro performance gain that can't be noticed?? Off course there are cases when I would advice to use native sort but that cases are rare so if you work on system where sort is bottleneck of your application then yes you should use native sort in all other cases I would advice to use library as it will help you in maintaining your application by providing more readable and easier to understand code which is much more important then micro-performance gain. 
It's a roundabout way to say that there is static code analysis for this kind of thing. You also get this with TS or Dart, for example.
The reason eagerness is a problem is composition: You can't make a plan, and then later enhance or create subvariants of the plan directly, because as soon as you create a new Promise, you've invoked its constructor. So to avoid that, you'd need to wrap the Promise itself inside an extra function, and now you're a step again removed from the type you wanted to work with. You don't have to do that with, say, Array.map, because Array.map is pure. So, ironically, making Promises eager makes them _less_ like standard synchronous functions/types.
Yea, it's kinda amazing, really.
Agreed. That's why I'm willing to use longer names, like `features/featureA/FeatureAList.jsx`. There's more typing, and duplication of text, but it makes it a lot easier to distinguish names in "open file" autocompletes and editor tabs.
Not half bad.
Your definition of "anyone reasonable" seems more geared towards "anyone who programs Javascript who has a habit of assuming this." But some habits/asdumptions are bad! Lots of other languages DON'T assume that a description of a major side effect and its execution should all be the same thing. And sloppy handling of state and side-effects is pretty much THE big headache facing most large applications these days. So it's an assumption worth reconsidering, at least in my opinion.
How would I implement that in the code?
If this is true, it is quite the fuckup. By the way, you don't need semicolons in JavaScript. I've stopped using them years ago.
How the fuck you use `for` without 'em?
virtual-dom https://patents.google.com/patent/US20170177736 | synthetic events https://patents.google.com/patent/US9003278 | components https://patents.google.com/patent/US8751925
I agree wholeheartedly- but is this a "pattern", or just organizing your files properly?
The cancellation issue is huge, imo, and it is very much a design flaw. Promises are essentially stateful value containers. All the approaches for cancelation boil down into smuggling an awkwardly previously saved reference to a control token into the constructor, requiring juggling around and passing around both the type and its controls. Futures/Tasks solve this directly by cleanly separating effect description/transformation and execution, such that once an effect is executed, all that's left behind are controls (the type it's gone at this point), and they exist right where they matter: at the execution call site. This allows you to do things like mixing effects in sequence or in parallel, passing along control flow in chained effects, etc, all with simple, logical control flow. Promise cancellation ends up being more like time travel. Programmers should NOT be tasked with figuring out logical paradoxes, imo.
There is a difference between things you might not need because the problem doesn't exist yet and problems that do exist and you overlook. The community tends to fall into the latter imo.
for(let x in y) for(let x of y) What other kind of `for` loop is there? /s
Run it in your terminal window.
That approach has literally been a disaster for JavaScript... though I suppose it's been a boon to JavaScript developers, because we're the only cowboys brave and crazy enough to tackle this crazy beast.
Anyone that appreciate code and hard work that has been put into it I would be thankful if you could take minute of your time and give me a star in github under [js-flock library](https://github.com/snovakovic/js-flock). fast-sort is part of that library exported as single module. That would help and mean much! I'm also open to suggestion, criticism and off course contributions to library is someone is interested. 
Random people helping each other out on the internet? We can't have that! Let's all go back to flaming and trolling and being all kinds of mean. 
[Live here](https://flems.io/#0=N4Ig9grgLgDtIC4oCcIFMA0IDOaA2aAxlGgCaIgB0AVtiFgGYCWBdCA2qAHYCGAtmgqUAFlD556IQmC4lZFEAF8M3foIRVak6bLTyNANx7IABNhMBeE6TCEIA2ZULI0PEgFECDqAAoA5NjOTDBQfgCUADpc2JQkAB5QAMIyclCWJn5xANwArH5RAPQFUTZ23pQARmCkAJ6UPDAweqSJwiykPtiRXDrYYASUeGAA5j5xYUoqILwCQoTYdFg6qQqKALqKQA). O_o
You can probably do a whole lot of programming without these difficult concepts and more WITH them. So do what you can, and take the time to learn what you don't know. Like others said, look for supplemental videos. What works for me is examples of the concepts being used in code. If you see 50 examples of any concept and can tear them apart and put them back together, you'll know more than you did before.
Automatic Semicolon Insertion is an error correction mechanism - that means it corrects errors. Do not use errors as language feature.
Believing in Briggs-Meyer personality types is a sign of ignorance and irrationality. You are probably not suited for programming yourself. 
I guess this is caused by content sniffing. The file header for a WebM which contains audio and video and one which only contains audio should look the same. For saving, I recommend to generate a link with a "download" attribute. You can specify the file name there. The extension should be still "webm", though. ("weba" is nonstandard.) https://developer.mozilla.org/en/docs/Web/HTML/Element/a#attr-download Blobs also have a mime type which you can specify when you construct them. Did you use that option? https://developer.mozilla.org/en/docs/Web/API/Blob
Array.forEach(() =&gt; { }) Hmm, I think that's it
Well ok. Still use them in `for` loops. But usually I use `for... in/of` and iterators instead of the good ol' `for`.
Just t
Damn, it works on MobileSafari too (iOS 11).
Probably a bug, not a joke.
By the way, good luck on MQTT. That has become my favorite message protocol. 
It was called "organize by feature" not so long time ago, but I suppose "component folder pattern" sounds more cool/buzzwordy. But "component folder pattern" is actually pretty understandable name. The worse is "Reference implementation pattern" which looks similar to something that was called HOC(Higher Order Component) back in time or to just passing components as props (which is common practice in React community I guess). Why people on Medium keep reinventing things, but under different names? Even if article has good content, there must be something pretentious about this. 
This looks helpful! I've been investigating using TS with Vue, and the biggest pain point so far is integrating Vuex in a strongly-typed manner. The best answer I've come across is [vuex-typescript](https://github.com/istrib/vuex-typescript), but it has to compromise some of Vuex's clarity (due to its string-based API). Anyone have experience getting this running? It is clearer to use Redux like [this](https://spin.atomicobject.com/2017/07/24/redux-action-pattern-typescript/)?
Yeah, I used HTTP forms so far to control IoT-Gadgets. Was pretty amazed to find out about MQTT.
You probably should read this part of the specification: [Examples of Automatic Semicolon Insertion](http://www.ecma-international.org/ecma-262/5.1/#sec-7.9)
They seem concerned with streaming and distributed content. Doesn't even contain the word "virtual", nor is it defined in there. The one that is supposed to patent a component doesn't do that as well. This is a valid component in React: `const MyComponent = () =&gt; "hello there"` are you going to tell me they have managed to patent that?
Or, to turn it the other way around - who would be interested if I cleaned up my ng4 project and published it as no-hassle no-node_modules no-build ready-to-develop seed project?
I feel for you... luckily, there's another option: http://badassjs.com/post/43158184752/qt-gui-toolkit-ported-to-javascript-via-emscripten
I think there's a bit of a distinction between "feature folder" and "component folder". As I read it, the idea of a "feature folder" is generally "put all files related to a given feature under a common parent folder instead of splitting them into separate folders based on type of code". A "component folder" is doing that for a specific component, where the component folder itself might live inside the feature folder, and also using `index.js` as the main implementation file for the component so that you can still do a nicely written import like `import MyComponent from "MyComponent"`.
You don't need webpack or any compile-stage build tool for es6 and jsx. Paste this into an html file and see for yourself: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.1/react.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.1/react-dom.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.21.1/babel.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; const Hello = ({ name }) =&gt; &lt;h1&gt; Hello {name} &lt;/h1&gt; ReactDOM.render(&lt;Hello name="World" /&gt;, document.getElementById('app')) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; You are shooting yourself into the foot, though, removing yourself from the rest of the community. And it'll only be harder for you as time passes. Webpack is an amazing asset, perhaps you've just stumbled over it with the wrong foot? A plain config gives you pretty much everything you need: module.exports = { entry: './index.js', output: { filename: 'bundle.js', path: './dist' }, module: { loaders: [{ test: /\.(js|jsx)$/, loader: 'babel-loader', query: { presets: ['env', 'react'] } }] } }
Update: It's actually just the same principle as `true &amp;&amp; "hello" === "hello"`
Do you don't minify either? Just because you don't write semi colons doesn't mean they aren't there.
Hm, in that case I might give React a shot. I am not saying that WebPack is complicated to set up - in Angular 4+, the official way to scaffold projects, with angular-cli, automatically includes webpack set up, I think. My issue is that 1. I don't want anyone to transpile the code I write (before production, at least). In best case scenario, it ends up looking disgusting, in worst case, buggier than I made it. 2. I don't want anyone to watch my folder and rebuild on background, even if it's fast and progressive. No, not you, Nodemon. Yes we still love you. 3. I don't need webpack. I truly, absolutely, completely don't need WebPack. And I hate adding shit to my dev env that isn't necessary, unless I love it. (Again, not saying it's not _useful_, it's just not _necessary_.)
Yay! That will save me from unnecessary levels of abstraction. Maybe one day I'll be able to make web pages in Visual Basic 6?
My comment was more of a tongue in cheek than to take seriously. But I do omit ; while developing. They are inserted later on, that is true.
RiotJS is a cool library that doesn't need webpack
Technically that's not a loop but a map 😝
ASI is there whether you use semicolons or not, not using them doesn't change the behavior of ASI at all. Regardless of whether you use semicolons or don't, this is still an error: return { x: 'stuff' } And whatever you call it is fine for you, but it's in the spec and consistently implemented by all browsers.
Technically minifiers could put a `\n` there instead of a semicolon and it wouldn't change the size of the file nor how it's executed.
Yes they do use it, but Angulars setup is pretty "special". Under no circumstance is it normal (background compilation AOT stuff, etc), they added it extra. I also think it's painfully slow and sometimes buggy. I work on a NG4 project and yeah sometimes it makes me want to scream. A normal Webpack project is easy to love and isn't like that at all. Just for kicks i'd suggest following along with the [first lecture](https://egghead.io/courses/react-fundamentals) on Eggheads fundamentals course. If you still think it sucks, well, babel-standalone would at least help you out of the es5 mud.
I'm still using react-router-redux and redux-auth-wrapper in my projects. I'd be curious to see how folks are solving that problem on the latest react-router bits.
IIRC that was what Douglas Crockford said, but the actual spec never calls it an error correction mechanism and it actually says ASI exists for convenience: &gt; Most ECMAScript statements and declarations must be terminated with a semicolon. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations. https://www.ecma-international.org/ecma-262/8.0/index.html#sec-automatic-semicolon-insertion
/r/Javascript doesn't take too kindly to us people. They employ a strict "don't ask, don't tell" policy. We can do what we want behind closed doors, but if they see our javascript without semicolons, we'd better watch our backs!
You could checkout Ember. I'm pretty sure their CLI takes care of your needs. 
not using semicolons doesn't change the behaviour of ASI at all.
IMO that's kind of a shitty policy. There are a lot of TLDs now used for many different purposes.
&gt; I hate WebPack &gt; I do hate TypeScript as well &gt; I'm fine with Angular 4 and JavaScript __for now__ &gt; I don't think I'd like React, because of JSX You might want to look at all this negative energy you got and ask yourself if maybe this isn't the right language for you.
Thank you for your responses, I genuinely appreciate you sharing your view. It's good to know that angular setup might be different from other projects - we do use Webpack 1.x in two projects in my day job, and it... works, I guess. Still better than the gulp mess we've used before. However, I write plain ES6. I don't wrap my files in IIFE. I don't compile Scss. I really don't need Webpack to compile my neat ES6 code to its bullshit /******/ ES6 code wrapped in a messy IIFEs and namespaced unreadable function names.
Oh noes, a developer swearing at something??!??!?!?!? Unheard of!
Try [Vue.js](https://vuejs.org/). It has all the model-binding, reactive UI and component goodness of Angular without the bloat. A full-featured Vue app is ~30Kb gzipped vs. Angular's "Hello World" which is ~130Kb. It is also faster than both Angular and React. [Comparison](https://vuejs.org/v2/guide/comparison.html#Size-and-Performance) You just need a JavaScript file, maybe a little CSS and you're good to go. [Vue.js 2 Quick Start Tutorial](https://medium.com/codingthesmartway-com-blog/vue-js-2-quickstart-tutorial-2017-246195cfbdd2) Sure, it also supports loading via NPM, creating applications via a CLI, WebPack, etc. but all that's optional. "Come over to the light side.", I like to say.
A semicolon is 8 bits as well... But it was mostly in jest, clearly nobody is stripping `;` out of their codebase. It would also break any strings with `;` in them too.
It's a public record of how you interact with other people. Do you want to have to explain this post to a potential hiring manager? "So, I see you hate all the technologies we use here, and you backtalk people who try to help. I think it's not a good fit."
OK, snappy comments aside, I've been developing websites for 18 years now. Most of the time professionally, too. Sure, I don't consider myself JS "guru" or "expert" or anything of that sort, but don't assume one angry post sums up all my development experience. There was a good number of technologies I've loved and enjoyed working with; Node.js, Express, bluebird, lodash, Phaser, etc are some of my favourite things. With WebPack, I'm being *forced* to do things I have zero interest in, adding bloat to even the simplest of projects. I have "negative energy" for a reason.
You're not trying to help, and hiring managers don't have time for Reddit. Also, any HR person worth their salt understands that Internet is an amazing tool if you love taking things out of context.
I don't have enough downvotes to give you.
Honest question: can you have single file components in Vue without webpack? I don't hate webpack/typescript/compiling in general (I'm mostly a Java dev) but I honestly like my javascript to be the same as I wrote it...
maps and loops are both needed to program ;'s god dammit mother fucker shit ass bitches. fuck. why ya gotta remove ;'s man. I hate that shit now all you twerps are doing it.
You can't, there's also an additional payload as you're now shipping the template engine that would normally reduce templates to functions at compile time.
If I understand correctly, an expected failure in this sense is a method that expresses failure by throwing / yielding an exception that was called by a consumer that regards that failure as one of several outcomes. For example, be `fetch_user( id, callback )` a method that will call back with either a user object or else an exception; that exception could indicate that (1) the `id` was malformed / missing; (2) there is no user with that ID; (3) the network is temporarily down. Probably (1) is a real bug indicating missing early checks, but (3) is an 'expected failure' in the sense that network splits are something you'll have to live with and handle by retrying later. How to deal with condition (2) will depend on circumstances.
But it doesn't say that. One could infer that this is hopefully what it means but it's an absurdly weird borderline click bait title. If I didn't know what elm was already I could possibly guess that it was just a Babel rule that wrapped every function call to prevent this
Not exactly JS friendly list, but it should be pretty easy to write a script which converts to JSON and extracts what you need using node, then you won't need to update the list yourself manually whenever it changes, just run that script from time to time (cron?). https://github.com/datasets/country-codes/blob/master/data/country-codes.csv List generator, which allows you to get JSON, but you will have to update your list from this one manually from time to time: http://peric.github.io/GetCountries/ Edit: I didn't read whole readme, but datasets/country-codes does update and convert to JSON if needed, you will need to have python on server-side
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [datasets/country-codes/.../**country-codes.csv** (master → d2e119d)](https://github.com/datasets/country-codes/blob/d2e119d96cbb567eae53b15bc96e3ab0b672421f/data/country-codes.csv) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmc8ykf.)^.
Bootcamp is too short of a time to test your aptitude in programming especially if this is pretty much the first time you've seen or done it. My personal journey into programming has been a long one with a couple of failed starts: 1. Had a private programming tutor for the C programming language when I was in fifth grade. (My dad thought programming was the future and he was right, but my fifth grade mind was way too small to grasp programming.) Most of the stuff was going way over my head and I quit before three months was up. I remember learning about arrays and was totally confused. 2. Took a Visual Basic programming class in middle school and got some exposure to building basic Windows GUI apps but it was still hard and I wasn't really drawn to it. 3. Took another Visual Basic programming class in high school and did well there so I went on to take AP Computer Science (C++ at the time). Did well in both of those classes and realized programming was what I wanted to do going forward. At this point felt like I really got it. 4. Went to college and did a BS and MS in Computer Science and learned a lot, especially during the MS where we tried to solve real, modern problems. 5. During my MS I TA-ed for first year CS courses and really enjoyed helping (mostly) freshmen CS students learn programming. Saw many of them struggle like I did earlier in life. It was rare for someone to just get programming immediately even among those who majored in CS. Those who never did programming before college typically struggled for a full year before either deciding it wasn't for them or continuing forward because they saw reasonable progress. 6. I've been working in the software field building web applications for the last 10-ish years and I still love it although sometimes I think about going into teaching (maybe bootcamp??) b/c I still have very fond memories of being a TA and walking others through this journey. TLDR: Programming takes time to grasp and its different for everyone. If I only had three months to learn / decide if I wanted to be a programmer I probably wouldn't be one and would have missed out on a career I'd end up loving. Seeing as you're doing a bootcamp you're probably a grown up looking to make a career switch and I get it if you don't have unlimited resources / time to figure this out. Good luck! 
[In places where it matters, the regular for loop still has far better performance.](https://www.incredible-web.com/blog/performance-of-for-loops-with-javascript/)
Hard to remember the last time I wrote a `for` loop
Very very true. We're talented but at the end of the day there's SO MUCH to know. I may not be the most technical oriented person but I understand UI, UX, and high level structural / architectural decisions. What I mean to say is, is all of us are floundering in SOME way. The ones who have very strong grasps on some things become seniors but that doesn't mean we're not lost on specific things, and a lot of time we leverage what we've stumbled on in the past to learn something new. Unfortunately, we live in a very truthless society. What I mean by that, is the employer you work for may not be the best employer. The pizza restaurant you order from may not be the best. The plumber you call may not be the best. But they're never going to tell you that nor should they, because there is always someone around the corner who will say that they will, so there's no room to be honest. HONESTLY... I have a lot to learn and I always run into things where I'm like "dammit I don't know or understand this... I feel inadequate" but I realize that I don't have to be Michael Jordan. I just need to improve to the point where I provide enough value to justify a salary. Now that being said, I have done this for many years so I'm probably better than a lot of people starting out, but the overall concept is still present. There is a huge market for React developers, and you won't use closure much here. The only thing that matters is... do you enjoy the challenges, the problems, and can you move past that feeling of not being able to get it. If you don't enjoy that feeling or the frustration, then it may not be for you. However if you can come to grips and be ok with that feeling and you enjoy coding anyway, then keep on trucking.
I use a custom gulp setup to run browserify with the React library. It's a few lines of imperative/functional code with a handful of helper modules and plugins. I've never touched WebPack, because I think convention over configuration is fundamentally flawed due to limited customizability and being overly subjective. Many who initially dislike JSX start liking it pretty quickly once they use it, but you can use React without it with no difficulty.
I think it's interchangeable. Component can be thought as some sort of "feature" and feature can be splitted into smaller components. "Component folder pattern" seems to be just a subset of "organize by feature" if I understood this article. IMO this is just word juggling, not a real difference. 
I've been an engineer for over a decade and a geek/programmer for about 28, so here's the best advice I can offer: Find a way to make the concept mesh. Maybe the teacher or textbook/materials aren't presenting the topic well. Maybe you felt a bit off for 10 minutes while they introduced it. It doesn't matter - you can learn it. You may not LOVE it, you may never be great at it, but you just need to finish your mental model of it. In programming - and many things we do - mental models are important. A good programmer doesn't lovingly hand-craft every artisinal instruction being sent to the CPU; they trust that a 'sort' library handles sorting well, etc. They know enough of how these work under the hook to figure out some problems, and other times will need help. A car is a similar example: I know how to drive a car. I know the maintenance basics - refueling, changing a tire, oil change, change air filters, washing - but I don't know everything. If my car throws the service light on and I look up the code, and it means that the Catalytic Converter is failing, I know at best I have some major research or a repair shop visit ahead of me. Mental models let us use things without being able to rebuild them by hand ourselves. All of this being said: are you not enjoying it because it's not clicking/is hard/etc. or are you not enjoying it because it's boring. The best developers, engineers and managers I've worked with are motivated to figure it out; the worst are only in the field because of a paycheck, and their lack of curiosity on the subject harms them, me and our end users. If you truly aren't enjoying it - not 'I just don't like these topics' but 'I never see anything cool about this', then pivoting isn't a bad idea. (I will argue, however, that the problem with many coding courses in colleges and especially bootcamps are that you do so much proof-of-concept or mechanically simple things that you would feel overwhelmed and like you cannot do the 'cool' things to see and hear about. And now for some specific advice... Recursion's text book definition is 'a function you call once that then call itself until a task is complete'. You typically use recursion for tasks that are hierarchal and uniform - for example, you wouldn't use it to read a deck of playing cards, as that's flat and easily done with a loop. It's often used in sorting algorithms - QuickSort is a great example, and [this video](https://www.youtube.com/watch?v=WaNLJf8xzC4) explains it well - each time you take a partition is a recursive call, and the key factor about recursion - knowing when to not recurse - is handled by 'how small are the resulting partitions'. Closure is a bit harder to work with. Part of this is because not all languages have them; another problem is that the problems they solve are typically less about 'this class of problems becomes possible' and more 'this lets me make more elegant solutions. I think [this](https://reprog.wordpress.com/2010/02/27/closures-finally-explained/) is a good explanation: a closure is a function that 'just works', and really because it had access to the state visible when it was defined. Put another way - you've been taught variable scope, and closures are a way to cheat around some of the rules you learned for variable scope. Consider a program with plug-in modules, like a web browser or text editor. These things use an API, but typically we think of API's as simply contracts to return values. Closures work in languages like JS, where a function is just another type of variable. This lets the API ask the plugin more elegantly - because it doesn't explicitly have to farm out the question - and the function that was initially returned from the plugin is a closure, meaning it can even access things like a plugin's internal configuration info. A solid example of this could be a text editor that has a formatting plugin, and you get to configure the format (I prefer spaces to tabs, and if there's a tab it's 2 spaces). Instead of calling the plugin directly every time, it can ask it once for a closure formatting function based on the current config. Then, every time it works on a block of text, it can format using that closure function, and still have access to your configuration. I can't find a good visual example for closures after a 1-minute search. If nobody else has one, and you're still struggling, let me know and I'll see if I can whip one up. Good luck, and don't give up because it's hard - only give up if you TRULY dislike it!
Why wouldn't this work with time traveling? Apart from the first run, this function does not change the behavior of the reducer. On top of that, you can still cleanly test the pure base reducer. 
As a programmer who does understand and use both recursion and closures, I have a set of counter-arguments for you: 1) Libraries often handle recursive cases for you. Sorting is an excellent example - most sorts built-in to language standard libraries are QuickSort variants, but they don't advertise it. As a programmer, black boxing it to 'it'll sort it, might take a moment, and I'll get a sorted list' is helpful. 2) Some domains do things more than others. I've been working on text-processing tools. Text processing doesn't often have a real need for recursion or closures. Mathematical and Geospatial applications have much less need for RegEx, input sanitization, text formatting, etc. 3) Many programmers inadvertently use language features without explicitly thinking about it. Almost every JS programmer uses closure in some way; many people right 'functions that call themselves' with identifying it as recursion. Heck, I've met programmers who actively dissuade their team from recursion as it's 'risky' or 'too hard'. Which leads to my point: Instead of bemoaning a programmer for not knowing, bemoan a programmer who does not try to know, or who absolutely evangelizes without figuring out if it matters. (No, I don't want to use Ruby or the latest library-of-the-month. I don't care if you cured cancer with it; I'm just doing a sort on a simple list, and the Java standard library is perfectly fine in our case.) Also, frankly, I care more about code being documented, well branched and source controlled these days. Your code is not self documenting in 95% of cases. You don't need to write a book but write something. I don't care how 'easy' of a fix you think this is, don't do it directly on the master branch.
Sorry, the short answer is no. [VueJS - Single File Components](https://vuejs.org/v2/guide/single-file-components.html). You need WebPack or Browserify. But, there is a [HTTP Vue Loader on GitHub](https://github.com/FranckFreiburger/http-vue-loader) that loads components via XMLHttpRequest.
Thanks for sharing the experience. And yeah, I think I would get to love React over time, but by now I'm just frustrated from learning new frameworks only to discover they don't fit my needs and throwing three weeks of experimenting instead of delivering. With both Gulp and Webpack, I think both approaches can work successfully. We had a gulp setup turn sour, because it just _aged_ and no one knew what exactly it's doing, in what order, and adding anything was a PITA. Which is one of my main problems with these systems - setting them up is easy enough, but bending them to your will later gets harder and harder. And as someone said, team usually end up having a "webpack guy" who siloes all the knowledge. For my personal projects, I don't want to be the webpack/gulp guy. (And don't get me wrong, I love working on infrastructure/architecture for server side stuff. I love me some Kubernetes. Having to architect and maintain a build system for a freaking HTML... no thanks.)
I've worked as a software developer for a few years now, since about 2010, and I generally enjoy it. But if I was in a competitive coding bootcamp I'd probably hate it. Bootcamps don't represent the general real world experience of programming for a living. You're not going to be spending 6-12 hours daily learning new concepts every hour.
yes
Not my policy. Anecdotally speaking, for /r/javascript, a vast majority of the submissions from `.in` are spam.
&gt; Somehow I bet you wouldn't get how to quickly determine if a dependency graph is a DAG or not Correct. And I wouldn't accept a lead position on a project that had anything to do with it, at least not without attempting to learn it. Also, while the comparison with closures may be somewhat apt, recursion is a *basic concept* in programming.
so, given that this is a technical topic, I need to understand the downvotes and your comment. You are entirely right in saying that not using semicolons, or using them, doesn't change the behaviour of ASI. That's true. I was just trying to say something along the lines of "Be aware of ASI". I guess your point is that my comment is irrelevant to the discussion at hand, given that either way you should be aware of ASI. I still think that there is a point where ASI just complicates things for people not using semicolons ex: var a = obj [a].forEach(logProp) // 'fail' i.e: ASI doesn't change either way but your *understanding* of ASI could complicate things anyways.
And it didn't sound like OP accepted a lead position where they needed to use closures on a day-to-day basis, in fact they specifically said the opposite. Oh, and my DAG example ended up being a one day thing that cropped up 4 years after I started this job.
Yep, total disaster. No one uses JavaScript and platforms are dropping support for the language. /s
The name "component folder" is the exact opposite of what's happening. This is "feature folder".
I think we will fundamentally disagree on this. If an "expected failure" is simply the ability to handle failures that can happen, then I would lump it into just "failure." For anything that might go wrong, we should handle the problem if we're able to, without distinguishing the multitude of "known possible failures" and random "unknown failures." I think, in fact, "expected failure" is just the wrong term. I would prefer to use "known possible failures" and "unknown failures;" this is similar to "known knowns," "known unknowns," and "unknown unknowns." Now, that said, to me, the idea of the two items quoted are not related. "Expected failures" are failures, and silent failures prevent handling of any kind.
your example actually is an example of when ASI doesn't apply, I was just pointing out that using or not using them won't magically make ASI not apply, it's always applying in all case all the time. If you don't want to use semicolons in your code, you need to think of exactly 3 scenarios (ignoring scenarios you will never see in real code, like having `++` on a line on it's own): * A line that begins with a `[` * A line that begins with a `(` * A line that begins with a `` ` `` And in those scenarios prepending a semicolon to the front of the line solves the problem (and there are multiple linters that can catch and warn you of that issue). So in your scenario, you could write: var a = obj ;[a].forEach(logProp) // 'success!' And in my opinion you need to worry a TON less about if you need a semicolon or not than with normal "semicolons included" javascript. Take this example: export default function () { const a = [ 'test' ] return { x: a } } Where "should" the semicolons go? In this example with "proper" js you should only have one (or 2 depending on your style guide). After the `]` and optionally after the `}` of the return statement. That seems super arbitrary to me, and I need to think about it a lot less when i'm not using them as the only time I care about semi's at all is when a line starts with one of those 3.
Damn, I like what I see. Thanks! Somehow I haven't stumbled upon this before. I'll give it a spin some weekend.
yes
I looked into it a bit, and quickly determining if a graph is directed and acyclic is to closures as building a bookshelf is to hammers. One is a task, the other a tool. When you need to inspect your dependency graph, you will know that you need to do it, even if you don't know how. If you can't wrap your head around closures, you'll never know when they would be useful (and thus never use them...) or understand the cause of "weird" behavior in your program.
[Relevant](https://www.reddit.com/r/javascript/comments/6n761u/what_is_meant_by_lexical_scope_i_dont_understand/). YDNJS is great resource to truly learn JS. Read [this &amp; object prototypes](http://dl.finebook.ir/book/4e/14725.pdf) it will become clear to you.
I'm all for threads because it will make JS a nicer compile target. I'd also like actor-like concurrency as part of the language. Web Workers are super clunky. You need a string or a blob containing JS source to spawn one, which makes building your app a whole lot more annoying. You can't just take some function and use that to spawn a worker. I very rarely use workers because of that. In Dart, you can spawn Isolates from top-level functions or static methods. I'd like to see something similar in JS.
Okay, but he didn't say he didn't understand closures, but that he didn't "get" them. I might be in the wrong here, but to me that is a completely different meaning. Just like how I didn't "get" currying at first, but could understand and use it if needed. Closures are tricky, regardless of whether you think they are easy or not, they can be difficult to understand sometimes, and even harder to know when they are a good idea to use. I'm almost positive any lead developer isn't going around not understanding that a function can inherit some scope, but they might not have fully thought through what that means, or how exactly it works and when and why. I'm just saying that it doesn't make them a bad programmer just like it doesn't make you a bad programmer for knowing the ins and outs of DAG generation. But i've hit my quota of internet arguments for the day (not to mention that I actually agree with you on some level that they should make more of an effort to learn closures, I just disagree that it means there is something really wrong if they don't use them), so I'm just going to disable inbox replies to the rest of this thread, and you can just assume I'm a really bad developer or friends with the guy or something.
Most of what you said is fine, but I'm not sure about your last statement. Especially in parallel execution, there are all sorts of logical concepts we need to be careful with.
Not only that, but as far as I know you can't prematurely exit from a forEach loop (you also can't use it to exit the function in which it's called since the forEach uses a function).
I'm rather fond of [hyperapp](https://hyperapp.js.org). It's tiny (&lt; 2kb), and includes both state management &amp; v-dom. Lots of the examples use JSX, but it's not required. Just use the `h()` function instead.
My experience with other languages has been immediate execution, and not calling the method if the application is not ready for it to run, or wrapping the async method in another method that can defer execution. The "anyone reasonable" remark comes from the idea that, when you call a method, you usually expect it to do what it's intended to do (I'm aware of lazy initialization and enumeration, etc").
we can only hope... Alternatively, you could compile IE6 via emscripten if you miss the pre-webpack days. 
It looks like a mashup of Vue and react but in vanilla js... I've used it and it's pretty cool actually...
You're learning; no one is an expert with something they're learning. The key is whether you're enjoying what you're doing, and whether it will keep your interest after you "graduate."
why would anyone do that? 
There's a simple solution to this. Just ban software patents. Sadly, the people in congress won't do that unless they have a loaded gun stuck inside their mouths. 
I honestly don't see a future for any JavaScript developer who doesn't have the patience to learn and apply the things that you openly hate, so I'm not sure how to be helpful except to suggest that you might be happier with another language. It's a weird question to bring to this sub. Most of us learned webpack while we were learning ES6 because we needed a reliable module loader -- so you're a little late to the party with your frustrations. You then pivot to hating on Typescript -- which has a substantially better developer experience and would help stave off webpack-based build systems. I want to help you be happy, because when we're happy we don't need to write titles that need censoring!
No one is funny on reddit. Srs bsns only.
easier to read on the eyes if you use single quotes....as for markup I've always used double.
I'm pretty sure this is the basis for one of the most wtf-inducing bits of code I've ever seen in a widely used library. From the [bluebird source](https://github.com/petkaantonov/bluebird/blob/ac381051cd26a6d1b735d9f8a239710f68a899c4/src/util.js#L201): function toFastProperties(obj) { /*jshint -W027,-W055,-W031*/ function FakeConstructor() {} FakeConstructor.prototype = obj; var l = 8; while (l--) new FakeConstructor(); ASSERT("%HasFastProperties", true, obj); return obj; // Prevent the function from being optimized through dead code elimination // or further optimizations. This code is never reached but even using eval // in unreachable code causes v8 to not optimize functions. eval(obj); } There's a [StackOverflow question](https://stackoverflow.com/questions/24987896/how-does-bluebirds-util-tofastproperties-function-make-an-objects-properties) about that snippet here, but basically it's taking advantage of the fast properties optimization.
That site looks really broken on my phone, as if a style sheet hasn’t been loaded in. And Vue is perfectly testable... 
No way, man. &lt;blink&gt;Netscape Navigator 3.0 Gold all the way.&lt;/blink&gt;
I get it, and I understand from a pragmatic view that it makes sense, but it still sucks. Just like the subreddits that require accounts be X days old or have X karma before posting.
&gt; Text processing doesn't often have a real need for recursion or closures. Funny, I literally just wrote a recursive text processing algorithm a few days ago: Given a database of strings, and a dirty input that is supposed to match one of the items in the database but almost always does not because of user input error, find the string that most closely matches the input, and scores it on a heuristic. The solution ended up being finding the longest matching substring, count the length of that substring times a heuristic coefficient based on the current depth of the search tree, and add it to the score. Then perform a binary partition by cutting out the matching substring, and recursively perform the same operation on both remaining parts (if any). It's got a 100% accuracy rate so far, even with up to 20% of the input being corrupted (our tests didn't bother going higher because analysis of customer data showed a maximum a 10% corruption rate in real-world data). And then there's this from last month: export const transformString = (str: string, transformation: StringTransformer): string =&gt; { // proprietary string preprocessing code cut out here return transformation(str); } // elsewhere in a consuming library: const transformationPipeline = (str: string): string =&gt; { return transformString(str, TurkishCamelCaseProcessor) } // higher up the chain in another file: const transformationPipeline = (str: string): string =&gt; { return transformString(middleware.currentPipline(str), DiacriticRemover); } // and finally in the resulting app: const result = transformationPipeline(input); Closures efficiently and cleanly abstract implementation details away from the end user. No futzing about with mutable arrays of transformers, where any hackish developer down the line would feel free to interfere with its contents in an unsupported manner. If a person says to me "I never need to use Recursion or Closures" then they're saying to me "I don't think about the problems I face in computing hard enough to analyze whether they are the correct solution or not, because I've already dismissed some pretty big tools for absolutely no reason". To put it another way: I was once tasked to design a visualization component for some massively complex hierarchical data. The project manager allocated 4 months for the project. Every developer passed on it due to a misunderstanding that complex data is impossible to visualize. I took it up and got the core of the renderer running in less than a day, in under 300 lines of code. Because recursion is the act of breaking up big problems into smaller problems. Once you get that down, you realise there's an insane amount of things you can do with computers where recursion is by far the best solution... Which almost nobody even realises because of the attitudes being tossed all around this thread, dismissing recursion as useless or too difficult. I'm done dealing with people who outright dismiss it. They make everyone's lives harder.
I thought the same thing. 
Is that logging the objects rather than returning them?
&gt; Okay, but he didn't say he didn't understand closures, but that he didn't "get" them. I might be in the wrong here, but to me that is a completely different meaning. To me they mean the same thing, but if that's not the case then yeah, I pretty much agree.
Thanks for sticking with me through this argument. First, I never characterized myself as a JavaScript developer. I mean, of course I didn't show you my CV, and I obviously develop in JS, so I don't blame you, but there's a distinction. I'm not looking for jobs in front-end development. I'm not claiming I'm the right person to start and maintain a modern SPA project. In fact, I hate frontend development, too! :D Second, if it's not clear by now, I use the term 'hate' liberally. I don't hate TypeScript. I *do* hate WebPack tonight, because it makes what's supposed to be a simple task (Give me ES6 code! Nice, clean ES6 code I can view and edit!) an impossible task. Is it my fault for expecting WebPack to do what it can't? Sure! Doesn't make it any less annoying when I have to deal with it in most frameworks. Third --- I'm a little late with frustrations? Pardon me? Was there a deadline where I was supposed to arrive at this subreddit, get acquainted with Webpack, and register my frustrations? Fill out my 27b-6 forms? Don't get me wrong, you don't seem like an evil horrible mean-spirited person, but having the approach "well if you don't learn this list of things ***I*** have learned, you don't belong in my club" is arrogant. JavaScript fatigue is well documented, and people telling others to get over it are major assholes, and it borders on telling depressed people to 'get over it'. Either way, the fact that you, and thousands of others have gotten used to Webpack at some previous point, doesn't mean my concerns are invalid and I should not apply critical thinking to this subject. Fourth, you sound like a major elitist when making comments like "I don't see future for people like &lt;something you're not good at but I am&gt;". There are people still happily programming in PHP, Perl, Ruby, COBOL, etc. Are you going to tell them they're not good developers because they actually do their job and lead their private lives instead of learning any of the dozen major JS frameworks being released every year, or the supposedly paradigm-shifting languages that others are hyped about? And related to that, fifth: If you honestly think that every developer should go through the steps you went through, based on your information bubble, then, uh, you are in an information bubble? I'm honestly puzzled if you're being arrogant or naive. Telling people to sod off isn't helpful. You're not some great blessing bestowed from heavens that will help me change my career for the better. We could have an e-peen war comparing all the things we've learned that the other didn't. Let me skip it: even if I was the worst developer in this thread, I am still capable of delivering products that make people happy. _With crappy code. With old frameworks. Without keeping up with the latest React release. Without TypeScript. Without unit tests. Without Webpack._ Am I saying that people shouldn't learn those things? That using Webpack in a team is a bad thing? Of course not. I'm just saying that frontend developers have gotten used to abysmally bad UX with current generation of tooling, and then bullying others who have a problem with it.
Still better than the hashtag private variables proposal. 
The bug is a regression in handling jsonp, so only occurs in top level code, and (because it's actually a bug in how JSONP is handled) only applies to sufficiently simple scripts. Still, sadness :(
I don't think so. "Help" and "learning" subreddits for any given subreddit seem to drain the original subreddit of newcomers, and the "help" subreddits seem to be slow in terms of posts and comments made.
It really doesn't matter. Just be consistent. 
You can use `find` to exit on the first match. If you're exiting the containing function half way through a loop, you should probably refactor you code.
Yeah, just tested it. It doesn't `return` anything, just prints out the objects. 
Personally I don't mind mixing them (but prefer double quotes for JSON compatibility, and so that I can use bad English punctuation), but The only really pragmatic argument I found was that it makes search in code with regex a bit easier - but that happens rarely from my experience. So, yeah. If it's a personal project, be consistent. If it's a team project, be consistent, and maybe do compromises to keep your more OCD coworkers sane.
The big question is, "Do you enjoy it?" Not the floundering part, but the actual coding part. If so, work through the challenges, if not, then don't make yourself miserable just for a job market that is hot. 
Could you just run Babel from the command line?
You best get used to it. The web is one of the fastest moving parts of tech. I, for one, don't want to return to the days of stagnation and supporting 15 year old browsers. I learn at least one new paradigm or library a year. You should to. Not so you will know THAT library, but so you can understand the underlying techniques that lead to its adoption in the first place. React brought us the virtual dom, a critical concept that has influenced everything, including Angular. If you don't want to use a build system, that's up to you. But the things you will be able to build will forever be limited to the technology of yesteryear, simply due to the inability to handle the sheer amount of steps necessary to get equivalent functionality and efficiency that one could with a build system. I don't like messing with build systems either, but it's necessary. You need to just maintain the code like any other part of the codebase.
 ^((that's not the punchline)^)
I, too, got the email.
The scenario you're describing here is perfectly fine. What you'd want to avoid is mixing single and double quotes in your JavaScript (not including JSX). If you're consistent in how you use quotes, grepping through your codebase will be easier later.
I've been using JavaScript for almost 20 years, and half the crap I learned about it is no longer relevant and/or true. Programming changes all the time. You have to get comfortable with the fact that you'll never know everything, and job postings that say you need like 5+ years of experience ignore the fact that the industry flips on its head every few years. Couple of years ago: Two way data binding is the future! Now: Two way bindings are the devil! We're all still figuring this crap out. GraphQL makes me super nervous.
I'm not going to make time to help petulant jerks who can't write a sentence without resorting to hyperbole. It's obvious that the problem here is a __who__ and not a __what__.
What I'm referring to when I say JSON is the ViewBag.SelectedLicenses yeah I only made it short because I thought this was a easy straightforward question but then people started asking questions about what I meant so I guess it wasn't haha. 
What's arbitrary about your example? It should have 2, one after each expression. The 2nd one isn't optional in proper code The arguments against using semicolons in code are absurd. Explicit code is *always* better, as the first half of your post proved: "you don't need semicolons... except when you do"
This will re-run every time you jump around in the action history, thus writing the historical state to local storage. That's unlikely to be what you want.
I started using [connected-react-router](https://github.com/supasate/connected-react-router), it has good readme and [FAQ](https://github.com/supasate/connected-react-router/blob/master/FAQ.md). So far I haven't had any issues with it and it supports HMR quite well, but no SSR support (which is fine for my project).
boo
Here's the real answer. Linting FTW.
No, it's just hilariously divorced from the truth.
I'm willing to bet that your opinion might change if you were a mod or admin, and had to deal with the sheer amount of spam from `.in` and new accounts.
Like i said, I understand the reasoning, but I wish there was a better way. Indirectly driving away Indian users or new accounts or whatever sucks. 
I actually meant for the optional one to be after the function definition, but forgot that I needed it after the return statement and had to go back and amend it. My point is that it's explicit for no benefit. I don't gain anything by seeing a semi, considering I need to know if something is an expression to even know if it needs one anyway. And the "except when you do" argument seems silly. You don't need curly braces in every situation, except when you do. But in the end it's style, as long as you're consistent I don't care what you prefer.
Or just use the built in sort on a typed array which is faster than any of these...
One less keystroke if you use single. 
But you're not "calling a method" per se, you're defining a type. When you define lazy, possibly infinite iterables, are you expecting them to BE infinite, right then and there? It's the same with continuations, really, which is what Promises/Tasks/Futures are ultimately modelling. Future values by definition may not exist yet. The point, as I see it, is to continue programming with that detail abstracted away. That's what pure types make possible, and what Promises obscure.
Well, they certainly like to act like they're the first!
&gt; How can I do that if they both run on different ports. I use a reverse proxy and proxy all my api requests to the express server and serve the static files via the proxy.
Which is why curly braces should always be used :) Consistency is personally why I hate the idea of leaving them out. So there's no semicolons in your code, cool. Except for this one, and this one over here, oh and there should be one here too. If you can't remember the rules just use prettier or a linter
The language is great because it's easy to pick up and uniquely positioned in the market. That doesn't mean that even it's designers think it's well structured. In fact, the opposite: it's popularity it's exactly what makes it messy.
Researched a bit and what I did was in the package.json file I added "proxy": "http://localhost:8888" in react what I did was componentDidMount(){ fetch("/api") .then(response=&gt;response.json()) .then(data=&gt; this.setState({data: data})) .catch(error=&gt;console.log(error+' 1')) } if i go to localhost:8888 I have an api But if I go on localhost:3000 I get . SyntaxError: Unexpected token &lt; in JSON at position 0
Curly braces always used? I don't really want to wrap every expression in curly braces, but you are free to ;) And nobody is saying "100% no semicolons", just like you aren't saying "semicolons on every line ever!!!", It's just a preference to not end lines with semicolons if possible which it is in 99.9% of cases. But to keep it consistent, no line should end with a semicolon, you prepend them if needed in those 3 edge cases (which I checked, and only appear 6 times in our 200,000 LOC codebase!) And I do use a linter, I use [Standard](https://standardjs.com/) across my whole codebase.
it's just like, even as a beginner every book I look through, even recent ones a year or two old, all start with teaching "var." Then I come on these forums and it's all "no, don't use var, that's old, learn 'let' and 'const'."
Oh, hello! You can ask questions here too, if you like. I may just be slow to respond.
I'll absolutely agree re: being dismissive of it as 'useless or too difficult'. Those attitudes prevent someone from ever learning those tools. Recursion tends to be easy once you recognize that a) you need a problem that can be solved by divide and conquer and b) you understand that you must protect against excessive recursion (not just infinite, because the language library typically enforces a smaller recursion limit). I think part of my own lack of closure use is due to the fact that my first few years out of college, I was on a 100% Java project - and Java didn't have closures until Java 8. There are probably problems I try to solve in other ways that closures could solve more cleanly.
I mean, use var when it's appropriate for hoisting and stuff, but then, probably don't do that, because you almost never want that, and it'll give you debugging headaches. Programming is hard.
You will be surprised about browsers built in sort. Barsort is about 10x fast as Firefox v57 native sort. It's about 50x fast as ...this 2 year old version of Node I'm running, and that sort wasn't "stable". 
Interesting... Why would JSONP require special treatment?
Lol wut
so why does every book start with var, then? 
&gt; And whatever you call it is fine for you, but it's in the spec and consistently implemented by all browsers. Yes, this is what people tend to forget. It's not "technically incorrect" to leave out semicolons, which is "conveniently caught by ASI." It's a well-defined feature of the language. Just use it competently (don't run into the edge cases) like any other aspect and you're good. Besides, in my view, a modern setup contains linting anyway, to catch these rare edge cases if they should occur.
 for (var x = 0; x &lt; 10; x++) { break; } // x == 0;
Hahaha so true.
johnfrazer783 has it. As a very happy user of Fluture (and a previous huge fan of promises) I would just recommend you give the library a shot and see if you like it. Something data related and very asynchronous would be best, like a multi-api scraper or something. The separation of asynchronous and synchronous mapping was the first thing I found very appealing.
&gt;&gt; console.log(That); "weird" !? 
They're cautious adopters of new technology. Their usual strategy is to let someone else go first, and then a year or so later they come along with a more refined version of it. Apparently pointing this out hurts some people's feelings, though.
&gt; a typed array I've benchmarked all the browser sorts. FF is slower (for now), chrome &amp; safari native sorts are faster than any js implementation. Care to explain why stability matters on a numerical-only sort? :P [edit] LOL, I [benchmarked](https://jsperf.com/fastest-sort) it on a 1M element array. It loses to `Array.sort` by 19% (100% in FF), to a native typed array sort by 4,500%, and even to a pure js radix sort by 300% If I did something wrong please fork the test and prove it :)
Because 'let' and 'const' weren't introduced until ~2014. Any book written before then would say 'var'. I know it seems really frustrating to learn, but I promise you: once you know the basics, when you start hearing about new features like 'let' and 'const' it stops being a scary thing. Because by then, you've been using the language long enough to really appreciate the new features. You won't be scared - you'll be excited. 
It was coming from my controller method, I posted the code that I used somewhere in this post. search for 'selectedlicenses'
If you're building a Redux app, [redux-first-router](https://github.com/faceyspacey/redux-first-router) can't be beat when it comes to routing for Redux. I'm its creator. Feel free to hit me on "Reactlandia Chat" linked from the top of the repo if you have any questions.
You have made a mistake in your benchmark. Before I saw your edit I ran a test on latest Chrome browser showing barsort is indeed much faster sorting equal distribution numbers, in a normal array and in a typed Float64 array: Benchmarking 1 seconds each function Checking sort functions Batch Testing Barsort :: 400 equally distributed reals from -20 to 20 Length 400 - tested: stable native sort 6088.6174 func/s barsort 6544.3258 func/s :: 3600 equally distributed reals from -20 to 20 Length 3600 - tested: stable native sort 189.5647 func/s barsort 607.8236 func/s :: 10000 equally distributed reals from -20 to 20 Length 10000 - tested: stable native sort 54.7073 func/s barsort 221.7369 func/s :: 100000 equally distributed reals from -20 to 20 Length 100000 - tested: stable native sort 4.1797 func/s barsort 18.8055 func/s :: 400 typed array, equally distributed reals from -20 to 20 Length 400 - tested: stable native sort 3331.1456 func/s barsort 5120.0336 func/s :: 3600 typed array, equally distributed reals from -20 to 20 Length 3600 - tested: stable native sort 167.5567 func/s barsort 576.0000 func/s :: 10000 typed array, equally distributed reals from -20 to 20 Length 10000 - tested: stable native sort 49.7144 func/s barsort 199.8114 func/s :: 100000 typed array, equally distributed reals from -20 to 20 Length 100000 - tested: stable native sort 4.1323 func/s barsort 17.0255 func/s Checked sorts 8 times. Saw 0 issues 
&gt; You have made a mistake in your benchmark which is?? You can run them yourself and even edit them, just click the link I posted. You can post as many numbers as you want, they're useless if nobody can repro
Yeah but: &gt; Thursday, July 7, 2016 V8 has probably improved in that area in recent versions due to turbofan.
As /u/bel9708 said, be consistent. We use double quotes. Single in rare exceptions. Mainly because JSON and we also are a java house so it bleeds over from there and it just feels consistent in the code style (same thing for semi-colons to terminate lines). If you want some well thought out (but opinionated) talks on the subject, watch some talks from Douglas Crockford on youtube.
&gt;which is?? The function is called 'sortorder' now instead of 'sortindex' that is why its giving the error. Sorry thats my fault i must update the docs.. 'sortorder' should beat all those if you test with arrays of 5000 to 500k long. 'sort' is hobbled a bit because it has to do a clone which is heavy with benchmarking 1 million element arrays.
Probably when you needed to do something `x` times where `x` is some predefined number? Though I guess there are still other options for that (lodash's `times`, generators, recursion, etc.)
Typescript works pretty well for me. You can even skip the compile step and not output js files at all with [ts-node](https://github.com/TypeStrong/ts-node). Auto-reloads also work with nodemon. One non-obvious thing that took me a while to figure out is that some Express types are in `express-serve-static-core`. So: import {Request, Response} from 'express-serve-static-core' function someController(req: Request, res: Response) { ... 
Updated the call, it's not any faster than `.sort()`, and updated to 100k elements and it still loses to `Array.sort()` by 2x and `Int32Array.sort()` by 400x (and `Float32Array.sort()` by 100x since that's what you referenced earlier) I'll repeat -- if you think my tests are broken then edit the test yourself and prove it. Or provide the code for your tests, not just the results.
&gt; Nobody is dumb enough to join me. Contemplate this a while longer. 
&gt; With WebPack, I'm being forced to do things I have zero interest in, adding bloat to even the simplest of projects. I mean, there's a lot of things WebPack is guilty of, but it specifically helps eliminate bloat by performing dead-code elimination in its bundles. Or do you mean to say the 252 NPM modules it brings in? Because that that shit is a little whack. 
Unoptimized JS performance still matters if you're supporting older versions of Firefox, Safari, and IE.
&gt; I honestly like my javascript to be the same as I wrote it... I'm not sure I understand this complaint. Source maps are a wonderful thing, and they're bundled right into webpack's output so that when you're debugging it, all you see is the javascript, same as you wrote it. Sure the underlying code is a bit different in structure but not in function; it's exactly like debugging a compiled language these days. You step over one line of code, your computer is really executing 20+ ASM instructions, but it's all transparent to you. 
What would that logic look like, I freely admit to my JS being hot snot, so any help would be greatly appreciated. 
True. And standard `for` is probably still faster in latest Chrome anyway. Just trying to point at that the difference isn't necessarily that big anymore (since the test was done in Chrome).
Fluture doesn't appeal to me because of Fantasy Land. My preference is async/await (which I use in C#), or RX, which really abstracts the async away. I was never a huge fan of Promises despite me defending them, but I'm not into FUD either.
Well, Im not making up any results, and I know mine are tested and checked. Code is in the repo. I dont know about yours, typed array sorts shouldnt be so different ?? but thanks for the feedback.
&gt; I don't want anyone to transpile the code I write (before production, at least). In best case scenario, it ends up looking disgusting, in worst case, buggier than I made it. I've been transpiling code for 5 years now. I've not seen a single instance where it ends up buggier than the original. Now about the "disgusting" case. Sure that can happen. But source maps were invented to fix this problem. You debug your code, the browser will load the source map and show you the non-disgusting original version that you wrote. It's wonderful. I urge you to give it a shot. 
Your tests are broken then. My tests are *stupidly simple*: ary.sort vs Barsort.sort(ary) Not sure why yours have thousands of lines of code... or why there's no documentation on how to run them
One reason my tests have so much code is they check the results and calculate things like the average misplacement if there is any. They also test lots of different random distributions and patterns. We dont know what jsperf is doing with the outputs, or even if they are valid.
In JS, async/await is just promises that look nicer, so there is no technical difference. Actually funny you say that, I was using Fluture for months and then started a job that used RX and they're actually very similar in usage, but you sound like you know your own mind. What is your opinion of Fantasy Land if I may ask?
WHEN PATTERN MATCHING IN OFFICIAL SPEC????kthx
&gt; One reason my tests have so much code is they check the results and calculate things like the average misplacement if there is any. cool, but I still can't run them locally without instructions :) &gt; We dont know what jsperf is doing with the outputs, or even if they are valid. Fair enough. function runTest(name, times, setup, fn) { let elapsed = 0; for(let i=0; i&lt;times; i++) { setup(); const start = +new Date(); fn(); const end = +new Date(); elapsed += end - start; } const avg = elapsed / times; console.log(`Ran ${name} ${times} times in ${elapsed}ms (avg: ${avg}ms)`); } let ary = null; function setup() { ary = []; for(let i=0; i&lt;100000; i++) { ary.push(Math.random() * 1000); } } let iAry = null; function setupi() { setup(); iAry = new Uint32Array(ary); } runTest('ary.sort()', 100, setup, () =&gt; ary.sort((a, b) =&gt; a-b)); runTest(`Uint32Array.sort()`, 100, setupi, () =&gt; iAry.sort()); runTest(`Barsort.sort()`, 100, setup, () =&gt; Barsort.sort(ary)); runTest(`Barsort.sortorder()`, 100, setup, () =&gt; Barsort.sortorder(ary)); runTest(`radixSortLSD(iAry, Uint32Array);`, 100, setup, () =&gt; radixSortLSD(iAry, Uint32Array)); yields Ran ary.sort() 100 times in 7701ms (avg: 77.01ms) Ran Uint32Array.sort() 100 times in 393ms (avg: 3.93ms) Ran Barsort.sort() 100 times in 906ms (avg: 9.06ms) Ran Barsort.sortorder() 100 times in 894ms (avg: 8.94ms) Ran radixSortLSD(iAry, Uint32Array); 100 times in 201ms (avg: 2.01ms) FWIW this is actually performing a *lot* better than jsperf claims, so you're right there. But I'm kinda shocked about the radix sort! I'd be curious to see how it does if you swap out the array type. Care to modify your code to allow for different array constructors? Should basically be: function (..., aryConstructor = Array) { let sortedArray = new aryConstructor(); ... } [edit] never mind, it only makes yours ~10% faster
Hoo boy. Going pretty hard on the paint, arn't we gang? I have thoroughly enjoyed the improvements to javascript over the last couple of years. They've made my job a lot easier. Especially with the toolsets and libraries developed alongside it: Transpilation, linting, testing, module bundling... nobody would dare start a project without them! We keep adding features and using development environments like TypeScript, Flow and Dart to make it behave more like a general purpose systems programming language. I suppose my point is this: what's the point of using a dynamic, interpreted language if we're just going to *transpile/compile* it down and treat it like a systems programming language, anyway? Javascript has become a blueprint for what we *really* want to do web development in: Web Assembly. I guess I see no real harm in continuing to add features to Javascript, but I feel like it makes more sense to encourage growth of Web Assembly, and use javascript for it's original purpose; Scripting. 
This would be a pretty gigantic bug, right?
very courageous
I agree with you, actually. They don't really act like they invented everything. I think they just get this reputation because people kind of think of them like that, especially given their marketing in the '80s. "Think Different" doesn't usually mean "do the same thing everyone else is doing, just a little later". One of Steve Jobs' quotes is: "If Ford asked people what they wanted, they would have asked for faster horses", implying that Steve Jobs was inventing the car while everyone else was just training horses. So their rhetoric was initially fairly "innovative", but it's basically a totally new company after the '90s, but their brand stuck around. They've come out with a few innovative things, also, and their innovations are bigger. It's not usually technical innovation, but it is definitely product innovation. Making capacitance screens instead of buttons? There were a small handful of touch phones before it, but none with even remotely the polish or featureset of the iPhone. And they already had been marketing the iPod (which was a major ripoff with basically no technical innovation, but it was marketed well and at the right time), so they could merge that and emphasize what the users already understood: It's your music player and your phone, combined. Even without all the customization (learning what an "app" was was kind of disorienting at first, at least for me), the appeal is blatantly obvious. If they never put in internet capability or anything like that, it still would have been the next big phone. It was something users could understand. But then they were like the last people to the game on the tablet, and making the phone bigger, and tricking it out with nice peripherals. So, they weren't innovative on the tablet, but they did completely revolutionize how we think of phones and the internet. So on the whole, they are an innovative company, but they don't act like it that much anymore. They're not *really* saying "This is the best of the best". They're saying "This is the choice for the masses. Your grandma can use it." and people are saying "I am in the masses." and nobody is worse off for it. Do they say they're doing stuff that no one else does? Sure, but are there any companies that don't do that? MS does it. Google does it. Facebook does it. Anyways, the way I see it, they get a lot of hate because they're successful despite not being the greatest iteration or being on the cutting edge. I also hate them because their customer support is garbage and their products are overpriced and annoying to use. But I recognize that most people really care too much about the quality of customer support, and they're not power users. So they like iPhones.
Because people insist on using it to transfer megs of data, so that’s megs of code to parse, compile (even just to the interpreter's bytecode) and then /execute/. Ignoring entirely the huge amount of time required for this the memory use is insane: First there’s the overhead of the syntax tree, I can’t recall exactly but it’s in the order of 48 bytes per node. So say you have [1,2,3,4,...] every single digit number will take 48 bytes. Strings take even more as you need the AST node and the string itself. So your 2-3mb of data is now taking 50mb. Then that ast has to be compiled in something that can be interpreted. The jsc bytecode uses varying length instructions made of 64bit words. Pseudo code for setting a value would probably be something like ``` new_array r0 // create a new array into r0 mov r1, #0 // load the literal 0 into r1 put_by_index r0, #0, r1 // set index 0 of the array in r0 to the value in r1 ``` So ignoring the other slots (cache related) you get at least 56bytes to put each value in the array down. For object liberals it is even more. Again this is ignoring additional additional magic fields. This leads to an additional problem: if you're generating the byte code from the AST then you end up with the AST and the byte code be in memory at the same time, and then while generating the byte code you'll need to periodically grow the buffer, so that means allocating another buffer that is bigger than the current buffer and copying into that. So worst case scenario you end up with the original script, the AST, and two copies of the byte code in memory, so your 3mb of data has become 150+Mb. This obviously causes problems on memory constrained systems. With memory usage getting to these levels you even get hit systems with &gt;1gig of ram as you can very quickly get to the point that you're paging, just so you can interpret your data as a script. [I'll update when I get home/off my phone and can look at code]
I APPRECIATE YOUR SENSE OF URGENCY SIR!!! Maybe 3 years at a minimum, say? It's hard to predict.
Still too long :( But thanks for pushing so hard for great features and making JS great again. Much appreciated!
I am very curious about your jsperf and that radixsort. I had an edit there and it didn't save doh! I'll have another go in the next few days. Ill try tidy up a testing file in the repo too, but my brain is just a bit frazzled with it at the moment. Im not 100% confident of that boast 'barsort is the fastest!' holding up, its just darn fast and deserves a look in.
FYI the radixsort is from an article posted a week or so ago. I was testing the same claim you made :) I just modified it to use typed arrays
Opinion: Fantasy Land is ugly af and is one of the more terse and convoluted-looking FP languages I've seen. 8-) More reasonable answer: as I hinted at in my original comment, I think programming languages have been at a point for a long while where we don't need to abstract our logical problems into mathematical ones. I'm not going to argue FP doesn't have a place, but the extreme adherence to algebra as a general purpose language doesn't seem useful or practical to me.
My counter-opinion would be that there is perhaps more value in languages that are [discovered rather than invented](https://medium.com/@kaychaks/wadler-s-act-in-strangeloop-cd59e3dcf710). Certainly it doesn't seem to me a great strategy to just poke around and hope we accidentally create something better... And hey, terse is great!
I just tested it on a whole range of inputs and its 2 to 3 times as quick as barsort on everything - amazing. Ill link it in the repo and put that project to sleep then! cheers :) edit, but it 'only' sorts positive integers properly, and cant make an index hmmm
[removed]
I disagree. Javascript has become a very powerful general purpose language imo, and I prefer it over the other languages I know well (namely C++, C# &amp; .NET, PHP, Java) for the creation of applications that handle data persistence (either on a server or locally). I create desktop apps using Electron, phone apps using Cordova, server apps using NodeJS, and so on. The main reason for that is javascript's powerful combination of weak types with anonymous functions/functional paradigm. I rarely even use true OOP in JS (prototyping, classes), I just structure my data in JS objects and go with it. JSON data flows beautifully between client and server JS. In other languages, there are very strict standards for doing stuff because they need to be easy for multiple people to work together. In javascript I don't need that because doing stuff is so much easier I just do big chunks of stuff alone. I've once worked with three other people to build an extremely simple e-commerce platform in PHP. Took us 4 months. I've written an e-commerce platform last semester in Node, took me less than 3 months with double the features. Granted, JS enables you to do more messy/hacky code, but after working with it for years, I consider my JS code very clean and optimized/efficient, albeit not very standard. JS enables me to work alone and still produce competitive software with beautiful interfaces. I don't just do web development in JS, I do everything. Javascript is my life. I do not use transpilers. I do not use frameworks like React or such. I do my stuff in Node and Express for backends with very minimal templating (Handlebars or EJS), vanilla HTML/CSS and JQuery for frontends. Anything more than that is too much for me. Everytime I build a web app, everything is from the ground up. If I need a pattern for things like routing, I just build one. No need for things like meteor. Javascript enables me to produce ~5000 lines of code per day, written by hand, in a very purist environment. I've written blog engines with comments, tags and a ful control panel in two days. I'm sorry, I just love JS and I'll defend it till death.
&gt; I'm not sure I understand this complaint. Well, it's not a compliant, just personal preference. In my case what I don't like is the compiling process. I'm mostly a Java dev who need to do some front end development, some minimal UI for my web services. In my java life I'm used to a heavyweight approach to software building (write, compile, build, deploy, dependency management via maven, different commands to run or debug, etc) . I used to enjoy the lightweight approach to software development that was javascript: you typed your code and linked or copied the extra libs you needed and that was it, a nice contrast. Now javascript development is becoming more and more java-like... and for java-like, I like java better! Now I'm sure in serious projects the heavyweight approach is better, but for a small SPA with a couple of screens it seems too much. (English is not my language, I hope I was clear enough)
fair enough
Is your api serving the correct Content-type for your json? 
I don't know why anyone would purposefully leave off semicolons, anyway. It's lazy and makes the author look bad.
 a la ColdFusion? god I hate that garbage.
Mate, I'm not sure I can agree that discovery is greater than invention; I would argue they are equally important for different reasons, and sometimes they are the same concept. For example, creating the transistor wasn't just an invention that came to fruition because William Shockley, Walter Houser Brattain, and John Bardeen knew the exact chemical elements and electrical behaviors they needed to get things done. Likewise, a working transistor wasn't just dug up from the ground one day. A lot was discovering new doping materials, or research on diodes, etc. It's the combination of discovery and invention that brings things to fruition. Regarding mathematics, I agree there is a lot of discovery there. I'm blown away at what mathematicians have connected, and can prove definitively. That said, to make these discoveries useful, mathematics had to be invented first. From there, formal logic, algebra, calculus, and more were invented to make sense of the discoveries, and to make them useful for higher-level concepts. Then on top of some of those inventions, programming languages were designed and invented. As languages progressed, more and more of the mathematics were abstracted away, which isn't a bad thing. While it can be annoying, and some might argue dangerous, that "anyone can code," there is something to the idea that programming languages, sometimes visual ones, abstract what the universe does enough to make it work for us without needing to understand what's behind it all. Anyway, we're getting into philosophy more than anything now, and I know I don't have the wherewithal to get too into it. We're also far from my original response, which was just an opinion about Fluture and my thoughts on failures. In closing, F# is enough for me for now. ;)
See also: ServiceWorkers and AppCache
I haven't used a for loop in a long time 
Or a while loop 
True, you have a point with source maps. I guess I got upset because I was (briefly) tring to get Webpack to give me readable code out right.
Precisely because memory management is a mechanical procedure which can be automated. Go won't replace C in all the cases, but when you need concurrency it makes your life enjoyable. And in the rare cases where you still need C you can always use it alongside Go. Best of both worlds.
I mean, sure, having 150-220MB of node modules is one part of the bloat that irks me, but of course running `npm i` isn't difficult. My bigger issue is with the setup. I want to be able to have a dead simple environment, just an IDE and files, and having the same code in browser, too. I can always add build system later. But I want to be able to start without it.
Follow on now that I'm home (you can do this on Mac, or I suspect linux if you have the right JavaScriptCore package installed) Somewhat hilariously my super pessimistic comments above aren't 100% true, due to an optimization /I/ implemented (presumably to deal with exactly this memory issue). Instead of creating a series of put_by_index calls (which it did do when I first made the JSONP optimization), it has constant buffers for array initializers: Assuming `jsc` exists, on Mac it's /System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc Everything is prefixed with if(false); simply to prevent the jsonp optimization. jsc -d &gt;&gt;&gt; if(false);var x = [0,1,2,3,4,5] &lt;global&gt;#BjkFdk:[0x1061800a0-&gt;0x1061c7200, NoneGlobal, 33]: 33 m_instructions; 264 bytes; 1 parameter(s); 8 callee register(s); 5 variable(s); scope at loc3 [ 0] enter [ 1] get_scope loc3 [ 3] mov loc4, loc3 [ 6] check_traps [ 7] mov loc5, Undefined(const0) [ 10] jmp 2(-&gt;12) [ 12] resolve_scope loc6, loc3, x(@id0), &lt;GlobalVar&gt;, 1, 0x1061e80a0 [ 19] new_array_buffer loc7, 0, 6 [ 24] put_to_scope loc6, x(@id0), loc7, 1048577&lt;DoNotThrowIfNotFound|GlobalVar|Initialization&gt;, &lt;structure&gt;, 98192352 [ 31] end loc5 Identifiers: id0 = x Constants: k0 = Undefined undefined &gt;&gt;&gt; We see that the instructions for the code are 264 bytes, which would be constant for any array length, but there are a few caveats. 1. It has to be an array of primitive types (numbers, strings, booleans) 2. It still requires an array of gc values, so that means everything is boxed, so your small numbers get turned into JSValue in JSC, which is 8 bytes per value. If we switch it to non-trivial objects the code necessarily becomes insane $ jsc -d &gt;&gt;&gt; if(false);var x = [{index:0},{index:1},{index:2},{index:3},{index:4}] &lt;global&gt;#AcSRko:[0x1035800a0-&gt;0x1035c7200, NoneGlobal, 98]: 98 m_instructions; 784 bytes; 1 parameter(s); 12 callee register(s); 5 variable(s); scope at loc3 [ 0] enter [ 1] get_scope loc3 [ 3] mov loc4, loc3 [ 6] check_traps [ 7] mov loc5, Undefined(const0) [ 10] jmp 2(-&gt;12) [ 12] resolve_scope loc6, loc3, x(@id0), &lt;GlobalVar&gt;, 1, 0x1035e80a0 [ 19] new_object loc7, 1 [ 23] put_by_id loc7, index(@id1), Int32: 0(const1), IsDirect|Bottom [ 32] new_object loc8, 1 [ 36] put_by_id loc8, index(@id1), Int32: 1(const2), IsDirect|Bottom [ 45] new_object loc9, 1 [ 49] put_by_id loc9, index(@id1), Int32: 2(const3), IsDirect|Bottom [ 58] new_object loc10, 1 [ 62] put_by_id loc10, index(@id1), Int32: 3(const4), IsDirect|Bottom [ 71] new_object loc11, 1 [ 75] put_by_id loc11, index(@id1), Int32: 4(const5), IsDirect|Bottom [ 84] new_array loc7, loc7, 5 [ 89] put_to_scope loc6, x(@id0), loc7, 1048577&lt;DoNotThrowIfNotFound|GlobalVar|Initialization&gt;, &lt;structure&gt;, 32132064 [ 96] end loc5 Identifiers: id0 = x id1 = index Constants: k0 = Undefined k1 = Int32: 0: in source as integer k2 = Int32: 1: in source as integer k3 = Int32: 2: in source as integer k4 = Int32: 3: in source as integer k5 = Int32: 4: in source as integer undefined &gt;&gt;&gt; Here we can see the code size is getting larger, and that size increases linearly with the number of elements, but the multiplier is 104 bytes per element. All of this is /before/ you try to execute the code, which has a bunch of other other allocations involved, and ignores other things that increase the total memory usage as well. And executing jsonp is slower than just constructing the object directly :D
I worked with a project using Babel once and within two hours I found out a bug that didn't let me use valid ES6 in some case.
Oh, no worries, I've contemplated that quite a lot. A big part of the reason of why I posted here is to see how people think - instead of just resigning and installing webpack without thinking it through. Also, just to make sure - the ES6 Angular 4 project is a spare time project meant to learn things, experiment and see how can things done be differently (for better or worse).
This can be said for pretty much any platform. Put your static files on a cdn.
Possibly. Sometimes stupid inelegant code is easier to read and understand though. Consider the following: function doesShipExplode(ship, obstacles) { var obst_idx, obst_len; for (obst_idx = 0, obst_len = obstacles.length; obst_idx &lt; obst_len; obst_idx += 1) { if (ship.overlaps(obstacles[obst_idx])) { return true; } } return false; } Pretty much anyone who knows anything about JavaScript can read that code. It may not be the most elegantly written code, but it behaves correctly and, best of all, exits as soon as it encounters the first overlap, whereas in `forEach` you'd still be looping over all the other obstacles (although, of course, you could just do nothing each loop): function doesShipExplode(ship, obstacles) { var exploded = false obstacles.forEach(function (obst) { exploded = exploded || ship.overlaps(obst) }) return exploded } If there are a lot of obstacles, that's a lot of looping. I feel like there are a lot of situations like this, where you're doing a test that says, "If this is true (or false) for a single item in the array, then it's true (or false) for everything" In which case being able to break out of the loop is a very good thing IMO. It looks like there is `Array.some` and `Array.every` which could serve this purpose. It's worth noting that the algorithm specified to implement `Array.some` does itself exit the function from within the loop, if it encounters a value that evaluates to true.
Right, like I said you can't exit prematurely from a forEach loop. Unless I'm not understanding the purpose of your comment.
My apologies on the late response, never saw the response. That sounds like a good combo to look at. I've been seeing a lot of people throwing meteor and sails at every project lately. I had installed feathersJS on my computers but never got around to building a feathers app yet so that is something I would likely try out soon. Still working building MEAN apps but looking to maybe venture out and see anything seems more comfortable or better suited for my apps.
Yes, I use that option, and constructing blob properly, with the type of audio/webm, I will try your suggested first option, and will let you know! :)
PM me if you want a little bit of extra help. I used to teach at a very competitive bootcamp. 
I used to feel the same way. But I gave it a try for one project, and now I'm sold. It just looks cleaner to me. Less visual noise. Anyway, I suggest you give it a try sometime. With ESLint you can automate this (and go back to semicolons if you end up not liking it).
Wow, thanks for all the details (and for your work on JSC, I hadn't inferred you were working on it from your first comment).
I uploaded my project github if pou want please check it out. If you want to test it you will have to go npm i . And got to the server file and npm i also there. Here it is. Please because I don't know what to do anymore. https://github.com/RandomGenerator42/React_really-not-working
See https://www.reddit.com/r/javascript/comments/6wy6zj/latest_safari_uses_for_assignment/dmcfupg/ for the details by /u/olliej who wrote and maintains that part of JSC, there's a bug in the JSONP-specific parser (because the overhead of plain JS parsing for large JSON objects is too much so there's a specialized code path). edit: /u/olliej is actually the author of the JS/JSON parsers
And here is the a screen shot of the api http://prntscr.com/gf989b .
I started to get a deeper appreciation for JavaScript once I wrote shell scripts in it: the setting is simpler and I find it much more logical than shell programming languages sich as Bash, AWK, etc.
I wouldn't suggest AngularJS for any new project, use Angular 2+. Angular CLI is pretty much the standard for starting Angular projects, and using it will make it easier to get new developers on board with your project because they'll be familiar with how the app is structured.
Maybe it's just me, but it would probably be best to use a consistent node version between developer boxes, test boxes, production and anything else you might have.
DELETED - invalid info was here
Angular CLI uses webpack and supports those things...
Description of this sub states &gt; All about the JavaScript programming language So I don't see why it would be wrong to discuss problems here. Besides, people who require help are much less likely to pop up in hot/trending filter than useful libraries and articles. I can see logic in your post but I don't think sending people in need of help away is an answer.
Cool game :- ) Looks like possibly fun to play ... Tough competition from lots of others a bit similar games maybe? Was a bit hard for me to see which ones were fighting against which ones. If the attack animations were a bit ... larger? would be easier to see. Maybe if they had swords. The attacks looks mainly as if they're throwing ... magic? on each other
&gt;This is by design so that different parts of code **can’t not** change the store arbitrarily. You need to fix this typo.
No sane person shell scripts in Bash, use Python it is far better and simpler. EDIT: Y'all seem to be a bit salty about this. It's all about picking the right tools for the job, a Bash one liner is better than knocking something up in Python, if you're working on more elaborate scripts, you probably want to use Python.
If you ever get there, let me know. I wish there was more emphasis on doing things in vanilla JavaScript rather than people inventing x,y and z library to monkey patch in features.
https://patents.google.com/patent/US6453335 Here is a patent for putting a answer on behalf of a server if it does not answer in time. ngnix answering a 500 if your backend does not answer within a second fall under this patent. Sound techy enough and you'll get any patent.
yeah, it's meant to be an integer sort, it does some bitwise math somewhere to get indicies so floats don't sort properly. The simple solution is to give it an accuracy, (e.g. "sort to `.001`", then multiply everything by 1,000 internally) but that a) makes it less robust and b) loses some accuracy at the edges of the numerical range
Read the You Don’t Know JS series by Kyle Simpson. He’s got a nice level of appreciation for the language and its infectious. He also has a commanding knowledge of the language and that’s inspiring as well. 
Yah it's all just prototyping for now. Nothing is final. Main thing are the mechanics and code behind it all at the moment. 
Whenever I am mad about having to use JavaScript I just breathe and remind myself that WebAssembly is slowly but surely becoming more and more supported and usable. 
they provide API access, u don't have to do this hacking ;)
ROFL
For Typescript-oriented backend I can recommend https://github.com/kamilmysliwiec/nest (not affiliated, I'm just a user). But I really liked Koa + TS.
So strange. I've been working with it for a couple of years now and haven't had any troubles.
yeah but not some other features (yet) like universal, which is quite important if you want SEO...
how old are you? 
Looks very powerful and complete. Is there any video tutorial introducing one on how to think and structure code with funfix? It would help adopting it for the least fp/haskell savvy. Cheers!
i had the same thoughts. how do you find the one View.js you are loooking for with your IDE without browsing through your folder structure?
I start to think you're all joking and i haven't gotten it quite yet. Where are the react patents that would have v-dom libs infringing of them? Until now, not a single one has been presented.
It's all a matter of perspective. Use it for a while and you'll see that it has benefits. I come from low-level, backend, native frontend, had years on asm, c, #, xaml and all these things. I remember that js gave me a similar impression, it seemed loosely defined and weird. I haven't touched many of the aformentioned languages for quite a while now. I use js on the server, on the desktop, on mobile and in the web. I wouldn't like to change it given that i can do things with it that simply weren't possible before. As for my initial impression, learning something like XAML took at least a year to be proficient. You learn a modern v-dom framework in an hour, or let it be two, and you're proficient. Tooling as well, modern js tools like webpack allow things the old world would struggle to implement.
The CLI does support Universal right now, I have a little demo showing exactly this https://github.com/toxicable/universal-starter/tree/cli CLI, universal (prerender or dynamic), lazy loading 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [toxicable/universal-starter/.../**a6e8cbc08a18338140fee2e9454497d2682440b3** (cli → a6e8cbc)](https://github.com/toxicable/universal-starter/tree/a6e8cbc08a18338140fee2e9454497d2682440b3) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmdd9kl.)^.
Many editors allow for fuzzy search. `ToDoList/index.js` can be usually found by typing `todoindex` in editor file search box ;)
Webstorm would have a hit for Todo/index But no hits without forwardslash
Not on german keyboards. :D
You not hitting any bugs doesn't mean there aren't any bugs. I'm not saying it's a buggy product overall, but it didn't inspire confidence.
Young enough that I'm not working with tech that is 30 years old.
Reminds me a bit of rxjs with that flatMap example.
Totally unrelated, but does anyone know whats the console / theme in the gif? So pretty! 
oeh nice, was looking for the a few weeks back and it wasn't back then
You seem to be making my point for me. Just like a transistor must work within (and depend on) the bounds of physical laws, wouldn't it benefit us to work within similar natural, provable constraints in software engineering? If, as you say, programming languages required maths in order to exist, at what point should it be cast aside? Thank you for the conversation, all the best.
I think you picked up a huge design issue in most future implementations (also applies to other languages) that the asynchronous task starts immediatly instead on request. In my opinion the lazy evaluation could bring many benefits. Thus funfix-effect looks really promising to me.
Sublime, Atom and VSCode find files even without forwardslash (`todoindex` is sufficient)
May be this article could help you - https://xbsoftware.com/blog/free-webrtc-example-with-webix-and-easyrtc/
Technically it's not a map because it doesn't return a modified array ;)
Wish someone would make a really good React + Typescript series.
Starter From Microsoft looks good. https://github.com/Microsoft/TypeScript-React-Starter
Yeah when I started mean stacks was obviously bridge angular 2+ was out so that's how I know some companies still use it but yeah I'd agree it would be smart to start using angular 2+ for new projects as that will be the standard from now on and angularjs may be put back on the shelve as a I used to use that. I'm curious how many people have used vuejs as well instead of angular. If you're an angular guy I don't see why you wouldn't enjoy vuejs. 
yes
For front end, as soon as I started using Webpack and frameworks like React and Vue that make life so much easier. All the heavy hitters have cli tools to spin up a project quickly, and it's not that crazy to pick apart the build process if you need to change it. For back end, maybe node 6 or so, most of the features of es6 and es7 are implemented now, and as soon as es6 modules are implemented I'll be ecstatic.
Isn't the api very limited? Can you list videos from your personal sub feed with info about whether you watched the video or not? 
Or even better, use a Docker container with everything.
Eh, any XSS prevention code that wouldn't catch this is probably terribly broken anyway.
Fixed! Thank you!
This is a pretty cool idea, I look forward to following the project's progress.
um... you *do* realize JS is case sensitive, right? And that `return y = false` makes no sense. And that you're literally overwriting the entire body with your image tag? And that your script tag is fucking *outside* of your HTML document? And that no sane human being has capitalized their HTML tags for quite some time now? And that embedding JS event bindings *in* your HTML tags is considered bad practice?
try vue.js if you "need" a framework, it is much lighter weight and less opinionated about the backend, and doesn't "require" any tooling aside from a &lt;src&gt; tag.
It has some problems that will never go away. Undesirable run-time type coercion, lack of immutable objects, lack of unicode support, lack of compile-time types. Only the last of those can be addressed with an "annotations-only" compile-to language like Typescript (or mitigated somewhat with a linter.)
I worked with the Api and I can say that it's rather advanced in my opinion. You should definitly check it out ;)
I completely misread your initial comment, sorry. 
Thanks for your support and suggestion. Yes, it is really important to have a consistent version of node and at least let new developer knows which version is needed. Docker would be one of the solutions.
Most tools have initialization commands in them to help with the generation of the init files. npm init tsc --init webpack-cli init /* https://github.com/webpack/webpack-cli */ I admit I had the same knee-jerk reaction to you about webpack. Mostly because it's designed in a weird way that makes the config files impossible to decipher if you don't know what you're doing yet, and because I'm sick of "New Tool of the Month" syndrome, where I now have to migrate an entire build process to a totally new paradigm. And yeah, we all know something better than WebPack will be out next year or soon after and we'll all switch to that one after countless flamewars over the benefits of either. But I'll tell you this. After I put aside my knee-jerk reaction and just sat down with it, I ended up realising it's a pretty cool tool. It actually makes my setup much easier for most things, to be honest. No more writing batch files to copy library dependencies to my output folder, webpack automatically combs through the node_modules folder and bundles everything up into one file. 'Course, there are times when it isn't so magical. Like if you accidentally try to build ES6 code in production mode; some clusterfuck of dependencies means that Uglify can't optimize that code for some reason, even though there's issues out there that insist it's fixed. IDK. It's better than not having it, and at some point there will be something even better. That's all I can say. 
im not sure about the watched flag https://developers.google.com/youtube/v3/docs
Let's be honest I've spent the last 3 years bringing this functionality into javascript without the need to change the underlying browser engine itself. There are also many other projects similiar to mine that have cropped up over the years and I didn't see mine (hamsters.js) nor any other alternative mentioned in this article. Frankly I find it unprofessional and possibly even illegal to take the ideas that many have invested their time in and use the dominate position as an underlying javascript execution engine to negate the massive amount of work that has gone into projects like mine by making things like (new Thread) and then simply adding your function body inside that call as if myself and others didn't do it first. It's disingenuous at best and honestly doesn't feel right to pretend like concurrency hasn't existed or that parallelism itself hasn't already been brought to the language and solutions like mine work for browsers dating back to IE9 and are as isomorphic as it comes for javascript. My project is www.hamsters.io (hamsters.js) and there are others as well, my solution doesn't just implement a fully featured thread pool with work queuing but allows individual functions to be executed concurrently across many threads as well as execution of functions in parallel across many threads in order to speed up execution of a **single** function. EDIT** Downvotes aside a really significant amount of time and resources have gone into bringing this functionality to the language without changing how the language it self works. There is frankly no way the WebKit community has not seen other examples of libraries that allow concurrent and parallel execution of JavaScript logic. If they are unable to present the exiting alternatives to their proposal then you are only getting half of the story and you are either advocating for or against a solution that has unknown alternatives. 
I find statements like "I know JavaScript" to not be that useful because there isn't a good definition for knowing a language. My resume includes languages that I am comfortable using and would be willing to have someone probe my knowledge of. When I look at others' resumes I find a description of a few projects you've done to be a useful gauge for what types of knowledge they currently have.
This answer was helpful. I guess you don't have to know every function there is to know the language. Just like how the English language has hundreds of thousands of words but no one actually knows every single one, except for those with special memory.
I'm just thrilled at the prospect of writing a web app in C++. /sarcasm
The `IO&lt;A&gt;` type is indeed lazy and powerful, being complemented by an eager `Future&lt;A&gt;` which gets generated on execution. Thus, along with a simpler `Eval&lt;A&gt;` data type for evaluating immediate / synchronous expressions, Funfix provides the kitchen sink :-) Links for those that missed it: - Future: https://funfix.org/api/exec/classes/future.html - Eval: https://funfix.org/api/effect/classes/eval.html Thanks,
but...why? 
The project is new, I've been working on it for about a month, although the data types themselves are ports from libraries I already contributed to, thus drawing on my experience from those and I'm talking of [Typelevel Cats](https://typelevel.org/cats/) and [Monix](https://monix.io/). I am a believer in documentation oriented towards beginners and will think about making a video. I have some work piled up currently, so I don't have the time right now, but soon. Thanks,
Thank you, I'm glad you like it! I have to think a little bit about the next step, but I think that it can be JSX... or C++X
I'm pretty biased towards React on my end. Rather than just point you to React tutorials, let me give you my usual advice on how to deal with forms in React, as that seems most relevant to your use case. Gosha Arinich has written an excellent series of articles on how to use forms in React, at https://goshakkk.name/on-forms-react/ . I highly recommend you read those. In particular, he describes the concepts of "controlled inputs" and "uncontrolled inputs", which are important to understand when writing forms in React. He also covers good approaches for validation, wizards, and other key form topics. He's also recently published a book called "The Missing Forms Handbook of React", which is very much worth it: https://goshakkk.name/the-missing-forms-handbook-of-react/ . Beyond that, I have links to a number of other articles that deal with forms in the [React and Forms](https://github.com/markerikson/react-redux-links/blob/master/react-forms.md) section of my [React/Redux links list](https://github.com/markerikson/react-redux-links) .
The inline example is abominable
I have to build a parser that will allow us to use a JSX like syntax
Nice writeups! There's longer and more detailed articles out there, but these are a couple nice intros to several key concepts for using React and Redux together. I particularly liked your comment about "reading lots of articles about file structure, and realizing I just need to get started and the 'aha' moment would come later". I also appreciate that you took the time to write things up from your perspective as a new learner. My only real disagreement is that we generally advise that people _not_ use a boilerplate project to get started, since they usually have too many libraries and pieces already configured, and that generally makes it hard for beginners to understand what's going on. Instead, we recommend using the official [Create-React-App](https://github.com/facebookincubator/create-react-app) tool, which creates new projects that have a solid build setup, with no configuration needed, and lets you focus on just using React right away (and adding whatever pieces you want on top). Also, two tiny nitpicks: first, the last header in the second article should be "Refactor" instead of "Refator". Second, as an FYI, `connect` supports an "object shorthand" version of the `mapDispatch` argument. Your Step 6 example could be simplified as: // Don't need to write an actual mapDispatch function if you do this const actions = {loadArticles : fetchAllArticles}; export default connect(mapStateToProps, actions)(ArticlesIndex); I'd be happy to hear any thoughts you have on the overall experience of learning React and Redux, including any pain points you might have gone through in the process. In particular, as a Redux maintainer, I'm always looking for people's thoughts on the Redux docs, and if there's anything we can do to improve them.
Man you don't like unit tests either? Damn 