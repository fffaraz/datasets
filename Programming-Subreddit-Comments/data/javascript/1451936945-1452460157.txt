Ok you like the architectural decisions Facebook made, but that's just a library vs framework discussion then. I think you can't say that Facebook won't drop React as fast as Google "drops" their products. I also know that React is just the view layer, what I meant was that their UI is not only build with React and never will be, because I heard from multiple Facebook developers that React is not suitable for every use case and that especially on facebook.com's timeline a lot of things won't be converted to React. &gt; In the current JS world, having a library that is easily replaceable is one of the main features we should be looking for. Angular developers should be able to appreciate this more than anyone else, I would think. The more reasonable developers definitely do, that's also the reason why a lot of people like Angular 2 a lot more than Angular 1. Sure it is a lot more than React, but inside the Angular box it is way more flexible and modular. Components are conceptional a lot like React components and I actually use the very similar I use them in React. A lot of other stuff are either pretty close to vanilla ES6 (Services) or use existing technology like RxJS. Everything else is just glue to make it a framework, which has it merits over the React ecosystem where there are multiple ways to do stuff and you basically need to figure it out yourself. Anyway, I like and use React and Angular, but I am actually very happy that I now can use Angular 2 over 1.x. 
&gt; var vesselSpeedUp = function () { this.visit = function (vessel) { vessel.setSpeed(vessel.getSpeed() * 2.5); //2.5 times faster }; }; // ... target.accept(new vesselSpeedUp()); So... why wouldn't you just do this? // ordinary function function vesselSpeedUp(vessel) { vessel.setSpeed(vessel.getSpeed() * 2.5); //2.5 times faster }; // ordinary function call vesselSpeedUp(target); I think the reason this is easy to solve in a straightforward, non-visitor way is because the example problem didn't fit what visitor was meant to solve. For visitor to be applicable, you'd need a structure of objects (maybe a tree, or a list), and the items in that structure would need to be a variety of types. In the GoF book, the example they gave is an abstract syntax tree. The object structure is (of course) a tree, and each item in that tree can be a different type, such as "AssignmentNode" or "VariableRefNode". But to keep this relevant to web folks, I'll use a DOM tree instead for an example. Let's say we have a class for each possible HTML element. class HtmlElement { // ... } class TitleElement { // ... } class PElement { // ... } // ... And you can imagine us creating a tree from these types. let htmlElement = new HtmlElement(); htmlElement.appendChild(new TitleElement('DOM Tree')); htmlElement.appendChild(new PElement('Hello')); htmlElement.appendChild(new PElement('World')); But now we decide we want some additional operations. Maybe we want to validate a given DOM tree, or maybe we want to convert a DOM tree to an HTML string. And each of these operations is sensitive to the *kind* of element. That is, the way we validate a PElement is different than the way we validate an HtmlElement. At first blush, the obvious place to put these operations is inside each respective class. class HtmlElement { // ... validate() { // Check parent element is legal (must be null?) // Check attributes are legal // Iterate through child elements and call validate() on each } toHtmlString() { let str = '&lt;html&gt;'; // str += ... iterate through child elements and call toHtmlSring() on each str += '&lt;/html&gt;'; return str; } } class TitleElement { // ... validate() { // Check parent element is legal (must be head) // Check attributes are legal // Iterate through child elements and call validate() on each } toHtmlString() { // You get the idea } } class PElement { // ... validate() { // You get the idea } toHtmlString() { // You get the idea } } // ... But this organization has some undesirable traits. The logic for the validation feature is split across many different classes, as is the html string feature, and any future operations we might add. Which also means each time we add a new operation, we have to change every element class. Plus, the element classes are going to grow quite large as we accumulate more operations over time. Ideally, each operation would be consolidated in its own class or function. But there's a complication. Remember that each of these operations is sensitive to the *kind* of element. When the operation was defined inside each element class, it was easy to know which kind of element we were working with, but now it won't be so easy. The most obvious solution might be lots of `instanceof` checks. function validateDomTree(element) { if (element instanceof HtmlElement) { // Validate html element } else if (element instanceof TitleElement) { // Validate title element } else if (element instanceof PElement) { // Validate p element } // ... else { throw new Error('Unsupported element type') } // Iterate through child elements and call validateDomTree() on each } But `instanceof` is considered naughty (even though in this specific case, I can't think of a practical benefit to avoiding it). But if we want to avoid `instanceof`, then we're back to the question of how do we know which kind of element we're working with? And the answer is: A little code in each element class, in an operation-neutral way, to tell the operation what kind of element it is. class HtmlElement { // ... accept(operation) { // Tell operation (the "visitor") we're an html element operation.visitHtmlElement(this); } } class TitleElement { // ... accept(operation) { // Tell operation (the "visitor") we're a title element operation.visitTitleElement(this); } } class PElement { // ... accept(operation) { // Tell operation (the "visitor") we're a p element operation.visitPElement(this); } } // ... And our operation class: class DomTreeValidator { visitHtmlElement(element) { // Validate html element } visitTitleElement(element) { // Validate title element } visitPElement(element) { // Validate p element } } And viola. We invoke the operation-neutral, element-neutral accept(), then that invokes the operation-specific, element-specific visitYadaYada().
Any chance you can show me how this could be done on my slider? I have done this approach on another slider but that one had full width slides, here they are a tenth of the width, so maybe the "empty space" is going to show before i have reached the last or first slide on increment?
Yeah I noticed, I guess I could disable click on the buttons when the animation is running? 
No, only people who hated angular before react can see it that way. React has been benefiting from angular's fails of implementing observables, but I don't believe that was the reason for React.
How is this not a clickbait shitpost? I could've made the same claims and promising the same promises using Ember CLI or Angular+gulp or whatever. This post is nothing special about nothing special, with a clickbait title and barely any content, advertising some guy's business and product. Basically, the definition of clickbait post.
Nice work as always, schteppe. :) [This](https://schteppe.github.io/p2.js/demos/concave.html) is one of my favourite of your demos. I always seem to want to add just one more shape...
ES6 modules can't get here fast enough. The proposed solution is elegant, but it is really filling a gap that is defined but not yet implemented from ES6. I look forward to modules that are called on demand using native code without need for a separate app/interface. The biggest problem I have with the proposed approach is that it requires part of your app to run on a server and part of it run on the client. Overhead aside, I suppose that is ok if the app is completely shackled to a single domain. It just means your app is not a portable solution. After all this is JavaScript we are talking about, so theoretically it should be able to run anywhere.
Cannon is great!. A while back I made a [vehicle demo](http://www.spacejack.ca/projects/drive/) with it that you can play with &amp; tweak the physics settings.
I'd love see a similar example in Ember. I've used it pretty extensively and I do not think it's this simple / possible, but I have little experience with fastboot or code splitting using broccoli. The problem being solved is non trivial and he provides a clear solution using React / Webpack so this is definitely not just "claims and promises". As far as the article is concerned it's got just the right amount of content imo; the problem it's discussing, the current methods of solving, a minimal example of how this new method works, and a link to a repo.
Definitely agree with you, for most scenarios optimizing #4 is still the best approach. The idea of a *partially delivered app* or *incrementally delivered app* is the direction were headed though
We're currently in the process of switching from Cannon.js to Physijs for our [3D game engine](https://github.com/WhitestormJS/whitestorm.js). Cannon.js was good, but we found Physijs to be better for our purposes.
I don't think this would work if it went into nested elements. I'm looking to do this for my chrome extension where I'd like to select elements similar to how the uBlockOrigin extension does this (this is also for getting the class/id of the element you want). 
Exactly why I have a task to remove all react from our product.
Hi! Check out my blog post series (more coming soon): http://freezer.js.org/minimum-viable-view-library/ I hope you find it useful!
Hi! Check out my blog post series (more coming soon): http://freezer.js.org/minimum-viable-view-library/ Hope you'll find it useful ;)
Check out my blog post series (more coming soon): http://freezer.js.org/minimum-viable-view-library/ Hope you'll like it! ;)
Check out FRZR: https://frzr.js.org ;)
Surprisingly, it was a validating syntax. As /u/TheNiXXeD says, angular is the one which goes the HTML &amp; web components way, react is the rebel. And that's actually good, you override whatever crap W3C spits and you just write javascript. You then render it into what you want: html, canvas, native.
Out of curiosity, what did you find better? Features, performance?
Hmm... not sure what you mean. Seems to work fine even when nested: http://codepen.io/anon/pen/JGEqLd
It was fun trying to stress test this on my MacBook with a Core 2 Duo and Intel GMA X3100 graphics, lol. Didn't expect all demos to run smoothly on these specs, but the simpler ones at least ran decently even if I had to set graphics to wireframe.
BLESS YOU it worked like a charm! THANK YOU!!!!! I just hooted! I'm making a really simple game i'll be sure it post it when it's finished its really almost done just finished up the last few odds and ends. Do you know why 'this' can't be used twice in this instance? Even if 'this' is the same element?
Hi /u/cassiozen, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Okay, I got it: combineReducer's nested return function's arguments (state and action) get fulfilled via a dispatch because the dispatch function passes a state and an action. So lets go through this one step at a time: const fauxReducer1 = () =&gt; { ... }; const fauxReducer2 = () =&gt; { ... }; let action = { ... }; let store = createStore({fauxReducer1, fauxreducer2}); store.dispatch(action); here is what happens when we do the dispatch: Our variable 'store' is actually just a function. We are calling the 'dispatch' function inside of the 'store' function. This is what the dispatch function looks like: const dispatch = (action) =&gt; { state = reducer(state, action); listeners.forEach (listener =&gt; listener()); }; So, here we see "state = reducer(state, action); Well, "reducer" is just a function too -- it is the combineReducers() function. So this is whats really happening: state = combineReducers({ fauxReducer1, fauxReducer2 })(state, action); BOOM. HOLY CRAP. 
Let me rephase as: If Facebook infringes on any of your patented ideas and you take legal action, you have to stop using React. 
state and action are part of the reducer api. `combineReducers` takes multiple reducers which could each be called independently with state and action arguments, and combines them into one, solitary reducer function which would also get called with state and action. The output of `combineReducers` is that function with those parameters. That is, `todoApp` is a reducer which gets called with state and action arguments because its defined as the part in `combineReducers` which is: (state = {}, action) =&gt; { ... } that is returned when `combineReducers` is called and assigned to `todoApp`. The other nested function(s) are able to access those values when the reducer is called, but that doesn't happen when `combineReducers` itself is called, rather when `todoApp` is. At that point, its being called as a reducer with state and action and the internals can do its thing. `combineReducers` itself doesn't do much. In fact all it does is returns a function (assigned to `todoApp`). Its that function that is in the form of a reducer that handles the heavy lifting of the actual combining at the time its called.
i think you're looking for: document.addEventListener('mouseover', function(e)( //e.target has current moused over html object, will do callback when you mouse over a new element )}
Use source blacklisting in your browser's dev tools (both Firefox and Chrome support this, not sure about the others). I work on complex Angular projects, and blacklisting the angular source code (along with other libraries like lodash) makes debugging the application's code simple in comparison.
Hey hey everyone. I've spent a few months learning/participating in development of some of the newer tools in JavaScript. I wanted to put together some educational material and this is my starting point. The most exciting things in this project are: - [jspm](http://jspm.io/): JSPM is a package manager that brings along with it the ability to transpile and bundle. It's in the same space as WebPack, but more closely adheres to the [ES6 Module Loader specification](https://whatwg.github.io/loader/) - [CSS Modules](https://github.com/css-modules/css-modules): Use CSS locally rather than having it all in a global scope. In the same space as importing CSS into a Web Component, but without the need for Web Components. - [PostCSS](https://github.com/postcss/postcss): Rather than using LESS, SASS, or Stylus.. transform your CSS in JavaScript for better performance, modularity, and mutability. Pull in features you want from the plugin ecosystem. - [ES6](https://babeljs.io/): If you don't know anything about writing in ES6 this is a pretty simple starting place. I don't make use of everything (no classes, etc.), but some of it is there. - [ESLint](http://eslint.org/): Arguably the coolest JavaScript linter out there. I've preconfigured this project with its ~200+ rules. It'll even mention some easy conversions from ES5 to ES6. - A more sane organizational structure for Gulp tasks. It's not much, but I really like how my Gulp tasks look in this project :) Feel free to ask questions here or hmu on Gitter: https://gitter.im/MeoMix/jspm-marionette-boilerplate
go try with React with TypeScript. ;) This is an example of what you may end up with: class ProgressBar extends FoodyComponent&lt; {progress:Stream&lt;number&gt;}, {progress:number, subscribtion?:IDisposable}&gt; { state = {progress: 0, subscribtion: null}; componentDidMount() { this.state.subscribtion = this.props.progress.subscribe(progress=&gt;this.setState({progress})); } componentWillUnmount() { this.state.subscribtion.dispose(); } render() { return &lt;div className="foody-progress"&gt; &lt;div className="progress foody-progress-bar"&gt; &lt;div className="progress-bar progress-bar-info" role="progressbar" style={{width: this.state.progress*100+"%"}}&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;; } } export class NavigationBar extends FoodyComponent&lt;any, {payload?:any, progressBar?:JSX.Element}&gt; { state = {payload: null, progressBar: null}; @Observe(RecipeSaveStarted) preloadingStarted(payload:{progress: Stream&lt;number&gt;}) { let {progress} = payload; if (payload !== this.state.payload) { this.setState({payload, progressBar:&lt;ProgressBar progress={progress}/&gt;}); } function removeProgressBar() { this.setState({progressBar: null}); } progress.subscribe(null, removeProgressBar, removeProgressBar); } render() { return &lt;div className="width-constrain margin-auto navigation-bar"&gt; &lt;a className="foody-brand" href="#"&gt; Foody &lt;/a&gt; &lt;UserInformation /&gt; {this.state.progressBar} &lt;/div&gt;; } } 
[HTML imports](https://developer.mozilla.org/en-US/docs/Web/Web_Components/HTML_Imports). I have no idea about HTML imports. I wasn't even aware this was a thing. I will wait until I have thought about this longer before I form an opinion. Minifying resources is easy when you have just a few files. As the number of files increases the reliance upon a build step to automate that task likewise increases. However, the more your app can be broken down into various files each file should, presuming it is a fully formed function or object, contain less indentation after beautification than otherwise needed in a larger file. This means the more code is broken into various files the less you get from minification and the more work you have to do to achieve and maintain it. This is why I have abandoned minifying code in my personal project when I broke it down from a few massive monolithic files into a series of library files. There is almost no need to bundle resources with HTTP2.
Are you using babel for async/await support or something else?
Do you have an example for comparison?
I've started on Cory's (the author) course on pluralsight. It's very well structured and delivered. Because you have to use a bunch of components (flux, gulp, browserify, router, browserify) this could make it pretty tricky for new devs to learn though.
Hi /u/YodaLoL, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Here you go! http://codepen.io/anon/pen/ZQLdwB New variables: currSlide equals the current slide; widthPercentage equals how many slides per screen. In this case, 10. Added two if statements, and a couple console.logs for keeping track of things \^.^ Cheers 
I was expecting a roadmap for future versions, not a "how to learn things one library at a time in a particular order" guide. Nice for people getting started, but perhaps poorly named.
The codepen I put up solves this! Just have to be more precise with your animation measurements (:
I think it does-isn't https://github.com/mweststrate/mobservable#top-level-api `autorun` the same as a computed?
This guy is actually really impressive, I'd never heard his story before, inspired me to start a open source project. 
&gt; If I'm reading this correctly, Facebook owns your patents. No. That's an utterly absurd interpretation. &gt; If you use React to make any patented software that you end up needing to sue Facebook for infringing upon, they can terminate your license to use React. No. If you sue Facebook over their patents, they will terminate your license *to their patents*, not your license to use React (which they couldn't legally do anyhow). &gt; For example, if you use React to build an ads platform, Facebook is totally free to use any of your patented ideas, or if you take legal action you have to stop using React. No. If you believe that Facebook is using your patented ideas, and you sue them, then they will very likely countersue you, because that's how patent disputes work, yes. But note that this is true *regardless* of whether you're using React. (Maybe the real lesson is, don't patent your ideas, and then you won't be tempted to sue Facebook?) &gt; Saw this related mention as well That refers to an older version of the PATENTS file.
[removed]
 "ECMAScript was always an unwanted trade name that sounds like a skin disease." - Brendan Eich
&gt; they aren't willing to base products on a UI technology that turns into a pumpkin should they ever become involved in a patent dispute with Facebook. Really? So they have dug into Facebook's patent library to identify one or more patents that they believe any React-based code they deployed would be infringing? Any chance you have any details on the patent(s) your employer is worried about? In addition, what steps have you taken to ensure that the non-React code your deploying does *not* infringe on any of Facebook's patents? Honestly curious, because your employer's strategy of not infringing seems really unusual, if not outright counterproductive. Why even build up a library of patents if not as a bargaining chip so you avoid the legal nightmare of trying to figure out if your JS rollover is infringing some patent somewhere? (Especially since it almost certainly is...)
"The license granted hereunder will terminate, automatically and without notice, if you initiate directly or indirectly in any Patent Assertion against Facebook or any of its subsidiaries or corporate affiliates" Maybe someone could rephrase this. This is what I'm getting stuck on. 
What 17 year old writes a JavaScript compiler? *edit* Since we're all so confused, I'll rephrase. It is extremely impressive to me that someone in high school had the intelligence, skill and ability to write a JavaScript compiler. Most developers will be unable to do so for their entire career. 
&gt; What 17 year old writes a JavaScript compiler? Jeez. Did you read the article? Your comment is **exactly** why folks like Sebastian feel ostracized or alienated: &gt; Just like at Thinkmill I was treated with a lot of respect despite my age and experience which surprised me a lot when compared to the way I was treated socially in tech. There were times were I’d get snarky comments on my age from meetup organisers which made me feel extremely uncomfortable.
Thank you! Definently. I didn't see any reason to stay at places where I wasn't happy and couldn't be which is why I made the decision to leave both of them. I've been at Facebook for 6 months and am really happy and don't see myself leaving anytime soon.
one of the worst aspects of coffeescript. 
Inspirational story, and I love how it demonstrates that the best way to learn is by building something you are passionate about.
Glad someone got what I meant.
Because Gnome 3 sucks too much.
Do you have your own office?! That is cool!
Facebook has a very large London office with hundreds of engineers.
Great! Definitely not advocating staying at a place you are unhappy. I have made the mistake of always thinking the grass is greener on the other side. You have been very lucky to have found a better fit for you with each change. All jobs will have ebbs and flows. They will definitely be boring at times. 
That's a good question. Now I'm wondering if I should change the feature to just have the 1 element highlighted only. Since I'm trying to replicate the uBlockOrigin extension's feature of letting you pick the blocking of a certain element on the page (this includes id's though)
How does this compare to https://github.com/JamieMason/shrinkpack ?
[enyojs](http://enyojs.com/) from webOS was doing HTML in JS years ago.
Seriously impressive guy - would love to meet him sometime
Great to hear! Thanks for the kind words.
When you get a chance, go to P.F. Changs in Emeryville. You will find a awesome honey chicken. Or try [making it](http://www.food.com/recipe/pf-changs-crispy-honey-chicken-copycat-426044) yourself.
I highly recommend having a listen to [The Upside of Quitting](http://freakonomics.com/2011/09/30/new-freakonomics-radio-podcast-the-upside-of-quitting/) by Freakonomics - it's entertaining and highlights some interesting points beyond "the grass may be greener". It's not all roses of course, but sometimes it can be well worth the risk.
/u/Yhippa I'm dropping this reply to get pinged when you get an answer from /u/ajacksified 
Wow! That's way more incredible than I was expecting. Thanks u/sebmck infinitely for Babel. I live a very joyous life working with Babel every day. At work we think JavaScript core features should just freeze and everyone work on Babel plugins instead =D
This was a great read (though a bit sad at times, our community is very immature). 6to5 is pretty much the only reason I was comfortable switching to ES6 in our application, and it's been absolutely fantastic. (Traceur just generated awful code at the time. Simple input would turn into nested try-catch blocks for isolation purposes. It was more proof of concept than usable solution.)
Yes, they had prior experience in few projects, that was their choice but they've failed to make it perform enough fast to be acceptable. Thanks for the link. 
&gt; No solution (yet) for the problems of mixins vs higher-order components React has decided to move in the direction of being agnostic in how you implement your classes, which is why there is a push to get people away from `React.createClass`. The real advantage of this is that it allows people to use idiomatic Javascript, and code in the style they feel is best. The only con is that decorators are in the non-finalized state (ES7) but I would argue this is a great design decision and is a solid long term plan. &gt; Requires a build system This is actually false. &gt; Enforced use of 'this' and classes (or class-like style) for any non-static components. Unsure what you mean for this? 
Thx for sharing! 
Looking at the current state of gnome/kde projects, I would say No. Those are much more complex, while doing basically the same.
I feel that this README is simply not finished. Pete made changes there 6 hours ago so he is probably working on it. Otherwise the title is completely misleading.
Babel is unrelated to mongo. It essentially lets you write your code in helpful, but not yet released syntax. It would allow you to write code like this: async function run() { let posts = await Post.limit(5).find(); return posts; } With `co`, you would need to write code like this: function run() { return co(function*() { let posts = yield Post.limit(5).find(); return posts; }); } `co` is essentially a stepping stone to `async`/`await` (their words). You can use it in node without needing to use `babel` to transpile your code. If you do use `babel`, however, you can use the "proper" syntax now, and whenever the features are fully supported in node, you can just stop transpiling. 
Gah, Babel started from scratch just over a year ago!
Great read. Thanks for posting. Also, it's very intimidating for a 32 year old that just got into the web/code world. 
CustomElements spec blurs your definition of markup vs programming languages... Especially if you consider xml and xslt.
* I find it much easier see what's going on with React. The latest versions of React just use plain ES6 classes (or stateless functions); that makes them easy to write tests for, to share, and to read the code. Everything is organized and neat, and follows a clear lifecycle. Angular, on the other hand, reads like a giant blob of HTML, because it's basically just a custom templating language. I would rather write _html and javascript_ than write _angular_. I can use my normal tools with React- such as mocha for testing- because _it's just javascript_. * Magic. Angular feels very... magicky. Cascading updates and circular references have been nightmares. React's only "magic" is that it's clever about how it updates children elements as an element's state changes, which is conceptually easier to follow. * Footprint; React is a whole lot lighter, which matters when we're building a mobile site. * Community support; React continues to experience massive growth, while Angular seems to be dying. A lot of it also came down to the other engineers here - other people were experimenting with React at the time (around a year ago), and had shipped some React code to production, so it seemed like the right time to try it out. While I was highly skeptical at first (I was a big Backbone+mustache fan), I think we made a fantastic choice. We've got a universal-render stack using node 4.2, and we share almost all of the code between the server and the client (the only non-shared code is webserver setup on one side, and binding to links on the other.) React continues to gain in popularity, and I have an immense amount of respect for where they've taken it so far; they won my heart when they moved to plain ES6 classes. The only thing I'm not behind yet is use of react-router... but that's a tale for another time. (for what it's worth, [I was at a _very early_ js meetup group](https://github.com/mhevery/angular-node-socketio/pull/1) where Angular was introduced in its infancy; I thought it was an interesting idea, but I've always held the opinion that its syntax, and overall philosophy, will stunt it.) + a ping for /u/Listen_up_buddy
Sounds like the right direction, I just need to figure out the logic for narrowing down to the inner elements if the mouse over gets to the more nested elements (to highlight only the more nested ones);
Those are examples of legitimate use cases for an OS GUI. They're used as an actual OS GUI and they do a lot more than these JS simulations do hence the complexity. My point is, why simulate an OS GUI for a web app when there are much better ways to design an application UI that are far simpler.
Check out https://www.youtube.com/watch?v=ffUnNaQTfZE (less entertaining version — https://en.wikipedia.org/wiki/Supertask).
It's weird how you're getting so upset while the author of the article did not.
Separation of concerns does not mean separation of files or languages. The reason why is that all related concerns for a single component, be it a livesearch, a typeahead, a banner, whatever, are as close together as they can be. I've been doing modular css defined in the same file as my html (jsx), which is the same file as the logic for that component. The only thing in or out is generic data and the rendered output to the browser. Doing it this way is usually very easy on the mind, because I don't have to worry about outside behavior (or even cascading styles!) inside the world of this atomic component. If, for some reason, I can't fit everything in one file, or find it convenient to split it out, I always have that option. I just require in the dependency. React doesn't force you to mix languages if you don't want to.
His first interview on the JavaScript Jabber podcast is really fascinating.
The answers to these questions are completely dependant on 1) what applications are you building. Do *they* require minification, etc and 2) Do you have the resources to spend on implementing and maintaining best practices. I can't imagine writing any clientside JavaScript without a build tool (webpack / gulp, etc), so minification is basically free with those tools, so why not.. module bundling is a necessity in my opinion. Babel is amazing and ES6 / ES7 is backwards compatible so you have very little to lose (possible performance / learning curve time) and a lot to gain (hugely improved programming language). And then of course there's writing tests. The sooner you start writing tests the more robust your applications will be!
And with a bit of hacking you can mangle it into Angular 1
No, you're being overly sensitive. Fact: he was 17. Fact: he did something noteworthy. To say "A 17 year old did something noteworthy" is in no way offensive or incorrect. &gt; Doesn't matter how you meant it. It very much does. "Nice haircut" can be insulting or complimentary depending entirely on intent. Calm down. &gt; When you're young and accomplished enough that its notable, it becomes the one thing people know about you. It becomes the thing you're identified by. You become the whiz kid, the 17 year old creator of Babel. When you're anything and do anything, that's the thing shallow, irrelevant acquaintances know about you. That is all of life. &gt; It doesn't matter that you mean it in a good way, you're still taking away the ability to be anything other than that identity. Jesus, I said 8 words. "Oh, I shouldn't comment on the 17 year old that wrote a javascript compiler because he might like football or play the banjo." ? Is this seriously how you tiptoe around human interraction? No. You're being overly sensitive, probably because you're friends. 10/10 sweet, 10/10 unnecessary. &gt; This has professional and personal implications worse than you think. Must suck being a well respected JS developer, regardless of age, that people love reading about/communicating with. I'd wager the personal and professional implications of being a guy that never did anything with his career (before you get overly sensitive, I'm talking about myself) are probably far worse. [A better phrasing on my original comment](https://www.reddit.com/r/javascript/comments/3zha2z/sebastian_mckenzie_of_6to5babel_fame_reviews_his/cyma2lv)
1. Pick a sane style guide like Airbnb's: https://github.com/airbnb/javascript 2. Unit tests are a good idea. 3. Use TypeScript. That probably wasn't what you wanted to hear, but having type annotations really helps a lot. It's a massive step up from the rudimentary linting you can do with plain JS. If your editor makes use of TS' analyzer (e.g. VS Code, WebStorm, or Atom + atom-typescript), the editing experience will be also vastly improved. And yes, you certainly should make use of some kind of build automation which takes care of minifying JS and CSS. **Edit:** Thanks for the downvotes, but OP asked for ways to improve the quality. Type annotations do that. Having types is comparable to having much higher code coverage. OP also asked for productivity improvements and making things easier if you're working in a team. Type annotations do this, too.
I went through it about a few weeks ago and thought it was one definitely one of the better courses I've found online. The only problem with it (not really the course but moreso the javascript ecosystem) was that it felt out of date by not using ES6 + Babel and Webpack which seems to be the new standard* (I mean that very loosely).
&gt; Those are examples of legitimate use cases for an OS GUI. They're used as an actual OS GUI and they do a lot more than these JS simulations do hence the complexity. Not sure for KDE. Since version 4 it looks like a Christmas tree, hence I wasn't using that for a while. But as for Gnome 3 it doesn't do much lately. Except maybe the user management, which isn't actually something outstanding, I can't see anything that can't be done by "these JS simulations" in Gnome's control center . Gnome configuration now days is mostly a monkey job of looking and changing gnome registry, and trying to find something descent on https://extensions.gnome.org/. (which most likely doesn't work in recent gnome-shell). &gt; My point is, why simulate an OS GUI for a web app when there are much better ways to design an application UI that are far simpler. I, personally, looking on that like on the possibility for customization. For example, I'd like to remove this shitty button, as I never use it, or move that tree from the left side to the right. I don't like immutable graphical interfaces, these are not flexible enough.
Yeah I used mailcatcher before too. This one is really better. I love it.
I guess a forkbomb is a hypertask then, based on my understanding that if a sequence becomes countably infinite, then the sequence of exponentials of the original sequence becomes uncountably infinite; specifically, that just as the number of operations in the nth run of a forkbomb corresponds to the number of binary fractions with 0 as the integer part and with up to n places specified in the fractional part, so does the number of operations in a forkbomb tend in the limit to the number of infinitely long binary fractions (uncountably many).
https://mathiasbynens.be/demo/jquery-size jQuery 2.1.9 zipped is 73,399 bytes. Zipped + minified it's 29,562. It's about 60% smaller. If you have many comments (e.g. JSDoc), the difference can be fairly large.
Right, so relative to company size, Google indeed has less to lose. That said, both are significantly invested. React has an advantage, but Google is definitely very committed, and you'd be hard-pressed to find other Javascript libraries with Angular's amount of backing. And as opposed to Google Reader and iGoogle, there's actual income at stake :) (And yeah, thanks for staying polite.)
&gt; I’ve wanted — for a very long time — the ability to deliver an app partially. When somebody visits “/login”, they should only have to download the code needed to render the login page. Dart has been supporting deferred library loading since 1.6. Looks like this: import 'package:deferred/hello.dart' deferred as hello; ... greet() async { await hello.loadLibrary(); hello.printGreeting(); } That library will be only loaded (and only once) when someone calls "loadLibrary".
Definitely one of a kind. Interesting to see what he'll do in the future (no pressure!).
https://twitter.com/kuizinas/status/684315131606609920 Need to investigate further before jumping to conclusions.
Great post! Really impressive just got the inspiration to start doing open source once again !
Performance has always bamboozled me about JavaScript though, people talk about it a lot but at least for user-facing applications it doesn't seem very important. For instance when I have a set of data that I'm operating on it's usually not more than a 100 or so items, which even going through 4 times is still only 400 function calls. I've never noticed any kind of slowdown with that and I imagine that it the most common use case. I would suggest that if you need to start delving in the speed of looping mechanisms then you either have a very specific requirements or you're pulling out too much data at once.
Could I challenge you a bit more maybe?=) If I would center the slider on load like this: http://codepen.io/ReGGae/pen/KVWpYJ?editors=011 Could you get it to work? Well if numbSlides % 2 != 0 it aint completely centered tho.
Unless you are building something more complex than a simple grid / chart. Imagine a dashboard where you can add a large amount of charts, graphs and grids. Some of them are plotting data over a few days in 1 minute intervals. Now a user applies a filter to the data set and you need to update each of the widgets. Or there is an automatic update every 5 seconds. You probably won't be using any methods, which make the code slightly more readable, but burden your app with terrible performance (as it is in most cases with map and filter).
https://en.wikipedia.org/wiki/Separation_of_concerns#HTML.2C_CSS.2C_JavaScript
I'm not sure why you're getting downvoted. Article seems solid to me. I especially liked this bit: &gt; A closure allows you to bind some data with a function that takes action on that data. This has analogy with OOP where objects allow us to bind data with methods. I don't know very many people who can make that connection, but you're absolutely right. In lower level languages such as C++, for example, a lamba/closure *literally* de-surgars down to a class, where the class's private data is a copy of the outer variables (that's how capturing happens), and the class's one and only method is `operator()` (analogous to PHP's `__invoke` or Python's `__call__`).
Currently, `shrinkpack` doesn't work outside of product development flow (i.e. you cannot use it to publish packages). See https://github.com/JamieMason/shrinkpack/issues/15
&gt; dinkin me mate on me BMX down the fush and chuppy to get a battered sav ? Can anyone translate this into American?
[**@sebmck**](https://twitter.com/sebmck/) &gt; [2016-01-05 10:44 UTC](https://twitter.com/sebmck/status/684324532409266176) &gt; @sebmck It's funny how I'm getting responses to this calling me a "young boy" or saying "I feel old" which is the exact thing I criticise. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Why London? No visa to work in SF like yo mate Gaearon?
/u/sebmck, you are really inspiring! I'm turning 27 this year, worked several years a web developer (and now back in school) and I'm nowhere near your level in javascript. Your script is one of the foundations of modern javascript. Truly amazing job. If you are coming to Sweden soon for a meetup i recommend nordic.js.
It takes a few seconds in the best case scenario. For everyone else, they'll have left already. 
We decided not to hand off any off protected code and data to a browser without validating the user first. They don't get to see anything but a simple login screen till they authenticate themselves, and as far as they can tell the login is just a little slow. The TOS for these sites also includes verbiage about not copying code or data FWIW, so it is important that they validate first. It's good for purpose built applications, not necessarily eye-candy sites like pintrest or whatever that need to lure you into registering, but if your users like a lightning fast user interface and you like shortened development times with not too-humongous data and reasonable security/IP, it is a useful approach.
Maybe its the second sentence: &gt; Simply put, the function declared in the closure remembers the environment in which it was created. So is the closure not remembering the environment, and only the inner function, whatever that's called, is? Examples further down the page better clarifies and correctly identifies the closure, but I can imagine people reading that first paragraph and quickly making early conclusions about the quality of the article.
&gt; dinkin Doubling / having someone sit on your bicycle's handlebars, or stand on your rear pegs to get a ride with you. [for example](http://www.ballnroll.com/Uploads/Blogs/Trendz/2014PlayersInnerKids/Danilo%20Gallinari%20Bike.jpg) &gt; mate "Buddy" &gt; BMX A type of bicycle &gt; fish and chippy A Fish and Chip shop. Or could be just a local take away place which does burgers, all sorts of fried foods, roasted chickens, sometimes kebabs, etc. &gt; battered sav AKA: Dagwood dog. AKA: Pluto Pup. AKA Corn dog (but with wheat flour instead of corn flour). AKA: Battered &amp; deep fried sausage on a stick.
Probabbly aren't sending correct header information. Facebook uses react in a lot of places now. Standard Ajax doesn't cut it. 
not if they want to use the application. Not every user is your typical web user, nor is breeding everyone to be that way particularly wise.
I recommend you to take an account at https://www.pluralsight.com/. It is 25€ per month but they have so much content (not only JS) for beginner/intermediate/advanced user that it's worth the price. You can have a free trial to test it by yourself.
You are right; I didn't see that. It is still a little larger than I would like, but much smaller than Bacon or Ramda. I will keep it in mind for my next project.
This is what I was talking about though. I would argue that the work of filtering out that data should be a database task, after all that is what they're optimized for. Of course that might be harder to implement so I understand there is a trade-off but my point is that a dynamic scripting language on a clients machine might not be the best place to do heavy data-processing of that kind. If you are then it's a good indication to me that there is something wrong with your overall strategy.
&gt; Fact: he was 17. Fact: he did something noteworthy. To say "A 17 year old did something noteworthy" is in no way offensive or incorrect. I’d be careful with this reasoning. It’s really between you and Seb whether this particular thing troubles him, but the general principal that “Because it’s true, it isn’t inappropriate” is faulty. For example, people are sometimes surprised to discover that I’m a Canadian and not an American. Commenting on that is certainly not troublesome. But in my career, people have also sometimes expressed surprise to discover that I am Black. That is opening a major can of worms. Both “Canadian" and “Black" are true and possibly less common than, say, American and White, just as 17 is less common than 27. But one drags a whole lot of social baggage that the other doesn’t. Again... It’s up to Seb to decide how he personally feels in this particular case. But I do want to point out that even when what we say is factually true, the way we put facts in juxtaposition with each other has social consequences, and we should be mindful of them.
&gt; it is a slight delay during login. It is completely unnoticed With average broadband, you can download like 1.5 MB per second. Once you've actually reached the full throughput that is (see: [TCP slow start](https://en.wikipedia.org/wiki/Slow-start)). If you only download a meg or two, the download time will be dominated by your latency. With mobile devices, the latency is typically rather high. 900 KB of additional JS will result in a very noticeable delay. Even more so if it's blocking.
Bite the bullet and build a small app with React/Redux. Then on a interview show them your skills with vanilla JS and the app you built. Most jobs I see to build apps use a framework. Websites not so much.
Downvoted because of obnoxious link title.
Get a react inspector tool for Chrome. Start debugging their connections. Look for any pieces of data that are sent on their requests versus yours. You'll need to mask your actions as those they are legit. Facebook has detention mechanisms in place to prevent bots. 
&gt; HTML is mainly used for organization of **webpage** content, CSS is used for definition of content presentation style, and JS defines how the content interacts and behaves with the user. React is for webapps. &gt; Modularity, and hence separation of concerns, is achieved by encapsulating information inside a section of code that has a well-defined interface. ... The value of separation of concerns is simplifying development and maintenance of computer programs. When concerns are well-separated, individual sections can be reused, as well as developed and updated independently. === the whole point of components
Nothing public, however the idea is, given some API Object w/ methods, etc, you just proxy it and add traps when needed. More cool stuff you'll probably find here: http://www.2ality.com/2014/12/es6-proxies.html
Very well done! Great documentation and very simple to use. Would be nice if you could add support for jspm.
&gt; Type annotations do this, too. Sadly, type annotations don't exist in Javascript.
I was referring to the fact that you don't need to use JSX at all in React
&gt; Damn, there are so many of these things. they haven't even mentioned Cycle.js, Mithrill.js or 100 of others...
&gt; They currently have 3 native iOS libraries for building UIs, who knows what's going to happen with React. react-native is big, but I think apple certainly has the money and willpower to manage and support all of those solutions.
try it out by yourself. Its possible - and dependend of the current browser
Didn't you read? He wrote he wasn't eligible for a visum for the US.
really? ugh! does chrome download the file? when I get directed to a pdf sheet after clicking on a button at any web site, I actually gonna see the pdf (chrome without extensions). Its an intern pdf reader
The thing is that I'm completely new to JavaScript scene. I know all the core, but my knowledge is quite limited. Can you suggest me where and how to start? Would be much obliged.
Explained in the article largely, less difficult immigration from the Commonwealth to the UK.
i see a lot of new people stick to companies that screw them or don't provide much good for them who SHOULD change jobs if they can within a couple of months. don't know how lucky you've been with your first jobs (or if you just put up with it, which is unfortunate).
It doesn't. JSX compiles into Javascript function calls. This: logCode( &lt;div id="something_clever"&gt; &lt;h1&gt;Thanks for the help /r/javascript!&lt;/h1&gt; &lt;/div&gt; ); Compiles into this: logCode(React.createElement( "div", { id: "something_clever" }, React.createElement( "h1", null, "Thanks for the help /r/javascript!" ) ));
Using your suggestion, I throttled it to 15fps. Looks great: http://codepen.io/codevinsky/full/gPgNOe/
If you reread my post, I said neither of those things. You really want to be upset at me though, which is fine. Continue on.
&gt; These two aren't comparable, and aiming for high code coverage makes all the quality benefits of types moot. The kind of safety net you get from types is like having enough tests to execute each and every line. If a library upgrade introduces a breaking change, the analyzer will immediately spot it. Without types, you need unit tests which execute the affected lines. Otherwise, you won't be notified of this problem. Someone has to stumble over it. &gt; Typing is awesome for code with large memory footprints and long object lifetimes. It's awesome as soon as you have some functions you want to document. You pretty much benefit from the get-go, because you can auto-complete a lot more. Here is a nice fully typed (!) Dart example: https://dartpad.dartlang.org/e23e4d137570c652591e Thanks to that single "as CanvasElement" type cast everything could be auto-completed. Now the analyzer knew that this *thing* has a "context2D" getter which returns a `CanvasRenderingContext2D` instance. And this context thing has things like "fillStyle", "save", "translate", and so forth. In practice, you need very few type annotations or type casts. Type inference takes care of the rest. &gt; Composition &gt; Inheritance. I don't see how that's related. Having types doesn't mean that you must use single inheritance and it also doesn't mean that you can't use object composition.
if you have the right data, there's plenty of line charts tutorials with d3js, like http://bl.ocks.org/d3noob/b3ff6ae1c120eea654b5 overall I suggest you to follow the tutorial here http://www.d3noob.org/2013/01/adding-more-than-one-line-to-graph-in.html and also the ebook is pretty useful (follows the blog basically)
&gt; Only if that breaking change is in the interface. Which they are in the vast majority of cases. I'm an early adopter of Dart. There were a ton of changes in the early days, but the tooling made it a non-issue. Changes in JS libraries, on the other hand, were always a major pain in the rear. &gt; Point is - With types, you ALSO need unit tests which execute the affected lines. My point was that you need fewer tests to reach the same level of confidence. The types ensure that everything does at least theoretically fit together. Have you tried an optionally typed language like Dart or TypeScript?
Glad I could be helpful :)
I've personally seen your interactions and you ARE generally an all around bully towards others. :2 cents:
I guess it really just comes down to each programmers personallity.
Haven't used dart. I have used typescript a little, but again, don't see the point. A lot of overhead for little reward, and *zero* reward if you're leaning heavily towards automated unit test suites. I am primarily a C# developer; I have a lot of love for typing, but don't agree it is a benefit in javascript, not in single-threaded, small-footprint/short lifetime applications. 
It greatly increases your employability at places you actually want to work at. :) I would be hesitant to work at a place that doesn't value knowing the language you are using. Knowing JavaScript is the basis on which you can build your skills in the frameworks. We have a satellite office that doesn't seem to understand js for shit and that code is a huge liability that is always causing problems. That being said, you can't go wrong learning React and some pieces of the surrounding ecosystem. The trick is finding small, independent, composable tools that can play nicely together. That's why I'm a huge fan of React and lodash. For personal projects, that's really all I need. IMO if you can't use a framework at all and can only use plain js you are probably wasting tons of time. 
You will be better off as a master of core Javascript than as a master of one framework. It is easy for a Javascript master to learn a framework, but hard for a framework master to learn vanilla Javascript properly (keep in mind that frameworks generally try to make a lot of tasks easier by abstracting them). That being said, if you want to learn a framework, pick up React. Not only is it very popular at the moment, but it is closer to vanilla Javascript than any of the larger frameworks. Getting better at React generally makes you better at vanilla Javascript, as opposed to getting better at Angular, which just makes you better at Angular.
&gt; It got boring last year, when I started working with React instead of Backbone and Angular 1. To be honest, I don't feel ready to learn Angular 2 now. Stop being a trend whore jumping on every bandwagon. There is no rule or law compelling you to use a massive monolithic framework. I understand that NIH is bad, but providing novel solutions to common problems is a lot more fun.
Thanks for the link this was a good read.
You raise an important point about learning. We find that developers who go the React route and learn about the tooling/concepts around it become much better developers - with better tools. This is not something that happens often with frameworks like Angular. The path is long but rewarding. Unfortunately, even after mastering the tools, the fatigue doesn't end. Setting up a JS project with good tooling is incredibly time-consuming and you have to constantly keep everything up-to-date between your projects. It's a brittle construction made of glue, custom code, and hacks. You get some really great things in exchange for your time. But it really shouldn't be this hard. Here's to hoping 2016 will see this problem solved. Let's hope the solution isn't just "stop using tools". We finally have good tools in JS. Let's make it work.
&gt; A lot of overhead for little reward Overhead? It requires fewer key-presses than JS and it's way more compact than JS with JSDoc comments. Plus, you have to check the docs less frequently and navigating the code is easier. &gt; [I] don't agree it is a benefit in javascript Machine-readable documentation has a lot of value. Also, why do you think GWT, CC, Dart, TS, and so forth exist? Why wasn't Gmail or Google Maps/Inbox/etc written in plain JavaScript? Why did EA use CC for SimCity (2013)? &gt; single-threaded, small-footprint JS apps are pretty fat. Modern JS VMs aren't lightweight in the slightest. The Dart VM produces more compact native code, but I wouldn't say that it has a small footprint. Dart's highly concurrent Fletch VM has a small footprint though. It only needs about 4 KB per process. But it's sort-of multi-threaded. There is shared immutable state concurrency. &gt; short lifetime Compared to what? SPAs may run all day. Web servers may run for months or even years. Anyhow, I still don't see why you think that those things are required to make optional types work.
This. Before reading this comment, I was ready to further research ReactJS. But now, after researching its license, ReactJS is a no-go for me. [This Hacker News thread](https://news.ycombinator.com/item?id=9271246) is informative.
Personally, I am fatigued because of the constant reinventing of the wheel, rather than incremental improvement of existing wheels. As a long-time veteran of JS, having worked with it since 1997, I'm exhausted by these newfangled systems that ignore the entire history of CS that came before them. E.g., Angular and React *both* mix presentation and business logic in truly offensive ways. Most of the Node frameworks have very poor ideas about testing (such as conflating unit, integration, and acceptance testing). And all of these are just recreating things that have existed for years. Rather than improving on other tools - or in the case of Angular, even their own tool - they throw everything away and start over. Because that has become the new Javascript Way - reinvent, reinvent, reinvent. Repeat until profitable. So yes, I'm fatigued because there are a lot of tools that are being created - and re-created over and over - and they're all rather awful.
Simply amazing. My most sincere congratulations (and admiration) to you /u/sebmck. 
Also, if you use a frozen object or Immutable.js, then `const` _really does_ mean "constant", since the reference is immutable and the object being referred to is also immutable.
Google search for "WebGL" and use whatever resources look best.
So.. where exactly are you having trouble? I don't see a question in there. Have you even attempted to do it?
Oh yeah, I agree with those points - I definitely learned similar things at University, but most of them were inside the lecture hall / at labs. &gt; How to effectively manage a project and a team. Sadly, while we did have some group projects, this wasn't emphasized during my course. I ended up learning this much later while working at real companies in a team. &gt; its a struggle to do so live I'm increasingly impressed with the ability of intensive/immersive coursed to distill these required lessons down into 12-week courses (think: HackReactor in SF / GeneralAssembly in Sydney). Graduation from those courses is difficult at the best of times, so I know those folks must have really put the effort in, and it often shows!
&gt; I've spent a huge part of my life helping developers out on the internet, and you want to dismiss me as a bully because I raised concerns about the way a very close friend of mine is treated on the internet? Thanks, I guess this is my life now. I've seen you blast people who were having issues getting Babel 6 working correctly calling them assholes and throwing your "I SPEND MY WHOLE TIME DOING THIS FOR NOTHING" weight around without knowing anything about them. You've actively attacked many frustrated users in the middle of Babel 5 -&gt; Babel 6 upgrading. Your contributions to open source are not a get out of jail free card for being a bully to others.
I don't feel fatigue either. I feel like a kid in a candy store and don't want it to stop.
So take a look at the stack they want you to use, make some really simple demo using their stack with github, and tell them you did it all in an evening (if you did) - that will get you your job. Employers should recognize it is much more about your analytical and problem solving skills and less about whether or not you have some syntax memorized.
Thanks for letting me know! It's a little click-baity I admit... What title would you have used?
Would use if open source. Hopefully you guys take that path.
Something written in an afternoon will do, and you can spin it. Recruiters do this all the time. I've landed jobs that I didn't meet their unrealistic expectations and so can you.
&gt; The alternative class syntax was much needed It was highly requested, but its need was debated for a long time. In the end its the volume of requests that got this feature included more than anything else. There are no needs for classes or hacky things resembling classes in this language. It is only familiar for people coming from other languages who lack confidence in this language.
I would caution you against putting classes with color names into your html. A color scheme you like today may not be so favorable tomorrow. You should abstract that out one more layer.
Nope, I use React/Babel/Browserify/NodeJS/flowType/ExpressJS - and I dont use boilerplate. Instead I copy / paste (LOL) portions of other projects that I want as my boilerplate, and tweak a little. use my npm init and npm install this or that etc. then I wire it up! It doesnt take me that long. I think a lot of people just don't have the passion for tooling, they have all the passion for building user interfaces but just feel impatient and stressed when working on tooling. I think a lot of people just don't care about tooling. I've personally talked to other engineers that really hate the whole concept of tooling and just want to be able to code and see their results immediately. They dont want to worry about the build system etc. Anyway here's what I do: https://github.com/MattMcFarland
All of this with server-side rendering? I'd be surprised if you didn't spend quite a bit of time on that stuff. If you never upgrade anything sure, but since most of the technologies are still relatively young it seems like you'll have a lot of pain should you ever choose to upgrade. Using Browserify instead of Webpack would help a lot though; Webpack is the most complicated piece. You lose out on a lot of functionality but yes.
I see it all the time... project or team leads poo-pooing javascript &gt; everyday in the programming news there's some major release of a framework or library that's "gonna change the way you think about javascript" how can I keep up with all of that? it moves too fast to try to keep up with itn ***and*** get everything done!" Answer: you don't. Once you start programming in principle on a project, why are you ***even considering*** adding or changing anything? Javascript is just as mature as php or python. There are old and solid frameworks and libraries just like cake and django. JS has the extra added bonus of having a low barrier to entry. Not only is it easy to get started because there are no special installations or compilers, but it's easy to grow. For example, in a personal project, I wrote a function that reads a tab delimited file into an object as a 2d array. I'm just a fucking starter with JS/Node, but I could absolutely spit that onto github and npm. Because of that simplicity, you have an ecosystem that is very robust and very active. That function could very easily grow into a library of file reading tools. Built and maintained by one guy just cuz. And then that project manager looks up file system utilities and sees dozens and gets overwhelmed. Dude... its' capitalism at it's finest. Pick one, make it your favorite, and move on.
Thanks a lot man for the link!
&gt; developers who go the React route and learn about the tooling/concepts around it become much better developers Are you kidding me? How can you even remotely say this with a straight face without pretending that you aren't incredibly biased. &gt; This is not something that happens often with frameworks like Angular. Jesus fuck, this is probably the dumbest thing I've heard in a VERY long time. A framework or library has no impact on how good a developer is, nor do they cause anyone to be a better developer by themselves. &gt; It's a brittle construction made of glue, custom code, and hacks. And then you go on to say this? So somehow hacking together a build system with multiple libraries makes you a better developer instead of actually spending time focusing on your code quality? You should probably step back and take some time to look at what makes a good developer. Somehow you equate how hard a ecosystem is to set up to developer quality. I'd rather pick a developer who chooses the best tool for the job instead of the most complex, simply because it's complex.
Fair point, though one of the advantages to having a spec'ed `class` syntax is that the alternative, was what we had previously: Nearly every major framework created their own `class` helper method, each one with subtle differences making a fractured ecosystem where code cannot be shared between each frameworks proprietary class construct.
Each piece individually is easy enough. Combined not so much. Your experience is different from most people I know - some of whom work at Facebook. I'm glad you're having better luck than us. Maybe we really do just have an aversion to setting up tooling. But personally I take joy in editing my `.vimrc`, `.zshrc`, `Dockerfile`s, etc. I feel great sadness whenever I open `webpack.config.js`.
Your favorite honey chicken looks like sesame chicken, which should be available at just about any american style chinese place. Its all over the place here in the US. You can try general tso's as well, which is a spicy version. Happy hunting. :)
That's evidentially not the case. You wouldn't say that Backbone was created by a C#/Java guy for C#/Java people, would you? There are a ton of frameworks which used wannabe classes. And they all worked differently and were completely opaque to tooling. Don't you think it's nice that you now can import some class from some module and auto-complete its methods? You also know how to extend one of those classes. Standardization is convenient like that.
What's NIH.
I would agree if the dependencies were actually stable. Older versions of lodash and bluebird are perfectly stable, and you can pretty easily upgrade to new versions in the future. The libs around React haven't been stable at all. If you had refused to upgrade to React Router 1.0 and found a bug, good luck. I don't think the docs for pre-1.0 are even available anymore. Yes, I'm sure you will say "then don't use unstable tools". That's fine, but despite my complaining the tooling has been invaluable. I just hope for a day where it's not so tumultuous. Fortunately, the tools are seemingly reaching a stable point, which I hope will alleviate a lot of the pain. If you had used your prescribed strategy in say, April or May of 2015, with React/Router, Redux, Webpack, and Babel, it would've been a disaster for future maintainers (and/or yourself).
ES6 doesn't add that much, and it doesn't look anything like C++. People have to get over the idea that they just have to learn one thing and they'll be set for the rest of their lives. That's not how this industry works. Keep learning and eventually you'll look back at everything you know and realize it's everything there is; and then you'll start to look forward to new shit.
How did you comment on a link that was hidden?
As a big supporter of Angular throughout the 1.x branch, and a huge user of jQuery for many years, honestly I've reached that point where I'm doing everything I can to avoid using javascript at all. it's a different kind of fatigue, and it's not like ive totally blocked it out of my life or anything, but I've been really enjoying bringing things back to brass tacks with minimal javascript requirements. It may be just the audience I cater too (enterprise software) but the fancy javascript stuff just gets lost on people and ends up becoming a pain to maintain or add new features down the line. Keeping it to the server side with javascript mostly regulated to the occasional ajax call and basic form validation has made my life, and the life of my co-workers, much easier. though I get the itch still.. havent found a single good project to even try Ember on after all these years.. 
I was gonna say I'm not fatigued at first, because I think there are still exiting things to be done with JS, I'm still having fun after all of these years spent with it at least. But I totally agree with you. 
&gt; In JavaScript, const does not mean constant, but one-time assignment. const actually means that you're creating a constant reference to some value in memory. You can change the value, but you can't change what the reference is pointing to. Because arrays and objects are reference types in JS, you can change their contents, but you can't redeclare them (thereby pointing the variable at a new value in memory) when they are declared with const. I'm pretty sure this is how constants work in most languages.
Awesome feedback. Will do. Thx.
Don't underestimate the mental gymnastics that anti-javascript band wagoners will go to to discredit any new feature of JavaScript.
I read this 3 times, slowly, and I still don't understanding what your are getting at. You're using the question mark but I can't infer what is it you are asking. Are you asking for recommendations for a Reddit app?
Just tell them you have 5 years of experience in es16. That should get you to the top of the stack. /s
+1 It's really not that complicated. It's a constant reference, not an immutable object, and that's fine.
JSXTransformer is deprecated. Facebook, and most of the rest of the world, use Babel now.
I disagree that JS is as mature as python (or that it ever can be). Python is now in it's 3rd major release. JavaScript will never escape 1.0 because of the "don't break the web" policy. It's a fundamental disadvantage that JS has when compared to other languages.
A mobile/native app is needed for a site like Reddit. The JS response to "lets make an android app" is "let's make a React Native app that consumes the already existing Reddit API".
If you know JS well, and can pick up whatever fly-by-night technology or framework an employer is using - you can not only find employment easily - you can make a lot of money doing it. Angular, react, whatever, are all somewhat temporary. Basing your career on a framework is foolish. 
&gt; Both let and const declare local variables with *lexical scoping* rather than *function scoping*. You got some terminology mixed up. Lexical scoping means variables are resolved statically at compile time, and not dynamically at run-time based on execution context. Function/block scope simply limits the visibility of a variable. All JavaScript variables are lexically (statically) scoped. Var has *lexical function scope*. Let and const have *lexical block scope*.
&gt; E.g., there's no world in which we need(ed) Yeoman, Brunch, Grunt, Gulp, Browserify, and Webpack on top of what npm could already do - especially when there's already make. Yet lots of people felt a need to fragment these systems to prove some sort of asinine point. Your problem is you're lumping things in where they shouldn't be. Yeoman is a scaffolding tool. Brunch, Grunt and Gulp are general task runners that implement the basics in different ways. Don't know much about Brunch, but the biggest differences in Gulp and Grunt is Grunt is setup using configuration, and Gulp allows you to define your tasks anyway you want. Browserify and Webpack are asset bundlers. They can be used in conjunction with Gulp/Grunt or by themselves. npm is a package manager that has script support that allows you to have technically a makeshift task runner, and build system. You want to stick to Make? Okay. But then all these tools need to go. https://en.wikipedia.org/wiki/List_of_software_package_management_systems That's just package managers. Because Make is the best right? Why reinvent the wheel when Make is the holy grail? Oh yeah, makefiles don't work so well on Windows. If learning and advancing your skillset, or the act of your ecosystem moving forward instead of stagnating bothers you, time to hang up your gloves. Because you're not cut out for this. Nobody wants to build SPA's in jQuery. That's why Angular was made over 5 years ago. Then React came out and ushered in a new better standard of components to the world, and Angular saw that and took the opportunity to make a new major version bump and rewrite itself to be more for today's standards, not 2009's standards. If using Angular 2 bothers you because you learned Angular 1, then stick with Angular 1. It's going to be supported for a long time yet. Slowly learn Angular 2. Or bet on something else coming out by the time Angular 1 is EOL'd. The problem here is everyone feels the need to learn every new fangled thing coming out and completely rewrite EVERYTHING they have ever made using it. Because apparently since John and Jane use this new tool Gulp, I can no longer use Grunt. It's worthless. And on top of that, the project I created 2 years ago using Grunt is now no longer working apparently so it needs to be redone using Gulp.
The idea that you should learn React before npm and ES6 is nonsense 
I wouldn't bother cause Alien Blue is owned by Reddit for quite a while and it's amazing app, at some point they will release Android version and your app most likely will die.
The idea that you need to learn ES6 or npm before you learn React is nonsense.
ES6 doesn't really add classes; it adds a keyword to enable (and standardise) a commonly used prototypal inheritance pattern with less typing. The difference is not insignificant; ES6 didn't "add" classes to Javascript any more than Jeremy Ashkenas did when he wrote Backbone. And while obviously it's a subjective question, I think it's utterly absurd to say that ES6 looks anything like C++, or is even moving in that direction.
Debugging and tracking
My friend although stated it in a very brash way at first, because of the frustration of getting babel6 going restated saying he felt that 6 was rushed because of Sebastian's want to release it at the conference. It lacked basic documentation on how to get started and what to do. On top of that, some of the plugins weren't working like stated. Your go to method? get snarky, become a drama queen threatening "how about I just delete the docs?" and calling names such as dick and asshole. Many people had chimed in on that convo asking why an OSS maintainer would respond with such dismissive, snarky, and bullying words. And your response to that? "Ok" You want people to be sensitive to your culture and feelings, yet you're free reign to be insensitive to theirs? It's a two way street buddy and frankly you think you're driving down a one way alley.
Nice write up dude, going to give it a shot after I'm done at ~~hell~~ work.
&gt; Just look at Bower! Bower incarnation was 3 years ago. It's our jobs to keep up-to-date with our tools. If you started a project 3 years ago and used Bower, I would hardly consider it abandonware instantly. Now if you did today, yeah. But Bower wasn't always abandonware. It served a purpose. But then npm started targeting Bower demographics and quite frankly, it doesn't make sense to use a package manager to install a package manager that does less than the package manager you used to install that package manager. People complain about this constantly and fail to realize everything they're complaining about is considered "old" in tech industry standards of time measurement. Gulp doesn't show any newer releases before 3.4 on Github, but the domain was registered in 2013. So that's 2 years old already. People are exaggerating it thinking that Grunt came out last week and now we have Gulp.
In ~~this industry~~ life, you have to learn how to learn.
See, we're not going to get anywhere if people want to think that 2 years is _a long time_ - that's more Javascript-community thinking for ya. That's where I take issue with the whole mess.
Well, if you had of succeeded in bringing in coffeescript then there'd be someone there now trying to get you to convert it all to ES6. No one would want to maintain that old-school coffeescript now that it's not the hotness. People on my team wanted to convert everything to Angular when that was introduced. Saved a lot of work by not being dragged kicking and screaming into a future that lasted all of 3 years. 
&gt; People have to get over the idea that they just have to learn one thing and they'll be set for the rest of their lives. Nailed it.
I kind of wish they'd introduce yet-another-initializer: `val thing = {a:1, b:2};` which was sugar for `const thing = {a:1, b:2}; Object.freeze(thing);`
This is a little feature I wrote to help people understand scope with colors: http://prettydiff.com/?m=beautify&amp;l=javascript&amp;jsscope&amp;s=http://prettydiff.com/lib/csspretty.js The comments are a gray color and can be folded. Functions/blocks are have a pale background color similar to their declared references. You can immediately identify closure when you see a reference that is colored far differently from the background of the scope where it is used. You can copy/paste code in directly to the tool or point it directly to another JS file online by changing the value of the `s` parameter in the address. In this case the feature only supports a depth of 16 scopes, because that is all the patience I had for creating color schemes.
In my experience, it's much wiser to hire talent as opposed to specific skills, but this requires that the hiring company be very forward-looking (something which a lot of corporate America isn't good at). IMHO, you should avoid job postings which include a laundry-list of technologies, because they're often just trying to get bodies to fill seats. Build systems, frameworks, libraries, IDE's, etc. are all just implementation details. I don't care if you've used _my_ build system, so long as you've used _a_ build system, just like I don't care if you've used _my_ framework, so long as you've used _a_ framework.
&gt;You have to research and make informed decisions which educates you, and builds your experience. I've been coding javascript since the first week it was released in netscape. The fatigue I have is caused by noobs, who make poor decisions that I have to live with, and a manager (who is also new to front-end) who also doesn't make good decisions. It's classic 'expert beginner' syndrome, and I'm quitting my job this week because of it. 
This is unsurprising behavior. Much like reference assignments, you can change the contents of a variable, but changing the variable itself loses the reference. Example: var myObj = {'foo':'bar'}; myObj.foo = 'baz'; // Changes 'bar' to 'baz' myObj = {}; // now the original object is lost. I feel `const` was a poor name choice. In compiled languages, any constant identifiers are replaced with the value of the constant, and they are not present at runtime. Obviously this is not the case with JavaScript, though I suppose a transpiler could do this. Rather, it would have been nicer to see `let` bind an immutable variable, and `let mut` bind a mutable variable (since we're really talking about mutability here, not constant values).
&gt; It's a community driven language. [Democratically designed!](http://www.wired.com/wp-content/uploads/2014/06/the-homer-inline4.jpg)
It's difficult to justify using/learning a new technology when the one you know and has been around a long time still does everything you need it to. At the end of the day it's about work/life balance and not chasing new tech just because you have FOMO. 
It's a high level guide, meant to encourage beginners to just dive into it, sequentially, and worry about the other portions as you learn the foundations. If you start worrying about setting up Webpack to set up ES6/JSX/ESLint loaders, etc, but are new to the ecosystem, it can be daunting.
My boss will ridicule me if I ever suggest using any code from github that hasn't had a recent commit in the last couple of weeks. He apparently doesn't think stability is a good thing. Can I work where you work? I need to get away from the 'expert beginners'.
I get that your just making a snarky joke, but if anyone is actually interested in getting involved, this is a good place to start: https://github.com/tc39/ecma262
Care to weigh-in on the ES6 discussion? IMHO promises and async/await should have all come together. Classes were a mistake unless they were going to support multiple-inheritance via proxies (even then I'm not convinced Object.create isn't enough). I'm still waiting for an improvement on IIFE syntax. Edit: spelling
Are you using anything like Cordova? I would suggest framing whatever you're targeting instead of opening a new window. This way you can control the frame from the parent element. https://github.com/apache/cordova-plugin-inappbrowser is a good solution for Cordova specifically. You can use an iframe but there are a few complications with that, one of which being most sites block the loading of their page within an iframe for fear of clickjacking and other exploits.
Many of the arguments against using `var` read like those terrible as-seen-on-tv ads' arguments. "Tired of not understanding variable hoisting? Try our new `let` and your troubles will fade away!" Don't get me wrong, I rather like `const`--it's pretty useful. But the introduction of `let` just comes across as bikeshedding. Most of the problems people try to claim it solves really stem from just not understanding how the language works. I'd argue that adding additional complexity is the wrong way to solve that particular problem.
It's always better to program with composition instead of inheritance. But inheritance still has its place. It sounds like whoever wrote the code you are referring too was just over engineering stuff. That's unfortunate. 
I did a lot of ES4/Harmony programming and classes were okay there, though not something I really needed since I already knew how to work with prototypical inheritance. I see ES6 as caving in to the syntactic sugar crowd and it's not a direction that I'm fond of. I don't need arrow functions which look like equals-greater-than =&gt; because it makes reading code more difficult -it looks like a conditional and it's just asinine to mix up the language in this way to save a few keystrokes. I honestly had no problem typing in 'function' before, and I will still use it. Now it's all about typescript, which I'm also not fond of. The problem with typescript is that it is a 'transpiled' language and can inflate it's surface area and thus gets more difficult to work with, and new releases can cause bugs as we've seen a few times in the coffeescript transpiler. I just don't need that shit to get work done.
Babel has a whole section about JSX and React on their front page, I believe it used to say something like 'the official transpiler for React', so it is totally a specific use case, but it happens to be one of Babel's core use cases as well. Edit: Also, the part /u/Funwithloops is talking about happens before any of your actual code is even run, so Babel or JSXTransform *is* the parser.
I do think it's better to be able to create block scope than to need to use a throwaway function to make an inner scope.
Would people really prefer the web to be like IoS/Android, where there is One True Company Approved Way to do things? Personally I'm really glad the web isn't like that.
&gt;Angular and React both mix presentation and business logic in truly offensive ways Many would argue that that rule is outdated.
Plus even with `Object.freeze` it's not too hard to accidentally end up with a sub-object of the frozen one that you've forgotten to freeze.
Maybe it's not JS per se, just the "everything kewl is an SPA" attitude?.. I mean, if you take something like Knockout or React and string together a mostly server app with some client-side logic (that's actually bound together nicely instead of spread over a bunch over haphazardly written scripts), wouldn't it be nice?
Also check out my other little side projects: http://nodegarden.js.org http://deck-of-cards.js.org ;)
Two years is a substantial amount of time. In general. In about 1.5 years, I've gone from zip to solid junior/middle dev. In software development as an industry, two years is a long time. Rails 2 was released in 2007. Rails 3 - in 2010. Rails 4 - 2013. Now Rails 5 beta is here. Each version bringing its own different features and twisting the interfaces.
I would be inclined to agree with this one. It's one of the few places I think it's useful. On the other hand, in the few places I've actually needed to create that block scope, I've found that a little refactoring removes the need for that scope manipulation entirely, and generally just ends up more maintainable in the long run.
The linked waypoint tells you about `Object#hasOwnProperty`, and I believe an earlier waypoint should have told you about the strict equality operator `===`, like maybe `return example === something;` (where `something` is already known from somewhere else).
Two years is nothing. You're using Rails as an example which is still another web scripting tool that hasn't been around very long - and release dates are irrelevant without looking at adoption rates. (See also Python 2/3.) The bigger point here, though, is that minor interface changes between major versions of a *language* is wholly different than throwing away entire technology stacks every two years, which the JS community does regularly. Last, 1.5 years isn't even enough time to know what you don't know yet. Give it another ten and you'll probably have a different opinion on the subject.
thanks dude for your large explanation - it is really valuable to read something like that when you are beginner :) and as beginner i must say that i have difficulties to understand you. i lost many nerves on problems labeled with "NEW". they are so demotivational for beginner. 
https://en.m.wikipedia.org/wiki/The_Paradox_of_Choice “*Why more is less*”
Check out: https://freezer.js.org/minimum-viable-view-library/
Check out: https://freezer.js.org/minimum-viable-view-library/
`const` comes from C, but w/ behavior more like Java's `final`. Problem is that folks confuse objects as if it was the same thing as the variable(s) which stores their reference. `const` merely prohibits a variable to be reassigned later on. If we also wish for the object referred by some variable to be immutable, we use **Object.freeze()** over it: `const THING = Object.freeze({ a: 1, b: 2 });`
Personally, i learned JavaScript and libraries that are for JavaScript much faster than i did with other languages. I am not sure what it is, but the language really sticks well with my brain. Also, i think the best part about JavaScript, is the non linear approach to problems. Instead of using library x, there are probably 10 or so other libraries that you could try, or better yet, you could make your own library! Seriously. For anything you want to do, there are multiple libraries. Want to make a game? Chose from the many game libraries (I prefer Phaser), there is literally so much community that it makes learning about the language, and new libraries worth it! JavaScript has made me more productive in the past month, than the last 6 months combined. When i use JavaScript, i am actually excited about using it. JavaScript is the language of my soul, so to speak. 
These are actually already added back..
This bjson means bind json
Does CDN means something other than content distribution network here? Because the method by which you serve files is largely unrelated to setting up a build system
Build engineer?
&gt; Angular and React both mix presentation and business logic in truly offensive ways If it works, it works. MVC (which Angular/react are not, at least not out of the box) is just meant to be a conceptual approach to make things easier, but it's by far not the only approach. The key here is to establish consistent systems and logical behavior that makes it easy to extend and maintain code in the future. Angular--I have little experience with React--accomplishes that quite handily, in my opinion.
People invest a lot of time and money in their educations, and we are generally conditioned to "get our degree and go to work", but the reality is that that is no longer enough (particularly in something with the rapid evolution of the web). You don't get afforded to learn a single thing, become sufficiently expert enough to work a job for 10-15 years, and generally not need to learn anything else. Overall this is a great thing for many people, but it is going to be frustrating and tiring for quite a few as well. I see it as opportunity. If it was easy, anybody could do it :)
100% agreed. I am by no means a beginner but when I pick up any new framework or library I start as minimally as possible now. I used to jump right into all the tools and whatever and found myself overwhelmed more times than not. If you're just learning anything, take baby steps. It's like driving a new car... You know how to drive, but you don't know that car. You wouldn't take it fast around a corner based of your comfort level with a previous car you had.
You have to have something larger in your GitHub too in my opinion. Since all of these things operate on the same principles you need to prove two things. First is that you can make something decent, in whatever language. Second is that a new language won't be a major barrier with you. 
Every new technology has this phase where there are a billion different ways to do something. In a few years things will settle down on a few defacto tools.
Oh, yeah, I understand what a CDN is, but the most using one will save you in terms of your build system is you won't have to worry about packaging and deploying third party libraries. There is a ton of other aspects to the build system you will still have to set up.
How is that true? Can't you just use the version of software that works? everything on npm is versioned.
Nice! But you should push es5 to npm with a prepublish script that calls babel.
Some example code to illustrate .. function test() { 'use strict'; const a = {}; const b = {}; const c = {}; let changeableReference = a; changeableReference = b; changeableReference = c; changeableReference.newProperty = 11; changeableReference = a; const nonChangeableReference = c; nonChangeableReference.anotherProperty = 12; // OK, changing the value, not the reference nonChangeableReference = a; // ERROR } Run that in a browser with ES6 let/const support. You'll see it runs fine until the last line.
this works thanks
I think you've misunderstood what I was saying. Languages will have major releases because there is a feature that _is worth adding_ which causes other features to break (i.e. breaking changes). When these features get added to a language, they bump the major version to let people know that their old code won't run without refactoring. It's important for languages to go through these growing pains because it keeps the language concise and powerful. JavaScript can never go through a breaking change. There are lots of areas where the language would really benefit from a breaking change or two (the equivalence mess comes to mind) but you can't discard the old junk in JS because it would break code that's already been written. As far as I know, JS is the only language that promises to never make a breaking change and this is definitely a disadvantage.
 var block = ['MMR: 2 | asdf', 'MMR: 1 | qwer', 'MMR: 1 | zxcv', 'MMR: 1 | fghj']; console.log(block.join('\n\n')); Does that work for you?
I agree with you that `let` is not strictly necessary. But there is also value in common standards, across programming languages. Additionally, `let` opens up a lot more fine-grained control of variable scope and is strictly more powerful than `var` in that sense. And since `let` and `var` are otherwise so similar, there is no point in teaching or carrying around the mental weight of the decision between them. So in summary, just use `let`. 
Surprised no one mentioned teamtreehouse.com yet. 
With JS you need to catch the tap on (local) links, prevent the default behaviour and forward the page to the contents of the href tag. You should be able to google this together.
that worked but im not sure how .join() works. 
[Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join) There are a bunch of other nifty array methods as well. 
I agree. Nothing has mandated that I write in ES6. But I've explored many libraries for research purposes over the past few months and to a beginner, I can see how it can be such a mess of noise. Without knowing what to look for, you can get really turned around when you run into ES6 tutorials that don't distinguish themselves or, even worse, CoffeeScript tutorials to show off usage of a library that is perfectly usable with ES5. Not saying the tutorials are good, just that they add to the noise that can really make it difficult for beginners.
Backbone was developed by a ruby dev.
Agreed. Don't use prototypes or the new class syntax. Just use closures and plain objects.
I have never touched CoffeeScript and to this day I cringe when I see articles or tutorials that use it. That said, ES6 tutorials are acceptable now. People will have to switch eventually and it's better to be ahead of the curve than behind. Granted, for a beginner I'd avoid it. 
Agreed.
its nonsense. only someone who learned only js first would think this is acceptable.
Yeah I understood your point. My point was that it's just an abstract a part of the foundation of the language, and therefore I don't consider it a "disadvantage". It's just a fact of life. I used the transmission as an example, but I think a better example is the Python 2/3 fracture. I wouldn't call that a disadvantage (tho some would) because its a low-level part of the universe. Other than that, does it really matter? It's there, but you don't really have to deal with it. It's a concept that doesn't directly affect the day-to-day. 
Will do what's your GitHub? I'll follow ya I'm at https://github.com/wski if you ever have any more cool ideas and want a lending hand I'm always up for a challenge. Likewise I've got a bunch of cool things going on if you ever get bored. :)
just to provide the anti-hint version -- this also works: function onlyTheTruthy(obj){ var result = {}; for(var p in obj){ if(obj.hasOwnProperty(p) &amp;&amp; obj[p]){ result[p] = obj[p]; } } return result; } and the delete operator is pretty slow in general... anyone want to do a jsperf to find the point where this might be more efficient than delete? also note, if you're into functional programming, this one won't mutate the original :)
No one is questioning that you need to keep up to date with tools. They're only questioning the need for new tools that are just rehashed old tools in a way that a few "rock stars" thought as unique. [Obligatory XKCD](https://xkcd.com/927/) Anyway, the newbie defends it because they know nothing but the latest fashion, and this does give them a leg-up since they've been professionally trained in how to use [tool x]. The next decade, when they're seeing the problems, they'll start asking the same questions that were asked to them. They'll also receive the same answers offered by the next crop that wants to repeat the cycle. Such is the cycle of web development. 
&gt;If it works, it works Spend a couple of hours in the Wordpress codebase then come back and say that.
Nah, this is a fairly cyclical thing. I remember this exact conversation occurring with ASP.NET components ("controls") many many moons ago.
the silly part is that as an experienced programmer, i do the exact same dadgum thing. i think [yagni](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) should become the guiding principle of javascript developers to fight the fatigue and the bloat. don't make things until you need them.
The problem with `Object.freeze` is that it only "freezes" the top-level object. If your object contains other objects that `Object.freeze` was not called on, those objects will not be immutable. Of course you aren't required to "freeze" objects all the way down the chain, but not doing so is inconsistent and could easily lead to weird bugs if the values unexpectedly change in other places.
I've used and liked codeschool.com. 
works great. would be nice if a child comment is selected, have it go to the next child.
Ahh so dynamically navigate based on thread depth. One problem is that native reddit doesn't support any sort of "selection" so it would be a feature only compatible with RES users. I'll look into it, thanks for the suggestion!
Also, it's good publicity :)
Werd.
Problem solved. Thank you /u/floydophone
Once you truly understand how powerful it is, you will never want to go back. Implicit return (and everything is an expression) are two reasons I love coffeescript. If you are doing functional programming, not returning a value should be the exception, not the rule. 
It's also pretty easy to save a file and reference it....
Easier for designers, crappier for programmers. 
You don't need to use any of those additional libraries if you choose. I write plain coffeescript with react and lodash for my side projects and it works fantastically. If you are dealing with lots of structures APIs and many pages you are going to want a good way to organize that stuff. 
Cool! One suggestion though, if your going to be making a front-end component, anyone using it will most likely want to over ride your styles. 1. CSS is case-insenitive, which is one of the reasons why most people use `kebab-case` with their CSS. You seem to jump back and forth. (http://www.w3.org/TR/CSS2/syndata.html#characters) 2. Personally I'm a fan of BEM style CSS, as it allows people to see the exact relation of the styles from the names (from what I've seen, there is no 'best practice' to arise in CSS naming schemes, making it one of those endless debates that never seems to disappear). 3. Consider putting in a package manager like `npm` 4. Lastly, I see you've licensed it as GNU, which makes it practically a no-go for any use for most people. You might want to consider a more lenient `LICENSE` file if you want people to be able to use your OSS. (I'm no lawyer so if I'm mistaken here please let me know)
Okay, I'll bite. &gt; I think the reservation is that it obfuscates how JavaScript actually works and gives an impression that it's working differently than how it is. Can you give a concrete example of this? A lot of languages have classes and/or a `class` keyword, and there's a *ton* of differences between how C++, Java, Python, Smalltalk, PHP, C#, Simula, etc. have implemented classes. Have you chosen one language as the canonical representation of classes, and deemed all others as "obfuscating" how that language actually works, because they don't match it? And if so, which language? Smalltalk is usually considered the canonical example of a class based language; are Java classes misleading because they give the impression that Java works like Smalltalk? Come to that, why are we focusing on classes? Variables, functions, scope, numbers, null, and a thousand other things don't work the exact same way in Javascript as they do in C, or Haskell, or whatever. Why is it a problem that `class` isn't exactly the same in JS and C++, but it isn't a problem that strings aren't null-terminated in JS? Isn't it misleading to call them "strings" when, as we all know, real strings are null-terminated?
It's more like if Google or Facebook decide you're violating their patents they can revoke your license to use angular or react. If you use them as a linch pin in your work that can be a mighty influence to discontinue your product, shut down your business entirely or need to rewrite your web platform because it has some sort of social component either entity has a irrelevant patent on. Keep in mind this might seem banal, but revoking a license and enforcing license agreements its painfully easy in US Law compared to filing a patent claim/violation. If your entire website is based in react/angular, having one phone call from a lawyer to rewrite your entire stack can bankrupt people quickly.
Looks cool
Make is beautiful though :&lt;
I agree with you, generally, but [this](https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.cl7ocy7ti) article, recently posted by someone else, gave me a new appreciation for the mixing of presentation issue, and how it's handled in React (in this example).
&gt; separation should be of concerns not technology. Can you unpack that? Are css, js, and html not modeling different concerns? If not, what are the concerns that should be separated?
ITT: "I have a lot of time to investigate things! All the options are wonderful! Javascript is a kaleidoscope of beneficent code gnomes offering me the fruits of their ingenuity. Kumbaya everyone!" vs. "Fuck fuck fuck the guy paying my bills just said the words *Angular 2.0* and I just spent the last year learning React and I'm still maintaining that fucking site and I'm definitely not getting paid training on this project, *shit*."
&gt; If learning and advancing your skillset, or the act of your ecosystem moving forward instead of stagnating bothers you, time to hang up your gloves. Because you're not cut out for this. There is an old saying about professional development, that ten years of experience is not the same as one year of experience repeated ten times. The trouble with the current JS world is that it's awfully close to the latter. An endless progression of new tools doesn't necessarily advance your skill set or move the ecosystem forward in any useful way, where by useful I mean being able to produce good, working sites and apps reliably and efficiently. &gt; The problem here is everyone feels the need to learn every new fangled thing coming out and completely rewrite EVERYTHING they have ever made using it. And the problem with that argument is that so often you don't have a choice, because there is so little longevity and stability in modern JS dev tools that literally something you just figured out last week can be broken today because of someone's update three links down a dependency chain. An obvious example is that we've been forced to give up tried and tested plugins like Flash and Java in favour of modern JS and HTML5, as browsers have literally been removing support for existing, working functionality. I find the idea that the new way is better mildly hilarious: it turns out that browsers also have bugs and security issues, but frequently they also don't actually provide basic features that work correctly and quickly, and there are several different ones each with their own quirks, and on top of that they update and move the goalposts unpredictably at an absurd pace. If the people at *YouTube* can't even manage to write a basic HTML5 video player that actually works reliably for more than a few days -- and based on the numerous glitches over the past few months, it appears that they can't -- then what hope do those without Google's resources and influence have? But of course it's not just about plugins. The exact same argument can be made about the plethora of task runners and build tools, and about the entire fragile JS package ecosystem under npm.
Thanks!
&gt; It's our jobs to keep up-to-date with our tools. No, it really isn't. For most of us, our job is to produce a good web site or app. The tools are just a means to an end, and if any tool is getting in the way or slowing us down, we should stop using it. Also, I'm having trouble telling if you're being serious about the timescales: is your characterization of 2-3 years as being a long time intended to be ironic/humorous? I suppose maybe it is if you work for a ship-it-and-flip-it start-up where your only business goal is to make a MVP that you can use for a big exit before anyone actually has to maintain anything, or perhaps if you work for a big web site with a full-time team dedicated to maintaining it, but many web sites and apps are not in these categories.
[removed]
&gt; I think one of the main problems is that however enthusiastic you may be about the rapid progress of JavaScript, you're often going to have to work with those who aren't. The JavaScript world changes rapidly. Whether it makes rapid progress is a different question. &gt; Dragging others kicking and screaming into the future with you can be tiresome and draining for everyone. The trouble is, there is so little longevity and stability in the JavaScript world today that no-one really knows what it will look like in six months or next year. You can drag others kicking and screaming into what *you* think the future will be, but if you're wrong, you just killed productivity forever on that project until the next team comes along to rewrite the whole mess using *their* idea of what the future will be, and so the cycle continues. Meanwhile, those old fogeys who expressed some healthy scepticism about relying on bleeding edge developments with no track record are probably still maintaining working systems with lifetimes measured in decades, or building new systems that will be close to that because of their carefully controlled dependencies and more conservative approach to tooling.
&gt; trying to stick with it indefinitely That wasn't the intent of my post. Even the bit you quoted gives a time-related context. In the context of the current project that you're working on, once you've started building, there's no reason to change of the toolset for the duration of the project... showstoppers and security notwithstanding. And when the project is over (unless it was extremely short, like a couple weeks) then revisit the toolset, update from 3.1.7 to 3.1.12. Upgrading versions midstream, unless it's for a high order fix, is asking for trouble.
Alright fine CDNs are worthless and you should never bother with them. Happy people?
&gt; In the context of the current project that you're working on, once you've started building, there's no reason to change of the toolset for the duration of the project... showstoppers and security notwithstanding. Other things being equal, I think we would agree on this. This is essentially what I was talking about with the old school way of building things: stick to mature, reliable technologies that just work, knowing that you won't always have the latest little trick available but that what you're working with today will probably still work tomorrow. Unfortunately, other things are rarely equal. My experience has been that no project using modern tools and libraries and lasting more than a few weeks reaches the end without running into one of those show-stopping or security issues. Moreover, as soon as you update anything to fix that issue, there's a significant chance that there will be unintended knock-on effects that can start a whole chain of update-everything-to-the-latest whether you wanted to or not. The kicker with web development is that sometimes the change doesn't even come from anything in your code or its dependencies, but from browsers breaking something when they update. This happens all the time and is IMHO the most fragile part of the entire industry, and it's entirely out of our control. Again, the most successful strategy to mitigate this risk that I know is to avoid using less mature features as much as possible, but since that literally rules out every useful part of HTML5 and CSS3 to some extent and since browsers are actively hostile to the plugins that we used to use to do a lot of these jobs instead, there simply isn't any stable platform to build on any more.
maybe target the &lt;div class=child.... and use :nth-child(n) to go to the next child class. i like your extension +1..
Thank you so much for the feedback.
What exactly are you trying to do
Yup. Moving from PhoneGap to Ionic after a few months. Slow and steady wins the race.
God that sounds so boring.
It's just a coping mechanism. The web is going through its nth "paradigm shift" right now, and people feel overwhelmed. All this diversity and experimentation is obviously a great thing, unless you're being paid to deliver "state-of-the-art" web experiences. Then it's just a pain in the ass.
&gt; srsly reddit no markdown? I guess you mean fenced code blocks. That's a Markdown extension which Reddit unfortunately doesn't support. 
=&gt; isn't always going to do what you think it should. There are still gotchas with fat arrows. [https://mobile.twitter.com/search?q=arrow from:getify&amp;src=typd](https://mobile.twitter.com/search?q=arrow from:getify&amp;src=typd)
Being able to close over loop counters is great. I really like that they copied this from Dart. I also like to declare my variables on first use as I do in other languages. Function scope was really inconvenient. Furthermore, IIFEs are now rarely needed which is also an improvement. If you don't use `var` at all, things are now a lot simpler.
Indeed. In the end, these frameworks were made for specific use cases: to make it easier for a professional team to develop and maintain very complex apps. When beginners try these frameworks they usually end up using them for apps that could have been easier done in vanilla Javascript. Hell, i've made that mistake myself in the past! But for beginners these frameworks add a layer of complexity that stops them from grasping what javascript is capable of out of the box. No wonder they get confused.
well what does your html look like?
like this: http://codepen.io/anon/pen/KVWZpz
&gt; downloaded the NW.js &gt; execution of .exe files It has nothing to do with JavaScript if a user downloads and runs an .exe file. Literally any programming language can do whatever it wants after that point.
Same here, although I often fall into the trap of spending hours and hours playing with a boilerplate or developing my own one:) imports, single-purpose modules, emphasis on the functional style of programming seem to have improved our situation compared to times when Backbone and Angular 0.5 were the cool kids on the block. Now, I can use React (or whatever else) for rendering, import only the RxJS operators I need, and build the whole thing using one browserify command. And that's pretty awesome. In a way, the reason tooling, dependency management, and the package ecosystem got so much better, is the fatigue.
[removed]
Oh sorry, it's because `i` evaluated when the setTimeout executes, and by that time the loop has completed and `i = 4` so it runs the setTimeout 4 times with the same `i`. You can achieve the same thing with the delay() method in jQuery (and not use setTimeout), var carousel = function(){ for (var i = 1; i &lt;= 5; i++){ $("#el_"+i).delay(i * 1000).fadeOut(); } } carousel(); If you're trying to learn setTimeouts then you'll need to have a closure for that, eg. var carousel = function(){ for (var i = 1; i &lt;= 5; i++){ (function(closurei){ setTimeout( function(){$("#el_"+closurei).fadeOut(1000);}, 5000 + (closurei * 1000)); }(i)); } } carousel(); This might be easier to read, var delayFadeOut(closurei){ setTimeout( function(){$("#el_"+closurei).fadeOut(1000);}, 5000 + (closurei * 1000)); } var carousel = function(){ for (var i = 1; i &lt;= 5; i++){ delayFadeOut(i); } } carousel();
Hmm for me async/await is just the same as generators, only syntax differ. Both rely on promises so it is not really difference between async function() or co( function*() ). Your solution does what I was thinkin about, eg create helper functions that transform patterns like done/err,result into thing that is acceptable by await/yield (that is Promise in my case). ES6 promise became standard just way too late, and there are too much inconsistencies in this.
Javascript/jQuery: $(document).ready(function(){ $("a.openlink").click(function(e){ e.preventDefault();// prevent the default click event (opening page) working var url = $(this).attr("href"); // work with the URL }); }); Follow this with /r/Graftak9000's comment and you're golden. I recommend just opening a pop-up (iframe?) window above the content, or replacing the content entirely. You'll have to do some Googling.
&gt; and we'll probably come to some sort of status quo. I have to disagree. Number of people who are programming JS whether as their vocation or their hobby is increasing and won't stop. With increasing numbers, we won't see any single winners, but more fragmentation and more proliferation. I think that is a good thing.
I SELECT you Pikachu!
&gt; By the way, no one cares if you did it the hard way and used a dumb editor. Agreed, but that isn't the point. In some cases you do not get to dictate your own development environment. You absolutely don't get to dictate the development environment of your users, peers, partners, or associates. That is hardly a cause for celebration in the change of a language. I turned off intellisense in Atom, because in large files contained in large projects it is slow and produces results that aren't helpful. &gt; Modules and classes are terser than the alternatives. I eagerly await ES6 modules so that. &gt; I really don't see how this equates to adding trash. Boilerplate. Wrapping instructions in a convention for an external benefit not observed upon the code being described by that convention is adding trash. Code is far more simple to read once all the silly unnecessary conventions are removed.
Watch out, Highcharts has a pretty restrictive license. http://shop.highsoft.com/highcharts.html OP, check this out: http://www.jsgraphs.com/ You can use filters to find the library that fits your needs. 
Really nice extension! The only thing I would like to point out - pretty minor really - is that you code uses both tabs and spaces for indentation. &gt; Line 13 and 131-143 use tabs while the rest use spaces. Besides that, it all looks really nice! I did just submit a pull request to it for a thread-depth navigation too - works with, but doesn't require RES. Click any comment of any depth and the navigation will stay in that depth, I assume that what the idea was.
&gt; =&gt; binds 'this', to the function, which was really needed. Except bind() already existed. function(x) { ... }.bind(this) 
Does it? I knew you had to buy a commercial license, but I don't mind that - are there any restrictions if you purchase? Edit: that comparison website is great, thanks!
Generators don't rely on Promises. You can `yield` them if you like but you are not forced to in any way.
$90 for a non-webapp site if ok, but if you are doing a webapp, it jumps to $390. It all depends on your project really. Regardless, Highcharts is a strong choice. Well documented and works very well.
I used CS for 2 years and went back to JS for a new project. CS has no real value over ES6 and is harder to read. 
Maybe each one is taking 100ms, but waiting on the previous request to complete? Http 1.1 allows two simultaneous requests at a time. Or maybe there's a limit elsewhere. Just a guess 
So it makes you stupider faster?
Promisify
&gt; Create a Native App that's Actually Just a Browser Disguised as an App
I expect him to recreate RES but 100x better and I want it last tuesday! Just kidding. I figured so, I was just proposing the solution to the problem. Fine extension, op. 
Typo'd, thanks.
&gt; I expect him to recreate RES but 100x better and I want it last tuesday! Maybe he'll have the proposed paid pro-mode running earlier than the RES dev :D Been waiting for that for a while\^\^ edit: just in case someone doesn't know, he wanted to do a premium service for RES which would allow you to sync your settings, I'd happily pay for that but I guess RL and a job got in the way.
&gt; Create a Native **Desktop** App From the title, I wasn't expecting much. I figured you left out the crucial detail, making this look like an article about building mobile apps. On another note, why are we calling them apps ? I get that this laziness has infected the industry for years now. But when we're on desktop, can't we just call them programs?
Reddit Enhancement Suite - Enhanced Edition: coming to a browser near you Summer 2016 I hadn't thought about replicating RES selection before. But thanks a lot for the feedback and kind words guys :)
Damn dude thanks a bunch man, I'll take a look today! And yeah that's what I get for not using a linter haha... thanks for the heads up.
With RES you can use shift+j/k for the same effect, and it also works in sub-comments as well.
I haven't explored much into Chrome extensions, but can you figure out what extensions are running?
No linter ಠ_ಠ You're a brave man with a lot of patience. 
I think you are partly correct. But not everywhere because: document.querySelector('my-app') returns for me an HtmlElement. Not an UnknownHTMLElement. see also: https://github.com/angular/angular/issues/5968 The following returns true: ``` document.createElement('my-app').__proto__ == HTMLElement.prototype ``` But I think you are correct that the AppComponent class, in my case, is not like in polymer extending the HtmlElement class. But it seems like registering the element still as custom element, behind the scene.
Haha I haven't had many problems working alone but with collaboration I see where the linter is very needed. I'll take a look into adding one.
[Wrappers](https://en.wikipedia.org/wiki/Adapter_pattern) are fine. If you have a particular convention in your codebase, create adapters for the libraries you're using.
This x1000. Two years ago I invested time in learning Angular. A year later I started to hit its limitations with some large applications, and transitioned over to React. Now that everything seems to be going down the path of virtual-dom, component based architectures, functional programming... it's all transferable skills. In the end it is all just javascript.
The problem you have with async/await is misguided. The purpose of async/await (in JavaScript) is to reduce code and improve the readability of promises.
I read this as "Lol Json DB" and thought "aptly named."
I haven't tried Nuclear yet, but I would definitely recommend Redux, not only because of Redux per se but also because of all the troubles you will save yourself by going with the current industry standard, and always having documentation and an active ecosystem to help you when needed. 
You can understand the core concepts and the code that implements them in redux in an afternoon or less.
I guess this is where I have a differing opinion. Closing over loop variables is mostly unnecessary (there's no penalty for extra variables declared in function scope), and declaring variables up front (instead of just in time) makes for more readable code. However, I do admit that I find it more readable because it more closely mirrors the syntax of older languages, such as C. C was the first language I learned, though, so I'm quite biased in that regard. I'm also biased in the sense that I think some degree of language inconvenience is a good thing: it forces you to think a little harder about how to write your code, which leads to better code quality in generally. The article even goes so far as to make a case for convenience over understanding of a basic language mechanism: variable hoisting. I think rewarding that lack of understanding is a terrible thing, especially for a language like JavaScript.
As in their code? chrome:///extensions, get the ID of the one you're wondering about, then check ~/Library/Application Support/Google/Chrome/{Your Profile}/Extensions/{id} EDIT: manifest.json indicates entry point As in the process? Menu &gt; More Tools &gt; Task Manager
Emm.. isn't this hybrid?
To build off of what /u/mikrosysteme said, it also doesn't require the additional dependency on `co`. If you look into the history of generators, yield, asnyc, and await, you'll see that in most cases people are using generators, yeild and co is a temporary stopgap while we all wait for `asnyc` and `await`, the objectively cleaner solution to asynchronous JavaScript. This is why `koa` (the framework to use if you want to do asnyc code) is completely switching to `asnyc` and `await` in 2.x.x, as was the plan the entire time. yield and generators are a more generalized concept, so yes - you can do everything with them that you do otherwise (in some form or another), but that's not the point.
I have a very small [project](https://github.com/aholmes/Simple-screencap) that I posted in /r/csharp a while back, along with some notes about what else I wanted to add to it. I woke up the next day to a pull request that had some code improvements and added features that aligned with the additional work I wanted to do. It felt really good that someone took the time to do that, and that they had enough interest in it. On the other hand I was bummed that I didn't get to do it myself, but the feeling of "success" from having another contributor overwhelmed that.
&gt; http://electron.atom.io/ There is actually an article about this on his blog http://tangiblejs.com/posts/nw-js-electron-compared
Javascript is not blocked while scrolling, only painting is disabled while scrolling.
`const projectWithSameName = await Project.findOne({account: account, name: projectName, isDeleted: {$ne: true}})` This is completely valid code. If you read the docs (RTFM!) http://mongoosejs.com/docs/promises.html &gt; Mongoose queries are not promises. However, they do have a .then() function for yield and async/await. If you need a fully-fledged promise, use the .exec() function. This is to say, mongoose queries are thenables, and work with `await`. `await` doesn't need an ES6 Spec promise to work.
Maybe it's harder to read for you. Not for me. If you use functional programming heavily there is no comparison. Loops and control flow statements aren't even expressions in ES6. If you don't understand why that's important you should keep investigating other functional languages. Just be careful, when you finally understand it will be hard to go back. 
Sweet!! :)
Definetly is on versions of iOS that I've mentioned. I mean you can test this by setTimeout console.log and watch it stop while scrolling is happening. There are a few example test pages of this. 
Yep, that's a decent writeup of how you'd structure a JS CPU simulation. Back when I was still actively working on [jsGB](https://github.com/Two9A/jsGB), its Z80 handler looked a lot like that: register block, opcode map, clock increment function (which is where all the execution happens, of course). The line right at the center of things is deceptively simple once you have an array of functions implementing the operations: Z80._map[MMU.rb(Z80._r.pc++)]();
Very cool!
Extensions are distributed as a zip file, you can inspect them.
&gt; Since Javascript is dynamic typed language, so types are checked at run-time. Due to this, most of the time we get silly typo errors while programming in Javascript. A variable could be assigned to Integer and later reassigned to String. I take real issue with calling '1234' a typo; it's a fundamental misunderstanding of types. Variables aren't 'assigned' and 'reassigned'. They hold whatever literal type you give it. That you can coerce '1234' to 1234 is not sufficient reason to learn a new language - you should address the problem in your coding style. 
When I read into Nuclear, it looked like: Redux without middleware. And if you combine Redux with Immutable, you are essentially getting the same thing.
No ones complaining about how hard it is to keep up with JS? I thought that's what the "fatigue" was about.
It's a bigger problem than you might think. I work with a group of about a dozen frontend engineers... How many of them understand the language well enough to avoid memory leaks and performance bugs in our large SPA? Probably one or two, at best. Most javascript developers I've met (read: small sample size) *think* they understand the language, but in reality, they only partially understand the bits they've bothered to actually investigate; for the rest, if something "doesn't work", clearly it's the language that's broken, and not their usage of it. It's like complaining that your "jig saw" isn't very good at cutting shapes out of a piece of wood.. but what you actually have is a power drill, so it's not really any surprise.
Yeah, this is for pre ES6 dev. It was made to make some of the maintenance work I was doing for clients easier. Due to time or business constraints, I wasn't able to change things up and use Babel, so I made this instead.
Thanks!
I'll let you keep the tears of failed rubyists for yourself. Meanwhile, I won't waste my time with a futureless technology. 
&gt; separation of concerns This has nothing to do with SoC. https://en.wikipedia.org/wiki/Separation_of_concerns &gt; You are advising a language feature because it benefits your development environment Yes, it benefits everyone who uses an up-to-date editor or IDE. It also helps with things like doc generation or tree-shaking. Furthermore, having a standardized way to do this makes it a lot easier. You won't have to learn the ins and outs of some framework's or library's homemade wannabe classes. It's easier to comprehend. &gt; outside that language I really don't see how working with source code is something one could consider being "outside that language". &gt; much closer to 100% No, not nearly 100% of the developers are using dumb editors for now and forever. &gt; boilerplate boilerplate boilerplate As I already mentioned, using the class keyword is more compact than messing with prototypes yourself. It's less redundant.
&gt; `new Array(3).fill()` Oh hey, they finally added that. Last I had seen (which was a while ago), it was a non-standard method only supported by Firefox. &gt; You can't use local variables before they were declared. It's the same in any other language. There is no surprise there. Right, but one of the arguments this article was making for using `let` was "but people don't understand variable hoisting." Except hoisting still applies to `let`, so it's a completely bogus argument. It just has a different failure mode. &gt; And your argument doesn't? You literally said that it's better if languages are cluttered with traps. Please, don't tell me I *literally* said something that I didn't even get close to saying, even figuratively. I said some inconvenience is a good thing. Not all of it, not all the time, and certainly not "littered with traps." A language that's convenient for everyone everywhere is a silver bullet; they don't exist, and for good reason. This is exactly why I called your previous argument disingenuous. 
No, it's really, really, truly not a custom element. It turns out I was a bit mistaken about UnknownHTMLElement in Chrome: Chrome creates a proto of HTMLElement for elements with dashes in the name, like `x-foo`, but UnknownHTMLElement for elements without dashes, like `foo`. That's a little besides the point though. The proto that the browser gives is generic and not determined by the Angular component definition. With a Web Components based library the element definition is registered with the browser and when the browser creates elements via document parsing, createElement(), innerHTML, cloneNode(), etc., it sets the prototype to what was registered. This and the lifecycle callbacks, which Angular components also do not receive from the browser, are the only things that make up the Custom Element standard. So again, Angular really does not use Web Components. I'm very familiar with this topic. I'm not lying here.
I tried 1.000.000 ; 1,000,000 and 100000, and also tried each with a $ sign. The poop count and the minute count were simple Integers.
Suit yourself. I can write code in about 10 languages for various purposes, and I've saved myself and my coworkers dozens, if not hundreds of hours by spending time writing various scripts. Some people have different definitions of wasting time. Don't you know that this entire life is just a waste of our time? :) Also, the Atom text editor uses coffeescript heavily. Looks like it's here it stay for a quite a while. :D
Could you write some pseudo code to demonstrate the differences for those of us who haven't used `elm` and `cycle.js`? This sounds like an interesting conversation but it's difficult to chime in without experience in all three without seeing any code to demonstrate the advantages your speaking of (which is probably why no one else has commented)
Thanks for telling me what I mean and what I prefer. Clearly you know them better than I do.
Author here, would love some feedback on docs and API. Would also love to answer any questions anyone has. Thanks!
Here's the canonical example that both these guys lead with. Elm's main docs are based around it, and Cycle.js also promotes it (probably to show how it's similar to Elm): http://jsbin.com/mafetitece/1/edit?html,css,js,output http://elm-lang.org/examples/buttons Here's the noteworthy code from the Cycle example: **DOM.select('.increment').events('click').map(ev =&gt; +1)** The results of that observable (reduced via the "scan()" method to be a count) is piped right into ouputted DOM, and reactively stays up to date as more clicks are observed. The human input events and outputted DOM is continuously called in a "cycle." Elm does something almost identical. They both have a sort of "main" run function where you can configure inputs and outputs of the whole program. The only real difference (i can spot) is Elm requires you to explicitly define a model, which seems to be akin to Redux's collection of reduce functions, and also ultimately representative of a "single state atom." As I recall, you can optionally do that sorta setup with Cycle as well. **Cycle seems to be more fluid (in how every thing seems to go around in a perfect cycle), yet more verbose; while Elm seems to have the absolute minimal amount of code required to declaratively define a reactive UI, but feels awkward in a few areas to accomplish that.** Another discussion question: what's the exact list of differences between Elm and Cycle besides that they are in different languages??
Just out of curiosity, what benefits are there in taking advantage of JavaScript's hoisting behaviour? Is it presented more for the purpose of teaching about scope or does one find it a lot in production-level code? I am new to JavaScript so I am not sure if it is standard practice to declare variables in such manner.
so basically [requiredir](https://www.npmjs.com/package/requiredir) but in a roundabout way
[does this work?](http://codepen.io/anon/pen/jWBvZV)
If painting were disabled how would the user know they were scrolling?
Agreed, I can modify my original code example so that it has a name. It is still a declaration though.
The name can be omitted. Therefore it's evidentially a function expression.
&gt; Explain just how insecure it is to not upgrade. It's not necessarily the *risk* of cost of insecurity. It's the very real cost of testing internal tools on newer versions. The larger the corporation, and the higher dependency on their enterprise web software, the larger the need to ensure their custom software will not fall over and die.
Sounds like it disables changing the DOM, not painting. Like I said, if the browser was no longer painting then the user wouldn't be able to see the content scrolling. [See this comment from that article](http://developer.telerik.com/featured/scroll-event-change-ios-8-big-deal/#comment-1606305524): &gt; Technically speaking, I would even argue that the painting is not paused. This is only the effect we observe. What is likely going on is the decoupling of painting via the backing store. The web page is painted to an offscreen buffer (usually tiled as GPU texture) and the browser manipulates the buffer according to user interaction (scrolling, but also zooming).
I recommend to not modify any of the built-ins unless you're polyfilling a *standardized* feature. https://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/
Remember when they said IE8 was going to be the Chrome/Firefox killer? I remember when they said that about IE7.
I don't think you're really grasping the issue here. It's not about encouraging the *users* to change, it's their IT departments that have to allow the change. In some places, a user can get fired for installing an unauthorized program on a company computer. It's IT who determines what's authorized and not. 
IE12 is called "Edge". You can put lipstick on a pig, as they say.
No, but *this* time Edge will really take care of it /s
...which is absolutely great news for our team given that we just spent 3 weeks writing 250K of code on top of patched babylon. So the only options for us now are to either lock in package versions or fork Babel altogether. Wonder which option is more "responsible" and less "evil". I understand the "someone might make something popular and we'd have to support it" reasoning. But the way around it is to define a proper API, not close the only way the parser can currently be extended.
There is no "auto" in corporate environments. Which this discussion is about. Have you ever had to deal with a very big company's IT policies? They could not care less what the consumer world outside their walls does. All they care about is *their* internal network and their numerous Intranet applications.
Cycle author here. For that reason, of course I resonate with your propositions, but I'll stick to pointing out only technical differences. Read http://staltz.com/unidirectional-user-interface-architectures.html for a comparison between Flux, Redux, Elm arch, Cycle, and BEST (Famous). And a bit more information that the article above doesn't mention: Elm and Cycle are similar, but still have important facts: - Elm has only first-order Signals, Cycle which uses RxJS supports higher-order Observables (meaning: Observable of Observables). - Elm ports and Cycle drivers are essentially the same concept. - Elm Arch utilizes Signals at the extremes (for input and for output), but not that much in between. Cycle.js uses Signals/Observables at the extremes but also in between, extensively. - Elm follows the React way when it comes to event handlers: they are specified and attached to the virtual DOM element. In Cycle.js, the virtual DOM elements we create in the app never have event handlers attached to them. This gives a clear separation of what exits the system (HTML without event handlers) and what enters the system (events through an event delegation system). In Elm and React, what exits the system is a data structure that has callbacks to return to the system. To compliment some points you mentioned: indeed React is only "reactive" with regard to rendering. Render happens when state or props changes. Other parts are not reactive. In Redux and Flux, the Store however is "observable" by components. And the Dispatcher is observable by the Store. React is in fact clearly multiparadigm: it uses OOP as a the main building block (for components), uses reactive pattern for its advertised "one-way data flow" from state to rendering, uses functional pattern with regard to "UI as a pure function of state". It is not properly seeking to be functional because it does not make effects explicit and push effects to the boundary of the application. They may be spread out in the application and there is no prescribed interface for effects. (Both Elm and Cycle have prescribed interfaces for effects: ports/drivers. Elm is strict about purity, Cycle cannot be because it is JavaScript, so purity is a matter of discipline). Conclusion: I disagree with your claim that React is plain FP. It's not. &gt; Discussion point: why are we not aiming to using a true FRP approach? Beats me. React's multiparadigm confusion plus its almost unanimous praise really intrigues me.
Sure, but I'm not talking about 'corporate IT'. I'm talking about corporate *IS*, primarily BI, software development, and QA, and the world of business users around them.
Corporate system admin is all about keeping the old apps last decade's hipsters wrote with activeX/java/flash working. It costs a lot of money to have those apps rewritten to a new language and the business doesn't get a lot of (visible) return.
Yeah, that's not going to meant shit at work. I'll still support 8 because our dense clients have equally dense customers who use 8. No one decides when IE dies.
Did you forget?
Maybe, but this is the first time I'm aware of where they put nag screens in the dead product when they close the door on it. (Assuming the final update is allowed to take place)
Yep! Here it is formatted: http://codepen.io/anon/pen/PZpyjW I'll take a look later if I have some time and if someone hasn't helped you out already...
&gt; My React app/React component/regular JavaScript npm module dev, build and test setup That's pretty great. Nice work!
Could people here also comment on http://buytaert.net/selecting-a-client-side-framework-for-drupal ? That would be most welcome: your insights are very much needed. Thank you!
Pass some Microsoft Cert tests. Have a bachelor's degree. Get lucky. 
"Internet Explorer 8, 9 and 10 die on Tuesday" hahaha...no. It just becomes unsupported. It's not gonna die anytime soon.
You are a true pioneer in this field. If you have any spare time, perhaps during a prolonged smoke break, I would love to hear more.
Again, since the name can be omitted, it must be an expression. if(function(){}) { console.log('ohai'); } That isn't a function declaration either. Maybe you should have actually read /u/rauschma's blog post. *An expression produces a value and can be written wherever a value is expected, for example as an argument in a function call.* That's what it's saying right at the beginning. A function call expects 0+ values. That's why you can use a function expression there. A statement won't fly. You can't put an `if` there.
The only thing I want "so badly" is that they don't put fucking **artificial** barriers for people who want to build upon their work.
The very best IT guys are the ones who look like they don't do anything If the IT guys are always hair on fire busy, they're bad at their jobs, or good at politics
i've been trying to do exactly what you suggest in my recent projects and your birthday example actually illuminated something that i have been fighting with. i'm having this exact problem in my pure frp/stream solutions that it would be nice to know the age at an exact moment in time instead of relying on deriving it from the birthdays. maybe i just haven't spent enough time with these relatively new tools but i just feel lost sometimes in my supposedly elegant signal graphs.
&gt; Sounds like some IDE intellisense nonsense. That might be helpful in the IDE environment, but it adds a bunch of trash to the code in the mean time. Today I learned vim is an IDE. If your editor of choice can't even autocomplete method names, you may want to stop using Notepad.exe.
I found out the problem, I used scr instead of src ._. Thanks for the help though :D
I would probably be using Edge if it weren't for the godawful tooltips and menus. Chrome and Firefox run like shit these days.
Microsoft Windows Embedded POSReady 2009 will be supported until April 9, 2019. It runs IE 8. https://support.microsoft.com/en-us/gp/lifewinembed
Edge is Win X only. Not every1's gonna get the "free" upgrade offer for some adware spy OS!
I'm always ready to believe, and equally willing to be disappointed 
Definitely. As I said, Elm is awesome. Part of the reason I hesitated on getting into Cycle or RxJS more is that I found even super well designed JS libraries still need to deal with JS...in a sense you're fighting a tough battle. For example, to "mimic" Elm, you COULD go with a wild stack like Redux + React + BaconJS + Typescript + ImmutableJS + Flow blah blah...but why bother when Elm already has it all? May as well go with a language that puts these concepts first rather than forcing a language to try and conform to them. If you have to use JS, definitely go Cycle or something like that, but like I said it just makes things harder. Even Andre Staltz above mentions that: &gt;Cycle cannot be (strict about purity) because it is JavaScript, so purity is a matter of discipline.
Now I can use flexbox everywhere yeeeey XD
Current Edge already trails Chrome and Firefox. Future Edge still trails Chrome and Firefox. http://html5test.com/results/desktop.html If you are having problems with Chrome and Firefox, fix your system. It's not them.
Thanks for the overview, within this entire thread, I have several hours of reading to do. I'll have start a project in both elm and cycle.js to get more insight though I feel.
Can ie11 run on Windows 7?
Yes. IE11 is also the last version for Win 8.1 as well. Edge demands the Win 10 "free" OS. 
Let's say you have a span in a link, how do you prevent even.target from returning the child-span instead of the link?
Compared to firefox and chrome it has been in development for a hugely shorter period of time. Considering that the score is impressive
I have not figured out a good use for this yet but this is sic. Nice work!
Could you explain more how you see the differences between Elm's signals and observable a in Cycle? It seems you're saying that Elm's signals and it's dataflow make them nothing more than glorified events, almost like what you see in React, but feeling slightly more "primitivey." 
You could use Element.closest to figure out if the target is inside the kind of element you're looking for or if target is that element itself. The current support isn't that great though. IE/Edge doesn't even support some prefixed version: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest http://caniuse.com/#feat=element-closest Well, if it's just one level you can of course also just test target's parentNode.
Edge was also just released...
It's a really slick browser... They totally redid it from the ground up. It's not as bloated as Chrome, and(I grit my teeth when I say this) Firefox... We'll see how long it lasts
And it is faster than both browsers... I really wish Firefox would turn it around. Firefox has gotten bloated as hell.
Anytime!
Yes, that works, but it messes up the logic of displaying the name of the colors at the bottom... Any ideas?
I made something just now, which borrows ideas from yours: https://jsfiddle.net/SeanJM/azLrmzos/ // t('$1 is totally calm, and $ is also a $', 'Democratica', 'man'); // -&gt; 'Democratica is totaly calm, and Democratica is also a man' function t(string) { var args = [].slice.call(arguments, 1); var i = 0; return string.replace(/(?:\$([0-9]+)|\$)/g, function (a, b) { if (b) { return args[Number(b) - 1]; } i += 1; return args[i - 1]; }); }
He's not referring to how well they handle HTML5. Seriously, just slapping the same response at people sucks.
That's all well and good, but Edge is only supported on Windows 10. Good luck getting the world to upgrade their OSes to use a Microsoft browser. 
We only target evergreen browsers. Much easier this way. 
You saw the example? How it can be better and productive? Or you usually comment on things without seeing before?
([mobservable](https://mweststrate.github.io/mobservable) author here) Within FRP two main streams can be distinguished: discrete and continues FRP. The common ground is that all FRP works with the concept of observability which enables reacting to change automatically. In other words, FRP establishes inversion of control. This is also the reason that you cannot call React in itself reactive; there is simply no inversion of control. Developers have to push changes through the system themselves by using setState. The difference between discrete (RxJs / bacon) and continues (Knockout, tracker, mobservable) FRP boils down to the question: what are you reacting to? State (continues) or events (discrete)? The most famous example of continues FRP is Excel; formulas are derived from the values in data cells (and not from the events that happen, although ultimately it are usually events that alter the data cells) Which approach will be the most convenient depends on the kind of problem you want to solve. Is time / the past a factor in the derivations? Use discrete FRP (examples: throttling network traffic, taking the average value of the last three seen values). Is time not a factor but can everything derived from the 'latest' value; use continues FRP. In my experience for 90% of the problems continues suffices and is easier to maintain. For the other 10% Rx is a powerhouse. Continues FRP is imho a bit easier to write, grasp and maintain because 'Transparency' can be applied: establish the signals / observer relationships that are needed to keep everything reactive on the fly. The earlier mouse example could look like this in Mobservable: // state: const state = observable({ mouseX: 0, mouseY: 0, }); const edgeLength = observable(() =&gt; Math.max(state.mouseX, state.mouseY)) const resizableYogi = observable(() =&gt; image(edgeLength(), edgeLength(), "imgs/yogi.jpg")) Now assuming that there is a DOM event that updates the mouse coords; the interesting thing is that in contrast to discrete FRP, in continues FRP not every mouse event will recalc the `resizableYogi`. Only an actual coordinate value change will trigger `edgeLength` to recompute, and only when the output of `edgeLength` changes, `resizableYogi` will recompute. 
Once XUL goes away, Electrolysis can land and that will help. Also hopefully some servo components help as well.
That fucking browser will zombie-walk for another decade.
heya, fix and comments here (from JS line 14): http://codepen.io/kav/pen/adJPPa
Absolutely false! Edge has **the same** rendering engine IE has, a fork, only the legacy code has been removed. New stuff in Edge is the same new stuff IE12 would have gotten. Don't go believing Edge is new under the hood! 
As I always say to anyone who says something is bloated. You don't know what the term means and you don't know how to measure that. And if you think Firefox is bloated, you show you are clueless as to how browsers handle cache. If you think Firefox is slow, you need to fix your machine. (And I've been telling people that for almost 10 years when I first heard someone say that online.)
He's responding to crow1170 who, facetiously, claims Edge will beat Chrome and Firefox. He says he won't because of the UI which leaves ... what? I know, I know. Throwing facts at a redditor just makes them blind crazy.
Hey Michel, good to see you again. Sorry I never responded in the Meteor forums--I just didn't have the answers (and still dont). I've spent the last few weeks trying to get to the bottom of this. I still can't get over the fact that "Transparency" comes at the cost of "side effects." For anyone who doesn't know what we're talking about, the idea is that Meteor's Tracker+Blaze libraries and Mobservable used within React allow you to use any "reactive datasource" within functions used by your components and when they trigger updates (because their data has changed) they tell React or Blaze to re-render the view instance; these observable data sources don't need to be passed in as arguments, they simply need to be used within the function, which makes the function the total opposite of pure. That means it's inputs aren't easily testable, etc. In addition, in the "continuous FRP" example you give, it's just an ad hoc one off example--so of course it doesn't recalculate all the code. To compare "apples to apples" it must first be put in a complete rendering framework, such as React. So yes there, as we both know, we can render only the branch that has changed using `forceUpdate()` but it's thanks to React that only a portion recalculates, not solely to using a "Transparent Observable." On a side note, I'm not sure you're definition of "continuous" vs "discrete" is complete. By definition, a computer is "discrete." Something continuous only occurs in theoretical mathematics or real life. But I do hear what you're saying about the fact that Transparent Reactive Programming doesn't allow for essentially the `scan` function that Rx has. I.e. accumulated reduce over time. That's another interesting characteristic/difference that I'm glad you pointed out. All on all, the TRP approach--while definitely great for beginner to intermediate developers and smaller projects--I'm worried about when it comes to bigger projects. The reason is it needs a host framework, and when you pair it with the host language it doesn't become a first class citizen of its architecture like it does with Cycle or Elm. As we saw with React and Mobservable (or Blaze + Tracker) you pair the two by somewhat of a hack, i.e. using `forceUpdate()` in React's case. This is as opposed to Cycle where streams are a first class citizen of the architecture, quite literally comparing one part to the next (e.g. Model to View, View to Intent, Intent to Model, etc). Mobservable on the other hand just shouts out orders to various React component instances to re-render themselves. It's loosely connected and "ad hoc." In addition, traditional argument passing is not used, so it's hard to test. As apps grow, it's hard to know what's going on. Instead of there being one continuous flow for your entire application whose stack trace you can track, you end up with many disconnected flows that re-run themselves whenever they want. You and I both know these tradeoffs. I've been a long time supporter of Tracker, as you know. I'm just saying if you can't test its inputs, if it's non-deterministic, if it not just has side effects but is based on side effects, how can we reliably test this architecture?? You can't without lots of fixtures and spying. Whereas pure functional approaches are the epitome of painless to test. My real question is--since I love TRP--how can we solve this problem? How can we make TRP pure?????? And in addition, what does Elm do to make their signals pure? You can use UI input signals wherever you want to use them just like any other immutable value--does that mean Elm can use reactive datasources the same way as signals?? It seems maybe we can learn something from Elm. I think TRP has to evolve on more step before I can comfortable continue to advocate for it. It may not even be able to do that, but if we can solve the purity issue, TRP may in fact be a best-in-class solution. If not, it's not a solution at all for professional applications (in my opinion--and you're talking to someone who's built like 10 major applications on Meteor and used exclusively Meteor for the past 3 years; yes, it's a tough pill for me to swallow, but I'm prepared to swallow it; the point is: I'm the opposite of someone who would easily disregard TRP). Another thought: Michel, it might also come down to *marketing value*. What I mean by that is this: ad-hoc re-renderings of component instances is not a fancy sellable story. Unidirectional data-flow and fractal-conducive cycles and all the other architectures Andre discusses here http://staltz.com/unidirectional-user-interface-architectures.html are. TRP has no good story. It sounds like a mess. Like a bunch of random spider webs spread throughout your application. You and me should come up with something that really makes TRP shine. It doesn't currently shine. It doesn't shine as just a mixin or higher order component within React. It likely needs its own framework. Perhaps one that renders to React (like Cycle is capable of). But it needs something that makes it testable. A framework that makes its data-flow story solid while also making it highly testable and less ad hoc. See what I'm saying. Without that, I think TRP isn't going to rise in popularity. U and me both likely have huge apps based on TRP. So it's hard for us to let go. But we are also the best ones to re-imagine TRP, taking its best parts, and fixing it's longstanding problems. Perhaps we can't fix its ad hoc nature (and rather, it is its best feauture!), but at the very least we need to solve the purity issue. We really do. From solely a marketing standpoint, there's no way we will survive in the current functional marketing climate. Developers aren't gonna wanna hear our side-effect-laden story. I've witnessed this all first hand in the Meteor community where all the forward thinking developers who switched to React are sick and tired of Tracker's slightly unpredictable ad hoc nature. Fixing its unpredictability--i.e. unnecessary function re-runs--won't solve the problem. It's a given that it must be solved. But once it's solved, we need to solve purity. Generally speaking, my idea is to push reactive data sources to the "edges" somehow, and box in the side-effect. Similar to how Redux's middleware addresses side effects related to promises etc in action creators. In short, functions that use reactive data sources need to maintain their testability and deterministic behavior under testing circumstances, even if they are using reactive datasources which alter their output!
Dude... brilliant! Thank you!!
Then you don't know the definition of "new". You are also stating they "refactored" but no one said any such thing. In fact, no, they didn't. As I said, it's IE's Trident engine with the old cruft removed. No one said anything about it being rewritten in any way, shape, or form.
&gt; Chrome and Firefox run like shit these days. Performance. It leaves performance. He would probably switch to Edge because Firefox and Chrome keep becoming worse and worse performance wise, but the Edge browser UI still has some issues. EDIT: And yeah, throwing facts at people can suck, especially when they're not even relevant to this part of the discussion.
I frequently find FF is using 800 or 900 MB of ram. That's a huge memory hog. One reason people call it bloated. 
A program which accepts user inputs on ideas for further JS programs. 
My understanding is that it is a fork, not a rewrite.
The government department I contact for is stuck supporting this piece of shit until 2017. Sigh.
And if nothing on the web works because they refuse to upgrade, boohoo on them.
When your html is entirely generated by js then the there is no longer a reason to separate them.
This. Java, Scala and TypeScript guys just don't understand JavaScript
A lot of corporate IS doesn't know shit about anything either and stagnates the software devs
the bit about callstacks for function expressions is horribly outdated. afaik all modern browsers will show the variable name in the stack.
Hopefully, this will mean the number of users using IE9 will soon plummet below the number of users with disabilities, just like the number of IE8 did. That's a fantastic argument for your employer to both focus on accessibility more and on old browsers less.
The problem with all these examples is that they are so trivial as to be completely useless. I'd love to see an example of a multipage app w/ authentication using cycle, because that's where I have a hard time understanding how to structure my code to use entirely FRP concepts. Can you make easily composable view components? Do I have to write everything from scratch or can I use off the shelf components from a library?
It is not true that ``let`` and ``const`` declared variables are not hoisted in ES6, they are hoisted. However reference of the variable before its declaration will result in a ReferenceError, the variable is in the "temporal dead zone". MDN has a good [article](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let) on ``let`` and ``const`` defined variables and the temporal dead zone.
The main problem with building anything complex with FRP is the Event Soup Anti-Pattern. Where a developers writes some code that triggers an event in a part of the application, and that event then triggers another, which triggers another. All of the sudden you loose the ability to reason easily about the application, and strange bugs start appearing. I saw several applications that where based on the Observable pattern using event bus libraries that you put a breakpoint in one place, click something on the GUI and the method is just run 3 times instead of one due to this carousel of events. It gets out of hand really fast. Its a disavantage of FRP is that it encourages this kind of thing. Its hard to reason about the app because of this loops and cycles in the logic that are not visible in code. I think the first 15 minutes of this talk explain why unidirectional data flow is important https://facebook.github.io/flux/docs/overview.html If you want to use FRP in a UI, you need to make sure that when triggering one observable you let the app react to the new value, but don't let it trigger more observables before giving control back to the browser. Edit: I forgot to add, Flux prevents event soup by making sure that an action cannot be dispatched while another action is still ongoing dispatch. See for example the Redux source, an error is thrown
Crazy to think that's only a year away though.
That's a pity. I was hoping for something like classList, but the then an event nodelist for every clicked element (based on axis). That would allow you to say if (event.targetList.has(element)) justDoIt(); Thanks for the answer nonetheless. I'll have a look.
Closest: https://jsfiddle.net/pmom5gdg/3/ Using matches and a loop to emulate closest: https://jsfiddle.net/pmom5gdg/4/
The information on both the GitHub, and website landing page are lots of things, but easy is not one of them. In fact, it is basically nothing - both do a terrible job at conveying a problem, solution, and some practical examples (that say *easy*). Really all I get is buzz and a signup form.
What's wrong with an array join()? ["join", this, "string"].join().
Isn't Edge essentially IE12?
Even if they were not supported anymore this doesn't really make things easier for a lot of us. Regardless of what Microsoft says it supports, if your userbase has enough IE8 users, you will have to support it.
What's going mainstream is writing things in a functional style when it's convenient. And the same goes for classes. Instead of sticking everything into some class as you have to do with Java, you only do it when it makes sense. It's the best of both worlds, really.
Yea my conclusions have been the same about Om Next and Datomic. Om Next seems to already have gotten right what relay and GraphQL is working toward: multiple synchronization sources, client side synchronization source capability, time traveling, no need for redux anymore since it basically serves the role of both redux and relay, an subscriptions. David Nolen in one of his videos says Om Next supports subscriptions but doesn't go into detail. Do you know if this true and if it's supported already? In short it seems like Om Next has accomplished the "observables all the way down" concept, popularized in the "turning the database inside out" video. So maybe the rest of the industry hasn't figured out asynchronous http requests, but clojurescript and seems to have figured it out. The one thing I'm wondering about with both relay and Om next is how do U perform other routines when you are performing mutations, perhaps send an email out. My sense is activities unrelated to server side state need to be addressed to, and not as a separate asynch request. It may need the result of the mutation or the prevState or both, or may need to perform some additional logic before the query is made, and generally shouldn't happen via an additional request. Ps. I love Elmish. I just finally gave it a look after seeing how nicely the code in ur comment here crossed the chasm between everything currently going in the functional reactive programming world. I think a lot of people, myself included, consider Cycle the closest thing in JS, but thanks to this thread I see the differences now. My question for u is have u reviewed the link above by @staltz comparing the different architectures with various diagrams? In it he goes to great lengths to make the point that elm and cycle have a fractal nature whereas react and redux basically don't. Does your version of Elm in JavaScript maintain that fractal nature?
But installed on 200 million computers. Out of an estimate 2 billion. Aka. 1 in 10.
Get a life and start doing real-world things. The more you do and the more varied the things you do are the more ideas you will get and the more useful they will become. Or you can remain fixated on "Javascript" and "must...write...code!" and write the 1 billionths utterly useless and forgettable piece of code. It's like a guy in 11th century England running around with his new shiny hammer - "What do I do with it? Give me something to hammer!". That's how the famous hammer-war started in 1148 CE, with thousands killed within just the first week. You could just write the millionth node.js chat server though. Of course, the *actual* problem of chat isn't the software you chat with but what to chat about - 99.999% of all humans in chat haven't figured this out yet. "Finding meaning" is by far the biggest problem in the live's of humans it seems. Here's some "real" suggestions: - You *could* write a decent frontend for edX.org discussions. Their's is notoriously BAD, and the edX platform is used by millions. - Since we are on reddit, you could write all kinds of helpers, for example an machine-learning based tool that filters annoying messages from one's reddit Inbox. You can learn the machine-learning algorithms on Coursera and edX. - You could write a browser extension that provides realtime chat for people watching the same reddit topic, the role of the extension merely is to load the browser JS files because reddit of course doesn't. - You could write a tool - a website, possibly - that manages online courses. Coursera's course overview page is okay, but edX's course overview is positively HORRIBLE. And edX is a *huge* platform, maybe the biggest learning platform of them all. Actually, when I think about it, yet another website may not be the best solution, maybe just a Tampermonkey/Greasemonkey script for the edX dashboard page. - Using the new HTML5 audio API: Write software for learning an instrument, the violin for example: Connect with websites that provide (machine readable) sheet music, display the sheet music and listen on the mic for how the learner plays. Display any discrepancies in timing and frequency - you will get RICH if you write a working good piece of software that does this! You'll also learn a lot about signal processing (here again edX and Coursera have great courses for the theoretical and mathematical basics), because the raw audio signal from the microphone is not really directly usable. For using the audio API from Javascript there's a W3C course on edX that does a good job. That's what I meant at the beginning, if you start doing stuff you'll find plenty of things to improve! Simply by heavily using reddit and online courses and learning to play the violin I could go on and on about things to write code for because I notice so many shortcomings. 
jQuery generally uses CSS selectors to target elements; the square brackets are just a CSS selector that select for the named attribute. `a[href="#sometab"]` just means "any `&lt;a&gt;` whose `href` attribute is *exactly* "`#sometab`". (So it wouldn't match "`http://www.reddit.com/#sometab`", for instance.) You can select for any attribute with square brackets, so you could do, for example, `input[type="radio"]` or `table[border=0]`. And there's [a variety of syntaces *within* the brackets](http://code.tutsplus.com/tutorials/the-30-css-selectors-you-must-memorize--net-16048), but the default is a full, exact match.
I think that this is a really good point. To take it a step further:[redux-thunk](https://github.com/gaearon/redux-thunk) is pretty much essential if you want to introduce async stuff to Redux, but it seems like a quantum leap from Redux as-is, in terms of both complexity and potential for disaster.
Hi /u/icemelt7, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Dammit :(
http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/
You no longer need a middleware to handle async in Redux. See: http://stackoverflow.com/q/34570758/339827
There's a new method: `view.render()` which will output HTML. `frzr.server` will also return `true` if your code is running on server.
https://github.com/shri3k/funxtion/blob/master/index.js Basically let's you invoke individual functions in a file from cli. I made this when I was playing with proxies when it was still early. My code isn't the prettiest or follows best practice so don't try to emulate anything that I do but this is also just another example what proxies can do. 
There are a lot of problems with this approach. - This isn't using watchify, so the rebuilds are slow. - When you switch to watchify, you will start to get stale/empty bundles on reload, unless you tie the dev server to the watchify requests - The local server should just use another npm tool, like `http-server`, so that the user doesn't need any additional global dependencies - There is no build error handling; it just shows up in your terminal and causes frustration if you happen to miss it - There is no LiveReload integration, you have to manually refresh your browser Honestly I wish gulp + browserify recipes would die. They usually lead to a terrible development experience, giving people the impression that browserify is slow and complex to set up. In 95% of cases you just want a fast development server like [budo](https://github.com/mattdesl/budo), and in the other 5% of cases you are probably better off setting up your own incremental dev server with [watchify-request](https://www.npmjs.com/package/watchify-request) or [watchify-middleware](https://www.npmjs.com/package/watchify-middleware). Here is a small and simple example which covers the above points and also includes `uglifyjs`: https://github.com/mattdesl/browserify-example/ EDIT: Here is a more advanced example which can produce optimized bundles with dead code elimination. https://gist.github.com/mattdesl/57825db09d5193916cb3
Yep, and we also have this problem of `&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8" /&gt;`
This is either wrong or you are referring to "FRP" as something else or the use case of Observables you saw was a flawed one. RxJS is meant to solve precisely all of these problems that you've mentioned. &gt; Where a developers writes some code that triggers an event in a part of the application, and that event then triggers another, which triggers another. With the reactive pattern (either in FRP or in RxJS Observables), each event stream declares when it is triggered. So it's a declarative approach, you never have magic going on where you are afraid of changing something because it's unknown what will happen. Reactive makes event dependencies explicit. This is the whole point of reactive in the first place. Read more http://cycle.js.org/observables.html#reactive-programming about `A --&gt;B` versus `A--&gt; B`. &gt; I saw several applications that where based on the Observable pattern using event bus libraries First of all RxJS Observables are not event buses. RxJS Subjects are event buses, and these are known to be frowned upon, people are supposed to avoid using them. Second, **Flux's Dispatcher is an Event Bus**, so whatever disadvantages you attribute to event buses apply to Flux. Read more http://staltz.com/nothing-new-in-react-and-flux-except-one-thing.html &gt; If you want to use FRP in a UI, you need to make sure that when triggering one observable you let the app react to the new value, but don't let it trigger more observables before giving control back to the browser. If you have such a "hidden" dependency or race condition, you can easily fix such issue by making the race condition or dependency explicit: make appReactionObservable depend on firstObservable and then controlBackToTheBrowserObservable depend on appReactionObservable. The point being: RxJS **excels** at solving precisely these types of bugs. I've been using RxJS and RxJava for 2 years, and taught several developers how to solve precisely these problems elegantly and with few lines of code with RxJS. I'm sorry but you couldn't be more wrong on this one, RxJS's strongest benefit is really solving event soup elegantly, where callbacks or event bus-based architectures like Flux fail.
Dude... thank you for asking this! By looking at the thread on /r/learnprogramming, I learned! I love starting the day feeling like I learned something new. The POWAAA!!! :) function Animal(legs, eyes) { this.legs = legs; this.eyes = eyes; } function Cat(tailLength, furColour) { this.tailLength = tailLength; this.furColour = furColour; Animal.call(this, 4, 2); } var felix = new Cat("32in", "orange"); console.log(felix.tailLength); //32in console.log(felix.furColour); //orange console.log(felix.eyes); //2 console.log(felix.legs); //4
Much less extensible than what I did. You can only replace linearly ('Hello', ' ,' , 'world!'), and with a set # of entries. Here, you can replace 100 '{}' with 1 string. 
&gt; Flux's Dispatcher is an Event Bus, so whatever disadvantages you attribute to event buses apply to Flux. Its an event bus with one very important feature: when an action is being dispatched, if another action is accidentally dispatched (while the first is still ongoing) then an error is throw. See for example the redux implementation of this -&gt; https://github.com/rackt/redux/blob/master/src/createStore.js#L116 This simple but fundamental feature prevents event soup scenarios. &gt; RxJS Subjects are event buses, and these are known to be frowned upon, people are supposed to avoid using them. That makes sense. So if an Angular 2 app is heavily reliant on Subject it will be a mine field of event soup opportunities, right? Where did you hear this that Subject is best avoided? makes sense I just never heard it. Subject is usually one of the first things that tutorials about RxJs show. Many angular 2 examples show it. &gt; The point being: RxJS excels at solving precisely these types of bugs If it has Subject and people use it a lot its all down the drain. Someone subscribes to an observable with UI data, and on the reaction chain it triggers another observable causing an unintended chain of events. My objection is not against RxJs in particular but against event buses in general. If what you are saying is true I wish they took Subject out to a separate lib. Based on what you say, Subject is actually an FRP anti-pattern. And its one of the most visible parts of RxJs. Do you agree, whats your take on this? 
Good point, thanks.
Called it format since I based it off of what I was missing from Rust: https://doc.rust-lang.org/std/macro.format!.html
No problems mate :)
Nope, in Chrome and FF there are errors :-/
In my company, IE8 is still the standard browser. I'm not joking.
Crap, there was an issue with `global` and `rollup` – should work now! I have client-side tests running in `electron` which seems to support `global` as well, so the issue didn't break any tests..
&gt; You could write a browser extension that provides realtime chat for people watching the same reddit topic, the role of the extension merely is to load the browser JS files because reddit of course doesn't I like this idea anybody wants to explore that together?
And, I say again, you, too, are clueless about cache, and how computer programs work. 
What exactly does watchify offer above 'watching' files? I am not too familiar with it but I thought it was a replacement for the gulp watch task. How much faster are rebuilds? Right now I see it takes 38ms to build the example on the link. Yes I know there's integrated npm tools for local servers. The users can actually just navigate to the file in the browser if they want in this case. I just gave them an alternative. What do you mean with build error handling? I use ".on('error',gutil.log)" which tells me when there's an error on the build process. No, there is no livereload, I know. I opted out of using it in this post, as well as uglify. Didn't want to extend it too much, but I can mention those tools so readers are aware of their existence. I'll take a look at your example. Thanks a lot for your feedback! 
I'm a curmudgeon. Clickbait works. I would have liked: &gt; Sebastian McKenzie (of 6to5/Babel fame) reviews his 2015
First of all, sorry for the spam, but I just launched a tool that might be useful for your software projects! Hacksboard is a tool that lets you keep track of the PR of your projects in a stack-like way. I developed it for my own development team and we found it so useful that we decided to publish it as a service. We're are on beta stage so we're searching for people to try the app and give us feedback about it. Thank you very much!
So very kind of you. Thanks!
Yup. This Would be awesome. 
Why reinvent the wheel if there's already libraries that do it for you? Seems like wasted time to me, as long as you understand what's being done with each library and why you need it.
I would love to help answer any questions you may have. If you're not a developer, or new to JavaScript or RESTful APIs you will need to learn these concepts first. But once you do, and log in to your Cosmic JS account, you'll find it to be extremely intuitive in the CMS admin area and really easy to get content to your application. Let me know if you have any more questions. - Tony https://cosmicjs.com
The previous article introducing subclass factory mixins with class expressions, was discussed on r/javascript here: https://www.reddit.com/r/javascript/comments/3xqmgy/real_mixins_with_javascript_classes/
does anybody know if typescript supports this?
I see what you mean. I do this for a living though, 8 hrs a day, 5 days a week. Believe me I have time to look at frameworks and weigh their benefits.
Thanks so much for the reply. I'm sorry if i was a bit vague, what I'm doing is writing down, in a hidden label, a web address and a description, say "google.com,google is a website:". So, there will be several lines of text, each with a comma, and a semicolon. A parser takes all the lines of text in that label, makes it an array, then separates the web address and the text description looking for the semicolon, parsing that entire line out, then separating the web address from the description. Using set attribute, it then makes a listItem and an a href with that information, and loops through the entire array until everything is parsed. I did this so my actual HTML wouldn't have hundreds of links in the code, and in order to update the list of links, I can just go to the HTML, write in plain text the new info, and when the page loads, the links are updated without need to physically code UL's, LI's, or A HREF's My problem is now that I'm trying to make the generated links call a function that loads an image into a content div. Therefore, I had my function loadPage(imagename), which should get, for example, imageOne.png passed to it. I seem to be stuck on using setAttribute to set the listItem as both a link, AND as a link that can pass the particular image to loadImage function. Here's the full [parser code](https://jsfiddle.net/aofkhtvz/) if you're curious.
Thanks for this!
Hey, look at this guy, he can afford not to care about 20% of the internet. It depends on the project, my last place we had this luxury, my new place, we have to support back to IE9 due to the user base.
I still recommend to use event delegation for this. Did you take a look at the examples I posted here?
Yeah. That example snippet was so unreadable, it hurts
I love MathJax and have used it in previous projects. Definitely an awesome, well maintained library, but it doesn't seem to have a live equation editor yet. Thanks for the reply though.
Hi /u/arolitus, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/romainlanz, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I thought your comment was a joke until I looked it up. Ok, first I've heard of brunch...
Uh oh! I'm very sorry for that. I'm interested on showing off the project in a technical view as well. Is there a chance for me to write a technical review and architectural decisions and re-post it again? Sincerely, I'm not interested in promoting and earn money on that, but more about getting feedback of other developers. Thank you, and sorry for any inconvenience caused. :)
I'm game. Send me a message 
At it's core isn't functional inheritance still prototypical inheritence? you're just returning the prototype as an object, whose prototype is Function.prototype. Also great link. edit: reworded original post to reflect what I meant.
Not me either ;) Thanks!
It's been around for a long time but is not as popular as Grunt/Gulp. I had been using webpack until I started playing with the Elixir language and its popular web framework [Phoenix](http://www.phoenixframework.org), which happens to include brunch as its build system and it brought back some memories and has me considering using more often.
Just to recap on some terms: * statement - an action to perform * expression - a statement that expects a value * invocation - a point of reference creation * declaration - an invocation where scope is applied Examples of where invocations are not declarations are rare, but include things like object properties. You have repeatedly claimed that a function without a name must be an expression, except that is not the definition of expression. A function must have a reference, but that reference does not have to be a name and the absence of a name or *BindingIdentifier* does not imply either a statement or expression. In the case of function arguments the reference could be something implied such as the legacy *arguments* as is used with Node style callbacks. The *FormalParameters* section specified by the spec does not describe function arguments. It describes the section of the function containing function arguments. The actual arguments are described in the spec as *ParameterList*. This is a declaration point. References can be invoked in that section, which is to say a new reference name/object can be stated for use later. Scope is attached such that any reference/object invoked there is scoped to the function body. Since scope is applied the invocation is a declaration. This part of the spec describes the behavior explicitly: http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-runtime-semantics-iteratorbindinginitialization See the bottom section of 14.1.18 about *BindingElement* where invocation and scope and formally described for items of the *FormalParameter* section. The reason why most function declarations require a name has nothing to do with whether a function is an expression or a declaration. It only has to do with its internal *call* method: http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist A function requires a point of reference. This point of reference is used to populate an internal *call* method on all functions except constructors. That point of reference could be an assigned reference, a formal function name, a *thisArgument* value, the arguments object of a function, or other reference point. TypeScript and Java have an additional parameter field that JavaScript does not have called a *TypeParameter*, which is also a declaration point. &gt; The "arg" there is an expression. It's part of the return statement. I previously stated that the return line is a statement and you appear to agree. The only action to occur on that line of the example is from the `return` keyword, so its that keyword alone that elevates the line to a statement. The reference `arg` is not doing anything there and nothing is being done to it. This means there is no additional action to perform than to execute the return. According to the spec: &gt; return [no LineTerminator here] Expression[In, ?Yield] ; The term *Expression* is a placement rather than an individual item, most commonly talked about as *expression position*. A reference can occupy *expression position* without being an expression. The word *Expression* is most appropriate to describe that placement, because formal expressions are in that location. If an expression, and thus an action plus value, were required in *Expression* position this form of `return` (not immediately followed by statement terminator) would be a *return expression* opposed to a *return statement* because the term *statement* in *return statement* refers to the action performed by *return*. **And with these spec references I can safely say a function without a name is in no way associated to whether or not it is a function expression or a function declaration and that references invoked as formal parameters are declarations.**
Dude, thank you times a billion, i think i just got it. Damn, i love it when things click. You rock, appreciate your explanations as well as your time!!! High Five!!!
Ok, thanks kenman, I'll hold off on any more posts about Cosmic JS.
You can enable or disable an input with javascript: .disabled = true; or .disabled = false; You can program things to happen when certain events occur by using `.addEventListener()`. Events: http://www.w3schools.com/jsref/dom_obj_event.asp You can also program things to happen on intervals or after a specified amount of time with `setInterval()` and `setTimeout()`: http://www.w3schools.com/js/js_timing.asp ----- Was this information helpful? Yes [O](https://24hoursbetter.files.wordpress.com/2014/04/youre-welcome.gif) No [O](http://rlv.zcache.com/what_part_dont_you_understand_funny_nerd_math_mug-rb4944a89856d4d658a54d22727502e12_x7j1j_8byvr_512.jpg)
Nope. The blog post explains: &gt; As you can see by using (the functional) pattern, there is no need to use the [prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain), constructors or the “new” keyword. Functional inheritance achieves this by passing a unique object around every time an instance of the function is called. edit: I see what you're implying. To elaborate, when you inherit through prototype, your new instance just *references* the properties of the parent prototype. So if you were to modify the parent prototype during run time (bad idea, generally), the child instance values would also "change". With functional inheritance, you're actually generating entirely new objects in memory that assume no knowledge of each other - which I would argue is much easier to reason about.
class isn't supported by IE though, correct?
All inheritance in JavaScript is done through prototypes, but people new to the language often confuse inheritance and scope. In this language scope and inheritance are separate unrelated qualities. When people say *functional inheritance* they are referring to one of three different things: * prototypal inheritance * object passing, such as currying * scope The code example above for functional inheritance is object passing. A function returns a prepared object. That function is then called when needed as a sort of blueprint of prepared object properties. Scope in JavaScript is challenging for many people new to JavaScript because it is different than more commonly taught languages like Java and C++. JavaScript is purely lexical in its scope model, you have to think in terms of nesting. Consider declaring a function within another function. Here is a brief example: var a = 1, //this is in the global scope b = function () { var c = 2, //this is in the function's scope d = function () { var e = 3; //this is in the child function's scope return e + c; }; }; In the above example there are three scopes: global, parent function, and child function. A lower (more local) scope can access references in a higher (bigger, less local) scope. Look at variable `c`. It is declared in one scope and used in a different scope, which is a closure.
Hi I created Shorti, use it in production and find it makes my life easier and development faster. It saves me time by keeping my CSS writing to a minimum. This is perfect for React, because the components are modular anyway, so why not write inline styles for them? Shorti makes the inline style writing a lot faster and easier. Also as a bonus if you're using ES6, you can use spread operators very easily to change up your styles: import S from 'shorti' let style = { S('font-22 color-ccc') } if (component.is_active) style = { ...style, ...S('color-green') } I'd love to get your feedback. Thanks! Tony
This is a passion project for him and an opportunity for me to flesh out some more concepts. None of us would be making money, it's not that kind of project.
The internal version number of the original release did say 12, but it evolved much faster than IE8-11 did, and the current version of Edge is already 13 (and unlike ye olde IE, there's no good reason to stay on Edge 12).
Arguably yes. But IE has such a bad rap at this point that MS does't want to deal with it. And Edge is supposed to be different because MS wants to roll out incremental updates like Chrome/Firefox rather than these monolithic versions that hang around and need to be supported for years and years and years and prevent us from taking advantage of more modern browsers. Even MS is feeling that pain and it ends up being bad PR because people forced to use old and outdated MS software just come away feeling like MS sucks and seeing how far IE dominance has fallen over the past 10 years MS is keenly aware that IE and their previous IE strategy is a losing proposition. So incremental Edge updates would be good because no one worries about Firefox 10 or Chrome 10 or any specific version for that matter, because nearly all users update. And users who don't are effectively forced to because they're a minority, the web doesn't wait around or cater to them and there's no real good way to isolate versions when the updates are granular and incremental enough. So the best strategy for users to maintain compatibility is to stay updated and developers (even poor ones) stop developing browser specific code because there isn't a specific browser version to target. So the only thing that matters is web standards and then we finally achieve a glorious utopia (I hope). If MS can keep Edge on that sort of cycle then a lot of the pain that exists (will exist) with IE1-11 will go away and there will be much rejoicing. That's the dream anyway.
(^^ reddit noob) thanks senocular 
/u/lewisje pretty much nailed it. Refer to the compat table: http://kangax.github.io/compat-table/es6/ And use Babel or TypeScript in the meantime. I'd go with TS because that also gives you better tooling.
Ahhh that makes a lot more sense! Thank you. I understand now.
Thanks for the detailed response, /u/ultraspacenacho explained exactly what I was mixed up on in his edit.
Thank you! This helped.
* Is the code in an SCM (git, mercurial, etc)? * Does he have any automated testing (unit, functional, behavioral, integration tests), or expect you to do any? * Is this a cowboy project, i.e.: is it just commit &amp; push all day or will it be versioned. If versioned, what scheme (semver, other)? * Elaborate on the front-end work to be done, what exactly is needed? * What does he define as "front-end": all client-side development, or only html &amp; css, with light javascript involvement? * What technologies are used/will be used for your part of the project? Any frameworks? * Has any planning gone into the front-end, what's the architecture like? * What's the purpose of this project? Is it a site for a FOSS project, or is it something that could foreseeably turn into a revenue-generating business? Keep in mind some "free" projects become popular and some people do want to get something in return for their time invested * If it's a business, what will you get out of it for your time? If you expect something out of it, you should probably specify how/what your effort is worth (strongly advise a written agreement) 
As far as waiting for the page to load, there is an event fired by browsers when the DOM finishes loading called DOMContentLoaded. So you could try adding an event listener for that before you fire the rest of the code. document.addEventListener("DOMContentLoaded", function(){//////}); ( on mobile so not sure how to get the formatting down, but I hope you get the idea ) DOMContentLoaded doesn't always work the same across browsers, though. I can't recall specifics off the top of my head but it's a good thing to try out. You can also wrap things in a setTimeout, window.setTimeout( function, 1 ); Which will only fire once the page is loaded. But it's a little hacky IMO. Try those out.
Nice catch, thanks!
I'm just about to get started with Vue, this will be a huge help. Thanks! 
Sweet, I look forward to giving it a go. Those benchmarks are looking pretty incredible. I see you fixed the issue where it wouldn't install on Node &gt;0.12, which was what blocked me from switching over to it.
Did you compare it [systemjs](https://github.com/systemjs/systemjs)? It has bigger objective, but it would be interesting to know.
If you do decide to use class, just remember: &gt; Even though ECMAScript includes syntax for class definitions, ECMAScript objects are not fundamentally class-based such as those in C++, Smalltalk, or Java. [source](http://www.ecma-international.org/ecma-262/6.0/#sec-objects), from the section of of the spec that talks about objects, check it out as there is a nice diagram and description of how prototypes work there too. 
As do I and, therefore, have my/(our) own setups that serve us better.
Never said you shouldn't use tools. All these tools are built in to the Unix shell, or can be built with shell and Unix builtins. There is no need for them when they should have been built for your own workflow years ago as they were with mine in 2004 and onwards.
Update: I did not realize that MathQill actually has a very nice API that includes the ability to insert latex into their editable text boxes with this simple function call: $('yourEditableBox').mathquill('cmd','\\sqrt, or whatever you want inserted')
"Paid" meaning "you look at the author's LinkedIn page and see he works for IBM".
Right. Everyone should have to start from scratch every time they're learning. Technology is supposed to make the barrier to entry into this field lower - doing what you're proposing is like the exact opposite of that. We have easier to use tools now for a reason.
Hi /u/kauffecup, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2390 times, representing 2.5200% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cypqw2u)
holloway's answer is correct, but let me show you another way that might (or might not) be more simple to grasp as a beginner. It involves using async-series, which is a part of the async library that provides utilities for handling asynchronous functions. In this case, async-series makes sure that each function is executed in series, ie: ONLY after the previous has finished. To do this you use a callback inside your functions to signal the end of execution for the current function and invoke the next one. This is the example from async-series page: series([ function(done) { console.log('first thing') done() }, function(done) { console.log('second thing') done(new Error('another thing')) }, function(done) { // never happens, because "second thing" // passed an error to the done() callback } ], function(err) { console.log(err.message) // "another thing" }) For your case you would do something like this: var functions = []; for (var i = 1; i &lt; 5; i++) { functions[i] = function (done) { setTimeout(function() { $("#el_"+i).fadeOut(1000); done(); }, 5000); } } series( functions, function(err) { console.log(err.message) }) Additionally, if the only reason you are using the timeout was to make sure that two divs don't fade at the same time and overlap, async-series would allow you to remove the timeout, like so: var fuctions = []; for (var i = 1; i &lt; 5; i++) { functions[i] = function (done) { $("#el_"+i).fadeOut(1000); done(); } } series( functions, function(err) { console.log(err.message) }) In this case, the divs would all fade continuosly but one after the other, never overlapping. 
Pretty irrelevant, but what is up with the tabbing (or lack thereof) in this guy's JSON objects? 
Wait... What do you want to achieve? What's the high level goal here?
I'm starting to believe that any dynamic JS loader at all is a complete anti-pattern. They're totally opaque to the browser's prescanner and always result in a cascade of death of network requests. They absolutely should be compiled out for production, but somehow make it in more often than not.
Meteor and Drupal is my favourite http://fourkitchens.com/blog/article/making-reactive-headless-drupal-8-interfaces-meteor
There are some support for MongoDB? How i can use it?
I couldn't get the DOMContentLoader to work but the Timeout worked perfectly! Thank you! This job has been my first dive in to JS so I'm sure I'll be back
Good answer! Also maybe: * who will implement the design? Is there a designer? Does he/she write HTML/CSS or will you have to do it (if you have to do it, usually there's a psd or a wireframe for you)? * If you're lucky there might be some kind of a specifications document. This will give you a clear overview of what you need to do. * Do they use any issue tracking soft? 
Author here. It's the difference between support for RequireJS' intended happy-path (you use `define` and don't need to depend on a callback at all) vs. using it as a completely generic script loader (which you can attempt with `shim`, but as shown, will be unsafe). As a completely generic script loader, for scripts that aren't bundled in the expected format, the claimed support breaks down.
Hey Michel, left you some questions on yesterday's post. Not sure if you saw them. 
This is the problem though. It's like talking to someone who doesn't use punctuation, or order their thoughts, or even finish one thought before starting the next one. There's no reason to embed the entire function into the call to reduce. Why not pull it out and give it a name that explains wtf it is actually doing? Then pass that in so you get something like aliasesList.reduce(findAllTheKittensWhoPooped, new List()); It's not a great example, the code above doesn't explain why we're reducing all the pooping kittens. What it does show though is that map/reduce and the various iterating methods are essentially functional primitives, in the same way that if, for and while are primitives of imperative languages. One other thing it shows is that new List() is the second parameter of the call to reduce, so we know what the initial value is without having to look 10 lines down. This is nice. I appreciate it's out of context, and it's nice you've added a comment, but comments are the bits of the code base that unit tests don't ensure are correct, and if you're writing 10 lines of code in a way that requires a lengthy comment, you should probably revisit the code to see how it could be made more readable. I'm actually with you on the rise of functional style programming, I came to Javascript from C# and we've been embracing this sort of thing for a long time (aren't we progressive!). It also causes a shed load of problems for the next developer comes along and has to comprehend, fix or extend it if it isn't handled empathetically. Here's the example to spare people referring back to the article: aliasesList.reduce((allMatching, matching, index) =&gt; { if (matching.count() &gt; 0) { const expanded = allAliases.take(index) .concat(List.of(matching)) .concat(allAliases.skip(index + 1)) .filter(aliases =&gt; aliases.count()) .reduce((current, aliases) =&gt; current ? current.flatMap( i1 =&gt; aliases.map(i2 =&gt; i1.concat(i2)) ) : aliases.map(alias =&gt; List.of(alias)), null); return allMatching.concat(expanded); } else { return allMatching; } }, new List()); 
Step 1: Use the latest version. Step 2: Quit using so many extensions and themes. Step 3: Notice a trend here? Or did you not read or understand the article? I'm betting both.
Most likely you are modifying the value of the webOnly var somewhere else, between when you set the 'click' listener and when the click happens.
Maybe in it's focus on functionality. But lodash is much more than just functionality. It has 100% coverage. It has a performance focus. It has module formatted libraries. It has documentation. So, no, not "what lodash is to objects". Not even, really, what underscore is to objects.
what is partString ? it doesnt seem to be defined anywhere in your code. 
From mozilla.org: **Firefox sometimes uses more memory (RAM) than it should.** LOL, you claim that mozilla.org doesn't know it's own browser. You are mentally defective. 
Typical redditor. Doesn't read or understand what I said. Attempts to put words into my mouth I never said. Talk about mentally defective.
Just to be clear here to OP: This syntax is in jquery AND a feature of CSS.
Use 1 event handler on the top, use a bubbling event, then use a data attribute to store the differening data that the function reads
/r/learnjavascript 
Good idea! As an added bonus, you could `fulfill` with the value returned from `syncCB`, in case you want to do something like remove any added globals, but hold onto their references (e.g. `return $.noConflict(true)`.
Well, this is seriously not looking good for me sharing stuff on /r/javascript. What's up man? I mean, I just gave something here. And I get this jaded response... Do you want people to give stuff away? Open source software runs on encouragement and support. Not this kind of comment. Think about peoples feelings and their willingness to share before posting... Be courteous. How about a thank you? And then another person up votes you for your comment... What is this place? Yes the code is performant, take a look. If you think you can do better, do better.
Indeed. It may also be nice to wrap the `syncCB` call in a try block, and reject the promise on error.
&gt; Yes the code is performant, take a look. Ok... &gt; for (var k in rope.fn) { *sigh* &gt; Open source software runs on encouragement and support. It also runs on input *and critique* from others. You submitted this code literally 7 minutes before posting it here, with some pretty big claims. Claims which I'm calling into question, and calling you out on. Back those claims up, or back them off. You do not have test suites, you also clearly are not performance tuning your library for utmost performance, and you also don't have submitters keeping any of that honest. So, what comparison with lodash do you think you have a claim to? 
Watch out with the arguments variable though, because it's not actually a real array, it just behaves like one on most fronts.
Ok, so first, events bubble up the dom, click on a nested &lt;li&gt; and if nothing catches it, you could have an event listener on &lt;body&gt; which would hear it. So in your case, you probably have a container div, with dynamic children, have a data attribute &lt;li data-foo='bar'&gt;test&lt;&lt;/&gt; So add an event listener to container, then the event will have the target of the event as a param, read the data attribute and update your image. On my phone, about to go to sleep, so might be a bit wrong. Fyi. 
I highly recommend this book: http://eloquentjavascript.net/ you can get it for free in PDF form at the above link
Me: FF is a memory hog You: you are clueless about cache Me: Even FF says it uses too much memory. So they are wrong too? You: Don't put words in my mouth. 
I'll check it out
And before you reply - &gt; If you think you can do better, do better. http://jsperf.com/rope-isn-t-lodash 8,808,427 vs 363,145 ops/sec, and I did that without even including your library initialization code you use for chaining. 
I think the point is: there's a major difference between "hey, i made this cool thing" and "i made something awesome that compares to X that you should use." The javascript ecosystem, as I'm sure you're aware, is rife with tons of crap code and outstanding claims. And, everyone wants everyone else to support their lib over something else. To /u/cosinezero's point, you have 5 commits, no tests (unit or performance) and sparse documentation. There's no compelling reason to contribute to or use your library when there are others out there that seemingly have a lot more time put into them. Check out: https://epeli.github.io/underscore.string/ I'm sorry to say, but in order to draw people in and adopt users, you really need to go the extra mile before your public reveal. Also, lodash uses lazy evaluation for chained methods. Your lib doesn't. Pretty major difference. So the comparison is a bit premature. I'm sure with a bit of time and work, you can make this lib a lot better and more consumable. Keep it up!
You write that without any consideration for improving it. Help me out man. Clearly you know better than I do, save me from blissful ignorance. What's so bad about `for (var k in rope.fn)` ? How its a tool to modify objects. What the heck did I do to you? You guys are really turning me off from reddit. This is not the first time, that this has happened. Look, I am a nice guy, and you're making it really hard for us to get along here. You assume I mean to hurt you by posting this? Just question me, think I am ignorant. Instead you crush me. What kind of support is that? Point me in the right direction. I'm teachable man.
You are evil man. Help me improve it. You are creating a fresh hell for me here without helping me out. Give me a direction. When changed to work with the actual object, your code runs slightly slower than a slightly more optimized version.
The list items each have a different *parameter*? I'm not sure how you're using the term parameter here... Let's start here, maybe? http://codepen.io/anon/pen/gPWrGw
ok, got it. Personally I think jumping through so many hoops to implement privacy is probably much more trouble, and performance sapping, than it's worth. What real problems are you guarding against with slightly stronger privacy than with privacy-by-convention? I'd just use underscored-and-prefixed (ie, `_pig_prop1`) or Symbol-keyed properties. Then you avoid the cache-unfriendly indirection of the extra object, and if you initialize the values in the constructor the VM can more easily guess the shape of the object and allocate a slot for the property. const CowOwner = base =&gt; class extends base { constructor(...args) { super(args...); this._cowOwner_cows = 0; } getAnimals() { const cows = this._cowOwner_cows; if (super.getAnimals) return super.getAnimals() + cows; return cows; } addCow() { this.cows++; } }; const PigOwner = base =&gt; class extends base { constructor(...args) { super(args...); this._pigOwner_pigs = 0; } getAnimals() { const pigs = this._pigOwner_pigs; if (super.getAnimals) return super.getAnimals() + pigs; return pigs; } addPig() { this.pigs++; } }; const Person = base =&gt; class extends base { constructor(...args) { super(args...); this.name = null; this.age = null; } }; class Farmer extends mix().with(Person, CowOwner, PigOwner) {} is a _lot_ less code and much easier for the VM to analyze. Since the VM can see the property initializers in the constructors, it'll allocate slots for all four properties, so they will be fast (as opposed to being allocate the in property map, which is slow). The downside is that privacy isn't strictly enforced, but it really wasn't in your code either, it was just more of a pain to get to. Who's going to be modifying the objects anyway? If you have a true security need for privacy, then the values should be stored in a closure. I'm an ex-Java guy, so I used to think not having privacy was crazy, but these days I think it's a bit overrated, and especially not worth adding much complexity for.
JavaScript: Understanding the Weird Parts https://www.youtube.com/watch?v=Bv_5Zv5c-Ts This course was my "lightbulb" moment with Javasript, it really helps you understand what's going on under the hood.
In terms of subscriptions, what I was referring to was this: https://github.com/facebook/relay/issues/541 but for Om Next + Datomic. Ask David Nolen if they have first class support for subscriptions yet. It's the equivalent of what Meteor does with LiveQuery, re-rending blaze views when subscribed to mongo data from the server updates. ...Regarding the diagrams, one thing I learned from @staltz via this thread was basically the concept that state is internally managed by the observable architectures, i.e. the "sinks" and whatnot. It's the equivalent of `foldp` in Elm. I.e. `scan` in Cycle. These reducers that operate indefinitely over time are maintaining state internally for you! So the conclusion is: Cycle doesn't need Reducers and single state atoms lol! I may be wrong, but that's what it's looking like to me. State is intrinsically managed by dealing 100% with time-varying values. This is as opposed to Elm, which has Signals but still defaults back to a sort of React style "managed" environment behind the scenes. This is why Cycle's core is apparently so small--it's just a natural cycle of observables, with a few pieces to glue it together. It's very fractal-like as a result. It's one never-ending flow, whereas the unidirectional stuff eventually has gaps which you much manually deal with. These "gaps" I see in my head as a "cliff" where state falls off of and lands in valley full of Reducers, Stores, Actions, etc, which you must manage separately. In short, state accumulates in the bed of the river in those valleys. Whereas in Cycle state appears to naturally flow and never stop (even though `scan` must be accumulating state for you behind the scenes). So in that way, Cycle really is a unique and very different architecture, even from Elm. Elm shares the characteristic that it's fractal-like, but at the end of the day it's most like React + Redux. So basically that means what you're making with Elmish is the fractal-like React + Redux in javascript. I forget, do you render to React? If you do, it would be nice, because then you get the benefits of React Native, etc. I think your project is more wortwhile than even you might think. It might even be more important than Cycle. If you promote that well, and brand it properly, you're basically all the best of Elm, but without having to switch to a language most people struggle with. Have you read Evan's thesis and all that? I mean there are some issues you will likely get in trouble with that perhaps Evan could only solve at the language level. I.e, similar to how in Cycle it's up to the developer to have the discipline to code in an immutable functional style, the same will be true with Elmish. But perhaps that's fine. I'm referring to his precise concurrency model and implementations of `foldp`, hot and cold signals, etc. I can't remember off the top of my head, but you likely have an even better idea than me. It just seems a few things here, we will want to get right, which will be some out-of-the-norm complex things under the hood, which as opposed to likely what you're working on now, which is getting an interface that looks like Elm. My hunch is it could look almost identical, but we could end up with different behavior under the hood. 
Because `setInterval` is asynchronous and does not block. To log "hi" last, put `console.log("hi")` just after the `clearInterval(pop)` var i = 0; var pop = setInterval(function (){ i += 1; console.log(i); if (i &gt;= 20){ clearInterval(pop); console.log("hi"); } }, 100); console.log(i); // here i is still 0
Seriously. WHY don't JS library/framework writers just FIX what's already there instead of writing anew ? I just don't understand. FAR more than any other language JS suffers from this problem. Is it a personality thing? Narcisism on the part of author starting a new project "I can do it better" ? Or perhaps the maintainers of an existing projects don't play well with others "GO away, you can't play with my toys"? Or perhaps it is something about the technology? Perhaps it's hard to understand the existing JS code base ? Or perhaps it's hard to know if a pull request has actual value? I'm not saying this to accuse anyone person or project, but JS seems to churn through libraries and project far faster than other languages and I don't understand why.
A standard library gives you, for better or worse, a set of tools that everyone uses. Your hammer may have a few flaws and may not be *exactly* the right kind of hammer for the job, but at least we all have used it before and know how to use it. Everyone knows the one I'm talking about. The claw hammer. That's the standard library hammer. There's a thousand kinds of hammers but we don't have to care about those because 95% of the jobs can be done with this one kind.
A few reasons I can think of, off the top of my head.. In part it's because the barrier to releasing a new project is so low (probably a good thing, but results in new stuff all the time). Since JS scripts are rarely huge programs and instead something you can get working and release in an afternoon (or an hour), it's often way easier to just release something yourself, that you control, instead of being blocked by someone else (who might choose not to merge your changes anyway). Aside from that, JS ends up on your website, it's not just tucked away on the backend like other software, and people are pretty sensitive about what gets loaded on their website. For instance, submitting a fix to RequireJS or YUI would have had no value to us, because they're huge libraries and we only need a tiny piece of functionality. Add to that the dozens of other things people are sensitive to (what globals the script adds to your page, test infrastructure, no agreed-upon metric like "is it Pythonic?", etc...) Finally: it could be the case that other languages have just as many duplicate packages, but their audience is just narrower so the projects don't get as much attention. Do you have a website? Then you probably also have JavaScript, and are going to choose a view library, script loader, module bundler, etc.
This looks cool! A few quick answers that others could disagree with: The build+pass badge represents that you have automated tests, and that they're passing. I suggest using circleCI for running your tests: https://circleci.com/docs/status-badges ...but you'll also need to HAVE tests, and have a "test" script in your package.json that runs them. Testing is a bigger subject; I suggest learning how to test your library with the mocha library: http://ricostacruz.com/til/get-started-with-mocha.html (random post I found on the topic that seems like good start) As far as speed, I'm not so sure — string manipulation is already really fast compared to other big JS speed killers like DOM manipulation. I would suggest adding an index.js that exposes the function; that way people who install it as a node package can easily use it. Details here: https://docs.npmjs.com/getting-started/creating-node-modules
Thank you, I'll look into those when I have some time. :)
It screams [Crayon Physics](http://www.kloonigames.com/blog/games/crayon). I feel old...
Geez, sorry to see you getting hate. Haters gonna hate, I suppose. FWIW you didn't claim to be what lodash is to underscore, so the snipe on perf seems a bit over the top imho. For me at least the tagline does a good job at explaining what the project is trying to do. Re: constructive feedback - for performance critical code, `for (var ... in ...)` can be bad because v8 doesn't always optimize it (see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#5-for-in ). That whole page is full of really useful info from someone who's done a ton of perf work, so it's well worth a read. Also, if you are into squeezing every drop of performance - maybe you're not there yet, and that's fine - try to avoid things like `[].slice.call` and `fn.apply`. As an example of a coding style to try to mimic, notice how Lodash code is simple, repetitive and procedural (e.g. while loops everywhere), as opposed to underscore, which internally depends more heavily on generic higher-order functions like `_.each`. Remember, the fastest code is the one that doesn't run. This implies two things: 1) less code is usually better 2) try to think in terms of how to run less native C++ code (e.g. a while loop is cheaper for the js runtime than a `.forEach`) Re: API - `rope.template` is kinda pointless going forward since ES6 has template strings. My suggestion to make a compelling API is to collect use cases from your projects at work and service those needs. In other words, dogfood, dogfood, dogfood. Also, pretty much every library writer these days use either commonjs (i.e. Node.js-style require/module.exports) or ES6 import/export modularization via Webpack/Babel, so it's a good idea to do that too and put your project up on npm. Thorough docs (API, examples and prose at a minimum) and creating a gitter channel are two steps you can take to help your project gain traction, and having a test suite will earn some confidence from people considering to use your library. Hope that helps
Something like [this](http://codepen.io/anon/pen/obWLBB)? By the way for animations don't use `setInterval` but [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame).
exactly. however I tested it a few times and it runs the code after the clearinterval but for some season canvas doesn't get a clear rectangle. I used it in the past but for this case it doesn't work. I tried requestAnimationFrame but it just renders first frame and freezes.
Along similar lines is [funscript](http://funscript.info/), an F# to javascript compiler. F# has a lot of compatibility with OCaml, but it is like Elm to Haskell in the sense that a lot of the higher level things are not supposed like HKT and type classes.
Ha! I thought it was going to be a `script` tag :).
I am loving jspm/systemJS too much right now to try anything else
Maybe he should quit developing all together, since obviously he should have only started a project if he was absolutely sure a prior work didn't exist already. I mean, that's why I got into programming, so that everything I do wasn't already done before.
&gt; There's no need to a smug elitist about it, though. Another standard reddit reply when presented with obvious learned methods and not "plug it in and do it for me". &gt;If you are working on a team, it's almost always better to go with a widely adopted open source tool Of course. Standard, decades-proven, known, everywhere Unix tools available on Unix/OSX/Linux/BSD. iow, everywhere and any educated programmer should be aware of and using them. &gt;you'll get no argument from me that people should spend more time learning the way things work under the hood and not just how this library or that framework want you to do things For one who agrees with me you sure do a lot of disagreeing. But that's standard reddit fare, too.
why do you still support IE8 and IE9? even microsoft doesnt support them anymore very cool badges and herokuapp!
One more notch in Atwood's belt
Because you can't "fix" a 45 KB wad of junk into a 1 KB streamlined solution. I mean, I get where you're coming from, we're bad at centralizing effort. But I've published a dozen (small) libraries, and in each instance I was well aware of the alternatives and started from scratch anyway because the alternatives were slow, bloated, fragile solutions that could not be made into a good solution without a rewrite and ditching backwards compatibility.
Here's a tip: Instead of function printUpperCase(words) { var elements = [].concat(words); for (var i = 0; i &lt; elements.length; i++){ console.log(elements[i].toUpperCase()); } } Write function printUpperCase(words){ return [] .concat(words) .map((a) =&gt; a.toUpperCase()); }
It's funny how you complain about name calling but start off with a personal insult. Hypocrites are funny. 
Mozilla doesn't say it the same way you are saying it. Mozilla is saying IF Firefox is using too much memory, then you are using an older version or too many extensions or too many themes or all the other things on that list. iow, YOU, the user, are doing things wrong but YOU, the idiiot, haven't figured that out yet as pointed out by /u/dhdfdh. So, agreed, YOU are the one who's mentally defective.
Never Mind. After almost 7 hour's working on this issue, It has now been solved 100%. Thank you,
[removed]
Your comment was marked as spam because you used an Amazon link which contains an affiliate tag; feel free to repost the comment + link sans the affiliate tag.
I have a concern how they use `parent` (and it is not quite clear from their Doc what it refers to exactly). Using `$parent` in Angular is known anti-pattern, is the Riot's `parent` different?
You might include a section in your readme addressing why someone would use this instead of string.js (http://stringjs.com/)
Is a cat better than a dog? 100% of cat lovers agree!
Definitely code ownership questions, then.
So basically you want a fast browser database with a mongodb like interface plastered over it. You could just use IndexedDB with [Recollect](https://github.com/divmain/recollect) to make it more mongo-like. Anyway, there's only one way to find out which solution fits the project: make a representative test and benchmark it.
I agree: the inner `reduce` should really be moved into a separate function with an explanatory name. Fundamentally, though, I still think this is the kind of code that looks like a [mess](https://www.reddit.com/r/javascript/comments/3zuucn/after_decades_of_neglect_functional_programming/cypwrvq) if you aren't use to this coding style and looks compact and understandable if you are. I probably shouldn't have used such an extreme example though. I was never happy with the underlying complexity of the logic of that snippet, which would be an issue whatever style of programming is used. As it transpires we're moving the whole thing to the server using a stock full-text engine (probably Found by Elastic), so we lose all this complexity at the cost of some additional network latency.
Strings aren't arrays, they are "array-like objects", the same way that stuff like `document.getElementsByClassName()` and `document.querySelectorAll()` return array-like objects, not actual arrays.
hhmmmm... I'm not a huge fan of these tips. I can't comment on the Angular or React specific stuff, but some of the tips a dubious at best. Tip #0 is an example of premature optimisation and micro-optimisation which makes the code harder to read. The method shown here may be faster today but that may change by next week but your code readability will still be paying the price. Tip #3. Abusing `switch` looks like a bad trade off over just a plain `if` chain. Also, many language implementations convert switch statements to look up tables internally. 
You don't know JS and JS the good parts
Yeah, it's a balancing act for sure and also part personal preference which people will never agree about. The article itself was good though, I'm totally ok with what you're saying. I've dabbled with F# intermittently which is functional functional and it is elegant. The key to making it functional is pure functions (ones that don't cause side effects) and this style of fluent interface.
What's the point of using both callbacks &amp; promises? Why not give them a promise and let them take care of their own callback? I'm genuinely curious. 
Duh, it's more fun! Sometimes I don't want to futz around with some dipshits code and pull request when I can do exactly what I need and make something new and learn a bunch too. 
Why I like node, having not ever used asp.net. 1. I'm not a particularly big fan of MS. They've improved but using Windows makes me want to smash things with hammers. I prefer OS X and developed on a UNIX based stack. 2. I have lots of experience with JavaScript. It's so easy to run I have an environment on every computer and phone. Easy to deploy. I've been using JS for years and years. Makes it easy to translate that to node.js 3. Async in JS works very well if you are used to it. Good for lots of stuff. 4. Nodejs streams are great 5. Insanely many modules, active community, run 'npm install &lt;whatever&gt;' and have something working in seconds. You can clone a github repo and have the skeleton of a cross platform web + mobile app, with database, component library, build shit, everything configured in about 15 minutes. 6. JavaScript is a useful skill that for better or worse will be used for the next 50 years. 
so that chart comparing loaders, why is RequireJS set to only support IE11+? have used it in IE8 for years. sounds like this is relevant. https://xkcd.com/927/ also, they are not interchangeable. some of these address JIT loading, module definition, dependency injection, config, conflict resolution, build steps etc. building something rudimentary and claiming it's 'most compatible and smallest' does not solve people's problems.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2395 times, representing 2.5226% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cyqhrk2)
came to say this, did. didn't see your post. :+1:
&gt; If you aren't delivering all of your page's immediately-needed JS in one, or a few, bundles, then you're doing it wrong. Unless you use **HTTP/2**, in which case you should **not** bundle. http://stackoverflow.com/questions/30861591/why-bundle-optimizations-are-no-longer-a-concern-in-http-2 Yes, the server will have to know what to push.
Please provide an example and I can possible act on it. What I mean is, take one of my functions and show me the more ideal way that you would prefer to use it.
Can you point me to where `String.prototype.splice` exists? From what I found, string does not have a 'splice' method. String also does not have a `map` method. Where did you find that string had these methods?
Lets see if I can get more down votes ;P Yeah, especially when its sooooo ugly. I know that might be because its a doc page, but really, its dam ugly. Make a page that makes it look good. Also the drop down in the form example isnt showing the whole word, the bottom of it is cut off. And why make the text in the table-based input almost unreadable? Dont like the way the input boxs look different either, just grates me. And offcourse, jquery....and coffescript...bleh.
 // 43% faster in Chrome 47.0.2526.106 on Mac OS X 10.11.1 // 98% faster in Chrome 47.0.2526.106 on Mac OS X 10.11.1 Will it be true with Chrome 48?
Yes, that is on my list of "Things to Adopt in 2016". The last time I tried it didn't seem to work on my set up of TypeScript and node. I should have another look into it. 
Thing is, npm is currently the biggest package manager in the world, and I don't see companies switching from javascript until at least 10 years. Furthermore, the spec is moving very fast and I think that the language is getting stronger and stronger every year. Plus, Google &amp; Facebook are 100% pushing javascript. One language for the front, the back, and the database (wink wink postgresql support for json/mongodb, cassandra &amp; others). It's just so much more financially interesting that having to split your teams between front &amp; back.
Nice, after reading [Welcome to the future of web application delivery](https://medium.com/@ryanflorence/welcome-to-future-of-web-application-delivery-9750b7564d9f#.1ikccg1gp), and looking at Ryan Florence's [example repo](https://github.com/rackt/example-react-router-server-rendering-lazy-routes) it looks like your plugin would be a better solution to his polyfill here: https://github.com/rackt/example-react-router-server-rendering-lazy-routes/blob/master/modules/routes/RootRoute.js#L2. It might be worth you having a look and putting a pull request in
I didn't robotparts' comment as a criticism, just a suggestion that might improve your public documentation. string.js is relatively well known so a lot of people's first reaction will be "I wonder how this compares to that". If there is something that you think your library does better then mentioning that USP is useful to someone browsing by. If there is something that you simply do differently (through subjective preference rather than more objective betterness) then that is worth describing. It isn't so much "tell me why I should even consider touching that", more "let me know the key differences so I can decide which to look at in more detail first (or only)". Of course you yourself may not have been aware of the other library until now, and even if you were aware of it writing something yourself as a learning/practise exercise has value and sharing the result is laudable.
I think it's generally a better idea to make the call to the parent constructor before you manipulate the child. So instead of function Cat(tailLength, furColour) { this.tailLength = tailLength; this.furColour = furColour; Animal.call(this, 4, 2); } you would want to do function Cat(tailLength, furColour) { Animal.call(this, 4, 2); this.tailLength = tailLength; this.furColour = furColour; } And I believe this style is actually enforced when using ES6 classes.
Oh... okay, interesting. Thanks for the info!
I think what he's saying is that while these functions might have some use, most programmers aren't going to take the time to implement it over another library or native methods. This isn't commentary on the code itself, it's commentary on its applicability to programmer's use cases. 
Its also very possible to have an app composed of pretty big standalone component that can be lazy loaded for a better user experience. (save bandwidth on unused stuff and load time) Lots of people in this world still have crap connections. 
lel top pen15
The core of /u/sime's statement was that you must add documentation with this kind of ambiguous signatures and, since JSDoc comments are so bloaty, it's a bit of work. That you fucked it up supports this point of view. "Clever" code just gives you more opportunities to make mistakes.
"if you got an array, just use spread" A "...words" parameter means that you're supposed to pass "word1, word2, ... wordN".
No believe me I completely understand. Until recently we were supporting ie8 at universities. However company wide we are dropping old SSL/TLS versions due to security vulnerabilities. These old browsers don't have TLS 1.2 enabled by default so your users are out of luck for using secure sites. It will force IT to upgrade. I think even IE9 has to have tls1.2 enabled manually. 
Exactly, I hate this attitude. Everyone loves lodash now, but what if jdalton took this advice? Because clearly underscore has been out for 3 years already and is already the clear choice to pick over this new library. Or maybe if Zuckerberg had taken such advice, because nobody can compete with MySpace, right? Maybe people just want to make stuff, who cares if X, Y or Z already exists and "does it better" because in the end, strings.js could stop development and rope could continue on and become the next big thing. Too many cynical people in development. Discourages people from wanting to contribute because heaven forbid they don't release a library that has 30 years of development and do 100% everything better than A, B, and C do.
&gt; http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html Thanks for sharing! Looks like a very elaborate resource. I especially liked that it's being edited with new solutions. Since JS ecosystem changes so often, articles like this are often obsolete by the time you find them
I think that was the right call, if you had to pick one or the other. Frameworks come and go but core Javascript skill will never go out of style (as long as Javascript is in style of course). I will add to that though that experience with a framework illustrates to an employer that you can build an app. If you've connected that app to a backend on your own then I think it looks even better. So, unless you're rolling your own framework you might be missing that kind of skillset, basically being able to work in a Javascript _environment_.
I think your code is an improvement over that function, thank you. --[edit]-- rope.fn.toCharCode = function (strung) { strung.value = strung.value.split('').map(function (a) { return a.charCodeAt(0); }); return strung; }; rope.fn.toCharCode2 = function (strung) { strung.value = Array.prototype.map.call(strung.value.split(''), function (a) { return a.charCodeAt(0); }); return strung; }; I tested your implementation, and found that the second version is slightly faster, but only by a very slim margin.
Some thoughts: &gt; these observable data sources don't need to be passed in as arguments, they simply need to be used within the function, which makes the function the total opposite of pure. That means it's inputs aren't easily testable, etc. Not this 'inpurity' isn't a result of transparency but a result of mutability. For any method that mutates a data-structure this objection hold. Nonetheless derivations in Mobservable are pure; they do not modify the system in any observable state. And that benefits testability greatly. Argument based purity contributes less to testability; for real-world tests that involve complex data you still have to construct state. Granted, with pure functions you can keep using this data for different tests. But this property comes not from the purity of the function in itself, but again, from the immutability of the data. Purity is something good to aim for, but not a goal in itself. If you aim for purity in its purest form you have to accept that all your data has to be immutability. Mutations per definition require side effects to achieve them. Going full immutable might be acceptable for a lot of apps. But as said, personally I think the costs are too high for complicated apps: no referential consistency, classes or even graph like data structures; you need to have all state in a tree. (Hence, imho, Redux / ELM is for apps with limited complexity and TRP is for full-end devs that want to model complex data :)) &gt; but it's thanks to React that only a portion recalculates, not solely to using a "Transparent Observable." No that has nothing to do with react. Whenever you compose derivations in Mobservable you will observe this behavior. It was just trivial to implement in react because React allows for composition and pure render functions. The above linked state history is a good other example of a 'rendering' that only updates part of the derived state graphs. &gt; Mobservable on the other hand just shouts out orders to various React component instances to re-render themselves. It's loosely connected and "ad hoc." It is definitly less explicit then cycle, but the mental model behind Mobservable is as straight forward: actions -&gt; modifiy state. state modifcations -&gt; updates the minimum possible amount of derivations to keep everything in sync. This happens like Rx in synchronously. &gt; In addition, traditional argument passing is not used, so it's hard to test. Yes that is a very fair point. Partially you could solve this by using pure functions that do your logic and using observable functions for composition, but in essence the only way you can fix this is by using immutable tree as your state. easier testable: var a$ = observable(1); var b$ = observable(2); var max$ = observable(() =&gt; testableMax(a$, b$)) var testableMax = (a, b) =&gt; math.max(a(), b()) &gt; My real question is--since I love TRP--how can we solve this problem? How can we make TRP pure &gt; ... Generally speaking, my idea is to push reactive data sources to the "edges" somehow That all being said I am definitily thinking about these questions; how can we overcome the (perceived) complexity and issues. But it is also very much a matter of how much you value (im)mutability. I'm thinking it might be really cool if TRP was applied to immutable data. A bit like derivablejs. On the other hand, using immutable data is also more obtrusive to the rest of your stack. &gt; Another thought: Michel, it might also come down to marketing value. Yes definitely that is an issue. TRP screams: trust the system. And there have been many unpredicatable or limited implementations around. On the other hand, React is also one big black box but everybody trusts its because they grasp the mental model and it has a good rep. Besides that TRP doesn't have much fancy terms to show of with. Except that it results in the most simple and straight forward code to write that doesn't require a degree in CS. But everybody claims that :) (Btw, building an UI framework with Mobservable in itself is easy; I think, by using mobservable.createTransformer, you can build the component / render stuff of React in 100 LoC including DOM reconciliation, but what will it proof?)
This article is what got me heavily into react and redux. Best article I have read possibly ever. 
Well, first, the whole thing of using console.log a an example is not very realistic because console.log accepts literally any type of value, whereas your real code that expects words will not accept booleans and other stuff. Your method is I guess ok *if that is what you need to do*. If you need to uppercase all strings in a nested array recursively, yes, go for it. But my point is - most methods out there do not need to have such flexible arguments. Generally a method expects parameters of a certain type, not any parameters it could possibly work with. Such rigidity helps a lot with understanding the data flow in the program. Also, your method name does not reflect what it does. It doesn't print anything, and doesnt really deal with words, more like arrays and/or words... Normally when it's hard to describe what a function does in its name it's not a good sign. 
Angular 1.x is far from obsolete. Just because Reddit thinks it's obsolete doesn't mean it actually is. Many companies use it, probably more than React or Ember. Backbone is a bit more "obsolete" but still used in a lot of companies and still actively maintained so I wouldn't really call it "obsolete". FWIW in Reddit's opinion, Ember is as obsolete as Angular 1.x and the only good frameworks are React and Vue.js.
I could rename the function to `poke_fun_at_raquo`... I'm kidding though, but I do agree with all of what ya said.
Ok, delete the original thread and repost, I guess. I not only gave you improvements - I literally gave you code examples in an jsperf. And you're continuing below with "Please provide examples" when people have general feedback for you. Please consider what you're asking and what you're expecting people to deliver to you. Anyways... I don't think chaining string manipulation is something I would use. Your code is a workaround from stapling features to the string prototype (which is good) but instead of returning the string from the method you're returning your library. That's not intuitive for developers - we are accustomed to string type methods returning the new string. Consider the following: &gt; var myString = 'test'.substr(2,1); versus &gt; var mySplicedString = rope.splice('test', 1, 0, 'INSERT').value; Yes, these do different things, the point is about the syntax you are forcing. I understand the desire to chain everything but when operating on a string literal this isn't ideal. YES, this is cool when you're chaining *only your string methods*. But think about this: What if I need to do something to the string that isn't in Rope? What if I need to trim() or toLower() in the middle of the chain? That forces the developer to switch back and forth between your chain and the native string methods. I very much dislike the .value property here for that reason.
The pagination is super annoying.
I too, subscribe to JavaScript Weekly.
XPost Subreddit Link: /r/reactjs Original post: https://www.reddit.com/r/reactjs/comments/402f9w/wsyiwyg_for_react_projects/
he spelled graal wrong, so I doubt it was serious.
It is explained in details in the video linked in the OP. Using a Promise/A+ compliant implementation (like native ES6 or Bluebird) means that the `onFulfill` handler is run asynchronously, and foreign code may run between the moment the script loads and the moment callback runs. A third party script or a browser extension may stomp on the globals defined by the script before you can read them in the callback. The `syncCB` callback passed to `little_loader` is guaranteed to run synchronously, just after the script loaded. Edit: I started this reply hours ago, and missed /u/exogen's before I submitted.
What's wrong with having to take some time and document it? If this clever thing is convenient and saves you time, and you document the expected behavior of the method, I don't see anything wrong with that. Sure, my example wasn't 100%, correct, but the point was to show it didn't need a large block of jsdoc, just one like the one I posted. The comment was not meant to start an argument about the specific syntax and semantics of jsdoc.
Not 100% true. It doesn't bind `this` to the new function. It just doesn't create a new lexical scope in the arrow function.
I don't make any use of parent for i know the downfall of strongly coupling any components. Its true they include it in some guides but i would not use it. You can pass callback in props or have connected components You can use Flux, Reflux, Redux, for state management and module bundlers. You can make higher order components, elements, leverage mixins and really make your code modular and straightforward. But the biggest advantages anybody looking at your code can get it . 
You are probably correct. I based my wording on this quote from MDN: "[...] and lexically binds the this value". They do, however, also state it "does not bind its own this, arguments, super, or new.target" and later on use the wording "capture the this value of the enclosing context". I will edit my comment to reflect the latter.
I've spoken to a couple of people at Google and it sounds like it's been a real thorn for the Chrome team, too. So if you're currently using AppCache in production, you should really get moving on a migration plan.
https://www.java.com/en/download/faq/ask_toolbar.xml
What about: https://ace.c9.io
Interesting article!
You need to get `with` the times, grandpa. `with` is the new ECMAScript-version-3 hotness and it's going to go down a storm, I'm sure.
I'm just now learning javascript, and got familiar with C# in the last 6 months, so just learned this concept for working in C#. I love it. Way more elegant than "function ()".
can you then declare a function like so? (secret) =&gt; { return { get: () =&gt; secret }; } 
It's a syntax for **arrow** functions. Which are similar but not the same as functions. Please don't make this mistake!
The arrow-function syntax is only an expression, not a declaration; if you want to use the function later, you'll need to assign it to a variable or an object member. By the way, I think a shorter way to use arrow-function syntax and store it in a variable would be this: const secretKeeper = secret =&gt; ({get: () =&gt; secret}); The reason for the parentheses is to keep that object initializer from being interpreted as a block of statements.
Hi /u/dzstormers, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `youtube.com/channel/UCU3feytkHYYS2CoIZKsSMlA` (aka. "The Designer"). Thanks for your consideration! domain submitted from|count|% :-|-:|-: [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27dzstormers%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|11|100%
Hey cosinezero! Your function from the original post is slightly changed when I worked at in the jsperf, storing the `strung.value` as a variable gave a slight improvement over your code example. Your performance was also weighted because you didn't pass an object into the argument. You put effort into your post and you put energy into it--and I appreciate that and you helped me appreciate the weakness that my code had. And I learned a few things in the last couple of hours! The native methods... There may be a few ways to fix that. I know looping through the Object is slow and that I would be wise to write it long handed. Do you think there would be value in going through the `String.prototype` and seeing if a method exists, if it exists offer an interface for it which is compatible, and if it doesn't exist, offer the `lasso` (renamed it) version? It is a lot to ask eh. I'm sitting here after work, thinking about this thing I put up and you took your time to respond. I just want to make sure you know, I appreciate you. 
Edit: look below for correct explanation. 
Backbone also is not obsolete. You can read the source in an 1 ~ 2 hours. 
I don't mind them deprecating things like this but why so sudden? Let it there for a couple of months in order for people to adjust their code. People rely on this. Its not like you can remove it with 1 days notice or whatever
Typescript is essentially just ES6 with type annotations. I don't think you can group it with the other two.
Fat arrow is the coffeescript way to describing it, since it also has skinny arrows in the form of `-&gt;`. `=&gt;` would be described as an *arrow function* in ES6 terms.
Nobody is going to remove this suddenty. AFAIK, the plan is to hopefully build a AppCache shim on top of Service Worker (maybe the plan has changed on this specific, I dunno).
http://www.modulecounts.com/ I don't get you wrong. But the difference between NPM and other package managers just speaks for itself. And it's the same thing for all package managers. Some package don't get support or commits. But the difference is SO huge, that it does not matter.
Good riddance. Never could get it to work like I wanted to.
Also, it's likely that they will be easier for the engine to deal with, because they cannot be used as constructors or generators and (because they don't have their own `this` value) cannot be bound or set to use a different `this` value with `.call()` or `.apply()` (in this, they are similar to bound functions, as in the outputs of `.bind()`).
I mean, everything you knew is still perfectly valid in ES2015.
Because it looks like an arrow. Its often called "fat arrow" since it uses = vs - so makes the arrow look "thick".
Oops. You're correct; fixed, thanks.
I need entities not to stay intersected with a tile. They need to be pushed out in the appropriate direction, and the correct velocity must be set to zero. Right now, they are getting pushed in random directions, and I don't know how to fix it. Code is here, if interested http://jdhcodelab.com/test/default/
They're just called ~~anonymous functions~~ _function expressions_ (is maybe better terminology? People are being particular; specifics are detailed in other links in this thread) in JavaScript (which have been around for a while). This new syntax is a different form of function and the distinction is made through the shorthand operator used to define them, the fat arrow (`=&gt;`).
Check this article (Flash required, sorry): http://www.metanetsoftware.com/technique/tutorialA.html It describes how to resolve collisions via projection.
I am intrigued. But the track record does not speak for the project. There were many attempts on creating one runtimeenvironment for every language out there. 
That piece of code is literally all I have for collision handling. Maybe more background info would help? That is inside a for loop that runs through all entities, then all tiles in its area. If the entity is colliding with the tile, then this code here runs. gameObj.physObjs[i] == current entity, tile == current tile. isRight and below are booleans telling whether or not the x and y values of the entity is higher than the x and y of the tile, respectively. Let me know if there's anything else to explain. Should I remake this post with just the player, and a tile?
Isn't one of the boons of Redux that it's so much easier to unit test pure functions?
Like 90% of the redux app I wrote could have tests but it's such trivial code it feels silly to test. Then there's the 10% that has tests to make sure nobody can POST values that will make a robot destroy itself. Obviously there's server-side validation, but you can't be too safe.
It is! That's what surprised me as well. Both in searching resources and discussing with engineers **I respect** I didn't see that it's too common at all. Since with Redux you are dealing with a single state object and everything is eventually dealing with that state object it should **definitely** be easier to test and comprehend. That being said, I still see that testing is definitely not natural for people dealing with it.
HTTP/2 including all relevant features isn't implemented anywhere, let alone everywhere, and counting on HTTP/2 then falling back to HTTP/1.1 would be a performance disaster. And the benefit of not bundling over HTTP/2 is small, affecting only cache granularity. Given the high risk and low reward, it could be a decade before not bundling becomes the better choice. I don't even know if I'll be making websites then.
Ah, ok. Thank you.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Anyone running isomorphic JavaScript apps yet?](https://np.reddit.com/r/webdev/comments/403wvl/anyone_running_isomorphic_javascript_apps_yet/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
The WordPress [Calypso](https://github.com/Automattic/wp-calypso/tree/master/shared) app seems to...
I tried something else yesterday, where instead of the velocities, vertical was based on how far into the tile the entity was on each axis. If it had more of a horizontal overlap, ________ | | | ____|_ |_|____| | &lt;-- More of a x axis/horizontal overlap | | |______| Then I would push it up or down, depending on the "below" boolean. This mostly worked, but there were issues if you walked against a wall (short one, 2 or so blocks tall) as you fell or rose, then there would be a frame where the above image would happen, and the vy would be set to zero. There were other issues with that too, but it is very hard to describe
I've developed 2 completely Isomorphic apps and about 7 other Isomorphic web sites. At my job we have been working on a (soon to be officially released) framework that basically lets you bring node to the front end so you don't have do much context switching and you get some free Progressive enhancement. You can check if out if you want. https://github.com/rill-js/rill I think the Isomorphic community is still figuring things out though but to me it seems to be trending up with more libraries providing shims for the browser or node.
The only thing with that is that it's not quite camelCase because the underscore '\_' character is valid, and it converts '.' to '\_', so I feel like it's 'jsCase'. You be the judge, and I'll rename it.
Preserves self variable for use inside of closures, normally **Thing** would be a constructor for a class, if you follow the RAII pattern, the you might follow it up with event handlers or other things... function Thing() { var self = this; masterSJW.on('triggered', function() { self.getTriggered(); }); } var t = new Thing(); **note contrived solution is contrived**
&gt; An arrow function does not change the 'this' keyword, or the lexical scope at all. I was curious to see if this was true: () =&gt; { var a = 5; } a++; &gt; Uncaught ReferenceError: a is not defined Unless I'm misinterpreting you, it looks like it's not the same lexical scope after all.
This kind of reversal meaning different things has been around for a long time. Observe C89: `a&lt;-b` means `(a) &lt; (-b)` `a-&gt;b` means `(*a).b`
The perl guys call it a "fat comma" because it's just an alias for `,` in perl. And I think in ruby they call it a "rocket" because I guess they had to ape the perl tradition of having a goofy name for every operator. But yes, fat arrow is probably the most common.
It's a stupid ass way of writing a function.
Perhaps if you wanted something simpler/smaller, that's very easy to customize. It has a very small set of variables that let you change the look pretty significantly.
"Syntatic sugar" for writting function() {} (var1, var2) =&gt; var1 + 2; is short for function(var1, var2) { return var1 + var2; }
To be fair, it's usually called a "hash rocket" in Ruby, and I feel like a bit of glibness is alright, because Ruby 1.9 added a JSON-style hash syntax, and folks needed a way to differentiate between the new and old syntaxes.
It's actually much more than that. NW.js lets you call Node.js modules directly from the browser's JavaScript code. This means you get complete access to the OS (filesystem, networking, devices, etc.) just like any other native application. It's actually a pretty neat combination!
here here, nothing but headaches.
It must be my Mac OS background showing through. I guess it's a debate similar to the "directory vs folder" one...
It's there on the actual code - just didnt come over when I copied and pasted for some reason. I edited it and added it if that's the one you were talking about
Both NW.js and Electron fully support Node.js modules. This means you could easily use a module such as this one: https://www.npmjs.com/package/sqlite3 I don't see a need to have this built-in.
&gt; I don't mind them deprecating things like this but why so sudden? Let it there for a couple of months in order for people to adjust their code. So you're saying that shouldn't just deprecate it, they should deprecate it?
egghead has a few nice courses on React and Redux, I'll draw your attention to this one on testing for both: https://egghead.io/series/react-testing-cookbook
There is – Function.bind creates a new function every time it's called. It doesn't matter in your case, but if you want to reuse the function and use identity equality, it matters. addEventListener("onChange", listener.bind(this)); removeEventListener("onChange", listener.bind(this)); That won't work because listener.bind(this) !== listener.bind(this) ETA: Sorry, I took your comment out of context. You were arguing about binding semantics, not mechanics.
I appreciate what you did there. 
To be fair, you're doing a few things that aren't best practices: 1. Declare a variable with a function value, not a function with a name. 2. camelCase bruh. 3. Arrow functions. All in all, it should look something like: var thing = () =&gt; { // ... }
Spoiler alert: nope it does not :) I only tried with "class" methods though. I would think that silently changing native JS behavior is a big no-no for a transpiler.
I'd say start with integration tests which lead into unit tests which lead into code :) [London school TDD](http://programmers.stackexchange.com/questions/123627/what-are-the-london-and-chicago-schools-of-tdd) is the future of TDD :P
Hehe nice example
You're right. &lt;edit out incorrect claim&gt;
Nah, not really. You're getting easier access to the this you want in the end. But it's still good to know how it works. 
&gt; But it's still good to know how it works. Agreed on that end, I'm sorry I sort of jumped on you for that, but I've just noticed people on this subreddit immediately poo-pooing .bind() explanations for people new to ES6 but experienced in ES5, and I just wanted to get my thoughts out there re: .bind() being a perfectly good way of understanding it conceptually.
Ah, yeah, it's definitely something that's doable in the old system, and you're right that it's effectively syntactic sugar in that sense. Implementations do matter, though. While a bind(this) can be turned into a no-op with sufficient compiler-fu, it's not clear to me that all compilers do this. A simpler syntax and the potential for a slightly speedier function execution is enough reason to switch from a bind.
All the apps I work on currently are isomorphic. My main work is on https://stream.me which is fully isomorphic using React. The bulk of the site is not done as a SPA, but many subsections are. For the SPA sections we use express and it's router on both the front and back end via a module (https://github.com/wesleytodd/nighthawk) which is just a wrapper around the express 5.0 standalone router. We have been running this in production for over a year now with no major hang ups. The performance is good and it is really easy to maintain because react is easy to grok and build on. Our company used to work on a site that was all angular and at the time it was VERY difficult to do isomorphic. Although I heard it is easier with the new version.
Haha, I got ahead of myself, meant es2015. Any mod able to change the title?
Technically it is short for (ignoring the underlying lexical scope sharing stuff): function(var1, va2) { return var1 + var2; }.bind(this) This is actually the main purpose for arrow functions is that the bind the scope inside the function to the scope outside the function. Other than that they are pretty much equivalent to normal functions. And lets all be very clear here, the OP example SHOULD NOT USE ARROW FUNCTIONS. Writing shorter code that is harder to read is WORSE CODE. If you are using the scope binding nature of arrow functions then GREAT. Otherwise es2015 does not make obsolete the code you would have written before.
Anything in Meteor is. 
Yeah... It seems like they're exclusive of each other. One tests that the logic works. The other tests that the code structure is right.
document.querySelectorAll(everything);
Please always keep anything you work on to yourself. There's enough broken shit in the world from "fuck you, I do what I want" people. I was about to jump on that guy for being smarmy and antagonizing, but your attitude is just as bad. 
Judicious use of jQuery is fine. But, to me, the danger is that it can easily mask antipatterns and code smells. In Python, if I'm writing something and I can't find an elegant way to make it work, I usually find that it's not that I'm lacking the right tools, it's that I'm approaching the problem from the wrong angle. As I'm using JavaScript more and more these days, I discover the same often holds true. Today, for example, I was doing something with CSS to try and hide elements. I had this case where I wished there was a parent selector. Began looking at what the Internet had to say about it and found nothing simple and elegant. Realised shortly after that I was approaching the problem wrongly. The solution was slightly more code, but was considerably easier to reason about, had less likelihood for side effects, and didn't require a comment to explain what I was doing.
This is something I've been toying with recently. I was using [Parsimmon](https://github.com/jneen/parsimmon), which is a great library, for a small project but ultimately I wasn't entirely satisfied with it. So I made Warbler. It's still a bit rough around the edges, but it is mostly working as it should. The README.md should contain most information. The source code is ~500 lines of fairly readable ES6+Flow. Feel free to ask questions/comment on it.
&gt; HTTP/2 including all relevant features isn't implemented anywhere, https://youtu.be/i2ezuw_RV78?t=737 http://caniuse.com/#feat=http2 or http://caniuse.com/#feat=spdy https://blog.cloudflare.com/introducing-http2/ https://github.com/http2/http2-spec/wiki/Implementations http://sysadvent.blogspot.de/2015/12/day-19-http2.html &gt; And surprise: you're likely reading this article over HTTP/2 right now! etc. etc. https://tools.keycdn.com/http2-test
I suppose, but you can't really blame the tools. Just because someone used a hammer and nails to build a satanic cult clubhouse, doesn't mean you can blame the tools used. Although I think these problems arise at how easy jQuery is to use for beginners and it's popularity, so we see more bad code around with jQuery? 
Yep, for about a year now! We completely rewrote our PHP app in Node + React, which is why I created React Resolver, to support async rendering on the server. There were lots of edge cases to solve, like redirecting based on business logic happening in the view after routing, short-circuiting the render to send a JSON response for AJAX requests, submitting a form using the standard HTTP POST format instead of an AJAX call, creating our own Flux library because the standard Flux dispatcher only allowed one dispatch at a time, etc. The solutions have certainly improved, and I greatly prefer this over having context switching between front end and back end implementations. 
Duplicate one...
&gt; jQuery does so much that there's literally a thousand libraries that do what it does. What *specific* thing do you want to do? If all you have is a hammer, everything starts to look like a nail. jQuery is a good beginners toolbox, but you'll find it quickly becomes a jack of all trades, master of none. The Javascript ecosystem is quite focused on building small, domain-specific utility libraries that only solve one thing, but do so very well (usually...). As such, it would serve you well to find ways to replace the kitchen sink with better tools. You'll also stop putting all your eggs in one basket, meaning upgrades or replacements are easier to implement. Separate out things like data manipulation, Ajax, and DOM operations into different libraries (or no libraries!). 
Thank you, and much respect! If I have a chance to contact the author, I will try to focus attention on three things. First, improving the documentation for the official site. Personally, I strongly dislike the “Wiki” docs style on Github. I would always prefer to quickly scan one-page comprehensive (as in, e.g., [lodash.com/docs](https://lodash.com/docs) and [nodejs.org/api/all.html](https://nodejs.org/api/all.html)) documentation where each option has a detailed explanation and examples. For instance, in [lokijs.org/#/docs](http://lokijs.org/#/docs) page I don’t see any example of “persistent”/“sortPriority” options in use, and the “sortPriority” option is not even mentioned (I’ve found it only mentioned at [wiki/Indexing-and-Query-Performance](https://github.com/techfort/LokiJS/wiki/Indexing-and-Query-Performance) page)! Second, I don’t understand those “ops/sec” examples. The performance will depend on the data size, right? For example, I have 200K-300K objects as my data. Assuming that “property1” and “property2” are indexed and each object is 500-1000 bytes in size, can you elaborate on how much time is e.g. results.find({ "property1" : { operator: value } }) .compoundsort(["property1", "property2").data() estimated to take (under various conditions)? Third, is results.sort( function(obj1, obj2) { if (obj1.property1 == obj2.property1) return 0; if (obj1.property1 &gt; obj2.property1) return 1; if (obj1.property1 &lt; obj2.property1) return -1; }).sort( function(obj1, obj2) { if (obj1.property2 == obj2.property2) return 0; if (obj1.property2 &gt; obj2.property2) return 1; if (obj1.property2 &lt; obj2.property2) return -1; }); equal to results.compoundsort(["property1", "property2"); ? And why is `[propertyname, isDescendingOrderFlag]` for `compoundsort`, but no `[propertyname, isDescendingOrderFlag, comparefunOptional]` syntax (as in `.sort(comparefun)`) So, it’s impossible to add my own sort function to `compoundsort`, right? 
Scope does not change in inner code blocks in JS unlike other languages. So arrow functions DO introduce a new scope.
Or Java... ^Or ^C#... ^^Or ^^... 
This is brilliant. I had no idea about GraphQL!
I commented to another guy with this link https://gist.github.com/ericelliott/414be9be82128443f6df. It's a bit misleading to say that lamdbas are anonymous functions. 
Great stuff. I've been wanting something like that for a while. Much easier to quickly cobble up a parser out of functions than to use a grammar file (at least for me).
Vanilla ajax is ugly as fuck
Thanks, I wasn't familiar enough with those languages that I wanted to generalize and risk spreading false information.
The example doesn't work with pure functions, does it? Isn't it best practice to define every requirement as parameter of the function, like: function (a, b) { return result; }
Jquery code is the opposite of reusable, the opposition of functional, opposite of composable, it's just not that good if you have more than 3 buttons on a page. But it's a stepping stone to understanding WTF is going on in a browser when you first start programming. You can write good code with jquery, of course, but it's easier to write shitty code with it. Lodash is a much better tool for writing effective code. 
It's also, much like React, a Facebook thing, so get to know industry best practices in RESTful and HATEOAS API design, SOA , ESB, and a bit of the history of Web service design with some pros and cons of earlier designs before jumping into bandwagons.
Thanks for the reply, much appreciated I get what you're saying, it makes sense. How to actually apply that for what I've got, I'm a bit stuck on. I tried to google some information on what you're talking about but I didn't find really anything. Here's what I'm up to using some of your code as reference: function OR(f, g) { return function(x) { return f(x) || g(x); }; } // simple filter var enabledQuest = (x) =&gt; AutoQuest[x.quest] var incomplete = (x) =&gt; !checkQuest(x.id, 0) var partIncomplete = (x) =&gt; !checkQuest(x.id, 1) // Special check for only certain objects var special = OR(incomplete, partIncomplete) What isn't making sense to me is how'd I'd use that special check for only certain objects. At the moment 2 of my objects need the incomplete and partincomplete check, all the rest only need incomplete. My final composed filter would be a combination of enabledQuests, the outcome of the special filter on the particular objects and the outcome of just incomplete on the rest of the objects. I think I know what I need to do, I just can't get there haha. On a side note, all these small compositions in this case seems like a lot more hassle and actually more code than the for loop, is this kind of thing generally worth it?
I get your point, there are a lot more cases this thing needs to cover because of all the cases this thing needs to cover. In time!
Sounds like your solution is what I would have eventually created if I were much smarter than I actually am. Do you have any public repos or demonstrations of this backend I could see?
&gt; if you stuck with vanilla JavaScript you would probably end up rewriting parts of jQuery. Yes, you can't use things like Element.matches or Element.closest directly - even if you only support evergreen browsers. http://caniuse.com/#feat=element-closest http://caniuse.com/#feat=matchesselector E.g.: https://www.reddit.com/r/javascript/comments/3zs9eu/using_setattribute_to_call_a_function/cyp7s4a If I had to improve the compatibility of my "closest via matches" solution, I'd need a polyfill for "matches". You'll also need a polyfill for fetch if you don't want to deal with the horrible XHR API. http://caniuse.com/#feat=fetch &gt; How else am I going to merge two objects without writing another .extend method? https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign &gt; Plus, the selector engine is pretty cool too. QSA is okay. jQuery isn't that important anymore, but I'm really glad that it existed. Prior to IE9, you couldn't even use addEventListener directly and there was so much insane shit going on. jQuery provided a usable normalized platform. The CSS never worked right with older IEs, but the JS was fine thanks to jQuery. It really helped a lot. "Vanilla" and "micro libraries" are somewhat misguided. What we actually desire are more modular libraries and a smarter packaging step which only includes the parts we actually use (tree-shaking). If you combine this with a few hand-selected polyfills, you end up with an optimal bundle which is comparable in size to a far more labor-intensive "vanilla" implementation.
I point novice API designers to this one: http://www.slideshare.net/XEmacs/representational-state-transfer-rest-and-hateoas While I don't agree with everything he says (and quite a bit of the rigid HATEOS tit-for-tat design creates real performance problems in practice), if you don't take it as gospel but as a starting point in your own learning and designs it's a great starting point (and an easy read).
This is my explanation about unit vs e2e testing, it is for Angular but principles are general: http://stackoverflow.com/questions/17070522/can-protractor-and-karma-be-used-together/29619467#29619467
Simple: sublime text 3 Featured: phpstorm (or just webstorm if you never want backend stuff)
Your data layer makes sense to me. Would you also define what properties/related records to return in your frontend along with pagination, etc? Can you help me understand why you would register a user in this way, instead of a POST to api/users? I'm also still learning this, so no subtext of that being somehow incorrect intended.
I'm a fan of Coda. It's constantly improving, too.
I'm only making a point of it because I think it's misleading for anyone learning a new language after JavaScript, or someone trying to learn JavaScript after something else. Ultimately, it doesn't matter what they're called, but every time we make up a new term for something new it makes it harder to translate skills in one language to another. And yeah, I should have read the comments ;) 
I guess, if PHP is the only thing you consider "backend stuff".
Thanks for the `j2c` mention :-)
&gt; I'm not going to change my coding styles to fit someones (Reddit comment) new ideas of best practice Tell me about it. You and thousands of other developers. Hell I feel like half of my career has been spent cleaning up after people like you that have no regard for why things become standard practices, kind of like the programming equivalent of Eric Cartman. This attitude is also one of the biggest reasons security vulnerabilities are so pervasive in our industry. People who have to review code from tens or hundreds of other developers can't be expected to constantly guess what's happening in non-standard code, and usually don't even bother wasting their time until your code passes some lint tests, and maybe has a few tests. You seem to take the expectation that we're all trying to communicate using the same methods as much as possible as some sort of authoritarian control scheme devised to force you into some sort of conformity, when in reality it's about efficiency, productivity, simplicity, and reducing the amount of work we all have to do; all things that are fundamental to being a developer. I just hope some day you realize being an edgy asshole doesn't make you seem like some kind of unique snowflake of wisdom that should be respected, but that anyone who glances over your comments that has been doing this for some time professionally are laughing at you and hoping that they never have to encounter a project you're a part of. Arrogance is a part of the growing pains of being a developer, I'd be a damn liar if I said I've never acted like that myself, but the sooner you get out of that phase, the better for yourself and everyone around you.
Im trying to improve/grow the way I do things aswell, so I hope someone shows something good. Sofar its just ugly complicated stuff to me. Prolly great in some things, but maybe not for this? If your going to keep adding more conditions its gonna get ugly real quick. For this sorta stuff I like to use a map (I do that alot), kinda like this.... var map ={ hotel:[0,1], motel:[0,1], mansion:[0,1] } sequence.filter(function(room){ if (AutoQuest[room.quest){ // Im not sure if checkQuest returns true of not...adjust accordingly if(map[room.quest]) return !map[room.quest].some( (x) =&gt; checkQuest(room.id, x)); else return checkQuest(room.id, 0); } }) Looks clean enough, yeah? And you can adding lots more conditions without it getting to ugly.
It is slow as molasses on my iphone 6 plus. That's not ok. 
Service worker cache will be entirely client-dependent so it's not really something that's applicable to a build phase like webpack. But a good example of how to cache static files with ServiceWorker can be found here. https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers
You must not use it? Look it up. I work in just about everything and use this for most of it.
First of all, please do not assure that I am correct in any way. It is just an general idea I though about and want to confront this with more experienced guys around here. The reason of having data access layer for me is to simplify code. I'd make /api/users just a something like mm lets say a "raw database access with ACL", where you just query database using rest api. You do not ask about specific things like "get my orders that are active" calling /api/orders/active , you just call /api/orders?active=1 or something. That is, the client gets what it actually has to query, you do not have to implement server side route for everything that client has which in my point simplifies whole thing. So you may have /api/data/{some-table-name} routes that are raw db access with get queries, this could be implemented as simple express middleware at once for all models around (I'd just make sure that from user scope, you should only be able to query public informations or one available only for your user). I'll also note that typically REST in data access means that GET queries data, POST inserts new data, PUT updates data and DELETE request deletes data from db. I'd propose to make only GET layer instead. The second layer "command layer" is a layer where you actually "do things" instead of only reading them. It just feels more natural to me as doing POST /api/users/ looks like I'd want my backend to just insert a user into database. While in reality registering an user is actually a series of actions that must be done and inserting user into table is just one of them. A "register" command has to validate if you are able to register user using this data, it should send confirmation email to user, it should add new user into row, perhaps add 14 day trial for user, create logs entry etc. I just feel bad about having an remote database insert with all other actions "hooked" into it, I'd prefer take it as a command, so I am just asking server "hey lets register me with data: {...}" and server will decide that this command involves of creating a new database row. It also solves for me an issue with naming conventions and some projecting headcaches, as "command" is not directly tied to one db table, it is totally arbitary thing that may for example just call some 3rd party api without touching a database at all, or a command may work on a several tables at once. I am not sure if this is a good approach, but for the moment it just feels the most "ok" for me.
[removed]
Emacs. EDIT: on a more serious note, the best editor is the one you: 1) feel most comfortable with 2) learn all the shortcuts for
Maybe you could combine your basic routes. Instead of `GET /api/projects/recent` make a general route like `GET /api/:model/:slice`. Then you could do GET /api/project/recent/50 &lt;- get last 50 created projects GET /api/user/recent/50 &lt;- get last 50 created users &gt; If a property were no longer needed on the view, and I wanted to keep the calls to the DB as lean as possible, I would need to remove that property from the route. Couldn't you do this with `POST` instead? Your sequelize query would basically become `project.find({attributes: [req.body]})`. In that case, your route would only contain the model identifier and the primary key.
"if you never want backend stuff". I can do a lot of backend stuff without PHP, your argument is as invalid as reasons for learning it.
In c# a lambda can be either an expression or a delegate depending on if you expand it to a full block. Expressions can satisfy delegates but not the other way around if I'm not mistaken. Expressions can also be built into each other.... Shit gets pretty crazy sometimes 
I know that people still actively seek to learn php from experience. I don't know why. 
ah thank you , yes im , im kind of new i will try to get better , hope to bring value to this group
&gt; ALWAY PUBLISH COMPILED FILES. Never publish the source. This is a simplistic view of the world. If you are publishing a library, publishing both your source and dist files are critically important. Especially since tools are starting to support tree shaking (removing unused exports). In addition, if you wish to support full dead code elimination and type checking in Closure-compiler - you need the original source.
"Slow loading time" is listed as a negative point for Visual Studio Code. First of all I think they improved a lot in this field in the last few updates and secondly I open up my editor once per session. In my opinion it doesn't really matter if it takes half a second or 5 seconds to load it up if I have a good tool on my hands for the upcoming hours.
Thanks but if you look at the code on this page you will see that the code checks cache version of the static files, I was asking about this step and if anyone managed this in the build process and webpack
I do not know if I should unit test all modules from my backend app or should I only unit test express routes to find if they return correct responses, fill database etc.
&gt; foo::qsa what is that double dot syntax?
I dont mind using jQuery as I am developing with some frontend libraries (mostly Vue now). So I am only using jq in some custom directives and such. Even that I only call JQ directly very few times, it is still to worth including it from jQuery CDN than fuck with browser inconsistencies everywhere.
Why Vim have so much negative votes? There are only 2 cons that actually matter and one of them is fixed by Neovim.
Clever code isn't.
It's from a stage 0 proposal: https://github.com/zenparsing/es-function-bind `foo::qsa('.bar')` is like `qsa.call(foo, '.bar')`. It's a so-called virtual method.
The amount of backend code being written in PHP, Java and C# literally dwarfs the amount of backend code written in Node or Python.
Thats a great idea; generating revenue from your skills early on. I'd wish I did that when I started out too :) 
Hmmm, I'll take a look at those, then. Edit: Heh, kind of. &gt;I firmly believe Dart is already dead but why the hell would you consider moving to the Dart team a bad career move? . &gt;So what? TypeScript and Babel/ECMAScript 6/7 ate its lunch. I am pretty sure Dart cannot capture the larger community. Of course Google can use it internally as much as they want but this is like getting excited about ABAP. . &gt;This article actually managed to get me interested in Dart. I'll be trying it out this weekend. . &gt;HAH. I realize you're joking, but I'm highly dubious about Dart too. If Google thinks Dart is right, why the heck is Angular 2 based on TypeScript? . &gt;Dart is dead. Long live TypeScript (says Google) (downvoted) I guess it's fair to say it's changed some minds, but imho these conversations sound like any other conversation about dart.
"Recommended" should really be "Popularity" without downvotes. As it stands it's really just mis-labelling popularity.
It's a combination of "--variable" and "!expression" While it is shorter to say if(!--pending) { doSomething() } than pending--; if(pending === 0) { doSomething() } The latter is much easier to understand with much less effort. * No need to understand that a decrement operator before the variable is different than a decrement operator after the variable. * No need to know JavaScript's version of numeric truthiness. So a beginner programmer (or just new to JS) can come maintain your old code while you are freed up to go work on new and more interesting projects. Otherwise you're stuck maintaining this junk forever.
&gt; Often people claim that google is giving up on Dart Are you sure they are saying this exactly? I sometimes say that Dart has failed, and when I say this, I am referring to Dart's original goal: to be the "sane alternative" to javascript that ran natively in the browser. Needless to say they have not achieved this goal, and put out an article not too long ago saying they were giving up on doing this. &gt;The Dart team has been working on this, the dart2js compiler that creates reusable javascript is still experimental, but this compiler will surely be released somewhere this year. If the angular team couldn't rely on this on a hot new project they expect to last for years, then I don't see why I should either. I know you may have some inside knowledge on this that makes it easier for you to believe, but from where I'm sitting, either dart wasn't good enough for the angular team or the angular team made a horrible long-term decision based on short-term problems. &gt; So the angular team decided to create a language, called AtScript, that could be used to generate javascript and Dart at the same time. Smart move! This was arguably one of the largest mistakes the angular 2 team made when announcing angular. &gt; The funny thing is that people thought that google gave up on Dart when angular announced Atscript, but the truth is, they created Atscript in the first place, to support Dart for angular 2. This, combined with the fact that google does not have a very good track record with these tools, and that *they already did this* with GWT -&gt; Dart. There's some more context here. - - - Overall, I don't believe that the general opinion is that Dart isn't a good language. It is a good language. It doesn't change the conversation at all to talk about how good Dart is or how useful dart is, or how hey did you know Dart can run on embedded systems? I, and many others, just don't see Dart capturing the javascript community in the same way Typescript has. Moreover, even if Angular 2 were to use it, it's not necessarily going to mean it'll be a big deal either, since the current trends are more towards react, where using Dart is much more of a hindrance than a help. 
I don't think unreadable JS would have been as big of an issue as you suggest. React's source is pretty tough to read or step through, but it's easy enough to use as a black box.
Another option: the beginner programmer, reading the criptic incantation, learns about unary pre-increment operator, unary logical not operator, operator precedence, type cohercion and expressions, very basic notions that will make them a bit less beginner.
Hello, Henry. I have developed several APIs and I am active member of several API meetups. In first place, avoid the temptation to tailor your API like a suit for your web frontend. Well done coming here and asking for good practices. I think your second approach is the winner and could work well if you follow REST practices. The **"/recent"** resource is a bad idea, IMHO. In first place, **"recent" is not a valid REST resource**. You can check if something fits under resource category because it is a noun. Recent is a adjetive and it place could be a query selector. In second place, what you are saying is that "project" have a subresource "recent". **What will happens if you want to add a "recent" property to your project in the future?** How will you be able to access it? I suggest you the following schema: **GET /api/v1/projects/?by=date;order=desc;limit=50** Which will lead you to develop a generic sorting system. If this is too much hurdle for you, go for: **GET /api/v1/projects/?lastest=50** This could work well and will give you no conflict, but if you abuse from specific query selectors you could end having too much. *Extra tip: Add versioning. Choose if you prefer placing it in domain name or base path, but do it to avoid future hurdles. Others do in "headers". I suggest you against (ask if you wonder why, I just don’t want to overextend)*
I used to be excited for dart. But if they can't convince the chrome team to embed the VM in the browser then it's dead.
Believing that Google will always use Dart so making the move is a good career move is naive. Never gamble your future as an engineer with your future at any one single company. I think the fact that Google is committed to Dart is a good argument for why a company might integrate it into their stack. But it makes a poor argument for why someone at Google would want to focus on it (at least in terms of that persons long term marketability as an engineer). 
scanning the arguments against, it sounds like it is all about popularity/fashion...
You need to understand that the Chrome team has different goals - that includes removing all levels of indirection between the DOM and the interpreter. Either they bake in Javascript or Dart, there is no room for both without the indirection.
It'd be more like if Typescript was announced and it said "The goal of this language is to replace javascript in the browser natively" and then announced some time later that it wasn't going to do that, and instead it was going to just compile down to javascript. Sure, it may actually be a good decision, but it still makes you question why it was even announced in the way it was and why it running natively as a VM was so important if it was just going to be thrown away anyway. You cannot deny it's going to make some people second guess the language and its management.
What are those cons? And how does neovim fix one?
By the way, I am always interested in talking about API's and JavaScript development (whatever it's back or front) with other people with curiosity. If you want to, feel free to PM me.
If you don't need legacy IE Support then you can pretty much do everything natively combined with some kind of framework to handle state, combined with smaller libraries to handle specific functionalities. Thinking less about direct manipulation of the DOM and more about state management that does it for you will make your code infinitely easier to think about. In 2016 the cons of jQuery outweigh the benefits; not maintainable, too bloated, not performant. But in jQuery's defense it's a really easy to start learning Javascript with it (which is exactly what I did). 
IMHO the second layer APIs seems more RPC than REST. These resources ("purcharse-product", for example) clearly look like remote actions. You can follow this path and have everything ok. There is a lot of APIs working with RPC. The problem is the number of resources that you will have at the end. Compare a simple users API: **RPC:** * /get-users * /get-user * /create-user * /update-user * /delete-user **REST** * /users (GET, POST verbs) * /user/id (GET, PUT, DELETE verbs) You have the same number of routes, but not the same number of resources. The second approach is a lot more development-friendly. They have to learn less resources and the actions are already defined by REST conventions. By the way: Exposing your db data directly by API seems a little bit strange to me. If you need this consider CouchDB to avoid developing an extra layer. What I usually do is following the "MVC" (V is JSON/XML) pattern in backend. Expose your data to your controllers through "fat" models. Let your API be consumed through controllers which handles the request logic (authorization, status codes, etc).
"replacing javascipt" is implied by saying "run natively in browsers", since if you run natively in browsers, that's what you're doing. 
"Popularity" is not an endpoint. Your analysis stopped before it even started.
Just use concatenation. for(var i = 0; i &lt; 3; i++) { console.log('foo-' + i); } Output: foo-0 foo-1 foo-2
&gt; If the angular team couldn't rely on this on a hot new project they expect to last for years, then I don't see why I should either. The difference is, are you making: 1) a javascript library, you want javascript devs to use, or 2) do you want to make an app, that is used by users in the browsers? For 1). Dart was not a good option, is not a good option, this will change, but Dart will still need to prove itself here. For 2), I think Dart has proved itself here. many projects have used Dart for this. I used it myself, and especially in combination with Angular2, I think Dart does a great job here. I wouldn't want to use something else. If you prefer react with ES6 or whatever, sure, use it. But I don't think angular2 using typescript proves anything here.
Tried Sublime2 &amp; 3 for time, than moved to Atom b/c Im a fan of open-source software and then my back-end mate convinced me to start using vim. From the time I learned it I finally have this feeling that I dont ever need to reconsider text-editor in my life. All I need to do is update my .vimrc.
Well then it seems like your statement: "I'm open for code hints and ways to improve it." is false from the way you are treating suggestions.
I'd forget about Browserify and determine if you want to use JSPM or Webpack. Personally I couldn't be happier with JSPM.
I think it really depends on what you are building. Do you think for web apps Chicago style is better?
I feel like you are jaded about something regarding facebook and possibly missing out on some useful technology. You might have your reasons but I recommend trying out a react + redux implementation before forming your opinion if you havn't already. It's a joy to work in and being able to create self contained components that have everything they need in a single file for portability it's pretty fantastic. Not saying you are wrong, I just had the same impression of react at first as well, especially the idea of JSX, but I tried it and now I get it and it's my go to choice. 
No, that's not what it means at all
Last I heard, @staltz said Cycle can render to React?? ...code is looking really good. I absolutely love how you're combining observables (passed in as a parameter) with something that at least looks like React in the declare/view block. I still need to dive into your code more, but a natural progression that incorporates the best of Cycle, Elm and React but for javascript seems to be evolving! You should write a Medium post like next week describing your explorations. It doesn't need to be a grand definitive release, but rather describes you're thinking. Your code is very nice, and I really think there is something there. Basically you solve 2 main issues: 1) Cycle's observable-only approach isn't accessible 2) Elm's Haskell-like language isn't accessibe lol. But both approaches use observables, which is a higher quality abstraction than the hacks to force updates that React uses. Cycle in fact might still be the one true way, and we just aren't accustomed to it--so I could be wrong here in promoting Elmish--but either way still being able to use *onClick* handlers is fucking key. That's an old school abstraction that both Elm and React have kept around for a reason. And I don't think it's that evil, especially in how you intercept event output via observables and transform it into state. That's money!
Where do you see he's already reading a bunch of blog posts? 
Popularity is important, it's one of the reasons I don't recommend something like mithril without strings attached, even if I quite like it. But I think you can characterize the arguments against dart in a few ways: ## Not different enough to impress Dart aims to be an uncontroversial OOP language with vaguely java-ish syntax. No part of this is appealing to me, but if it was, I would find the optional types undesirable. It doesn't have the simplicity of coffeescript, the portability of ES6, the functional aspects of livescript or elm, or the heritage/community of funscript or other off-language compile-tos. It's just Java-ish. Of course, that could be a good thing if you like Java, but a lot of what I want from Java already comes from ES6 classes and arrow functions. ## Questionable JS interop For a while, using JS code from dart looked like this: var googleMap = new JsObject(context['google']['maps']['Map'], [...]); (from [here](https://www.dartlang.org/articles/js-dart-interop/), on the dart website itself, in case you think I picked an unflattering example) This is easily worst-in-class interop. I've been told this has been improved, but this is what made me ignore dart full-stop initially, and you still have interop issues if were to make a library in dart that you want javascript users to use. You don't have this problem with most other compile-tos. Not even elm! ##Questionable Longevity This is not entirely fair on Dart, but it's from Google. And google's track record here is *not good*. I'd honestly avoid Dart just on the basis that Google *already* had a project, GWT, which does a lot of the same things. But instead of adapting that, they trashed it entirely and started from scratch. This scorched earth strategy is very common from Google, and you can see it in other places, such as Angular 1 to 2. There's also the fact that google itself appears unwilling to use Dart when it seems like it would be a good fit, going so far as to make atscript to avoid dart when it came to Angular 2. And, of course, Dart was supposed to run natively in browsers, and was announced not too long ago that this goal had failed. This also doesn't reflect well for its future. ##Significantly different from Javascript This is not a problem unique to dart, but it's a problem that even *Typescript* has, which is essentially ES6 with type annotations. The more different your code is from javascript, the more it makes a lot of JS devs uneasy. Even with sourcemaps, it complicates debugging and requires tooling to even begin to use. You'll notice this is at odds with "Not different enough". My theory is your language either just has to be javascript + *something*, or so totally different that the benefits you get from using it outweigh the debugging+tooling cost. ##Popularity Yes, popularity is a problem. Compared to typescript I think it would be fair to say that dart is less popular, something which is only going to get worse as angular 2 gets more popular. Typescript is so popular in fact, that Dart can even leverage it to type against your javascript code, which begs the question again of why using Dart at all. - - - It's important to keep in mind that not all of these criticisms are **entirely fair to level against Dart** (there might even be some [good reasons](https://www.reddit.com/r/javascript/comments/406q92/why_im_joining_the_dart_team_of_all_places/cyrxxqo) for some of these problems), or even **worth talking about anymore**, but I don't think it's fair to say that people are arguing against Dart just because it's *not* the flavor of the month.
I'd opt for (--pending === 0) More clear than the original and no extra lines. 
Atom has gotten noticeably faster in my experience. Still slower than I would like it to be, but has been getting faster. 
This is a timer that counts down from 5 minutes to 0. I learned a little bit about the setTimeout and setInterval methods to make it. Planning to add a second timer that counts down from 20 minutes to make it a "pomodoro" style page, and at some point save information to a database so I can keep track of how many Pomodoros I do. http://gbuilds.github.io/timer.html When I first made the timer there was an interesting (to me) bug where each click on the button element would start a new countdown function... so the timer's value would jump around wildly. Yes, I am not very good at Javascript yet :)
I don't mind the discussion at all but you're just making up crap about what he/she has done unless you personally know the person. 
The very act of forcing a log in before seeing a product makes me close it immediately.
(! --pending) makes it easier to understand?
I figured out what the issue was client.monitor(function (err, res) { console.log("Entering monitoring mode."); }); client.on("monitor", function (time, args) { console.log(time + ": " + args); }); The fact I was monitoring Redis for events was the reason everything got screwed up, the Value got passed to the monitor instead of the get function. So I removed it
Cool! I recognize that it's not complete, but one of the clouds obscures some of the text under the button... all I can see is "LEARN ABOUT HOW MARIOMAKELY TAGGING". Also, is that text supposed to be a link? Because I haven't learned much from just doing a search, and I don't see anything pertinent below the fold. Other than that, I like the presentation of the search. I'm not sure if I'd like it on a larger website, but for a purpose-built site like this, it seems to work rather well as a single pattern for both desktop and mobile.
This is the typical way I've done it in the past. But GraphQL or a query language like it would allow not having to change the backend when changing the frontend or vice-versa. That is a nice win too as you can decide how many different XHR requests you want too. That means if one data set is a bit slower, it can be pushed off to a separate request. Or if content is loaded that is out of sight/inactive, it can be requested after the primary content request. The data mining point is a good one but I think for most, the benefits of decoupling are worth it. Making development much harder purely to avoid mining seems a bit pointless as if someone wants to mine, they'll do it no matter how many roadblocks are in place. But of course there is likely a flip side where the domain makes it necessary. The other facet is really the mining issue should be pushed off as a separate concern. You could use something like GraphQL but have another system that is responsible for monitoring how the API is being used and disabling/throttling/notifying based on suspicious behavior. That seems more robust in the end too.
You're the one making assumptions as we have no information as to whether he/she read articles on the subject. I'm simply calling you out on YOUR assumption.
It would be incredibly hard to replace webpack with npm and node scripts 
Hi /u/OpenSource-Express, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `opensource.express`. Thanks for your consideration!
But npm isn't a build system. It's just a set of scripts. If you can get away with that, you didn't need a build system. A lot of us have complicated things happening at build time that are significantly better with an extra tool. 
Some people, when confronted with something they don't know, make an effort to learn on their own. Some people are weirdly helpless and have to ask.
Well graphQL *could* replace REST in your app, but it doesn't have to. With REST you need a lot of different endpoint for fetching different parts of your database. With graphql you can ask for the specific fragments of the data you need on the client through a single endpoint. They're not exclusive to eachother, you may just find that with graphql you won't need as many restful endpoints.
Thanks, I didn't know this. You're the man!
&gt;Just because java ran inside browsers doesn't mean it was replacing javascript, just because flash runs in browsers doesn't make it a replacement for javascript. ??? Yes, yes it was. That was the specific reason to use java applets or silverlight. You wanted to replace javascript with something you found better. Flash is a little bit different in the same way a movie player is, but you still had people making entire websites in it to avoid javascript and HTML. In fact, java applets were specifically designed to replace javascript for good. People didn't think javascript was going to stick around.
What do you think of recommending use of [pre-commit](https://www.npmjs.com/package/pre-commit) to ensure that things are compiled and tested before they are committed?
I have been building a site aimed at electronics hobbyists: [kitnic.it](http://kitnic.it/). It's a work in progress obviously. Would be happy to explain more if anyone is interested. I learned to use React for it which has been pretty fun. The whole thing is [open source ](https://github.com/monostable/kitnic) and compiled to a completely client side site deployed to GitHub pages. I tried a lot of build system frameworks and didn't like any of the usual suspects (Grunt, Gulp, Jake etc). I normally stick to Make but for this I have been happily using [ninja-build-gen](https://www.npmjs.com/package/ninja-build-gen) and [Ninja](https://ninja-build.org/). I configure the build using Coffeescript and most of the build tasks themselves are also in Coffeescript running on Node.
Great point!! If you are interested in contributing then submit a PR, otherwise I can probably add one tonight.
In total agreement with kcdwayne on this. I have used grunt and gulp on big production apps and dabbled with webpack. And now I ONLY use npm scripts. It is way easier to understand and my builds are more reliable and faster. Most people don't need more than a few npm scripts for their build process, and you can even just pull the more complicated ones out into a bash script that runs the actual steps. I am about 6 months into no build tool and am loving it!
Sounds a bit like what I read about ruby a few years back from some people comparing it to PHP/Python/Java.
I wish developers would use more parentheses. I'm all for succinct code, but ffs make it readable. if (!(--foo)) {} Although it's a bit frustrating to see this in JavaScript, since it's a very lazy way to evaluate a condition, and downright disallowed in other languages. This is much more clear. if ((--foo) === 0) {}
I always recommend [Secrets of a JavaScript Ninja](http://www.amazon.com/gp/product/193398869X/ref=as_li_qf_sp_asin_il_tl), which has been a great tool for me to learn some of the intermediate to advanced JS stuff. Covers some basics too, but is mostly for learning the deeper stuff. I like it a lot. 
While it's true that all of the latest versions of the major browsers are evergreen, there is still a big chunk of the web that's running on older versions of IE, etc.
You can miss the point by giving a point-by-point rebuttal too, yes. /u/spfccmt42 said that they only saw people arguing against Dart because it wasn't popular or fashionable. There's plenty of other reasons that people have, and I listed quite a few. Not all of them are accurate or worth talking about anymore, but it's just not correct to say that they don't exist.
&gt; What would be the best approach to doing data binding right? Probably not the answer you're looking for, but: Not doing data binding at all, and instead using a more React/Flux approach. There's a reason why this approach is taking the JS world by storm. Failing that, I guess using getters and setters, although as you note that gets quite awkward.
Finding intelligent information on how the loader spec and NodeJS will co-exist has been extremely difficult. Now if I could just find decent information on the progress of the spec...
Meteor runs on top of Node.js and moves the application logic to the browser, which is often referred to as single-page applications. The same language is used across the entire stack, which makes Meteor an isomorphic platform. As a result, the same JavaScript code can be used on the server, the client, and even in the database.
You're either misunderstanding or being extremely uncharitable in your interpretation and playing word games. Clearly by "replace" he means replacing from the user's perspective: meaning the user can use it **instead** of javascript. Most reasonable people didn't think Chrome was going to delete every line of its javascript VM code. Now, whether failing to "replace javascript" is a significant mark against Dart's success is a whole different argument.
No I'm saying that it was always the goal to have dart and JS code running at the same time in the same app (even when they were trying to get the dart vm in chrome). While you could make a 100% dart app, the goal was to allow significant JS interoperability, meaning work alongside JS. Dart (and web assembly) want to give a choice of another language to write business code in, but not replace JS at all.
VANILLA FTW!!!! Serious note: The less people have to learn to get going the better. This is what made the web great to begin with.
Do you have any public repos where I can copy what you've done?
Honestly, after years of working with Java/C# and JS, I want to go as far away from the old school Java/C# class-based OOP as possible. Google leans heavily towards OOP and imperative programming in ALL of their languages and projects. IMO, Go is the best thing in that vein that has come out of Google (sort of). Still imperative OOP, but ditches most of the boilerplate you see in C++, Java, and to a slightly lesser degree C#.... but, in general, there are so many other interesting languages/concepts/paradigms/etc. out there now..... JS is evolving rapidly, and so are languages in general... we have really interesting things like Elixir, Elm, ClojureScript, Rust, Swift, etc. becoming viable now. I just don't see the appeal of Dart.
&gt; It confirmed my long time suspicions about Gulp and the like. You might have some confirmation bias, there. :) Grunt gulp etc weren't just invented for no reason. If you're just doing very simple things, you can obviously right-size your solution.
Thank you for your opinion. Actually I agree with you, I was working a bit with Node.js server application and I really dont like it. I learned a bit more about Angular and I really do like it but I strugle to imagine how you can actually build a big application using only Backbone, it seems to be really simple.
I learned a bit more about Angular and I really do like it but I strugle to imagine how you can actually build a big application using only Backbone, it seems to be too simplistic and lacking features. Do you have any opinion on that?
It really depends on what piece of a web app you want to test. Each style has good applications and bad. Over use of either is counterproductive (dogmatic use of any tool or method is, really). London style often results in very rigorously tested code, and makes extensive use of dependency injection. Detroit style takes a few steps back and just cares about results rather than exactly how a method/class did it's job. This can save time, but can also result in indirectly retesting the same collaborators multiple times, which leads to redundant test cases. However having higher level tests that check several systems together is also valuable. It's all about judging the tradeoffs for each scenario.
Webstorm is amazing, it's got so many hidden gems and when you uncover them and all the short cuts, developing becomes so fast.
I heard it was fairly slow in some cases though.
You pay the cost of modules one way or another. JSPM and requireJS both work by requesting files through HTTP as they're needed. This is indeed quite a bit slower *at load time* than how webpack or browserify would do it, but as a consequence you don't need any file watchers or even a build step. When you go to production, you can "optimize" both into one bundle. 
Well I've built plenty of systems with both and read plenty of articles on both sides. My point is that npm are just scripts. If you only need simple scripts then you didn't need a build system to begin with. My biggest use case at work is a shared build system. We have dozens of similar sites, and they all require the same build steps. I could copy paste code, but with gulp, I can actually share the entire build system. Even with npm, I'd have to copy paste the package.json then instead.
.star-item:first
Are you serious? Flash and Java were both used because people didn't want to use javascript and/or javascript wasn't powerful enough at the time. They were definitely to replace Javascript, that was their entire purpose.
I've never seen this and it's unreadable. If this is trying to cast to a boolean why not do !!pending ? Or check pending===1.
Also, npm scripts often are not OS agnostic whereas most other options are.
Well, it's just a chart listing out features, so it's easier to spot any bias than it would be prose. Still, doubt you'll be able to find all that much that is totally unbiased about this kind of thing.
vim
What does it do! It fails any sensible code review for being far too clever and far too unreadable without a context switch. 
nice article
I looked at it once and it looked, in my admittedly limited experience, like Java. At the time, I thought of it as an alternative to JavaScript and an alternative that looked like Java was not something I envisioned being interested in. Many of the reasons given in this piece are subjective and it's tough to evaluate how relevant they may be to someone outside of Google, but the one I found most tricky to do anything with was the "it just feels right to me." I have a similar feeling about a completely different language but this feeling probably has no value to anyone else.
Can someone ELI5 WebAssembly?
These things change all the time, it is never too late if a good argument is made. Maybe gh-pages or js.org? Ill go through putting something up on js.org and see if I can recommend that with an easy enough process. 
&gt; much faster than running JavaScript Is it though ? V8 JS is pretty fast
Web Assembly is a binary format for a static formal language (derived from asm.js, which is a subset of JS) that can be fed into JavaScript engines (that support it) to create fast executables. The formal language is higher-level than bytecode and therefore easier to evolve. The output lives inside the universe of JavaScript and therefore integrates well with it. Given how fast asm.js is, C++ compiled to Web Assembly will run roughly 70% as fast as when you compile it to native code. Web Assembly will probably eventually get support for JavaScript OOP. At that point, it will truly be a universal virtual machine for the web.
But a beginner is still likely to confuse whether pending gets decremented before the check for equality or after. Fewer lines of code saves nothing in the long run and "plain as day" code has lasting value.
&gt; IMO, Go is the best thing in that vein that has come out of Google (sort of). Still imperative OOP, but ditches most of the boilerplate you see in C++, Java, and to a slightly lesser degree C#. I've used all of those and Dart is actually the most terse and the most amenable to a light, functional style. Yes, in Dart every object is an instance of a class. However, that does not mean all *code* has to be inside classes. You can write top level functions and slap together objects just like you would in Scheme. Anonymous functions are common, have nice lexical scope, and have the lightest syntax of any of the above languages.
&gt; There's also the fact that google itself appears unwilling to use Dart when it seems like it would be a good fit, going so far as to make atscript to avoid dart when it came to Angular 2. For what it's worth, every team I know using Angular 2 in Google is using Dart. Angular 2 [supports TypeScript, JavaScript, and Dart](https://angular.io/docs/dart/latest/quickstart.html).
Knowing the difference between `--thing` and `thing--` is pretty basic imo, but to each their own.
Why? Can't jspm pre-transpile on the server?
What's your opinion on GraphQL. Is rest "dead"?
Note that HTTP2 is actually happier with lots of tiny modules that are fetched in bulk as-needed.
If you want to maintain the line-breaks (\n), you need `white-space: pre` or `white-space: pre-line`. https://jsfiddle.net/wcu2gytg/ https://developer.mozilla.org/en-US/docs/Web/CSS/white-space Alternatively, you can output `&lt;br&gt;`s. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br
&gt; You can use any(mostly) language You can use C or C++ and soon-ish also Rust. It's currently not a good target for managed languages like C# or Python. You basically get a large typed array as RAM and you can do arithmetic. That's pretty much it. It's a low-level compile target. In the future, it will support things like multi threading (with shared mutable state) and SIMD. It will also compile to ES6 modules which look and behave like any other module. So, using some Wasm physics or game engine will be like using any other kind of library. That's a pretty big deal, I'd say. Making Wasm a better target for other languages (GC etc) is on the road map, but I wouldn't hold my breath. I expect that this will take at least 2 years and I have absolutely no idea how well it will actually work.
Chrome and node use v8. Do you know what other vendors plan to do?
WebAssembly can be thought of as a core subset of Javascript. Javascript runtimes (such as V8) are already blisteringly fast, but they have to support all this old nonsense that's stuck around with the language for the last 20years, and that means slowdowns. WebAssembly throws away all those old parts, and keeps the ones that the runtime knows how to run at light-speed. And it's done in such a way that means other entire languages can be run on WebAssembly which otherwise would not be compatible with Javascript. An example is running programs written in C on top of WebAssembly, essentially making WebAssembly the run-anywhere virtual machine that Java always longed to be, but required you to learn Java (_eww_). _edit_: I'm well aware the above isn't 100% correct, but I'm Explaining Like OP's 5. All the other ELI5's were very technical in nature and required understanding of what ASM.js, etc, is.
How does WASM compare to Adobe Flash/AVM bytecode from ActionScript 3?
&gt; Also i don't want my css injected trough js. Then why do you do it? You have to opt in for this behaviour - you have to specifically configure webpack with style loader to do this. Anyway, if you want to use Webpack to bundle your CSS, you can use [extract text plugin for webpack](https://github.com/webpack/extract-text-webpack-plugin) to split the CSS out into a seperate file.
I used to write CoffeeScript all the time - but I find it quite hard to read these days. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu i + 1, dish for dish, i in courses wtf is that. It's much more readable in plain JS. var courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; for (var i in courses) { menu(i + 1, courses[i]) } ES6 (with Babel if need be) is as if CoffeeScript was merged back into master, and solve many of the annoyances that CoffeeScript solved years ago. The difference being that ES6 lost all of the ambiguities and vagueness that CoffeeScript comes with.
I do not understand why someone would choose CoffeeScript over Vanilla JS to write code faster. In my experience, actual coding is only a small fraction of programming, meaning that in reality it saves you an insignificant amount of time if you write code slightly faster. ES6 introduces most of the shorter syntax anyway.. Plus, the Javascript example for a loop is purposely bloated to make CoffeeScript look better or what? courses.forEach(function (dish, i) { menu(i, dish) }); I understand CoffeeScript can be used for the different syntax if you're a fan of Python, but I really don't find it any easier to read compared to traditional JS. But maybe that's just experience.
I think that is a really good point about working in a JavaScript environment. I have connected up apps to backends I have build but they have also been shy on heavy frameworks
What we'll see in my opinion is not that you'll write, say C++ and compile it to WebAssembly. Rather we'll see a lot of languages like TypeScript, CofeeScript, Dart, ... come up, that use WebAssembly, that eventually will replace these very-close-to-js languages. You'll then write in [nextAwesomeThing].wasm that will be made for webdev and interacting with the DOM. 
Not quite. WebAssembly is a byte code through and through. You are probably thinking of ASM.js which is just a subset of javascript. Initially, WebAssembly is going to support all the same features as ASM.js without expansion. Initial implementations of WebAssembly will be using a ASM.js interpreter poly fill. However, it is expected that eventually WebAssembly will diverge from javascript limitations all together. From what I've read they are thinking about adding support for things such as threads to WebAssembly.
&gt; so the chromium team has just accounted for the most popular ones or all of them? They support x86, x86_64, ARM, and MIPS according to the official site. There appear to be unofficial ports to PowerPC and s390. &gt; what is that in reference to if not V8? It's imprecise writing, primarily because it conflates a language with a particular implementation of a language. Generally speaking, there are a variety of potential approaches available for implementing a language, forming sort of a continuum: interpreted &lt;-&gt; just-in-time compiled &lt;-&gt; ahead-of-time compiled Moreover, there can be any number of different implementations of a given language, and they can live at different points along that continuum. For example, you could create an implementation of the JavaScript language that was purely interpreted. That's the strategy that nearly all implementations used for the first decade or so of the life of the language, from 1995 to roughly 2008. You could also create an implementation that primarily uses interpretation but also uses just-in-time compilation for portions of the program identified as being performance critical. Or you could write an implementation that uses JIT compilation for everything. If a language has, say, five major independent implementations that all use different execution strategies, some of which involve interpretation and some of which don't, can you say that the language is interpreted? You can't say any such thing, because a language is not the same thing as an implementation of a language. What interpreted really means here is "not ahead-of-time compiled", like languages like C or C++ (although, again, [that's using messy and imprecise wording, since there exist interpreted implementations of C and C++](https://root.cern.ch/introduction-cint).) Or alternatively put, JIT compilation is often lumped in as a technique used in writing what is called an interpreter.
Don't use map for side-effects. You don't actually intend to create a courses-sized array filled with `undefined`, do you? Use forEach instead.
This is pretty anachronistic. There are still people moving *to* CoffeeScript?
For typescript and cofeescript it would make very little sense to use webassemly, since that would literally have no benefit, and just breaks the language, since they are just sugar on top of js. Dart on the other hand could use it. My main concern is more languages like Scala and Haskell, since their standard libraries are huge, (although it's not so bad with Scala).
How new to programming are you? Was going to recommend a better solution than a for loop.
The examples (except for the object literal in example 5) are laughably misleading, so here's a more honest look: # Example 1 Strawman: if (typeof elvis !== "undefined" &amp;&amp; elvis !== null) { alert("I knew it!"); } CS: alert "I knew it!" if elvis? Idiomatic ES5: if (elvis) { alert('I knew it'); } # Example 2 Strawman: var square; square = function(x) { return x * x; }; CS: square = (x) -&gt; x * x ES6: let square = (x) =&gt; x * x; # Example 3 var x = 10; var y = 20; var z = 30; var res, res_final; if(x &lt; y &amp;&amp; y &lt; Z) { res = "Y is in between X and Z"; } else{ res = null; } res_final = res ? res: "Y is not in between"; CS: x = 10 y = 20 z = 30 if x &lt; y and y &lt; z res = "Y is in between X and Z" else res = null res_final = res if res else "Y is not in between" ES6: let x = 10; let y = 20; let z = 30; let res = null; if (x &lt; y &amp;&amp; y &lt; z) { res = "Y is in between X and Z"; } let res_final = res || "Y is not in between"; # Example 4 Strawman: var courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; // menu is some function for (i = k = 0, len1 = courses.length; k &lt; len1; i = ++k) { dish = courses[i]; menu(i + 1, dish); } CS: courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu i + 1, dish for dish, i in courses ES6: let courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; for (let [i, dish] of courses.entries()) { menu(i + 1, dish); } 
I'm not sure I understand what you need, but if you want stuff where "the whole thing just sorts itself out" maybe you'll like the next gen stuff like Falcor or GraphQL, where data is sorta the data model itself.
I frequently use packages but perform some sort of transformation on the source prior to consuming them. I also wish to utilize the ES6 source and not the Babel transpilation.
Not close to true anymore. You can write code in groovy, scala, clojure and it will run on the JVM. This has been true for half a decade. Please don't spread old misinformation. 
You've forgotten to define some function for _menu_: menu = (a, b) -&gt; console.log a, b courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu i + 1, dish for dish, i in courses And in your JS example, you're declaring an iterator called _index_. But inside the loop, you refer to an undeclared iterator called _i_. ES5 Fixed version: :P var menu = function (a, b) { console.log(a, b); }; var courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; for (var i in courses) menu(+i + 1, courses[i]); ES6 version now. It can be copied &amp; pasted &amp; run in any updated Chrome &amp; Firefox family browsers: :-D (() =&gt; { "use strict"; const menu = (a, b) =&gt; console.log(a, b); const courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; for (let i in courses) menu(+i + 1, courses[i]); })(); 
Just a heads up, interaction with the DOM will not be possible with wasm any time int the near (or even somewhat far) future. It's the very last thing on the list of "might do one day" things.
How many times a week does someone on reddit ask this quesiton?
Oh that was just the very top of a much larger object, I just wanted to destructure variables from the object I was working in, just to save myself writing long objectNames.beforeMyVariables or doing things the old way with a load of of assignments. Anyway thanks to your link I saw that destructuring is basically just variable assignments so I tried this: let myObject = { red : 'redc', start : function () { let { red } = myObject; console.log(red); } }; myObject.start();
Anecdotal, i guess. I've never seen anyone suggest using it for general purpose programming, nor have i ever run into an app/tool that i wanted to download that ended up being written in it. I've seen it suggested as a better JavaScript in professional circles a couple of times, one of which was by a Google employee. Their website certainly stresses it's use as a web dev platform, and most of their tutorials are to that effect. That being said, I wouldn't use JavaScript for GP programming either, there are simply far too many better alternatives. I think you're way off on the tooling front. There are dozens of ides, editors, build tools, linters, optimizers, and frameworks. Literally hundreds of actively supported tools. You have far more choice in environment and workflow in JavaScript. 
What for you mean slow?
What a plot twist. Finally web developers aren't forced to use JavaScript...but ES6+ and the JS eco-system have become good enough that many / most will continue using JS anyway. 
I mean the tooling you get thanks to type annotations and type inference. This demo, for example, is fully typed thanks to that single "as CanvasElement" type cast at the very top: https://dartpad.dartlang.org/e23e4d137570c652591e Everything was auto-completed and everything is type-checked. Another example: http://i.imgur.com/PMSSG18.gif http://i.imgur.com/HYDGFvx.gif The tooling is similar to the tooling you get with Java or C#. The difference is that you need very few type annotations and casts to make that happen.
 x = 10; y = 20; z = 30 console.log 'CS still got some more tricks!' if x &lt; y &lt; z
ES2015 is the international standard defining javascript and followed by every browser vendor. Typescript is a language promoted by a commercial company. What to choose? What to choose?
I look forward to the moment when Microsoft scapes off and packages as WASM the top half of visual basic's syntax for an epic "Jscript/ASP NT strikes back" trainwreck.
It's a valid point, but it's never the right one. Hey jQuery isn't even a part of the language, maybe we **shouldn't** use that too. The thing is, valid JavaScript is valid TypeScript, so until they don't allow this, OP should be fine.
I just say that Typescript features can be added to plain javascript on-demand via flowtype. And it works with Babel / ES2015 js
I don't know if it's a requirement, but you should consider not using `document.write`. It's bad way to create output with a lot of trip-falls. It virtually can't/shouldn't be used in any real-life scenario, so there is no point in learning about it.
Damn, and I thought *I* was cynical. 
&gt;I am pretty sure we will never use TypeScript or the features of ES2015 at work Huh? If you are using coffeescript, you're already using some ES2015 features like arrow functions, classes, destructuring. Coffeescript was pretty influential in a lot of what ended up in ES6. Anyway, ES6 is the standard and something you should know. Typescript is a smaller subset of ES6 with type annotations and a type-checking compiler. If you learn typescript, you mostly learn ES6, and if you learn ES6, you will learn most of the typescript syntax - except for type annotations. Typescript is most useful on larger projects with multiple people working on the same code base, or when working with libraries you're not familiar with ("learning by types"). If your team is coming from Coffeescript, it could feel a bit overbearing. Just keep in mind that with typescript, the type annotations are (mostly) *optional*, so you can write TS as if it were ES6 and add types after the fact when your code's API stabilizes. This honestly gives you the best of both worlds. On the other hand, if you're working in smaller projects and you've come to miss the light syntax of coffeescript, there's [livescript](http://livescript.net/) - a coffeescript descendant with less stupid things (like automatic variable scoping) and more useful things (like function composition, piping, and partial application).
courses.forEach((val, index) =&gt; menu(index +1, val)) More readable in es6
 class GraphQuery extends Query { static parse(object: any): Try&lt;GraphQuery&gt; { return TimeRange.parse(object.over).flatMap((timeRange: TimeRange) =&gt; { return Filter.parse(object.where).flatMap((filter: Option&lt;Filter&gt;) =&gt; { return GroupBy.parse(object.by).flatMap((groupBy: Option&lt;GroupBy&gt;) =&gt; { return new Success(new GraphQuery( filter, groupBy, timeRange )); }); }); }); } } Well... interesting is one way to put it.
No, sorry. It's not that complicated though.
It's easier to reinvent the wheel when you have seen one that works. 
This would be a great way to spread malware!
Better to be knowledgable first. Then, you can *choose* to be clear or terse.
its already is
Routes are a way of answering the question "for a given request to the server, what code should handle this request?" You use it to say that the server should respond to a GET for 'yoursite.com/abcd' with certain code, and should respond to a POST to 'yoursite.com/efgh' with other code. This might explain it. http://expressjs.com/en/guide/routing.html I'd also recommend just writing and playing around with an express app. I highly recommend either the browser, or just plain old `curl`, to help mess around. `curl` is very valuable, actually; I recommend running `curl -v SOME_URL` and checking out what it tells you.
Kill me
`return new Success(` oh lordy me
Definitely a good recommendation with cURL. Also postman is a helpful app. https://www.getpostman.com/
great, thanks! haven't heard of curl (except when installing stuff on the terminal I think...) I'm currently playing around with an express app. I supposed I've been overwhelmed with new syntaxes (app.use / app.set / app.get) plus lots of functin(req, res)'s. 
[In the future, this will be natively supported](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import). Currently, no browser natively implements the spec, however. BUT there are very popular tools like [Browserify](http://browserify.org/) that let you write your JavaScript in modules and compile them down to a single JS file.
If I'm completely honest, I remember enjoying creating small VBScripts back in the late 90s.
No way. GraphQL doesn't handle resource creation, update or deletion. Is just a bunch of vitamines for the "R" in "CRUD". In the other hand, if you are doing APIs which could be consumed by others, is in your interest following common best practices and standards. REST APIs are easy to document (swagger, raml) and consume. GraphQL makes more flexible API data retrieval (which you could already do with [sparse fieldsets in REST APIs](http://jsonapi.org/format/#fetching-sparse-fieldsets)), but in no way it will kill rest.
Be that as it may be, it was just curious to hear you say that Dart had the lightest of the syntax among the languages /u/joshburgess mentioned, when a lot of the languages they mentioned were more on the functional side, while dart has very little to no support for functional programming.
gulp/grunt are not build systems either. They are just tasks managers. 
Probably around the same time you were eating paste in school, right?
You can code a local web server to serve your html. I did that in C: http://rodrigofcosta.net/#Programs
Right, but you make a build system with those tasks. They're a step more complicated than just scripts though.
I did as well, but the keyword is "small". The language is like the stereotypical gateway drug, except VB skipped everything possibly fun about drugs and just went to hell as soon as you got to "I should put this part in a module so I can re-use it."
What do you have loops in your webpack config for? 
You can accomplish what you want with QtWebKit.
Yes, database, service, files i/o. Just want to use js (html, css) just as GUI. Python to do the rest of work. 
Memoize Forces you to have pure functions and improves performance
Same thing with brs: https://jsfiddle.net/wcu2gytg/1/
&gt; so typing in: localhost:3000/thisisarequest is making a request - and you need to set up a corresponding route to appropriatedly deal with that kind of request? Yes. Requests aren't just page hits though. Typing something into the url bar and hitting ENTER will request a page, but that page can also run JavaScript to make requests, or it could contain an html form that POSTs data when completed, or an &lt;img&gt; tag that refers to an image... etc. these are all HTTP requests.
The `Success` part is actually the least of my worries. Just that it was written in a way that seems to be intentionally verbose, indented, and hard to read. So let me rewrite it a bit with some assumptions that they have a vague idea of `Maybe&lt;T&gt;` and wrote it in a way that makes sense in javascript. I don't use `flatMap` since they're using it as a kind of `bind` which doesn't make a lot of sense without syntax support. class GraphQuery extends Query { static parse(object: any): Try&lt;GraphQuery&gt; { const timeRange = TimeRange.parse(object.over); const filter = Filter.parse(object.where); const groupBy = GroupBy.parse(object.by); const failed = [timeRange, filter, groupBy].filter(x =&gt; !x.success); if (failed.length) { return failed[0]; } return Success(new GraphQuery( filter.result, groupBy.result, timeRange.result )); } } But it still doesn't look right to me. The fact this is in a class as a static function with *no* class members is even more weird to me - it screams that someone came from C# or Java and has no idea that functions can be bare in javascript. If we write it more idiomatic es6/ts, we end up with something that doesn't look all that bad. I also don't like how little they rely on type inference in TS, so I relied on it a bit more: import parseFilter from "./filter"; import parseTimeRange from "./timeRange"; import parseGroupBy from "./groupBy"; import {Success} from "./maybe"; import GraphQuery from "./graphQuery"; export default ({ over, where, by }) =&gt; { const timeRange = parseTimeRange(over); const filter = parseFilter(where); const groupBy = parseGroupBy(by); const failed = [timeRange, filter, groupBy].filter(x =&gt; !x.success); if (failed.length) { return failed[0]; } return Success(new GraphQuery( filter.result, groupBy.result, timeRange.result )); } With `Maybe&lt;T&gt;`, we can check if the calculation succeeded and extract the result out of it. I assume that they have an `Error` or `Failed` function to go with their `Success`. I assume this function sets some kind of error property on the result object and sets the `success` to false. This is used to propagate the error, which is the reason they were using `flatMap` in the first place. This is less monadic and doesn't use continuations, which could be a problem if those parses were very expensive, but imo it'd have to be pretty expensive to justify how that code looks. If we really need to use it monadically and need the continuations though, we can still do it with a simple helper method that won't make our code look horrible and indent it all over the place: import parseFilter from "./filter"; import parseTimeRange from "./timeRange"; import parseGroupBy from "./groupBy"; import {all} from "./maybe"; import GraphQuery from "./graphQuery"; export default ({ over, where, by }) =&gt; { const getTimeRange = () =&gt; parseTimeRange(over); const getFilter = () =&gt; parseFilter(where); const getGroupBy = () =&gt; parseGroupBy(by); return all( [getTimeRange, getFilter, getGroupBy], ([timeRange, filter, groupBy]) =&gt; new GraphQuery(timeRange, filter, groupBy) ); } (This might look like `Promise.all`, and that's no accident, since `Promise&lt;T&gt;` is also monadic) So really, no matter how they could have approached it, I think with a little bit more effort they could have made it a lot more clean and easier to maintain.
As someone who has written gulp, grunt, and vanilla scripts I can say just any single one out of the three may be more complicated than another. 
Hey @DevSPCL, kind of lacking the time to go into detail with everything at the moment, so feel free to contact me personally on the compound sort issue. As for the more "public" issue, that of performance, the db size certainly influences binary-search indexes due to the fact that binary-search performs an optimized array scan, but unique indexes won't because LokiJS leverages the optimized hashmap lookup feature implemented by the underlying js engines, not sure about all of them, certainly v8 does. Interesting couple of posts here on how performance does not vary on a single object containing 500k keys (which is an insane amount of values): https://groups.google.com/forum/#!topic/v8-users/Ap05Lv4e6no Wish I had a little more time to answer and investigate - beyond the realms of exhaustion just now.
I use angular 2 and I can assure you that they are doing something wrong here. The app is not very performant at all.
Oh, back then I didn't even consider using modules for web coding. I don't think Javascript was ready for module oriented projects either. This was the glorious days of tiny little stars following the mouse pointer, and Perl CGI programming. But more to your point, yeah, I guess I would have gone mad had I decided to use vbs in anything complex.
Yes quite a few people use native ES2015 support without transpilation in production. There's quite good support in nightly browsers and decent support in stable channels: https://kangax.github.io/compat-table/es6/. The Chrome support maps to the current support in NodeJS. Also, Babel is only one transipilation tool. Traceur and Closure-compiler can both transpile to ES5 syntax. Babel supports some uses that don't strictly conform to ES6 syntax and so is encouraging developers to use habits which won't work when the don't transpile.
Thanks, this looks feasible indeed. However, have you heard about: https://en.wikipedia.org/wiki/Chromium_Embedded_Framework ? I've found it like couple of minutes ago and now I'm curious if should try with Qt or this at first.
How the hell did php ever supplant Perl? Did we all take a brick to the head?
Your Example 1 is incorrect; your "idiomatic es5" solution is checking if `elvis` is falsey, not whether it is null or undefined. That's a major source of bugs in JS code (eg, checking for the existence of an optional parameter to a function, get passed on `0`, and incorrectly assume no parameter has been passed), and the existential operator is actually one of the very few things that actually *is* still missing from ES6 compared to CS. 
The Nylas N1 email client is an example of a JavaScript frontend with a Python backend. But in that case the Python part runs on a server. If you use Electron to build your frontend (as N1 does) you could alternatively spawn a Python subprocess from the JavaScript code to run everything locally, and to get the benefits of Electron's ability to produce easily-installed artifacts. To combine JavaScript and C++ or C in one app, use [Node Addons](https://nodejs.org/api/addons.html) to call into shared objects from an Electron app (or other app implemented with Node). Edit: You mentioned that Electron is taking a long time to install. I find that the easiest way to develop with Electron is to structure your app as a NodeJS project (with a package.json file, using npm to install dependencies), and to include electron-prebuilt as a dependency in your app. electron-prebuilt comes with an executable that is used to actually run the app, located in the project hierarchy at `node_modules/.bin/electron`
I've looked a bit into Lambda. Looks very nice, but just like Google App Engine, if you write an application with it, you're married to it for life. There's no way to port to anything else.
I'm curious how this could be used server-side with node.js.