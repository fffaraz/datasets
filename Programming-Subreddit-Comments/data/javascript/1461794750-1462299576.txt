But like, BFS, really? You can figure out BFS just by it's name in no time. Come on, its a for in a while.
This feel quite complicated. I mean it is useable and understandable, but there is so many things to do for just creating a global counter..
For no reasons other than I was curious I tried to implement without a queue. Maybe qualifies? Uses a list of children to search next. module BFS where data Node a = Node { value :: a, children :: [Node a] } bfs :: Eq a =&gt; Node a -&gt; a -&gt; Bool bfs root = bfs' [root] where bfs' nodes to_find = elem to_find (map value nodes) || bfs' (concatMap children nodes) to_find
document.getElementById("#filter_Ammo_Caliber_module_259").style.display = "none";
I mean he says right in his article that his 960+ Github thing is just showing he likes programming...
what /u/senocular said.. 8 seconds for a few lines to move around is way too slow
Exactly. And he's not helping his future prospects by plastering his shit attitude and lack of professionalism all over the internet. 
Pull the function out of your object: function Tile(...) { ... } var tiles = { grasstile: new Tile(...), }
&lt;/thread&gt; Very well said. An interview is about how a person tackles a problem, not if he knows the solution. Some people complain about some interview challenges being impossible to solve in 45 minutes, specially with a lack of resources. In every professional's career there is a moment where they are handed a problem without enough time or resources to solve it. Employers want people who make the most of it, don't give up and accomplish as much as they can within the limits.
Another option is being a consultant. I'm 40 and I've built up a pretty good client list. I get paid a lump sum per project as a contractor and because I'm so fast at coding now I make way more than most salaried employers. It's funny because I'll build a bunch of web apps for a fortune 500 company but if I were to ever go through the hiring process they'd never hire me as an employee. Sometimes I wonder if large companies aren't intentionally making these interviews impossible just so they can say "We can't find any American devs!" and then go hire an H1B that they can exploit.
 window.stop(); ??!?! [Window.stop](https://developer.mozilla.org/en/docs/Web/API/Window/stop)
This method also adds a ton of insight into "how well can I work with this person", which is arguably more important than anything. Are they humble when they don't know something, or a bullshit expert know-it-all? Do they realize the trivial nature of the problem and be a good sport and play along, or do they scoff at the exercise as a waste of their precious time and half-ass it. Do they think through everything and try to uncover all the edge cases or do they blast through the problem with the quickest and most likely wrong solution? It's the little things in an interview that make all the difference in the world. Not the correct answer at the end. 
I don't like having global variables though
I don't understand why it isn't used? e.g. see examples above.
You can wrap the entire thing in an IIFE and export only the tile object...
Have a script run every day that adds a line to a file commits it and push. Boom! Maybe you can use amazon lambda or one of those free micro instances. 
I am gonna say, that I looked for my current job for over a year. The more experienced you are, the more you make, more you know what you want, it's going to take longer. I know this is a old stat, but expect your job search to take about 10,000/2-4weeks in time for a GOOD job. As in, you want a job that makes 100k? Expect anywhere from 20-40 weeks.
"Answer these riddles three &amp; I have employment for thee"
You don't need to go that far. For one, you can date commits in the past, so no need to do something every day. Secondly, well [there's many tools like this](https://github.com/gelstudios/gitfiti).
I'm in Seattle - I'll take one job please :)
You're treating tile as if it were global, but its not. Its being defined in tiles.tile. The only problem is, tiles isn't fully defined by the time you're trying to define grass, water, etc., so there's no way to access tile yet to use it to create these objects. If you don't want tile defined outside of tiles, then you need to let tiles be defined with tile first before attempting to create grass, water, etc. objects. Ex: var tiles = { tile:function(width,height,image){ this.width = screen.tileWidth * width; this.height = screen.tileHeight * height; this.image = image; } }; tiles.grass = new tiles.tile(1,1,document.getElementById("grasstile")); tiles.water = new tiles.tile(1,1,document.getElementById("water")); tiles.tree1 = new tiles.tile(2,5,document.getElementById("tree1")); tiles.tree2 = new tiles.tile(2,5,document.getElementById("tree2"));
This is probably what you're looking for if you don't want to use Vuex http://vuejs.org/guide/application.html#State-Management
The thing about google interviews is this: They give you TONS of material before hand so you know exactly what to study. Usually you have plenty of time to prepare yourself. Even if they didn't give you prep material, the google interview process is so well documented at this point that there's really no excuse not to go in prepared. Source: I interviewed there last week.
I think this sounds a lot better than the official proposal. I don't like the idea of requiring a new file extension. 
Agreed, it could be. The interviewers themselves are more senior than the interviewee, and could probably not answer the given questions if in interviewee's shoes. I have read feedbacks from people who were hired at companies like Google, and they shared that like 90% of the questions asked at the interview, they answered "i don't know". Succeeding at an interview is more than being able to answer all questions correctly, no matter how complicated. Also, maybe a manager would be reluctant to hire someone who seems to know everything, as he would feel threatened having that guy in his team.
Best company I worked for would do what you did, and put you on a one week training contract. In that week they gave me two days to get acquainted with the documentation they provided (really good doc, breakdowns of every function, user flow maps, interaction maps, UI spec, data spec) and to look through their testing suite and run it. Honestly some of the most amazing documentation I've ever seen. Also helped that they had insanely clean code and tight style guides + code reviews. They sent me a vagrant box, I ran it, pulled in the repo's, ran the relevant commands. Day 3 and 4 I was to write a very simple feature by extending a portion of their code. Day 5 I was to deploy that code live as an A/B test, monitor the heatmap and report the effect this change had, changes I would make and why. It was great. I completed it successfully and they converted me to full time. They did this with a few others, and it worked well because even if the person wasn't a good hire, we still got code we could work with and finish the feature they worked on, so money wasn't really wasted.
Wtf is sort stability?
&gt; 14 Sep 2011 I would double-check any findings given against modern runtimes.
This right here. I'd like to add to this as well. As Eli The Computer Guy puts it: It's not what you know, it's not even who you know. It's *who knows you*.
I recently had a take home coding challenge for a FRONT-END position, that was basically to write two public functions to read/write a file format. Here's the specifications for the file format: * The first four bytes of the file shall be the magic number 0xBADCAB00 * The next four bytes of the file shall contain the four salt characters used when creating the file * The next sixteen bytes of the file shall be a series of cryptographically-random bytes used as the IV for AES-128 * The next sixty-four bytes of the file, when decrypted using AES 128 with the IV loaded, shall yield a thirty-two-byte random string, the MD5 digest of that thirty-two byte random string, and sixteen zeros. This is provided for easy password checking without decrypting the whole file. * The remainder of the file shall consist of key-value pairs of the following form: * A 32-bit word of the length of the key (including trailing NUL byte) * The key * A 32-bit word of the length of the encrypted value * The encrypted value (serialized as JSON and padded as described above) * A 16-byte MD5 of the decrypted, unpadded value TLDR: I didn't do it.
1. What is your name? 2. What is your quest? 3. What is your favorite colour?
I was in an agile webinar today that promoted the idea of an immersive interview. Basically the idea is to pair program with the team you'd be on to see if you can code and to see if you are a good cultural fit. I like the idea. 
I use the whiteboard test not to find a correct solution to the problem but probe how the candidate works under pressure and how their brain processes a problem. Of course there's a general direction I want the candidate to go, but they have 4 possible solutions. Hell, they don't even need to answer the problem, just don't royally screw up. Also, since we typically hire JavaScript developers they need to know how to write a for loop. The question we ask? Given an array of objects, each containing a non-unique ID, write a function that returns an array of unique objects. Essentially, remove duplicate objects from an array (using vanilla js).
Or... don't work for companies so incredibly poorly managed that they have an interview process not only useless, but actually *counter-productive*? If a company is that incompetent, why would I want to work for them? Incompetence can make your life miserable in hundreds of ways.
Yep. If I'm forced to let the HR guy do some of the interview, I let him ask a simple (not coding) brainteaser. But obviously that won't tell me much about their ability to do their job. That's what the coding exercise is for (we sit together and debug and add features to a simple program, talking a lot, googling where needed, explaining to me what you're trying to do, etc). 
It occurs that in a stable sort the first sort isn't actually a crap shoot. Rows with same values will preserve relative order. So you also don't need to sort by multiple columns to observe the affect, sorting by the same column multiple times and being guaranteed that order is preserved is also guaranteed with a stable sort
I also thought it was peculiar that he was so specific about where he interviewed. I thought it was bold to explicitly mention a company, but then he takes it one step further and actually lists the location. 
100% agree. 12 years experience, do plenty of hiring. **If you do have a technical test, at least make it like *actual work*.** I have a very simple app that displays a list of things on the screen, and I give them a few tasks - fix a simple bug, add a tiny feature. I sit next to them, encouraging them to explain what they are doing, prompting them when they get stuck. I feel like I have to un-train their crappy-interview PTSD: "Don't know how to do that? What do you usually do in this situation? You Google it? Correct! Yes, of course you can do that in the interview. That's what real programmers actually do."
Startup?
&gt; Well, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the template option, just replace it with a render function. You can even embed render functions in your templates using the special &lt;render&gt; tag! The best of both worlds, in the same framework. Oh, and don’t forget you still get to use the lovely single-file components. Now *this* is interesting. I'd love to see more frameworks explore this angle. Congrats, this looks like a good release.
[Wikipedia's article is pretty good](https://en.m.wikipedia.org/wiki/Immediately-invoked_function_expression).
&gt; Just like the good old jQuery days. Get up and running in a flash with React. No build tools, no config, no bullshit. I like it already.
Wait, you're telling me that companies are looking for amiable, hard-working people who try to solve problems? Shit. Mind blown. ^^^is ^^^the ^^^/s ^^^necessary? In all seriousness, you wouldn't happen to be hiring amiable, hard-working programmers who try to solve problems, would you? I'm, er, asking for a friend. 
We approach ever eternally towards proving the inevitability of [artwood's law](http://blog.codinghorror.com/the-principle-of-least-power/): &gt;any application that can be written in JavaScript, will eventually be written in JavaScript.
I think he might be a bit entitled and arrogant, and should have said the things in this blog post in the interview (more politely, of course). But he absolutely has a point about stupid, irrelevant interview questions, unnecessary multiple interviews, etc. Not every company has sensible hiring practices. I've hired mostly fantastic programmers with excellent communication skills. One 30-minute phone screen, with relevant, easy questions, plus one 2-hour interview, half chit-chat, half easy pair programming with me.
This is the other side of the article I was looking for. Reading through all of this has given me some new perspectives on the interview culture going on. I too was guilty of looking at algorithms as "do you have this memorized" as opposed to "I hope you don't know this so I can see how you think". It's so obvious now that I've read through this comment section a bit. Thanks for the insight.
How's the Seattle's market for junior devs?
This looks interesting. What are the advantages over something like [Joi](https://github.com/hapijs/joi) or a more standards based approach like JSON schema with a [JSON schema validator](https://github.com/epoberezkin/ajv)? Edit: It looks like you are using callbacks for errors and a return for the value? That is not a common javascript pattern. I would recommend using just a synchronous return with something like { value: &lt;the value&gt;, error: &lt;error or null&gt; } 
As an interviewer, I think it's irrelevant - why not just avoid algorithm questions unless relevant to the job?
Did you try applying for smaller companies or start-up's?
They wanted to make array.contains, but and old version of MooTools added it to Array.prototype in an incompatible way. Chrome refused to break the internet, so they had to change it to array.includes. We still don't have it because MooTools decided to change Array.prototype. https://www.reddit.com/r/javascript/comments/38hr69/es7_array_polyfills/crv4k0f
Angular 1 doesn't require it either.
Oh wow that is very informative. I hope someday i can work for a company like MS. 
Anecdotally from what I've seen this process is more of a junion/mid level interview. Many places I've seen didn't even have coding tests for senior candidates unless they had reasons to be actually concerned.
&gt; I remember it from when I was 20 because I studied it the day before the exam with a very hot classmate. Maybe that's why both me and my hot classmate got offers from Google 10 years down the line.
Why can't you just `&lt;script src="phaser.js"&gt;`
I did some tests with initializing a couple new Array(100) and comparing it with a doing the same thing with an ObjectPool, and I'm glad to see that the ObjectPool out performs by a factor of 3:1 (181ms vs 63ms over 1M iterations).
Brevity is certainly one advantage. I'd argue the biggest advantage such methods give you is clear demonstration of intent for others reading your code. Map, Reduce, Filter can all be done via **for** loop. However: * When I see a **Map** call, I know we're talking about **data shaping**. * When I see **Filter**, I know we're talking about **removing items from a collections**. * When I see **Reduce**, I know we're going for a **cumulative effect** from processing a collection. It makes code much more readable and especially more scannable. For me, performance/brevity benefits beyond that are just a nice bonus. BTW, this is all doubly true when it comes to chaining these calls; `blah.map(...).filter(...).map(...).reduce(...)` etc chains are very easy to digest.
A stripped-down version of this that could just do the Snapchat style modifications would be super useful
I'm in my 30s and I usually tell people no if they ask me to do something ridiculous. If someone asks me to do some really involved task that would take days, I tell them that I'm more than happy to sign a contract with them for a couple of weeks if it would make them more comfortable, but I'm not working for free.
Good ideas! I'll try to add some of that functionality in this weekend. I wanted to make sure I'm not completely reinventing the wheel here and that it would actually make peoples lives easier before going too far. So for constants I could do something like `tc.integer` instead of `'integer'` but what benefits do you see from doing it this way / is there a better way I should be handling it?
Thanks! I'm actually fixing a memory leak I have with DataTables library and a couple others in my app. I've been using the Chrome Dev Tools to take a snapshot of my heap and I'm trying to tackle all the detached DOM nodes.
One extra script tag seems like a non-issue to me. If the phaser global confuses webpack and it's too much of a hassle to work around... I'd rethink using webpack. A bundler should not be deciding what game libraries you can use. There's [stack.gl](http://stack.gl/), but it's more a set of low level WebGL utilities.
Thank you for the thorough explanation :) I love the examples you've provided. You hit some of the pain points I'm facing right on the head.
I feel like you're the only one pointing this out here. What actually being assessed during a technical interview is not the face value knowledge and technical skills. It's about how you communicate, collaborate, and how you behave when you encounter a challenge.
For most jobs, if a candidate starts out saying "I am going to implement search from scratch", I honestly think that's the wrong candidate for most jobs. I want the candidate who starts out saying, "what can I google about how to approach this problem?" "how have others tackled it"? "are their any libraries I can use?" "does this library look suitable, tested, maintainable,..." That's the right approach.
If you do think you are that smart, why can't you understand some algorithm that some people can? Come on, face the reality and work harder. There are always some people who are smarter than you, and if you don't know something but they do, surely they can do more things than you. And this is the reason why some people can work as a software engineering get a annual salary more than 2,500,000 USD but you can't. Work harder and not to deny the facts. 
I haven't interviewed in a while but I look forward to asking, "Can I Google this?" And when they undoubtedly tell me no, I'll ask, "So if I come across a problem and don't immediately know the answer you just want me to 'whiteboard' it until I come up with a solution?" My job as a developer is at least 50% web searching (and that's low-balling it) and the rest is knowing exactly what to search for and how to apply the answer to the problem at hand. Academics teaches you to bang your head against the wall until something makes sense, business demands you get it done by any means necessary.
I couldn't agree with more. Coding are easy to learn nowadays. You can train yourself for few days and you can build a website. Make someone get an illusion that they are genius and they are doing high-tech...... In fact, they are just scaffolding.......
You can use Angular 2 without Node, and in fact, their starting guide allows you to simply write your code in the browser.
Exactly. This isn't a "one person" task.
I think you're looking for an argument, but I don't want to play.
Worth noting is that what you are doing is relevant if the underlining implementation is based on a reference counter GC. However, none of the JS engines does that these days. The last engine to do something like that was IE7. Even then, it only mattered if there was circular references. 
Some of those spatial awareness and logic tests are actually a good indicator of capacity for reasoning and problem solving. They may not be code, but they do correlate with the ability to learn to code and solve problems.
`ConstructorExample.prototype` is the the prototype for objects created by that constructor function, not the function itself. The function has a completely separate prototype chain. It's a function, so its prototype chain begins at `Function.prototype`, as with all functions. 
&gt; write me a function that takes in an array of integers, and an integer N. This function returns the sum of all integers between 1 and N that are evenly divisible by any number in the array. function sum1toN(n, moduli) { let sum = 0; for (let i = 1; i &lt;= n; i++) { sum += moduli.some((j) =&gt; !(i % j)) ? i : 0; } return sum; } // Tests: console.log("1.", sum1toN(100, [2])) // Even numbers only console.log("2.", sum1toN(-100, [2])) // Negative even numbers only console.log("3.", sum1toN(100, [3, 5])) console.log("4.", sum1toN(50, [5])) // Multiples of 5 console.log("5.", sum1toN(0, [5])) // Count to 0 console.log("6.", sum1toN(-0, [5])) // Count to -0 console.log("7.", sum1toN(1000, [])) // No moduli console.log("8.", sum1toN(10, [11, 15])) // No matches console.log("9.", sum1toN(10, [-2, -3])) // Negative moduli That was easy. (I made assumptions for handling negative numbers) 
&gt; You need to be able to write a BFS cold, and you need to understand how a hash table is implemented.” &gt;While this is great advice, it also demonstrates why people eventually develop interview fatigue over a career. I’m not talking about fatigue from your third interview this week, I mean, I mean fatigue that sets in over decades. &gt;I don’t have an easy solution, since I actually do completely understand why tech employers rely on these exams. But I do think they take a serious toll on the field, and are a major contributing factor to attrition (as well as aversion among people who never go into the field at all). We, as developers, really do have to re-load complicated undergraduate coursework into exam ready memory over, and over, and over. &gt;I’ll finish the way I always do: if you interview like this, that is your choice, and you should feel free do do so — I really mean this. But why then do these employers act mystified that there is a “shortage” of developers? It seems to me that aversion and/or attrition is a very natural outcome for the way we do things in software. “No thanks, I’ll do something else” seems like a very reasonable response to an industry that hires like this. This entire section hits the nail on the head for why I left development professionally a few years back. Fuck that noise.
You can just require Phaser and then use it globally. I know it’s not ideal but it’s the easiest way. Generate a custom build with the stuff you don’t need then just require it.
I support your rendition of "Fuck the man" protest.
Man, you all are assholes
You can't moan about a company being incompetent based on one experience in an interview, and yet complain when said company judges you based on same interview. What bothers me most about this article is that he seems to complain that none of the companies have spent time looking through his project history and blog, yet he doesn't display any evidence of having done homework to prepare for the interviews himself. That, to me, is the real incompetence here. Job interviews are just a process, you have to treat them as such.
duckduckgo !so, then !g
Because `Object.prototype` isn't really special - it's just an object, stored on the constructor, which works exactly like every other object. The reason it's still kind of special in JS is because of [the `new` keyword](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/new), which is used to create new instances. As taken from MDN: &gt; When the code new Foo(...) is executed, the following things happen: &gt; 1. A new object is created, inheriting from Foo.prototype. &gt; 2. [...] In other words, the `.prototype` object isn't used for anything until `new` is used, in which case it's applied to the new instance.
Or just walk out and mutter a '*fuck you, don't waste my time*'. 
That isn't interviewing. That is taking 90 practice tests before your final. Shame all around.
This isn't bizarre. The questions are probably from the same article the interviewers both googled when looking for interview questions. Interviewers are far less professional and experience than most interviewees probably know. edit: clarity
...but didn't offer him a job. Telling ;)
A binary tree is a data structure, not an algorithm.
Jesus 7 days! I turned down two interviews for being 4 hours long. 
One other point is that while he feels entitled to a reason why he want hired, there are serious legal reasons why companies can't do that. It's an unintended consequence from laws regulating the hiring process. Saying "why" opens the door to being sued, so companies stay quiet. 
Well, the first step would be to find a hosting provider that supports node. You can either choose something like gandi's simple hosting with node + whatever db you are using, or something a little more complex like deploying a docker container with a node server and databse in it, on a platform like digital ocean (but this would require you to learn all about docker, obviously). I would decide on a hosting solution, and then go about learning how to deploy your code to that platform. 
Doesn't event capturing work for you if you want to invoke each and every child events? Doesn't `querySelectorAll` work for you when you want to select child nodes based on condition?
I believe Grunt was around before. Still it is good to have choice between using it and not. "Good" or "bad" choice for a project is a personal matter. If you need fast results and A1 does it for you, then it can be perfect choice.
I think I had that toy when I was a toddler
when i say "bad" choice, I mean there are better option available. otherwise, there are enough apps built on angular to make it a perfectly valid choice.
Try to make it into a factory example ``` var tiles = (() =&gt; { function tile(width,height,image){ this.width = screen.tileWidth * width; this.height = screen.tileHeight * height; this.image = image; } return { tile, grass:new tile(1,1,document.getElementById("grasstile")), water:new tile(1,1,document.getElementById("water")), tree1:new tile(2,5,document.getElementById("tree1")), tree2:new tile(2,5,document.getElementById("tree2")) }; })(); ``` but then you would still have to destructure it when you want to create a tile in a new scope so then ``` let {tile} = tiles; var X = new tile(1,1,document.getElementByTag('what-ever')); ```
Thank you!
Thank you!
Our last hire was a real good talker as well. Ended up being atrocious at actually getting work done. Wish I had given him some sort of task to go through rather than getting charmed :)
Event capturing will work for me only if I'm responding to an event on the element I want to work with. `querySelectorAll` will help me if the condition can be expressed as a CSS selector. Sure, I can use it with * to get all the child nodes as a NodeList, and then filter it (but I have to keep in mind that NodeList isn't an Array and doesn't have a filter method), but that is actually more work than implementing a DFS, so not very useful as an abstraction.
That's simply untrue. 99% of these questions are standard problems that are encountered during an undergraduate course in algorithms and the interviewers expect to do them fast, far too fast to actually be coming up with a solution on the spot. And if you come to an interview without prior familiarity with these problems, the chance is very slim for an interviewer to think that you're a worthy candidate.
Impressive, great work!
Mootools also extends prototypes.
And what can't be written in JavaScript will be written in C and JavaScript bindings will be provided(i.e. NodeJS)
When you use client side routes, the back and forward browser buttons just work as expected. You don't need to call window.history.back() in the code. This used to be a headache for front end people. You may remember how people also wanted to prevent page refreshes in their SPAs (lots of stack overflow questions asking "how do I prevent people from pressing F5???"), but that also has been more or less settled too. I would like to be able to use the stop loading browser button just the same, to cancel whatever is loading in the page at that moment. Again, please see how you can't do that on vibe.co.
var s = [];var x;s.push("# " + $("#**boards-drawer**").children()[0].innerText); $(".list:has(.list-title)").each(function() { x = this.innerHTML; s.push("## " + $(this).find(".list-title")[0].innerText);$(this).find(".list-card-title").each(function() { s.push("* " + this.innerText); }); }); copy(s.join("\n")); I'm guessing this fixes it but without knowing what the original output would be i can't be sure
TL;DR: interviewing sucks because they ask me irrelevant algo questions i would never need to do or could google. to be fair, OP can just learn these - but in the vast majority of cases, the interviewer wouldn't expect you to write a fully working solution - this is a test of your attitude as much as anything else. I'd be more interested in seeing how a candidate would approach a problem they clearly have not studied/prepared for/thought about before and would work with them to find a solution or discuss approaches/pitfalls and downsides. I need to know _I can work with this person_ under stressful circumstances. I need to know they are not moody and socially inept and can rise to a challenge with a reasonable approach. I couldn't care less about the outcome of the algo test. 
Man, so I'm not the only one, huh. I'm not 40, but I have had 4 failed jobs in software and just had failed interview after failed interview in my latest search (on hold now)
Puzzle solvers are always looking for puzzles to solve. Sometimes they invent them so that they can solve them. I don't think that's good for business.
Holy God I hope there are other people like you in the world
And afaik you can't break from `map` or `reduce`. So even if you look for one array item you have to iterate whole array anyway. In such situations `for` or `while` should be faster.
No problem. You might be able to find a free PDF of it somewhere online. But it goes through building with gulp, making a small app with angular, writing tests and then deploying to (I think, I can't remember, it's been a while) digital ocean or heroku. I worked through it a while ago for the same reason that you did - understanding the full flow of an application. When you're self-taught (I am as well), it's literally filling all your knowledge gaps with research and practice.
Can you provide a real life example? I've always just used for loops I'll have to look into map more. 
I landed here through: https://www.reddit.com/user/krispykrackers/m/programming I don't care about javascript stuff.
thanks for your answer! You're pointing on the right direction, but the big doubt that I think many people could have is "how" those things that you said are done and shared ("with no changes") and then executed depending on the situation.
What in the blue fuck edit: i missed the "r" in through, so I had no idea what they were talking about
Had this exact experience when applying for a front end internship (!) position two days ago. I was, among other things, asked to quickly create a database structure and how I'd write optimised SQL queries. And how to write an algorithm traversing binary trees. Internship. Front end. Yeah.
Congratulations. You're a real programmer.
Wish I had this nugget of understanding a few days ago, when I was being interviewed for exactly this.
In my experience, colleges are actually remarkably bad at teaching the practical bits, which is what you're missing. My point is that you should stop worrying about having missed the practical bits from college because there's a good chance they didn't teach them anyhow. Congrats on getting that far already! That's no small feat that you've done already! So, yes, you need to find a server to host your app on. I'm assuming you're using express (or something similar) as the web server software, since you said 'node'? Here's a tutorial I just found that seems to be pretty decent. It has you install Mongo, which you may or may not need, so be aware that they're making some assumptions that may not apply to your app. https://www.codefellows.org/blog/how-to-host-a-nodejs-app-on-an-ec2-ubuntu-server But let me boil that down a bit: The basic steps should be very like what you did on your local machine, plus the initial OS setup and something to keep the app running in case it crashes. All of the tutorials I've found today use the npm package "forever" to do that. You can go way beyond these simple steps to set up continuous deployment, or deployment via Git, etc etc, but this will get you started and you can research other possible methods as you come across them.
Wow! Good luck with your project! I'll take a deeper look later but I really appreciate your contribution. I also think real examples help a lot. Thank you so much.
Map is for generating a new array by applying some function to each element of the array. For example: [1, 2, 3, 4].map(x =&gt; x + 1) Will return the array [2, 3, 4, 5]. 
One thing you can do is use React components as templates on the server, so your initial HTML render is done on the server in React, but after that rendering is done in React on the client. Obviously, it's harder to set up an app this way, but if you want hybrid server/client rendering this is one of the best ways to do it. 
Holy shit! This changes everything! Performance wise, map vs for &amp; fn()? Any huge dips if we're talking about loops with hundreds of items? 
Reduce on its own is sufficient, really. With reduce, you can implement the functionality of both map and filter. E.g.: Array.prototype.filter = function(fn){ return this.reduce(function(p, c){ if (fn(c)) {p.push(c)} return p; }, []); } Array.prototype.map = function(fn){ return this.reduce(function(p, c){ p.push(fn(c)); return p; }, []); }
actually there is already native `Array.prototype.find`function which as I see has good support in browsers: https://kangax.github.io/compat-table/es6/#test-Array.prototype_methods_Array.prototype.find
Okay. valid point. But you could use `filter` like this: `arr.filter(item =&gt; item.name = 'foo')[0]` Which wouldn't be effective if you had e.g. million elements in array.
Why wouldn't you be allowed to use NPM in a corporate environment?
I think you don't see real life issues until you are iterating over thousands of items. maybe tens of thousand. I'm sure there's a jsperf somewhere
It's probably a little slower, but for it to matter, you'd have to have such a big array that you should be asking yourself why you have such a big array. It's always easier to simply do less stuff rather than try to make the stuff faster. 
I'm 55 and have changed jobs just fine recently. It just takes longer.
We do algorithm and coding questions where I work and I find them extremely helpful in evaluating candidates. We typically aren't looking for a perfect answer, but rather how you approach the problem. How do you reason about it? How do you break it up into smaller chunks? Do you recognize the implications for performance and security? How do you validate your solution? Are you able to work well with the interviewer by asking questions and taking feedback? Whiteboards suck, it's important to actually be able to type, execute code, and Google. While the problems don't match real work, we attempt to emulate our work environment as much as possible. We find that candidates who can reason about solving simple algorithms are generally more successful in the job, even if the problems are abstract and not related to "real world work". We tried "real world" problems at one point in time, but it's difficult to form a real-world problem that hits on all the nuances you want to probe in a short amount of time, and we found it didn't work as well.
Holy shit, you are a negative human being. 
Or ya know, network.
I think in cases like Google they are testing a few things. First, they want to make sure that you have theoretical and technical know-how and can code "lower level" stuff. There you are actually building foundational software that needs to be performant. You aren't just using out of the box frameworks to put together an application. Second, and I think this is a big part of it too, is that you want to actually be there. I think many people want to work at Google but you need to prepare. That preparation, to pass the interview, says a lot about you. I know devs there that are amazing and others that kept breaking systems that we had that I wouldn't hire again. Third, are you a fit for their culture? I don't think whiteboarding is great but perhaps they do that to show how flexible you are. I find it very cumbersome because I can refactor much faster with a computer and an IDE but it is what it is. But I don't think they are testing that skill in particular. I know that when I hire people I am looking for two things: are they good+ technical people and can they get things done. This is what companies like this are looking for. And that's why their process "works."
No, I'm realistic and honest.
One of the "constrains" was that, because it's a Big Brother voting site, it means that, at some point, the site would be hammered with people voting. And you had to take that into account. So, although voting was simple enough, the fact that, suddenly, the thing would be hammered to hell had to be taken into account. And you had to build thinking about that. (I was planning on using a MQ to store the votes and then add another process to consume the votes, so the database wouldn't be hammered and still be able to show the site fast enough -- it was a non-issue, on my view, if the vote counting was a bit delayed.) *Edit*: Also, I was employed and had a full time job at the time. So it was 7 days of my free time to complete that. Again, it's fun and the idea of using all those new toys was exciting, but heck if I'm going to lose 7 days of my free time to do all that. I'll learn those things on my own.
Some large companies disallow installation of any software that is not included in an officially sanctioned whitelist
3 is so spot on. Always try to be nice to everybody you ever work with. You never know who's favour you might need in the future. 
Startups, consulting, and larger companies.
I got a maze-solving problem to do at a devops position I interviewed for as well. Obviously I didn't solve the problem, but the recruiter nicely told me that he wasn't interested in seeing if I solved it in one go - he wanted to see what my method was. Bit of TDD and a data structure with field names that made sense and I was on to the next level.
I just recently changed careers into software development, and my current position was I *think* a decent balance. Here were the steps: * Phone interview with HR. Basic questions, nothing technical. * Phone interview with the prospective tech team that I'd be working on. They asked me about my portfolio, what problems I liked to solve, etc. Nothing super technical. * Code challenge. ~1hr on the night of my choosing. They sent me a zip with a few files in it. The challenge was relevant to the company (finance related stuff), and was fairly trivial. Interestingly enough, I had never coded in that language until that night. * In-person interview. Entire day long. Meet with the tech team, meet with some HR people, work on actual problem that the tech team was working on to get an idea of how I troubleshoot in a slower paced work situation. They kept reiterating that it *was* a long day, but it was as much as them figuring out if I was a fit, as it was for me figuring out if they were a fit for me. The actual work was split up by small meetings with other team members, lunch, etc. Prior to it all, the idea of an all-day interview was pretty ludicrous. But, I think if it's a little more slow paced, and you work on actual problems they're dealing with, it can help you decide if you actually want to work there. 
Yeah, I could use some javascript-focused podcast links as well. I've got plenty for the other parts of the web stack that I use, but for some reason good javascript podcasts are hard for me to find.
Vue is a joy to use. I hope devs give it a shot and appreciate its beauty.
React.js server-rendering is certainly one of the strongest contenders with "Isomorphics JavaScript"/"Universal Javascript" The most easy setup for it is having React.js components as views that turn a JSON data graph into Website markup. For the initial request, can ideally call the same components on the server side and render the same markup on the serverside that your client would on the client side. Then you send that prerendered markup together with the JSON data block to the client. When you now render the view on the client React's virtual DOM diffing will find out that the markup already exists as it should and will just wire up all the event handlers for a full working application. So you end up with a situation where you have one single source of truth for your markup rendering (the shared React.js components), can have a fully dynamic js side, but you can also provide search engines etc with server-rendered HTML for the initial view state.
Hmm come to think of it, isn't the latest version of pixi.js more modular? It only does 2D graphics though, not audio, input, etc.
Is this a proof of concept and is it a drop in replacement for node?
Not currently in Seattle, but it's been a place I've considered for relocation. If you don't mind me asking, what do you love about Seattle? And are the days really as gloomy as I hear they are? 
lol I wish you were in Boston. 
google question...and the first link to pop up is to stack overflow. 
so am I missing something here? At least on ruby on rails it would be something like: create a vanilla ror project create a sql database for the votes. change the route for the root to some template that you made for the votes. create two html buttons do a post (or ajax if you wanted) to register the vote and...ta dah lol maybe that would take me a couple hours because I'm rusty...but unless I'm missing something...that should be something that you could actually do within an hour if you knew what you were doing. 
I frequently listen to [JavaScript Jabber](https://devchat.tv/js-jabber), but I'm also looking for more JS podcasts.
Oh look, another post bemoaning modern advances in web development technology on the Reddit frontend-dev circuit. Must be Thursday.
Well, even with the shifting goal posts, that still doesn't take 7 days of work if you are using the tools at your disposal. Heck, even the scaling up portion of it is simplified by the fact that 1) you are using AWS and 2) you know when the scaling up should occur. Maybe the issue wasn't that they expected too much, but you didn't have the experience for the job.
I made assumptions for also setting up autoscaling and ELBs in AWS, and planning for scaling as well. No need for a SQL DB.
Bear in mind that `$rootScope` dependency is a bit of a code smell and anti-pattern in Angular. Definitely look more into the flux architecture and the redux/vuex implementations of it.
?? Maybe I'm missing something (I'm not a js person), why would a built in sort return out of order? What could it possibly be doing, looking at leading decimal digit...?
I also listen to The Changelog and JavaScript Air.
It is Thursday ! 
I love Vue and sing its praises whenever front-end frameworks come up. Also Vuex blows Redux out of the water as far as usability is concerned. Honestly 2.0 looks pretty fantastic and I appreciate the consistency with v1.x. Looks like I'll have to change almost nothing (not using any of the deprecated features). I figured virtual dom was going to be included but I also like this idea of combining templates with JSX. 
You know, that one function? The one you always make? It looks like this... &lt;form onsubmit="return validate()"&gt; ... function validate() { alert('Your form is incomplete!'); prompt('Please provide the correct value'); return false; }
My post may be negative but those things *are* happening in the industry. Like them or not you have to acknowledge them and then, if you aren't an idiot, at least try to plan what you'll do to keep the bills paid if they happen to you. There is a lot wrong with the way IT is done in the US. Not admitting it is gonna lead to your ending up like all those steelworkers in the 70s who watched the job at the plant go away
I found it easiest to contribute to projects i actually use and like. make issues on their github, propose features, look for 'up-for-grabs' or 'good-for-beginner' labels. One of my first contributions was to eslint; as an avid user, one of their rules didnt encompass my use case. So i hopped on github, looked over their `CONTRIBUTING.md` and made a proposal to expand that rule. After a bit of discussion on accepting the proposal, their first response was to ask if i'd like to make the PR. 
What? My dad just got hired at 63 to do Swift stuff.
I like Seattle for the summers and the jobs. I'm used to the weather now. I've been here almost 30 years.
Seattle is really needing people at all levels.
Or have a mandate to stay with one stack. I've been at some places that *enjoyed* the idea of vendor lock in ... if it's not microsoft, it's not getting in.
Sounds similar to why I still live in Minnesota. Thanks for the response!
Doesn't look like spam to me, though the author does comes across as somewhat inexperienced.
Keep in mind, the author compares stateful and classful react to angular 2. 
How can I say it this sound too good to be true, so I'm warry.
my personal rules to frameworks: if you need animations or css3 animations you might want to skip a framework, they dont seem to be thought about during the design of most frameworks if you have hundreds of event handlers `$('.foo').onclick(bar)` x 100 use a framework if your using lots of jquery .clone() or have an app that can be broken into reusable compontents ex listitem, button iconbutton, use a framework react seemed the sanest framework of the recent bunch imo
TypeScript 2.0 will add flow based typing. Maybe not as powerful as Flow's but it will cover 80% of use cases. It will also support .js files (it supports them today but without the flow based typing there are not many uses)
Do software engineers earn less in australia??
Exactly. If you compare a conversation you have with someone, say at a tech meet up, to a conversation you have with your interviewee (in these big company situations), you learn a lot more from the guy you had a nice conversation with at a tech meetup. That's how I like to interview. Two way conversation. Learn about what things they've worked on. Asked about problems you know they should have encountered, and how they addressed them. Don't give them a whiteboard marker and rewrite a handful of algorithms. Engage in a dialog where they can share their proud moments and you can steer the conversation in directions that will provide insight into their experience. I hate fire drill interviews. 
Nice to see someone who isn't complaining. It is a good job in most cases.
So how do I handle 3 differents observable functions in a row that depend on the previous ones response? I'm doing something like Obs1().subscribe( function(url){ Obs2(url, some_data_from_method_params).subscribe( function(user){ Obs3(user, other_data_from_method_params).subscribe(etc) } )} });
Haha sorry I should have been more clear! I just mean it takes me less time to code it, not saying it is more performant. I just like using it for mongodb collections.
Pretty sure that isn't how that works.
There's no way the architecture I have will solve any problems. If anything it's creating more!
Welcome to functional programming! Consider using lodash for much faster implementation of those methods on arrays and other collections. Continue exploring functional programming in JS - you've just scratched the surface. You can gain MUCH more impressive super powers.
It's different everywhere in Australia, some places pay as low as 45-50k and some are up at 100k+. The average Australian professional wage is 75k I think?
The super powers with these functions are that they return a new array and you can use that to chain on more and more calls. You're correct with one off maps or reduces, but there are cases where you can do something like: myArray.map(do some transformation).filter(remove unwanted members).reduce(just spit out a single value). Yes, you can write that with a bunch of for loops, but in that case, I think you certainly lose readability. You can also create reducing, mapping, filtering functions that you can reuse. When you use those, readability increases even more. You can totally do all of that with for loops (because that's what reduce, map, filter really are anyway), but the added functionality (LOL) of functional programming really shines when you're doing a bunch of stuff all together.
I do, check out: http://youtube.com/watch?v=0nh2EK1xveg
Same.
How many ms do you consider negligible to the end user? How many total operations need to exist to exceed that number you consider negligible? I know I personally have had to optimize out reduce and map calls in some of my libraries to scale with larger or complex collections, and if we're still going to need for - this isn't replacing it by any means - why have map or reduce at all? Just for the legibility? That's makes no sense to me and just serves to confuse the language spec and possibly even make a few coders a little bit worse. It's not like map or reduce are universal multi-language patterns like for loops are.
What is blocked? HTML is just simply raw text, you can post it to share by copy/pasting it to a fiddle here: https://jsfiddle.net/ and then hit save, copy the link and comment it here.
The &lt;iframe&gt; only needs the same origin if the site itself disallows it. I'm still confused at exactly what you're attempting to accomplish here. You're adding an iframe into your own HTML file and then attempting to format the content found within the iframe, correct? Is the site you're looking for data from not your own?
Also, I would make a fiddle but I dont know how to replicate the multiple HTML files I am using or the changes that come about with using file://.
You're right about brevity I suppose, but I think there is something severely wrong if even a complex series of for loops isn't immediately obvious in purpose. It's a ubiquitous multi-language pattern that every programmer can immediately identify, and if they can't it probably says more about your average JavaScript developer than it does the legibility of for loops. .map and .reduce are a reinventing of a wheel for no apparent reason other than "Hey, I can immediately tell that's a wheel!" As though anyone has ever had issue identifying wheels in their previous iterations.
Well if your design issue is stemming from your own initial design issues, then I would just recommend reworking them. Having multiple pages that trigger page reloads/etc is not ideal, especially for a locally run page as Chrome and other browsers will not support cookies, etc. You can control views/etc with hash changes as opposed to separating out various html files like you have.
FYI, that would have been a more appropriate link to post than the one you did, since the original one doesn't really have anything to do with JS.
Love my job 😁
Complaining might get annoying but dissatisfaction with daily life is the only way that life improves, and it's important to realize that everything is relative. Software Engineering is an incredibly cushy job and so there is a lot to be happy and satisfied about, but just because you don't risk death everyday (like an oil rig worker) does that mean that you don't get to complain when your boss is a dick or suggest that interviewing practices could be better?
I have no idea how people concentrate while listening to voices. I need non-vocal music.
I guess I fundamentally disagree with most users here that map or reduce are easier to debug than for loops, my reasoning being again the universality of the for loop pattern makes recognition and debugging a very practiced event for any developer. I even question the readability argument, as again for loops are universally recognized where as any experienced developer new to JS will need to dig into the spec to use .map and .reduce just so they know how to structure it.
Yeah, the Clojure peeps figured this out; it's the underpinning of how transducers work
Yet all things being equal -- it's a fine job. Everything is relative.
Typically, creating observables from intermediate `.subscribe` calls is a code smell. Instead, you want to only call .subscribe once at the end to output data. It sounds like you're *literally* translating promises into observables, which is kinda missing the point. Let's say you have two xhr calls `xhr1()` and `xh2()` that return promises, and the second one depends on a value from the first one. You can get an observable from `xhr1` easily enough with `var ob1 = Rx.Observable.fromPromise(xhr1())` Now here's where there's a shift in paradigm. You want to refactor `xhr2` so as to make it agnostic of the data structure of the response of `xhr1`. Let's say for example `xhr1` resolved to `{id: 1, firstName: "John", lastName: "Doe"}` but `xhr2` only needs the `id`. So, instead of function xhr2(dataFromXh1) { return request({url: "/api/foo/" + dataFromXh1.id}) } You actually want function xhr2(id) { return request({url: "/api/foo/" + id}) } The benefit of doing this for `xhr2` is that you no longer need to care what type of data structure the `id` comes from, and where the `id` is located in the data structure. The `id` could be from a User object, or it could be a `userID` field in a Project object, it doesn't matter as far as `xhr2` is concerned. Now you can use RXJS' fluent API to pipe the desired value from `xhr1` into `xhr2` var ob2 = ob1.map(data =&gt; data.id).flatMapLatest(xhr2) Or even better var ob2 = ob1.pluck("id").flatMapLatest(xhr2) `flatMapLatest`'s argument is a function that is triggered whenever an observable receives data. It receives the data as te argument, much like `subscribe` does, but it converts the output into an observable (basically, it calls `Rx.Observable.fromPromise` under the hood in our case because xhr2 returns a promise) From here, you can keep chaining `pluck` (and friends) and `flatMapLatest` to serially call as many dependent xhr requests as you need. I say `pluck` is better than `map` because using `map` requires explicitly writing out an argument variable `data`. Pluck doesn't, therefore it is *point-free*, which is considered a good thing in FP. Notice I haven't used `.subscribe` yet. Once you have no more streams of data to compose into your observable chain, *then* you can call `.subscribe` to get out of RxJS and go do some side effects ob2.subscribe(myData =&gt; console.log(myData), e =&gt; console.error(e))
`for` loops are easy to understand until they become complex nested behemoths. A `for` loop must be read in its entirety to be understood. Iteration methods on the other hand carry with them meaning (`map` transforms elements, `filter` removes elements, `reduce` produces a single value from elements) that can be read and written in chunks. Plus the methods receive functions that can be further separated (and re-used in both functional and imperative code).
Holy shit. This makes so much sense. Thank you!
Okay, so you're a fresh faced JS dev coming from say a F# background - you understand reduce and map because you've used them before. You still have an entirely unique calling structure to learn in order to debug or use these structures, which is admittedly not a huge issue - programmers learn new calling structures all the time. Or, you see a for loop, and you immediately recognize every part of it because again, it's ubiquitous and self explanatory. If you genuinely have a series of complex loops which in many peoples minds here would necessitate a 'reduce' or 'map' call, I would expect a comment at least in a word or two describing the action of the loop. Honestly, even with a chain of 'map's 'reduce's and 'filter's I would expect a comment, but the argument here is that these functions increase readability so we'll assume a comment isn't necessary. So the question becomes: Is it worth creating several new functions obfuscating 'for' to performance detriment just so people don't need to add a '//Reduce to sum of collection' to the top of their 'for's? I have a lot of trouble seeing the view of the majority here, and feel there is possibly an inherent bias among primarily JS devs to the way their language does things, not dissimilar to the way PHP devs will defend to the tooth and nail the way they shoe-horn backwards compatibility into the spec.
I thought you would only be able to write off a percent of what you would use for work, not the whole thing.
I am working in one of those big corps in which the author of this article might have been interviewed and I often perform technical interviews. I have no idea why this guy was rejected, but I find at least some of the questions that he was was asked quite plausible -- I might ask some of them during interviews myself. Let me tell you why I do that. Let's start not with the particular questions, but with the qualities that one might expect from a good programmer. - I expect the candidate to be able to write *good* code in at least one programming language. By good I mean: concise, readable, easily maintainable, extendable and verifiable. - The candidate should be an expert at least in one topic, be it search algorithms, network programming or some programming language. - The candidate should have at least basic knowledge of math and algorithms. You don't use them every day, but when you do, you should be aware of stuff like time and memory complexity and some basic algorithms (yes, including BFS). - It's hard to verify, but the candidate should be able to quickly learn new technologies, programming languages, what have you. Every day at work he will see a lot of new code, APIs, libraries, that he'll have to use. So, how to verify all this during an interview? You have a time limit of say 50 minutes and you want to see the candidate write at least ~30 lines of code. You can't give him a trivial problem, because it won't show anything. You can't give him any problem that will require boilerplate code, because it will eat up all the time. And you can't give him puzzles, because they do not show anything. What's left is a medium-level algorithmic problem that you expect the candidate to solve in say 10 minutes and code in another 20. This is somewhere on the level of usual problems for BFS, that the OP hates so. What will you see from such a problem? - You'll see whether the candidate can reason about a problem. - You'll see whether he recognizes common algorithms. - Most importantly, you'll see some short, but non-trivial code. Does the candidate divide the code into functions in a meaningful way? Did he name the functions and variables properly? Did he handle the corner cases? If everything goes well, we got say 15 minutes of interview left for other questions. Now it's time to check candidates experience and expertise. I like to talk about the candidate's previous projects, ask him about various technologies that he used and get his opinions. Together with the first question, this usually gives me a good understanding of the candidates abilities. Finally about feedback. Indeed, it is not common to give the candidates feedback on their (failed or successful) interviews. But usually in the end of the interview there is time for candidate to ask the interviewer any questions about the company and interviewing process. For me it sounds like a perfect time to ask for some feedback. For some reason, during the interviews that I performed, I was asked for it only once or twice.
Impact &amp; reach: If your software is used by that many companies then someone's getting rich off of it. It ain't you. That's fine, but who get the shit if something goes wrong? You do. How cool is that? All the blame, none of the reward. Unless feeling cool is enough. Demand: You would hope that's the case but a large number of companies aren't looking past the end of the quarter or considering anything but shareholder payout. On top of that, what makes you think management is going to learn from its mistakes? They didn't with the failed outsourcing attempt in the early 90s. Debugging: Someone's losing money. If no one's screaming at you there must be someone higher up on the totem pole to take that shit. Instant feedback: all that does is provide you the ability to watch things go to shit in real time. Nah, I don't need a new job. I like the money and the work is easy
I also give the IRS my reddit handle when filing taxes. 
Set up 2 streams: * Query stream (goes from your App to SQL executor) * Result stream (goes from SQL executor back to your app) I call it "monodirectional architecture" cause both MySQL and "monodirectional" start with "M". 
`let` has block scope, which means in your example, there are 10 separate variables called `i`, and each iteration uses a different one. `var` is scoped to the current execution context, which means every iteration always points to the same variable.
My suspicion is that ```let``` (by only having block scope) will cause a new value to exist on every iteration. As you already indicate, using ```var``` causes a single value to be present, being the value 10. If you try to see JS as a language where every variable essentially is a pointer, things become easier: ```let``` will cause a new pointer to be created for every iteration, whereas ```var``` will only cause a single pointer to be created, of which the value is changed. This makes a difference for the closure you create, as in the case with ```let``` a different pointer is closed over every iteration. With ```var``` a single pointer is closed over, causing the last value to be used when the timeout function actually is executed.
because of scoping. the es2015 specification additionally scopes a `let` declared in the header of a `for`-loop to each iteration of the loop. with `var` it's scoped to just the header, meaning that since `setTimeout` pushes the `console.log` calls to the end of the event loop, it will only ever see a value of `10` for `i`.
The default comparator calls the `ToString` internal method to convert it to a string and then sorts the items based on that.
Nice, i'm going to check out Vue. I am familiar with [Ractive.js](http://www.ractivejs.org) and it looks extremely similar, should be a painless transition, especially looking at the documentation. 
The ones I've seen will have a semi-coding-related test for senior candidates, usually along the lines of "how would you structure this example application". Very little code is actually involved, except for as you mentioned if the company has reason to worry that they may not be competent at coding. My last job was fond of tic-tac-toe for junior/mid-level devs, mostly just a sanity check for "can they code at all?", and then they'd generally give a problem that they didn't expect the dev to actually solve (for me it was maze generation) but just wanted to see their general thought process and approach to things where they can't just regurgitate knowledge they already had. 
That's kinda my point.
Yeah, like I said: &gt; Also, remember iframed content must have the same origin as the parent page This means both your location.href and the iframe src must have the exact same domain. If they don't, you cannot access the iframe because it's a security violation, as the error message states. Also note you *must* use the `http://` or `https://` protocol. You cannot access iframe contents via js if your pages are using the `file://` protocol (again, due to security concerns). You can use something like https://www.npmjs.com/package/http-server to serve local pages from a local server and point to `http://localhost:8080/your-file.html` instead of `file://path/to/your-file.html`
 // Method 1 var speak = message.content.split(" "); // Split the message into an array speak.splice(0, 1); // Remove the first element of the array ("speak") speak.join(" "); // Stitch together the array with a space as seperator bot.sendMessage(message, speak); // Method 2 bot.sendMessage(message, message.content.replace(/^speak/gi, "")); For more specific questions to the discord.js library you should consider to join the Discord channel of that library: https://discord.gg/0SBTUU1wZTYXocdB
Exactly why I am pretty sure it is shady to write off something that is not 100% used for work. The IRS could easily come back at you if they wanted.
naively, yes, but modern javascript engines have many techniques for optimizing variable allocation. for instance, one of the first of such optimizations the v8 team talked about was creating shadow classes for variables that share values, allowing two (or more) variables to occupy roughly the same space in memory as one. i'd imagine a similar optimization could be done for many instances of one variable sharing an execution context. 
Gonna need a source for that. Everything I have read has said maybe you can maybe you can't. EDIT: This says it is precentage based. http://www.nolo.com/legal-encyclopedia/deducting-computers-bought-work.html 
&gt; I was wondering if anyone does front-end development without using all these fancy tools for bootstrapping projects? It's mostly a matter of where you want the complexity in your app. A web app is a distributed system and your life is a lot easier if you have your state coordination in one place: either on the client or on the server. The heavier single page app frameworks are written by people who choose to put their interface state completely client side. The seemingly unnecessary things you're running into generally ARE fairly simple tools, there's just a ton of them (because they're each supposed to do one thing) and they all require configuration (because the authors want them to be flexible) and the result is overwhelming if you don't know what each one does. The sane alternative is to put all your UI state server side and just have the client XHR and innerHTML predefined views. This is the approach that 37 signals advocated and (afaict) the motivation behind turbolinks. What most people seem to do is neither and instead volunteer to solve distributed systems state coordination by implementing some of their logic server side and some client side with cascading complexity as the project ramps up in size. If you are building your code as a single page app, your app will further be simplified by having all your state in an explicit app model instead of spread out across the DOM and in components. This was the win of Backbone over jQuery (for example). The various component models since then are about allowing you to ignore the contents of the DOM completely and therefore allowing you to only have a single piece of state to manipulate without any coordination anywhere. So that's why the frontend is the way it is. Choosing a framework is largely about choosing what you value: small ([domvm](https://github.com/leeoniya/domvm/), [vue](http://vuejs.org/)), component isolation ([polymer](https://www.polymer-project.org/)), completeness ([ember](http://emberjs.com/), [angular](https://angular.io/), [aurelia](http://aurelia.io/)), or state control ([Redux+React](http://redux.js.org/index.html)). Finally, if you truly do have small apps, you can bang out something in jQuery or vanilla javascript and it'll work because it's a small app and anything works for building a small app. The DOM is a terrible API and has always been a terrible API and I'm happier now that I can avoid it.
I'm gonna assume you don't know the difference between a 1099 Independent Contractor (IC) and W2 Full-time Non-exempt. If you are an IC, which most/all freelance developers are, the you can write off all business expenses in full. &gt;If you use the computer in your business more than 50% of the time, you can deduct the entire cost under a provision of the tax law called Section 179. Even if you use less than that, nobody will be able to decipher that other than one's self. So yes, it's somewhat "shady". But no, the IRS will not able able to "come back at you" unless they have proof how much you use your computer on specific tasks (which is highly unlikely). IRS: "Do you use this computer for work more than 50% of the time?" Guy: "Yes!" IRS: "Ok, then." Case closed.
`let` triggers a special mode for the `for` loop where a new _binding_ (storage space) for each loop variable is created, per loop iteration. The `for-of` loop behaves similarly, for both `let` and `const`: const arr = []; for (let i of [0, 1, 2]) { arr.push(() =&gt; i); } arr.map(x =&gt; x()); // [0,1,2] For comparison, a `var`-declared loop variable: const arr = []; for (var i of [0, 1, 2]) { arr.push(() =&gt; i); } arr.map(x =&gt; x()); // [2,2,2] 
In my company we're building websites by defining 1) an HTTP API and 2) front-end only js code for merging data. Web pages are then prerendered on server using express-dom (with webkitgtk and soon with jsdom as alternative). It's working pretty well, and it benefits from all new w3c api that appears.
Forgot to mention tools like window-page, which is responsible for telling between the need to run merge code or ui code.
&gt; data.foo.bar.baz I'd think there is a problem with my code if I use more than 3 degrees of nesting.
You can break from reduce if you write your own version of reduce, which is pretty easy. Lots of libraries that have their own pointfree versions add this (some as part and parcel of either creating a transducer interface or an iterator interface, which would need to be able to break to support a "take" command). You just need to have a way/means to signal it from the reducing function, because it wouldn't make any sense to write "break" in the middle of a simple reducing function that you pass to reduce.
Well, it's not going to be simpler than a pure function if it requires another function to work, now is it?
Array.map can be implemented as Array.reduce, so anything map is for, reduce can be for.
You have to remember too though that the whole article is a ragequit. He's fed up. He's over it. And I personally don't blame the guy, because obviously, this has been building over time. That angle has to be taken into consideration too. I'd be chafed and pissed as well. In fact, *I am* chafed and pissed. I hate what the work world today has become. It's not just the interview process, but it's employers' and upper management's attitudes towards the people that make money for the company (in the first place), it's the cutting of benefits, it's the general lack of job security, it's numbers-before-people, it's "we always fire the bottom 5% performers ever quarter", and [**it's shit like this too**](http://www.nytimes.com/2016/04/10/opinion/sunday/congratulations-youve-been-fired.html?action=click&amp;contentCollection=Health&amp;module=Trending&amp;version=Full&amp;region=Marginalia&amp;pgtype=article&amp;_r=1). 
alert(): the preferred function for advertising pages. "DON'T LEAVE US, PLEASE STAY"
I could say that I knew Vue before it was cool! :)
Bonus: no mutations 
You could, but why would you? Map is used (generally) for one class of tasks: calculating an array/list/stream transformation. The big advantage of using map/reduce/etc is expressiveness. What I mean by 'what map is for' is, what information does using map convey to the reader.
But why? es6-shim has Promise support also
&gt; ES6 contains some good stuff. It also contains some features old timers perceive as eye candy, which is features that exist only to supply some sort of convention or style popular elsewhere opposed to any reason of utility or performance. Sure, but I wouldn't say that's the same thing as *an objective step backwards*. That's being critical of potentially needless bloat in language features. &gt;Then make your site slimmer for mobile. Many commercial sites horribly fail at this due to all the analytics/spyware/adware shoved down the pipeline. In many sites caching is too little and too late to help. I don't feel sorry for you when your users are abandoning your site with 5kb of content and 3mb of assets plus another 3mb of advertising. Yeah, now imagine there's another 3mb of javascript runtime + std lib you have to download for every website that uses a different particular version, which is what the article is advocating. You're screwed before you even start.
... as a professional programmer, I don't understand this article in the slightest. I suspect that someone is making their job entirely too complex. 
Depends on what your source of data is. 
One thing, the author mentions for the second round at Start Up E that: &gt; After considering it for two weeks... I'm guessing that's the problem there... Startups move fast and they need people now not later. Chances are after 2 weeks they'd already interviewed a bunch of candidates and may have even already been in talks with hiring someone. Other than that while asking someone to implement BFS is a pretty BS problem to ask... it still seems like something you should be able to crudely solve without fore knowledge so long as you understand what a BFS is. Or even if you don't, but understand the idea of a queue and have someone explain to you what BFS is. 
No not at all people generally view tech workers and developers as mysterious wizards. I think the salaries aren't as high as say Silicon Valley because the competition isn't so fierce in Australia because there aren't as many tech companies. Still plenty of developer jobs to go around. 
I'm not sure how to feel with all these theories and concepts from OOP.
Until I saw the power of functional programming from outside the box of "regular" coding, especially regular Javascript coding, I felt exactly the same as you. Maybe looking into some tutorials on reactive programming (like with RxJs) might be as big a paradigm shift for you as it was for me. It would be exceedingly difficult to replicate that style of code with for loops and still retain any sort of maintainability.
first is just for traversing the DOM, that's true.. caching the length is not the best in every case, for example with regular arrays it actually prevents browser optimizations for taking place. I haven't checked that out with live collections, but I'm pretty sure nowadays it's faster not to cache the length.
I'm 33 and about 7 years in my career (I didn't switch, I was just a late graduate). I feel like a lot of companies treat you like babies regardless of how experienced you are, and it's hard for me to find some company that is not just looking for someone doing flash-in-the-pan stuff.
And if you don't have a good one? Well... I kinda do have a big network^if ^I ^wanted ^a ^nursing ^job ^&gt;_&gt;. And these people I've talked to don't know anyone looking for a web developer. I barely know anyone doing software or IT-related work, either.
Nesting is fine. The problem is useless checks against something that should be obvious from a documentation standpoint.
sure, but you may be processing incoming JSON data that of course you can break it down into smaller pieces, but somewhere you might have to handle it nested that far in. Say you're processing an internet sourced TV guide, you might have: { queryResults: { channels: { channelId: "23-2", currentProgramInfo: { seriesId: "29348-3", startTime: 1234567890, endTime: 9314597835 } } } or some other completely different organization that could get deeper than that. 
This doesn't seem like a great fit then because the request/response part of the interaction isn't really abstracted away by most JS webservers. 
Ooh! Those look pretty nifty.
Start attending public meetups for programming groups in your city. If there aren't any, start one. You will make friends, you will learn things and you will have something new to do, and new things are always good for us "old guys".
Does being a professional mean you suddenly know everything about programming? I am a professional as well, yet I spend reasonably large chunks of my time constantly learning. The article talks about FP as it relates to `null`-able data-structures. If you have no experience with FP, it would be natural that you wouldn't understand it. 
True. But it can get a lot more indepth than that, with lists nested 2 or 3 objects deep that cross reference to other lists that are a couple levels deep from the original data object, it's really pretty messy. I wish I could give a real life example, because a lot of people don't believe how poorly organized incoming data can be in real life situations. :-D but I think I'm prevented from doing so, just in case my employer were to get pissy about posting something from a live system. And yes, the first thing that I do after receiving input that sucks like that, is break it down into smaller bits that are usually in a format that is more suitable for the desired operations that we need to perform. But I do get a lot of "why do you spend so much time parsing the incoming data into a different format?" ... because that makes the code that needs the data much more simple. Using CPU time and memory when the user is not doing anything is basically free, using it when the user wants us to respond to them is costly. And of course, less complex code is always preferred. 
Think of it as an investment into your future. Shit, you MIGHT be able to write it off as a job expense or on your taxes since it is relevant to your career.
The idea is, Ill have my routes capture the request, send it to a controller, decipher whats needed and send that to the database 
No, it sure doesn't, and I certainly don't pretend to know everything, in fact, I mostly work in interpreted style languages, and have basically forgotten everything I once knew about lower level languages, due to lack of use. I do have a rather finely tuned sense for detecting when people are doing things that are far more complex than necessary -- and sticking to specific paradigms that are not suitable for the task at hand, for whatever reason, is one of those things. Pure FP is mostly relegated to academic pursuits because in the real world, users need programs, mostly, that are more than simple input X output Y devices. More realistically, though, this is a barely coherent article that one would think is about type safety in Javascript, but reads much more as "I wish we were using a different language entirely", which I suspect is fueled by making things more complex than they need to be to begin with. 
I am well versed in functional programming. The fundamental difference between me and the users here seems to be I'd rather roll my own functions than use .map or .reduce. It's faster, I'm a better programmer for it, and I lose none of the legibility that so many here seem to associate with .map or .reduce. And lets be honest, the difference in lines of code written is approximately 3 variable declarations between .map versus your own iterating function. It's not some sort of unmaintainable spaghetti behemoth. Functional programming is a tool in the tool box, and yes it's descriptive and wonderful, but it's not the only tool in the toolbox.
Only if you're an independent contractor. Stop assuming everyone knows exactly the situation you're talking about. Most developers are not independent contractors in the slightest, so in most cases, you're completely wrong.
This is awesome! Really cool :) Going through the gitbook now.
Dude, what?
If they think you owe money, they will find you.
I don't think I would agree FP is limited only to academic pursuits. We've a few years on the onset of scala, which along with F#, are enjoying continued growth in popularity and adoption. Javascript not too long ago had a "revolution" with FP and react, shortly followed by redux. This article mostly talks about the `Maybe` monad. This is basically baby's first monad and is fundamental to large swaths of functional programming. If *this* is tripping your "far too complex than necessary", then all I can say is you should probably get more exposure to FP before you start casting judgement on these things. Finally, this *is* about type safety. The code illustrated at the end of the article *will never* suffer from `undefined` or `null` values in inappropriate places. 
I almost wonder if some article-generating algorithm is responsible for these. I remember long ago hearing about an algorithm that created smart-sounding scientific papers, and at least one of those generated papers got published. The only other explanations are a spammer, but I can't imagine a spammer would put this much effort into original content. They would just copy-paste Wikipedia or something.
&gt; I cannot barely understand how the code can be the same on both sides, client and server For most of isomorphic applications that I've seen, and all of the ones I've worked on, the backend/frontend code isn't 100% the same. Given the same **state**, they produce the same rendered **view**, but how they go about doing that is up to them. When a framework claims to support Isomorphic Applications, it typically means that the code/business logic you write can be applied, unchanged, to both sides. However, the framework/boilerplate code wrapping your code may, and likely will, be different. For example, if you look at React/Redux applications that implement Isomorphism, they will often have very different ways of getting a hold of an initial state object, but once it's acquired, they pass it through the same reducer pipeline to produce a rendered view, and then they handle the rendered view differently (front-end spits it to DOM, back-end stores to a string to pass to front-end). If the app uses ReactRouter, it will need a History object. The front-end can just acquire this from the browser window object, but the back-end needs to essentially mock one out. So, the code that runs on back-end and front-end isn't 100% the same, but the idea is that, if a framework is properly designed with isomorphism in mind, all of the business logic that you write can be used, unchanged, on both sides.
Yeah, I said 'collection', because that's easy to grok, but when someone brought up the concept of `.then` being the promise equivalent of a `map` method, it was a real eye opener. I'd say the next "ah-ha" moment is when you understand that `reduce` is the `NAND Gate` of the FRP world, in that you can build all the other operations (map, filter, find, etc) from it, and by doing so, can essentially inject "middleware" like logging or lazy evaluation with little hassle.
Great response. Hiring is hard. Will keep at it.
If this is possible, I wouldn't want to see it done in the public web. Once I depart from the site, that site shall have no more say over anything in my window.
Isn't he the same guy who made that video bashing JavaScript? It's on youtube, cannot find it, but I remember commenting on it and basically telling him to fuck off. I guess he just loves JavaScript and was probably just making the video to show the negatives (nothing wrong with that, all languages have some faults). I am now trying to find the video so I can delete my youtube comment.. I didn't know he was actually this advanced though. 
I specified freelance developers, smart guy. Maybe if you had better reading capabilities, you might have understood from the get-go.
Understood, this is not something we need per say, more a side project of mine that perhaps someday will work well enough to deploy at work
By relatively new developer do you mean you have &lt;1 yr experience / recently graduated? If not, you can ignore what I'm about to say because someone with work experience isn't really the intended audience. In my unqualified, I'm-not-a-hiring-manager opinion: team projects are what would likely catch an employer's attention more than whatever technology you were trying for a solo project. Even if it was just a weekend hackathon, at least having something that indicates you're a team player is a good thing. Plus, you'll be networking and getting connections with other developers which is another way to get a job. The interviews I went on as a graduate always focused more on teamwork, every time I was asked "how did you resolve a conflict in your team?". It was pretty much the question they seemed to care about the most. I talked more about the project I did where I was responsible for more documentation than coding.
"dependancies"? Seeing the same grammar mistakes over and over is really annoying.
Having just glanced at this you could probably simplify this by using a state machine like [stately.js](https://github.com/fschaefer/Stately.js/) or streams like [bacon.js](https://baconjs.github.io/)
I would also take a look at [Ramda](http://ramdajs.com/0.21.0/index.html). Or something like [Hanuman](https://www.npmjs.com/package/hanuman-js) if you need something more lightweight.
You're translating it down to it's individual steps. I was translating it down to what I perceive that it's output should be, when given just about anything. Without knowing what, specifically, the output should be, because there's no discussion whatsoever of what that should be. It is not clear from the code, what it's input or output is expected to be. That makes it just plain terrible code. * edit: I might be able to glean, that it's look for a String as an input, but that's just an assumption I make from looking at it, without having any idea what the library involved that is pulling all the weight is looking for From what I'm reading, a "Maybe" is guaranteed to return any one of "Something" or "Nothing", and "Something" is any valid possibility that is not "Nothing". We have that in javascript already -- It's called "undefined", and "everything that isn't 'undefined'". That's not helping anything at all. 
You not understanding it isn't the same thing as it not being clear. Your response to not understanding something *should not* be "this is over-engineered" or "this is terrible code". It was fairly clear to me. I don't know exactly what their `L` or `N` object does, but as I specified, that's not actually very relevant to understanding how data is flowing through that piece of code.
Well, I'm not sure I would call it special so much as sane. Pretty much every other language with for loops operates under the javascript let special mode. `let` was Js's way of reigning several poor language design choices of the past (actually, was the even designed or is it something that became standard because that is how it was worked in IE?).
exactly what I'm talking. all hybrids work with native promise if available, otherwise what you provide.
polygoat doesn't require any Promise implementation neither native nor polyfill nor ponyfill nor shim nor whatever
Any kind that allows me to accomplish the above criteria, I suppose. Given, I think it has to be an object-relational database to meet the criteria.
I'm from high energy physics and all papers are technically published by "The Collaboration". I wasn't fortunate enough to get a paper through the collaboration in time to graduate, meaning it just left there hanging. It's different in theory and in solid state. Also I'm not intending on staying in academic physics, so my experience is from doing data analysis on millions of collision events, writing a framework to analyze that data, and writing a 300 page paper on the results. There's more, but industry doesn't see that as experience, they see it as school work (on average). 
I do think that's my best bet. Just need to sell it properly to equate millions of physics collisions to industry big data analytics. 
This isn't the best subreddit for this, but I'll give you a few pointers. You'll need a list, also known as array. Give this a read: http://www.w3schools.com/js/js_arrays.asp Make sure you understand what it is and how it works, specially the *Access the Elements of an Array* and *Looping Array Elements* examples. Using the knowledge from that it's simple, you just have to access the previous elements in the list and sum them, then continue filling up the list as you advance.
In practice, I find I use map/reduce as general purpose data mappers. Sure, your example for multiply is quite general and can be used repeatedly whenever you have ... an array of integers and need them multiplied. I find a slew of cases where I have a bit of data and I need to turn it into something else for .. whatever it'll be. I'm not about to add something to Array.prototype for each one of these things - that would be insane. That's not to say you can't do something like -- var arr = [1,2,3,4,5,6,7,8,9] const multiply = (v) =&gt; (v2) =&gt; v * v2 arr.map(multiply(5)).map(multiply(10)) Which does the same thing. Maybe not as performant as for loops will win out over closure callback functions -- but this to me is cleaner and has fewer side affects. For my two cents, I'd much prefer the look of using map/reduce over a for iterator that pushes back to an array.
I'm not super keen on rewriting your server and handing you the answer. Mostly because I'm lazy but partially because you won't learn anything. Create a JSFiddle with a reimplementation and I might take a poke at it?
No you couldn't, if your pre-requisite for using promises, Q or whatever... were that you refused to even learn the names of the methods and what they do before declaring them incomprehensible.
I agree that's perfectly acceptable - a lot of code written with map is perfectly acceptable. Does that make it a necessary language addition?
Refactoring I don't object to, you need to do that to keep code manageable, or at least you need to do it to the parts you continue to interact with. But he's not refactoring, he's making little stylistic tweaks. While I'm all for normalize code style, it's much less important what you normalize on. Switching to another style is something any competent developer can do (and something incompetent developers love to whine about). This guy says in the article, the goal here is to be able to continuously change the code base's style to keep up with what's trendy, and that's just misguided. The correct way to handle code style is to give it as much attention as necessary to avoid friction, *and no more*.
Necessary? Maybe not... I'd call it more 'low hanging fruit' with a lot of the other new extension methods on built-in globals. I mean, most of the times I use anything in lodash, it's going to be merge, map and filter... and maybe combining them with chain.
I'm talking about asking you to implement a skip list to test your chops.
&gt; Can I remove it? &gt; Yes, ... ?
This reply, given the reply above, literally made me lol. Like /u/FormerGameDev, I am also a former game dev and I agree with just about everything he's said. There are good things to be gleaned from functional programming concepts (especially immutability), but the code in the article is almost totally inscrutable unless you have fully grokked functional programming, and that pretty severely limits your audience.
**Due to the complex data model, I would like to do as little mucking around with the database as possible.** Probably a schemaless solution would be easiest, mongoDB? Anyways Step 1: figure out which database you're using. Step 2: find an ORM to manage it for you.
I don't mean just handing me the answer, but how and where I might incorporate said libraries into my program. 
&gt; What projects do you think instantly catches an employers attention? Something ambitious that solves a really hard problem and is very simple to execute. It sounds like you might be looking for some sort of quick win that achieves maximum thrill. Unfortunately, this does not impress potential employers.
I would agree to leave at be, but I feel I wasn't clear enough or you misunderstood me. I meant "you" generally. One is not meant to plug their ears when they don't understand something, etc. Until you specifically start saying the code is shite and isn't worth learning for whatever reason, I wouldn't say you specifically are rationalizing not learning it. I would just keep in mind that we (inclusive) are not often writing code for the lowest common denominator. Just as one can go too far with FP for one's audience, one can also get lost in the FactoryProviderProxyBeanImplementation forest with OOP. 
Perhaps your reading of the article wasn't very charitable? Their opening referenced &gt;Millions of lines of JavaScript have been checked into source control at Airbnb over the past **8 years**; meanwhile, frontend Web development has evolved dramatically. Their closing, also, had this: &gt;Using available codemods and a few that we wrote and contributed back, we quickly made **big improvements to old code**. I have modified 40,000 lines via codemod with little effort, which brings a lot of old code into better compliance with our ES6 style guide. (emphasis is all mine) Which doesn't sound like "continuously change to keep up with trends" so much as "Ahhhhhh! We have thousands of lines of old code no one wants to touch!", to me. That is to say, I interpreted this as them trying to find a way to maintain and update their legacy code to be a bit less legacy.
Front end heavy enterprise web application development, .Net, SQL, lots of Javascript, too much Ajaxtoolkit!
https://medium.com/airbnb-engineering/turbocharged-javascript-refactoring-with-codemods-b0cae8b326b9#.iysoicee5
 Object.defineProperty(Array.prototype, 'multiply', { enumerable: false, value: function(multiple){ var retArr = []; for(var i = 0, l = this.length; i &lt; l; i++) retArr.push(this[i]*multiple); return retArr; } }); var arr = [1,2,3,4,5,6,7,8,9]; //You honestly tell me, which code is more functional? Which is more legible? More maintainable? arr.map(function(val){ return val * 10}).map(function(val){ return val * 5}); arr.multiply(10).multiply(5); I'm not... entirely certain you're being honest or straight here. You're monkey-patching the array prototype for *one*, very specific use case of multiply. What if you need to add, now? Do you want to add another function that does adding? What if, instead, we kept 90% of your `multiply` function, and just passed in another function that did the single part that was different for adding, multiplying, etc? Like this ... Object.defineProperty(Array.prototype, 'callForEachMember', { enumerable: false, value: function(callback) { var retArr = []; for(var i = 0, l = this.length; i &lt; l; i++) retArr.push(callback(this[i])); return retArr; } }); Then you could do this: arr.callForEachMember(x =&gt; x * x); arr.callForEachMember(x =&gt; x + 2); arr.callForEachMember(x =&gt; x ** x); // etc ... Now, what I just wrote is `map`. And if you asked me what's easier to read between: arr.map(x =&gt; x * 10).map(x =&gt; x * 5); arr.multiply(10).multiply(5); ... well, I'm going to tell you the `map` one is. If you really wanted to, you could even do this: let multiply = mult =&gt; x =&gt; x * mult; arr.map(multiply(10)).map(multiply(5)); 
tldr plz
i... just... wow... I can't tell if this guy is just a github troll or a complete cockwad.
Silly little game, but neat. Really good level of commenting you've got going there. If you're open to feedback, [`_` is a *very* unusual variable name for a `this` reference](https://github.com/brenolf/dash/blob/gh-pages/js/dash/dash.js#L81). I would suggest `self` or `_this`. I'd also say to put [this all on one line](https://github.com/brenolf/dash/blob/gh-pages/js/dash/dash.js#L238) if you're going to drop the braces, which makes it a lot harder to accidentally stick a new line there without adding the braces back.
Okay, ignore baconJS. Express handles a request for player 1 -&gt; stores the weapon used Express handles the request for player 2 -&gt; stores the weapon used Once both requests have been handled in either order (i was suggesting using bacon to determine this but you can use any way you like) you should use the state machine. You have a state machine defined like this: rock: { paper: () =&gt; playerTwoWins(), scissors: () =&gt; playerOneWins(), rock: () =&gt; draw() }, paper: { paper: () =&gt; draw(), scissors: () =&gt; playerTwoWins(), rock: () =&gt; playerOneWins() } // etc... the initial state is chosen from player 1's weapon, the child state (the nested three) is chosen by player 2's weapon. Function is called to return the result. Does that help? 
http://nvm.sh maintainer here. As of the latest version, if you `nvm install` something when you don't have a default alias set, it will automatically set that version as your default. Ideally this helps new users the most.
Neat. I've done something like this for a little while now. It's survived knockout, angular, vue, react, and will probably continue to be relevant for a while longer yet: app/ components/ foo/ foo.styles.css/less/sass/styl foo.logic.js/jsx/ts/cs/ls foo.view.html/haml foo.readme.txt/md foo.spec.js/ts/cs/ls services/ someService.js ... someService.spec.js ... areas/ home/ home.logic.js ... home.spec.js ... services/ someHomeService.js ... components/ home-banner/ home-banner.logic.js ... Unit tests, documentation, styles, logic, view, all in one folder, all in one place. The naming convention makes it very easy to open by file name in e.g sublime or really whatever. Each area can have basically the entire folder structure nested within it. The `home` might have some components and services specific to it. But, if I realize it's applicable to more than just `home`, I just drag it up one level and put into the correct "global" area.
25 shmeckles?!
&gt;We all had enough of Hillary Clinton’s emails servers. I don’t think many really cared about it [...]. "So I made a project about it!" ;)
Oh, huff. It's the same thing you were talking about, only formalized a bit more.
Thank you. Looks like exactly what I was going for.
This is the closest I've come to being convinced that map may serve a useful function versus various functional or non functional implementations of for loops. Thanks for the feedback.
Sure, and optimization *can* be a valid concern to have. If you're iterating over millions and millions of items? That might be a good time to use as low an abstraction for iterating over them as you can. You probably have much bigger problems if you have to iterate over that many items, given, but the point remains. 99% of the time, the `map` (and friends) will perform well enough that it will not be a real concern. I think there's something to be said for new people finding the `for` loop easier, but, on the other hand, this is code *I* have to maintain as well. That's an important thing to balance out. Do you want to be writing the 4-5 lines every time you want to do some projection with an array, when you can do it in one? Personally, as a rule of thumb, the fewer lines I have to write, the fewer lines I have to maintain, the fewer lines I have to debug, the fewer lines that can go wrong or have a bug in them. There may also be some initial cost in learning what `map` is, but imo, this is one of the most useful things you *can* learn. If you learn `map` and `reduce`, you can describe just about every kind of data projection and transformation there is. In fact, if you understand `reduce`, you can even implement `map`! For me, `map` is a simplified, standard, error-free way of representing the intent that my code wants to create a new list of items by applying a certain transformation to another list. This is, to me, the **most useful** thing about it - it communicates your *intent*. You could say the `for` loop also communicates this, but you can use a `for` loop to do all kinds of things. You can only use a `map` to do one kind of thing. Therefore, it takes me less time to read, parse, and understand a `map` than a `for` (especially if I'm looking for things like common fence post errors). It's small, of course, but it can add up. Hope this helps!
When I say tools, I mean utilities like grunt, bower, ember-cli, etc.
For the front-end, there's so many different kinds of issues that come up in different browsers, different operating systems, that it was a major turn-off for me when I was starting out. In the server-side, things are very clean and well-defined.
Thank you all for your thoughts. Since I would have to type out quite a lot of the same stuff for each direct reply, I'm coupling it all here instead. So as I mentioned, I'm just now starting out with learning front-end development. Unfortunately, there's so many choices of frameworks out there (Angular 1, Angular 2, React, Backbone, Ember, etc., etc.) that for me, it's a bit difficult to choose what framework to learn. Then, when I do start going through the tutorials/guides for a particular framework, they're always in the vein of: 1- Install npm 2- npm install grunt/bower 3- npm/grunt/bower install &lt;framework&gt; 4- &lt;framework-cli&gt; set-up-project 5- Start writing some actual code 6- &lt;framework-cli&gt; run-your-code Now to me, that's very off-putting as I feel that I should be able to simply put the relevant JS/CSS files in my HTML page and get down to writing the code. Since I'm not looking at full stack JS, I don't really need the NodeJS server as my Nginx or HTTPD server should be able to serve the relevant files for me to test. Now, I understand that it *is* possible to do that, but it seems to be either not that obvious, or not well documented (at least in the official guides). For example, from what I've seen in forum posts and such, ember-cli seems to be the recommended way of doing a project in EmberJS. This makes me concerned that perhaps the 'old-school' approach is not well-liked and if I were to apply for a front-end job, I would either not be hired OR might have a difficult time at the job.
Template engine or virtual dom, event emitter, browserify and some object observ lib from npm.
&gt; code no one wants to touch I guess that's the question. I'm assuming it wasn't in such bad shape that this is the case. If it is, then you're right, this is worthwhile.
Yeah. That helps. Thanks!
"built in vanilla JS" uses jQuery fun game though
Thanks a bunch :)
I didn't hear about Ramda, this lib looks pretty neat.
i bet there is an generator on github for this kind of posts ....
And HammerJS.
lol
"The most amazing characteristic of AngularJS framework is that it is developed by Google" Okay...
Thanks! Hope you like it
Whoops, thanks!
&gt; MongoDB [No](http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/).
Excellent answer :) I'm really happy this post is generating some "movement" and we're all getting answers like this. You made a good point... "Most apps don't run exactly the same code in both places". That's a thing that gets me closer to what my mind can understand (right now haha). But, for example, if you watch videos about "angular-meteor"+"angular-server" this is the concept that is "sold". Same code everywhere and that is so daaaamn goooood that it is also confusing. I leave an example of what I'm talking about: https://www.youtube.com/watch?list=PLhCf3AUOg4PgQoY_A6xWDQ70yaNtPYtZd&amp;v=_mu6BWsnaPM Another thing that comes to my mind is that we are almost always focusing on "rendering", but what about things like shared APIs? (I think there are some mentions in the video above. Min 34-35 aprox) Thanks again for such a great answer.
**Best** 10, huh? Why not best 100.
Would really love the pipe. Have been marketing it around the webs. Lets hope it will get more traction. 
Hi, I’m one of the organizers at Full Stack Fest 2016 (https://2016.fullstackfest.com/), a full-stack developer conference which will be held in Barcelona during September 5-9 2016. Our Call for Papers (https://2016.fullstackfest.com/call-for-papers/) is open until May 14th and we’d love to receive some proposal from this community. We’re providing paid travel and accommodation for the selected speakers worldwide :) We would really appreciate if you could spread the word about it within your members. You can also find all the details in a PDF if you want to distribute it: https://2016.fullstackfest.com/full-stack-fest-2016-cfp-press-release.pdf Regards.
i'm sure you have, mine is not an unusual outlook
cool, you can also check my simple mvc implementation :) https://github.com/DrakeLeung/demo/blob/gh-pages/patterns%2Fmvc%2FREADME.md
 Why go with that realisation? Take your age as an advantage and connect with the interviewer better than a younger person might. I'm sure you have plenty of job experience and interview experience to know that it's all about selling yourself, not how well you can design a solution to a particular algorithm. Is there any harm in asking the interviewer "Hey I haven't done this algorithm in a long time, could you give me a brief run down on how it's suppose to work again? Do I visit every node on my current depth or do I explore all the child nodes first, then go back to the initial node?" Absolutely not. If there is, probably in the wrong interview.
wow, great! Cool design
Well, shit, you better get down to the Calais Jungle and let everybody know about this philosophy.
Stopped reading the moment he said CoffeeScript is awesome. Anyone who supports CoffeeScript has zero credibility in my eyes.
Cool! A package like this really ought to support 2d barcodes too. :) 
Complex interactions like that are greatly simplified with FRP approaches. I recommend you take a look at cycle.js 
[and this too](https://en.wikipedia.org/wiki/ShotCode) 
2 space indent? No semicolons. Nope. 
Implement an entire OS in the browser. 
&gt; Never start a line with ( or [ so, no readable JSONML and no IIFE closures? pass.
Yes many, including some big names like [npm](https://github.com/npm/npm)
Wow! Thank you for making a good library. :D
Really interesting. If I recall correctly, there was a known project from the React space using it, too.
No problem. Trying to have it be everything that anyone can need when it comes to 1D barcodes. With the 3.0 release I think I'm coming pretty close to that :)
It's not spam per-se, its shallow articles like about.com would write. About.com articles are great--if you know next to nothing about a subject and only need the thinnest veneer of knowledge to impress your friends. Or they're great if you know all the backing details, and just need a refresher (i.e. you can cook, but you need a half-remembered recipe). This stuff she writes is very similar to that. Pointy-hared bosses must love it for giving them the thin veneer of knowledge.
Thanks for pointing that out. I have always been pretty horrible at grammar and usually I have my wife read my stuff over but didn't this time.
Would this direct users to a website via a QR Code scanner or something like that?
I will say I would expect map or reduce like tools in any array handling or object iterating library, yes. Is it functional? Yes! I feel like because people are spoon fed functional programming with calls like .map or .reduce means they feel they are the building blocks you describe them as. Does that mean you couldn't use a for loop to create the exact same functional calling structure, the exact same building blocks? No. In languages like C# where lambda expressions are themselves ubiquitous I'm much more inclined to see your point as a fundamental building block of the language. But JavaScript just isn't there. Much like PHP, it's just got so much baggage that unlike Python or C# it can't just drop in a new version. Blame browsers, blame whoever. I would be more inclined to agree with the statement: in ES6 reduce, map, and lambda/arrow expressions are fundamental functional building blocks and for shouldn't be used when a functional alternative exists - and when for is used it should be functionally wrapped. I mean, lets be clear, even in Chrome arrow expressions have been around for less than a year! So I suppose in some ways you've convinced me?
I'd also like to thank you for taking the time to try to convince me. Just because I disagree with you doesn't mean you haven't made me seriously consider how I view map and reduce.
&gt;In languages like C# where lambda expressions are themselves ubiquitous I'm much more inclined to see your point as a fundamental building block of the language. But JavaScript just isn't there. The fundamental unit of abstraction in javascript is the function, and we use them to make everything from modules to classes. While javascript does not have as many expression forms as I'd like, you can still make anything an expression *arbitrarily* with an IIFE: if ((function() { return true; })()) { console.log('hi'); } (please don't actually put an IIFE in an `if`, it's just illustrative) &gt;So I suppose in some ways you've convinced me? I'd say, at this point, just give it some time to think over and stew fully. Whenever I am approached by an idea I am not immediately open towards, I will often have to force myself to keep thinking about it occasionally from time to time. It can sometimes result in me gaining insight that I hadn't prior and coming myself to agree with the idea.
When the `putOn` function is in the constructor, a new version of the function will be created for every instance of `Shoe`. So if you have 1,000 shoes, you'll have 1,000 `putOn` functions. When it's on the prototype, all instances will refer to the same function. On a side note, if you're directly assigning the prototype to an object literal, you should assign the constructor property to the constructor: Shoe.prototype = { constructor: Shoe, putOn: function() { alert("Shoes on"); } };
You can't have it both ways. If asking algorithm questions is a good way to see how people think, its a good way to see how _you_ think. The point is, these questions are as worthless to as most candidates as interviewers. You're much better off trying to figure out how a company deals with technical debt, resolves differences of opinions, etc... And, I'm being a bit two faced about this because I always ask a binary search type question. The last hire who absolutely aced it has turned out to be a huge dud. Then there's the example of Hired. They cherry pick the people who do the best on their tests and give them offers rather than passing them on to other companies. And their culture is a shit show.
I did not know your library, pretty nice! I sure will use it in the future for some project! 
&gt;2 spaces – for indentation No thanks. 4 = tab = more readable. &gt; Single quotes for strings – except to avoid escaping I prefer double quotes. What is the argument for single? &gt;No semicolons – It's fine. Really! Nope, I don't like to have to infer that a declaration or expression has ended. 
&gt; IIFE I think with this style you just pre-pend IIFE's with a semi-colon. I'm not familiar with JSONML.
Software engineers earn less than in the USA in most places around the world, but cost of living + other benefits are generally an improvement over those in the US. Much more vacation time and unlimited sick leave mandated by the government in many countries, and insurance and healthcare costs tend to be much lower in general.
but... &gt; No semicolons
This is the exception. If you start a line with ([`, you should prepend it with a semicolon. This is good practice anyway. The linked page has more info 
Backbone didn't delete itself from the universe. Use a [virtual](https://github.com/leeoniya/domvm/) [dom](https://github.com/trueadm/inferno/) [library](https://github.com/facebook/react) for your `render()` so you don't run into composition problems and skip using Backbone's event handler stuff. I think there are better ways of managing state in an app but I transitioned a number of Backbone projects to React for the view layer and it worked fine.
Could you explain constructor: Shoe and what t means and its purpose?Thank you!
Looks interesting but I think they should have the supported barcodes on their README.md 
Is that just a JS thing for you? I feel like Ruby and Python read pretty well, and similarly for me, JS without semis.
It's not finished yet...
Thanks, I'll steal that phrasing in the future. The "hurr functional programs can't *do* anything" fallacy comes up far too often. 
Could you please post an example of your code? I am having a hard time understanding what you're trying to do. In addition, could you please elaborate as to why you're running a while loop on a Google Map instance? How are you structuring your application? Which tech stack are you using?
Thank you for this!
Yes, most of my projects do. One of them: https://github.com/jprichardson/node-fs-extra (fs-extra) is around a top-25 project on npm.
Per day 
&gt; It's compatibility with different browsers is not there yet to make it qualify for release ready status. Yep, that's why optimistic estimates put it out in June at the earliest. Still issues to resolve, but that's how software in beta works.
Objects have a constructor property that lets you access the constructor function that created them. This property is inherited through the prototype. Every default prototype object has one. If you replace the default prototype object with an object of your own you should also make sure you add in the correct value for the constructor property or it will be wrong for the instances created by that constructor. {}.constructor // Object function Shoe (){} new Shoe().constructor // Shoe Shoe.prototype = {} new Shoe().constructor // Object 
https://medium.com/@scottluptowski/code-sharing-between-react-native-and-react-web-apps-b1e1de22fc53 Whoooops
Oh, you might also want to take a look to Booshelf.js or Knex if you want something more low level.
In practice, it probably won't make much of a difference. Even if you don't reassign the constructor: var myShoe = new Shoe(); myShoe instanceof Shoe // returns true However, if you want to check the type of an instance, you'll want the constructor property to be there: myShoe.constructor === Object \\ returns true myShoe.constructor === Shoe \\ returns false This is why it's generally a good idea to just add functions to the prototype instead of overriding it: Shoe.prototype.putOn = function putOn() { alert("Shoes on");} 
&gt; http://codepaste.net/oci63r Are you running initMap() somewhere else hoping to initialize all the maps at once? I would also recommend using classes instead of id's. id's are unique so you can only have one element using each id. If I could suggest a new approach, I would switch the id map to a class and then add the lat/long as attributes like `data-lat=num`. Get rid of the JS in the loop but instead run some JS when the page loads to loop through all `.map` div's, pull the attributes for lat/lng data and then create the maps.
In what universe can relying on a badly implemented, unconfigurable, runtime error correction mechanism to produce the source code of a program be considered not only "fine, really!", but also "standard"? It's like claiming it's ok to stop your car by running into things instead of using the brakes. It works, after all, and is very elegant, when you think about it. No need for complex braking mechanisms, and you stop the same way many other things stop. Why not? There might be some disadvantages in terms of collateral damage to the car and other nearby objects, but as long as everyone understands that you aren't going to use your brakes, it's fine, really!
It's the future... today! What a time to be alive...
&gt; I prefer double quotes. What is the argument for single? Fewer keystrokes and it looks nicer.
Learn English please. Then learn Javascript. Then come back and ask again. 
Hi /u/haterofallcats, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Forgive me for my noobiness.But what is NodeJS,Eloquent Javascript,CSS,DOM,and jQuery?Different programming languages?
Yeah, I'm looking at Bookshelf right now. My only issue is, it's all SQL and tables and such. I don't need that, I don't need anything relational. The prototype of each object ensures its structure and its relation to other objects. All I want is for a server somewhere to let me read and write persistent data in the form of regular Javascript objects which will persist on the server, and to run queries of all objects matching specific attribute criteria. While Bookshelf and the like can clearly do this with some work... it's like fishing with dynamite. I don't need all the stuff that's there, in fact I'm tempted to try a solution building on IndexedDB or something instead.
The value in Standard was that it was the first linter where I didn't have to mess around or think about anything. I just downloaded it, it ran, and told me what I needed to fix. Then I could get back to work instead of worrying about trivialities such as using semicolons or not, two spaces, or four, etc. It was the very first linter to do that - no thought required. Now I can enforce style over all of my projects, if people want to participate, it's a style they have to follow. It's not so much about the choices, but encouraging the dev and their team to just pick something, stop bikeshedding and be productive. 
I'm honestly confused about that. I know they use the Chrome JavaScript engine to do some amazing stuff. I'm not sure if it IS JavaScript or if we should call something else. 
I'm pretty sure it *is* javascript, just a different and somewhat unique implementation. But I don't even use it, so I'm not the person to ask.
Absolutely not, seriously. Try Python Ruby, or even Java. In fact, pretty much any other language. Then learn javascript. 
Absolutely agree, dynamic languages are a great way to get started with programming, but Javascript has too many caveats to serve as a good first programming language.
How is Java different from Javascript?
First thing you need to do is understand prototypial inheritance as it's implemented in Javascript. Let me give you a rundown: **Prototype chain** Every instance has a prototype chain. This is a list of objects that they "inherit" from, and is stored on the instance as a hidden property (usually called `[[proto]]` or `__proto__`, I'll refer to it as `proto`). Note that this is **not** the same as `.prototype`, the latter being a totally normal property that just so happens to be used for something special. For instance, if you do function Foo() {} Foo.prototype.a = 1; var bar = new Foo(); Your new instance, called `bar`, will have its `proto` set to `Foo.prototype`, which in turn has its `proto` set to `Object.prototype` (because it's an object, see the last paragraph of this comment for more). The prototype chain for `bar` is then `bar -&gt; Foo.prototype -&gt; Object.prototype`. When you ask Javascript to get you a value, for instance by trying to read `bar.a`, Javascript goes down through the prototype chain: 1. Does `bar` have a property called `a`? If so, return it. 2. Does the next step in the prototype chain, `Foo.prototype`, have a property called `a`? If so, return it. 3. Does the next step [...] 4. If we've reached the end of the prototype chain before finding a property, return `undefined`. This means that if you run the above code, and then do `bar.a`, you'll get `1` returned because a property called `a` was found on `Foo.prototype`. If you do `bar.b`, you'll get `undefined` because no object in the prototype chain has a property called `b`. If you do `bar.a = 2` and then do `bar.a`, you'll get `2` because `bar` comes before `Foo.prototype` in the prototype chain. This is also what makes `instanceof` work - `bar instanceof Foo` just checks if `Foo.prototype` is in the prototype chain of `bar`. **Proto** But Javascript needs a way to know how to create the prototype chain. You can do so manually using [`Object.create()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create), but normally you use the [`new` keyword](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/new). This operator does the following: 1. Creates a new empty object 2. Sets the constructors `.prototype` object as the new objects `proto`. 3. Calls the constructor, with `this` set to the new object. 4. If an object was returned by the constructor, return that. Otherwise, return the new object. The important step here is number two. This makes it so that the prototype chain of the new object is set to `Foo.prototype` when you do `new Foo()`. *This* is where the prototype chain is created - not when you set `Foo.prototype` to some value. This is also the reason that the `proto` of `Foo` isn't set to `Foo.prototype` - `Foo` wasn't created using `new`, so its prototype chain was never set. Note that JS sometimes hides the `new`. Writing `{}` is the same as writing `new Object()`, `[]` is the same as `new Array()`, `function(){}` is the same as `new Function()`, etc. This is getting a bit long, so I'll write about **this** in another comment.
This is /r/javascript, so this is going to get downvoted to hell, but still... No, it is not. Javascript is a bad first language in pretty much every way other than making nice-looking toys quickly, and even that is questionable. Why? Because the language itself sucks, it is very fragmented (there are many versions with different levels of support and there are different dialects all of which have bad editor support), there is no common style guide/list of best practices and the community changes very rapidly. More details: * Javascript is an untyped language with many insane rules, which can be confusing even to people who had previous experience with other programming languages. For a first language, I suggest a language which forces you to think about the architecture of your program and the data types you are working with, i.e. a statically typed language. * In my opinion, the first language you use should be strict and its tooling should provide human-readable feedback on your errors. That's why I suggest you start with Java - it has the best feedback out of all the languages I've ever used, its tooling is great and the documentation is stellar. * What is Javascript? Would you include extensions like JSX and Flowtype? Everyone has their own way of writing Javascript. Other languages also have different "accents", but none of them are as bad as Javascript in that regard. The reason why a lot of people are talking about Javascript is because a huge amount of effort goes towards trying to make it less painful to use. As a beginner, you probably want a boring language with an an active, yet calm community. EDIT: Oh, and setting up a nice Javascript environment will take you many hours. Installing an editor, then hundreds of plugins for that editor, then configuring the build system, etc... takes a long time. To get started with Java, on the other hand, you'll have to install the JDK, download and extract an IDE such as Eclipse, and then you are pretty much done. It takes me about 5 minutes to set up a complete Java dev environment, and about 2 hours to set up a JavaScript dev environment.
Wow.I did not know it was this bad.I will try java based on your recommendation and python.Thanks for bringing this to my attention.
Another Medium.com bitch fest.
Damn yeah. I'm from Barcelona and it looks extremely interesting. For sure, I'll try to be there. Thanks for bringing people like A.Staltz to the event :D Buenas noches!
I don't really agree on the setup part, many ide's do linting out of the box, and installing npm with some gulp flavours is really not that much of a hassle to start out with.
They are as similar as Ham is to Hamster. edit: I should probably clarify this statement (which I didn't come up with by the way). Java and JavaScript are related only superficially. Their syntax's are both inspired by the C and C++ languages. Around 1995 (I think), when JavaScript was first created, Java was being heavily marked. The inventors of JS had the brilliant idea of naming their product JavaScript to piggy-back off of the popularity/advertisement of Java. And it worked... Though it still leads to endless confusion. But yes. In essence, they are NOT relatable. Java as a language is probably most similar to C++, JavaScript is kind of a weird beast that I'm not able to accurately compare to another language since I am just in the beginnings of learning it myself. To answer your initial question, I don't think that JavaScript is a good first language to learn because it is extremely complex and forgiving (it'll let the beginner get away with things that they should NOT get away with), but mostly for the reason that you will have to learn it via "web development" which is a whole nother thing that I think is not so good for a beginner to pollute their concentration with, as it's only tangentially related to "hard programming". I personally would suggest C as a starting language. Python is another good start. Java is another good one. Which one you choose depends on your inclinations: You want to learn about computers at a very low level (e.g., the little bits and bytes/small details)... Start with C. You want to get up and running coding non-trivial apps relatively quickly... Start with Python. You're not sure and want to learn something that is generically relatable in style to other commonly used languages... Start with Java. More importantly, start with programming. It doesn't really matter what you choose as most knowledge you gain will transcend the language you learned it from. Programming is more of a mindset, a way of tackling problems, than it is learning a specific language.
`this` isn't the same. Its a whole 'nother beast. The value of `this` is determined at call time for a function (though in global scope, when not in a function, it references the global object). It is defined dynamically for a particular call based on the object from which the function was called. Consider the following: function printName () { console.log(this.name); } var a = {name: 'a'}; var b = {name: 'b'}; a.printName = printName; a.printName(); //-&gt; 'a' b.printName = printName; b.printName(); //-&gt; 'b' One function, copied over to 2 different objects, and each time it is called, the value of `this` is different. JS looks at the call site to determine what object the function is being called from and assigns `this` accordingly within that function body. This is, in fact, how shared methods in a prototype are able to work since you have one method that can be shared between multiple objects based on the fact that `this` will dynamically point to the correct object - the one that's calling the function. You can influence the value of this at call time without reassigning it to another object with `call` and `apply`. And if you want a version of a function where `this` is a very specific, non-dynamic value, you can use `bind`. printName.call(a); //-&gt; 'a' (not referenced from a; call makes the association) var printB = printName.bind(b); printB(); //-&gt; 'b' (not referenced from b; but b is bound to `this` through bind()) There is an exception to this rule: constructors. Constructors are an appropriation of normal functions to use them as factories for creating objects. The `new` keyword is what changes their behavior from normal functions to constructors of objects. As a constructor, a function behaves differently, and one of those differences is how `this` is defined. Consider a normal function: function Constructor () { // &lt;function body&gt; } When called with `new`, it gets transformed into something like this: function Constructor () { this = new Object(); Object.setPrototypeOf(this, Constructor.prototype); // &lt;function body&gt; return this; // + also hijack any returns in the function body // that don't return an object to return this instead } In a constructor call, `this` represents the new object being created. It's created for you automatically before the function code can run. That object is also set up to have its prototype set to use the Constructor's prototype property (which is _not_ the prototype of the constructor, just a property name that this process knows to look for when performing this action). The function body then runs as normal, and without you having to say so in that function yourself, the object being created (`this`) is returned. `this` does not reference the constructor function itself, nor does `this` usually ever reference the function instance thats calling it (unless you did something funky like assigned a function a property with a value equal to itself). So your `ConstructorExample.a` would not have been created. What does association does a new object created from a constructor function like this have with its constructor function? Nothing other than it has a prototype set to that constructor's `prototype` property. And by default, function `prototype` objects have a `constructor` property in them pointing back to the function itself. So when you make a function function Constructor() {} Automatically, this happens: // in the background Constructor.prototype = { constructor: Constructor }; When you create a new instance from that constructor function, the object that gets created (as `this`) gets that object as its prototype so: var instance = new Constructor(); console.log(instance.constructor); //-&gt; Constructor (taken from Constructor.prototype.constructor) You can use this inherited property to check to see if an object was created by a certain constructor, but you can't always depend on it. For example, what if someone defines they're prototype properties like this? function Constructor() {} Constructor.prototype = { all: [] // bad to do, by the way }; This creates a prototype that no longer has the constructor property... actually it does, but the property `{}` uses for its constructor. var instance = new Constructor(); console.log(instance.constructor); //-&gt; Object (taken from Constructor.prototype.constructor) The other way to check to see where an object came from is to use `instanceof`. It does not use the constructor property to determine if something is an "instance" of something else. It looks at the prototype. But this can also have issues because objects can have whatever prototypes they want through functions like `Object.create` but don't necessarily have to have been created from the constructor that houses that prototype. var instance = new Constructor(); console.log(instance instanceof Constructor); //-&gt; true (instance's prototype == Constructor.prototype) var obj = Object.create(Constructor.prototype); console.log(obj instanceof Constructor); //-&gt; true (instance's prototype == Constructor.prototype) You can see that even though Constructor didn't create `obj`, its still considered an `instanceof` Constructor because its prototype is `Constructor.prototype` (though `instanceof`will also search the entire prototype chain; it doesn't have to be the highest prototype). 
That's a good call. The concepts you learn in any language will transition to another. Once you learn one, others become much easier 
!function works too
That's what my dad told me when he heard I was learning programming.Only he wanted me to learn C or C++ because "if you learn these,you learned them all.The only things that changes from program to program is the syntax and different commands."I find python much easier though.
What other languages have you learned, besides js?
/u/magenta_placenta, you should be embarrassed.
it's tumblr for devs, yo.
Angular is losing traction, but it's still viable in most cases. If it's a big project, I wouldn't suggest angular as it's hard to reason to use angular with frameworks that are faster and better than an 'HTML6' attempt. React is a popular one, but it's hard to reason that it's any good (despite the huge community pushed by facebook) compared to other projects like mithril, vue, riot, virtual-dom that do it better. I don't know if you'll find a lot of help here, possibly meet-ups in your area will give you better ideas. Most of this subreddit is to learn javascript or to share knowledge about frameworks recently.
I'm not following the slippery slope argument either. The article you linked didn't say anything about the negatives of an "HTTPS everywhere" approach - it just stated that Google, other tech leaders, and privacy experts applaud the push for more TSL/HTTPS/encryption. &gt; ”Despite how common plain HTTP can still be today, it *is* outright insecure, and a real and present danger to users and to the open web.” That sounds like it's directly in opposition to your point.
In addition to everything above: -JavaScript has a wildly different inheritance mechanism than other languages (prototypal). Yes, new iterations of the language abstract this away, but I still think it's important to understand. -JavaScript doesn't run "top to bottom". While is not really true to say it's asynchronous, for all intents and purposes it feels that way. This could be very confusing for a beginner. I recommend C as a good first language, it will give you a solid foundation of the basics: types, control flow, functions, etc. Then move on to an object-oriented language, like Java, C++, or C#. If you make it that far, go back to javascript and realize how much of a mindfuck it is. 
If you start with a lower-level language like C++, things will only seem to get easier. Going the other way works but it can be more painful. Python is a great starting language because of how much it holds your hand. But it also means you can have a rough time once you start trying out languages that don't. The most important thing is fundamentals, though, and those don't depend at all on the language. Good luck and have fun :)
Par for the course!
I for one was not aware that functions were first-class values in C++.
I don't recommend it because of all of the stuff you need to type in just to get anything to work, which looks like a bunch of mystical incantations at first. Python is much better because you don't need to do that; Scheme is ideal IMO, even though it isn't used in much practical programming, because you will understand exactly what is going on when you read the code.
You're indexing it by the wrong loop variable. Try it as obj.files[j] 
It sounds like you got some tangible improvements, so it was probably worth your time. But the changes made here didn't obviate the need for pipelines or dependencies, they were made just to stay trendy. That's what I call a waste of time, not all uses of codemods.
It bothers me very much that a body responsible for the development of a language is now involving itself in the implementations of that language. This is very very wrong, and now we have works like [this](https://github.com/tc39/proposal-ptc-syntax) that not only change the syntax, but require that implementations process code in a specific way. Language specifications should only dictate syntax, input, and output. Worse, there are no actual issues listed for "proper" tail calls, and the justification is that it [can't hurt to reexamine them](https://github.com/tc39/proposal-ptc-syntax#issues-with-ptc) despite decades of study (reinventing the wheel; a common trend in JavaScript). Worse still is that this particular work calls for proponents of "proper" tail calls to defend its merits. That's not how the burden of proof works.
How can this thread not already have a recommendation for Douglas Crockford's "Javascript: The Good Parts"?
Uh, dude just wrapped a library in a react component; not exactly rocket science there
also look at http://brm.io/matter-js/
Fibonacci is a common learning example in programming. Google didn't return any code to do that?
I always like this one: One is essentially a toy, designed for writing small pieces of code, and traditionally used and abused by inexperienced programmers. The other is a scripting language for web browsers.
Performance-wise, if whatever difference between let and const actually surfaces with meaningful impact then you're probably already in a very good spot. const, however, is great for code readability because it is a statement of how the code is supposed to work. If I see a const variable I expect it not to be reassigned. If I see a let, I expect it to be reassigned. Anything else tells me there is likely a bug. Given that code clarity is almost always the greatest concern, using const as the default choice and let only when necessary makes a lot of sense to me.
There are issues with const and let in Chrome from a performance point of view. See the following links for details; * https://github.com/petkaantonov/bluebird/wiki/Optimization-killers * http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean
I made a similar choice and have been sticking with `let`, particularly on personal stuff. My mantra is to never mutate whenever possible, and as such glancing at the way a variable is declared doesn't change my opinion about how its used.
That's fine and all, but it should be the implementations that dictate the spec in that case, and the spec should be given the proper investigative time and effort needed to avoid **implementation** issues caused by a **spec**. Imagine if C99 dictated that C compilers write binary data in little-endian. That would be absurd and break everything.
I'd love to submit, but the speaker lineup on the homepage is pretty daunting :)
Typescript is kind of meh. I've used it/will be using it for a project, but the module system is retarded and it really frustrates me. I don't think it is a good idea recommending it as a first language because of that, and I also think that it doesn't have enough resources to be beginner friendly.
Not really. The JS community in general is pretty quiet and inactive.
The Reactiflux community on Discord is pretty active. Primarily focused on React-related libraries and tools, but plenty of general discussion too. Invite link is at http://www.reactiflux.com.
It is JavaScript but with other APIs exposed and a module system (which the browser has not (yet)).
 console.time('testName') dostuff() console.timeEnd('testName') // logs to console "file:line testName: 1337.0ms"
the problem is the way the JS is ordered and called... * your building 10 functions named initMap() (old functions are replaced) and they are not called * your reusing the same element: `var mapDiv = document.getElementById('map')` initmap problem: i would just exec the code immediately, or add the startup options to an array and loop through it later: // add this javascript before you build your maps var maps = [] //inside of the while loop add javascript maps.push({center: {lat: &lt;?php echo $lat; ?&gt;, lng: &lt;?php echo $long; ?&gt;},zoom: 14 }); // then finally on document ready add for(i of maps) googleMapAPI( document.querySelector('#map' + i), maps[i]) reusing the same div: what you want is to print a new div: `&lt;div id="map&lt;?=$count++ ?&gt;" style=".."&gt;` (set count to 0 first!) final solution, something like this: $count=0; while ($row = mysqli_fetch_array($result)) { $Event = $row['eventName']; $Date = $row['date']; $Photo = $row['eventPic']; $eventDes = $row['eventDescription'];$lat = $row['lat']; $lat = $row['lat']; $long = $row['long']; ?&gt; &lt;div id="map&lt;?=$count?&gt;" style="float:right; width: 200px ;height: 200px; background-color: #CCC;"&gt; &lt;script&gt; function initMap() { var mapDiv = document.getElementById('map&lt;?=$count++ ?&gt;'); var map = new google.maps.Map(mapDiv, { center: {lat: &lt;?php echo $lat; ?&gt;, lng: &lt;?php echo $long; ?&gt;}, zoom: 14 }); }() // &lt;- execute immediately so you dont replace initMap with the next iteration of the while loop &lt;/script&gt; &lt;/div&gt; &lt;? } ?&gt;
you can store it for free on firebase, its like a free/paid database that works via API ( `http://my.firebase.com/save/ {id:1, task: "foo"}` ) theres also firebase alternatives on google. if not the easiest route is a $5/mo digital ocean server "droplet" and PHP for the backend. just write the data to a JSON file or CSV file or mysql database if you want to be professional (or code both for practice)
I know how to time things. Question is how to you replicate the same sequence of UI events for the purpose of testing overall app performance.
I knew proper tail calls were too good to be true. Of course TC39 is going to come through and convolute the shit out of that. More key words! More weird code! 
This is such a non-issue for me that I can't even comprehend how it would be a problem for a programmer. Do you type with just one finger? What's your WPM? I'm not trying to be insulting, this is actually kind of blowing my mind. The difference between typing out these two keywords is so minor, if you're using any sort of correct typing technique, that it barely even saves you a millisecond. This is like C programmers trying to convert every variable into some obscure unreadable contraction instead of typing out what the variable does. You're sacrificing a significant improvement of readability in order to save 0.000000001% of time in your day. I mean jesus, if this is such a problem, get a text editor that allows you to type snippets. Then you can press something like `c+enter` and "const" will be outputted. Now you only have to press 2 letters instead of the 3 for "let". 
Box2d is a port from c++. Its interface is not really js friendly and kind of hard to work with. However it's more featurefull and enables you to do a little more. If your needs are not extreme I'll go with p2
If you do want to learn it try playing around with Qt. In modern C++ you can avoid most of the complicated things.
Seriously, so with that you can use functions as arguments to, and as return-values from, other functions?
In the comments, the author keeps saying they don't mean that people should build websites without Javascript at all... But in order to accomplish what they're saying, *that's exactly what you have to do*. And then also write it with Javascript to give the better, responsive interface that the majority of your users desire. I can't imagine who the users are that browse the web without Javascript enabled. Why would I target them? Until I've got some hard evidence that they make up enough of my customerbase to warrant all the extra work of making my website work 2 different ways, I can't even consider doing that. It might be different if frameworks like React worked that way by default. (At least, if you use Express on the backend to do the rendering.) That if you wrote an app in the framework in the official way, you'd get this functionality without additional work. But so far as know, nothing like that exists, and it would be rather hard to make it exist. And it would complicate things, even so. I just can't see this as anything other than an anti-javascript rant because the author doesn't actually have a *reason* not to enable Javascript... They just had it off for a while to test something on their app. Nor have they provided any reason to think that a significant number of people browsing the web have Javascript disabled for any decent reason at all.
Java is atrocious, JVM is interesting and useful though, and there are many language options that target [JVM](https://en.m.wikipedia.org/wiki/Java_virtual_machine) Unless you're planning on becoming a professional Java dev, don't waste time learning it as a first time language, it will cause you pain. Ruby or Python are the current front runners for first language IMO. Go (golang) is worth looking at, so is Groovy or Kotlin if JVM interests you. More obscure choices would be Clojure or Scala, but I'd recommend those as 3rd or 4th language to learn, along with Haskell, or other Lisp/Scheme variants. I think it's important to learn at least one imperative low level language, one OOP language and one functional language. Strict typing and Dynamic typing is also essential experience for anyone considering programming seriously. I'd love to recommend Nim too but unfortunately it's still in its early stages of life and lacks a significant community.
You got upvoted to hell, which is probably a sign that most JS devs sort of agree with you that the language is like the Wacky Wild West. The reason most of us use and know javascript is simply because it, through a bunch of quirks of history, became central to creating web content, and we all grew up wanting to create web content and teaching ourselves how to do it (I may be wrong, but my sense is that most JS devs don't have computer science backgrounds, I certainly don't: we're mostly self-taught). The way Javascript developed over time is a lot like how Boston's roads we're planned: a pig walked through at some point and trampled down some weeds, then people walked on it and made it a path, and so on and so on until we have roads leading every which way with no overall sanity. ES6 brings a lot of missing things to the table, and in general browser standardization has gotten much better. But under the hood, it's still a wacky contraption. Which is not to say that javascript isn't a fascinating language with lots of neat things to discover. It's FUN. Even though it's problems easily lead to lots of crazy buggy code, exploring it is fun. It's still what I enjoy waking up in the morning and doing every day! But... if I had to do it all over again, yeah: I'd start with a much stricter, well-designed language. If backend was my focus, probably python (PHP is a similarly wacky beast, though its latest version is a real step forward). If applications were, Java and C. And heck, I wish I'd started learning Haskell from the start: there are things of beauty in that language that are mind-blowing and deeply improve how I think about code. Javascript is an adventure. The thing is though, in the long run, you don't want computer languages to be adventures: you want them to be clean, clear, and predictable. And if you start out that way, it's going to lead to better Javascript.
I'd actually say that Javascript is pretty much undergoing a FP revolution right now! And on three fronts at least. One is that FP-friendly utility libraries like lodash are becoming incredibly popular, mostly because people are looking for standardized efficient ways to make things instead of re-inventing the imperative wheel day in and day out. The other is that people who program long enough discover FP patterns on their own as they optimize their code. They may not realize what they're doing, but it just sort of happens over time as people improve. When you think about how to handle null types more consistently, eventually you just hit upon patterns that look an awful lot like Monads, regardless of whether you even know what those are. And finally, lots of the FP people are just plain taking up javascript and bringing in ideas and libraries and code from their world into ours, whether into Javascript directly or as compile-to-javascript languages.
Getify's You Don't Know Javascript is also an awesome series (and free to read if you're willing to read online).
I'm actually a front-end engineer, and I typically browse with JS off. It's made my internet usage at home so, so much better. The vast majority of sites work correctly without JS, and load times are incredibly fast (no need to bother with a half MB pile of crap). There are some sites where I'll just add them to the exception pool; YouTube, twitch, and a few others "deserve" to run JS. The one that gets me every time is Medium. Did you know that the content doesn't even render without JS? For a platform that basically resembles a shared blogging site, what the hell do they need JS for? I still haven't turned it on for them. It's been fucking great. There are lots of apps that should be written in JS with all of the fanciness it offers. Then there's shit like Wikia and Medium and NYT and other static content sites that, for reasons beyond me, think they need a fancy app to view text. Those people should be the ones to write no-JS friendly code, because requiring a bunch of app code serves no fucking purpose when I just want to read text.
I find this article very vague. For a text that does not mean that you should not use Javascript there is about 95% hints towards that js should be optional. It really feels like a non-issue with a generic encouragement in it
Swapping to cookies is not hard. Store the JWT in a cookie. Don't parse the cookie on the frontend side to get the token (that's impossible if you're using a httpOnly cookie anyway, which you should). Just add 2 lines of code server side to check for a token inside the 'authorization' header or cookie. And on login provide the token to the user in the json response (or whatever you have setup) and as a 'set-cookie' header (httpOnly). Using localStorage subjects you to a serious vulnerability called XSS. Although this does not apply if you are 100% you are not using any 3rd party code on your site (ads etc are a HUGE XSS risk). Using a httpOnly cookie protects you against XSS, but introduces the smaller, not as serious, CSRF vulnerability that you can protect against with a bit of code.
Thanks for the advice! Do you know whether the performance of Box2D is good (especially if also used on the server)? I've seen many ports, but I assume the one I linked in my post is the best one?
No there is definitely tons and tons of examples out there, but when I look through what they have I do not see the following: &gt;Load the series on body load. This means you will need to have you body tag as **&lt;body onload="yourFunctionName()"&gt;** You will need to write your function. Print the first two seed numbers outside your for loop using **document.writeln(number1);** **document.writeln(number2);** Granted I don't know what any of those tags mean, or if they do anything. Here is one example I found, but clearly I don't want to turn in something that isn't even close to what he is asking for: &gt;&lt;html&gt; &gt;&lt;body&gt; &gt;&lt;script type="text/javascript"&gt; &gt;var a=0,b=1,c; &gt;document.write("Fibonacci"); &gt;while (b&lt;=10) &gt;{ &gt;document.write(c); &gt;document.write("&lt;br/&gt;"); &gt;c=a+b; &gt;a=b; &gt;b=c; &gt;} &gt;&lt;/script&gt; &gt;&lt;/body&gt; &gt;&lt;/html&gt;
Performance is generally [not a good reason](http://kpdecker.github.io/six-speed/) to use ES6 features. Use them because they make your code easier for people to understand. Using `const` tells the reader (and the compiler) that you won't change the binding later, which is handy for a lot of reasons. Right now though, JS engines don't always take advantage of ES6 features to make faster code. To answer your specific question, [this test](https://github.com/kpdecker/six-speed/tree/master/tests/bindings) shows that `let` and `const` are pretty much the same performance as `var`.
I haven't seen people mention this yet, but I think that it's important for people getting into programming to have fun and be motivated to learn more. This isn't JavaScript specific, just in general. If it's difficult to grasp and/or takes a lot of effort or time before you can see results, beginners might give up
Es6 is a new version of Javascript. It is not yet supported by all browsers (modern ones like Firefox or Chrome support much of the new standard). Node.js supports some es6 since Node 5 I think. Those arrows ( =&gt;) are part of es6. It can be used to declare anonymous functions in a more concise way (and use the lexical scope). Const and let are also part of es6. Those are ways to define block scoped variables. For example, const inside a while loop is not available outside of the loop. Const also has the benefit that this variable cannot be reassigned. But objects assigned to a const can still be mutated, as long as the variable itself is not reassigned. More on es6 can be found here: https://ponyfoo.com/articles/es6
I understand that this is the approach (`head, ...tail`) in lots of functional programming languages. But is there any benefit to doing it the recursive way rather than something like: const compose = (...a) =&gt; x =&gt; a.reduceRight((y, fn) =&gt; fn(y), x); Honest, curious question. Would be very interested in your opinion.
&gt; Facebooks’ solution to their problem is the solution to my problem Yeah, this is one of my past client's. Tech-savvy enough to get things at a super high-level, but that's about it. Anything that Facebook, Twitter, Amazon, Instagram, etc were doing, we must be doing too - because surely we're going to scale ludicrously fast and run into the same problems they have in the next 6 months.
It's funny that he thought "React makes you sad?" was meant to be only humorous. Dan Abramov made it so that people who were frustrated w/ the variety of ways to build with React could focus on the simple stuff, or find another solution that works better for them. "React makes you sad?" is a great example of the strength and thoughtfulness of key React community members. Ironic that the author of this whiny post misunderstood it so thoroughly.
Browse [random-yeoman-generator](https://h3manth.com/random-yeoman-generator/) ;)
Webpack is an amazing tool but Jesus Christ is it complicated. 
C# is a fine language. The C# eco-system is a pale facsimile of the JVM one. Both in terms of the number of people and project participating. I'll take the eco-system over the language anyday. Source: have programmed professionally in both.
Typescript is, IMHO, the way forward for javascript. However, because all javascript IS typescript (typescript is a superset of javascript ), all of javascript's warts must be carried along. See: "javascript the good parts"
I pretty much always dream "Imagine if Brendan had had another month to 'clean up' " javascript. Time to actually test drive his invention."
On a side note, how are you supposed to handle all these dependencies and third party tools on a decent size team? Does everyone have to always be using the latest version of every damn tool required to manage your code and avoid conflicts? Or does one person upkeep the code base for deployment?
How is this better than Cordova? 
It's simple. All you need is 3 month classroom training to get basics right.
If you're still wondering about performance, there are **a lot** of optimizations that the compiler can make if it knows that data is immutable and functions are pure, which is a reason why Haskell is such a fast language compared to other high level languages. Realistically, we'll be lucky to see this ever materialize in JavaScript. The performance difference is going to be negligible for a long time, so don't worry about it. Use ES6 (and beyond) features because they improve how you read and write your code, not because of performance.
I personally cannot stand classes. But I do like the the whole: `var something =&gt; () { ... }` I think its called arrow notation. There is no need to down vote this.
Use a proxy that sets up a local trusted CA and generates certs automatically for you, for example [mitmproxy](https://mitmproxy.org) or [nassau-https-proxy](https://www.npmjs.com/package/nassau-https-proxy)
This is incredible! I'm going to give it the read-it-every-day-until-it-sinks-in treatment. THANK YOU SO MUCH! Also I have get my call, apply, bind game up to speed.
&gt; [[proto]] or __proto__ Say foo, does JS look at the foo.prototype.constructor property to determine the value of proto?
Today I made it to Github trending and Hackernews for the first time. [here's my project](https://github.com/akshayKMR/hogwatch) A bandwidth monitor. Rest of my repositories are some of my cooler hackathon hacks.
This is what npm and bower are for.
I have made a plugin system for a Knex-based ORM which is less than 200 LOC. It's easy to use plugins: https://github.com/kripod/knex-orm/blob/master/example/model.js Writing plugins is also pretty straightforward. Just use `PluginBase#beforeQuery` and `PluginBase#afterQuery` in a class: https://github.com/kripod/knex-orm/blob/master/src/plugins.js
&gt; There's no property called a on ConstructorExample, nor Function.prototype. undefined is returned. First, thank you so much! So, it seems like the 'this' keyword is basically only an active thing, and that it only comes into play when an action is being taken with a function - the function is called, or new'ed, etc. - because otherwise if 'this' generally refers to it's referent object or function, it seems like it should in this case refer to the constructor itself rather than be undefined. Would it be correct to say that 'this' can sort of be thought of as a runtime setter method? (I think some of the confusion here is fueled by looking at functions as object literals, and seeing the things inside them as properties, even though while functions are objects, this would be erroneous and getting carried away with the 'everything is an object' mantra of JS.)
To play it safe on a team, I have experienced freezing the version number when adding it to NPM package.json. Then architects or team leads regularly check for updates and if there are any issues with them.
**random-puppy** Returns a random puppy image. Or a random image from any subreddit. const randomPuppy = require('random-puppy'); randomPuppy('optional-subreddit') .then(url =&gt; { console.log(url); }); //=&gt; 'http://imgur.com/IoI8uS5.jpg' https://github.com/dylang/random-puppy
It is really nicely written. Very rare :) 
**what-dog** Give it a image url and it will return a promise for the breed of dog and something about the dog (via Microsoft's what-dog.net). const whatDog = require('what-dog'); whatDot('http://imgur.com/B7a15F5.jpg'); .then(doggyData =&gt; { console.log(doggyData); }); //output { isDog: true, breed: 'Norfolk Terrier', about: 'Spirited, small but sturdy, feisty yet sweet personality' } https://github.com/dylang/what-dog
Yes, but I'm not seeing how this is helpful. Standard is about authoring, not production (any uglifier is gonna stick semi-colons etc back in to get your code on one line). A good linter is all you should need. 
**captionbot** Give it a image url and it will return a promise for a caption for the image (via Microsoft's captionbot.ai). const captionbot = require('captionbot'); captionbot('http://imgur.com/B7a15F5.jpg'); .then(caption =&gt; { console.log(caption); }); //=&gt; 'I think it's a dog in the snow.' https://github.com/dylang/captionbot
Thanks mate! I'll try p2 since it appears easier to work with. I'll try to see whether the performance is good on a node server. 
Hi mate. I'll use p2 for now (2D Physics). It is from the same creator as CannonJS (3D javascript physics engine). I used cannonjs previously before (even on server side) and it worked well on the server side as long as you really don't have any complex objects or a big scene. 
I wanted to try out Vue, so I looked up public APIs and decided to do it with SWAPI, a Star Wars API. http://swapidemo.netlify.com/ [repo here](https://github.com/marriola/SWAPI-demo) edit: fixed the bugs, and converted it from a monolithic IIFE to several nice ES6 classes
Try this: You and your partner set up a shared Dropbox account. Keep all your data in a .json file. When your app loads, use the HTML5 File API and a file input to read the .json file (see: http://www.html5rocks.com/en/tutorials/file/dndfiles/) Make your page(s). Serve them with python simpleHTTPServer or node connect or similar. ^ that's how I'd do it for local development. As far as frameworks? Pick one that fascinates you, React/{Red|Fl}ux is pretty popular, but I like Angular just fine. All the frameworks have decent tutorials if you're willing to spend some time searching for them.
Unless the OP really didn't want the console to spit anything out, such as third-party applications, it would be my recommendation to alias console functions and then switch them on/off. 
If you need a standalone app you could give electron.io a try. It's actually not too complicate to run a webpage as an application. bundling as an electron app will remove the need to have a nodejs or other server runtime installed on the consuming pc you could in the future modify the backend to be web based rather than bundled with the application as for framework choice I can recommend a react/redux stack. The component based approach is really intuitive. Other good options include vuejs with vuex or aurelia. Really doesn't matter too much what you choose considering the size and that the development team is 1 person. Just pick something and start. 
Since [Node 6.0.0](https://nodejs.org/en/blog/release/v6.0.0/): &gt; Node.js now supports 93% of ES6 language features, thanks to V8 version 5.0.
I've been using a lot of Backbone.js recently and really love how open-ended / unopinionated it is. The router and sync methods are pretty easy to work with, and it has almost no dependencies. I would suggest Backbone for MVC, handlebars for templating, materialize for styling, and mongoDB for storage.
I think arrow functions have been part of node since v4
I get the feeling that something deeply majyyk (like dragons) might happend because of the "no temp variable" deal. Getter/setter being called while the tokens are swapped leading to undefined behavior on "what is a right now?". Using a const value in the left part to throw and put the following tokens/values pending assignment to limbo... Marvelous things to ask during job interviews! (because those weird behaviors don't need fixing/linting but an explanation, sure)
&gt; console.log = function() { if(debug) { clog.apply(this, arguments); } } if debug is false, it seems that this would evaluate to: console.log = function() { if(false) {}; } How would this be different from: if (debug) blah; if (false) ; It seems that it would still have to debug the if statement? In a few thousand lines of code, if I have a number of debug statements that are evaluated every time different events occur, it seems that all of those unnecessary if statements would add up. Is the Google Chrome JavaScript interpreter smart enough to know that a given variable is always going to be false, and to not bother parsing it whenever an event calls a function that has a debug statement in it?
I agree with the top post, JS is not a good language to start learning programming. To learn programming you should start by doing "back-end" stuff, because you have learn the language fundamentals first. Build functions, algorithm, classes, control structures, logic flow using that language you have chosen. Don't get bogged down in "front-end" stuff and JS yet. If you do you'll be dealing with different paradigms, browsers APIs, etc. Set up a simple dev environment and write some alogoritms. Then write something like an app make a HTML output, etc. In my opinion PHP, JAVA, C#, Python are great choices. An even better choice would be PHP since it's widely used, there'll lots of tutorials and tools. Once you are comfortable with back-end logic, take time to build something interactive using JS. Only learn the advances JS concepts later, when ypu have mastered the back-end. JS oop, async patterns and behaviour is simply to much for a beginner 
i wasn't referring to that. :) i know rest-spread though is not es6 but it will be super useful when it arrives.
Found the guy who will use classes over factory functions because they are "faster" Kidding aside code is for humans to read more than computers to run fast. Const and factory functions help in that regard and is why we don't care about performance of them up front. You should care about performance when you have a measurable impact to your problem at hand
Alright that's nice and short. Thanks for the help! :)
Does this help? http://andruj.github.io/articles/2.html
Not exactly. The specific standard on tail-call recursion is dictating that the implementations execute a certain way. The two (or more) implementations of a spec should be free to execute however they please as long as the result is the same.
If you are using a minifier like UglifyJS you can configure it to remove your console.whatever function calls
Not sure if this is an option, but you can strip console.* statements with uglify `drop_console`. Very useful to keep local build logging, but deployed scripts are clean. https://github.com/mishoo/UglifyJS2
Inspired by Mathologer, I made a circular times table generator. http://picturelements.github.io/multiples
You can use another function as a service. Angular has $log.log(), node.js has debug(). These can be configured to log to the console, log to an HTTP log server, or write to the filesystem, depending on your needs. when you write your website or app you would use $log or debug instead of console.log. In node the debug function gets enabled when the app is started with the --debug flag (npm run app --debug, or node app.js --debug). In Angular you would use the $logProvider.debugEnabled property in a config function. Other systems like React or Ember may have other logging services.
Even more than that: use https://github.com/JamieMason/shrinkpack . It parses the npm-shrinkwrap.json file, saves all NPM package tarballs to a `./node_shrinkwrap` folder, then rewrite the shrinkwrap file to point to those instead. You get exact versioning on installs, and the ability to do installs cross-platform because it's the packages, not build artifacts. Also, a few hundred tarballs are _much_ smaller and easier to commit than 150MB and 25K files worth of ./node_modules.
This looks like an interesting project! The only thing I'd be worried about is that it's appears to be using gzipped tarballs, which source control systems don't really handle very well. Every update to a package would result in a new copy of the entire file in the repo, which can make the repo very large. It would be better if it used *uncompressed* tarballs, as then the Git/Mercurial diffing algorithm could handle it nicely and save diffs between the old and new versions.
Dividing an array by consecutive values. The array [3, 12, 24] is 3/12 = 0.25/24 = ~0.01 when computed left to right, whereas it would be 24/12 = 2/3 = ~0.667. Of course, you can always use var arr = [3,12,24].reverse(); var t = arr.reduce(function(a,b){ return a/b; });
Hit the nail on the head. The author is not saying that Javascript is evil, or that nobody should use Javascript; the author is making the point that Javascript is being used (*misused*) in certain places where *not* using Javascript would give the user a better experience. I agree with the author that there is a lot of Javascript on the internet that doesn't need to be there. 
This is exactly the example (in abstract at least – calculation that depends on order) that I thought of and decided was too contrived. Surely the fine people on the ES6 committee didn't include it only for that!
Further, those empty branches are almost certainly optimised into non-existence by llvm
Arrow functions and modules.
Yes, obviously. The question here is preserving login state across subdomains, eg translated subdomains. Also, XSS concerns are not really a big factor as none of the information in our JWTs are sensitive. &gt; Don't parse the cookie on the frontend side to get the token Okay, so that adds no new functionality. The question is about swapping subdomains and preserving login state. 
Okay, here's a less-party-trick example: Promise.all([ imagesStore.fetchImagesForReview(), notificationsStore.fetchNotifications(), reportsStore.fetchMonthToDateSpendReport() ]).then(([imagesToReview, notifications, spendReportData]) =&gt; { // much clearer correlation between fetch-promise position and result position in the array, and no need to manually pull stuff out }); Or another example, a by-hand recursive implementation of fold that is made clearer by destructuring: function fold(f, initial, [head, ...rest]){ if (head) { return fold(f, f(initial, head), rest); } else { return initial; } }
A quick unsolicited suggestion for your browser DB interface: [PouchDB](https://pouchdb.com/). The library's API is much improved over IndexedDB and will work anywhere that supports IndexedDB and WebSQL.
A proper usecase for me is reconstruction of object hierarchy from flat-notation. Say you have a form with several input fields; each of which is bound to an element in an object hierarchy: say, you do a web shop and have articles with numbers, prices, and dimensions. You could map "number" and "price" directly and have a dimensions object (length, width, height) mapped to "dimensions.length", "dimensions.width" and "dimensions.height". In order to construct the dimensions object, you simply split the name of the inputfield and do a reduce - starting on the right (the higher in the hierarchy, the more you have to look on the left). And you're done. 
Building of a linked list: const arr = [1, 2, 3]; arr.reduceRight((tail, head) =&gt; ({ head, tail }), null);
Is it not: var something = () =&gt; { ... } ?
Well, generally you wouldn't be "updating" individual package tarballs, you'd be replacing them. if I install `some-package-1.2.3`, which depends on `minor-dep-2.4.0`, my `/node_shrinkwrap` folder would now contain `some-package.1.2.3.tgz` and `minor-dep.2.4.0.tgz`. If I then update `some-package` to version 1.3.0, Shrinkpack would delete `some-package.1.2.3.tgz` and add `some-package.1.3.0.tgz`. So, no diffing concerns to worry about. Minor size bump, but certainly not anything I'd see as an issue. And again, given that the typical alternatives thrown around are "check in your entire `node_modules` folder", and "zip up your entire `node_modules` folder and check _that_ in", this is by far a better approach.
&gt; Also, XSS concerns are not really a big factor as none of the information in our JWTs are sensitive. You can store sensitive information in a JWT - they're secure - unless you misplace your secret key of course. That's not the issue, the issue is that someone can steal the token and use it to make any kind of authorized requests - impersonating the user the token is authorized for. This is a much bigger problem in XSS since unlike CSRF, the perpetrator has access to the token - whereas in with CSRF the perpetrator is (ab)using how cookies work in order to make a POST request to a targeted resource (like, send money from account b to account a). But with CSRF the perpetrator never sees the response or the token, and the user must themselves click a link or visit a website with a targeted script to your specific service (like an email with a link) - it's a narrow, less automated and less general point of attack compared XSS. But you don't have to worry about it if you know for sure you're not linking to or running 3rd party code (like using a local version of jquery instead of a cdn). But since you're wanting to share state across subdomains - just use a cookie (with httpOnly flag set).
But it isn't really a well-built article to prove their point. I agree that the whole advertisement world is one giant mess of Javascript and malware which puts a huge strain on the Internet. But instead, she starts rambling about empathy and ... dynamic content ... I guess? Anyway, she could've made her point clearer using the following things: * If it can be written in CSS, please do so; * Javascript needs to be used for dynamic content or complexer animations; * Keep it to a minimum.
Ya I got the syntax wrong &gt;.&gt; But the point is still the same.
How is it different from wrapping gmail with fluid.app ?
Symbols have a lot of advantages; they don't show up in `for-in` loops or `Object.keys()` for instance, which makes them safe to use to extend objects, because it's unlikely to break code that wasn't expecting extra unknown string properties to show up. They also of course can be used to guarantee uniqueness, but maybe you don't always want that. Sometimes you might want to share a symbol with other modules, and that's what the symbol registry is for. So therefore if you use `Symbol.for()` to get a symbol by name from the registry, you still get all the other advantages that symbols have over strings (i.e. they don't show up where string properties hang out.) That's why you'd use a symbol over a string, even if you don't need the uniqueness guarantee. 
&gt; The issue is that both files will be in the Git history forever, which makes the repo grow much bigger over time. But that's the point. There's many reasons to want to have everything needed to set up and run your project, checked in, and available right there. And if you need to check out an older revision, you've still got all the appropriate dependencies. I honestly don't get the repo size argument - I've seen it brought up several times in regards to this topic. We've got a repo at work that's probably close to a gig at this point because of having several Java libs that had to be upgraded over time. Now, _that_ is something that's getting larger, thanks to all the various multi-megabyte JARs and stuff we've had to upgrade over the years. In contrast, the average NPM package tarball is maybe a few dozen kilobytes.
Thanks for the link. :)
Thanks. I was trying to work without Angular or node -- they seemed like extra overhead and I didn't see anything that they provided that I couldn't do on my own at a (probably?) cheaper cost, since I'm writing a pretty simple (albeit a few thousand lines long) code. It's mostly error checking, "Is the person allowed to do X? Ok, let them. Otherwise, don't." ;)
Thanks. :) I was designing with the $40 Walmart pre-paid AT&amp;T smartphones in mind, and mine seemed really slow most of the time before I upgraded. With a few thousand lines of code, throwing in several hundred extra if statements that would continually be iterated over as events were called just seemed like kind of a waste.
A lot of functional languages have both `foldLeft` and `foldRight` which are equivalent to JavaScript's `reduce` and `reduceRight` so that may have had some reason to why it was added.
Symbol registry? 
After you write your first configuration or two it becomes really simple. But yeah, first time I tried to hook up babel, HMR and dev middleware, shit took me five hours probably.
I'm glad you responded. I posted this after seeing your comment in the [ES6/recursion thread](https://www.reddit.com/r/javascript/comments/4h4t5a/what_are_your_favorite_es6_features/). I've never used reduceRight nor seen it used until your comment, so when I saw it, I assumed it was new. I'm afraid this example doesn't get me very far. I'm a bit of a novice, so I can follow what you've written but I don't really **understand** it. Could you suggest some reading to get me up to speed? Thanks for the response.
I would definitely suggest [Prof. Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/). It's a great read.
Use a logging library like Winston or write your own wrapper function that checks if debug is true before logging. 
Oh God please don't do this. Just write your own wrapper function don't overwrite native methods. 
So... pretty much like how we've sometimes prefixed certain property names with an underscore or two when they are attached to an object as an implementation detail and not part of the data, ie: foo["__type"] = "MyClass"; becomes foo[Symbol.for("type")] = "MyClass"; ? 
Recently found out that there is a dependency on ‘fsevents’ (mac only) in a couple of widely used gulp modules after a client who uses linux tried to run “npm install” on a shrink-wrapped project i delivered. Very curious how this could have gone under the radar. If webpack is the ONLY Dev tool i have to worry about, i think its time to jump on the band wagon.
It wasn't working because there was no substring matching "-1" in your src value. 
wow that would be such ugly solution. 
All I really really want is object rest/spread. Async/await will be nice too but I definitely use the former more.
You need to: - Add an event listener to the window or document.body - The event you listen to should be 'keydown' - Inside the callback (function that gets called when that event occurs) check to see if the key that was pressed was the 'home' key. - You check this using the e or 'event' object and the .keyCode property (e.keyCode) - Check if e.keyCode matches the keyCode for the 'home' key which is 36 - if it matches you can change the current page using window.location.href = whateverURLyouWant
i guess I do. I follow clean code principles which have a certain style. http://www.amazon.com/gp/aw/d/0132350882/ref=mp_s_a_1_1?qid=1462071547&amp;sr=8-1&amp;pi=SY200_QL40&amp;keywords=clean+code&amp;dpPl=1&amp;dpID=51oXyW8WQwL&amp;ref=plSrch
Its not supposed to be I am just making a novelty website for my school and has no real value. 
The right answer.
... am I bad for just pointing how much better string interpolation is? I feel like that's something JS should have had a *long* time ago.
The problem is that it looks like a syntactic word jumble. Good code isn't short, it's readable. At least in my opinion. I do love arrow functions though.
I hereby decree that any discussion of javascript as a programming language now should include the obligatory link to: https://www.destroyallsoftware.com/talks/wat (uhm, do I even have the authority to do that?) 
[removed]
Honestly, it probably got voted down because people love to vote down people that say they're going to get downvoted. 
Honestly, I'm kind of pumped for generators and iterators. I've wanted that kind of native support in JS for a while. The rest is great too, and I know I'm probably in the minority, but that has me most excited.
You need to create an option element for each selectable entry and append it to the select element, you don't need the line break.
The right answer for nodejs
This appears to not be supported: https://github.com/queckezz/koa-views/issues/14
Is there any difference between this and console.time() and console.timeEnd()? 
Don't use js for stuff Html can do... &lt;a href="https://www.google.de"&gt;home&lt;/a&gt; Will navigate you to Google when you click this text. 
How often do you do this?
I'm not the most familiar with Koa, not Jade (err, pug) but : - it looks like consolidate will receive `state` as the second parameter https://github.com/queckezz/koa-views/blob/master/index.js#L133 - this winds up being passed into jade.compile: https://github.com/tj/consolidate.js/blob/master/lib/consolidate.js#L307 - and jade.compile recognizes the pretty parameter in this options object: https://github.com/pugjs/pug/blob/master/lib/index.js#L80 If you can somehow get `pretty: true` onto state, that would probably make its way to jade.compile
Regardless if you get it to work, this is a bit of a hacky solution. You don't want to rely on string manipulation and the image having a valid color title in its name. It's also not very readable, and will become a mess when something changes (like you move the images folder to a different place) A more robust solution would be to just include the color as a data attribute: &lt;img data-color="black" src="images/randompicture.svg" /&gt; And in your javascript: mine.color = e.target.getAttribute('data-color'); Then you can also store a hex or RGB value in there, if you want
Still, all the examples she gives are clearly better with JavaScript: Gmail, Facebook, Trello...
`Symbol.for()` enables you to use the same same symbol in different _realms_. Each realm (e.g. a frame in a web page) has its own global variables, including `Symbol`, `Array`, etc. If an object crosses realms, you want special keys that are symbols to remain the same. Hence, a cross-realm registry. JavaScript engines have their own way of making sure that, e.g., `Symbol.iterator` is the same value in all realms. Therefore, if an object is iterable in one realm, it is iterable in all realms. Within a realm, you can use other mechanisms for sharing a symbol (e.g., import it from a module).
How so? I've used a pretty new library called [AbsurdJS](http://absurdjs.com/) for precompilation of html and css, could have used SASS and EJS but both are not are good at importing javascript modules. Other than that standard es6
I like Aurelia, I really do. I prefer it to angular 2. On the other hand compared to react, both Aurelia and Angular are just too fat. I was working INTESNIVELY with Angular for 2 years sice 1.0.0 to 1.4.4, then tried Aurelia on two projects and then migrated to React. So these days the best frontend solution for SPA is React+MobX. No one else comes even close.
I think it's the latter: the idea is that it's much closer to a type signature representation of what's going on. You can name the variables more clearly than I have (though that too can be too much, because it sometimes obscures patterns that are more generalized than the names imply).
They are sprite sheet, the template is also server-rendered for fast performance!
Yeah I know, `eslint` told me that. I plan on adding some functions of the class's prototype like `setOptions` and maybe `setCurrentSelectedCategory` to change categories from outside.
If you're doing operations on a list like (acc,item)=&gt;acc+item where the order of operation doesn't matter, then it doesn't matter what order you do it in, and reduce vs reduceRight doesn't matter. But lots of operations, like what we do with composition vs pipe, do matter, because you're basically nesting items inside each other, so there's an innermost vs outermost. One example I like is composing promises. const composePromises = listOfFunctions =&gt; x =&gt; listOfFunctions.reduceRight( (acc, fn) =&gt; acc.then(fn), Promise.resolve(x) ); Written like that, you're chaining a series of functions that will run in sequence as specified, where rightmost to leftmost = first to last. If you were to use .reduce instead, the order would be reversed, which makes a huge difference to a sequence executed In fact, you can get the exact same effect as reduceRight just by doing [1,2,3].reverse().reduce( etc...). It just iterates in the reverse order.
Reduce is an extremely powerful operation that can allow you to ab abstract out everything from filtering to mapping to summing, etc. It's hard to spell out a simple use case because you need a whole program of context to see its value and how it improves code by boiling down a bunch of transformations into a single one. Let's say you have a bunch of DOM nodes in an Array and then one you want to append them all to... AND you want the result to be that one DOM node filled with all the others. With reduce you can do that in just one clear line of code as opposed to writing a for... in loop with a bunch of intermediate variables and a separate return statement.
I personally think that `new` (like most keyword) is weird and inconsistent. I like to create functions that return objects created using `Object.create(myProtoObject)`. Still wondering about the font-family thing though. Care to explain?
I did something similar a few months ago as a jQuery plugin. I remember that it was a pain in the ass to recopilate all emojis. http://franverona.com/jemoji/
I made **glitch.js**, an image manipulation script to create visual glitches in images. I just published it and I'm now trying to figure out how to set up a GitHub page for it. ~~Right now you can download the zip and open index.html for it to work (sorry)~~. Edit: a [demo](http://f.cl.ly/items/3A2d250M1p420X3h1H3A/index.html) and an example [screenshot](http://imgur.com/4a1tP6H). [GitHub](https://github.com/nathanuphoff/Glitch-JS)
I see them as being the building blocks of Enumerations. const shapes = { TRIANGLE: Symbol(), SQUARE: Symbol(), CIRCLE: Symbol() }; if (thing.shape === shapes.CIRCLE) { circumference = 2 * Math.PI * thing.r; }
At that point, HTML with jQuery if you want some minimal JS stuff. No sense using React or Angular if you aren't going to have a data driven back end with most of the rendering in the client.
Not bad, perhaps the typewriter effect is a tad strong though when I’m trying to relax.
I noticed the images aren’t hi-dpi/retina, and then I was wondering why you don’t check for native support before loading all those images. OS X supports Emoji out of the box just about anywhere so the image representation is rather obsolete. 🌝 Edit: just checked, the Emoji above is visible on at least Chrome, Firefox and Safari. [And crisp too](http://cl.ly/g1FA).
Use css. selector { color:black; } selector:hover { color:red; text-decoration:underline; } If you want to able to change the styling of the underline then you'll probably need to use a `border-bottom` instead.
Thanks for the suggestion, I'll do scrolling text in a future video
This is just a panel, OSX devices such as iPhone don't need it at all because it has a specific keyboard for it (that's why you don't have the icon on whatsapp for iphone, and android you do). This is a panel just for the devices that need it, I might make an editor in the future that checks if the device need the panel at all.
I wish I understood what people are talking about when they say router like this.
&gt; Creating a library that capsulates a concern (like file management) doesn't cut down on the reusability of the code. Sure, but then we can't always create a library for everything. If we start creating a modules that does more than one thing, we will eventually run into the problem of OOP, which is having to think about naming not only what to do (function), but how we logically group that in a way that if we are wrong (or requirements change) we will have to move big chunks of code instead of just moving files. Complexity lies in trying to create a single module that does similar things (not talking about OOP) without using the principle of trying that in at least 3 different places to prove the module and it's members can be reused consistently. In my experience developers underestimate the capability of building modules with high cohesion, and that leads to unmaintainable code. &gt; I don't think I would have written flattenArrayInsideFile as a resuable function in a library Of course, the article aims specifically in business specific needs (internals), not how to build reusable libraries. You are totally right, it doesn't make sense creating something like that, it is so business specific :)
I work with coffeescript everyday and it contains a lot of traps, that's why I hate it, but in other hand it also have some awesome things like this one.
Thanks
its really about where you want to place your scripts in the html. and are elements already in the DOM before your JS runs. * `&lt;tag onevent=foo()&gt;`, is inline JS and hated by some for being messy. but its really ancient js 1.0 and maybe just kept to keep compatibility with older websites * `addEventListener` is the newest, but requires the element exists in DOM before you can attach it, so the script has to be after the elements in the html file. legend says javascript includes belong in the `&lt;head&gt;` tag iirc * the alternative to document Ready is just a script tag at the bottom of the HTML before `&lt;/body&gt;`. it will run last and all elements will be already exist in the DOM * document ready was created by jquery because the old way was very hacking involving 3 different ways to for all 3 major browsers to tell when all elements were on the page and we can start running JS. something like: if(!window.trim) /* ie */ document.body.onload=init else if (Array.prototype.someFireFoxFunc) /*firefox*/ window.onDomContentLoaded = init else /* chrome*/ document.ready(init) then the browsers standardised it. Use document ready you can still put your JS includes in the `&lt;head&gt;` tag where it belongs and run it later. and theres the paradox, good practices say js includes belong in `&lt;head&gt;` but you cant attach element events because they dont exist yet, so people started moving them to the bottom of the html (or use doc ready)
With the [release of node v6](https://nodejs.org/en/blog/release/v6.0.0/), you CAN release node packages that are ES2015 only. I actually did this internally where I worked only to find out people are still using node versions as low as v0.12.7. Given this, I really don't see the benefits to this considering a lot of people who will need to use your package might be on lower versions of node. ES2015 isn't widely supported enough yet to really justify not transpiling it in my opinion.
So much this. I love the idea of arrow functions, but I hate the syntax. Talk about code obfuscation. I know the syntax was borrowed from other languages, but just because other languages do it that way doesn't mean it's the right way to do it. I would even have preferred to type out arrow_function instead of the awful =&gt;. I can't wait for operator overloading to be implemented in JavaScript so I can do arrow functions without having to use something that looks like a dyslexic greater than and equals sign. 
Just not true at all.
?
yea thats what i do; as a bonus it avoids cached JS files which is a PITA when you upload a new one and customers cached the old one
What does caching the old one mean? They didn't remove it in the old one in their headers?
Looks like an opportunity for snakes. Here is a link to the game logic for snakes in Javascript. http://codeincomplete.com/posts/2011/8/5/starting_snakes/
Thank you for your feedback! I'll try to use Grammarly on it so it'll be a little better in terms of English. Sorry! :)
Opening a Pull Request and adding `.npmignore`'s is one of the fastest and easiest ways to contribute back to the community. A quick way to get a list of every package you have installed that could use a better `.npmignore`: find ./node_modules -type d -name 'test' You'll make your install a lot smaller if you do this.
images loads in the web with a stream - which creates a scrolling effect (click [here](http://earch-land.com/w/wp-content/uploads/2015/07/C360_2015-07-19-15-54-57-358.jpg) for example). The sprites located each in a different part of the image, so it makes a whole row of emojis load with scrolling effect (like 10 each time). Hope you got it
Well, I'm not really using Node. If debug is always false, then would all the: if (debug) ... be dead blocks, removed by Chrome (and other major browsers)?
You kind of answered your own question there. The reason people don't make good use of the .npmignore file is because either they don't know about it or they don't care enough to do it because most packages are made by people in their spare time. Either way, like /u/thejameskyle said, make a pull request. It's what they're for.
Another reason is that some people appreciate the test and example folders so they can just open those up if they need to figure things out. Another thing to bear in mind is to keep things in perspective, unless you are Sinde you are probably going to only save a few KB at best here (especially in npm 3) and disk is cheaper than your time. 
Yeah, I'd wager that most people are like me and just can't be bothered to eliminate, say, some documentation and tests from my NPM build.
You can't use pseudo classes like :hover inline -- it was suggested once but never really went anywhere. You either have to use more regular CSS like u/electric_creamsicle suggested (which is the preferred method), like this: hoverMe { color:black; } hoverMe:hover { color:red; text-decoration:underline; } &lt;a class = "hoverMe"&gt;PROJECTS&lt;/a&gt; Or you could set the textDecoration property to set an underline as explained here: http://www.w3schools.com/jsref/prop_style_textdecoration.asp You can also combine multiple JavaScript statements in each onmouseover event like this: &lt;a class = "hoverMe" onmouseover = "this.style.textDecoration='underline'; this.style.color='red';" onmouseout = "this.style.textDecoration='none'; this.style.color='black';"&gt; PROJECTS &lt;/a&gt; However, this is not a recommended practice, as it will ultimately end up making it harder to write code, easier to make a typo and get a weird bug, and harder for people to figure out what's going on. Also, you know you don't need the href attribute in an anchor tag if you don't want it and aren't going to use it, right? So you don't need to include: href="JavaScript:void(0)" unless you want to. :)
[removed]
Yeah that sounds right. Good advice, cheers.
[removed]
I made this Simon game for Free Code Camp - http://codepen.io/eddyerburgh/full/reqYRL/
Have you seen a browser rely on the adoption of a package.json file, too?
I'd personally suggest to add the package.json's "files" property instead of .npmignore for two reasons: 1. The way .npmignore works can be confusing when used in conjunction with a .gitignore. 2. Listing what a package needs instead of what it doesn't need is more explicit. That's just my opinion but I think it's worth spreading the word about [package.json's files](https://docs.npmjs.com/files/package.json#files).
Thanks! Let me know if there is something you'd like to see in the next video
That sounds good actually. Considering I'm developing on a 3.4GHz quadcore with an HD6870 GPU, I'd expected a significant performance drop on weaker systems.
Simple spell check would pick that up
This. It's easier and it's probably what you want to do. If it's a library, you probably only want the compiled files and the source files. My `files` is usually just `["src", "dist"]`. Excluding everything else with .npmignore is messier. 
except if there isn't an .npmignore but there is a .gitignore the .gitignore is used as an .npmignore, but it is not if you have an .npmignore. So if you have `.secret.json` in your .gitignore and then add an .npmignore with `test/*` then congratulations you've just leaked all your secrets.
Well, there is `.bind(this)`, but I do agree arrow functions are a lot sweeter.
Because transpired generators are slow and native ones aren't.
I'm totally against fat libraries and CSS frameworks when it comes to small projects. I wrote jSpine because I never used more than let's say 10% of jQuery features. Any feedback would be greatly appreciated
For what it's worth, I'm not sure that protecting your "own proprietary code" makes much sense with JS ... A) (probably) no one wants your code. Js code tends to be very specific to its own site, so anyone who might want to steal it would be hurting themselves by not just writing their own code. I've been doing Web Development for a decade and a half and never once have I ever heard of actual JS code theft. B) if, for some bizarre reason, some one actually wanted your code, they could still steal it when minified; everything is they need is still there, it just takes a little longer to grok C) if you're worried about security, the JS is irrelevant: everything an attacker needs is on the network tab of their dev tools, not the scripts tag Minimization is great for a slight performance bump to a polished site, but I'm highly skeptical that it matters for code protection. Worry about satisfying your users instead of a (probably completely imaginary) boogeyman ... or else stop writing in a language that requires, by its very nature, to be exposed to the world.
native generator?
I'm out of time to solve this problem, I understand I didn't present enough information. For now, I'm just going to whip up something simple.
I don't use node either, purely browser based apps. The above snippet is for your build tool (like gulp, which is using npm under the sheets). My basic flow is a `build-dev` which is similar to above, but without uglify and the NODE_ENV line - that constantly runs and rebuilds as I save. This pumps everything into a dev folder. Then I have a seperate production flow, which the above is part of. That I just run when I want to push production changes. Kind of the best of both worlds. This is largely based off how React approaches it - and I am sure other libraries as well. See the SO second answer here: http://stackoverflow.com/a/36151490/614112 The second answer goes into the detail of what is happening
I'd say it's safe to assume you are either not actually clearing the interval correctly, or there is some global state that you are changing again the second time around that you don't need to. You need to use the debugger to pause when the game restarts and step through it, you should be able to see what matches your assumptions and what doesn't. Or just post your code here
&gt; For what it's worth, I'm not sure that protecting your "own proprietary code" makes much sense with JS ... Agreed, I make it all public and my users have even sent me patches! It's just "proprietary" in the sense that I own it and it's a standalone website I made, so nobody is writing stuff that depends on it as a library. I care about minification for performance. Takes my JS bundle from 3.5MB to 1.5MB. 3.5MB wouldn't be the end of the world I guess, but it's nice to cut it down to 1.5MB without sacrificing anything!
At the moment I am going to have to move on with something more simple. I have a lot on my plate this week, and can't dwell on this one problem right now. While trying to fix it prior to this post, I broke it even more to where it won't even make it to the problem I described. Pasting my code in here wouldn't show my issue.
You should try to avoid using `setInterval` to animate. Use `requestAnimationFrame` or CSS transforms like [this](http://output.jsbin.com/xupabitoza).
The class that I am taking does not have access to that. I'll just post what I have here even though it doesn't make it to the problem. If you click on the arrow at the bottom, and then the how it works button, you can see the code. [You may cringe at everything](https://studio.code.org/projects/applab/vRJt8D7dR1PoxF3BVZ5RSQ)
Any builtin support for delegated events? $('body').on('click', '.tbtn', function(e) { // code }) vs: $('body').on('click', function(e) { if ($(e.target).hasClass('tbtn')) { // code } })
Neat! It's always nice to see new util libraries -- jQuery is great and really changed the landscape, but often I try to keep my sites &lt; 100KB total if possible. I'd highly recommend picking a version number to support of all major browsers, so developers know what they're getting into.
Just fyi. In chrome: jspine.techlabs.ro/:1 Refused to execute script from 'http://raw.githubusercontent.com/wdub/jspine/master/src/jspine-v1.3.1.min.js' because its MIME type ('text/plain') is not executable, and strict MIME type checking is enabled. (index):87 Uncaught ReferenceError: $ is not defined
I would try asking about this over at https://m.reddit.com/r/greasemonkey , you'll probably get a better response - it seems like what you're using is basically the same thing but in Chrome. I doubt you'll get much response here considering this sub seems to be more for actual website development than scripts and extensions, plus your trying to download YT vids as MP3s, which is possibly against ToS somewhere.
/r/javascript /r/webdev should suffice. It also acts as a great way to save time as the not so good info can be identified by the downvotes
I like http://javascriptweekly.com and http://www.echojs.com
That's not the scripts fault, it's your fault for not downloading it locally. Since the mime type doesn't match the type you're requesting, it can't be "verified". The second error is a symptom of the first.
I was merely referring to what happened when I clicked the link to check out the example.
Here's my new favorite one that I came across yesterday for the first time. https://javascriptkicks.com/ rip dailyjs
OP, based on your question, I'm assuming you're new to web dev. Take the last part of /u/dadrew1's advice, learn about dev tools and break points, and don't use console.log. It might take a few more minutes now, but getting in the habit of using a debugger will save you hours if not days in the long run. If you find that `close` is being called as expected, most browser dev tools also allow you to highlight HTML elements and add custom styling in-browser. That way, you can experiment with the webpage.
Safari's actually not far off from ES6. I have no idea what Apple's release timeline looks like, but the developer preview currently supports 99% of ES6.
http://jsfeeds.com/ is pretty good.
Without seeing your code, why not use a wrapper with fallback support for in-browser DB things? Localforage supports this: https://github.com/mozilla/localForage
Hopefully, at some stage this year, my workplace will be delivering ES6 alongside our transpiled JS. Just need to transition to a CDN that supports basic logic (like VCL) so we can do browser detection and return which script is best suited. Compliant browsers get ES6 and everyone else gets the fallback.. Easy :)
The article does not focus in NPM libraries though, it is more about internal behavior. But there are libs that keep the same contract for some methods, such as [js-cookie with the Cookies namespace](https://github.com/js-cookie/js-cookie/issues/125#issuecomment-171591186) (whose contract of the get() and set() are pretty similar to other alternatives out there with different interfaces).
No, but that's kind of a odd comment to make. The reason that storing metadata in package.json is a great idea is precisely because it's a special file that's only part of the Node.js ecosystem and it already exists. ES2015 modules should be the default for .js files, and wanting to use the deprecated commonjs format should require a special annotation in package.json. (Since this a break change, put it in Node 7.0 and move on.) Since browsers don't really support module loading without libraries/polyfills they are already free to adopt ES2015 modules as the default/preferred way, so we end up left with fragmentation in behavior in the ecosystem.
Go to https://jsfiddle.net/ and paste your HTML in the HTML part, the JavaScript in the JAVASCRIPT part, and the CSS part in the CSS part. You do have separate parts, so you aren't using things like onmouseover that's hardcoded in an html attribute, right? Copy/paste, it's really easy. Also, just link to https://studio.code.org/projects/applab/vRJt8D7dR1PoxF3BVZ5RSQ/view it's super easy and then nobody has to search for an arrow only to realize that you meant "triangle". Then... holy cow, my eyes! I'm blind! That website has way too much color and junk. Please just copy/paste elsewhere. And last but certainly not least, you need more comments in your code. "But I don't need comments, I understand how it works." Yes, but we don't. And I guarantee, if you come back to this code in six months, you won't remember what you typed and what everything means, which is why you want comments. The code starts out with a timer variable. Ok, maybe that's part of the problem, that you aren't calling a function that specifically clears/sets the timer or something. But whatever, let's move on. Then you call a function, home button. What's the home button? Why does this function need to be called? I have no idea and frankly I don't have enough time to figure it out. Tl;dr 1) you need more comments, 2) don't ever code in that environment again if you can help it -- code elsewhere then copy/paste in there if you must, 3) I like lists. ;)
code looks fine; possibly youtube blocked it; maybe it would work if there was added after document.ready? or at some point after the subscription-container widget is rendered, the first page load might be too slow? 
&gt; it just saves a kilobyte or two of space This will become hundreds of gigabytes of unnecessary traffic if people actually start using your packages.
that is a strange problem. its only workin for me if i: * use window.close() `onclick='window.close("map")'` * use `function close (id){` https://jsfiddle.net/tvpezw2n/ 
Always refreshing to hear other peoples' stories.
Yeah, that's not a bad idea at all. Perhaps I can store a hash of all the unique IDs.
Even if you're new to javascript, I would recommend you to start learning the ES6 javascript syntax right from the start. It can be a hassle to set up babel to transpile your code to the old syntax, but it's worth the effort. The world won't go back to the old syntax again and the coding style is quite different from the old one.
gitlab has free private repos, i believe.
Naaaaa jQuery isn't "problematic". It can be. Depends how you are using it. Today with a lot of "MV*" frameworks, you should'nt do a "view layout system" with jQuery, better to use VueJS React whatever. Also if you plan to use a framework that not depend on jQuery, then don't use it (aka Angular). If you need light stuff there is also micro libraries to avoid a complete jQuery solution (like https://github.com/wdub/jspine)
or dedicated server with dedicated private git. I'm using gitolite and it's fine for me.
How is dropbox slow? I've been using it for some personal projects and never noticed any issues. It does all the syncing automatically in the background and you never actually have to wait for files to load or save other than when you switch computers.
There isn't a single technology that wouldn't find somebody to describe it as 'problematic' or worse. Given that there are millions of web sites out in the wild using jQuery it can't be that bad I guess. It may depend on the context of course and any given project if it is a really good choice. Especially since nowadays we have viable alternatives.
thanks for the reply. as i said to "dadrew1" : you have a point. although the script already exists on Greasy Fork and i just wanted to improve it. but you're right, maybe i shouldnt do this. thanks anyway :)
you can't escape from it embrace your destiny http://needsmorejquery.com/
thanks for the reply. i fixed it by myself, but thanks anyway, i appreciate the help :)
private git repos i don't think are a good idea because some data aren't supposed to be stored in git
A challenge I have with the weekly new libraries is that I can never tell when it might become useful for me. Redux + React has yet to feel insufficient, but that's likely because I haven't done anything too major with it yet. (I think my largest app is about 50 different components). What I want from a "Why X matters" page is a real-world example of how/when the status quo fails and why the proposed alternative might resolve that and be worth the added noise.
Switch to [switch](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/switch#Examples).
To be more precise, Angular has its own cut down version of jquery, which they call [jqlite](https://docs.angularjs.org/api/ng/function/angular.element).
I'm pretty sure they're just saying that *some* es7 functionality is being implemented for the first time, and that's all. It's nice that they'll have most of es6, though.
Now it is stored locally. I apologize for that.
I'm still lost on how to feel excited about these things. Unless I can totally get rid of my build pipeline, why does it matter what features Chrome supports? I imagine performance is likely better than the transpiled solution, but I have yet to need to worry about performance to that granularity.
Not yet, but you're right, delegated events would be pretty useful. The real problem comes when child elements are stuffed with more elements so we have to figure out which is the container. This is how I get it done when multiple elements are inside the clicked element. &lt;ul class="container"&gt; &lt;li data-prodid="1"&gt; &lt;div&gt; &lt;span&gt;Product 1&lt;/span&gt; &lt;img src="product1.jpeg" alt=""/&gt; &lt;/div&gt; &lt;/li&gt; &lt;li data-prodid="2"&gt; &lt;div&gt; &lt;span&gt;Product 2&lt;/span&gt; &lt;img src="product2.jpeg" alt=""/&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; $('.container').on('click', function(e) { e.preventDefault(); if (e.target !== e.currentTarget) { var clickedElement = e.target, node = clickedElement.nodeName, liElement; if (node === 'IMG') { // find the li element } else if (node === 'SPAN') { // same as above. More pain } ... 
There are only 2 things in "ES7", the Exponentiation operator and Array.prototype.includes.
I totally agree with this fine comment. And we're finishing up a full scale e-commerce website in React + Router + Redux.
You can switch to code view from the drag and drop editor, I pmd him a solution and explanation last night after his first reply. I think he's in a school class which requires they use that. 
I started learning Javascript with a jQuery competitor called [MooTools](http://mootools.net/) - it meant that I was able to initially make satisfying and recognisable progress, but I was kept completely blind to the existence of a lot of *really cool* JS features that I now use day-to-day. When I *actually* learned javascript properly, the things that MooTools and jQuery gave me just seemed superfluous, and they got dropped - I only use them now if I'm picking up someone else's project and it's already widely used. My advice? Use jQuery to overcome the new-things-are-scary hump, but with each new thing you learn - make sure that you know how to do it in vanialla javascript as well; and then you'll see why everyone is so stoked about ES6 :D -P
Gogs is fine too !
Wow awesome dude, I want to buy one just to code rainbow animations now xD
&gt; own Yep I'm saying this because I see lot of devs adding jQuery to Angular projects.
Thanks for the link! :) But as you already mentioned: Mr. Egorov's post deals with Array objects. He makes no clear statement about HTMLCollections.
it's really a confusing way to emit events. why making the code look like it's doing something different than it's really doing ?
Not for "real work", but I have a lot of personal projects - prototypes and game dev experiments - and I freakin' LOVE not having to have a build step for them at all. No 500Mb node_modules directory, nothing to compile, just some .js files and a browser. The thing I love about it is that one day in 2026 i'll find an old hard drive filled with folders, I'll double click on "index.html", it'll run and I can tinker with them again: just like the prototypes and games I was making in 2006.
As for me, I generally prefer Typescript, so no getting rid of the pipeline in sight.:) Also, looking forward to testing WebAssembly.
Is there anything missing? Based on your opinion which one of these are the hottest right now?
I thought they were moving to using years in the standard, ES2015, etc?
Hey, another Mootools user! There are dozens of us, dozens! Seriously speaking though, learning Moo was a huge crutch. The next time I applied for a job, I couldn't do anything in JavaScript since there were MT equivalents for everything. It was bad.
&gt; Copyright `Date.now()`. All rights, wrongs, and grey areas reserved. That gave me a good laugh. Great job on the application, although I'd definitely like a way to play a song from a suggested artist without having to move away from the current one. Also might want to use `.replaceState` instead of `.pushState` to avoid hijacking the back button.
You will need to, because it's not in ES7.
It depends on your project/personal needs. To create a simple landing page with almost no logic except for just some "element placing depending on some JS code", jQuery + PHP would be a great solution. You are going to waste your time learning complex frameworks such as Angular, React, etc for a simple project. However, if you want to create a more complex web app, maybe some framework could do the job (using jQuery or not). Just remember: use the right tool for the right situation. And don't try to use the same tool for everything.
Thanks :) And yeah, that would be good!
Obligatory [2ality](http://www.2ality.com/)
https://esdiscuss.org/ Will always find something new &amp; interesting to read.
The main reason is that symbols as property keys don’t clash. For example, the property key `Symbol.iterator` makes an object iterable and will never clash with any other property keys. You could achieve roughly the same effect by generating UUID strings. But that would introduce a new category of property keys, which is basically what symbols are, anyway.
I never wrote a single line of Ruby, but the Ruby/Rails part seems pretty wrong, too: Rails is a "version" of Ruby? Rails have versions which are "dialects"? I don't even understand the next sentence, in this context: "Multiple versions works for for OS releases, but not for web dev.".
It's fantastic for debugging. I hate it when I have to mess around in the Safari console and don't have access to arrow functions, new array methods, etc.
I type "framework sizes js" in Google and a Wikipedia result came out: https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks
Maybe, but on her website she says she has contributed to this book, and the tone of voice seems to be positive.
Yeah!
It's problematic if you don't understand DOM yet.
meaning?
Can we stop abusing 'Written over weekend' ~~bugs~~ features to write ugly and non-nonsensical code? It's fine to use it in self projects, but please keep it out of prod..
Heeeey, and in just 3 updates, too!
i can't read something when a full page popup interrupts me
I think what he's trying to say is that `Array.prototype.includes` has been in Chrome for awhile. So when your title mentions "ES7 Support is Arriving" it basically just means that the exponentiation operator is coming :p
It doesn't seem that you read Mackinstyle's full comment nor responded to it. You were responding to a different issue, I think. His comment works equally if you rewrite it as: &gt; I'm still lost on how to feel excited about these things. Unless I can totally get rid of my build pipeline, why does it matter what features browsers support? I imagine performance is likely better than the transpiled solution, but I have yet to need to worry about performance to that granularity. 
Check out: https://www.youtube.com/watch?v=0nh2EK1xveg for the DOM manipulation part.. 
LOL. I'm gonna spend 3 mins trying to find that post - the ROI might be some of the softest luls in years.
&gt; If you get worked up about it, you have missed the joke. If you get worked up about it, you have just participated in the joke. She doesn't write out-and-out hoaxes, she writes stuff that is ridiculous, but only slightly more ridiculous than things people actually do and think, thus pointing out how ridiculous we techies are. The more people fall for it, the more it points out how absurd our industry actually is. Very Onion-esque, IMO.
You'll be `await`ing a little while yet :/
ofc ;)
yes I didn't say the opposite. But adding jQuery to Angular is useless. The mentality of Angular is to skip dependencies like jQuery. Plus Angular + jQuery start to be heavy. Anyway I don't use angular, I'm not concerned :p (I prefer more modular frameworks like Backbone / Vue / React).
 var commands = { help: { fun : function fun() {}, info: function info() {}, useful: function useful() {}, admin: function admin() {}, default: function go() {} }, ping: function () {} }; var command = function cmd (context, name, subname) { switch (typeof context[name]) { case 'object': command(context[name], subname) break; case 'function': context[name](); break; case 'undefined': context['default'](); break; } } Usage: command(commands, 'help'); It can be expanded to allow deeper nesting, and parametized arguments.
:)
here's an implementation using switch: //Exporting all commands to function 'command' module.exports = { command: function(the_command, suf_command, user, permissions) { if (!suf_command) { suf_command = 'go'; } var cmd, scmd; var isAdminRequired = false; switch(the_command) { case "help": switch(suf_command) { case "admin": isAdminRequired = true; case "go": case "fun": case "info": case "useful": scmd = suf_command; } case "ping": switch(suf_command) { case "go": scmd = suf_command; } cmd = the_command; } if (!cmd || !scmd) { return "Command " + "`" + prefix + the_command + " " + suf_command + "`" + " not understood :(" } if (isAdminRequired &amp;&amp; !permissions.manageServer) { return "Your not authorized to accsess these commands!" } return commands[cmd][scmd](); } EDIT: Personally I wouldn't go this way. I'd follow /u/name_was_taken and /u/thisissultan ideas.
Or use this with ugly syntax: var commands = { help: { fun : function fun() {console.log('fun');}, info: function info() {console.log('info');}, useful: function useful() {console.log('useful');}, staff: { admin: function () {console.log('admin');}, mod: function () {console.log('mod');} }, default: function go() {console.log('default ^ go');} }, ping: function () {console.log('ping');} }; var command = function cmd (context, path) { var path = path.split("&gt;"); var name = path[0]; var path = path.slice(1, path.length).join("&gt;") switch (typeof context[name]) { case 'object': command(context[name], path) break; case 'function': context[name](); break; case 'undefined': context['default'](); break; } } usage: command(commands, 'help&gt;staff&gt;admin'); command(commands, 'ping'); Disclaimer: mobile produces ugly code. sorry &amp;nbsp; Anyone up to tell me how this actually sucks?
Man above-the-fold content is getting out of hand. It's bad enough that on my 1080p monitor I don't even see any text when scrolled to the top, but on top of that, a *giant* nagware screen pops up to push everything down further. Anyway, typescript is most useful in larger team settings with people who like types. That's mostly when you should use/consider using it. 
Weird article. Just gives a marketing blurb for each of the frameworks with basically no synthesis of value or use case. Half of the mithril description isn't even talking about it. 
This is it: **California Style Sheets.** https://medium.com/cool-code-pal/a-call-for-web-developers-to-deprecate-their-css-1f6430781393 I see the joke is somewhat on me. But hold on, O'Reilly would put her satire in a rather serious book?
"An Imperative, Dynamic Proposal" sounds like a reference to Jonathan Swift's ["A Modest Proposal"](https://en.wikipedia.org/wiki/A_Modest_Proposal) which is a satire about eating poor children.
Looks pretty out of date. No mention of react, angular is still version 1, etc.
Here's your issue: [https://jsfiddle.net/0koaynup/](https://jsfiddle.net/0koaynup/) Didn't even think about namespace collisions until your last comment. 
&gt; O'Reilly would put her satire in a rather serious book? I thought the book was about yavascript?
Sorry, but abusing getter/setters for event binding is not novel at all. C# did [similar stuff](https://msdn.microsoft.com/en-CA/library/aa645739.aspx) using operator overloading more than a decade ago (they use the much more logical `+=` operator to represent `push` though). There are even posts on thedailywtf.com about horrible getter/setter abuse that are more than a decade old... I acknowledge that syntax abuse is a phase that many smart people go through in their road to coding mastery. It can be gratifying to contort the language in unexpected ways, and it might seem like reducing character count to the absolute minimum is equivalent to maximizing simplicity, but that is a mistake. Don't confuse clarity with terseness. Clear code is usually terse, but the tersest code is not always the clearest. Strive for clarity, not for terseness.
I don't care about `Array#includes` or `**`, we need module support!
I don't understand, if you want strong types, use a strong typed language. I use JS for everything from batch scripts, to cli and websites. I have never had the need for Types. This is just another tool, that will waste my time for a bit, then fade away like the many before it.... The only thing that has been there for me this entire time, is VanillaJS. ;)
&gt; California Style Sheets are a standard, meaning there is a group of people at W3Schools who come up with new properties (like border-radius and box-shadow) every year. [](/hahaha) I love this.
Oh god, those comments. This is hilarious. 
👌
If you want to remove the phrase: a) y = y.replace("&lt;my phrase&gt;", ""); If you just want to verify it's there, you can use String.prototype.indexOf, which returns the index where it found the substring, or -1 if not found: b) y.indexOf("&lt;my phrase&gt;") != -1 // true if y contains "&lt;my phrase&gt;" There's also a slightly simpler and clearer includes method new to ES6: c) y.includes("&lt;my phrase&gt;") // equivalent to b As for the text going off the side of the page, those blocks are in elements that have the `white-space` property set to `nowrap` so they just keep going off to the side.
Yep you're right, it's probably a matter of preference. That been said, I do think that .npmignore is more error prone. For example, I am using a IDE that creates a .idea folder but that's not visible from the IDE itself. It's also in my .gitignore so I never happen to see it anywhere and may just forgot about it, it's ignored after all. But then it gets published along with the package if I forgot to add it to the .npmignore. Actually I'd probably have to add .DS_Store, .vscode, and any other files that may not be useful to the package. So the thing is, with .npmignore you're not really sure about what's included in the package and on the other hand, you know exactly what's in with package.json's files.
It's good that they are putting a lot of effort into Edge. But with IE still so widely used, supported by MS, and shitty you have to wonder what the point is. `0%` to almost `3%` US market share in a year is impressive, but it'd probably be more if it was just another iteration of IE rather than a browser that is completely foreign and new to users. So it really doesn't matter who steps up their game and who doesn't, because IE is actually never getting full ES6 support, and Microsoft won't put it out of it's misery. 
Yeah, I too often find my self including less files than I'd have to ignore. Might well be a great way to encourage you to shorten the list.
you could also [conditionally serve](https://blog.getify.com/smarter-transpilation-strategy/) transpiled code to IE users. 
That's not a peculiar question at all. It's actually incredibly common string manipulation. It's so common that there are built in methods to handle find and replace (eg, String.prototype.replace()). You could also use slice() to remove parts of string. var str = "This is a string."; console.log(str); //This is a string. //Replace the phrase with an empty string strReplace = str.replace("This is a ", ""); console.log(strReplace); //string. //Slice off and return starting at the index of the word string and stop at the index of . strSlice = str.slice(str.indexOf("string"), str.indexOf(".")); console.log(strSlice); //string
With any luck you'll be driven out soon enough as well.
Using iPad mini in Reddit app which uses web views, iOS 9.3
I haven't. It's usually TODOMVC-like.
&gt; TODOMVC So essentially, a breakdown of how different frameworks/libraries solve one particular problem? 
Would love to hear your comments ^_^
Woosh
They can stop distributing it though. They could have left it out of their new OS though. They can stop releasing bugfixes for it and EOL it though. They really aren't doing much. 
&gt;Why O'Reilly would put her satire in a rather serious book, and how it got past technical review. It's not a book for beginners. Books are written with an audience in mind. In this case, it's a book for people with some experience that are maybe open to seeing things from the perspective of someone else - potentially someone with more experience. Satire is a useful tool for getting yourself to really question your beliefs and how you see the world. Some people, as you can see by some of the comments in the thread, act rather negatively when their beliefs are questioned. They get defensive and lash out. This is a sign of someone who is not very mature; they hold on too tightly to their belief systems and tie them too strongly to their own identity and perception of self-worth. They don't understand that questioning and possibly rejecting old beliefs is a normal and healthy part of learning and growing - in any profession. Take a look at [Ignaz Semmelweis](https://en.wikipedia.org/wiki/Ignaz_Semmelweis). He was a doctor in the 1800s who had the audacity to suggest that doctors wash their hands before delivering babies. His ideas were initially rejected by doctors because they took offense to the suggestion that they were causing the deaths of mothers due to infection. I'm not saying Jenn Schiffer's satire is necessarily the same thing, but whenever I read her posts, I'm reminded to think critically about the work I do, decisions I make, and the to views, technologies and techniques I espouse. And most of the time it's pretty funny. You've gotta be able to laugh at yourself sometimes.
Nice, I wasn't considering this usable data by any means, just a starting point for OP. So thank you for taking it to the extent you have.
Heavy buzzword alert here ! A selection: Complex abstractions. Built-in abstractions for real-world applications. Maintainable, scalable applications. Encapsulated, reusable components. Large-scale apps. Higher level constructs. Full-scope. Simplicity, elegance and modularity. Large production app. Fractability. While I can accept that my work and its challenges may not be as real-world, large-scale and full-scope as everybody else's, I find it very annoying, that people have not even the benevolence anymore to describe a *real-world problem* with a *real-world use case* and providing a solution for it by giving us a *real-world example*. And I'm not talking about another Todo widget. Jeez. Real-world apps. As opposed to what exactly? Middle earth apps?
How about, instead of being an ass and trying to make me feel bad, you just tell me what I'm missing? Is it the obvious fact that the statement is satirical, or is it something else? 
How's saying "whoosh" being an ass? Calm down dude. I'm not attacking, no need te get all defensive. The piece of text OP posted is satirical, the author knows a virtual machine isn't an actual physical machine.
Rsync scans everytimes tons of small files and it can be slow
It's a completely unconstructive comment, and it only serves to inflate your ego. Besides, as I told you, I was already aware of the fact that it was satirical, so I guess you're the one who got whooshed. 
As opposed to your very constructive comment. Chill, it's just a random comment on the internet, no need to be upset. Bye now!
Let's just setup Satireoverflow.com and see how long it takes people to realise they clicked the wrong link and now their database is kaput.
&gt; I don't understand, if you want strong types, use a strong typed language. You mean like, oh i don't know....Typescript? &gt; I have never had the need for Types This actually made me chuckle a little. Have you never had to do a typeof check in javascript? 
That's what we thought when Firefox was at 3.6 and look at that number now. I'd have no problem with it though, it's just a number.
Simple, really. We have a square and as big of a circle inside the square as possible. Then we add points at random somewhere inside the square's area and figure out how many points are inside the circle and how many points are there is total. The equation is as follows: PI ~= 4 * PointsInCircle / PointsInTotal After that I just calculate the error, as in the distance of the estimation from the actual value of PI (in this case, just the JavaScript Math.PI constant) and graph it. It seems like the estimation is really dependent of how evenly distributed the points are. I figured that JavaScript's built-in Math.random is probably not the best candidate for this and therefore I googled around a bit and found a little better random distribution number generator library called Sim JS. Funnily enough, it seems like the Sim JS website has been hacked (:D) so I wouldn't advice visiting. Now, when using Sim JS to generate these more evenly distributed random numbers, we sometimes get a really bad seed and it takes longer time for the error to go down, but I guess that is ok, as this is an estimation after all. Repository for this project can be found here: https://github.com/ahvonenj/estimate-pi-graphical
If it makes you feel any better, you're hardly alone. If people don't hate him just on the basis of being the person responsible for javascript, they hate him for his support of prop 8, his support for coffeescript, or his new brave browser (which skims profits off of ads). 
true, i never needed help that i didnt get from google so i guess thats why. anyway i fixed it by myself but thanks for reading (and wanting to help /caring) !
lol
&gt; This is similar to the hipster-glasses/scarves effect. TIL: [https://en.wikipedia.org/wiki/Hipster-glasses/scarves_effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)
the year is 2035
Well i don't seriously use Dropbox as a backup utility, more of a handy way to keep files synced easily without having to use git. Also, it's handy to have stuff like photoshop files and what not in Dropbox, because that kind of stuff you wouldn't put in git anyway.
At first glance, you have conditions for 'greater than' and 'less than' in the loop, but are you forgetting to handle 'equal to' and it is initializing with with both sides of the condition equivalent? 
[Jenn Schiffer’s reaction to this thread](http://negativitysandwiches.com/post/143748978235/listening-in-on-a-room-of-people-talking-about-who).
I swear, one of these days, I'm going to replace V8 in Chrome with a Python interpreter.
Maybe! Hard to paint everyone with the same brush. I just don't want us to treat typescript as a panacea when it's just a tool to solve some problems - some problems which you might not have yet.
Very often a full stack framework will put forward a specific kind of idea about how things 'should work', ie the set of basic concepts behind such a framework. It is very hard to make a full stack framework to which you can bolt on anything, even if it doesn't adhere to the frameworks base concepts. I have the most experience with SproutCore (Ember was derived from it). It provides a full stack MVC system featuring data bindings (automatically updated values between different objects), observers, automatically cached computed properties, state charts, view layers etc. Most of this is compartimented in modules (called frameworks) and you can make a selection what you need. However, in order to make this all work together and work fast, all parts / modules / frameworks share the same basics, and use the features described above in order to give the developer an order that is convenient. Try to imagine a full stack framework of which every module would have a different API concept. The amount of 'glue' code you'd have to write in order to make things work would possibly outgrow the actual code of the modules. The purpose of frameworks of this size is to help you prevent writing this 'glue' code. Consequently, everything coming from outside, and therefore having a different API will have to be wrapped.
MDN is just so incredibly good that I have no reason to go anywhere else. But I mostly work on the server, not much front-end js
Thanks! I didn't knew the guidelines to be honest ;-) So I'm gonna keep that in mind, so I will share also other sources! Thanks for letting me know :-)
Greater than moves the entity up, less than moves the entity down, if it's equals it shouldn't move at all (which is kinda what I'm going for). It doesn't start with the equals to since the target position is always grid (1, 1) and the start position is always grid (11, 4).
Well, if you don't like jokes in a "serious" coding book then you definitely don't want to read any of mine :) Some readers actually like a little levity now and then. It even helps some stay engaged (or so I've had a number of people write to tell me). The examples you show here strike me as simply her writing style and her having the same opinion as I do about levity. I for one find her satire to be entertaining, to varying degrees. It certainly isn't something that I think hurts her books from what I see here (I'm not especially familiar with her work). As for technical review, well, it could be that her reviewers called her on these things and she exercised creative control and said "they just didn't get the joke". Fair, in my mind. The risk with this approach of course is that some people simply won't find your humor funny and some will even be actively turned off by it. It's very much a personal thing... what's funny to one person isn't to another and there's no right or wrong of it. I think it's that more than anything else that usually has publishers wanting "serious" books: there's simply less risk from their perspective. I don't know... for me, I'd rather read a groan-worthy joke every now and again than have my eyes glazing over from a sterile text. While some of the examples you post do in fact make me groan, and DO, I'd have to say, border on being incorrect, they all look to be borderline and not outright incorrect, at least if you understand that she's coming from a place of entertainment.
Just create a website that randomly chooses keywords from tags and switches them around.
with inotify for linux or FSEvents for osx or probably a mix of different techniques
Hey there! I'm the author of the blog post. You can actually send a text message to any number you want. The example I used was just your personal phone number because it is the easiest for you to verify that your code is working. The reason that it is only letting you text your personal number is because that is the number you used to verify your account. Trial accounts can only send messages to verified numbers which is why everything is free for development. To send messages to any number you would have to upgrade your account and then would be charged a fraction of a penny per text message.
It's an interstitial essentially.
Yeah, I fixed that pretty quickly. Thanks for checking, though. :)
But we want strong types and also to keep our 50k line of code JS app without porting it to a vastly different language. 
Is your server being flooded right now? Takes a very long time to load for me. Like the idea though!
I get a lot of useful information from W3Schools that I think wouldn't be on MDN - like bootstrap.js examples
I've always read that it was bad, it even has a website dedicated to that: http://www.w3fools.com/. Aside from whether it's good now or not, I have a chrome plugin that filters it out of google results so that MDN results are more visible, because that one is undeniably *good*
Hit front-page of hackernews a few hours ago, and I'm running on the cheapest possible DigitalOcean droplet :) That said, the major patches of lag I've seen have been due to Spotify's API hiccuping. It's running pretty swiftly for me now! 
thanks!
!
it's more my reaction to the unnecessarily negative response from one particular person. i didn't want to write a 2nd blog post about how maybe it makes more sense to read the *whole* chapter and not just the small parts outlined above. folks can buy the book (profits go to EFF, who are fighting to let everyone pretend they have superior sense of humor and/or technical book editing abilities) OR y'all can read the whole chapter here ~*FOR FREE*~ https://medium.com/cool-code-pal/one-world-one-language-15be446f8809#.g7zdtctri my deepest condolences to everyone tragically affected by the fact that o'reilly and i have conspired to ruin your wallets and outlook on the web development industry. &lt;3 xoxo j$
Your mentor is behind the times. He probably read about the w3fools.com link and never bothered to read it about it again. W3Schools is fine. As the w3fools site now says &gt;W3Schools still has issues but they have at least worked on the primary concern developers had. For many beginners, W3Schools has structured tutorials and playgrounds that offer a decent learning experience. ... &gt;He suggested I always go to MDN because that's the official source of JS. It's not the "official" source but one of the best.
The thing is though, it was never bad. Most of W3Schools stuff was written for newbies and frontend devs, and really, even 5 years ago, the majority of frontend devs were more designers and less engineers. But, then, out of nowhere it starts getting a bad rep because it's not more technical or whatever. It's the same now as it always was, really.
That one post was indeed acerbic. As the op here, just wanted to note that the whole point of this thread was *not* to criticize you or demean you in any way, but question what I found to be an oddity - I've asked the same and commented about the same issue - The intriguing part for me was the inclusion of your satire in an otherwise uniform (Serious™?) book. That's all. California Style Sheets and Node for modern web pages are epic! (And apologies if anything here other than that one mean post has been Upsetting™).
Why not use Vanilla.js 
My only experience with it is the stuff that comes up in Google searches for CSS/JS/HTML things, usually right above the MDN result. I wouldn't say it's inaccurate, but it is very low-effort -- no explanation, few examples, and low on detail. But it is fairly up-to-date and gives answers you can actually use, unlike, say, the Wordpress.org forums.
You need to declare your arrow function as `async`
Ahh, thank you, I always forget that. EDIT: One more question...how do I await that async function? So, the revised code is async function addFiles(dir,tree) { return (await readDir(dir)) .map(async (name) =&gt; {await readDir(dir); return name;}) // error here } but that just returns a bunch of promises, because the function is not being waited upon.
nah the original post isn't upsetting, i rather enjoy seeing people squirm thinking that what i am writing is both serious and in a technical book. it's part of why i do what i do! o'reilly has some good sports in their book department and when it was pitched to them that a satirical chapter of mine be added to the book, they apparently loved the idea. but also, to be fair, literally everything i've said in that chapter is correct and true - facts and opinions. javascript literally does not need the java virtual machine to run xoxo j$
Really? We're gonna give her props for being a deconstructionist who gets published in a book where people who don't know her are going to read the words and wonder what the hell is going on? You know, like what happened to OP?
I wish it always did. 
How do you get something in a function to happen without calling it? You don't. Period. You are solving your problem the wrong way. Explain what you want to accomplish, and you will get a recommendation that is much better than an answer to the problem you've created for yourself.
I'm actually not giving her "proper respects," I'm pointing out the nature of what she is doing. You can decide for yourself if it is clever, or necessary, or disruptive.
If W3Schools is the first search result and I'm only looking for quick info on an element or browser API, it's usually good info and gets the job done. 
The obviousness of it, and the periods between the letters in CSS. She's trying to make a point. :)
self
I never saw any. Oh well.
What were some things on w3schools that used to be bad? 
I'm guessing you mean *non-consecutive* spaces? use /\s+/g &lt;--- g for global (as in replace ALL occurrences). + sign just makes it match *consecutive* spaces
Perfect, thanks!
I wanted the structure to be compatible for users without javascript. Using a base64 placeholder source wouldn't work work for them.
It was partly due to some, while not strictly wrong, dated information. Their suggestions for things were from a prior period in web development, and were at that point considered bad practices due to changes in the way browsers work. Furthermore, they practically ignored any community input (And HTML standards are pretty much community built), which is how a lot of developer resources are run. And for good reason. The standards evolve constantly. Extending this even _further_, because of their presence, they were easily confused with the W3Consortium, the organization that officiates web standards, and when contacted by the W3C to make efforts to disassociate (Avoid misleading, make available a disclaimer of affiliation), nothing was ever done. The only reason there was a huge push against them is because W3Schools was the top of the web results for almost anything web related, despite these problems, so folks had to actively go against them or the cycle would've never ended. Though, if I'm wrong on any of these points, feel free to correct me.
I don't understand what you mean. Can you elaborate?
Thanks for the post. I found it really cool -- I like how you broke things down and actually explained what was happening rather than just "copy and paste this code and it works". 
Wrap the return in `await Promise.all(...)`.
`Promise.all(arrayOfPromises)` returns a single promise that you can `await`. Alternatively, you can do a `for-of` loop over the result of `map()` and await each of the promises.
Ugly but accurately documented is infinitely more valuable to me personally than pretty and poorly/incorrectly documented. Ideally, documentation would both be easy on the eyes ***and*** functional, but if I have to choose one, I will always take function over form for technical docs.
W3Schools is actually a better reference for beginners than MDN. The way it presents its content is smart and thought through. MDN is better for more advanced developers. The references on MDN are badly organized, but they have the newest features and in-depth explanations.
I tend to use it just for CSS/HTML stuff, it's playground and more is nice. For JavaScript MDN is awesome.
W3Schools is kind of useless - or rather overshadowed by better alternatives. For quick lookups, use something like devdocs.io and MDN for more in depth info.
Serious question - do you have an example of where they are inaccurate? I use them all the time.
I've never seen anything wildly inaccurate enough to notice. At this point, the way I'd describe the difference between W3Schools and MDN is that W3Schools is like a cheat sheet/quick reference/introduction to a given thing and MDN is like a heavy reference manual with a lot more detail and lesser-known rules/properties/methods/etc.
So far I haven't had incorrect documentation from w3schools. The website is not only pretty, it has a unified tone for its documentation, so you know what you'll get and what to look for when you search their site. MDN has digressions, jargon that writers don't bother explaining, and all of this is confusing.
Sure! If a base64 string is the src value, that means there needs to be javascript to change the value to the desired image sometime later. If a user isn't using javascript then they would never be able to see the desired image, it would just be blank. &lt;noscript&gt; is an element that is only rendered for browsers without javascript, which is where I store the image to load. This way my javascript library will be able to dynamically read and load the image on demand, while still loading the image (though not lazyloaded) without javascript.
devdocs.io
[Ask HN: Who is hiring? (May 2016)](https://news.ycombinator.com/item?id=11611867)
I don't think it should be published in an o'reilly book but it's funny everywhere else
W3Schools : web development :: Nickelback : Music
Not the OP, but in nearly 20 years of using JS I can only recall one time I needed to check the type. But then I'm a perfectionist who doesn't write a line of code without thinking it through thoroughly. Maybe that's why I've never been bitten by the type monster who is apparently the bane of every other developers existence (based on how often I read articles bemoaning the lack of types in JS). 
Don't know why someone would downvote me... it hasn't ever let me down. Don't know why someone would be so butthurt that I've never been led astray that they would feel the need to downvote that. Some people... Jesus Christ.
MDN doesn't use extremely simple examples. They often tie multiple concepts together instead of just demonstrating what you were after. Not that it's a weakness, just a different approach.
I'd argue devdocs is more efficient either way - or you could install it (or a similar one) and use your OS highlighter. Or, you can add it to your browsers search engines so it works directly from your browsers search bar like you'd like: http://devdocs.io/help#browser_search
Context does matter. I'd have laughed myself silly if I hadn't bought something with the expectation to further my education.
They've most likely cleaned up over the past few years, but this archived site will explain some of the problems they had previously: https://web.archive.org/web/20130302014219/http://w3fools.com/
Which would be cool, if my current method didn't work fine, but it does. So if everything is already working fine, why would I go through the trouble of doing something else?
As much as I prefix all my searched with MDN, I always seem to get w3schools links right at the top if I don't. I give them credit for SEO.
http://devdocs.io/
Mozilla developer network
If I may put on my Internet-Armchair-Expert hat, get on my high horse and direct it on a soapbox for a second, ... This is the kind of writing which is only funny to people who are in on the joke -- as made painfully clear by all the "pro" comments in this thread. In other words, it can at best be considered elitist, and at worst be considered disinformation. There is an art to satire (or however you want to call this), and this isn't it.
I've got this `https://developer.mozilla.org/en-US/search?q=` bookmarked with `mdn` as a keyword. You've just got to start typing `mdn` in a new tab and arrow-down and start typing your question (it's probably one of my most heavily used bookmarks.) *Edit:* Maybe not so much a question, MDN's query works better with keywords and verb-ages.
This is the correct answer. The best way to learn its too get your hands dirty.
I'm so conflicted about devdocs.io. On one hand, it does a job that a website has no business doing, and as a result is missing (through no fault of its own) critical features like activation via keyboard shortcut, integration with native features like OS X's Spotlight, and background updating. This gives something like Dash a solid leg up. On the other, it's probably the best example I've seen (other than Google's main properties) of a beautiful JS-powered website that don't need no font-end framework. It's everything that the no-framework fanatics like myself argue ditching frameworks can give you: its performance and load time both blow every website written with a front-end framework, no matter the framework, out of the water.
Or [Zeal](https://zealdocs.org/) for a fast offline documentation. For Mac there is [Dash](https://kapeli.com/dash).
Devdocs is also incredibly simple for a "web app". There's no need for a framework because it really isn't doing anything beyond loading a list for the sidebar and loading templates for the main area. I'd barely consider that a web app. Also, I wouldn't call it beautiful, it's actually pretty bland overall.
Because you obviously must use something else. Honestly, I've been developing for 15 years and have never heard of devdocs. I have no idea why this guy is promoting it so hard.
Woah, this is cool. I've already paid for Dash though and you can't beat being able to search via Alfred (or offline searching). I've got MDN documentation shortcutted to `js` so I just pop `js trim` for instance into Alfred and go straight to that article. It's great.
This article is pointless. That's an opinion that I hold, because I had an opinion about the article that I read. If I had read a different article, I would have had a different opinion, which would have been different since it wouldn't have been the same as my other opinion. &gt; "I have an opinion on this article." -roxm when discussing the article. Despite the fact that this article was pointless, it's also a bit contradictory, but that's just my opinion. If the article had a solid thesis instead of being a collection of sentences strung together, it might have had a point. You might have thought that you gleaned some meaning from this article, but you would have been wrong. In summary, my feelings toward this article are that it: 1. Is rambling, incoherent, and serves no useful purpose whatsoever, and 2. Does so in a way that is not funny while trying to be funny in a not-funny way, and somehow fails despite the double indirection. That is what is wrong with this article. _roxm is a bored redditor who was frustrated enough about this article to type this up on his phone while he waits for the build to deploy._
Check out http://regexr.com
Don't know why you got downvoted cause you're right and the point I was trying to make. But this is reddit after all where wisdom and understanding are sorely lacking.
That's just silly. Your implementation of `Symbol.for("Symbol.iterator")` can conflict with mine just a much as if we just used the string `Symbol.iterator` without a Symbol instance
It depends. You know what you are doing? It works since you can filter it for finding what you are looking for. Don't know what you are doing? Be ready for inaccessible, low quality code. Is it bad? Yea. Is it terrible? No. Is it good if you know what you are looking for? Yea. Is it good if you don't know what you are looking for? No. Kind of like codecademy. It is good for a start. Are you a web developer if you do every lesson on it? No way. But it is a start. Learning to walk is a part of the process In Learning to ride a motorcycle. 
If that is true then telling people to use MDN instead of W3S seems like telling people not to use StackOverflow for .NET because they should be looking up stuff on MSDN
Right. It's great as a reference manual with examples. I find it easy to grasp whatever came up.
Are http://www.w3fools.com/ still up-to-date? They link to sites that look abandoned (are they?): http://movethewebforward.org/ http://www.webplatform.org/ 
Examples? You're asking a lot if you want people to download and then figure out your own library to give you feedback on it. (also, saying you have the "unified" or "standardized" build tool will [invoke this](https://xkcd.com/927/))
&gt;To install Angular for a browser application please use: `npm install --save @angular/core @angular/compiler @angular/common @angular/platform-browser @angular/platform-browser-dynamic rxjs@5.0.0-beta.6 zone.js@0.6.12` RxJs is now "standard" to install with Ng2? Did they give up on a 10kb file size for hello world?
https://github.com/Flet/semistandard
They sure aren't, but that was their goal, not mine, and I'm totally going to keep banging on about it until they admit defeat or pull off a magic trick. And even minifying and gzipping the crap out of ~800kb isn't going to get you to a tiny download size. You are going to feel that on a 2g/3g mobile device no matter what bundling tricks you try and pull.
Can I get an ELI5 on what rxjs is and why it's required?
From the article: &gt; In this guide I will be encouraging you to use eslint-config-airbnb which is a great starting configuration. Can you outline *any* reason why your suggestion is better? Otherwise this seems like pointless bikeshedding over someone else's perfectly serviceable choice.
Think about it this way. If you had the equation: A[small square] = r^2 That would tell you the area of a square with sides of length r, where that is the radius of the circle. That would be ¼ of the larger square surrounding the circle, since the length of each side is 2r. That is, the area of the larger square is: A[big square] = (2 * r)^2 = 4 * r^2 The area of the circle is much bigger than A[small square], but still smaller than A[big square]. It turns out that this ratio is pi. A[circle] = pi * r^2 The ratio of the circle area to the big square is given by: A[circle] / A[big square] = (pi * r^2) / (4 * r^2) = pi / 4 Therefore, if the points are truly random, the ratio of points in the circle to the total number of points in the big square will also be: P[circle] / P[big square] = pi / 4 Thus, you can calculate pi as: pi = 4 * P[circle] / P[big square] 
we use a tiny portion of RxJS in the core, and you can opt into the rest of the operators if you like - we've not given up on 10k, but that's a little ways off yet. For reference, here's a simple hello world that's using rollup and ES6, clocks in at 200kb min/47kb gzip - https://ng2-compiler-test2.firebaseapp.com/
&gt; To install Angular for a browser application please use: `npm install rxjs@5.0.0-beta.6 ` angular release candidate relies on RxJs beta!! Brace yourself! lots of Breaking Changes are coming EDIT: removed mailto link from rxjs
Whats your use case here? You're most likely asking the wrong question ;)
That's true, but only if (as you say) mdn is set up as a keyword. That doesn't seem to be what /u/hatestheinternet was talking about. 
I know angular uses rxjs. I am not saying it is a bad decision but *depending on a beta version*, breaking changes in rxjs will cascade into angular. I can already see that migration from ng2 rc1 to ng2rc2 is going to be *fun*. whatever new features --*I do not know about RxJs*-- RxJs will have in new version, would it not be better to ship ng2 first with Rxjs 4.x and do the upgrade to Rxjs 5 in ng2.1?
Yes, I know I don't have time to do it, but if someone could create a wiki that lists articles explaining the why of different programming constructs, that would be epic. Why do we need (or what problem is being solved by): if statements, closures, modules, generators, arrow functions, objects, arrays, React, Redux, flexbox, BEM, etc. 
Seems that's in the pipeline :)
It's not as horrible as it used to be (both in content and design) but MDN is still much, much better. Since (afaik) it's still ranked higher for most searches, I got into the habit years ago of adding "MDN" to the query every time I look something up.
Meh, the other day I was looking up something for twitter bootstrap and this actually came up: http://www.w3schools.com/bootstrap/bootstrap_grid_basic.asp I mean why would they feel the need to make that page, apart from clickbait. It says exactly what the bootstrap docs will, with an increased chance of being out of date.
Its a Release Candidate, not a stable release. Don't write production code in it if you're afraid of the API changes.
Let me explain my viewpoint like this: as ng2 rc1 is using rxjs 5beta. so when ng 2 is released, it will depend on RxJs beta (or rc) unless you somehow know that RxJs 5.0 will be released before ng 2.0. catch my drift? at this point of time, breaking changes are inevitable but as long as ng2 depends on RxJs beta, it will be hard to go from RC to production ready.
Oh come on, you can do better than that. You sound like a non-developer talking about how easy it is to build websites. They always notice what takes up the most screen space, but not what actually takes time: - downloading, storing, indexing - smart search algorithm - links to places on pages - highlighting sections on pages - expand/collapse arrows in the sidebar (framework bait right here) - settings page - auto-generated table of contents - doubtlessly more I didn't notice Almost every web app isn't more complex than that when it comes down to it. That's my point: they recognized that they don't need a framework, most teams don't. &gt; Also, I wouldn't call it beautiful, it's actually pretty bland overall. I meant beautifully engineered. But if we're talking aesthetics, I think they did that well too. It'd be a shitty documentation tool if its appearance were anything but bland. It's very clean and clear as well.
The W3Schools stuff is usually much more condensed than the MDN articles. So if you need a quick help or win, you might want to go there. I've never seen really bad code there, mostly because there are only few and very short code snippets. Double checking, which Browers or Platforms provide feature A or B is always helpful.
Again, we work very closely with Rx, and frankly, they've been more stable than us over the period of the beta. Non-issue.
I see, that is good enough, i guess
It is quite good, but not "incredibly", unfortunately. For instance, this sentence from https://developer.mozilla.org/en-US/docs/Web/CSS/min-width is not 100% accurate: &gt; The value of min-width overrides both max-width and width. What does "override" here mean exactly? Does one declaration remove the effect of the other? Always or sometimes? For instance: - if `min-width` is smaller than `width`, then `width` is used and so there is no "overriding". - if `min-width` &lt; `max-width` &lt; `width`, then `max-width` is used, and again, there is no "overriding".
I use a Chrome-extension called W3Schools Hider. It hides w3schools from my Google results. It has WAY too high page rank. I feel like it reads more like a Tutorial than actual Documentation. So its def a good resource if you are learning HTML/JS (although it might not teach you best practices). But beyond that I prefer MDN.
If you don't set it as a bookmark but add it as a search bar option (possible in both Chrome and Firefox), you can instead just type 'mdn query' or 'mdn&lt;tab&gt;query'. No need to remove your hands from the keyboard to reach for the arrow like some kind of savage.
That was *delicious*. There's entirely too little Clue in our community as a whole, and that article was *full* of it.
Please don't. After running into outdated or simply incorrect info at W3Schools I always advise people not to click their results (I even have them blacklisted)... hopefully they'll drop out of Google eventually.
Someone posted this link below: https://web.archive.org/web/20130302014219/http://w3fools.com/
If you are googling for a specific thing they will most likely be correct. You just really don't want to learn the whole javascript from them.
some top-tip advice. Wish I had done this a long time ago
when i saw `other discussions(52)`, I was like how the hell do 50+ subreddits care about angular? Apparently all angular announcements link to changelog.md instead of a blog post like rest of the js framework. 
That's a good point. I should write documentation. But I thought the commands in the roadmap were kind of explanatory
I updated the readme. Is that walkthrough good enough for now?
&gt; but the same is true of whatever site I use instead Well, you can contribute to MDN, that's an important advantage.
Me and my coworker were describing the other day how great W3Schools is and how they almost always have a supet easy example to build off of. 
Agreed, your description is much better. What I am objecting is the use of the word "overrides": What if min-width is greater than max-width but less than width? What overrides what?
While people complain about W3Schools all the time, their XML sections are actually pretty good.
&gt; Does W3Schools still suck? &gt; No. Do I care? Also no. A reputation that damaged is very hard to be undone for me. MDN and StackOverflow is still superior. I also use the w3school blocker extension :)
The link I posted is to the web archive. They now state that w3schools is better.
Not necessarily. I think ESLint is all over adjusting it to yourself, but let's be honest. It is really time consuming to set it all up by yourself. More options to do it quickly (adjust _just for you_) is a good thing. Config-airbnb is a feature-packed config, which may not fit your needs (especially if you don't use React). I used standard before and it is ok for simple needs.
RxJS is like pipes for your house. You install a pipe going from your water source(data) to your water heater. The water heater automatically heats up whatever water it's given. You them hook up pipes to your shower. Whenever your shower needs hot water you just ask it for more and it will automatically heat it up for you without you having to explicitly tell it to. / Eli5 It's basically a way to program using observables.
something like this. cookie = (document.cookie || "").split(';').reduce((mem,v)=&gt; { mem[v.slice(0,v.indexOf("=")).trim()] = v.slice(v.indexOf("=")+1); return mem }, {}) fooElem.innerHTML = "Hi, " +cookie.Name+ ", how are you doing?"
So why did you link to an irrelevant article...
Exactly. When I began learning web development I made a cheat sheet with w3Schools and I constantly have them under my eyes. Most of the time that's all I need, but this site falls short when you need to go deeper. w3Schools shouldn't be considered a reference, but a starting point. 
 elemA.style.backgroundImage = "url('image/" +elemB.className+ ".png')"; you can use any two elems for elema/elemb its a little trickier if elemB has multiple class names: you have to figure out which class to use from property `elemB.classList`
maybe what your really looking for is a different pattern... function test(SearchTerms) { githubSearch = SearchTerms.toLowerCase(); } if you really need to build a new if statement you can use `Eval()` or `new Function(" if (text == 'notjavascript') foo() ")`... but theres probably a pattern you can build a list of terms in an object and loop through that, or build a functional thing: var test = (v, val) =&gt; return v===val if (Test(someVar, "javascript")) foo() .
Since we are speaking about minimum width, maximum width and width values, overriding assumes higher value. If it said min-width overrides both max-width and width, then it would have been totally incorrect. But yeah, I understand where you are coming from, and it might be confusing for beginner. 
She is such a memer :3
This is a brilliant piece. I'm dealing with the same shit all the time.
i think you mean it *seems* more than a bit coincidental, as you're talking about what you perceive to be true without a strong case. i can't argue really that they are not my accounts other than just telling you they aren't, also your free 2 minutes with me are up! xoxo j$
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Catch mistakes before you run you JavaScript code with ESLint : x-post r\/javascript](https://np.reddit.com/r/programming/comments/4hn2nm/catch_mistakes_before_you_run_you_javascript_code/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; Where do you guys get your information on new JS frameworks and libs? Reddit and hackernews are my sources of all news about technical and programming. &gt;If I have a billion questions, where's the best place to ask them? google them up. unless you are dealing with real bleeding edge stuff or are just desperate, you will find that there have been dozens of people who have been in your shoes and posted at SO or reddit. one or two might have gotten a practical answer. &gt;But I want that to change. I want to be the guy who walks in on Monday and says "hey guys check out this awesome new library I found over the weekend" [Like this one](http://www.commitstrip.com/en/2016/04/26/the-just-got-back-from-a-conference-effect/)?
lol I've only been developing for a year, so I like that I'm not the only one that never heard of it. The site seems nice, but as I said, google works fine for me.
The way you spam that domain makes me question is legitimacy.
TIL
Well we are on Reddit so everything feels like bike shedding, but really it's just up to you to explore your own personal flavor of ESlint config that works best with your team. I personally enjoy the restrictions of standard.js so we implemented it into our code flow across our node apps. My suggestion isn't better or worse, just another path to explore in the ephemeral art of programming.
Yes please, I want a tech agent.
I've been working for a while in this framework and using it in production in the company i work for. It enforces good pratices of service design in node js, and make it really simple to use. With his plugin system you can even distribute you services across different machines, without changes in your code.
The eternal JS struggle.
Well, I'd rather eric elliot talk about an actual problem that exists rather than go off on a rant about how hiring developers who use "new" is a bad idea or some other such nonsense.
Shit, I'm this author's alt account? My life has been a lie ^Also ^I ^did ^the ^opposite ^of ^defend ^the ^work ^in ^this ^book, ^wtf ^you ^on ^m8
Holy shit yeah. I used to like Eric, he may have different ideals than me, and that's okay, but when I saw that I lost all respect and just don't care to read anything of his anymore.
If someone took that question seriously, I'd think twice about hiring them. https://www.youtube.com/watch?v=bzkRVzciAZg
You can use DevDocs offline
....you're hired!
I'm not bashing Node, I just hate irrationally exuberant people. People who are always being *pumped* by one technology or another are exhausting.
What's the advantage of using this "react wrapper library" instead of just using reactjs? The build that bundles this code will also include reactjs code too.
My understanding of lodash fp is that it is wrappers around existing lodash methods that have their arguments flipped and are all curried. Some methods also stop accepting optional arguments, since currying and optional doesn't work too well with one another. For the most part, that would indeed be a simple call site change. There's more [details on this page](https://github.com/lodash/lodash/wiki/FP-Guide) about what it would practically mean for you. But I would consider if you need this and if it is solving problems you have, before you take the plunge. Does the rest of the project use immutable data structures and make heavy use of passing partially-applied functions? 
Dear Google: I really want to keep my sidebars on desktops/laptops! I'm not always on a phone/tablet!
Eric Elliott is a running joke in the #learnjavascript irc.
Watch out that page also doesn't mention polymer so they will downvote you :P
MDN is organized in *some* manner, sure. But rarely in a way that I go "wow, this really was a useful way of arranging the info, I'll be sure to talk MDN up the next time there's one of those W3School vs MDN reddit threads". 
 #firstworldproblems
Oh, look. Eric Elliott wrote another article about how great he is.
I don't have any advice for doing what you want. But I'd caution against trying to do it wholesale. While it's probably nice, unless your codebase is tested to the hilt, it's going to end up with some issues that aren't obvious. You're going to want to change 1 piece at a time and make sure it works before moving on to the next piece anyhow.
Hi /u/rsschouwenaar, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). This article is completely removed from JS. If you want to submit general programming-related topics, please consider a sub like /r/programming instead.
You'd be surprised. The tech industry is the only one where I've found irrational exuberance to be a valued trait.
think of it as a pro athlete's product endorsement. Plus this is only the second time I've seen him pimp @JSCheerLeader, he needs to start an Instagram feed and try harder.
It's still good without the standalone examples. Just makes you have to work a little more to get it. Which I personally see as beneficial.
When was the last time you wrote a string that simple? In my work I'm usually doing stuff like this. *Strings:* '&lt;div class="' + className + '"&gt;' + '&lt;p&gt;' + content + '&lt;/p&gt;' + '&lt;a href="' + link + '"&gt;Let\'s go&lt;/a&gt;' '&lt;/div&gt;'; *Template Literal:* `&lt;div class="${className}"&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;a href="${link}"&gt;Let's go&lt;/a&gt; &lt;/div&gt;` Notes from this example: - Your string can span multiple lines. - You don't have to escape quotation characters. - You can avoid groupings like: '"&gt;' - You don't have to use the plus operator. Another example: *Strings:* title + ' ' + firstName + ' ' + lastName; *Template Literals:* `${title} ${firstName} ${lastName}` Notes from this example: - No need to add whitespace to the variables, it just happens inside the template string. [edited for formatting]
@temp69389389 is spot on. A lot of engineering and optimization went into DevDocs (5 levels of caching, efficient use of memory, async search, optimized DOM operations and DOM structure, … plus a lot more). It's not fast by accident. Some examples: * https://github.com/Thibaut/devdocs/blob/master/assets/javascripts/app/searcher.coffee * https://github.com/Thibaut/devdocs/blob/master/assets/javascripts/views/list/list_focus.coffee * https://github.com/Thibaut/devdocs/blob/master/assets/javascripts/views/list/paginated_list.coffee Disclaimer: I make DevDocs :P
hi you need addEventListener and preventDefault
so would that need to go after the opening brace for both functions?
Said this to the other guy, but I pretty much got really pissed with them coming over MDN searches and added this: https://chrome.google.com/webstore/detail/w3schools-hider/igiahejkpbnbnekdaefddmdceocmjpll?hl=en-US
How about if you want to do this in the future - 'Hi! ' + user + '! I\'m ' + name; `Hi! ${user} ! I'm ${name}` Escaping always causes me a headache - However the power really comes in when you spread over multiple lines, I defy you to find the old syntax easier to read then. For a simple expression it can be overkill.
Thanks. It work´s fine now :) Still i can´t figure out why. As far as I know span "marks" an area, like a text, which can be edited. Do you mind explaining?
&gt; 20 ms. That's about how long it takes to load jQuery. I would suppose that this depends greatly on your connection capacity. Loadind jQuery is only part of the equation. Then you have to execute it. This would warrant a lengty and argumented discussion which is probably already well developed somewhere out there. Suffice it to say that jQuery does add a computational overhead. If you're on a battlestation hooked to fiber optic, and only tingle a few elements, you don't care. But there are users on a shitty mobile with a dripple connection that may also be valuable customers. Then there is the programming effort. jQuery may alleviate some repetitive task and make for a more compact, legible code ; but it also comes with its own syntax and logic and at times I find it cumbersome to switch back and forth. With the new features in HTML5 and ES6, the rationale for jQuery is becoming tenuous. Finally there are cross-browser concerns. While they may still be legitimate in some cases, the bulk of the browsers wars are over.
No one is mentioning it here since its r/javascript, but W3Schools SQL docs and SQL editor are awesome. SQL fiddle takes too much time to setup while w3School's sql editor has prepopulated data. Also their examples are easy to understand, especially when looking for correct syntax.
It will be an entirely different React instance &amp;mdash; in the case of sharing instances, we'd have to head down the [HTML Import](http://www.html5rocks.com/en/tutorials/webcomponents/imports/) path, with each component specifying its dependencies &amp;mdash; multiple entries for the same dependency would load once and then from cache.
The website seems to be down. :/ 
Define slow. We use tons of transpiled generators in our app and it runs like a dream. 
 I was not understanding the documentation correctly. I assumed that importing it would have changed the _ object globally, forcing me to take the red pill and change it everywhere. But if I get it right, `fp=_.noConflict();` it's made exactly to keep the two cohabitating in the same codebase. 
We would never (since better tools are available*) use template strings for constructing HTML, because there are better tools for that. Your example in JSX would read simply as: &lt;div class={className}&gt; &lt;p&gt;{content}&lt;/p&gt; &lt;a href={link}&gt;Let's go&lt;/a&gt; &lt;/div&gt;; So XML/ HTML is out the window. In general, long strings (and multiline) strings instantly make inspect code smell (Does it really belong in the code or would it better fit in a config/ database?)
Strange how after 16 days away you come back to reddit *twice* in two days, both times to *this* thread. Also strange how you go to the bottom of a collapsed comment thread to, once again, defend Jenn Schiffer.
It can bundle. It's intended for JavaScript and only JS, not JSX, Type, Coffee, etc. You can configure that stuff yourself but it's intended for javascript developers to write the ESWhatever code and compile for use in all browsers and node versions. It bundles modules based on what you require() and includes it in the output file webpack style. One would use it to abstract away most configuration and just write javascript how they should and and compile a widely-compatible distribution of their code with the ease of a simple command 
Beyond readability, my argument against template strings is code style consistency. It is so much easier to identify a literal string when you have a single-quote or double-quote convention, than a mix of template string and either of the two. Note, that you cannot use template strings for everything, e.g. import statements will not work with template literals (``import * from `foo`;``). This adds code style inconsistency to the code base.
Yeah, most of the major libraries have something similar to help namespace clashes. You should be able to implement it slowly.
https://jsfiddle.net/uxq6rt9p/4/
I use JSX as well. But I think most people don't and constructing HTML templates with strings is still a really common thing people do. If your entire point here is you don't like template literals, that's fine. You're one person, I don't care if you use template literals. But I think they're clearly useful for the reasons I outlined above, even if you don't run into those use cases in your code.
Excellent post, I appreciate the writing style. Something I wish I could mimic with my own technical writing. My guess for why nobody disables this, is that it's really not that big of a deal. The post missed the opportunity to show before/after timeline results of how this actually benefits in the real world.
Consider the following code: $(".foo").addClass("asd") `bar`.replace(/bar/, function(match) {doStuff(match)}) That is equivalent to $(".foo").addClass("asd")("bar").replace(/bar/, function(match) {doStuff(match)}) due to ASI rules for tagged template strings
A single average image on the internet is bigger than that, just think of it as your page having just one more image. but arguably provides way more value. Also, albeit not necessarily, these frameworks are mostly aimed at SPAs, furthermore, proper CDN configuration that uses etags and 301 responses should turn into 83kb gzipped weight. which is nothing even for 3G/hsdpa(+) 
So you have a preference to use manual concatenation and want to purposefully find data that supports your view point? Sounds like selection bias to me. Maybe they are propagating faster than you can replace them for a reason. Template Literals are part of the standard and best practice. They follow a convention used in modern templating languages for years and so it's familiar, even more so than manual concats to many front-end developers. JS Linting rules and style guides tend to prefer them over manual concatenation and you'll find them throughout many modern JS libraries and plugins. The only real argument I'm aware of is that for the time being they require a transpiler to use in older browsers. But eventually the browsers will catch up and the need for transpilers will be reduced and eliminated. 
Using the template literal for the HTML is definitely more readable, although it does have the annoyance of including a bunch of unnecessary tabs/spaces that otherwise wouldn't have made it into the final string. This becomes much more noticeable too when running your code through a minifier.
I've been writing JavaScript since 1996. I've don't a hella string concatenation. I now use template literals exclusively, unless it's something really trivial. If you are dealing with concatenation that spans many lines, in my case often 100+ lines of template code, template literals are a godsend. Besides they obviate the need for a dedicated DSL for templates, such as Handlebars, etc. Here's a very simple example: // ES6 Template with Partial: //=========================== var es6TemplateList = $('#es6TemplateList'); // Define partial: var es6Partial = function(somebody) { if (somebody.friends &amp;&amp; somebody.friends.length) { return ` &lt;li&gt; &lt;div class='no-flex' style='max-width: 100px;'&gt; &lt;h3&gt;Friends:&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;ol&gt; ${ somebody.friends.map(function(friend) { return `&lt;li&gt;${friend.name}: ${friend.job}&lt;/li&gt;` }).join('') } &lt;/ol&gt; &lt;/div&gt; &lt;/li&gt;` } else { return ''; } }; // Main template that consumes partial: var es6TemplateRender = function(people) { if (people &amp;&amp; people.length) { return people.map(function(somebody) { return ` &lt;li&gt; &lt;aside&gt; &lt;img width='80' src='${ somebody.image }'&gt; &lt;/aside&gt; &lt;div&gt; &lt;h3&gt;${ somebody.name }&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; ${es6Partial(somebody)} ` }); }; }; // Render template with array and append to list: es6TemplateRender(people).forEach(function(peep) { es6TemplateList.append(peep) });
lol, wasn't asking you to. Awesome community.
Yup, this is a solid point.
&gt; &lt;div class={className}&gt; &gt; &lt;p&gt;{content}&lt;/p&gt; &gt; &lt;a href={link}&gt;Let's go&lt;/a&gt; &gt; &lt;/div&gt;; Minor correction &lt;div className={className}&gt; Don't you keep narrowing down the need for string concatenation at all. It's like continuing to narrow the criteria so that the only outcome/answer is the one that you wanted in the first place. Why not just tell people you don't like it and leave it at that. 
Exactly, template literals are beautiful for interpolation! The only arguments *against* them are if for some reason you absolutely cannot have Babel in your dev stack.
Yes, I wish I could find some hard data about speed improvements. Also, something I did not know is that if you do turn off debugInfo you can temporarily re-enable it using angular.reloadWithDebugInfo() I tried turning it on and off in my app, I don't see any difference. Is it supposed to improve paint and render times?
Also, check out [qudos.io](http://qudos.io), [sitepoint](http://www.sitepoint.com/javascript/), [pony foo](http://ponyfoo.com), [2Ality](http://2ality.com) for other JS sites, [javascript weekly](http://javascriptweekly.com), [node weekly](http://nodeweekly.com), [Frontend Newsletter](http://frontendnewsletter.com/), [HTML5 weekly](http://html5weekly.com) for email newsletters, and [Javascript Daily](https://twitter.com/javascriptdaily) on twitter.
Talk to developers *outside* of your company. Check if you have a javascript [meetup](http://meetup.com) in your city. Check if you have local branch of [nodeschool](http://nodeschool.io/), they may do intresting meetups too. If you don't have a local branch of nodeschool, organise one - this is an amazing way to give back to community and teach new generation of javascript developers. 
[This is my app.](http://basketball-gm.com/) Currently uses promises but I want async/await. So I ported the core to async/await and benchmarked it: original promise-based code vs. async/await -&gt; regenerator vs. async/await -&gt; native generators. Native generators were maybe slightly slower than the original promise-based code, no big deal. But with regenerator it was 20% slower. That's too slow for me, although for apps that are less constrained by JS performance, that might be fine. ([Kneden](https://github.com/marten-de-vries/kneden) is also fast for async/await, but it's too buggy currently.)
Your problem is that you don't want to call that function again. Make another function that you can call again, and use that when you need it AND in original function.
&gt; But I want that to change. I want to be the guy who walks in on Monday and says "hey guys check out this awesome new library I found over the weekend" I might be alone on this but don't be that guy. Every time I see someone post a new framework or library that basically does what 1000 other libraries have already done I just cringe. If you see something truly awesome that could benefit the business then by all means mention it.
Just learn something they are all pretty useful to know. Learn what you like the look of. I really get on with angular so recommend it. Well written ng1 code looks kinda like ng2 code, so even learning ng1 is useful! 
That's cool. Would be good if the demo could be cumulative.
After trying a few times I couldn't tell if the demo actually did anything with my image. Maybe you should bump up the strength? But more importantly, why?
Let me start of by saying I'm not advocating debugging on production code but in the scenario in which a production bug existed would the performance benefits of this change out weight the ease of debugging an issue? I guess this isn't a question we can answer since the article didn't contain any before/after results.
That is quite easily done, but there's an inevitable point where the image just breaks beyond repair, and then you're basically screwed. I'll look into it, but it might take some time to do it right.
That's not meant to happen at all, the algorithm does require some fine tuning, especially getting it evened out accross different file types (png is more sensitive). The file size is also largely influential, really small and it breaks easily, really large and it does (almost) nothing so I'll have to look into that. If you open the console in the demo you get a report with each try, whether it's successful and an image object. The reason *why* is because I'm going to implement it as a hover effect on my soon to be portfolio website, and I figured I might as well publish it. On my portfolio it's also limited to medium sized and optimised jpeg’s, so the result is rather consistent. Can you tell me what browser you're using? And was it the demo link here or in the GitHub read me? Thanks for the feedback!
It's my project now, so it's up to me. :)
That came out wrong. I did not say that template literals cannot not have such a use case. I have shared our internal arrangement to give a broader context to my disliking of template literals. Regardless, I will keep the discussion more open to general practices, as opposed to a specific use case.
There is no such thing as "best practices". &gt; JS Linting rules and style guides tend to prefer them over manual concatenation and you'll find them throughout many modern JS libraries and plugins. References?