I'm in a nexus 6 in the webview and it runs really well
You don't nessecarily need a framework to easily change/debug the code of others. If the code is just small JavaScript modules required into an entry point, its much easier to debug that over framework code, IMO.
Yeah! My problem was to increment the percentage in 0% to 100% in a specific time. The other things I've already done. This will help me. Thank you very much!
Cool! I should probably invest in another laptop cause it runs painfully slow on an intel pentium!
It's not that hard! My high score is 64 but I did kinda spend 5hrs playing this while making it... 
&gt; In this context, "tooling" refers to things like call-tips, auto-complete, type-checking, refactor/rename, and things like that. No, it does not. None of that requires a build step. &gt; TypeScript and Dart can offer much better tooling than ES6. Then go use those instead. &gt; Modules and classes add a lot more structure in a declarative manner. Modules are nice, because without them you can't break large applications into smaller files without a build step. This is a wonderful addition, but you can carry on without it. Classes are not necessary at all, and will likely make things much worse. I know concepts like classes, inheritance, and declarative programming may seem necessary for people with an OOP background but they just get in the way. These concepts add overhead and additional complexity without increase to execution speed. If you want to program in something that looks like Java, which is what this is, then go program in Java. If you lack the imagination to program large elegant applications without these concepts then this conversation was over before it began.
This is pretty fun! Good work!
turn off sound?
Pretty fun. You need to watch this and it will be 10x the fun: https://www.youtube.com/watch?v=Fy0aCDmgnxg
You can't delete a session cookie, because it has no expiration and the purpose is that it should persist as long as you are on the site. You *can* set it to an empty value: document.cookie="mySessionCookie=;" You may need to add the path or domain or other values to ensure you are setting the same cookie, **but not the expiration**. it is possible to "shadow' a cookie by writing a more specific cookie with the same name. If you are trying to remove a session cookie by setting an expiration, you are actually creating a regular cookie that has already expired and not affecting the session cookie.
20 mins on I still haven't got past 3 :P
Cool thanks!
No problems on my Note 2014 tablet. Nice job! 
You're not the only one. Most large javascript projects don't use frameworks. Frameworks are trade offs, the make one thing really easy and other things hard. I generally don't find the give me much.
Haha its meant to be hard! - makes it more addictive :P
Thanks! This is the awesome website i used to generate the colourscheme: http://coolors.co/app
Okay so this is how I use the code: 1. I start running OkCupid's 'Boost' feature. This feature gives my profile enhanced/maximized exposure for exactly 15 minutes. So during that time, many more people (who fit my search parameters) view my profile than normally do. 2. As soon as I start running Boost, I enter the js code in my browser console. 3. Upon entering the code, my browser begins to open the profiles of every person who happens to look at my profile during the Boost time period. This makes it appear as if I am interested in the other person as well. When the javascript is running, I literally just walk away from my computer because it opens (and then closes) dozens of tabs in my browser in order to view the profiles. Does that give you enough detail? 
It's working now. Nice! I guess my browser went nuts yesterday.
I'd recommend putting the bundle in a ["release"](https://github.com/bucaran/retab/releases) instead of in the repo. Compiled packages don't belong in source. GitHub releases can also be associated with a particular tag/commit, and add in notes like changelog.
&gt;Static typing becomes more valuable as a codebase gets larger and the number of developers that work on it gets bigger... [Citation Needed] I've worked on some enormous code bases and I can't think of one where static typing would have made any difference whatsoever. I can count on one hand the number of bugs that I've encountered over the years that were the result of "incorrectly assumed" types. On the other hand I can't even count the number of bugs that are the result of statically-typed code making assumptions about the platform it runs on. I also can't count the number of bugs that get introduced when people let the compiler try to work out how to deal with math involving different integer types. Static typing is really only good for one thing: Performance. It speeds up certain operations because the compiler/interpreter doesn't have to do as much work figuring out how to handle any given object.
There's two trends going on here. For one it's really easy to make a compile-to-JS language, and the proliferation of languages (TypeScript, Elm, Dart, JSX/Flow) is partially a result of that. The other is that applications are getting bigger, and need better static guarantees.
&gt; Static typing is really only good for one thing: Performance. So is Typescript more performant than Javascript?
It's more that you're always going to have one step, and scaling 1-N is trivial, so there's almost no additional cost. //gulpfile.js gulp.task("scripts", () =&gt; { return gulp.src(src.js) .pipe(concat("app.js")) //.pipe(babel()) .pipe(gulp.dest(dest.js)) })
Interesting. Glad it's working! Feel free to mess around with it... I'd love to see what mods/tweaks people can add to it!
You should call the game Hard as Fuck
lol
congrats, not congress boyo; Republicans only marginally responsible. 
Have you ever worked on a large code base which *does* have static typing? 
that looks really cool!
Also, change colors. Some are way too bright. It would look better and would improve UX.
I don't have an OKCupid account, or access to the boost feature, so I couldn't test it out myself, but you should be able to debug it yourself in console too. Start by typing the following in your console: jQuery('#spotlight .thumbs .match')[0] I'm guessing this won't return an element, and if that is the case, what you should do is then try to inspect element on whatever element that is supposed to be selecting (I'm guessing the picture of the lovely ladies/lads), and change that line in the snippet to identify the right element. 
It's not really any more work than vanilla js. You just add a grunt task to compile it, and then every time you press save, the files are recompiled and your browser will auto reload. However, even if it WAS more work, it's worth it in the end as a project with multiple people adds a lot of complexity, and therefore debugging time. Anything you can do to prevent this ahead of time will make your project faster/cheaper. 
If you can make it responsive, you should put that on the Firefox Marketplace.
This is all I could think of with that title. https://youtu.be/mioc_Zite5s?t=19s
Can imagine that running slow, but know that there can be *huge* performance gains between browsers. I've made a few simple browser games myself, on the same machine, I can get like 20 fps on firefox developer edition, when I get an easy perfect and smooth 60 fps in stock chrome. So if you hadn't, compare performance across browsers.
That talk looks bloody brilliant. I'm a js noob, but they make it very easy to understand. Thanks a lot for sharing dude! 
Haha thanks!
The main push for Google to go to static typing is due to performance concerns. They've pushed the v8 runtime pretty far over the last few years performance wise but now they are planning on pushing for either optional typing or a smaller subset of js functionality to continue pushing browser performance. 
Here's my 2c: - the first columns is good; all important stuff for a basic intro - there is a lot of emphasis on old DOM APIs that most "modern" JS devs rarely interact with (getElementsByTagName, `navigator`, etc) - modern frontend practices are encouraging less querySelector + DOM manipulation and more data binding, virtual dom etc like in React and Ember - "JS security" seems very out of place, maybe better suited for a different course - I really don't think AJAX deserves its own section, just encourage abstractions like [xhr](https://www.npmjs.com/package/xhr) since they are suitable in 99% of cases - IMHO JavaScript courses should be teaching closures, functions as first class citizens, and other functional paradigms rather than OO/class style programming in ES5 - IMHO any course that does not touch on node/npm and its tooling (i.e. gulp, grunt, browserify, webpack) is not preparing the student for real-world JavaScript practices
Now you can use the IndexedDB API in Node.js! Aren't you excited?
Met up with a couple of old school friends recently. One is now a Python programmer, the other is a C++ programmer: "...That's interesting" I said, "I'm working on my Javascript at the moment..." Python guy: "Javascript is shit". C++ guy: "Javascript is just a scripting language."
FYI this is not my servers URL, just using it in this example
There are no errors in the console, is there any problem with the GET and POST requests as far as you can see? 
Just DLed fiddler, how do I use it haha
So mostly you just open it haha, it'll give you a running list of all the http requests in and out of your machine. Your Ajax request will be in there somewhere, either as successful or failed. I haven't had a chance to check your code just yet.
There is a typo with your get request, 'trype: GET' should be 'type: GET'
Your post request starts '$ajax.', it should be '$.ajax'
And there were no errors, jesus. As far as fiddler is concerned it hasn't recognised any http request from my site. My site isn't live does that matter? I'm still sending a request to the server. Might it be a problem with the HTML?
&gt; $.ajax ({ &gt; trype: 'GET', should be type: 'GET',
Impressive
If you do have jquery in your project, make sure your code isn't executing until after jquery has loaded.
C and C++ are some of the worst examples of static typing - there are much better type systems out there. If you're interested, I'd recommend having a look at something in the ML family - in our team. In our team, the defect rate plummeted when we switched from Groovy to Scala. It really does make a difference. I hear a lot of people make the claim that they see very few type errors in production, but their definition of type error is skewed by OO languages. You'd be surprise see how many bugs a good type system can pick up. 
One of the few things I like about working in Java!
Nothing rigorous. I did take [this IndexedDB-based game I wrote](https://play.basketball-gm.com/) and run it on top of fakeIndexedDB, and it's pretty damn slow. Maybe like 5x slower. In theory it could be much faster because it doesn't have to hit the HD. One of my goals is to get to that point. But I haven't really tried to do anything clever for performance yet. For example, if you look at the data structures for storing records and indexes, they're just plain JS arrays, so it's pretty slow when you have to insert a new record in the middle of a sorted array. Basically, I have now reached the point where all the functionality is there and all the tests pass, but there is a lot of room for optimization. That means it's useful now for building unit tests and playing around with it, but if it was blazing fast, it could be much more interesting...
i see, i was basing my language from sicp. https://mitpress.mit.edu/sicp/full-text/sicp/book/node15.html
Build cool shit and the rest will flow. For example, you'll be working on a project and think, "I could really use a library that does X". This will happen frequently, and usually someone else has already written a library to do X. But eventually, you'll run into a case where there is no library that does X. So you'll learn how to write it yourself and learn how to publish it to npm. Stuff like that will happen all the time if you're building cool shit. Even better if you work to incorporate the latest technologies and best practices into your cool shit.
Whether or not a programming language is a called scripting language isn't necessarily arbitrary. (I'm assuming that the categorization you were talking about is scripting vs. non-scripting languages.) The distinction tends to fall on the primary use of the language in practice. Like Julia is a scientific programming language because it's primarily used among non-CS scientists and has features that make it really useful in that domain. (Or at least that was the intent of its designers; I don't actually know which demographics use Julia.) Take this description from [a good essay on scripting](http://www.cse.wustl.edu/~loui/praiseieee.html): &gt; To script an environment is to be powerfully embedded in that &gt; environment. In the same way that the dolphin reigns over the open ocean, &gt; lisp is a powerful language for those who would customize their emacs, &gt; javascript is feral among browsers, and gawk and perl rule the linux &gt; jungle. You *can* use C++ as a replacement for JavaScript in the browser, but it's not really built for that. Emscripten feels like a cludge but is helpful if you have a bunch of existing code. You'd never really feel powerfully embedded while using C++ and its standard libraries in a browse.r &gt; I've never really understood the "just a scripting language" thing There's certainly a subset of people who'll deride a language for being a scripting language. I'm not one of them, but their motivations aren't too alien. Terms like 'scripting' are useful because they they can corral languages together by frequently-shared properties, and it's okay for people to dislike the trade-offs associated with those properties. For example, performance seems to take more effort for implementors to get right in lots of scripting languages, often because it's harder to statically reason about programs in languages that don't preserve much type information. Dynamic reasoning isn't as well-developed a field, so things like tracing are only relatively new developments. So the C++ guy could have legitimate reasons for harboring a grudge against scripting languages, at least within the context of the problems that guy has faced. Or maybe the C++ guy is just a curmudgeon and beyond saving.
Just for you buddy: http://www.amazon.com/How-Win-Friends-Influence-People/dp/1508569754
The fact that the core of the framework is written in TypeScript doesn't mean you have to write your application code in TypeScript. In the end it's just JavaScript so you can write your app logic in whatever language you like, so long as you have JavaScript in the end. Using TypeScript certainly has benefits and it's easy to get started with, so if you're starting a new project you should definitely give TS a shot. Alternatively you can go for ES6 which I have also seen used in Angular (1.x) projects successfully.
Exactly what does Scala provide that makes finding type mismatches easier than in C++? Interfaces? Better generic support?
I would have totally started scripting in general much earlier if I could have realized there were ways it could have got me laid... damn.
I think the performance gains of using Typescript have been over-egged. There's still a lot of things the browser can't do unless it knows certain features will never be available, and the DOM is still a tremendous bottleneck. Garbage collection remains and we know that's a difficult problem to solve efficiently, even in 2015. Pure JS will never be terribly quick; we have to settle for 'good enough'.
It sounds like the issue is more that you don't know what to do rather than how to do it, so here are some super awesome things you can look into with Node. * Cross Platform Desktop Apps : [Electron](http://electron.atom.io/) * Robots: [Johnny-Five](http://johnny-five.io/) * Games: [Unity](https://unity3d.com/) * Containerizing Deployment Tools: [nScale](http://nscale.nearform.com/) * Microservices: [Sceneca](http://senecajs.org) Your best bet is to look at projects for inspiration on what to do next. Javascript runs in a lot of cool places theses days and as the projects above show, there are some interesting tools being built purely in JS. The list above is just some of the cool stuff being built in JS, each being a potential area that you could look into. The important point is to do something interesting, there is no great feeling though than being able to use JS for your site, build tools, deployments, and even the little light box on your desk.... it's something quite special! Have fun! It's a great time to know JS.
Haha it was a painfully slow process but so worth it :P
I'm not aware of any performance claims about TypeScript as it stands today.
Indeed, that is one of the ideas the OP himself mentions on the github page.
And don't forget the refactoring benefits of a statically typed language. Are you changing ID's from Numbers to a structure? Change the type annotation on the return type, and suddenly every place that uses it lights up with the error without you having to do a textual (and most likely incomplete) find-and-replace. I'm NEVER going back to Vanilla JS after using Typescript.
Since the "3D city" project has been posted here before. I thought you might like to see my project, on which it is based, which has more of an old-school feel. I'm aware there are some rough edges around the UI, but any feedback is welcome. Currently having to host on GitHub rather than my own domain: I can't even afford food at the moment (no joke), so webhosting costs are way way down the priority list, leaving my domain unavailable. So, whilst I hate to beg, desperation requires it. If it brings you any entertainment, please consider helping a struggling programmer out and fill my seriously empty stomach: there's a donation link at the bottom of the screen. In any case, happy retro-city simming!
Both games this was inspired by are hard and repetitive. 
Further, I should add that it was ported by hand, rather than use Emscripten. Whilst it's a great tool, and heralds an exciting future for the web, when building this I ultimately wanted to learn something more than how to invoke a new tool.
If you need all that, it's not a "quick start". If you need all that, I question your abilities.
On the surface it seems quite similar, but the once you start drilling into pure functional programming, there are certain type system features that make a big difference. Some of the major things off the top of my head. - Algebraic data types allow you to encode your data in a way that the compiler can enforce you've handled every case. - As one example, this gives you Option and Either/Error types, letting the compiler enforce you've handled success and failure conditions instead of forgetting one. - This lets you write every function as a total function. If you build an entire application out of total functions, then you're entire application will be total. ("Total" refers to the fact that you handle every possible input with a valid output). - The end result is that, done properly, your program is statically guaranteed to have no unhandled edge cases. No digging through stack traces to figure out why your program crashed or threw an exception. My philosophy is that absolutely anything that could cause your application to crash at runtime is a type error. You can still screw up your business logic, but only a subset of such mistakes will make it past the type checker. (* Reality is always more complex, and (in Scala at least) 100% totality checking is a fantasy. But you can get surprisingly close, and it's generally quite easy to write very solid code on the first pass.) - Higher kinded types make monads much simpler, allowing you to maintain functional purity while still having side effects. This helps reduce complexity and cognitive load in complex codebases. - Monads also make it easy to hide all the messy details about your Option and Either types instead of having to unwrap and perform explicit error checking after each call. - Monads also make it easy to handle highly concurrent / asynchronous / network code in a deterministic way without writing lots of plumbing. - Type inference mean that you can skip complex type signatures and boilerplate. Just write your code and let the compiler figure it out for you. Keep in mind most of this is entirely possible in C++/Java/etc - but generally harder to do right.
requestAnimationFrame in javascript goes for maximum posibble framerate capped at v-sync. In your case it's 144. Multiplying *velocity* by *delta* could fix that though.
1. use .getComputedStyle to get background color 2. Use RGB or HEX inverting algo to invert color. 3. Apply inline-style background-color to element(Yes, inline-style. Those are okay if they generated on-fly)
Cheers you amazing human being.. I'll give it a try ;)
Doesn't have to be novel! Look at any tech product - Linux, Facebook, Gmail, etc - almost all started as basically clones of stuff that was already out there, maybe with a few minor differences. You can make an open source clone of some proprietary software, or a web-based clone of some desktop software, or a clone of some Angular software redone in React, or whatever.
For some reason, I think this is cool. 
Google already provides you with an API and a library which is fairly easy to use. I'm afraid you have to rewrite it. I just looked at one of my scripts that does exactly what you want, but is for v2. It's broken too (Using gdata.youtube.com only returns support stuff no matter what parameters I try) - https://developers.google.com/youtube/v3/ - https://developers.google.com/api-client-library/javascript/samples/samples - https://developers.google.com/youtube/v3/docs/playlistItems/list
Really impressive. Makes me wonder why I haven't done anything this big. Would you mind explaining how you do it? I mean, more specifically, how do you start with a project that it's so huge and how do you determine the game rules? 
Which comment(s) in particular? As far as I can tell, I was the only one who mentioned that there can be minor performance improvements if types are used more consistently: http://www.reddit.com/r/javascript/comments/35etka/is_angular_20s_use_of_typescript_going_to_be_part/cr3unvm Some people mentioned that static typing is good for performance and it kinda is, but using TS doesn't make your JS statically typed.
If you open the debugger (F12 on Chrome/Firefox/IE), you'll see this error message: Uncaught TypeError: document.getElementbyId is not a function Indeed, there is a typo at line #13, `document.getElementbyId` should be written `document.getElementById` .
thanks =) it works now
What is neato?
Oh you... http://i.imgur.com/himZD0M.gif
Author here. A livestream of me building the module earlier today is available here - http://www.twitch.tv/yoshuawuyts/v/4888464 :D
Its a brand of cereal.
Use inline styles. There is absolutely no point in doing this in a roundabout way.
Now its all make sense.
Uh-oh! This screen is too small—I won't be able to fit in all the controls, buttons and gizmos! Sorry! Where is my mobile friendly version?
It sounds like you're making something similar to [aerotwist's FLIP animation method](https://aerotwist.com/blog/flip-your-animations/).
Well Google is working with Microsoft on Angular 2
Yup, angular 2 is tired now. I need a newer more alpha state framework!
Are you already familiar with ES6? If not there you go.
OP, YOU ROCK
Great stuff! Thanks!
YOU WONT DERAIL THIS CELEBRATION OF CORPORATE COEXISTANCE THIS TIME
... 4 hours of my life just disappeared reliving my past.
Anders Hejlsberg talked about it at Build, they even had 2 Google employees talk at Build.
The problem with Lua style coroutines is that you never know when a function you call is async, so you won't know when a function is suspended and when it runs to completion without being paused. And in a language like Javascript with shared mutable state, the difference can have a lot of impact. If I use your library, and call a method on it which is not async, I know that the state of the world is pretty much what it was before I called the method. If I upgraded your library and that function is now async, the world might have changed drastically when it has finished. But there's no way for me to know, because making your function async didn't require me to make any changes. But it can certainly introduce timing bugs that are very hard to track down.
They did some collaboration on Typescript, not Angular, as far as I understand. But since Angular 2.0 is being built with a lot of Typescript, you could argue that the collaboration almost extends to Angular. Source: [Keynote from ng-conf 2015](https://youtu.be/QHulaj5ZxbI?t=17m56s)
How do you have that much free time?
Test string was by accident, removed now, perf is same. On older version of React 0.10 it's about ten times faster, maybe a React expert can help out. Angular 2 feel free to add. **Edit**: I couldn't find Angular 2 on CDNs yet which makes it harder to add to jsperf. :/ **Check out http://jsperf.com/mithril-react-ember-knockout-angular/9 which has a fixed React implementation. Thanks to the folks for the code fixes!**
hanuza, thank you!
How don't you? Kids? Crazy work schedule?
Yep, who knows how close the EOL for 2 is now, can't stay in the past. ^^^(/s)
He's not your friendo, palo
That's good question. I suppose I didn't even know those alternatives exist.
I side with the others. Is a personal decision. At work we won't migrate our current codebase to angular 2 any time soon. But we might start new projects with it. 
Sorry AutoCorrect on the phone
&gt; Hide all. Then IF Data A - CCD001 Data B - 51,65 or 92 Data C - Week, Fortnight or Month THEN Show section A. Wat.
It's not the typical use case, normally it's only around 2-3 hundred rows but there are some cases where it gets crazy. Server side paging is not possible because we use the data to build charts, filter, sort etc.. which is all handled on the UI. I actually mostly solved this problem by implementing a hacky block technique. Each time readystate fires read the response check if an open block is present, check if it's closed if it is parse it. The next response subtract the length or the previous parsed block(s) and do the same thing.
I don't want to stagnate as a developer and I love learning new things. So why not? I mean, doesn't it get tiring writing the same code, in the same style, day in and day out? I advance my skills constantly and learn new ways to do things all the time. Code I wrote 6 months ago is drastically different than code I write today. Keep hungry, my friend.
You've got quite the mess there. You've got a lot of redundant checks, so try to combine them. Here's one of many ways, though it could clearly use some improvement: if (DataA == 'CCD001') { if(DataB == 51 || DataB == 65 || DataB == 92) { if(DataC == 'Week' || DataC == 'Fortnight' || DataC == 'Month') { // Show section A } else { if(DataC == 'Quarter' || DataC == 'Half Year' || DataC == 'Year') { // Show section B } else { // There may be a problem.. } } } else { // Show section C } } else { if(DataA == 'CCD002') { // Show section D } else { // There may be a problem.. } } 
Thanks very much - I will give it a try. I tried to explain to the people at work it isn't just something you can whip up, it is like knowing a second language... "Google it" was the response.
Could also be this. :D http://ejohn.org/blog/javascript-micro-templating/ If you want small 10-ish line micro templater. It uses the same tags
Can anybody tell me what's in it for a company to spend time and resources creating a framework for developers to use?
It's actually built on GitHub's Atom Editor and works pretty well. I pretty much use it as a glorified text editor cause I still don't do any JS but I've heard people on podcasts talk about how nice it is. 
You are right. Will do!
This is cool as hell, thanks for sharing!
Could you pick a worse subject line for this link? By the way, I have an incredible tip for success! You'll never guess what we did to impress you! [Click here](http://gullible.fool.clicked.on.link.with.no.idea.what.it.was.about/)!
This is great work. I really enjoyed playing it. Thanks for sharing. Also, the detailed explanation of how you went on implementing it is invaluable. Please keep experimenting, IMHO you have a huge potential.
Good point, a bit more about prototypes, which is a very important feature of javascript matters. Good post, Bosola.
This is not Visual Studio. It's Visual Studio Code, which is only a fork from Atom. So lets not get too excited yet. 
Great article. I love sinon.js. It really makes it quite easy to reach 100% coverage with your tests, especially since stubbing makes it very easy to test failure scenarios, without having to set up some kind of state that will fail when run. Another tip: [sinon-as-promised](https://github.com/bendrucker/sinon-as-promised) makes it possible to stub functions that return a promise. For instance: sinon.stub($, 'get').rejects('Server unreachable!');
I would say do iOS development. Unlike JS, where you have to come up with architecture yourself, Cocoa forces you to use some of their patterns, and you can learn more about how UI code is structured. At least that worked pretty well for me.
It's not a fork, though?
it's a statement of one's age, hidden inside a compliment. 
It doesn't work on the server, does it ?
We've gone from just me to 10 developers and only had one leave cause he moved out of state and another when he got cancer.
Well here's why you don't need a framework ; or feel like you don't. In a high-turnover company, if you work on large-scale apps, it's just not feasible to work without a framework. The wasted time understanding the codebase for newcomers is just a waste of money. But that's just like... my opinion man.
How is this helpful? "How do I do x?" "Don't do x". iOS development isn't exactly an alternative option, it's structured very differently and there's pretty much only one way to do it. Plus, you know, it makes iOS apps rather than websites...
If you haven't posted this on Hacker News yet, you really should.
[Ractive](http://www.ractivejs.org/) could be a good choice.
[VueJS](http://vuejs.org/).
In your experience is performance really an issue? Since I expect to use promises mostly for network calls, is the overhead actually significant?
If you know how to use variables, control structures, and a small-but-useful portion of the prototypal methods (Array.sort, Array.filter, Array.foreach are my bread and butter), then you're ready to start exploring libraries. Most everything you could do with vanilla JS has already been done (and better than you'd think to do it) in jQuery or Underscore/Lodash. I'd just recommend that when you find a particularly powerful function -- look up how they implemented it. Figure out what they're doing; it'll teach you more than just blundering through trying to implement something similar.
that looks interesting. minified 54kb, plus I think I should start using templates too. 
An open source debuggex?
An ad without a brand wouldn't make much sense, would it ? :)
I will recommend [when](https://github.com/cujojs/when). Also I'd avoid jQuery deferreds as they don't follow the [Promises/A+](https://promisesaplus.com/) spec 
Why hiring someone that is not familiar with your tech stack?
Where's my Ember bro?
Thanks, I'll start playing around with prototypal methods now!
Make one yourself http://blog.mdnbar.com/binding-data-with-objectobserve
Just to sort of address your concern about using JS to manipulate the DOM: My job title is "JS Developer". I work on Node and Angular primarily, but I've used React, Ractive, and Knockout. If I had to do DOM manipulation with vanilla JS, I'd need the MDN open the entire time. I just don't know the function names. And I have no intentions of learning, because jQuery and Angular handle all of that shit for me. Hide an element? ng-hide="condition" or $('#element').hide() I _could_ do it with document.getElementById('element').style['display'] = 'none'; But that's uglier and more characters. I also had to google applying CSS with vanilla JS. So there's that.
This is cool, although I assume you change the URL to use as an undo/history? Might be worth it to come up with another strategy as it owns your browser history.
Great job man, love seeing close to native experiences using the web! 
If the promise library is spec compliant, the code is basically the same. Using bluebird on the server because it's way faster. 
You probably won't ever notice the difference, unless you run 1,000,000 Promises in jsperf, but it's worth mentioning since it's fun that some code we write is faster than the actual browser code :)
Bluebird is really well made and much faster than Q: https://github.com/petkaantonov/bluebird/tree/master/benchmark
&gt; Of course, it came from bad coding rather than the tech itself, you'll agree with me on that. Yes. Let's not be confused about that. And many people will use that anecdote as evidence. I find people who immediately say a framework is a requirement for everything they do are people who don't have a fundamental understanding of how to write programs. Or they're more concerned with slapping something together quickly rather than doing it correctly. Same-ol, same-ol designs and layouts. Or, as in your case, they're thrown into a pile of muck and don't want to have to deal with that again. In a lot of ways, muck is the norm in a software project but throwing a framework at it is like throwing programmers or money at a problem. The problem itself isn't going away and frameworks, if used indiscriminately, only put a band-aid on it. I'd go much deeper but, today, I'm starting into a new client's muck. He hired me to save his company site but, when I told him what needs to be done to bring it into 2015 from 1998 when it was last worked on, I was told not to deal with those things and just make it work. Fortunately, I have a contract spelling things out ... but I digress.
how does this compare to D3.js ? 
Hmm, Riot actually looks pretty cool and I quite like Ramda. Perhaps also [cycle.js](https://github.com/staltz/cycle) but it's quite a bit different from everything else. Will have to try them out.
It's 12kb gziped, that is not the same as minified. Also I Don't want MVC framework, I am rather looking for library or plugin. Thanks for you post anyway. 
Well, you already have to understand how a regex works to make sense of this. But I think it's cool to have a secondary way of looking at it... like a little sanity check that how you parsed it in your head mates up with how it's graphed. Neat stuff.
The actual library doesn't matter too much, but I'd recommend one that's A+ compliant. That way if you ever decide to use native promises it's an easy switch. jQuery's implementation is not so I'd recommend against it. RSVP is a good one that's used by Ember and is pretty bare bones. Bluebird is also a great one and provides a lot of extra functionality which can be useful. Either of those would be a solid choice. 
Still, only 18 Kb when not gzipped. Quite a bit less than most of the other suggestions, although it is of course a framework and not a lib. :)
RFC 5322 Email Regex: (?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@ (?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\]) (You'll have to paste this in to the page- the ()s in the URL seem to be confusing Reddit's markdown linking).
&gt; to bring it into 2015 from 1998 when it was last worked on Your pain, I can feel it
shame it's so difficult to remove
[Here's the chart](http://i.imgur.com/tAYziQh.png)
I had to look then to see if you were being sarcastic or not
If you're looking for microframeworks, check out http://microjs.com/ 
If you wish to learn more please visit http://blog.wolksoftware.com/introducing-inversifyjs
Clever solution, definitely does the job. Feels a bit hacky for my taste. Instead of copying the value in JS/SASS, aren't you now just copying the classname? Doesn't solve the problem of hard coding values. Refactoring or removing styles/elements will cause problems that are hard to debug. I'd probably just use something like this: https://github.com/vigetlabs/sass-json-vars Although it does seem to be ruby/rails only, I like the idea of having a separate JSON/JS file to hold the shared variables.
Does chrome still silently hide uncaught exceptions? That's not acceptable to me. Bluebird fixes that.
This looks an awful lot like http://regexper.com/, which I believe has been around longer (and is my goto tool for this kind of stuff). Is this just a fork of that code base?
Cheers! And thanks for putting this extension out there. It solves one of my major quibbles with Safari. 
&gt; It's not like its cheating is it? It's apples vs oranges though. Not pushing all changes to the real DOM is of course faster, but that doesn't tell you how fast you can update the DOM. And that's what this benchmark was supposed to measure.
jQuery's promise library is basically shit put there by the devil to confuse developers. It's not A+, it's A-hole. Edit: and now that it's been put in, it has to stay in to preserver backwards compatibility.
Who said I was learning to do the same thing over and over? It's called iteration. Improving my skills. Many things improve with iteration.
KNOCKOUT FOREVER
Your function is very complicated compared to what you say you want to do. What exactly are you trying to achieve? What is the variable count mean? 
I believe this is what you want - http://jsfiddle.net/0dyt4oja/.
Yeah it works well whenever you need two-way data binding like forms and stuff on a manageable scale. Otherwise you can end up with ridiculous view models that have way too much going on in them.
VueJS is awesome, its like Angular but for sane persons who need to get shit done.
Have you looked at Rivets.js? 
RiotJS looks great. Could've used it for a small project I just did where I used React. If I have time I'll try switching it out
Object.observe? Write a quick wrapper around that. Then you're off to the races. Everyone reaches out for libraries so quickly, you can write your own stuff. **Edit:** http://codepen.io/Garrett-/pen/qEwwqp
Unfortunately for now this approach is only viable if are fine with ignoring everyone not using Chrome: http://caniuse.com/#feat=object-observe 
https://github.com/petkaantonov/bluebird#error-handling
**Single Page Web Applications** by Michael Mikowski and Josh Powell only uses jQuery. I thought it was a very good book. They teach how to structure complex applications as well.
I would argue that there is no such thing as small enough applications for Knockout nowadays. No matter what you are developing with it, it will look like a mess compared to more robust solutions like Angular or React. If you need to stick to small amount of dependencies that bad it may be better just to write 2-way data binding yourself using something like Object.defineProperty() rather than relying on an outdated abstraction that nobody wants to learn anymore.
BLUEBIRD FTW!!! 
A SPA is an application that changes the content on the page without reloading the page. However it also allows users to access content within the application using url fragments. The benefit of this is that you can maintain continuous javascript state over what visually appears to be a variety of different pages. Typical frameworks are Angular and Backbone.
heres a quick demo https://jsfiddle.net/h4cyvfdv/ basically you handle the data yourself, and bind the click and event handlers yourself. imo jquery saves me some serious amts of keystrokes
Thanks for the explanation!
Could we at least make it perky? ( º)
OP is talking about a website looking app without page reloads but I think Pandora is a SPA and it's more like your calculator. A SPA is a front-end web application all on one page, be it a website architecture or a calculator or a game or a music player. OP is really only asking about a SPA website app though.
...but the homepage says it's lightweight! how could it be bloated?
There's a few polyfill options https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=object.observe+polyfill
&gt; Prototypes are like model homes, and classes are like blueprints. Great metaphor here.
Awesome, I was just thinking about how it would be cool to recreate the original SimCity in js last week. I'll be browsing through your project for sure!
Can you name a use case for these?
If we're looking for typos, here's another: &gt;JavaScript also a class keyword that provides syntactic sugar for writing constructor functions and prototypes in a declarative fashion. Should be JavaScript also *has* a class keyword...
Bluebird rethrows errors on the next tick by default if there is no error handler to catch it, Q has a .done() method that you can use to signal that you are done with this promise, so if an error still happens, you want that rethrown. What happens in the promises polyfill if there are no rejection handlers, but an error gets thrown?
From now on whenever someone asks me about objects, classes or whatever I'll give them this. Thanks!
Check out [Eloquent JavaScript](http://eloquentjavascript.net/). It's a really good introductory JS book.
The code is already being bundled, I actually want to combine classes. Weird and stupid, but that's what I need for this.
Seconded. The more I think about it the more I like it.
If there's a legitimate bug in the tutorials, you should report it! You won't be the only person bumping into the issue. I know a few of the Codecademy folks and they're really responsive. They care deeply about their product. So, I think they'd be grateful to receive the feedback. I haven't done their JS tuts, personally. But, I do think it's a great idea to learn from multiple sources. I also really like Eloquent Javascript, as ThinksInCode mentioned. In addition to that, I'm a fan of [You don't know JS](https://github.com/getify/You-Dont-Know-JS)
https://github.com/raganwald/raganwald.github.com/commit/14bba11f2547f636bdc5801b1728511fb9680129?short_path=df4097f#diff-df4097f57892e5e94d29568083063cc1
It's conceptually simpler and more natural while still being very powerful. It;s light and fits well with self assembly of workflow (grunt, webpack etc). Angular is more chunky and opinionated for big apps
With or without a framework the concept of a SPA is basically the same. The premise is the following two points without ever changing page state: * dynamically send and receive data, such as form data, at the user request. * dynamically add and remove structures of the page to suit the appropriately desired change of content by the user The problem with a SPA is that the more challenging aspects of client-side development become substantially more complex, particularly: SEO, accessibility, data state. Frameworks are really good at storing data relative to state, but tend to make the other two items far worse.
Thank you for the feedback! I'll be sure to check out that book and hopefully move past my confusion with codecademy. Good luck with your programming as well!
Thank you for the feedback! That entire series of apps is extremely convenient and will be very useful, thank you! 
Cool! It's always nice to see usage example for Kefir.js
Thank you for the feedback. I don't think it's a bug, with codecademy, I think I just have too little experience with programming and whatnot, so I'll check out you don't know ja as well as a bunch of other links that I've been sent. Thank you!
Oh! I kept reading and I found out what that was supposed to mean. Initially, I thought it meant tiny homes, like dollhouses. Now I see it's supposed to mean a real house which you'd use as a model to build your own.
No prob!
And now you understand that in a deep way, prototypes really aren’t about defining an object the way classes or concatenative inheritance are, they’re about defining *delegation*. So when someone asks, “can you do laundry,” you say “yes,” even though your particular apartment may not have its own machine.
I found it helpful as a supplement to my intro to programming class. I also replaced the near useless textbook with Eloquent JavaScript by Haverbeke (there is an annotated version available by Gordon Zhu). 
The best way to find out which one you should use is to try them yourself. (I would personally recommend WebStorm, but you might like Sublime better).
I'd personally recommend Webstorm as JavaScript IDE. Multi-platform support and integration with Bower, Grunt, Gulp, Node, debugging, &amp; application performance profiling. Both are great editors, but Webstorm is my preference. Both offer free trials so try them both as _cott0n suggests. 
use both. i use sublime for text editing, and webstorm for programming and debugging.
Yeah, I tried atom for awhile but gave up on it because everytime I added another community module something didn't quite work right.
It worked for me. I haven't written much code in a bunch of years, and decided I wanted to get some JavaScript chops together so I could make some small changes to a web app I use every day at work. After looking around a bit, I tried Codecademy, and - after a false start - got through the whole course. It took focused time to do it. There are some deep or odd concepts in there which took me a few cycles to figure out. But in the end, I learned it and can use JavaScript now.
Use what you need. I'd recommend starting with sublime, if you start finding features that you really need that's in Webstorm then switch to it. Find the best tool for where you are right now.
&gt; The Common Lisp Object System has generic functions, but not classes. CLOS does have classes. That's what `defclass` is for. CLOS is class based, it's just not *single dispatch*. I think dispatch is a really fundamental difference in some OOP languages. CLOS, Dylan, and Julia are pretty deeply different from JS, Java, and Smalltalk even though all six can be considered object oriented. I really like the rest of the distinctions you draw here, and I especially like that you do so in a neutral value-free way which is sadly rare when talking about JS.
To write a SPA without a framework, you'll need to write a framework.
I love WebStorm, wouldn't write Node.js without it. That being said, for JS in general Sublime has pretty good tools
It actually is now.
Is it really accurate to say that Javascript has classes? ES6 has classes, but [it doesn't look like they're ready for prime time yet.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Browser_compatibility) 
Thanks
Thank you. I suppose that I took a false start as well. I'm glad to hear that it worked for you! Hopefully I'll have similar results
Isn't that what React.js is good for? Writing SPA applications without needing a framework. Technicality I guess in that React.js is a library, not a framework. Coupled with Node.js using a isomorphic codebase, you have yourself a framework-less SPA.
oh but there is how are you not aware of its existence? https://github.com/voodootikigod/logo.js
I used webstorm for a couple years, but the memory leaks were massive (this was 4 years ago ish), so I converted to sublime 2 and never looked back. 
So, we can look at how things started out. **In the good ole days** There was a server, it responded on port 80, it sent a series of XML based tags that a browser would loosly interpret as links, bold, headers, title. That was it. **Then came "Dynamic" rendered content** E.g., the ASP, PHP, cgi-bin, JSP. These sent a series of XML based tags that a browser would less loosly interpret (comparatively to the previous version). They called it HTML, they could even change the HTML depending on various factors... **Then came JS/CSS** JS allowed you to modify the HTML within the browser, or "client side", in a model called the "Document", now known as Document Object Model. CSS brought styling which was great, it helped the model become a more elegant view! **Then came AJAX.. or Web2.0** This is actually just the rise of XMLHttpRequest object. It was introduced into the Javascript and browser context and suddenly the browser could make a lot of decisions as to what resources to go get, and it could build the entire XML based set of views on its own depending on the data. **Then came SOAP, .... Then came REST/JSON!** REST is just a convention we use to send javascript objects represented as strings (JSON) over the network when its requested from something like a web browser (e.g., XMLHTTPRequest mentioned earlier). This wasn't particularly eventful, but it led to THIS: **API ALL THE THINGS** Literally, they came dumping out left and right from everywhere. It became really easy to produce and consume data from anywhere. So now we have tons of non-HTML data flying around being dynamically turned into to HTML inside of the JavaScript and into the DOM! **STOP USING JQUERY** The entire web dev community begins getting flooded with people who sort-of-know-programming-but-not-really. They're useful, but dangerous. Most attach listeners to all the events, multiple times, and don't know how to structure programs very well. This had a back lash from people who knew how to program, business owners and even the people doing it, which led to THIS: **START USING FRAMEWORKS** Java popularized the idea of frameworks, frameworks have been largely dismissed by even the creator of java and Spring (a java framework thats really popular) because it forces conventions and largely dictates how to program. This has some pretty horrid side effects if you run into a problem your framework can't really "naturally" handle. Most frameworks become popular because of three reasons: 1. Newcomers to programming AND front-end find it easier to use a declarative syntax. 2. Newcomers to front-end BUT NOT programming, ESPECIALLY JAVA PROGRAMMERS, are usually business students who took up programming in the 90's and feel comfortable with the mistakes we all collectively made back then. 3. Companies widely realize if they can lock you into a framework, and you learn only that, they can dictate A LOT about what happens on the web. And patent it (yes, Facebook has a patent on react). Largely, frameworks are useless. Just use the DOM and vanilla JS, you'd be blown away how much easier, faster, and elegant it is (once you learn a few ins-and-outs). 
I've always liked SPAs for "closed" applications; internal apps like time tracking or public things like gmail which are not crawled. However, given the rise in popular SPA frameworks of late I think the SEO-niss is getting better (more so with crawlers being able to parse javascript, but also with frameworks being able to expose things in a crawler-friendly way when needed).
can i please ask what kind of memory leaks? Isn't every editor the same? sorry, noob question here.
You can may be use the REST api, which works using the clientid and private key, which you create in the google developer console
This is amazing, I've been having trouble understanding classes in Java, and this is a huge help. Thanks!
Prediction: The highest rated comment here will be a joke about "yet another framework".
Better than code school for beginners in my opinion.
Also, var launch = function launch() { ... } Will compile.
Same here. I use PhpStorm though but almost the identical programs. If I need to do serious programming, I open PhpStorm. If I just need to fix a small bug, format som JSON or convert newlines to commas for SQL calls, I open Sublime. Sublime is the toolbox, PhpStorm the garage. Both have their uses and I love both. Also: if you run multiple monitors, get PhpStorm (or WebStorm). You can then move some parts of the editor to other screens. This means that you can easily run code in split screen, while still having a file tree, version control, terminal, TODOs etc. open and visible.
I'm sure there's so much to WS that I don't even know about.
Also the variable + anonymous function is far from useless. var foo; ( foo = function(){ console.log( foo ) } )(); foo(); ( function bar(){ console.log( bar ) } )(); bar(); //bar is not defined
This is actually quite cool. Would make for much more interesting default profile pictures than the usual outline of a head and torso, since you could still recognize people from their unique picture.
I use it a lot and still feel the same way. Imagine a multiple monitor setup where all this is visible at the same time: - 2 Editor tabs split vertically - File tree - Git changes - Terminal - Test runner - Debugger - [Visual representation of database](https://confluence.jetbrains.com/download/attachments/54339253/uml.png?version=1&amp;modificationDate=1406718641000) - TODOs - Integrated Gulp runner All well integrated with each other in PhpStorm with similar look and feel, along with the best prediction system and refactoring tools I have seen for JS/PHP. I enjoy Sublime, Atom etc. as much as the next guy but honestly, comparing them to PhpStorm is a joke unless you only do basic stuff.
Wish I read this before my interview this morning.
How's it different from SVG Morpheus? http://alexk111.github.io/SVG-Morpheus/
I don't get the metaphor about the model home... blueprints I do..... 
How about d3.js? I heard it's really cool
Depends on your needs / your toolbox. I largely prefer using the terminal for file management, git operations, test running and debugging, and IntelliJ / PhpStorm / Webstorm's terminal just doesn't compare to iTerm imho.
Just pick one and start coding. How can you compare one with another if you don’t try them out by yourself?
I used Webstorm for a while (node.js/angular) and this is a really good IDE. However, this is a heavy gun and after 3 years I realized that I used almost nothing from the "IDE Features". In big projects, Webstorm can be painfully slow (I have SSD, 16go RAM, i7, Win8) and degrade your overall experience. As long as you add files and code, code completion is more and more useless in JS. All my build process relies on non-IDE-specific tools such as gulp or npm so I dont use the integrated ones. I switched to sublime 6 months ago and I think I'll never go back. Everything is more smooth: configuration is just changing some vars in a JSON file, it consumes about 100~200mo per instance, and plugins are not "poorly implemented packages" (and I would say that webstorm also relies on packages). The only thing missing is the integrated terminal. 
&gt; Webstorm can be painfully slow (I have SSD, 16go RAM, i7, Win8) Same pc configuration here. Webstorm takes a whole lotta time to get up and go, while Sublime is instantaneous. Even when it crashes, when you relaunch it, it loads immediately. It's pretty neat.
The options are pretty overwhelming, but I believe you can narrow your serious options down to the 4 big ones: Angular, Ember, React, and Backbone. There are lots of little indie frameworks but I wouldn't put money on any of them surviving for long. Your choice then depends what you're looking for. If you're after something you can put on your resume to get you a job, then angular is probably the only choice (unfortunately). It's about 10-100X more popular than the other options. Coming second is Backbone, which was very popular in the past, but I think Angular has taken over as the industry buzzword so it's definitely the best choice here. Another differentiating factor is their 'size'. Angular and React are what we'd call monolithic frameworks. They are full application frameworks that deal with routing, data binding, storing and modelling data, AJAX requests, making view components, and even have their own ecosystem and command line tools (for Ember anyway). In contrast, React is just a view layer, and Backbone is just a model layer. This is good if you like npm's modularity - you can mix and match AJAX libraries, routers, models, event systems etc. with these because that isn't within their scope (npm is the node package manager which contains lots of modules for client side JavaScript that you can use with Browserify or Webpack). I personally much prefer this approach because you can build the best stack for any given task, but if you're a Rails person, you're probably used to being forced to do things the Rails way, and in that case I'd go with Angular or Ember. If your choice comes down to Angular or Ember, I'd choose Ember for hobby projects and the like because I believe it's far better designed, but Angular if you're just doing it for your resume. I think of Angular as a bit like the PHP of the framework world. It's popular because it's popular, but most of what it does is hacky and slow. But like PHP you can make a lot of money out of it. My favourite framework is React+Flux (Flux being the model/event layer) but I'll let you decide for yourself.
thanks. This was intended to be quite easy and straightforward. Hoisting will be explained a bit later, and with great extent :)
Neither did it have a standard way to swap an object's "prototype" until very recently, and assuming you're talking about `Object.assign` as far as I know the cloned object doesn't inherit the clonee's "prototype", which is what one would want in e.g. Self.
http://webix.com/ looks really nice as far as widgets go codemirror is a must 
I'm on Linux so the terminal in PhpStorm is just a wrapper on the real terminal. So it doesn't really make a difference for me. I also run most of the git operations, tests etc. in terminals anyway but mostly because I want the entire dev environment to be cross-platform and easy to use for other people. Or if I some day want to switch IDE again myself. It's nice to be agnostic about that part I think.
&gt; I assume he's referring to `Object.create`, which was introduced in ES5. They specifically mentioned a way to *clone* objects, which absolutely isn't what `Object.create` does. &gt; Ironically, the polyfill for `Object.create` relies on the new keyword. I fail to see what's ironic about it, `Object.create` creates an object with the provided prototype. `new` does essentially the same (but the prototype is provided by the constructor, and it calls the constructor afterwards). Aside from properties definitions, `new` and `Object.create` are interchangeable as primitive operations, you can trivially define one in terms of the other.
I guess it perhaps depends on how much and which kind of programming you do? I rarely close my IDE at all so I only have to actually wait for PhpStorm to start like once or twice a month maybe. But I also do quite a bit of programming every day and use workspaces on Linux so it doesn't get in the way when doing other stuff.
I don't have control of adding any code to the webpage so if any of these scenarios require that then I'm SOL. Right now I have a webpage that is display certain information inside a div and I want to make a simple solution for the end user to just print that information inside of that webpage. Will this be possible without accessing live code.
Yet the stuff in the fridge is still yours. Usually.
Wow, devdocs.io is absolutely brilliant. Thanks a lot for this!
&gt; You're confusing cloning and copying. No. &gt; In a prototype-based language, the act of cloning is merely setting the prototype on a new object. That is not the way it's used in Self. At all. You seem to be using IO's terminology instead, which would be inspired from javascript's. &gt; In such, the new object can look to the old object for defaults. If the old object changes, so too may the new object. That's inheritance. &gt; This concept has been bastardized a lot, thanks to Java. The Self handbooks defines cloning as a shallow copy: &gt; *Cloning* is the primitive operation returning an exact shallow copy (a clone) of an object, i.e. a new object containing exactly the same slots and code as the original object. the difference it makes is that cloning is the primitive operation while copying is the overloadable one which acts as a constructor. Self also makes no relation between the prototype and the new object after the copy, what javascript calls a prototype, Self calls a trait or a mixin (depending whether it has parents itself).
Well as to the first part, a memory leak is just that the application keeps on accumulating memory usage for no reason even if you just leave it open without using it. Every editor is definitely not the same. Sublime is far more lightweight than most IDEs. IDEs evolve over time and get better or worse and then maybe better again. 
Well, I close my IDE when I shutdown my computer. But while programming you might want to open several projects and Sublime Text does it way faster than JetBrains IDE. I used to use WebStorm and PHPStorm when programming and I think they're great, they have a lot of really neat features. As you said, once your project is open you're good to go. But concerning javascript (since I mainly code in javascript), Sublime Text is the way to go in my opinion.
I honestly don't know what you're talking about. I assume you simply have not actually worked in Self before. &gt; That's inheritance. Sure. I never said it wasn't. But you must keep in mind that there are different forms of inheritance, such as prototypal inheritance (delegation - JavaScript, etc.) and concatenative (Java) inheritance.
OMGYAF! Let's predictions occurs!
I am not invested in either framework but there are some very clear differences that would explain why they didn't just "use React." - size/complexity: React is a monolith that can't be digested by just skimming a couple small files - API surface area: less room for major semver bumps - modularity: React devs seem to fear dependencies - versioning: React encourages the use of peerDependencies which is truly going to be a nightmare in 2 years with hundreds of UI modules across different conflicting React versions - no singletons: React can only be required once, otherwise bats will fly out of your computer. This is compounded by the versioning issue. - style: React uses and encourages a different programming paradigm
I used this one in the past: https://github.com/mahonnaise/jquery.easyPrint.js Looks pretty simple apart from the obsolete Opera hack.
Wow... That example is truly amazing..! Thanks!
The documentation is different from how the language actually works. It is worded that way to make it easier to understand. Edit: Kind of similar to how a lot of documentation on JavaScript talks about 'classes' in JavaScript even though pre-ES6 JS has no such concept.
[Mithril](http://mithril.js.org/) is also an interesting framework, I would suggest to check it out! :D
This was the exact sense I was thinking of.
One man's pain is another's "hit me harder, that tickles!" Who can say?
I'm about 86% through the course, honestly it's the best resource for me. I prefer to learn by doing and I couldn't ask for a better way to learn. To answer your question, I suppose it depends on you, whether you prefer something like code academy or a book or a class room environment. In my experience, it's the best. 
Why would you choose to work in that role if you didn't enjoy it?
Depends on how well you know the language and how many frameworks you think you need to use. Its really easy to make a huge mess with Javascript and everyone's mother has a framework.
Yes.
How does it compare to [Cycle.js](https://github.com/staltz/cycle)?
What if I simply wanted to build a backend for data storage and retrieval? &lt;- isn't that builtin to meteor? also, why would having meteor affect your framework choice? 
The Google bot executes JavaScript, so the challenge at this point is more a matter of code design. Are controls and actions available to the extent where they can be accessed and engaged by the bot? If the bot does engage a control is the information that comes back accessible to the bot in a way that makes sense? We might logically presume that if the interaction is correct and that if the bot can access various points of content then everything must be ok. This is more often than not extremely wrong and it takes a lot of extra work to verify. Even if the content is easy to access by a bot and always makes perfect sense the next question is if the content uniquely indexable apart from other content. In multi-page app you have unique addresses by which content can be uniquely associated. You don't have this in a single page app (client side routing doesn't count unless the routed address is universally available and always returns roughly the same content). This problem can be solved, but again, it is not easy or immediately clear. These are the same battles that have been fought for years with regard to screen readers, but at least there is an intelligent human behind a screen reader.
I don't see how JavaScript, in and of itself, would make a particular programming job more or less enjoyable. There are some languages that are really unpleasant to program in but JavaScript isn't one of them. It might be occasionally frustrating.
Just a minor point of clarity. HTML came before XML. In the good ole days HTML was whatever a browser was willing to accept without regard for any standards specification and most syntax violations. HTML was originally a minor tag based language formed from a minor sub-set of SGML. XML is also formed form SGML, but its standard required terseness and wellformedness and the standard came before browser adoption. Eventually when browser decided that they wanted to use faster parsers that required less maintenance, so everything became XML-ish with additional rules to allow HTML some syntax slack and provide backwards compatibility with old shit code. In really old browsers, before XML, it took roughtly as long to parse garbage code as it did clean code because everything was custom. Now clean code (closer to XML) parses substantially faster. It is even faster still the less embedded CSS, JavaScript, and CDATA sections are contained directly in the markup.
Get on the boat before it sails! Don't be the one that gets left behind!
I've tried React but it didn't make enough sense for me to just dive in and start using it. 
ya unfortunately I need to get it to work inline with vanilla javascript.. anyone out there please help!
Thanks! This book looks useful, I'll check it out. 
That one morphs, the OP's does not. slightly different.
Just sending and receiving JSON, and showing and hiding different views? That seems pretty straightforward, although my understanding is high-level and it *might* be tricky to actually implement...
Raganwald is simply on another level. The depth and clarity of his thinking on pretty much any topic just blows me away. 
This is a good starting point! Makes it clearer, thanks for the help.
How does this compare to FOAM?
I use Backbone.Marionette at work (also RequireJS, SASS, and grunt).
I grant you that there's another sane reason: if you can't avoid it without breaking the rule #1 of RFC1925.
Yeah... what people do is render their web app statically on the server and then make that accessible to crawlers, right? Something like https://github.com/prerender/prerender.
Not supported in the release to have null values in the array, someone has developed an extension that can ignore missing data. www.jsfiddle.net/leighking2/sLgefm04/6/
Maybe I didn't word my question correctly, sorry. On the jsfiddle, what if I don't have data for May, but I want the graph to continue through May.
I like it a lot. But I'm very lucky to work on a team with very talented engineers, who actually understand and like JS.
For me it's less about the code and more about awareness of the capabilities and limitations. Business folk and server-side devs alike don't always grasp the idea of *transit time*.
actually, considering that it is still 1.0+ quite a few. http://www.quora.com/Which-startups-use-Meteor-in-production
I realize that these are not your arguments, but I'll reply to them here anyway. * Size: React sure is big, but it's not anywhere near being bloated. It's a very focused framework. * The API surface area is very small, especially if you compare it with Angular et al. * Dependencies: It's not that dependencies are feared, it's that dependencies add to file size and the React team doesn't want to take in dependencies on libraries that isn't 100% needed. * Versioning: This is just the nature of frontend bundling. You wouldn't want to use two different components which requires two different versions of React and end up with two separate versions of React in your bundle. * Singletons: Not really sure what the issue is here. You wouldn't want to serve up two versions of React on the same page either way. * Style: I'm guessing it's the style of how you're creating components, on which I fully agree. The React.createClass way is a bit icky, and the ES6 class approach isn't that much better. But like I mentioned earlier, better ways are coming.
I think I'll use this, thanks!
I have features that just don't work on non-webkit browsers, it doesn't cause a crash but the website will crash, an equivalent of "He's Dead Jim".
A live demo would be very helpful.
Java is to JavaScript as car is to carpet
&lt;state-of-smart-assness&gt;Understanding is the key to hateless existence. This applies to all things.&lt;/state-of-smart-assness&gt;
Douglas Crockford's [Javascript: The Good Parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742) is pretty canonical in the world of Javascript. I bought it after completing the Codacademy JS course and have read it a few times since then.
Do you have any working examples of nested views? I'm playing around with an app but theres such a short blurb about nested views and neither the shopping or todo example uses them.
im not sure what this lib is... but this looks like backend code? if you are sending res.render ( json.stringify(obj) ) you will have to JSON_PARSE that object before u can use it second if its supposed to have methods you might have to send a real class instance, ie res.render('filename', new Person({model: results})) or you might on the front end have to do something like new myClass({model: JSON.parse(data) }) edit: did you check console.log(results) and see what data is returning? you can also check if it has functions attached on results.fn or results.prototype or whatever it is (i forget!)
A colleague of mine wanted to start a collection of browser-crashing codes... This reminds me of him.
Hmm I'd prefer to use ES6/7 to write Angular 2 applications, but it looks awesome none the less. However, I have serious doubts whether this will be better than Aurelia when they are both released.
Awesome use of the canvas, props to you!
Lololol
I think I see where youre confused. Theres a few parts to the puzzle that arent obvious. Javascript is not multithreaded. It can only do one thing at a time, and it does things in order. There are APIs, like the DOM, or setTimeOut. Javascript calls one of these functions, then goes on to the next thing without waiting (this is the non-blocking part). Those APIs can call other multithreadded things and do whatever. But then, they complete. How can the initial caller from within javascript be alerted to this? By passing a callback in. That callback gets called once the API is done. Then theres the que and the stack. Sec I just remembered an awesome video that 'splains it better than me, watch the whole thing : https://www.youtube.com/watch?v=8aGhZQkoFbQ
[**@floydophone**](https://twitter.com/floydophone/) &gt; [2015-03-18 00:03 UTC](https://twitter.com/floydophone/status/577983679495995393) &gt; @mattdesl @dan_abramov @substack @_ericelliott please please someone release these as separate modules! ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
drag n drop is a pita, there was a nice dnd library released on here last week or so if you can find it it might help a lot overall its pretty easy -- you just get the x,y from the mouse event and check it vs the solution, if it matches accept the move and draw the puzzle piece in another place jstween is decent for animations and animate.css is pretty nice also.. if it needs to poll the server interactively you can use websockets and its not that hard, 20 lines of code on the javascript frontend side -- the simplest templating solution (for example) is totally easy, not sure how its done in django but in php its like this template.html ... html here ... &lt;script&gt; var board = &lt;?php echo json_encode(boards[$level]); ?&gt; var playername = &lt;?php echo json_encode($playername); ?&gt; ...etc... &lt;/script&gt; of course its not the most fantastic but just as a brief example of how you can mix backend and frontend... the other options would be like ajax and websockets... personally i prefer websockets
Awesome! Glad to hear it's not too bad. So adjusting the size of a puzzle piece depending on the number of categories (the more categories, the smaller the pieces), can be done using jstween? Thanks so much for the tips and specific libraries! 
That's fantastic. Now go back to IE8 fixes, developer.
i guess it depends what your puzzles are made of, html or svg or what. but jstween is for animation, so if its just html you can change it with jquery or css probably.
It's disappointing that the proper tail calls feature is merely "under consideration."
Ha - thanks - perfect!
It is more important what the project is than what the language is. If it is a useful, worthwhile, enjoyable product than any reasonable programming language is great. If it is a boring or otherwise uninteresting project then even the world's greatest programming language cannot make it fun.
What is Polymer, and what's wrong with it?
It has to do with what jQuery did in the javascript space to enable people to use javascript easily and normalizing functionality between browsers. The javascript lib/framework eco system has sinced exploded but jQuery is still very common.
Angular's source is pretty well documented.
There are a lot of browser specific quirks and bugs that jQuery handles for you under the hood. This is a great resources to check them out - https://docs.google.com/document/d/1LPaPA30bLUB_publLIMF0RlhdnPx_ePXm7oW02iiT6o/edit#
Can you explain why? Noob here. Why is it expected to develop for something that old?
I doubt shadow DOM is already here.. Even if supported I'm not sure I would use it but here is a better approach, but is pretty controversial. I know people that still write a component in HTML+CSS+JS, yes 3 files per component. This is separation of technologies and not separation of concerns... Sorry, but take a look at this component [here](https://github.com/hackhat/fluxmax-smart-css/blob/prod/src/ui/Task.js). Before arguing about CSS in JS please take a look at [this](https://speakerdeck.com/vjeux/react-css-in-js) and [this](https://github.com/hackhat/smart-css). Some benefits of my approach: - Check shadow dom support: http://caniuse.com/#feat=shadowdom - With my approach you can write encapsulated components; CSS performance is very good, but if you really insist on an external CSS file you can make a grunt/gulp task to get the CSS from smart-css, it's already prepared for this; - With smart-css you also have CSS namespaces; - Templates have logic (as long as people say best practices are to not keep logic in views this is impossible in real world projects). But logic needs to be debugged and debugging in a template is pretty awful. With a react.js component you are debugging a javascript file... as simple as that, no string templates... You don't need to learn anything new and you can write pure js. If you are interested in high quality web apps take a look at [react.js](https://facebook.github.io/react/) and [smart-css](https://github.com/hackhat/smart-css).
Not sure what I should think about that... lol
It's easy to start using (especially a few years ago, now there are more alternatives), but hard to stop. Unless you are super careful (note: nobody is super-careful) it gets commingled into your JS like a candle melting into a carpet. 
Almost certainly some debug code the Imgur devs forgot to take out. You can safely ignore it.
There are a lot of useful things being added in ES6. I would highly recommend learning them. I've only used ES6 features on the server side. For client side, I've dabbled with babel.io for a side project. If I started a new project today, I would use ES6 using babel.
It's lightweight and solves some cross-browser issues, especially regarding event attachment and handing. Also, it allows easy DOM manipulation on collections of elements so there's a lot less *for* loops. For example, here is attaching an event to a element collection in vanilla JavaScript: var buttons = document.getElementsByTagName('button'), ii, len; len = buttons.length; for (ii = 0; ii &lt; len; ii = ii + 1) { buttons[ii].addEventListener('click', buttonClick, false); } And with jQuery: $('button').on('click', buttonClick); If you wanted this to work in IE8, it'd be a lot more code without jQuery, but that is less of a concern today.
&gt; It is a pain or enjoyable to work as a Javascript Engineer? Not sure what a "Javascript Engineer" is, but as an engineer who currently codes primarily in Javascript (and a strict superset, Typescript), I'd say it's both painful and enjoyable. It's painful because it's not really a great language. It's not *terrible*, but if it was possible to use *any* language on the client, Javascript would have died a long time ago. It's enjoyable because it's fun trying to make the best of what you've got. I happen to like dynamic languages, and Javascript is at least fairly small, but it's not a beautiful language. For instance, Lua is *very* similar (primary data structure are hashes/dictionaries, prototype-based inheritance, etc.) but it's superior in almost every way: smaller, faster, proper lexical scoping, proper tail calls, multiple assignment, multiple returns, coroutines, metaprogramming, so on and so forth. 
Either debug code as internet_jones suggest, or an [XSS vulnerability](https://en.wikipedia.org/wiki/Cross-site_scripting) that a commenter is exploiting. Care to link to the imgur post with the popups?
It's pretty large relatively. For that instance, you can just write a DOM iteration helper, and save the 32 or so KB you probably won't need. And event delegation can be done as a small helper as well. elEach(document.querySelectorAll('button'), function(btn, i) { btn.addEventListener... });
Money. Let's say you're running a store online and you have a large user base still on IE8, let's say 10%. The logic is that if you support IE8 you will increases revenue by 10%. The reality ins't that clean, but that's the premise. On the flip side, if supporting IE8 costs more than the 10% additional revenue then it isn't worth it.
I use classes, default function parameters, spread, for-of, template strings, const/let, fat arrows, promise, symbol, computed properties, modules, and some of the new Array/Math methods/functions. I don't write much JS, but all of that stuff is pretty straightforward. What's not straightforward is destructuring in the parameters position with default values. That crap is a complete fucking nightmare. It's the dumbest shit I've ever seen. They totally fucked that up. SO ANGRY! WRARR! Named arguments with default values really don't need to be complicated. That stuff is super easy (and declarative!) in other languages.
That sounds cool. We actually use babelify because we already browserify our code, switching to another tool would be a whole thing. But yeah babel definitely could be faster.
This was yesterday, it was somewhere in r/gaming but there is no way I could find it now. Everywhere I looked on google I saw the xss vulnerability which is what made me nervous. It happened on a handful of different links, its happened once today so far but I've been on reddit for a few hours now and haven't seen it once. 
Fun fact: You can get candle wax out of the carpet by ironing the carpet with a paper towel between the iron. Heats the wax, and gets absorbed into the paper towel. Saw that tip randomly as a kid and never forgot it. 
you could build your house by first forging your own hammer, then cutting your own wood. or you could buy them, stop wasting time, and just get to work. i could re-implement an ajax function, or just use one that is completely tested, has more options than i will ever need, and just works. same with all the other built in functions and methods.
if login page has an element (&lt;div id="login"&gt;&lt;/div&gt;), then in login.js will use this id. when turned to admin page, the script will warn for not find the "login" element's id.because multiple entry points will output one file finally.right?
It's probably already cached in your browser if you use a common CDN version. If you bundle it in your build process, that's an issue though. 
ok,I think multiple entry points is the right answer.
Don't fix it. Kill it.
Once I got past all the "like.."'s in the video, that was an amazing video every JS beginner should see. Cleared all my questions!
Thank you! More research to do. 
Can confirm. Source: girlfriend spilled hair waxing shit on my carpet. Also take a razor blade to trim the top excess that doesn't get picked up. Light trim, atomic thickness.
The first answer here looks like it'd be helpful: http://stackoverflow.com/questions/15097315/change-onclick-attribute-with-javascript it's suggesting you do this: document.getElementById("clicker").onclick = function() {Submit();}
"Web Components is a standard that is getting really popular these days". Is it? It seems like nobody cares except Google. I've seen hardly any adoption. Polymer, Ember, React, etc. all have components that rely on their own implementation to work. This would appear to me like a spec failure, since you can't share these components.
As someone who's been working at this for 15+ years, it doesn't hurt. [CodeWars](http://www.codewars.com) is fun, too. Some of the advanced katas can prove extremely tricky. Seeing how other folks solved the same issue can be incredibly insightful. 
I've been coding JS for years and only used jQuery for one demo project that never made prod. I've used Yui, Dojo, Ext, React, and others, but I've never really had the need to use jQuery. Those other libraries already have jQuery like tools built-in, except for React, where you don't need any Dom manipulation or event handling tools, since it abstracts that stuff away.
&gt; If you want to study code why the hell would your first thought be to look to frameworks? I tend to agree, well written frameworks are usually doing all kinds of silly shit to squeeze out performance or deal with browser quirks. Not at all the place for someone new to javascript to be looking for pointers.
You need to not remove the parentheses with `Submit`. You want to assign the function `Submit` to the action, not evaluate it during the assignment. document.getElementById("clicker").onclick = Submit; Edit: If you followed nemmonszz example and wrap `Submit()` in an anonymous function, that would work as well.
Normalizing cross browser differences is a HUGE part of what makes jQuery worth it. Anytime I'm working on a project that's purely webkit I rarely ever consider jQuery, but the moment IE7, Opera, or anything else has a chance of seeing this, it's back to the dollar sign for a safety net.
It depends highly on the company, your co-workers, and the libraries and tools you use, just like every software job. Shitty co-workers with legacy software stacks, few tests, and no automation is painful. Good co-workers with modern libraries, well tested code, and plentiful automation is quite nice. Supporting old browsers can be a pita no matter what your environment looks like.
I guess: Edge may be nice, but there's still a lot of legacy IE browsers around. At 'ork, we're still stuck with IE9, for example. It will be years before we're at Edge.
I get the size difference, but if I really have to use in hybrid app, which of these library to go for? By Hybrid app I mean, entire files are available offline, best performance will be the key, as well as smoother performance.
That's the sane reason. In practice nobody in your user base uses it except the clients boss. This was not specced, everybody signed off on IE9, but the week before deadline it turns out the guy uses IE8 so please be as kind to rework the whole damn thing to work on IE8 too you got 3 days thanks.
if anyone has the video to the talk that would be awesome!
Or you could just admit to yourself that you don't know, and avoid posting tautologies. JQuery allowed for more idiomatic programming without a framework. You got cross platform compatibility alongside best practices and well tested operations, for a start. Javascript is a horrid little language and any toolset to make it less painful was accepted. Until JQuery really started addressing developers concerns, it was just 1 choice among many (Prototype, Moo, etc). So there's nothing about the nonsense you posted. It's just voodoo to you.
Or you could get over yourself
lol
Why so mad?
Why are tail calls bad? I would have naively thought the opposite: less allocation/clean up of stackframes and/or unrolling to loops should be a performance benefit. Or is it that the extra analysis and jitc time outweighs that in most cases?
Because it is required by numerous other libraries that we use, and because we have been using it in our codebase for a long time, and because it is a well used library that suits our coding and development library rules, and because we have a lot of code that already uses it, and the size of the library isn't that big compared to a lot of the other parts of our app including other libraries.
I use it for two reasons really. Firstly, because I'm lazy. $(''). is shorter than getElementByID. Secondly because I picked up the habit of using it. And changing habits takes effort... see point 1.
Us poor bastards who contract for government don't get that choice. :(
As others said, jquery was made at a time where it was needed. Differences between browsers were huge, and dom apis very poor. Jquery, along with prototype and mootools, brought in a unified way to query the dom, to bind events and to manage ajax requests which were on the rise. Adding to it a nice way to develop your own plugins, and everything was there to make it a big success. After that, Jquery stayed extremely active, and evolved to take advantage of every new api, focus on performance improvement, while staying consistent and easy to understand and use, and that drove its adoption for years. Nowadays, browserland is changing (damn fast) as javascript took a big boost, CSS3 brought some goodness, vendors started to unify and standardize their practices, and front end frameworks are popping every week. Jquery may be less relevant, 'cause you can easily compose your own 'framework' from smaller parts you'll get e.g. on npm and use some polyfills for new apis you want to use with backward compatibility. But I think it still has its use cases. People are familiar with it, it has been battle-tested and optimized for years, you can find good support, it still greatly does its job at bringing compatible code for browsers you want to support. And a lot of code has already been written with it, that needs to be maintained. So, javascript and Jquery history lead us to this situation: - Jquery solves problems a front-end developer faces daily - It has been the best way to solve them for years, and is now ubiquitous. - There is a lot of talent available. - There is a lot of legacy code written with it to maintain. - It's battle-tested, well supported. - Its API stay consistent while performances are improved. - It's easy to find resources about it. - It has tons of plugins, anybody can write her own. - It's so well known that even non-tech people have heard of it. Those conditions make Jquery still extremely desirable in an enterprise point of view.
Oh god, my sides. Thank you for that, good sir.
In response to your mention of Typescript I'd suggest taking a look at a [Angular 2.0](https://github.com/angular/angular/tree/master/modules/angular2) or [WebRx](https://github.com/WebRxJS/WebRx). Both frameworks are written in Typescript (I'm the author of the latter).
Really cool thing. Sadly it doesn't show me any stats after set-up. Not sure if I can do anything to debug what's going on. Running in Win 8.1.
No different really to how boost was/is an automatic part of C++ dev's toolkit. It solved problems so well that you never would want to think about the boilerplate required if you didn't. I write JS everyday, and jQuery makes it nicer because I don't think about boilerplate as much. Anything that makes something you do every day nicer is a good thing.
&gt; Provided Microsoft doesn't screw it up Edge should work fine. My son is in the entertainment business. When he started his first company, he called me fretting over other people telling him he's trying too hard and the presentations he's making are "good enough". I told him, "You're not in the 'good enough' business." Edge will "work fine" for consumers in the same way IE works fine for them because developers bash their heads against the walls trying to get IE to perform correctly and no other reason. From the many things I've seen on caniuse about Edge listed as "under consideration", I can see that part won't change.
I'll forgive you but try and understand what you're reading next time. Don't be like most redditors are.
The difference in what?
&gt; i could re-implement an ajax function, or just use one that is completely tested Of course, ajax has been working properly in all browsers, and is a W3C standard, for years so you can forgo jQuery for that ... and many other things we don't need jQuery for anymore.
introduction to deprecated feature? https://developer.mozilla.org/en-US/docs/Web/API/Navigator/battery 
Well yeah, jQuery meant to support old browsers but now front-end developers use it everywhere, I remember I saw someone ask for review on his website, he have 7 lines of javascript and he used jQuery...
It's may be true for when you are developing for IE7 or IE8 but there is no reason to use jQuery in modern browsers.
Most government projects require insane amounts of backwards compatibility unfortunately :(
[**@mraleph**](https://twitter.com/mraleph/) &gt; [2015-05-12 18:37 UTC](https://twitter.com/mraleph/status/598195342291574785) &gt; here are my \#GOTOChgo slides http://mrale.ph/talks/goto2015/, mostly already seen examples but also some new [[Attached pic]](http://pbs.twimg.com/media/CE03fnNVIAE2rQ4.png) [[Imgur rehost]](http://i.imgur.com/LFnWKb3.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
sure. and then re-implement a selector engine. then re-implement json requests. then re-implement triggers and a generic event handler function. and then test in all browsers. soon you have re-implemented jquery, but shitty. in the end, sure, you might not need it. but why? masochism?
You only need to do all that once. And then you know how it works. And you're a real, self-reliant programmer. And you don't need jQuery.
I sometimes use jQuery when older browser support is required. Most of the time I just tend to use an alternative framework: http://vanilla-js.com/ It suits all my needs, and is pretty lightweight, you should check it out. Really the most performant JS framework out there, IMHO.
The syntax I gave there is perfectly valid, the syntax you demonstrated simply adds the default object in addition to the default fields, it depends on your context which you need. Oh and I also added a demonstration of how to rename a field using destructuring assignment, maybe you weren't aware of that? I don't really agree with any of your points but I don't really feel like debating it with you as you've adopted a pretty confrontational debate style there.
Meteor + Mithril and you will never write a line of HTML again
Ok, fair point... 
I'm reading the book but some of it was too confusing just yet. 
Can you give an example of something that looks weird to you?
I see them all the time in places where they aren't necessary. People seem to use them just because they can. I know there are some weird cases where we need to retain the variable data for some sort of callback, but in many examples I see there are simpler, non-closure solutions.
Code incompatibility goes to the back-end )
A closure can be used to keep variables from going into the global namespace (see: module pattern.) You also need a closure if you want to use an object instance method as a callback.
Hi, I'm also a Meteor developer and yes, it's the best thing that happened to me since I've been programming. You can build a backend using node + express. In case that you don't want reactivity, don't use the reactivity. The last option I would say is Ember. It has solid conventions, there's no many way of doing this so you will be guided. Backbone is too much for something simple and I'm not a big fan of Angular, specially now that they are going to ship 2.0 that changes a lot of things.
Chakra has best ES6 support so far.
Looks like Firefox and Chrome have implemented lots more ES6 features: http://kangax.github.io/compat-table/es6/ (comparing to IE11, IE10).
And now compare it to Edge.
Closures in javascript allow a function to use variables from outside it's immediate scope. Like many JS features, closures can be powerful, but they can also be dangerous. The first example that comes to mind for using closure is in higher-order functions (functions which return functions). function adder(x) { return function addToX(y) { // the addToX closure has access to // the x variable, even though it belongs to // the `adder` scope. return x + y; } } var addToFive = adder(5); addToFive(3); // 8 In this type of scenario, closures allow us to create functions which "configure" other functions. *Functional Javascript* by Michael Fogus is a great book on this subject, and talks in length about the role of closures in functional programming. On the other hand, closures can be dangerous when used without intentionality. Passing around functions in JS is so simple, that's it's easy to lose track of your scope. You might start out with something simple like this: class Person { constructor(firstName, lastName) { var fullName = [firstName, lastName].join(' '); this.on('askForName', () =&gt; { // This callback has access to the `fullName` // variables, which is outside of its immediate scope this.reply('My name is ' + firstName); }); } } But as the Person class gets more complicated, you may want to refactor out the `askForName` callback: class Person { answerWithName() { // Oops! firstName is undefined. this.reply('My name is ' + firstName); } } It may seem clear in this example what went wrong, but as your code gets more complicated, it can be really easy to lose track of scope. Having access to variables outside of your function scope makes it easier to write code that puts you in this situation. EDIT: [Mozilla has a nice writeup on closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), for anyone that's new to the concept.
Microsoft can't move forward chained to the husk of their past failures because of the poor business decisions of ignorant company leaders. Put a bullet in the zombie's head and move on. 
[os](https://nodejs.org/api/os.html#os_os_loadavg) on node.js seems to have less support on windows than linux. Worked on my linux server, but graph didn't show up on firefox.
I interview and grade potential candidates for an Angular focused job. I *want* at least a year of production experience with Angular. I'm willing to accept many years of javascript plus at least one major framework. It's a game of: will this person roll well into the team and contribute? My tip would be: create a github account, add that to your CV, and put up any little experiments or the code you write when following tutorials. When I see a github account on a CV, I actually look at that before I even look at the CV.
Cool. Wanna pay me to do computer stuff?
was trying to be polite about it ; )
I don't understand where the idea that a closure is complex comes from. There may be fairly complex reasons for it, but while doing high-level programming it's one of tools available that can make simple and readable code. When you have more experience, they will be something you can just read, rather than have to give much thought to. A decent IDE such as Atom or WebStorm helps show which { and } tokens match each other. Keeping indentation standard is also important so one can see the scope of variables.
In GUI development there were always cases where you would have to respond to events, so there were callbacks involved. Once you have events and callbacks, closures are not too far-fetched. It is true that in learning algorithms we don't necessarily learn about events and callbacks. Also functions are related to closures. When we study algorithms we may only study procedures. Some languages allowed for the procedure to return values via the parameters that were passed in. Returning values via the parameters allowed for returning multiple values rather than just 1 function return. But languages started changing, parameters started being passed by value which copied the values and all of a sudden you could not change them if you wanted to return new values to the procedure's caller. JavaScript just epitomizes closures, I guess. In Ruby, methods by default don't capture closures. You can use "lambdas" to capture the closure instead. But Ruby users complained about those differences. They wanted that Ruby was more like JavaScript, where nearly everything is a closure. Lars Bak, founder of Dart, recently said that one of the things that he would take away from Dart if he could, would be to make it more explicit when extracting object functions that capture the closure. But they made Dart matching a lot of the JavaScript syntax and semantics and they copied that way from JavaScript. In some of my Dart code I like it that I don't have extra ceremony when extracting method closures. His reason is that if you just "forget" the parentheses the code would then capture the closure rather than to call a function if you had intended the latter, instead. He just wanted it to be extra hard to make that mistake. Closures allow for code nesting. One function could contain another function and a closure. I guess nested JavaScript code really exemplifies this. Without closures, code would have been much shallower and perhaps more repetitive. Without closures you would have to create more libraries of functions and procedures. Closures may give you an anonymous function, without closures you would have to declare a named function somewhere, increasing the burden of you having to name a library, name a function and remember to refer to that library in the future. 
Thanks a lot! Also, do you know why the bottom part looks broken when the form is large? http://jsfiddle.net/Bum3z/14/
you could build your house by first forging your own hammer, then cutting your own wood. or you could ~~buy them,~~ stop wasting time, and just get to work. i could [download a re-implementation of] an ajax function, or just use [the native] one that is completely tested, has more options than i will ever need, and just works. same with all the other built in functions and methods.
You seem like a happy person.
KISS in JavaScript would mean keep your code modular. Write complex functions, but functions that does one thing well etc.
Thanks for sharing. This is a great resource
As far as V8, my recollection is that it affects only the function in which it's declared.
They most certainly add complexity. The problem is that they are needed to solve complex problems that span from implementation issues to language limitations. Well designed software is not necessarily simple. Interactions between software layers often requires more esoteric language features, than simple types or loops. Even with a different paradigm (actor messaging in Erlang/Pony/Elixir) you use closures. In a message passing language, the amount of code saved by a closure is KISS.
People prefer what they prefer. I don't like CoffeeScript, but judging people who do and insulting their intelligence is incredibly immature.
People got shit to do man. The stakeholders don't appreciate us burning hours and taking on risk that don't benefit business value.
I agree when it comes to Coffeescript. However Jade is very readable and I'm not sure I get the comparison between it and Coffeescript. One should never do a demo in Coffeescript since one would assume a majority of the audience wouldn't be familiar with it. Jade, however, is probably a good fit for a demo because it's succinct compared to vanilla html and especially other templating languages, which means less typing. Plus it's quick to learn so the audience won't be confused. And I say this as someone who HATES templating languages... edit: And BTW I'm a grizzled developer (40+) and we use Jade in production. It's cached so doesn't slow down anything. It actually got me excited about doing front-end dev work again, which is a miracle in itself.
IMO the answer is information density. Tools like coffeescript/ jade/ SASS let you express relevant details while removing irrelevant or redundant symbols that typically just add line noise without adding additional information. In fact for all of the tools you mention, the first time I looked at Coffeescript, Jade, SASS/ SCSS I understood exactly what it meant. I can look at the source and have a pretty good idea of what the output will look like. I really don't understand what's so difficult to grok about any of these tools. Having done a fair amount of python in the past, Coffeesript's use of indentation to represent a function body this feels completely natural. And at least in the case of coffeescript, parens/brackets are *optional*, so you can add them in if you feel they're necessary to remove ambiguity. If you know CSS selectors then Jade should be pretty self-apparent what it's representing, and again, IMO it's a lot cleaner &amp; easier to read and write than comparable HTML. Not sure what the story is with writing input tag or how one could possibly know how to do it in Jade but not HTML. They are almost the same except for the extra &lt;&gt; symbols and closing tags in HTML. Other things like // javascript: if ( ! foo || ! foo.bar || ! foo.bar.baz ) return "not found" vs #coffeescript return "not found" unless foo?.bar?.baz So yes you need to learn what the `?.` does but one you do you're better for it and the latter more succinctly represents the intended outcome. Demos aside (where the primary goal is to convey information to a broad audience) I don't buy the argument that "X doesn't know it already therefore (some group) should not use it and technically you can do the same without it" That argument could be applied to Scala, Clojure, ("just use Java!") or babel/es6 ("You have to transpile/ use source maps!") Also latency is really a non-issue, it's parsed/ transpiled once and cached at runtime, or it can be done at build-time as well. Finally, in many cases coffeescript creates more idiomatic (and I'd argue "correct") javascript than you would yourself. Just look at the coffeescript homepage for examples of the JS output. In almost every case, the source is easy to comprehend and the output javascript by comparison is much less so. So which would you prefer to read and write? Sounds like the same old "C vs ASM, Java vs C" luddite argument to me.
Closures add complexity to roughly the same degree that objects add complexity. (In fact, you can relatively straightforwardly simulate each with the other) I think your issue here boils down to two root causes, both of which may be easier to understand if you reflect on your experiences learning about OOP: 1. Unfamiliarity. Code using a new concept will feel obtuse simply because the concept itself is a barrier to understanding. As you learn more, the concept feels more natural. The KISS principle tends to be stated in terms of absolutes, which is kind of silly. "Simple" is *always* relative to the audience involved. 2. Unnecessary use. It will always be difficult to understand code that is going out of its way to needlessly use a piece of functionality. That code will likely be difficult to understand because its form doesn't reflect its function. In well written code understanding what the code is supposed to do should give you some insight into how it does it. Unnecessarily using functionality prevents that from happening. Closures are a wonderful tool in many situations, and can often greatly simplify code. Many OOP design patterns are basically making an object out of "99% a function, but we need to carry some state too". With closures that entire object is unnecessary, and removing it simplifies the design.
After your first code example I can't tell the difference between closures and inheritance from reading your post. That will sorely confuse people who are either new to closures or JavaScript. Considering that this distinction is why people have trouble understanding scope in JavaScript I would say it is rather important.
No, really though, can you provide a concrete example of someone unnecessarily using closures? Right now you're following the statement that you don't understand them well with the assertion that they're unnecessary. Working through a few samples could either help you gain understanding or convince everyone to sympathize with the closure abuse you're encountering.
&gt; JavaScript is just a unique language, and closures are typically used simply to make JavaScript act more like other languages, but the resulting code doesn't look like other languages due to the prevalence of closures. I would say the opposite. Closures make JavaScript very different from languages like C, Java, and such. The thing that is added to the language to make it look more like those others is *prototypes* and prototypal inheritance. Prototypes are certainly not the same as classes, but its still inheritance, and the use cases are similar. Please understand that scope and inheritance are unrelated concepts. Lexical scope makes JavaScript very different from the C based languages. Java was the last major hold out to get this with Java 8 last year.
Perhaps our definitions of rock star differ. When I think of a code rock star I think of something like this: http://prettydiff.com/guide/unrelated_rockstar.xhtml
When I began taking JavaScript seriously back in 2005 just after I saw Google maps, there was very limited documentation compared to today - or at least I had not read it or heard of Dave Flanigan's Definitive Guide to JavaScript back then. I was writing code to handle an HTTP call, based on other examples, and I had no idea why it was working, and I did not know about closures. I tried various combinations of syntax that would either break the code or get it closer what I wanted it to do. Some time later, it just clicked, and I could understand closures and used them in many places, and I still do use them a lot. One place I avoid them is when writing performance critical algorithms that I may be porting to C some day.
Yeah, referring to a peer as "kid", "son", "sport" is not respectful of the person no matter how much you may disagree with them. Mind you, I don't like CoffeeScript of Jade either.
Who said something about not learning? I'm just asking if you like examples for libraries in ES6. If it was like that I should learn pretty much every framework to be a "programmer". I have job to do and things to learn, there is a balance between the two of them. 
I would avoid any and all jobs wanting the current version of Angular as requirement. In fact I am blown away that anyone is even building anything new in it.
I really enjoyed this. The data was very interesting.
I laughed. Downvote away.
You should really try and use replaceState so that the history of the user doesn't get polluted.
Your comment is all over the place and based on things unrelated to this. You are claiming everyone needs a framework or library to get work done. I'm saying you don't when you know how to use the APIs that come with the browser. If you can't use those, and don't want to, I question your competence and base for being a programmer. As it turns out, it appears that most redditors need a framework or library to wrap around the current API which they don't understand or find too hard or they just don't want to learn how to do it. Real programmers don't take issue with that.
You apparently also make your files world-writable. You'd be better off as chmod775. It's at least marginally better security. Just make sure you set your ownership and group properly.
I've always wondered why Occam's Razor is not applied to computer programming.
What problems does this solve over traditional routers? The only new thing I saw was building route strings declaratively. Like: navigate('people'); refresh({page: 2}); Instead of: navigate('/people/' + defaultPage); navigate('/people/' + page);
The only reasons to prefer ES5 are if you're working with a module loader that doesn't require a compilation step in development, or you're creating a module you intend to redistribute in the short term. ES6 isn't an optional productivity tool, it's the future of the language, and it's definitely coming. If JS is your job, ES6 is now part of your job.
jQuery was incredibly popular because it bridged the gap between many browsers with quirks that would make people tear their hair out. Nowadays, there are far fewer reasons to use it, but it retained a lot of its popularity because everyone *used* to use it. (And that meant that there were a wealth of plugins to do almost everything.) That said, the library can let you write some very terse code still; While jQuery isn't really *needed* by JavaScript developers today, a lot of people *want* to use it for its phenomenal terseness. (For example, [here is Resig answering a question with some example jQuery](http://www.reddit.com/r/ProgrammerHumor/comments/2xx66t/he_should_have_used_radio_buttons/cp4mgpo?context=3).) It's very easy to appreciate how fantastic of an abstraction it is. For example: Many functions return instances of themselves, allowing for chaining function calls into a functional pipeline. (Similarly to how you would work with JavaScript Arrays with `.map()`, `.reduce()`, and friends.) These functional pipelines, *even if they can't perform their desired effect*, still return themselves. That means that you don't need to worry about checking the returns of the items in the chain, and you can make the pipeline as long as you like. Also, instead of passing elements to callbacks all the time when doing actual DOM manipulation and querying, the element is set as the callback's *context*, solving the problem of argument uniformity. While these are (admittedly) simple little details, they exist throughout the library; jQuery in its entirety is designed to be easy to use after you get the hang of its style. *jQuery is not needed, but it is ridiculously well executed.* Because of this execution, jQuery's longevity is pretty much inevitable.
[caption](http://imgur.com/sPCWsdT.jpg) This is what I saw when previewing the page from Expression Web, and how I thought it would turn out.
As somebody who just started learning the amazing things gulp can do, how do I go about doing that?
Did you make it to the Remembering Data exercise of the Tutorial? That'll show you how Navigation tracks the States and data as it builds its dynamic breadcrumb trail. This allows a user to return to a previous View, recreated as they last saw it. The breadcrumb trail is part of the Url, which means it's bookmarkable and still works if you open a link in a new tab. You won't find that in other routers. Refresh navigation has a unique way of remembering data that I don't cover in the Tutorial. Imagine you're building a paged, sorted and filtered list. The paging Hyperlinks must keep track of the sort order and filter criteria. Building these kind of Hyperlinks is difficult with traditional routers. Navigation remembers the current selections for you, so that refresh links include them automatically. You can [read more about these two features](http://grahammendick.github.io/navigation/documentation/rememberingdata.html)
Thank you! I was wondering if I needed to create a js and a css folder for their respective files, and it looks like that may be the issue. I will try that when I get back to the site.
Keep in mind that the paths are relative to the entry file (usually index.html) so you'll want to create the folders at the same level as that file.
Why the deleted comments? It lowers the value of reading the discussion, making it harder to follow.
[sure](http://jsperf.com/tonum-plus-vs-math-floor), but of course you lose precision.
I looked at both before commenting. 1) `string === "true"` is easier to reason about than `require("parsebool")(string)`. 2) `return val === "true" ? "false" : "true"` is shorter. 3) I and /u/rikurouvila do not believe this behavior is desirable. 4) `string.toLowerCase() === "true"` does this. Modularity is great, but personal modules do not always need to be published on NPM. `npm link` is a great alternative.
http://caniuse.com/#search=querySelectorAll
Very nice, and thanks for the feedback, but the decision of making the function _not_ return a boolean unless `obj` is either "false" or "true" is completely on purpose. Basically, I wanted to use the strings "true" and "false" as if they were regular booleans, but leave other strings as they are. 
I dunno how I feel about this. Remove the unnecessary spacing and this whole module is &lt; 15 lines of code. At some point you just have to copy and paste into a utility class. On top of that, I agree with everyone else that parseBool('a') === 'a' is strange and unexpected behavior. Inconsistent return types are evil and I fail to see a good use case. It allows for mistakes like this to happen if(parseBool('not_valid')) // condition passes Also, and sorry for criticizing so much, but having an options hash with only a single possible value that can be replaced with a single method call, which is more explicit, seems a bit silly too. parseBool('test', {ignoreCase: true}) vs parseBool('test'.toLowerCase()) One could argue for the null/undefined case here, though.
If your IDE has good code-collapse support then doing a full code collapse on a file with a lot of closures really simplifies things. The top-level structure becomes apparent, and you can pick and choose where to drill-down. As you drill down, the functions that get exposed are in the given context of the drill-down path, and will begin make a lot more sense.
JS type coersion sucks (still better than PHP though), but unit tests aren't likely to catch all these possibilities in non-trivial software (and devs have to be aware that all their unit and E2E tests need to account for these kinds of problems -- except that most devs don't even know it exists). This is part of the argument for Flow or TypeScript which are better for these kinds of problems than unit testing. Grab that drink and enjoy [a fun derivation of basic JSFuck](http://webcache.googleusercontent.com/search?q=cache:MvDuPn9xkf8J:https://www.jackwearden.co.uk/blog/bending-javascript-type-coercion/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us) 
Math.floor doesn't cast a string to number though. It coerces, then floors. Also note that flooring isn't the same as truncation. &gt; Math.floor(1.2) 1 &gt; Math.trunc(1.2) 1 &gt; Math.floor(-1.2) -2 &gt; Math.trunc(-1.2) -1
It brings some good minds back to the Node team. 
Now you can start explaining why it's going away to all those same people!
I may not be a smart man, but I know what love is.
&gt; Why do you act so aggressively? That's just how you decided to interpret it. My comment was completely free of aggression. This is just syntax of some language. It's not like you were the one who came up with this shitty idea. &gt; you should have said "default values for an optional argument" "Named arguments with default values really don't need to be complicated." I was actually pretty clear.
What proprietary stuff? The DOM API and all the rest are web standards.
Support dates for lambdas: * Java 8 - April 2014 * C++ 11 - August 2011 * Swift - new language (2014 ish) * Python 1 - 1994 * JavaScript 1 - 1995 * Ruby 1.9.1 - January 2009 * C# 3 - August 2007 The only outliers here are Python and JavaScript. For these other languages lambdas are new and probably not foundational. Lambdas are the only scope model available to JS.
Worth pointing out that the best shim for `querySelectorAll` is still Sizzle. It's probably the largest you'll have to load for supporting IE8. Everything else is titchy by comparison.
Tail calls can allow garbage to be reclaimed sooner, and they do save on stack space. Setting up the parameters to the called method can involve some shuffling though, which can add a little overhead (especially if done naively). 
That's called [keyboard ghosting](http://www.microsoft.com/appliedsciences/antighostingexplained.mspx). Unfortunately there's absolutely nothing you can do about it as it's a hardware issue.
Well shit.
If you have to support IE8 it's by far simpler to just use jQuery We're finally getting to the point where maybe IE8 doesn't have to be supported on new sites, but on my main site it's still around ~5% usage.
At my company we've gotten the semi-green light from "up high" to target any new projects for the current version of all the major browsers. As a webdev of 14 years I haven't felt such a breath of fresh air in a long time.
This approach seems far too complicated and error-prone. You would be forced to write a lot of boilerplate code for every possible transition to and from. Large applications would be nightmarish. Keeping state in the URL, one of the differentiating features, doesn't seem useful for anything beyond trivial use cases. In those cases you would just use a regular router ('/:id', for example). Looking at the React/Angular examples, it even turns the code into something that doesn't follow the frameworks best practice.
This is one of the more interesting sw eng articles I've read in awhile. It's probably worth publishing.
Would anyone mind explaining what this means to a Node.js noob like myself?
Probably nothing. Basically the node team had a split for whatever reason and some developers forked the code and started io.js and then they resolved their differences and now they're back together again.
There's no way to achieve privacy or modularity without closures. (See: module pattern for example). Technically, you can use try / catch block to introduce a new scope, but yeah. And closures are very, very common in existing javascript code and learning the language without learning them is kind of useless.
I found this video to be the best explanation of the split https://youtu.be/1IOukA10QeQ [3m59s]
Some of the Facebook React guys were talking about how the MooTools source really helped them learn. It's clean
Isotope can be used with or without jQuery.
&gt; split for whatever reason Yeah, like Node using an outdated version of it's JS engine or something.
That is most probably true.
Frameworks are a fickle thing. If a job **ABSOLUTELY** will not hire you without mastery of framework X then you probably don't want to work there anyways. Time spent mastering a framework is time not spent mastering vanilla JavaScript and other web technologies. Last year I worked for a couple of months for one of the ten largest software companies. They demanded Angular experience, and I had none. I still got the job beating out 27 other candidates. A couple of weeks later there was a reorg and this team was told to not use Angular any more. My willingness to learn new technologies was far more important than dedication to a certain framework.
The sheer number of libraries built around jQuery is a huge reason to use it, aside from it's cross browser support and short syntax.
Boolean flags are generally set by just using the flag. Pngquant has 3 of those, for example: --force overwrite existing output files (synonym: -f) --nofs disable Floyd-Steinberg dithering --verbose print status messages (synonym: -v)
If you're just looking to join arrays of data together based on some shared object key, I wrote a lodash mixin library to do any type of join. https://github.com/mtraynham/lodash-joins If by "cross" you mean slice &amp; dice OLAP... There's Crossfilter which allows you to filter datasets in a OLAP fashion. http://square.github.io/crossfilter/ New York Times also released PourOver, which has similar OLAP functionality. http://nytimes.github.io/pourover/ If it's an exorbitant amount of data, I'd go with a SQL DB of for joins or ElasticSearch or MongoDB for OLAP BI data processing.
Personally I prefer recursion, folds, etc. over while loops, but your example is certianly better. The problem with OP's is that it does not take advantage of tail recursion. I know JS doesn't have tail recursion, but some day it will.
Thanks! What do you mean by publishing?
Crossfilter looks amazingly promising
Wuh...what?! &lt;BookerT&gt;Tell me you DIDN'T just say that!&lt;/BookerT&gt;
Meh..js can be written as //javascript return !(foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz) ? "not found" : true; too but I see your point. The only gripe about `CS` for me is with white space. I have spent countless times trying to find where I screwed up the white-space. Any tips on this would be greatly appreciated. 
I am seriously considering making a VR app that transpiles `coffeescript` into `javascript`. 
Sure, this is useful for implementing the `--no-flag=true` becomes `--flag=false`, etc.
This is excellent news for anyone who has been working to "sell" the virtues of node in a technologically conservative organisation. When io was originally forked I was deeply concerned about the effect it would have on perceptions of the platform in said organisations, and the risk that they'd decide it was all too unstable and risky and jump ship back to Java. Hopefully this decision will mean we can look forward to a stable long term future for node.
The changelog is buried down there http://backbonejs.org/#changelog
This gets interesting, because OTOH there is proof of concept for a port using JavaScriptCore: https://github.com/flyover/v8like - though it is not actively developed.
he's only 5 damnit!
The DOM API still trails or is inconsistent across browsers you might care about. And now you have to be fucked to go look and see exactly what part of the API is safe to use for your project. Maybe write some wrapper functions that smooth over the details. Or you can use jQuery and get to work on something that brings value to people instead of pulling your dick.
Yeah, as we all know, there are no quirks anymore... until you stumble across them in production. Or when a user goes "hey, this doesn't work on my phone" and you have to respond with "lol thought it would, whoops". A jquery-like library something you have to evaluate per project, not something you can write off completely.
It had more to do with Joyent's control over node, and the lack of a new Node release for more than a year. 
That's what software engineers are for. And software engineers test things. You did test things, didn't you? And you have software engineers and not reddit wannabe engineers don't you?
Wow. I'd bet you own a computer and know everything about them ... and stuff.
I don't find XHR ugly or annoying or so difficult that I need someone or something else to help me use it. It's a few lines of javascript but I can see how a redditor would struggle mightily with a few lines of javascript.
Yeah, people who write like that make me want to loose my mind.
So you couldn't figure out what the video was saying either to explain it?
What's the difference between web development and programming ?
can anyone explain me what are web components i keep hearing about polymer, mozilla brick
It seems like this could be cleaner if you relied on the recursion scheme "unfold". This way you can extract the explicit recursion and lean on a tried and true method. Your code can become more declaritive and simply describe the job at hand. // code you don't have to write ever again function unfoldP (f, next) { function recurse (accum, next_) { return f(next_).then(x =&gt; { if (x &amp;&amp; x.value &amp;&amp; x.value.length) { return recurse(accum.concat(x.value), x.next); } else { return accum; } }); } return recurse([], next); } // code you actually write function getStuff (next) { if (next &lt; 10) { return Promise.resolve({value: [next], next: next + 1}); } return Promise.resolve({value: [], next: null}); } unfoldP(getStuff, 0).then(x =&gt; console.log(x));
I don't really have a use for this, but the source code is definitely worth a look at. It get's me excited for the future of JS with ES6.
&gt; A simple example would be replacing if(test){a;b;c;} with test&amp;&amp;(a,b,c) which shaves 2 characters in the right scenario. [Google Closure Compiler](https://github.com/google/closure-compiler) does this automatically. I bet with the advanced compilation option, there are even more things that are optimized which most people wouldn't think of.
Two tactics I've used in the past when my code wasn't working as expected... Quickest way to find out why some CS isn't behaving as expected is take a snippet and use the `coffee` command to see the generated JS from the command line: $ coffee -sp &lt;&lt;EOF # paste your code in the console volume = 10 if band isnt SpinalTap countdown = (num for num in [10..1]) EOF ... and the coffee compiler prints the generated JS to stdout. Usually I can spot what's going wrong there. Also, if necessary start adding implicit delimiters where nesting isn't crystal clear. CS is a little like Ruby in that the parens and brackets are optional in most cases, you can always keep using them if desired. Function body is (I think) the only place in coffeescript where whitespace/indent is the *only* demarcation, and if you've done Python that's not so unusual. 
We're a little behind and just now starting to think in terms of mobile and responsive design. If it was up to me (and it might be), I'd say if it works on the current version of mobile Chrome then it can ship.
I would like to just point this thread to what is going on in HN https://news.ycombinator.com/item?id=9544970 A lot of people are asking "doesn't doing this in the client defeat the purpose if people can just get the original image?" My short answer here is: no - watermark.js handles several different inputs. It even accepts file inputs - so you can generate watermarks on the client and then upload them. Reading from a file input does not leave your images open to a Google bot to index your non-watermarked images :) And for the case of using existing urls and images, I don't think many typical users would not go digging through JS source code to see the original urls you are using - but yes it is possible and something to consider :)
Oh my! that thing is very tricky! Great work however!
This is really nice. I really hope they'd support android soon. While JSX does make React development easier, I really find it awkward to use. I still favor QML's syntax over JSX.
There is of course no standard when it comes to implementing an CLI options parser as long as it (ideally) follows the [Unix Utility Conventions](http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap12.html) In my implementation, available [here](https://github.com/bucaran/parsec) you can see how I deal with `--no-flags`. As for `pngquant`, `--fs` is the default and `--nofs` negates it, correct?. C/C++ usually simply use something like `getopt` to parse CLI arguments. So, there is no exactly a convention regarding `--no-flags` that I know of. I have also worked with low level CLI option parsers, I implemented one for the fishshell [here](https://github.com/bucaran/getopts). 
Oh okay thanks. Could you tell me the PHP equivalent of node.js so I could have a better understanding of what it is?
And python closures are annoying because you can read vars, but if you try to assign to a closure variable you actually create a new function scope var...
Avoid using globals and you may not afraid of shadowing. Globals are pure evil. 
I might be reading it wrong, but the first paragraph in the first comment in the linked issue says ["The new "converged" node project will begin with io.js master and port changes from node.js in for its first release target."](https://github.com/iojs/io.js/issues/1664#issue-74519669).
Thanks for the explanation. It's a little clearer. I'm tempted to make the analogy PHP is to Apache as JavaScript is to Node, but even this seems wrong. 
It perhaps depends on your needs. In the past people were content to just create an HTML table. But an HTML table is pretty static by default. The advantage is that generating an HTML table is incredibly easy. Then with the HTML table you could show it in any web page you'd want it on. It's also easy changing the template to customize the HTML table. With JavaScript you can also show tables. JavaScript gives you more chances to make the table more dynamic. You could show just part of the data. Allow for filtering data, searching, reordering, etc. If you don't know much about JavaScript you could try to use some jQuery library. Those come with examples you could borrow from. Cheers!
Consider pasting your code to [gist.github.com](https://gist.github.com/) or [Pastebin](http://pastebin.com/), and sharing the link to the code in your post. This way, we can actually read the code. For now, the code is a mess of gibberish, and no one has the time to figure any of it out. **Edit** grammar
Could you ELI5 to me why?
You are using Jquery. You are in luck because JQuery has terrific documentation. Go there and look up each function you are using one by one in the JQuery documentation. The only other thing you need to understand is your use of regular expressions. Google "regular expression" and you can find any number of explanations as to what they are and how they work. If I were your teacher I would ask you to explain exactly how you got to that regex, and when you can't explain it I'd fail you for cheating.
Great news. It was a shame to see the Javascript community split over io.js &amp; node.js.
Interesting i didn't realize that was possible.
I'm no expert, so take with a grain of salt: If you want to do it yourself, you might try checking out Codecademy and going through the basic html and CSS courses. Doesn't take too long. Tables and CSS styling should be able to accomplish what it sounds like you want. Javascript would add functionality. Regarding a server... I don't know. You can get free web hosting, just google it. Or save web projects on sites like CodePen and JSFiddle or others.
Sometimes it seems like io.js is kind of the Quebec of javascript. Like how it's always threatening to secede unless it gets more power and more stuff...
Well, the server-side JavaScript community. There are plenty of people in the JavaScript community (myself included) who don't believe that JS really belongs on the server and couldn't care less.
Personally, I would store the CSV files in Amazon S3 and use an Amazon Lambda script to automatically convert any new files to multiple JSON files, and store them in a directory structure that matches how you plan to access them. I'd build a simple HTML/JS app to load these files via AJAX and display them in the appropriate format. This app would also be hosted on S3. Since this approach doesn't need a backend server, it should be very cheap to run and should easily scale to support huge numbers of requests. Edit: This assumes you only want to display a static table of data in HTML format. If you want more advanced functionality, such as searching or aggregating over large parts of your data, you're probably going to need a database.
* A runtime is an app that reads a particular language's source files and makes it "do things". * Some runtimes have support for several languages. Most support only one. * Node.js is a runtime for the Javascript language. * PHP core has its own runtime for the PHP language. * There are several alternate PHP runtimes that run the PHP language. * There are several alternate Javascript runtimes that run the Javascript language.
Some people think of them as the same, but when you're coding for a browser, it's a really different skill set. HTML is a markup language, which is totally different from what most people think of as "programming". There is no if-then-else logic, no loops, no variables. CSS doesn't have that either. JavaScript does, but your normal problems are all about browser compatibilities, interacting with HTML, how the info is transmitted across the internet... Very different primary concerns than other programming.
I would start with this one: https://github.com/johnpapa/angular-styleguide
Made a similar bar-clock long ago when I worked with javascript. Pretty minimalistic. I like your approach as well! Here's mine: http://codepen.io/perskes/pen/iorLF
This is an extremely bad idea. If you explain what your end goal is, perhaps people can suggest other approaches.
If you're into doing a lot of development yourself, I think the Google Charts API has everything you need. Other then that, tools like Kibana and Graphana will probably do the job too. But they require you to save the data in a specific way, rather than create the tool around how the data is today. Also, there's a ton of great chart plugins for javascript, as I see others have mentioned. Though, I think there's a general lack of mapping. This could be solved by rendering a custom Open Street Map with statistics built in based on your data.
This would make a great grunt or gulp plugin for watermarking images. I would not recommend doing it on the browser, while the average user will be unable to remove the watermark a smart one can simply download the image before the watermark is applied. 
Awesome, I really like the minimalistic approach! Both the code and aesthetics are effective and efficient! And... you were ahead of your time as it reminds me of Android's *new* "material design" look. For mine, I just wanted to mess around with the new html5 meters and using a different approach to tell time (different than the traditional analog hands and digital numbers approaches). Thanks for the response and thanks for sharing! 
&gt; bashing the Angular community ... due to bad practices Hope you don't mind, not really contributing to the thread, but I want to be sure that we're clear here. When people like myself are bashing Angular, it's because of the *standard* best practices, like a FactoryControllerFactoryDirective or whatever. I think it would be really stupid to blame a framework for people not following the established best practices though. If *that's* what you're talking about, those people are ridiculous.
Nice tutorial. Sorry to ask, but are prototypes considered a best practice in JavaScript? Or is not using them considered a best practice? Does it really matter? The reason I ask is because I don't use prototypes, and I'm wondering if I should start.
This will mess with minification. What are you trying to do? If you want an alias, you can just use an assignment. let query = document.querySelector.bind(document); console.log(query('body').className); function foo(a, b) { return a + b; } let bar = foo; console.log(bar(2, 3)); // 5
There are very limited cases when you should use eval. I'm not certain this is one of them. A simple google search will explain the reasons why it's not a good idea to use it
It is considered best practice but won't have any type of performance impact unless you're instantiating thousands of that object. Start using ES6 with proper classes rather than messing around with prototypes anymore, they are a thing of the past. EDIT: Downvoted for stating the truth. Start using an ES6 transpiler and stop using a language standard that is over 5 years old.
Or Scotland or 100s of other examples
hey Web dev here of over 2 years experience. Willing to give you a hand. Why dont you tell us what you think/beleive is happening with each line and we'll go from there
Just thought I should throw this in: ExpressJS is more comparable to Sinatra and Flask while frameworks like SailJS, Meteor(?) will be more comparable to RoR and Django. 
No, wasting your engineering resources on unforeseen, avoidable quirks is not what software engineers are for. That's called: wasting everyone's time. I'm sure your users care big time that you didn't use jQuery or some variant. They're super impressed.
So you are saying, use jQuery and you don't have to test in browsers or devices? Now there's a good idea.
In terms of evaluation, this is all i have so far http://pastebin.com/bB0zdhxR Sorry if it's not very clear, everything after a hyphon is evaluation, the rest is code
Love the logo :)
One reason is that there are preexisting projects/programs named "node", so they can't just call it "node" (although they do anyway sometimes). The ".js" just makes it clear it's based on JavaScript and not some other programming language.
I wouldn't really have an issue with it. 
lol .NET is a name Microsoft came up with when the internet was blowing up in popularity in the early 2000s. It's their whole big software framework that covers different languages/tools/libraries etc. ASP.NET is just the ASP part of that whole deal.
I'm too busy shipping code and shagging ya mum. lol @ "studying" the downside of using jQuery. Sounds like a fun time in your cubicle bro. Do they even let you touch the codebase?
Even if you can, you still shouldn’t.
I just wanted to second wkf. It got a chuckle out of me. Good job!
Yeah, man! I just got Lollipop (Android 5.0) on my Galaxy phone. For the most part, I'm enjoying it! What do you think of Google's material design? 
No, that's not really what happened. But for simplicity sake yeah
In general I agree (with breaking the back button in general) but you could also say that Apple shouldn't have implemented a feature that broke a lot of sites' existing functionality.
You should try it swipe back from comments view to list of posts.
As others have mentioned, what you're doing really doesn't make a lot of sense out of context. You're almost assuredly doing something that you shouldn't be doing, or there's a much better way to achieve what you're trying to do. That said, this function will do what you describe: function myAlias(newName, oldName) { window[newName] = window[oldName]; } (assuming you're doing this in the global scope)
I've owned by own web dev company of 10 for 11 years. I own da code. You need this: http://youmightnotneedjquery.com/ 
Where did you learn this from? In what situations can it be fastest? What exactly do you mean by "cast" since that's not exactly what happens? How much faster, and why should I care?
This feature was implemented more than a year ago, with iOS7. It's not like its anything new. Its more convenient (when browsing with 1 hand) than annoying, for me at least. When I see sites that use their own swipe left or right navigation, its usually for 'navigation' and its badly implemented. I have to be extra careful when scrolling down on those sites or else I might trigger it and go to their next blog post or new story when I'm reading the current story.
I'll never understand why people ask a question here instead of looking for someone elses' already posted and answered question. Seems like a waste of time. http://stackoverflow.com/questions/18889666/ios-7-is-there-a-way-to-disable-the-swipe-back-and-forward-functionality-in-sa
I actually did some searching but didn't read this page. Thanks. I almost never post questions for that reason.
Author here - the only reason why it's a "which chick is hotter" app is because of facemash. I thought it would be neat if it went "full circle" (facemash lead to facebook that lead to react native). From my experiences, and although they are limited to just me - I don't think the tech industry is a "boy's club", heck my team at work is primarily female apart from myself. The idea was that you build the app along with the post, not directly copy it, meaning you're free to change the pictures/content/function of the app yourself. The tutorial is only meant to show uses for as many common React Native components as possible. I know some people might be touchy with the content, but this is already history - I'm not promoting actually creating the app. It's already been made. [It's currently active](http://www.facemash.com.au/).
Personally I think you're overthinking this. It's something different than your average todo app and it's relevant to the hypes (tinder, badoo etc). I can't stand another todo app and I'd find a kitten war childish. Then again I do get your point and some women might be offended but this is the internet, no matter what you write someone will always get offended even if you don't intend to do so.
&gt; I can't stand another todo app and I'd find a kitten war childish. So your reasoning for this not being a problem is that todo apps are overdone and kitten war is childish. so what is facemash to you, then? That's NOT a lame/overdone concept nor is it childish? so what is it that makes it a better alternative than the other two?
It might be. Isn't to me, isn't to a load of girls (that work in the tech industry!) that I showed either. It's a harmless, non functional application that mimics the history of Facebook, nothing more.
&gt; It might be. Isn't to me, isn't to a load of girls (that work in the tech industry!) that I showed either. You knew for a fact that it would cause controversy. You addressed it in your post. If the "load of girls" you showed this app to unanimously concluded (either by saying "it's OK" or by not making any sort of protest) that there was nothing demeaning about the choice of application, then why were you still self-aware enough to comment about it in the tutorial? Furthermore, they may not have said anything about it because they felt they couldn't - that's actually a big problem I read about a lot with tech - women who feel like they can't speak up about things like this. For what it's worth, I'm a guy - and a guy who is actually very critical of the "oversensitive Tumblr SJW" type. This choice still smacked as disrespectful to me, and your disclaimer only made it seem even moreso.
I didn't think it would spark any controversy in the slightest if I'm honest with you. That comment in the article was a, albeit probably badly worded, light-hearted joke (who finds dogs/pieces of code attractive?). I don't see how you can assume that. A couple of them have gone away and actually followed the tutorial. None of them were pressured into saying it's okay - they're people, and they have a voice. Just because they're female doesn't mean they lack a backbone to speak their thoughts.
Curious, I know this uses webworkers, but how does this compare with offputting to an Io task? Like async.parrallel?
That's what I'm doing right now, but I feel like there's a more efficient way. It's not that I NEED the most efficient way, since it's a small tool anyway, but I'm just curious and like to learn, so I was wondering if there's a better way of going about the problem. As for the reason I'm doing this, I just want to build a little tool that adds a bar to the top of my webpage, so I can see which breakpoint I'm currently at on the page without having to do something silly like "background: red" every time.
&gt; how does this compare with offputting to an Io task? Like async.parrallel? I'm not familiar with async's approach however a quick google search suggest to me it's not making use of additional threads and cpu cores, I could be mistaken. This I designed to allow you to execute a single function across multiple cores and therefore speed up execution. 
There you go: http://jsbin.com/loniwituji/1/edit?html,js,console
No one is answering directly so I am hijacking this dude's well formatted code: funciton validateEmail uses a regular expression - and tests the email string to see if it passes the expression. Reading a regex might seem like cryptic black magic - but it is not. Just think like a computer and read it like "a character followed by this kind of character or that kind of character ..." etc. Its beyond the scope of this to explain regex but there are billion good regex tutes. So anyway - regex test returns true if the passed in string matches the pattern. The first function returns true if the email is valid according to the regex. The validate function first uses jquery to get the element with the ID "result" - this is a bit of a code smell because who wants IDs all over - but hey its an example. the "#" selector grabs IDs. read about selecotrs to understand that more. Its not a JS thing - its a web thing. So anyway - jQuery grabs the result element and sets its inner text to an empty string. Then it grabs the element with ID of "email" and snatches its value - popping it into the email variable. The email variable is passed into the validate function - which passes it to the regex. If it is good to go - the if condition passes and the first branch is taken. If the email is crap - the other branch is taken. As ugly and ineffecient as it is - jQuery goes out AGAIN and grabs result for both those branches. If you want to do this right - LIMIT THE NUMBER OF TIMES JQUERY TOUCHES THE DOM. So anyway - jquery' ugly ass jumps in and sets the text for result to the email address is valid. Then it goes out AGAIN and grabs result to set the css color to green. This is all harsh and fugly though bro. consider grabbing result 1 time: var $result = $('#result'); Then you can do all that magic after the fact. But also consider that you are doing the same thing in both branches. Would it not be better to have a success var and a color var - then set the values of those vars in the if statement - then after the fact set the result to the DOM elements? The last line calls the validate function when the submit event is received from jquery. function validate(){ var $result = $("#result"), email = $("#email").val(), isValid = validateEmail(email); $result.text(email + ( isValid? " is " : " is not " ) + "valid"); $result.css('color', isValid ? 'green' : 'red'); return !isValid; }
I've dabbled with node a bit and personally I feel it still has a way to go, I've found it's great for simple things but complex logic like say transcoding a video is handicapped by javascript being single threaded, and with node not having a native web worker implementation I can't readily port my multithreading library to the server side. The biggest limitations to me are node trying to position itself as a "platform" instead of what it really is..javascript. There was a video I recently watched that compared GO and node and it was pretty clear that node's approach of do as little as possible for you was not necessary to achieve good performance. Node tries to do too little, the server side eco system has become a patchwork of different packages to achieve different goals, many of which are not maintained and guides to getting setup are horribly outdated, packages missing that are required etc. 
Yeah - if you are building things primarily for you - do what works for you. If you are working on a team - you will usually have a couple of code pedants that want to have a dissertation about why ternary operators are the devil and why you should never reach down more than layer into an object. But its all just tools. If it works for you - use the style that fits your mind. I would just caution to be aware of the amount of coupling you have if you walk down objects. Calling: world.level.sublevel.player.shield.hitPoints--; from the outer application is going to make all that crap pretty well married to the outer application and might be a royal pain in the ass to unit test. 
The gods are evil. YES - there are GOBS of people out there that still use IE7. And they might be the CEOs brother. 
Good points :) I hadn't considered all of that.
he had accepted to die as the popularity of the Clintons!
My little dev company has about 20 active clients. 10 of them are in the entertainment business and virtually no IE visitors of any version at all. One of the clients is a restaurant that sits next to a financial monster and they get about 50% IE visitors, presumably from that institution, but none of it is IE7. Worldwide, yes, there are a lot of people still using IE7 but, relative to all the others, its virtually nil.
You're not missing that show.
Trunk water delivery system operating at 5% efficiency.
It wasn't until now that I realized my projects could use more emoji.
You're totally missing the point. This library can allow a user to watermark an uploaded image, then ship it off to something like S3 with the watermark in tow. Yeah, if you use this realtime: easy to circumvent. But that's not all this can do. 
Repo for the lazy https://github.com/brianium/watermarkjs
/r/aureliajs/
Prototypes can be good to know in certain tight performance scenarios. Due to JSs object chaining you can use prototypes to create 'defaults' that act as fallbacks for objects that may not have their own copy of a property/function declared. An example would be, say you create a custom particle object and want to initialize 100,000 of them. You also want a function that will "move" a particle. You could attach the function to the particle object on initialization or you could add it to the particle's prototype. If you attach it to the prototype, that function (move) is created once in memory, and is still accessible by all of your initialized particles - BUT if you declare the function (move) on the particle object itself, you end up w/ 100,000 instances of it, 1 unique function (move) for each particle, which could have big performance implications.
What kind of scenario would you use this?
I need it for diffing web pages. Download the HTML of two pages, run them through Himalaya, then diff on the JSON to find the actual data on the page. Another use case would be manipulating the HTML more effectively by turning it into JSON then adding/removing nodes and (after writing such a function) rebuilding the HTML. Himalaya returns an exact representation of the HTML so this is possible. I suppose static analysis would be another use. Need to see how many tags or classes get used, whether or not `id` attributes collide, and other statistical things. This is much easier and more accurate working with a JavaScript object as opposed to a massive string. JavaScript has a lot of HTML parsers, but they do not return the document in the form of JSON. They instead provide callback hooks where you can take portions of the HTML as it is parsed for you to assemble into some other string, say XML. I need something more along the lines of a parser for an AST of HTML, and that is Himalaya.
Turns out I know nothing about javascript. EDIT: Turns out people agree with me I guess?
I came expecting something great, and walked away shaking my head.
I think the "can you explain" and "do you understand" type of questions aren't great for interviews. I agree that those concepts are important to know, but I think a better idea is the "make it work" questions. Give them a couple of examples that could potentially make use of all of these concepts, for example: function Car(make, model) { this.make = make this.model = model } // make it work: // define `map` and define `apply` var result = map(apply(Car), [['Honda', 'Accord'], ['Toyota', 'Camry']]) console.log(result) //^ [{make: 'Honda', model: 'Accord'}, // {make: 'Toyota', model: 'Camry'} // ]
That sounds pretty interesting. Do you happen to have links to any benchmarks? I could see the latter using more memory, but I'd be curious to see the actual performance benchmark results. Bigger doesn't always mean slower.
I have never encountered a performance problem with Javascript. 
By my own experience I can tell you it can be orders of magnitudes faster. The CPU also has to do a bit of work too, essentially qualifying every new function for each object. ** Here's a stupid-simple [jsperf example](http://jsperf.com/prototype-vs-this).
Closures are good for shared memory between instances. Take this: https://github.com/LazerUnicorns/lycheeJS/blob/development-0.9/lychee/source/platform/html/Input.js
Very nice! :D You might have just convinced me to start using prototypes ;)
I don't think they are doing any of that. The async library is more for assisting with the order (or lack of order) of execution of async functions, not for sending them off to separate threads. Or that's how it was the last time I used it. Haven't really used it since ES6/7 syntax came around.
The closure question is the only one I'd say is minimum viable person. If you don't know about closures, you can't really do anything.
I ask similar questions but don't delve too much on the definitions. I would ask "have you ever heard of the 'call' method in Javascript, and if so can you explain it." I don't ask trick questions about call vs apply since they essentially do the same thing. If the interviewee gets stuck then I help them as long as they're on the right track. - Can you tell me what a closure is? (Also acceptable is a anonymous function) - If I were to create a function or class with a private variable in it, and one with a public variable, what would that look like? - Can you explain the Same Origin Policy? (They can mention XSS and JSONP here too) - If I had an array of objects, where each object contained an id property and some objects were duplicated, could you create a function that returns an array of unique objects? (only pure JS, no frameworks) These 4 questions can tell me how good someone is with Javascript.
Nice work! I find it best to use a function and the conditional ternary operator when dealing with time format. It will save you from having to repeat yourself using if(someTime&lt;10) { someTime = '0' + someTime } over and over. Example: http://jsbin.com/sibedavewa/2/edit?js,output
&gt; Anything you'd do differently? To answer that question, yes, I would probably do it like this: var map = function(f, xs) { if (!xs.length) return [] return [f(xs[0])].concat(map(f, xs.slice(1))) } var apply = function(ctor) { return function(as) { return new (ctor.bind.apply(ctor, [null].concat(as))) } } Or in ES6: let apply = ctor =&gt; as =&gt; new ctor(...as) let map = (f, [x, ...xs]) =&gt; x==null ? [] : [f(x), ...map(f, xs)] I would consider using the native `map` to be acceptable. 
Nice! I'll have to try that out. 
Closures are pretty crucial to writing good JavaScript. You should definitely reconsider your stance on them.
Bind is also useful for creating functions new functions with arguments already applied. Even if you're not using this, you can use bind. The first parameter is the value of this but if your function doesn't use it you can pass null or whatever you'd like. I use bind a lot to make little helper callbacks so I don't have to use the anonymous functions all the time. Not essential but I like the style.
then yet again, this questions is just something anyone can memorize and make a good impression
I'm with you to an extent, as soon as I have to write two bind methods I might as well just use var that, but I think it's important to understand that both are options. I tend to think of bind as the "right" way and that = this as the party trick to save me repeated binds. 
You wouldn't happen to have a blog post explaining how you work around them? 
What exactly are you shaking your head about? 
Can you post any sample code of the bind helpers?
Ah the good old ```apply``` vs ```call```. I really doubt that it will say anything about your skill. That said I felt the questions were easy, and it's a 10 minute read if you don't know about the questions.
I assume this would be useful for scrapping webpages too right?
Yes, that is essentially my use case.
Yeah. Actions (past experiences) speak louder then words.
How long do you use JS?
I'd also ask about ES6 and other compile-to-JS languages too.
I agree. Maybe for quite a senior position you want to ask a few like this to make sure they have some experience. But otherwise, even if you tell them what the function does and then get them to demonstrate use I think that's more useful. The number of interview questions I've failed before for "travia - what does this obscure feature most people have never heard of do" seem really pointless. You know it or you don't. If you tell me what it does I could demonstrate a good use of it and that shows real learning and skill rather than memorizing trivia
I asked all about this in interviews, the problem was that we could not find applicants that could answer them in depth. It was really strange to see that most of the applicants for a JavaScript position were not able to explain what this function will log, and how you can call the function to log something different: function test(){ console.log(this); } 
pathetic
It's great for promise situations `getItems().then(console.log.bind(console));`
By choosing not to.
Actually, photoswipe doesn't have any dependencies. As long as you have a link to the images you want to display, you can work with photoswipe. Check out: http://photoswipe.com/documentation/getting-started.html. It should show it a step by step on how to add photoswipe into your homepage.
One and a half year. I've had problems with DOM, sure, never with javascript itself. Javascript is really fast on modern browsers.
These are good questions because they get to the real question which is, do you really know JavaScript or do you know what you learned 10 years ago and copypasta the rest? I always ask them to "Describe JavaScript in 1 sentence". Really what I am looking for is any concise explanation that will naturally lead to more questions.
&gt; Can you explain how closures work to me? &gt; This is a great question to ask programmers that claim to be experienced in general, but not with JavaScript. Closures are a general programming concept that is extraordinarily important in JavaScript. Finally my degree is paying off! Having graduated from a top computer science university, I know that this is complete bullshit. I haven't heard of closures until years into my JavaScript experience.
I'm relieved. I was not sure if I need to do the steps in the documentation *on the garget machine* (und thus need a terminal server, or root server, is nothing is installed..) or just anywhere. Thanks so far. I'll se what I can do :).
Ah i see, i guess my library is similiar in one aspect. When a function is executed and the device doesnt support threads it falls back to doing async operations on the main thread
All I'm saying is it's yet to happen : )
Maybe docs need to drive a little more attention to it. There is a section for that use case: http://brianium.github.io/watermarkjs/uploading.html
There's half a dozen languages that can be compiled into javascript, you'd evaluate my java knowledge for a javascript position?
I have not used Ember (only researched it some) so I'm probably not in a position to answer but this is the Internet so... Size is really off putting for some and less so for others. If you are building some kind of enterprise application primarily aimed at desktop users then it is not very much at all. If you are a start up that is trying to sell things to new users, then sure every kb might count. And one reason for selecting it is that it is pretty opinionated and they try to have a reasonable and stable upgrade path (now at least). So if you like its opinions more than Angular's and want something more structured than Backbone then I think it could be a nice choice.
Hey guys! This is weekly newsletter I started recently. Feel free to subscribe (https://www.getrevue.co/profile/janis_t) if you like it.
You could probably spend days trying to optimize the way you are querying DOM elements, and it would have zero impact on your site's performance. :) Don't prematurely optimize, it is usually a big waste of time. 
&gt; If I were to create a function or class with a private variable in it, and one with a public variable, what would that look like? Wait, how can a private variable be done? You can do it as a "static" variable for all instances of a class, but each object can't have its own private variable. Typically i might use the _ prefix, but it's not actually private. Please show me how if I'm wrong :)
Thanks! Oh, nice! I'm still pretty much a novice... I've come across the concept of ternary operators and have seen them in some code, but I don't really know much about them. Will look in to them. Thanks!
I honestly thought it was broken until I saw your comment. Brutal!
I'm just glad it wasn't one of those slideshows where you have to press right, right, down, down, down down, right, right.
* If you were to get rid of one state in the US, which would it be and why? * Name three previous Nobel Prize Winners. * What's your favorite song? Perform it for us now. * On a scale from one to ten, rate me as an interviewer. * Who is your favorite Disney Princess?
I'm not sure I fully understand the uses for call/apply/bind or how they are better than other ways of doing the same thing. If "this" is sometimes not going to be the object that calls the function, why bother using "this" at all? Why not just pass a variable and sometimes that variable is the object that would be "this" and other times it's some other object? What's the advantage? I can kind of see the helpfulness with borrowing functions, but again, to me if the function uses "this", it's meant to apply to the calling object and if you're having to rebind "this", you're not using the function as intended - which might be the whole point? And the whole thing with apply being able to make functions with a variable number of arguments... Why not just have an array as your function argument and have the function parse out the array as necessary? I'm hoping I'm missing something really major here cause it's not clicking.
Look forward to it ;)
I recall there being a number of snow/rain effects people put a lot of time into. I don't have any libraries I'd personally endorse but a quick google search for "javascript snow" will give some options. About the only thing I've made for purely novelty that's easy to share it something I call "seizure mode": window.setInterval(function(){var x,r=[];for(x=0;x&lt;3;x++)r.push(Math.round(Math.random()*255));document.body.style.backgroundColor="rgb("+r.join(",")+")";},34);
&gt; The judgement which can be derived from these questions is really binary "is X at the level that he has written his own library" Hasn't every programmer written their own libraries? &gt; But there's going to be huge need for js programmers bellow that level There is? I can answer those questions and I consider myself to be fairly average. I don't even write that much JS. I just spent a few hours here and there to actually learn the language. Everyone can do that. If you actually do use the language, I recommend to spend a few days on learning about everything the language has to offer.
Most of mine have had to do with very large complex data sets. Traversing the array and subsequent nested arrays can get extremely slow if you're not careful about things like caching your array lengths it's a small thing but can really add up. take a look at [this jsperf](http://jsperf.com/loops/70) for some loop examples
No question about writing testable code?
I did some Googling for "webmaster scripts" and found some really old stuff: http://www.leejoo.nl/java/buttonz/verlegen_button.htm, http://www.leejoo.nl/java/buttonz/vergroten.htm &amp; https://www.hscripts.com/scripts/JavaScript/index.php
I think the point of the questions in the article is to separate the jQuery developers from the JavaScript developers.
I agree with you. It wasn't clear to me either when I was trying to get my head around this. I'll try to address some things that might help click this entire thing into place. &gt; If "this" is sometimes not going to be the object that calls the function, why bother using "this" at all? Mostly because we can't really guarantee every object having every method ever! Think of things like `NodeLists` in the DOM. Let's say you want to get all the `divs` in your page. So, you write `var divs = document.querySelectorAll('div');`. But you also want to loop through all of them, filter the ones with the class `image-container`, and add a new event listener for them. But you can't really use `Array` methods despite the fact that `NodeList` objects are array-like objects. So, you can borrow the `.filter` and `.forEach` methods to do your deed. i.e: `//Please ignore the poor code format but I wanted to show that you can do this in a one-liner/functional programy way` [].filter.call(document.querySelect('div'), function(el) { return el.className === "image-container" }).forEach(function(el){ return el.addEventListener('click', function(){ console.log("Got it!") }) }) As you can notice from above, it can get pretty complicated if you want to create a local method for each object (code bloat and gets expensive pretty quickly). Sometimes, it's just easier to borrow things from other methods and knowing that you can do so makes it a walk in a park when thinking through things. It's actually one of the fundamental parts of functional programming. It's what I find exciting working with JS. I just think about what I want to do and implement it without a serious concern of how my objects need to be structured. You can honestly do **A LOT** when you familiarize yourself with the native methods. &gt; Why not just pass a variable and sometimes that variable is the object that would be "this" and other times it's some other object? There's that trick when passing around objects that ends up doing things like `var that = this`. The problem with this trick, is that it can quickly lead to memory leaks. You leave references to objects everywhere around your codebase. However, when using things like `.bind`, `.call` &amp; `.apply` you avoid all of those pitfalls. Just like above, getting used to them removes the hang-ups/worries while you just focus on the primary task. &gt; I can kind of see the helpfulness with borrowing functions, but again, to me if the function uses "this", it's meant to apply to the calling object and if you're having to rebind "this", you're not using the function as intended - which might be the whole point? Isn't the point of functions to do one thing and do it well? If that's the case, it doesn't matter what we feed it. Either way, as long as it does its job well, we don't have to worry about it. It ties up rather nicely with the whole TDD thing. &gt; Why not just have an array as your function argument and have the function parse out the array as necessary? Because that's verbose and unclear. It would involve using `for(var i = 0; i&lt; arguments.length, i++){...}` loops all over the place. Sure, it works for the first time you write it. Probably even faster, if it's a concern. But think about doing multiple operations like I did above with the divs. In each borrowed function, several things are happening: (a)You understand that I'm borrowing a function from `Array.prototype` (b)You understand what comes out of `.filter` (i.e: an array) (c) You understand that `.forEach` performs an operation to all filtered elements. If you had to read that code (and are aware what `.filter` and `.forEach` do), you go straight ahead and concentrate on the callbacks passed in those two functions to understand the criteria for `filter` and what happens to the returned elements. That is nearly impossible to achieve with just `for(){...}` loops. You'd have to add comments, extra code to filter, then extra code to do stuff to the filtered objects etc etc. The point being, it adds up. It's unclear and non-reusable. Remember, the point is about focusing on the task at hand while making sure the next guy or future you doesn't struggle to comprehend the logic around it. This is a really trivial example, but it can get super helpful for when you aren't sure what's the context of an operation. Remember the `setTimeout` example that people use as an interview question (fix this to log `i` from 0 to 9)? for (var i = 0; i&lt; 10; i++){ setTimeout(function(){console.log(i)}, 1000) } This can just as easily be fixed by: for (var i = 0; i&lt; 10; i++){ setTimeout(console.log.bind(console, i), 1000) } See how readable that is?
Here are some free ones. Some for newbies and some more advanced. http://tutorialzine.com/2015/05/15-awesome-and-free-javascript-books/ 
My favourite [Functional JavaScript](http://shop.oreilly.com/product/0636920028857.do) by Michael Fogus
Yeah drawing on canvas :). So no need for CSS animations. &gt; Also, for the new me.Vector2d(x,y), I would try caching the function me.Vector2d to avoid recalling it over and over but I'm not really sure whether that would do much. Maybe look into the implementation of the constructor function itself. That's effectively what i'm doing. Here's the actual code in case you're curious: https://github.com/agmcleod/snowballeffect/blob/master/js/sprites/environment_object.js#L13 creates the array. Then updates the points: https://github.com/agmcleod/snowballeffect/blob/master/js/sprites/environment_object.js#L51
&gt; closures sound amazing, I'll have to try them the next time I need a variable like that. Read about functional programming (or you [can watch this video](https://www.youtube.com/watch?v=m3svKOdZijA) for some inspiration). It's so addicting when you get used to it. Plus, if you're into node, then they're totally unavoidable. However, they can lead to some of the most annoying memory leaks in existence. So, you need some care when messing about with them (cleaning out any references and such). var myObj = function(x){ var y = 0; return function(x){ this.x = x; this.__y = ++y; } } var MyObj = myObj(); var obj = new MyObj(2); var obj1 = new MyObj(2); var obj2 = new MyObj(2); obj2.__y // 3 - You can now keep track of how many objects you've create, etc. &amp;nbsp; ` .bind(null, test)()` is a bit unclear. Sometimes, you want to differentiate between calling something and just returning a function to call later. 
For these: https://github.com/agmcleod/snowballeffect/blob/master/js/sprites/environment_object.js#L51-L52 Why not reference the same object? (this might change later, so I'm not sure!) Also: https://github.com/agmcleod/snowballeffect/blob/master/js/sprites/environment_object.js#L56-L64 Wouldn't a bind be more efficient somewhere in there?
This seems wonky, but as far as I know; it is the officially proposed way to do private methods and properties in ES6. const privateFunctionName = Symbol(); // Scoped to the file, so it's technically "private" class SomeClass { constructor() { // Private properties in ES6 Object.defineProperties( // Can't define private properties any other way. this, { _privateProperty: { // Some teams use underscores, some do not. enumerable: false, writable: true } } ); } [privateFunctionName]() { // Use symbol as a computed property so that it is only accessible via the file that has the privateFunctionName Symbol inside of it. } }
Most excellent trolling. Not advanced, but certainly solid intermediate skills. Bravo!
We require bind with ES6 somewhat often, as it has heavy use of `this` inside of class definitions and it is sometimes necessary to set the context of `this` to something else.
At one point in time, "mouse followers" were all the rage. [Stuff like this](http://www.javascriptkit.com/script/script2/cursortrail.shtml)which happens to be on a site where you can find [a lot of that silliness](http://www.javascriptkit.com/cutpastejava.shtml). A couple others... [This one](http://javascript-fx.com/index.php?page=scripts) seems to have, along with other stuff, [a springy mouse trail](http://javascript-fx.com/mouse_trail/spring/demo.html) which was like the climax in the evolution of mouse trails xD [Dynamic Drive](http://www.dynamicdrive.com/), which I'm surprised still exists, still has scripts with explanations like "while this script works in both IE5+ and NS6+, it may run awkwardly in the later" xD [A ticker! Wow](http://www.dynamicdrive.com/dynamicindex2/mikescroll.htm) 
I almost never use **this** because it produces shit code. As a result I would provide weak answers to the first three questions. This means I am really bad at OOP, but has no bearing on my ability to program JavaScript. When interviewers cannot tell the difference between OOP and programming generally I try to educate them. If I don't get the job for this reason then such a company is probably not some place I would want to work.
Psh. The microlibrary utopia won't be reached until each unicode character is its own module.
I'm sorry to hear of your observations passing, my condolences. It was a good observation. 
 b@x200s:~/git$ cd PhotoSwipe &amp;&amp; npm install node-sass@3.1.1 install /home/b/git/PhotoSwipe/node_modules/grunt-sass/node_modules/node-sass node scripts/install.js sh: 1: node: not found npm WARN This failure might be due to the use of legacy binary "node" npm WARN For further explanations, please read /usr/share/doc/nodejs/README.Debian npm ERR! node-sass@3.1.1 install: `node scripts/install.js` npm ERR! Exit status 127 npm ERR! npm ERR! Failed at the node-sass@3.1.1 install script. npm ERR! This is most likely a problem with the node-sass package, npm ERR! not with npm itself. npm ERR! Tell the author that this fails on your system: npm ERR! node scripts/install.js npm ERR! You can get their info via: npm ERR! npm owner ls node-sass npm ERR! There is likely additional logging output above. npm ERR! System Linux 3.16.0-4-amd64 npm ERR! command "/usr/bin/nodejs" "/usr/bin/npm" "install" npm ERR! cwd /home/b/git/PhotoSwipe npm ERR! node -v v0.10.29 npm ERR! npm -v 1.4.21 npm ERR! code ELIFECYCLE npm ERR! npm ERR! Additional logging details can be found in: npm ERR! /home/b/git/PhotoSwipe/npm-debug.log npm ERR! not ok code 0 b@x200s:~/git/PhotoSwipe$ In think I installed requirements stated in the readme: [Node.js](http://nodejs.org/), [Grunt.js](https://github.com/cowboy/grunt), [Ruby](http://www.ruby-lang.org/) and [Jekyll](https://github.com/mojombo/jekyll/) everything but grunt I could install via apt-get (debian jessy). Grunt: b@x200s:~/git/photoswipe$ npm install grunt@0.4 --save-dev grunt@0.4.5 node_modules/grunt ├── which@1.0.9 ├── dateformat@1.0.2-1.2.3 ├── eventemitter2@0.4.14 ├── getobject@0.1.0 ├── rimraf@2.2.8 ├── colors@0.6.2 ├── async@0.1.22 ├── grunt-legacy-util@0.2.0 ├── hooker@0.2.3 ├── exit@0.1.2 ├── nopt@1.0.10 (abbrev@1.0.5) ├── lodash@0.9.2 ├── minimatch@0.2.14 (sigmund@1.0.0, lru-cache@2.6.3) ├── coffee-script@1.3.3 ├── glob@3.1.21 (inherits@1.0.0, graceful-fs@1.2.3) ├── underscore.string@2.2.1 ├── iconv-lite@0.2.11 ├── findup-sync@0.1.3 (glob@3.2.11, lodash@2.4.2) ├── js-yaml@2.0.5 (esprima@1.0.4, argparse@0.1.16) └── grunt-legacy-log@0.1.1 (underscore.string@2.3.3, lodash@2.4.2) b@x200s:~/git/photoswipe$ Obvioulsy I have installed npm. 
My fave 3 js books are JavaScript - The Good Parts, which is slim but meaty, Object Oriented JavaScript, which is the best intro, and JavaScript - The Definitive Guide, which is a great reference.
&gt; If a function is private, there is no reason to put it on the prototype at all. Just define it in module scope. After discussing it with my team, we agree that this is possible, but then you'd have to run a .bind for context each call, to get "this" to be the instance. Having private functions setup via computed properties and symbols preserves all of the correct context, which ultimately results in more readable code for us. &gt; private props can be stored easily in a weakmap to keep them off the instance object. The only real issue with this, is that weakmaps conflict slightly with ES6 class definitions in that we must instantiate the weakmap within the `constructor` method, which then necessitates that we put the weakmap onto something like this._weakmap in order for other methods to have access to it. This can be overcome by abandoning ES6 class sugar, but that sugar has proved to be too streamlining to our development to let go of, just to avoid having private properties on the prototype.
http://www.lissaexplains.com/ &lt;-- filled with good late 90's hacks and gimmicks. On a personal note this site basically was the start of my career in web development. Oh memories!
You can right-click the back button if you want to speed this up.
It seems to me that it wouldn't take much to modify this code to provide a "bolt-on" real REST API for an existing non-restful system. Just take the db.json and map the routes to real .PHP files and arguments (PHP, just for example). This seems pretty lightweight too so I can't imagine it would add much of a scalability issue.
1. Definitely could be slimmed down to do it. Adjust the bezier curve to just use point 0. It just happened to be the 4 values i arrived at after a bunch of tweaking. 2. Could be, though I think bind would look a little nuts inside the chained functions :). I think it looks cleaner now than it would with bind.
Word of advice if you care so much about votes: talking about it will make it worse 
Would rather have video of the preso.... anyone got that?
jQuery falls back to querySelectorAll in many cases. The performance of the query method doesn't really matter, but the complexity of your selector does. `$("#foo")` is way faster than `$(".foo span.bar div[data-asdf='baz'] .bar:nth-child(5)")`.
Awesome post! Thought it was really cool that the author referenced Miklos Bona, he was actually my neighbor growing up.
"Created with &lt;3" is becoming the new cringeworthy footer note of our generation
Google dhtml - dynamic html is what these effects were initially refereed to as
Graduated CompSci in 2000 and been using JavaScript heavily since then. In the first few years JavaScript resources were very poor. The only book I used regularly was Flanagan's JavaScript, and I do not remember it mentioning closures at all in the first edition. I still have it somewhere, I'll check when I dig it up.
1. Javascript is not Java 1. That looks a lot like an exam question, this isn't really a place for that. 1. The [JavaDoc](https://docs.oracle.com/javase/8/docs/api/java/util/StringTokenizer.html) for the class has your answer if you can extrapolate.
This site has a pretty long list of free JS books, include advanced topics: http://jsbooks.revolunet.com/ From that list you have: * [Design patterns](http://www.addyosmani.com/resources/essentialjsdesignpatterns/book) * [Dom](http://domenlightenment.com/) * [Let's build a Framework](https://s3.amazonaws.com/dailyjs/files/build-a-javascript-framework.pdf) * [ECMAscript spec](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) Profiling the web stuff recommended by Paul Irish: [this sfgate.com devtools perf walkthrough](https://docs.google.com/a/chromium.org/document/d/1viSX0vNYPeDB9iWLaOyAg6Fa6u0gufVB4lmbcrWhYSM/edit), [jankfree.org](http://jankfree.org), Addy's [brand new DevTools talk](https://speakerdeck.com/addyosmani/devtools-state-of-the-union-2015), [Web Fundamentals critical rendering path](https://developers.google.com/web/fundamentals/performance/index?hl=en) covers modern pageload profiling, [High Performance Animations](http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/) is a classic, and [the](http://www.html5rocks.com/en/features/performance)[se](http://www.html5rocks.com/en/search?q=performance) pages on H5R are ok.
Yes, the good old days, I remember them well. Still I find it curious you never heard of closures before then, it's a fairly fundamental concept that dates back to the 60s. It's true though that dynamic languages like Python, JS, etc weren't as popular and there wasn't as much information to go around.
java != javascript
We stated on this one but ended up going to https://github.com/basicallydan/interfake because it allows you to define your urls.
You can represent a *property of an object* by name with a string (`var str = "width"; console.log(image[str]);`) but not a variable by name. At least, not without `eval`, so essentially you can't. I assume x-skeww's answer (`let bar = foo;`) is what you want.
The SO link? I looked at it. The topic of logic in templates is hotly debated. http://www.boronine.com/2012/09/07/Cult-Of-Logic-less-Templates/ and http://www.ebaytechblog.com/2012/10/01/the-case-against-logic-less-templates/ Besides, the SO topic refers to *templates*. React doesn't have templates. https://www.youtube.com/watch?v=x7cQ3mrcKaY &gt; Right, which is why I prefaced my comment. The author clearly doesn't understand all of the technology involved well enough to make the claims he is making. It's a small nitpick. It doesn't mean he doesn't understand the relevant technology.
Having used both Angular and React, I am finding the React/Flux paradigm much more intuitive and easy to visualize in my mind. I'm coding faster, making less mistakes, and everything is nice and modular. Big fan.
I can see that being a problem in some cases, but of the 4 "can you explain/do you understand" questions in this article, 1, 2, and 3 reference specific methods. *bind*, *call*, *apply*, *map*. There's no confusing them, that's what they're called. The last "do you understand" question is about closures, which I don't even know a pseudonym for. Even if there is one, I don't think it's a stretch to call closure the ubiquitous descriptor for that technique.
I don't mean to pick on you, but I find this comment kind of funny - you're simultaneously (seemingly) defending Angular by saying it allows you to put logic in templates, while also saying it's wrong to put logic in templates. The whole "no-logic-in-the-view-layer" mantra which has been repeated as a "best practice" for years has, IMHO, been abused way beyond its intentions. I'd love to see an example of any reasonably-complicated app without *any* logic in the display layer. After a decade working for several web companies on apps of various sizes, I can comfortably say they don't (or rarely) exist in the real world. The fact of the matter is that there are at least two types of "logic" in an app. What I will call "business logic" encompasses rules like "a user model has an addFriend method which adds other user models to the given user's 'friends' array". And you're right - this kind of logic shouldn't live anywhere near the view layer, regardless of what your view layer is. But nearly every app also has a certain amount of what I'll call "display logic," which has nothing to do with the core data/app model itself, but only relates to how it's displayed on the page. This covers rules like "the friends list should be a div filled with one UserCard view for each friend, *unless* the user has no friends, in which case a span that says 'no friends found' should be displayed." React's philosophy is that this logic should be expressed in plain-old-Javascript rather than forcing it into a template language which only contains a subset of this functionality, and which requires learning an entirely new API (you're right, Angular has filter, but why should I have to learn their syntax when JS has it built in?). After ~9 months of playing with React and ~a year before that using Backbone with a similar philosophy, I'd say it's one I agree with wholeheartedly.
Been experimenting with React a fair bit, the main thing that gets me so far is that because everything follows the "unidirectional flow of data" (which I like), you have to have some sort of event handler in a lower level component you end up creating a series of handlers to call further up the chain to actually have an effect at the top component which is then "pushed down". This seems like a lot of extra handlers/callers that I don't miss from the Backbone/Marionette days. Am I not using this correctly or is this just "how it is"?
That is a problem, yeah. A lot of this can be fixed by using the Flux pattern, but it can still be an issue. I believe a new feature called 'contexts' are coming to React which should further mitigate this.
Yes, that's correct. I have a similar problem with a modal...in order to "close" the modal, I need to pass a callback down 4 or 5 levels to trigger it from the child component. Contexts are great! For /u/jellatin , if you're not familiar they are undocumented but are committed to by the React team so safe to use. Essentially you do this: In the root component where you'd have the callback, you do this: childContextTypes: { someProp: React.PropTypes.&lt;whatever&gt; }, getChildContext: function() { return {Whatever...could be a callback} } Then, in the child component 5 or 6 levels down or whatever, you can do this: contextTypes: { someProp: React.PropTypes.&lt;whatever&gt; } Then you can access it in the child component with this.context.someProp Super useful! Edit: I should also mention like /u/cgaudreau said that if you're using Flux, needing to pass down handlers should be a rareish case (from my experience). For example if you need to pass data back up and have it bubble down, that's a perfect example of updating state. You fire off an action at the lower component, it goes and does whatever, updates the store, the store emits a change, the root component is listening and picks up the change, and then propagates the new information down through the tree via props. The only time you really need to pass stuff back up through is if you're not using a store or if it's somewhat transient and wouldn't make sense to (a modal being open/closed, something changing in a form, etc).
That's a really good one! I always think that one is array, the other isn't, but I can never remember which one. I'll have no problem from now on!
lol, that would be a great site to iframe on jQuery's homepage to show off jQuery.
I'm guessing that you cloned the repo and tried to build the scripts. You don't have to do that. In fact, you really shouldn't unless you have a reason to. Just simple copy over the js and css files from the dist folder into your website and then import them into your website. If your doing a simple static html page, its as simple as referencing the files in your index.html. If your doing something more complex, there are a bunch of tutorial videos around that can show you how to add js/css to your project. 
+1 for Allonge, that book is amazing and truly mind expanding. 
For anyone interested in using contexts - I recommend reading [this Gist](https://gist.github.com/jimfb/0eb6e61f300a8c1b2ce7) about the difference between the "owner-based" context model (the way it's implemented now) and the "parent-based" model (which will be introduced in 0.14). The difference is subtle but quite important. Unfortunately I need parent-based context for my use case, so I'll have to wait.
I'm adding "created with blind hate" to mine now. Balance things out. 
I've used var self=this a lot as well, but not that much nowadays. One cool thing with es6 (or es2015 as it's currently named) is arrow functions. They bind this for you, meaning you don't have to bother with the self=this anymore. They will be a lot easier to understand if you already know how bind works. 
I have been using Mockjax for this. It seems like the main advantage here would be the ability to actually make changes to your fake data store (which you have to code yourself into a Mockjax solution). Pretty neat. 
Interesting, thanks for your comment. Would you say your criticisms of the book are primarily the lack of depth and explanations of "why" rather than just "how" or are there inaccuracies? Can you recommend any alternative resources? 
Seems a little weird TBH. Though I really do hate using bind with passion
Calling a function in JavaScript is expensive no matter what, and a direct array access is really fast in most modern JavaScript implementations. This function would be slower, wouldn't save many bytes in file size, and the task it's supposed to accomplish isn't remotely complex.
Unfortunately there are no good alternatives on the subject of design patterns that I know of. IIRC Nicholas Zakas has a book with design patterns in the title but from the TOC I think DP was just a part of it. I haven't read it in any case, so I cannot comment. Back to Osmani's book, I'd say the main problem is one of approach. The book mostly follows the GoF patterns and tries to _translate_ some of the code to JS without even questioning if the pattern is "translatable" (i.e. if it occurs). Sometimes it also fails by presenting some subjects as patterns when they are not such (e.g. the so called "Constructor Pattern", which is just an overview on different ways to create objects in JS). Finally yes, it does get some things wrong. To pick just one other example, the whole explanation and proposed solution on the Command Pattern, one pattern that can actually apply in JS, is completely misguided and wrong (what he presents is simply not the Command Pattern at all).
A perf indicating not just that you are wrong, but that the results are all over the place and completely unpredictable by browser. http://jsperf.com/array-prototype-last The browser indicated as "Other" is IE11. The browser indicated as ... or Chrome 40 is Vivaldi prerelease.
But that has nothing to do with the language. (FYI - I'm writing tests right now, just in a language (java) I don't like)
Has a lot to do with judging a programmer. Last thing you need is someone polluting the source tree with unmaintainable junk.
I think so, and I speak as someone who hasn't touched React yet :-S
Created with less than 3 what?
This would be true except for JITs. Modern JITs have many optimizations available, including inlining of function calls in many cases. Of course, if this were added, it would be slow for a while until JITs caught up.
what i see is that in most browsers the index tests are ~10x faster with the exception of firefox 38 where they are ~1.25x faster
I promise you you will fall in love with JSX. If you design your react components right there will be no 'pollution' just clean compact components
But helps with syntax highlighting and linting in a lot of editors. Arguably a limitation of the editor.
They build prototypes with HTML/CSS, and then hand it off devs who adapt the static HTML.
So... as someone who made an app or two with Angular and sort of transitioned to Polymer, can someone explain the advantages of React? I think I understand React in principle, but it looks... uncoordinated? tangled? Am I completely incorrect in thinking Polymer has a similar goal, but a much prettier sugar layer? It seems like a more efficient blend between React and Angular.
Seriously. This site. Are you allergic to UX?
i've had designers start writing JSX just like they would edit handlebars/erb/whatever templates and then start learning some basic javascript for view code. they just might not deal with the model code.
&gt; if (this.length === 0) { &gt; return undefined; &gt; } It would return undefined anyways: &gt; [][-1] undefined For what it's worth, "first" and "last" are getters in Dart: main(){ var a = ['foo', 'bar']; print(a.first); // foo print(a.last); // bar } **Edit:** Forgot to mention that there is a semi terrible shortcut for "last", which you can use if you don't want to store some array in a temporary variable: &gt; var a = ['a','b','c'] undefined &gt; a.slice(-1)[0] "c"
It's how everything should be made. Especially code. And music!
It's not so much that I'm against coupling the two, but why not just go full javascript, why still stick with html syntax? Wouldn't something like this be way better var CommentList = React.createClass({ render: function() { var commentNodes = this.props.data.map(function (comment) { return { tagname: 'comment', author: this.author, innerText: this.text }; }); return { tagname: 'div', class: [commentList], innerText: commentNodes }; } });
Great, so continue to use the indexes then. No one would be forcing you to use part of the language you don't want to use. let callback = Array .from(arguments) .filter(x =&gt; typeof x === 'function') .last(); if (callback) { // assume last() would return null or undefined when the Array is empty // assume user doesn't expect a Promise back // etc, etc, half baked example } Are there other ways to do something like that? Of course. In fact, you may never use a method like last, but it is a method which has a natural flow to it when working with functional javascript. In fact, you could even extend `Array.prototype.last` to accept a predicate, which would cut out the need for filter entirely in this scenario. Will it make it in to the spec? Probably not. I don't think leaving functions out of javascript because calling functions is "expensive" is a good enough reason, though.
I'm guessing that you're referring to my lack of ECMA6 usage as being intermediate. Fine. I'm also guessing you don't run a large engineering organization for an Alexa 100 site with tons of JavaScript. Out there with the big boys we're all about maintainability and opening our hiring pool to those who aren't necessarily JS geeks because, yeah, we're not Google. So maybe when you grow up, if you stay in programming, and lead a team of people you'll understand why coders who always code on the edge of the language and use all its sparkly new features are a detriment to an engineering organization not a benefit. Leave that edge stuff for people in masters programs. 
Been looking at React as well as others but just cant get my head around how it would work with our app. It's a reporting tool with over 240 separate reports. Some of the reports with 50+ fields with repeating sections. these simple examples are making it hard for me to imagine translating into our app. any Suggestions. 
 Array.prototype.last = function(cb){ for(var i = this.length - 1; i &gt;= 0; i--){ if(!cb || cb(this[i], i)) return this[i]; } return undefined; };
If you can get the content from the webpage using an AJAX request, then you can traverse through it to get exactly what you want from it. You may need to use jQuery $.get() (https://api.jquery.com/jquery.get/) or plain JavaScript XmlHttpRequest (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) Both return the data of the website, you can traverse through it making it an jQuery object using the jQuery function or dollar function (http://api.jquery.com/jquery/#jQuery2) or you can parse it with plain js using DOM Parser (https://developer.mozilla.org/en-US/docs/Web/API/DOMParser). But I guess you won't be able to do it because of CORS (https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) 
have you had a problem with modules that want to build?
It should return `undefined`, because that's what JavaScript does. For reference, in Dart, you get a `RangeError` when you go out of bounds and you get a `StateError` if you try to access the first/last getters of an empty list. I prefer getting errors over JavaScript's "let's pretend nothing went wrong and let's see what happens" approach, but we're 20 years too late to fix that.
This site crashes on mobile (iPhone)
Just correcting some of your points. I don't really use either. &gt;* Is still in dev preview. It's mostly an experiment meant for possible future use. It just hit 0.9 and will hit 1.0 at Google I/O. Last I/O they addressed that it *was* an experiment and evolved to a fully supported Google product. &gt;* Isn't used in anything much at Google. I know that the newly released Google Play Music web app is built on the old 0.5 code. I'd say that's pretty darn battle tested and displays their confidence in the library.
I like it. `console.log.bind(console)` was always frustrating to write, given the duplication and obvious need to succinctly bind function references when they're passed, rather than at the eventual call-site. Using `::` seems unnatural to me, only because I read it by default as the namespace qualifier operator from C++/ES4/AS3. But I could get used to it.
Don't think of this as a replacement for function.bind -- think of this as a way to use method-style syntax without having to actually stick methods onto a prototype: https://esdiscuss.org/topic/scoped-binding-of-a-method-to-an-object
I do agree that we should wait and see its usefulness. If it turns out to be immensely useful, then I'll be all for it. If it becomes blasé, then maybe it shouldn't be in the language.
It is meant to be used as slides during a presentation. It is not a website per se. 
Well, if a module needs to build components, you'll need vcbuild -- you can get that from visual studio express. To be honest, I've never tried it from a share, but I don't see why it wouldn't work. Oh wait, are you building the node components on debian and referencing them from a share in windows? That probably won't work -- you need to rebuild for each OS I believe.
I'm quote enjoying toying with [mithril](https://lhorie.github.io/mithril/), which is a similar concept but much more minimalistic.
Yea, it builds fine -- gyp basically looks for the build system on the given platform to build C/C++ components -- make for linux-based systems and vcbuild for windows. In npm you'll typically see a bunch of yellow warnings but 9 times out of 10 it builds OK... Used to have some problems, but delete node_modules, clear cache and try again always does the trick. Biggest problem I've seen is modules that straight up do not work on Windows -- and of course, the inevitable path length problems -- in windows you can't go over some 250 characters in a path and with node modules nesting, potentially to infinity, it does crop up sometimes.
Same origin policy may stop a web page from accessing another. So if that policy stops your page you are going to have to put that code in the server side. You could look for crawler tools.
[Eloquent JavaScript](http://eloquentjavascript.net/) by Marijn Haverbeke
&gt; search engines cant always figure out how to read your page if it's rendered with javascript. They're better at it than you might think: [We Tested How Googlebot Crawls Javascript And Here’s What We Learned](http://searchengineland.com/tested-googlebot-crawls-javascript-heres-learned-220157) &gt; Server side rendering is also good for initial page load speed This alone is a great reason to do server-side rendering of JS. And don't forget that JS doesn't always work as you might expect (even when it's not turned off); errors, script hijacking, browser quirks, etc.
do you have just one environment? That's kinda the problem here... right now it's just me, but eventually there's going to be a number of people. having a consistent base would be best so something like docker containers would be better. I mean I don't want to have to install a bunch of desktops. I suppose a windows vm with a local network share would be "portable" but may wind up causing the same kinds of problems.
Just cache the result. Do your queries at the beginning and store the result in some variables. In my games, I just get the canvas element once at the very beginning and that's it. That's the only query I do. Querying the DOM is very different from matching of CSS selectors. IDs are much faster here. It's a simple lookup in a hashtable or some similar data structure. That's why it's a good idea to use IDs for JS.
I'm on mobile so I apologize for grammar and such. Right now, I'm developing games with GameClosures devkit (and in-browser IDE) to write games in JS (Phaser, mostly) and then I port them natively to iOS and Android with DevKit. I recently began using React Native which is almost as cool as React except it's not cross platform. Last summer, and for the past few weeks, I've been using Ionic to write a social app. It's definitely improved in multiple ways over the year, and paired with angular it's amazing. It also has a material design version, which is awesome. Ionic does have its downsides though, like customizing it can be terrible. Also, because it renders the apps in a WebKit wrapper, you may run into some performance issues (I did with heavy animations but nothing else). It's built on Cordova so it supports Cordovas native libraries/frameworks. What exactly do you mean run JS in an app without third party services? If you do hire a mobile developer (either native, like objectivec/Java/swift, or JS), be sure that you have a write up clearly documenting what you need, what you have done, and how you want to do it. For example, if you have to query a MySQL table be sure to include a chart of rows and columns, where each column is used, etc. Whether or not you need to write your code twice depends on the framework. Right now, React Native only has iOS support (eg class names are like 'iOS-taskbar.' When an android version is created, hopefully it will only require changing the iOS to material/android. Most JavaScript -&gt; native/app frameworks are cross platform (Cordova, and by extension, ionic go to android, ios, blackberry, and Amazon). And some advice on the server/backend: don't use PHP. Give something like node and sockets.io a try, it can be just as powerful and sticking to one language has its benefits. Good luck! 
it only took him like 7 years to write it too and I've heard bad things about it.
On the risk of getting down voted for going into discussion, are you referring to avoiding new and this and moving to factory functions as writing good JavaScript? Technically any function that's using external vars other than its arguments is a closure right? We often use bind call or apply for those but depending on the usecase we also use some externals with a closure. I'd be curious to hear how you think they are essential though? Maybe I've been missing out :) My main issue is that if you get a closure from a factory function that you can't check but can execute their methods or properties. Objects are friendlier to debug there. 
When this is needed we use our agent platform and only send messages using JSON RPC and a transport layer. It's open source if you want to check it out, evejs on npm 
F12
Still don't understand the advantage
Open up your browser's developer tools (probably F12) and open the console.
1 / 3 = 13 ?
is it still pretty common to use jQuery w/ ember?
How many times is this same message going to be rephrased and reposted?
nice1 ... ◉_◉
I don't think it's completely _bad_, but it was probably disappointing for a lot of people. A lot of that, of course, was due to the long time, but also because people were expecting a lot of it. You know, jQuery was _the_ library, it was ultra-popular and then the author starts writing a book. In the end, when it finally came out, it felt... not bad but not anything special either. It was a generic JS book, and "nothing more". People were probably expecting things like one of those "annotated jQuery source code", I guess, or John's own blog (back then he was quite active) or [stuff](http://ejohn.org/apps/learn/). When it was announced the point was ["the greatest untold JavaScript secrets"](http://ejohn.org/blog/untold-javascript-secrets), which was a lot to promise. It also felt a bit rushed. Yes, really. It felt a bit like "let's get done with this already". So it wasn't properly cleaned up. It was a book from 2008 released in 2013 and a lot of the "secrets" of 2008 were already common knowledge (or even surpassed knowledge) in 2013. This meant that the book that people were expecting was "advanced" but when it finally came out it felt at most "intermediate", and it does contain some errors. The book can still be read and it's not as bad as I make it sound. But I probably wouldn't recommend it to just anyone. You can read it and get some benefits out of it, but probably not anything in particular. I don't think someone with the intentions of OP would get what they are looking for.
[Maybe because of this](http://updates.html5rocks.com/2013/12/300ms-tap-delay-gone-away)? ### Why do clicks have a 300ms delay? If you go to a site that isn't mobile optimised, it starts zoomed out so you can see the full width of the page. To read the content, you either pinch zoom, or double-tap some content to zoom it to full-width. This double-tap is the performance killer, because with every tap we have to wait to see if it might become a double-tap, and that wait is 300ms. Here's how it plays out: - touchstart - touchend - Wait 300ms in case of another tap - click This pause applies to click events in JavaScript, but also other click-based interactions such as links and form controls. ---- If this is what you have, you can search for "tap delay 300ms" or "eliminate 300ms delay" or something similar and will find various solutions.
http://pakitgroup.info/2015/05/create-calculator-with-javascript/
Maybe I will just stick to Front-end dev until I am more comfortable.
books in general are pretty disappointing these days, at least when about javascript. Changes so fast by the time its published its obsolete.
Indeed. Since components should only contain view logic either way, the designers just need the most basic js skills, and if they lack them they can just fake it with static data until someone can come around and give them some help, so that they learn as they go along.
I'd say that you should look at every field type as a component, every section as a component with field subcomponents, etc etc. PM if you want more focused help.
Yes, sadly they are.
In a lot of what I read today I saw everyone was talking about React. It looks pretty dope. Meteor looks insanely cool to me but I need something with a little more of a guaranteed immediate future for me. Im trying to learn all I can as fast as possible reading everything I find and coding for 8 hours a day. Everything seems up in the air with Meteor, people are saying it has potential but not immediately do you agree? 
[\#95](http://www.alexa.com/siteinfo/github.com), actually. He also wrote a [couple](https://leanpub.com/javascript-allonge/) of very well regarded [books](https://leanpub.com/javascript-spessore). Which Alexa 100 site do you work for? Also, can you send a link to the books you wrote? I'm interested in having a look.
 ) &lt;---- you lost this.
This doesn't answer your question, but there's no need to reinvent the wheel: http://rezitech.github.io/syze/ .
It would be array.last instead of array.last(). Your code would stop working. Well, that's if you only check if it that property exists. If you check if it's a function, you'd overwrite it and you'd break other people's code. Either way, you'll break something. If you add something which isn't part of any standards, you aren't polyfilling it. The actual standard may use the same name for something else. So, you're only creating a potential compatibility issue. Many websites broke when Firefox started to support Array.prototype.contains, because MooTools used that for something else. ES7 had to rename this to "includes" to avoid this problem. Polyfilling is okay. Adding custom stuff isn't.
jQuery is a dependency for Ember at the moment. You can use it.
Thank you. I still need to find a champion to move this idea along, but in the mean time it is now a [strawman](https://github.com/tc39/ecma262/pull/36).
I'm still missing a React vs X comparison on a larger scale...
Controller as syntax replaces `$scope`, which is effectively deprecated. Responsible developers will avoid `$scope` at all costs.
You add a new property to the object, or increment a counter and suddenly the key has changed. Not a very good idea, unless your objects are deeply immutable. 
&gt; Controller as syntax replaces $scope, which is effectively deprecated. Source? Is, for example, [this doc](https://docs.angularjs.org/guide/controller) completely wrong? Edit: Sorry, I think misread your comment, `$scope` is not completely deprecated but useless with the Controller as syntax.
I would recommend you to use React. This is a useful boilerplate : https://www.npmjs.com/package/es6-react-boilerplate 
+1 for trying not to use jQuery. I mean jQuery is awesome and all - but given that MS is starting to pull it's head out of it's ass, I think it's time to start thinking post-jQuery
Anonymous functions are a very simple ad ubiquitous concept compared to closures, I don't see how asking for one is an alternative for an other.
There is no need to go that far. It's a bad idea but someone else reading this thread may actually learn something from it. 
I agree but I have often the feeling that people don't read entire threads :p
You are correct. Only the documentation describes them briefly. You could open an issue on GitHub or write in StackOverflow you specific question and I will do everything I can to help. :)
Thanks - makes sense, I agree with most of that. I suppose I haven't hit any of those problems. The biggest concern would be performance, but the apps I've made are not extremely large and performance has still be pretty smooth with lots of data (No need to worry about older browsers, so I can't comment on the polyfill speed!). Conceptually, Polymer feels like what React is aiming at. Or perhaps better, Polymer seems like an evolution of React. But again, I haven't used it in any sort of gigantic application - and I probably wouldn't just yet. I think the day is coming, though!
pretty sure this: ``` var life = Proxy.create({ get: function(obj,value){ return Reflect.get(obj.value); } }); ``` should be ``` var life = Proxy.create({ get: function(target, name, receiver) { return Reflect.get(target, name, receiver); } }); ``` in your last example. Reflect is also spelled incorrectly. Reflect.get takes 2 or 3 arguments: target, propertyName, [receiver].
No, you can't really do that, but you can compress the asm.js, which will reduce your file size around 7x. Luke Wagner has a program that does this packing. I'm not sure exactly how difficult it is to use, but the github repo is here: https://github.com/lukewagner/asm.js-pack
What exactly are you asking?
That works ok for small basic markup, but when you have larger more complex components markup is far more succinct than code IMO.
Or you could listen to this episode of JavaScript Jabber that Brendan Eich was on. Great episode! http://devchat.tv/js-jabber/124-jsj-the-origin-of-javascript-with-brendan-eich
&gt; Is not as widely used. React has gained incredible popularity. It has? I know developers love talking about it, but I rarely see that in the context of migrating an application to React, which is something I found far more frequent with Angular when it was the hype. Just something I've observed, curious to see if that's supported by actual numbers.
Pastebin
Yeah, that and the fact that it's being removed in Angular 2.0. Avoiding `$scope` should make migration easier.
not sure what u mean, maybe somethingl ike the old .live? //this is jquery-1.10, if older try .live() $('#product_division').on('mouseenter', '#product_price', function(e) { console.log('1') }) //this is jquery-1.10, if older try .live() $('#product_division').on('mouseout', '#product_price', function(e) { console.log('2') })
It is just going through the DOM, what do you mean by a node (still a beginner)?
Yes I know, JavaScript is what I mean.
There's a bunch of stuff in there though?
At my work each developer has a windows box. We have all our source code in version control, each dev can clone it and can do development fine. When we deploy to production -- linux boxes -- we basically take the same version controlled package, run npm install on it, grunt build and we're off to the races. I'd try to avoid over complicating things with network shares and virtual machines. Keep it simple, stupid.
With Map, you can use anything as key, not just strings. 5 and '5' are now actually different keys.
I just started this Professional JavasScript for Web Developers as per your recommendation and it's great so far, just along the lines I was looking for so thanks. the unit tests alongside every code example are a nice addition
well, every call you iterate over all (unmarked) card fields and compare the number to the one called. If it matches, mark the field. btw, you should check if the number the bingo caller calls is has already been called to avoid duplicates
Ok cool! I think Ill get pretty comfortable in front end and then dive into back end instead of trying both at once. I would love to be a full-stack developer eventually though.
True, true. You could do both.
their skeleton app is a disaster.
The whole user and key thing is basically irrelevant - it could present purely as an endpoint like //my.website.com/lambda/lgtest and your questions about DDOS protection would still stand. In fact, the other piece of the author's puzzle is that his html could be placed in S3 and fronted by Route 53 - so deployed without a single server - basically making DDOS attacks more of a billing attack.
This is pretty cool. Could be a way to offload longer running (up to 60 seconds with lambda limits) reports/data from your server. We actually have a couple heavy reports that this could be a good way to take the load off our backend. Good article.
My 5 * Explain prototypes ( OOP knowledge ) * What tools do you use to develop with ( does this person actually use dev tools, at the very least chrome dev tools ) * Do you explore or have any javascript projects outside of work ( does this person keep up with javascript frameworks and advancments ) * Explain to me how you would write a todo list application ( Get an idea of their architecture knowledge and frameworks of choice they use if any ) * Tell me what bad javascript is to you in detail ( readability, performance, etc. )
Yeah i'm getting the impression that even tho the environments may be different, `git pull` &gt; `npm install` creates a highly consistent setup, regardless of os/setup.
I was going to make a xor joke, but js doesn't have an operator for it.
Yes it does. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR
It really is a very good book. I don't remember there being unit tests with code examples. Is that with the download materials? The book will definitely elevate your understanding of JS. 
I'd also recommend [Javascript Spessore](https://leanpub.com/javascript-spessore) as well.
probably never. because by the time all the browsers agree on ES6, it will be obsolete.
what is this recent fascination with slack? I mean, I get why a company would have its employees on it, but are people really too stupid to use IRC? We have an entire network dedicated to open source irc.freenode.net
if you don't care about seo and bandwidth.
Up to browsers and if you're willing to lose potential users for a browser that takes a long time to integrate. I'd guess you'll be able to use it fairly standard in ~2 years.
I was thinking the same thing.
I imagine it will be much like css3. A lot of devs still have to support ie7 or 8, meaning css3, years after its release, is still not something you can assume everyone has. At least ES2015 has a backwards compatible option (the transpilers you mentioned). We're talking years. Things are getting better. All modern browsers have autoupdate, so we will soon get to the point were new tech can be assumed to be available, but not yet. ES2015 may even be the last major browser tech to fit in this category of slowly adopted tech. 
ES6 was feature complete last year. They already did agree on it. It's not 2007 now.
This is me being pedantic, but when did people start calling it ECMA 6 instead of ECMAScript 6? I've noticed that it's being called ECMA 6 a lot in this subreddit. Source : http://www.ecmascript.org/
All depend on your user base, some poor programmer working for big corporation will have to support IE8 for a long time.
Probably within the next 1-2 years. But to support older browsers, I imagine folks will still be transpiling for many years to come.
express is teh dankest
The ES6/ES2015 spec should be finalized [next month](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts). Browsers are already implementing some of the features, and I imagine that that will speed up after the spec is accepted. However, as a React user, I can say that it's trivial to include Babel to precompile ES6 features if you're already using Webpack or Browserify, which you should be.
Why do you capitalize files and variables?
It's the same as HTML5 being implemented, it's a spec based implementation that gets added in features, Node already has the majority of ES Next/6/2015 features (the ``--harmony`` flags, [iojs](https://iojs.org/) extends this further by automatically loading in completed/frozen features). However this works at different paces, not everyone implements it at the same time and not everyone implements it in the same way. The spec is almost completely finalized, however **that does not mean it's available everywhere** Node depends on the V8 engine to implement it for the most part, may that either be the node developers, v8 contributors or google themselves. This can happen before or after SpiderMonkey (FF), Chakra (IE9), and other stand alone ES engines like Rhino and Phantom. **tl;dr** probably 3 years, at least, you gotta remember that people were implementing ES6 as the spec was being finalized because they can cherry pick frozen sub-specs. You will be using a compiler for a **very** long time, similar to desktop developers only just now not having to worry about XP users anymore, while they're still the majority. You also have to remember that JavaScript is a cherry picked ECMAScript (while everyone lately IS trying to implement it in full), **it still is not a pure implementation**, [Mozilla and Google have added weird tibits to their engines that are unique to their JS engine, and aren't defined in ECMA](https://developer.mozilla.org/en-US/docs/tag/Non-standard)^[tests](http://kangax.github.io/compat-table/non-standard/)
[No browser supports it? Hm, strange, that's not what I remember](https://kangax.github.io/compat-table/es6/)
even better to use [JSPM](http://jspm.io/). It is much more trivial to get started with and even production workflows are simpler.
There isn't a logical XOR because you can't short-circuit with it like with logical AND and OR, so there's no point including one when it would be the same as bitwise XOR.
nope
This was my knee-jerk reaction too. But seriously, just try it.
I have followed commonmark, and while it seems nice enough, it aims to be backwards compatible with markdown, which mean most of my issues are impossible to fix. I have to be honest though, I didn't know about restructured text or asciidoc. Looking at restructured text, it looks like it's nice enough, but more complex than anything I need. I can't imagine a case where I'd need nested paragraphs, for example. There are also some pieces of syntax there which I would probably replace with other syntax. Asciidoc looks like it may be an abandoned project. I just went to the website asciidoc.org, and most of the links there are dead. That's a bad sign. In the end though, I could perfectly well have gone with restructured text or markdown. It's nice though, to be able to control the syntax such that it's exactly as I want it. I also just kinda felt like designing and implementing a markup language, and wanted to see if I could do it.
Well, i'm in too ! I didn't read prior works but i don't like how github flavored markdown handles tables so i'll invent a new one https://xkcd.com/927/ :)
I just figured somebody might be interested. I know I'm definitely not the only one who's frustrated about certain aspects of markdown. If nobody is interested, I'm sorry. However, that's what the downvote button is for.
The &lt;br&gt; newline bothers me a bit. Markdown is meant to be clear without parsing. What about something like `/ \/$/`? Edit: ignore me, can't read.
Brilliant!
While I don't necessarily disagree with you, I really want to keep the simpler &lt;br&gt;. Far too often do I see reddit comments whose formatting is completely broken because the author intended to have multiple lines, but ended up with a jumbled mess on one line.
The pop method will return the last index of an array but it also removes the index from the array.
Have you considered org-mode ?
I reviewed the project and here are my initial thoughts: * I would not even use the words *bold* and *italics* as descriptors. I would recommend using *strong* and *emphasized* instead so that the description is upon the language enhancement instead of the presentation. * Instead of reliance upon `&lt;br&gt;`, which is not semantic, why not just ignore line break rule in this case or break paragraphs into separate paragraphs? * Code blocks do not need `&lt;pre&gt;&lt;code&gt;`. `&lt;code&gt;` is sufficient. When white space preservation is a concern CSS should be used with the property: `white-space: pre`. When use of stylesheets is not available the less constructive HTML `style` attribute could be always applied to the code tag to ensure proper presentation without mutilating the HTML. Either way its an implementation detail that should be an unrelated item to language description. * HTML should always be escaped, **end of story**. Where exceptions are allowed your language becomes an irrelevant security pest. If this is not purely about language description then it is not an accessible technology and it will likely not be supported. I understand the intention may be something that is easier to use than markupdown, but it also needs to be a better technology. It could become a better technology, but right now its not. You need to understand the technical concerns of markup language design and description and stick to this is a superior way. I stating these opinions based upon some hobby work I have done in the past for markup language design: http://mailmarkup.org/mail-documentation.xsd
I think its great, good changes. It would be even greater if it had tables and github-style language selection/syntax highlighting. Of course those things make it a lot more complicated.
Do you have any experience with XML Schema? It is not just about description and validation. It is also about defining constraints, reuse, and extension. All rules must be relevant to other rules and optionally relative to all other rules. I think this awesome so far and moving in the right direction, but that it is also just the tip of the iceberg.
Thanks for this. Been using JS for many many years but it's always good to brush up on basics and fill in a few gaps. 
This language is supposed to be a language to write documents in. Adding all the capabilities of HTML would create a clusterfuck. However, if used in a context where the only person/people editing the raw document is/are trusted, it makes complete sense to let them break out into HTML. If it's say used for the admin panel of a CMS, and the client asks you to have for example an iframe on one page, or maybe have some javascript, or anything which it doesn't make sense to include in this language, you need to be able to break out and do whatever you need to do in HTML. Of course, it would make no sense allow "users" (in this context: random people who made an account with the permission to post comments or something) to write unsanitized HTML. It is however absolutely crucial to be able to do it in a context like a content management system, where there will be needs which this language can't and shouldn't cover.
Evergreen browser should support all of ES6 by the end of the year. Most of the big features were already implemented or are nearing completion.
I think for the case of italic and (to a less extend) bold, it makes more sense to use &lt;i&gt; and &lt;b&gt;. Italic and bold are part of written language, and have a meaning in grammar that was around long before the web. If you read a book or magazine, you don't see bold and italic rendered differently depending on the context. You see **bold** and *italic*. Changing the presentation to something else, would be like modifying punctuation -- it wouldn't be what the author intended. &lt;em&gt; and &lt;strong&gt; make sense only when you're not using italic or bold in the traditional way, and you really are just marking up the text semantically. The distinction may be too subtle to care about, unless you are a pedant like me. 
ah, my mistake.
I think he means that you should insert &lt;br&gt; on linebreaks, but also close/start a new &lt;p&gt; on double linebreaks.
In most cases, you are only marking the text semantically. It's only in very specialised writing that you specifically want to specify that bold characters are vectors, or that italicised names are Latin names. Even in these cases, you don't particularly care if the characters are bold, but that they are vectors, and you don't care that the names are italicised, but that they are Latin names. In these cases, what you really need is a much more complex markup language than MD or even HTML - hence why the majority of scientific writing in many fields is styled in LaTeX, where these elements can be defined semantically without worrying about their actual representation.
You should use `Array.isArray` instead of instanceof. You might also want to filter by Boolean to avoid an array of undefined: var arrayArg = [].concat(arg).filter(Boolean)
thanks ;)
Actually OP said that MD was insufficient but had not investigated other existing markups that would suit his use case. Enjoy the standard HTML rending this comment shitbucket. 
Pointing out alternative solutions, providing feedback or voicing criticism is helpful. Berating people for not volunteering their time in ways you personally approve of is not. Welcome to the bazaar, where people scratch their own itches, vote with their feet about whether a project is valuable and "just because" is a perfectly fine reason to build something. If you don't like that, pay them or otherwise convince them to make you BDFL. Until that happens, you will have to live with the fact that some of us make the wrong decisions and, say, choose upstart over systemd (or vice versa), as much as that may annoy you.
It would be nice to brainstorm about the interface for such a library and get lots of feedback before implementing yet another model library. I personally would like to see something based on levelDB :-) It can be used in the browser backed by indexDB or localStorage. It already emits "put", "del" and "batch" events. 
I included that because it seemed like common legal sounding things, but you're right that it seems a bit pretentious reading it back now. I'll change it.
Maybe you missed this part of the exchange w/ OP &gt;&gt; In the end though, I could perfectly well have gone with restructured text or markdown. It's nice though, to be able to control the syntax such that it's exactly as I want it. I also just kinda felt like designing and implementing a markup language, and wanted to see if I could do it. &gt;That's a fine task and reason to do this. Seems like you had fun working on it so that is great. I just hope you don't expect people to adopt this when more established and featureful solutions already exist. Try not to be such a smarmy douche when you are saying exactly what I already said. 
This is awesome man. While I might not agree with every point of philosophy you put into this, I honestly think that this is a job well done. Keep it up.
&gt;All files in this directory are licensed under the GNU General Public License v2. This kills the adoption rate
Nice work. I'm just not sure that saving 10kb from es5-shim is worth adding an extra layer of complexity and another failure point.
 wholeCrew = [].concat(wholeCrew); Mmm, i don't know, it looks clever, but it's not very readable. Instead i'd write it as: wholeCrew = Array.isArray(wholeCrew) ? wholeCrew : [wholeCrew]; or even Array.isArray(wholeCrew) || (wholeCrew = [wholeCrew]); it shows your intention on first glance, instead of making you parse this code in your head.
As an advocate for Single Responsibility, I very much dislike function overloading like this. It saves a few lines of code, indeed, but it proportionally increases severity of headaches when having to learn and maintain the code. Especially in Javascript where one cannot use data type definitions for function arguments. There is nothing wrong with having two functions with almost identical names; one function, "A", handling a single instance and another function, "B", handling multiple instances, which then in turn calls A for each iteration.
It isn't really a question of how many is using GPL, it's a question of you trying to create a replacement for Markdown and putting in blocks that hinders adoption. For Mortup to succeed you are banking on someone creating a LGPL (or MIT) licensed reimplementation of Mortup, but who will do that when the license compatibility with existing software is so poor? The only way for me (and others) to use this is to be fortunate enough to be working on GPL licensed code, or create a Mortup server which convert Mortup to HTML by transmitting it through HTTP.
I think this is a bad idea, because of how JIT Compilers work. You generally will want your functions written to only take a single type through each parameter, so that the JIT only has to compile it once. If you have a second type go through that function, then the first version has to be discarded, and a polymorphic (i.e. slow) version needs to be generated. In short, don't write generic functions if you intend to run them on your hot code path (what you send to requestAnimationFrame). 
I know concat can be a little slow, so I ran a perf test. Interestingly enough, throwing the ternary check into a function outperformed the ternary check itself... ??? Maybe there's some sort of optimization that occurs when the interpreter processes the code? Craziness. http://jsperf.com/convert-to-array-w-concat
&gt;However, you're right that it could be beneficial to use something like the MIT license even for the library. As I said, I agree that it could be good to use a different license. Having thought more about it since that, I'm probably going to change the license once I get home. I just disagree that nobody wants to use GPL'd code. You are of course right that it is an obstacle for some people.
Sure. But that's just not always an option. When functions start to become larger (and preferably, they should be held under 100 lines for readability and manageability reasons), functions must be split up. And "Bob's your uncle", you're forced into utilizing both behaviors. In this case, adding "[]" around the "wholeCrew" parameter for the single instance example would make 3 lines of code in the function completely obsolete. So why was this done? "For convenience" is hardly a good argument. Too much code is written in weird ways simply because "we can".
Function IsEven(number){ return number % 2 === 0}
Porque no me sirve para números negativos
When I first saw your repo I thought 'this is kind of interesting'. I also don't like how Markdown requires a line to end with two spaces for a linebreak. But when scrolling up and seeing the GPL v2 license my first thought was 'Nope! Not worth it'. Adoption == making developers lives easier, not harder, and with a GPL that means more work.
How do you want it to handle negatives?
No one commented yet that the door is being opened and closed repeatedly if you are boarding a group! Yes, this is a toy example, but what if the door is some lock on a resource? The best reason to refactor this function isn't readability, it's performance. The naive refactor is just foreaching an array with the single version, a better one actually uses economies of scale.
In my experience, most open source projects will let you help in one way or another. The fastest way to start contributing is to help with documentation writing. Everyone wants to write code but the documentation is equally important to moving the project forward. Plus its a good way to show that you know what you are talking about so that they trust you to write code that will contribute to the project. I'd recommend jumping on board with one of the javascript/ node-based CMS's. They are in their infancy and need some help growing up. http://blog.innovsystems.com/nodejs/best-nodejs-cms If that doesn't strike your fancy... go to github, look at the number of stars in decending order for javascript projects and find one that is taking pull requests. hope this helps
I want to tell me if they are even or odd but if I leave the code with no corrections it gives NaN.
The code I posted above can handle negative numbers with no problem.
Were you involved in the development of this? I'm keen to hear about the experience of developing a babel plugin. 
I have to agree with this list.
I typically don't find ternary operators as readable 
A few noobie questions: When you do something like `true || false`, are both statements evaluated or is the first one checked to be `true` and if it is, that line "stops executing"? Or are both statements evaluated regardless if the first one is true or not? Does the second statement matter at all if the first one is true? My guess is no, since `true + false === true`. Does `conditional1 || conditional2` mean "if conditional1 is false, use the value of conditional2"?
Provided the close door is actually a perf problem
Alright, I've moved the entire thing to the MIT license now.
Not all alphabets have a concept of italics (think Japanese or Hebrew), so it's helpful when your text is translated, or somebody is using something like google translate to read your page. I think it's also helpful for screen readers for those with vision impairments. We can't verbalize "italics" but a voice can give a certain *emphasis* to words. 
"Don't try to deeply understand" -- that seems strange. If you don't practice understanding things well, how will you fare on difficult problems that require you to gain that level of understanding?
Smaller functions are usually nicer, indeed. I strive to produce small functions, too. But 100 lines fit well within the height of a screen in an editor (like VIM), so that most colleges or collaborators can read it without the need for scrolling around. Even with increased font sizes for us slightly aged hackers. :)
thats meant to be the first step in the process... they are ordered I believe 
How is a factual statement trolling? Did you even bother with the followup conversation? Seriously, the code ended up being relicensed due to the input of this thread, and you think I didn't contribute positively to the conversation?
Mozilla builds the Firefox web browser, Firefox OS, and various other projects that are almost all heavily dependent on JS. Firefox, for example, has much of its front end written in JS. Firefox OS is also heavily JS-based (the Gaia apps, like the dialer, email, etc. are all JS apps). Mozilla is a non-profit dedicated to the open Web. It's a great place to have a broad impact building with and for JS and the Web. 
Wow... Incredible find!
very interesting, thanks :)
Great question. I have tried PHP, Python and JavaScript. Just earlier was my second attempt at Learn Python the Hard Way. I understand basics like strings, integers, if/else, and all this other stuff, but when I go, "Let's build something" even something simple makes me frustrated because I don't know how to put these pieces together to make anything. I don't seem to retain things, and I don't feel like I'm getting better at problem solving. I have tried a couple project tutorials, but wouldn't that just teach me one way of doing something, not how to do it myself? It's like teach a man to fish... I try to tell myself, just practice, but I get so frustrated and it becomes such a time-sink that I get demoralized. Edit: I just tried chapter 1 of A Smarter Way to Learn JavaScript and even though I knew the material, I enjoyed the practice, and I think the approach to learning is powerful. Going to proceed, wish me luck!
this is an exercise from Eloquent JavaScript. http://eloquentjavascript.net/03_functions.html#p_zxMN8E0WOI[1] To do this recursively, and thereby understand recursion better, is the goal. Efficiency is not.
Don't juggle your arguments. - It makes it more likely that you handle erroneous arguments by silently doing the wrong thing instead of throwing an error. - It is an ever-growing task. For example, ES6 is coming, what about iterables? What about array-like objects? What about array-like objects when `crewMan` is also an Array-like object? What about passing in an object to create a new crewMan? - It makes your code more complex. - The caller already knows how you should handle the arguments - you're doing work to figure out what is already known. - It doesn't play nice with optimizing compilers, so this pattern cannot be used in performance-critical code. - It's ambiguous. For example, the article says nothing about what a `crewMan` is, but is apparently assuming it isn't an Array, because if it were then the function would break horribly and there would be no good way to fix it.
There's a family of languages called Lisp that is meant to work like this. It is a very cool concept. Everything is a list. A single item is a list of one. Functions and arguments get passed around as lists that resolve into other lists. JavaScript is not Lisp. It has its own paradigms and effective patterns. Using those of another language is a fun exercise, but not a recipe for good code.
Becaus the real issue is that it's a hammer. Something which has existed for quite some time. And with many smart people working on the hammer for quite sometime, there is a scarcity on how many innovations can be called novel/useful. Not saying this project couldn't be called useful for the problem domain for which it was designed but with the lack of research into what already exists in the market it is an uphill climb to make it into a good general markup tool while also being novel. Nothing wrong with that at all. Just not something likely to be widely adopted or considered much more useful to warrent inspection by useres of existing and established designs. If it brings you joy and usefulness to work on it then by all means continue. 
Take the [Learning How to Learn](https://www.coursera.org/learn/learning-how-to-learn) course and follow that up by watching [How To Learn A Language Quickly](https://www.youtube.com/watch?v=ma87XyWKeQc).
had no clue that there was a course on it... awesome
open-source components for use by biologists, awesome project that has a github "wishlist" for needed components http://biojs.net/
Hi! I don't fully understand your question, but if what you want is to have a recursive function to tell odd and even numbers apart, you might want to explore mutual recursion. I haven't tried the code below, but it should work as follows: function isEven(n) { if (n === 0) return true; else isOdd(n - 1); } function isOdd(n) { if (n === 0) return false; else isEven(n - 1); }
haha. He's right MIT is why open source exploded in recent years.
Bad idea. This interface is confusing. It's an antipattern. Do not do it.
Thanks for your response, very thorough and educational
Well I certainly didn't make it because I expected it to become widely used, so... I suppose we agree?
I agree, naming and having documentation is very important, not just having to read the code. Thanks for the information :)
I hope I didn't sound too harsh. (Don't take it personally if I did, please) Keep writing and submitting things that lead up to interesting conversation ;)
I increased my font size because im gettibg older, but also because it makes my functions smaller
Looking back, I think it's been beneficial for me to work with small snippets of code as opposed to large projects. Once you start working on large projects, you tend to move away from general programming/framework/language learning into domain specific learning, which wasn't really my primary interest. I like to learn in small bursts - for instance when I was learning about the ngModelController, I spent a quick fifteen minutes implementing a directive that worked with two-way binding. It was an ugly and worthless directive, but that was fine, because my only concern was understanding ngModelController. I redid that exercise for 3 days until I could get it working quickly without referencing the documentation. I did the same sort of thing, trying to reimplement [Crockford's Monad pattern](https://youtu.be/b0EF0VTs9Dc?t=942) without referencing the source. In a way, it's almost the same idea as a musician practicing scales, but we work with data structures and control flow instead of music.
Just think faster.
Are you studying for an interview? Do you eventually want to become a framework committer? If so, which framework? The methods are different for each of these.
I think it will be hard to beat ES6 gains. Also they could try to make JavaScript go on a diet by coming up with what they have deemed the "SoundMode". This mode would make optimizations around classes more obvious. Outside JavaScript, maybe WebGL would finally be able to prove itself. Graphics cards are a messy business that everyone is always complaining about as they have bugs and so on. Maybe with the WebGL since it would be a standard that would not change with flimsy businesses goals, platforms would finally be able to take advantage of a standard to go alongside the browser that they so adore. Also SVG is another horse worth a bet. SVG allows for zoom-able content and with the different kinds of screens it could be the one size that fits all. Java is popular. But JavaScript is trendy and unencumbered. Companies are willing to invest a ton into JavaScript just because it is _the_ standard that just won't go away. So anything could happen. For now, the transition to ES6 will be rocky, as many companies used to the Java classes will have to learn a new way to do classes. Or not, if they can change JavaScript to be more like Java. The complaints right now are that ES6 classes are slower than prototypes. With the "SoundMode" they would start to improve on that. But the costs come in less free-willy flexibility of JavaScript. :-)
Pretty sure its just written in PHP. also, Those are definitely not the only two reasons you could be downvoted.
 var iseven = function (x) { return x === 0 || !iseven(x - 1); }; console.log("is even: " + iseven(9)); EDIT: That will not handle zero or negative numbers. But this will: var iseven = function (x) { var y = Math.abs(x); return y === 0 || !iseven(y - 1); }; console.log("is even: " + iseven(-6));
This is a language property called "short-circuiting". Some languages do, Javascript does.
Thank you for such a thorough reply! I'm on mobile, so I'll keep it short. When you say `var a = 1 || 2`, is it only "1 || 2" that's being evaluated? The variable declaration isn't included? 
I'm trying to study for the stuff that hasn't been invented yet, that I'm going to have to learn in the future. Frameworks, Programming languages, Libraries, whatever it may be. To be successful at whatever it is I'm doing I expect to have to learn a lot of new things over the next 5-50 years. The idea is to shorten the time it takes to learn those things. 
How deeply do you want to learn these frameworks, programming languages, libraries, whatever? And, again, to what end? What do you define as success? Do you want to write the web framework? If so, knowing the language you want to use better is a definite requisite. Do you want to develop the next [sendmail](http://www.sendmail.org)? If so, an emphasis on reading the problems with past mailers would be useful. Do you want to develop the next [Rijndael](http://en.wikipedia.org/wiki/Rijndael) (AES)? If so, a close look at how to write secure code would be useful (and I'd suggest reading the [OpenBSD](http://www.openbsd.org) changelogs to see their audit process). You also need to figure out how you learn, by reading books, by copying code down into your editor, by answering questions, by listening to lectures, etc. and leverage that to make yourself a more effective student. tl;dr is that you need to give a better working definition of "the stuff that hasn't been invented yet, that I'm going to have to learn in the future." 
A word of warning, this can cause subtle bugs. This is just one of many examples. function add4(a) { a = a || 10; //default to 10 if no a return a + 4; } add4(0); //=&gt; 14 -- because (0 || 10) evaluates to 10 Instead, do this function add4(a) { a = (a === undefined) ? 10 : a; //default to 10 if no a return a + 4; } add4(0); //=&gt; 4 -- now it works correctly 
&gt; I think this is a bad idea, because of how JIT Compilers work. And: &gt; don't write generic functions if you intend to run them on your hot code path Don’t go together. The first statement is an “absolute,” while the second is a “qualification.” I don’t necessarily agree with this code’s choices, but similar things apply to combinator-heavy code. That can be much more flexible, with functions that are small and have a single responsibility, but it isn’t always as fast as writing fat functions that duplicate some patterns in their bodies. So it can be a trade-off: Write most of your code to be as readable/maintainable/flexible as possible, but optimize the shit out of the tight loops that actually matter for your server load or perceived performance.
The query would happen outside the component. Wherever it happens, that can push an update to the component by rerendering with new state data. Or, the components can subscribe to an event system and changes could push updates out through the event system. I have a React app that renders a single State object that has all the data that can be displayed at any one time. I have an app object that's outside of the react components. The react components can ask the App to do stuff, like fetch new data. And react components can subscribe to the App to get statechanges. I have the main component subscribed to the App. When the app's state changes, the main component gets the new state value and, in the call back from the statechange event, it calls setState with the new information. When it calls setState, react handles taking the new data and figuring out what has to change in the actual displayed content.
The thing you're talking about, i.e. higher order functions, then all of your performance gains come from (hopefully) lazy evaluation, and the dev's anonymous function itself being JITed. In that regard, yes, using forEach, reduce, etc, is a good idea. Even in a case like lodash using it's own definitions and not the native functions, the polymorphism happens on function entry, not in the inner loop. I don't think that's what the author was intending, he was talking about the interface for the dev's own function. Array.prototype.forEach got a single sentence in the article.
Okay, so I'm getting that you're looking for tangible examples. The question was designed for x^2 technology, and purposely written so that tangible examples were not the focus, but I'd be curious to see how you'd answer so here here is some practical expression of the question. How deeply do you want to learn? =&gt; Relative to the rest of the people actively using any example technology, I would say being in the top 5-10% of active users would be a good mark. And, again, to what end?=&gt; The end would of course be practical application and theoretical knowledge at the level of top practitioners.(being as good as the best) If that were current javascript- examples would be like the architects/ rockstars at companies that are top in their field. Examples of which would be Google, Oracle, Microsoft, IBM, Facebook, etc. And knowledge of the tools and frameworks they use to be able to build the things that they do. Examples of such technology in Javascript would be like: Nodejs, Angular, React, Backbone, Alloy, ionic, ember, phantomjs, etc What do you define as success? Again... being better than everyone but the top 5-10% of developers in that specific field Do you want to write the web framework? Capability to write web frameworks seems like it would fall into that category Given the previous answers how would you recommend learning the previous mentioned technologies, getting to the level of the top Developers at the top companies, in say under 2 years (or whatever denomination of time, that is significantly faster than those managed to gain that knowledge). With that answer in mind how would you apply the same process to be able to develop technologies for the following emerging fields as they develop: Quantum computing Cryptocurrency Optical computing Quantum cryptography Nanomedicines Tissue engineering Etc Given that all people learn differently. What is the closest you can come to codifying or systematizing that process? hopefully this helps clear up where I'm going.
&gt; you're looking for tangible examples No, I am looking for you to better specify metrics... What makes one in the top 5~10% of users? How do you define a "top company"? Is Google a top company? How about Twitter? Netflix? Amazon? IBM? Apple? Hewlett Packard? Oracle? Microsoft? RSA? VMWare? Goldman Sachs? The Federal Reserve? The NSA? The CIA? MI6? Mossad? Checkpoint? 
And above the page components, at the very top level, some kind of app component for switching between pages?
Yeah. Check out react-router because it enforces a good app structure. https://github.com/rackt/react-router Here's a good example: https://github.com/rackt/react-router/blob/master/examples/master-detail/app.js
Use [reflux](https://github.com/spoike/refluxjs). Your upper-level component listens to DB changes. When a lower-level component needs to change the DB (or retrieve data over the wire), it sends a message (aka action) to the Flux datastore (a model in other systems). The dataStore processes the data/AJAX, does the processing to the database (or raw JS objects if you prefer). When this is finished, it sends a message and the new data to the top-level component which then re-renders its children with the updated info. The main takeaway is: flux datastore updates --&gt; re-render top component --&gt; re-render children --&gt; trigger flux action --&gt; flux datastore updates --&gt; repeat
If you're not willing to drill down and get to the specifics of what makes a company good, what makes a developer good, what makes learning effective, etc. I can't help you. PM me, if you'd like.
You shouldn't bother making a whole new object for something so temporary. Like these ... if (!Array.isArray(wholeCrew)) { wholeCrew = [wholeCrew]; } // and later wholeCrew = [].concat(wholeCrew); You can just call the function recursively ... function board(ship, wholeCrew) { if ( Array.isArray(wholeCrew) ) { wholeCrew.forEach( board ); } else { openDoor( ship, wholeCrew ); goInside( ship, wholeCrew ); closeDoor( ship, wholeCrew ); } } A lot less wasteful.
Yours is the first post I've read which addresses the maintainability issue... I'd like to expand on that. Initially, the suggested approach is (arguably) not *that* bad... but as soon as a developer has gotten used to your functions accepting *any* reasonable parameters, then you have a problem. This function only accepts single values and arrays, but not iterables? Bug! Why can't it handle an object with the crew as properties? Bug! Why can't I just pass an array of UIDs? Bug! The function will end up as a bloody nightmare. And to keep some semblance of readability, will likely be split up into separate functions to handle each type anyway...
I have used this style in two libraries. I don't advocate it as something you should use often but it can work well in some specific cases. I've used it for a library for building HTML objects, for example ... createHTMLElement({ class: 'some-class', html: childElement }) createHTMLElement({ class: [ 'some-class', 'another-class', 'third-class' ], html: [ childElement, contentPane, someButton ] }) Internally the functions that dealt with adding the class and the html (and other components) could take arrays or individual elements. In practice the element descriptions were fairly large (this was for single-JS applications where the front end is all built in JS). The other case was for a parser framework. In both cases you would make a large JS object literals to represent your data and then throw it into a function to break it up and do stuff on it. The use case is specifically to allow an objects properties to be a single value or an array of values. I wouldn't advocate it for just general like the author suggests though. I think your code could start to feel a little ambiguous.
I'm still reading through / watching tutorial videos, but calling setState after something new (like adding a new comment) will re render the components with the new data added?
Yep. setState will apply the update. If the state has changed, it'll rerender the component to the virtual dom and then use an algorithm to determine what changes have to be made to make the actual dom look like the virtual dom. If there are no changes, it does nothing. If there are, it finds the shortest route to the destination. For my app, the post and all its comments would be in the top most parent component's State. Then that component has other components in it that take their data through props. Changing the state on the parent updates any child components that rely on props that come from that state. EDIT: some of the child components have their own state and call set state on themselves based on what they need. I have a mini gallery component that takes a set of photos, shows a few thumbnails, and you can click one to show it larger. Which one is selected I keep as state within just that component and as you click parts of the component it's running setstate on itself.
Indeed, not only does it bring confusion when maintaining the code, but you'll run I to restrictions/errors. What if you need to pass an array? What if you assume to be retrieving an array of arrays? It'll get really messy. Overloading in JavaScript (or any dynamic language I know) will cause confusion and errors. Avoid it by default.
In this simple case, you just need to put the closeDoor function outside of the forEach loop.
I could use a variety of migration tools :) On a serious note, how about a scientific library of some kind? JS is often overlooked for crunching numbers, but that leave's the door open for fresh new ideas... even if they may be borrowed from other languages.
wow. how about learn html like a real developer.
Yes, and the openDoor before the loop, as well. Then the model would line up with the story... A group goes in by opening the door, walking in as a group, then closing the door, once. 
&gt; How would you use recursion to check even or odd? Read this link! This is a better link, the one I chose seems not to work well: http://eloquentjavascript.net/03_functions.html#p_iDq2OgBOGw Base cases: 0 is even, 1 is odd. Recurrence relation: evenness(n) == evenness(n-2). From these facts, you can calculate whether any non-negative number is even or odd. OP is confused, but there *should* be recursion in the answer.
func() || func2() also only executes the first function if it returns a truthy response. proof: http://jsbin.com/zojipedave/1/edit?js,console *My original comment incorrectly stated the opposite of this, edited to avoid misleading anyone, thanks to /u/greymalik for his correction*
The main thing stunting the growth of JS in some ways is getting everyone on evergreen browsers, and having up to date JS engines on devices. I think this would be the main catalyst for an explosion of JS app capabilities. Otherwise, I'd hope to see integers and typed objects standardized and implemented by then. Rock solid, reliable support for APIs that have just been/are still being implemented (WebGL2, AudioContext, IndexedDB, WebWorkers, WebRTC, Fullscreen.) Mature web/app frameworks that aren't being re-designed every few months. A JS engine on all mainstream devices/PCs that lets you acess native APIs. Better capabilites for web apps on mobile. Eg: better UI and user awareness of 'installing' and launching web apps from homescreen, rotation control, address bar/bottom bar control, etc. I also hope to see some long-term winners of the compile-to-JS languages. Anyway that's my wishlist. I dunno how much of this will actually happen in 5 years though.
Why do you think the majority of people will only have ES5.1 browsers? With Windows 10, IE will be an 'evergreen' browser.
Actually, it's because the ternary version is deoptimized by the compiler ;) The `toArray` function is actually inlined. Anyway, check this out: http://codepen.io/anon/pen/gpMWZP?editors=110 For whatever reason, when the ternary version is compiled the JIT gets scared and tries to mess with the IR of with `[array2]`, but can't.
A drag and drop library that doesn't suck is really missing. We need a library with jQuery UI's draggable complete feature set and ease of use that plays well on mobile and supports stuff like hold to drag. Touch punch for jQuery UI is a travesty to say the least, interact js looked promising but it's too complicated and lacks in versatility and dragula although simple lacks in features. I have worked a lot with those libs the last 3 months due to a project and if anyone decided to take on that task I could help a lot both in brainstorming and UX testing and in code. 
how do i pick-up an issue?
Nah, more like the developers of the recent Javascript engine inside their Edge/Spartan browser (Chakra 2.0?) will want to push the product guys to let them write something which emulate nodejs. Would make sense, seeing as they're on a push right now to write migrate tools to get anything and everything to run on the windows platform (iOS, Android source, etc). see - http://blogs.msdn.com/b/ie/archive/2014/10/09/announcing-key-advances-to-javascript-performance-in-windows-10-technical-preview.aspx As for my predictions? ES7, signed libraries, and HTTP 2 in wide use. Javascript gains ground re: developers over Java, as Web-apps are now just as performant as Native apps for phone and desktop. 
&gt; Pretty sure its just written in PHP. Just because mod_python and Python are there, doesn't mean they are being used.
IRC is great. Slack is just shitty IRC.
How about a usable replacement for D3? I was forced to use it at work and hated every minute of it.
&gt; It does, but only in case of assignment: Technically it always does. In the case of `if (true &amp;&amp; {})`, the if-statement is implicitly converting the return value of the predicate expression (`{}`) to a boolean.
Trackira is reborn and moved away from a experimental project to a professional one, but still under development. It's coverage are now 92%, and the core changed completly. It's also plugin-friendly and let you create your own virtual node. A comment node are given as an example in the plugin folder.
Have you tried out Angular-Meteor? http://angular-meteor.com/
yeah. graphs and charts is the most common requirement.
haha, nice idea thanks
It's fine with diagrams!
I'm not really sure what that means - can you elaborate?
mixing all these different frameworks into one. like using react inside angular, or angular inside meteor. 
anything inside angular* FTFY
This will not work as you're only returning a value deep within the stack. When flowing up the call stack, you end up returning nothing.
Hm, true! I am not a JS pro BTW, but I suppose you can take advantage of techniques used in other languages for optimizing mutual recursion such as [trampolines](https://taylodl.wordpress.com/2013/06/07/functional-javascript-tail-call-optimization-and-trampolines/).
try http://c3js.org/. http://www.highcharts.com/ also has a lot of great stuff built in, including click and drag to zoom. I used to use d3 and spent so much time getting good at it that I scoffed at this stuff... but in the end the charts pretty much look the same and a lot more corner cases are handled by default. Felt stupid not to use a chart library instead. 
Standalone 2d collision library. With performance optimisations, polygons collisions and other shape collisions. 
dev is slow but isn't exactly abandoned https://github.com/masayuki0812/c3/commits/master but if the level of activity isn't where you want it to be, then don't use it. 
Sidenote, speaking of migrations, was having the same problem a month or two ago. Ended up turning into a full-featured ES6 server framework. Just submitted it to this subreddit, actually. Command line migration generation, support for table create / drop, indexing, adding, removing, altering columns... the whole nine yards. :) https://github.com/keithwhor/nodal
there was a site that has open reqs for developers to contribute -- can't remember the name of it though.
This project could benefit some help: https://github.com/telemetryapp/osmos It is, to my knowledge, one of the lightest yet smartest object-data-mapper. It has two areas of improvement: relational mapping, and a better abstraction for queries (though that could make things worse).
just trying to help, not trying invalidate your point
Thanks, I just was telling him it would be welcomed. I will probably have to learn this D3 stuff eventually. I'll have to read a ton of books then put it into practice.
&gt; I don't want to venture into "JavaScript OS" pie in the sky talk Too late. Mozilla are way ahead of you there with their FirefoxOS. 
I am not convinced that such a thing is possible. You can certainly understand things faster by understanding them more superficially but I don't think it is possible to understand them in depth without sacrificing time proportionally to the level of understanding. More time = more depth. Kind of like Blade Runner's "lightbulb which burns twice as bright, burns for half as long" so a knowledge base learned at twice the speed is half as complete. I don't think there is another way around it. The exception to the rule would be an anomaly, a savant of some kind. With software we do have an opportunity at every level to abstract away from the complexity and a *need* to understand an entire knowledge base at full depth by wrapping complexity away; automating a number of common usage cases. But the problems and their understanding do not disappear. The knowledge is no longer required in a number of cases but it is merely not required and only in those cases. The problems still exist and are there to be understood. So one could abstract away from requiring *others* to understand full depth for all tasks but not without at least that one person having a deeper understanding which, again IMO, requires time. 
I use both, but I recommend grunt for single purpose, the plugin tasks in grunt are much more mature than gulp. I ran tasks that run linting tools for js/html/css/less/... run automatic tests karma/mocha/... generate coverage, sftp build output to remote servers, package nodewebkit apps and more. with gulp it has always been hard due to the fact there are no plugins for non mainstream activities, while in grunt you can find a plugin for everything. it is not that i don't like gulp. it is very nice. just its plugins are not there yet. maybe in a year or so it will be better than grunt. who knows. for now: grunt.
"I once had a car whose speedometer would randomly move up and down, but the actual speed would never change. Can you explain this?" No. Without access to the actual code of the hitcounter, we can't tell you much of anything. It could be literally anything: poor coding of the hitcounter, intentional faking of view count, web scrapers accessing the hitcounter URL, you name it.
I mention them specifically by name in my reply right there above? 
&gt; Re: migrations, full support for them and rollbacks, along with tracking your database schema (tables, columns, indices) This one for me enough to use your framework, because even sailsjs with waterline does not provide tracking schema-db changes and generating migrations like doctrine/django orm. 
I use 'make' and I'm done with it. Works on all *nix/BSD machines without installing anything. Works with everything.
&gt; Grunt vs Gulp: Which One Should You Use? ...and then doesn't tell you which one you should use.
That's the beauty of it - it depends on you.