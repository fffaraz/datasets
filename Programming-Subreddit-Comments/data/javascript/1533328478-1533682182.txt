Interesting. Is this something you would implement in all projects?
I think the way websites / web apps are being built today- lazy loading of some form is becoming a requirement. Depending on the performance goals of the project I would certainly implement this moving forward. Maybe I would reach for an external library or something for a more comprehensive implementation- but for smaller projects your own solution is fine. 
doesn't really bother me Statements still live on their own lines Just looks like clutter, honestly
I've been using [CSS-Modules](https://github.com/css-modules/css-modules) for awhile now in combination with [React-CSS-Themr](https://github.com/FriendsOfReactJS/react-css-themr). It's not perfect, but I feel like I get enough utility and safety out of it to make it worth it. I can keep my CSS files small and focused and my components fairly portable and side-effect free. At the same time I get some flexibility in styling since I can create a default theme for my component and allow that to be changed outside of the component by passing down another module file that can override the component as needed. import React from 'react'; import PropTypes from 'prop-types'; import classNames from 'classnames'; import { themr } from 'react-css-themr'; import ButtonBase from './ButtonBase'; import defaultTheme from './buttonbase.cssmod.scss'; const LargePrimaryButton = ({ theme, ...remainingProps }) =&gt; { const classes = classNames({ [theme.large]: theme.large, [theme.primary]: theme.primary }); return &lt;ButtonBase className={ classes } { ...remainingProps } /&gt;; }; LargePrimaryButton.propTypes = { children: PropTypes.any.isRequired, isDisabled: PropTypes.bool, theme: PropTypes.any.isRequired }; export default themr('LargePrimaryButton', defaultTheme)(LargePrimaryButton); A newer alternative is [CSS-Blocks](https://css-blocks.com/). I cannot recommend it specifically because I haven't used it, but it builds off of some of the same concepts of CSS-Modules and has some extra optimizations. The code seems less readable to me, which might be why I haven't tried it out yet. 
This is my biggest pain-point with python (well, that plus code indention), and one of the many reasons I like js.
\&gt;How about using a VM that runs javascript itself in a secure sandbox? Sure, that'd work. Thanks! I'll check those two projects out.
I'd still need an interpreter, though, wouldn't I?
Hey, I'm sorry for your loss. Besides putting "elementary tutorial" in the title, I'm not sure what more I could have done to prevent this from happening. I'm new to Medium, so if you have suggestions on how to prevent someone who doesn't want to read my articles from reading them, let me know.
Use styles in plain JavaScript. It's the most straight forward and your styles are in your component, making them very portable. And you can have components take in override styles as a prop so they're customisable too. 
Ahhh this is why I love Vue. Scoped CSS blocks üëå
Why there is no Angular lib in this list?!
If you're gonna do one, you might as well do both.
I'm pretty much the same tbh, I was mainly aiming to be contrary. The only thing I'll stand behind I'd leading commas, leading commas are the shit!
The loading will still be super shit but it won't block the page at all.
This is not a JS Dev thing. This is a Dev in general thing. Me, I'll only comment something if I feel that conveying WHY it is written the way it does will benefit someone. For example, for months I kept coming back to one piece of code in my company's application that I just wanted to make better. I tried variations of the same kind of change many times, and each time the outcome was worse than doing nothing. Finally my only change was to add a comment that simply says not to try making that kind of change again, that it won't provide the benefits you might intuitively think.
Performance on mobile is pretty bad. Is this because the demo page has multiple of these buttons with effects? 
Yes was a bit slow and laggy for me. On a mid tier older android phone though which probably explains it.
I'm the same way. I'm a self-taught developer/college dropout, and I never properly learned all the algorithms and math witchcraft that you usually get from college. I've started to realize, though, that it's not that those people have a differently-wired brain and just naturally understand it better than you; it just comes down to practice. If you wrote particle generators constantly for a month, it'd be super painful at first, but over time you'd start to remember the math patterns used for them, and would start to recognize them in the wild. I've been trying to get into machine learning for over a year, and when I initially started, I felt hopeless; it was so overwhelming. But over time, I learned a bit of linear algebra, watched a ton of shit on youtube about neural networks, and I'm finally getting to the point where it's all becoming clearer to me
Your app doesnt have tests. Thats a killer. (I didnt see any terrible offender on the rest of your code)
Nice work! Reminds me of the ‚ù§Ô∏è button on Twitter.
I‚Äôm not usually one to rag on differences of opinions even it comes to code style preferences, but leading commas are atrocious.
Ah my bad, I was thinking of the case where the error property was something other than a function, like a string. But that doesn‚Äôt work in JS.
curious what people think of [https://github.com/paragonie/paseto](https://github.com/paragonie/paseto) in comparison
Farticles!
Wow. 
Hmm how does theming work? Not a great way to do sweeping changes, is there?
In the process of stripping it out entirely, in favor of using postcss variables and nested for the scss style syntax and specificity; with a single css import in the top level index.js file (Create-react-apps). There‚Äôs no real benefit in modular css approaches for these apps as they are small and will remain that way. Modules seem to be a great alternative for larger apps, though I don‚Äôt see much benefit or efficiency gainz in the class composition.
I should have been much more clear. Im sorry about that. There is a dragend event for when the mouse pointer button is lifted. https://developer.mozilla.org/en-US/docs/Web/Events/dragend 
I was kind of disappointed one of the demo buttons didn't say that.
Very good bot! Great idea, and props to the creator.
Good human.
I‚Äôm sorry for those other bots that have been forcefully programmed to betray you üò¢
Awesome list, thank you.
I feel like it's the other way around. Semicolons help the machine differentiate between statements without ambiguity, but looking at them as a human, it feels like pointless visual noise. But, to each their own and all that.
They make code harder to refractor, easier to mess up, and don't even protect you from potential issues with ASI. Semicolons are, at best, useless noise. 
Not really. If your rendering library is dictating, for example, how you are authenticating your users, or communicating with your API, then you really have serious architectural problems, other than not understand what a framework is.
It depends. If you‚Äôre doing a large project where you‚Äôll need a custom component library, styled components and emotion are great. They‚Äôll allow you to dynamically style in powerful ways However, if the project is relatively simple and you don‚Äôt think there‚Äôs much dynamic styling involved CSSM+SASS/postcss is what you should go for Other solutions just aren‚Äôt there yet and I‚Äôd recommend you avoid them. And there‚Äôs no good reason to go vanilla css instead of CSSM
For those wondering about sharing SASS variables in js, CSSM has :export() that lets you import anything inside it as object in JS files
&gt; It's really short sighted and dumb to think it has no impact. I didn't say it had no impact. What I said is that it was irrelevant when considering one or the other in the context of building a large application.
There are a couple of interactive websites like regexr.com that make this task a lot less painful.
Have we come full circle now back to the early 2000‚Äôs? Because this is the type of shit Flash developers would have been doing back then. Also, what does this have to do with React? It‚Äôs a friggin canvas animation overlay. 
also, not cascading hundreds of requests ... aka "bundling".
This is all noise. Learn what interests you or what you need for work. Get good at solving problems regardless of the language/paradigm/library.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [reactjs/react-chartjs/.../**README.md** (master ‚Üí a0f0f8f)](https://github.com/reactjs/react-chartjs/blob/a0f0f8fca0da4f5674d9173d1a290e41bb073958/README.md) ---- 
Please don‚Äôt.
Highcharts can do this for you, but it's not free: https://www.highcharts.com/docs/chart-concepts/3d-charts
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Niekes/d3-3d/.../**README.md** (master ‚Üí b2173c9)](https://github.com/Niekes/d3-3d/blob/b2173c931222b24419d1008369dff6a8bfe9e5d0/README.md) ---- 
Learn both. FP vs OOP is the one from most epic holy-wars. Just use better for your current task.
RE Styled Components: The common theme I see in pretty much every one of these threads is that the devs against styled-components: 1. Are typically using a framework, which suggests they're not actually working on anything more substantial than brochure-ware (or they've got a miracle team who's thoroughly read, understood, and unanimously agreed never to extend-upon the framework concepts/conventions). 2. Experience out of control prop-passing, which suggests a fundamental misunderstanding of how to structure not only styled-components, but large react applications in general. 3. Haven't actually _used_ them, which is surprising given that the library was developed by the same person that created css-modules, and is intended to address a bunch of the problems css-modules suffered from (c'mon, meaningful import order isn't a problem?) I'm sure I'll get a lot of flack for saying all this, so I'll try to offer some tips: - Instead of passing multiple props to make your styled components flexible, just use `extend` and create a new SC for the cases that differ! There's absolutely no need to make your SC all singing and all dancing. That there is a God component, and that's bad. - Draw clear lines of responsibility. If you can't tell what SC belongs to what, it's outgrown itself and should be refactored into smaller parcels of style. - Stop trying to write your SC as though it were scss. As soon as you treat it like SCSS you've lost a significant portion of the benefit by introducing tight-coupling, fragile class names, and nesting nightmares. - Store chunks of reusable styles as regular template strings, and conditionally render _those_ into your SC, rather than conditionally applying a style on every. single. declaration. Just to clarify, I'm not trying to downplay the value of other options, but it irks me that so many devs come out against styled components without ever actually taking the time to understand how to use them. &lt;/rant&gt;
Absolute mobile-killer for my device but I like the idea :)
With all due respect, css is made for documents, it conflicts and bleeds when applied to modules and components. Selectors, classnames and id-tags just don't scale and the hacks around it (bem, css modules, etc) are either implicit or bound to compiler-steps. You see this right away when you use react wraps around css component kits (bootstrp, material, etc), which are selector based. Now you can't nest, compose freely or slots are gettingn in your way, because css is fundamentally opposed to a component oriented architecture. Slaping it into a shadow dom or scoping its names is a band-aid. React especially is trying to not interfere with it, you use css like you always have. But because of that people are obviously seeking better solutions.
As someone who hasnt ever done web components, how does developing them compare to frameworks like react etc? 
You can't usually make and receive requests from external domains without a valid CORS header in the response. You will either need to do this outside the browser, or use JSONP, as listed here: https://jobs.github.com/api
Javascript will never be more functional than it is. Look at Haskell if you want to know what that future would look like.
How can I use jsonp on this code? what function would I append to the request? 
Besides you having a possible CORS issue, I like your fetch method. The use of the .then and going through those methods is really cool and I learnt something. Thanks. 
If you want to practice regular expressions take a look at [regex crosswords](https://regexcrossword.com). As you may guess, these are crosswords based on regex. It really helped me understand regex faster. 
I'm so bad at math that I didn't even know that there was more than one of them.
Read through the documentation on JSONP. Generally, you want a function that places your data somewhere useful and then runs a callback.
It's a React component. That's what it has to do with React.
As someone who knows React but has no idea what you're talking about, what are you talking about?
Too bad this comment isn't going to get as many upvotes as it deserves because it's nested inside a severely downvoted one.
Probably because canvas animation on mobile is still pretty iffy.
Latest node introduces full multi threading.
Ohh, sorry, Basic. 
You dont need to include the package-lock.json file to git, thats just for u
I‚Äôd say regex101.com is the best I‚Äôve come across 
Thank you very much! I‚Äôll be sure to take a look
If you are running node on your server, you can use [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware) to sidestep the cors issue.
The code itself is fine. Here‚Äôs an article on CORS: https://developers.google.com/web/ilt/pwa/working-with-the-fetch-api#cross-origin_requests TLDR: You can‚Äôt do http requests to other domains from javascript in the browser unless that domain serves the correct cross origin policy header. Solutions: - JSONP, I guess this only works if the server supports it. - Send correct header from server, again it would need to be your own server to be able to add it. - Create a server side proxy that does the request and then use that endpoint in the front end.
Yeah to be honest its not that big of a deal really. The first prod react app I worked on used a set of scss partials which lived in a separate 'styles' folder, where the folder structure matched the app &amp; component directory structures. CSS modules feel slightly nicer than that, but honestly not *that* much better. Its nice for making components more standalone, and lets say you had like a set of company branded/styled components that lived in a component library, it would theoretically be good for that.
High charts is totally 100% free for non commercial use.
Tip: Prefix each line of code with 4 spaces.
But you do not have some sweet stuff like :before/:after/:last-child/etc in that case. 
I‚Äôve been using react-chartjs-2 at work and it‚Äôs pretty straightforward. 
[Trump Trend Tool](https://hapax.bitbucket.io/trumptrendtool/)
Just make sure you indent with tabs.
[https://github.com/deep-storage/deep-storage](deep-storage) is yet another state management library for React but it's been working quite well for me (disclaimer: am author)
What are some of the things you learned?
&gt; what function would I append to the request? Any function name you like. That's what it says in the documentation. &gt; ?callback=myFunction So if you make your call with `?callback=foo` on the end, their API will send back foo( &lt;all the data here&gt; ) so if you have your function `foo` ready, your function will be fired. But the trick is, you don't make a request. You use a script tag with the URL as the `src` attribute.
&gt; Semicolons are totally useless Yea, well, I imagine Adolf Hitler had similar opinions.
Mon dieu. We're not barbarians. 
How long did it take?
https://github.com/astronomersiva/lego/issues/1
My primary interest is in implementing gatsby like lazy-image loading. I currently do this manually with &lt;img&gt; tags in markdown and it feels awkward. I am planning to add sitemap generation too. 
I spent about a week...like an hour or so every night.
How about doing a push request to fix the licensing issue in the upstream project? Or raising an issue there? For your own usage, you could include the MIT license file yourself (having made it yourself), attributing credit to the original author.
Thanks, I've read that explanation about 10 times tonight but yours was probably the best. I actually tried this many times but went to other possible ways of doing it because it wouldn't work.... But hours later, I figure out that the docs are wrong. The api actually uses &amp;callback=foo *NOT* ?callback=foo like stated. I should have checked earlier but still, pretty annoying. Here is me finally consoling some data for anyone wondering. &lt;script class="api" src="https://jobs.github.com/positions.json?description=python&amp;location=new+york&amp;callback=jsonp"&gt;&lt;/script&gt; const script = document.querySelector('.api'); function jsonp(data) { console.log(data['0'].location); }
I already created an issue, author has not responded yet. Modifying the file myself is a bit of a pin, considering i am not the only one using these files, and it is very convenient to download them from NPM. I think it might be enough that the module name is package.json
If you are absolutely certain they are always numbers as strings or empty strings... var values = [ "1", "", "5" ]; var sum = values .filter(v =&gt; v) .reduce((a, b) =&gt; parseInt(a) + parseInt(b), 0); console.log(sum);
Since you mentioned numbers instead of integers, I'de suggest using `parseFloat()` instead of `parseInt()`. And use ternary operator to check whether a value is a number or not. e.g. var values = [ "1", "", "5" ]; var sum = values.reduce((a, b, c) =&gt; (isNaN(c = parseFloat(a)) ? 0 : c) + (isNaN(c = parseFloat(b)) ? 0 : c), 0); console.log(sum); 
Thanks for suggesting mermaid. I checked it out but looks like they render from a given text block into charts. We want to be able to have our own HTML in every node. 
Not sure what you mean by switch to array. Objects and arrays a very different structures
If it's an object in itself. The below would make the Object into an array of it's entries. Object.key(res).map(key =&gt; res\[key\])
I released a complete rewrite of a web app I wrote called Astral. It pulls down your GitHub stars and lets you organize them with tags and notes. Written with Vue.js, Laravel, and TailwindCSS. You can check it out at https://astralapp.com/ and it's also [open source](https://github.com/astralapp/astral) if you'd like to contribute or install it on your own server. 
values.reduce((total, item) =&gt; total + parseInt(item, 10) || 0), 0)
Do you plan to add scss/sass or less support?
Can you specify your problem and your need of conversion? :)
The current version was heavily based on what I do with my site but yes, LESS and sass are pretty easy to implement. If you are interested in doing this, [this](https://github.com/astronomersiva/lego/blob/master/lib/tasks/copyMajorStaticAssets.js#L32) is where you might want to do it. PostCSS already has several plugins for this so this should be trivial.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [astronomersiva/lego/.../**copyMajorStaticAssets.js#L32** (master ‚Üí e8371a7)](https://github.com/astronomersiva/lego/blob/e8371a7aef093bbbc698d9170085b9f8d0c1b292/lib/tasks/copyMajorStaticAssets.js#L32) ---- 
Good bot :D
Good human.
I equate semicolons to lucky underwear and black cats.
So I'm working with something like this: Foo={} Fetch(url) Res=&gt;res.json() Foo= res (This is if the fetch returns an array, changes it to the object foo) So it makes the object accessible outside the scope of the fetch function, so I was just wondering if I can do the same thing with a fetch that returns an object, if I can turn the object into an array in the fetch response
Do share your project once it is done, I would love to take a look :) One thing is for sure, this will be a good learning experience.
Yes, that would be great!
You can loop the object and make it an array or some pseudoanswer like toArray (). I prefer objects all the way so my answer to this is a biased
I'm taking a slightly different direction, to incorporate some unnecessary things just to learn, add functionality. The premise is to take markdown files with YAML, and have react render them as HTML. I hope to add a comments system (requires a DB), and all the posts get served through an Express API so that in the future it will be easier to aggregate. I also intens to incorporate images, auto-resized by Jimp. I'll certainly share it once it's done!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [astronomersiva/ajanta-cli/.../**index.js** (master ‚Üí bf9e5cc)](https://github.com/astronomersiva/ajanta-cli/blob/bf9e5cc73384a60c47d91f6385ea7a12968cf490/index.js) ---- 
RetroMatic: Real-time Retrospectives [https://github.com/MassiveNerds/RetroMatic](https://github.com/MassiveNerds/RetroMatic) Angular 6, Angular Material, Angular Flex Layout, and Firebase
Depends on his level, it is possible. People have built awesome projects while on a flight from one state to another. Very impressive and inspiring. 
RetroMatic: Real-time Retrospectives [demo](https://retro.massivenerds.com) [https://github.com/MassiveNerds/RetroMatic](https://github.com/MassiveNerds/RetroMatic) Angular 6, Angular Material, Angular Flex Layout, and Firebase
What have you named it? 
For the video player you might take a look at: [https://www.youtube.com/watch?v=YEJBmmqXUQs&amp;list=PLNYkxOF6rcID8S0kEBuQwRyev7RgilNZF&amp;index=6](https://www.youtube.com/watch?v=YEJBmmqXUQs&amp;list=PLNYkxOF6rcID8S0kEBuQwRyev7RgilNZF&amp;index=6) With code at: [https://github.com/GoogleChromeLabs/sample-media-pwa](https://github.com/GoogleChromeLabs/sample-media-pwa) I don't think a video player should contain the monetization part. A stream should just throw an exception and the user should get redirected to a payment page.
Some time ago I wrote about how to render a webpage on either the server or the client side. The solution removes HTTP overhead on the server and hydration problems on the client. Example: [https://custom-elements-hn.now.sh/](https://custom-elements-hn.now.sh/) Write-up: [https://medium.com/@tomdezentje/progressive-enhanced-website-with-custom-elements-7b2b194b5aa9](https://medium.com/@tomdezentje/progressive-enhanced-website-with-custom-elements-7b2b194b5aa9) Code: [https://github.com/TDezentje/custom-elements-hn](https://github.com/TDezentje/custom-elements-hn)
You can use a callback as the parameter of `.setState()`: this.setState((prevState, props) =&gt; { return {counter: prevState.counter + props.step}; }); https://reactjs.org/docs/react-component.html#setstate
setState is asynchronus [https://reactjs.org/docs/react-component.html#setstate](https://reactjs.org/docs/react-component.html#setstate) `this.setState({prop: value}, () =&gt; {` `// access updated value here` `})`
How do you get it to actually generate the site? The docs say "Run lego s to run a server. Run lego to create an optimised build" but both of those things sound like what you would run after you've generated the site. 
Not once did "useless" comments have annoyed me. I find it better to over-comment than the opposite.
If you don't mind, is there any resource or tutorial to learn how to make a project like this? ( I have been learning Js, Node and React for sometime and I think this might could be good project). Thanks. 
I'm in the same boat bro, hang in there
Context is great, but if youre building anything beyond trivial apps it doesnt scale in a way that gives it an advantage over redux. Redux scales very well and even though there is boiler plate, in then end that code gives you a way to truly decouple data from views at scale, arguably the point of using it.
Loved AngularJS, then the whole Angular 2 (the duce) happened. All well, tech rolls on.
&gt; Scoped css out of the box is absolutely great. having worked in react at scale, this does sound nice.
More like 10 hours...I have done a lot of similar work already so it basically just putting together some stuff.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [astronomersiva/lego/.../**README.md** (master ‚Üí 2da84e3)](https://github.com/astronomersiva/lego/blob/2da84e30241a32518a182ab1cdca9c765372e535/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e3lwotm.)
setState can either take a function or an object, if you use a function it is guaranteed to receive the last state: setState(state =&gt; ({ count: state.count + 1 })) There's also an additional callback that pings back once the state has been merged in: setState(state =&gt; ({ ... }), () =&gt; console.log(this.state))
Care to elaborate? I prefer to toy around with vue for hobby projects, but angular 1.6 does his job for day-to-day work. We adopted angular 5 project recently and it only feels better. And anyway if you love react to the sky why not to use it? Both versions has ability to use other rendering engines 
In this case, bundling would likely be safer. If the dependencies are locked down, the user can't accidently bring in a dependency version that breaks the plugin. That will save a few steps for the user as well.
JSS is great. We had a long back and forth at work between a designer on using SASS + CSS modules vs JSS and eventually JSS won because it works so well with React component architecture. 
Using the style prop is very inefficient because it's recomputed every render. You also can't use a preprocessor or an auto-prefixer without additional dependencies. 
VS Code has good support.
i understand angular 2. but why 5 more version breaking changes in &lt; 2 years?
It's the `String` constructor. Constructors are functions, which are values / objects. Similar to `Array`.
Yeah, that makes sense.
React lets you use jsx, which combines real JavaScript with real HTML. Angular puts javascript in fake html with strings, losing much linting support and leading to a bunch of angular-specific syntax. React doesn't do nearly as much as angular but does what it does so much better. 
"So, how much do you know about (stat website gen. name)" "I wrote it!"
I use underscorejs all the time. It has handy functions for doing the black magic you need. 
It's a shame flex box fails on ie tho 
Minimally--just enough to support js in it. Still substantially less than Angular, which adds even more confusing symantics 
What breaking changes exactly? I know there were some when things went from AngularJS to Angular2+ but there really haven't been any that I've seen since. I wonder how many Angular bashers have actually given Angular a legit try (just installing the angular CLI doesn't count) before making criticisms.
i use angular 5 at work. the cli/webpack stuff is annoying.
Ohh thanks :)
Feel free to take a look at the source code on my Github: [https://github.com/tvillarete/apple-music-js](https://github.com/tvillarete/apple-music-js) I'm currently a student going into my fourth year of college, and I've taken a keen interest in frontend web development. This was one of the projects I've been working on for the past couple months to practice using Redux, which is pretty awesome! Let me know what you think, I'm open to any feedback!
It's looks great!! Congrats! You've even nailed the transitions. Great work!
Thanks! My goal was to see if you could recreate Apple's silky smooth UI, and it turns out that you can pretty much do anything Apple can do with pure CSS
It's actually just 'Angular' (and Angular 1 is AngularJs), and they keep updating it with stuff. The version number is irrelevant at this point, but its to give an indication of a bigger update
Looks like your store setup call to createStore is wrong - you're passing two different enhancers, when you need to compose them into a single enhancer. Are the docs here : https://redux.js.org/recipes/configuringyourstore
When the page first loads, it will run through the script line by line. However, you put the var damage = Math.floor(Math.random() * (max - min + 1) + min); outside of the function bodies. So whenever you call moveOne or moveTwo it will use the same value it generated. The solution would be to move the Random function inside moveOne and moveTwo so that a new number gets generated every click.
I had no idea it was wrong, thanks for the feedback! I'll take a look at the docs and make the necessary changes üëå
It will. If you use the functional form, each call runs separately. If you use the object form and multiple calls give values for the same field, only the last one wins. 
This fixed my problem, thank you very much :)
Interested in an internship? :)
Holy shit, really? Can I ask how long you've been coding (in general)?
I would, in a year from now. :) 
Very nice. I'll book mark this post. I'll look into the source code soon. Thank you for sharing! 
Very nice job on the animations
Just based on watching the video, I think your UI transition is smooth but definitely missing the bounciness. The transition Apple has I think really bring the user interaction to life. See [Designing Fluid Interfaces](https://developer.apple.com/videos/play/wwdc2018/803/) from WWDC this year. Anyway, I think this is a pretty cool project.
I think what you have is pretty close, and I wasn‚Äôt trying take a jab at you. I just thought that you might be interested in that WWDC session, since I find it pretty fascinating from a front-end‚Äôs perspective.
Interested in providing my company with your proven skillset and capabilities for a cut rate?
Very impressive. 
If you say so... I still quite dont believe until I do a test, find a doc reference or dig into the source Because there‚Äôs a second setState parameter with a callback
lol no
What does this have to do with JavaScript.
I dont know, it was in the suggested subreddit related to development in which i decided to post since maybe someone would think that they can be useful and join
Dread it. Run from it.
Why is this downvoted 
No idea why. As long as I haven't offended anyone I am good. 
You rock, dude. 
You are taking a single part of that page out of context. They are basically reserving the right to change things *if necessary* but as someone who has been using angular since beta I can say that since actual release the breaking changes have been extremely minimal. Updating to a new major version has never taken me more than an hour and for most of them it has been more like 15 minutes. If we are cherry picking quotes how about &gt;Compatiblity note: The primary goal of the backwards compatibility promise is to ensure that changes in the core framework and tooling don't break the existing ecosystem of components and applications and don't put undue upgrade/migration burden on Angular application and component authors.
Extremely minimal compared to what?
quality post!
I'ma 52 year old studying React currently and I think your project is awesome. It's inspiring me to push on through the difficult stuff I'm struggling to understand because the end results will be worth it. I'm pretty new to JS in general - I'm the old dog trying to learn new tricks :) One day... ;)
I never said Angular is better than React or Vue, just that it is undeniably better than AngulaeJS. AngularJS fucking parses the names of your function arguments to do DI! It has to run a digest cycle to do change detection! How can you argue that that is better than Angular.
No idea, most likely because it‚Äôs not from OP.
Keep at it! It gets so much easier as you continue to practice. I only started using React maybe 6 months ago, and had no experience with web development or programming before I started college (And I never even learned any web dev from college courses, it's all been through doing side projects). The key is to just make stuff. Make anything that you think sounds cool. Put in the hours and eventually it'll just click. You got this!
Hey man, that's good to know :) I downloaded your repo and thought I'd installed all the dependencies but got a weird compile error when starting the dev server: ./src/js/toolbox/components/icon/index.js Module not found: Can't resolve 'feather-icons' in 'C:\Users\Martin_Bowen\Desktop\apple-music-js-master\src\js\toolbox\components\icon' Am I missing something simple? :)
Great job man. Looks great!
Fabulous work man :) 
Compared to any other stack of the same size I've ever worked with. What do you want to compare it with, react? Well the part of angular that most closely maps to react, components, really haven't changed. The only thing I can think of offhand is the `&lt;template&gt;` element being removed from the html 5 (.1 I think? Whatever version) proposal which led to angular implementing a `&lt;ng-template&gt;` element. A find and replace fixed that. Otherwise I can't think of anything, and definitely nothing major, that has changed about how you define a chunk of js and relate it to a chunk of html. So angular's track record with regards to the same scope as react is pretty good. What else do you want to compare? Maybe the router? Ok so the angular router changed multiple times **during beta**. But since release it has been more stable than the standard react router. I know that react router isn't official, but I'm trying to compare like for like as much as possible. Angular is a much larger framework. It has a lot of parts. When you have a much broader scope then occasionally stuff might change. *None* of it has been a burden. The vast majority of changes have been solved with a find and replace. Offhand I'm having a hard time coming up with something that wasn't fixed with a find and replace other than rxjs. And rxjs isn't strictly Angular code. It's a dependency that is developed by a 3rd party. And even then the changes have been mostly around import statements and the rxjs team even releases a tool that fixed those import statements for you. Run It, run tests, oh boy it worked (I'll even admit I was sceptical but it really did work and was that easy). The other rxjs change, moving from chained functions to a pipe function, had to do with rxjs moving from relying on monkey patching to instead using a more modular design and *still* wasn't that hard. Basically instead of: obs$.map().filter().subscribe() It became obs$.pipe( map(), filter()) .subscribe() That's not even angular code. That's rxjs. Certainly there's an argument to be made over if the framework takes on the dependency then you can include changes to the dependency in the total cost of ownership for the framework. But I still didn't find it particularly burdensome. And all that happened like a year ago and since then rxjs hasn't really changed either. The vocal community is toxic to angular. And I get it to some degree. Look at my post history and you'll find me agreeing that reusing the angular name was a marketing mistake and I get why some people are angry that they felt betrayed when 1.x was all but deprecated. But the amount of hate that angular gets from people who don't even use it is ridiculous and at this point it's been literally years. I'm not even going to try to stop people from trolling with the same tired old "hurr durr a new version of angular have fun relearning everything" comments; it's not worth my time. But if anyone wants to have a real conversation about angular I'll be happy to talk about it. And the first to admit that it's not 100% roses. But imo it still brings enough compelling choices and features to the table that I think the community at large is doing itself a disservice dismissing it out of hand like it does.
Until about a week ago, I had no idea that Apple's streaming service actually had people that even used it. Then Apple had an earnings report and services (such as Apple Music) crushed it. I had no Idea these people existed so it's nice to see my investment is ok. 
I appreciate your detailed post. But it kind of illustrates my point. It's extremely minimal for a company that can afford a dedicated fullstack/angular guy. For smaller startups with &lt;= 5 engineers, that sort of maintenance overhead, while only marginally larger, causes issues.
You've already done so much for a tech demo, but adding a little bounce probably wouldn't be too difficult. Well done btw.
First, let me make this clear: my point was not everyone should use Angular. I don't want any single framework to have the lions share of the market, monopolies are bad for ecosystems. But, I don't work at a large company. And you are basically making my point for me. If you actually worked with angular regularly you would see how major versions aren't some horrible shit show of "Oh god they are breaking changes!". They are more like "oh some cool new features. Neat.". It really isn't some huge deal every time a new version is released. And support for older versions continues, they aren't just immediately discarded. The details are in that link from the parent I originally responded to. At the end of the day angular might not be the right choice for you. And I have no problem with that. But a lot of developers aren't making that choice and instead basing their decisions on troll posts and memes about angular that aren't even true.
That‚Äôs sick! 
About 5 years now. Close to three professionally. And I have written several build tools like this at work so this is something that I do often.
Fourth face: If a method of an object that is bound to a second object is called, whether as a property of the first object or not, the `this` within that method will point to the second object. e.g. var obj1 = { func1: function() { return this; } }; var obj2 = {}; console.log(obj1.func1() === obj1); //true (the first face) obj1.func2 = obj1.func1.bind(obj2); console.log(obj1.func2() === obj1); //false (not the first face) console.log(obj1.func2() === obj2); //true (the fourth face) var func3 = obj1.func2; console.log(func3() === obj2); //true 
That's sharp af. Nice job!
The level of difference is just an admission that angular 1 was shit. Everyone who invested in that ecosystem felt duped, and since a2 is so different anyway might as well as jump ship entirely.
I used React at my previous job but took a new position which uses Angular. Why do I dislike Angular? * Overengineered - way too high of a learning curve. We just hired an intern and it's going to take some time for him to learn all of the angular specific concepts. IMO, the steeper learning curve doesn't pay off with faster development compared to React. * RXJS - I can't stand RXJS. I hate the way effects look, I hate all the new terminology one must learn, I hate how overcomplicated it feels. * Bugs - We've hit several bugs with the CLI and ng build - latest was this one: https://github.com/angular/angular-cli/issues/9588 * 3rd party libraries - 10x more on React It's not the end of the world, still love the job and people but really dislike Angular relative to React. Maybe it's my brain is wired differently (well probably not, compare the popularity of the two :) )
To be fair though, AngularJS was never meant to be a framework, it was meant to be a prototyping tool.
I can‚Äôt help with that particular error, but I would highly recommend you get a Mac or Linux box if you want to start getting into development. Running Unix will make your life so much easier and will also get you used to working in a terminal.
You have our respect, bro. Keep Learning and you will find your way very soon.
I loved your work with the online windows 10 and this is even more cool!
Great job! Really impressed with the transition animations and the little details such as album artwork shrink/grown depending on play or pause. Nice work!
For the record, I would definitely pay him and offer competitive entry level salary.
Technically React does make things look nice lol I‚Äôve always been upset about the whole backgroundColor nonsense.
Uhm, React is a library, but I would not mix two different beasts into one. I bet there are lots of components out there that can support your work with React, it's better to stick to one tecnology at a time.
They run on roughly the same model. It's fine to like one or the other but having them both in the same project is going to increase your k-weight and force everybody who picks up the project in the future to learn both. Whether what you gain is worth the downsides is up to you. I don't see it but you're the one that knows the project.
I agree on this. I implemented React on most of our projects at work but before I got to my company they'd never had a dedicated Web developer before, so a lot of the legacy projects with front end user Angular because the backend leaning fullstack guys were more comfortable with the MVC-ishness of it. 
This. Ubuntu has evolved into a great operating system and is super easy to install and use. You will save yourself so much headache by running *anything* other than Windows
Thanks. They really hid that 3D chart I was looking for in the documentation. I will give it a shot. It looks cleaner than vis.js, but I can't tell yet if that's a good or bad thing.
The bigger question is how are you intending to handle synchronous writes?
Yeah, this industry is just unfortunately swamped with both good and bad internships and job listings. Reddit likes to be skeptical because of that.
No idea (yet), but it shouldn't be an issue for this since it will only be a single user.
Making this stay in place and making things ugly too.
This is amazing!
Try to use a transformation function instead of manually filling an array using a for loop. For example, in src / js / api / actions.js: const artistData = {}; for (let i in artists) { const artist = artists[i].artist; artistData[artist] = []; } Could all just be something like: const artistData = artists.map(i =&gt; {i.artist: []}); https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map If you need to get an object from the resulting array, use the Map constructor that takes a collection (Not map, I know that's confusing): const artistData = new Map(artists.map(i =&gt; {i.artist: []})); https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map Good work btw, you should get a job pretty quickly. 
If the OP is moving from React to Vue, why not? At some point you have to have both. 
I completely disagree with this advice. Nowadays, with options like cygwin or bash for Windows, you can get along just fine without any problems. Additionally, software development often goes hand in hand with consulting and consulting is littered with MS Office and then Linux starts to become a hassle. 
&gt;We have server and client file for BDO What's BDO?
If you are referencing an array multiple times, never use list.length = 0
Could do SQLite, NeDB or a couple others.
Google spreadsheets can be private, you don't have to share it...
Async is a great 0ackage. üòä
in that case it depends on how you want to structure your data.
Awesome job. Quick question, are you using the Apple Music api for the songs or something else? 
Choose the one you know. If you're building a small app, more likely than not all mature databases will be able to handle your needs well.
I'd recommend Bash for Windows as well. It works absolutely fantastic.
Is this (or will this be) up online somewhere? I use Apple music but iTunes on Windows is just blight on the very concept of software so I'd love to use a web app that just let me stream the music 
Looks great! I‚Äôm currently working on a project which might benefit from parts of this. What‚Äôs the license on your project?
Same lol always gets me
almost the same really, they both got keys and values which can be iterated - it's just the array is a list and object is a dictionary, they are very much interchangeable.
Good job man! My only critique is that it would be far nicer if you separated styled components, animations and logic into separate files and try to keep the component itself pure
Github Repo: [https://github.com/sinclairnick/juke](https://github.com/sinclairnick/juke) Please use responsibly
Feel free to give advice, code review and please use responsibly
Check if it's missing from the package.json file, he could have it installed locally and it'd not break in his machine.
Amazing work, and I don't meant to rain on your parade, but... Apple Music is already built in JS - EmberJS in fact ;) [https://www.reddit.com/r/emberjs/comments/3c42v4/built\_with\_ember\_apple\_music/](https://www.reddit.com/r/emberjs/comments/3c42v4/built_with_ember_apple_music/)
Damn that looks slick! Good job! 
RemindMe! 2days
Any idea, if it's possible to add Chromecast support?
Do you think you‚Äôre gonna add a feature where you can add to playlists. Or shuffle
You should try something in React Native. Not that browser projects aren‚Äôt cool, but mobile dev has a lot of different challenges. If you are interested in mobile, go down that path early because companies tend to want you to work on things you are experienced in rather than your primary interest. I was a front end dev for years and now work mostly on mobile, and that‚Äôs the one thing I‚Äôd change if I could go back.
Are the animations just styled-components as well?
you can do it! it's worth the investment, and the concepts apply well across different front end paradigm, JS or non
you can do it! it's worth the investment, and the concepts apply well across different front end paradigm, JS or non
Do you care to keep the object keys? Also the order of the values is not guaranteed.
he supplied me with some inspiration
Dude this is amazing! What would you do differently if you started all over again? 
This is a cool project, I really like the idea.
May I ask how you make the smooth transition animation between pages?
Definitely understand where you‚Äôre coming from, AngularJS was definitely nice at the time. Hard to go back to it now
I hate when I do that. There are certain libraries I get so used to using, I install them globally. Then I'll forget it's a dependency of the project I'm working on, and freak out when it won't work on a different machine. Ugh.
This is a bit smelly, but because functions are first-class objects in JS, you can add anything you want to them, including other functions. function api() { console.log("default action"); } api.get = function () { console.log("get action"); } api.post = function () { console.log("post action"); } An alternative, which follows the general shape I think you have in mind here, is this: const api = (params={}) =&gt; { function get() { console.log("GET", params); } function post() { console.log("POST", params); } switch(params.method) { case 'get': return get(); case 'post': return post(); default: return get(); } } 
Thank you **very** much for answering. So, I was able to get this working by using the function argument but I can't help feel its a bit of a hack. It seems I'm basically forcing my react component to disregard any batch process that would allow it to run more efficiently. I also don't understand why a batch process that touches two different parts of my state doesn' just work, although I'm wondering if it has to do with how deeply nested my state is. Actually, thinking about it a little more i bet this is it, but I'd like to see what you think. I simplified the example I gave initially but my state actually looks a bit more like this: ```javascript state = { activeStep: 0, stepOne: { value: '', suggestions: [], } } ``` The child component is stepOne and only has a responsibility of updating that part of state so my onChange method **previously** looked like this: ```javascript const newState = { ...this.state.stepOne, ...childState }; this.setState({stepOne: newState}) ``` and now the working version looks like this: ```javascript this.setState( state =&gt; { const stepOne = {...state.stepOne, ...childState}; state.stepOne = stepOne; return state; }) ``` 
Cool!
I did not think of that first solution, thanks! This definitely works like I want but I it indeed feels like it is not the best practice in terms of coding style. But for now it does the job!
Yep really grinds me that npm doesn't build a dependency checker in, there are some tools to help you catch these errors, though milage with complex projects you'll need to setup the correct entry points. Check out dependency-check on npm
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations
Just use mobx with react. Close enough to vue. Not as good but will work
Thank you trout_fucker
I think if it makes sense it's totally fine and often preferable. I've seen a bunch of libraries do this
No framework? Not even a self-developed one? Poor Github frontend devs...
Thats all fine and good but it feels like it solves modularity but brings more other problems and gotchas. There are more native solutions like preprocessors, css modulesc, bem that seems to solve same issue without that overhead. 
I doubt they need it. Their front end is a ruby app, and JS is only used to sprinkle functionality here and there.
Yup, in general avoid loops. If one needs to do something behavioral with a collection, i.e. something doesn't return a value, use the forEach method üí™
Added the ability to add songs to playlists this morning! [https://github.com/tvillarete/apple-music-js/pull/5](https://github.com/tvillarete/apple-music-js/pull/5) I'll definitely be adding shuffling too in the near future. It's on the to-do list
Drawing SVG is very easy. Instead of adding HTML to the DOM just add SVG. http://svgpocketguide.com/book/
Do with it as you please! It's open source :)
Uses observables and computed properties with mutation to make it work more like vue instead of having to act like JS support immutable objects with redux
When using an object to store functions I'll often create a default handler function in there ``` const API = { get: function () {}, post: function () {}, defaultHandler: function () {} } const handler = API [method] || API.defaultHandler; handler(parameters); ```
Wish they'd fix their turbolinks setup so I wouldn't get phantom navigation(URL updates but page doesn't) now and then when using history back/forward.
There are many others not mentioned too like this in global scope, in module scope, in unbound functions, arrow functions, etc.This face list is not exhaustive.
Have you ever heard of Mopidy? It's a self-hosted music streaming application, that had the ability to be expanded upon with JavaScript and Python. You should turn this into an interface for that platform, it would be really cool! Although there might be some copyright issues...
You use bootstrap and/or css media queries? For responsive layout.
Python and F# are both functional, and similarly, they've implemented syntactic sugar around their language to "support" objects
 function api() {} var methods = {} for (var key in Object.keys(methods)) api[key] = methods[key]
``` const artistData = artists.map(i =&gt; ({ ...i, artist: [] })); ``` or: ``` const artistData = artists.map(i =&gt; ({ [i.artist]: [] })); ```
What I'm trying to see if I can do is get array methods on an object return in the promise itself without having to pass the returned object to a higher scope then push to an array. Just trying to see if its possible as I cant get it to work.
"No framework" implies no 3rd party framework.
Hey OP, you mind answering my question below please! =D
It just means that what others do in X language, they do it in ruby, they could be using Ruby libraries.
You sneaky Magician you...how‚Äôd you do that!? Haha cool project man! 
I may be a bit late to the party, but where exactly did you learn Redux? I mostly work in Machine Learning, but I've been looking to update my web dev skills and I'm interested in learning more about Redux. Thanks man. Project looks good. 
That's precisely my point why they don't need a JS framework.
It says 'Whoops something went wrong' during sign up.
Hey, thanks! I described my approach [here](https://www.reddit.com/r/reactjs/comments/94mtct/i_made_apple_music_using_react_redux_and_styled/e3m84uj). I also posted a bit more detail about how it works in the README on GitHub, but the gist is that I built my own API and use my own iTunes Library on a flash drive to host the music.
Yes, if you looks under the hood, OOP has common point with FP, object are structures that map pointers, **on functions**, on variables. But the visual result is not the same, and that's the key. Organization / readability. OOP makes things more readable, but can be tedious syntax-wise if you don't organize your work, while FP becomes a mess when your software reaches a certain mass. OOP which wraps FP is the best way to go. AFAIK, js is an object oriented language with FP features. 
I never claimed to be op. And I posted knowing that the person is smart enough to know I am not op. So what's your point? 
why the downvotes? we should be celebrating the use of all modern technology. And ember has a different market than react anyway -- totally different mindset
Good to know Àô Õú üÀô
Ah thanks! That‚Äôs helps. So do you stream the songs from your pi to the app through the API? 
That's only true if you don't need to break out of a loop early to avoid wasted cycles, or loop with an increment other than 1. Loops can be quite useful in many situations. Trying to shoehorn everything into forEach doesn't work 100% of the time.
I was just pointing the fact they might not using JS framework, but they might using Ruby framework, making the title slightly wrong, not trying to contradict you ;).
I thought at one point they used vuejs?
The API lets the frontend know where it can find the specified song (so only song metadata from the API), but the files themselves are also stored on the Raspberry Pi. So both parts work together but are separate. Hope that helps!
That's GitLab. 
Feel free to DM me if you have questions. 
Old? I have seen this issue 2 weeks ago
To send data what you can do is something like this: `yourNewWindow.on("ready-to-show", function () {` `yourNewWindow.webContents.send("data", data);` `yourNewWindow.show();` `yourNewWindow.focus();` `});` To receive the data in the new window you can do: `const { ipcRenderer } = require("electron");` `ipcRenderer.on("data", (event, eventData) =&gt; {` `console.log(eventData);` `};`
&gt; ou also shouldn't be using JS to make things move and you can't use it to make things look nice There's nothing you can do in CSS/HTML that you can't do with JS, let's not troll the newbies...
You're claiming, I'm saying you're wrong. Don't switch position, you are the one to post proof. I'm not going to find an alternative on every CSS hack for you sake.
lol what? You just claimed: &gt;There's nothing you can do in CSS/HTML that you can't do with JS, let's not troll the newbies... &gt;You're claiming, I'm saying you're wrong. Don't switch position, you are the one to post proof. I'm not going to find an alternative on every CSS hack for your sake. I did not ask you to show me an entire site. I asked you to show me 1 thing. Anything. Go ahead. I can't show you proof of something that doesn't exist.
There's always a framework. They have a set of standard libraries, practices, interfaces, structures and architectural guidelines, that they follow, i.e. a framework. They're just not calling it a framework. 
You're a nasty troll, you think I'm going to get baited in your position switching ? You clearly have no idea of the potential of JS. Stop teaching wrong stuff on forums.
There is exactly 0 Vue in this article.
I think this is your answer 
Extreme jealousy is what I'm feeling now. I'm just learning JS and Node. Good job!!!
Christ above, please don't. 
Internal ids don't need to be unpredictable. Auth tokens do. If you mean you are using a permanent JWT as an auth token, then as soon as that gets compromised, you're hosed. You want to at least be able to revoke compromised tokens. Making them expire is also good practice, because it means that by the time someone manages to brute force one, they've long expired.
This is good, thanks! Feels like a perfect mix between my code style and stutterbug's answer.
It's a general purpose programming language, so you can do just about anything with javascript. HTML and CSS is just for content and visuals, javascript can be used for interactions and behaviors. But from your question, it seems you might want to read up on what a programming language is.
How do you authenticate a patch/delete of a document that was created under an older JWT? Simply through internal ID?
As others said, this looks like ExtJS. The two biggest problems I ran into with it were: - lack of flexibility. I might need a button group. If that's not supported, I'm hosed. If I need one of them to have an icon and that's not supported I'm hosed. If I need one button to have an arrow that opens up a dynamic popover menu and that's not supported, I'm hosed. - breaking changes were painful. Like, you pretty much have to rewrite everything painful. You will not get things right the first time, for example everything that takes a string eventually needs to allow component composition and some way to hook into an async data source. Couple of other things: - accessibility is a must these days - dev tools are also extremely important
And it returns a promise, so you can also do this.setState().then() or use await.
Lol, I love this mindset trap, it's always easy to say "it won't be difficult to add this one tiny thing". It's not difficult, but it takes some time. And there are tons of tiny details like this. That's the difference between a polished product and a prototype, demo or research project. Op has done a fantastic job. Not hating on you by the way, I just wanted to talk about that mindset I see pretty frequently. Adding a bounce would be cool.
Not sure what downvote you mean?
Wake up, it's 2018. 
At the time of my comment, the comment I replied to had at most 0 points
Meh. It‚Äôs awesome.
THAT MUCH? The dude went overboard with the usage of Vue!!
Proxies would make this shit a breeze in the park. Make a new proxy object which highjacks the get method as you want. ...if I understood your "problem" correctly
Thank you for your insight. When researching for a workable design, I also ran into similar challenges, and I tried to solve this by the following: Regarding to the flexibility: I have decided to go with a well-established design-framework, which pretty much dictates which component types you should have in the system. I spent the good part of last year experimenting with both Material Design specs, and Microsoft's Fabric UI design specs. I am planning to implement whatever components they described with my system. But as you can imagine this is not enough, you must be able to create both, composite and custom components with this system. At the moment I have a fairly straightforward component model. You basically generate the boiler-plate for a component using a command line utility, and override render, layout, and theme methods. As for accessibility: This is pretty much covered in both the design specs that I have been using, but unfortunately not quite extensively everywhere. I don't have a custom solution for this. I just follow the design specs. Regarding to the dev-tools: There is't really much that you need specifically. To develop with the framework, you setup an npm package and a typescript project (single file umd module, and ES5). Because of the single file module setup in the typescript project, you don't need bundlers like webpack and such. As for task runner, I make extensive use of Grunt, which handles the build and minification of the produces js files. 
I worked on a multi-page site recently with mostly static content. We still used a framework (Mithril) for a few forms and other widgets. It was worth it and ended up being a lot less code than doing manual DOM manipulation. Github has quite a bit of front-end logic if you look at it.
Just be careful that the property names of api don't conflict with Function.prototype (eg 'length'.)
&gt; start with small functions, and compose those to more complex functions That's exactly the same thing you do in every language, no matter which style you use, it's too vague. &gt; I don't see how this doesn't scale. Refactoring is easy, testing is easy. How large are your applications in FP ? Did you even try coding in OOP style ? I don't fully reject FP, I reject *fully written FP programs*, and when I say program it's not the 3k app. 
Just a heads up, open source doesn't necessarily mean the code is free to use/modify. For a project like this you should still add a license, github can generate one for you. If you don't care about or need attribution and want people to use it freely, I recommend the MIT license.
Also, they‚Äôre using web components
You might not need a state management solution, if you don't have a complex state.
This is great! I checked out the actual site and I'm particularly impressed with the transitions and state management. If you don't mind a quick tip: you could use something like [react-loadable](https://github.com/jamiebuilds/react-loadable) to make loading the album art seem faster by supplying a square placeholder image/div while the actual album image is loading. This will reduce the scroll jumping as well since it'll just have to load one element before the rest of the album images. You could even lazy load them using intersection observers. Here a screenshot of the album art with 80mbps download speed: 
yeah this isn't language-level typing, this is just a constructor `String` that I presume Mongoose is using to do its own run-time type checking.
I was meaning to do something like that, but never found a good framework for getting the job done. This seems like the perfect solution. Thanks for the suggestion! I‚Äôll add that to the to-do list!
Weird! Can you try again? I (hopefully) fixed the issue.
Short answer: Since js does not have an std lib you should take the next best thing. 
Think bigger. Are you willing to strip and replace the existing lodash functionality with a code library of your own (or worse, a bunch of custom implementations that are different for every project), then pay an engineer or two to support it through bug fixes and browser compatibility updates, and add a manger to work with all that plus incoming feature requests and prioritizing? On top of that someone has to write the documentation and everyone needs training on the replacement API, which spreads out to extending the time for new hires to get fluent with your in-house library. What's the ROI on that? Probably not good. Or you can use the library to take the burden and go on to think about solving the problems instead of minutae =)
GitHub uses a lot of Javascript! It‚Äôs not only-javascript but it is clear they have their own library/framework/whatever. RoR doesn‚Äôt exclude a big amount of javascript. A great UX for services like GitHub must pass through JS.
Minor nitpick but it's a scripting language - A very flexible scripting language that can run almost anywhere because of the way tech has grown, but still, not a programming language.
You were not a programmer during the IE6 days, were you?
You really don't need a framework anymore with Web Components.
I'm going to be writing a blog post discussing the implementation in-depth. It's definitely easier to visualize if you pause certain parts of the animation and focus on understanding more fine-grained parts of things. Your description already proves you have a good understanding of the high-level DOM layout which is a great start! :)
Yeah I‚Äôve already had them switch to importing the methods directly. It forces you to think a little more about what you‚Äôre doing and has the added benefit of a smaller bundle (so long as you don‚Äôt `import _ from ‚Äúlodash‚Äù` anywhere). For imports, we‚Äôve settled on doin it like `import _isEmpty from ‚Äúlodash/isEmpty‚Äù`. 
While I get your point and agree, I feel as though it‚Äôs more of a mindfulness issue. If you‚Äôre using a ‚Äúfallback‚Äù when you‚Äôre in no danger of hitting an error or can easily (and sometimes more succinctly) implement something like a default argument value... I don‚Äôt know it just seems like you didn‚Äôt really think about it. I wouldn‚Äôt even think of refactoring a project to roll this back though, not worth it. In future projects however I‚Äôd like to enforce more of a ‚Äújustified use‚Äù philosophy. 
You dont need std lib in any browser JS.
you should add a vpn advisory
You should write your API for the people who are going to be using the API. In my experience, knowledge of interpolating functions isn't something that people usually have, so, just off a hunch, I would say no
Thanks for the tip! PRs welcome haha :)
Days? Shit, I still have to support IE10.
Good stuff!
You're getting downvoted but you do make a valid point. About ohhh 8 years ago or so it was quite common to support Chrome, Firefox and then a whole smattering of old IE garbage. We take the ES5 array functions like `map()` for granted now, but IE didn't get them until IE9. If you had to support say IE7, you were forced to use `_.map()`,so you might as well just use it everywhere to keep the code base simple. Hell, not even IE 11 has `find()`. My guess is the developers at this company went through this era and are just used to doing it this way.
You need to read up on the subject lad. :) &gt; There is zero integration, it couldn‚Äôt be used like other components: hocs, ssr, storybook, design systems like framerX, etc. You can surely SSR with web components. Just like how you'd do it with any framework - you hydrate the state on the SPA from static SSR-printed data. The fact that Storybook does not support it (is in progress though) and framerX (whatever that is) is a problem of those tools. Tools for web should support the web platform, don't you think? Tools relying on non-standards libraries that battle standards are dumb, and you shouldn't use them. &gt; Not to mention that a React component is javascript, the lowest possible common denominator Haha. Web components are a part of the web standard. As native as your &lt;html&gt; tag. If that's not the lowest possible common denominator I don't know what. You're talking through your hat. &gt; no one is using it YouTube, the second biggest site on the internet, uses web components. &gt; pretty big difference to something that relies on polyfills and some aged browser tech. Web components are in no way aged browser tech and as you probably already now, the ultimate goal of a polyfill is to be replaced by a future browser implementation. If you have had or are using polyfills today, you can remove them in a year or so when the native browser support is enough for your needs. Compare that to a library (React, Vue or whatever) where you'd eventually have to rewrite it fully instead. 
Having worked in a few codebases where people didn't bother fixing potentially missing values, even when the compiler throws warning about it, I'm with you here. I'd rather over-sanitize than take a chance on throwing a pointless exception and finding out during QA. Or worse, live.
You should be knowing the web and JavaScript, not React. Web components is the standard for creating components on the web. It's created through inspiration from React, Backbone etc during the latest years. This is probable comprehensible by you if you've got experience with React: https://hackernoon.com/web-components-the-react-way-8ed5b6f4f942
I understand where you're coming from but I don't think in the grand scheme of things matters much and you're really not going to notice a performance loss. If you just started this job I'd say lay low for a while and just take in the culture. You're not going to get much respect if you start a job and immediately start rockin' the boat. 
If you've got experience with React, this probably gives you some good insight: https://hackernoon.com/web-components-the-react-way-8ed5b6f4f942 A TL;DR is that web components is custom elements (&lt;your-own-tag&gt;) with life cycle callbacks (like Reacts componentDidMount etc) that runs natively in the browser without the need for any libraries. This is mainly important for the future of mobile where quick load times is important; and having thee trivial things native is far better then shipping a bundle possessed by Babel and React. Since it's native, it also allows true reusability on the web platform. A web component would work in React, Ember, Vue or whatever framework you'd change to in the future - since it's native browser tech. 
Why do you need the brackets there? What do they do?
Performance is definitely a concern with some Lodash functions (see `_.merge()`). I have two competing opinions: on one hand I think you should use something like Lodash whenever you can. They are tried-and-tested functions and there is little point in "reinventing the wheel". However I also believe that if you do not have to support legacy browsers then you should use native methods where applicable.
&gt; lazy coding The worst coders I've worked with are the ones that need to continuously show how hard they work or how clever they are. Solving problems with simple, short and widely used solutions is a great skill to develop for a programmer. Of course, there are cases where performance comes first, but most of the time, keeping the code simple and easy to understand for the next developer should be the main concern. 
This is not necessarily a good thing. Page load times are extremely slow for server-rendered web apps, compared with Jacascript based PWA's running on the JAMstack.
&gt; lazy coding haha shut the fuck up
&gt;My biggest issue here however is the mindset it seems to have created. To me, it comes across as lazy coding. When I asked, I got answers mostly saying something like ‚Äúit‚Äôs a safety net, in case the value/property chain is null‚Äù. i've worked at places that used libraries like that, and it does encourage lazy coding and not thinking about the structure and function of your code. i wonder if it's all that big of a deal at an agency though. the name of the game is usually produce something that is good enough and move on. if you were maintaining a product that made a company money, i think it might be worth pursuing more aggressively.
i was a programmer in the browser wars days. i think OP has a point and it might be worth pursuing. being dismissive is not the same thing as making an argument. you didn't make an argument, you just dismissed what OP was saying with some gatekeeping bullshit.
It could be habit or it could be dealing with an edge case that you just haven't thought of. It's hard to tell from the one example. Are you sure there's no critical thinking behind the usage? For instance, it's possible that it was written as your example was at first, but they needed to handle a special widget that wildly fires onChange with a custom payload that doesn't have target, and it was safe to swallow it. Or as you surmised, they could have written it in the era before event.target was guaranteed. Maybe at a certain point they found out it would always at least be an empty string, but decided that consistency in the code base was more important than using a built-in function. Maybe they want to account for any shape of payload in `event`, and not crashing is more important than failing fast. (Though I'd like there to be an error printed at least in that case.) More possibilities. Maybe they just don't know the new method (I'm talking about String.trim() now) exists. Can you fault them for not keeping up with a detail that doesn't have discernible impact on their day-to-day? Perhaps they spent their time focusing on extending the product instead of checking whether this new method (which they once knew was unsafe) is now safe in all the browsers and devices they care about. Lodash is performant, proven, and well-documented, so it's an easy crutch, especially if a developer actually needed it for compatibility once upon a time. The point I'm trying to make is that it may well be the way it is for a reason. There are often untold stories like this in code. Silent decisions. If it's a truly important decision, and it's not obvious from the code, yeah, it would be great if there was a comment explaining the why. But you're not going to add "// consistency" to every line where that was on your mind. I'm not a heavy lodash user, but I've been working with javascript for a long time, and I've been guilty of all of the above at one time or another. I eventually moved the codebase to the newer style (mostly), but only after I justified it by reducing our bundle size and making the codebase easier to follow for new engineers. Or it could be like you said. Maybe they're lazy and don't care to keep with the times. The questions you have about the code are good and valid. I know their answer seemed a little flippant, but perhaps they didn't realize you were asking more about a general theme than an exact line. You should ask them if there's history behind it. If it makes sense to use the new style, you should advocate for it. I'm sure you can come up with some, if only to make it nicer for new developers like yourself. If your arguments are good and they're reasonable, they'll agree. Or maybe you'll learn something in the process. Tangential to my point: I wouldn't mention performance as a primary argument if I were you. Lodash is pretty dang performant, on par with or faster than the built-ins in many circumstances. And if any function is measurably slower, it's not going to matter unless you're doing tight loops tens of thousands of times. tldr; Question the status quo for sure, but be slow to judge. You could be the one missing the bigger picture.
Efficiency of standardization, native over imported. Lodash fails all of my sanity checks. Use it if you must but I'm going to refactor it out when I push my next branch.
Wow, you guys sound really defeated. I'm glad I don't work with you. Inefficient libraries like lodash should be justified and re-justified every opportunity possible. You wanna support this novelty library for the next decade? Double down then, my friend.
You're sort of off topic though. The question is not whether or not lodash is useful, it's whether or not you should do obj.prop or other common native syntax, or should you insist upon _.get(obj, 'prop') and other lodash alternatives every time? Clearly we should use standard syntax where it's appropriate and bring in lodash only where modern apis are still insufficient *(for example _.get(obj, 'dot.chain[0]path') is a novel use of _.get that the native api doesn't have a method for)*.
Love this app /u/syropian! What happened to the old starfield animation in the header? I liked it so much I made https://github.com/transitive-bullshit/react-starfield-animation
I much prefer Ramda.js for it's composability.
Great plan! Another way to really drive it home is with an extension like ‚Äúimport-cost‚Äù for VSCode. It shows you how much code you‚Äôre importing in bytes so you can gauge the weight versus the benefit. If you stop thinking of imports as ‚Äúfree‚Äù it can really help with the whole ‚Äúimport all the things‚Äù mentality.
&gt; I'm glad I don't work with you. Funny, had this thought after reading one of your other comments, and this one sealed the deal.
Have a look at closures. Or run a singleton function.
&gt;Have a look at closures. Or run a singleton function. Any links that may help me in my search?
It only reduces the payload if you refactor the entire codebase like this though. Also if you use chain, you might be saving almost nothing. Chain, for us, is what is really worth it.
jQuery is a library, but I take your point
That's only if your count variable is a global variable. Just create a function and put the count variable there or pass it in.
There are good articles around specifically on reducing lodash's payload size on front-end. TL;DR; from what I remember: you have to use a lodash babel plugin and a lodash webpack plugin. That brings big reductions in bundle size, even if you are not using lodash (bc usually some 3rd party lib will be using it).
Agreed. It‚Äôs why I don‚Äôt use fancy gymnastics in projects, like `~str.indexOf("word")` instead of `/word/.test(str)`. But preferring `arr.map(item =&gt; ...)` to `_.map(arr, item =&gt; ...)` isn‚Äôt clever. The first is also a simple, short and widely used syntax (more so than the lodash version IMO). I don‚Äôt know if you see the nuance I‚Äôm trying to convey... essentially I‚Äôm all for it if it sticks with the notions you mentioned.
Doesn't es6 pretty much do everything lodash does? 
Is it just me or you just took off with your own monologue mate? You grabbed "lazy coding," started the dichotomy fallacy path and didn't address OP's thoughts. If I may, both lazies and smartasses are usually bad coders. The example brought by OP seems to be a blatant case of using a library for no other reason than inertia. Clean code and good practices don't fall from inertial coding.
I tend to not use lodash anymore or to just use it for very specific functions. Modern JavaScript is enough for let‚Äôs say 90% of what you need to do. To me, the main benefits of libraries like lodash are for cross browser compatibility. It‚Äôs true that for older version of IE some JS functions are missing or don‚Äôt perform well, so using lodash can be helpful. For example I had to implement a highly performant datatable in JS to display and render several dozens of thousands of rows, the difference in performance is very noticeable depending if you use native functions or lodash functions. You need to benchmark in these cases. But if we talk about targeting modern browsers, in my opinion, libraries like lodash or even jquery are dying libraries. We don‚Äôt need them anymore.
A script language is a programming language ...
Its frontend so its not real development anyway. I wouldnt worry too much about it.
Anything you send to the client is editable by the client. It‚Äôs likely you could get this 99.9999% right just by minifying and obfuscating your JavaScript. But if you realllllly need it you would have to maintain the delay time on the server. 
Have never needed anything from lodash, seems like dead-weight wrapper.
Consistency is almost always more important than subjective correctness, and even often more important than subjective clarity. I actually hate Lodash it's this mega beast thing that some people rely on far too heavily cause they didn't keep up with standards or whatever. It makese eye roll _hard_. The fact remains you're all but certainly better off swallowing the pill and getting on with it. Keep using Lodash the same way they have until it becomes a measurable issue and you have a case to build rather than just "it feels wrong". Everyone will be better off.
They could just use a Babel loader to rewrite the lodash imports
I‚Äôm assuming all that info is in a database and there are keys that link student to image. You would basically have to join those tables and loop through the join and display image to correct name. Maybe you can access it via some api then you would just have to render the JSON into the page. As far as random names along with it you can just use math.floor and math.random as the index to pull in random names. You would just have to add some conditionals to check if same name comes up twice. I don‚Äôt see a super easy quick solution other than that. Hopefully maybe someone can you give a faster way 
&gt;Clean code and good practices don't fall from inertial coding. One programmers best practice is another programmers worst practice. I could find just as many programmers that would call your code shitty as you could find that would call my code shitty. It's all very subjective.
Yee I know that material UI is better in the sense that's there's more features however I'm struggling with understating how it works and implementing it in my application.
I think I'm on the same page as you here. Lodash has its time and place, but I often see devs defaulting to using it when they really don't have to. Imo, think more critically as to whether or not it really is (1) more performant and (2) increases readability. And never, _ever_ blanketly import Lodash. Having to write out each individual method that you're importing also forces you to think a bit harder as to whether or not its actually necessary. I am always dubious of Lodash during code reviews. It seems that it's a lot easier to fall back on slapping in an `omit` call instead of figuring out why the data is in that shape in the first place and whether or not you have the ability to change it, first and foremost. There's a time and place, sure, but only if you've thought critically about the code you are writing beforehand and aren't using Lodash as a mental shortcut. JS devs are desensitized to the plethora of libraries that we have to use constantly to perform our jobs, but that doesn't mean that we shouldn't still try to keep our imports to a minimum. 
While Lodash has better performance in some cases, I'm unconvinced it's worth importing the library for those gains. I've been developing professionally for 15 years and have not seen a situation in the real world which method of iterating an array actually mattered, especially on the front end. Typically sets of arrays are filtered down to a manageable size long before that. I can imagine there are probably a few niche situations where it matters but they are few and far between. Using Lodash for the performance benefits presents a similar problem that developers in compiled languages face when they write optimization code that is complex, probably brittle, and hard to read... eventually the compiler is able to optimize plainly written common code as good or better and now you're stuck maintaining or migrating your code neither of which is ever pleasant. In the front end case eventually the browsers will optimize and unless you have a pressing case for optimization, it's better to write common code that is readable and maintainable.
I commented above about disliking Lodash, but this is the better answer. Consistency: uber important, especially for sprawling corporate codebases. 
So basically the new Function statement is creating a self executing function i.e. defined and executed immediately. [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) has details about function constructor. The statement defines a function with parameters taken from the context keys(Object.keys) and it is executed with their values using Object.values. Details of Self executing function (IIFE) [https://developer.mozilla.org/en-US/docs/Glossary/IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)
If they aren't frontend developers chances are they took the past of least resistance. I would imagine some of them used to work in JS when browser was more of an issue and we didn't have some of the really nice language features we have now. I would worry too much about it. Now, if the codebase were a more recently developed and maintained by JS-devs then I might be a little more concerned. But I don't think non-JS devs relying on a well known, well tested, utility library is anything to worry about.
We agree then. At the end, it boils down to team agreements. In our team, we took the decision to completely replace the JS Stlib with Lodash. Then, for just a matter of consistency, we use Lodash everywhere. Also, in the case of `Array.map` there's not much difference, but once we had an `Object.values` that slipped through the reviews and QA and ended up breaking a page for IE11 users. 
It sounds like they found something that worked for them several years ago and haven‚Äôt had sufficient news to re-evaluate. It‚Äôs a natural cycle. If you can add value to the organization, do so, but know it‚Äôs not likely their priority. It‚Äôs been a means to an end.
Uhhh... there's better ways. 
&gt; Simply through internal ID Yes, JWT are just for the authentication layer, you application should never know about JWTs. You put the user identifier in the JWT and sign it, when you get the JWT token back you verify it, extract the claims (containing the user identifier), and promptly forget about the token.
template can help you.
Fun fact: In some environments, [setTimeout()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout) and [setInterval()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval) can also act like eval()
Huh, I read the first link before and I didn't understand - but now it just clicked for some reason. I'll see if I can break it down for future users. Explanation: Take the following simple code and try it out on a recent version of chrome or Firefox: console.log(new Function('a', 'b', 'return a + b')(2,6)) From my understanding - `new Function('a', 'b', 'return a+ b')` is the same as declaring a function like this: function(a,b) { return a + b } After that - (2,6) is just supplying the parameters (i.e - `a` and `b`) of the function. Now take `context = {dog: "pug"}`. and the code: (new Function(...Object.keys(context), "console.log(dog)"))(...Object.values(context)); The code `new Function(...Object.keys(context), "console.log(dog)")` is basically function(dog) { console.log(dog) } The second part `(...Object.values(context))` Is supplying the value (`"pug"`) of the key `dog` in the `context` object as the parameter to the above function. The last outer sent of parenthesis is, as the above user mentioned, a self executing function. Hope this helps someone. 
While I agree with the idea of preferring native functionality over 3rd party, I don't think it's a problem or "lazy". If what you say is true about your coworkers writing "lazy" code (which I interpret to mean error-prone or hard to read because it obscures what's happening), then that likely shows up in a lot of other places. I'd view lodash overuse as a symptom and not the root problem. If using lodash a lot is the worst it gets then it might not be worth worrying about. If you want to enforce a rule that limits the usage of lodash then do it programmatically, anything else will waste people's time with nitpicky code review comments. At my work we use this plugin to ensure that only lodash functions that don't have native equivalents are imported and it's saved us a lot of time. https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore
Yeah the consistency argument did come up, and it‚Äôs one I can‚Äôt argue against. It‚Äôs a tough call since both sides have their merits. 
There are no absolute truths in software development. ;) 
You are creating the element `document.createElement("p");` in the loop. That's right, but you'd need to store that element in a variable so you can add content after: let paragraph = document.createElement('p'); // Create the element paragraph.textContent = 'My paragraph'; // Text added to the element And finally, you have to add the element to the DOM document.getElementById('test').appendchild(paragraph) You can do all of this with jQuery, is even easier but I wont recommend you to learn jQuery yet. Keep learning Js. PD: I apologize for my bad English, It is not my main language :(
Mostly unnecessary, should be able to do everything you need with vanilla and es6 features. I don't remember the last time I bothered messing with lodash or underscore.
The app is useful as it is now and makes font pairings easier and faster. However I think a big improvement would be to show a visual of the font in the drop down list. For example, have Oswald font actually written in Oswald. Without that I still have to remember click through many fonts remembering or guessing as to what they look like before finding the one I want. As it is now I'd probably use it with a second window with google fonts open, that lets me filter based on serif, sans-serif and other options. So I can find the visual style I want and then use your tool to quickly test pairings.
Can you explain what you mean by "no other reason than inertia" or what "inertial coding" is? Didn't understand what you meant. Thanks!
Material UI is really really impressive and if you are using webpack with react, then setup shouldn't be an issue, it took me less than 5 minutes to set it up and doc is also really great. plus, it provides really good components.
MERN (Mongo, Express, React, Node) Boilerplate with a custom resource and error management implementation for server and client-side communication: [https://github.com/jmrapp1/Node-React-Redux-Boilerplate](https://github.com/jmrapp1/Node-React-Redux-Boilerplate)
Awesome web design looks great
Only commenting because I‚Äôm in complete disagreement with your entire comment. We‚Äôre starting another project right now I‚Äôm TypeScript where almost all of the business logic will be handled frontend. We‚Äôre not an isolated case. Your dismissal of frontend is nearly offensive and betrays a lack of understanding on your part. I can agree that being micromanaged sucks. However if I‚Äôm to oversee frontend development the first thing I want to understand is the team‚Äôs habits. They‚Äôre just as harsh on my code reviews, I‚Äôll never auto-approve my own PR just because I can. It‚Äôs not like I‚Äôve enforced anything, I‚Äôm just trying to get to grips with the situation. Oversight and discussion from all devs is just part of healthy workflow IMO.
i just wish js offered a good way to deal with undefined object chains.. data.employees.marketing.persons[3].... now i'd have to do this if (!!data) { if (!!data.employees) { if (!!data.employees.marketing)............... you get the picture just give me undefined omg ... dont throw errors break the whole thing. i'd rather do this.. person = data.employees.marketing.persons[3]; if (!!person) {.....
&gt;When I asked, I got answers mostly saying something like ‚Äúit‚Äôs a safety net, in case the value/property chain is null‚Äù. Having fully implemented ES6, this is the sole reason why we continue to use Underscore/Lodash. We at first tried to use natives, but if your data has any ambiguity then you're going to deal with missing values. It's so much easier to use `_.map(x,...)` than `if (Array.isArray(x)) { x.map(...) } else if (x instanceof Object) { ... } else ...`. In terms of code and pack size, yes you can import each function individually from Lodash and save space. But Angular 2+ Hello World is a whopping 2MB, without ANY business logic. I don't think Lodash is the reason your pack size will be excessively large. But this is a totally different debate.
It seems their decision is ideological, because frankly, there's zero benefit to having to type out the entire DOM command every time, vs. using a super-thin jQuery-like (or similar) wrapper for these key, and often used commands. They may not need jQuery, but using the raw API with absolutely zero API sugar indeed sounds painful.
My way would be to do a nested for loop. Loop through main then loop through each iteration main[i].list[ii].name
The fact you're not polyfilling features or compiling your front end is why that error actually got to IE11.
_Anymore._
lol this reminds me I just got sugared this afternoon. i was in great pain!
git lab -v
 git: 'lab' is not a git command. See 'git --help'.
Thanks, your good
What would be the advantage of adding a polyfill instead of using `_.values`? The earliest browser that we support is ie11. 
&lt;marquee&gt;i've not been deprecated yet!&lt;/marquee&gt;
You polyfill the features you need and you don't need to import lodash. You can potentially get JS compiler optimizations if you're using native features. The majority of people that I see go to grab lodash are lazy coders that don't try to keep up with what is available to them. They get the job done but very sloppily because they compound lodash with lodash. It creates very confusing and hard to reason about chains of logic. It also just usually goes hand in hand with "I don't care if this errors" then you realize later after you've spent multiple hours fixing a bug it comes down to masking or swallowing errors.
while(1){alert("ü§£";}
Wowowow! xD Relax mate. 
i've done both ... but when im tired i just go with if else 
[removed]
&gt; The array.map thing could be to make the speed more consistent across browsers. What world do you live in where the milliseconds have to match between browsers? Are all your pixels exactly the same between all the browsers for this maximum consistency? I'm not saying that you should ignore performance entirely, but premature optimisation is to be avoided like the plague. It wastes time, make code less easy to understand and introduces bugs. I'm not saying that `_.map` vs `array.map` is going to make this difference either. But I would value readability above performance until you get to a point where you can measure and care enough about the difference to change to the less readable implementation. At least these are my opinions after from my work experience. I'm not simulating rocket launches or doing complicated algorithms that needs requires me to squeeze every last ounce of performance. For the most part I just focus on being productive while producing readable, maintainable code that can be easily extended. The opinion of others may be different based on their use-cases and requirements.
Wisely said! 
You should have a look at https://github.com/lodash/babel-plugin-lodash/blob/master/README.md Essentially optimizes Lodash imports.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lodash/babel-plugin-lodash/.../**README.md** (master ‚Üí 3f9c8e4)](https://github.com/lodash/babel-plugin-lodash/blob/3f9c8e48ba66ed68132f7c1ef40b5e1e4c466d6c/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e3or4p1.)
minimize defensive coding: https://github.com/mikechabot/maybe-baby
"Never take down (or complain) about a fence until you know why it was put up"
Experienced the same thing, maybe less extreme. Here now the rule of thumb is to use native JS unless it‚Äôs neccesary. I‚Äôd say depending so much on a library is something you‚Äôd want to avoid (as our project completely depends on jQuery), to be able to move forward when that library becomes obsolete. I can say the only function from lodash we actually use now is debounce and we import it directly to reduce bundle size (like import debounce from ‚Äòlodash/debounce‚Äô). Just make sure to be calm about it as it‚Äôs not the biggest issue and just gradually make them see how it can be done otherwise.
This is great. Have you thought about hashing the password instead?
This is bananas, and so many of the comments in this thread are wild. - *Unit tests* should be your ‚Äúsafety net‚Äù, not avoiding two lines of proper error handling. - Every dependency you add makes your code more brittle and your bundle larger. - You‚Äôre very tight to be concerned, but remember as the new frontend engineer in a dedicated role, they are looking to you for guidance. Make a case for why you think it‚Äôs adding any technical debt or bloat and fix it.
Developers who have an overreliance on it, yes. It creates more debt and bugs than it solves in the long run.
I understood his problem much like a maintainability problem than a performance problem. Yeah using lodash every can be good for performance but it produce terrible code...
Also last I looked (maybe a few months ago?) tree shaking + webpack + lodash was busted, so you still had to grab the individual packages anyway.
Am I the only one that thinks OP comes across as really arrogant in this thread? 
Naah, i'll stick to Parcel. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_pavan_chowdary] [How to become a full-stack Javascript developer \[ resources + guide\]](https://www.reddit.com/r/u_Pavan_Chowdary/comments/94z71r/how_to_become_a_fullstack_javascript_developer/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
It looks like a mutation to me, which could be problematic. `state` shouldn't ever be touched or mutated. this.setState(state =&gt; ({ ...state, stepOne: { ...state.stepOne, ...childState } })) The idea generally is that you receive state and return a new immutable state, which means a shallow clone with shared references.
Following an established pattern because 'that's how it's been done before'
it is faster, but I still prefer to use native .map. Who knows-maybe in next 5, 10 years some clever guy on V8 team, or at Mozilla will figure out how to make it faster than lodash's implementation. 
No snark here, but is that the new flavor of the month? It has a shit ton of stars on github. I could go on an on and on about how much I dislike webpack, even though I use it. I will be checking this out asap.
Parcel use the conventions over configuration approach. It does basically the same thing as Webpack but handles most of the common use cases out of the box so no need for tons of configuration.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
With Node.js it's crypto.randomBytes(length, function(err, buffer) { if (err) reject(err); else resolve(buffer.toString('hex')); }); 
TL;DR: Be proficient in 47 different tools and languages including backend logic, frontend design and development but only collect one salary.
Or maybe both OOP and FP are Procedural in disguise! :O
There is a proposal for that: https://github.com/tc39/proposal-optional-chaining Optionally, you could simply create a safe-access proxy.
Just come here looking for something like this. Perfect, thanks. Will definitely head to the beginner sites listed. Quickie though, I'm looking to learn javascript for web development (not sure if it has any other uses?) Would I need to learn about node.js? Would i need to learn the back-end aspects? 
Plesse also add freecodecamp AS free learning Ressource. Especially after the update its linke the best ressource out there
&gt; It creates more debt and bugs than it solves in the long run. That's a bold statement, using lodash where a native implementation exists is one thing. But using a battle tested utility lib for things that you would otherwise need to write and test yourself is another thing. I would strongly argue that if you manage to create bugs and tech debt while using a library like lodash that you've done it wrong.
The most worrying thing I saw here was a team of programmers, working on the same solutions, with no established standard, repeating nested function calls, from memory. As a Programme) Project) Team, stuff like this needs consistency first before any consideration of whether it is the 'right' way to go about it. If I came to this Project tomorrow, and showed beyond argument that the 'right' way to do this was to use a. n. other library, then show me the single function declaration where I can globally make the change. Will all the devs be doing this consistently in all future releases of the product? OR will I be hunting down instances of this ugly piece of code and tripping over a thousand edge cases and side effects? TlDr: It doesn't matter but good practise does 
Not what MDN says. It's listed as obsolete. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/marquee But even still, I'd say that's HTML doing the job of JS and not styling something.
\&gt; creates very confusing and hard to reason about chains of logic Lodash is a collection of functions that each do one thing. There is massive power in memorizing the entire library and exclusively using it for all data transformations. You end up writing less low-level boilerplate which minimizes the surface area for bugs. A team which has a good knowledge of lodash will write less code, move faster, and cause less errors. It's performant, tested, and documented. It becomes ubiquitous language for communicating data transformations. Either you've only dealt with very poor quality codebases that happened to use lodash, or you just don't know what you're talking about at all. Using lodash well is a massive benefit to a JS codebase.
Full-Stack aka cheaper than hiring two good programmers in their respective fields (front/back). Be an expert in one or the other rather than a jack of all traids.
Node.js is a JavaScript runtime environment for the server. While traditionally, JS was for the browser only, leaving you to code your server in PHP python ruby etc, with node you can now use Js for the server as well 
Oh I definitely agree with you. Unfortunately I have only ever seen it used for the tiny bit available natively haha! End of the day every project is different. If it ain't broke don't fix it
you mostly don't need lodash. Learn to use array.reduce .
Oh I definitely agree with you. Unfortunately I have only ever seen it used for the tiny bit available natively haha! End of the day every project is different. If it ain't broke don't fix it
&gt; It's performant, tested, and documented. It becomes ubiquitous language for communicating data transformations. &gt; &gt; so is vanilla JS.
The comments in this thread are absolutely crazy to me. Complete memorization of lodash is one of the most powerful tools one can have a JS developer. So many people seem to be griping about not using the native methods, but lodash's scope is so much wider than what is available natively. I get your point if lodash is only brought in for keys/values/entries/trim/etc (ie: the super basic functions). But lodash has so much more power than that. It's tested, documented, performant, and allows for a ubiquitous language for data transformation. A team that has a shared understanding of lodash will write less low-level boilerplate. They will write less code, move faster, and introduce less bugs. I suspect you (and many others in this thread) need to hone your intuition around data transformations. Look into functional programming.
yet people use it for everything, even map or filter. "But it works on objects", well ignorant developers should learn about Object.keys and Object.values .
Programming is about effective clean communication. Using lodash or underscore often cleans up the code making it quite clear what your intent is. I agree that you shouldn't use it for just the sake of it though. 
I disagree that *learning Javascript would take about 2-3 weeks or 2-3 days* for someone with programming experience. I would say more like 3-6 months for anyone looking for basic ability to be able to apply the language in real world situation. 
What bugs does it create? Get the hell out of here. Lodash is necessary because JS has an extremely wimpy standard library. Just because it added map and filter does not mean Lodash isn‚Äôt necessary anymore
I believe that if there is a function that exists in native JavaScript, use that over the Lodash version. That being said, the JavaScript standard library is relatively very weak compared to other languages. Lodash has always felt like the missing standard library to me, and there are still plenty of reasons to use it.
At my university, a course titled ‚Äúadvanced topics in programming, using java‚Äù. We we‚Äôre taught the language on the first day. Once you know a C style language well, you can hit the ground running in almost any other C style language.
where is the freaking package managers and compilers.
My guess would be running it enough times leads to the code being optimized. See [here](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) or [here](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e) for some possibly-relevant details.
You can never assume anything is linear about performance, especially when N is a small constant like in your case. There's all sorts of possibilities, optimized versions, to hitting certain hardware sizes that align well. In general, for perf, I'd just recommend you stay with standard big o analysis and refrain from performance testing until the end (and if you need it). Most runtimese these days are quite advanced and performance measuring them is usually an artform in and of itself.
I mostly agree. I think you identified the problems with this behavior pretty well. It indicates a real lack of thoughtfulness about how JS fundamentals work, and about what states your app can be in. I also think relying on library code tends to make code less readable, because you now have to look up whatever API the person happens to be using. Often times that is a worthwhile trade off, but in cases like these? Seems doubtful. I do think there is counter argument to be made though: developer time is expensive. If Lodash allows them a level of abstraction where they don't have to spend time thinking about some inconsequential details, it might well be worth it.
Thanks! Password is hashed and saved to the database using BCrypt. Look at User.ts under server/models. I have it encrypt the password whenever a user is saved and their password is changed or set
This is inaccurate. You don't have the vast majority of functions available in lodash in vanilla. Have you even looked at the function list?
If you're using lodash everywhere else, you might as well use their filter/map for the sake of consistency. Additionally, lodash provides shorthand iteratees which are wonderfully expressive: `filter(objects, { type: 'thingA', isDefault: true })`
lmfao 
The only thing JavaScript has in common with Java is the syntax. 
1. I don't think there's that much churn in the backend world; two years isn't that long. Anything popular and widely used now will almost certainly still be in two years time. 2. Yes, for a fresh project I would just download the latest version of everything. 3. I'm not sure what you mean by lots of points of failure?
That was really a doozie to read
I‚Äôve been in the industry for a few years and really, my ‚Äúbubble‚Äù is intact.
Who on earth would think the R in CRUD is repeat. Just think for like a second, it doesn‚Äôt make any sense does it. 
My impression is that lowdash is very much like jQuery was a couple of years ago: just filling gaps in the JS specifications, and making it compatible across browsers. I would say it will be less and less needed. Bottom line, you should use it as few as you can.
As someone whose about a month into finally giving in and learning javascript, parcel has saved me from throwing my laptop out of a god damn window.
You find some things the hard way but if you‚Äôre going to commit to a language, a good book and a weekend can fill in the gaps for any dev worth his salt.
* Eat * Sleep * Update * Read
And c, c++, c#, obj-c, typescript, php, swift, heck even python is c ‚Äústyle‚Äù even though the syntax has major differences.
rave
While I agree that skills are best focused on front or back for the general developer, full-stack skills are quite useful for startup work. I‚Äôm a frontend dev but when I‚Äôve done interviews with startups we always discuss the extent of my backend knowledge, with the implication that having my hands on the entire stack is necessary along with my primarily client side work. 
Coming from backend world, Angular is pretty great if you're used to strongly typed languages and OOP, plus all batteries are included and development style along with best practices are well defined, so you won't see huge style/architecture differences from tutorial to tutorial like with react/vue, everyone follow pretty much the same rules, which is great especially when you start.
Well there is at least one reason to use lodash map over Array.map since lodash map works with the value as a "collection" so you can map over both arrays and maps. The argument structure for the object iteration is just \`(value, key, index) =&gt; ...\` I believe this is right perhaps Im dreaming?
Personally, I feel like all that functional programming thing is a passing fashion. Now, it does have it's obvious benefits, but lets be honest - functional programming has been there since forever (longer than OOP) and, unlike OOP, it had decades of theoretical basis even before it was actually used in computing. If it really was better, it would have taken over the world years ago.
25 ms can't be an issue. The browser paint cycle is locked to approximately 16ms. 25ms isn't even 2 paint cycles. At my company, we have a rule that if anything can be completed within a single cycle, it's performant enough and chasing anything more before you profile it is just premature optimization. 
There are [touch events](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events) so maybe one way you could do this is if the use touches the button it will fade the image in and when they lift their finger it navigates.
Wait, you're legacy code isn't as awesone as what you'd write today? Tell me more... In all seriousness, it sounds like you know how to do better, so form that into a cohesive stance and do better. Remember though, in the future the better code you're writing today will be looked at as antiquated and as misguided as the code you're being critical of today.
okay
Surprised a lot of people are this passionate/opinionated about a single line of code example. Nobody worked on legacy code before, or in a large unorganized team trying to get a project out the door?
I only have a smartphone so can't provide an example but, I would try using map() or filter() Otherwise I would consider underscorejs or lodash. These work on collections as well. 
Well a lot of react and especially redux is largely inspired by functional programming. Functions like map, filter, reduce are ubiquitous at this point. I agree it's unlikely we'll see a pure functional language be the most popular language anytime soon, but history is showing there were lots of good ideas in functional programming and frankly some bad ideas in OOP.
I disagree. Handlers waiting would be more descriptive of what it actually is. Its just less sexy.
&gt; TLDR I'm New and Let me ask why it‚Äôs done this way. FTFY
These discussions all seem to assume that everyone is a thoughtful senior developer. OP's has a team of 20 devs working on IE11 javascript. This makes those assumptions statistically unlikely. If there are 15 pre-existing places in the app where you're using Lodash to do [insert thing here], and a dev (esp a jr dev) is about to add instance #16, I'd much rather they just follow the existing pattern. Now, if they're awesome and thoughtful and have concerns, I'd also want them to discuss a potential refactor with the team lead so that we can go back and improve all 16 places with vanilla JS. 
 &gt; Programmers seem to have forgotten the real purpose of **integration** tests, that is to prove the code can solve a real-world problem, and all the parts can fit together. I couldn't agree with this sentiment more. Well, I mean... I added the word "integration". But without it, that sentence is just silly. 
I agree, logically, but also, real world, you want people to use your tool. Just like clickbait titles want you to click threads, it‚Äôs annoying, but in the middle ground, serves its purpose. Compromise: from here on out, all fancy names are taglined by their technical description, like the worlds lamest movie posters. Serverless: Handlers Waiting Vagrant: Computers inside Computers Slack: Work Procrastinating 
You can still set breakpoints in dev tools. Anything on front end is not safe.
Nice article! I do however have one question: In the last code block you create a new `Uint8Array` in every event handler. Why? Couldn't you just share one?
Touching on mobile/tablet is already less than great. Adding an effect which delays the expected action is far from a good idea, particularly if you're thinking about providing a tailored, ‚Äúresponsive‚Äù experience. Even more, 2 whole seconds?
The way rookie webdevs talk about what hip tech companies do with their stack has always perplexed me. Who the heck cares? Who are they to you? I have done a lot of contract work, so I have worked at a lot of companies. A few ones everyone has heard of. Each one thinks their system is honed to perfection. Each one is very different. Both cannot be true. Some times it feels like myopic religious zealousness.
Because the memory's buffer array may change when grow is called you can't really cache the views to it. It's not as bad as it may seem tho, remember a view isn't a full ArrayBuffer, just a view into it. Additionally, in V8 escape analysis can make the allocation a stack allocation and further view specific optimisation can turn it into pointer operations. I say can here because.. it's JIT magic and I'm not involved with the V8 project, things constantly change. For example escape analysis was and may still be disabled in Chrome because of some security concern.
This is the best [http://www.chartjs.org/](http://www.chartjs.org/) I don't know others. it might the only one exists
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Figured I‚Äôd cross this into here just in case anyone can help!](https://www.reddit.com/r/webdev/comments/951upb/figured_id_cross_this_into_here_just_in_case/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hi /u/yurkaninryan, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/Henriqueszss, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Innovator87, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/authenticprogrammerx, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/jlehuraux, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/kingducasse, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Xoor, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/coin-lancer, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/liorkesos, this post was removed. If you'd like to post a link, then please use the "Submit a new link" option. If there is additional commentary or links you wish to add, please do so in a comment. Thanks for your understanding.
Hi /u/throwaway119284, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
I'd actually say it applies to unit tests as well (but a lot lighter on the "all the parts can fit together" side) Despite the name, you **should not** be writing tests for units of code so small that you're essentially testing that the language spec and compiler have not in fact changed since the last time you looked at them. To me, a unit for testing purposes isn't necessarily small but simply self-contained (so it can be quickly tested without mocking anything or needing much setup). It's not uncommon for me to write a unit test that actually involves four or five different private/internal functions under the hood because I only write tests, unit or otherwise, for code that a user (not necessarily a human - might be other parts of your code even) actually calls. So even my unit tests are testing that the code actually solves the problem that its users rely on it to solve and that the underlying private parts fit together properly.
I've encountered this myself a few times. After investigating pretty thoroughly, I am virtually certain (at least in my cases) the culprit is memory allocation. `matrix(1)`may perform so differently because so little time is spent on creating space for data compared to everything else the code is doing. Change that to `matrix(1000)` and now much more time is spent on allocation and the performance characteristics change. Also, as a general rule for testing: 1. Always start with a delay to allow for the engine to settle. 2. Between each test, build in another delay to allow for the GC to run (this is especially important if your code creates a lot of objects or consumes any large data). If in a browser, monitor when GC happens and adjust as needed. 3. Try varying the order in which you do your tests (this will often highlight a mistake in your test runner rather than a problem in your code). 4. When focusing on performance, your tests should always still represent real-life expectations. If you never expect to use `matrix(1000)` but you want to stress-test the code, then change your tests to do `matrix(10)` a hundred times (or whatever). Here's how I would do your tests: const delay = period =&gt; new Promise(resolve =&gt; setTimeout(resolve, period)); async function runTests() { await delay(2000); console.time("my solution runtime"); matrix(1000); console.timeEnd("my solution runtime"); await delay(2000); console.time("other solution runtime"); matrix2(1000); console.timeEnd("other solution runtime"); } runTests();
Looks pretty cool and it's nice to see it running on so many platforms. I'm guessing the JS source is not open source and available to look at?
They don't run Turbolinks. They run their own flavour of pajax...
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Hi everyone! &amp;nbsp; A while back me and a colleague of mine open sourced a color picker component for [AngularJs (1.5+)](https://github.com/talamaska/angular-radial-color-picker). A total of approximately 3 users were really happy with the end result and at least 2 of them even found a [real-life usecase](https://community.openhab.org/t/custom-widget-angular-radial-color-picker/28874/5) (IoT &amp; smart devices). &amp;nbsp; Felt pretty amazing, so lately I've wanted to get back on the OSS horse saddle. I've decided to bring some life to the old color picker component by porting it to other frameworks. Proof of concept was started with Vue and it paved the way (and pretty naturally I should say) for the React component. The color picker internals (color wheel &amp; rotator) were rewritten, profiled with DevTools, and then rewritten again and as a result dragging (especially on touch devices) feels snappier and more responsive. &amp;nbsp; Contributions are more than welcome! I haven't had the time to setup any tests and could really use a hand there. &amp;nbsp; TL;DR: I ported an AngularJs component to Vue ([codepen](https://codepen.io/rkunev/pen/zjEmwV/)) and React ([codepen](https://codepen.io/rkunev/pen/mjKoyK/)). Go check'em out at GitHub: [vue-color-picker](https://github.com/radial-color-picker/vue-color-picker) and [react-color-picker](https://github.com/radial-color-picker/react-color-picker) and smash that star button ‚≠êÔ∏è ‚Äã
thank you so much, this is still easier than manually creating an answer key. 
I didn‚Äôt expect this post to get as much attention as it did, but I‚Äôm glad it‚Äôs creating civil discussion. Legacy code or older devs would have me approaching this question differently. The project I‚Äôm on now is all younger devs and we‚Äôre shipping in about a month. I wouldn‚Äôt even consider refactoring for something like this but the discussion is open for the future. 
Ok
Why does it sound painful? (learning).
https://stackoverflow.com/a/17253557
How can you say this? This is not even close to true. The function set in lodash is wayyyyy larger than what is available in es6.
The standard DOM is produced by a committee with goes for the most generic, most verbose variations of everything, at the hope of staying neutral from API design fads, and to maintain opportunity for future extensibility. The standard DOM is often not intended to be used directly as a matter of course, but rather as a building block for more specialized and simplified APIs. Basically think about it like this: it's like having to fill-in all your taxes all by yourself, with no help from anyone. Can it be done? Is it the expected standard? Yes and yes. Is this what most people do? No. They rely on software and/or consultants to streamline the process.
Because you're not actually waiting for it to finish. It feels like you are when you're writing it, but that's not how it's executed. Basically, an `async` function happens in another thread, and then `await` says "the rest of this scope should be executed in the same thread as that async function". You can do other stuff while they're executing.
Because it's non-blocking. Sure, you still have to _wait_ for the response, but you can still have other code doing work until you get that response. If it were synchronous, all your code would halt, you would wait for the response, and then continue down the commands. Fire off the await asap and then do all the other tasks (setup event listeners, transform data, parse whatever) and then when your await returns, then you can fire off the next function(s) that will act on the new data.
There's lots of [literature](https://hackernoon.com/async-await-generators-promises-51f1a6ceede2) out there available explaining how it works. No, `await` does _not_ block. The execution of that function is interrupted at that point and other stuff may run. When the underlying promise is resolved, execution of the function continues from that point on. The link above explains how `await` is basically equivalent to promises + generator functions.
This rule is good to know but it makes some code pretty annoying to write `someNodeList.forEach((el) =&gt; { el.style.display = 'none'; }); // [eslint] Assignment to property of function parameter 'ct'. (no-param-reassign)`
Correct. Internal to a function, `await` looks like sync code, but consumers of that function see it returning a Promise. 
Well it depends on projects and developer habits too. But I‚Äôve worked on live project with consequent JS code base without jquery or lodash, or a very limited and sparse usage of it.
Hello, thank you for your time and analysis. It seems that memory allocation definitely plays big part in the execution time. I run the test with only matrices in both functions and it was \~1,8 s vs \~3 ms (for N = 10000) in favor of the other solution (iterative approach). However, strange things happened when I run the tests with full implementations, but this time changing matrix implementation in my solution to iterative. Runtimes looked like this: matrix : \~22 s / matrix2 : \~16 s (same matrix implementation using iteration) matrix : \~7 s / matrix2 : \~16 s (different matrix implementation using Array.fill() ) So, it looks like my solution actually run 15 seconds longer after changing the matrix implementation, even though comparing **only** matrix allocation runtimes, the iterative approach was clearly much faster. This is insane! I might want to run some more tests in the future and maybe gain some insight from it. Right now I'm thoroughly confused. Also, some good points I didn't consider about delays and GC, little did I know when it comes to testing. 
Yeah, with IE9. I would measure safety from "the time we stopped needing to support IE8," since that's where it's clearly unsafe. If OP's company's policy was always to support two versions back (who knows when that was enacted?), then this would've been in 2012. It's definitely been a long time since then, so hard to excuse not knowing about it entirely. But if it's unclear what versions you need to support, I could see using lodash here--since the whole thing is included anyway--just to avoid headaches from corporate customers. I don't know, I don't want to justify their behavior too much, and the explanations may reveal things about their work environment (past or present) that are not great. I'm just trying to explain some fairly legitimate thought processes that could lead to that usage.
If an algorithm has different performance depending on the size of the input, it may happen for various reasons. In particular if you compare two different approaches and each has better performance on different sizes it _generally_ means they are making different trade-offs. As an example, `matrix2` has a much better initialization code. That is, this: const matrix = new Array(n).fill(0).map(e =&gt; new Array(n).fill(0)); is quite slower than const results = []; for (let i = 0; i &lt; n; i++) { results.push([]); } But then again this only matters if that part's performance is _relevant_ when compared to the rest. If the rest of the process uses a similar amount of time, then `matrix2` will be faster. But if, for whatever circumstances, one becomes slower than the other, then that particular difference may not matter that much under those circumstances. Now, does this happen to this example? Quite probably so. `matrix` uses only one loop where you move the indexes `i` and `j` and check a _simpler_ condition (`count &lt; n*n`, where `n` doesn't vary throughout the whole thing), while `matrix2` uses four smaller loops (`for`) nested into another loop (`while`) and they all check conditions which do vary on each loop. It is merely a guess, but I would guess that, `matrix2`'s process is _less optimizable_.
Hello all! My name is James and this is the first React.js app that I've built to try and build up my skills in React and also create examples for my web developer portfolio. This app uses React with JSX and no Redux (I don't even know what JSX is) as well as Bootstrap 4.1 Beta and FontAwesome for various icons. Along with that, some of the CSS is custom-done to suite my needs. I would like to know what your opinions on this little demo are, how it could be improved, and what skill-level you'd put me at with React as a whole if you could!
ELI5 lmfao 
I would have agreed if you couldn't transpile your code, but since you didn't put that qualifier I find it hard to believe that you absolutely _need_ lodash. It's a crutch that I see weak or naive developers immediately grasp for without taking into consideration the technical debt added by using it. The bugs aren't in lodash itself, just so you know. Lodash is built very well and it has it's particular use cases. However, what you're claiming is it's a standard library replacement or enhancement which is **required**. Everything lodash can do you can do in plain javascript without much extra work. For..of and For..in handle a majority of cases, I don't use .forEach as I dislike the callback syntax and don't want to invoke the functional overhead. Lodash has this pretty neat function called \_.get which just so happens to be the function which causes the most side effects because people don't realize what's a valid value or that deep in a function you're calling it's mutating what should be the real value. JS has added map, filter, Object.values, Object.entries, Object.keys, Object.assign, and soon a syntax for \_.get with `this.?value.?might.?not.?exist`. I find the safety lodash gives you is easily supplemental with good tests, and even then you're better off not using lodash so you're forced to write good tests that allow you to know when something actually breaks while building a feature.
No, they don't do the same thing. I didn't bring that up because I didn't really go through the whole thing in detail. So you _might_ have had a reason why you'd need to zero-fill the matrix. If you don't, then of course, don't do it. That's one of the most important rules in optimization: Don't do things you don't need to do :)
Honestly, I really like it cause it's simple but well designed. I've resized it and it's good that you increase the UI elements (there are a lot of people who don't do that). Regarding you js-react code it's hard to tell since you didn't provide any repository alongside. the image icons are awesome. Anyways the UI is really great but the code isn't visible so would be good if you put it somewhere...
I'll try to figure out how to get everything on github later and then I'll link it back here and tag you. Would you be willing to take a look once I've got that done?
If you have a very good use case to include lodash, sure, use the functions. The point of this discussion is the over reliance on lodash. You don't **need** lodash to make something with javascript. 
great first app! A few things I'd suggest based on a cursory review of the code. 1. You have multiple `&lt;Item&gt;` components defined in the Shop component, why not use an array of objects and a `.map()` to quit the repetition of the `&lt;Item&gt;` component. Like [this](https://gitlab.com/snippets/1740899) 1. you should make the barrier to entry when adding items to cart as low as possible. Having to set the qty to &gt; 0 before clicking "Add to Cart" seems counter intuitive. I'd either set all qty's to start at 1, or when you click "Add to Cart" it automatically assumes you meant to set the qty = 1 and adds it
Thank you for your reply!! I much appreciate any feedback. &gt; You have multiple &lt;Item&gt; components defined in the Shop component, why not use an array of objects and a .map() to quit the repetition of the &lt;Item&gt; component. Like this. Granted your method works quite fine for a first react app, but learning to keep things DRY early on doesn't hurt :) I actually did have this on an earlier version of the app, but deleted for some reason. I plan on going back and adding that back in, because I agree with your point on the repetition. &gt;you should make the barrier to entry when adding items to cart as low as possible. Having to set the qty to &gt; 0 before clicking "Add to Cart" seems counter intuitive. I'd either set all qty's to start at 1, or when you click "Add to Cart" it automatically assumes you meant to set the qty = 1 and adds it This is actually how I originally had it myself, however I received feedback from a family member earlier today that they would rather the count start at 0. They made the point of possibly adding in "add all items to cart" button later on, and if everything was preset to 1 it would give them at least 1 of everything - what do you think about this bit?
You'll need to show us the code, but likely you'll be to reset your variables (this is particularly simple if you wrap everything in a class)
It's a bold statement that I've observed and have heard from multiple people who now share my pessimism for lodash. If you're worried about bugs of your code and use lodash to just assume you're going to be alright is exactly the cancerous culture lodash has. You still need to test your own code just as hard or even harder to catch the side effects of inconsistent decisions while using the library. \_.get is by far the most overused function that usually leads to bugs as people pass in values and expect _.get. The thing with _.get is once you start using it and providing default values you have to be very strict with what you do with your returned result. If you decide to use the raw object after that you have to consider all possibilities of a valid value and an invalid value... Might as well just add more \_.get's as it's too hard at this point to know what value will be here. If I have to spend any amount of time figuring out _what_ value is supposed to be here your code sucks. Like I've said in other comments lodash isn't the problem. Lodash is built very well and has it's defined use cases. It is not a std library supplement because you're lazy.
You should check out the code review stack exchange
Okay, I'll work on those bits next! Based on what you've seen so far and after I provide these updates in the near future, would you be able to recommend me a starting place on where to improve my skills from here? Maybe another project or something like that?
So if you're disciplined and are able to keep yourself in check when using lodash then by all means use it, but it's the _majority_ of people who use it I have a problem with. As explained in my other comment to you there are defined used cases but other functions cause side effects that are hard to reason about. It could be that I've only been able to work with bottom of the barrel JS devs, but I doubt that. I don't believe I've only worked in poor code bases either. I also love when people say lodash is performant over native features. JDD's goal with lodash was to have it work on all platforms not to optimize for a specific one. So it can be performant in some areas and not others whereas native is bound to be optimized for that platform. To put it simply, you may be part of the small community that uses lodash for specific documented reasons and are able to avoid a lot of the side effects that lodash _can_ bring. You still haven't changed my opinion on lodash as it's burned me and other coworkers on multiple different teams at different companies.
Ooohh! I was looking earlier for ways to do conditional rendering like you just edited in to your comment! Thanks for the info. I'm not sure which I like better though.
I used Chrome Developer tools and just looked at Sources =&gt; app.js. [Here](https://gitlab.com/snippets/1740901) is what I see. 
&gt; I don‚Äôt care where in the stack you write your code, doing anything ‚Äújust incase‚Äù is sloppy and a telltale sign you‚Äôre lacking coverage and critical code review. This covers my concerns perfectly. 
Look into ternary operators with Jsx, allows you do things like this: {(cart.length &lt; 1) ? &lt;h2&gt;Your cart is empty!&lt;/h2&gt; : &lt;div&gt; &lt;h2&gt;Cart items would go here&lt;/h2&gt; &lt;/div&gt; } 
just keep adding features to the cart. Add in the ability to modify qty's in the cart modal, add a payment workflow, etc.
Yeah, I should clarify that I was interviewing for frontend roles at startups. The full stack questions were with a vibe of ‚Äúit would be super awesome and helpful if you had a little bit of working knowledge‚Äù. I think it‚Äôs just inevitable that crossover will happen when you‚Äôre working closely with such a small team to build brand new products. Definitely helpful to practice running your own dev stacks when doing frontend experimenting. 
You‚Äôre testing your API implementation in a black box, essentially? This is the type of tests I find most useful as well.
i mean you can't get away from all the div's with bootstrap but you could split it up into components so they aren't AS noticeable. As far as code quality goes though, the example app you built is pretty straight forward, good job üëç!
Okay, I suppose I can work with that for now. The goal here for me is to build up my skills and find a job using React as my main skill that sits on top of my other web development skills, so I'm just hoping this will be enough to help get me somewhere with that.
Thank you, that is much appreciated. I'll keep improving my skills from here!
Hes probably refering to plain view frameworks like react and vue. Web Components are pretty much exactly that (they provide similar lifecycle callbacks like reacts componentDidMount etc.) but native so theyre more performant. I havent used them yet though so I cant say if theyre currently a good replacement 
Extremely minor (non-)issue, but why wrap &lt;App /&gt; in a div?
I can't promise anything since I'm loaded with work. Currently working in angular2+. I did a huge app in React back in 2016 and since then a lot of things have changed. I've also written a lot of none ES6 code since I wasn't really familiar with it back then. Remember, always ES6 your code. That's one of a mistakes that I've mad previously. It's a bit tough to learn but pays off at the end.
Even though I know ES6, I'm hesitant to use it for compatibility's sake... what is your take on that? I used to work at a large company that serviced other large companies around the world as our clients and the some of the biggest issues we had were making our web apps compatible with internet explorer 8 &amp; up because there are so many companies out that are still stuck in the stone-ages, sometimes we even had to support as far back as IE5! Hell, a bunch of ES6 doesn't even with in IE10. So while I love ES6... I'm just not sure enough of the world has adopted it?
Escape analysis is about how memory allocated by one function can escape that scope and be modified by other functions causing inefficiencies in compilation, or thread performance. https://en.wikipedia.org/wiki/Escape_analysis
This looks exactly what I would expect an Asteroids game in JavaScript to look like. I found this on github awhile back when I was looking into writing games.[ Asteriods remake.](https://github.com/jphamilton/asteroids)
Also, instead of using .then, you can use async/await. You are using the babel env preset anyways. Your choice.
Instead of function doSomething() { return myPromise .then(value =&gt; { doSomethingWith(value) }) .catch(error =&gt; { handle(error) }) } you can write async function doSomething() { try { const value = await myPromise doSomething(value) } catch (error) { handle(error) } }
Probably.
If you find a way how plz tell me
Im still learning as well. But I‚Äôm just in html and css. I‚Äôll learn js but first I want to solidify my knowledge of html and css. I would like to develop an app. Could you tell me how can you simulate an app? Because when I write my code I always see it on a webpage, not on an app. Relatively to your app, one thing that is missing is that when we click on add to cart the cart symbol doesn‚Äôt show up. For it to show up you have to slide up. But I think when you add something the cart should appear temporarly
Without the code / some kind of browser error console output, we can't do much other than conjecture.
I'd say it's adequately performant for most of the time. I've run into cases where I couldn't use lodash due to performance constraints, but these have been few and far between and in fairly "non-standard" apps. Side effects are hard to reason about in general -- this is not specific to lodash -- but I suppose could bring a layer of "opaqueness" if used sloppily. But in the end sloppy code is sloppy code and I don't think it's fair to put the blame on lodash because people who write shit code will write shit code in any context with any tools.
that question has already been answered by devs... for making sure value is not undefined, further questions should be directed toward people who actually wrote it. more so because this is not a standard way to do it anywhere, so unlikely would have any idea what was going through their mind.
ruby had this way data?.people?.group3[3]?.....
&gt; Could you tell me how can you simulate an app? Because when I write my code I always see it on a webpage, not on an app. There's a few nuances here that I'll go over to the best of my knowledge. Firstly, there are Web App(lication)s, and these are built using a lot of the same technology as a website, but a web app is interactive and much more involved. Thing of a website as a static site you visit, say for example your local hairstylist's haircut website. You don't do much with it, you look at it for information. A web app is more like what I created above, the user can interact with it via selecting items and quantity of items to throw in their cart. If you're looking at making a literal phone-app, as in for android or smart-phone, what you're looking for is using a web-based view, such as the WebView for android. Using WebView, you'd be able to display your website or web app inside a "view" in your native android app, but you'd still need to learn some android programming. I hope that helps, feel free to PM me if you are confused. As for the thing you said about the cart, can you elaborate? I don't understand you.
It‚Äôs not required just as much as compilers and assemblers aren‚Äôt required. You‚Äôre not wrong, you‚Äôre just being pedantic and impractical. Lodash offers a lot of nice APIs like _.last(). I will continue to use those, and it‚Äôs sad that a library has to implement these APIs. That‚Äôs the fault of JS.
Hi /u/jaytron90000, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Sorry it‚Äôs my second language. If you scroll down to the last items, then add an item, then click on add to cart the cart item on the top left corner won‚Äôt show up unless you scroll up. I think it would be cooler if when you add something to the cart, the cart icon should appear temporarily for show that it successfully added
It says that it requires a write-up in 1 of 3 ways, one of those ways was in a comment. I did that.
Btw, I‚Äôll use html css and js, what I was told was that this softwares work on all smart phones so I don‚Äôt need to do several different apps to suit each one of them. What do you mean about android programming? PHP?
It is asynchronous meaning that the engine can do other stuff while waiting for the await response. When you create an "async" function, it means that its execution can be put on hold when you use "await" inside it and your code can do other stuff.
Ah I missed that, extra large queue today. I'll fix it.
&lt;blink&gt;wanna go to my place later? üòè &lt;/blink&gt;
If you don't recognize generally good ideas, at least within a particular application of a particular language, your subjective ideas probably *are* shit.
I'd suggest you change MAIN.list to an array, since it looks like the shape of each person there doesn't change much. This way you can just go const { list } = MAIN list.map(({ name }) =&gt; name) unless the Person labels are significant in anyway. 
They should really call it something different like `suspend`.
Wordpress works too, clients all want wordpress ;-D
You have webpack for this. Babel inside webpack helps you transpile your code to ES 5 so that in works in "all" browsers and all browser versions (targeting IE here). Also you can include polyfills which are basically functions who haven't been built in IE because it stopped updating the browser in order to support the new functions which have appeared and are appearing. In other words, It doesn't matter if you are using ES6. You wont break anything. How do you think React, Angular work in all browsers. They use webpack mostly to take care of those specific issues. People are quite reluctant to switch to ES6 because of the steep learning curve but it pays off at the end believe it or not. It's always good to know ES 5 because that's what you actually get in your bundle at the end if using webpack or some other tool
In what world does a basic devil's advocate comment warrant the reply you gave?
&gt; I've been developing professionally for 15 years Fallacy: Appeal to authority &gt; Typically sets of arrays are filtered down to a manageable size long before that. How do you propose doing such filtering? possibly by iterating the array?.. see where I am going here? &gt; complex, probably brittle, and hard to read We are talking about using lodash methods which are pretty much equal in readability. &gt; eventually the compiler is able to optimize LOL, not when browser-compatibility is an issue. You might have something that runs fast everywhere but older versions of Safari. If that Safari browser version is important to your users, you will probably want the performance benefits that an extra 30kb give you...
Yeah, I am thinking about implementing this feature, but I am searching for an efficient way, because there are 800+ fonts. However, I have two alternative options: 1. Grouping fonts by style. For example, serif fonts, sans serif fonts, etc 2. Changing the text font when the user hover over some font, instead of changing the text font after closing the font menu Do you think that one of those two is a good alternative?
Contentful has been really great in my experience. I use it both at work and for personal projects. A brief list of things I like about it: - free tier is the perfect size for personal use - consistent APIs - supports custom plugins - 1st party SDKs for many languages
You‚Äôre down voting this guy but he‚Äôs right, clients immediately default to Wordpress for any and everything because it works for many, many use cases. I hate it too but if developer happiness is not your primary concern then Wordpress is a viable option. 
[removed]
Anyone have any good easy resources on learning web assembly? I'm personally psyched about web assembly but I find it quite hard to follow.
Clients never know what they want or why. Defaulting to wordpress because they said WordPress is the single worst reason to pick WordPress 
&gt; Page load times are extremely slow I think "extremely" is a very dramatic word choice. Personally I've never found Github to be slow. Also, Github is using Pjax (a Turbolinks like library) which speeds up loading. See this video on Turbolinks: https://www.youtube.com/watch?v=SWEts0rlezA I also prefer the old Reddit to the new SPA Redesign which feels a lot slower for me and a lot of users. My point is, that while technically you are right, in practice it depends on a lot of factors.
I feel like we should clarify: you can do headless with WordPress with [WP REST API](http://v2.wp-api.org/), which has been baked into the core for some versions now.
I didn‚Äôt say you should default to it I said it solves for many use cases and all other things equal, if it makes the client happy that‚Äôs a valid data point
Make them global /s
It's also been around for forever, fairly cheap to host and has a well-designed admin. This is coming from someone who has moved past it (SSG's and other CMS's are more appealing) but I can't fault people for defaulting to WordPress. It's a good CMS and only gets its horrible reputation by people misusing it (layering on tons and tons of plugins for instance).
I used to use [**https://snipcart.com/**](https://snipcart.com/) a lot back at an old client-work job, it served the needs of shopping cart functionality pretty well. it may be more than what you're asking for, but it does integrate with Stripe.
Sorry mate. You're right, I was a bit harsh in my tone.
This, will always recommend. 
Depends what data you need stored, you could easily make your own using services like Firebase for basic CRUD and auth. If you need something premade then Contentful is a good way to go.
Async functions aren't in another thread (or like being in another thread). They will continue to be synchronous until they hit an `await`. Then they will exit early allowing the calling context to continue to run, only picking up again when the value awaited resolves. At no point in time would they execute at the same time as other JavaScript code.
^[a-zA-Z]+$
I wonder if this was at all inspired by the Coding Train's video on making asteroids with P5.js
üòä thank you!
Thanks bro!
Hmm, maybe I didn't look into ES6 as much as I thought but I didn't think it was that hard to learn. Anyways, to be frank I don't know what webpack is yet, but if it helps with compatibility then that works for me! I know that I tested the app in older IE versions and it broke due to the usage of new ES6 syntax and functionality, but I assume that I would have to do something with webpack first for it to work like you said? 
What does Map do in the background?
Can't wait for syntactic sugar go the way of promote synergy. 
Meanwhile I get (as if I have a choice) to work with an outdated version of a legitimately bad CMS (Liferay)
LokiJs
To the best of my knowledge you can use HTML, CSS and JavaScript to build the interface of an Android app, but you'll still need to set up an Android activity that "wraps" around the web interface to display it, which I think still requires a little bit of Android programming (Java or C# if you use something like Xamarin). As far as using PHP, I suppose it's possible but I don't really know. I'm not exact on the details for Android apps.
Firebase's admin is pretty confusing to non-techy people which is likely why OP wants a CMS.
`Arr[Arr.length-1]` saved you a few KBs from having to import lodash. Having helper functions are nice but sometimes they may give undesired behavior. What happens when you pass an object into \_.last()? If it returns the last key entered then you have potential weak code that can accept a data type it was not designed for. That's my issue with using \_.each with Objects.
Well the Admin would be custom using a simple node server that performs CRUD operations on a firestore db. The app client would just consume the Firebase api. Cheaper than paying for a hosted cms, scaling and load balancing are all handled by google, and a lot of fun putting it all together not to mention highly reusable. 
Except it does lie on lodash as it makes it so easy to _not_ care about whatever you're passing or have been given. Over time when you don't care and compound it with even less care it creates the issues I'm talking about. Even talented engineers can run into this issue. This subreddit loves to play devil's advocate for every little thing and I'm not going to spend hours debating it.
Just for convenience, as I would like to use it close to a hundred times a day to quickly check info.
Have you already looked at the official Chrome extensions documentation to get started?
I like Zesty.io, but I work there so I‚Äôm a bit biased. 
_.last() is more readable than array indexing. It‚Äôs very subtle, but the benefit is priceless. Downloading Lodash is not the bottleneck in your app, and readability is my top concern. There is nothing more expensive than developer time, and focusing on clean code and readability has the largest ROI of any investment you can possibly make. 
I'm glad they've now at least got a second payment plan that includes mutiple locales. I reached out to them 2-3 years ago but never got a reply. The gap between free and paid was 999 a month.
yeah, I already made like a 1000 line if else if etc javascript file that ended up working. Not the most efficient but it works
OK, so your problem's solved?
You completely ignored the actual concern which was unintended behavior. _.last is a bad example to debate as it's generally useful. There are other helper methods which are more fluid in how they process what is given to them.
As I mentioned in my comment in r/webdev \- You can always take a look at headless CMS systems by comparing their features. This might be a good idea if you already know what features you will need. [https://github.com/gentics/headless-cms-comparison](https://github.com/gentics/headless-cms-comparison) Some systems don't provide you with write API's that could potentially waste many hours if you want your web application to store data using the headless CMS.
The unintended behavior argument is extremely weak for me personally. It doesn‚Äôt matter what the behavior is when you pass in an object, because the way I build software all code paths are exercised by tests. There‚Äôs no need to say ‚Äúwell what if I pass an object into _.last()?‚Äù Because there‚Äôs no speculation as to whether that could happen or not. My test suite will ensure that it doesn‚Äôt. Next argument.
Nah, got code to write. I'll just look at the docs and do just what I need to get back to work.
If you're using CRA then this isn't a library. Split the actual component out from the demo/development app and list React as a peer dependency. Also include a README. 
I'd ideally like a solution more like what I wrote in the original post so it would be easier to edit and update, but I've accepted it probably isn't possible, at least for someone with the little experience I do. 
The only reason **you're** able to deem it weak is because you actually have tests. You ensure rather than assume, which is a pattern not a lot of developers follow. You put quality, readability, and reliability above _just getting it done_. Which is unfortunately not always a reality for everyone and everything. Your team obviously enforces writing **good** tests, I've tried to get multiple teams to do it but they're so fucking lazy and shitty managers don't enforce any quality. It's been a common problem that I've had to deal with. You have an environment where you're able to use lodash with moderate success but that doesn't mean it always will be. The biggest issue I found lodash to be in actually in the frontend where people write selenium tests exclusively and don't actually test anything other than that. The assumption argument isn't invalid or weak, it's a very real problem that a lot of teams have, yours has procedures to reduce the risk.
I disagree about where it got it's reputation from. Around 2010 I dove pretty deep into wordpress, read a book about writing plugins and wrote several fairly complex ones, read core source, etc. At that time a lot of the plugin developers barely seemed to know what they were doing. Even the author of the plugin book I read, who was very smart, was fairly inexperienced and had recently learned how to program by live editing php files on the server through WP's interface. Even when the PHP world had finally embraced MVC, separation of concerns, namespaces, and OOP, wordpress itself and especially the ecosystem surrounding it was full of inexperienced developers who wrote really bad code that violated long standing best practices of the development world. Wordpress got a bad reputation because it was bad software with a good makeup artist. I don't hate it though, I'd still rather use it than Drupal which I have to use now. It did let me ultimately deliver editable sites with custom functionality and a nice UI to clients, so I can't hate on it too much.
Ok thank goodness it wasn't only me struggling with the Material UI documentation! I find it really confusing.
Nice
Node.js - there are plenty of great free videos on youtube
[Strapi.io](www.strapi.io) is my favourite. Open source, graphql and a strong community 
[Strapi.io](www.strapi.io) is my favourite. Open source, graphql and a strong community 
what headless means in this case? ty
Don‚Äôt start with angular
The problem is not Webpack itself. Yes it's docs are long and not as detailed as they can be, but the real reason why configuring Webpack is such a drag is because of the plugin and loader ecosystem. Ideally you should be able to just install the plugins and loaders and they just work. In reality the dozens of plugins and loaders never play well with each other. Why does inserting this loader cause my sourcemap to disappear? Why does this plugin cause Webpack to crash? Configuring Webpack is a huge pain because the abstraction is leaky and debugging config is a nightmare. 
Gee thanks. Anything else you recommend?
Its not a bad framework but it has a steep learning curve. If you‚Äôre new to Frontend development start with vanilla js dom manipulation, get into the toolset like webpack and babel and sass, try several frameworks, I like react, angular is good too
Thank you.
Awesome, thanks for the info.
I have experience already with us DOM and a little front end for a project I did with some friends but that's about it. Are there any other good front end frameworks that are similar to angular but easier to use?
Vue.js is easier and very popular as well. IMO there are three big competitors being React, Vue and Angular, Vue being the simplest of them, React is good once you get the flow going as well
How many articles on testing/TDD have you read that are showing an example of a Calculator's add function with two arguments . It's the database mocks, the external service mocks, stubbing, etc, that are always overlooked but entirely representative of real work. 
Feedback welcome!! üòÅ
I used keystone js for a simple project and really liked it. 
If you want to make a single page application (SPA) you either have to make a framework that does this, or use a prebuilt one, of which the popular options are angular and react. Another advantage is if you are writing in angular, you are more likely to find proficient programmers and get them up to speed quicker than your own custom solution. If you're not writing a SPA then there isn't much reason to use these tools.
Are you wearing Nike shoes? Based on the exhaustive details given, I am pretty sure you are. Have you tried literally anything?
Shouldn't this part: obj.duration * 1000); be: obj[0].duration * 1000);
You can start with angular, just find a good resource. Look up Todd motto. He helped develop angular and has good videos and YouTube and a great paid course on his site. 
Wordpress has a justifiably bad reputation, for example - they took 7 months to fix an un sanitized input https://www.reddit.com/r/PHP/comments/8u1yjx/unpatched_wordpress_vulnerability_allows_code/
Isn't this a small wrapper around express?
Yes, I should note, I am also looking into use node.js as well :)
Find a language that you like that compiles to web assembly?
React has become the defacto standard for front-end development. Other libraries are good too, but aren't nearly as popular. It's a lot of fun to learn and master, I highly recommend it. 
when he's talking about "views" he's saying that each creation of `new Uint8Array` doesn't copy the entire buffer of memory that it's reading from. All of those "views" are just individual cursors that are all reading from the same buffer of memory `memory.buffer`. Therefore the overhead of creating multiple "view" objects isn't that bad.
ButterCMS
netlify cms kicks ass!
1. Promises. Was almost impossible to wrap my head around for a few months. 2. Mocking and unit testing. A lot of frameworks use getters, compositions, whatever, so basically to mock them you need to understand partly how the frameworks are built, which is expert level javascript most of the time. There's also not a lot of tutorials that go in depth about this essential topic. 3. Webpack/Babel: Still can't tell if those 2 are amazing or pieces of crap.
The legacy stuff. There are a lot of legacy stuff in JavaScript that still "works" like the with keyword. You don't have to learn it, but it is there and in old projects.
Would you use promises on a key up set timeout validation?(that also hits an API). The context is type and hit 3 characters, do a search, can be more than 3. The problem I had was the set timeout, cleartimeout time was set to either 80 or 250ms, and it's possible to like type too fast before it's done to reset the validation before the other trip finishes/this can mess up state handling which are then used to show an error border(red color) or not. It would make more sense to use onchange, but even that, while a search is going, do you prevent any other inputs or just cancel waiting for the other one and do a search on the new input(with more or less letters). This part is subjective.
[removed]
This is awesome in epic proportions!! 
If you're using multiple `&lt;script&gt;` tags, do it in order of use eg. `&lt;script&gt;` `// your global variables` `&lt;/script&gt;` `&lt;script src="1"&gt;` `&lt;/script src="2"&gt;` Then both scripts can use the global variables. Probably not the way do do this. Maybe have to combine session storage(client or server). I used to do this though when I was first starting out haha. Depends if you have any compilers.
yes
Try Netlify CMS, IT works great for me. Also they have great support, and clear documentation. 
since javascript was my first language, it legit took me months to fully understand what objects were. i couldn't understand what the \`new\` keyword was doing. this is much more explicit in other languages with clear delineations between classes and objects. i was sitting in a thrift shop reading an old book about web design when it suddenly hit me, and that was my personal "i understand programming now" moment. weird, huh?
&gt; well probably not, compare the popularity of the two http://www.npmtrends.com/@angular/core-vs-react-vs-vue Angular is the second most popular frontend framework.
The most difficult part has been understanding the benefit of unit testing besides helping out with regression testing, actually I still don‚Äôt understand.
That's what I've been seeing and reading, which is why I've been steering towards it aha 
Recursivity, the examples just blown my head
Thought of using a throttle or debounce?
Do people write code like this... for production usage?
I dont understand what you just said..
You use it for the backend/admin and you can then use the CMS apis to create your frontend with whatever framework you prefer. Ex. Headless WordPress could use React, Angular, or Vue for the front end. But still let's you use the prebuilt WordPress API's. 
For me personally I think a visual representation of what the font will look like before choosing it would be most useful. So I think that the second option of changing the text on hovering the font sounds most useful. I assume that the whole google fonts library is not being loaded and only the selected fonts are loaded after they are selected. So the speed at which the fonts change on hover may be an issue if they are downloaded on the fly. Also the fact that a user might hover over many fonts which all then get downloaded might just cause excessive traffic. So it can be a tricky issue to solve. I wonder how it works on the google site, to have all the font previews displayed on the one page? As an idea would it be efficient or realistic to have an image placeholder for each font in the drop down that gives a visual of the font, but would avoid downloading it until the user actually clicks it? In theory that seems like it might be efficient if you can find a way to automate the image creation of course. Wouldn't want to do that by hand for all 800 fonts. Good luck with finding a solution.
Closures, promises, partial application, recursion, generators/iterators, this, protoypical inheritance, the event loop and call stack
Yeah, I've used them before and I thought the setTimeout/cleartimeout(on next keyup) accomplishes that. I think overall it was just rushed/poorly thought out. Room for improvement. Like I should have just used onchange instead of keyup/compare.
I just want JavaScript to do things in the order of the script and not jump all over the place. Is there a framework for me?
Async/await should work 
Correct. Webpack is a savour
How am I not myself?
So I can make an api call and have it wait for the response before moving on to the next line in the script?
Yes, you might have to get a library, but you should be able to do it 
Defacto standard in the USA. Doean't apply to Europe and Asia.
I would add proper use of async/await adds even more confusion, especially if you'ven't already grokked promises
Why would you want to? Blocking code while an API responds would be janky 
What if the next statement in the script depends on the data from the API call?
Unit testing helps making sure a single part of your code does exactly what you want it to do. " If I put in X, do I get Y?". It is really useful for more complex and generic functions. For example, I always extensively test validators, even write the tests before I write the code That way I'm not reverse engineering my own functionally, been burnt by that a few times
Await doesnt block.
I know. 
How so? I find async/await syntax pretty easy to understand. They're just taking what would otherwise be in .then(whatever =&gt; ...) and putting it in a seemingly separate function.
Vanilla JavaScript? Coming C# and Java, the lack of type safety was a mind fuck.
React and Promises will help you there
What I don't like about contentful is that you're forced to store everything on their servers.
I just want to do C# client side. Thats all.
[Here's](https://github.com/postlight/headless-wp-starter) a pretty nice starter headless kit from Postlight, that uses WordPress, React, GraphQL, and is server side rendered using Next.js. 
Coming from Ruby, scoping and the object model.
Irony of being a full-stack developer. :)
***This***
Just the basics lexical vs canonical scope, first class functions, events with pubsub inside the same app, functions vs. classes, webpack. After that everything was easy.
Full stack is not known only as MEAN, there is MERN too, probably something else too
One important thing is that await is a control flow mechanism in a way that ".then" isn't. With await you wait for the promise to resolve before doing the next thing. Then allows you to move on right away.
Currying in practical use cases
I just use node scripts because webpack/babel make me emotionally drained - it feels like when you're setting up a tent in the wind and the segmented sticks are flailing about whipping you in the ass and eyeballs and the canvas is nipping at your ankles like a chihuahua because your stepping on it to keep it from flying away. I probably just don't know how to properly use them though because when I look at everyone else using them it's like that same scenario - being molested by an outlet-store-tent in the rain - and you look over and there's a dude who pulls up in an RV that folds out to a domicile bigger than my apartment at the push of a button.
[removed]
[http://www.contentacms.org/](http://www.contentacms.org/)
You need to be aware that they returns promises (hence if you don't grok promises this might get even more confusing). &gt;They're just taking what would otherwise be in .then(whatever =&gt; ...) and putting it in a seemingly separate function. Sort of, but if you're not careful exceptions will get thrown if you don't handle errors which either involves using `try/catches` around your awaits or mixing promise syntax in with them. e.g., `let a = await getVarA().catch(err =&gt; ...);`. Or using another library like `async to` and returning an an err/data response similar to node callbacks. e.g., ``` let [err, a] = await getVarA(); if (err) return err; ... ``` Then there is the fact that it's easy to mistakenly write code sequentially when it doesn't need to be. e.g., ``` async myFn(x) { // Fires off sequentially waiting for each promise to resolve let a = await getVarA(); // 400 ms let b = await getVarB(); // 200 ms let c = await getVarC(); // 100 ms return x + a + b + c; } await myFn(1); // ~700ms wait ``` When it could be better written as ``` async myFn(x) { // Fires off in parallel let a = getVarA(); // 400 ms let b = getVarB(); // 200 ms let c = getVarC(); // 100 ms return x + await a + await b + await c; } await myFn(1); // ~400ms wait ```
Many people have an async function that returns an awaited value (not using await elsewhere in the function). Anyone that knows how it desugars know that's about the stupidest thing you could do.
Pro tip: replace callbacks with promises.
Finding complete resource which can teach as a beginner from classical to modern concepts at one place in short time without being outdated or paid. Everybody out there is sharing their own understanding of js while mdn is supposedly having most comprehensive docs, they are certainly not beginner friendly. JS is not crazy or weird. It's the most intuitive language if introduced properly and reader should drop their pre-built perceptions of a programming language.
Yes, I run my business critical Arithmetic Expression Evaluation as a Service for enterprises using the code in this runkit.
Coming from Python development, I kept using pythonic methods for things like list comprehension, small verbage things here and there. I mean, `list[0]` and `list[-1]` make sense. But `list[0]` and `list.splice(-1)` kinda don't. Also, `for a in b` compared to `for (let a of b)` still doesn't sit right with me.
What is your goal of learning programming? To find a job?Develop specific app,like games or mobile apps?Hobby?Discovering new thing?Or just improve JS skill in general direction? I think this is also a factor,you can mention in your post.
Indeed. Any character, with the exception of N (NodeJS) is exchangeable; DB - Router - View/Render engine - [Node]. PERN is becoming popular (Postgres, Express, React, Node) because Postgres offers a lot of flexibility, and with feathers + sequelize, building API's is a lot more data-orientated (it takes more time than writing the basic queries, but offers a lot of data-protection and stability albeit with a steep learning curve). To be honest, I prefer it be called NERP simply so it sounds less like what we call adult entertainment. There's even QPERN which is PERN with GraphQL - allows the flexibility to run regular REST alongside Graph queryable endpoints. Very good if you know how to write GQL queries (and if you don't, graphiQL has autocomplete). I'd even say that the MEAN stack is fading out with MongoDB being less desirable for many projects (though I still want to find a project for it and believe I don't need relational data for everything) and React having taken a huge bite out of Angular's previous dominance.
Don't know where in Europe you live, but here in Amsterdam it definitely is.
It is but express is node kinda
It's definitely on the list!
that's a nice approach
Depends of what do you want to be. Do you want to be a back-end developer or front-end? Depending on your answer it could be Node.js or React/Vue next
Looking towards front end at the moment but eventually both would be the goal for a full stack.
Then replace promise.then with async/await.
Take a look on this article about what framework to choose in 2018. [https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d](https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d) If you want to find a job quick then I'd recommend React. Take in mind that no matter what framework you choose you have to learn other libraries, module bundlers, etc! For example: if you choose react you have to learn redux, if you choose vue you have to learn vuex and if you choose Angular you have to learn Typescript, ngRx and Rxjs. For all framworks you have to learn webpack too!
That analogy just perfectly describes my experience with webpack as well. Have my upvote! 
Thanks for that! I'll be sure to have a look at the article! Yeah that's always gonna be the case, however well you touched on React and Redux, I read and heard that react came out with its own context API is this better than Redux?
I hardly ever come across any practical way to use currying, despite writing mostly functional code
Oh my! Please no. 
[removed]
TypeScript might be your friend?
The thing with Python is that it is pretty much the only language with a sensible and coherent syntax
I dunno, the Bees?
I think this idea that it's not needed is largely true. Although on a really big site it might still be worth while using jQuery. If only for a minimal decrease in optimised file size. As it could be said that you'd be writing a lot shorter statements and that kb reduction may negate the kb overhead of using JQuery. Although a modern minimiser should largely do this anyway. Less relevent as internet speeds grow, but on mobile a reduction in kb is alwas a ++. Other reason to us JQuery is merely cause it's already there throughout a code base, although that's not strong incentive to keep using it, it may simply be practical to continue depending on the scope and time to live of the project ;)
Yeah thats true. React's context API is pretty powerful but you will still need to learn redux IMO
I‚Äôm kinda learning now, well, have been for years and I find finding the current best practice super hard to figure out when you don‚Äôt know enough to make that assessment yourself. I don‚Äôt want to learn things that are obsolete, but the speed that things move it‚Äôs hard to find courses / tutorials that are not obsolete as soon as they come out - and even then, there seems to always be fifty ways to do everything and as such, with limited knowledge in the first place, it‚Äôs hard to know who‚Äôs right and suggesting the best solution, or who‚Äôs pushing some geek agenda for reasons beyond me. Also, when trying to follow a course / tutorial when your genuinely learning it for the first time and something in the course / tut has changed and you don‚Äôt really understand it yet, makes it super hard to figure out how to overcome that particular stumbling block. I‚Äôm also dyslexic, typically with css and html this hasn‚Äôt been a problem, because it‚Äôs very much, Male this change, refresh, ah that worked / ah that didn‚Äôt work as expected and iterate, not really THAT important for me to start at the beginning and go through complex stuff in a logical order. To be fair, JS and the various libraries are also not too bad to understand and see what‚Äôs going on where... but, when people refactor code into various files and use the more efficient yet kind of notation that is less descriptive, it can become super hard for me to extrapolate what the hell is going on (where as if it was a big file and all written in a less ‚Äòcompressed / efficient‚Äô way, I would understand no worries. I also find that I see something I don‚Äôt understand, I learn it, then about 23.5 seconds later I have no idea what I just learnt but just kinda know how to make it work ( fat arrow functions for example - I‚Äôve watched videos explaining them to me a majillion times, I can use them, but if I had to write down now how/what they are/do, I wouldn‚Äôt be able to do it concisely) I do hope this shizzle gets easier, it‚Äôs so frustrating to understand the concepts, have ideas, and just spend time getting caught up in minutiae instead of realising my goals.
No worries, I'll make sure to look into it, thanks for the insight and advice!
React is really fast, encourages a really clean separation of concerns between components, and integrates markup really well with jsx. I think it is the best, easiest way to write a user interface, and react code is generally pretty easy to read too. I haven't tried vue or angular however
How do you use node scripts to transpile JavaScript without babel? 
Then wonder why those parallel requests are now running sequentially.
this sounds more like advocating the use of Bootstrap, and rationalising that's why jQuery is needed ;) I'd ask the same question of Bootstrap, why in 2018? With so many automated css generation/optimising tools out there these days and improved browser compatibility. IMO the answer is largely there isn't much point, generally. Unless you're already using it.
hahaha.. good one. Just to be clear, I am not against paying. I have paid myself for some resources and even support some by being a patron but take a look at python docs. They have such a wonderful tutorials in their documentation. also refer [learncpp.com](https://learncpp.com) I think JS lacks such community driven useful resources. 
very cool 
What this points to! 
Realizing you cannot always use jQuery. 
I still can't get my head around them because it just feels like you're duplicating code and now how two things to maintain, and need 2xs as long to finish a feature. I'm testing the feature as I develop it, so once it's done I don't see the point of unit tests. I know I'm wrong, I just don't know how to fix my attitude and how to start writing tests that feel good. Add to that that I use typescript which already catches a bunch of stuff for me, which doesn't help my attitude lol
Ah yes, you're absolutely right. How can I loop this though? If I want to start with obj[0] and then after refresh move to obj[1]?
For me it was the prototype syntax and debugging. ES6 classes are much easier IMO even though they are just syntactic sugar.
An entire article to say "hey guys polyfill.io is neat and you can host it too!".
The difference in issues is bad.
The event loop and the patterns to handle this architecture. Events, callbacks, promises, generators and async await
this is that thing that hard to explain to self.
[window.foo](https://window.foo) = 123 and [window.localStorage.foo](https://window.localStorage.foo) = JSON.stringify( 123 ) work fine for most cases 
Prototype chain
`this` It's confusing as fuck.
Passing object data and figuring out if you just passed a reference or an actual copy of the object
Angular.... ?
It‚Äôs actually nice because it leads you to write more functional code. Ask a java dev how many times they‚Äôve written a static method without this in it. 
Another option as well yes, what's your view on Angular compared to React or Vue for Front End Development?
Thanks for your feedback, I've looked into React a fair bit and I'm still yet to dive into the Vue framework/library so I'll definitely have a deeper look!
Variable scopes. Coming from Java, PHP, and essentially _every_ other language, variables would be scoped to a block (function, for, if...). Javascript? Functions only.
Calling `new` on a _function_??? That took me a while to accept haha.
[removed]
It'll click when you start editing others code and something broke.
I've enjoyed using Prismic.io on a couple recent projects. It was easy to use, easy to customize, and the pricing is extremely fair. (They have a free tier available for single user projects, too.)
I don't understand what you are saying... if the code below relies completely on the data you are waiting for, how can you NOT?
90% of this has nothing to do with js
If you block the thread then you render your app useless until the response comes back, providing it ever comes back. You should make the request and let the promise handle whatever happens while also letting the flow continue. Even if the flow depends on the response, you shouldn't block everything.
More unbiased opinions about [Prismic](http://prismic.io) from different people on Twitter: https://twitter.com/i/moments/1014837228672077825
&gt;Javascript? Functions only. Except variables defined with let or const, of course. I feel the same way about Python, I wish it had block scoping. 
How does then allow you to move on right away?
How? What issues were you experiencing without TS?
Why would a library be necessary?
React will help there?
I used to deal with `with` when I did flash. Man can that get confusing
Function is called again from within itself.. that's it.
I used Prismic.io for one of my projects because of the generous free tier and the ‚Äûslices‚Äú feature. It was a pleasant experience using it together with Gatsby. Some features are still missing (they update often) but all in all I‚Äòm happy with it :)
This but it also helps you catch small mistakes way easier
I'm still not a JS expert, but AFAIK .then will run asynchronously in the background, whereas await will stop the code execution within the async function.
I'm similar.. I test features as I develop them and then a final few times before committing and pushing. Then QA gets it, then UAT. I too know that I should be writing unit tests and using some testing framework or something, but...
Extensively use them with a React app. Using the Sagas npm package, generators make a great place to stuff business logic / UI logic.
PHP could be used to write a RESTful API that your app could interact with but it wouldn't do anything on the frontend. Also you are correct in terms of your distinction between a web application and a website. Then there is a native application which is what people typically think of when they think "app". I need an application can be written in React Native (Js, HTML, css), Swift/objective c (apple) or Java (Android). There is an increasing trend to develop using React Native or something of the like because it is basically compatible with both Android and Apple, reducing the need for two apps.
I‚Äôve found that as soon as you integrate typescript or flow, a good IDE lights up with useful features that preemptively reduce bugs 
 self = this;
You've confused me... list[0] both does and doesnt make sense? If you dont mind, could expound on list index stuff you mention there..
I'm imagining they could be used as a bit of a state machine for business logic. I should try rewriting shine existing code and see how it comes out with generators. 
This guy codes. 
Yup!!! 
I believe objects and arrays are always be reference, unless you do some work to make a copy of them.
Hi all, We use prismic for a lot of our projects (using around 9 repos and plan to use many more). We have very complex projects with multi products and multi languages on each repo. We looked at a lot of other options before we decided to pick them. We use Prismic and Preact for the tech part. Contentful was a very good option but it was just to expensive (3-4x) on what Prismic was ofering. While Contentul it's a more mature product Prismic is quite good. Why did we choose prismic? * easy way to create and deploy content types * slices * content relantionship * translations ready * easy UI for the the content team * Preview and content schedule - which is so great if you have a lot of content changes * API structure and filtering is quite good * CDN is good * community is quite big (they have a slack group) and people are helping eachother * they tend to reply to people for features etc * integration field (very good for ecommerce) * experiments (a/b) testing What needs to be improved * image optimization - we get the images at a higher size * translations process - you need to imput all data over and over again even if it's the same across the board * no table support for rich text editor
&gt; For me it was context. Definitely my biggest hurdle. I still don't know how contracts are used in PHP because I've never seen a real use case.
BTW, this is not nested data, as I interpret the term, and expected the data look from the title. Nested data is where an object has children objects with similar shape which themselves can contain children. Recursion frequently comes into play when dealing with nested data. This is just an object in an object. It's also weird the personX objects are not in an array.
I hear the same argument from many of the devs that switched from other languages to Javascript. Which to me only seems like a problem for how they go about their variables. Personally I never really had a problem with my types. Heck, I even abused the system a couple of times but only in a way that was still safe.
I feel like editors do that without typescript too..
I feel like that's programming in general. Recursive stuff always twists my brain until I figure it out.
Probably knowing good conventions. JavaScript reminds me a lot of PHP (when I first started with PHP, anyway) where since it's so easy to get started, seemingly anyone can write code and get it out into the public. Because of this, it can get tough and requires a lot of internal discipline to always keep yourself from breaking down and "cheating" so to speak with mixing business logic into areas it shouldn't exist, or polluting namespaces you shouldn't. Or just slapping a global object into the code and just throwing properties onto it instead of properly exporting and importing. I'd say not to rush anything, keep pushing and challenging yourself and even when you feel comfortable writing JavaScript, keep a discriminating eye on the code in case it can be made simpler or more efficient. Just because modern computers/browsers are superdupermega fast, it doesn't mean you should iterate over an array four times when it could be reduced to twice or even once. Shit like that. Stay hungry.
What? You can have parallel requests using only async/await. [resultPromise1, resultPromise2] = [fetch("..."), fetch("...")]; [result1, result2] = [await resultPromise1, await resultPromise2];
check out Got js or request-promise
&gt; It is really useful for more complex and generic functions. Unfortunately people started using tools that validated the entire code and requiring a minimum level of tested code, which makes it so that you also need to validate very simple code that is very tedious and time consuming to test where you already know for 100% fact that it will always work the way you intended it to. Say I make a counter that just ++ the number, I still need to test that where it doesn't really provide any meaningful value to my unit tests. And adding useless test statements with all kinds of weird testdata to stub just so you can get a x % of code coverage still seems very unnecessary to me. Sure, when developing a complex application it might hold value, but when I make a default constructor that just wraps a controller and does nothing more, I really should not be required to add tests for that file. It just running is already a testament of that it works as designed. Many Javascript tools and especially the testing tools could benefit from either ignoring those or to have them easily bootstrapped and generated so it doesn't cost me a lot of unneeded additional time. Right now I find the tools for the bigger frameworks to just be barely useful and really overpromise and oversell their uses. Especially for the click-tests that run a browser that do things. It just requires way too much code to get a basic thing working. Stuff that works nice in other languages gets ported to Javascript without asking whether we really need it to work like that or whether it really provides a meaningful addition.
Or `const [result1, result2] = await Promise.all([fetch("..."), fetch("...")])`
Much easier to understand when you have a decent grasp of the call-stack. Every time it goes deeper, it‚Äôs just adding it to the stack 
Much easier to understand when you have a decent grasp of the call-stack. Every time it goes deeper, it‚Äôs just adding it to the stack
Understanding the problems I run into and how to look for solutions. I started with my Javascript basically before some of the open projects started. Mozilla didn't have a great library yet and many of the errors were very hard to search for. Debugging was also harder, meaning that you couldn't just click the file that the console was pointing me to and see the exact line it was going wrong. Most of the stuff you just learn by doing or when you see feature X is needed, you just find out who used it and how they used it. I still feel like some of the concepts are unclear to me but that never stopped me from finishing whatever I needed to do. And the biggest problem I had when starting with a new framework is how you move from the "hello world" tutorials to more specific and higher level stuff. Many times I felt that there was a huge gap between the experts using the language and what tutorials available to get better at it. Sure you can make a nice todo-list, but what if I need to make a form with cross-field validation that also needs sometimes to validate via the server and in the meantime also show me some graphical representation of what was entered besides it. Like, how do you make the step from the first line of tutorials, to getting really deep into the framework. Which basically ends up being lots of trial and error that you also forget to detail somewhere, so everybody else after you also goes through the same process again.
How did you figure out unit testing. I have basically no idea where to start.
Without TS, I couldn't be confident that my changes wouldn't break the application elsewhere. With TS - you instantly know everywhere that's affected. Another issue is knowing what properties are on an object. I always felt like I was blind to what was on an object, where as TS I can literally view the definition and see what properties are on it. To me it helps massively to reduce bugs and improve confidence when reading code and making changes.
this
Isn‚Äôt that the point? 
Closures. I get what they are (sort of.) What I don't get is practical application. I know they're useful, I just don't really grasp it well enough myself to naturally reach for a closure when working on my own projects.
Try this for an exercise: write all your multi-argument function as curried function: Instead of writing: const add = (x, y) =&gt; x + y Write: const add = x =&gt; y =&gt; x + y You'll notice how convenient it is to compose functions. Once you get comfortable with that style of code, you'll encounter some library functions that's not curried by default. Then you'll feel the desire to currying them before using it. Every style/paradigm has pros and cons, so don't think this is the only way to go. But if you want to know why people care about currying, this is the way to learn.
&gt; I hear the same argument from many of the devs that switched from other languages to Javascript. Which to me only seems like a problem for how they go about their variables. If you hear the same argument from many other devs that have come from other languages, wouldn't you conclude that their arguments are legitimate and that type safety is a big benefit?
Async is basically syntactic sugar for wrapping the rest of the function in a promise. It doesn‚Äôt stop application execution in the way other languages do. You might already know that. 
You animal. 
Fat arrow functions do not have their own this. There are other nice things about them, but those things are less important. 
Nice job dude! Perhaps my only usability suggestion is to automatically add 1 item to the cart when you click Add to Cart. Personally at least, thats what I would expect to happen. You could also add what item was added in that brief popup that occurs when you add an item.
That's a good rule of thumb. Anything you can put in the hands of editors is one less thing they'll ask you to modify in code.
I highly recommend these two YouTube channels when beginning JS: [freeCodeCamp](https://www.youtube.com/channel/UC8butISFwT-Wl7EV0hUK0BQ) and [The Coding Train](https://www.youtube.com/user/shiffman/featured). There are more complex stuff there too, just start with the basics and fundamentals.
The fact that you can't just say look at some version constant supported by the browser and know your available feature set, instead it's random stuff implemented by each shitty runtime (browser js engine.) I realised that's why I really loathed it over serverside languages for a long time, if I upgrade Ruby then I get that version's stdlib and changes. If I want to use a new feature in JavaScript it's basically pot luck and a bunch of polyfills or transpiling.
I find this whole business confusing, but I did see a talk (sorry, can't seem to find it just now) where the speaker said that what's really going on async/await is that there are generators happening behind the scene. Because ofhtat, it's (somehow, and this is mumbo-jumbo black magic to me) possible to pause the execution of a single function while the thread returns to doing other stuff. There, I've added to the confusion.
You always find bad spots if you search for them. For example the eco-system for TypeScript in React is (in comparison) bad. Does one of those single issues matter? No. It is the overall picture and both (React and Angular) have their use.
No.
Hmmm interesting point. Got any links for that?
I've found that class methods and arrow functions have helped me avoid a lot of the `.bind`, `self = this`, `.apply`, `.call` madness. I also never use `this` in event listeners, only `event.target`, because things get screwy so quickly otherwise.
Thanks for the article. Your explanation of the different steps and choices is really nice and clear. One thing I would say is though that, having worked on Angular apps (w/ Typescript) for a while now, I don't think classes for models are useful. Classes are only useful if you need to use factories. Nearly all apps I work on now involve NGRX. In a redux based app, you need to be able to deep clone and the like. Deep cloning Typescript classes (unless you implement your own custom function) doesn't copy class methods - which eliminates, in my eyes, one of the main reasons you'd want to use classes (instead of interfaces) in the first place. Interfaces are easy to use. They \*enforce\* contracts, type definitions. They can easily be mapped to a ViewModel. They can be easily copied. Etc etc. 
cool story
About Webpack: watch [this free video course](https://laracasts.com/series/webpack-for-everyone), it helped me immensely wrapping my head around Webpack and how to use it. Would not want to go back to the bad old days.
Interesting.. Thanks.
&gt; async/await is that there are generators happening behind the scene Yes, that's my understanding as well.
I usually go that = this
JavaScript was the first programming language I learned. It's still the one I know best by far. I've always just assumed that I need to write my code in ways that guard against passing the wrong type of data. Write good variable names and function names and do type checks within functions.. seems to work for me.
\`then\` doesn't run until the promise resolves... and I believe \`await\` works the same way... I could definitely be wrong too though.
What a useless article. I'm disappointed in Dan Abramov for even publishing this.
You have to in vue.js 
Command line tools are kinda their own thing. And yes, they are perplexing.
Learn TypeScript. Learn OOP. Use TS to build fullstack app.
As long as your promise never rejects, and you never want to run synchronous code after initiating your async action, that's fine. The latter limitation is more of an issue in test code than app code, but I still dislike async/await in many cases because it forces me into try/catch.
Create-react-app does everything for you only with one single command.
Fair enough. Personally, I usually use promises, just because I'm used to them, but I'll use async/await (and try/catch) if it makes the code more readable (i.e., avoids a series of nested promises).
It's really pretty easy.. [https://mochajs.org/#getting-started](https://mochajs.org/#getting-started) Or maybe even easier, just write your own: function testMe(fn, input, output) { return fn(input) === output; } ////////////////////////////////////////////////// function add1To(num) { return num + 1; } console.log(testMe(add1To, 1, 2)); // true 
+1 for PERN + sequelize. That's my go-to.
I found it hard to switch from object oriented languages to javascript and not following any of the design concepts I was previously expected to follow. I hated writing in JS until I found Babel and Webpack and I was allowed to follow OOP concepts a bit better.
&gt; In Javascript the this keyword is always a reference to the object that called the function. https://stackoverflow.com/a/51675487/6224823
the font in the code blocks are hard to read
*what is this*!?
Hahaha, still trying to make web components happen? Web components are not going to happen.
It does seem odd to me that it's the object that **called** the function, rather than the object the function was access from. I.e. the window's foo example: a.foo(); // this=a in the function call var foo = a.foo; foo(); // this=window in the function call. It makes passing unevaluated functions around very awkward as the context is very easily lost.
That's very much true, and this is why we have `.bind()`. It`s also why most ppl prefer arrow functions and just don't use `this `. 
Forget about testing as some mysterious activity. Write a tiny bit of code, and ask two questions: 1. How does this work under the correct circumstances? 2. What would fuck it up? You implicitly already probably know the answers when writing it, or manually testing it by exercising the UI or something. Automated testing just takes that concept and turns your questions into code. Start with unit testing - it's not the most valuable long term, but will get you started writing basic tests and figuring out how to stub/mock/spy so you can write integration tests down the track, which is where the real value lies.
Sounds like homework. 
Good article. I had never heard of polyfill.io, but it seems to make sense. Not as fast as planning ahead, but probably leads to a more rapid development process.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
Until web components are *actually implemented* it's just another framework. There's no guarantee that they'll make it, and the likelihood that they'll make it as-is is pretty low. And worse, the best polyfill forces you to make concessions and do things a special way that won't be required for the real version, even if it was miraculously the same as proposed. Thanks, but I'll pass.
 ((that) =&gt; ({ bind: function (_this) { const self = that self.bind(this)(_this) } }))((self) =&gt; self ["\x63\x6F\x6E\x73\x6F\x6C\x65"] ["\x6C\x6F\x67"] ("\x6C\x6F\x6C") ).bind(this)
This is a weakness of promises: it's way too easy to end up with deeply-nested code that mimics the exact callback hell promises were intended to mitigate, especially when you need to fire side-effects. 
How?
That's more of a problem with getting into the programming mindset than with learning js specifically. Your first programming language is by far the hardest to learn, ince you've trained yourself how to think like a computer learning new languages is for the most part just learning new syntax.
I agree! The code font is very cool, but difficult to read. If there is a "thin" or "light" version, that might help.
I think you might misunderstand pure functions a little // logSomething: Date -&gt; Console -&gt; String -&gt; () function logSomething(d, cnsl, something) { const dt = d.toIsoString(); cnsl.log(`${dt}: ${something}`); return something; } This isn't a pure function, cnsl.log is a side effect regardless of what it does. you would need to use the result of cnsl.log to generate your return value for this function to be pure. That being said it's also only pure as long as your inputs are also pure. if you pass in console then it stops being pure. generally that's why we push side effects to the edges of our application because the core remains pure otherwise it defeats the purpose since we are still dealing with side effects at unexpected times. For this example you might benefit from this blog post(although the whole series is great) https://bartoszmilewski.com/2014/12/23/kleisli-categories/ 
1. Fischer-Yates shuffle 2. Split one random array into two.
I am EXACTLY like your mind set. I don't get it either. So many times I'm making a feature that needs to do a specific task... so I make it do that task, and it works. I verify it works for all scenarios within my application. I don't see how seperating out code again to show that it works is of any use when it's working in the application correctly. I know I'm wrong too cause everyone's doing unit testing, but in my 15 year experience writing apps I just don't get it. My apps work, and the functionality does what it should in all scenarios. What do I need to test again? what?
Looks the same to me, perhaps your app doesn't support it? WFM on desktop.
Yep. My eyes bleed every time I see something like this: const myThing = doThing() .then(thingResult =&gt; { return doNextThing(thingResult) .then(nextThingResult =&gt; { return doOtherThing(nextThingResult) .then(lastThing =&gt; lastThing); }); }); That's just three levels in, and I cheated a bit by using an implicit return on the end.
No the point is to divorce content from ui. 
Oh man, the hardest thing for me was definitely knowing how to use the damn language. I first got into programming a while ago, maybe 5 years ago, and I knew all the basic syntax like for loops and stuff but I had absolutely no idea how to build something. I was mainly learning on Codecademy and they don‚Äôt really teach you (or didn‚Äôt) where to code or how to make a project. HTML and CSS are each because you can see your changes immediately. I know ‚Äúbackground-color: black‚Äù is going to change the background black but I just couldn‚Äôt figure out how to manipulate the DOM or what I could really do with the variables or for loops or anything.
https://en.wikipedia.org/wiki/Window#/media/File:Window_Porto_Covo_August_2013-2.jpg
I started caring about currying when I started caring about memoization.
You don't? Unless writing it yourself.
No, that would just give you the default import named as `functionName`...
https://i.imgur.com/lbkb61o.png
How does it compare to browserstack? That's what I'm currently using for cross-platform/browser testing.
&gt; Writing good variable &amp; function names isn't really part of type checking It kinda is though in loosely typed languages. `getMiddle` vs `getMiddleArrayElement` gives you information about what data type the function is supposed to receive as input. I don't know.. my naive understanding.. TypeScript just feels like a little additional linting, but I know I'm wrong... TypeScript will "save" JavaScript! :)
https://i.imgur.com/z6igDSa.png Weird.
You can almost always flatten a promise chain, though.
You probably can't do this automatically without a library. If you are on a native browser, you can prompt the browser's printing dialog, in which the user can select 'save as PDF' manually.
Just select an item from the array and push that to another array. This sounds like homework though. 
People actually use the redesign? Has it gotten better than when it first came out?
1. Yes. I use it pretty much entirely for the code blocks and so I can figure out how to use it best when it eventually gets thrust on us (I view any further investment on the old site as wasted investment because I think they're going to discontinue it eventually) 2. I don't think so. It's still pretty god awful. I have no idea what they're thinking. As far as I'm concerned, they should just backport code blocks, add in syntax highlighting, and call the redesign a massive waste of time and money, but they're almost certainly not going to do that.
Youll have to put together something to do it for you. Id start with some reasing on pdfs https://en.m.wikipedia.org/wiki/PDF#File_structure And alibrary or package that already exists
Sagas, for one thing. https://formidable.com/blog/2017/javascript-power-tools-redux-saga/
Well stated. Most IT managers are woefully lacking in programming knowledge and Experience. They‚Äôve ‚Äògrandfathered or grandmothred‚Äò themselves into positions of authority And do not fully comprehend code optimization. It‚Äôs really them saying, ‚ÄúDuh, can you write this?‚Äú
It's still not easy. I work on a fairly huge web app, and browser inconsistencies still get us all the time
Good bot
polyfills
When it comes to bugs, I don't think static typing gives you anything that TDD doesn't already give you. I think the editor help is a matter of preference. I find the noise of types makes things harder to read. Especially with things like curried functions.
That isn't something you will be able to with just JavaScript. Once the page goes to the next URL, there isn't really way for the browser to know which element is next. Besides, you don't need really need all of the URLs in every page anyway. The back-end is a better place to track which URL you just used, and you only need to create enough JavaScript to load the next page.
But it really isn't inconsistent :(
This one is explains things well with some visuals https://javascript.info/recursion
Why?
Learning to name variables.
Lodash has `_.sampleSize`
Scoping rules . And automatic line termination rules. Coming from C and Java and other languages, I was sure it is all the same or at least similar, so I just started using JS without reading about it first. I was so wrong. It lead to some subtle bugs that took me weeks to debug. I was mind blown how ``` return a() + b(); } actually works.
PDF spec is crazy, I don‚Äôt think you want to venture that journey. Unless if you know for sure that you only need a specific subset.
True.
prototypal OOP. Coming from C and Java classes in highschool/college, it took forever for me to wrap my head around this.
Ok. I see, thank you. I've refactored this to just use the json instead of a URL refresh. I'm hoping to just use the duration to decide when to move to the next json element and put the correct content in place
Isn‚Äôt that like being the skinniest kid at fat camp?
&lt;a href="index.html" download="website.pdf"&gt;This will TOTALLY work&lt;/a&gt;
Not writing spaghetti low effort code.
/r/javascript seems to be so pro react/angular, that they are anti everything else :(
I think you're post drives my point even further, you're right I was mistaken and this is exactly why I think the async/await learning curve is one of the trickier bits of Javascript.
It's a terrible practice. All manner of other things might be needed in the future and all manner of unforeseen side effects could happen 
`list[0]` grabs the first item in an array in both JS and Python. Which makes sense, it's the 0th item. `list[-1]` grabs the _last_ item in an array in Python. Easy to remember syntax, minus means from the other side, got it. JavaScript however, uses `list.slice(-1)` instead of using the same syntax that it itself uses for normal indexing. The number of times I've sat debugging code only to realize I used the wrong syntax on that...
It's by far my favorite language, and I plan on making it a focus point in my career for sure
With was actually a concept ahead of its time (destructuring is the modern \`with\`). It's just too bad it had incredible performance issues (and, as you said, could easily get confusing if misused).
What do you mean by functional code? Immutability? Using higher order operations like map, filter, reduce? ADTs? 
I hope you are proud of yourself
`.then(val =&gt; val)` is not necessary; the previous promise in the chain will already have resolved with the final value. I don't mind generic variable names here; all they convey to me is that we're using an implicit return - otherwise we'd just say `.then(doNextThing)`. Of course, as long as `doNextThing` was my code, rather than a library, I'd modify it to return the promise that resolves with the value I want, avoiding `res` altogether.
It took me 2 weeks: but i did this Steganographic app for my website. Ive even made a video showcasing it: [https://www.youtube.com/watch?v=MftFXujlfOg](https://www.youtube.com/watch?v=MftFXujlfOg)
A gag is a special case. Anything real should not knowingly follow bad practises. Ever. 
jQuery used to have a selector when you downloaded it that let you pick the functions that you wanted in the package. It was very nice, but that was almost ten years ago, and I don't believe they still offer it. Instead, what you will find is a massive number of CDNs offering to host jQuery on your behalf. Not only is the file size of no relevance to your bandwidth costs, this typically means that the user already has jQuery permanently cached -- making it a 0 byte download. If you were to pick and choose your functions, it is very unlikely the user will have come across that exact combination of functions before, and they will have to download your jQuery file. With the CDN, it is very likely they have downloaded all of jQuery before, and they will _not_ have to download your jQuery file. I believe this is why jQuery removed their pick-and-choose script generator. Ignore the bloat. The additional RAM overhead is negligible. The bandwidth and speed improvement from the user not having to download jQuery far outweighs it.
Using smaller functions and composing then
This is exactly what he ment with no practical way. You just gave a completly irrelevant answer. You're doing some math that you almost never come across.
Spreek je ook voor /u/overdude? üòÇ
The hardest is and probably always be how to deal with complex problems in JS and how you're going to solve them. As a lead on projects with several other developers implementing solutions on a higher level about structure and organisation is way harder then the concepts of the language itself. That's just the easy part. There is so many things to consider like scalability, extendability, reusability. These are all things you learn from experience.
We still have a far way to go regarding full support for webcomponents in all browsers, but I disagree about calling it ‚Äòjust another framework‚Äô. A framework is an application design that follows a certain flow. You can do that with webcomponents too, but you don‚Äôt have to. Besides that, JavaScript frameworks don‚Äôt voor quite well with eachother where webcomponents are agnostic, hence reusable in (framework exceeding) apps. I think that it‚Äôs all about reducing the risk of legacy code. Just imagine what happens with the components built with Angular when switching to, for example, ReactIt becomes obsolete and you‚Äôll have to rewrite everything. And thats where the power of webcompents comes to force.
Time: I think I watched all of Crockford's videos plus some others, that took at least 10 hours probably closer to 15-20 since I pause and rewind etc. I also read Secrets of the JavaScript Ninja by John Resig (jQuery creator) which was really fundamental. Also, it is quite easy to confuse JavaScript with the DOM API as a beginner so I feel like that is a good milestone in the learning curve. It is very important to try all the things you learn, I recommend the book Peak: The New Science of Expertise to understand how to learn faster. Fantastic book, so important to all of us who learn for a living. 
Save as - &gt; PDF. 
Yeah could have chosen a better word for, "wrong scope bro" 
Is this going to be recorded and uploaded somewhere? 
Yep, and whenever I try to get deeper into it and look at tutorials they show stuff like testing an **add** function.... Test if add(2,2) returns 4..... üòï
Short version; compile C to WebAssembly with Clang.
This is one of those questions where the correct answer is "What are you *actually* trying to do?"
Calling `log` of course makes sense as far as being impure, but what just the behavior of accepting `console` as a param makes it impure?
react and node are quite difficult. its just my opinion but neither follow on directly from vanilla js. it depends what you want to do, but bootstrap or jquery would be more natural
No, others downvoted you. 
I try very hard to avoid positional parameters for exactly the reasons you mentioned. FYI, I'd probably write it as function doOtherThing({ count, value, enabled}: Foo): Promise&lt;Bar&gt; { return SomePromiseThatResolvesWithBar } but everyone kinda has their own ideas about what's most readable in destructured args.
Thanks, Trying this now, I guess I'm just overcomplicating it. I don't know that I need a refresh if I have a way to change out 'slides' basically, with content being based on each Json element. I'm not sure how some applications do this in theory
It says it will email the recordings to you after each session, so you just need to sign-up for his newsletter looks like. 
Why would they do that? I‚Äôm right 
Hijacking the top comment, would absolutely recommend a thorough read of Kyle Simpson's \*"You don't know JS!"\*, especially book 3 aptly titled \`this &amp; Object Prototypes\`. Especially chapters * [Chapter 1: *this* Or That?](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md) * [Chapter 2: *this* All Makes Sense Now!](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md) I was struggling to under \`this\` for over 3 years in multiple languages and after a lot of cursing, two re-reads I feel like i finally \*fully\*\* understand it and \*\*all it's gotchas\*\*
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**ch1.md** (master ‚Üí f0d591b)](https://github.com/getify/You-Dont-Know-JS/blob/f0d591b6502c080b92e18fc470432af8144db610/this%20%26%20object%20prototypes/ch1.md) * [getify/You-Dont-Know-JS/.../**ch2.md** (master ‚Üí f0d591b)](https://github.com/getify/You-Dont-Know-JS/blob/f0d591b6502c080b92e18fc470432af8144db610/this%20%26%20object%20prototypes/ch2.md) ---- 
The world is full of strange people. I‚Äôve never used jquery, it‚Äôs 2018 we‚Äôve no use for it. 
I meant `import {blah} from ‚Äújquery‚Äù`
All of consoles functions are impure, I mean I guess you could use console in some way that's technically pure but in this case it wouldn't be.
If you want to change out content within the page, you will need to either use Ajax/JavaScript to retrieve the content and replace it within the page, or you will need to include all of the content, hide the content you don't want to see, and then use JavaScript to hide/show the content you want to display.
Afaik as long as you use lodash-es instead of lodash, webpack tree shaking should work
Ok I'm currently doing the latter to test so I may continue with that and just experiment with looping so I change content out at an interval
Thank you for clarification :) I will search and try until I find an efficient solution
exactly!! I too see tests all the time testing the dumbest stuff, if you're going to get that nitty gritty at what point do you stop? Test is true===true?
I've done this with Python (Django) using Gmail SMTP server. Don't know how it's done in js, but I'm sure there is an existing node package for it.
Cool then, I'll do some research on it! Thanks for the info!
Of course, if we're going there, we really should think about default values: function doOtherThing({ count = 0, value = 'defaultCheese', enabled = true}: Foo)... Also, isn't that Promise&lt;Bar&gt; syntax from TypeScript? I don't recall seeing that in plain ol' JS.
One thing I haven't researched yet is the difference between 'React' and 'React Native.' From what you just commented, it seems like basically using front-end web dev technologies to build the front-end of your "native" app using a web-wrapper.
The Date() object. I've been an FE developer for a long time and I still struggle with any time related bugs. 
I think that is what he ment.
You mean you tell me you're writing JS in 2018 and not using TS? (kidding, mostly...) Actually, I use Flow. The syntax is more or less identical though.
There‚Äôs at least a dozen node packages for everything üòâ
&gt; Why not call it lambda component Render props do not need to be anonymous functions, so that is not a good name at all, IMO. Also, everyone more or less settled on render props, and this feels like bikeshedding.
Right, so essentially relying on `console` in particular is impure, I'm guessing largely because of the fact that it's a global, context-dependent object, like if a function was expect to have `document` or `window` passed in. I wasn't sure if you meant that, in general, relying on an object being passed and expecting it to have a particular method was someway intrinsically impure
I actually think it‚Äôs worth learning Vue first. It has great documentation and bootstrapping tools. Once you‚Äôve done a project or two in Vue, pick up React. React and Vue work almost the same and require similar mental models. React has a more lego like, bring your own libraries, ecosystem so it takes longer to get comfortable with it.
Ah, Flow... Haven't tried it, but I'm a huge fan of TypeScript. Cut my teeth on Java, so when I got my hands on TS and found I could use strong typing (to save my clumsy ass from typos), I was thrilled. Sadly, it's not (yet) used widely in my current job. I'm working on it...
I've got one project that uses it and one that doesn't. The one that doesn't is just painful for me. Thing is, adopting a type library *can* be done incrementally, but it doesn't provide any real value until you reach a certain level of coverage, and this is a big clumsy legacy app where reaching that level would likely take weeks.
Change ```js const obj = { doStuff: () =&gt; this.name } ``` into ```js const obj = { doStuff: o =&gt; o.name } ```
Here's a util for comparing them. Objects do out perform Maps for get/set operations [https://jsperf.com/es6-map-vs-object-properties/73](https://jsperf.com/es6-map-vs-object-properties/73) Good on you for continuing to look though. Don't fall into the five monkeys trap of coding.
[removed]
Ran those tests, and I have maps greatly outperforming objects in 2 of the cases (iterating and get), with set being somewhat close. Chrome 68 on a macbook
I think he's not providing practical example of currying, but suggesting op to start incorporating currying into existing workflow as a way to see its benefits. The code example that he provided is not necessary practical one, just to illustrate his suggestion.
Interesting.. Thanks!
You're right! I probably unfocused the tab and throttled the JS Ran it again and I am getting the same results as you
I saw something similar with Chrome 68 on Windows 10 -- iterating an object being *99% slower!* I just to need to think of a gentle way to get the guy to reconsider. I just don't think you should unnecessarily avoid a feature language especially under what may be false pretenses.
The typical bugs that I find TS catches are optional variables, either undefined object properties or potentially null values. A lot of devs just assume the data exists in the right type, as opposed to still loading or being optional.
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared) gives an explanation of how the two differ at the Language level. From my experience, I have _never_ had the bottleneck of my application be using `Map` vs `{}`. There is far more low-hanging fruit than that. 
You should use PDF.js, it's already build in to Firefox and will be in all browsers in the near feature. https://github.com/mozilla/pdf.js/
You should use PDF.js, it's already build in to Firefox and will be in all browsers in the near feature. https://github.com/mozilla/pdf.js/
Finding a resource that explains monads in a way that wasn't idiotic. For what is actually a pretty simply concept, this was fairly difficult. I feel like it'd be easier now because the Mostly Adequate Guide is much less obscure these days. 
Got an obvious solution for that... 
Agency/content-shop work seems largely stuck in 2010. It's solid work, but if you want to work with the latest and greatest, get out of there and join the SaaS/product-shop world. Except CSS-grid. Nobody gets to use that because IE 11 is still a thing.
I've used a lib that first made a representation of HTML in canvas, and then used canvas image data to build a pdf. I didn't go into why they implemented it this way, but maybe it gives you something to check out and hopefully a place to begin.
Performance is often a red herring, especially armchair performance. Unless you're writing code that absolutely must be fast, then it serves little purpose to exclude useful language features. The question I always have when people say "because performance" is "did you measure it?" Followed by "is this the bottleneck?" Typically they can't answer those questions, which can at least start the conversation. Given that it sounds like he is senior to you, just ask about the last time they benchmarked it and whether or not the code you are writing is performance sensitive. Fwiw the number of projects where that kind of performance matters is quite small. It's often just premature optimization based on incorrect assumptions, which can be the hardest to overcome.
Yeah. Arrow functions and whatnot have made "this" better, but it's still a pain. I try to keep it simple: if the code will execute in the same place it's declared (ie, im not passing a function as an argument to another piece of code), then I'm good. Otherwise, i either use an arrow function or explicitly assign a variable with this before using it.
Yup. You'll get emails after every session with the recorded link.
\&gt; After reading a short chapter, you go to my website and complete twenty interactive exercises. Algorithms check your work to make sure you know what you think you know. function checkUserKnowsWhatTheyThinkTheyKnow(userAnswer, actualAnswer) { return userAnswer === actualAnswer; } \&gt; Algorithms
**this** inside normal function vs arrow function, especially in event listener.
Ah, it's just a hue picker, but a *composable* one! Here's an example with airbnb's wonderful [rheostat](https://github.com/airbnb/rheostat) package - https://codesandbox.io/s/mq890vl3kx
Would this be something a complete beginner would benefit from?
I agree, this does not seem possible.
That's hard to say. The nice thing about it being free is there's no harm in giving it a try. Best case scenario you learn a lot, worst case you waste 30 minutes of your time. 
Well it's using frontend dev technologies, but it's not creating a hybrid app or using a web-wrapper. It's actually (according to Facebook) virtually indistinguishable from a real native app (Objective C or Swift for iOS and Java for Android). I'm not sure exactly how it does this, but a quick google search found this: https://stackoverflow.com/questions/41124338/does-react-native-compile-javascript-into-java-for-android/41124415
Unless I'm missing something, this means you're basically just requiring the developer to send in what would be `this` as the first argument. Right?
If you don't need it to be open source or self hosted, i'm pretty happy with https://prismic.io/
Wow, this is actually super cool to see and play with.
The performance is meh, the Code is okay, the results are great and interesting. I bet that was a lot of fun! Thanks for this!
Actually no, I reddit on my phone and was reading medium on my pc. I didn't dig it up because I didn't think anyone would care but just search for crypto on medium and pick one. They are equally repulsive. 
It's called machine learning nowadays.
Event loop and async programming.
&gt;3. Webpack/Babel: Still can't tell if those 2 are amazing or pieces of crap. I hear ya, brother, some days I just hate myself for choosing it, other days I'm really happy I did. I always think I must be doing something wrong.
Would you recommend learning React first? 
Closures probably one of the hardest concept to explain. Runtime environment and event loop, how do function calls, promises and all that stuff play together.
Sure bind makes passing functions around manageable, but it would be far easier if the default was that the arguments of a function don't change based on usage.
The other thing I failed to mention is that: JS was never designed to be used with classes. Another thing worth considering is that using classes for all your models does bloat your file size out that bit more. When you use an interface, the end product is a plain js object. When you create a class, there's a lot more boilerplate under the hood that needs to be created. [https://es6console.com/jkkab7tq/](https://es6console.com/jkkab7tq/)
For instance, as shown in the article, I have added a transformation and I also believe that we could add validations to the User class while the user is being created. If we were to go with Interfaces + NGRX, does it provide similar functionality? 
I guess I should've emphasized my point. When you have curried functions, it becomes easy and natural to write small functions and compose them, especially when your functions require lot of context (e.g. environmental variables, db connection string, user preference, etc. etc.) having a small curried functions and composing them becomes easier than to have a giant function with lots of arguments. But every paradigm is a trade off, it's for your to decide if it makes sense for a particular situation. Anyways, I'll try to come up with an actual example when I have time. 
Why not. Sure. 
 VS code with linters and intellisense I dont understand the not needing documentation part and I dont understand how knowing the type of a variable makes it so you know how to use everything..
Yeah, probably. Here's a [free React bootcamp](https://tylermcginnis.com/free-react-bootcamp/) I did. 
I see. Validations upon the instantiation of a model (in this case User) probably wouldn't be as 'clean', as with an interface you obviously don't have a constructor. That said, it would be relatively easy to create any validator helpers as functions. `export function validateUser(user: IUser): boolean {` `return !!`[`user.id`](https://user.id)`;` `}`