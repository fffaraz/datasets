If you have something to add - PR is welcome)
If you know Javascript but don't know Java, you could learn Java or use Node and have a server doing servery stuff in 20 minutes. Every language has a list of pro's and con's but the reality is you can achieve pretty much the same features in all of them, so people pick the one they already know over the one they don't. Essentially people follow the path of least resistance. As an example which might appear to a sysadmin, If I need a script to run on a windows box I'll write an old style DOS script instead of a PowerShell script even though I believe PowerShell to be superior. I do it because I'm familiar with dos style scripts. History is littered with appeasement of this mentality. Javascript is called Javascript because at the time they wanted to ride on the coattails of JAVA. VB.NET existed purely to suck VB6 developers into .NET land. TL;DR: People want to achieve results not learn dozens of functionally similar languages.
I remember your nick from the decaf project :) I have been following both projects for about a week, trailing the recent ES6 module import discussion. The decaffeniate-parser is still on CoffeeScriptRedux on GitHub though, but there seem to be some traction there as well. Cheers to hoping eventualbuddha, juliankrispel and the CoffeeScript team can work together.
How big is the repository of "npm packages which have been approved by blogs, articles, or sites like reddit"?
If you already know Java, C# or even C++, definitively go w/ ES6. Chrome got keyword `class` since version 42 and Firefox gonna have its at version 45: https://developer.Mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes Consider Babel &amp; Typescript transpilers as well: 1. https://BabelJS.io/repl/ 2. http://www.TypeScriptLang.org/Playground
`npm run test`will return 1 if you have failing tests `npm test` will return 0 no matter what I think `npm test` must catch or something, but I haven't looked at the internals.
Does it actually change the characters, or does it just display === as the long equals character? 
Thank you for all your hard work lads and ladies!
Depends on the ligature. * The `&gt;=` and `&lt;=` `||` ligature take 1 character's worth of space. * The ligatures for `!==` and `===` take up 2 characters worth of space. * The `=&gt;` and `&amp;&amp;` ligatures still takes up 2 characters. I'm not entirely sure of any of the decisions I made (as I'm totally ignorant of any best practices when it comes to ligatures). This was mostly an experiment. But I kind of like how it shortens the character length, particularly since I never use `==` and `!=` in the first place. But if you use a mix of both strict and non-strict equality, this might be confusing as they'll have identical character lengths.
node.js has only been around for 6 years, and is under heavy development, issuing new releases every few weeks or so. In the past year I have had to upgrade several times due to bugs in npm. Contrast that with Perl/Python/Ruby etc which have been around for 20 years. I'm sure it's possible to write stable code, but the ecosystem and libraries are still young and evolving.
For me TypeScript has been the saving grace for scalable web development, even the JavaScript it emits is very well structured and readable.
CS is dead anyway
I work on an app that gives the user the option to create/customize graphs on the fly based on 3rd party data they've hooked up. They need to see what the graphs look like while customizing a particular metric without having to pull that data from the api all over again. But the backend also needs to be able to create/manipulate that data into our graph form as well, so that code is all isomorphic. We also have a lot of helper/utility functions that we reuse all over our code, and since we made it isomorphic, we don't have to update it in 2 places now. 
You can get V8's version number via: node -p process.versions.v8 I wish Node's site would just say which version they are using, when they plan to upgrade, and so forth.
i think it is the way it is because it became like that over time. i can remember first there was a package-manager called kiwi. then there was npm and eventually it prevailed. i see the argument very often, that node_modules is huge and npm is slow. but in the end it works good enough and huge deployments are actually running with that stack :D also i like new stuff, cant wait how we will solve dependencies once there are multiple js-vm's (v8, chakra, ..) available haha.
That is exactly my confusion! Since now there are so many options. Should I focus on a transpilers like TS or ES6 or plain-old ES5? I can take the long way and start from the bottom but I want to know whether that is necessary or I can just work my way up without ES5?
No, the actual characters themselves aren't changed. It's just a visual effect provided by the font.
Oh, that's OK then, carry on! :)
Ah! No the original characters remain intact. Ligatures just provide a different presentation for a sequence of characters (this is particularly useful for cursive fonts and scripts that require connected glyphs for optimal presentation).
I like the idea of the on-keyboard selection, but I don't really need that. So, uh, I took off the dollar signs for [this one and got the math right](https://jsfiddle.net/HeejulLee/89804fhu/2/). The example code you gave me led me to understand how I should put the math. I still kept the messy code, because I don't feel like thinking about cleaning the weeds when it's not even working properly. Now, the problem I have left is the Shipping Tax. It should add to the grand total when it is checked, no matter what buttons are checked above it. Edit: The Shipping Tax is charging: Shelf = $10 Drawer = $15 Desk = $20 &amp;nbsp; I'm sorry hahahaha but thanks for helping!
yeah, this one seemed a little convoluted for a "top 10 common mistake"
Go right to ES6. Transpiling is easy (I figured it out...) so why not? I'm using a library right now that is half written in ES5 and half ES6. It's stupid fucking difficult for me to recognize new syntax vs. old. If you're trying to learn for yourself, go ES6, if you are learning for a job learn whatever they want you to.
If you are referring to io.js, they have merged not just in code but in actual maintenance and formed the "Node.js Foundation"
Current V8 is 4.6.85.31 as of Node v5.5.0. They are fairly quick to turn around support for newer versions of V8 that bring notable features. I imagine this will be a pretty quick turnaround considering how many people will want it. That said, here's the Github issue kicking off integration: https://github.com/nodejs/node/pull/4722 And here's the branch for the integration: https://github.com/nodejs/node/tree/vee-eight-4.9?files=1
I just use npm search to find a package that does what I'm looking for. Does it need curation? 
One key advantage is pre rendering HTML on the server side with the same code you're running on the client side. That means you can make a webapp that both loads incredibly fast and has all the advantages of offline, client-side optimisation.
I think it's a very common problem to have something that has to be done on the server-side to ensure correctness, but is also useful to do on the client-side to provide faster feedback to the user.
That's a great suggestion! Definitely something we'll take onboard. I'm expecting our archives to be accessible from many different places later on, so having a default number that's feasible for all locations would be ideal - but having it dynamic like that would be best.
This will be great for node. It'll be a little less so for browser developers. The fact that The Samsung S3 is still showing up on my analytics as 1% of traffic means another year of support. Safari has been pretty awful with ES6 support too. Apple typically only supports features that benefit their endeavors. They lock out all other browsers so, no matter what icon you tap, you're getting WebKit... and not straight WebKit, you're getting Apple's WebKit. Desktop is even worse. Microsoft did us a solid by deprecating their older deficient browsers, but users will be holding onto them tightly for years. My honest, albeit, pessimistic opinion is that we won't be using proxy objects for widespread web development for about 3 more years. 
npm3 does flaten dependencies. There are many package managers. We have the option to pick the one we want to use. You might want a package manager that makes certain distinctions for you, while other people do not, and that's okay. 
Very cool, thanks.
&gt; "there's nothing that can can handle this except JavaScript" One example: I haven't seen any other language where the server can render virtual-dom and the client can update it using the same code. I also haven't seen a language with as a nice of a streams interface. Modules make js super compact and easy to work with. Pair that with npm and you've now you've got a huge amount of advantages. But ultimately, js is a programming language. Isn't it great that people who prefer this language get to use it on the server?
By unstable, he means rapidly supported.
These newly supported features are almost always slower and and will be until the v8 team has time to really optimize them. For example, using the Map object is slower than a basic object (at least it was a few months ago).
Maven central also has a huge collection of packages, a lot of which are of much higher quality and have been thoroughly tested throughout the years. I doubt that anyone would choose JS on the backend because of libraries.
How can MooTools breaks instead of overwriting the standard with his own API. I can do `Array.prototype.contains = 123` if I want...
This is good info, thanks! So I guess my next question then, is how would I run something like mocha or webpack from within a script where I could monitor it and then throw an error code based on it's result?
So it sounds like mocha is a non-issue for now. Thanks for this info.
Seems to be more than good enough for Netflix and Walmart, to name a few.
&gt; Well, from a gaming perspective where you may need to run logic on both sides, this is a huge boon. Unfortunately, the performance isn't quite there yet for most types of games. &gt; That's kind of useless since most games aren't usually written in JS anyway. &gt;It also lets you create some interesting ideas like Meteor, where you can send a snapshot of the DB to a client (containing only stuff they could normally access, of course), and they can essentially run that site offline. Not a JS on server only idea, but it greatly streamlines the process. I have mixed feelings about Meteor. At the same time I like the idea, but I've seen a few applications built in Meteor that have gaping security holes thanks to the authors not paying enough attention to its architecture. &gt;It also lets you focus your coding ability on a single language, allowing you to become more proficient overall quicker. I would argue that learning JS isn't a very good starter experience since it isn't a great language by any means. In fact, it's almost a textbook example of a poorly designed language. I would be wary of teaching JS as the first language. &gt;Concurrency becomes very easy working with a single thread language that treats spawned threads like an asynchronous process via web workers or child_process. I don't see how concurrency in JS is easier than in languages like Java. If anything, it's frustrating and harmful for beginners. &gt;Also, as /u/thejmazz has said, NPM is phenominal. So is Maven central and others. Once again, I don't see what makes JS special in that regard. &gt;Programming overall has a lot more of a social aspect than I think some people realize. The more widely used a language is, the easier it is to solve problems. But Javascript *isn't* as widely used as other languages on the backend, and its certainly not a better fit than the alternatives. &gt;It's bizarre because JS used to be the language everyone made fun of. Now, it's gunning to become one of the most important languages in the history of programming. It's still the language almost everyone makes fun of. Just because JS users are more vocal, it doesn't mean that JS is good or more important than other languages.
Why not? It's good enough for the majority of web applications and you can have full stack developers who only need to know one language.
CS didn't support most ES6 features for a long time. 
Grunt is still alive :)
I still use it.
&gt; straight WebKit, you're getting Apple's WebKit Funny because WebKit was (or still is?) originally ~~made~~ forked by Apple from KHTML. The one in Chrome/Chromium is actually a fork. Edit: With relevance in mind, Google obviously doesn't use WK's JS engine (JSCore). Edit2: history.
Gulp is better
Yes, but not as perfect as with TypeScript. For example, a linter can't see that you pass an HTMLDivElement to a function. In TypeScript you have to specify it, in turn you get autocomplete on it. Sure, you can type with jsdoc, but TypeScript feels way superior in that regard.
I don't really see what the point of asking your question is if you are going to dismiss each point without taking the time to program something first hand following the examples everyone is giving you. 
Cool, it's gonna be interesting to see how big impact proxies will have on libraries and frameworks
Fixed.
It's new syntax that's supported by many (but not all) modern browsers that your average person might use to view your site. MDN is always a great source, and has more information on it [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings) There are a few tools that can take code written using the new syntax that's come out in the last year or two and re-write it into what you're used to seeing (and therefore what older browsers will support). [Babel](http://babeljs.io/) is among the more popular options, though how you use it will depend on what other tools you might be using (such as grunt or gulp) or if you're not using any others at all.
I don't feel the need to use Grunt, since I am doing very basic things on my projects (ES6 polyfill, minification mostly) with Webpack. The config is a bit painful though .
Well clearly the javascript community disagrees with you on that. "Universal" is another term used but honestly it doesn't really matter as the concept holds true: The same piece of code can run in the server as well as the client.
One example would be a single web app that could run and render entirely in the browser but also be able to be server side rendered if needed without any code changes. This is currently possible and is being done in the React community.
civil war will need to be fought.
React itself in current state is not a long-term solution ;-) Ugly hacks, things in swing and getting deprecated, version 0 for reason, and the company behind likes to "break things" :)) It must be an irony to recommend React to someone who just got burned by Facebook so badly he doesn't want to hear words BaaS any more. This article explains it quite well: https://medium.com/@burkeholland/facebook-is-creating-a-house-of-cards-33ce47144154#.2qo022agj Plenty or Angular projects with Redux, Flux, Webpack, whatnot. I wouldn't see much point to use React itself with Angular, but even there you are covered by the project called `ng-react` :) 
Kinda surprised that Proxies weren't implemented sooner after everything moved away from `O.o`, but yay. Now I can start to move away from my crappy little three-ways-of-doing-the-same-damn-thing wrapper.
Like an open spec that makes ES6 future proof contrary to CS ? Like a wider community of developers ? 
Well, that has nothing to do with language features... Anyway, if we are talking about ES6 in general, then yes I totally agree with you. That's why I'm thrilled CS is finally embracing ES6. My company has a lot of JS projects written in ES5, ES6 and CS. The way the JS ecosystem has innovated lately within ES6, I was starting to get impatient with our CS codebases.
Principles of Object-oriented Javascript by Zakas was a huge help to me
 let li = document.createElement('li'); li.innerText = 'blah'; document.body.appendChild(li); It just boils down to creating an element and appending it. From there, you could use `setTimeout` to delay a function from running that will remove the li.
Um...really? From the Decaffinate project readme: "JavaScript is the future, in part thanks to CoffeeScript. Now that it has served its purpose, it's time to move on. Convert your CoffeeScript source to ES6 JavaScript with decaffeinate. [...] Preserve whitespace, formatting, and comments as much as possible to allow a full one-time conversion of your CoffeeScript source code." And decaf appears to have the same goal; "Decaf grew out of the frustration of having to refactor coffeescript to es6 syntax". Which is something you would do as part of converting your codebase from CS to ES6, but not otherwise. The clue is in the name: They exist to remove the caffeine (ie, coffee) from your project. :)
I use it for all of my projects (personal and professional) - Have had no problems with it and I prefer the config-driven approach over gulp. I've found the ecosystem to be anything but dying.
/r/dailyprogrammer
Thanks! You're correct on most of your assumptions here. 1. I believe I'd added the semicolons there in a stab to see if that was what was wrong with the code, but I'd forgotten to remove them. That being said, I would agree that I'm still getting a grasp on the difference between *declarations* and *expressions*. 2. I have a decent understanding of the need to call JS after the HTML element(s) it's going to affect. However, I didn't think about how JSFiddle and other similar tools would handle it, and things like onDomready are things I'm not yet familiar with, though I am aware that they're out there and that I need to get a grasp on them. Regarding my apparent lack of understanding of setInterval/setTimeout, you're correct! I'm going to work on getting a better grasp on it this afternoon though, so thanks for pointing me in the right direction!
1. There's some value to being able to share code between the frontend and backend. This can be easily overstated, but some model code (often related to validation) is often portable. 2. If your app logic is mostly on the frontend, your backend will basically just be an API server, and thus could be in any language, but you may want to pre-render it on the backend (a so-called "isomorphic" or "universal" app). Pre-rendering a JS app, as a practical matter, requires JS on the server, and if you already have JS for the pre-rendering, maybe just go ahead and use it for the API server parts too? 3. Again if your logic is mostly on the frontend, then it will be mostly written in JS, which means most of your devs will be familiar with JS. Someone has to write the backend though. On a large project, you might have seperate frontend and backend teams; on a small project it's probably just one of your frontend devs who gets tasked to whip something up. 4. Increasingly build pipelines (grunt/gulp/webpack/browserify/whatever) are based on node.js. Not a great reason to write your API server in JS, but another reason why node needs to exist and be installed *anyhow*, so why not? 5. Five years ago, the state of the art was vaguely RESTful APIs. Now there's some very cool work being done on tools like GraphQL, Relay, and Falcor. But...they're all being written in JS. And I realize that just raises the question of "well, why?!", but the fact is they are, so if you want to use them...you need JS on the server. 6. npm is really quite nice 7. Why not? It's not like PHP is without warts. :)
just so you know, feb is 29 days this year (if you're basing that 28 off how many days it usually has).
&gt; Map object is slower than a basic object Using `Map` for any `Map&lt;String, ?&gt;` is wasteful and most likely will stay that way. But if you have non-string keys, you really can't compare `Map` and `{}`/`Object.create(null)`. They have wildly different behavior. Side note: Afaik arrow functions actually already are faster than their compiled counterparts. Node core switched everything over recently because of that.
Not just how, unfortunately. Encrypting is half the problem. For example; Is your VM secure in memory? Can a software that have user access read the passwords as they are decrypted and before they're removed from memory?
Yes, because It Works™. Plus, (contrary to popular wisdom in JS-land), the build tool is the least interesting and least novel part of the problem we're solving. Once you've got one that works, move on to solving real problems instead of rewriting the build chain every week.
Performance issues: use the browser profiling tools. Bugs: write tests for your code. Otherwise: `console.log()`
There is always room for improvement. Grunt rebuilds are slow and it has no support for hot module reloading. Webpack (with dev server) has in memory partial recompilation with hot module reloading on CSS and React components. This means the page can refresh CSS and React component code without refreshing and losing your current state, pretty neat huh? These things significantly speed up the workflow and increase productivity, contrary to your wisdom.
I tried dev tools for bugs/performance, it is not enough (very old code, tons of files, no comments etc). And if I start writing tests, it will take me months to reach anywhere and my manager wouldn't allow it. My task is to find as many bottlenecks as possible and band-aid them to work for the next 6 months to a year (another team is re-writing the codebase). Thank you for your reply.
Np. Actually, lets back up, what exactly are you trying to achieve? Have users been complaining about 'slow parts' of the application? Do you have concrete reports of bugs or crashes? What is your task here? Who gave it to you? Why did they do that? Or is this more of a "I dunno, just make it stop being bad" kind of situation? I ask because if users are saying "when I click the thing then it gets slow", then you've got a good indication of where to start looking :)
Well I can pretty much code my way, I know arrays, objects etc have a notion of prototype but still wrapy head around some concepts 
As opposed to Flash, Unity, Java Applets, etc.. Not an unreasonable qualification considering that a lot of web games are made with some of those technologies.
The bug report says "this page is slow" - there are ten thousand things happening on that page. I kinda have an idea where to look, by using dev tools of the browsers. What I am looking for is a tool that will give me function wise, how much time the page takes. And save that data for comparisons later (Something like blackfire for PHP). I don't know if it exists for JS, but I figure it is okay to ask here?
I'm curious what the 9% is that remains to be implemented.
Thank you, hadn't used this before
But none of those are needed to make a web site and everything has to have HTML. Then, again, you can't make much of a game with HTML alone which leads to my point: I often see sentences like that on reddit. "I just made a web page using HTML and CSS". Well, no shit Sherlock.
I almost said something like this would occur to the Microsofties bragging, a few weeks ago, about Edge's positioning ahead of Chrome on ES6 support. That Chrome would probably run by them soon but I just didn't know when.
My team has been using it for nearly three years now (July of 2013). I have tried gulp/webpack/npm scripts on other projects. I have written about half a dozen grunt plugins. It is a nice balance between configuration and code. Configuration is nice for the other team members, the custom tasks are nice when you absolutely need it.
I tried eloquent twice not a fan of the book never got past a few chapters. I started you don't know js which I like more. Edit : it tried to live it wanted to love it. I understand why some like it though and the annotated version seem nice
Thanks. I know this has been debated ad nauseam, but the question has even arisen in my own company with someone sharing the video internally, so I made this writeup to be able to link it later and avoid repeating myself. 
Yeah, not necessarily better (thats very subjective) but I think its fair to say that Gulp currently has a much more thriving community. People are definitely doing a lot with tools like Webpack and other module bundlers but I see the purposes of these vs Gulp/Grunt can be pretty different. 
You are absolutely correct that when you can't use some unique, stringable value then a Map is indispensable. In my situation I have a lot of objects with unique IDs and can use Map&lt;Object&gt; or dict[object.id]. The latter was 20-30% faster for my application.
https://kangax.github.io/compat-table/es6/ I guess it's CH49 or CH50 column
Thanks.
Exactly. Use the tool you are comfortable with and gets the job done. 
Thanks, fixed.
Better late than never. Thanks for the reply. +1 to specifically pairing falcor with redux. Speaking of, what's been the the most effective way to do that, in your experience? Why do you need the separate path for changes, if falcor supports web socket model sources?
Ah, you're the author? In that case, good job: I found it very clear and well structured.
Does anyone really care all that much in the age of babel?
Fourteen hours is enough to write a simple web application. So go do that. Don't worry about a framework or tooling - just build your first end-to-end application.
Grunt is absolutely alive and well... As another user put it, it's maturing and transitioning to a new group of people leading the project.
&gt; What is your preferred method? The real deal, of course. http://www.2ality.com/2014/09/es6-modules-final.html
&gt; What are the disadvantages of just doing Site.com/uploads.html?id=12345 where 12345 is the id of the content submitted? It's (subjectively) ugly, harder to type, and conveys less semantic info. If there's a profile page for each user, then I'd say that `/profile?id=12345` is probably the worst option, `/profile/12345` is marginally better, and `/profile/bob` is the best, because why are you letting your internal IDs be visible to users? It's an implementation detail. Every character the user sees is valuable; use it to convey semantic information. (Also note that the last option is what Reddit does.) The advantages, however, is that it used to be slightly easier, although modern frameworks more or less remove that advantage. (Also, this isn't a JS question.) &gt; I've read that google executes JavaScript on websites so it doesn't seem like the id method wouldn't be indexed by Google as long as there is a link to it somewhere on the website. That's utterly unrelated. With a url like `/foo/?bar=baz`, everything after the ? is a query parameter interpreted by the server, and the whole think is just a link, full stop. Nothing to do with JS. &gt; Let's say you generate a new page for every user who creates an account. Wait, what? No, you're way off base here. Nobody is creating pages; it's all being generated on the fly from a database. We're just discussing how to structure the URL that makes the profile controller pull up the user record with an id of 12345 (or a slug of 'bob', as the case may be), load the profile page template, and render out some HTML to the browser. &gt; If you as a webmaster wanted to change how the page looks, you would have to recreate all the current user pages since all the user info is already hard-coded into that page. Yeah, back in the 90s. Not relevant today. &gt; Another large issue is that if you use the user/username.html method, your hosting cost would rapidly increase since you're now hosting a lot more html pages Again, no. &gt; So is the only disadvantage to using the user.html?id=12345 waiting for the ajax request to finish And again, no. What that does is tell the server, basically, to execute the 'user.html` file passing it in an id of '12345', and return the result, which would be expected to be the user page for that user. There's no ajax calls happening here. Now, a completely different way of handling things would be a link like `/profile#/?id=12345`. Anything after the hash is ignored by the server, and interpreted by the browser. This would normally represent something like "send the browser the Single Page Application for displaying user profile pages, start it up, and then get it to request the data for user 12345". That's 100% different, and yes, it has a lot of disadvantages, such as being really slow, needing to wait for AJAX requests, and some big questions about what search engines will do with it. On the other hand, SPAs have some advantages for some purposes too, but...yeah. Big difference. TL;DR: URLs don't really work the way you think they do.
I have to admit I haven't studied ES6 modules as closely as other areas, but it looks like modules are inherently tied to whole files. So if I wanted to do something as simple as this... var publicThing = (function () { var privateData; return function publicThing() { // ... }; }()); To use ES6 modules, I'd have to move the contents to its own file, right?
Comparisons of things like preact vs react are never going to be completely accurate. All the larger frameworks will generally trend toward a jump in speed then slowing down slightly over time as they implement something and then slow down some as they deal with edge cases of different browsers (you'll notice that most smaller and newer frameworks don't have all the codepaths needed to support older browsers). I'd also add that microbenchmarks aren't especially useful at judging framework performance while doing non-microbenchmark things.
I'm glad that you did these benchmarks. The only thing I would suggest is to add a control (native JavaScript).
its for seo / google indexing there are some cases where you wouldnt want the page to be indexed by google, ?id=123 is preferred there. `reddit.com/r/javascript/comments/123/workhtml-title-gore` indexes better, looks better (and therefore) gets more clicks, and ranks higher) than `?comments&amp;id=123`. 2/3. the point is make a template: `&lt;p&gt; {{ $Username }}&lt;/p&gt;` and then you just change your template. the pages are never stored to the disk, just generated automatically via template.. using a template is sweet now in 2016, its usualy just `template.view('user.html', {Username: 'joe', email: 'foo@bar.com'})` or similar. ---------------- disadvantages include using apache mod_rewrite, having to build or use a url router, and putting that in your index file. (but most of these are handled by framework) ----------------- really its for done for SEO and professionalism. also really its entirely the same, the way this works is it redirects everything to your index file: `index.php?/r/comments/123/workhtml-title-gore` so 'index.php?user/123' vs 'user.php?id=123' ... ? its totally the same.
In some cases I do have some private functions. I noticed I kept changing the way I was implementing these sorts of things and started wondering if I should make them all uniform. I guess I don't see any harm only using pattern 2 where I need it, but I do rather like the readability of it
What? webpack does so much more than copy and rm, what are you going on about? Grunt doesn't do any of these things. It has some FS helpers, but those aren't used by people consuming tasks (usually). They are meant for task authors. I really don't get your point here and it further confuses the topic about using Grunt vs something else.
I suggest reading through [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS). It taught me things I never would've imagined existed about JavaScript.
Then I can't get automatic security patches from the repo using apt periodic like all my other software. So I won't.
`bind` [was finally made fast in 4.9](https://chromium.googlesource.com/v8/v8/+/97def8070cbb979419c041c3732d5e11779f79da) which means there's actually not much difference between using it and arrow functions, but arrow functions are generally more readable. I don't see any reason why `Map` couldn't be optimized to be just as fast as raw objects for primitive keys. Given how v8 [constructs hidden classes](https://developers.google.com/v8/design?hl=en) for many types of object access (which I'm sure you know, but I'm just linking for reference), there's no reason why some smart optimization work couldn't make `Map` the no-brainer choice for almost all data storage. 
Update on the situation, [we finally figured out that this will be fixed in Chrome 49, and that it works in Chrome's dev build](https://github.com/WhitestormJS/whitestorm.js/issues/19#issuecomment-177134854).
Thanks for the feedback. In fact I wrote a first version of the article which was too harsh, decided to sleep on it, and I re-wrote most of it the day after, but then I got a strange bug where Chrome was deleting things instead of formatting, while Firefox worked correctly but messed up the icons (with cross-origins errors popping in the console). I tidied up the two last parts but didn't re-format the beginning (which I had kept from the first version.) I'll fix this. edit: I removed unnecessary emphasized parts (about half the highlights ^^' ), hope it's better like that. 
Thanks, though the example looks good to me, there is the risk of them saying "looks the same but hey, you use class, we're not, it's not the same thing", that's why I chose to only craft a js example to stay close to their code. But I hesitated and thought about introducing SRP/ISP before deciding to stick to the simplest and more focused version. 
System Ruby, Python, GCC, are all like that. System versions of languages are always out of date and more finicky.
I don't think so
Are you seeing demand for it among jobs? I hear so much more about React these days.
 npm install -g n n stable
Aside from tail-call optimization and new RegExp features, I'm seeing a lot of green in that chart.
One of the maintainers [mentioned](https://github.com/nodejs/node/pull/4722#issuecomment-174749322): &gt; Node.js v6 will be out with at least V8 v4.9, hopefully V8 v5.0. Not that that means anything...
So basically, whatever goes into ESYEAR is what managed to get to stage 4 by YEAR. And the gate for stage 4 is when a stage 3 thing ships in at least two major browsers. So the fact that we're not getting async/await in ES2016 means that not enough browsers shipped it by the time TC39 did their deliberations. At least, that's what I've gathered.
Its the 9% you want to use.
competition is good...now lets see if MS just decides to cheat and leave us for dead.
No. Still WIP.
To be fair, it is all documented at http://coffeescript.org/#operators Can also be used like this: foo ?= 'bar' translates into: if (foo == null) { foo = 'bar'; } Then there's foo or= 'bar' to check if the variable is truthy, and sets the value if it's not. foo || (foo = 'bar');
I never bothered with it. Went with Eloquent JavaScript (then the first edition) and later read the second as well as the You Don't Know JavaScript series.
I'm reading Eloquent, it seems too basic and slow paced
Thanks, it is hard to find the right plugin! 
How could i display this on a page while it is an external file?
[Debian repository for 4.x and 5.x](https://github.com/nodesource/distributions#installation-instructions)
[**@tripu**](https://twitter.com/tripu/) &gt; [2015-11-19 16:40 UTC](https://twitter.com/tripu/status/667381995438276608) &gt; So glad to recommend excellent work by @\_\_DavidFlanagan, @rauschma, @slicknet &amp; Crockford. I learn a lot from them. &gt; https://www.w3.org/wiki/Resources_about_JavaScript_and_Node.js ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Me too. It's as if he'd move every for loop into a public function and test all those individually.
.catch("Stackoverflow.com") 
wow there are so many Eloquent fans, so popular................I was leaning towards js for web dev
what's so great about eloquent?I read the beginning but i felt like it's very slow paced, did you do the assignments there as well?is that why that book is so good?
Amazon AWS has also started doing this. I believe the catch is that you have to host your application in their cloud though. I think it's free for wildcards too which is cool.
I'm not exactly sure what your point is, but I'll mention a couple of facts about Buttercup that may address your comment. Buttercup's package is between 30 and 50mb on average before being wrapped by an installer. This package is compressed and is slightly smaller. IMO this is not an unreasonable amount to download, but we don't really have much of a choice here. Updates (for patching/security reasons etc.) are obviously the same size (new package is required to download), and this is definitely the simplest way of managing the product. We'll address all issues fairly as the product matures - but installation size is far from being a high priority at this early stage in its development. Buttercup is a security orientated product, so we need to ensure that we can roll out important updates very effectively - if this becomes a problem, we'll address it immediately to ensure our users' archives remain functional and secure.
The tried, but he was happy with his current position and turned them down. That is mentioned somewhere in that thread.
Any love for Eric Elliott as a person, and his free book 'Programming JavaScript Applications'? 
Right - so Maps should be optimized in the same fashion for those that follow predictable schemata, and drop into slow dictionary mode (like objects) when used as data bags. I'm hoping they can make the same optimizations for Maps as for regular objects, or I foresee a lot of bikeshedding about whether or not an object should be a Map or vice-versa.
I think it's important to have read, if for no other reason than the historical context. You will inevitably work with someone who follows the advice given. Cover to cover is only 200 pages or so.
[removed]
I mean to ask not what they currently support but if when they ever plan on moving to the newer version
Have a look into function currying. But as a trite example, this will work. function test(a, b) { return arguments.length === 1 ? function(x) { return a + x } : a + b; }; console.log(test(1, 2)); console.log(test(1)(2));
jup, except for * autobinding: use [autobind-decorator](https://github.com/andreypopp/autobind-decorator) instead * everything is an expression: use `?:` for `if` expressions and `map` for `for` expressions. no alternative for try expressions ☹ * existential/soak: no alternative. `x==null ? null : x.y` is a sad substitute for `x?.y`
 try { something } catch(e) { window.location.href = "http://stackoverflow.com/search?q=[js] + " + e.message; }
Transpiling arrow functions uses a closure, assumedly because `.bind()` has been slow for so long. Here's an example - can't use a shortener b/c AutoModerator will get it: https://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=…=function%20bar()%20%7B%250A%20%20return%20(foo)%20=%3E%20this.foo%250A%7D There are two reasons you still shouldn't use `.bind()` in React's `render()`: 1. It's still slow on non-V8 engines, and 2. It kills reference identify for use in shouldComponentUpdate: (e.g. `foo.bind(bar) !== foo.bind(bar)`). This means you may get superfluous rerenders. [See this discussion](https://github.com/facebook/react/issues/5197). My solution to 2. is the following function on my Component superclass. It requires use of `Map`. It keeps a cache of bound functions and what they're bound to in order to always return the exact same function, if asked to bind the same function to the same data again. This allows for fast SCU. The nice thing is, since `callbacks` is bound to `this`, these callbacks are cleaned up if the element is GC'd. class SuperComponent extends React.Component { // Preserve reference equality at all costs! // We do this by creating a bound function, then storing a reference to it based // on the identity of the source function. Consider this like .bind(), except it always // returns the same fn for the same callback &amp; data. _bindCallback(callback, data) { this.callbacks = this.callbacks || new Map(); let dataMap = this.callbacks.get(callback); // Check if we've already got it. if (dataMap &amp;&amp; dataMap.get(data)) return dataMap.get(data); else if (!dataMap) dataMap = new Map(); let fn = callback.bind(this, data); dataMap.set(data, fn); this.callbacks.set(callback, dataMap); return fn; }; }
Try khan academy. They have awesome JavaScript tutorials. 
what's so great about eloquent, I read the first 40 pages or so...seems to slow paced
I have some java/python background I could've understood the beginning fine but got bored, felt like it was too slow paced. but by reading the massive comments I got I feel like I need to get back to this book
There are two more advanced JavaScript classes on there. You have to start somewhere. 
Right??? I've been working on their courses for the past few weeks. It's really helpful. Good luck!
It's definitely a book for beginners
I'll explain. First, you're not get "REST API access to some blog tables." This project uses GraphQL, a replacement for REST. It means you only need one round trip from server to client to get all the data you need for your view. Its much faster. Second, the server setup is slightly more complex - which is why I've taken all the hard work out of the equation. With this project, you need ZERO support for PHP. There is no PHP...anywhere. Third, yes - you miss out on a lot of WordPress plugins, at least those that affect the front-end. You can still use plugins that affect data, such as Advanced Custom Fields, or what have you. However, you now have access to literally 200K+ npm packages at your disposal. Lastly, this is completely different than Ghost. Ghost aimed to be a simply blogging platform with a dumbed down admin. The only thing it has in common with this project is that it uses node. WordPress wants to be a CMS that can be used to develop complex applications, and it's really hard to do that when you a limited to the current WordPress development experience. This project is aimed at developers - specifically full stack Javascript developers that are disappointed with the current array of node-based CMS' out there. WordPress brings a rock-solid, user-frield admin interface that clients are comfortable with. WordExpress brings a much more developer-friendly environment to allow that to happen. 
I feel like the new meme of 2016 is to create spin-offs of the word "react". This one, unfortunately, completely [misses the point](https://github.com/kolodny/deact/blob/master/index.js#L28). FWIW, the idea of using template strings has already been explored in far more depth here: https://github.com/trueadm/t7 but the author has since moved towards using babel plugins because template strings have the weakness of being stringly-typed (whereas JSX compiles to a true structured tree) Despite all the js fatigue talk these days, I'm actually all for new projects, but you really need to do some research if you want to contribute to this space now.
I'm sorry, but the power of React is state management and dom diffing. JSX is just syntaxic sugar. I personally would expect a "react-inspired dom library" to handle that; thinking react is about a dom-like templating language is kinda missing the point. Not trying to be an ass here, but just pointing out.
Maybe for javascript beginners, but certainly not for webdev/programming in general beginners.
I just went through it recently as essentially my first exposure to Javascript and I think it definitely works as a book for beginners, however I think that Haverbeke makes a few odd choices for examples. Like in chapter four, it would make more sense to teach the format of data structures via a few simpler examples before diving into statistical correlation. It essentially requires the reader to understand an additional, unrelated concept while still trying to wrap their head around what they're learning in regards to JS data structures.
&gt; it would make more sense to teach the format of data structures via a few simpler examples before diving into statistical correlation. It essentially requires the reader to understand an additional, unrelated concept while still trying to wrap their head around what they're learning in regards to JS data structures. That's exactly the problem with this book being aimed to beginners. If you're a total beginner to web development and programming in general, there's just too much to wrap your head around at the same time and you get confused, unable to focusing and understanding anything. The code examples/exercises are too complex for a first-timer.
**O'Reilly: JavaScript Patterns by Stefanov** is an excellent follow up to the Zakas (which is about the fundamentals) and then **O'Reilly: Learning JavaScript Design Patterns by Osmani** when you're done with that one. And for the truly academic approach: **Design Patterns: Elements of Reusable Object-Oriented Software** by "the Gang of Four"
Based on the parameters OP gave, this is likely what the question is asking. My example made too many assumptions about allowing more arbitrary numbers of arguments.
Binge watch egghead.io videos &amp; conference talks while occasionally pausing to try out the things you've seen on your own.
Haha totally! 
I wish I could upvote this comment more. What many people don't realize is this: The overhead of the DOM itself is going to eat into at sizable portion of your "budget". On Desktop it's usually 1/5 - 1/2 of the 60fps budget. On Mobile/iPhone it's more, and on Android it's even more just due to the slower cores. If your framework is using up most of the remaining budget, you have no hope of delivering a great UI experience. It's incredibly important for a view lib/framework to provide as little overhead as possible for this reason, so that you can do what you need to do, and still provide a good experience. It is my personal hope that a lot of the efforts going into this will push all major frameworks to deliver stellar performance, and in turn push browser vendors into really focusing on optimizing DOM interactions. The combination of these two things will lead to a very bright future for the web.
I was building an algorithm on top of Raft for my thesis and came up with this abstraction that makes it easier to create understandable distributed systems. It took me three weeks to implement a mutex on top of Raft (most of that time was just spent understanding and implementing Raft). After I built Conflux, I was able to do it in a few hours. I'm looking for feedback on the idea, as well as suggestions for improving the API and documentation. Thanks!
Those all do different things. Assignment, loose equality, and strict equality. `8=3` is also a syntax error, because you can't have a variable name that starts with a number.
This is neat, would be cool to have as a chrome extension to automatically load whenever you hit a page that returns JSON.
Fair point re: dating; Secrets of the Javascript Ninja is, in my view, a more modern take on the same concepts.
https://github.com/johnpan/whenDefined/blob/0d9b004b42f494b15fcf448d13e86a19c5329824/whenDefined.js#L97 Yeah... I'll stick with using standard module loading.
as a back end dev i read this, as well as watched his video on pluralsight.... it seemed rather fundamental and important for a beginner to understand before they got into bad practices and jquery bs. though the video seemed easier to figure out though than the book. 
How is this "inspired by react" exactly? There's no virtual dom implementation anywhere to be found along with no sensible story for component composition. This is basically just another string-based templating library that uses a fancy new es6 feature for implementation.
How much is lost to that million though, and how does that compare to the money gained through supporting everyone else? Given my scenario above, that would be net $99mil.
Fun fact about function declarations...They get converted to function expressions behind the scenes (for hoisting). This is why you can put a function declaration anywhere within its containing scope and it works when called (i.e., it works if you call the func before the func declaration is defined). I was just helping a co-worker debug some old JS code. He was re-writing function declarations into expressions and they weren't working. If you ever run into a mixture of function declaration and expressions, look out for this. It's an easy bug to fix as long as you're aware of hoisting.
Of course this is the obvious refutation to my example, but my comment was just that; an example. In reality, businesses need to analyze every aspect of their product and customer base to arrive at the correct decision. It is never as simple as "1% of our users is 5,000, so we have to support them." If it takes an additional 3 developers to support that software, now you're back down to net $0 when their time could have been used elsewhere.
AFAIK, Falcor doesn't yet support the server to pushing changes to the object graph. Everything is wired up as request/response. So, your client can issue requests over the socket, but the Falcor router won't yet push graph updates asynchronously. Briefly, the way we've wired with redux is: * We're using thunk-like middleware on our React containers to dispatch actions that request data from Falcor * We also have an open websocket connection that handles pub/sub: 1) adding models to a socket.io room, 2) mapping model paths to redux actions, 3) dispatching those actions to affect the redux state Stay tuned, we're going to publish some examples of how we've wired this up soon... 
This is what I was getting at and should be addressed. Unless the developers of these types of apps can clearly articulate their understanding of these issues, I probably wouldn't store anything too sensitive in them. AgileBits (the makers of 1Password) wrote [a decent blog post](https://blog.agilebits.com/2012/11/08/dont-trust-a-password-management-system-you-design-yourself/) touching on a few of these topics a while back.
I wouldn't exactly say theres a literal translation from declarations to expressions. For example named expressions have a locally scoped name that allow them to be safely self-referential while declarations do not. function foo() { console.log(foo); } var bar = function bar() { console.log(bar); } var fooRef = foo; var barRef = bar; foo = 1; bar = 2; fooRef(); //-&gt; 1 barRef(); //-&gt; function bar() {}
It's debatable. The examples used in the book are often more difficult than the concepts they attempt to teach. 
yeah, chrome extension well be cool 
wake up, read js news, which is about 500 react redux boilerplates, for about six hours, drink myself into a coma, repeat
&gt; reason about Why are academics so obsessed with this phrase? You can "reason about" the behavior of a function, you can "reason about" code, etc.
&gt;Well what if the site has 500,000 users? Now you're at $25,000 a month and all of a sudden it looks pretty darn good, doesn't it? It's not that simple. Developing for 1% of users doesn't come for free, and many businesses fail to properly account for the cost of slowed overall development (or increase in hiring) in order to be compatible with this niche, vs the cost of building new features that attract a larger audience. At an old company I worked out, our biggest client ended up being our least profitable, because the cost of supporting them and all their edge cases with specific software, special staff, outweighed the size of the contract. The last two companies I've been at have been forward in saying "we don't support IE" and could get away with it because of the nature of the business. Likely, a balance can be striked in between.
Thanks for the feedback. I wasn't aware that this was a problem, I've edited it. Also: I'm flattered to be called an academic, but I'm a full-time software developer!
I really feel that it's not a bad alternative to GCM - A good implementation with CBC+HMAC is very secure and highly portable, whereas GCM isn't. Safari is a constant pain-in-my-arse.
It is very opinionated and the first bit is a ton of railroad diagrams. Doesn't matter. Skip the diagrams and read the parts where he discusses the intricacies. The "Good Parts" of the Good Parts book is perhaps 10%, but it's an awesome 10%.
I made a Babel plugin that allows you to export privately scoped functions for unit testing but strip them out for production builds https://www.npmjs.com/package/babel-strip-test-code 
+1. There are a couple of JSON viewer chrome extensions, but none of them are very pretty or give you access to the value (even if they show it, like JSONViewer)
How hard would it be to wrap this in a angular module? I've not experience in Angular. But, I'd like to get stuck in.
Adding my vote for Eloquent JavaScript, 2nd edition. The best part is the built-in editor which means you get to play with what you're learning as you learn about it. Note that Zakas' book Professional JavaScript for Web Developers, 3rd Edition is also good, but I would recommend it after Eloquent JavaScript.
testing, fixing bugs, adding features, and going to meetings
You could try reading Javascript &amp; jQuery by Jon Duckett, although it can be quite easy if you already have a decent level of JS.
It's about as simple as it gets. If you find it overly difficult then maybe you aren't cut out for doing this? 
One can certainly argue as much, but you will find a lot of beginners and advanced coders alike agreeing that the difficulty of understanding the authors examples are often a distraction or even a deterrent to the more important task of learning the fundamental lesson at hand. I've seen far more people agree with this sentiment than not. 
Well, that comment was kinda agressive. Programming is not a talent, it's a craft. A technical skill that anyone - with enough dedication over time and access to proper content - can learn. If something is supposedly aimed at beginners but beginners can't understand it then maybe that content isn't for beginners at all. That's all there's to it.
At my job we use React or Angular, with the option of trying other frameworks if we want. I started out as more of a designer with little FE skills. Studied up and now i'm more of an FE engineer then designer. I love it.
Thanks :)
Ohh cool, great to see that others have started out with little skills as I have. How did your employer look towards your training? Were they accommodating? Were the more senior devs looked upon to train you up?
I'm not sure what a "Javascript Developer" is, can you elaborate? I'm a Web Systems Administrator that also does a lot of full stack developing. I've been coding for about 20 years and all I can tell you is writing Javascript is *only part* of what I do. As a matter of fact, being a Javascript Developer seems to me to be a part of what *you* do as a Front End Developer. Most FED's I deal with are focused on the user experience and interface -- this encompasses HTML, CSS, and Javascript. Many FED's I know are experts at jQuery, have a solid understanding of competing libraries, and a good grasp of Javascript as a language aside from frameworks. In the past few years, many FED's also boast expertise in MVC type Javascript frameworks like Angular or Ember. So, I guess I don't know what a JS dev does on a daily basis.
Not sure if sarcasm but: There are an increasingly large amount of people who deal with only JavaScript for their assigned tasks, developer or whatever silly title your company gives you may be at a broader level if you deal with many things. For example you could expect a "Java developer" would be a developer that works with Java day to day. As expected a "Javascript Developer" would be someone who deals with JavaScript day to day. 
C#, Java (or any statically-typed language) is just a sin. Shame on you (you know who you are).
I think that depends on what kind of job you get. If you get a government job it will likely take so long for things to get approved you'll have plenty of time to learn what you need to.
The `curl | bash` script detects your system and determines which package source to include. You then get security updates like any other ppa. You only have to do things manually when you want to change major versions (node 4 vs 5)
1 is a CSS thing https://css-tricks.com/almanac/properties/c/cursor/ 2 Not really sure what you're asking however, javascript is not generally a visual thing that you see on DOM. If you're trying to display some code use &lt;pre&gt;&lt;/pre&gt;
I was thinking about something similar to this the other day. So cool to see someone built it! Cant wait to play with it!
I think your slack invite is busted.
routine is like 2 hrs in email/meetings, 2 hrs handling tickets/issues, 2 hrs writing new code, 2 hrs fixing bugs if your trying to get a job what i recommend for practice is: make a form, make an ajax form, make a single page app, make a 2+ page app w/ router, make something with transitions, make something with animation (jstween, animate.css, something) should only be a few days. after that youll have experience doing front end JS equal 1-2 years JS work.
It seems to work for me. Try again maybe?
2) Create a div and overlay it on the iPhone image's screen. Use `mouseover` and `mouseout` event listeners to trigger functionality when over the screen (ie, your div) and not when you're... not.
debug?
That's really smart. Thanks for sharing!
I got that but "poor quality" is pretty little explanation for the title of a 45min talk. The Talk took a completely different route away from the title. He did provide solid advice on how to go about designing systems in an environment like node. A little more contrasting between common pitfalls people made and the presented patterns would have been nice though.
Agreed, he really breezed past that part of the talk. The main criticism seemed to be that the node code was mostly written in a messy procedural style, neither functional nor object-oriented. He then went on to talk about good functional/oo styles and kinda left behind the original criticism. (The implication being that node/js either encourages poor programming style, or makes it easy to fall into bad patterns)
Principle of charity: it is not ego, it is merely easier to write your own than integrate a PR. This is especially true if you have local changes that the PR doesn't know about.
JavaScript is such a dense onion of layers. Everyone tries to get tips and advice on how to tackle it. Which books to read, what pitfalls to avoid. All good, but at some point you have to just start cutting. The crying will be over before you know it. 
That's the thing about most programming books. You gotta skip past the stuff you already know, and if you need to look something up, just skip back to read up on it. You don't read these books cover to cover usually.
Imo it's much more targeted as a beginner's series book, for someone new to the language. I believe people who are advanced are probably searching more for software engineering concepts, and such. YDKJS doesn't cover any of that, and you'll probably want to pick up Eloquent Javascript if you're an intermediate rather than YDKJS. Plus, if you want the hard copy, the former is much more affordable, and imho much better.
and who knows ? maybe the author is not confortable with communication, and maybe your code was actually useful. After all after a long period of inactivity the project was updated not long after you submitted a PR - a good sign for the author that it gathers some attention.
3: the original author had made the changes already but left it sitting around on their machine for ages without pushing it to github. 
4: the author hates you
You find it more enjoyable to start with drinking into a coma, then reading about the next opinionated way to live your life.
In general, it's a good idea to ask if PRs are welcome before you start working on one.
You "rebuilt" it and submitted a PR without talking to the author first? Uh. The project was probably outdated because the author didn't have time. Giving him a huge PR to review and then maintain isn't helping him. If you wanted to help you could have created an issue (or multiple) and sent a few smaller PRs to fix them. 
I don't think that the majority of YDKJS is "super" advanced, but it's pretty lol to say it's targeted for beginners. The very name of the series implies otherwise.
I think you took something out of context here. Google fiber exists to piss in carrier revenue streams. My argument is not the one you're painting: google owning everything and then evaluating TLS in that context. It is that google is playing a multi front fight here. They don't like carriers offering competition to their advertising strategy, so they are pushing to encrypt everything under the convenient guise of privacy. Their whole business model is monetizing info about you. TLS'ing all of the interesting data means that they get all of that info to themselves. There is no amount of "you just don't understand" that will remedy that problem. Privacy is a convenient excuse to a critical business threat and they deserve to be regulated over it. 
The last couple PRs were things like whitespace and a typo in docs. So I just assumed it would be cool if I fixed it, maybe I should have asked.
If you don't know how to program, that first chapter or two will seem to move very fast indeed.
my preferences, take it or leave it: * [rollup](https://www.npmjs.com/package/rollup) for projects where combining is the _only_ build step I want to use (no ES6/babel, etc) * [browserify](http://browserify.org/) if I want a simple, It Just Works bundling I've gone with this after my Babel transpile * [webpack](https://webpack.github.io/) if I have a serious project that I really care about how my output bundle looks/performs
Big changes in a single PR should be carefully coordinated in advance and the PR author needs to understand the review burden placed on the project owners in this case.
Hi /u/PrinceZelo, sorry, but we don't allow that here.
System.import will be equivalent to require.ensure, I believe.
;
As someone who maintains a fairly small npm package but still gets a decent number of users and pull requests: if your PR changes more than about 20 lines of code, *especially* if it isn't well-documented, I will try to look at it but it may or may not ever get merged. Imagine going back to something you wrote even 6 months ago and having to perform a code review on it. Not only do you have to make sure the new code fits in with the original intent of the project, you have to remember how the project was organized in the first place and if any of those changes are going to break that. Now imagine you've published this as a module somewhere. Now you have to spend an extra couple of minutes updating the version number and syncing with npm/bower/whatever. Individually, it's not a big deal but it's a bit of an investment of time and brain power upfront. That being said, I absolutely love it when someone contributes to one of my projects. It's seriously flattering. I just don't always have the time to reciprocate.
All sounds awesome. Love webpack, really excited for ES6 module tree shaking features. Any other improvements are just icing on the cake.
Hi /u/mhopki13, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hitting my head against my desk when things don't work. Reddit. Hitting my head against my desk when things do work. Reddit. Fighting with the product team. Reddit. Telling the product team no to their insane ideas. Reddit. Waiting for NPM 3 to install or compile dependencies. Reddit. Telling the developers on my team they need to start writing unit tests. Hit my head against my desk. Dealing with merge conflicts. Reddit. Merging pull requests. Writing unit tests. Reddit. Home time. Check emails at home. Update Asana tasks at home. Go to sleep at midnight. Repeat.
It doesn't matter if you use containers. What matters is that you can horizontally scale it. That means that no state can be stored on the nodes that connect to the clients. Each node should connect to a backend like Redis or Kafka or something else, such that each chat message is distributed to all other nodes with clients that care. Stick a load balancer in front of everything after you've got that down and you'll be golden. 
Don't use `setInterval()` do this instead: function update() { // do stuff setTimeout(update, 250); // make sure there is nothing after this line } update();
&gt;Is it safe? &gt;Uh… it evals both user input and random code, unchecked, from an external site. This is what security-minded folks would refer to as Very Bad™. haha
My apologies. I figured this met line 2 of "Posting: General" where is reads "Posts must be related to JavaScript, even if indirectly."
 I make stuff open source because I want my work to be useful for others. I don't make it open source to burden myself with support and maintenance for free. Even the smallest PRs can pose an incredible amount of work. I've got a github project with some pending PRs but checking them out, testing them and then possibly merging them is a lot of effort that I'm not willing to take. Trivial PRs are welcome. Small PRs that can be merged without conflict and are easy to test are also welcome. As soon as conflicts or testing is involved, chances are they will be ignored. It's not about ego, it's about not wanting to deal with the large overhead associated with PRs. 
 return this.getTasks().map(function(task){ return `&lt;Task key=${task._id} task=${task} /&gt;`; }); } Also the ES6 is a little wordy, the return statement is not needed 
DataTables. Lots and lots of sortable, filterable, exportable, customizable, pageable, rotten DataTables...
Gotcha, basically no products period. It might be helpful to other users to update the guidelines to reflect that. Since not all product posts fall into the "Posting: Advertising &amp; Self-Promotion" section.
Could you elaborate on when I should be using state? I recently hacked together a state machine in my most top level React component to keep track of my app's data, but I think I'm realizing how unscalable it's becoming. I think I need to implement something like this instead. Awesome article!
Thanks! It means a lot.
Understanding this is what makes a junior dev a senior.
I don't suppose you can use modules in the browser yet, with Canary or FF developer?
Basically the ability to more easily "reason about" a program is an indication of statelessness, immutability and side effects being "pushed to the edge" of an application (with the "core" being composed of pure functions) There's really nothing super academic about it. You'll need a working knowledge of a lot of FP concepts to become a top tier frontend engineer in this day and age.
Sounds mildly annoying but this is probably an overly dramatic reaction. Promote your fork or...just accept it as one of those shitty things that sometimes happen and move on. :)
How is your library different from the other react-konva library? https://github.com/search?utf8=%E2%9C%93&amp;q=react-konva
[Plagiarism.](http://javascriptissexy.com/javascript-objects-in-detail/)
You can read an article I wrote it talked about how we added react as another layer to our requirejs backbone app https://medium.com/@royisch/moving-to-react-redux-in-baby-steps-aea0402624bf
You need to unlearn *a lot* of bad shit that the ASP.net world has taught you about the way the web works... it took me nearly two years to de-program myself. First, forget about the notion of a "postback". It's a poor abstraction invented by the authors of ASP.net that [has done more to mutilate generations of promising web developers than any other web tech I can remember from the last 20 years](http://www.brainyquote.com/quotes/quotes/e/edsgerdijk201164.html)
Could you please provide a link to "Exploring ES6" book. Couldn't find it. edit: never mind http://exploringjs.com/
You should watch some videos where Ryan Dahl (creator of Node.js) discusses the reasons he made it. Nobody has really mentioned it (though a few have touched on some related concepts,) but the primary reason that Node.js exists is because it differs from the traditional threaded model that most web servers were using prior to NGINX and Node.js proliferated. Node uses an evented system, in contrast to solutions like Apache or writing a web server in Java (for example,) where you need a new thread for each client connection. This allows you to use very little compute to achieve reasonably good performance/scalability. That is extremely valuable, and when you add in all the other benefits it makes Node a really strong technology. It isn't perfect, but it's remarkably efficient in its strengths. It's easier to scale than a threaded model, to be sure.
`return false` stops the event from continuing so I don't see why not
Thats not an anon closure. Its an IIFE so you can have your own scope. A closure is when you return a function and still have access to things that are in its scope.
Feels fucking amazing, thanks for asking.
Performance. https://github.com/olimsaidov/react-konva generates unnecessary empty DOM elements.
It's new sugar for writing anonymous functions, especially one-liners. parameter =&gt; expression (commaSeparatedParameters) =&gt; {expressions} or something in-between
Its a jquery thing. Returning false from a jquery event handler will be the same as calling: event.preventDefault(); event.stopPropagation(); You're seeing the effects of `stopPropagation` which prevents the event from triggering handlers further up the DOM, which includes `live` handlers (`live`, by the way, is deprecated and you should be sticking with `on`). More info: http://api.jquery.com/on/ Note that the vanilla DOM API also supports a returning false behavior from standard event handlers, but this will only be equivalent to `event.preventDefault()`, not also `event.stopPropagation()` like with jquery. It's recommended, however, that for the vanilla API you use `preventDefault` and `stopPropagation` directly instead of relying on the return. 
one major problem in the js world is that many developers are more focused around tooling then on actual solving problems. when you learned grunt, gulp arrived and was the new kid. then there are commonjs, require or brosify, there will be a b c and d .... same same, but different. stick to what works for YOU not some fellow kitchen sink developer. you have to solve real problems and should not think longer then sou should about your tooling. I am still using grunt because it gets the job done and i accept the loss in speed but welcome the configurable setup. like that all of them have their upsides and downsides. i recently wrote a small grunt cli tool which just gives me the basics to start developing because I had the same problem like you. tl;dr: find or build something which serves you well and gets the job done. spend more time on solving the actual problem then on sorting your toolbox. cheers edit note: removed the name of the tool to not promote it
This is pretty neat! You have a GH link handy?
hm no, that was not what my intention was. my tool is not meant to be a replacement. i wanted to give an example that even "old" tools get the job done if you settle with one and that you don't have to follow up with each new tool that rises at the horizont. 
Read about the latest JavaScript drama. Reading tweets about people bashing callbacks because they don't know how to code properly. Reddit. HackerNews. Write some code. Reddit. Github. Reading about the cool new async feature that will be available in ES2022 but we can use today with Babel. Trying to wrap head around hundreds of lines of code configuring Babel / Karma / &lt;latest hype tool&gt; and cursing. Checking JavaScript conference videos and trying to filter out only videos that actually show some code / anything remotely related to code. Reddit. Code. Destiny (PS4) news. Reddit. Code. Etc.
I saw there is an example using React on github. Do you reuse DOM or destroy it and build new ?
&gt; if you have a public repo, it's inherently open source Technically no. There has to be an open source license attached to the code, otherwise it is just random copyrighted code which you found on the internet. 
Looks like a good flow to me.
hmm thanks man, I'm gonna give that a try 
thanks man I'm gonna do that exactly
thanks man, I'm gonna do that
I really don't like the whitespace that appears, when scrolling fast on my nexus 5... This really isn't necessary. 
Then you simply comment there
Wow, thanks for that in depth description.
This is one of the biggest obstacles working in .NET-land (people not knowing where the client/server boundaries are).
What really bugs me is the lack of communication. The maintainer may have had good reasons for not accepting your pull request, but you have no idea. That and he/she is so slow to take action on updating this code. Those two reasons only would make working with this person (and their projects) too frustrating. I can take rejection, but at the very least point me in the proper direction.
If we're going to nitpick, let's nitpick all the way. I can attach the MIT license to any random code I can copy-paste, but that doesn't make it automatically open source if I'm not the rightful owner.
It is a nitpick right up to the point that someone wants to sue you for copyright infringement or not following the license. 
I'm as lost as ever. Which of the ways described am I supposed to be using? How am I supposed to know which one is applicable to my situation? Honestly, JavaScript development is agonizing to grasp. I've been programming for decades, using everything from Basic, assembly, C, Perl and so on. But even after years with JavaScript I still feel that true understanding eludes me.
I think not doing something because you might not be cut out for it is missing a lot of opportunities. So I'll take all the handholding I can get. May be I won't be the next noam chomsky, but I can still tell people I tried.
 function thisMessage() { this.approve() } I.thisMessage
@LookWordsEverywhere my new commit does not use Array.prototype. Depend on jQuery? Yes, until native Promises becomes a standard. Until then, a small lib of 100 lines cannot use its own promises. @kpthunder seems you are bothered by setInternal, i will look into it, maybe loop with setTimeout is better
There are various problems in the JS world right now : - ES6 transition : new language not supported by most browsers , especially mobile ones - Module systems : ES6 has a module system , but obviously browsers do not support it right now , nor they support node js module system - AMD/UMD/ ... is the old way to create modules in the front end , which is not compatible with neither the new ES6 module system nor nodejs module system - JSX is a language on top of Javascript you need a transpiler in order to make JSX code run the browser isn't going to run that code. So you need a tool to transpile then package all this mess. The irony is that Javascript is a dynamic language that now suffer from the exact same issues as compiled languages but without the advantages of statically typed languages : crazy compilation times without any static type safety. MY ADVICE : use Typescript directly. Typescript supports BOTH NODEJS MODULES AND ES6 MODULES AND CAN COMPILE TO ES3 OR ES5 ! it also support JSX(through TSX files) problem solved. Obviously Typescript can't manage assets(json,css...) but why should it ? Using typescript compiler is just THE BEST solution right now. The rest is slow and messy.
Not that controversial in my opinion. If people want to inundate their projects with dependency hell then that's their poison. If they reflect on the health of their project and discover a dozen major version specific dependencies interwoven into all facets of their code then they are doomed. This reminds me of a pregnant step sister (age 19 and pregnant with kiddo #2) who we let stay in our house. We let her stay to help her out so that she could get her life on track. She was depressed that she would have to pay for child care (she just assumed we wouldn't mind watching her kiddo) so that she could go on dates. People are going to stupid lazy short-sided shit that buries their code in bad decisions. Not a controversy.
Nice to see a more pragmatic comparison than the usual nonsense. As someone who's worked with both, I've had a quite similar experience.
Once here.
&gt; That said, do you really need to use modules? Well, even my amateur stuff is getting little too big and unwieldy (hundreds of lines) ... modularizing should help. &gt; So far I've had zero problems adding a bunch of script tags to my page There are situations where there are problems. E.g. I haven't found a way to properly use dust.js plug-ins without require(). Also, I'd like to learn the right way(tm) to do front-end development :)
You still need to be very careful with cyclic dependencies: // entry.jsm import {b} from 'dep'; export function a() {}; // dep.jsm import {a} from 'entry'; // a is not initialized yet, throws const b = a(); export b;
and Vue is the easiest of them all, and it still feels like you're writing javascript. 
The fundamental problem is of architecture. HTML was designed for post-backs and print layout. JavaScript was written in 12 days. This was fine for a simple form where you type in your favorite author and get a table of books back at the library in 1999, but it flies in the face of UI application architecture since Xerox Park. 1. The DOM is redundant. Data should be stored in data models, pixels should be bound to widgets, and their values calculated on the fly. Most desktop UI frameworks have this concept, but the web does not. So things like Angular and React (and jquery soup) exist to solve a fundamental problem: all JavaScript apps essentially exist to synchronize two lists: the data model and the DOM. 2. There is no native widget framework (web components might finally solve this). So there is no built in way to re-use widget code. 3. There was never any sensible layout engine. Rather than incorporating a unified layout engine that sizes from the outside in, the browser has many layout engines, block, inline, inline block, absolute, tables, and the CSS grid to name a few. It was developed for print layout, not windowed applications. Each wall that they hit, they just added on more complexity. 4. Everything is by default global. If you import any CSS, it can jack with all other CSS on the page. If you create variable in JavaScript, by default it gets slapped on window. With no concept of encapsulation of concerns, of course it's going to get terrible. 5. JavaScript is a crap language, shat out in 12 days. I'm not saying it's not fast. JIT made it plenty fast, but it lacks a built in module system, static typing, dependency management, and native compilation phase. 6. JavaScript developers have historically been graphic artists forced to write code. Many don't understand computer science principles, never programmed in statically typed languages, and don't understand these fundamental concepts. 7. Most people with Comp Sci backgrounds look down on this mess, and don't want to touch it. This leaves the younger generation of JavaScript programmers to re-invent the wheel: static typing, threading, mutexes, module systems, dependency management, versioning, encapsulation of concerns, binary encoding, etc. Because of these fundamental problems, you get things like grunt and gulp and bower. You get Angular and React and Ember. You get browserfy and webpack. You get feuding frameworks because none of these solutions are built in, and the frameworks exist at a level where they can only work around browser problems, rather than at a deeper level where they can be fixed. Granted, a lot of this is *finally* on track to get fixed after 20 years of stagnation, but my rant pretty much summarizes how we got here.
There are several nice features, 1. externally read only exports. when you use `export` the public object exposed for your exports cannot be written to, even though your module may still change the exports. 2. pass through exports. `export * from 'fs'` will turn all of the exports from `'fs'` into local exports, without creating extra allocations/GC churn, can lead to dead code removal that is not possible (realistically) otherwise. 3. auto strict mode. Historically some features (const/for of) have been behaving oddly in sloppy mode. sloppy mode is not a top priority for supporting new features, expect things to get weirder 4. new syntax support. The parser for modules is actually separated from scripts. New syntax will be landing on the module parser, and may not land on the script parser (most notably `await`). 5. flat identifier exports. this might sound strange but having a flat namespace, but right now node only has a single export: `module.exports` ES6 supports exporting multiple things at once. You can still export objects with properties just like `module.exports` if you wish though. Also, all exports must have valid identifier names, which may sound limiting, but it removes some strange cases. 6. browser support. in theory node and the browser will have compatible module semantics with ES modules, and won't need a build tool. However, I recommend you still use a build tool in order to get things like dead code removal and load order optimization. There are a few more esoteric VM optimizations that can be achieved due to semantics of ES modules that I won't go into.
I feel like some people need to use React Native before they get over their "JSX isn't HTML!" mental block.
I'm with Kyle Simpson on this one as well. Interesting syntax. Short and terse. Ultimately easy to makes mistakes with.
Hammers are hard. That claw part is awful for hammering in nails.
Author here! Also, **most of the post is irrelevant now.** I assume it got posted because of the Twitter boost from /u/TomDale: &gt; https://twitter.com/tomdale/status/694537423716499456 Anyway, For context, it was written while we were building a complex, isomorphic React application (pre-Redux days) while simultaneously maintaining a huge Angular 1 application. **Angular largely answered our major architecture needs.** Coupled with each URL mapping to a folder + view, if you could Cmd-T in Atom/SublimeText, you could find the view &amp; work on it. Easy peasy. **React is BYOA(rchitecture)** (and convention). We had to solve async rendering on the server, data-binding woes, caching in-flight requests &amp; error handling from a CMS, etc. (The CMS is why we had to set innerHTML all the time) With Angular 2 on the horizon &amp; Redux solving most of the data-flow issues in React, **you can probably ignore from over 6 months ago.** :) 
[**@tomdale**](https://twitter.com/tomdale/) &gt; [2016-02-02 15:06 UTC](https://twitter.com/tomdale/status/694537423716499456) &gt; The small modules fallacy in action. https://medium.com/@ericclemmons/angular-is-easy-react-is-hard-6f55e360482c &gt;[[Attached pic]](http://pbs.twimg.com/media/CaN-GynWkAA937N.jpg) [[Imgur rehost]](http://i.imgur.com/UaB9CR1.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
SitePoint submissions are automatically sent to the spam filter for review, it a site-wide thing. We have to manually approve each one.
&gt; The vdom alone is sufficient reason for me to use React Why does vdom get so much hype? Isn't what its doing something that the browser engine could optimize on its own? Also, on Firefox I'm actually showing .innerHtml = html is faster than vdom here. http://jsperf.com/replacement-v-diffpatching
The most interesting point was the one about tree shaking: automatically reasoning about which functions in a library are unused and leaving them out. The author argues that this is the way to solve the problems between large monolithic APIs and the pain of managing many tiny libraries. Consolidating the micro-libraries while still keeping small deliverables is a promising direction.
&gt; JSX is Not Really HTML yet Angular 2 breaks the HTML5 standard
Hey there! I'm curious about something you said in particular regarding angular: &gt;In fact, the sharing of $scope to child views meant that we largely ended up with a single root state that was available throughout the app. Are you saying your child views were explicitly referencing their parent/root, or just implicitly using variables on the parent/root from scope inheritance? Was `$scope` ever being manually passed around? It's somewhat unusual for me to see anyone proposing non-isolate scopes since `controller-as` syntax came to be.
Github shows contributors to the code base, is that not enough?
&gt; 6 months ago That's a decade in webdev years.
&gt;and pass minimal data and a string data-path to each business-logic component. Everything is props because every component is pure. Can you expand on this? What is a string data-path?
Thanks for the article. But why is the background color so YELLOW? :( My eyes got sore
I'm not exactly sure what do you mean, but check out: https://github.com/pakastin/worker-example
&gt; Github doesn't see you as a contributor but you should be recognized. Simply because I contributed an idea via PR? I disagree. Submitting a PR is the beginning of the contribution cycle, not the end. Case in point, some time ago I found a bug and went to submit a PR but lo, one already exists! However, it had been stalled for a few months, the maintainer left some comments but the submitter never circled back around to complete the task. So, I pinged and no answer. Waited a week, forked the PR, made the necessary changes and re-submitted. Should both of us get recognition? Or just me, if my "completed" PR is accepted? 
I have some example articles that demonstrate that google can render a javascript rendered website Example: http://searchengineland.com/tested-googlebot-crawls-javascript-heres-learned-220157 But even if it does, what about other bots that you want them to read your site, like social platforms: facebook, twitter, tumblr etc... as far as I know they simply fetch your html and read it no fancy javascript render 
* Wake up * Get coffee * walk to office (upstairs) * check email and respond as needed * coffee * check news * check server logs for error. * coffee * perform code reviews and merge requests * coffee * review change requests assigned to me. * write code/test code/repeat * lunch, take walk * write code/test code/repeat * check email and respond as needed * code reviews * check tickets * walk downstairs to dinner and family time. 
Sure. When designing an app as a single, large, immutable object, any part of that object can be queried and modified (in an immutable-copy kind of way) just by knowing the string path to that part of the object. For example: "site.main.posts[274].comments[32].email" An email display component could know how to modify an email address without knowing anything about the global object, save for one helper function (setAt(path, value)) and a string containing the object path. This is an oversimplification, of course. For a large app, not everything can be represented in a single deep hierarchy, else there would be circular references. But posts, sites, and comments could be broken out and referenced by a key or two, these keys passed in with the path. Also, if any data changes trigger other data changes, it's easiest to have a helper function on the store for that particular modification. Lastly, I don't recommend letting all leaf nodes know about the global object. There's no need for a generic email input to know about the global object. Keep knowledge of the global object in the business logic components.
This actually should be done by default when setting the project type to node. Anyway great package.
Performance-wise, maybe. In terms of developer experience, however, that would first require defining a standard for it, implementing it, and then having it supported by all commonly used browsers. Sure, we're probably getting there some time in the future, but it's completely reasonable that virtual DOM receives the hype it gets at the moment.
Thanks, I'll look into it. Tryin to get as much info as I can!
consider using an object for m/v/c (not a function) then youd have a real class * model would be ways to manage your data. functions like `getdatafromdb` or `getusers` and stuff like managing arrays `removeitem` `findwhere` etc * view is for rendering templates or components like navbar/userbar * controller is is for things like routing (each page's logic), and picking what data to use and what data transformations to use. things like `routeIndex` (site.com/)`routeProfile` (site.com/profile/x) etc... basically this is the fns u use the other two sets, ex: `routeIndex = () =&gt; { this.views.load('view.html', { data: this.model.getUsers() })` if you have only one function for views you can return a single component, ex a single form. also consider using an init function, like `myobj.init() =&gt;` set options, add html, add ui binds clicks and keypresses etc.
Hmm... How's this? http://codepen.io/anon/pen/zrLmpL
Yea let me drop that in and see how it looks, i really appreciate the response. I spent about 2-3 hours doing research and looking through tutorial examples, and forum examples, of people doing pieces of each individual function to try to get that working. I tried just taking that out, but it always broke my link which i didn't understand because it seemed to me that the lnk.href was defined in the script so I didn't understand why window.open(lnk.href) isn't enough? When I removed the &lt;a href=" "&gt; &lt;/a&gt; it didn't work anymore.
Do you have an example of this I could take a look at? The pattern Redux uses (essentially the Elm Architecture) is great, but usage of it with React seems to leave some magic and there's a lot of finicky setup. My main trouble when trying to create my own version has been how to properly update the top level model/state from deep children - namely, how to pass down the requisite function for making the update with a data-path and value while keeping things as stateless as possible. 
I admit, I agree. I wrote a few large Angular 1.x applications (with minimal JS experience) and moved to React and swore off Angular after the 2.x disaster. It's hard. I consider myself an experienced javascript developer now but I still struggle wrangling Flux (Redux, Reflux) in large projects. I feel like I'm fighting the framework and design patterns at times. Coding doesn't flow for me with React, in Java or even Angular it was almost effortless. I'm now training a new hire on React and realize just how steep the learning curve is.
&gt; JSX is Not Really HTML This seems to be a common cause of confusion. Maybe it's because I've seen [Clojure's hiccup](https://github.com/weavejester/hiccup) library, but to me this was obvious from the get go. How on earth *could* it be HTML?
It's faster to test a small peace of code than full flow. The most common bugs we have at our company is not a bugs with flow, but with such a small pieces. (In strongly typed languages most of theese bugs must be resolved by compiler, but this is javascript)
I'm a javascript engineer and I write very little html and css. The main bulk of what i do is client side and server side js and even when I am manipulating the dom, it's usually through js written html and not writing out html files themselves. 
I think that's because, if you have no explicit `href` attribute but you do have an `id`, it's treated as an internal anchor rather than a hyperlink.
Despite how old the article is, I still found it insightful. I'm venturing deeper into the react world and definitely see what you mean about the BYOA. Now that it's 6 months later, do you think react resolver is still relevant? And what about your comment about fat controllers/containers? I'm actually still finding that to be the case (sans a solution like react-resolver). 
Also what kind of degree, if any, do you have?
Tell that to early JS programmers who relied on `!!(new Boolean(false)) == false` /s
I work for an online advertising network and we have loads of partner sites which we place ads on images, in text and elsewhere. Not so much creative (that's the creative sides job) but more all the core logic that makes the magic happen.
I have a business degree. I'm self taught in js etc, I've been a jnr engineer for just over a year now, and actively started teaching myself js about a year and a half ago. I started working with html and css around 4 years ago and wanted to learn more.
Same here.
 function The_Alerts() { alert("This is Alert"); var return_boolean = confirm("Do you confirm ?"); var return_input = prompt("Enter Data", "Default Data"); document.write("confirm returns: " + return_boolean + " &amp; prompt returns: " + return_input + "."); } The_Alerts(); No issues with the script on my end... Chrome console gives no errors...
I mostly see angular code trying reaaaaaaally hard to forget that `$scope` is even a thing, especially after we had controller-as. But even before we had that, it was seen as a bad practice to use things like `$parent` or `$root` in a view without a very good reason, particularly in a directive, since now it made some dangerous assumptions about its parent scope and made it much harder to reuse. Just a little surprising to see someone mention this behavior as a *good thing* in *defense* of angular. I've always seen `$scope` as one of the worst parts of angular, and the fact that it's pretty much gone in 2.0 only confirms that as far as I'm concerned.
Wow, I haven't actually seen someone defending the new angular 2.0 syntax. You don't dislike it in any capacity? Does it not strike you of html templating not doing very well if you can't easily tell what's logic and what's template?
1000 row limit for a spreadsheet? 
What is it that you do?
Nice, you can hit me up if you're on PS4 as well (alessio87alex is my PSN).
Nope, I don't agree. The mess is on the code author more so than the tooling they use. It comes down to depth of integration. If a third party tool is only lightly (preferably not at all) integrated into the application code then it is removable and can be replaced with a different tool or custom code. When this is the case nobody complains about the state of tooling. The other end of the spectrum is when third party code is so heavily integrated into your code base that its removal requires a substantial (perhaps complete) rewrite of the application. If this is the case then you, the code author, have utterly failed yourself and your users. These are the people who bitch about the state of tooling, and typically also blaming everything else (typically starting with the standard technology) instead of blaming themselves for poor decision making. In my opinion they deserve to fail just like an over leveraged business. I view this state as being 3 seconds from death by a crack overdose, because your shortsightedness and addiction to dependencies has left you in a terminal state with no recourse. &gt; and what to do about it? For future projects just manage your dependencies responsibly with a focus on separation of concerns. For current projects generate a bunch of spin to your stakeholders on why yet another tool with a sufficient increase in tech debt is fully qualified until you suffocate.
It's the document.write(...) that causes this. Details can be read on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/write). &gt; Once you have finished writing, it is recommended to call document.close(), to tell the browser to finish loading the page It's possible that some browsers automatically close the document for you, so they don't show the page as loading. In general though, document.write should never be used for a real page. If you call it on a page that has already been loaded, the document will be wiped first. That is why your input button disappears. If you want to display the results of your script, try [the console](https://developer.mozilla.org/en-US/docs/Tools/Web_Console) (F12). It's more versatile.
Creative wise is front end-ish. Anything that touches the Web page is front end, anything code that sits on the server is back end. My front end work basically stops when I've developed a container for creative to put their code into on the page I'd that makes sense (e.g. A floating I frame that hovers over the webpage). And there's a lot of dev work on how we get those containers there, how they're positioned and where etc, all that stuff happens In the browser (client side) and then there's a lot of configuration and routing, logging endpoints etc that are processed on the server (back end work). 
&gt; ...are there careers you can get as just a JS specialist/engineer/developer... No. You can treat programming as a career but there are extremely high odds you'll become obsolete if you try to make a career out of a specific tool. You're in a good place as someone who's already picked stuff up on their own. Keep it up and you should have a relatively easy time finding a job centered on work you enjoy.
"With observables, there’s no re-render and diff necessary." - Under the ReactJS section. I don't really agree with that, regardless of whether you are using observable or not, when a particular value is updated you will at some point have to update your view, ie.. re-render. Am I missing/not-seeing something here?
Is it a mess because there are a lot of options? What makes it a mess? I think that people are obsessed with the best and there is no good measure for the best because every tool has its purpose.
ES6 module syntax gives some flexibility; you do need to figure out how to use it that makes sense on your project. Also note: &gt; There is also one thing more - it shades real source of function. In ~200+ LOC module, when you see a line "doSomething(xxx)" you must scroll source all way top in order to see that: A good IDE (eg, anything by Jetbrains, but Sublime or whatever should do this too) will help a lot here in terms of providing insight into where functions are coming from, letting you jump straight to their definition, etc. &gt; I was making A LOT mistakes due to incorrectly requiring certain things, like using: Similarly, a good IDE will flag incorrect imports automatically, and will provide autocomplete so you don't mess them up. &gt; So what are real good sides of ES6 modules, because it has a lot drawbacks for me. I wanted to learn ES6 and I started to use ES6 modules but from what I see now it just make more mess than old commonjs require() thing. I think you're deeply overstating the difference between commonjs `require` and ES6 `import`; there should be a 1:1 mapping between your old `require` statements and your new `import` statements. Much of your post seems to be "I was structuring my modules like *this*, now I'm structuring them like *that*, and I hate the change." Okay, so don't change? I like using named exports, but they're not needed; you can just export a big object as your default export just like you were with commonjs. You're asking what the advantages are to the ES6 module syntax, but I'm actually wondering what the drawbacks are; I'm not really seeing any listed in your post.
Yes. Believe it or not, I've had much faster and simpler development by simply rolling my own data manipulation code. With lodash, and now seamless-immutable, the amount of code actually necessary to manage state is nearly zero.
so are there any frameworks out there considering es6 proxies for data binding? i've asked on r/aureliajs, as this framework is using object.observe when available. so far it's the closest thing to what i want in an mv framework. a lot like angular but without the strange lingo and need to wrap everything in a special observed object.
Comprehensive overview and nice in parts, but a few low-effort sections, e.g.: &gt; CommonJS is all well and good, but what if we want to load modules asynchronously? Really? *That's* what your research told you was the motivation behind AMD?
&gt;These are the people who bitch about the state of tooling, and typically also blaming everything else (typically starting with the standard technology) instead of blaming themselves for poor decision making. I think you have misread or misunderstood the complaints against tooling if you feel that the problems are simply code being too tightly coupled to tools. In javascript, everything from your code editor to your compiler needs tons of very explicit, very finnicky configuration. Every project on top of that needs heaps more configuration. There's a bunch of very nuanced decisions to make in terms of what tools to make, what libraries to use, and how they should be combined. Usually if you want to combine two tools, you're going to have to do even more configuration, usually very brittle ones at that. Having to configure so much so frequently is basically unheard of in every other language I've worked in. In languages with a reputation for good tooling, there's a strong convention and meaningful defaults around most things, to the point where you don't even really think about it. If you write C#, you'll spend almost zero time configuring your compiler, even if you want to add a new language, like F#. If you want to do something like completely switch how you write unit tests, you're just installing a plugin away from being able to start writing code. All of this is huge barrier to new people coming javascript. It tires people out. It makes people not want to try anything new whence they've got something working to not go through that pain again. It's not good, and it's not healthy. This is "javascript fatigue".
We don't have to really be fair to Knockout if Vue is better in any way. The question is...is it? Having used Vue and not Knockout, I can't really say. But new frameworks will pop up constantly, so this is just another one making the rounds.
Come on guys, surely JS will be around forever, the way COBOL is still around, because of a huge field of legacy codebases. ~~/s~~
I don't have a public thing I can show you (it's a work project), but I can explain more. My top level app object has a single listener (simple function callback pub/sub) that listens for a single update event, any time any data in the entire app changes. All data changes are being done in that same store file (not in any of the components), so the function to fire that event is called after each function capable of mutation. When the top level component has its callback called, it simply sets a trigger int in the state (literally, the this.state.trigger is set to 1 again), which triggers an update without calling forceupdate. Most components either request data directly from the store, or have it passed in as props for generic and leaf nodes. Since the path strings are passed progressively downward, every component knows where it is relative to the grand data scheme. The key thing here is that I do not pass down the update function from parent to child (except for leaves). The components request access to the global object directly, calling update functions directly. The data is only passed down so that the components know where they are and to make use of the shouldComponentUpdate optimization. This strategy works pretty well whether you use immutable data or not, but it is easier to optimize if the data is immutable. Also, I should mention that my experience so far is with many separate apps, usually on their own pages. I haven't used routing/single-page apos. However, this technique should scale by creating a greater-encompassing data scope as the root data object.
That does resolve one issue! great! and it works, plus the code is way cleaner. I tried adding a &lt;pre&gt; tags and it seemed to clean it up by adding a box around the item itself, so now I just need to probably set a size value for that object and background color to make it fit in the theme better. Thanks a ton for your help, its faster, and much cleaner code. the &lt;pre&gt; resolved all of my issues with the looks
Thank you for testing it out for me ForScale :-)
its very strange when i used the &lt;pre&gt; tag it made what looks like a table on the page(apparently its very strange that is has done so. I've never seen or used that tag but it fixed all my spacing issues, it looks really nice tested it on all browsers. I would really like to be able to change the background color of it but it doesn't look like thats doable. I also do not understand why this did what it did. Apperently the &lt;pre&gt; tag is just supposed to change the spacing of standard code when you are using code in a text box to keep it from spacing improperly and to keep it clean looking and easy to edit. but for some crazy reason it made what looks like a table on our page, wont take the standard options to set values like a table so im a little curious what the hell happened here's a photo. [Imgur](http://i.imgur.com/6XEqCHN.png?1) Switched to first option provided btw thanks @ugwe43to874nf4 also thanks @ForScale yours was also much better than what I had. I just took the first one that resolved my problem. Thanks @lewisje its nice to actually understand why things do what they do I am enjoying learning this stuff.
vast majority of the complaints on react side that I see are things I learned within a week of using it
It's mainly because most components in an application can be reused if properly architected. Tables, panels, modals, buttons, loading bars or spinners, notifications... etc., but only if you properly use scope - i.e. isolated. If you're assuming `$parent` or inherited `$scope` (`scope: true` in directives), you'll end up with a lot of contextual and repetitive views and controllers which you don't really need. In React, this type of encapsulation is almost enforced and you'd have to go out of your way to get out of it. I think that's an advantage. 
thanks bro, i appriciate your help, some weird stuff going on with the html5 now but the script is much better now. thanks i did that as soon as i saw the reply and other than some weird &lt;pre&gt; tags causing tables where there shouldnt be its faster, cleaner code without the problems mine had. Kudos
Thanks bro, I appreciate getting to actually understand why it wouldn't work the way I wanted. the only pieces of example code I could find for some of the things I was searching for just turned out to not be the best cleanest way to perform those functions.
I think in the context that is used he means how angular renders pit the watch statement and then checks if there is a diff. You are correct, if any value forwarded to the Dom changes, a rerender will be required
Id like to be able to change the background color around that, i tried inserting a &lt;table&gt; instead of &lt;pre&gt; and it looked pretty scrummy no table, no borders, no background. I don't believe adding any attributes to &lt;pre&gt; will do anything but effect the text since thats what that function is supposed to modify but for some reason it made what appears to be a table. I can't use a css file i can probably embed or in line some css, however it cant conflict with the css attributes that this wordpress page uses, so it makes me slightly nervous. Any Thoughts? if you compare the previous photos with the new one that box didn't appear around the object until &lt;pre&gt; was added. goes away when removed and the crappy formatting/spacing return.
Willing, yes. Able, I'll have to ask the boss.
Perl will be the next hotness.
I work for a small PAAS company. My team takes our core product and repackages it into custom libraries/components tailored to specific industries.
This is what we're running into too. I'm finally wrapping my head around Redux (not to mention thunks, ducks, and reselectors) but communicating it all to a new hire or consultant is a project all to itself. This stuff is opaque and full of jargon. 
Yes, CanJS is. It's part of its roadmap: http://forums.donejs.com/t/canjs-roadmap-discussion/75 . In that article, it linked to the project that is already using proxies: https://github.com/canjs/can-observe
It doesn't break the standard at all from my understanding, but maybe somebody more familiar with Angular 2 can elaborate. https://www.w3.org/TR/html-markup/syntax.html#syntax-attributes
Cool! What's the weird stuff with the html?
Why call it tree-shaking? it's dead-code elimination. Albeit not a full implementation.
This is some very old stuff man, the industry is way past this
+1 for exporting an object. export default { myfunc(){ } } 
if you say constructor: function Flower () { It won't be anonymous anymore. Just give it a name between function and the paren. Edit: for your function you can set place.Person.displayName = "PersonConstructor" To get the same effect. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName
Angular has a lot steeper learning curve for a plain Javascript developer than React.
Hmm, the point of doing things this way for me however is to be able to dynamically name constructors which will get logged correctly, so hard coding a name is not really an option. I was full of hope when I saw that link but &gt; Non-standard This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future. :(
Having used both, Knockout a few years ago for a couple small projects, and Vue much more recently, I think Vue is definitively better--in every way that you can compare the two.
What do you think of Vue? 
From what I understand, when the state of a React app changes, the whole app effectively re-renders in its virtual DOM. Then the system intelligently modifies the DOM with minimal operations. So yes, while the entire application template needs to be re-evaluated after every state change, in the end, the DOM only changes what it needs to. This is basically what you described in your hypothetical todo example. I'm not sure if you've worked with React very much but this whole process of re-evaluating an applications template comes very cheap. This is React's most powerful feature IMO.
I've seen it before! It looks a lot like [mithril](http://mithril.js.org/mithril.html) which I also mentioned I like, only mithril encourages more of what react calls "pure functional" components.
Knockout has been around way longer, but is unfortunately still quite behind when it comes to the modern understanding of components.
&gt;Most people with a comp sci background have little or no understanding of lexical scope and closures, so they are doomed when they get to this language anyways. Why would anyone not have exposure to lexical scope, Java has lexical scope. 
Hmm but yeah can't get past `Do not use it on production sites facing the Web`it also seems to only work in Firefox so not really that useful. Would be nice if it did work in others.
Javascript engineer here. My official title is "Software engineer". Currently working primarily in Node/React, but I've worked on many stack flavors over the years. Your best bet typically is to get a computer science degree from a traditional 4 year college. That's the background most of the engineers I work with have in a large scale technology company. Maybe things have changed, but web technology programs were shit when i was in college. The web changes very quickly, educational institutions tend to move very slowly. In web especially, you're going to have to get very very good at teaching yourself things, that will actually be the most important skill in your career.
I think what finally made Vue a contender for me was the ability to write really clean single file components. You're still writing javascript but your template is both accessible AND out of the way at the same time. I actually started with RiotJS which is a great little framework that can also do single file components in a similar fashion. Unfortunately the rest of the library wasn't quite powerful enough for me, so I turned to Vue. Haven't looked back though, it's been really great so far.
They've been intentionally obscured so that desktop devs can feel like they're working in a stateful environment 
I enjoyed using knockout, but I found that errors are *really* hard to track down. React with JSX compilation was so, so much better. If you stuff up the syntax it fails immediately. With knockout, you never know if you wrote the wrong syntax, or stuffed up some aspect of data binding, or some variable scope issue, or whatever
mouse scrolling doesn't work properly.
Would you say that a web degree and certifications is a good enough foundation?
Awesome! =D
I believe if the only thing that is updated is state of a child component further down the tree, it only needs to render that subtree.
I just tested it. Object.observe still works on my machine.
Ah interesting, I didn't think camel case was part of the standard just against common naming convention.
Looks like it's available in canary builds [right now](http://imgur.com/sz85b7q) (mine is 50.0.2638.0)
YES 100% THOUGHT THIS WAS A FINE BROS JOKE THREAD until I saw you were the only person making g that connection. Go you!
Yes, first one sounds more like something I would do for fun at free time. What do you mean bad time, do you recommend job hopping?
&gt;Half of my guys are only just starting their move away from MySQL to Mongo MySQL and Mongo are completely different and are tailored towards solving very different problems. If you can't elucidate why you specifically need Mongo for your app, it's probably not a great idea to migrate over, because relational algebra / SQL is fucking awesome and makes everything easier. MySQL to Postgres is a different story. They are similar software and solve the same sort of problem - storing relational data. 
SEEMS LEGIT
Have your say, join and discuss about the repo content here: https://gitter.im/bmkmanoj/learn-javascript/~chat#share
I cannot believe all the Angular fanboys have just quit and let React come in and be the new sheriff in town. And all React really offers is to be the new Curses library for different viewports. (All you noobs will need to google "curses unix" to know what I am referring to). Its a strange world for software architects... what to recommend? 
You've done a great job copying someone else's work and spamming your own site. Nice work!
I think it's more that it's an entirely new way of thinking, where your application exists in discrete slices of state in redux. It's like a slideshow, things don't actually act on your application, they request a new state and then the application/react view layer just renders what the next slice of state should look like based on props. If you can ditch all your presumptions about how a JS application works and embrace the redux store state, with react being entirely view templates, it's actually reasonably simple but it certainly is jarring at first because it's like an async/sync hybrid or something.
You still have to recreate the entire virtual DOM and diff it with the old virtual DOM. That is efficient compared to rerending the real DOM for every change but wasteful compared to only processing what actually changed. If you know the dependency graph for each property, you can be more efficient than React can possibly be today. Whether it's enough to matter remains to be seen.
Are there any framework/library that can build data bindings graph with kvo as fast as vdom libraries render to dom? Or we are instead optimizing for the case that doesn't involve many heavy dom ops, and we have plenty of js time to perform diffs/whatever?
The client ID and the client secret are your app's username and password for GitHub, respectively. With both these pieces of information someone could do anything your app could do to the data your app has access to. You keep the information safe for the same reason you keep your own password safe.
Any reason for not using strict mode?
Love the prefetch Idea dude, I'm gonna use it and I will come back to you ;)
Think of your entire codebase as a tree with "dead" code being functions and variables as branches and leafs that are not attached to anything. Shake the tree and the dead code falls off. I agree that "dead code elimination" is a more descriptive term. 
Oh, I read what you had typed more closely: If you removed the `&lt;a&gt;` tags, and you somehow have that `id` on something like a div or a span, and then set a `href` on it, that won't make it a clickable link (you could set some Javascript event handlers to simulate this, but if you want something to be an inline link, it's best to just use `&lt;a&gt;`). This is assuming that you didn't just remove the `href` attribute, like I guessed at first. --- FTR the two commonly used tags that `href` is valid on are `&lt;a&gt;` and `&lt;link&gt;`, and they're usually used when textual data could be referred to (like a stylesheet, or another HTML file); `src` is more commonly used for binary data like images and plugins (with the exceptions that `&lt;iframe&gt;` and `&lt;script&gt;` also use `src`), and `action` is intended to refer to a remote server-side script that data is sent to (I think it's only used on `&lt;form&gt;`), but with the advent of Ajax, the distinctions among these attributes are blurred.
For real, if you look at an old enough code base, you can date when different parts of it were developed by the languages, libraries, and programming patterns used.
the following is from the angular documentation "An Angular "service" is a singleton object created by a "service factory". These service factories are functions which, in turn, are created by a "service provider". how on earth do you find this easy to reason about? what are they speaking? for me angular is the javatesation of javascript. if you are a java developer, then it's quite easy because you don't have to change your way of thinking, you still use the same old fashion thought school of factories,factories of factories and services to achieve simple stuff. the challenge is adopting this new way, the react way. that is by no means easy, but if you are a developer who's new to both then it's much much easier than angular's.
neat. Is there a way to remove an added function other than leaving it there and just clearing the text?
How it can be faster than simple React rendering for initial render cases if it is built on top of React and also creating graph of watchers that will invalidate React components? And what about rendering table with items, that can be sorted by different properties, and for example we need to display 10 out of 1000 items, how good is mobservable will be in this case?
It's not out yet on stable builds... [Hopes dashed...](http://i.imgur.com/EdgTWoO.gifv)
No way. I've worked with Angular and kinda dubbed with React. React seems easy because the view part API is pretty simple. That's why most people think it's easy. I could even build a simple silly app in an afternoon. But when you get to actual SPA that deploys to the real world, you start realizing you are fighting the framework non-stop. Reflux/Flux/Redux are complicated and make it a nightmare when dealing with things like 2-way data-binding. Angular, on the other hand, has a steep curve when you first learn it. But after a couple of weeks with it, you can work on most live apps without too much of a hustle. The whole $scope/$controller thing is pretty standard and applicable in most situations. The only thing that can be challenging is using directives as components. That's where silly hacks come in, but by then you are already comfortable enough to make it up as you go (i.e: Get shit done for your end users). It's not so much about which has a better philosophy behind but about what gets your job done quicker.
I would go along the lines of something like this, obviously expanded for your use case... function getPromise1() { return Promise.resolve(1); } function getPromise2(x) { return Promise.resolve([x, 2]); } function getPromise3([x, y]) { return Promise.resolve([x, y, 3]); } getPromise1() .then(getPromise2) .then(getPromise3) .then(output =&gt; console.log(output)); // [1, 2, 3]
well… you have to catch exception somewhere. catching it via try-await-catch is one option. Another option, is to catch exceptions at the point where you exit into synchronous domain: async function a() { throw new Error(); } async function b() { a(); } function run() { b().then(() =&gt; { console.log("we're ok!"); }).catch(e =&gt; { console.log(e); }); }
Huh? This has been possible in Chromium stable for months. Come to think of it, maybe I enabled a flag I just forgot about?
It's cool. Your store is pretty similar to Redux's, but I'm still not 100% on actions and reducers (from Redux) since they sometimes seem a bit crufty. I haven't had the opportunity to build a whole lot in Redux yet, and most my React implementations are just small features that are part of larger apps. Anyway this is good shit, hit me up if you're ever looking to get hired in Ontario ;)
Ah, I see. Thanks!
Says there's an error on the page when I try to open the link... Won't load...
But the attacker would still need to get an access token, right? So the attacker still has to fool someone into going through the OAuth flow, on an app that they control. Also, if the client ID and secret were exposed, would the auth code grant type just be the same as the implicit grant type?
Only since April 2014.
Yes, but as the wide success of phishing scams has shown, convincing people that you're someone you're not isn't terribly difficult.
Job hopping in the beginning of your career is the only way to make money. Staying in one place for a long time drastically decreases how much you'll end up making long term. I'm not saying switch every 6 months, but after 2 years you start to get stale with the latest technologies - it's time to move on. 
Java has always had lexical scope.
You can see a comparison to angular 1 &amp; 2, React, and Ember in the video
Thanks for the advice, I am going to read some literature on Backbone. I don't really understand one thing. Should Model have methods like `document.getElementById("myApp")` for defining the DOM Element where to show the output or Models should be independent from the context?
As I wrote on another comment, I don't really understand one thing. Should Model have methods like `document.getElementById("myApp")` for defining the DOM Element where to show the output or Models should be independent from the context? I understand that it is the interface with the DB or the data. 
I updated the code and deleted the fiddle after the code was updated. Long story short, I removed the `&lt;pre&gt;` tag replaced it with `&lt;div&gt;` used `&lt;style&gt;` `.border-inside` and created rounded borders and backgrounds, as well as set its size to `margin: auto` as well as set `padding= "20px";` then assigned that style to my `&lt;div class="border-inside"&gt;` Then I took my HTML Elements from before, placed them in a `&lt;div&gt;` inside the `&lt;div class="border-inside"&gt;`. then gave button and Input Field gave them properties like this to set the spacing and alignment of them: `&lt;input id="userInput" type="text" placeholder="Enter your Session ID Here." style="margin:auto; margin-top: 15px; margin-bottom: 20px;display:block" /&gt;` `&lt;input id="goButton" type='button' value='Connect to Session' style="margin:auto; margin-top: 20px; margin-bottom: 15px;display:block" /&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;` My entire code looks like this: &lt;span&gt;Remote Support&lt;/span&gt;&lt;br&gt; &lt;p&gt;Please type your Session ID into the blank below, when instructed to do so by a technician.&lt;/p&gt; &lt;style type="text/css"&gt; body { background:#f0f5f9; } .border-inside { border-radius: 15px; background: #f1792e; padding: 20px; width:auto; height:auto; } &lt;/style&gt; &lt;div class="border-inside"&gt; &lt;script type="text/javascript"&gt; window.onload=function(){ document.getElementById("goButton").addEventListener ('click', function() { var userInput = document.getElementById('userInput').value; window.open("&lt;test url here&gt;" + userInput); }); }; &lt;/script&gt; &lt;body&gt; &lt;div&gt; &lt;input id="userInput" type="text" placeholder="Enter your Session ID Here." style="margin:auto; margin-top: 15px; margin-bottom: 20px;display:block" /&gt; &lt;input id="goButton" type='button' value='Connect to Session' style="margin:auto; margin-top: 20px; margin-bottom: 15px;display:block" /&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; The way it is now it looks exactly as I want, and most of the placement of the objects is based on the size of each other and the items around them, so it should look good on multiple screen sizes.
The scenario pointed out in the stack overflow question you linked is concerned with the specific case of not awaiting an async function call. I hadn't even considered this scenario until now but it is a legitimate use case. Initiating an asynchronous operation without waiting for the result. This shouldn't make you apprehensive about using try/catch blocks though because the vast majority of async ops will require you to wait for the result, in which case try/catch blocks are effective. This particular scenario is a situation that needs to be handled with a little more care is all, if you intend to capture the error. When you spawn an async call that you do not intend to wait for, you are essentially creating a new execution context because it does not get reincorporated back into your original context (as you haven't waited for the result that then gets used in original context). If it is a situation where that new async context gets pretty complex than I would put a try/catch at the highest level of said context and handle it there. If it's a simple operation, than maybe the 'unhandledRejection' event mentioned in the SO question is enough for debugging.
nope is just for getting and formatting data. --------- unless theres no backend and your getting data from a html form or something, i guess `model.formdata()` for reading input is totally a valid cause for that web-app. TMI: and i guess thats where mvc breaks down. technically you need a MVC on the backend and one on the frontend...thats why theres MMVC because you need another controller for input and events on the front end. its actually something argued about a lot where to put the input fns and events. 
Oh cool, I wanted it for a long time to fix a bug in one of my browser extension. I need to check if there is any visible content before appending an icon to it. textContent does'nt work in that case. Glad that it works now. However, for others I dont recommend using it when textContent works. innerText (at-least on Chrome) is over 200 times slower than textContent.
Someone want to summarize (not tl;dr) this? I was able to follow what he was saying and was on board until &gt; &lt;V params={M}/&gt; &gt; &gt; is nothing different than: &gt; &gt; V = f( M ) I then realized that I'd only read the mere introduction to the article.
(Good) employers don't care about certs. Focus on building cool shit in the open. Write blogs. Speak at meetups. Learn obsessively. The jobs offers will pour in.
Sorry. I'll update the main post.
Yep, that's the main use case I was referring to
&gt; When you realize that a plain old JavaScript function can do the job just fine, then your next question is why you would use React at all? * readability of JSX vs plain function calls * performance (virtual dom diffing and optimizations) * security (passing in HTML-looking data) * built-in tooling (react perf, proptype warnings, ...) * community * external tooling * help / discussion * components but i’ve only read until the citation, so maybe the author addresses some of these points
&gt; but i’ve only read until the citation, so maybe the author addresses some of these points Spoiler: He doesn't
"fluid and smooth". I'm on a 4.5ghz Xeon with a gaming GPU and this gives Chrome more jank than my Atom tablet playing games.
Yea I know that. I just don't know why its foo and bar
&gt; Dev – So, this screen has data element x,y,z… could you please create an API with the response format {x: , y:, z: } It sounds like the author is working with lazy or incompetent frontend devs, and is blaming that on MVC frameworks. Either that or the first few paragraphs of this ~~article~~ book have nothing to do with the rest of the article. (FWIW: In any MVC framework I've worked with, it's trivial to rebind fields received from the API to different fields in your application's state.)
i’ve gotten a few lines further (was distracted) and he mentions [`virtual-dom`](https://github.com/Matt-Esch/virtual-dom) in the next paragraph, but not how to integrate it in his approach seamlessly. also once you start using it, you’d already profit from JSX…
&gt;After using React and seeing what was coming in Angular2, I felt depressed: these frameworks systematically force me to use (...) word "library" on React's website should be like 3 times bigger
&gt; React is the way to go Nope. React depresses him. &gt;When you realize that a plain old JavaScript function can do the job just fine, then your next question is why you would use React at all?
Been saying this for years. When I first heard about MVC for the web, I started scratching my head in the same way I did when I first got into web development, in 2004, and asked, "Why does anyone use IE?". I just don't get the MVC thing in that it doesn't make sense to use it.
What I don't get, is the key differences between this and Redux/React. They sound the same (though more clearly defined here). I probably didn't read it close enough.
So essentially: Binding the view to the model, with a controller to handle actions.
This was kind of my thought too. Isn't a well made controller just a state container with defined user actions?
I generally leave thrown exceptions for the truly exceptional cases and prefer explicit checking for failure cases. The reasoning for me is mostly that JS doesn't have a very robust error typing system, almost everything is just "Error" so it can be hard to know what you do and don't want to catch, and JS offers no syntax for catching specific types, so it can be extremely easy to accidentally catch tool much and accidentally swallow errors.
Ah that's probably the key thing to be aware of. The error typing system in JavaScript isn't really good enough to EAFP the way Python, for example, can.
If you get all your nav items, then remove class disabled you will reduce all the duplicate removals. Then add disabled back to the one that actually needs it. Not gonna guarantee that this snippet will work, but something along the lines of: toolbar.find('[data-action']).removeClass('disabled'); if(folderType){ toolbar.find('[data-action="'+folderType'"]').addClass('disabled'); }
Sorry, I think you're right -- I was mistaken! http://imgur.com/gAaNJtW My assumption was that React would warn on attach not being able to reuse nodes, since I was running it in development mode and have seen this warning in the past. I'll take a closer look at what's going on here.
As someone who uses Knockout (through Durandal) for work and Vue for a side project, Vue feels better in every way. I wish I could justify the switch at work but the differences are almost exclusively in how easy development is. Once you actually get it working they're functionally the same.
f = a normal function. A transform. It can do literally anything. The idea is that a View is just the Model passed through a function, even if the function just jams the model data into HTML. So that statement means: V is the output of the model passed through a function.
Very cool but why not just use github or properly package it so other people could also benefit from your genius? 
Alternately: there was no spec, the PO never defined the requirements, yet somehow you were given and able to complete a task.
the premise though, "Dev – So, this screen has data element x,y,z… could you please create an API with the response format {x: , y:, z: }" that in itself is just a question of api resolution, i.e. does it make sense to throw more blobby data at the client. I tend to think it does given the back and forth approach has connection overhead, and otherwise it forces a lock-step approach and opens lots and lots of edge cases. This fine grained approach {x,y,x} sounds like unskilled client developers or dogmatic optimizations that are unsupported by testing. Chances are you can move a screen's worth of data in one connection faster than piecemeal, especially with everything moving towards https. You WANT some decoupling between server and client, if you don't have to touch the server every release and it is well tested, and the client has what it needs, then I would lean towards limiting the changes to the client. But I have to wear both (all) hats, and have to look for opportunities to make less work for myself. 
Yea, it really does except the view and the controller/state and view are kind of the same thing. It looks exactly like a react component.
Mister Jean-Jacques Dubray, thank you. It's ten years I try to explain to various co-worker why I never felt comfortable with MVC. This seems more natural to me, and is presented way more eloquently than I ever could, even if the difference with a good mvc implementation seems minimal. * the good: the encapsulation of the "controller", and general clarity of the model * the bad: the machinery needed to keep the state, and trigger a render * the ugly: his hack for differentiating query and update 
This is an interesting read, but I feel like this author is unfairly nit-picking one specific (and poor) way of using MVC. I feel like he's saying "instead of writing proper MVC, you should use this entirely new paradigm. As long as you follow this new paradigm correctly, it's better". The issue has nothing to do with whether or not you use MVC - it has solely to do with not writing shitty code. I started skimming/quick reading the second half of the article. However, I saw this image which seems to be a summary of how he says to do things with this "SAM" paradigm: http://cdn.infoq.com/statics_s1_20160203-0311u20/resource/articles/no-more-mvc-frameworks/en/resources/fig7-small.jpg Can anybody explain to me how this is any different than similarly written MVC? Everything I've ever read about MVC is you have: a View that makes calls to a Controller (specifically single Action inside of that controller); Action calls the Model; the Model does it's thing and returns the results (which should/can be the new state of the Model(s)) ; and in proper MVC the Action should simply be returning the results from the Model. To me it sounds like this could be summed up as: "Have your model return a more complete state.". 
Yea, that's what I was thinking about reading through this too. He's comparing extremely poor MVC to "perfect" SAM when it needs to be compared to "perfect" MVC.
Yea, I agree. It looks like he's really just proposing that you make sure to return a state instead of something else (like a success/failure value).
To expand on the answer by /u/phpistasty you could make a small configuration object that defines what buttons should be enabled, for a given folderType. var folderActions = { root: ['folders-new', 'folders-edit', 'tree-edit', 'folders-delete'], trash: ['folders-new', 'folders-edit', 'tree-edit'], someOtherfolder: ['folder-edit'] }; Then, you make a function that reads that configuration object. It uses folderType as a key to look up the list of toolbar actions. The `$.each` call applies the same operation (e.g. removing that disabled class ) to each of the actions in the array. function updateToolbar() { var actionsToEnable = folderActions[folderType]; $.each(actionsToEnable, function(i, value) { toolbar.find('[data-action="' + value + '"]').parent().removeClass('disabled'); }); } 
I think performance can also be a concern, but how important performance is varies greatly and I usually don't worry about it until I need to. Plus that's an implementation-dependent issue that could always be fixed in the future.
It begs the question though: how does one handle validation errors then?
&gt; Which my small brain has difficulty figuring out how this isn't just Redux It isn't Redux because he didn't come up with Redux
Don't couple your model to your form or to the DOM! Model should not have knowledge of anything but other models it relates to (and even then not much). 
I've been writing a similar (model &amp; collections with observe &amp; events) library myself over the past few days, will be [here](https://github.com/JimAnkrom/shoebox) in the next few days (very little code up there right now, most just scratchpad until I check in a major import &amp; refactor project later this week).
I agree. That's what I don't understand about all of these "ideal paradigms". They seem to focus only on when things work as expected - not when they go wrong. I guess you'd probably return the error message as the new state.
Do you even lift bro?
 &gt; This fine grained approach {x,y,x} sounds like unskilled client developers To be fair, that is a real problem that some people cannot avoid. I'd argue the most coding practices or frameworks are about protecting humans from themselves or each other rather than some technological achievement.
it didn't change the way it was displayed, but if its cleaner code then its cleaner code
This ain't heavy satire, it's medium.
Yea totally. REACT IS NOT A FRAMEWORK. FOR FUCKS SAKE.
I feel like there are a bunch more things she got wrong and I like your style of explanation - can you expand your list?
Are you using bluebird? You can just do: Promise1 .then(x =&gt; [x, promise2]) .spread((x,y) =&gt; console.log(x,y)) Example: https://tonicdev.com/56b26439a4504a0c000b3b40/56b26949eefec70d0075aa8c
Very interesting article. I'll recommend it to my coworkers!
I think Atom can be configured to work. I've also heard good things about VS Code (which is free). I don't use either one so I'm not really sure about getting them configured. I personally use Jetbrains editors (Webstorm/PHPstorm/Intellij IDEA); they just work out of the box, but they're not cheap.
What he is proposing is essentially just [re-frame](https://github.com/Day8/re-frame). Your entire model is in a single place, the ui is a pure function of that model, and handlers on DOM events are what update the model. Using [Reagent](https://github.com/reagent-project/reagent) is a lot like using react with immutable js, allowing react to efficiently update only the changed components. Actually, the trend I see seems to be that JavaScript developers are moving more and more towards reinventing clojurescript.
There are absolutely some niche uses for node, including: 1. Providing an easy websocket implementation as an addon for your existing API server, in order to support push notifications and real time updates 2. Pre rendering isomorphic/universal SPAs on the server. But I took OP to be talking about a more basic/general case of using node for the entire server which...yes, you could certainly do, but there's not a lot of advantages to it. What I said was: &gt; if you can't articulate why your Express code is better than the PHP/Ruby/Python you had before, you need to stop There are reasons to do it, and if they apply to you you should use it. It just shouldn't be the automatic choice because it's newer or cooler or webscale or whatever. :)
Yep!
What about the "next-action-predicate" part, which he described as a callback, which was troubling to me. It kinda reminded me of a poor version of something in Haskell, where a series of actions could be built up as thunks and executed at a later time when the data is needed. I may have been misreading, though.
What does formal education has to do with understanding concepts? If that's how you see the world, you're greatly mistaken.
You can of course go the "plain old javascript function" route without resorting to dropping a library like react. React does support calling it without JSX, and there's also libraries like mithril, which encourage "just functions" which return POJOs (returned by mithril `m`). That ways you still get the same benefits of performance, security, tooling, etc, but with "plain old javascript functions".
&gt; What does formal education has to do with understanding concepts It makes you understand concepts from people with experience of those concepts.
google is a java-heavy company (dart in particular was designed to appeal to legacy java devs) and the angular team in turn needed a strong internal customer base to sustain itself. it's a product of the environment angular was born in.
You mean directories? Got that already.
Haven't a clue what you mean but I have a feeling I don't care either.
I never said I didn't understand it. I come from a graphics programming background where this concept originated. I know what it is. Read the article if you want to understand why I question its use cause I agree with his points.
[removed]
+1
I don't agree with the premise that an MVC framework forces APIs to match the UI. As a server dev you have to "just say no". Clients can make different models or whatever they need to do. 
I'm just not sure how exactly I should write the program, I don't know what logic to use. I simply want to print a single number (1-6) on the webpage, that part is no problem, it's finding a way to actually track the cycle days (excluding weekends and restarting the count to one every six days). I'm obviously not a programmer at heart.
I think the main difference is that other people invented Redux/React.
[removed]
My typical practice lately has been to handle as much validation in SQL and the view as possible. This means my API returns a 500 or more specific error in the event the crud operation failed but hopefully the view informed the user of common errors before even submitting to the API. Of course it's not always possible or even desirable to have validation logic in the view in which case I usually find myself having together a response model or parsing reroute codes or something specific to that situation.
Direct link: https://dev.windows.com/en-us/microsoft-edge/platform/status/moduleses6
Simply just track the cycle and output the number on the page, I'm not sure what the input would be
The difference as I see it is that the controller is minimized to a data access layer. The view handles all other parts of the controller. Not sure why it takes so much effort to say, combine the view and controller in the view and create a CRUD API to access any models stored in SQL.
Simply just track the cycle... and output the number on the page... So, would your input be the current day of the month? And then your output would be the cycle number, 1 through 6?
Brilliant, look forward to giving it a try
I'm fuckin' near braindead, cut me some slack. But yes that would be correct
Hi /u/jahanmanesh, please only post about a project once, unless there are **major updates**, in which case you may post (just be sure to mention what the major updates are). Thanks.
Articles like these bother me because some beginner is going to read it and think that rolling their own framework is a good idea. Rolling your own anything is never a good idea in production. Oh there's a defect in your framework? Guess you're staying up until midnight figuring it out instead of googling for a stackoverflow question about your exact issue.
All good points. In terms of readability, have you looked into hyperscript type helpers? https://twitter.com/andrestaltz/status/693045571649695744 
[**@andrestaltz**](https://twitter.com/andrestaltz/) &gt; [2016-01-29 12:18 UTC](https://twitter.com/andrestaltz/status/693045571649695744) &gt; JSX &gt;[[Attached pic]](http://pbs.twimg.com/media/CZ4xQ9nWkAAwsS3.png) [[Imgur rehost]](http://i.imgur.com/zDMJo3v.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
This script you can just plug into a page and style it however you want. Code with comments: http://codepen.io/anon/pen/pgOwpO?editors=0011
Yeah, I came here to see if someone was going to say that the thing was so brilliant I should read it all...
Not sure if you know this(you probably do), but just so everyone is aware you CAN use hyperscript with React. https://github.com/mlmorg/react-hyperscript 
That's where loopback comes in
Alls I know is, once I invested the time into digging to Ember, I was able to crank out black box components and wire them up at ludicrous speeds while vastly reducing the number of bugs. Testability and reusability are also through the roof compared to just using jQuery, etc.
Reading this made me feel ignorant. I must have skipped something important along the way.
What about this made you feel ignorant?
"I heard this reddit thing can get us a lot of hits. I think it's like Digg."
I like how SAM is better because now my designer, who spent all that time learning HTML5 and CSS3, will not have to learn Angular. They can just write plain javascript functions! 
First one, I guess concatAll flattens arrays, and concat joins arrays.
Excellent. That's the type of things I missed in javascript :) Thank you very much. From this point I think I can write something better. Solved !
I feel like this is similar to Flux, but he doesn't seem to like Flux either.
Lol! No worries! So... you could do it each month. You'd have to program it up ahead of time. If the first Monday is the 3rd, then use JS's getDate() method to time it. getDate() will give you the day of the month. So if 3rd = 1, then 4th = 2, 5th = 3. Go through the month and get em all set up. Then you can a script run that gets the date and uses it's relationship to the cycle to tell you what cycle number the current day is. Make sense?
That sucks. I'm the author – if I failed to explain something sufficiently, that's a failure on my part. I'd be glad to expand on anything here though.
What about windows build?
[removed]
I thought the reason modules and HTML imports haven't been implemented in-the-large yet was because there were unanswered questions about how to handle downloading lots of tiny files over a laggy network (perhaps presuming HTTP/1.1). Is that no longer true/am I mistaken?
No just native ones
[removed]
Its a library that you use like a framework, but just don't call it a framework.
There are as many reasons why it's a good idea. There are many reasons why it's a bad idea. This is not a productive area to deal in absolutes. Not only that, but if there is a bug or defect in a 3rd party tool you're using, you will still be staying up until midnight figuring out what to do about it, because your paying customers will rightfully not accept anything but.
Go on...
Welcome to JS. There are three small problems with your code: 1: After 'function(numHours)' there should be no semicolon. 2: Don't put 'numHours' in quotes in the if statement. That will compare the string "numHours" to 8, which makes no sense. 3: You're missing a closing brace at the end. And also, (unrelated to your code), if you prefix every line with four spaces, reddit will properly show it as code.
2 good answers already, just a heads up that there is /r/FreeCodeCamp too. To expand on /u/lewisje - just as a super simplified example of hash v. collection Hash: var hash = { myProperty : true } hash.myProperty // true hash['myProperty']; //true var thing = 'myProperty'; hash[thing] // true Collection var collection = [ { myProperty : true } ]; collection[0].myProperty; // true var i = 0; var thing = 'myProperty' collection[i][thing]; // true 
What I'm trying to say is, you are asking a really stupid question.
A pre-requisite for this post is to have an understanding of the Javascript language. If you feel ignorant, the simple solution is just to learn it.
I don't want details, I'm interested in &lt;5 bullet points
tl;dr Letting front end developers dictate the API is a bad idea. Example, [GraphQL](https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html) let's the front end view specify what data the api should return. Actions should be pure functions and shareable across models. You should use SAM (State Action Model) instead of MVC. SAM is like React + Flux. 
It is, they're designed for HTTP/2, there will be not much use of native implementation over HTTP/1.1 I think having first native implementation will be a big trial for a standard. If after having that users will still recompile it to ES5 for some reason, then it means standard failed, and either should be fixed or abandoned.
I would like pages to be hosted on the Internet so mobile app and desktop app could use it and using AppCache (offline). But some html/js component might be needed for desktop app and slightly different mobile app. How we can have some kind of detection what code block does each app need?
In MVC, you have Model and View with direct refrences to each other. (example, backbone it's common to pass a model into the view's constructor.) In SAM, the View only has refrences to actions. Those actions can then infom the model to update with new data.
Minor terminological point, the author is describing what is (in my experience) more commonly called [decorator functions](http://javascript.info/tutorial/decorators), a subset of the more general [decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern) applied to functions. "Function wrappers" (or more commonly "[wrapper functions](https://en.wikipedia.org/wiki/Wrapper_function)") are kind of a different thing that typically don't add functionality, and may only serve as [adapters](https://en.wikipedia.org/wiki/Adapter_pattern) or [facades](https://en.wikipedia.org/wiki/Facade_pattern).
pretty sure facebook doesn't use websockets fyi. https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=does%20facebook%20use%20websockets I would think the additional server resources needed for websockets would be justified for subscription services, i.e. games or something, or a predictably small audience Who knows though, maybe we will get back to persistent connections by default someday. That in itself used to be something of a "security" feature. I see a new batch of DOS on the horizon too...
The hard part about directives is learning what parts not to use. Once you learn that, they are quite simple.
Well, it isn't. This is not valid HTML. &lt;div className="my-class"&gt;&lt;/div&gt; It's valid JSX, however.
1. Yup, i left await out intentionally. To show that both cases are fine 2. You can't have async all the way. Top level context is synchronous and you have to be there eventually AND all regular event callbacks are synchronous
[removed]
That's a good criticism of general-purpose APIs, but I don't really see how his architecture would solve that...
Ahah kinda, until you really need that one of these parts or you inherit a codebase that use them :)
I was thinking exactly this the entire time I read it. A good article regardless, but the terminology would be better kept to what is already out there.
1. You're mixing jQuery with vanilla JavaScript, to select nodes. Pick one way to do it and stick to using that throughout. 2. Since link is a CSS class name, your jQuery selector should be $('.link') 3. You're trying to select a tag name using the ById method. Instead use getElementsByTagName('h2')[0] I only briefly looked at the code so didn't really gather what you're trying to do, but I'm sure there is a much more succinct way to do it, especially if you're going to use jQuery. 
Hi are you using R.E.S? Reddit Enhancement Suite
funny everyone seems to have stopped reading after that same sentence. my problem with what he's saying is he basically compares Facebook with his own website, which looks pretty slick, but doesn't even begin to introduce the problems solved with ReactJS. 
What I mean you need to use libs / polyfills / lot of boilerplate to load JSON into browser apps. Sure, you can automate things to include methods into your projects, but what I meant is really native, like: `&lt;script type="application/json" src="data.json" var="data"&gt;` or `var data = loadJSON('data.json');` or similar, where you don't have the overhead of passing it to a parser before usage. &gt; fetch I did not know that, it seems they are well on their way already. Thanks.
Thanks, I am trying to do it in vanilla javascript. I had a look at some code but still cant get it to work. I am now trying to use onClick functions to run it but im not sure where I am going wrong. https://jsfiddle.net/jzzdLvm5/1/
ITT: People who would give up their left testicle to get to use MVC daily because they love it. I'm with the author of the article I'm afraid. MVC for Javascript is overkill. No amount of arguing will convince me otherwise. I have 16 Years commercial development for global brands now and MVC hasn't even made it into my JS web development and my code is still modular, extensible, OO and readable. In short, if you can't work out how to write good readable, progressive code that gracefully degrades in Javascript without having to use some massive MVC framework - you're doing it wrong. People are making JS to be more complicated than it actually is - it's a scripting language. That's all. I've made my living doing this and have *never* had an issue I couldn't solve using vanilla Javascript. *Flame away bitches.* Edit: Help yourself to cake btw ;)
Angular 2.0 was announced 2 years ago at ng-conf. They were pretty emphatic about Angular 1.x being dead (showing tombstones of $scope, controllers, DDO, angular.module) and promised a "community driven" Angular. Google started a community on Google Drive with weekly meetings, source code, timelines, etc. After a few months it completely stopped, no updates, no input, no nothing. Fast forward to next NG-Conf and everything the community had been discussing was gone, it was yet another NEW product, with new further out timeline. So the Angular 1.x crowd who was super excited about Angular 2 and holding off on building projects in 1.x due to no migration (at the time) were screwed. There was no transparency, it was kind of odd. Rob Eisenberg left as well during the shift (http://eisenbergeffect.bluespire.com/leaving-angular/). A large number of Angular devs moved to React, which has it's own cons of course. The rapid shift and leaving customers in the dark makes it hard to bet on a framework like Angular. Now, Angular 2.0 looks great... It'll be interesting to see if the community takes off, would be even more interesting to see if they didn't screw up the first pass. 
At a first glance this looks awesome, we were just implementing the concept of global/ per module styles with default properties and this looks like a nice way to handle it all :D I'll be pulling this into my companies react native project very soon :) Thanks! 
No. I think you are stupid for asking a bait question and think I'd fall for it.
Modules are highly overrated.
Would be nice to have for local development.
Awesome! Happy to hear. Please feel free to reach out and let me know how it goes!
[removed]
You're coming in here telling us you're above a very common, very popular pattern that's used by some of the best developers in our field. When asked what you do instead you say "directories." If you want to act like some big boy coder with 30 years of experience who knows better than everyone else you need to be prepared to defend your ideas. Do you even realize how you're coming off?
Speaking from a front-end perspective: 1) I would rather kill myself than build a single page app on top of public REST APIs. You NEED an app specific API that can change a lot and ensures the app state stays consistent between individual clients. Everything except for formatting and displaying data must be done on the back end or your front end technical debt will eventually reach a point where adding new features is impossible. You need both back and front end people who understand this and management who does not push them into hacking things the 'easy' way. 2) People who push canonical MVC on front-end are idiots who used to do Cobol and now switched to javascript because it is easy and well paid but they want to write it using Ruby principles because Ruby is a 'real language' and much cooler. If you think front end is anything more than this picture: [http://cdn.infoq.com/statics_s1_20160203-0311u20/resource/articles/no-more-mvc-frameworks/en/resources/fig7-small.jpg], you should die in a fire.
Bruh... http://codepen.io/anon/pen/eJLjvQ
&gt; avoiding answering the question because you're shit As I said, you're trying to bait me cause you think, at least, you already know the answer. I'm smarter than you cause I won't answer your stupid question.
I didn't, it was already provided in the code I was suppose to start with 
Can also someone explain why my code is wrong for the second exercise (the contents one)-It always says "No such contact" : var contacts = [ { "firstName": "Akira", "lastName": "Laine", "number": "0543236543", "likes": ["Pizza", "Coding", "Brownie Points"] }, { "firstName": "Harry", "lastName": "Potter", "number": "0994372684", "likes": ["Hogwarts", "Magic", "Hagrid"] }, { "firstName": "Sherlock", "lastName": "Holmes", "number": "0487345643", "likes": ["Intriguing Cases", "Violin"] }, { "firstName": "Kristian", "lastName": "Vos", "number": "unknown", "likes": ["Javascript", "Gaming", "Foxes"] } ]; function lookUp(firstName, prop){ // Only change code below this line for (var i=0; i&lt;contacts.length; i++) { if (contacts[i][prop]===prop &amp;&amp; contacts[i].firstName===firstName) { return contacts[i][prop]; } else if (contacts[i][prop]!==prop) { return "No such property"; } else if (firstName!==contacts[i].firstName) { return "No such contact"; } // Only change code above this line } } // Change these values to test your function lookUp("Kristian", "lastName"); 
I don't care how I come off. This is reddit, where 80% of everyone doesn't have a clue what they're reading about or are kids under 18. In any case, two points. I said I agree with the article so you have my thoughts. Second, the guy is asking a bait question and I won't fall for that. Especially on reddit where: &gt;80% of everyone doesn't have a clue what they're reading about or are kids under 18. 
Wow, thankyou that was a very in depth response
See. You can't even understand what I said and twist what I said.
Using react and react-native, you can write cross-platform components and change the rendering depending on which platform you're on (Web/Electron/iOS/Android).
Thanks for the comments. It's a simple alternative for collecting random snippets. I made this for myself and figured others might have use for it as well. I just wanted something easy to use and browser based since I work from multiple machines.
I'm the CTO of a small company, and a contributor to several js based repos. However you can practically live out of javascript without working with concepts such as function wrappers. I have used some of the patterns shown in the article, but not consistently and sometimes unknowingly. 
No, no, that wasn't my point. Your article is very solid and well explained. However it made me feel I'm lacking in theorical background to understand some sections. I've practically never used scope binding. I'm the kind of self taught developer that starts every method with `var _this = this;`.
the purpose and implications of bindings, like I've spent years copying a temporary reference to `this` and that, now that I think about it, I wouldn know how to explain what's the first argument for fn.apply. I've passed `this` as well as `null` and it works. But again, I seldom use `function.prototype.apply` or `call` or `bind`. 
Developer here - Samsara grew out of my work at famo.us, where I was its Chief Architect. Its main goal is to think of layout as a stream, and to create user interfaces by composing streams. Ask me anything!
`apply`, `call`, and `bind` all allow you to redirect the value of `this` in non-arrow functions. This has two important results: * Allowing you to use a function as though it was part of an object originally * Allowing you to "tear off" a function from an object without losing that context For example, imagine we had a class like this: class Cat { constructor(name) { this.name = name; } meow() { return `${this.name} meows loudly!`; } } Pretty standard stuff. We can use it like you might imagine: var tony = new Cat('Tony'); tony.meow(); // =&gt; 'Tony meows loudly!' However, imagine we "tear off" this function: var meow = tony.meow(); meow(); // Uncaught TypeError: Cannot read property 'name' of undefined Woah! An error! We lose the fact that the `meow` function belongs to `tony` when we assign it to another variable or pass it around, "tearing off" its context. We can get around this by using `bind` and friends: var tornOff = tony.meow; tornOff.bind(tony)(); // =&gt; 'Tony meows loudly!' tornOff.call(tony); // =&gt; 'Tony meows loudly!' tornOff.apply(tony); // =&gt; 'Tony meows loudly!' We can also replicate the earlier error by passing in `undefined` or `null` to these: tony.meow.bind(undefined)(); // Uncaught TypeError: Cannot read property 'name' of undefined tony.meow.call(undefined); // Uncaught TypeError: Cannot read property 'name' of undefined tony.meow.apply(undefined); // Uncaught TypeError: Cannot read property 'name' of undefined This commonly occurs when you pass functions as a call back to another function, for example, `setTimeout`: setTimeout(tony.meow, 0); // Uncaught TypeError: Cannot read property 'name' of undefined However, we can get around this by creating a temporary function which keeps the reference to `tony`, or by binding the context of `meow` to `tony`: // es3/5 setTimeout(function() { tony.meow(); }, 0) // =&gt; 'Tony meows loudly!' // es6 setTimeout(() =&gt; tony.meow(), 0); // =&gt; 'Tony meows loudly!' // through bind setTimeout(tony.meow.bind(tony), 0); // =&gt; 'Tony meows loudly!' In the context of "wrapper" functions, we're going to be passed "torn off" functions like this quite a bit, so it becomes important to understand how the `this` is being bound (or not) to the functions you're being passed. Doing the `var _this = this` allows you to somewhat mitigate the issues if you can close over the functions you pass around, but in the context of things like prototype functions, you cannot close over the initial value of `this` during the object creation, only the current value of it. Hope this helps to clear it up a bit.
Sorry for stupid. so you want a function that when pressing down a key will close all the open images on a reddit page? 
yup... only close down the images and post what shift+x does is open all the images only and then close it.i dont want that .i want to close down all the images and post not just images 
New guy here. So... you want to close the page? Return to a homepage or something?
It was a cold winter's day; snowflakes falling effortless to the ground below. I sat silently at my computer, coding a script for OP. ;) It's a function I wrote for you. It will *close* anything on the page on which it is running.
didn't you see my video if you didn't plz see it in hd .it will tell you more accurately what i want ....i want to close down the post and images i clicked ...with the help of a keystroke 
I wonder if loading JSON in a script file that way is asynchronous. 
This is good to know, thanks
While it looks like you've got your problem solved, I would like to suggest that you use eslint on your editor with a standard like googles preloaded. The reason I suggest this is it will catch the unnessicary semicolon, but in addition it will enforce a standard use of character returns and other stylistic things. While this is entirely preference while you're still new it could get you writing very neat, readable code, in addition to catching errors. A simple `.eslintrc.js` file (which would be put at the root of your project) might look like module.exports = { "extends": "google" }; 
Oh... Here, this script: window.addEventListener("keydown", function(e) { if (e.keyCode === 46) { var OK = confirm("Close all expanded frames?"); if (OK) { var allExpanded = document.querySelectorAll(".expando-button.selftext.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } } } }); If you run it in your console while browsing reddit, then when you hit the Delete button on your keyboard, it should shut down all of those expanded frames. Try it! *Tried it. It works for text posts! If it's a video and not text, you'll have to use `expando-button.video.expanded`. Make sense?
a script sounds like a possibility, possibly sed or awk or something more customised. If the .js file output from visio doesn't change (try diff), then just clobber it with your own version for now.
I see that you're planning to integrate it with Backbone react and vue on your roadmap. Why not Angular2 ?
Do you know how to open your browser's javascript console?
Good call. Doing so would give the viewer an actionable takeaway.
[Here](https://www.youtube.com/watch?v=d0pOgY8__JM&amp;list=PL37ZVnwpeshH37NxpV6XbgdDpY-w48hMd&amp;index=13) you have a talk about a use case.
No, the multi-file problem is largely solved HTTP 2. The big hold up is a standard means of referencing a module from a given local/remote file system. There are a lot of different file systems out there that have different syntax and work in different ways.
The issue is the .js file does change whenever u alter any cells in the Visio shapes, otherwise i could have just copy&amp;pasted a backup .js file i have to replace the one outputted by Visio. It would be such a massive help if there was a way to find and replace 1 IF statement without opening the file. I will explore the script idea.
Mmhmm
try this: return function() { return true; } versus return function() { return true; } The curly brace on the same line protects you from semicolon inference. 
Why not inline updated js in the html? Leave your js libraries unchanged so they can be cached.
[removed]
It's good stuff, and getting better. Something like a very tiny percentage have completed "all" of the available material, so if you do actually follow through you're in a good position.
In addition to the amazing reply fro /u/achen2345 , I would just add a high-level thing: understand what the *problem* that the code is trying to solve is. Code (and libraries/frameworks) are created to solve a particular problem, so if you don't understand what the problem is then the code will not make any sense. For example, if you were trying to understand the jQuery source, and were under the assumption that it is some sort of harness for loading plugins, then a lot of its code probably doesn't make much sense. But if you know that the primary purpose for jQUery is to make DOM manipulation easier and to smooth over browser incompatibilities w/r/t DOM interaction, then the code would make a ton more sense. (jQuery probably not the best example to demonstrate my point though, since it is so all-encompassing... but for more narrowly-focused libraries this becomes more important).
Six months ago I fell in love with recast; I've never worked with an AST transform utility that is so straightforward. There are now many issues in github with no responses and I think it's a dead project. I'm the last person who can complain about a library that isn't kept up, but I recommend finding a different AST transformer.
&gt; non-global or cascading Use an ID; set the properties you don't want to cascade.
Curly braces on their own line in JS is how you know you're dealing with a classical back-end CS type of guy. They tend to also think JS has block-level scope, though this is not so much the case anymore as more back-end guys have gotten into JS in recent years.
**Browser suppport** Chrome 49 and above by default Chrome desktop 47 and 48 with Experimental Web Platform features enabled from chrome://flags Firefox from version 25 Edge: ‘Under Consideration’
as I write this, my OSX Chrome browser is at 48.0.2564.103 so I'm guessing they should be releasing ver 49 soon enough
way late. found this post again i dont know if the intent was to use `i` outside of the for loop like that, so idk if this helps. i ended using `innerhtml +=` for append instead of `innerhtml = ` replace everything https://jsfiddle.net/poz1sdkp/
I think version 49 is due 29th feb.
1: yes in some rarer cases in the rare case two are sharing the same result: if (a == "foo" || a == "bar") output == 1 the first one has only one unique output so you can write it as output = "" if(a == "foo") output = 1 any time you use `else` you can set that as the initial value: output = "" if (a == "foo") output == 1 else if (a == "baz") output = 2 // still need this one // else if (a=="bar") output = "" // dont have to write this now // else output = "" // dont need this 2: your right! also if you have many checkboxes that affect logic (or more common is checkboxes and radio groups that enable those boxes) extract everything to a single calculate function: `calculate()` and bind that function to every checkbox and radiobox. this is way more common in industry (and avoid bugs)... 3: yea. you could pass them as parameters, but only if they are in the same spot every time when you do `if(field1) { field2 = x }`... extract that if they are in the same spot to: `function dostuff(a,b,c){ ... }` if you do that you can then create a copy of that fn that has the first 1 2 or 3 or all parameters already set with only 1 line instead of duplicating: function n(check1,check2,check3){ console.log(check1, check2, check3) } //bind 3 parameters var n13_14_15 = n.bind({},13,14,15) n13_14_15() // 13 14 15 //bind 2 parameters var n22_24 = n.bind({}, 22, 24) n22_24(1337) // 22 24 1337 //bind 1 param var n26 = n.bind({}, 26) n26("foo",1337) // 26 foo 1337 so you could do something like function calculate = (field1,field2,field3) {...} var myfn = calculate.bind({},14,15) chk16.onclick = myfn.bind({}, 16) // expands to myfn(14,15,16) chk17.onclick = myfn.bind({}, 17) // expands to myfn(14,15,17) you could also use lookup table, (an array or object that stores keys/pointers to related items) fieldsforcalculation = { 24: { foo: 25, bar: 26, baz: [27,28,29] }, 25: { foo: 13, bar: 19, baz: [] }, etc } function calculate (idnumber) { var fields = fieldsforcalculation[idnumber] // now fields = { foo: 25, bar: 26, baz: [27,28,29] } if (this.rawValue == "1") { this.resolveNode( fields.foo ).rawValue = (this.resolveNode( fields.bar ).rawValue * 7); } else if (this.rawValue == "0") { this.resolveNode( fields.bar).rawValue = ""; } else { this.resolveNode( fields.bar ).rawValue = ""; } } calculate(25) normally youd use that by getting `idnumber` from the DOM, then passing that to `calculate()` 
I have two simple rules. Top Level Classes and Functions -&gt; Braces on their own line. Body Level and Inline Routines -&gt; Opening Brace on the same line. It results in: if () { ... } else if() { } else { } or var x = function() { ... }; or switch () { } or function () { ... } or foo.prototype.bar = function() { ... } 
It took them WAY too long to do this. All the workarounds were complete crap and the feature isn't even that complex. They already had media stream but it took them years to let you save that stream in a useful way? Ridiculous.
Let the anger flow through you. Use it. Only the dark side can understand legacy javascript. It helps to imagine that you have the ability to force choke the old developer wherever they may currently be in the world now. I may have accidentally force choked a developer to death who used all 1 and 2 letter variable names once. I am not sorry. 
If you were, you wouldn't belong to the dark side, would you?
The code keeps on flowing, though. Only one bug-labeled issue is open at this point, the most recently closed issue was 20 days ago. The author may not have the time to engage with users, but he's definitely active.
1.) I wasn't even thinking about that first code and that makes total sense now lol, I don't know how I missed that when I was typing it.. The second code portion, good to know as well thank you! I also noticed on the second code if both boxes are checked it will calculate on the first part of the code instead of the second, but I should be able to fix that one after playing around some. 2.) I will keep that in mind for future use but thank you for assuring me I picked the right one haha :) 3.) I will look into this a bit more tomorrow when I'm working on it again as I don't take my work home haha, but I will let you know if I need any help after reading up some more on what you posted. Again thank you for your help on this so far :)
&gt; It looks "enterprise programmers" of the server-side figured that they'd need to pay more attention to rich clients and found appropriate to take their bloat with them when they migrated. Boom. Stopped reading. Enterprise software "is computer software used to satisfy the needs of an organization rather than individual users." It's not a look, or a feel, or a code smell, or inherent bloat, or any such preconceived pattern or concept of software development anyone may have. Using dependency injection is not a "symptom" of writing enterprise software. It's a pattern used for inversion of control. The end.
Sure, I will. When I find something valuable. 
Firefox is asking for permissions before capture your webcam.
Thank you, you really went the extra mile with your explanation.
&gt;The javascript section could go into a bit more depth on object oriented programming I think it's more than fine, I feel they focus more on functional programming rather than oop. You won't be doing oop with Javascript as you would in Java, so a basic understanding of it is enough to get you through. I'm not saying we shouldn't care about oop!Everyone should spend time learning oop. It's just that free code camp's aim isn't that. 
Case sensitivity was a big problem when I tried to do a web component &lt;-&gt; react bridge. Because html attribute names are case insensitive and props in js are sensitive, you lose information. What I ended up doing is to have a dash before a letter to make it upper case, so my-attribute would be myAttribute. This was a big of a hack but worked out well in practice.
In comparison to its contemporaries, pretty much everything. * Transclusion is a weird and confusing term, and time has not made this term any better * There's at least three ways to do a custom transclusion, two of which are considered deprecated. Have fun figuring out which * Every directive needs a factory, and usually a controller and link function * However, a directive can have, at most, a factory, a controller, a compile, a pre link, and a post link life cycle function. Wow! * *Some* of the above functions can have `$inject` for more DI, some can't. This means about half of your dependencies may be injected into your factory, and the other half in your controller * Passing in multiple sets of HTML requires custom transclusion (and very manual/error-prone DOM manipulation) * You have to manually specify what your directive can be bound with in `scope` if you want it isolated (and you do) * You have to specify what *kind* of binding lives on that scope, and none of them play with another * You can't figure out what kind of binding something is expecting without trail-and-error or looking at its documentation/source * You can specify a template URL, but this drastically complicates trying to use the component after transclusion (you have to do weird things like `$setTimeout`) * `Require`. All of it. * `MultiElement` too, while I'm at it * `bindToContoller` vs `$scope` - about half of examples in angular go one way, the other half go the other way * The whole directive configuration object is very error-prone, particularly in the 5-6 signature functions that you must simply memorize It's also just way more verbose than any of its contemporaries. Take a look at [components in vue](http://vuejs.org/guide/components.html) for something still close to angular. In react/mithril/etc., your components are literally just plain javascript functions. In fact, in mithril or some kinds of react, your components can just be *one default exported function*. And it does everything the horribly complicated directive API can do!
I'm fairly new to JS but I've programmed mostly in C++. From what it looks like your function goes through the array you've stored all the data in and the first entry does not equal the name youre "looking up" so it outputs that the first value is not equal and breaks out of the loop. I would having the loop iterate through the entire array first and should it not find it, then output at the conclusion that it was not found. I can try running the code later when I get home from class.
Hey! Your loop starts with i = 0 and first looks at contacts[0]["lastName"] to see if it's == to the string "lastName". It is not. contacts[0]["lastName"] == "Laine", is true. So move on to your next condition because the first wasn't true, (contacts[0]["lastName"] !== "lastName"), which *is* true, so... "No such contact" is returned. Make sense?
Wow, I didn't know angular 2 had to write its own HTML parser to handle all of that syntax. That would be a pretty good clear indication to me that I was doing something wrong. I guess it's more correct than ever to say that you're no longer writing HTML, but angular. What's interesting most to me though, is all of the benefits of this custom HTML parser as in the [linked blog post](http://angularjs.blogspot.com/2016/02/angular-2-templates-will-it-parse.html) ... come for free when you use your javascript as your template instead of HTML. Funny, that.
&gt; What I ended up doing is to have a dash before a letter to make it upper case, so my-attribute would be myAttribute. This was a big of a hack but worked out well in practice. This is basically what angular 1.x did as well. `&lt;directive some-argument="hi"&gt;&lt;/directive&gt;` will assign to `someArgument`. [In the blog post linked](http://angularjs.blogspot.com/2016/02/angular-2-templates-will-it-parse.html) in OP's submission, the author states this of it: &gt;Case-sensitivity solves a long-standing confusing issue in Angular 1 where you needed to just know the convention for mapping template attribute names to JavaScript names. This was an easy pit for novices and even experts to fall into.
[Here](https://hashnode.com/ama/with-aurelia-team-cijv67apt000o535313ewe3qo) is the link to the AMA
Use a Javascript templating library. I made a quick JSFiddle: https://jsfiddle.net/danneu/9qzbvxyt/4/ I use the Nunjucks (https://mozilla.github.io/nunjucks/templating.html) templating library, but you can google "javascript browser templating" to find a bunch of other options that might have better docs. Also, notice that I use a `&lt;script&gt;` tag to write the template so I don't need to painfully stitch a string together manually. It's not Javascript, so the browser doesn't try to execute it or render it like it's HTML (since it's not, it's a Nunjucks template). Hope that answers one of your questions, though I wasn't so sure. &gt; Also, are the filters (which for example look if user whos requesting the data is logged in) between the controllers enough to have some kind of basic safety? Not sure what you're asking, but handling an AJAX request isn't that different from how you handle a request from the browser. It's still up to you to authenticate the user and have logic like: if (currentUser.id === message.user_id) { // currentUser wrote this message, so we'll allow them to view it response.status(200).send(message); } else { // currentUser did *not* wrote this message, so we won't respond with it // since they aren't allowed response.status(404).send('Cant let you do that'); } Doesn't look like I understood the question.
[removed]
that means i have to paste this daily on my java script console..isn't there any other method ..... edit found a extension called [control freak](https://chrome.google.com/webstore/detail/control-freak/jgnchehlaggacipokckdlbdemfeohdhc?hl=en) will this code work in control freak and can you plz tell me how should i use this and lastly thanxx for all the help and time you give it to me 
I've never used control freak, but just copy and paste the code I gave you in to it and have it run every time you're on reddit.
So you have to do that?
Well I did it but it doesn't work.
For what it's worth Brad addressed one of the points of spec compliance here ( http://angularjs.blogspot.com/2016/02/angular-2-templates-will-it-parse.html ) I tried to respond on that blog but they don't currently accept comments. The big problem I see may be one that seems obvious but some people may also think is ok because it *may* never affect developers is this - Consider a property in your JavaScript "open" vs "OPEN" vs "Open" Sure they are all valid names for a property of an object in JavaScript but since no matter how you use it in Angular 2 it get's lowercased by the HTML parser in HTML that means the developer can no longer control which property is actually used in the expression in ng2. Anyone could argue that no one is actually going to create a bunch of properties on their controller or view-model or whatever that are simply cased differently but it points to a fundamental problem - specs are created to commonize what we do and how we learn but when everyone deviates from these specs it makes it more difficult to discern what is reality vs what is something that's magical from the framework we use. All frameworks contain some magic under the covers but if we as developers learn these things without understanding it's specific to the framework we developer bad habits because we start to think it's just how things work. I'll never forget having a 20 minute discussion with a developer who I truly think is one of the smartest and best problem solvers I know about how directives are a part of how JavaScript works with HTML out of the box before finally convincing them that they are only specific to Angular. It's important to understand the line between what is valid and what is provided by the framework in my opinion.
In conclusion, only use Angular 2 with XHTML documents, where element and attribute names can be case-sensitive.
http://codepen.io/anon/pen/yeRLBP?editors=0010
Holy shit thanks! Thought you could use a comma to separate numbers.
sure, take a look here http://codepen.io/anon/pen/BjqaJZ?editors=0010
Oh, I did this before and it didn't work. Guess I had a mistake, btw why does the &gt; sign have to be before the equals sign?
I follow a modified Allman style. The modification I do to it is that I align all assignments up in each scope.
NSA doesn't 
&gt; Using $.get([...]) I retrieve the data from the database and display it pass the strings saved in the db, that was written by users, through laravels html escape(no XSS) func before returning it as json. laravel has its own htmlspecialchars that i think is a lot better than php's i think its `HTML::entities` // AJAX route return array( sitename =&gt; 'My Site', userprofile =&gt; HTML::entities($profile), comments =&gt; HTML::entities($comments)) 
Once upon a time I believe Babel used to actually use regenerator for certain things. Regenerator uses recast. 
If I had to kick someone in the balls everytime I read shitty legacy code, I wouldn't have any legs anymore.
My answer is necessarily biased since I am myself a js dev. I tend to think that javascript, as it is right now and where it is headed is a very strong language. Though if you start to dabble into calculation heavy algorithms, you're looking for some level of micro-optimization that only low level languages are able to give you, such as C/C++. (But this is becoming less and less true, since V8 is really a fucking good interpreter) But if you're not trying to go through 250 full genomas at the same time, I guess javascript does the job pretty well. I definitely think there is a future for javascript in the science fields, mostly because it's so easy to learn and because the community is huge. You can get packages on npm for pretty much anything right now, even the most unprobable things. For anything other than heavy calculations it does WONDERS. You can contemplate this, for instance, in Google Spreadsheets, where they use googlescript for macros, which is essentially javascript, probably parsed into something else on the backend ; I guess.
How can late binding not help you with that ? You just need to make sure the objectPersister symbol is initialized with the correct value in the execution context. Using DI in javascript is like trying to speak English in German. Just speak English, IoC is built-in.
its fine. some people prefer it. you can set most of the symbols with js, but not so many other langs :) kind of cool π = 3.14 console.log(π) //3.14 imo the only thing missing is 2d array functions (matrix fns), pythons itertools, and some of the big number types and complex math stuff (javascript Math object is small compared to many languages). Easy to get around if you dont mind writing them yourself, otherwise i'd say python is faster to write code with.
And how do you get objectPersister into the context? 
unheap.com has a lot of good ui plugins, but this might be too niche. i would google 'tournament bracket jquery plugin' there was a thread on r/javascript about this a few months ago too can search it
The problem is never that there are abstractions, but that the abstractions doesn't fit the problem at hand. An abstraction that require a special parser is not a good abstraction, but that doesn't say that there are no other abstractions that actually is good. But that requires both an open mind for recognizing failure, a strong design sense, and a good knowledge of the options at hand.
I'm not sure we read the same article because it is exactly what the article says. It critizes this notion too, just in the paragraph after... Oh yea, but you stopped reading :)
This isn't a proof. Without even commenting on the relevance of mixins, I see no implication relationship between the use of IoC through late binding and rails mixins and/or monkey patching.
Most of the time the same way you get JQuery into the context. If you think of a polymorphism-like situation where different implementations use different dependencies, this still works since each dependency would use a different symbol.
People just like to talk shit... I bet the same person was bitching about the kabab-casing in angular 1 and how confusing it is.... Now they fixed that and it not HTML standard. All the while forgetting that with angular you can build an app in a month that would have taken 6 without it....
Why not link directly [to the content](http://eloquentjavascript.net/) instead of using a blogspam-thingy?
another way to write it! your using else if when you should not... because its breaking the loop dont return until the loop is finished (check every item) for(i in contacts){ if (firstName==contacts[i].firstname){ if(typeof contacts[i][prop] == 'undefined'){ return "prop not found" } else{ return contacts[i][prop] } } // continue loop: } return "not found" how you have it now you should write for(i=0;...){ if (firstname != contacts[i].firstname){ continue } else if (firstname == contacts[i].firstname) { ... } 
&gt;So every component should be in the global scope ? No I don't think so (I'm not snobing you by the way, I reserve my time for implementation discussions for clients) It's not about syntax Andrew, it's about imposing a rigid flow/architecture in your applications. There is a difference between starting most of your code with factory(['service1', function(service1) {}]) and not doing it. There are those that will discard it as a syntax consideration, and - to save us time - there are also those that will say that this helps writing modular code. I don't believe in controlling your expenses by cutting off your credit card. It usually doesn't help, and credit card turns out to be useful at certain time and to buy on internet. Then there are those that will say that Visa has a chargeback program for debit cards. I think this is fine, I am not in the business of convincing people. I'm happy to engage discussions and provide clarification on my views when necessary. Then happy for everybody to choose their lifestyle. I'm happy and successful with what I do so I am in the best position to understand that others might feel the same.
You're pretty much spot on there. Python has the right tools and a big community focused around that field. What I'm wondering is that are people beginning to develop those tools for js as well? Considering how much faster the V8 is. Is the js community showing signs that js might one day be as popular for this sort of stuff?
The main difference is things like JSX never claim to be HTML with all of the benefits associated with it. It's always been interesting to me to watch people defend the HTML as the view, then go and have to add a bunch of proprietary extensions to it to get a vaguely comparable level to javascript. In this case, they had to write an entire HTML parser just for case sensitivity! Yikes.
It is really just talking shit to you if a library has to write an entire HTML parser to get around the fact they're writing non-standard HTML? You don't see anything wrong with it at all?
This is a really nice and concise explanation of await and Koa 2. Thanks for a write-up -- it comes at a good time for me! 
this guy gets it. 
Did you see what I added at the bottom of one of my other comments? I gave instructions for what to do for video...
Check your conditional statement. You can't do the comparisons all at once like that. 
Hehe I'm just use to writing like that so I added in both options even though the other wasn't necessary :) And makes sense, my only main question on that so far though is do I actually put that into a field, or the JavaScript section for the main page, where would it actually go?
Angular 2 is the "Duke Nukem Forever" of JS frameworks. It recently hit beta after a year of development, and may never actually have a stable release until 2017. And by the time it does have a stable release, there will have been several dozen react-clones released in that timespan. 
Why have you posted this here?
The second way is a constructor function. It sets up a prototype that can be used over and over again to create new instances of the prototype. So, with the first (literal) way, you can make one car and you have to set stuff up for each individual car you make. But with the second way, you can set up a factory that can crank out car after car. And funny enough, with the constructor you will actually end up writing less code. Think about having to define all the properties of 10 cars each time a new car is built vs simply writing one line to call the constructor function for each new car.
Random data is, most of the time, a very bad idea in tests. If you do have random data, you will absolutely need to keep track of how that random data was seeded, and even then it's usually more trouble than it's worth. I can count the # of times random data has helped me on one hand, and the # of times it's burned me is easily a two digit number. That said, it usually won't kill you right away.
They are similar, but they aren't the same. Look at the console output for both. The first is just a reference to a plain object. The latter is: Car {wheels: 4, engines: 1, seats: 1} Which means that you can do things like Car.prototype.foo = 7 and then myCar.foo will be 7.
&gt; My point is that, each month Angular 2 is not officially released for production, which is a long time in the JavaScript ecosystem, the meta of what the typical stack of web apps will have drastically changed. Coming from python world, that suggests that something is wrong with the ecosystem ;-) Every month there is new "best thing" invented. 
&gt; d3 4.0 will perfectly support only ripping out and using those parts Aaah, that's great news. Now it's always a bit of gamble when you pull in some 3rd party chart components. The other day I just needed a basic bar chart and when I installed some charting module from npm my uncompressed file size went up 1 mb because it depended on d3. In the end all I actually needed was: var Scale = function ([dmin, dmax], [rmin, rmax]) { return (x) =&gt; (((x - dmin) / (dmax - dmin)) * (rmax - rmin)) + rmin; }; 
If you meant something like django, then something like express web framework is probably comparable (i.e. they both hardly change). JS code that runs in the browser changes a lot. :) As opposed to probably something that runs on node.js.
Some people can't spot they're going down a rabbit-hole even when it's pitch black, their arms are pinned to their sides by earth and there's a carrot stuck up their nose. It amazes me too, and makes me flash back to the days of arguing why Flash "websites" were a bad idea. I used to talk with people who were literally seriously advocating for building state-management, bookmarking, cut-and-paste functionality and even keyboard shortcuts into their Flash apps to address navigation and usability problems, rather than take a step back and realise all those problems were caused by the fact they simply chose the wrong technology in the first place (eg, they should have built a *traditional website* that gave them everything for free, and sprinkled flash animations around the place where some graphical flourishes were desired). As a general guideline, if you find yourself re-implementing significant chunks of the browser's core features in your code that runs *inside* the browser, then that is a sign *you have fundamentally fucked up your architecture*.
What are you paying?
Why is contacts[0]["lastName"] !== "lastName" true? When I call lookUp("Kristian", "lastName"); I don't say lookUp("Kristian", "Vos"); but lookUp("Kristian", "lastName"); so when I check contacts[0] i check if it got the property names "lastName" not its Value and see yes it does. contacts[0]["lastName"] === "lastName" true.. Im probably mixing it all up :)
Depends on the project of course. I like to flat-bid when possible. My last gig was like $8k+. For hourly it depends on the person but usually 15-30 an hour. Its a wide range but it really depends on the person and project.
To be fair, a lot of people say that JSX is "just javascript" (in the sense that it's not a pseudo-language implemented in js and half-baked into HTML syntax), but at the end of the day, JSX requires a custom parser too and doing something like `&lt;script&gt;function Foo() {return &lt;br&gt;}&lt;/script&gt;` will blow up just as hard as `foo.innerHTML = "&lt;input [(ngModel])='something' /&gt;"`. The question here should be: am I realistically going to be running into the need for an idiom like `foo.innerHTML = "&lt;input [(ngModel])='something' /&gt;"`? In my opinion, that would never happen in a real project, which makes the argument look like nitpicking from a guy who has an agenda to promote his own framework (literally, as he provides consulting for $$$). But to address the issue of over-engineering, it does beg the question why the Angular team didn't just use `ng_model` or `ngmodel` notation instead (It's not that uncommon).
V8 doesn't support async/await yet. Chakra is the only engine with (experimental) support. You have to use Babel or Traceur if you want to use it today.
I'm not a particularly huge fan of JSX either. I like [mithril](http://mithril.js.org/) and [hyperscript](https://github.com/mlmorg/react-hyperscript), especially with typescript or livescript. What's *most* interesting to me about the `ngModel` versus `ng_model` is that angular 1.x already had an established convention of getting around this! `ngModel` in javascript was represented as `ng-model` in the view. This was consistent and predictable, and one of the first things you learn when using angular. 
Small clarification with the prototype: The prototype is set up to be used over and over again witch each Car instance, as it represents a place for definitions that are shared by every Car made, but the prototype doesn't "make" instances, and the instances aren't instances of the prototype. They're instances of Car made from the Car constructor, all of whom share the same, single Car prototype object that is automatically created with the creation of the constructor function. (I'm pretty sure this is mostly just a consequence of bad wording in the previous comment)
For compilation, that would indeed be just as easy, but have a gut feeling I'd need to add quite some complexity to correctly handle webpack's watch functionality (would love to be proven wrong here). It looks like the react-starter-kit can handle watching differently since it serves your application via node. Our backend stack uses php, so this would need some proxying magic (which I ended up setting up for hot module replacement, but I also like the option of having a simple watch mode too—will probably be going more in detail on this in a future post).
JavaScript is only missing everything that makes using Python nice for this kind of thing -- tooling and libraries. I love JavaScript, but it's not currently a viable replacement for scientific computing at the moment.
StackOverflow :v
That is true that Array function inherits from the Object function. I should have been more clear that in my opinion arrays offer more primitives use cases and additional methods.
...world?
Excellent resource. I have the first edition on my night stand.
One perhaps less obvious thing JavaScript has going for it regarding scientific programming is its ubiquitousness and relative ease of designing massively parallel programs.
the console in the developer tools in whatever modern browser they use (but this would be difficult if you need to support tablets or smartphones)
I don't really see the point. ``` export default class Foo { } ``` and ``` export default function foo() { } ``` work fine. Why a babel plugin? 
I completely agree, Angular 1 is easy. Just include the script and you're up and running. With Angular 2 the whole build chain setup and required polyfills are a mess, it's not intuitive how to get up and running with it.
How did you handle source maps? The gulp-sourcemaps plugin is almost magical and it's unclear to me how webpack handles this. 
I stopped even READING about angular once I got on the React train. 
1. ```rm -rf node_modules &amp;&amp; npm install``` 2. Pray 3. ???? 4. Profit 
_returns from riding around on his broom_ The Car constructor is not the same as the Car prototype. The constructor is a _function_, the prototype is an _object_. They're separate values with the prototype being accessible as a property on the constructor function. /* constructor -&gt; */ Car.prototype /* &lt;- prototype */ When a new car instance is created, a new object is created. Through the Car constructor function, we are able to execute code that operates on that instance var myCar = new Car(); // &lt;- Car function runs, does stuff to myCar instance As part of this process, because of the use of `new`, the `myCar` instance created also gets an association with the prototype associated with Car, which is found by looking at `Car.prototype`. When this association is made - which is mostly just a variable assignment of an object reference - the `myCar` instance truly becomes a "Car" inheriting all the Car functionality defined on that prototype. console.log(myCar.__proto__ === Car.prototype); //-&gt; true // Note: use of __proto__ not recommended, but shown for demo purposes `myCar` itself is _basically_ "just" an object. Its a value in JavaScript that can contain other values that further define its makeup. It is the baby of using the Car constructor with the "`new` guy". It is not itself a prototype. There's still only one Car prototype. It does contain a _reference_ to that object though. That reference is what elevates `myCar` from a standard object into a "Car instance". Its that special reference (signified above with `__proto__` but more accurately described with the hidden, internal slot known as `[[Prototype]]`) that lets JavaScript know that when this simple object is being used, it can be used with the definitions that define Cars, as depicted in the values stored in `Car.prototype`. For the most part, "new instances of the prototype" isn't really a thing unless you're talking about making a bunch of functions, and by making those functions each get they're own, new, prototype objects. Of course _any_ object can be used as a prototype (via something like `Object.create`), so its kind of arbitrary in the end. When dealing with constructor functions and `new`, the functions are single objects which act as a catalyst for object creation that runs code when the object is created, and the `prototype` property that is automatically created with that function is a single, lonely object all instances created by the constructor look to for shared definitions. Does that help at all? _stirring cualdrun_
sure, granted everyone can have an agenda of sorts. my ex boss at an enterprise org upon news of angular 2 and all the changes it would bring said "just great, they keep changing it so they can make more money consulting on it, travelling the world and giving talks, training people, writing books--while we have no choice but to cave in as we've already bought into it and invested heavily. it's an industry". whereas I don't share his sentiment and hold different views of OSS, it makes you think... 
That link proves the point I'm making. Their HTML parser provides *more functionality* than just the one piece everyone is focused on here. They didn't write it just to make their code compliant, that's an absurd claim. A lot has been gained by writing their own parser, just as a lot was gained when React wrote their virtual DOM.
Why is everyone assuming an HTML parser was built ONLY so they could break standards and still be valid? That is an absurd claim and clearly not true as they've already listed the advantages that were gained by doing so. It's one reason, not *the* reason. Additionally, where's the tests showing that it *is* orders of magnitude faster? That sounds like an unfounded claim. That said, if one facet is slower but overall performance is notably faster, again going back to all the tests against Angular 2 showing it to be a top performing solution, then does it really matter? At the end of the day, implementers are going to be most concerned with overall performance more than individual low level performance aspects.
Looks like they've gone in a direction a little more language agnostic http://jupyter.org/ and https://www.npmjs.com/package/ijavascript
This plugin is for when you export anonymous function or class. (Which is often the case) Naturally, if you are exporting a named resource every time, there is no need for this.
For the most part, it doesn't matter. There are subtle differences, but I don't think you'll be running into them. For example the second, declaration version of test will by hoisted so you can actually call it higher in the code. test(); // something got done! function test() { do something }; This is not the case with the first, expression version of the function. One thing to note is that if you happen to be using `this` in your functions (which again, I would guess you're not so it doesn't matter), there is a difference of what it would be when considering the different forms: game.save() // &lt;- `this` is `game` // vs gameSave() // &lt;- `this` is global (or undefined if using 'use strict') For `gameSave()` style functions, you're likely not using `this` anyway, so it shouldn't matter if you go with `game.save()` instead. The benefit of `game.save` is that you're not cluttering up your global scope with a bunch of functions, instead grouping them into a single object which can help you keep better organized as you write more and more code.
See [Speaking Javascript](http://speakingjs.com/es5/ch15.html#_which_is_better_a_function_declaration_or_a_function_expression)
Hello fellow windows user! *waves*
Sure, but why would you export an anonymous symbol if you plan to use a plug-in to re-name them later? Why not give them a name from the beginning? 
I wasn't familiar with the term hoisted, although I knew how it worked and your explanation made it easy to understand, thanks for taking the time to explain
Please correct me if I'm wrong, but I would not use react for drawing stuff with d3. I'm thinking that since d3 kind of have state (move something 10 pixels to the left, then wait,then move 10px to the right). But when you're working with react you should build your app so that it can be re-rendered at any time. Wouldn't the two libraries work against each other?
Yeah I won't be using 'this' for either. I thought about the global scope too, but never really worried about that before, which is ironic since I was worrying about something else trivial. It just felt a little weird and thought it wasn't natural or something. [jsperf](http://jsperf.com/function-declaration-vs-function-expression/15) barely shows a difference too so I was worrying for nothing. Thanks for taking the time to explain, I really appreciate it
Oh that is really interesting, I did not know about function.name. Thanks for the link, it was exactly what I was looking for.
function expressions can be named too var test = function test() { do something }; 
Because I am lazy. I make tools to do the tedious tasks for me.
Chakra guy here. How much detail do you want? Generators don't touch the event queue directly since they are all synchronous. The engine juggles the execution contexts (essentially stack frames) such that each time you enter the generator body the same execution context is re-used and is suspended and saved when you yield again. Async functions are currently implemented as a source transform to generators and promises and is quite similar to how they work in Babel. In terms of event queues and call stacks, the behavior of async functions is identical to that of promises (since they're actually the same under the hood in our implementation).
Not sure what CSS has to do with sourcemaps, but I can't imagine debugging webpack-built code without them.
First you need to create a barebones page to import jQuery, and provide a script block to add custom test code. On page load, in the script debugger of your browser's developer tools, select the jquery file from the list of external source files (google will help you for each browser's UI.) For the main entry point of jQuery, it's the top of the file, not sure about angular. Then you'll want to set a break point near the top to stop the execution on page load. Refresh the page and you should see that line highlighted. Use flow control keys until it stops, using F11 / F10 / Shift+F11 keys. As you navigate the logic chain, make notes of variables that you are not familiar with, or maybe have heard of but don't know how they work. * F11 Steps into a function call, so you'll jump to the internals of that function and step on each line until there are no more and you will auto step out back to the previous code point. * F10 would have executed all of the lines of code in that function call "at once" and moved the highlighted line further down in the same view. * Shift + F11 if executed inside a function call, will take you back out to the line of code that triggered the function call or the next line thereafter (depending on if the return value of the function is used.) At any point during this process you can console.log variables you are interested in and they will be dumped to your console for easy introspection. Now that you have completed this step, you should have some specifics you can look up in the jquery api docs. Remove the main bootstrap breakpoint in jquery itself. Now you need to use the sample code from the API docs in your barebone app. I would start with $(...) which handles a couple of distinct workflows. It can compile a string snippet of text into an HTML Fragment. It can generate a promise to execute a function parameter when the dom is ready. And it can query the DOM using CSS selectors (with non-standard enhancements.) Append the body with some random elements, and a script block that tests each of your $(...) use cases. Set breakpoints on the code you wrote, and refresh the page. Now you will want to Step-In (F11) and repeat the process above. You should see some familiar parts of the code by now, and eventually you'll learn which parts can be stepped over (F10.) Inspect local variables to help fill in mental blanks. Search through the full codebase in your preferred editor to find where variables are defined so that you can read the comments around them for more explanation. Go slow, I spent two weeks ripping out all of the cross-browser strategies jQuery used to normalize different behaviors between IE, FF &amp; Chrome. It was a PITA, but in my opinion that was the most valuable asset jQuery had - well past its plugin architecture, or function chaining features. Sadly I started it around the time that IE&lt;9 started sunsetting, and native browser development was far less of a rats nest as a result. On a side note, try not to look at jQuery as a model of great code. It's a model of complicated code written for high performance and low bandwidth. Those constraints will make understanding the source more difficult for a junior developer. So you may not want to take away any best practices until you've advanced to the point that you are capable of making design tradeoffs with those constraints. I would almost argue that knowing completely the difference between .call() and .apply() is required for understanding jQuery because they manipulate scope more than most. They do the exact same thing, change the scope of `this` in the function being called to the first parameter of .call(scope) and .apply(scope). Where they differ, is in how each passes parameters to the function being call/apply'd. function foo(a, b, c) { } foo.call({scope}, a, b, c); foo.apply({scope}, [a, b, c]); In reality all .call()'s could use .apply()'s instead by just wrapping an array literal around the supplied param(s). Apply is useful when you are programmatically compiling the arguments based on a logic path. Call is useful if you know the parameters going in won't change so you csv them like any other parameter list. With practice you can learn to debug minified source code this way, a trend and skill I'm thankful is finally becoming arcane. 
Lol, I misread your first line as "Let the **angular** flow through you." and I thought what a hilarious and cruel suggesting for a beginner. The dark side rhetoric just reinforced my misread. :D
Just read the second paragraph. His definition of enterprise software is incorrect.
All the time in Best Korea.
Awesome! Thanks again!
Yes. It was a Websense proxy in my case. I can't remember the exact details but you can tell NPM to use a plain http connection. I also had to ask my IT Ops team to let NPM see through the proxy. This sort of thing is incredibly (and depressingly) common in "Enterprise" environments :(
Again, thanks for the detailed and thoughtful answer. While I'm more focused on Angular at the moment, I think most of the principles you talk about for jQuery still apply. They're different, but getting in and using the debugger is definitely a plan. I like the "go slow" comment, too. Rather than think, "today I'm going to finally understand jQuery," I expect to revisit it regularly and instead say something like, "today I'm going to figure out the way jQuery handles chaining" or somesuch.
huh ? Parallel and javascript ? How does that work?
Also [don't be clever](http://www.codethinked.com/dont-be-clever) as they say.
If you're going to use random data, you could give [json-schema-faker](https://github.com/json-schema-faker/json-schema-faker) a try. It generates data based on a json schema.
What are the main advantages of the switch ?
Fuck you and firefox.
That only works if you're comparing equality with a series of values: There's no way to write a `case` label that means "less than (something)."
 mangle: { screw_ie8: true, }, Does that actually do anything or is it a typo? We just have ours set to ```mangle: true```.
Angular 2 has a cool router and IoC container, but nothing prevents anyone from using angular IoC container with React. As for the router, there are hundreds of routers that can be used with React. Given the fact that 1/ one is forced to used either Typescript or ES6 through Babel with Angular 2 ( No ES5 isn't viable, just look at the silly boiler plate in the exemples ) , well why not directly use JSX then ? 2/ The framework is complicated , try to copy React in every ways ( components , redux architecture ... ) , I personnaly chose to stick with the original React is in not a silverbullet, but using Angular 2 is just cargo culting. There is nothing in this new framework , NOTHING that could not have been added simply with updating Angular 1. And the angular team is going to learn the "you don't break code" lesson the hard way. Angular 2 will be a failure, just watch.
Can't argue with that.
read the post. it’s actually just using the scales from d3. there are other parts as well that can be reused (e.g. color and date facilities) without using d3’s data binding and DOM manipulation
Over a year of development, they announced it two NG-Confs ago, October 2014. And they had been working on it a while before then as well.
Or the project is too huge to refactor for ease of development.
... Do you understand how the code works. There's a section that selects based on the css class `expando-button.text.expanded`. You have to replicate that section in the code with `expando-button.video.expanded` instead of `expando-button.text.expanded`.
- The incremental reloading is really fast, and hot module replacement is awesome (didn't really delve in to the last one in the post, since it deserves it's own) - The configuration feels incredibly complex at first, since there are a lot of nuances in different options, but once you're used to it it's really easy to get up and running, or adding a loader to your pipeline.
Those JS engines aren't available yet, as far as I know; and this hasn't been implemented yet on the server. I can't wait until it's in V8 stable.
https://www.reddit.com/r/javascript/comments/44abna/babel_plugin_that_gives_name_to_all_es6_export/czp1g5s
when you use `else return`, its the same as doing if (concacts[0] == theone) return else return //any code after this never executes one of the `if blocks` always exec. and both exit the function immediately. so it always exits on contacts[0]. test: function test() { for(i in [0,1,2,3,4,5]) if(i == 5) return 'yes: ' +i else return 'no: '+i } test() so just move your return "no such contact" to outside the loop, and your good to go.
Having sourcemaps properly composed through the build process is a straight up requirement for me. Debugging and error reporting on closure-compiler advanced optimized JS without a source map is horrendous.
Post the code you are using. You should be fine just plopping a `setTimeout` inside the function. Now that I look at it, you aren't supplying a callback for `setTimeout`. You need to pass it a function. Right now you are passing the return of `.removeChild`. So: `setTimeout(() =&gt; me.game.world.remove child(this), 1000);`
I was hoping that self appointing me as CTO would somehow embed that knowledge into my brain.
Have they fixed the issue with `ng-options`/`select`'s `ng-model`s value comparisons? A change with 1.4+ was to always have: &lt;option value="2"&gt;Two&lt;/option&gt; be `=== "2"` as all underlying `value`s are strings (fair enough) rather than ` == 2` as per &lt;1.4. The problem is none of our non-string bound `select`s are binding anymore because `2 !== "2"`. From `==` to `===` is a good change, but it seems the Angular team hasn't bothered to coerce the left-hand side of the expression into a string but has left that on us as devs to do it?! Really? So I have to change ***ALL*** of my APIs rather than the Angular team adding `value + ''` on the left? I'm working on a major Australian government system that uses Angular and we are unable to upgrade past 1.3 currently because of this problem. Or have we managed to miss an easy fix for this issue? Here's an extremely simplified example of the issue we're experiencing: &lt;script&gt; $scope.data = { age: 2 }; &lt;script&gt; &lt;select ng-model="data.age"&gt; &lt;option value="1"&gt;One&lt;/option&gt; &lt;option value="2"&gt;Two&lt;/option&gt; &lt;option value="3"&gt;Three&lt;/option&gt; &lt;/select&gt; Angular 1.3 binds the select without issue, while 1.4+ does `2 === "2"` et'al and of course doesn't find a match and leaves the select as blank. How have the rest of you guys fixed this in 1.4+? 
Well effectively the difference here is using props or using state. Given that props are immutable I think this works well with functional programming.
Is that your actual code or were you just too damn lazy to articulate your problem to us so we could help you solve it?
https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/
that code worked, thanks!!!
Probably not missing anything, however, there might be issues calling the render to dom call on every change, rather than having a top kevel component that never changes, so all changes are within the existing component hierarchy. Don't know if this actually makes a difference. In my app, I have a fake state on the top level component. It's an object with structure: { trigger: 0 } Whenever my model changes and I receive a call from the event listener for the only event I have ("update everything"), I call this.setState({ trigger: 0 }); This effectively forces a render without warnings, even though the state's value didn't change.
what did you expect to happen? (sorry not trying to sound like a douch, im genuine interested) also it's not an array but somthing that tastes like a array called a [`HTMLColletcion`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection) you notice it don't have array in the proto list so you can't use things like forEach.... unless you write it like `Array.prototype.forEach.apply(nodeList, function() {});` js is simple, DoM is crazy 
I use ng-options like: &lt;select ng-model="data.age" ng-options="foo.age as foo.label for foo in bars"&gt;&lt;/select&gt; and then bars would be something like: [{age: 1, label: "One"},{age: 2, label: "Two"}, ...] Can't you process the ages to ints after you've fetched them from somewhere?
It'd at the very least be the platform used to pull the data. You can't connect to a mail server in just the browser sadly :( I'd setup Node with express (or koa) and have it pull mail from your server to then spit out in an SPA as you said. Normally I'd put something together as an example, but I'm at work ATM.
That's what I was going to suggest, return a function instead of immediately invoking removeChild. Might want to steer clear of arrow functions, though, if compatibility is an issue: Edit: If you don't use an arrow function, you need to pass `this` to the callback. setTimeout((function(elem){ me.game.world.removeChild(elem); })(this), 1000); 
Hey! Yep, that's how it works! Well, *technically* it's an array-like node list. https://developer.mozilla.org/en-US/docs/Web/API/NodeList But for all practical purposes you can use bracket notation to access the elements (the nodes) within the node list just like you do with arrays. It works the same for getElementsByClassName and querySelectorAll.
I don't know what other code I need to show... I figured this was enough
If you use the second option, I believe you will miss out on all of the optimisations provided by the virtual dom in React. If you find that you need a away to extract the state from your components I suggest looking at redux.
Does this not include the promised new component router then? It wasn't in the notes.
This looks great. Will definitely give this a try
That's great, I didn't think Angular 1.x would receive any more updates after Angular 2 and since I'm more proficient with it, I'd still use it for simpler projects/tight deadlines where setting up an isomorphic JS app would be too much trouble.
Small hint: ~~Array.prototype.sort does not sort in place but returns a new array with the elements sorted.~~ Edit: hint was bogus :-P
I tried that, but it doesn't work as well :/ function largestOfFour(arr) { var newArr=[]; for (var i=0; i&lt;arr.length; i++) { var arraySorted=[]; arraySorted=arr[i].sort(function(a,b) {return b[0]-a[0];}); newArr.push(arraySorted[i][0]); } return newArr; } largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);
Really? Guess I'm behind the times, thanks for the correction.
Excuse the naivety, but are generators are a feature in the engine, while async and await are syntactic sugar for generators and callbacks (promises)? 
Part of me hopes not... Else I can look forward to a series of new bugs reported against form-for if they change select/options.
My hint was wrong anyway, actually. Sort does sort in place. Was confusing with Ruby for a second. I think the problem is in your sort compare function. a and b will be numbers of the sub-array, and yet you are accessing [0] on them.
No prob! &gt; its never gonna be true (this part: contacts[i][prop]===prop) because it will always compare the value of the property (which is for example Laine (on the left side) with just the "word": "lastName" right? Hmm... within the context of what you've got up there, I don't think it will be, but it could be in another situation. Check this out: http://codepen.io/anon/pen/WraEey?editors=0012 Kind of a goofy example, but that's how it could be true there.
Since we're splitting hairs, is your example really the definition of a closure or is it instead one of the benefits of using a closure?
That's a pretty particular example, and in those cases it's better, imo, to expose your api surface in index files. // two/index.js export { two } from './two' It's not like you're going to know what the code does just by knowing the function name anyways, so it's a small benefit.
 function count (num) { for (var i = 1; i &lt; num + 1; ++i) { console.log(i + ""); } } count(10); Here we are using a loop starting from 1, doing num + 1 to offset starting from one and converting the output to a string. 
Wow, thank you so much! You're a life saver! :) Edit: actually, I was wondering how I would go to make it so that it would not need the console command?
But you can't do this if you're doing something stupid like returning a new object from a function call (e.g. `ng-options='item in myFunct()'`). Then you try and use `track by` but that cannot be used with `select`s (as in the horrible ng-options version, not HTML DOM objects). What ***may**** get us around it is to cache the results from the first call so that all references are the same and we won't need `track by`, but I'm not sure that will work in all cases in our system.
negative velocity would move up, positive down tbh that looks like an `animspeed/2 * fps` calculation to me, so the first one is (bounce for) 4 frames maybe and the 2nd one 2 frames? not 100% sure. im not a gamedev. /r/gamedev is really good tho docs (i think this is the framework): [link](http://melonjs.github.io/melonJS/docs/me.collision.html)
is their goal to update angular and meet up with 2.0? or is it being maintained separately for x amt of time and there's an eventual abandonment and expectation for you to switch
You had the right idea with your `output` variable. Something like this should work: function count(num) { var output = ""; for (var i = 1; i &lt;= num; i++) { output += (i == 1 ? i : ", " + i); } return output; } count(10); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 I'm using the ternary operator in line 4 to cut down on code length. Its syntax is `&lt;condition&gt; ? &lt;if true&gt; : &lt;if false&gt;;`, and can be expanded to if (i == 1) { output += i; } else { output += ", " + i; }
Thanks for your help!
You could always make your function act on a persistent scope reference rather than create a new object. 
* Make an ajax request to your server * Your server returns HTML * Your javascript inserts that HTML somewhere in the DOM. More modern web frameworks make this pretty easy, since the pattern is so common nowadays. Heroku is using EmberJS If you were to do this with jQuery, it would look something like this. On Heroku, that right part (the content) has a class of 'main-panel'. The left part (the navigation) has an id of 'sidebar' Ugly code but here's the gist. You'd want better error handling, maybe some transitions, etc. $("#sidebar a").on('click', function(e) { e.stopPropagation(); // prevents the link from actually opening the target url = $(e.target).attr('href'); $.get(url) .done(function(response) { $(".main-panel").html(response); }) .fail(function() { $(".main-panel").prepend("SHIT BROKE!"); }) }); }); [jQuery's get function](https://api.jquery.com/jquery.get/) (use the promises - done, fail, always) [EmberJS](http://emberjs.com/) (though there are tons of frameworks that are similar) 
Can you explain what the first part of that function does with stopPropagation? It's not opening the new link and then I'm slightly lost.
You use pushstate for that (google it) (EDIT: OP's comment originally asked about address bar URL manipulation). I've not used it, but that's what you use for URL manipulation like that. Your code starts to get more complex, but a basic application as we're discussing really shouldn't get that tough. I defer to others for recommendations. I use jQuery in my day job since I work on projects which existed before Ember (etc) existed.
Ok I understand what your function does, I will check out pushstate right now. I've used jQuery before for AJAX and I would like to stick with it because that's what I know best. Thanks so much! Very appreciated :D
Good luck! I'm sure others in this subreddit will have plenty of valid opinions about frameworks, if you're considering going in that direction. That said, this pattern is very well established nowadays, so you should be able to find plenty of tutorials and documentation to help you along.
What would I google in order to find more information about this kind of stuff? What is it called?
I'd start by reading this: http://diveintohtml5.info/history.html You're going to get pretty far just by reading about HTML5 history (aka pushstate)
Thanks alot! These resources seem very useful! :D
One consideration - only the first form allows you to take advantage of `const` and `let`.
No i am really new in coding if i knew coding i will not waste your time here .... and if i just have to replicate the sections you shouldn't say this at the beginning &gt;If it's a video and not text by this I thought you are saying one thing at a time ..... okay i did it but its only working on videos and post its not working on images and gifs At first i tried this thinking this could work but this didn't work window.addEventListener("keydown", function(e) { if (e.keyCode === 46) { var OK = confirm("Close all expanded frames?"); if (OK) { var allExpanded = document.querySelectorAll(".expando-button.selftext.expanded"); var allExpanded = document.querySelectorAll(".expando-button.video.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } } } }); And then i tried this i removed warning from the 2nd one because i didn't need it .......this worked but only for videos and post it didn't work for images and gifs window.addEventListener("keydown", function(e) { if (e.keyCode === 46) { var OK = confirm("Close all expanded frames?"); if (OK) { var allExpanded = document.querySelectorAll(".expando-button.selftext.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } } } }); window.addEventListener("keydown", function(e) { var allExpanded = document.querySelectorAll(".expando-button.video.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } }); Edit Fixed Gifs and images For images and gifs it was .expando-button.image.expanded, .expando-button.video-muted.expanded Removed all the warning's in this code window.addEventListener("keydown", function(e) { var allExpanded = document.querySelectorAll(".expando-button.selftext.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } }); window.addEventListener("keydown", function(e) { var allExpanded = document.querySelectorAll(".expando-button.video.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } }); window.addEventListener("keydown", function(e) { var allExpanded = document.querySelectorAll(".expando-button.image.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } }); window.addEventListener("keydown", function(e) { var allExpanded = document.querySelectorAll(".expando-button.video-muted.expanded"); var i = 0, expLength = allExpanded.length; for (i = 0; i &lt; expLength; i++) { allExpanded[i].click(); } }); Can you plz check the code are there are any mistakes in it i removed warnings does it affect the code in any way possible and how to change the keybinding right now we press delete button to close all the things how to change the delete keybinding to Mouse button 5 thanxxx (i have multiple mouse keys so how to change it mouse button 5) **Sorry for the really bad english its only been 2 months since i started learning english...i can't write english properly but i can understand it properly** and the last question would be how many days did you take to learn java script if i learn javascript how many days it will take me to learn the code thanxx ***and Thanxx /u/ForScale for Helping me Till The End*** 
They always talk about how they'll keep the 1 branch up for a while. Also I doubt the "soon" part, because Angular 2 is still in beta and having all the 3rd party components migrate to 2 is definitely going to take a while. 
Chugging is a good word for it.. [Dojo2](https://github.com/dojo/dojo2/tree/master/src) was due out at the end of the year. The last commit was 8 months ago. They also mentioned using popular libraries instead of re-inventing shit for 2.0. Look at the repo. They fucking re-wrote promises + a bunch of other shit. Dijit widgets are a fucking nightmare, everyone at work hates them. Don't even get me started on the non-standard AMD plugins they use (have fun building dojo using webpack or require.js). I don't see how they remain relevant going forward.
Thanks for the idea but I really needed something for the introduction. Developer tools will be for sure used in the last lessons.
I just missed it appartently. Perfect reply ! Thanks !
`arrayOfArrays.map(a =&gt; Math.max(... a))`
Very cool
2 frame web layout, now thats something I havent seen in a long time
If I removed [0], it still doesn't work- it gives me undefined. Also, I did Math.max and the map method, I know it works, I am still trying to solve it with sorting just because I want to know how to make it work with sort().
Uh... apparently you haven't visited ESPN or NBC Sports lately. They both switched to a framed format last year, and it's awful. Also this whole infinite scroll thing.
More elegant to simply call forceUpdate(): componentDidMount() { Model.onChange(this.forceUpdate); } or set state properties explicitly: componentDidMount() { Model.onChange(() =&gt; { this.setState({ foo: 'bar' }); }); }
Perfectly sized, lazy loaded responsive images (mediaquery and/or selector based) based on schema.org microdata: http://codepen.io/dlueth/pen/VeGrMe
Your function declaration in the script file should look like this. var updating = function(element, data) { var target = document.querySelector(element); var raw_data = document.querySelector(data).value.toUpperCase(); target.innerText = raw_data; }; Notice I'm just passing the parameter names into the document.querySelector calls. This gives you the flexibility to change your target and raw_data variables every time you call your updating function. Now get rid of the last line of our script file. That updating call isn't tied to any event so it's not really doing anything for you. The important calls are in your html file. Edit the &lt;input&gt; element like this: &lt;input id="raw_data" value="abcdefg" type="text" onkeyup="updating('#update_element', '#raw_data');" onchange="updating('#update_element', '#raw_data');" onfocus="updating('#update_element', '#raw_data');"&gt; Now you're passing in the element IDs as arguments each time updating is called.
Ehh the weird part is when you want to do transitions. I think some people opt for `React.addons.TransitionGroup` as to preserve the DOM tree.
Sry for coming so late back to you (so many deadlines coming up right now..). That is exactly what I was looking for! Thank you very much for the example you provided, your solution is much more cleaner and easier to write. Going to research later more about Nunjucks and Handlebars (as another user in this thread mentioned) and look where the differences are (: &gt; Doesn't look like I understood the question. You did (: I am kinda late to the party (working with asynchronous calls) so I was kind of scared by them.
The barrier of entry is much lower for propTypes than it is for flow/TypeScript (especially when integrating with an existing project). Facebook is actually planning to phase out propTypes in favor of flow eventually, but for now it's an easy way to do basic type validation.
Gawd, no offense, but this almost reads like a parody of everything I hate about current javascript trends. Remember when it was all as easy as adding the jquery script tag and then figuring out what you needed to do in the interactive console? This trend of adding compile steps on top of interpreted languages breaks my heart. Interactive sessions can't be beat for figuring out how to get stuff done fast, and they are being hunted to extinction.
Great comment, but probably I haven't give much context about what I aim to achieve with a more complete version of this module. My idea is that very often we need to have an easy way to separate functionalities in your gulp tasks. This module already helps with this (even if you can do it with some lines of custom code if you want, as you said). But what I would really love to do is to have reusable gulp tasks that just accepts a configuration object to become specific for your project. I am already working on a 1.0.0 version that should also help with this.
Please dont forget to mention Victory. http://victory.formidable.com/
Appreciate it!
Fwiw I've switched to using pure Npm (scripts) + Webpack for my recent projects (no Gulp/Grunt/whatever) and I'm fairly happy with it.
this.forceUpdate() is the same as this.setState(appState), except it doesn't rely on you keeping a reference to appState. This seems more elegant to me. Whatever design you go with, flux or not, some components need state and cannot be pure. For example, recently I made a DropdownMenu component. I think that would be impossible to do without setState.
The problem I see is that the paths to the custom modules are dynamic, depending on which client I want to build the assets for. So I won't always want to override `module` with `client_a/module`, I'll sometimes want to override it with `client_b/module`, so hard coding these overrides in the `package.json` won't be flexible enough. Unless of course I'm approaching this in completely the wrong way, in which case I'm open to other suggestions. :)
`string-=str[i];` is you're main problem. Though `+` is an operator for string that represents concat, there is no respective `-`. You either have to use methods in string like `slice` or `substr`, or you have to go at it from the other direction. Instead of taking away from your input string, build it up, one letter at a time using `+` until you reach your input `num`.
Here's [how you probably want to write your function](http://jsbin.com/ratifo/1/edit?js,console,output). Notes on your code: 1. What do you expect `num.length` to be? In your example code you pass `11` as second argument, so what do you think `11.length` will be? This is the reason you always get back the same string you passed to this function: `str.length&gt;num.length` will *never* be true (I can explain why that is if you are curious). 2. You can't subtract characters from a string in JS, like you try to do in the `for` loop. When you use `-` (minus) operator with strings, they will be converted to number, which isn't something you want in this case. 3. It might be just reddit's text editor, but try to indent your code: it makes reading it much easier.
Ohhh okay..I thought if you can add letters to a string, you can also remove letters..
Had a debate today on angular vs react. People said its quite hard to learn react.
Maybe, but if you're using JSX you pretty much have to have some kind of build step going on. Integrating typescript or flow into that ... flow (heh) wouldn't be all that hard. I can't speak for flow, but you can basically rename (valid) ES5/6 to .ts and it'll still compile, though you will need to install the typings.
Can't wait to read part 2 and part 3 of this! 
Working on it! It should be in around 2 days since I don't want to rush it out.
In your `while` loop, you check for `str.length` not being equal to `num`, but since you never change `str` inside the loop, what do you think is going to happen? And if you change your `while` check to be `string.length!==num`, think about what's going to happen to `for` loop inside of it. (Hint: `while` and `for` loops are not running at the same time) --- **Indent** — add additional spaces or tabs before actual content of the line to show hierarchy, i.e. code inside the `for` loop would be indented one level to show that it's executed only when `for` loop is running. Your code indented: function truncate(str, num) { var string=""; if (str.length&gt;num) { while (str.length!==num) { for (var i=0; i&lt;str.length; i++) { string+=str[i]; } } return string; } else { return str; } } 
After reading this I'm convinced that Webpack doesn't do anything better than what I'm already doing with Gulp.
It seems that cells are rewriteable, I can make an O an X by clicking on it. It is not really important, tho.
Lol. We all make stupid mistakes. It's part of the job. Not that it would have helped here, but you should look into using a linter. It will help catch a lot of mistakes like this in your code. (It may have helped here, I generally don't put config files through the linter though)
Fair enough. I'm not anti-gulp or trying to convert you. I'm glad what you have is working for you :D 
Well boo fucking hoo, someone does something differently than you. 
Some feedback: for those who've never heard of webpack, might want to start off with "what is webpack" before "why webpack". Cool thing though!
I agree. And that's why I won't be learning Angular 2 anytime soon. Too much to learn at once, just let me live a little for Christ's sake. I just started feeling comfy with React/Redux.
Ah that was actually a conscious decision. I think people care a lot more about why to use it/what it can do other than what webpack actually is. I also saw this a while back, which influenced my decision: https://www.youtube.com/watch?v=u4ZoJKF_VuA
Check out [commemoji](https://github.com/martellaj/commemoji) so you don't need to remember the codes. Also supports Atom's emoji commit style guide! /u/_ar7 
I've actually been using: https://atom.io/packages/autocomplete-emojis It's super useful.
To build out your paths, use Node's path in your gulpfile: var path = require("path"); This provides a cross-platform abstraction of file system paths. This lets you write out paths for Node like this: var default = 'whatever'; var blog = 'blog-whatever'; var post = 'post123'; var module = argv.module; var pathToModule = path.join(default, blog, post, module); You'll need to create some functions to initialize your module paths and use it with the test I gave before for whether a module flag was provided.
Does the Html plugin add a script tag to the output html for the bundle? I noticed the template doesn't have one.
Good question! Yeah it actually does. At first I had the bundle in there, and I almost posted a question on stackoverflow asking why webpack was loading my files twice haha. I'll make it more clear.
Nice, that's good to know. Nice tutorial, I just tweeted about it. Looking forward to the next parts.
Thanks the response. Creating a plugin for Browserify is out of the question tbh, due to us not being that proficient in JS. I've just found that webpack has `require.context`, allowing for dynamic requires. Do you know anything about that, and if so is it appropriate for my situation? My thinking is that I could use it to require the directory containing the custom modules for every client. Then I could create a module that would be in charge of loading my local modules - it tries to require the client version of the module. If it exists it uses that, if it doesn't exist, it requires the default module. I'm not sure that would work, but it's an idea. Any thoughts?
EAFP is very much a Python idiom which is allowed by the ecosystem. JavaScript's exception handling is not used widely so it won't work that well in JS as most cases are going to be very broad errors like TypeError etc.
Made the change: https://github.com/AriaFallah/WebpackTutorial/commit/f75308a52aeb54bcf84e93b3dc01a6343440e105 And I appreciate that a lot!
I love what you are doing and good job! I was on the same boat a few months ago and could have used this tutorial. Correction, I can still use it. I wish you the best luck.
Dojo was always held back by IBM, who was mostly responsible for Dijit. It's too bad, dojo had such promise and it was the first to implement many features that are used in other libraries and frameworks. 
I wouldn't want to speak ill of the people who made such a great tool, but I agree :p
I'm not sure that it's totally fair to say they re-wrote promises etc. when they had them before the more mainstream implementations. They've had promises since the very early days of the toolkit. They're likewise "non-standard" for AMD as they predated it and were one of the influences in its creation.
Well many great tools all have terrible documentation.
Although JavaScript is *everywhere* - you don't find it so much in big games: it doesn't have any cred in "serious games land" even though many will use a scripting language embedded in the game for modding and prototyping. A lot of games use Lua as a scripting language - and if you're confident with JavaScript, it will take you no time to pick it up. In fact, if you're confident with JavaScript you won't have that much problem with *any* modding language: they're usually designed to be expressive and relatively simple. A better way to do this is to find games you like and check out the code of some simple mods and see if you can figure it out! Also, making games with JavaScript is getting more and more popular: so if you're into modding, why not go all the way and start making your own ;)
Does hot module reloading mean I can edit a CSS file and see the changes immediately across devices like browsersync?
`i` is just a variable that with each iteration of `for` loop is set to some number and we treat it as an *index* (it's for this reason why we call it `i`). So, in our example, `str[i]` will become `str[0]` during the first iteration of `for` loop, and `str[1]` during the second. We do it because individual characters of the string can be accessed this way: "test"[0] //=&gt; "t" "test"[1] //=&gt; "e" "test"[2] //=&gt; "s" First letter is at index 0, second letter is at index 1, and so on. If `str` has `str.length` characters, last letter will be at index `str.length - 1`, so if we go through letters from index 0 to index `str.length - 1` we get back original string. `str.length` is just a convenient number for most `for` loops that operate on the whole string. Does it make sense now that there's no magical connection between `i`, `num` and `str.length`?
Because is about javascript.
Worth noting that using a variable declaration for the function you can reassign that variable to another value later on, or even another function. A common pattern I see is pointing a declared variable function to `noOp`. 
Awesome :D
Yes, but only if you make your server accessible from ips on the same network. I'm sure you can do this with the webpack dev server, but I haven't really looked into it.
How does webpack compare to rollup.js?
And you can proxy it? I'd like to use webpack inside a Rails app, I have something similar set up that uses gulp + webpack + browsersync + a bunch of other stuff but if I could simplify and rely on fewer tools that would be great. 
Certainly not impossible. In the redux paradigm, a dropdown menu's `isOpen` or what have you can be stored in global app state, toggled with an action creator, and passed down as a prop. Whether doing it this way is more practical than storing it as local component state is another question.
I know the new release of webpack2 does tree shaking, and that webpack currently can do async loading. So I guess there's not a big difference.
No. edit: but if you tell us why you think you need this, maybe we can help you find an adequate solution. second edit: Think about what it means for something to *be a pair*. There is no type 'pair' in JavaScript. You can only group things into pairs using a container like an array with two spots, or an object with two key/value pairs.
ohhh okay :) I kept thinking we have to "tell the computer" where to loop through, like give him a string or array by saying i&lt;str.length for example.. Thanks a lot!!!!!! 
\*\*/*.js would pull in all JS files under a directory recursively? Or am I missing something here?
Not gonna get much interest without some more examples in the readme (preferably not so trivial) of what Juliar excels at compared to other langauges
The benefit comes from tree shaking dependencies, not your own code. Lodash is a perfect example.
Tic tac toe doesn't really need an AI. There is an easily follow able set of steps to at worst tie every time. The real difficulty is dumbing the "AI" down so the game is actually fun
Yeah, I've found it really useful in some specific scenarios. One I used it recently with is to generate a style guide based on some .yaml files I had alongside my component files. Because it was dynamic, if you added a new component and built, it would just appear automagically on the website. I've also seen it used a lot for running unit tests for similar reasons.
This was inspired by a project from here: https://t.d3fc.io/
No it's even easier. You define a single entry point and webpack does the rest. module.exports = { entry: './index.js', output: { path: './public', filename: 'bundle.js' } } And then webpack will put watches on all files you `require` via your entry file. This is the most basic of basic config files, pretty much copy pasted straight from their website.
How can one do that? I could only thought of making good or bad moves randomly.
Can you explain what for(let sub of array) means? is that some special loop? (Im a beginner :)
Also I m getting a SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode when I copy paste what you had
Here is that converted to common javascript - he's using the more modern, less commonly support version of javascript. var array = [[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39],[1000, 1001, 857, 1]]; for(var i=0; i &lt; array.length; i++) { array[i].sort(function(a, b){ return a - b; }); } console.log(array);
Thanks-I've tried whats being suggested there but nothing works-I m getting: [ [ 4, 5, 1, 3 ], [ 13, 27, 18, 26 ], [ 32, 35, 37, 39 ], [ 1000, 1001, 857, 1 ] ] so its still not sorted..
Yes, that would be the ideal solution. If you can give me an example of how I could do that? Let's say its based on the request host name - clienta.host.com should use client a's custom modules instead of the default ones, and clientb.host.com should use client b's custom modules instead of the default ones - how could I do this at run time? I'm open to using any additional tools / libraries.
Something else: if you want multiple entry files and you do file globbing, you're going to have a bad time. The webpack approach allows you to slice and dice your bundles however you want with very minimal effort on your behalf.
Wow! Tree shaking is compensation for a lack of discipline and bad code practices? DCE is used by pretty much every compiler ever, including all of the popular javascript minifiers. 
Man I wish I had seen this 2 days ago before I suffered figuring all this out before starting on React :P Great stuff, hope it gets some visibility.
A function is an object just like any other. It can be passed as a parameter to a function and/or returned from a function. `makeMult` returns a function, so `xTen` and `xHundred` are functions, since they are assigned the values that are returned from calling `makeMult`. `y` is the parameter that those functions take. When they are called on lines 12 and 13, the value 55 is passed as that parameter. `y` does not yet have a value while `makeMult` executes. It's just the usual mechanics of defining a function that its parameter is not known when the function is defined. Suppose you had a regular function: function example(name) { console.log('hello ' + name); } ...and I asked you what value `name` has. You don't know, because this function has only been defined, it's not been called. The value of `name` isn't known until that time. It's the same in your example, except that the function is defined in another function, but it doesn't change the fundamental fact of how function definitions work. 
I'm with you there man. Webpack was really rough for me too when I was first starting off with React.
so then there is nothing special about webpack.
The argument that classes promote inheritance doesn't make much sense in my opinion - they *allow* it, but any push towards actually using it is purely out of habit on the part of the programmer. I've pretty much exclusively switched to composition over inheritance as I find (performance consideredations aside) it allows me to write cleaner encapsulated code. So far there has been no case where I've felt pushed to use inheritance instead and composition is generally as simple as class Foo{ constructor(){ this.bar = new Bar (); ... Instead of class Foo extends Bar{ ....
Why?
Nah, not really (that I came across). The main differences between React and Vue as far as limitations go has to do with community size. React has more quality community-produced libraries/components, more people writing about it and answering questions, more examples and more production websites out there written with React, etc. Technically speaking the lack of a virtual dom in Vue also limits you to client-side rendering. In exchange Vue is more lightweight and, in my opinion, easier to read and learn.
I personally had trouble learning React--but not entirely because of React itself. It's because Angular gives you a complete set of libraries needed to build a web application. You don't need anything else. React only gives you a view builder. This is enough for toy applications, but if you want to build anything with more than a couple of pages, you need to learn Flux/Redux/??? and fetch and then realize the quirks of React/Redux when it comes to nested state/props, and that you need to learn Immutable.js to resolve that, and... As much of a monster as Angular is, all the documentation is in one place and you only need to learn one framework. (Of course this only applies to Angular 1.x. Angular 2 is hard to learn, but I attribute that to the fact that the documentation is incomplete in many areas.)
It could also read from the BOM, like `location.href` and that's harder to fake than the `Referer` header, because if you set `location.href` you trigger navigation.
.io is not hip enough?
Gotta separate ourselves from the Ruby hipsters.
When is .ninja going to pick up? 
When the LSD kicks in
This is why I'm not a millionaire from implementing js calendar scripts on wordpress
Unfortunately, rails isn't going to work for my proposed architecture... Thanks anyway!
I'm a big fan of TypeScript. I use it in some of my open source project. Flow's okay too. I use it at work. I like that both of them use an inline syntax (eg `variable: type`) as opposed to annotations like Closure (eg. `/** @define {boolean} */`). Static analysis is good stuff. Using either TSC or Flow will give you better coverage against typos and certain types of common mistakes than will vanilla JavaScript- so I suggest you give one a go. PS. TypeScript comes with the added benefit of Web Storm which is pretty slick IMO.
"Gulp vs Webpack" http://i.imgur.com/2bNfj14.jpg
In chrome, just put a ? as the first character and it defaults to a search e.x. ?react.js or even ?google.com
There is an add-on for Firefox called [GreaseMonkey](https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/) that allows you to execute arbitrary JavaScript on a given page or range of pages. There are tons of user scripts already available for GreaseMonkey but if you can't find one to your liking then it really wouldn't take much googling around to find out how to add a calendar widget.
Yes, same thing I noticed. It's sad because I'm really looking forward to using it.
Hey, I saw that the squares take long to be created and did something about it [here](http://codepen.io/yuvalsaraf/full/OMBBoL/). As you can see, the ui is built in 1 go, making it much faster, as for the animation, negative delay can be used on animation to make it start in different times, making the animation the same a cross all devices. Unlike before - the animation was depended on the speed which the setTimeout was called (not always the same as you define it). 
That looks great! The reason for the setTimeout was to make it more obvious how the effect is constructed, but I do prefer the final look of yours more. Nicely done!
On the script include tag that you provide them, add a query string that would be their unique identifier. e.g. &lt;script async src="www.hosting.com/myjavascriptfile.js?id=1234"&gt; &lt;/script&gt; On the server when that file is requested you store the Id for that session and any data that comes back you store against that id. This id you can map back to the publishers page. The other way someone mentioned was grabbing the pages url (location.href) but there are issues with that, one of those being that storing a string in a db is not as memory efficient (though you could reverse the process and do a lookup of that url vs the Id, but it still means that you will have to do more computation on the server when the connection is live to figure out Id to site). And depending on where someone is running your script (e.g. An iframe) you might not pick up the correct page you're running on. You're better off mapping the data on the Id later on when pulling stats. I'd highly recommend reading "third party javascript" by Ben Vinegar as it covers all of these kinds of use cases. 
It often seems like Doug Crockford goes out of his way to contort code just to be different and I don't always get why he does the things he does at first. The things is though, I think he's basically always right when it comes to JavaScript. I JSLint my JavaScript code and it almost always ends up looking like good code and I thank JSLint for that.
There will be situations where hacker types will try to send bogus data to customer accounts.
Visual Studio Code also has some amazing TS support if you can't afford Webstorm.
http://l20n.org/
Very cool!! Some quick observations * No hyperlink support * Allows each tab to be a separate connection * The session is instantly killed when the back button is hit even if the time away is less than a second
Yeah, it's really yet just a boilerplate.. Pull requests are welcome ;)
The expected take-away from this example is the closure nature, that each function returned from makeMult keeps it's own value of the "mult" parameter, no matter when and where it is called. 
It does makes a difference. 
Just search for *mdn* + whatever. E.g. *mdn promise* -&gt; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
1. `Object.create` is (sort of) new to JS, but it is the preferred way to set up inheritance for the prototype. Before it existed, using `new SuperClass()` was basically the only way to set up inheritance in the prototype chain. So older code you'll see use `new`. The problem with using `new` is that you get side effects of the constructor call as a result of setting up class inheritance. For example, lets say the constructor for Vehicle counted how many vehicles were produced. function Vehicle(theName, numWheels, numSeats) { Vehicle.count++; // ... } Vehicle.count = 0; // ... function Car() { // ... } Car.prototype = new Vehicle(); // ... var car1 = new Car(); var car2 = new Car(); console.log(Vehicle.count); //-&gt; 3 ... not 2? But I only made 2 cars! `Object.create` does the same association of connecting the prototypes but does so without calling the constructor. 2. Using `Vehicle.call` (effectively `super`) is the preferred way since it enforces a consistency in how that input data is handled. If the constructor for Vehicle ever changes and decides to have a new behavior that always removes a wheel when a new Vehicle is created but not when a new value for `numWheels` is set, then having car use the setters in its constructor wouldn't allow it to follow that behavior without you also going into `Car` and updating it with the same change. Throwing that responsibility to the Vehicle constructor means not having to worry about stuff like that and that data gets managed consistently throughout all subclasses. 3. No? I'm not sure if I understand 3, or what its difference from 2 is. If my response from 2 doesn't clear that up, then I might need a little more info ;)
If you want to look at the internal implementation you should check out the source code of some JS engines (like v8) edit: https://github.com/v8/v8/tree/master/src/js
Not what I need.
Thank you!
first one missing `return newArr` second one too shorter way to write it: function bouncer(arr) { return arr.filter(function (x) { return Boolean(x); }); } bouncer([7, "ate", "", false, 9]); //[7, "ate", 9]
I'd say 2D should be faster due to it makes a square and then takes the square to get a circle on pure integers. compare it to a between select in sql, if it's only ints and there's an index on it it's blazing fast. 1sec sounds a bit extreme for a responds. I did this many, many years ago with MySQL. you have to turn all lat/lng data into kilometers, to flatten out earth. accounting for the curve and then do he same in the query. you end up with this: https://gist.github.com/tobsn/899413 fyi, it's very, very fast.
Do you like it? Everything starts from humble beginnings, even a project like Angular was a single line of code...
You mean falsy values, right? &gt; [7, "ate", "", false, 9].filter(item =&gt; item) [7, "ate", 9]
If I return newArr, it doesn't work as well- Im only getting "false". Also I wonder why I have to return newer - in another exercise I didn't have to return it and it worked: var oldArray = [1,2,3,4,5,6,7,8,9,10]; var newArray = []; newArray = oldArray.filter(function(x) { return x&lt;=5; }); Where is the difference btw. those two exercises?
yes :)
You're not calling 'setCookie' with all the parameters, that might be it.
True! Although Web Storm gives free licenses to open source maintainers. (That's how I got mine.)
Are you asking why x==false is not the same as Boolean(x)?
Could you elaborate a little more on that? What changes do we need to make?
VanillaJS is an in-joke. It's not a real framework or library.
Hi, I think you might not need to use img.onload = function(){ ctx.drawImage(img,position,0); } You can probably just use drawImage directly. ctx.drawImage(img,position,0); Hope this helps (: Okay, I think I know what might be happening. From this http://stackoverflow.com/a/15850795 SO question, it seems like it is crucial for the image.onload event to be defined *before* the image.src is defined. I'm guessing that the moment img.src gets defined, the browser fetches the image immediately. So basically your image.onload events never fire, which you can debug by placing a &gt; console.log("Loaded image "+j); or &gt; alert("Loaded image "+j); inside the image.onload event. 
It's not about the order of events, though. OP is just overwriting the onload event on each loop, so the one that gets assigned the last will be the only one in the image. So your solution is the correct one - just remove the .onload event.
It's not entirely a joke: https://en.m.wikipedia.org/wiki/Vanilla_software Sounds better than 'plain javascript' IMO.
I have now commented the onload out, but does not change things postively EDIT: currently trying zack's suggestion.
Gave it a go, nicely put together.
Just went on this and got involved in a game of everyone trying to jump on someone's cursor, and him or her running away and getting chased by everyone. Was really fun!
Woosh
Wow, this is very usefull. Although hard to understand at this point. I dont have clear questions yet, have to do some reading first haha. Thank you very much! Will report back maybe tonight - maybe in the beginning of next week, if you dont mind.
In all honestly do what you think you'll enjoy most. That's the easiest answer. Follow that line of thinking and you know one thing is certain: you'll enjoy it.
Sure thing - let me know if you have any questions (I tried to make my writing a bit more clear above).
Actually I just tried the code again and now it works :) What I meant with var oldArray = [1,2,3,4,5,6,7,8,9,10]; var newArray = []; newArray = oldArray.filter(function(x) { return x&lt;=5; }); And function bouncer(arr) { var newArr=[]; newArr=arr.filter(function (x) { return x==false; }); return newArr; } was: the only difference btw. those 2 is that one is suppose to return only the not falsey elements and the other ones bigger than 5. Why do I need to return newArr in the "falsey code" but don't need to return in the other one?
Because the *.then()* method creates a closure, and *this* inside *.then()* has a different scope assigned to it. Read [this](http://stackoverflow.com/questions/111102/how-do-javascript-closures-work).
Are people still starting new projects with Backbone?
I really like Flow and how it handles type inference - and was betting on it over TypeScript initially. However, they released it JUST as ES6-via-babel hit the zeitgeist and I feel like it didn't really catch up/recover from it: commits were slowing down towards the end of the year, and the open issues kept rising. The core is written in oCaml so there are obviously going to be less contributers - though it seems like they are picking up steam again now. I'm doing a lot of React Native, so it's there "by default" and I don't have to add more stuff into my build process. The lazy part of me hopes that 2016 is Flow's year... but I'm waiting to see before I go all-in. 
The code in the then block is in a different scope, var self = this at the top of the function declaration, then replace this with self is how I've always handled it before and it seems like the standard way to handle it from what I've seen. I know they changed some stuff about that with es6 but I can't remember exactly what it was
The new lambda experssion (*arrow function*) syntax captures the scope of it's enclosing scope. Meaning function F() { this.age = 10; setInterval(() =&gt; { this.age++; }, 1000); }; will increment the age variable declared in the function. [Source](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
Love it - already been using it for internal apps at work (in Chrome) There is .indexOf() on an array too, but the code is far uglier: if (!!~array.indexOf(whatToFind)) { // found } else { // not found } 
Right, for existing applications a re-write would be questionable. I just can't imagine someone reaching for Backbone when starting a new project in 2016 with all the alternatives available.
You should run your code. It won't do what you think. Be careful not to confuse "scope" and "`this` binding". They're different things. EDIT: OP has since updated their code.
How are you testing it? I don't think cookies work when you open it as a file, try with a local server.
&gt; I actually took the code from MDN But you changed it. Specifically, you changed `this.age = ...;` to `let age = ...;` EDIT: To clarify, *all* JavaScript functions capture their enclosing scope. But function declarations and expressions would also *always* define their own local "this" value, thus masking the outer scope's "this". Arrow functions, on the other hand, won't define their own local "this", leaving them free to resolve "this" from the outer scope.
Exactly the problem. He states it's used in a class method. Thus, `this` should refer to the instance. 
You're right, I'll edit my code to be correct.
FYI that is explicitly against YouTube's policies, on account that their business model hinges on selling a/v ads.
"Universal"? 
Yes, I'm also recommending a message queue or even a db for very large things like that. Very nice numbers on this though! Thanks for that! Large pages can be quite a challenge, there is a lot of error handling to be done.
Sure, but I also wanted experimented developers advices on React and Angular, what's the most comfortable to use and which one is the most valuable in a resume. :) but if I follow my instinct, I would go angular 2.0. But that's my google-fanboy side speaking I guess ahaha
That is in the readme right below the examples. [Comparison to other libraries](https://github.com/taylorhakes/painless#compared-to-other-frameworks-) If I missed anything you would like to know, please let me know. I am very interested in improving documentation
My bad! I read that as how Painless compares to others rather than "This is is what Painless is trying to fix"
You could setup a webpack environment where you have an entry point for shared common code and then each tenant could have their own specific entry for custom code. A brief example: https://gist.github.com/anonymous/353a8bfb9996d6d3cbac also see: http://webpack.github.io/docs/multiple-entry-points.html
I've started using it for my toy projects and it's great! It provides a fast feedback loop especially when you integrate it with an IDE. Webstorm has built in support and Atom has some decent plugins too. It catches bugs that you'd just not think of even with a full suite of unit tests. It also helps you think about the code you're writing as you specify return types in functions and parameter types. It's surprising how lazy you get with dynamically typed languages. Chances are high you'll already be using Babel for some part of your build process so one more plugin isn't too much of a compromise. Anything that helps reduce bugs and increase quality without too much effort is pretty much worth doing. 
Yeah, despite how much I try to put something together with the Webpack docs, I always end up copying other people's magical config incantations. I still don't understand if the Webpack server reads the rest of the config file. I always seem to have to duplicate incantations for it specifically.
I tried to add it to an existing project. You can opt into typing individual files, so it seems like a great way to start using in an existing codebase. I had to abandon Flow though because I was using several ES6 features that aren't supported by Flow's parser yet. * [Destructuring with default parameters](https://github.com/facebook/flow/issues/183) is missing. * [Annotating React 0.14 stateless components](https://github.com/facebook/flow/issues/1081) isn't fully supported. You can annotate the internals, but when you got to use `&lt;YourComponent prop={whatever}/&gt;` it doesn't make the connection and assumes the component accepts all props of all types. There was at least another issue with array destructuring, but it looks like that's been resolved.
Backbone.js gets some undeserved hate from fans of other frameworks, but Marionette.js is a huge improvement over stock Backbone and makes it a lot easier by removing all the requisite Backbone boilerplate. Obviously it's not the hot choice nowadays, but I've always admired Backbone.js. It's a good and well-tested library, the source is dead simple to grok, and both the interoperability and modularity of the different pieces work really well.
I'm calling click-bait. As an actual JS developer, yes the market is crying out for us. I know for a fact that the market isn't crying out for people with 0 professional experience. There _are_ companies who will take on completely new people, but I bet that very few who contacted you would have. You mislead (but didn't lie) by putting things into "experience". Recruiters read it as "professional experience" not "backyard experience". Finally, you mislead us at the end when you talk about contracting. These contracts _don't_ "ALWAYS renew". Especially if you're shit. They pay well because they expect to treat you like shit and for you to bust your ass for them. 6-figures in a contract job (in a 1st world country) is far less impressive than a fulltime job. You should probably have made that clear from the start. 
Came here to post this. Maybe OP is using an older version of Babel?
Yep, absolutely. Paired with Marionette, it's really quite pleasant. Many criticisms of Backbone came from people using Backbone and wrapping it with spaghetti. Using Marionette really brings Backbone up to par with the new generation. I've never understood the mindset that new things somehow make old things worse. I think that's a pretty damn debunked myth. Yes, you have new options, with new features, but there isn't a web application you could write in React/Angular that isn't possible in Marionette. You can make web components, make use of modules (AMD/CommonJS), make them properly isolated and testable, handle state properly, make it perform well, do server-side rendering, etc. Anyway - many of these things are developer problems, not tooling problems. They can be done properly with Knockout, EmberJS, and even vanilla javascript. 1. It's a stable API. It's so stable, I'd venture to say it's *done*. That's not a bad thing. That's an important consideration when starting a new project - you're going to be building a foundation, so why try to build it on hot lava? Backbone and Marionette are still actively developed, bug fixes, etc. They're just not yanking the carpet out from under devlepers on every major release anymore. 1. You don't need to subvert behaviors just to do things that are already familiar. Notice all of these articles about using canvas, d3, jquery, datatables, etc, with Angular/React? They (and many other libraries) were built to directly manipulate the DOM, which is discouraged in the new generation of frameworks. IoC and declarative programming is good, except when it's not. The effort goes both ways. 1. You don't *need* to transpile (JSX, TypeScript, etc). Many would say that's a trivial thing, since most projects use a build system anyway (I certainly do for modules and CSS). But it's one thing to pretend you're writing javascript when you're actually authoring non-standard HTML, non-standard JavaScript, automatically shimming tons of bloated code just to use new, unratified syntax. Don't get me wrong - I'm excited about the changes coming to JavaScript, but I'm not a big fan of shims. Let's not pretend Backbone/Marionette is bad. It's just not shiny. The only objective thing wrong with Backbone/Marionette is that the communities have died down a lot. I think that's more a symptom of #1 (it's *done* and *stable*) than the misconception that it's dead.
Thanks, I think this is it. I had assumed automatic semicolon insertion would be used here -- but it seems to only do that if it encounters a parse error. Because the code doesn't bring up a syntax error, it doesn't include a semicolon and the entire thing dies in a fire.
Uh... maybe I'm missing something, but why is this on /r/*javascript*???
Yes, but usually when you develop a library, you want to make it available from Npm and Bower and just using `npm version` or `bower version` is not enough. Basically the problems appear when you have to deal with git tags and build processes and you want to unify the whole process IMHO 
This excellent YouTube video "Semicolons cannot save you!" from FunFunFunction @MPJme explains the very few existing traps when treading on the no-semicolon path: https://Medium.com/humans-create-software/semicolons-cannot-save-you-bf991756174e 
I would agree with this. I think by far the biggest strength of Backbone and Marionette is that both are simple, straightforward, and predictable. Even more than that, you can at any time step straight into their code and see exactly what's happening. Even Epoxy, which does a little bit of magic internally to turn your binding commands into lookup functions, is still _mostly_ straightforward logic. For that matter, Ampersand-State is a fantastic upgrade to Backbone.Model. While I like the change in mindset that React leads you towards, and I think the overall mental model becomes more straightforward, the fact that the guts of React are effectively a black box and errors have big stack traces full of React code makes it somewhat more difficult to debug. I see a lot of potential overall benefits in developer productivity from the whole React/Redux/ES6/Webpack stack - explicit dataflow, time travel debugging, hot module reloading, and so on - but I'm still trying to sort out whether all the complexity of the tooling is going to outweigh the benefits. Overall, though, Backbone certainly shouldn't just be dismissed at this point. Stable API, large ecosystem, and simple code and toolchain should make it still a viable option.
Apart from the Big Three engines (V8, xMonkey and Chakra), there's also [Duktape](http://duktape.org/)
You have a good bit more work to do, mainly because it looks like you haven't really thought through what you're trying to do. So for starters, you've created a function on line one called `check()` which you are trying to call with an inline `onClick` but you should instead call that in your javascript. From there you have a bunch of variables that you use to hold data - not bad. But then you check that data with a `func.value` but you have no variable called `func`. `func` isn't really clear so let's change that to be what we're actually checking which is a `selectList`. So let's change the select list's ID and then make a variable that captures its value. Now you can use your if statements to check the selectlist's value. But when we look at what the if statements are doing, they're just collecting the inputs' value and doing nothing with it. So how are we ever supposed to check those values against what the user inputted? This should all be good insight for you to keep going. Just relax and really think through what you're doing. Here's what I've changed for you so far. https://jsfiddle.net/thatgibbyguy/ppmy9yt7/5/
Yes, I actually do like this. I was not being sarcastic.
This actually looks really interesting; it seems to address some pain points I've been having with mocha, and at least according to the documentation, solves some issues I had when I tried Ava. Looks solid, and I'll be giving it a shot when I get a chance.
Hm. I would be interested in the Google search portion of this, however AFAIK, google does not exactly like automated google searches, and its search API has been deprecated for years, with a promise to stop fully in 2016 january...so what is up with this exactly?