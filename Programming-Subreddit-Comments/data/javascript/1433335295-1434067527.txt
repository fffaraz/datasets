Not a blog, but I listen to [javascript jabber](http://devchat.tv/js-jabber/) on my way to/from work all the time. They talk about a lot of the popular libraries/methodologies/frameworks that are around as well as have pretty well known guests from the coding world talk about different topics. It's a great place to learn about things that could expand your skill set.
I just did it. BTW: `7b - 5a = 7 * 2 - 5 * 1 = 9`. You have to be very smart to understand the extreme logic.
Ahh, we are talking about inheritance, not about general OOP in JS. My fault, you are totally right.
I like Dev Tips Daily...it's a daily email that just has one small animated dev tip per day. https://umaar.com/dev-tips/ . Something about getting just one nugget daily works really well for me. Bite-sized, grokkable.
Everytime someone asks this, we realise that * Webstorm is the best IDE for JavaScript if you like IDEs * Sublime, but possibly also Atom or Notepad++ are the best text editors if you don't like IDEs. *edit: and of course Vim or Emacs if you're into hardcore editors*
I don't know if this is 'correct way', but a quick test in nodeJS shows it works. // Assuming code in question is in aa.js var hades = require("./aa.js"); hades["hello"] = function() { console.log ("Hello! new method"); }; hades.hello(); 
Yeah I really need a coffee this morning I can't spell to save my life. Alright thanks for that. About accessing the parsed string in the enterDigits method? If if I ran a test that was like this.enterDigit(one). How do I access the literal in that method and convert/return the value using digits object? Sorry for the straight forward questions, but having at least one quote on quote example that is logical is going to help me flesh out the rest mostly by myself.
 function CalculatorService() { var digits = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7 , eight: 8 , nine: 9 }; this.enterDigit = function(stringDigit) { return digits[stringDigit]; }; } var calc = new CalculatorService(); calc.enterDigit('six'); // 6 
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
I would rephrase your question as 'What benefits does it bring?' * Code less. In the README.md example, I wrote an input file of 16 lines, and got two necessary files with a sum of around 30. * It forces the developer to use the promise returned from `$.ajax` instead of `success`, `error` and `complete` properties. This is better because promises make code more readable. * When you change something (ie: the url), you only have to modify one codebase. This is also true because of the previous point, ajax calls are meant to be defined once client side. * It automatically maps parameters of `fn` that are in the url (like id in `/find/:id`) to `req.params`. And, the parameters of `fn`that are not in the url are mapped to `req.body`. No confusion between `req.params` and `req.body`. And because of this, client ajax methods can be called with simple code, for example: `ajax.find(1, false)` even if the first parameter is a url parameter, and the other is mapped to `data`.
For large apps: Scala. For small apps and quick/simple scripts: Javascript For fun: Haskell 
http://raganwald.com Blog of the author of JavaScript allonge
https://github.com/josdejong/jsoneditor
I read http://kukuruku.co/ from time to time - mostly because a lot of their articles are usually on HN frontpage. They have a JavaScript hub. 
Don't ask me why you'd want to do it but you can
and it's probably worth donating to sublime, atom or notepad++ projects too if you use them much... they're written by people too, with families, rent, grocery bills, medical/insurance bills... who just happen to wrate the best effing editors available and offer them for free
&gt;Depending on use case of course. Absolutely. Do you want it to happen when the user stops scrolling/resizing? *Debounce* Do you want it to happen throughout the scrolling/resizing, but not hundreds of times a second? *Throttle* Do you want to let the user know that they are evil and then block their IP? *Denounce*
Benchmark can be seen on Twitter: https://twitter.com/trackira/status/606096634846380032
[**@trackira**](https://twitter.com/trackira/) &gt; [2015-06-03 13:54 UTC](https://twitter.com/trackira/status/606096634846380032) &gt; Trackira virtual DOM boilerplate \#GitHub https://github.com/trackira/trackira Faaster then \#reactjs \#javascript \#js \#html5 \#css3 [[Attached pic]](http://pbs.twimg.com/media/CGlJrUBUIAENTPQ.png) [[Imgur rehost]](http://i.imgur.com/0Qm5wLD.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
lol damn autocorrect :P
Generally, debounce is ideal if you want to just look at the 'ending' states of a repetitive event, not all the intermediaries. Ex, a debounced function on resize should evaluate whenever there's a pause / ending to the resizing. Throttle is pretty self explanatory, you want to look at the most recent results of the event, but no more than every 100/200ms etc, so that you evaluate on even the intermediate results as often as you can. 
I know Mithril is an MVC framework, but their [blog](http://lhorie.github.io/mithril-blog/) is excellent. There are JS idioms hidden in posts and it's very well written. 
It's not really heresy, but without plugin support it's not ready for me.
That's why the correct answer is not Webstorm, but IDEA.
How do you handle the model setup? Do you build external model classes? If so, how do you keep the data in sync?
What do you mean that writing complete nonsense code results in undefined behavior?! 
That strikes me as somewhat unusual, but if I were on a project where that was the official coding style, I'd do it. When you ask people to follow your project's coding conventions, sometimes you're expecting people to code in ways that are contrary to their personal preference. I can't very well demand that of others without being willing to do it myself.
$200 for an individual developer. Also, I have never seen any paid plugins...link?
Decent insight, bad memes.
www.html5rocks.com
Not quite what I was looking for- I need to visualize (not serialize) the data for use in the browser by an end user.
Nope. Its really one of a kind in terms of completeness. Everything else is more "build your own", and relies on external tools, which does work well for a lot of devs. But if you want a true IDE for JS, WebStorm is it. 
Blogs I like that I haven't seen here yet : * [http://perfectionkills.com/](http://perfectionkills.com/) * [http://webreflection.blogspot.fr/](http://webreflection.blogspot.fr/)
I flit between - webstorm 90% (work) - atom 8% (quick editing of non project files) - vim with js plugins 2% (general quick editing or ssh editing tool. Also being able to edit large files without having a stroke is nice)
I used them a lot before I learned how to use .bind and .apply. But honestly I pretty rarely use them now.
But I don't like how I have to put my seatbelt on **EVERYTIME** I get into my car. It's *sooooo annoying* I'll just pass. Chances are I won't ever need it, and I've never needed it before.
It is because you are submitting this form when pushing this button, read about event.preventDefault() to interrupt submitting form.
... Throw vim and emacs into that second bullet point and you'll be a OK in my book :)
Visual Studio Code
Vim is awesome. Really fast and easy to navigate once you get to know it, and it runs on the command line. I always program in vim in a tmux session in an ssh session to my server. I have `alias attach="ssh [mydomain] -t \"tmux attach -t $1\""` in my .zshrc, and have various tmux sessions named prog0, prog1, etc. This way, I can have multiple terminal windows open at the same time, with vim on my server in each on them. With i3wm as my window manager in Linux, this means that I can have many shells open on my server at once in different windows, neatly tiled and easily navigatable using the keyboard. Chromium generally goes on a separate monitor, or in a separate workspace if I'm on a laptop with only one screen. All in all, I'm able to never touch the mouse. With the vimium plugin to Chromium, this extends to the part where I test my web apps in a browser.
`this` attaches the method to that instance. `prototype` attaches the method to every instance of the object. If you just have a single instance it won't really matter, but if you have more than one instance, using `this` means you have an individual copy of the method for every instance. This can result in pretty large performance hits if you run many instances of an object. Also if you are doing inheritance of object types (classes or whatever you want to call them in js), using `prototype` can make it a lot smoother.
http://www.zell-weekeat.com/ This guy has a lot of great articles on Susy.
Not using semicolons never bit me, so I really don't see the problem - it's just a personal preference. Of course you should always follow project's guidelines, but if you're the person who sets up guidelines or it's your personal project - I don't see a problem.
I've never tried emacs, but I'm willing to bet it would service me quite well.
I'm currently using Atom, which I like because I had been using Sublime Text and enjoyed it, but its development seemed stagnated. Atom being open source is a great benefit. It's not out yet, but I'm very much looking forward to trying out Nuclide (Facebook IDE): http://nuclide.io/ The reasons I'm looking forward to Nuclide are that I've been doing a lot of React work, and its integration with JSX, React, and React native should be very nice. I'm also very intrigued by having Flow integrated into an editor. I've been interested in that project, but I haven't been able to to integrate it into my current setup very well yet.
Re the vimium plugin, it just allows you to use your vim-fu to browse without a mouse. Its a great way to browse and much quicker, or at least feels quicker, when you're in the flow. Definitely recommended.
I happily paid the $70, not because I'm altruistic about helping developers, but to get rid of the nag popup on every 5th save. Well worth it.
It's not a blog per se, but I really enjoy the video tutorials over at [EggHead.io](https://egghead.io/)
JetBrains WebStorm - there is no substitute.
Depending on how much grasp you have on development and how much you like to code extra, which is not related to your actual work, I'd recommend you can even ditch IDE completely. First IDE alternative - * [Aptana Studio](http://www.aptana.com/) - Eclipse based, free and awesome * [Webstorm](https://www.jetbrains.com/webstorm/) - IntelliJ based, paid but great on features. But if you don't mind getting you hands dirty, I suggest use code editor and write lines of codes to automate every process. Choose code editors - * [Sublime Text](http://www.sublimetext.com/3) - My favourite and really rich on features. * [Brackets](http://brackets.io/) - Adobe's great offering, has a lots of plugins and cool features built-in like live reload, npm, git support etc. * [Visual Studio Code](https://code.visualstudio.com/) - Microsoft's entry in code editors, based on Electron on which Atom editor is based on. Currently bare bone, but get's a lots of work done. Once you're done choosing your text editor, get software ready. * Install [Node.js](https://nodejs.org/). You'll need it anyway, so go ahead. * Install [gulp](http://gulpjs.com/) (or grunt) from Node.js - **npm install -g gulp** * Install [Bower](http://bower.io/) from node.js - **npm install -g bower** Now, you need to know/ learn/ copy gulp commands. Npm and bower are easy for this case, all you need to know is how to install repository with it. I've included my starter package.json (used by npm to install file dependencies) and gulpfile.json (used by gulp to automate workflow) below - * [package.json](https://gist.github.com/bikasv/3ff429be1caa44d97889) * [gulpfile.js](https://gist.github.com/bikasv/19cdd15a727178be9366) Using these few lines of codes and a normal text editor you can beat best of IDE's, and at the same time you can have full control over your development. Personally, I never needed IDE for web development and it seems I won't be needing in near future as well.
Good article! There is, however, an issue with the property decorator as implemented once you create more than one `Person`: var me = new Person('Monty', 'Python'); // Set: name =&gt; Monty var you = new Person('Remo', 'Jansen'); // Set: name =&gt; Remo me.name; // Get: name =&gt; Remo Since you're storing the value gotten from the setter in a closure variable and the setter is going on the prototype, you've created a property which has its value shared across all instances. It's pretty easy to fix it: function logProperty(target: any, key: string): void { var newKey = `__logged${key}`; Object.defineProperty(target, newKey, { enumerable: false, configurable: false, writable: true, value: target[key] }); // property getter var getter = function () { var val = this[newKey]; console.log(`Get: ${key} =&gt; ${val}`); return val; }; // property setter var setter = function (newVal: any) { console.log(`Set: ${key} =&gt; ${newVal}`); this[newKey] = newVal; }; // Delete property. if (delete this[key]) { // Create new property with getter and setter Object.defineProperty(target, key, { get: getter, set: setter, enumerable: true, configurable: true }); } } Since `this` is the instance in setters and getters, we can set up another property to hold the actual value for each instance.
I think it is a great idea (I moved to writing all my OS projects in ES6). The important part I found is providing the released version in different formats (AMD, ES6, transpiled CommonJS, transpiled global) if you want to accommodate a larger target audience out of the box. Two helpful tools I would recommend: Browserify + Babel as UMD (`browserify src/index.js --standalone myname -t babelify --outfile dist/myname.js`) if your project does not have external dependencies or you want to include all dependencies in the build. StealJS which transpiles your project in all the above formats with the respective individual file structure while maintaining dependencies to other libraries (see http://stealjs.com/docs/StealJS.project-exporting.html).
I use the mouse to navigate the dev tools, but all other parts of web browsing is mouseless. I made a quick video of how I'm browsing with vimium: https://www.youtube.com/watch?v=MizMg1Vf7DA I use Dvorak. When I press `d`, which is where `h` usually is, all links get bubbles with characters over them. All the characters are on the home row, or equally accessible. As I type the characters in the bubbles, the bubble whose characters I pressed will be clicked. The keys n and t, in the location of l and k on a qwerty keyboard, scroll up and down. If I press `shift+D` instead of just `d`, I also get the bubbles, but whatever link I press will be opened in a new tab. Everything in the video, except for stopping the recording, was done with the keyboard, not letting my hands off the home row. EDIT: In case anyone's interested in a more extensive overview of my workflow, I made this video a while back as a part of a collaborative project among people in a community called nixers (http://nixers.net, or #nixers@irc.nixers.net in IRC): http://d.mort.coffee/img/workflow.webm --- I don't have autocomplete or analyzer support, as I've never felt the need for that, but I'm sure there are vim plugins for that.
This is an issue with the library or your code and does not have anything to do with javascript.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/laravel] [Need PhantomJS help to convert html to pdf : javascript - repost from /r/javascript](https://np.reddit.com/r/laravel/comments/38eh8z/need_phantomjs_help_to_convert_html_to_pdf/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Eric Elliott's stuff is good. Most of his posts are on [Medium](https://medium.com/@_ericelliott) but the best place to keep up with him is on Twitter.
I just wish Leo Horie would update it more, or did he move it to another URL?
Might wanna give [this](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch4.md) a read. I also had a similar misconception.
Not quite sure what you mean by 'visualize'. I use this little function to format large JSON objects so they are read more easily: function json(obj) { var j = JSON.stringify(obj, undefined, '\t'); if(j) return j.replace(/\n/g, '\r\n'); else return ''; } instead of one long string, it puts in line breaks and tabs according to the depth and structure of the object.
I would stick to wkhtml since its entire purpose is rendering, and also shares the webkit base with phantomjs. Try and play arround with the viewport, image and resolution size parameters in wkhtml http://wkhtmltopdf.org/usage/wkhtmltopdf.txt. Also check what your pages look like in the print (vs "screen") css media type. 
Only because the assignment didn't tell me to but should I be making a global variable? Seems as though just having that method you wrote for digits doesn't return the value into the getDisplay function so the test fails. Here's how I wrote the test file (after using the method you showed me) var service; beforeEach(function () { service = new CalculatorService(); }); it('should display 0 when loaded', function () { expect(service.getDisplay()).toEqual('0'); }); it('Should add 6 to result', function () { expect(service.enterDigit('six')); }); it('should display 6 when loaded', function () { expect(service.getDisplay()).toEqual('6'); }); Obviously the value is hardwired to 0 in the getDisplay method, but I don't know what to change the return to. 
I would suggest using both AWS S3 and AWS CloudFront, since S3 alone does not provide a fast worldwide distribution of your assets. In most frameworks you can easily switch btw the two, if you want to avoid caching problems in your local environment.
See: http://www.w3schools.com/css/css_mediatypes.asp Essentially css can be attached to a specific type of media, default is screens (i.e. what we see on computer screens via a browser). Then there is print, which is a style browsers will apply when you want to print a page, to save ink, fit to the page size, etc. This may / may not be affecting how your charts look in wkhtml, test it with the page in your browser, go into print preview and see what the charts look like. I am pretty sure wkhtml uses screen, so it shouldn't be an issue, but worth exploring. 
You shouldn't make a global variable, you should make a private member of your object on which to store the display state. Above I was just demonstrating the correct syntax for writing a method and accessing an object with a variable. function CalculatorService() { var display = ''; var digits = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7 , eight: 8 , nine: 9, zero: 0 }; this.enterDigit = function(stringDigit) { display += digits[stringDigit]; }; this.getDisplay = function() { return display; } } var calc = new CalculatorService(); calc.enterDigit('one'); calc.enterDigit('three'); calc.enterDigit('zero'); calc.getDisplay(); // 130 Also, you can't just use `expect` in a Jasmine test by itself.
He may have been referring to the 3rd parameter, `space`, which allows you to apply whitespace formatting to the result. It's not fancy, but it gets the job done and it's native functionality. 
cloudfront sounds like a great product for what it's designed for. in my particular case it doesn't make a huge difference. the vast majority of our users are located in one of three east coast U.S. cities (nyc, boston, washington d.c.) and our amazon datacenter is in Virginia so the S3 servers are already geolocated in the correct zone for our use case. 
A quick look through comp.lang.javascript seems to indicate that he believes that mess to be flawless.
Webstoooooooooooorm forever
The types (and the existence of the undefined type): typeof undefined; // "undefined" typeof null; // "object" typeof []; // "object" The lack of head spread arguments (even in ES6): function foo(...head, tail) {} 
You either love vim or YOU'RE WRONG
The polling example is *horrible*. You're checking offsetWidth on an interval, implying that the DOM is changing at the same time - you've just successfully automated layout thrashing. Also, polling is always a hack around not having a proper interface. If you're polling something caused by your own code, you're doing it wrong.
The annotations are recent, so that's pretty much what this is.
Great article. The first time I read it I thought that these functions couldn't possibly be essential - helpful maybe, but not necessary - but then I wrote what I thought was a simple function, and I learned otherwise. The idea was to, given a list of numbers, return the sum, and I just couldn't get it to work. I am 100% certain I had jQuery installed, I checked and triple-checked. I even had four different plugins. But it wouldn't work. On a whim, I remembered these "essential" functions, copy-pasted them in, and voila, success.
i love that my phone autoincorrected me twice in this thread and I received 2 unique jokes about. Bravo guys you are on point today. :)
What do you want to do with js? The answer to that question should give you a good "compass setting." One thing I feel that is seriously lacking on Codecademy, and something that I feel is extremely powerful, is DOM manipulation with js. Codecademy gets in to it a little bit with jQuery, but it's like they don't even touch on it with just pure js. Here's something that kind of blows my mind: You can write like 99% of an entire website with just js code. Js can modify both html and CSS. You can use it to create/remove html elements and change styling and you can use functions to create animations. Reversing strings and crunching numbers is cool, but js offers so much more than that. I guess, specifically, I would suggest looking in to document.getElementsByClassName("className")[0]; document.getElementById("elementId"); document.getElementsByTagName("tagName")[0]; Then sticking stuff like this on document.getElementsByTagName("body")[0].innerHTML = " "; document.getElementsByTagName("body")[0].style.background = " "; And look in to timing functions like var int = setInterval(function() {}, 1000); clearInterval(int); setTimeout(function() {}, 1000); Also, adding event listeners like document.getElementsByTagName("div")[0].addEventListener("mouseover", function() {alert("Your mouse is currently over the first div in your document")}); I feel like that's powerful js stuff that Codecademy really doesn't touch on. Maybe you were already aware of all of it, and if you were, I apologize.
Bummer. Only for the ES6 promises and not for $q in angular :( Looks super sweet though.
While I think code academy is a good way to "jump in" and figure out whether you even enjoy programming or not, its far from a good way to learn how to actually program. I've referred a few people to https://github.com/getify/You-Dont-Know-JS and they have done well with it, and its free and open source, so give it a go. 
Something funny I wanted to share - you can be so fast with vim that you can get tendinitis. Happened to me :D
It seems stuff like Codecademy focuses way too much on the `how` instead of the `why`. Set a goal to manipulate the DOM (build a web page out of it) – basically create HTML/inline CSS in the DOM with things like `var someAwesomeDiv = document.createElement('div');` and `someAwesomeDiv.style.background = 'red';`. Good luck!
You could change the `getDisplay` method to this: this.getDisplay = function() { return display || '0'; } Now it will return `display` if `display` is a truthy value (i.e. not an empty string, because you've concatenated something to it) or the string`'0'` otherwise.
Definitely agree that it's not always under your control, I remember when we had to poll for hash change. But I would advocate going to great lengths to avoid polling, even forking a dependency if appropriate.
Codecademy basically lets you sit in the passenger side in a car but it makes you think you've driven the vehicle by the end. If you're up for it, I suggest trying to build a basic "To Do" app that emulates something like the one on http://todomvc.com/. It doesn't have to be nearly as complicated as their code, just get something that works. Or maybe make a sideshow that cycles through multiple images. If that's still outside of your scope, you may want to just go through some other courses, or perhaps read a beginner level book. "JavaScript and JQuery: Interactive Front-End Web Development" by Jon Duckett. I bought the book for my girlfriend who's currently learning development and I think it does a really good job of easing beginners into JavaScript. People at this subreddit love Douglas Crockford's "Javascript: The Good Parts", but I find that as someone who's really fresh has a hard time understanding the finer points of that book. I'd peg it as a medium level book once you already know a little about the language. Good luck!
~~I also recommend http://stackoverflow.com/questions/1357118/event-preventdefault-vs-return-false~~ This one is better http://stackoverflow.com/questions/18971284/event-preventdefault-vs-return-false-no-jquery
I agree on your second point but you're not always working with just your own code.
Could you elaborate a bit on why you would use both browserify and require.js in the same project? They seem to serve similar (but not totally overlapping) ends and I'm never sure when to pick one or the other.
I see that it doesn't have any Ember plugins, but it does have an Ember library. Go to: File --&gt; Languages &amp; Frameworks --&gt; JavaScript --&gt; Libraries Then click on the "Download..." button. Click on the dropdown box and select "Typescript community stubs". Scroll down to "ember" and click on "Download and Install". That should definitely help if you are not using it already.
Nice. Can you explain the motivation - what is the (now or future) benefit of this compared to Matt-Esch/virtual-dom for instance? Thanks.
[This goes for all other JS too](http://nodejsreactions.tumblr.com/post/79877244605/using-an-ide-to-write-node)
I think it's how i'm declaring the enterDigit in Jasmine. Because this is how I wrote it out. it('Should add 6 to result', function () { expect(service.enterDigit('six')).toEqual('6'); }); But i'm getting the impression thats not how you ensure the execution of the method, causing my problem of the number not adding to the display variable..
Yes, become an open source developer and make something popular. Then you get it for free! :D
That Jasmine statement is saying that you expect the `return` value of `enterDigit` to be `'6'`, but your `enterDigit` method has no `return` statement, so it returns `undefined`. If you want it to work that way, you could write `enterDigit` like this: this.enterDigit = function(stringDigit) { display += digits[stringDigit]; return this.getDisplay(); }; Now `enterDigit` adds the passed-in digit to `display` and then returns the display value (from `getDisplay`).
Yes, I guess that would be a problem. 
try using the wkhtml params to render a high resolution of the page, possibly some responsive sizing is causing it to maintain aspect ratio ? 
Thanks very much for all the responses everyone! Very helpful, I'll definitely stick with ES6.
Do u know if this includes any Ember CLI or Ember data support? Currently I'm using Atom as my primary editor. I would like to use a more full featured IDE.
Html and css were the easiest languages I learnt
Pretty sure it wasn't vim that gave you tendonitis.
You need a backend to do this stuff.
Javascript is fairly easy so far, but html and css just slip my grip on learning it. I don't know what it is about them.
Looks nice, but i still feel that it hasn't got all the features i require on my forms. Lately i've been dealing with forms that have quite a lot of if/else things about them that make it very hard to use these kinds of things, whilst still wanting to keep form validation going. Still, having most logic back in the controller now instead of in the view is a good thing. I'll see if i can use it in my next project
That seems incorrect, if you put a semicolon where it shouldn't go, that could cause problems. It could also be more diffucult to debug than errors caused by a missing semicolon. To me the problem with semicolons is the time people waste obsessing over them. It's extremely pedantic when the code would run just as well without semicolons. I've done plenty of programming in languages that require semicolons, and I'm very happy that javascript does not require them, it's one less thing to slow me down, and my coding style never leads to problems caused by omitted semicolons and it is still very easy to read. 
Have you looked into using canvas? Very minimal HTML just to set up the canvas in the page then code everything else to render in that canvas. No HTML or CSS fuss around what you code.
I doubt it. I think PDFCrowd is using wkhtmltopdf also and when I go through their system with similar settings it turn out fine. These are the settings 'options' =&gt; array( //'page-size' =&gt; 'a4', 'margin-top' =&gt; '0', 'margin-right' =&gt; '0', 'margin-bottom' =&gt; '0', 'margin-left' =&gt; '0', 'footer-right' =&gt; '', 'footer-font-size' =&gt; 9, 'cookie' =&gt; ['print' =&gt; 'somecookievalue'], // 'dpi' =&gt; 288, 'zoom' =&gt; 0.78125, //'viewport-size' =&gt; '1280x1024', //'orientation' =&gt; 'Landscape', 'page-height' =&gt; '172mm', 'page-width' =&gt; '350mm' )
It is maybe because html and css arent programming languages
It's typical to wrap an IIFE in parentheses so this does not look out of the ordinary. Look closer and those parentheses, instead of being a mere statement wrapper, are actually invoking the first function.
I did both codeacademy and treehouse classes. I REALLY recommend Treehouse - good amount of theory &amp; practical lessons &amp; projects along the way. I did their front end dev track (html/css/javascript/jquery/ajax/api's) and am now working on a few side projects with a LOT more confidence. I'm a data scientist as my day job, so I use javascript mainly for data cleansing &amp; d3, but I think the class would be helpful for anyone trying to work on a front end project.
I'm kind of in the same spot. However i chose Grunt instead of Gulp because it was a while ago and Gulp didn't have many plugins yet. I like Gulp and i see why one would use browserify. I'm currently looking how i could get rid of bower (reduce installing time), and have some templating module (or something) too to easily bootstrap new apps and components. It seems there is never a one-to-rule-them-all solution and often it still requires some setting up, especially behind corporate firewall. One thing i'm also looking into is if i should switch to typescript. Mostly because it allows me to write better code that has less errors and is a bit better implemented then many linting solutions (which still don't catch everything). Currently i'm satisfied with my Grunt solution which is able to run a backend, mock, use socket.io, lint, concat, do sass and bootstrap parts, but its a hassle to manage files (which browserify could replace), slow (live reloading takes about 5 seconds to kick in) and more. But i know i can do better. I think it depends a lot on when you started with some kind of framework and what you needed it for, but currently it seems that Gulp is gaining ground (and next version of Grunt isn't going well), sass finally has dumped the Ruby requirement and other tools might ease it too. Unfortunately bootstrapping apps is still quite a hassle and installing a new project still requires some work and i'd like it to automate even further by installing node and git on Windows automatically as well.
Eclipse. Eclipse for everything.
http://www.scotch.io
To be fair it's only v. 0.3 but I'm really digging it. It's perfect for this backend developer pretending he knows Javascript well enough to pull out a Meteor app.
Yeah i figured. Would be nice to have some kind of extention for this as well. Batarang and ng-inspector are nice, but still don't have lots of support for promises (yet)
Seems like a reasonable pricing scheme to me. The alternative would be a monolithic IDE at a significantly higher price point. It's nothing like DLC, it's multiple different products. I am very happy with WebStorm and haven't needed the others.
But they kind of are because you're using hundreds of different key combinations in place of the mouse.
My experience learning on codeacademy is similar to yours - it didn't teach how to think and problem solve like a programmer (at least for me). If you feel like you can't make up and solve your own Javascript challenges at this point, try reading and doing the exercises in Eloquent Javascript - it's free. Have an editor open to write code with (I just had jsbin open) http://eloquentjavascript.net/
Ember CLI is just a command you run on the command line, no? There is a terminal pane in Webstorm so I'm sure you could use it for Ember CLI.
nano always getting left out
I love Sublime Text.... but not $70 love. I'd probably buy a license if it were under $30. I can deal with the nag you can hit escape out of every few hours.
I also use netbeans. The most important feature for me is to be able to run the debugger directly where I type my code. I am also writing Java code so I can keep the same IDE for everything.
&gt; key combinations You must be thinking of emacs. Typing vim commands is exactly like typing text. Sure you wind up using the mouse very little (if at all) but I'm not sure that's worse for you, or everybody'd be getting tendonitis in their left hands all the time. 
[Ed is the standard text editor.](http://www.gnu.org/fun/jokes/ed-msg.txt)
Done in one.
AFAIK, webpack turns *everything* into JavaScript, inlining css, images, fonts... If you want output other than JS, you need to use something else. And if I've completely missed the options for using webpack to do other things, please, someone, light the way.
Thanks for your idea.I will try it later.
Am I the only one who read this and thought, "tough shit"? I mean, unless you're just doing node stuff for back end /IoT things, the technologies are inextricably linked. Html/CSS abstractions can only go so far from the vanilla form of their languages.
I wish more devs understood this, but sadly they don't. More than almost anything else I consider a developer to be a "professional" if they understand that the code they write needs to be understandable and maintainable long-term. How they write comments... or indeed if they do at all... is one of the best indicators of this (the other being whether they write the simplest code possible that accomplishes a given task or whether they always build in more complexity than is necessary in the name of "architecture" and "flexibility"). I've been getting paid to develop software for around 25 years and I've seen how it goes when you do it wrong and also how it goes when you do it right. Trust me folks: do it right! 
I love cloud9 both pay version and self hosted. 
$200 to start for a personal license, or $99 if you wait for one of the regular sales. Frankly it's easily worth every cent.
Webstorm, but be prepared to spend a lot of time getting used to it if you're coming from another editor.
This is only for native es6 promises, and presumably relies on some internal state for inspections. Bluebird represents promise state in an entirely different fashion, and thus isn't compatible (it's already possible to [inspect Bluebird promises](https://github.com/petkaantonov/bluebird/blob/master/API.md#synchronous-inspection) as well). 
The combination of typing quickly + almost no interruptions of the workflow, because of the awesome vim keybindings, is what led to the problem. But thank you for your input, all seeing doctor.
&gt; Fuck wkhtml, its weak compared to PhantomJS So much this, thank you
Pick up the latest Smashing Book. Technical skills are important, but you will also require an understanding of design and development theory.
If you're typing constantly without breaks (were you a stenographer?) then it really doesn't matter what editor you're using.
And in case someone wonder why it seems that there is no benchmark for Trackira, has many reasons. First off, I don't like to show to others that I'm better or worse then them. And Trackira is also a boilerplate, and in the end it will become what you you want it to be. Differently from the out-of-the-box solution it is now. But locale I'm running benchmarks, and I posted some on Twitter. The fact is that Trackira is the fastest virtual DOM solution if you don't count with Snabbdom and CitoJS. This solutions don't threat attributes / properties correctly etc, and other things. IF this has been corrected, Trackira would been equal. However. At some points - basicly rendring and patching - Trackira shows a better performance then this two mentioned virtual doms.
Try doing codewars or other katas and posting them on stackoverflow code review (or here). You just need to try, get feedback, try again, etc... It takes a long time to learn how to program so just keep at it. The good news is that once you know how to program, picking up new languages is easy.
If vim improves my workflow and leads to longer time spent on the computer it matters. You should have just asked me to elaborate, not sling some passive-aggressive shit.
I use and love WebStorm, however have to give credit to Visual Studio Community edition, not that I've used it for JS myself, but was impressed that the Ionic framework guys said that "...it’s quickly becoming our preferred Ionic development environment." http://blog.ionic.io/announcing-ionic-templates-for-visual-studio/ And seeing as I do most JS in TypeScript now you would expect VisualStudio to have top support for it being a MS project.
Very good video, indeed. His website for his promise library is also a very good read. https://www.promisejs.org/ Correct me if I'm wrong, but it seems tj's co.js (now, in 2015) seems to work very similarly to how he's described his own code here in this video from 2013. 
Why did anyone think for a second this would work with non-native promises?
Amen Brotha! I'm not quite up to 25 years... but close... But yeah... I've worked in places where they force programmers to comment the shit out of code. The problem there was the comments were mostly just a lot of useless clutter. The second problem was, the comments weren't ever updated when the code was updated, so in many cases, the comments didn't make any sense. I've worked in places where NO comments were allowed. ZERO. Zip. Zilch. That encouraged nice clean, readable code, BUT the problem there was the WHY was lost. You'd run into a line like quantisMega = 6; And everyone who looked at it would say WTF? and waste lots of time figuring out what it was for, what it did, and why it needed to be 6 right there at that point in the code. &gt;whether they always build in more complexity than is necessary in the name of "architecture" and "flexibility" Yikes. I could rant about this for DAYS. Some of the places I've worked have taken "architecture" and "flexibility" to comically absurd levels. The problem here is it takes something that should be simple and turns it into overly engineered and complex garbage.
Well, I like to think of it this way: * HTML is a language made for adding semantics to information * CSS is a language made for describing how something should look * JS is a language made for interaction. So why use one language to do what another language was made for? I think in this case, what looks offensive is document.getElementsByTagName("body")[0].style.background = " "; The best way to change styling with JavaScript is to adding or removing classes, not direct CSS manipulation. It makes changing style later on much easier and still lets you work in the right language for the right job.
You mean you only want to retrieve the elements that are set to hidden?
Using an IDE for javascript always felt weird to me. I tried using Visual Studio and Webstorm, and didn't like either. Once I found sublime, I've stuck with it. Tried atom, didn't like the blurry rendering and slow loading for larger files. Visual Studio Code is fairly promising, though. Being able to step through node applications is interesting, and running build commands (gulp) from the editor is nice.
My understanding (and this may be wrong, I haven't done the tests) is that DOM manipulation via javascript is not as performant as it could be. Repeatedly manipulating the DOM can cause performance problems. The argument I've heard is that React uses a 'virtual DOM'. It does all the hard work to the virtual DOM and when its ready to display, it moves the virtual DOM to the real browser DOM. This method is more performant than several other frameworks. But hey - I concede I might be wrong. EDIT: Again, I personally haven't done the tests, but [this guy seems to have.](https://www.codementor.io/reactjs/tutorial/reactjs-vs-angular-js-performance-comparison-knockout) Its from Jan 2015 too, so not too old.
Vs code isn't open sourced yet
Find a public API and start doing cool shit with it. Not Instagram our Google maps or Twitter, something basic. You'll solidify your ability to manipulate hashes/objects and arrays while also doing something very relevant (consuming and manipulating APIs.
If you got the best results in the "vdom-benchmark", it doesn't mean that your library is the fastest in real world scenarios. For example, this benchmark doesn't trigger deoptimizations if your api allows to create virtual dom nodes with different shapes. It is also important to look at gc pressure (I am using dbmonster benchmark for this). There also other things that important in real world scenarios, like Composite Components, scheduling, support for complex animation use cases, etc. 
I'm no expert, but here's my take: - html is the structure... the *what's in the document* - css is the look but can also add interaction/functionality with pseudo selectors like :hover, :active, etc (and css can do animations with transitions/transforms/@keyframes) - javascript is for data manipulation and complex interactivity (including animations/games) &gt; So why use one language to do what another language was made for? Because it's so much richer. Like you can style things (eg, complex animations) with js that you can't easily (or possibly at all) style with css. For example, how would you achieve random motion with css? And with html, js allows you to write much, much less... Arbitrary example, but why would I write out &lt;div&gt;Div Number&lt;/div&gt; 100 times when I could instead write for (var i = 1; i &lt; 101; i++) { document.getElementsByTagName("body")[0].innerHTML += "&lt;div&gt;" + i + "&lt;/div&gt;"; } &gt; I think in this case, what looks offensive is document.getElementsByTagName("body")[0].style.background = " "; If it's just an aesthetics thing... Here's what I do to condense: var x = document.getElementsByTagName("body")[0].style; and then x.height = "100px"; x.width = "100px"; x.background = "red"; Not too unruly, right? I don't know... &gt; The best way to change styling with JavaScript is to adding or removing classes, not direct CSS manipulation. It makes changing style later on much easier and still lets you work in the right language for the right job. I don't know... I feel like you can't do a lot of the advanced interactivity stuff this way. Like how would you make a game or complex animations based on user input without js? How could you have a person type in coordinates for a Scorched Earth type game missile launch without doing direct styling manipulations with js?
I know this things, and I only use benchmarks locale. I'm not aiming to be the fastest or best, just to give people a boilerplate where they can adjust and build from. And you have a point with what you say. I measured in a real world scenario with the CitoJS performance on some animation. 23 operations per loop on Chrome. The fastest one in vdom-benchmark. In that case Virtual DOM - who is 22% slower in benchmark was almost equal. Just now I'm re-doing some internal code to give it a "better flow".
If your pre-compiling your templates or serving them from a database there's no security/safety issue. If you're allowing templates to be embedded on your HTML or fetched by AJAX then you run into the normal set of issues where a template could be tampered (or intercepted respectively) by some malicious code and then your template engine will happily eval whatever was injected. If you template engine is eval'ing strings at runtime it opens up a wider attack surface than one that does not allow eval. But again, restricting evaluation to the server side and/or pre-compiling templates into functions that you run within the context of the binding data mitigates the safety issues. 
Thanks!
I just went back to Cloud9 and I'm loving it. The editor is pretty decent and even the free tier keeps a server running for you (for up to a week I believe), which is great for checking your frontend on multiple devices during the development stage.
Since you actually asked for feedback, I would personally try something along these lines: https://gist.github.com/anonymous/9898998fb4b44a0e6044 But more interesting than that, you may consider monitoring *directories* recursively instead of files. I'm not sure it applies to every filesystem (probably not), but at least on Linux with Ext4 partitions, whenever a file is changed, the mtime of its directory is updated as well. In this case there's no need to monitor files individually.
Did I fall asleep during the part where Async and Await were covered?
If you get IDEA Ultimate, you get access to all the plugins, JS/PHP/Python/Ruby. Havn't seen the C/C++ plugin drop yet, but crossing fingers. FYI, they fix bugs/add features to a shared code base between the plugins and the sub-project. Plugins (js) often get released in slower increments than the sub-project (webstorm); but it's like a week difference if you use the EAP builds. It's all the same editor, you're mainly paying for the plugins/support, or just Java. It has pretty phenomenal Java support; beats the pants off Eclipse 10 fold.
I would hope that you're not editing files on your server in production to begin with.
"Fuck it"
Hi! The library can make your browser reload right after you save the specified files within 1 second! I think it's enough for developers? Sorry if I misunderstood your point. Can you explain further? Thanks for the feedback!
Thanks for the feedback! Yes.. should turn off it on production server, otherwise it will keep sending ajax every 3 mins! 
No. All of us at Build were confused too. Here's the original video btw. http://channel9.msdn.com/Events/Build/2015/3-644
Check out Dashing D3: https://www.dashingd3js.com/
You should also check out [live-reload](https://www.npmjs.com/package/livereload), [browsersync](http://www.browsersync.io/), or [webpack-dev-server](https://github.com/webpack/webpack-dev-server). Live-reload and browsersync can easily be included with any task runner, and webpack-dev-server is fantastic when using webpack.
Simple, don't use inheritance in the first place.
+1 for webpack and **webpack-dev-server** here. In many situations, it can even hot reload your JS (updating the JS code without reloading the page). Bonus: it also works for CSS.
JS devs who use PHP in back-end? Is anyone so foolish?
Which browsers support ES6? Is this mainstream now?
I've delved into FP with JavaScript to a decent degree. I use higher order functions, currying, partials, understand the value of immutability and pure (side-effect free) functions. Spend a lot of time working with Lodash and have played around with [Ramda](http://ramdajs.com/0.14/index.html). Right now my biggest issue is seeing a problem in a functional way right off the bat - my brain wants to solve it the imperative way and I have to stop and really evaluate whether the problem is best solved in a functional way. To that end I'm wondering if Scala is "functional enough" to help me start thinking that way or if I'm going to be too tempted to fall back into imperative and rigidly OO styles when things need to move quickly, so I'm wondering if I should dive into a purely functional language first to force that way of thinking so that when I get to Scala it will be second nature. I've written just a few lines of Haskell and while some of the syntax is jarring I can see the value there.
awwww, thanks for linking to my project &lt;3
Inheritance makes things much harder to understand, you will lose the simple directional flow. What happens is that type Child calls into type Parent and it can call back into Child. To understand and debug Child you need to hold the Parent in your head at the same time. The deeper the inheritance, the more complicated it gets. Also the code is now split over multiple locations, which means jumping between contexts and everything involved in that context. When you modify Parent then you need to consider all possible Children of it, so that you won't break anything. Basically, I've been searching for years for a good example for inheritance - and I still haven't found one. (Other than some language limitations, e.g. Delphi). If you show the actual problem, I can probably show how to make it inheritanceless.
&gt; Right now my biggest issue is seeing a problem in a functional way right off the bat - my brain wants to solve it the imperative way and I have to stop and really evaluate whether the problem is best solved in a functional way. This is normal - it simply takes a while to rewire your brain and learn new patterns to do things. I think it's handy to be able to apply functional concepts to your production code as you go - for me that was the benefit Scala, but you're already using Javascript for the same purpose. Might as well dive straight into Haskell - it has a few escape hatches, but for the most part it forces you to do things properly. 
I'll just leave [it](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3) here.
&gt; Array.contains({elem}) It's "includes", unfortunately. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes It's not called "contains", because MooTools modified an object it didn't own.
no i am simply asking how to group the child class's methods under the same {} just like in the case of the parent class in the article you referenced. 
Oh man, I just started building a CMS with Angular yesterday and I wanted to implement some D3 graphs. I was just so confused as to where to start from. This thread is just what I need!
You say that inheritance is only useful for is-a relationships. I agree, but I find that happens pretty often in some domains. Less so in web development... Besides that, composition doesn't really solve the problem of holding many things in your head at once. Instead of superclasses you need to consider member objects. Instead of subclasses you need to consider consumers. In a language that lets you encapsulate members and protect them even from your descendants (or similarly in a language where you can't protect them from outsiders), there's not much of a difference to be had. Designing for inheritance is hard, but designing a good interface (not *Interface* in the Java sense) isn't that much easier.
Jerome Cukier has some very interesting posts about key concepts of D3, for example: http://www.jeromecukier.net/blog/2013/03/05/d3-tutorial-at-strata-redux/ The blog also contains more advanced topics for undertanding D3.js, such as: http://www.jeromecukier.net/blog/2015/05/19/you-may-not-need-d3/ And a useful cheat sheet: http://www.jeromecukier.net/wp-content/uploads/2012/10/d3-cheat-sheet.pdf 
It was contains in the demo at jsconf. 
Github Wiki is a great jumping off point and resource throughout your development https://github.com/mbostock/d3/wiki
yep, I use the tutorials https://github.com/mbostock/d3/wiki/Tutorials section as well
Do you mean this code was for that demo?
[Here is an example](https://github.com/bucaran/parsec) of generators/iterators in ES6 to make a full CLI parser.
##### Parsec is a hand-crafted CLI options parser using ES6 generators in ~150 LOC. &gt; Why another options CLI parser?. There are several options out there. There is yargs and commander (&gt; 1000 LOC) which are fun to use, but end up doing too much. &gt; There is also minimist and nopt, which are leaner and offer a more limited feature set, but I wasn't comfortable with their traditional design and large code base. I also found both slightly too verbose for my taste. &gt; I decided to write my own solution (though it wasn't the first time) using ES6. &gt; The end result is **~150** LOC and a readable code base. ./app --foo bar -t now -xzy Parsec.parse(process.argv) { "foo": "bar", "t": "now", "x": true, "z": true, "y": true } 
How about the documentation?
The jar file (twitvid-java 1.6.1) is no longer available.
Thank you, that is the kind of thing I was looking for!
I know how to do this in ASP.NET and PHP, but since JavaScript really piqued my interest, I wanted to see what the possibilities were with that first. The MEAN stack looks pretty promising: I'm already using Angular and MongoDB. Thanks for the info!
Yeah, I put that in the original post. It's a great site
One of the best paid resources IMO, only complaint I could see is that it's prob to fast and brief for absolute beginners.
Client project. I just fancy building my own stuff and I plan on selling it afterwards if it's comes off good.
https://egghead.io/technologies/d3 It's paid but for $25 to better your career, I'd say that's worth it. 
I just started using D3 and had been trying out several different instructive resources. I finally landed on "Interactive Data Visualization for the Web". It's free to read online. I followed the tutorials and am building a production-level app with it. I know it sounds like I work PR for this book, but this book was just really straightforward, thorough, and helpful. Highly recommended. Link below. http://chimera.labs.oreilly.com/books/1230000000345
Thank you, will do!
No debate, I 100% agree with you.
In case anyone comes back to read this, onprogress does not fire at all in &lt; IE9, we had to revert back to onreadystatechange &gt; 2
I use the free account for the SSH project. My server running my code. 
Just put this at the top of your JS to "fix" things: Array.prototype.contains = Array.prototype.includes; String.prototype.contains = String.prototype.includes;
Oh I will for sure, in fact once I actually migrate the code for use the DBID and such won't even be the same, I didn't think about the ToS before that, but there actually could be something like that in there so good idea. Also, you're idea completely works! It's SO much easier to do it that way also, I didn't realize that there was a white space as I haven't worked with much XML so it got rather confusing working with it while learning also how to iterate. Many many thanks, I spent so long scratching my head and all I needed was an outside look! (also, completely forgot about sticking a debugger in, but I will definitely do that with any other issues) A small question in case you see this, say I wanted to pull that for all of the children, would I make it where it would change the index number ( I think that's the term?) to entries[i].getElementsByTagName("record")[1].firstElementChild.textContent 
Wow, it sucks someone downvoted you. The project documentation looks awesome.
I am a fan of Sails.js which is a server side MVC framework for node, that uses express. Its documentation is good and it has its own ORM for database as well convenient rest blueprints for models. As far as being a full mvc framwork goes its pretty un-opinionated and lets you solve a number of problems a number of different ways.
Modifying built-ins is only okay for polyfilling. So, no, I certainly won't do that.
If you are making a game you should be using canvas and not using CSS. There are also many ways of doing animations in CSS now. You should rely on CSS and only use JS to fill holes in CSS's ability.
Express and Mongoose are pretty solid choices to build an REST api with mongodb connection. You could also take a look at: [meteor](https://www.meteor.com/)
I think we might be thinking about performance in 2 different ways. I'm comparing manipulating the DOM client side with a round trip to the server. In that context, client side DOM rendering is fast and you get functionality you just can't do otherwise (i.e. implementing drag and drop columns in a table was trivial in Ember). I do like what the React community has done and Ember's rip-off of their work is going to drop in a few weeks and I can't wait to see how much better our app is with it (the previously mentioned drag and drop had to be dropped itself with tables over 2k elements because of performance). But, the article that you linked to is not comparing drag-and-drop client-side vs server-side, it's comparing different strategies for manipulating the DOM client side. It also seems like he doesn't quite grok why React is so performant (that's cool, I don't either). Anyway, my point was really that, in a jQuery world, I'd agree that you shouldn't manipulate the DOM. But, for reasons of maintainability (how will you keep track of the state of your app if the DOM changes out from under you every time you hit the wire). With SPAs, on the other hand, you do have a maintainable way to manipulate the DOM client side. There are still rough edges to watch out for but moving from thin-client web apps to thick-client web apps enables all sorts of great features.
I started using d3 with this tutorial. There's definitely stuff you can skip if you already know js fundamentals, and it's a great resource for any level.
Udacity course on d3 anyone has experience with it looks spoon-fed-awesome.
Is `.remove` and `.replace` confirmed to work how it does in this library in the spec in reference to multiple matches in the array? Personally I think it might be a little inconsistent that `.remove` will remove the first instance and `.replace` will replace all instances.
&gt; If you are making a game you should be using canvas and not using CSS. Interesting. Why? I feel like there have to be some limitations... maybe not though. &gt; There are also many ways of doing animations in CSS now. You should rely on CSS and only use JS to fill holes in CSS's ability. Yep and yep (well, *pretty* much agree on the second yep; I'm no expert though).
I wasn't invited to their party.
So, I actually misread the original comment as "manipulating" the DOM rather than just styling. For styling, I agree that you should be using css or one of its children. However, I have found it useful to set the width on elements at runtime when you can't know what their width should be a-priori. I would not, however, recommend this in the general case.
Use a triggerwarning FFS! I just had a really bad flashback just now. Poor souls doing PHP *and liking it*.
I liked grunt having its own "run" window pinned to the bottom of the IDE (I usually kept version control open bottom left and terminal / grunt on the bottom right). The change was for consistency with the Gulp integration though so the reasoning behind it makes sense for those who use both. 
Netflix released a really nice Ember AddOn for D3. You should check it out and see if its worth porting any of their components to Angular.
&gt; ClassB.prototype = new ClassA(); [Don't use new to copy the prototype (you will end up calling the base class constructor twice), use Object.create instead.](http://stackoverflow.com/a/4613017) 
The only issue, i see with the setup you gave me is that enterdigits replaces the value in current value. I want it to append the number, like if i do enterDigits twice with different values it'll append it to the existing value. Now i managed to do that with a += instead of just =. But it only works when the default currentvalue is 0. If i put it to an empty string it won't append, and I don't want to start with a default value of 0 but a null value. You have any idea why that is?
I dunno, but that reminds me, [I made this using D3 a while ago when reddit was hiring devs.](http://outoftheblur.com/h6/d3-git-graph.html) It's shows connections between reddit developers based on commits to the reddit git repo. Interesting to see the split when one crew of devs left and another crew came on board. I know it's off-topic, but thought you guys might be interested in the subject matter and to see something fun you can do with D3. :)
&gt; Which browsers support ES6? All the browsers that support the ECMAScript-5 code generated by transpiling ES-6 to ES-5, e.g. Babel. :-)
FYI if you're around Philadelphia, we're getting a Philly WebAudio meetup together -- send me a message if you're interested!
Yeah, I'm gonna second this book as well. It's sitting two feet away from me and it gave me a nice running start on things.
What is the assignment asking me to do then? The test's it wants me to build is what's driving me crazy with confusion. 
Transpilers have marginal advantages over most browsers when it comes to the official specs. But even Babel is only 76% compliant vs. The leading browser (Firefox) at 69%. Even so, I don't think that's a shame at all.
I think the strategy proposed here for pseudo-private properties in classes using symbols is really interesting.
This gets my vote as well.
Another way to hide information in Javascript is to use IIFEs. You can select the return value of your IIFE to close only over information that you want to provide. For example, your IIFE can close (transitively) over a giant bag of state and you only have to make a small portion of that state available. It's not quite as nice from a sugar perspective, but it does give you intra-module information hiding. 
Absolutely. That is expensive in the case of private properties for instances of a class, but it is a tool in the toolbox, and another example of how having one kind of thing makes JavaScript flexible. Methods are functions, and have the same scoping rules as functions. Unlike, say, Ruby, where methods are a different kind of thing than lambda, and thus there are all these special cases for converting one to the other or dealing with scope.
&gt; So you need to do all of that AND use a lot of shady techniques to prevent your subclasses to mess with your superclass behaviour (you know, the 'final' and 'abtract' keywords, all the trouble you have with equals and hashcode that have no clear solutions, the recent addings in Java 8 like default implementations in interface, fucking brilliant idea!, etc). 'final' and 'abstract' are pretty cut-and-dry. If you don't want a child to mess with a method, make it final (or private, if possible). If you can't provide a reasonable default, but need it to exist, make it abstract. Why do you consider them 'shady'? 'equals' and 'hashcode' are pretty easy to write if you accept that instances of most subclasses should never be equal to instances of a superclass or other subclasses. If you need a comparison which allows for that, write your own method. And to be honest, you can often get away with the default implementations because a lot of objects are never tested for equality or used as keys. This is essentially the same as writing 'equals' and 'hashcode' for non-inheriting classes. As for default methods... &gt; Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces. [\*](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html) ... just stay away unless you're forced to use them. It's a feature, not an obligation. &gt; These are big pain, for no gain over composition if there is no is-a relationship. I don't think the pain is so big. But don't do it if you don't stand to gain anything. No one is disputing that (I hope). Edit: Oh yes, and &gt; It certainly ease the execution flow. I once had to deal with MVC app with controllers having a inheritance hierarchy (the intent was to make default overridable behaviour). That was a mess. A nightmare. You never know what was executed when. Really, here, composition should have been used. Without knowing anything about the framework in particular, I will concede that composition makes it easier to follow the flow of execution when necessary. On the other hand, proper inheritance lets you forget about it.
The version of JavaScript that Unity uses is not really JavaScript at all. "UnityScript" has different syntax rules that might be totally valid JavaScript, but illegal UnityScript. You might have better luck posting this on StackOverflow... As a side note, Java isn't JavaScript. They're two completely separate languages, with totally different philosophies -- JavaScript is to Java what grapes are to grapefruit, as one likes to say.
I would rather JavaScript just have null. You could still check if an object has a property with the `in` operator. I meant I would prefer `typeof []` to evaluate to "array". You can't slice arguments without passing them to `Array.prototype.slice.call` (or with es6 argument spreading). I know it's not difficult to achieve head spread arguments, but it would be nice if it was in the standard.
Super awesome. As a musician and a programmer, this makes me want to start building something ASAP.
I'd start by looking for errors in the developer console. There's probably a file (or files) that the save feature missed.
My mistake. All true.
I agree with you 100%, I like using IIFEs for true encapsulation in nearly all cases. The disadvantage to doing it that way is that you have to re-define your methods for each instance so that they all get a unique closure scope tied to that specific instance. When speed matters, you will want to just use a prototype with some `this._dontTouchMe` "private" properties to avoid the overhead of defining functions for every instance. The symbol strategy is just a fancier way to create those `this._private` properties and to make them more opaque, since symbol-keyed properties are non-enumerable.
Is there any major difference between trying it on jsfiddle and on local machine? I downloaded the png file as well on my local machine, and it still doesn't work. Not sure how trying on jsfiddle would make a difference
Thanks! It means a a lot! Excited to get this series rolling. Get coding!
Awesome! Judging by your username, I'm guessing you're the author. Good job at explaining it, doesn't look quite as intimidating as the other articles.
Whole series: https://medium.com/ecmascript-2015 2 articles left :)
Totally agree... Some of us deploy entirely client-side apps from static servers, so you can't just manipulate, say, custom theme CSS from a user's preferences when there's no server-side script whatsoever. It's not meant to be used everywhere, but it definitely has some use cases that make it relevant.
Check out ammo.js
wut
[Sublime Text](https://www.sublimetext.com/) seems to be the trendy choice these days, but it is costs money (not too much, and it's totally worth it). Other free alternatives seem to be popping up, like [Atom](https://atom.io/) built by the GitHub team, [Brackets](http://brackets.io/) from Adobe, or even [Visual Studio Code](https://code.visualstudio.com/) from Microsoft. I was on Notepad++ for many years, and it's still my default text editor, but it doesn't hold a candle to Sublime Text. Multiple Cursors is a killer feature.
This looks like a simple template renderer. 
Hey, I get it, and trust me I'm a big fan of AJAX and DOM manipulation techniques using jQuery/javascript/js frameworks, etc. I do it a lot in fact. Perhaps I misunderstood. It seemed to me that /u/ForScale was talking about the power of using js to change the DOM. He said "You can write like 99% of an entire website with just js code." And I agree with him. That is hella cool. And while I don't use js to make 99% of an entire website (I suppose I could), but I do use js to change html/css a lot. Who doesn't? :D Then I saw /u/points4participation comment that "you shouldn't be using javascript for styling the DOM." And I agree with that ONLY if someone is doing it just for the sake of "using js just to make a static webpage for fun". Its preferable to use html/css. Someone asked why... I saw no one mentioned performance. I don't know for sure, but I'm guessing writing a page in html/css probably renders faster than a page written 99% in js... Anyway... that's what I was getting at. "Why not write a page in 99% javascript? Why not have that js render a static html/css? It can be done! Why not?" The only reasons I can think of is 1) Its more of a pain in the ass... and 2) its probably not as performant as simply html/css. Of course, if that html/css is going to change on the client side in any way, js/jQuery/some js framework/library is pretty much your only option (but you know that). &gt;It also seems like he doesn't quite grok why React is so performant (that's cool, I don't either). Something with the efficiency of using the two virtual DOMs. There's a before virtual DOM, and an after virtual DOM. Somehow that seemingly overly complex system performs very fast. I think I read about how its not an accident. Some very talented devs apparently thought it up and made it work on purpose under some mandate from Facebook. &gt;Anyway, my point was really that, in a jQuery world, I'd agree that you shouldn't manipulate the DOM. Agreed, but... heh... I do it all the time anyway. There's not a lot of other convenient choices usually, and the performance hit isn't always so terrible.
What makes you think you cant use AngularJS for multi page applications?
what directory did you execute that command from? does rasterize.js exist in that directory?
Does chrome support this yet? I'd be interested to know if V8 can still generate a hidden class for symbol-keyed objects (though I wouldn't see why they couldn't)
I guess technically I could. You mean, setup angular on each page? But it seems like a lot of setup I would have to do for each page (I guess). It just seems wrong to do it that way.
I have only used one "framework" and that is Angularjs. And of course, before that, a lot us either used jquery or pure javascript. I like the power and architecture within angularjs but I always thought of it tied to single page apps. And on the different javascript versions, I guess I never really looked at it.
Thanks, is there not a JS version of eclipse?
Thanks, is there not a JS version of eclipse?
I think there is a JS version of eclipse. https://eclipse.org/downloads/packages/eclipse-ide-javascript-web-developers/indigosr2 
I've actually done several projects using angular to enhance a classic site (non spa, server side mvc) with great results, totally recommend it. If you have a server-side template engine theres no need to setup each pace.
Thanks, do I need to change the language at top to be Javascript after installing plugin?
Writing a resume in JSON sounds perfect to me. I imagine the writing of themes that would have me ripping out my hair though.
I'll repost my comment from HN: Just looks like more JavaScript antipatterns, this time with some ES6 flavour. We know how to "solve" the problem of encapsulation with JavaScript. It's not with closures, Symbols, or some other arbitrary hack. We do it by enforcing specific idioms that only require a developer to recognize *intent* instead of learning 80 different ways to do the same thing. You simply *put a single or double underscore in front of the property name*. I read what I thought was a clever anecdote by another developer the other day, that the underscore in "obj._varname" indicates "here be dragons." It's an extremely simple idiom to teach new JavaScript developers. I get it, JavaScript is robust. So you can do fun things like this! These are great experiments. But really, what are you accomplishing? You've now just thrown in a closure and a bunch of lines of code (defining your symbols, etc.) that any developer new to your codebase is going to look at like "... what the... what is going on here?" You can solve the problem easily with one character. Consistency. Convention. Creating useful, easy-to-understand, repeatable idioms. That's what we should be focusing on.
What do /u/mrzepinski think about the concerns that `class` is just a poor wrapper around the `new` keyword (expressed much more elegantly by Eric Elliott and Kyle Simpson), and their opinion that JavaScript should embrace prototypical inheritance instead of trying to add "object-oriented-like" features into the language? (I say OO-Like" because under the surface it's still prototypical, so it won't always behave like true OO would be expected to.)
Which definition of `extends` specifically? **ECMA6** - prototypal [OOP inheritance](http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29): class Foo {} class Bar extends Foo {} Or **jQuery.extend**; **_.extend**; **angular.extend** - Object shallow copy (also called `assign`) var x = {name: 'foo'}; var y = {age: 20}; _.extend(x, y); x // {name: 'foo', age: 20} 
Like when you have for example: class X extends Y{}
You might want to check out [Mozilla's Javascript Canvas Tutorial](https://duckduckgo.com/l/?kh=-1&amp;uddg=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCanvas_API%2FTutorial%3Fredirectlocale%3Den-US%26redirectslug%3DCanvas_tutorial).
Lodash was based off underscore with different priorities. Lodash wanted strong support across different environments and became somewhat of a superset of the library. They're merging both in code and politics. IMO about time. What a month of project merges it has been in the JS world! I've since migrated to Lodash after starting with underscore.
Polymer has a tool for this called Vulcanize which you can use to optimize your components. 
Great that cleared things up for me.
You don't really need a framework! You can do DI with ES6. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import Then just run everything through Babel and you're good to go! 
If you pull in handlebars or another js templating language it shouldn't be too difficult. 
I'm not familiar with Eclipse, but I would assume so? I lump Eclipse in with the more classic IDEs like VIM. I've found that the plugin community for programs like Sublime Text have a ton of momentum, so it makes it incredibly easy to find support and tailor it to your needs. Not so sure about those 'older' IDEs
Beautiful. I thought I was the only one but it looks like other people beat me to it.
AngularJS is a crackhead midget ladyboy from Thailand supervising an egg toss in a mental asylum. The entire framework is like an opium nightmare designed to be unmaintainable within 7 days of it being deployed. Everything is a tag or an obscure compounded class name. Congratulations on making stuff more hopelessly complex, it proves you are the winnarz. ... but of course, anyone who had built a site in AngularJS and had to maintain it would already know about all of this. If they cared one way or another.
👃
[p2.js](https://schteppe.github.io/p2.js/)
First, not every pattern you disagree with is an “antipattern.” An anti-pattern is a specific term that usually refers to a pattern that introduces a systemic and contagious problem. An anti-pattern might be something like writing a class where every method takes a callback, so now everything interacting with the class must be written in continuation-passing style, which affects everything interacting with that code, and it ends up infecting the entire codebase. In any case, the article is not, in fact, about using symbols to create privacy. You say you get it, JavaScript is robust. Yes, that is the point, that you can do a lot of things in JavaScript that cannot be done in other languages where you get whatever it is the language provides and cannot do any more. Whether you should or not is entirely your decision, and yours alone.
This is not a new library in the sense that they're starting from square one. This is a merging of underscore and lodash.
*An anti-pattern is a specific term that usually refers to a pattern that introduces a systemic and contagious problem.* Which is exactly what we have here. Using closures and Symbols to mimic encapsulation when, generally, there's already an established convention to create private members, is almost certainly a systemic and contagious problem. The fact that people are repeating and sharing these patterns means, by definition, they're contagious. *Whether you should or not is entirely your decision, and yours alone.* I mean, yes, I have personal agency and free will - anything I decide to do is my decision alone. As does every developer. The point of establishing patterns and pointing out anti-patterns is that *we shouldn't be selfish when writing code*. Writing software is a team effort, and code is read far more often than it is written. We're more often that not writing code for other people, not ourselves. We're writing code for our community, co-workers, and customers. Our customers don't care about what our code looks like, but they care about how many bugs it has. By establishing standard practices and idioms we increase the efficiency of our teams and communities by decreasing the amount of time individuals have to spend interpreting other people's code. Just because we *can* do something in JavaScript doesn't mean we *should*.
Same! Been looking for something to play with in my free time and this hits the spot.
Yeah, and these are the most used for functional programming practices. Definitely not a case of "another all things javascript"
It's been a long time since I've actually worked in javscript. I spend most my time in c# these days with things like coroutines and linq. I had no idea the same sort of stuff was possible in javascript (and without jquery even!). Thank you for blowing my mind.
Right. I'm excited about this. Its an example of the issue I mentioned getting better. 
You are obsessed with the colour of the encapsulation bikeshed. If something you don’t agree with becomes popular, that isn’t contagion, that’s people making decisions for themselves that don’t suit you. Contagion is when people have no choice in the matter, when there are network effects. It happens to me all the time, I don’t call it an anti-pattern, I call it people having a different perception of their needs than I have. I don’t feel like every single thing I disagree with must be stomped on, hard, to prevent the world from being infected with a terrible menace. You have an opinion. You don’t magically have an insight into what is selfish and what isn’t. The fact that you like thing A and dislike B doesn’t mean that by fiat you can lecture people about why A ought to be a standard idea and B is a selfish thing to do. Furthermore, you lack perspective about this post. Nowhere does it say that disaster will befall you if you don’t use symbols. Nowhere does it say that using symbols is superior to using closures, or superior to using a naming convention like underscores, or superior to doing nothing at all. Some posts are prescriptive: You should do this, you shouldn’t do that. Other posts are descriptive: This is how this feature works. This is how that feature works. This post is **descriptive**, its primary purpose is to describe certain consequences of the JavaScript language. It uses “toy” examples that may or may not be appropriate for each reader. If you are saying that a toy example chosen for its effectiveness in illustrating another principles is a toy, great, say so. But really, all this extra lecturing about the importance of standardized idioms and so on is waaaaay off-topic. The post is not telling anyone that there is only one way to do it. Trust me on this one: If you try to make every example a piece of production-ready code that is resistant to all objections from people like you, nobody would get anything written, ever.
It's a non-concern. JavaScript, whether version 1, 3, 5, 6, or 7, is object-oriented. There is no "one true OOP."
uncss: https://github.com/giakki/uncss
Great, then I'm saying it's a toy. And there's nothing wrong with that. :) (... Except, of course, for the fact that in a team environment, I would consider it an antipattern.) It's easy for a newcomer to read an article like this and assume it's some sort of standard practice. I want to be clear that it's not. I'm merely providing context.
It is based on Objects, but it is not Objected Oriented in the classical sense. I feel it is a mistake to try to force JavaScript to mold itself to those traditional Object Oriented concepts.
Something to keep in mind when choosing is accessibility. https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility
I mean, are we talking about thousands of markers at zoom level 2 or 16, and what's your marker placement process like outside of clustering? Clustering can be done very efficiently if N is minimized. If you have a set of defined polygons, for any type of admin area, group your markers by point-in-poly first, then simply cluster them by proximity.
According to the article, this is the equivalent es5 syntax to class/function: function Vehicle (name, type) { this.name = name; this.type = type; }; Vehicle.prototype.getName = function getName () { return this.name; }; However, this is not quite true. Assigning the getName property to prototype directly will set that as a function, but it will set it as an _enumerable_ property. e.g. `var myCar = new Vechicle('General Lee', 'Dodge Charger'); for (var i in myCar) { /* the function 'getName' will show up here */ }` For more verbose, but ES6-behaviour implementation in ES5, you can use `Object.defineProperties` syntax, e.g. Object.defineProperties(Vehicle.prototype, { getName: { value: function() { return this.name; }, configurable: true, writable: true } }); enumerable is false by default, so you don't need to explicitly specify it. This can become really problematic to not use the es6 approach, e.g. if you have code that may run on your es6 code compiled to es5 for backward-compatibility, you might want to list the properties of your vehicle and expect just the name and type, but also get function names in that list too. http://www.2ality.com/2015/02/es6-classes-final.html
&gt; It's not called "contains", because MooTools modified an object it didn't own. It's not called "contains" because those developing the spec made the insane decision to base the language spec around language libraries.
What about this *isn't* polyfilling?
Great article! Recently released a node module for building command line tools using the es6 class format. I love the new syntax! https://github.com/terminalvelocity/soil-cli
I'd definitely use the DOM. An absolutely positioned &lt;div&gt; with fixed width and height a background image is pretty much the perfect model of a playing card, and you can use things like CSS transitions to implement in a couple of lines some fancy animations of the card leaping from the hand to the discard pile or whatever. That stuff will be automatically GPU accelerated by the browser so it should be really smooth even on mobile. You're going to be doing a whole bunch of wheel reinvention if you do all that from scratch with a canvas. 
Problem seems to be he doesn't know the definition of OO and keeps saying it when he really means "verbose, Java-like implemention of OOP". It happens all the time on here and /u/webdev. 
&gt; Linting can catch all potential issues just fine. Ahahahahahahahaha. Good one.
Nice use of PhantomJS.
I think there is a typo in the "a problem with encapsulation" code : rename (first, last, middle) { this.firstName = first; this.lastName = last; this.middleName = last; // middle return this; } Nice post anyway ! However, it's worth noting that even with your last code, it is possible to access the "private" properties by doing something like : let author = new Person('Howard','Lovecraft');. console.log(author[Object.getOwnPropertySymbols(author)[0]]); edit: my bad, didn't see your footnote #4 
It's hard to do such robust static code analysis when the language is dynamic, interpreted, and duck-typed. It'll be difficult to do what you want, and nothing like it really exists right now. 
Odd that you consider vim an IDE and lump it in with eclipse. I mean it's expandable into a full fledged IDE but it's definitely in the scope of a lightweight text editor. 
Adding things which aren't in the specs is monkey-patching.
Canvas, no doubt, take a look at phaser.io, take it slowly because its not a small framework to learn but you'll love it
Wow gotta try this one! Thanks!
How do I select what device, what channel? Modern PCs with USB interfaces can host several MIDI buses.
My point is: designing for inheritance IS hard, harder than composition. Inheritance should ONLY be used for isA relationship. NOT to factorize behaviour. That's what composition is for. In other word, only inherit when you need to. Final and abstract are fine in themselves, but it is just a difficulty you can easily avoid with composition. &gt; 'equals' and 'hashcode' are pretty easy to write if you accept that... Actually it is more complicated than that. You can make subclasses and superclasses comparable with equals *if and only if* equals is final in the superclass. BUT then you can have 2 subclasses objects that would be equal, while not even being of the same class, nor have the same state (providing the inherited state is the same). OR you can do what you described BUT you have to remember to test with class == and NOT instanceOf in your equal method. All other possibilities break the equals contract (I can show you in details if you want, you have a [start here](http://stackoverflow.com/questions/12239344/why-should-i-not-use-equals-with-inheritance)). So no, this is not simple, and not perfect functionally speaking. I agree you don't always need to define your own equals but: &gt; This is essentially the same as writing 'equals' and 'hashcode' for non-inheriting classes. This is unfortunately not true. About default method: yes I won't use them myself, but the fact they exist means other will use them in the code base I work on :-) Anyway, these problems are java-specific but my point is for any language: difficulty of inheritance = difficulty of compositing + additional difficulty of designing properly for inheritance. &gt; On the other hand, proper inheritance lets you forget about it. I'm actually not sure it is ever a good idea. Do you have an example? Thanks for the interesting discussion :-)
We try to keep it simple, here is an example -&gt; https://github.com/jsonresume/jsonresume-theme-modern/blob/master/resume.template
How are they not real arrays? Thanks.
Because they are essentially a type of object in js
Maybe look at typescript. It may give u something in the middle
A text file filled with curl commands.
* BabelJS * Webpack * ReactJS * ESLint * BrowserStack * Mocha, Chai, Sinon, Mockery * Chrome * Slack * Sublime * SourceTree * Mechanical keyboard =)
I think this is due to the popularity of class-based OOP that most people will probably refer to as classical OOP. I could imagine this might be due to the popularity of Java when teaching programming, forcing people into the mindset of class-based OOP. When these people head out to learn JS - expecting a lighter version of Java - they will complain that JS is not OO because it isn't class-based. While it could be a valid complaint that JS is not class-based, the complaint that JS is not OO is certainly not. OOP is a paradigm, class-based OOP is an implementation of it. While Java implements OOP as class-based, JS has multiple paradigms, one of them happening to be OOP - just not implemented in a class-based way. This is also why JS devs often find this critique of JS rather ignorant. I think JS is actually more OO than Java since it doesn't try to force everything into hierarchies of classes. Instead, it just hands you a simple object implementation where you can create objects and prototypes anywhere you want, at any time. Personally, I think a functional approach to JS that uses objects to handle data is incredibly more powerful than classes. As a polyglot programmer, this flexibility is why I love JS. It is probably also why this implementation of classes in JS gets so much criticism.
Get the fuck out of here then
&gt;What a month of project merges it has been in the JS world! I think we will finally witness a decrease in the number of JS libraries. It's like a solar eclipse on the web. :D
&gt; Java doesn't have first-class functions... That's an example of language limitation. With implicit interfaces, just interfaces, lambdas you can avoid it. &gt; Most GUI toolkits have a base class called Component or similar... It's the closest to convincing example there is. But you can avoid the inheritance with a single interface Component, and use embedding/traits to build-up implementation of Components. Alternatively use a single type for UI elements. Although, I don't have examples of those designs. &gt; In RPGs there are friends and enemies. http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/ and http://gameprogrammingpatterns.com/component.html &gt; In Java there are lots of Streams... Inheritance is not necessary, interface is sufficient (e.g. [Go io](http://golang.org/pkg/io/)).
&gt; if you have code that may run on your es6 code compiled to es5 for backward-compatibility, you might want to list the properties of your vehicle and expect just the name and type, but also get function names in that list too. That's not the case because transpilers like Babel use `Object.defineProperty()` rather than straight assignment to the prototype, so methods are not enumerable. 
Good question. You can get to the device and port list with this code: https://cwilso.github.io/WebMIDIAPIShim/examples/routing_1/ As far as channel goes, that is derived from the first byte of MIDI data. The quickest way i've seen of doing this is to use the [bitwise AND operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_AND) on the first byte of midi data, ex. [0x90] noteOn, and the maximum number of channels, [0xf] 15 (MIDI channels are counted from 0 - 15, 16 channels in total. channel 0 is what you would know as channel 1). So, if your first byte of your MIDI message was 0x91, you would use 0x91 &amp; 0xf, which would give you channel 1 (channel 2 to humans). You can try this out in the browser's developer console and it will return the correct channel. This wrapper makes this kind of thing easier to manage without learning 7-bit MIDI code: https://github.com/ryoyakawai/WebMIDIAPIWrapper This shows how to to send your device messages: https://webaudio.github.io/web-midi-api/#sending-midi-messages-to-an-output-device Hope this helps.
I would definitely be interested, but i'm in California. If i'm out there I will get in touch. Thanks!
Could you link to these tools also? thanks. 
&gt; This is spoken like someone who's knowledge of professional software development comes from watching Silicon Valley. Indeed. Silicon Valley is a very accurate portrayal of professional software development in tech startups, and substack lives in Oakland. He might have a different impression of software development if he lived outside a major tech hub.
Yes, I agree, JS is perfectly OO without needing to borrow keywords and classes from these other languages. Some of the design problems are related to clashing OO paradigms that don't really fit. The creator had to appease the requirement to adopt some Java-like elements, such as new Object() creation, which don't even work the correct way from that POV. So there is this weird mix of paradigms, but they are all OO, this is not procedural C or something. It's an interesting idea, an army of Java-trained CS grads are driving this push to more class-based syntax. I think the rise of mobile has elevated JS to no longer be seen as a toy language, now that all these fat apps are made on the client side. So everybody wants that sweet $$. Of course people like to trash talk: "front end? is that some kind of sandwich engineer? will you be a designer next?" But now that the cash is rolling in, everyone wants to make it into their own preferred class-based thing. Yeah, that makes some sense. A lot of cleverness has gone into making JS behave in ways one would expect in a classed language, e.g. using closures to get consistent "this" values. But if you were looking at it from fresh Java eyes, it would seem pretty hacky. So if these new ES6 keywords fix that for people, I'm fine with it. Then people can stop complaining and being so fancy all the time. However, I too think the flexibility and lightness are JS' distinguishing feature. I can just pop out an object without creating a new file, importing headers, implementing an interface, setting a delegate and 20 other things. 
Emacs. The single greatest productivity improvement I've ever made. Nothing else comes close. Combine it with spacemacs and it gets even better.
The language is not a problem. Just be sure to take a book that will let you learn something. Get a college level textbook that uses pseudocode for the examples and not something written "for people who knows js" - I repeat the language is not the problem. The problem is that such books that have as target people that for their reason decided to not go to college, tend to be only a bad approximation
Crossposted from /r/reactjs. git repo: https://github.com/aickin/functional-react See also - https://github.com/dekujs/deku which is a functional alternative to react, not based on react, but an independent project.
Git. Nobody mentioned this before?
Partially I agree with you, but we live in a modern world, where such developers, like you, who looking into improving experience and community, would be very helpful by making several components really really decoupled. I won't call it frankenstein, I will call it another module, maybe not nodal-db but something new. I mean, like right know, people using nodejs just don't really know about easiness and awesomeness of using orm with migrations. I will say it will be kinda right thing to do - let people to use one of the most awesome (for me, at least) components of your system, and then, if your system with all it's other components all tied together (like nodal fullstack) is suitable for people and easy to use, config and contribute to - they will stick to your whole full stack. As example - Symfony2 and Doctrine. People who have choice - they use Symfony2 with Doctrine, who have not - try to use Doctrine separately, if they are keen of it. So... I won't call it Frankenstein, I will call it choice, decoupled reusable components (which is very, very good practice). You may be very helpful to community and developers, just making ORM with auto-migrations come true :)
Your point about 'cobbling things together' sums up my (short) experience perfectly :/ Once things become complex enough in someone else's code, i'm finding myself well out of my depth... lots of nested/linked transitions, interpolations, obscure scales... madness! Just starting out on a rewrite of my project now.
I was surprised as well. If you'd asked me: What is the one tool you could not live without, I would have to say Git.
GruntJS - I use it in every project of mine. Something I can't live (code) without. http://gruntjs.com
Node and io.js
I stopped using UE a long long time ago...it was great, but the latest versions wheren't that good. I think PHPStorm is really powerful. Also try Total Commander, i've been using it since windows 95 and it's simply the best tool to manage your files 
For me: * npm. In particular grunt/gulp/yeoman/bower and a few other smaller utilities. Also node is my preferred for any custom utilities I need to create or small prototypes. * Sublime and it's packages. Way too many to list. But if I had to choose my favourite, it would be emmet. * OhMyZsh. I prefer this over the standard shell * Charles (aka 'the jug'). I especially like the map remote/map local feature for files which helps me debug other environments easily. * Chrome. My preferred dev browser * Vmware fusion. Old versions of ie, plus a windows VM I use as another dev environment. * Git (and sourcetree) * Middleman (used to create html templates passed to the backend devs). Looking at switching to something in node though just haven't been happy with something yet. * Mocha for testing * AngularJS/React/JQuery/handlebars. Obviously not all at once. Right tool for the job. * Sass * Spotify * mechanical keyboard and mouse with programmable buttons * CI (at my current company we use bamboo but I'm not concerned as long as I have something) * Dropbox. * Trello. Our projects overall usually use Jira, but I typically manage my own work outside in trello.
I've been teaching a friend how to program. Git was one of the first things taught and imo it should be a requirement.. and use it properly. Nothing more frustrating than team members who commit multiple pieces of work at once or those who can't merge and just take their own work.
Pretty much my list too.
My favourites have been mentioned here already, but here are some that aren't immediately apparent when googling: - http://computationallyendowed.com/blog/2013/01/21/bounded-panning-in-d3.html - http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html - www.d3noob.org/2013/01/adding-tooltips-to-d3js-graph.html (from the very long, often basic / high level book (free): https://leanpub.com/D3-Tips-and-Tricks/read )
I've been calling it Niode
I found metalsmith to be a good node alternative to middleman. It's super configurable.
Git, Gulp, WebStorm, Chrome (mainly for DevTools), Slack, SaSS, NPM, Mongoose, Express, 2 external Thunderbolt displays for my macbook. I do a lot of Angular/Node/MEAN stuff with native iOS and cordova sprinkled in.
ngrok
http://ternjs.net/ Tern.js is a stand-alone code-analysis engine for JavaScript. - Autocompletion on variables and properties - Function argument hints - Querying the type of an expression - Finding the definition of something (really works, not text search) - Finding references to something (really works, not text search) - Automatic refactoring works in: emacs, vim, brackets, atom, light table, eclipse The atom version has some screenshots: https://github.com/tststs/atom-ternjs Its kind of magic. If I type: angular. I get autocomplete showing all the methods on angular with all the argument names and types annotated. It will snake through your node or bower modules and read all the docstrings. You see inline documentation to remind you what the method is. This stuff is hard to do in an untyped language. It made me put in a lot more @params in my docstrings Sometimes it gives me bad hints like console.log(... log(number) : number so its confusing `console.log` with `Math.log` But when I do autocomplete I see the choices displayed with the function argument types including the return type.
OP has a hard on for Eclipse it seems from the comments, but really, go grab WebStorm. Forget Eclipse.
Beyond Compare the best file/dir/ftp/sftp comparing tool (it's paid but comes with a free 30 day usage trial)
* [TypeScript](http://www.typescriptlang.org/) * [VS Code](https://code.visualstudio.com/) * [Atom](https://atom.io/) * [Node.js](https://nodejs.org/) * [Gulp](http://gulpjs.com/) * [tslint](https://www.npmjs.com/package/tslint) * [Karma](http://karma-runner.github.io) * [Mocha](http://mochajs.org/) * [GitLab](https://about.gitlab.com/) 
Also, this is how I've been approaching "Classes" in JavaScript (I avoid using 'this' altogether). Are there any disadvantages to this? function MyClass(someValue) { let memberVariable = someValue; function privateMethod() { // do some stuff return something; } function publicMethod() { let x = privateMethod(); // do some stuff return somethingElse; } function anotherPublicMethod() { // do something return anotherValue; } // Equivalent of C++ header file return { getMemberVariable: function() { return memberVariable; }, setMemberVariable: function(newVal) { memberVariable = newVal; }, publicMethod: publicMethod, anotherPublicMethod: anotherPublicMethod }; } let myObj = new MyClass(1337);
Checkout code climate. Also, find a boilerplate build system like react-starter-kit and try out the system, customize to your liking 
Past tense? I thought there was still a lot of legwork that needs to take place.... indeed: https://github.com/underdash/underdash
Grunt oh lord grunt. All the tools mentioned in this thread fired up with my build task. Love jshint? Love LESS? Love them even more in your watch task!
The only downside is most if not all packages are written in coffeescript. It's fine, I get why they'd like it with syntactic sugar subclassing and whatnot... but if I'm writing a plugin, guaranteed it'll be in JavaScript.
You and I pretty much do the same thing. :) I would also like to add that Atom's ecosystem has exploded and its package manager is amazing which I thought was lacking in Sublime. No longer do I have to worry about setting up downloaded packages and syncing up configs when I'm switching the machine.
Oh boy, wait till you hear about gulp. 
Great thing about UE is you can open a TB file and the editor won't completely bork.
Absolutely! Helps SO much when reviewing logs pulled off an app server. I personally name its macro capabilities its best feature... can't tell you how many times I've recorded a complex series of steps and then played it back many times to accomplish some repetitive task
Thanks it's really helpful
What do you think about JSPM's speed? When I reached a modrat size of my react app, the loading time was just too large, and had to go back to webpack/browserify!
&gt; Kaleidoscope, One of those weird apps What is weird about it? I've never used it but it looks like a pretty standard `diff` tool.
nice! didn't knew that, thanks...
No need to succumb to devious js ways: ES6 is a sure indicator that Javascript is finally embracing Classes, Inheritance, Modules and such. 
Git has a *massive* learning curve, but it's freakin' amazing.
You can write in ES6 now. Just save as .es6 and it will babelize it. I am guessing that they will gradually move all of their codebase to that. The best parts of Coffeescript has been kind of merged into ES6 already. The only thing I've really done in coffeescript is my atom package: https://atom.io/packages/supercollider and I did quite enjoy working with it. But sometimes you just gotta use some () so you can read the damn thing. 
Serves the same exact purpose AFAIK. I use either depending on the project.
https://github.com/raganwald/raganwald.github.com/commit/84bfeb264382eb1b1736d40414daa42729cbd57f
The latest Babel is excellent, but not every project will be on it. The spec was only finalized in February, so there are still a lot of environments out there that may not necessarily define the accepted flags for each defineProperty property. Reactify (the transpiler for JSX under browserify), for example, still doesn't define the props so that enumerable is false. The most common case will be when a project's package.json doesn't have their latest transpiler version defined, since transpiler upgrades are often high-risk since they very directly change production code behaviour. I'm simply giving a caveat so people know this is something to double-check.
JSFiddle for sure.
Atom is pretty good now, but the abundance of very low quality plugins is hurting it. If I run for a while some plugins will start leaking like a sieve.
That's the thinking, though -- this isn't a method to prevent yourself from having to update your code when the models change. This is a way to _allow_ you to update your models and code without having to: - Loop through every single pre-existing record in your database and update it - Add another API version endpoint - Break dependencies - Check for old versions of the model anywhere in your code
I immediately thought of the global warming piece on the home page. http://www.reddit.com/r/science/comments/38ntxy/new_research_suggests_global_warming_is/
Almost at the home stretch for completing the assignment. It's just this error in 8 comparing to '8' which I don't quite understand. Is the toString() not working or is the string literally including the quotation marks? [Here's my fiddle](https://jsfiddle.net/wzAyL/427/)
Newer JS engines recognize the reuse of these functions and reuse them instead of making new instances. You can look at the various jsperf benchmarks on this if you need to prove this to yourself. I still prefer classes for basic structures that I can then compose with higher-level AMD structures.
Okay, let me take a stab at it first, then: * 2015-2017: Babel (or future competitor) expands to support bidirectional transpiling between a large set of languages, effectively making source-code language choice a matter of personal preference. * 2016: Services like Amazon's Lambda begin to disrupt what it means to write "server-side code", which also leads into a whole new generation of frameworks on the client-side to take advantage of the new architecture. * 2017: Pure client-side businesses will begin to be a real thing: businesses without any server-side assets at all will be able to remix available web services and lambda functions to create rich experiences without the need for custom servers.
As a front end dev: Firebug, Fiddler, Sublime Text 2, DiffMerge and Pixus.
The problem with JS is there's no "this is how we've always done it." There are thousands of resources out there, many outdated, that provide a plethora of ways to accomplish the exact same thing. It's overwhelming. How many JavaScript developers have you interviewed or worked with that compose objects by defining methods in the constructor instead of via prototype, for example? I think ES6 is a great place to set a solid foothold with the community and say, "here's what we've learned about Object composition, inheritance, closures [...]". We've only learned these things precisely because the language has evolved. Inheritance before Object.create was just plain confusing. (My parent constructor method gets invoked when I set the prototype? Yikes.) In order to do that, though, the thought leaders of the community need to be aligned in their messages. I'm mostly fond of AirBnB's style guide in this regard because it has a wide reach and encourages clarity. It's easy to point at and say, "just read this." I'm currently working on [Nodal](http://github.com/keithwhor/nodal), an ES6 API server, with a focus on encouraging the use of easy-to-learn, repeatable idioms. It's a big project, and I'll probably do a write-up about decisions regarding design patterns focused around it. I've spent a lot of time ensuring consistency across modules and making it easy to reason about. (Do me a favour and ignore the CLI code, that's a mess. Those are the dirty dishes I'm procrastinating cleaning ;))
I agree with you on node.js but I still think JSX is a mess... I'd prefer to use regular Polymer Components now that they are 1.0. 
I recommend a few changes to that code. * You don't use 'this', so don't use 'new'. * Since you don't need 'new', change the name to makeMyClass() which identifies it as a factory, but not a constructor. * Keep functions out of the return (put those getters and setters above). * Getters and setters aren't typical in JS. Prefer direct access unless you specifically need protection (at which point, you usually don't want getters or setters). * You're using esNext (and I presume Babel). Change the return to "return {getMemberVariable, setMemberVariable, publicMethod, anotherPublicMethod};" as it's easier to read and less maintenance ([more here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)). Even if you leave the functions there, use arrow functions as they're much easier to read in this case. 
That's interesting that you switch editors between host systems. Why not use Sublime for both?
Javascript becomes sentient
This gave me a good laugh. If anything ES6/7 is going to create a plethory of rewritten libraries and frameworks
Alright nevermind that, i changed all the variables to equal null. Instead of passing strings or equaling a string of '8' it's just doing toEqual to the int instead. Should be able to implement a if statement for different operators and do everything as it should work. Thanks again for everything, really helped me refresh myself a bit on the whole programming lingo
Duck Duck Go? Really?
Another consideration is that JavaScript will continue to have a limitless and growing list of stakeholders, everything from enterprises with massive backend implementations to indie devs writing interfaces running on LCDs hanging off drones. When there is so much variation in potential usage, for the world's most openly developed language, there is 0 chance of settling.
I can't help with the intent of the question but please, stop using bower. In theory npm should be able to do everything bower can, maybe not as intuitively but more importantly there are few reason to use bower. If you are working on a project with a tone of multiple versions I can understand to some extent but then you're probably bloating your JS/ CSS. Yea, bower is not necessary. NPM is good enough and It's not only me who thinks so.
The less familiar I am with stuff, the more I lump it together :-)
why the fuck are you repeating yourself?
0. Git 1. zsh 1. Webstorm 2. Vim 3. https://github.com/componentjs/component 4. grunt 5. JSHint 6. JSBeautifier 7. SASS 8. nvm 9. node-inspector 10. Chrome devtools 11. https://github.com/visionmedia/debug 12. ExpressJS 13. ZombieJS 14. CucumberJS 15. Jasmine
It's a legitimate qualm when you have to deal with developers writing code that barely functions in the wild.
OP == Fag or Troll Repeatedly asking for JS version of eclipse [First Time](https://www.reddit.com/r/javascript/comments/38kp4v/text_editor_ide_that_checks_errors/crvu0s5) [Second Time](https://www.reddit.com/r/javascript/comments/38kp4v/text_editor_ide_that_checks_errors/crvu16t) [Third time] (https://www.reddit.com/r/javascript/comments/38kp4v/text_editor_ide_that_checks_errors/crvu11t) [Fourth time] (https://www.reddit.com/r/javascript/comments/38kp4v/text_editor_ide_that_checks_errors/crvu0we) [Does he even know how to google?](http://lmgtfy.com/?q=js+plugin+for+eclipse) 
I've tossed around the idea of switching everything to npm, however one question always arose: **How do you inject front-end specific assets into your `index.html` similar to `wiredep`?** npm has the concept of `main` files, but it's a single string, used when your app is `require()`'d, I believe. I'm with you on the npm train, but I need to answer some of those questions first before I can make that jump. 
Thanks, good point on the factory. The reason I'm using a getter is because if memberValue is assigned a new value it won't be reflected in the returned object if you put it directly into the return statement. For example: function makeObject() { var memberValue = 'Hello, World!'; function reduceMember() { memberValue = memberValue.substr(0, 5); } return { memberValue: memberValue, reduceMember: reduceMember }; } var obj = makeObject(); console.log(obj.memberValue); obj.reduceMember(); console.log(obj.memberValue); // Output: // Hello, World! // Hello, World! I'm actually not familiar with esNext or Babel, just making personal projects for myself in Chrome using strict mode so I don't care about browser compatibility. Will have to check those out.
* vim plus a bunch of plugins * fish * git * bash scripts * babel * npm * Server Auditor Android App * Hacker's Keyboard Android App * Linux Deploy Android App * framaroot Android App * Linode/Digital Ocean * Docker sometimes * Chrome * Paypal * tig * http-server * npmjs.com * tightvncserver sometimes * grep * wget * less * vimcat (vimpager) * hub * google / stackoverflow * slack/hangouts/skype (chat) * hotplate * hotpot express * cheap energy drinks/energy drink syrup * Amazon Prime Now (or Instacart)
grep, curl, tail. I have to agree on Dash, though i oddly haven't used it as much this year. JS tooling: JSHint, grunt, etc. 
I'm primarily using objects as a way of encapsulating data and separating business logic. I rarely find myself using inheritance
No they haven't. It's all collaborative conversation and ideas so far.
Wait till you hear about Make.
Webpack can be compared to browserify not gulp or grunt even though there are some overlaps. 
You kid but we go full-circle more than we'd like to admit. 
ITT people who add so much to sublime that they should really be using a real IDE (e.g. WebStorm)
Consts have other purposes: [Speeding up global constants using fixed field optimization](https://blogs.windows.com/msedgedev/2015/05/20/delivering-fast-javascript-performance-in-microsoft-edge/)
Sometimes I'll browse this for ideas on new stacks. http://stackshare.io
Is OP posting that from the past ? Because what I read here are early 2015 trends, not predictions.
In line 13 you declare the variable 'valor' to be the element with an id of counter. Parsing a jquery reference to a div id as a number would at best return undefined, you probably want to try parsing the text value of the div. Hope this helps!
thank you guys for your response!, thats really helpful to me
As the comments allude to, I think handling state is incompatible with Ramda based on FP concepts. I think what you may really be looking for is a _state machine_ implementation; with this, you can abstract all of your state into a single object.
Ghengis is a pretty decent tool for mongo management - http://genghisapp.com/
For me it was the opposite. I tried a number of different Linux distros. I was spending more time figuring out why things didn't work than being productive.
what the?
Thank you for introducing me to browsersync! I'm in love. Now if I can just make it work with Cloud9...
Completely agree. 
Note that Addy Osmani's design patterns book follows the path of taking GoF patterns and simply trying to _translate_ the proposed solutions into JavaScript, without a proper analysis of their applicability. This is approach is both dangerous and wrong, as a fair number of those _patterns_ turn out to be complete _non-patterns_ in JavaScript. Just to point one example: the Command pattern's solution is generally explained as "AKA: Object version of closures"; that is it emulates closures in an OO language without support for them. In a language that _does_ have support for closures natively the pattern turns into a non-pattern and the forced application of the proposed solution should be considered an anti-pattern.
&gt; 2: Smaller libraries (and the composing of) will be preferred over large frameworks and &gt; 4: Large, fully-featured frameworks will remain rightly popular Well, which is it young feller? You want I to use libraries or frameworks? Mean to say, if'n I use libraries, they ain't gonna be frameworks, and if'n I use frameworks, they ain't gonna be small libraries. You see... [Shut Up!](https://www.youtube.com/watch?v=nrDQrb5PITc) --- Edit: It's missing ~~#9: Browsers will improve and reduce the need for polyfill.~~ ✓Came true before publishing. 
That's pretty cool :). I took a slightly different route and just utilised Oscillators with this library: https://github.com/meenie/band.js - You can see an example here: http://plnkr.co/edit/LG20SL?p=preview
Ah that's true, was only thinking in terms of frameworks.
SSH, of course.
Pushing to production. Thx mate.
&gt; 1: Fewer people will write JavaScript without a compilation step Disagree. Less people will need to since JavaScript as a language will evolve. As well, Microsoft, the real thorn in everyone's side, has changed pretty significantly since Balmer left, leading to better versions of IE. IE is ultimately the one reason why people feel they need to resort to Babel. &gt; 2: Smaller libraries (and the composing of) will be preferred over large frameworks Not so sure I agree. Again, just look at other popular languages. Some python folks like Django for a complete solution, some people like flask and native db drivers. I think what we'll see, is all the noise start to finally settle down. There will be less everything, as certain projects obtain critical mass. So you'll end up having a few mature libraries, micro frameworks, and monolithic frameworks that most people goto. &gt; 3: Focus on libraries that do one thing and one thing well Well, see #2. &gt; 4: Large, fully-featured frameworks will remain rightly popular Well, eventually evolutionary pressures will mean that we end up with a select few of the best. And that's a good thing. It means the community's efforts will be put to better use. Same goes with tooling. Surely NPM will crush Bower, nodeunit will lose out to mocha or jasmine, grunt and gulp is to javascript what maven and ant are to java. All defacto standards so to speak. &gt; 5: The use of compilers (Babel etc.) will be abstracted for us by generic build tools not sure I agree. What examples do you have in other languages? &gt; 6: Running the same JavaScript client and server side will be common Well, not really. You might share more code, but you're not running the same application. &gt; 7: As ES2015 implementations complete, we'll be writing ES7 already Not so sure. I think the pace of Javascript version adoption will go up. Transpiling kinda sucks. &gt; 8: The rate of new frameworks will begin to slow down well, no shit. it's called maturity ;)
you're kidding right? Java is far bigger in almost every way to Javascript. And it will be that way for some time to come. http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html 
I think there is going to be increasing interest in this: http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html
That's how learning works. Take a weekend off and just have fun with installing and debugging different Linux distros, I guarantee there's a distro out there that you'll like. Also check out /r/unixporn for your customization!
You might be interested in /u/rauschma's blog post, [Fake operator overloading in JavaScript](http://www.2ality.com/2011/12/fake-operator-overloading.html) ([reddit post](http://www.reddit.com/r/javascript/comments/1fxi1i/fake_operator_overloading/)). I just _thought_ I knew JS really well until I read that post...
Can anyone summarize the parts of underscore that will be in underdash? I know people liked their docs, but is there any part of the source that is preferable to lodash (besides file size)?
It still is man, you gotta keep the faith brother!
I built Cardcast and Blackjack Cast (two card based Chromecast apps). First was dom, second canvas. Canvas required more initial setup, but is definitely the way to go if you use any animation (like dealing cards).
Real predictions for next 4 months: * Ecmascript 6 Finalized. * [The Grid CMS](https://thegrid.io) beta begins. * Windows 10 Free to all current windows 7 and up users leads to lots of IE Edge users. * Developing Node apps on windows gets a whole lot better if they ever fix that damn max file path bug. * New Intel 14nm architecture (Skylake) - More new computers, lots more IE Edge users. Doesn't matter, IE 9 and 11 still won't die... yet * More Embedded, Drone and Internet of Things apis * Next generation of mobile devices with more voice and gesture APIs. 
Some of the best articles you can read about JS can be found on [raganwald.com](http://raganwald.com/). He touches on functional programming, OO, and everything in between. His approach to solving problems demonstrates the kind of JS programmer one should aspire to be: given the flexibility of the language, it is important to be very good at choosing the right abstraction and language features to attack the problem at hand. Dogmatic promotion of one paradigm or another (OO v. functional for example) seems pretty short-sighted and narrow-minded. The "Two Pillars" article someone else mentioned also touches on this.
Advantage: true data privacy. Disadvantage: memory allocated for each instance's methods, instead of instances sharing the same function objects. These are two sides of the same coin. Especially on the client though, you're probably unlikely to have instances in large enough numbers that memory allocated for the methods actually matters. In many cases, the guarantees around data privacy and having an object in valid state are more important.
To give my own answer, `Object.assign` is probably the feature I've gotten the most use out of so far, with `Promise` coming a close second. I'm looking forward to learning generator functions, although the fact that they still need to go through a compile stage is kind of annoying.
Actually yes, you are correct. Ramda is the one I was thinking off trying next. I always get the two mixed up.
ES6 modules. As a heavy ember developer I use this the most. Ember CLI depends greatly on it. Promises are a close second, with lambda functions in third.
Why not just use om?
webpack serves a different purpose than gulp
I never even knew about `Object.assign`. That's one less lodash dependency I have to include. Thank you!
Having promises built into the language is incredible. Proper classes are amazing. The `=&gt;` syntax is awesome. Probably the highest ranking one for me is `const`.
Give me real objects dammit, not this shity half assed prototype shit.
The spread operator `...` is so convenient and I use it all the time. If you enable `stage: 0` features in babel you can even use it to spread object literals as well as arrays. For example: /** * Deep map the keys of an object. The keys of the object will be passed into * the given function and will be reassigned according to the function's result. * * @param {Object} * @param {Function} * @return {Object} */ function deepMapKeys(obj, fn) { return Object.keys(obj).reduce((p, key) =&gt; { return isPlainObject(obj[key]) ? { ...p, [fn(key)]: deepMapKeys(obj[key], fn) } : { ...p, [fn(key)]: obj[key] }; }, {}); } 
I want to avoid using generators for now, seems to add a lot of excess stuff and I want to learn how to use grunt and jasmine from the ground up.
Destructuring assignment looks awesome, but I can see some issues with readability because of how much it blends in with other syntax. I like how PHP uses the [**list** construct](http://php.net/manual/en/function.list.php), but we all know how new keywords cause problems with legacy code.
* Fat arrow combined with `map`, `filter` and `reduce` means that I rarely have to write out an old school loop. * Template strings, not for the templates but for their multiline capabilities. * Class syntax makes class stuff *so* much easier to read. 
I haven't found any uses for spread but I think that is just because I don't fully understand what it can do and what the tricks are. I didn't know you could expand objects with keys using it. 
I was kind of laughing as he described what my team and I have done for the last year and a half while describing them as predictions
You are right. This decorators works also for any method which returns promise.
I wish they would have taken the ruby/coffeescript style. The backticks don't highlight correctly in vim and I'm too lazy to fix it.
Shorthand property/method names are pretty handy.
Didn't you read the OP, you only get to pick one.
This one is awesome! I've seen it a number of times, but keep forgetting about it due to programming in coffeescript day-to-day where I still can't use it.
Ye i have no idea why some people are against class syntax, i love how clean it is!
If we're including things that have been polyfilled / came from a library for a long time and don't really feel ES6 specific anymore, then definitely `Promise`. For stuff that actually feels new, the combination of `destructuring` and `rest`/`spread` really cleans up a lot of repetitive code. Arrow functions are a very close second.
Fortunately, when actually developing software, you get to pick _more_ than one.
+1 I love that Ember CLI has been pushing ES6 2015 and babel so hard.
A lot more people want to uses classes of some form in their JS code though. I'm just glad that see now have a standard syntax and semantics instead of mass incompatibility. 
A fun talk. JSConf Budapest is slowly but steadily uploading talk videos [here](https://www.youtube.com/channel/UCCjbi45K7abWuGGm2yfDg5w/videos), and they all have links to slides in their descriptions :)
I do believe her posts are a form of satire. That same comment, if you haven't noticed, is by the author.
It's the best. I adore ember so much.
This is pretty awesome. Is there a way to use ES6 in the console? Edit: Also, is there a way to run the code without pressing 'Run'? A lot of these sorts of tools allow you to run the code with `cmd-enter`, for example.
Hi, I'm the author of functional-react. Based on what I know of Om (which is far from comprehensive), Om is really cool, but I think it requires you to use ClojureScript. It also has stronger opinions about data structures than vanilla React, I believe. I think an approach like functional-react might make more sense than Om if you want to stick with plain JavaScript, if you are gradually porting an existing React project component-by-component, or if you want to use mutable data. That being said: Om is really cool, and it's much, much more aggressively functional than functional-react, which is just the slightest dusting of functional sugar on top of vanilla React. If you want to use Om, you totally should!
I found a solution. Looking at this: http://maxogden.com/node-repl.html. It is possible by simply adding: ;(function () { var repl = require('repl') var os = require('os') var empty = '(' + os.EOL + ')' repl.start({ prompt: "&gt; ", eval: function (cmd, context, filename, callback) { if (cmd === empty) return callback() var result = eval(cmd) callback(null, result) } }) })(); wherever you want the test to stop. It's a lot of code but doing it this way you have access the scope of the function you are testing.
 setInterval(function () { var all = $('#parentdiv').find('img'); var random = Math.floor(Math.random()*all.length) var Rimg = $( all[random] ) var randomurls = [ 'http://fpoimg.com/50x50', 'http://fpoimg.com/150x150', 'http://fpoimg.com/40x100', 'http://fpoimg.com/70x50', 'http://fpoimg.com/100x50', 'http://fpoimg.com/100x100'] var oneurl = randomurls[Math.floor(Math.random()*randomurls.length)] Rimg.attr('src', oneurl) }, 100) youll probably have to change the #parentDiv and img selectors to work for you, and increase the interval to something like 1000 https://jsfiddle.net/q7vggxyo/
Spread is convenient for QSA, for example. [].forEach.call(document.querySelectorAll('.md'), function(e) { ... }); vs [...document.querySelectorAll('.md')].forEach(function(e) { ... }); or [...document.querySelectorAll('.md')].forEach(e =&gt; { ... }); String to char array: &gt; [...'foobar'] ["f", "o", "o", "b", "a", "r"] Pushing all the values: &gt; var a = [1, 2, 3], b = [4, 5, 6] undefined &gt; a.push(...b) 6 &gt; a [1, 2, 3, 4, 5, 6] So, in this case, it's like `a.push(4, 5, 6)`. Similar use case: &gt; var v = [3, 4, 2, 5, 1] undefined &gt; Math.max(...v) 5 Certainly more convenient than having to use apply: &gt; Math.max.apply(null, v) 5
The biggest improvements are classes and modules, because these add standardized declarative structure which is accessible to tooling. I also really like let/const and fat arrows, because block scope and lexical scoping are much easier to deal with. Fat arrows are also more convenient to type.
Yahoooooo!! Thank you!! This is great. It's the first time I have seen the images change. Awesome! It's been driving me loco for the last couple of days. Is there anyway to get the images to change once and stick to the image they change to? At the moment the images keep changing I guess at every interval. Also with the randomurls, if they files are called random1.jpg, random2.jpg...random33.jpg etc. Is there a way to choose an image at random with one line of code rather than listing all 33 images? I was thinking something like: $imgrand = rand(1,33);... ...'http://localhost:8888/wp-content/uploads/2015/random'.$imgrand.'.jpg') Thanks again
Setting default values for options is a good example: var options = { foo: 'bar', ...overrides } options.foo will be "bar" if not specified in `overrides`. Generally everywhere you'd use an "extend" method via iteration (or Object.assign with ES6) you can use object spread. 
change these 2 lines var all = $('.parentdiv').find('img').not('.easter') // replace the old line wih this and var r = 1+Math.floor(Math.random()*33) Rimg.attr('src', 'http:// ... ' +r+ '.jpg').addClass('easter') 
So cool! this works awesomely! You have already done so much, I am going to work out how to get the images to cross dissolve rather than flick to the new image. Or is this not even possible? I don't need need for it to happen, just think it will be funnier.... Thanks mate !
I'm using immutable with regular React right now, and would never go back to regular js objects. The performance benefits and debugging improvements are huge. Does functional-react work with immutablejs?
yea theres probably a jquery plugin for that =] idk how hard that is tho. adding a css would be easiest. you migh wanna check animate.css out https://daneden.github.io/animate.css/ this would be a bit easier, just add two classes "animate flipinX" (not sure if its animate or animated) gl
whats the latest on es6 browser support? also, for the people using it, are you transpiling or using shims?
Fat-arrow syntax is great, but I've been using it for 1.5 years already, so I'm pretty used to it. Destructuring and object shorthand notation is also great. You can e.g. return multiple values from a function with return { foo, bar } and then assign them with const { foo, bar } = getFooBar();
Destructuring is also probably my favorite, though fat arrow is also great. I didn't think about using it like you said, which I could have totally used yesterday! Good tip. I found it super useful when using functions that take in an options array, like function (name, { key, kind, type }) which eliminated a lot of the boilerplate code at the top of the function to pull those out.
&gt; lambda functions I'd call them 'arrow functions'. It's a cleaner syntax for functions but they're not closer to the idea of 'lambda' than the functions JS already had (which were still pretty close). You can still declare the old style inline/anonymously. The term makes more sense in Java, where the notation `(a) -&gt; a+1` is way different from anything we had before.
Most of the features are only available in transpilers. Complete list: http://kangax.github.io/compat-table/es6/
That was a waste of time 
Transpiling; babel is awesome, and at this point, I feel like you basically have to have a build step for any meaningful project, so it's essentially free. I mean, I was going to run my code through webpack anyhow... 
woah! super impressed you just typed that out on your phone. I did get the images to change using what is above, but still interested in your code. is there a way to adapt this code so that it can change the images back to their original image? at the moment I am just reloading the page, which isn't ideal. thanks
A ridiculous statement to make, especially when referring to a post like that. The performance of an actual app depends on a lot more than how repeated elements are rendered. 
One of a big issue with micro benchmarks like this is that when you are writing TodoMVC for a benchmark, it is simple enough that you can write your code such that it will basically output the optimal dom mutations and you are measuring the overhead of the framework assuming perfect code. Now, in practice, you can't write perfectly optimized code on a large codebase. So, you want many properties: 1) If you write naive code, the code will be reasonably fast 2) There are tools to let you find bottlenecks 3) Optimizing those bottlenecks doesn't require you to make fundamental changes the way the code is written React has been designed with those 3 use cases in mind. Many people switched from Angular 1 to React because it didn't meet 1 and 3. Writing naive code would lead you to severe performance issues and the way to solve them is to stop using Angular features. Elm, Om and Mercury are based on immutable data structures. So, you get that very good performance by default at the cost of having to write your application in a very different way that introduces many real challenges. So they put the burden on the developer to write optimized code for the entire application. Depending on the type of application you are building, you want to use libraries that give you different trade-offs.
Arrow functions save lives.
 Var x =document.querySelectorAll("img"); Var old = []; for(var i=0; i&lt;x.length;i++){ if(x[i].src.match(/420xautos/)!=null){ old.push(x[i].src); x[i].src = "random"+Math.floor(Math.random()*32+1); } } //this restores old images for(var i=0;i&lt;x.length;i++){ if(x[i].src.match(/420xautos/)!=null){ x[i].src= old[i]; } } again should work but can't test. I'm glad you liked my solution:) Edit. I'm really annoyed how reddit doesn't add my linebreaks when writing with phone:/ Edit2. Was missing ; after old.push()
Thanks, this guy has some interesting stuff to say. His "Invent the future, don't recreate the past" talk was very cool
I tried to use and understand this but I cant seem to get it to work. I think it may be to do with: scr.match(/420xautos/)... The 420xautos is part of the file name and not a directory. The images are all called something like: 420xautos_COMP_xxxxxxxxxx.jpg, 420xautos_DIR_xxxxxxxxxx.jpg, etc... Could this be where the problem lies?
while most is sugar, promises really are the great great new feature in my opinion. 
Require is MORE expressive than import at least for the time being. Right now es6 imports don't support asynchronous requires, which is a huge missing feature. Import is also a language construct, not a regular function like require, so you can't mix imports with higher order functions.
Only *YOU* can prevent callbacks!
what is a "co-routine" -- I heard some js expert mention this the other day. Wasn't familiar with the term. 
Shouldn't be, no. Check the generated js
Proxies and arrow functions for me. Both result in material improvements in code readability.
The modularity alone makes it worth it imo. 
you should list babel instead of those other libraries and `fetch` instead for ajax.
I don't see any reason to use this over moment.js
I could go either way myself. Not everyone agrees on this approach.
 Does this work??? Apparently it does work on mobile aswell
Love how the JavaScript community seems to universally hate CoffeeScript, yet over half of the responses in this thread cite the arrow function syntax as one of the best features.
SO, you replaced a lot of extensions WITH gulp? This is relevant to my interests - care to share what you have automated using gulp?
Yes! And especially with how they can be used with functions! Few people seem to ever notice they can do more than just concatenate strings and variables. Here's a [small tool of mine](https://www.npmjs.com/package/auto-html) that uses template strings for automatic html encoding for a good example of what template strings can be used for.
Arrow functions are just like regular functions, except `this` is lexically scoped. There's nothing different with how stack traces work with them.
The spread operator and it work together nicely! function logStuff(...args) { console.log('stuff:', ...args); } 
i would make an animated png (if there is such a thing, i know ive seen one on sublimetext.com) over a html5 video element
There's a reason that import is a language construct: all of the imports can be statically analyzed without needing to run the code. Build tools like Browserify rely on statically analyzing all of the dependencies of a project, and fail when `require` is used in clever ways. It's likely that ES6 minifiers will exist that work the same way and http2 webservers that statically analyze dependencies so they can figure out what other files to push to the client when the client requests the main javascript file.
i would encourage you to profile it yourself, there were some good articles on profiling mvc frameworks this year paretos principle says 90% of the bottlenecks will be in 10% of the code. you might be able to get huge gains from small refactorings. most of the code im proud of in the last 15 yrs was optimizing other peoples render() functions for speedups :D its a fun programming challenge ne way, and the chrome benchmark utils are great :)
I kinda agree. I find myself writing function() when I want to be explicit. I haven't had to debug something in a fat arrow function yet so I'm not sure how bad it is.
How do you use your proxies? any examples?:)
Class syntax and attribute getters/setters. Lovely to write JS that way.
A coroutine in javascript is a generator that yields promises. Here is an example: https://github.com/neurosnap/async-flow-control/blob/master/src/routes/index.js#L119 What it allows a developer to do is write code that looks synchronous -- the code progresses line-by-line -- but is actually asynchronous. It is able to do that because of the way generators break up a function into parts separated by each yield expression in the function. I think of generators like a switch statement where each case is defined by the code between yield expressions. Each yield (or case) only gets activated when the function's `.next()` method is called.
I think the use of examples leads to misleading code. What I mean is, what the code does is not readily apparent just from reading it. While I agree there are some formats with new Date() that are confusing, but if I see something like `format('mm/dd/yy)` then I have a reasonable expectation of what it's going to output. When I see it like `format('January')` and the comment shows it outputs `August` it's misleading. In fact, glancing over the code and seeing things like 'January' or 'March 05, 2015' is going to make me think those items are hard coded instead of coding by example. 
React has "propTypes" to define the interface, but I don't see it used in the example. Did it support it? I think it's a better idea to use that because you can actually have type information, as well as whether the prop is optional. 
It's faster and lighter than oh-my-zsh, so it really depends on your needs. 
I get that, but I'm still not convinced to move towards them. I mean, sure, they give you that awesome scope but it's not worth it if you already know how to preserve scope. function fnName(){}.bind(this) does more than ()=&gt;... Plus, I can never hit the "=" on the first time!
I prefer fn names but to each their own!
Fat arrow, destructuring, modules, `let`, and classes. My code is so much cleaner. 
I'm quite functional in my code (pinkie up!), however fat arrows still feel unnecessary so far! Not that they dont do what they do, but they feel forced in from coffeescript. I like CS, but native adoption is tricky. I write lots of scoped fns when it's dealing with nested code (obviously!) and that's the only time I need stack tracing. It's a catch-22. PS: `=` symbol is hard to get right in text editor. I end up with `+` every single time!
Very much worth a watch!
HTML and XML are pretty much the same things if you're using them to define your layouts and elements. Plus, XAML is a lot of fun once you learn it.
I wouldn't quite consider Babel.js a library so much as a build tool - I did link to it within the same section, though! I've never used fetch. Have you got a link?
fetch is a library that follows the spec. native fetch is coming. - https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API - https://github.com/github/fetch The reason you use babel is so you don't need all those libraries you mention as a lot of them are no longer necessary with es6/7
^Javascript ^: ^Test-Driven ^Learning A project aimed to help the user master Javascript with a test-driven approach. Each unit contains an annotated tutorial on the code and the ability to run Unit Tests to verify the expected behavior. Topics: * Arrays * Bad Practices and Solutions * Booleans * Built-in Functions * Closure * Comparisons * Conditionals * Exceptions * Falsey Values * Function Expressions * Function Expressions as Parameters * Functions * General Performance * Hoisting * Logical Assignment * Loops * Namespaces * Numbers * Object Prototype * Objects * Objects Functionality * Prototypes * Strings * Switch Block * Ternary Conditionals * Truthy Values * Variables
I'm in Northern VA (just outside of DC) and make right around the same. Full-time dev for ~3 years now. No college/university and have Govnt. Clearance
I don't think she meant that promises are sugar.
It all depends on the app/website you are creating as well. who cares if someone modifies an embedded client side template they are only screwing up there own view as the template is only creating views to render. As for accessing the JavaScript in the view before it renders, Everyone has access to javascript via the console anyway. Your not eval'ing the templates server side, your also checking the view-models and user Input (serverside) before persisting anything. Also your not letting the end user to save or modify any views. 
Sure, there are benefits to a language being less expressive. It makes them easier to statically analyze e.g. Go. However I still believe simple language constructs + libraries are better than complicated language constructs which can't be built upon.
The project is a good idea, but I think it'd work well as a companion to some written pages going through the course. "code as documentation" approaches may seem intuitive to you, but many beginners would have to be led into it with a helping hand.
I agree. You have to think in TDD.
Thank you for the reply :)
No prob! It's obvious you spent some time building it thus far. I think it could be useful.
Looks like the code sample right after "Libraries like Underscore use a version of tap that is “uncurried”" isn't right, should that `it` work? In the "array literals" section there seems to be some word jumbling in the description of the nested arrays: "...one element that is an array array with one element this an array with one element that is..." should be something like "...one element that is an array with one element that is an array with one element that is..." ?
So pitch me on Ember, I've been hearing a lot about it lately. I got deep into Angular + Browserify last year, which was OK. How does it compare? 
I personally like haskell, even for web projects. There are a lot of interesting developments like haste, or elm. But I don't understand the "humor" of this article.
you can use cookies, window.localStorage, ajax client &lt;-&gt; server, or an iframe. cookies: might not work because you might go off domain. cookie syntax sucks. might need to use it with iframe or frame also. window.localStorage: you can save as much data as you want here, data = {a:1,b:2}; window.localStorage['forrestqa'] = json.stringify (data);... but might need to use this with iframe also. i like this one, save the data every time it changes, then when complete, on submit you just send the value via ajax to your server and your done. ajax: probably also have to use an iframe. i wonder how optimizely does this their website is very well done my guess is youll have to use an iframe
Fluid APIs/DSLs (graph queries in my case) and multiple inheritance. 
I dunno, development is JS is a lot faster and flexible then C++. I would definitely be doing UI and behaviours in JS. I hope it's compatible with some node.js api's and can use NPM packages, that would unlock a crazy amount of libs.
Currently I only know of one other payment processor that allows you to use their system on your site. They use a Javascript processor that passes values to their own server but do not require login unless your email has already been registered. It is also is pretty expansive on customization. It is MUCH more secure to do processing on your end... Especially if the sites aren't using SSH.
The "solution" looks more complicated tio me than the problem. What the heck does "getInitialState" come from, and what is it for? Also, it could be lie. The button could be disabled inDOM, but: you assume it's not. The DOM button *has* a state. I see no need to cache it in a different layer, while the cached value could be wrong. Especially not if you have to manually add the cache layer. This feels so wrong. If this is how it is to work with React, then I don't want React.
I'm curious. Can you quickly show or explain?
Hey there! The reasons are just uncountable, but let me give you a brief why I love it. I've built production applications in several major frameworks - Knockout, Backbone, EXT, Angular, and Ember - and while all of them seem to be working towards a Rapid Development ideal, Ember seems to me to be the only one that has allowed an entire team of developers to develop rapidly on the front-end. This is mainly due to Ember being very very strict on *convention* over configuration. The first time I tried out Ember, I decided I liked all the observers and events and stuff, but I kinda liked doing things my own way becasue that's what I was used to in other frameworks. I didn't want to spend the time learning Ember convention and just go with what I knew. And so I went right around the resolver, router, etc, and just did my own thing, and had no idea how wrong I was because it was a similar experience to all the other frameworks I'd used previously. The second time I used it (in my current job), I decided to do everything the ember way and see how far I could get. I used the CLI, used all the directory conventions, naming conventions, did everything the Ember way. And the more I learned Ember convention, the more rapid development became. Especially when other devs joined the team, and we all did things the Ember way. Because we didn't have to come up with our own conventions, we saved heaps of time. And everyone was on the same page. It allowed us to very easily get into sync, and write code like one developer instead of 5. And our code is very readable! Outsiders can read and understand our code relatively easily. The learning curve is pretty damn steep, especially for those without Ruby/Rails experience (Ember's philosophy takes after Rails), but I tell you what, after being spoiled by the full Ember experience, I will never go back to the old way willingly. I'm addicted.
Here's a tutorial that should help: http://tutorialzine.com/2011/03/photography-portfolio-shutter-effect/
Debounce is a timeout function that you can wrap around other functions that will reset a timer each time you click. When the timer runs out the last function is executed. So if you set debounce to 1000ms and a user clicks login multiple times (within 1000ms) only the last click will be executed. For what was described in the blog post I wouldn't use debounce though since it has a required delay and you still can have multiple requests.
If you're gonna do a code screencast, you need to upload it to youtube at much higher def than 480
I agree, the button should be disabled until the promise is resolved for a better user experience. I thought it would be useful to mention debounce as well, it does come in handy at times.
Both fixed, thanks! 
The first one is kind of dated, though. https://gist.github.com/yukimono/b5bb3e5668629399fa6a
Tested it a bit, I love it!
What is the advantage over webpack-dev-server if used w/ webpack (with hotloading enabled obv)?
The semi-colon *sometimes* technique. https://github.com/github/fetch/blob/master/fetch.js
console redirection, read-eval-print-loop, etc.
&gt; Whenever I see Google Chrome as a requirement I think 'no thanks'. Chrome is not a requirement. It's using V8, the same library as Chrome. 
Why? Please don't do this. Make the functions take an array instead rather than modifying built-ins. Yes, the functions are useful but not at the cost of breaking things.
I definitely recommend the CodeSchool courses. I'm just finishing up the Best Practices course. 
does this help? https://jsfiddle.net/w7opptar/ I removed some of the bits I dont think would work on jsfiddle. See I cant get the images to change even to the same one. Thanks
If we're talking about tools that package a development or production build of code, then Webpack is not far off from grunt/gulp. Webpack does have plugins that modify the build in similar ways that gulp/grunt would (i.e. babel/typescript, sourcemaps, uglify, banner, less/scss -&gt; css, html-min). Instead of an explicit build configuration, the dependencies in code produce an optimal bundle. There are other types of things Webpack doesn't do, such as `bump` your package/bower files, or initiate test suite runners. Browserify is playing catch up to Webpack because of these features, even though it's likely more popular.
For comparison, you can see that this example works. I just cant work out how to change the images back to what they were before. https://jsfiddle.net/q7vggxyo/40/ 
Gulp is incredible. I didn't use Grunt but looking at how it worked, it seemed much more complex to get into then Gulp
I didn't even know about this! Have you never had an occasion where you had to write code like the following? : var someObject = {} someObject['aprefix' +someId] = someValue; Simply because object property names cannot be computed? I've absolutely hated this for the entirety of the time I've written Javascript and I'm old as hell at this point. I can't believe I missed this. It makes 2015 for me! I hope I'm not misunderstanding or it will be like learning Santa isn't real for me. 
Html 5 &amp; javascript can do many of the things for which Flash was historically used (i.e., playing video or sound, as well as the complex graphics used for games.) Flash was used because the core technologies (Html/Javascript) did not yet make these things possible. Nowadays, I would consider it a bad decision to develop something in Flash, because fewer and fewer clients are going to be supporting it. e: fixed "Nowadays"
What is going on in
Not seeing the value prop over webpack
The big thing for me was no need for HTML and CSS. Just a bunch of classes derived from display object that were easy to manipulate and draw on screen. Closest I've seen I'm terms of ease of use thus far is pixijs but still - action script was what js should have been and I'll miss i still miss it dearly :) 
In terms of workflow you can follow a similar approach in JS using CreateJS and the Flash IDE. What made the IDEs (FlashBuilder, FlashDevelop) better for ActionScript is that ActionScript is a strongly typed language which makes things like function renaming, syntax checking and finding references to functions and properties much easier and more robust.
At it's core `webpack/browserify` are module bundlers and `grunt/gulp` are task runners. You can have `webpack/browserify` in `grunt/gulp` but not the other way around.
Highly recommended. Your way of explaining the methodology and not just throwing some code on the projector was brilliant. :) Was just wondering, you mention another guy talking about error handling. Is this it? https://www.youtube.com/watch?v=a8W5VVGO-jA
Do you need help with the math or with understanding how this works?
1. Well you have `a` that starts off at 8 2. You then increase the value of `a` by 4 3. The `if` check tries to see if `a` is now larger than `10` 4. It should be (12) so the code enters the block inside `{…}` 5. `a` is now assigned with the value 2. `a` is `2` And yes, this is valid JavaScript. 
Not seeing the comparison either
Woah yah that definitely works! I'd actually thought that maybe I wasn't calling the function, right before you replied. So good to know I am not a complete moron haha. I am trying to get it to work now where the events are triggered when a certain drop down value is selected. But I really don't know enough about the structure of functions, how, when and where they should be called. If my html is set up like so: &lt;div&gt; &lt;span class="foo"&gt; &lt;select name="foofoo"&gt; &lt;option value=""&gt;---&lt;/option&gt; &lt;option value="change images"&gt;change images&lt;/option&gt; &lt;option value="change images back"&gt;change images back&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;div id="parentdiv"&gt; &lt;img src="http://s9.postimg.org/j8lccpfz3/image1.jpg" alt=""&gt; &lt;img src="http://s9.postimg.org/nj008al27/image2.jpg" alt=""&gt; &lt;img src="http://s9.postimg.org/ywmjjhvkv/image3.jpg" alt=""&gt; &lt;/div&gt; Then I know I need to include something like: $(".foo").change(function () { if ($("select[name='foofoo']").val() == "change images") { // change images }else{ // change images back } But whenever I add the functions you made to this, then it doesn't seem to work. I know it will be something to do with the order in which I am calling and doing things. Also in your jsfiddle, all the images change together at the same interval, whereas I would like to have their change staggered slightly. Thanks for all your help mate x
&gt; However does that have any implications on the end running environment? Do we have a situation like Java runtime environment client needed to run Java? Not exactly. The V8 engine is actually very well optimized, so it doesn't add much in the way of overhead, nothing like Java at least. The reason V8 was chosen is because of the fact that a) it's open sourced and b) its very fast, compiling and optimizing as it goes, and c) JS is a language that many of us have grown to know and love. Generally speaking though, the implementation is setup to minimize the amount of work needed to move between the two memory spaces. It is also key to note that while the library is currently targeting UE4, it is not necessary for flathead to be bound to UE4, or anything else for that matter. with some tweaks to the library you would be able to hook it into a text editor, a torrenting application or whatever application you would like to work with. The only thing the library does is abstract the internals of V8 away by providing a simple API to move between C++ and JS. 
Speaking as a former Flash developer, it's hard to speak in absolutes. A lot of the frustrations people have with JavaScript is that the old beginner-friendly features tend to interfere with more complex applications. However, once you follow some best practices, that's not really much of an issue. On the other hand, with the Flash environment, it was more distinct. Beginners could use movieclips, the stage, and the timeline. More advanced developers could almost exclusively use straightforward, OOP code. However, this also had issues IMO because mixing these two turned into an even bigger mess than what JavaScript is today. Flash was a single platform that was targeted at a HUGE spectrum of users and platforms, and ultimately I feel that led to its demise. Imagine if a good half of Java use cases were for animation, and how that might transform the product.
My point was, with Webpack you don't really need gulp/grunt because the majority of tasks compose code bases into a bundle anyway (concat/sourcemap/uglify/less/scss). If you need tasks that run tests/coverage/perf suites, there's nothing stopping you from directly invoking those or having `scripts` in your npm package.json configuration. tl;dr, it is possible to replace gulp/grunt with just NPM and Webpack.
My pleasure! Ember is reasonable for smaller apps, although it is really designed for "ambitious" applications. I've used it in both! Depending on how small it is, the filesize might be a bit overkill. In terms of good beginner resources, I personally bought this book to give to my team to read: https://leanpub.com/ember-cli-101 (it's $25, but brand new and well worth it if you're ready to commit). This is probably the most well-regarded beginner resource at the moment. A lot of blogs out there will also be helpful in a variety of ways, however you've got to be a bit cautious because Ember has recently been updating at a very fast pace, and the new Ember CLI workflow is a bit different, however the concepts are mostly still the same (convention over config etc) I'll see if I can find some more specifics for you and will follow-up soon!
Yup. I just wanted to state the distinction between them since I've seen many people use both to do the same task (ludicrous). Btw, if you're using just webpack as your bundling tool then you're doing everything from `npm scripts` anyway. 
Thank you :)
I started on the same idea, then realized what damage this could do... oh man I hope nobody in my team sees that.
Goddamn that's annoying to look at. Bah.
https://jsfiddle.net/qdme21cf/19/ Here's a fixed version with rolling image change. The select doesn't work on jsfiddle but i made a test html for it and it worked. Just add the script between script tags in head and remove the randomImg() and setTimeout(restoreImg, 5000) from the end, they are there just to demonstrate the rolling change with jsfiddle.
Thanks for the insight! I wonder how optimizely does it as well.
So jquery.ajax is finally going native? Thank God
If you're writing isomorphic apps—or just like using the same API on the client and the server—check out [Isomorphic Fetch](https://github.com/matthew-andrews/isomorphic-fetch), a light wrapper around the polyfill that lets you use it via node, webpack, browserify, bower, etc.
Thank you. It does help. I'll get back to this after I finish what I'm working on. For now I'm just gonna limit the file upload and check with php.
There's still a lot of stuff action script does that js can't such as cross-browser compatability, networking, static typing, and bytecode, but overall browsers improved a lot and became a better platform.
thats really cool. what data are you actually sending over the websockets between server and clients each frame?
Maybe you wouldn't have noticed if I didn't say anything... But to me it's like, https://imgur.com/M52a91q
Finally, theoretically they can be layered together
Flash's biggest advantage was how weak the web was in those days. HTML and CSS couldn't do a lot: * Font support was local client only. If a font is not on the user machine it cannot be used * Very limited layout support. Table-based layout was a monstrosity, but it was the best we had. * No real support for animation. It was possible but clunky in JS, but not really very powerful. You certainly couldn't rotate elements, for example. * Inconsistent to nonexistan support for audio and video * Inconsistent JS support So if you wanted to put a game or a more interesting UI on the web, your choices were Java (powerful but clunky to work with) and Flash. Both of these were essentially sandboxes dropped into the middle of the page, and both were self-contained virtual machines. While Java was (and still is) extremely powerful, it is also pretty awkward for beginners to work with. At one point Java Applets were a good way to embed content, but it was difficult to work with and persistant security and memory issues made Java less attractive. Now most browsers block Java applets by default, and iOS does not support Java at all, so it is less relevant on the client end. (Java is very much alive and well on the server.) Flash was very attractive to those who wanted to build animations and clever user interfaces. It supported audio and video, had a robust animation system with a timeline, layers, and motion tweening system. But what really made Flas popular was games. Almost all of the early web-based games were written in Flash, because it was relatively easy and reasonably powerful. But Flash wasn't originally designed as a programming or game development environment, so you kind of had to subvert the animation mechanism to build games. Still, it was far better than anything else out there at the time. (I wrote a Dummies book on developing games in Flash.) Flash was really plagued with a lot of the same problems as Java as it became more popular. The newer more powerful version of ActionScript became almost as complex as Java (as it needed to be for more serious programming) alienating those who preferred the simpler environment. Memory leaks and security issues proliferated, causing numerous security problems. Meanwhile HTML5 (which is really more about CSS3 and enhanced JavaScript) was forming. This system pretty much resolved all of the issues that made Flash necessary. Modern browsers support custom fonts, flexible layouts, animation, dynamic rotation of elements, audio and video natively without a plugin like Flash. And the recent improvements in JavaScript are very impressive. JavaScript is an odd little language, but its performance is becoming far less of an issue, and the capabilities are excellent. JavaScript and ActionScript were always cousins, so the differences between them are not difficult to manage. The canvas tag in HTML5 does pretty much everything you could do in Flash visually. You work with it a bit more closely than you did with Flash (for example, there's nothing like a Movie Clip) but there are many libraries (including one I wrote) that create Movie Clip-like objects, and they actually work better than the old movie clips in a lot of ways. I re-wrote that old Flash gaming book in HTML5 and I truly don't feel like I lost anything. I haven't even had a copy of Flash for the last few years. (Makes it awkward when people ask questions about that old book.) tl;dr: Flash did a great job solving problems that are no longer there.
The client maintains a queue of attempts (so multiple tries between syncs 'stack'). Each attempt has an id, a 'diff' which contains the dependents of the state change, and a 'patch' which contains the state change itself. The server iterates through all attempts, and applies them until one fails (or they all succeed). Then it returns the id of the most recent successful attempt to the client so it can update its own state and retry accordingly, and sends the updated state to all other clients.
Thanks mariuz! Did not expect this, but thank you very much for the praise =) 
Mono-UE is a great stepping off point, but as it was retired its not exactly the greatest place to be building a game. What Flathead is bringing to the table is a tool that helps people that are not formally trained in all of the mannerisms and idioms of C++ that want to work with UE4 but don't like the insanity of true spaghetti code (blueprint). There are many issues that JS has, but there are also many programmers that find it fun and enjoyable to work with. 
Not only is this super-verbose, it creates a whole new one-length array every time, then just tosses it to the garbage collecter. Might as well do arr[arr.length - 1];
very cool. if i have my mvc setup so my state is just one object i can just send the whole object to checkerboard and it will diff it and send it to the server?
Problem being, it isn't the truth. Yes, classes are in es6, but they are just wrappers over prototypes. Es6 continues to leverage prototypal inheritance.
I'm
Fantastic! Thanks again mate. This has got me really interested in Ember for my next largish app. I may bug you again in the future ;)
http://stackoverflow.com/q/27259557/1397319
This was a really well written and insightful response! Learning ActionScript was fun for me. I liked its strong typing and classes, etc. and it's nice to see us getting some of that with ES6. I too haven't owned Flash in ages. Isn't it still used for animation though right? I thought I heard of some TV shows using it that way.
 does it rebuild a canvas or svg structure of a different size on resizing? its probably that... you could profile it and check. or set resize option to false and check.
Very neat, though to be a complete and total pedant, this is a library of list processing tools. It's missing a generator type. Of course, javascript itself isn't helping, but this kind of generator is whats missing from most of these functional libraries: let generate = (list) =&gt; { let helper = (i) =&gt; { if (i&lt;list.length) { return () =&gt; [list[i], helper(i+1)]; } else { return () =&gt; null; } } return helper(0); } The exact structure, semantics, return value etc are a matter for debate, but essentially a functional generator returns a value from a list, and the means to get the next value. While it sounds tedious, the point of it is referential transparency of the input values, i.e. a generator that isn't exhausted on it's first usage. Things like a range(number) function for generating the infinitely long list is the canonical example here. I'm waxing academically here. Doing full functional javascript in this style would be a mess and why nobody wants to do it. OP's link is cool. 
Flash was killed by Steve Jobs over licensing. At a key point in iphone dominance over mobile, they removed support. Apple and Google both backed open standards. But Jobs really turned it into a media campaign. And since managers around the world doded on Jobs every word, this anti Flash idea spread through corporate leadership with very little tecnical insight but got pushed as policy into IT departments. Who embraced the trend in their race to get budget for mobile development, nodding along. It turned Flash into a pariah basically overnight. Flash kicks ass for animation. It is an amazing IDE. And Actionscript is a great language. There are unique problems with Flash also, which im guessing will be brought up elsewhere in this thread.
I see a lot of high praise for flash in this thread and I want to counter balance that. Flash was a closed binary blob that a single company distributed, typically with additional antivirus or toolbar software, and tightly controlled the developer ecosystem around it. The plugin was prone to crashes, a mess of security flaws, and a mostly inconsistent user experience between websites. This transitional phase is a bit painful, yes, but we are better off now that it's influence over the web is coming to an end.
Thank you for taking a look at the project, I really appreciate that, here are some first steps: Using the terminal: * Go to the Learn Javascript folder (the second one) * npm install (this is the first and only time you will use this, it should update and install all the dependencies) * bower install (this is the first and only time you will use this, it should update and install all the dependencies) * If there are errors, go one level before the folder structure and try again * Grunt test (this runs all the tests, you should see the 149 passing tests on your console) * (extra, hopefully not needed) The karma config may give you some errors, you just need to adjust the config to match your local structure You can just start with the easy topics (functions, arrays, etc) or topics you don't know, and read the code, understand it, change it, add more cases, and then you can run the tests again and they should still pass, they are ordered alphabetically, not by level of difficulty, perhaps I should change that. I am very interested to find examples that I have missed that should be considered ‘core’ or ‘basic’, so please let me know if you see something like that. Also, feel free to send pull requests, or if you want to take a deep dive, I don’t mind adding you as a collaborator.
Ah yeah that sounds about right.
Array.uniques() runs in O(n^(2)) time, but it can be implemented in O(n) time (expected).
Given their reason for retiring the project, how do you think that same situation will affect Flathead? http://lists.ximian.com/pipermail/mono-ue/2015-May/000324.html
I feel that Flash enjoyed a lot of power in those early days that then started to get sandboxed and curtailed so that the browsers were safer. Whenever Flash gave in for the browsers, the browsers may have just asked for another something in the follow up. So Flash had this idea of trying to become a supported web standard by compromising like that, until the browsers just asked for Flash as a whole to get out. :-) So what we are left with is not an exact replacement for the old Flash. The "new" standards are actually sandboxed and curtailed and it's an issue when trying to bring back some of the content that used to be hosted on the Flash plugin actually. Even more so since for now at least they may be enjoying fewer restrictions in their mobile deployments. These are strange times since developers don't get the feel of mobile on their desktops. The desktops may have to change, every screen may have to become a touch screen and so on, so that we are at least on common grounds. The trouble is that "old" content developed with an outdated mindset is still trying to find a new home in the mobile/browser duality. Just recompiling those old codebases into a new format doesn't look to be enough I'm afraid. Browsers may themselves have to compromise in order to welcome that old content back in.
One use-case might be something like: var year = "1/1/1970".split('/').last(); Which can't really be done without using an intermediate variable (unless you resort to regex or something).
It's more readable and terse. I use lodash's `.last` frequently for this reason.
I'd love to see that implementation if you could share.
about the only thing that flex got right was two way data binding. The markup combined the worst of xml and html, the stock ui controls were awkward and ugly, it took about 3x as much code to do something in flex as it took to do it in prototype and the data serialization was painful.
&gt;with very little tecnical insight you ever try to use a flash site on an old android phone (i think it was like 2.2 or 2.4)? if it worked at all, it would be slow, unresponsive and suck the battery life (worse than normal android operation). whatever you feel about the media around flash dying, there was technical merit to ditching it. i know it's easy to explain things you don't agree with as everyone else being a gullible moron but it's hardly helpful or based in reality
I'd been using hubot and extending it from there, but this could be real fun.
ELI5: why do we need this implementation when ES6 has promises built in natively?
I can't agree.... MXML is just XML, even if it is name-spaced and the convention was camel case tags. The out-of-the-box element library is **still** much larger than HTML and everything could be styled with CSS, or even as attributes. Shit, you got really descent charting/grid libraries for free, and this was 2004. There is a lot to be said about static languages within teams. Either way, code and markup was shared in the same file, so it enforced the single purpose responsibility. Some of the "directives" you could make, were animated, slick and really appealing. Why do you think most DVR interfaces still use ActionScript? JSON parsing and web services were a hell of a lot easier than XMLHttpRequest, which didn't even show up till 2005. jQuery didn't even come along till 2006 to make that point less of a pain. Browser compatibility was basically a non-issue, at least for the developer. Once it was announced that HTML 5 would support video, everyone pretty much jumped ship. To me, ActionScript was wayyyy ahead of it's time. Instead of 1 company leading the way, you now have a gigantic community governing the future of web technology, everyone with their own opinions. Things are chugging along much slower, and we're still adopting ideas that Flex/ActionScript had years ago...
Maybe, but ES6 generators aren't what I was talking about. I'm not sure what you would have to do to them to make them referntial transparent, or if that's even possible. 
This is a good intro to Promises, but the code should not be used in projects. It is not spec compliant with ES6 Promises. You will find issues when transitioning to native Promises. Choose an A+ compliant Promise library. https://github.com/petkaantonov/bluebird https://github.com/taylorhakes/promise-polyfill
I'll make it a bit more readable below, and I wonder whether you're using jQuery and whether you meant to make all of those global variables (or maybe they were defined somewhere else in your code): function round(num, dec) { 'use strict'; return (Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec)).toFixed(dec); } function start() { 'use strict'; $(function () { var loan_amount = +document.getElementById('loan_amount').value || 500; var interest_rate = +document.getElementById('interest_rate').value || 1; var loan_term = +document.getElementById('loan_term').value || 10; var i = interest_rate / 100; var months = loan_term * 12; var monthly_payment = loan_amount * (i / 12) * Math.pow((1 + i / 12), months) / (Math.pow((1 + i / 12), months) - 1 ); var line_chart_data = []; var bar_chart_data = []; var current_balance = loan_amount; var y = 2014; var year_end_number = y + loan_term + 1; var month_number = 0; var month_end_number = (loan_term * 12) + 1; var monthly_interest_rate = i / 12; while (y &lt; year_end_number) { var m = 1; y++; while ((m &lt; 13) &amp;&amp; (month_number &lt; month_end_number )) { line_chart_data.push({month: y + '-' + m, item1: round(current_balance, 0)}); bar_chart_data.push({y: y, a: round(current_balance, 0)}); current_balance = current_balance - monthly_payment + (current_balance * monthly_interest_rate); month_number++; m++; } } //LINE CHART var line = new Morris.Line({ element: 'line-chart', resize: true, data: line_chart_data, xkey: 'month', ykeys: ['item1'], labels: ['Balance'], lineColors: ['#efefef'], lineWidth: 2, hideHover: 'auto', gridTextColor: "#fff", gridStrokeWidth: 0.4, pointSize: 0, pointStrokeColors: ["#efefef"], gridLineColor: "#efefef", gridTextFamily: "Open Sans", gridTextSize: 10 }); //BAR CHART var bar = new Morris.Bar({ element: 'bar-chart', resize: true, data: bar_chart_data, barColors: ['#efefef'], xkey: 'y', ykeys: ['a'], labels: ['CPU'], gridTextColor: "#fff", gridLineColor: "#efefef", hideHover: 'auto' }); }); } Now I know that wrapping a function expression in the `$()` function-call is a proxy for `jQuery(document).ready()` and at the core you could just add a `DOMContentLoaded` event listener: http://youmightnotneedjquery.com/#ready (The simplest way is `document.addEventListener('DOMContentLoaded', start, false);` but the link above has code that works even in IE8). Also, you could make that inner function your `start` function and add listeners for multiple events, like `DOMContentLoaded` and `submit` (presuming those input fields are part of a form). Other than that, your code looks like it has no glaring inefficiencies; it sets up all the data before calling the constructors for the Morris chart, thereby minimizing the number of DOM operations needed, and like /u/mc_hammerd my best performance guess is that setting `resize` to `true` is the culprit.
Had totally forgotten about that. So easy to navigate through data.
Sir, we went through all this before. Its done. And i stand by the statements that corporate leadership has limited technical insight, dev community is more complicated and that Jobs was transformative. All graphical engines are battery and resource intense. And i agree Flash has unique issues. We could list them. I assumed someone had. Cheers.
Please read the spec. At the very minimum, `.then` should accept a success **and error handler**, and should **return a new promise**. As it stands there is absolutely no way to handle errors, and I am able to mutate an existing promise by adding new callbacks to its queue. This is bad news. Promises are not just syntactic sugar. Here's a really useful resource for you: https://gist.github.com/domenic/3889970
Very good point, the ES-6 generators are referentially opaque Why? Because copying Python, that’s why.
The [accompanying blogpost](http://www.graememcc.co.uk/onfunkier.html) - particularly its closing paragraphs - contains some important detail on why this release isn't quite as feature-complete as I'd like.
So will this also upload the resized image? Or is it just showing it to me rezised? The stackoverflow examples and articles I saw weren't this simple. There are problems with image quality and I also read about some IOS bugs ... that is why I don't really want to start working on this just yet. 
Although if the array is being discarded anyway, `pop()` might serve just as well.
To a degree you are likely correct. But just keep in mind that your browser is not likely to have the same build of v8 that your game is and there may be differences in the API
Mithril's render does generate DOM (maybe it didn't at the time you posted this): https://lhorie.github.io/mithril/mithril.render.html
&gt; What was there before angular? Nothing popular, just one-off experiments, I'm pretty sure. Client-side MVC/MVVM/MV* frameworks evolved as client-side rendering of UI started to be used. There was nothing before because UI was rendered on the server. Ruby on Rails popularized MVC on the backend in ~2006 (note that I said *popularized* and not invented) and people were all about server-side UI rendering at that time, so JS frameworks were more concerned with cross-browser compatibility, improving DOM APIs, animations, making AJAX easier, etc. Fast forward to ~2010 when Twitter and other big names started to release products using client-side rendering. It started to pickup steam and more and more products were released with client-side rendering in the 2010-2012 time frame, so frameworks like KnockoutJS and Backbone started coming out as adoption increased.
&gt; So far angular is the oldest of the ones I know of being first released in 2009 It was initially released as commercial product. When Misko Hevery realized that it is not easily sold, he started to use it at Google and pushed his managers to allow him to work on it. By the time it was really released as open source, Backbone.js was already being used in production by many companies. This head start allowed Backbone.js to get a big market share, some of it still hasn't migrated over to anything else. Before that, any more complicated UI was done as a native app.
I mean, create in-browser bindings to the Unreal Engine with the Emscripten API (the engine in your browser wouldn't matter): https://kripken.github.io/emscripten-site/docs/api_reference/index.html I've seen folks on the Unreal forums mention that they got scripting in their Unreal browser game by compiling the Lua interpreter to emscripten, which is a pretty slow way to do it. This way the JS would be running directly in the browser, not in an emscripten-compiled interpreter :D Although, doing this would take an insane amount of effort; it'd be like maintaining bindings to an entirely different JS engine at the same time as V8. IMO if you wanted to support additional JS engine bindings, the thing that would make the most financial sense is JavascriptCore for iPhone/iPad Unreal games, since you're not allowed to use V8 on iOS (because JITs aren't allowed)
ExtJS, YUI, qooxdoo, dojo, and many others came before. I think that we can separate the frameworks that came before jQuery and the ones that came after it. Before there was jQuery the frameworks tended to be more monolithic. Then all of a sudden with jQuery the frameworks started trying to reuse more jQuery code for their functionality and it complicated matters. ExtJS for example initially used jQuery but then dropped it. jQuery was itself kind of a UI framework. Only it was not clear what the components were. With jQuery the components got so intermingled with the DOM that encapsulation was poor. But jQuery provided anyone with a powerful JavaScript library, so that even those who were not programmers by trade could also use it to create UI with. After jQuery the newer frameworks had the responsibility of trying to appeal to anyone and everyone, but not many have achieved that goal. jQuery continues to be unique in that anyone can use it and that the minimum code required to start using it can be hard to beat by newer and bigger frameworks. More recently in the last 5 years we have seen newer frameworks directed at the Canvas and WebGL markets. These are completely breaking with the tradition of the DOM and are necessary because a lot of content does not fit the DOM well now that plugins have been deprecated so for example we need the Canvas and WebGL to play games. One of the downsides of DOM frameworks is that browser differences spoil the fun. A difference in how borders are calculated can cause a huge misalignment issue breaking UIs that tried to go against the text flow that is standard of HTML. Also Zoom In and Out can cause misalignment. I think that Google developed their own custom frameworks to create things like the Google Docs. Only they did not publish those frameworks for others to use. One of the things the Google developers may have done to try to extract more performance out of JavaScript and the DOM was to "fix" the standard implementations by coming up with their own new set of APIs which may have used more knowledge of internal working of the JavaScript engines and such. Also that reminds me that one thing I learned in YUI was that they would use a CSS file to reset all values like borders, font sizes etc so that the differences among the different browsers would also be reset. But that made the normal text flow completely borked without the proper spacing and so on. They did that so that the custom UI they would create would work well across browser versions. I hope I could show a little of the challenges that the frameworks have tried to solve.
Where there is a will, there is a way. https://code.google.com/p/v8/issues/detail?id=1312
How exactly does one end up going from gainfully employed and productive software engineer to full on homeless? I can't even begin to connect the dots as to how that could happen given the economic stability we enjoy in software.
Naah. it all started with backbone. There was JavascriptMVC which I believe was one of the first, but it didn't really become popular until backbone and ember, knockoutjs hit the scene, then shortly after angular....and now we have quite a few to choose from. I think it's great, each one learns from the previous frameworks and becomes better. In a few years I figure it will settle down after we go through another round of "next generation" frameworks leveraging es6/7. 
Around 10 years ago we had prototype with scriptaculous. I don't remember anything else going beyond being a lib. 
&gt; a comment which suggests that a JS interpreter would cast different types to one of their random common properties when subtracted from each other Eh. That's how JavaScript deals with these situations which would be type errors otherwise. You get a nonsense result instead of an error. The point was that getting a type error is preferred. Just like `typeof null` shouldn't be "object" or stepping outside some array's bounds shouldn't give you `undefined`. It's just one of JS' fuck-ups. Even Brendan Eich doesn't think that these things are super awesome. He also considers function scope to be one of the mistakes, by the way.
Yeah, it's HTML5 Game Programming for Dummies. I think it's still in book stores or Amazon. Even if you don't buy the book, all my code is available for free at http://www.aharrisbooks.net/h5g/ (The Flash stuff is there too if you're interested, but I haven't supported it for years.) I've also got a course on Udemy based on the HTML5 book. PM me if you're interested and I'll send you a significant discount code. 
Thats not JSON, its just an object... And please do not ever use `document.write`... If you want to talk about processing JSON, talk about how to turn an object into JSON, and how to parse the JSON you might get from a resource.
He shouldn't really, because it's misleading. It has nothing to do with JSON. It's just objects and arrays in javascript. He even uses `document.write`, which is really bad practice. If you want to learn about JSON, look up how to parse it, and how to turn javascript objects into JSON, so that you can send and retrieve it from a server, and actually make use of it.
My guess is that the array is too small for the faster algorithm to be of merit. If you make a test with a large array you'll start seeing benefits. Personally, I think that the limitation of the O(n) solution that array values can be stringified is not worth the performance gain. 
This is an important point. The format of a JSON stream, and of an Object or Array in Javascript are similar but not identical. This gets very painful if you start writing JSON files as if they're Javascript, because it can be very subtle in the differences - things like needing to use single quotes around keys and values, and where you can put commas. And there are things you can do in the Javascript version that you can't do in JSON - such as having Functions as values.
Variables are undefined until you define them, so in your example, you are trying to multiply two undefined variables and assigning it to `goldCount`. Also, it is often helpful to look at the console (Ctrl-Shift-J on Windows for Chrome or Firefox).
So what you're saying is that I have to define everything in the correct order for it to work? 
I'm pointing out that JS executes usually from top to bottom so you need to *set* everything in the right order. (Idiomatically, one *declares* all the variables at the top of the function to avoid some of the surprising behaviour of ``var``.) "Declaration" is the ``var foo`` bit, "assignment" or "setting" is the ``foo = ...`` bit. JS lets you mush them together as a convenience but you need to recognise that they're different if you're to elevate yourself from n00b status :). Cf. top-posting in email threads. If someone forwards you an email where everyone has top-posted, you need to read it "bottom to top" to make sense of it even though it is presented "top to bottom". Your code confused the JS environment just like a top-posted email thread confuses someone copied into the middle of it. **Addendum:** I'm also saying you should create example{1,2}.js and experiment. You'll learn more that way than copy-pasting bug-fixes from Joe Random Internetter.
Knockout was fairly popular and mature before angular.
All you need to know: JSON.parse(string) JSON.stringify(object)
Thanks for your help! If I want the variable inputDamage to equal to the numbers I write in a input text field in HTML what should I do? I think that is the only thing I need to fix to have the code working, sorry to bother you!
There weren't frameworks until the time you mentioned or maybe a little further back. Back then, most of us knew how to code. Nowadays people don't want to think, or can't think, and only want things to work without having to understand why. Thus, frameworks. Kinda like /u/contantofaz who doesn't know the difference between frameworks and libraries. Most redditors are kids under 21 with little to no experience so few, here, will know of anything back to 2001 when I first started coding for the web.
It illustrate one possible method, create inputexample.html: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt;&lt;input type="text" id="mirandaCornielle"&gt;&lt;/body&gt; &lt;/html&gt; Open in web-browser of choice and open the Javascript console. (In some browsers this is F12.) This will let you experiment with Javascript one line at a time. In Computer Engineering, this is often called a REPL which stands for Read-Eval(uate)-Print Loop. Look it up on Wikipedia. Firstly, we need to grab the HTML element out of the document and store it in a variable. 1) *Declare* the variable. (You may note that I'm using surreal variable names to discourage copy-pasting.) var sidDabster; 2) Use the ``getElementById`` function to grab a reference to the input element and *assign* it to our variable: sidDabster = document.getElementById("mirandaCornielle"); 3) Type some text into the text box. 4) Retrieve it via the ``value`` property: var iAmSidsTowelboy = sidDabster.value; // a JS convenience to declare _and_ assign in one go console.log("Current value is " + iAmSidsTowelboy); **Danger, Will Robinson!** The browser doesn't "know" the difference between the number ``10`` and the character "1" followed by a "0". (We usually use quotes (") to discriminate between literal text and numbers. I.e.`` "10"`` is different to ``10``.) Exercise 1: A defining feature of a computer is the ability to do *different* things depending on different input. In JS, the ``if(...) { ... }`` construct can be used to do something only if something else is ``true``[1]. How can you make sure that only numbers are accepted? [Hint: See what ``+"10"`` and ``+"ten"`` produce in the console. Does ``+"10" == 10``? Does ``+"ten" == "ten"``? The ``alert`` function will pop an error message box up to the user.] [1] Extensions: Research "truthy" and "falsy" in the context of Javascript. Research the ``parseInt`` function from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt. Exercise 2: Research HTML event and, specifically, the "input" event[2]. Can you use these to run your code every time the user changes the value in the text box? [2] https://developer.mozilla.org/en-US/docs/Web/Events/input Exercise 3: [Extra credit] What is the variable name ``iAmSidsTowelboy`` a reference to?
There are many different approaches to this. Here's some of my thoughts. Sorry for not mentioning any specific projects. You're probably familiar with some libraries because you're their user. On the way you've possibly found some bugs and places for improvements. File issues and talk to developers or simply start by sharing patches and ideas. Also it doesn't hurt to just read code and learn from it. If you haven't contributed much code before, the hardest part is to start and really get in. This can be hard especially in large projects so maybe try finding a smaller one. Their developers tend to be more friendly and responsive and are more than happy to get help. Also a good way to contribute to the open source community is to create your own projects. But keep in mind that there may be already similiar projects and prefer focusing your time to help improve them. It isn't always so simple and reinventing the wheel is also a good way to learn and innovate. Some places to find projects: [Github trending](https://github.com/trending?l=javascript), [DailyJS](http://dailyjs.com/) and this subreddit.
The easiest analogy for explaining FP is to compare it to the gang of four design patterns. I.E. you have a method that operates on data and calls a predicate its been provided. For instance the visitor pattern and the map function. The primary difference is that OOP uses design patterns for mutating state and FP respects immutability. A good example in javascript would be changing all of the elements of a list to have their text to read "in bed" at the end. You select out the list from the dom, map the list with the predicate `(item) =&gt; item + "in bed";` and then replace that parent with its new elements, while the original list is still in your scope to do with as you please. 
Way back in the day they were called DHTML libraries and lots of people used them. They weren't fully fledged "hollywood-principle" frameworks though. PPK has more info on them: http://www.quirksmode.org/blog/archives/2007/01/again_javascrip.html
Ahh. That makes complete sense. Is functional programming generally used as a piece of a solution or are there some clear cases when to use it? I imagine it's just not as common in JS since UIs and interactive application s are generally so stateful. Hmm. Maybe something like a helper library?
Without wanting to seem needlessly cruel, I'll be direct: what you've written is relatively meaningless. I'd recommend trying to get a good grasp of fundamentals first. Play in the console getting used to assigning variables, setting properties, etc. That being said, ``console.log`` writes to the developer console. If you want to do something different, i.e. write text into a HTML element, then you don't want ``console.log`` appearing anywhere in that bit of code. Play in the console with var foo = document.getElementById("output"); foo.value = "Hello, world!"; and see if enlightenment is attained.
For javascript, both. The main candidates in the helper category are Ramda, Lodash, and underscore. For ui you want to Google "functional reactive programming". In other languages like anything in the Lisp family, FP is very extensive. And in the extreme, Haskell, where almost whole programs can be written in FP with very little state existing, and usually only in a form that the compiler can strongly typecheck.
Sproutcore was among the first crop of 'modern' JavaScript frameworks, in fact I'm pretty sure Ember was a fork of SproutCore which would make Ember older than both Backbone and Angular....
The greatest benefit of html5/css/javascript over Flash is that they don't belong to fucking Abobe, who have a knack of killing off great products (Freehand, Fireworks, Director, and now Flash, to name a few), while pimping their stock moneymakers - Ps, Ai, Ap, Aa which haven't improved or progressed in 5-6 years. Corporate twats.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 1. [**See also**](https://en.wikipedia.org/wiki/Ajax_framework#See_also) of article [**Ajax framework**](https://en.wikipedia.org/wiki/Ajax%20framework): [](#sfw) --- &gt; &gt; &gt;* [List of Ajax frameworks](https://en.wikipedia.org/wiki/List_of_Ajax_frameworks) &gt;* [List of JavaScript libraries](https://en.wikipedia.org/wiki/List_of_JavaScript_libraries) &gt;* [Comparison of JavaScript frameworks](https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks) &gt;* [JavaScript library](https://en.wikipedia.org/wiki/JavaScript_library), [JavaScript](https://en.wikipedia.org/wiki/JavaScript) &gt;* [List of web application frameworks](https://en.wikipedia.org/wiki/List_of_web_application_frameworks) &gt;* [Comparison of web application frameworks](https://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks) &gt;* [Content management framework](https://en.wikipedia.org/wiki/Content_management_framework) &gt; --- ^Interesting: [^List ^of ^Ajax ^frameworks](https://en.wikipedia.org/wiki/List_of_Ajax_frameworks) ^| [^Spry ^framework](https://en.wikipedia.org/wiki/Spry_framework) ^| [^ItsNat](https://en.wikipedia.org/wiki/ItsNat) ^| [^SmartClient](https://en.wikipedia.org/wiki/SmartClient) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crzft1n) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crzft1n)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
thanks for the detailed response. I'm not so much concerned with getting familiar with rejection or tooling as I use gullp, jshint, jscs, etc. in my daily work. Maybe I should have been more explicit with the post, I'm not trying to get into Open Source for the first time, just looking for inspiration and to see what projects out there people are contributing too. 
in `checkCookie()` you are using a `cname` variable, but I don't see it defined anywhere, and `checkCookie()` doesn't take any arguments. Is that a global variable? `getCookie("")` looks like it would break something, though I haven't tested it. Did you mean `getCookie("week")`?
Haha no problem man, I am pretty much at the basic skill level of Javascript etc. Thanks for pointing me in the right directions tho! 
Is that just *part* of your js code? Cause I can tell you right off the bat, the function storeCookie(){ var name = playingVid document.cookie = "name=playingVid" alert(name); } Isn't going to alert anything since playingVid is undefined or not initiated (not sure what the proper term is there). So, that's causing issue. And here's W3Schools take on js cookies: http://www.w3schools.com/js/js_cookies.asp
The projects in-and-around the React community are quite eye-opening right now. If you plan to ever do work in React professionally, now's a great time to get involved. [Dan Abramov](https://twitter.com/dan_abramov/with_replies) is working on [Redux](https://github.com/gaearon/redux), and there are numerous projects inspired by React/Flux, including: - [Mithril](https://lhorie.github.io/mithril/) - basically a lighter, less-opinionated version of React. - [Cycle](https://github.com/staltz/cycle) - a functional reactive web framework. - [Cerebral](http://www.christianalfoni.com/articles/2015_05_18_Cerebral-developer-preview) - inspired by Flux and for React, uses ideas from the Elm programming language. 
I've used [jStorage](http://www.jstorage.info/) to help simplify the process of working with localStorage.
Probably a literal object. Like a lego block.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/youtube] [YT-LNK.org - 100% Clientside Javascript YouTube downloader • /r/javascript](https://np.reddit.com/r/youtube/comments/391l5m/ytlnkorg_100_clientside_javascript_youtube/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Source code is online, have some other things to deal with before moving to AWS, but support is there. https://github.com/deviant-io/deviant.io/blob/master/server/lib/badge2image.coffee (that's the image handling part). You can use https://Deviant.io to generate badge with public and private repo stats.
You might check out the new badge code, which combines the 2 badge designs, and allows you to show private as well as public contribution history (on https://deviant.io). source code: https://github.com/deviant-io/deviant.io You're welcome to keep using the octobadge version as well, but Deviant will be the version getting active support = )
I've not heard of jstorage. Looks cool, but I'm unclear why something like this needs jquery?
Awesome, thanks for the update.
The developers of Slack, the fastest growing workplace software ever?
I'm the founder of rrrepo - we're currently only giving limited moderator status to people who we believe will make super high quality repos, so they can pave the way and set the standard for other users. If you would like to be a moderator, please contact us on Twitter with your topic of choice. Thanks! https://twitter.com/rrrepo_
Director and Shockwave was definitely losing market share way before Unity became a thing, or HTML5 was even a thing. I think if more people picked it up in the beginning, it *would* have been bundled in a creative suite. But Director's fate was sealed a long time before HTML5 was a twinkle in Paul Irish's eye. ;-)
actually, here is my solution: function makeList(){ var list = document.createElement(arguments[0]); for (var i = 1; i &lt; arguments.length; i++) { var item = document.createElement('li'); // Set its contents: item.appendChild(document.createTextNode(arguments[i])); // Add it to the list: list.appendChild(item); } return list; } window.onload = function() { var list = makeList("ul", "red", "blue", "green"); var theListDiv = document.getElementById("theList"); theListDiv.appendChild(list); } I had to call my function this way. var list = makeList("ul", "red", "blue", "green"); If I was writing this in the real world, it would have looked like your solution.
Rofl Open Laszlo. Haven't heard that one brought up in so long! 
 onclick = "dostuff(this)" function dostuff (b){ var btn = b.innerHTML if (btn == "steen") { ... } }
I added event listeners using vanilla js. You don't want JS in your DOM elements. https://jsfiddle.net/5ft5w50n/10/ HTML &lt;div id="knoppen"&gt; &lt;button class="knop" value="steen"&gt;Steen&lt;/button&gt; &lt;button class="knop" value="papier"&gt;Papier&lt;/button&gt; &lt;button class="knop" value="schaar"&gt;Schaar&lt;/button&gt; &lt;/div&gt; JS function play(e) { var possibleMoves = ["steen", "papier", "schaar"], gebruikerInput = e.target.value, computerMove = Math.floor(Math.random() * 3), computerKeuze = possibleMoves[computerMove]; console.log("Computer: " + computerKeuze); //Gebruiker vs Computer if (gebruikerInput == "steen" &amp;&amp; computerKeuze == "schaar" || gebruikerInput == "papier" &amp;&amp; computerKeuze == "steen" || gebruikerInput == "schaar" &amp;&amp; computerKeuze == "papier") { console.log("Sam wint!"); } else { console.log("Sam heeft verloren!"); } } var buttons = document.getElementsByClassName("knop"); for (var i = 0; i &lt; buttons.length; i++) { buttons[i].addEventListener("click", play); };
Hi /u/DonMildreone, this is the [2nd time](http://www.reddit.com/r/javascript/comments/388ykr/can_you_guys_help_me_with_this_list_of_gulp/) you've posted this link within a week, please don't post it again. Thanks for your cooperation!
_[citation needed]_
This is perfect.
TIL about '~' and '~~' in JavaScript
Cookie are not part of js. Cookies are part of HTTP, so are visible to things that use HTTP ( server, client ( your browser ) ). You do use JS to get / set cookies though. I'd recommend using some existing solution here: https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
My comment was in regards to your exceptional claim: &gt; fastest growing workplace software ever
Lol. Well that was the intended behavior of this demo :). I guess I should have made it more clear that that's what the intended behavior is. It's not super practical, but I thought it might be a neat effect to get peoples attention on a simple one page site.
Yeah it does have a little hiccup. I'll see if I can fix that...
It's not that anyone would use them. I'm sure there are lots of five-year old kids who get a big kick out of them.
Cool thanks
i would love to use something like this for my youtube links page, is there anyway i could use your code as a templace but instead of having images, embedding youtube videos?
If so, it seems like only a small part of a larger problem - I don't see this being a very good homework question on its own.
&gt;Putting x outside the function(), wont recognize the var. It does, though. var x = 0; function inc() { alert(++x); } inc(); // 1 inc(); // 2 inc(); // 3 If you declare another `var x` within the `inc` function, you'd shadow the outer `var x`, and it won't work as intended.
qdb_data isnt defined anywhere?
Those may have been some that I removed, since they had 3 posts on the frontpage; the 2 I removed already had responses.
You definitely should perservere, and it takes quite some time, but the result will be worth it, imho. That being said, you *will* throw yourself at the deep end by starting with nodeJS. Here is the key points what I would advise for you to look up: a. The Scope. Understandig what it means for a variable to be global, local, how variable names are looked up on the scope chain can mean a lot less headache for you. b. Understanding THIS This is the magic part of the language that most developers do not actually bother to learn, but sidestep, intentionally or not.. I would bet a small amount of money that you will encounter this-related issues first. And that is okay. As long as you actually learn from it :D c. Callbacks. The non-blocking nature of the node means that if you, for example, read data from a database, your code will not progress as intended if you do not put the "what to do with the data" part as a callback - meaning that you only do something once you *can* do such thing. Similar to how many scripts are put in the browser as "onload", so you wont end up trying to do things with images that have not been loaded yet. To passing functions as parameters, I will try to explain it in the most simple way: imagine you are building a calculator. There are many ways to do that, but lets just say your operations are always taking two variables, okay? So call them x and y. In that case, an eloquent way of calculating thing is to write the following function: function calculateOperation(operation,x,y) { return operation(x,y); } So you take the function as a parameter, you define add(x,y), multiply(x,y), factor(x,n) and you have your own little calculator via this passing feature. (I am aware that there are simplest/easier ways to do a calculator, it is just for demonstration of how you can pass around functions :D. The thing to take off from it is that you can point to anything when referencing things, even to functions, that is the dynamic nature of the language, I guess.)
&gt; You realize jquery is just javascript right? Yeah, I realize that. You realize jQuery is not native right? &gt;Fetch is different from jquery and the traditional XHR request in many ways. It's also similar in many ways.
Sure, they released, but it didn't get any traction until around 2012
Half of them aren't even books.
First read [js for cats](http://jsforcats.com) to get your js legs. Then read [weaning yourself off jquery](http://substack.net/weaning_yourself_off_jquery) to get off that jquery dependency. Then follow the core workshops on [nodeschool](http://nodeschool.io) And just keep at it, you'll get there. 
I used the console to just override the success check. Does that mean I qualify to work at a pentest shop?
It sort of something that I think I want, but I'm not exactly sure how;d you actually use it - any chance for a real-world example?
Nitpick: this code will not return 4. It will raise an exception, incrementAsyncPromise(n0) .then(incrementAsyncPromise) .then(incrementAsyncPromise) .then(console.log); // =&gt; 4 Instead you need to say, .then(console.log.bind(console)); // =&gt; 4
If you manage to hit the top directly then try to wheel up, you stay at the top. Same thing with the bottom and wheel down. Can cheat and simulate it by left click dragging the scroll bar all the way to the top or bottom.
&gt; map[2][5] translates to the rock at x: 2, y: 5 You mean the rock at x: 5, y: 2. Your first-class array is an array of rows. EDIT: Oh, I see, never mind, just looked at the source, I get it. The strings are meant to be interpreted top-to-bottom. I had the rocks falling sideways.
(As a point of clarification) Should a note be placed explaining that the DASH files do not contain audio?
[old versions of IE (8 &amp; 9) don't have the `console` object exposed unless the user has the developer tools open](http://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function).
You can also be sneaky and just find the check function and use their own validation code to solve it :p (function() { e = map; return e.map(function(e) { return e.split("#").map(function(e) { return e.split("").sort().join("") }).join("#") }); })();
FYI: If you don't return a value at any point during your testing it can break the success check. Just reload and run again. 
Wait, what? Do you even know what React Native is?
I know this is late to the party, but jQuery is a library with support for plugins. It is not a framework.
It does that server side?
Yes, if it's server-sided.
oh ok, I had no idea those sites were set up to do that. I assumed they would all be client side, given there is no need for it to be a 3rd party server side script (other than to serve ads on a landing page).
It means that you're an exceptionally sneaky ninja.
Yeah, just use console.trace(), find the solve function and there's your answer
I would start with: https://nodejs.org/documentation/tutorials/ or http://www.nodebeginner.org/#javascript-and-nodejs this will give you the basics of nodeJS. Another option to 'swim' quickly is to know how to debug nodeJS: https://greenido.wordpress.com/2013/08/27/debug-nodejs-like-a-pro/ Good luck
The damn name.
When you click the mouse wheel and move the cursor up or down the scrolling will stop when the scrollbar reaches the top or bottom. I don't mind because I only ever use that when I want to reach the top or bottom of a really long page without wanting to reach for the keyboard...
I wonder if there is an app in which you can stream the dash file and the m4a file at the same time. I could simply make a Tasker task to play a youtube link with dash (that's 60fps right?) and audio on my phone! 
I like the pattern also. Been using RamdaJS on a recent project, which has a pipeP and composeP for something similar. var createUser = P.pipeP(doSomething1,doSomething2); createUser(user).then(stuff)
Yeah, basically. 
I guess you have to pay to get a website without ads and extra features I guess .. I need a hack !! thank you for your reply 
Inheritance should be avoided where possible because it introduces complexity into your application which simply is not needed. And your example is the perfect example where you shouldn't use inheritance, and use mixins instead. You can use inheritance where you have a more specific case of a more general one. So A inherits from B if A is a more specific case of B (For example a Lion can inherit from an Animal class). We say that A "is" a B. In your example the monster and the player "need" animation capabilities (which IMO should be separate from a monster object anyway), the monster isn't an animation. Of course everything is debatable, but inheritance chains introduce complexity which you usually don't need, and sometimes it is not a good model of what you are trying to model. So basically what I am trying to say is that I would choose mixins over inheritance.
Are you going to tell your users that too?
No. This is a prototype, and hopefully some help to those trying to do the same thing - we provide more advanced features and capabilities to the browsers that support it and cut those features out of browsers which cannot. Hopefully soon our platform will provide adaptive bitrate streaming to Chrome, and Firefox where the user has enabled the flag. Feature detection is a standard way of providing more advanced features where you're able.
@Nesvand Definitely, the DASH video only files are a problem for those that don't know about it.
from this site: https://github.com/es-shims/es5-shim it looks like the new features are: - iterating or looping through an array, probably inspired by underscore.js (reduce,map,each,some,filter,etc definitely google these, i find these the most handy) - more array stuff: lastIndexOf('someitem') - date.toJson() - function.bind: creates a new function that, when called, has its 'this keyword' set to the provided value, - Number.prototype.toFixed(): decimal rounding (1.222 to 1.22) - Object.keys(): keys from object ( {a:1,b:1} to ['a','b'] ) - String.prototype.split(): "ab|cd".split("|") to ["ab", "cd"] - String.prototype.trim(): " asdf \n " to "asdf" - String.prototype.replace() - Date.parse (for ISO parsing) - Date.prototype.toISOString - parseInt(): make integer from float or string: "1" to 1 theres more stuff also according to: http://kangax.github.io/compat-table/es5/ like use strict and immutability and property getters and setters thats probably the real question, when to use getters/setters, use strict, immutibility, and bind maybe you can just google es5 getters/setters, es5 use strict, es5 immutibility, and es5 bind =] gl
I don't think the Youtube comparison stands. I've never had to make any custom settings to get HTML5 video. As /u/rorrr pointed out, having to mess with settings in your browser is going to be a deal breaker for a lot of potential users.
That would be extremely helpful.
Is this helpful? https://www.wix.com/support/html5/ugc/4705e0d5-86ec-4b55-8eaa-9c52dd505792/8b1c4e48-f654-4893-a8a7-d6f1ad1d2c9c
Eh.... no thanks
can you try this code please http://codepen.io/developedbytom/pen/jkLDv
well since they built custom apps for both iOS and Android and dont have to worry about the short comings of browsers and GIFs, it works just fine. 
I've never been on Wix; I don't know anything about it. If you can get access to the html on there, then just put all the CSS code you want in between style tags. Like this: &lt;style&gt; h1 { background:green; } &lt;/style&gt; Might work.
Not entirely sure what you're looking for. Let's start with this: function add(x, y) { var z = x + y; return z; } function multiply(x, y) { var z = x * y; return z; } alert(multiply(add(4, 6), add(9, 1))); /*alerts 100*/ What's this one not doing that you want it to?
Thank you 
I appreciate the sentiment--but the reason it doesn't work in Firefox (by default) yet is because we haven't finished MSE for all platforms. So not really OP being lazy, it really just requires Media Source Extensions being shipped. You can follow https://bugzilla.mozilla.org/show_bug.cgi?id=MSE to track that work. And as long as the OPs library is doing feature detection, it will just work™ for all Firefox users when MSE is enabled by default.
Damn. Sorry. Hope you get it figured out!
I started with no experience with learnyounode. If you're looking for a challenge with not a lot of reading, start there. It was definitely an uphill battle, but I learned a lot in a short amount of time and landed multiple jobs.
Is this a stream or are you talking about two separate videos? If it's two separate videos then it's up to you to queue up the playing and monitor when things finish. If it's a stream then that's a little out of my comfort zone...
Is there a `wiredep` equivalent that I can use to inject npm packages?
I will Nshallah :) 
LOL! Why not?
Nice! Glad you got it figured out!
JavaScript is the standard language of the web browsers, so if you want to do any kind of programming or interaction that is available to users on the web JavaScript is immediately available. JavaScript is also heavily used on the command line thanks things like Node.js and iojs. In this case you can use JavaScript exactly like a bash scripts and Perl. As a result of those two environments JavaScript is almost a fullstack language. The only things missing are: * A standard module system (coming in ES6, but nobody is supporting it yet). * A standard large data store API. Currently major nosql database vendors write their own JavaScript interface libraries. The absolute first things you should learn in JavaScript: * Declaring references: `var`, `let`, `const` (let and const are super new) * Declaring/assigning functions Then you need to learn to use the language: * Loops - do/while, while, for * Assignment and Expressions - basic operators and syntax * Conditions - if/else/else if Now that you can write in the language (kind of) you need to understand scope. * References are bound to the scope of the block in which they are declared: in functions with `var` or any block with `let` and `const` * There is a global scope, but try it avoid it, because collisions can happen there. * Scopes can be nested. * Lower scopes can access references in higher scopes. Crossing scope boundaries like this is called a *closure*. * Understand that you can perform computation in a child function and store the result in a closure (separation of concerns). Virtually no overhead, clean code, and great rejoicing with triumphant nude dancing. Once you understand lexical scope you need to learn arrays and objects, which are the basic data storage items of the language. * Array are faster to access and dynamically populate than objects. * Objects are easier for people to understand because the keys are whatever you want. * Objects can be accessed by variable using something called array notation: `obj[myVariable]` Learn to avoid the pitfalls * always use `use strict` to prevent some stupid from creeping in. * always use `===` and `!==` to perform strict comparisons instead of sloppy `==` and `!=` * learn about hoisting and then learn how to prevent it from happening in how you write your code * semicolons are **required** at the end of statements and assignments, but the interpreter will insert them for you if you forget (Automatic Semicolon Insertion). Always ensure you don't have missing semicolons, because ASI can result in unexpected surprises. * OOP does work the same in JavaScript compared to many C based languages, until you have a year of experience never use: `this`, `new`, `Object.create`. The only exception is that somethings will require use of `new` or they will throw an error.
That's nice but I'll have to train myself to make it more readable to me. Right now it's almost like fully es7 code has been put through google closure compiler for me.
Click mouse wheel in and try to go up or down. it doesn't work. my bad for not elaborating
Haha it works fine on about:blank
Hmm I wouldn't know how. I'm now trying to download both files and combine them somehow with Tasker. But autoinput is acting weird so I have to use shell input taps. 
It's two seperate videos, but I would like to combine them into a single stream somehow. I don't know if it's even possible, as I am fairly new to the MediaStream stuff. Rightnow I am just playing the next video on one ending, but there is a blip while it switches, and the videos are actually one video cut into several pieces, so it would be nice if I could rejoin them separately in the browser. The problem is that I want to play them as the next ones are downloading. It's also a business requirement that they be sent in several pieces
Nope that works, I forgot about that feature! Will update.
I think doing that is perfectly acceptable. If you want immutable data, use `Object.freeze(a);`. `const` is immutable bindings, not data - trying to use it as a marker for immutable data doesn't actually help, especially if newbies think it means immutable data.
Are there unicorns?
Ehh, it's just inconsistent behavior with primitives, that's why I suggest against it.
The removeElement function should be using the elementIndex variable in the test instead of calling the indexOf method again. if (!Array.prototype.removeElement) { Array.prototype.removeElement = function(element) { var elementIndex = this.indexOf(element); if (elementIndex !== -1) { this.splice(elementIndex, 1); } return this; }; }
Thanks very much for your reply. With your function so you pass in operation and operation becomes add/multiply etc? Or am I still not getting it?
Works for me.
mmmmm deferred unicorns. 
simplistic way would be to provide a `parts` collection of part IDs on your model. 
Is it just me or is ES 6 and up broke JS's ease of reading code?
Indeed. However, borrowing these technologies [for this purpose] seems like a mistake.
Overall it looks pretty good, but in the spirit of a code review, I'll offer up some potential areas for improvement: * You might consider using a beautifier since you have a lot of inconsistent spacing &amp; formatting. There's online, CLI, and Grunt/Gulp versions, so whichever fits you best. Inconsistent formatting isn't a big deal in the grand scheme of things, especially if this is a solo project, but when you're on a team you'll generally want everyone writing code the same way to help prevent bugs. * You might also consider using a linter, such as JSHint or similar (also available online, CLI, Grunt/Gulp), to help you prevent bugs and bad practices. For example, most people would prefer that you always use `===` and to never use `==`. * Your `createWS` function is a borderline behemoth, I'd probably try and refactor it to be a little bit more exact in what it does, while moving auxiliary code out. For instance, you define the `pong` function inside of the `createWS` function, which usually isn't a good idea; however, you can't simply move it out since it's relying on a closure (for the `connection` and `i` variables), so you'd have to refactor your code to take that into account. * Additionally, `createWS` does more than the name implies -- it looks to actually parse/handle incoming data -- which can create confusion (and possibly bugs) if you're on a team. * Also in the interest of a team environment, proper docblocks for your functions would be really good to have. * I'm also not a fan of the magic strings (mostly URL's) scattered in the code, and usually like to keep them all in one place. I've applied many of these concepts to [this gist](https://gist.github.com/k3n/6c8b8a7cbf8df6ceb4c4), though do note it hasn't been tested at all ;)
This is a proposed ES7 feature, not ES6. This may never see ratification whereas ES6 is agreed-upon at this point.
I would not expect that to work. The object which is used for `this` is the object specified just before the function. ::console.log `console` is the object which is used as `this` and bound to the log function. Your examples only have a function and no object 'in front' of them. 
You would need to change it to: foo(this::function() { // ... }); The other way doesn't work because there is no object as the implicit receiver. I'm not sure if I worded that correctly, but it's the same reason `::console.log` works and not `::log`. Hence, `::function() {...}` won't work either. There's no way of knowing what you actually want to bind to without explicitly stating it.
it's a little bit cringey to consider jquery as a "bleeding edge" framework at 2015. Also you're mixing frameworks and libraries. jquery and react are libraries. angular is framework
I am just getting started with javascript and have been looking at Angular 2 and React. The syntax of angular 2 looks more attractive to me vs React, but I don't know if it will be production ready before 2015 is over. If that is the case React + flux seems to be the most popular for 2015.
Does it make sense to combine them with ffmpeg or something in the backend? Otherwise you could cross-fade the videos pretty easily by preloading n-videos with shaka then hook into the "ready" callback so you know when a video is good to go and start playing 1s from the end of the previous vid.
Yes, I agree - jQuery is not only "not bleeding edge", I argue it isn't even appropriate on many grounds. The mixing of frameworks and libraries is purposeful, as there is much overlap amongst the two. But I agree, a distinction *can* be made.
The same reason (American) high school students create tons of mostly useless clubs their senior year: pads the resume.
That's possible to do with media extensions, and something we're looking at doing in the future . If you read to the part where we switch between different quality renditions, which are actually different video source files, it should lead you in the right direction. 
Oh snap. What are some ways callbacks are better? I've heard performance from a poster below.
What features do you feel are difficult to read/use? I think after you sit down and write some code using the new features, they fall in pretty naturally.
[Here's the full talk from the quote](https://www.youtube.com/watch?v=GaqxIMLLOu8) &gt; Nesting callbacks via Promises can be tricky as well. You are not necessarily done with nesting the callbacks just because you have started using Promises. What do you mean by that? Can you give an example?
The function generators. I'm sure if I just sat down and properly read up on generators, I'll get the concept, but right now, I have no clue what it does.
Excellent article - one of the best illustrations of the beauty of using promises over callbacks. As the author states, it is about far more than simple syntax indentation (!) Regarding the performance cost - I wrote Zousan (https://github.com/bluejava/zousan) specifically so I could use promises everywhere (even in HTML/JS games!) with impunity. There is essentially no performance hit (and its only 2k).
Awesome. And how do you determine the constant factor?
For me, callbacks have two advantages as a main mechanism over promises: - Even if promises are powerful, callbacks are easier to understand for any javascript developer. You can e.g. have a look at this article: http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html to see how you can easily shoot yourself in the foot with promises if you don't completely grasp what they do. - It's easier to build abstractions from lower-level concepts than to go the other way around. Having functions and a defined interface using them for every async call allows client code to decide which abstraction it wants to rely on. If you prefer promises for your flow, then you can turn any function using the callbak pattern to a promise (most promise libraries give you a 'promisify' or 'denodeify' function to do it), and if you prefer something else, you can build it. I'd admit that I prefer promises for my control flow, but I think that having callbacks as base mechanism empowers the community by letting anyone build what ever she wants on top of it.
As I state in the article, I'm not really proposing to build a "framework" as much as a thin "foundation" that will provide a module loader into which one can load microJS single-purpose modules to accomplish what they need. One module I will also likely provide is a (very thin) browser enhancement module which will mostly rename awfully named vanillaJS methods like querySelectorAll(). Why fragment further? Because no existing libraries met my small,fast,modular,non-browser-first,promise-based requirement. 
Of course this second issue would probably be better characterized as an "issue" for callbacks. Promises could easily resolve synchronously, but the spec authors felt deterministic behavior was far more important (and I think most people agree). After all, its not really *faster* to execute the handler immediately, its just about the *order* of execution. [whats faster: sock, shoe, sock, shoe - or - sock, sock, shoe, shoe?]
Fair enough.
Yes, they really are interesting, particularly the Windows' timer 15ms granularity. Thanks for sharing!
It sounds like you're wanting to make something that will make every visitor of your site hate you.
I came to the same conclusion when I took over the front-end dev for web apps at my company. I REALLY wanted to use something that already existed -- but I came from a background in game development, desktop apps and industrial systems -- and I just couldn't stomach most of what was out there. I'm glad I did it. If I'd tried it any earlier in my career (about 15 years in), I'm sure it would've been a massive flop. Our framework is way smaller than Angular, on par with React for speed (as in close enough), component-based, everything is lazy-loading, no transpiling required, no 'builds' required, public/private component scopes and automatic routing. We're trying to open source it now, but the documentation and demos are taking longer than I'd like... 
Besides “virtual methods,” it also makes writing combinators a little different, because you can write `this::f(...args)` instead of `f.apply(this, args)`. Is that nicer? If you’re trying to make it obvious that you’re writing a combinator you can apply to a method, then yes: function es6once (f) { let calls = 0; return function (...args) { return calls++ ? undefined : f.apply(this, args); } } function es7once (f) { let calls = 0; return function (...args) { return calls++ ? undefined : this::f(...args) } }
The link is 404ing, but my guess is the quote refers to *small*, focused and highly composable modules. For example, see [xhr](https://github.com/Raynos/xhr), [domready](https://www.npmjs.com/package/domready) or [ghauth](https://www.npmjs.com/package/ghauth) modules. These would be far less useful and less depended on if they were authored with promises: - depending directly on a promise implementation (bluebird, q, etc) is vendor lock-in; especially in browser domain where you don't want to include multiple different promise implementations (or multiple versions of the same implementation) in the same application - returning a "promise-like" object complicates your code, probably won't be spec-compliant, and won't behave like the user's promise implementation - expecting a global Promise constructor means the module is not usable without a polyfill Sadly, it is easier just to use Node-style callbacks and then let the user "denodeify" or "promisify" the module: var Promise = require('bluebird') var xhrAsync = Promise.promisify(require('xhr'))
Love this kind of content; thanks so much for sharing this, learned s ton! 😄
Javascript isn't the first language to have generators, python being the most obvious example. What they do is break up a function into distinct parts that will be called sequentially but not necessarily temporally; as in they can be executed at different times in the application's runtime. Determining how to break up a function is by using the `yield` expression. I like to think of a generator as a big switch statement: the code in between each `yield` will be its own case, and the interpreter will call each case in sequence but not necessarily at the same time. This has quite a lot of benefits, especially readability, lazy-loading, and asynchronous flow control.
C is similar to JS in some ways. They're both simple languages but just sophisticated enough for some smart design patterns that allow them to be used for complex apps. They're also nearly opposite languages. JS is very high level and C is low level. You don't generally worry about memory management or pointers in Javascript, but the entry points and order of execution can be a little confusing compared to C's main. Some things I can think of, as someone who started in C a long time ago: * Only functions can create scope, so they're used a lot for that purpose. * Functions are first class, so get used to using them as values, objects, parameters and return values. You can declare a function just about anywhere. * Functions can create closures which are especially useful given JS's event-driven design. They're often used like classes or structs in other languages. In other words, functions, functions, functions. Optimization mostly comes from minimizing object or closure creation in high performance parts of your code.
T_PAAMAYIM_NEKUDOTAYIM 2: He's back, and he's angry. There's something a bit unsettling about allowing a `foo::bar` syntax where `bar` is not a member of `foo`. 99% of the use of .bind() in the field has to do with things like `getAPromise().then(this.dance)`, and for that something like `this::dance` would be fine. But that's not valid in this spec. You'd need `::this.dance`, somehow. That syntax does not fill me with glee. 
Any advice on finding mid-level js dev work in Denver? Most of the postings I see are all looking for senior devs and I'm not quite there yet. I've been working in DC for 4 years (all front end data viz type stuff for government) and really want to get out to the mountains. 
This is a valid complaint, but why not just fat arrow that instead? getAPromise().then(x =&gt; this.dance(x));
[**@nolanlawson**](https://twitter.com/nolanlawson): &gt;[2015-06-09 00:39:43 UTC](https://twitter.com/nolanlawson/status/608070937045528576) &gt;Just did an audit of iOS 9's IndexedDB/WebSQL patches. Out of 6 critical bugs, only one was fixed: [*gist.github.com*](https://gist.github.com/nolanlawson/08eb857c6b17a30c1b26) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/399a0g%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Yes, that's what I use now. It's certainly adequate. The most convenient way to deal with this has to be the way ActionScript 3 did it: Any non-static method defined on a class is always bound to its instance. That almost always does what you want. It's also slightly backward incompatible with existing specs, so probably not the most likely outcome here. Still, look at this: class AlertsWhenClicked { constructor(private state) { window.addEventListener("click", this.clickHandler); } private clickHandler(e) { alert(this.state); } } That would be so nice.. 
Virtual methods are pretty cool. function capitalize() { return this.charAt(0).toUpperCase().toUpperCase() + this.substring(1).toLowerCase(); } function clamp(min, max) { if (this &lt; min) { return min; } if (this &gt; max) { return max; } return this; } console.log('foo'::capitalize()); // Foo console.log(7::clamp(3, 5)); // 5 console.log(4::clamp(3, 5)); // 4 console.log(1::clamp(3, 5)); // 3
good to know!
React Native still doesn't support Android, although.. &gt; Android support is coming soon [Source](https://code.facebook.com/posts/1014532261909640/react-native-bringing-modern-web-techniques-to-mobile/)
Webworkers are the correct way to solve this. The setImmediate/setTimeout approaches do work, but webworkers will use the client's cpu more naturally.
For me it's things like fat arrows, spread operator, etc. When words start being replaced with meaningless symbols the code becomes arcane. I've never had any trouble reading es5 and below code, but so much if es6 code looks like pure gibberish to me. 
ಠ_ಠ
edit: i misread the flow of the code sorry looking forward to using ramda for stuff like this jquery performance lately is pretty bad so... (people have said jquery show,hide, and html() are the largest bottlenecks in their apps now loool)
But IE8 doesn't support setImmediate either, you have to shim it with setTimeout which yields the other issues mentioned in the article, so I'm a bit confused about this solution. A 3000 element array is not big, I wonder if the problem here is actually the efficiency of the comparator.
But MSIE8 is supported in the [setImmediate shim](https://github.com/Katochimoto/setImmediate)
`foo::bar(bash)` looks more like `foo.bar(bash)` than `bar.call(foo, bash)`. Likewise, `foo::bar(...args)` looks more like `foo.bar(...args)` than `bar.apply(foo, args)`. So that hints that since `es7once` wraps around `this::f(...args)`, that you can use it on a method. Of course, everyone reading this forum already knows what `.apply` does and how that works, so this syntactic sugar is not going to be a big deal to any of us.
&gt; PHP 5.4 fixed that. It now says that the "::" was unexpected. Lol, that took a while
He is using FRP to create event streams, there is little overhead here, in fact probably less than jQuery's own event delegation. This is pretty much the same approach I would take if using FRP however I would most likely delegate to the `document.body`.
Thanks for all of your answers guys. Incredibly helpful. Are there any disadvantages of using ES6 with babel ? I mean as you have noticed i am not an expert in ES..so that's why i opted to master ES5 first.
The tests at http://jsperf.com/spliceslicewds aren't really showing what it appears like they should be. `.splice` is mutative. So the test is being run the first pass for each test, but then on every other pass, `input` is an empty array. Definitely agree that it's worth noting that all of these behave slightly differently
This, the inneficiency is probably elsewhere in the code.
Honest question, would you mind pointing out any resources you've found regarding routing, templating, and other "framework-y" functionality done in vanilla JS? I'm interested in strengthening my admittedly terrible JS foundations, while also looking to get into creating SPAs that are as optimized as possible.
Actually, the shim they are using uses script onreadystatechange for IE8 : https://github.com/Katochimoto/setImmediate/blob/master/src/setImmediate.js#L109-L110 https://github.com/Katochimoto/setImmediate/blob/master/src/polifill/readyStateChange.js However, in IE10 due to a bug in how setImmediete works, it does end up going to setTimeout. 
Hmm my method is working very unreliably. Can you manage to get the 1080p DASH and audio files to download without the use of autoinput? Then I can easily merge them together with Tasker and ffmpeg
~~It's resolved immediately, but callbacks are always called on the next tick, which is all you want if you're just yielding the thread:~~ (see my more recent comment) Promise.resolve().then(function(){console.log('hello')}); console.log('goodbye'); // goodbye // hello
Versions change fast these days.
So it has more to do with the features in JavaScript at the time than any preferences by the node designers. Makes sense. Thanks for the comment.
I'm definitely going to get this, but can you tell me how it changed your life? Are you saying that with just that book, one is potentially ready for some sort of job programming in js?
Ahh! Is there any resource you know that I could learn more about this ticking process?
Poor Safari is undefined
I could add in fixes, but I have had my laugh for the day.
Whoa. I just assumed that "1.5" was inspired by Java's old version conventions and didn't bother to check twice. 
Why do people keep publishing the same worn out content? Yes, we know about Babel, and are already using it. Thanks.
So disturbing to discuss the potential future of Javascript in the Javascript subreddit!
There are a ton of people who do not and this article is for them. 
What does this offer over .call() except saving a couple characters? More importantly, .call() should be used sparingly and .bind() should be avoided (abysmal performance and harder debugging). Why make these easier to use with dedicated syntax? I know lua does something similar, but I don't think JS needs this 'feature' as well.
Then read my blog post: http://bl.ather.on/why-i-forkd-deferricons-all-hail-deferricurious
Hi /u/YOBCZWHYNOT, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `dibaiee.ir`. domain submitted from|count|% :-|-:|-: [dibaiee.ir](/search?q=%28and+site%3A%27dibaiee.ir%27+author%3A%27YOBCZWHYNOT%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|5|83% Thanks for your consideration!
The issue I have is that it adds unnecessary syntax. Virtual methods attempt to solve a problem that JS doesn't have at the expense of cognitive overhead. The pipe function and currying/partial application does the same thing without extra syntax. Babel recently added support for this bind operator. Here's their examples ([source](http://babeljs.io/blog/2015/05/14/function-bind/)). //Babel ES6 example import { map, takeWhile, forEach } from "iterlib"; let _val; _val = getPlayers(); _val = map.call(_val, x =&gt; x.character()); _val = takeWhile.call(_val, x =&gt; x.strength &gt; 100); _val = forEach.call(_val, x =&gt; console.log(x)); //Babel ES7 example import { map, takeWhile, forEach } from "iterlib"; getPlayers() ::map(x =&gt; x.character()) ::takeWhile(x =&gt; x.strength &gt; 100) ::forEach(x =&gt; console.log(x)); An example using Ramda and ES6 functions. Lodash-fp can do the same thing as well. Change the fat arrows to functions and it's ES5.1 which works today (without compilation). var R = require('ramda'); //we get a function that we can reuse var dry = R.pipe( getPlayers, R.map(x =&gt; x.character()), R.takeWhile(x =&gt; x.strength &gt; 100), R.forEach(x =&gt; console.log(x)) ); dry(); dry(); The Ramda example is DRY (reusing chains in data processing is common, but the Babel examples need to be wrapped in a function to do this). It doesn't need me to track variables, and most importantly, I may have problems, but 'this' isn't one of them (seriously, 'this' causes a lot of JS bugs).
There are three points here. First is that ES6 is a final draft (aka, fix the spelling errors and go) which is going to be finalized in a few weeks, so becoming familiar with the new standard is important. Second is that the ECMAScript committee doesn't want to make decisions in a vacuum. They want feedback on ideas and they can't get this unless developers read and comment. Reddit seems like a great place for this to happen. Third, Babel has added support for this feature, so you can use it today, compile, and run everywhere.
Thank you a lot for your time to explain! :)
&gt; Putting x outside the function(), wont recognize the var This assumption is incorrect. The code above is proof.
The world doesn't resolve around you sir!
A bit of a reminder that ES6 classes are still prototypes underneath, and a cool way you can take advantage of that. This also is a way to still use mixins if you're now defining your React components with ES6 classes.
Hi, what are you trying to do? I wouldn't expect to use jQuery with node however if I can understand what you are trying to achieve I may be able to offer advice?
&gt; Third, Babel has added support for this feature, so you can use it today, compile, and run everywhere. And yet people still won't just embrace a bytecode interpreter in the browser. If we're just going to write our code in whatever language and whatever version of those languages we want, I wonder why we never go the full nine yards.
Thanks. Looks promising. Especially paired with /u/mkmoshe answer
If you use Chrome the, the add-on you want is called TamperMonkey
https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript I think that adding PNaCl to the browser is the best option. Make a good bytecode and a take that chance to make a good low-level API that languages can plug into. Once that is done, simply make JS the 'default' implementation on top of that. I think the JS people have a vested interest in the language. We're basically doing this already via asm.js which is "backward compatible", but runs code that would actually cripple old browsers if you tried to run it there. The biggest problem IMHO is those C# or Java programmers that insist on transforming JS into what they already know rather than learning the language properly. 
I feel like this is overkill
No matter where you put it it will be available to whoever knows what they are doing to sniff if out. Essentially your token is like a public key (in the sense that security is not compromised by hijacking it). For a site I worked on for my previous gig we added our token the ajax header ($.ajax({headers: {...}})) and where fine.
I think I like the wider utility of [is.js](http://arasatasaygin.github.io/is.js/) just a tad more.
This is essentially what I'm doing, it is being added to the light wrapper for ajax in durandal. I just wasn't sure if *storing* it in a function prototype was more or less safe than some other method of storing it. 
And yet none of this is really true. It's the job of compilers and interpreters to handle the necessary transformations into a set of instructions. For an obvious example, /u/androbat made mention of asm.js. Right now it's as close as we have to a bytecode interpreter in the browser. The difference is that JavaScript is acting as the bytecode. Some other examples are C, C++, Rust, assembly, et al. Granted we're beyond bytecode at this point. In fact, the situation is more complex as the compilers need to output machine code that runs on innumerable architectures, not just a single bytecode and a handful of browsers. While a lot of the comments on that post are vitriol, there are sound responses as well. In the end, history has shown that his position is simply incorrect.
Good article! It's important to remark that mixins **must** be defined as objects in ES2015 since methods defined using class syntax are not enumerable by default. Object.assign works only on enumerable properties.
Phaser.io uses Pixi.js instead of the canvas, which is a super performing replacement for Canvas, and should probably be the answer for OP's question as well. 
Go with a MEAN stack if you want to learn the full-stack experience, or go with Meteor, which has everything tightly packed in one place.
&gt; ES6 is still prototype-based (and why that's still bad) The author's position is that this is awesome, not bad. And one of the reasons the author feels this way is that instead of having a benevolent dictators just "change the language," people have the flexibility to try things. Lots of people tried making their own classes, the idiom proved of interest, and thus sugar is in the language. And lots of people tried composing little functions, and CoffeeScript's arrow notation was popular, so they're in the language too. Having simple things that you can use to build other things is bad in one way: You get a Cambrian Explosion of people inventing their own stuff, but good in another way: People can try different things and popularity wins out for better or for worse. JavaScript, especially now that transpiling is a normal thing, is quickly becoming a true community-driven language. *And that is very interesting*. Whether the author personally agrees or disagrees with every decision, they're extremely interested in watching this unfold. *Disclaimer: The author speaks of themself in the third person, and we really can't trust anyone with an ego the size of the Hindenburg.*
&gt; What does this offer over .call() except saving a couple characters? It looks more like a method. Extending built-ins (monkey-patching) has many downsides, but people still did it because it allowed them to write the kind of code they desired. They wanted strings to have "startsWith", "contains", "trim", etc methods. I'd prefer if promises had a "timeout" method like they do in Dart. Essentially, it's the same as this: http://en.wikipedia.org/wiki/Desire_path Putting up more "don't step on the grass" signs will not prevent this nor will it improve the situation. Virtual methods give you a better way to do this kind of thing. They aren't global and others who read the code can clearly see that this method isn't a regular method. You'll even be able to jump to its definition. &gt; More importantly, .call() should be used sparingly and .bind() should be avoided (abysmal performance and harder debugging). Just because performance isn't currently that great doesn't mean that there isn't a way to improve it. In Dart, for example, forEach is just as fast as a for-loop. Just because you put some function there doesn't mean that the VM actually has to call a function. It only has to do something which will yield the same result. So, if you create some local instances of some object and pretend that it has these 3 additional methods, the VM could just create a hidden class which does have these 3 additional methods. No one will be able to tell the difference.
This isn't a help article, but it's not letting me remove the "help" flair.
Why not use CSS3 transition
Yeah, I was thinking CSS, but the book I am using says as a challenge to try and use only JavaScript, so I figured, challenge accepted!
&gt; If you want classical inheritance (like the vast majority of average programmers do), then ~~change the~~ use a different language. FTFY
Maybe I'm old, but most of these libraries I see posted make me think "kids these days." Everyone wants to bend the language with libraries. http://vanilla-js.com/
So long as you realise that you aren't making classes and mixins, but functions with methods delegated to the prototype. In other words, you're still doing what you don't like to see, making it purely a cosmetic exercise by using different keywords.
What he's saying is that methods declared in a class definition don't have `enumerable: true` set in their property descriptors, so their names aren't returned by `Object.keys`, `hasOwnProperty` and the like. And you meant to say "`fu` doesn't get set as a delegation target on `sna`"
And it's not practical to expect a language that doesn't have inheritance to be altered to support it just because people have the delusion that that language should adhere to classic OOP principles.
It's also an unnecessary reminder that if something isn't a primitive in JavaScript *then it's an object*. `prototype`, `constructor`, arrays, functions, etc.. All objects. Every single one.
Thanks - yes, we really love what BlockSpring are doing. I think the main difference is that BlockSpring are helping more general users to create cloud functions while we're looking at creating cloud APIs to help web developers.
I think they meant this Object.assign(sna, class { fu() { } }); Or the variant `(class {}).prototype` 
No, not at all. I should make the usage tab more obvious as a lot of people have not realized the examples under there.
er, what's the backstory to this?
You can check if you are running in the browser pretty easily by seeing if the window object exists. if(typeof window === 'undefined') { // use node api } else { // use browser api }
Interesting article and shows that the JavaScript community is continuing to move in a functional direction. Functional programming is incredibly elegant and powerful, and I hope the trend will continue. If you like functional programming or want to wet your feet, check out [Ramda](http://ramdajs.com/). If you don't understand the differences of say, Ramda vs Lodash, check out the links under *What's different?*. Edit: And of course, [lodash-fp](https://github.com/lodash/lodash-fp).
You should use Browserify! https://github.com/mafintosh/browserify-fs This way you can use the exact same fs API without any environment checking.
Took a look at is.js, and it's a great library. The focus of xtypejs though is purely on data and robust performance. A check like [this one](http://xtype.js.org/usage/checking_combination_of_types) for instance, is optimized to be minimally expensive while also producing clear, concise, readable code. (Be sure to also take a look at the 'compact' tab of that example.) You can also mix in instance types, as in [this example scenario](http://xtype.js.org/usage/checking_instance_and_other_types) for displaying a product. Another example is to actually [switch on the types](http://xtype.js.org/usage/switching_based_on_value_type), all with very little code. 
👍🏽 for Ramda.
Ah okay well you could use canvas or effect css with Javascript :)
It's said "Heil" not "I agree".
You could look into brfs and bulkify to inline the contents into your bundle. Or maybe get somewhere with the "browser" field; eg run a pre-publish step which spits out the result of the node validation as JSON, and the "browser" field just stubs that for API parity. 
It personally changed my life because it was my first step towards achieving the goal I had set for myself, which was to become a web developer. I was laid off from a job in a different career, so on the day I got laid off I picked up that book and started working through it. 5 months later (about 3 to go through the book and a couple more learning some other things, for example, jQuery) I knew enough js to get a job as a front end web developer. I mostly work in HTML/CSS but I definitely wouldn't have gotten the job without knowing what I knew about JS. I was able to use JS and AJAX to create some unique solutions to the challenges presented to me when I was doing a sort of trial internship for the job. That book is the only book I bought. I used the internet for any other resources. But the book definitely helped me develop a nice familiarity with JS, and for that reason I am very satisfied with the purchase.
Wait... are you the same guy as /u/poopysaurusrex? Weird... No problem! And seriously, reach out to me whenever you would like to discuss html/css/javascript. I'll try to help you out as it also helps me to learn! And here, don't wast your money on buying books: http://eloquentjavascript.net/. Also: http://www.codecademy.com/en/tracks/javascript 
Love the idea! I'm using ghooks at the moment, but you still have to manually invoke gulps execution. Definitely going to give this a shot shortly. Thanks for the hard work
It'd be a nice datapoint. More on Hidden Classes: https://developers.google.com/v8/design
Lots of languages compile to javascript.
I highly recommend starting as "support" (which can be a broad category, and on not-primarily-tech companies, likely to require a broader but not as deep skillset) or QA (if you like breaking things and automation) QA is less demanding in some ways and more in others (but I feel free like the hiring process for QA is more forgiving for entry level than development), but QA lets you learn the product and technology of the company in a broader perspective which will help you be a better developer when you get there... I personally started in general support doing daily processes to keep shit running and a bit of reporting/dba overflow tasks, then moved to another company as QA for a mostly Javascript project, and ended up prototyping enough fixes, and putting enough code in tickets ( I started filing more tickets like: "bug on line x, which causes this undesirable behavior y, replacing with this line with code line z should fix issue" vs "page doesn't do x" ) so w/o asking they offered me a developer position... so I get here via an unusual path
Most other replies here are pretty reasonable: why would you need a library for such trivial and infrequent stuff? Well, I personally have to do quite a few of these checks manually, and when I work on new projects I need to copy the utils directory over every single time... not that it's a HUGE pain, but it's definitely nicer to just put a package in my package.json and know that all the utils are tested and working efficiently. Good job, OP!
&gt; Specifically the compiler creates a ".js" file for each ".ts" file and that exists in the same directory as the ".ts" In the `tsconfig.json`: "compileOnSave": false https://github.com/TypeStrong/atom-typescript/blob/master/docs/tsconfig.md#compileonsave Not really sure what issues you're having with modules, it supports ES6 and CommonJS import syntax. You may need to get the declaration files for the libraries you use though. Get [tsd](https://github.com/DefinitelyTyped/tsd) which is like a package manager for TypeScript definitions. All available definitions are here: https://github.com/borisyankov/DefinitelyTyped Fyi, TypeScript still uses a reference path for declarations (since you don't import them). Just create a `tsd.d.ts` file to import all your 3rd party definitions and include that in your TypeScript build (or let tsd do it). For more info: https://github.com/DefinitelyTyped/tsd#tsddts [atom-typescript gitter](https://gitter.im/TypeStrong/atom-typescript) for more help.
For what it is worth, I wrote an entire SPA using nothing but Promises, jQuery, and Bootstrap. The hardest part was URL handling and the history API (pushState). Whether or not you'd want to go down the same adventure and have everybody in IRC and this subreddit heavily critique you is your decision. :P
I'm trying to make a plugin to make a slider and attach it to my .ejs file (just for experimental/learning purpose). To do this, I understand that I need to listen to the event that is that is being called on the element, somehting like $('#mybutton').onclick. How do I do that? (Sorry this may be another stupid question)
You may click the link of the post title to view the full question at StackOverflow. Hope someone would be of help.
That looks pretty clean to me! What bugs you about it?
Using contains.call() doesn't add a method. Array.prototype.contains = function () {} adds a method. The first calls a function while the second extends a built-in (which is not what you appeared to say). &gt; Needlessly noisy example. What could I take away from that example and still show what happens and why it happens? &gt; According to your comment, it outputs "123blah". The expected output is "abcblah", NOT "123blah" which illustrates that the 'this' that I pass in is completely ignored, but no error is issued and instead, I get garbage that is hard to debug. &gt; And if you use ::, you can't? The operator is overloaded so telling unary from binary isn't nearly as easy at a glance as 'call' vs 'bind'. Further, I still can't tell you if the function performs a series of binds and then calls the results or performs a series of calls (which are very different things in JS both in performance and excution).
&gt; There will always be hordes and hordes of average "show me da codez" 9-5 developers I'm not sure that making fun of them changes how it's a practical concern. Out of all theese [prototypical languages](http://en.wikipedia.org/wiki/Prototype-based_programming#Languages_supporting_prototype-based_programming), is javascript in use because it's the only guaranteed option on a ubiquitous platform or because it's unusually powerful? &gt; never-ending hysteria about how badly they're going to be confused by JavaScript classes Classes syntax doesn't address any legitimate issue. I don't believe anyone will be any more confused than they would already be, when faced with the mutating classes of a prototypical language.
&gt; Using contains.call() doesn't add a method. Array.prototype.contains = function () {} adds a method. No shit.
From what I understand, generators were intended for library designers more than end-users (just like Proxies and Reflections or the Object methods from ES5). async/await are the syntactic sugar for the most typical generator cases and because they are a specific type of generator, they can probably be more optimized than regular generators which aren't really optimized at all (and there don't seem to be any plans to optimize them any time soon -- which is why generators should only be used to call other functions which may then be optimized).
That article is on the past, if promises makes your code better - use it! None should suffer from callback hell, it's becoming the past. You can use promises, async/await (will be on ES7, and it's already on Babel and Typescript, Fibers (the way Meteor choose)...
bookmarked/stared Zousan, I chuckled on the reason you called that way - good naming =p.
There's demand for junior devs who've cobbled together a few minor personal accomplishments. Hello world programs don't cut it, nor things copied/modified from courseware. But if you've demonstrably built a few cool things from scratch yourself, you have a shot. Being junior + a telecommute requirement may introduce some friction to the process, unfortunately.
&gt; It looks more like a method. Extending built-ins (monkey-patching) has many downsides....They wanted strings to have "startsWith", "contains", "trim", etc methods. and &gt; Monkey-patching is what people did to add their own methods. I said you didn't need to extend the prototype if you use .call(). How will :: help this "monkey patching" if .call() already exists and isn't used? After all, in order to use it, you still need to know about .call() at which point, the glanceably explicit nature of .call() and the fact that it is easily discernible from .bind() seems to make the operator wasted (and that's before considering that most people will assume it is a namespace operator like in every other language). &gt; No shit. Rather than attack me, it would be more conducive to other readers if you addressed my points about function-bind's performance, bugs, ease of recognition when coding, and difference from typical usage of the operator.
&gt; How will :: help this "monkey patching" I already covered this in my first reply. &gt; Rather than attack me You're the one who assumes that the other party is an idiot. I just got tired of it. We also went through this 2 times already. I know what call does. I already told you that. Twice. Talk to someone else.
I'm using a templating engine, .ejs file. So does that mean I can't include jQuery script tag in the .ejs file?
either or... I'm only one data point, but I do feel like those previous two positions were a progression and all contributed to useful experience for the next, and each was right for me at the time... so definitely, get an entry level doing what you think you want now, but don't hesitate to move around to related roles later if you feel like you'll be happier there... cheers
I'd be curious how this strategy (running CPU-bound calculations in child processes) compares to running them in the same thread but running the whole app clustered? What are the trade-offs?
stick your utils directory in a repo somewhere and reference it in your package.json
The most glaring difference between those two snippets that you claim to be identical, is that one uses quotation marks, and the other *(that doesn't run)* uses... those things that look like italicised quotations, but **AREN'T**. You're not using quotation marks (double apostrophes?) in your code that '*doesn't work*', you're incorrectly using what looks like a *double grave accent*, which is most certainly **not recognised as an equivalent to quotation marks** (They are completely different characters). **Edit:** It's not even a double grave accent, it's the angled left and right quotation marks. You only ever want to be using apostrophes, and double apostrophes (well, quotation marks) - the vertical, non-slanted ones. Hope that solves your problem!!
I would say that telling newbie JS programmers to "just learn the fucking language" is akin to telling a Windows user to "just fucking install Gentoo". The learning curve for becoming an expert in JS is just too steep, so it is not that hard to understand where people are coming from when they want the familiar stuff. There is a reason why there are so many code-assisting tools in JS, it is way too easy to fuck up real bad in it.
If you're running an instance on each CPU for clustered, then all the child process would do is slow down the core it's running on. This would make all requests to that process take longer. While that sounds bad, this could be good because if all of the processes in your cluster decide to process the calculations in the same thread, someone attempting to connect to your site wouldn't be able to until one of the calculations is complete. Sorry if any of that's confusing, I probably need some sleep.
The problem is people *do* think there is but one definition. Mainly because they've been told that endlessly.
No. What object is `sna` delegating to? The above code is basically the same as: let p = { fu() { return "foo" } } let sna = {} sna.fu = p.fu; console.log(sna.fu()); Would you say that `sna.fu = p.fu` is delegation?
This is why you have a build directory that compiled files go into. You can then just ignore this dir and delete it whenever you like. gulp.src('src/*').pipe(do).pipe(gulp.dest('build'))
There is also [Underscore](http://underscorejs.org/#template) and [LoDash](https://lodash.com/docs#template) templating.
Yeah I'm aware there is plenty more :) I've had a look at the different options out there and dust.js appeals to me most. I'm just curious what frontend devs are successfully using, perhaps with experience with template languages and any issues they ran into. I might as well pick up Ember/Angular/React and save time if there isn't much point building an app on a template language for the view. I'm using express on a node.js backend if that makes any difference.
/r/remotejs
It depends what you build, but I like react a lot for data-ui handling. You can use react router and build it as SPA or use it just as a view in MVC
&gt; Err, yeah. sna doesn't get a copy of p's fu method. Right, it gets a copy of a reference to `p`'s `fu` method. Delegation is an entirely different concept. `Object.create` delegates, `Object.assign` copies.
The [polyfill the author mentions uses an `onreadystatechange` hack, which is apparently faster than `setTimeout`](https://github.com/Katochimoto/setImmediate#script-onreadystatechange). The only polyfill for web workers I could find has the caveat that it's single threaded, so that wouldn't actually solve the problem at all.
Anytime I hear this, I [like to link to this post](https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/)
A copy of a reference to a method on an object *is* delegation. Or perhaps you think the original notion of delegation on [Wikipedia](https://en.wikipedia.org/wiki/Delegation_\(programming\)) is wrong... Also, if only `Object.assign()` did copy... let p = { fu() { return 'foo'; } } let sna = {} Object.assign(sna, p) console.log(sna.fu === p.fu) // true Because `sna.fu` is *absolutely* equal to `p.fu` that means that `fu` has been delegated. If it was copied they would be different instances of `Function`.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Delegation (programming)**](https://en.wikipedia.org/wiki/Delegation%20(programming\)): [](#sfw) --- &gt; &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), there are three related notions of __delegation__. &gt; &gt;* In its original usage, delegation refers to one object relying upon another to provide a specified set of functionalities. In research, this is often referred to as __consultation__ or as __aggregation__ in modeling. &gt;* In [Common Language Infrastructure](https://en.wikipedia.org/wiki/Common_Language_Infrastructure) (CLI), a [delegate](https://en.wikipedia.org/wiki/Delegate_(CLI\)) is a form of [type-safe](https://en.wikipedia.org/wiki/Type_safety) [function pointer](https://en.wikipedia.org/wiki/Function_pointer) usually used in an [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern) as a means telling which method to call when an event is triggered, keeping the method type. &gt;* Rarely, it refers to a programming language feature making use of the method lookup rules for dispatching so-called self-calls as defined by [Lieberman](https://en.wikipedia.org/wiki/Henry_Lieberman) in his 1986 paper "Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems". Delegation as a language feature supports the [prototype-based programming](https://en.wikipedia.org/wiki/Prototype-based_programming) model. &gt;Despite delegation being fairly widespread, relatively few major programming languages implement delegation as an alternative model to [static inheritance](https://en.wikipedia.org/wiki/Static_inheritance). The [Self](https://en.wikipedia.org/wiki/Self_(programming_language\)) programming language incorporates the notion of delegation through its notion of mutable parent slots that are used upon method lookup on self calls. &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), a __multicast delegate__ is a delegate that points to several methods. Multicast delegation is a mechanism that provides functionality to execute more than one method. There is a list of delegates maintained internally, and when the multicast delegate is invoked, the list of delegates is executed. &gt; --- ^Interesting: [^Delegate ^\(CLI)](https://en.wikipedia.org/wiki/Delegate_\(CLI\)) ^| [^Protocol ^\(object-oriented ^programming)](https://en.wikipedia.org/wiki/Protocol_\(object-oriented_programming\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cs2wpfo) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cs2wpfo)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Schroedinger's cat. A primitive is a primitive until you want to look at it, at which point it gets boxed.
This is so lucid. Though I will say: being willing to work at intern rates for 6-12 months worked great for me. The enterprise consulting startup I found through my tech school job board only paid me $600/week for 8 months, but the sheer quantity and quality of full-stack training they gave me was astounding. One year later, I am now intermediate-to-advanced in SQL, C#, JavaScript and HTML/CSS. I can go start-to-finish on complete business management applications, and mostly by myself. All of which is to say: being willing to work your butt off at intern rates for a good smaller company can be a life changer. If you can leverage that time to become skilled in all aspects of application development, then you will have real bargaining power. Of course, the fact remains that working your butt to the nub is part of the deal...
On this you are spot-on. People have been told endlessly that OOP is such-and-such. Amusingly, most of the things people claim are OOP are things that horrify Dr. Alan Kay, the man who coined the term in the first place.
Actually it's one of those optimizations that increase readability, as changing a class while instances exist can change the behavior of those instances, making it difficult to reason about what a class does. The fact that its high speed as well is gravy. You are right though, in the sense that choosing classes where they don't make sense because of some perceived performance benefit without measuring is bad. 
If an object *has* a prototype. The result of `Object.create(null)` doesn't, but nothing stops you from assigning it later. Or overriding it with another object even later. `prototype` is just a "special" thing that gets automatically enumerated if necessary. `constructor` is another "special" property. Using the word "class" in a language that doesn't have them doesn't fit, IMO. We're coming at this from opposite directions, and I'm not sure we'll ever reach a mid point...
Yes, but eventually you take Babel away when ES6 is fully implemented in the browser (which isn't too far away). Then you're left with native code. I agree that Typescript has other benefits, such as typing, but if we're talking about ES7, let's talk again in 7-8 years :)
Well, you can, but then jQuery would only be available on the page with that script tag. It's better practice to include libraries like jQuery on the main page so it's globally accessible. 
The problem is constructor chaining and identity change is a real probability in Javascript unlike other languages where you can change the "prototype" on the fly as well. For example in Python your class will always be your class because whenever Python see's class Foo, it gives Foo a unique identifier even if Foo was already defined. In JS you can change the identity of your class by simply changing .prototype.constructor; Also constructor chaining when you need to fit objects into different patterns is also a concern. In JS var foo = new Foo(1, 2, 3); Is syntatic sugar for. var foo = Object.create(Foo.prototype); Foo.call(foo, 1, 2, 3); What you can actually do is something like this function Foo() { this.x = 'test'; } function Instance(Foo) { if (this &amp;&amp; this.constructor === Foo) { Foo.call(this); } else if (this) { throw new TypeError("Can't be called as a mixin"); } else { return new Foo(); } } Which allows you to use Instance as a function or as a constructor seamlessly. With the classes syntax this becomes even more non-obvious.
To add on to what /u/wjohnsto said, if you're missing a declaration file, just create a shim declaration that returns you an `any` object. I've never used Kefir, but here's my stab at it: **kefir.d.ts** declare module 'kefir' { var kefir: any; export default kefir; } Then in your code you can just do: import kefir from 'kefir'; There is also a pretty silly *hack* you can do with TypeScript, which may be useful for Webpack, as you can require things other than JS modules (like HTML, CSS). declare function require(name: string): any; If you want to support the community, feel free to contribute back to DefinitelyTyped, they are good about accepting PR's for definitions.
Cool! Reminds me of some of the really old Windows screensavers :)
Winamp player visuals
cool
Still not sure how I feel about the arrow functions having lexical *this* . It seems like it's taking something that's a little confusing (*this* is always controlled by how the function is called and never by how it is declared) and making it into something that is a lot more confusing ( ...*unless* it's and arrow function, then... )
Closure is awesome, it's too bad not a lot of people know about it. I haven't used a lot of the features but my favorite is the [AvlTree](https://closure-library.googlecode.com/git-history/docs/class_goog_structs_AvlTree.html) class.
You don't need the language or type attributes, just use: &lt;script&gt; //your wonderful code here. &lt;/script&gt; Or: &lt;script src="path/to/your/wonderful/code.js"&gt; The language attribute has been deprecated for a long time now. Browsers use text/javascript as the default as well, so you don't really need to specify it.
It is actually explicit... you just aren't used to the syntax. Destructuring has been about in CoffeeScript for ages and is super useful and will be exactly the same in ES6/2015. Like all things, there's a time and a place for them but your piece point blank shoots it down because you are finding a hard time understanding it. That should tell you something, and it's not that "destructuring is terrible". Spend more time with it, you'll grow to like it!
It fits well with the new class syntax so you can call functions on the class(prototype) from within things like setTimeout or Promise.then because the scope is already there rather than having to bind it. 
I DO understand it, believe me, but many many new developers will not. My point wasn't "OMG I DON'T UNDERSTAND THIS I HATE IT I HATE IT..." it was, wow look at these terrible things you can do with it and how it's not easily understood at first glance. To me, its potential for pitfalls deter me away from any benefit
[The bug is still open](https://code.google.com/p/v8/issues/detail?id=2700). It should be available in Canary (dev maybe?) if you enable the experimental JavaScript stuff. chrome://flags/#enable-javascript-harmony This tweet is a rather misleading, really. It's getting really close, but it isn't done yet.
&gt; To me, its potential for pitfalls deter me away from any benefit This is what makes it sound like you don't understand it. It's a simple concept and when used in the way it should be used(ie. not overcomplicated just because you can), super useful. 
This is a highly silly argument and the examples are just terrible code in general. I could make a similar argument against almost any feature in javascript. Look, for loops are terrible and lead to non-performant code: for(var x = 0; x &lt; 100000000; x++) { for(var y = 0; y &lt; 100000000; y++) { for(var z = 0; z &lt; 10000000; z++) { console.log(x,y,z); } } } Who would put such a terrible feature in javascript?! gasp!
In algorithm analysis, the desire is to calculate the number of "operations" that a block of code requires in either the best, average, or worst case (typically worst case or average case). In order to calculate the number of "operations," we must determine how many operations each line of code requires. Usually that means "how many CPU operations." For example, we know that `++a;` takes one CPU operation via the x86 assembly instruction, `add` (assuming that variable is stored in a register). Now, the problem is that it isn't necessarily clear how many CPU operations each statement takes. (Different compilers might compile the same line differently, for example. Or, different languages might compile down into many different assembly instructions.) Therefore, it is necessary to define how many CPU instructions each operation in your programming language requires. Typically, we operate under the assumption that arithmetic, logical, and assignment instructions take 1 operation. Once we have some sort of model, we define a function `T(n)` that says, "If we're given `n` elements to work with, our code will execute `T(n)` CPU instructions." Some problems have more than one input, so you might have to define `T(n, m)` or `T(i, j, k)`. So if you had something like: function sumUpTo(target) { var sum = 0; for (var i = 1; i &lt;= target; ++i) { sum += i; } return sum; } First, we count the instructions: 1. Initialize `sum` to `0` = `1` operation 2. Initialize `i` to `1` = `1` operation 3. Compare `i` to `target`, happens `11` times (once for `1, 2, ..., 10, 11`) = `11` operations = `n + 1` operations 4. Add `1` to `i`, happens `10` times (once after `1, 2, ..., 10`) = `n` operations 5. Add `1` to `sum`, happens `10` times (once for `1, 2, ..., 10`) = `n` operations 6. Return `sum` = `1` operation Now, we add up all the operation counts: `T(n) = 1 + 1 + (n + 1) + n + n + 1` And simplify: `T(n) = 3n + 4` And that is the computational complexity of this algorithm! Here, the constant factor is `3`. If we define the number of operations each instruction contributes in a different way, we might end up with the different computational complexity. These small differences in constant factor are usually inconsequential when `n` is large. Therefore, we use Big O notation as a tool for classifying computational complexities. `O(3n + 4) == O(n)` So we say that this is a *linear algorithm*. Does that make sense?
I don't understand what you mean by "not explicit". It's very explicit, just like any other declaration. You're just not used to the syntax.
I don't understand why it's taken so fucking long to add support for this. Literally all they had to do was setup a regex replace to turn the fat arrow in source to function(){ … }.bind(this)
You could probably pick any JavaScript feature and describe it the same way: &gt; wow look at these terrible things you can do with it and how it's not easily understood at first glance constructor-function / prototype / \_\_proto__ / new / this Destructuring assignment is much easier to grok than most in my opinion.
From the POV of the caller though, functions have always been black boxes. For example you never know if what you're calling was produced by `bind()`, or if the function is bound to a lexical `self` that stands in for `this`, or if `this` is even relevant to its internal logic etc. So fat arrows don't make anything more or less confusing in that regard, but they definitely improve things from the point of view of the callee.
Last comment got removed cause I shortened the url, anyway; This XP screensaver: http://1cv4y131sweukg8sr2f7vd57.wpengine.netdna-cdn.com/wp-content/uploads/windows-xp-desktop-background-wallpaper-vortec-space-800x600.jpg
https://github.com/swift2js/swift2js
I agree for the most part, but what would you suggest be done instead? Remove classes from ES6? Also, the point is not that all abstractions are leaky, so it doesn't matter. The point is abstractions are useful, and 1) a decision has to be made about the utility of the abstraction vs the cost of it and 2) we still have to understand what's going on under the hood, which speaks more to your point.
Its not typescript, exactly. There are type annotations within the source but these are supported in babel with the flow transformer. More about flow: http://flowtype.org/ (flow in babel: https://babeljs.io/docs/advanced/transformers/other/flow/ )
The first 3 examples were all obvious to me. That's probably because I'm used to pattern matching syntax from other languages. Syntax that you are not used to is always strange at first.
Thanks.
I edited my comment, but it's essentially the same. Have you considered using decorators instead of flow as it wouldn't require a third party lib if you're using babel.
FINALLY. I've been waiting forever for this. It's one of those little things that adds just a *bit* more friction to using the Dev Tools console for debugging.
My only problem with the template strings is that if you want to use them as a clean way to do multi-line strings, indentation (i.e., spaces and tabs) are included in the actual string.
Ok, let me give a bit more real world example. I have two files. widgetA.js widgetB.js Both are importing Kefir an npm module (import Kefir from 'kefir'). I now want to move widgetB.js to use TypeScript (widgetB.ts). Please tell me if I'm missing any steps: - rename widgetB.js to widgetB.ts - create the shim file as you've outlined - add tsify to my browserify pipeline Is there anything else? Do I need a tsconfig? Do I need to a tsd file (DefinitelyTyped package manager)?
That comment doesn't _deserve_ good arguments!
You cannot capture this kind of thing in a benchmark. It could have anywhere from small to huge hit, it depends on too many things.
No, I mean if you use a class definition as a Mixin then Object.assign will not work. class MyMixin { foo() {}} class MyClass {} Object.assign(MyClass.prototype, MyMixin.prototype) 
Try using $.getJSON() The response from ipinfo.io wraps the JSON in parenthesis, but yours doesn't. If you change the type from jsonp to json, it seems to at least not throw an error.
There has been a lot of back-and-forth, but the behaviour appears to be that methods defined in a class definition are non-enumerable, but methods defined within an object definition are enumerable. Thus, the snippet I posted above works fine in Babel, because that's what they think is the specified behaviour. But the second snippet you posted is not going to work, as you say. You can't (easily) mix one class's prototype into another (or anything else). If it turns out that this behaviour does not match the spec, I will change my post, update my book, and file an issue against Babel. Thanks either way, important to be sure.
You can always borrow the `Object.assign` pattern from TFA: function MyClass { // ... } Object.assign(MyClass.prototype, { method1 () { ... }, method2 () { ... }, method3 () { ... } });
I changed the code: http://jsfiddle.net/b4rbapn2/ &gt; Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://menshealthherbalpharmacy.com/test/json2.php. (Reason: CORS request failed). It works when I changed my script to create jsonp: &lt;?php header('Content-Type: application/json'); $data = array( 'ip' =&gt; $_SERVER["HTTP_CF_CONNECTING_IP"], 'country' =&gt; $_SERVER["HTTP_CF_IPCOUNTRY"] ); echo $_GET['callback'] . '('.json_encode($data).')'; ?&gt; http://jsfiddle.net/y3ucpwah/
&gt; It *can* be useful and enable you to write some pretty clean code, but its potential for misuse outweighs its benefit. Can't the same be said for most of JavaScript? - some of the flexibility it allows can lead to clean code, but can also lend itself to misuse and confusing as hell things. Just because a tool can be misused, doesn't mean that it should never be used.
&gt; If you'd like to show off your latest project, then that's great! We love seeing what fellow redditors can come up with. However, the same posting rules apply: it must relate to JavaScript. For example, this could be a link to the project page (unminified/unobfuscated source code), or maybe an overview of your architectural decisions, a code review request, etc.; you can even do so in the comments if the site itself doesn't meet the posting criteria. NOTE: The fact that a site was made with JavaScript does not automatically make it eligible to be posted to /r/javascript, including games. If we allow any site that uses JS to be posted to /r/javascript, then we'd soon be indistinguishable from /r/WebGames, /r/InternetIsBeautiful, etc. Instead, we aim to foster discussions around the source code, and/or the development processes and practices used to create the project.
CoffeeScript managed to pull it off.
There's a decorator library using this. I plan to open-source that as well in the near future.
What you have said should work, note my comment as I have outlined what the kefir.d.ts might actually look like. You may have trouble getting it to run if you use the declaration from /u/skitch920. I took a look at Kefir to better be able to provide you with a declaration. You have two options, since Kefir actually circularly references itself on the export: First (my recommendation): declare module 'kefir' { var kefir: any; export = kefir; } To use this: import * as Kefir from 'kefir'; Or you can use this declaration: declare module 'kefir' { var kefir: { Kefir: any; }; export = kefir; } And use this: import {Kefir} from 'kefir'; You need to make sure this declaration is available in the file that imports Kefir. You can do that via `/// &lt;reference path="kefir.d.ts" /&gt;`, or (if you're using a tsconfig to compile the ts) you can just include the kefir.d.ts in the tsconfig.files. I would **highly** recommend using a tsconfig.json, as this is what `tsc` and IDEs will be using to compile TypeScript going forward. Take a look at the following npm modules I've written to help manage/extend the tsconfig.json: - [tsconfig-glob](https://github.com/wjohnsto/tsconfig-glob): Provides a mechanism for globbing .ts files (instead of listing all of them) - [tsconfig-lint](https://github.com/wjohnsto/tsconfig-lint): Allows you to run tslint using rules specified in the tsconfig.json. 
If you're talking about a library, npm certainly is the way to go these days. The commonJS/node.js modules standard is only a stop gap until ES6 modules are supported natively. I wouldn't bother with bower. It's just a glorified wget with half-baked dependency management.
My comment was in reply to a borderline-troll pile of nonsense with such gems as &gt; ES6 is still prototype-based (and why that's still bad). and &gt; If you want classical inheritance (like the vast majority of average programmers do), then change the language. Don't just try to misdirect the masses with sugar I was talking about the developers who can't be bothered to **learn** the language they're using, JavaScript in this case, and who would prefer JS become Java since they know classical inheritance and don't want to learn anything new. I don't know what % of the population of all developers they represent (small, hopefully) but I don't think we should be worrying that they'll misunderstand `class` and build the language around their ignorance. It was of course merely my opinion (and yes, an arrogant one). You of course are free to disagree, and I never meant to imply that you have to justify why you do :)
Well, my current browser (chrome canary, updated today) is sitting at 45.0.2429.0 and it shows: http://i.imgur.com/9KvrVDO.png I'm assuming it's because I have the chrome://flags harmony flag set.
CoffeeScript is not a browser.
What is going on with firefox?
I wonder if the Chrome implementation is really equivalent to your solution. My guess would be that they pass this by reference rather than value as an optimization. That's why you shouldn't use `=&gt;` when you can get away with `-&gt;` in CoffeeScript (you start eating up a lot of memory). As I understand it, JS is only getting `=&gt;` which I expect people will use when they don't need to close over this (like the example in the tweet) so it is important to optimize the call to not have a performance hit. 
Arrow functions don't have that "arguments" thingy, there is no prototype, lexical super/new.target, ... Maybe you should actually look into this first. Also, "literally" some regex? You think that having some regex-based preprocessing step is the way to do this?
A bit of further reading on frontend modules: - [npm module basics](https://github.com/Jam3/jam3-lesson-module-basics) - [npm module creation](https://github.com/Jam3/jam3-lesson-module-creation)
The problem is not with multiplying. The problem is in `0`. for (i = 0; i &lt; 5; i=i*2) So, `i` starts at `0`. Then `0*2` is...? ;)
I'm guessing their implementation is still experimental and not much attention has been given to optimization yet.
Arguments I've heard: - Today's bundling only works with JS, with scarce support for only a few other file types - Bundling is an extra step that we all need to do, so best to do natively if possible - Bundling is often done sub-optimally in complex situations, like loading assets post-load (probably in response to user interaction) but not loading dependencies of those assets that are already loaded, leading to bundling creating larger downloads and slower websites.
It does intend to eliminate them, not through the features mentioned in that article (which only make the trips faster) but through "server push", which allows the server to send your browser files that your browser hasn't yet requested. But for that to work the server needs to know which files to push, and AFAIK that's an open problem. See my speculation about it in the third paragraph of my original post.
Not positive, but I think it's under flags for Chrome also.
lol.
Formatted: var bardata = []; d3.csv('data copy.csv', function(data) { for (key in data) { bardata.push(data[key].CommonSpeciesName) } var datum = { }; for (var i = 0, j = bardata.length; i &lt; j; i++) { if (datum[bardata[i]]) { datum[bardata[i]]++; } else { datum[bardata[i]] = 1; } } var data = []; $.each(datum, function ( index, value ) { data.push({species:index, count:value}); }); var data = data.slice(0, 5); var bardatas = d3.values(data); countinfo = []; for (var count in data) countinfo.push(data[count].count); function compare(a,b) { if (a.total &lt; b.total) return 1; if (a.total &gt; b.total) return -1; return 0; } data.sort(compare); Fyi, this won't even run because there is a missing bracket and I really encourage you to just clean up your code before you dump it to a post... But this is what I would have done... // d3.csv's second argument is an accessor for each row, not the whole dataset // the third function has access to the full data set and possibly an error d3.csv('data copy.csv', function (datum) { return datum['CommonSpeciesName']; }, function (data, error) { // Count up duplicates var speciesCount = {}; data.forEach(function (datum) { speciesCount[datum] = (speciesCount[datum] || 0) + 1; }); // Map it to a list of {species: &lt;name&gt;, count: &lt;count&gt;} var speciesKeys = Object.keys(speciesCount); var speciesList = speciesKeys.map(function (key) { return {species: key, count: [speciesCount[key]]}; }); // Sort by count? // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort speciesList.sort(function (a, b) { b.count - a.count; }); // Top 5 var barData = speciesList.splice(0, 5); // Update your chart with barData here... }); There is also a debugger in Chrome. Right+click, Inspect element, Sources pane