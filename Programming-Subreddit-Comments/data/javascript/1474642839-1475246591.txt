Cool! Thanks for the help it worked now
It cascades, but that doesn't make it *modular*. Anyway, leads to nothing right now. If you don't like it, don't use it.
I am currently looking which of those 3 frameworks I want to learn, and Vue.js looks most interesting to me. It appears to offer the same functionality like React or Angular, while beeing easier to learn. Tell me: Why should I learn React instead of Vue?
Typescript and Flow are similar in that they both introduce a form of static typing to Javascript, so yes if you use one you don't need the other. In terms of why you'd choose one over the other, it basically comes down to philosophy: Flow takes a more lightweight approach, Typescript a heavier one. As for missing out on Typescript if you switch to Flow, here's a list from a blog post from "That Typescript Guy" (https://medium.com/@basarat/typescript-vs-flowlang-caee1386b4fc#.gszm3nutl): * `.ts/.tsx` extension. I like having type annotation in a .ts file whereas flow encourages you to have `.js` extension which feels like an upgrade / deprecations nightmare. * Bootstrapped. I like that TypeScript is written in TypeScript (JavaScript) and just as portable as JavaScript. FlowType is in ocaml. * Third party JavaScript definitions : If you use jquery (or lodash or momentjs or your favorite JavaScript lib) and want to use it in a safe way TypeScript provides a very nice story aka DefinitelyTyped. * Of course the current TypeScript ecosystem is significantly bigger then the flow one so if you are looking for future safety the answer is fairly obvious. (Personally I don't find any of those reasons to be very compelling, but then again I tend to prefer lighter solutions in general.)
you're not storing what's input from the prompts. code should be: var a = prompt("enter a"); var b = prompt("enter b"); var c = prompt("enter c"); Also anything returned from prompt will be a string so you should parse int before you run any actions: var a = parseInt(prompt("enter a"), 10); var b = parseInt(prompt("enter b"), 10); var c = parseInt(prompt("enter c"), 10);
React is not a framework. It's just a library, you can use it with everything.
No it doesn't. There's a difference between a slot containing "undefined" and a non-existent slot. let a = [undefined, undefined, 1]; let b = []; b[2] = 1; a.forEach(x =&gt; console.log(x)); b.forEach(x =&gt; console.log(x)); 
Riot much more easier than vue and react. 
Hey there, TypeScript PM here. TypeScript does have a few more goodies like parameter properties, accessibility modifiers, and enums. If you don't like these features, you don't have to necessarily use them, but for a lot of people they're *extremely* useful. Additionally, interfaces are a very powerful way to describe types in JS. People who try using something else after TypeScript have told us they really miss these features. I'll also point out that one of the reasons that TypeScript isn't currently a Babel plugin is for performance reasons. TypeScript is made to compile *very quickly* because iteration needs to take as little time as possible. While I don't think we're opposed to the idea of integrating with Babel in some way, there's a big advantage to the way that TypeScript exists today. In addition to that, TypeScript's editing experience is probably the best-in-class in the JavaScript world. That includes completions, navigation, and other goodies. I don't think I've seen as seamless an experience with anything else. This is especially helped out by the fact that we have such a large collection of `.d.ts` files on [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/), which basically means you can get a great experience for any library you use. Let me know if you have any other questions!
I looked at your "perfection" - please stay away from UX, design and web programming. What you have done is horrible on many levels, and you're just unable to accept that.
point of order: [vue isn't the default framework for laravel](https://www.reddit.com/r/javascript/comments/4v0u0y/php_framework_laravel_selects_vuejs_as_default/)
Correct, except for the last paragraph. Setting `length` to 0 removes all elements whose indices are 0 or higher.
Is there a place where I can learn these design patterns? I'm sort of guilty of that one line jawn
I simplified. It's *possible*, it's just not *wise*. Securing a direct connection to a database is insanely difficult.
One thing I want to ask right now - can you clarify the usage of performance.now? I've looked at a few documentation pages and I'm not understanding what is occuring. Is performance a constantly updating variable? Respective to what?
Completely missing the point of both libraries.
OP meant "speed factor rather than time units", and this approach sounds better indeed, until you implement responsive pages and realize there should also be an offset factor :)
Also, could you point me towards a resource where I could learn the syntax at line 46? I have no idea what that is or does 
No not stupid. The spec is badly written and now won't ever change. I battled through this crap recently too. Another issue is how parentheses are optional for single arguments but required for multiple. Just pick one or the other! Still deciding if I want to just always require parentheses regardless of argument number. 
Awesome! That makes sense. I was just reading a Google article on it that had explained it to me well before I read your reply on this one. I guess it makes more sense to use this rather than Date.
It is a [template literal](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals), a newish way to write interpolated strings added to the javascript language in its 2015's revision. In the example at line 46 you could have written, with the same result: pre.innerHTML = 'state: ' + state[0] + '\nsince: ' + state[1] It is just more convenient (and less ubiquitous since it is a new feature that only modern browsers support). By the way, it is totally unrelated to the problem. It is there just to format the textual debug information.
&gt;Vue's api, lifecycle and state management is actualy quite complex. Sincere question: what about it do you find complex? I'm currently working on a not so trivial application with Vuex and everything and it's working out quite nice. Being a backend developer, I actually really liked it that it was easy for me to get started with Vue and then gradually evolve into a more structured application. If I had to describe Vue, I would say it's between jQuery and React, depending on which way you want to pull it.
Just FYI, moment ships with typescript definitions now.
I actually figured it only had to do with the debug output, but was still interested in learning about it. I'll have to take a closer look at this specifically. I appreciate your help so far, I've learned a few things already and I think I understand the concept you've got going on here.
Mutating state is fine. We fought against [observable gotchas](https://vuejs.org/2016/02/06/common-gotchas/) like not being able to create or set new objects, "leaking" state where the tiniest mistake would result in Vue climbing through your objects transforming them into slow observables, and state management where there's simple no indication where to put local state that doesn't want to be auto-transformed. There is a lot of "magic" going on with unexpected side-effects, unless you study the docs, and even then things aren't exactly clear. This is something you don't have to do with React because it's quite clear how it works and what it does.
I think there's a divide here between professional development and lay-development. What jQuery did was allow lay-people to get into JavaScript development pretty easily. At the same time it helped professional developers take some of the pain out of cross-browser development until they had the time to develop more robust custom solutions. You're average hobbyist or tinkerer might not care as much about long term maintenance, scalability, or optimization - they want to play with something, see it work, and get a specific task done. Professional developers care more about the craftsmanship and returns of using a particular library or framework. With that in mind something like Vue might be good for a certain segment of the development population and grow in popularity that way. That's part of the openness and greatness of the web, even though it also makes it a little messy. 
On click events should be using scope emits. You could listen for those. But if the dev didn't emit anything not entirely sure what you can do.
I wouldn't judge Vue's ability to scale on that "Hello World" or TODO example. A better example of Vuejs is the hacker news clone done with Vuejs 2.0 &amp; SSR: https://github.com/vuejs/vue-hackernews-2.0 Just like one of the other comments mentioned, Vue + Other stuff is just as powerful as anything else. Take it with a grain of salt, but Vue's performance is near the top vs the others. https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html I've been playing with it for the past week or so and I like what I've seen. What Vuejs doesn't have going for it is the HUGE ecosystem of resources that React has generated with its popularity, but with the impending 2.0 release, I think I see that improving in the near future.
The code I wrote was indeed just to show you how to approach the problem (time, acceleration, deceleration). The proper way to implement it, since you have more than one element, is to encapsulate the logic in an object blueprint (or class), and iterate in the animation loop each object, updating its internal state and applying the new rotation value via CSS transform. After dinner I can show you what I mean with another example.
In my opinion, you can't go wrong with either. As I mentioned above, the resources available to React ecosystem are huge--you might find yourself spending a bit more time with Vuejs simply because a tool/plugin/component isn't out there as it would be with React. The real hurdle is bending Webpack to your will and wrangling with the configuration. Scaling apps need Webpack's magic and this tweet is a fairly good summary of the current state of it. https://twitter.com/codeincontext/status/778580127416451072 
You need to know how observables work and what they are. Why you can't create new objects in them, or replace them. Then you account for it with specific $setters in objects and arrays. Or use VueX from the get go. You need to know that it transforms everything in this.data and that it is not a place for local state that doesn't want to be reflected. Put a single THREE.js object in there and it will transform the entire scene graph down to the buffer arrays (this happened to us). But now, where to put state? You don't have a clear component or class with a constructor. You have module scope, which is dirty, or adding your stuff into this.pleaseDontTouch, but under circumstances it still gets transformed (add it in a specific component callback, there's an issue where Evan explains when). React does not have any of these issues. You have a clear component. It has a constructor, put anything you want in there, it won't mutate. It has a reactive state, where you put reflected data. It has a callback for mounting, dismounting and rendering. You don't need to study a template language with gotchas of its own, you just use what you know. It can be composed naturally without extending or prepping other components. You don't mess around with slots, you just filter or iterate over the components children. I don't know a single case where Vue is simpler.
Interesting... can you elaborate more on how you look at it? My thinking is since all export forms contain a declaration, the export itself must be a declaration. Eg. it'd be weird if adding `export` before `let x = 1` changed its behavior in a way (rather than just exporting the symbol).
&gt; I love the way React packages everything about a component together. Vue does that too with the use of .vue files. Read through the docs to see how. Personally, I think packaging markup, logic, and style actually makes code LESS reusable and maintainable, but Vue lets you shoot yourself in the foot just the same as React if that's what you want.
I guess that `export let x = 1` is a declaration, but I usually export references and values that I've already declared elsewhere e.g. `export foo`; this latter case seems more like a statement to me. That said, your point makes the semantics clearer, so I understand why this is the case. Thanks!
u/helderroem gave you a good answer to your bug. I also just wanted to point out that `Math.sqrt()` in JS will return `NaN` for any negative radicand passed in. So while the quadratic formula is helpful for finding even imaginary roots, JS will not be able to compute them. console.log(Math.sqrt(-100)); // NaN And on a much less important note, you don't have to do `0 - b` to negate a variable. You can simply do `-b`: (-b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a)
What I like the most is how it's a one-stop solution to target modern ES. I don't need to worry about what feature to setup in babel, and what plugin I should use. I also don't need to configure a separate type system. Screw all that choice, I got code to write, not pipelines to setup. Just pick TS, and you'll have someone doing all that stuff for you, giving you a consistent package in return. And it's almost zero configuration. I've wasted endless evenings on webpack/babelrc and all that snafu. And perf is great because it's almost impossible to fuck up. (edit: obvious webpack can do alot more then tsc.exe, but really, I dont want that power if I can avoid it)
Thanks! my app is under review from Apple now, hopefully it gets approved
You're welcome! Around line 8, you want to do something like: this.mouseEvents = this.mouseHandler(); And then on line 9, 10, 18, and 26, use this.mouseEvents instead of this.mouseHandler(). Notice we're not doing a function call anymore -- we already have the returned value of this.mouseHandler() and we're using the same object rather than a new one every time.
They're verbose, but we're talking three names here. As for state, it's a normal class, it can't be any easier. The component also has a state prop, just like Vue's data. Question to you. You want to make an editor component using codemirror. Ignoring that there may be ready-made bindings for now. &lt;template&gt; &lt;div&gt; My Editor &lt;textarea id="editor"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;template&gt; &lt;script&gt; export default { ready() { let editor = CodeMirror.fromTextArea(this.$refs.editor); // ??? } } &lt;/script&gt; Where do you store "editor" so it can be used later on? React? I don't have to think about it, because it's regular Javascript. I know React won't mutate local state and i know what my class does and does not do. It's not just a stateless object as well. class EditorComponent extends React.Component { componentDidMount() { this.editor = CodeMirror.fromTextArea(this.refs.editor); } render () { return ( &lt;div&gt; My Editor &lt;textarea ref="editor" /&gt; &lt;/div&gt; ) } }
That's not quite true, jquery was both a cross-browser system papering over browser incompatibility and *a terse, powerful, fluent, set-oriented, high-level DOM API* trying to make good use of and provide good integration with its host language rather than provide for some unholy lowest common denominator of java, c++ and JavaScript. 
https://egghead.io/lessons/javascript-introducing-the-observable
Well, the article is simply referring to "the most popular JavaScript library" when it talks about the space these three things are vying for.
Out of curiosity, did you get to look at Inferno? It seems to hold up as one of the fastest in the benchmarks, while being similar to React.
You basically do the same in Vue. You can use `this.editor = CodeMirror.fromTextArea(this.$refs.editor)` in the `onMounted()` function and have it accessible everywhere else. It won't be reactive because you haven't specified it in in the `data` block. I feel Vue vs React is like an Apple vs Android or Mac vs PC thing. Both camps have their pros and cons and it's difficult to convert people someone once they're settled.
Thanks!
I made an example using really simple math and JS: http://codepen.io/lemmin/pen/rryLJL (You can mess with the variables at the top to change the feel.) I was really hoping that using jQuery's animate() function for animation-duration would allow you to slow down the animate, but it resets the state of the animation every time you change that style. The CSS animation route is slick, but unfortunately, I think JS is more practical for your implementation.
BTW you have /r/adops
Also piggy backing on to this post to say this should be in /r/learnjavascript
Another example of naive solutions becoming popular because they make a todo app look simple.
Relative speed, thank you. I don't know why this never made it into any major libraries. I've been using it for 5-ish years on projects, then I think two years ago there was a post by Facebook who had been using this in their apps for a more "natural" feel. Now we have material design which feels like a perfect match. This is something that gets overlooked way too much.
This just in: Safari has been shit since its inception, and continues to be shit.
Tooling.
But jQuery wasn't just 'the most popular JavaScript library', it was *the* way you did development on the web. It had a consistent, clean, and well-documented interface, it saved you from a lot of browser incompatibilities, it consistently offered features ahead of browsers - if you were a newcomer to writing frontend software, you'd basically just assume jQuery was the standard. Even now, it's still massively ubiquitous compared to all of its competitors. On the other hand, the choice of Vue over React, or Angular, or whatever other framework(ish) options are out there is an issue of genuine debate. There's no product out there that is entirely dominating any of the metrics. There's good reasons to use Vue, React, Angular, or something else, and many people are choosing to do that. That is very different to the height of the jQuery era.
Down voting because I got an annoying dialog part way through reading.
You're awesome dude. I can't wait to go home after work and digest all of this. :)
NodeJS is single threaded by default. You can't compare go and it's concurrent nature with nodejs by default. There's a way for implementing concurrency in nodejs via the cluster module https://nodejs.org/api/cluster.html as you can do in Python with threads (using a module) or in ruby with fibers. You can't compare on the same grounds two things that by design are inherently different. Edit: however, the solution isn't trying to program nodejs apps with go concepts, but instead trying to think in JS terms.
Isn't that enough? Static compile-time validation! 
The React Hello World can be better written to compare to the jQuery version as: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;React Hello World&lt;/title&gt; &lt;script src="https://fb.me/react-15.0.0.js"&gt;&lt;/script&gt; &lt;script src="https://fb.me/react-dom-15.0.0.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="greeting"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render(&lt;p&gt;Hello from React&lt;/p&gt;, document.getElementById('greeting')); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
It was way easier for me to reason about how to do things with Vue over React. It fit my mental model better. I also prefer handlebars over JSX, though now that's also a valid possibility in Vue if it's your preference.
Compares favorably to the jQuery version: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery Hello World&lt;/title&gt; &lt;script src="https://code.jquery.com/jquery-2.2.4.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="message"&gt;&lt;/div&gt; &lt;script&gt; $("#message").html("Hello from jQuery"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
If anyone wants to do feature detection of this bug: https://gist.github.com/jensarps/15f270874889e1717b3d#gistcomment-1881634
&gt; jQuery eliminated many barriers to entry by NOT requiring a programmer to be versed in best practices, design patterns, etc Eh. I don't agree with this portion. I mean, jQuery sort of had that effect. But more than that, jQuery allows you to do incredibly simple tasks without having to write loads of code. Stuff that should already exist in the Javascript standard library. And on top of that, it gave you a nice simple API to do those things - instead of the cruddy nasty standard Javascript API's.
use their eslint config offline
&gt; Just saying that "React is the new jQuery" He didn't say that at all, nor did the community he's citing say that. &gt;really hammers in the nail that the author doesn't know what he's talking about Like I said before, he didn't actually say that he was commenting on the consensus in the community at the time (which is false as you and /u/viveleroi have correctly pointed out). So the author didn't actually say that, nor did he say the thing you mistakenly attributed to the article (nobody said that React is the new jQuery). So, not really.
I'd second shizzleberry, but I'd recommend going one step further and using an IDE that incorporates ESLint (eg. WebStorm). They can be configured to use a specific ESLint file (eg. the airBnB one), and you'll get warnings immediately, instead of later on when you run your linter.
I only recent started programming so what is eslinh 
I have long since given up hope that Safari will be non-shitty.
Safari: The new IE.
When you tough articles here couldn't be more stupid.
Because Vue seems a very simple data binding library at first. It becomes muddier the deeper you go. Vue came to fame because the Laravel community started using it. PHP guys...
I agree with your sentiment and I know JudeOutlaw was just being pedantic, but even so, if your API is insecure (accessible via ajax without a login), then it's exactly the same as leaving the DB insecure and public. 
&gt; Okay. I take it that Earth is flat because you say so. Might have as well tested it on a brick! What an incredibly insensitive thing to say. You want to redefine "accessible" to mean something other than "people can access it", and you're trying to make me feel bad for having broken eyes and being unable to access your "perfection". &gt; No, books cannot be turned into full scrolls because you'd have to paginate 'em for one reason or the other. Yes, books most certainly can be and are. My phone remembers where I was on a long page; I certainly prefer a long page that I scroll. I *get* that you don't think this is aesthetic; I'm trying to "see" things your way. Can you see things my way? &gt; Rest of the discussion on Lobsters because that's were you less trollish. At this point, I assume you probably have read that discussion, and feel like everyone's against you. I hope that reading your reception on lobsters instead humbles you, because I do run into about 1% of webpages that are "designed" for me to be unable to use them. Please understand I'm not trying to make some trick argument: I'm actually unhappy with the pages you design and I'm really angry trying to explain this because graphic designers keep doing what you're doing: They try and make me feel like it's *my* fault I don't like their pages. You're not special in this regard: A lot of "designers" do this. It's frustrating to no end, because every time I say I hate this, I get called a troll (or worse) by people *like you*. Imagine what that is like for me, and then you might begin to appreciate my frustration. Maybe then you'll stop telling people to "disable pinch2zoom", and start telling people why they shouldn't. 
Yes, but since I'm still in the beginning stages of learning JS, I have no idea how to compile an exe. I just wanted to put something together really quickly that would work for the other projects I'm working on. I might do it in the near future, will be a nice learning opportunity.
Look at meteor js. It has a lot of the scaffolding needed.
 You mean like it's being used way longer than it should be? I agree. 
also, depending on if you already know what a callback is you can use [forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) to iterate through the hobbits array. to add the class you can use [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) a new way thus requiring a modern browser is via [classList](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)
Thanks a lot for the reply. Im currently doing one of those coding bootcamps 9am-9pm sort of deal and this was our first weekend. I am already feeling oversaturated with information and tired. I will read up on the appendChild and textContent for now. I might pester you a bit more later with some questions but thank you!!
Haven't gotten to that step yet but i will be reading up on the className as well as the forEach. Thank you!
eslint is a tool for helping you keep a consistent code style. here is the [getting started guide](http://eslint.org/docs/user-guide/getting-started) for it. the airbnb style guide, which is implemented primarily in eslint (see airbnb's [github page](https://github.com/airbnb/javascript)), is one of many different eslint configurations (one notable example is the [standard](https://github.com/feross/standard) configuration, but don't let the name confuse you; it's just one person's opinion on what "standard" should mean). also, do you have nodejs installed? if not, you'll need to in order to run eslint yourself: * [direct download link](https://nodejs.org/dist/v6.6.0/node-v6.6.0-x64.msi) * [website](http://nodejs.org) * [api docs](https://nodejs.org/dist/latest-v6.x/docs/api/documentation.html) nodejs uses a tool called npm to install libraries (like jquery) to your directory. they have a really neat [getting started guide](https://docs.npmjs.com/getting-started/what-is-npm) that's worth a read (check out the links on the sidebar to navigate to different parts of the guide). you might also be able to integrate eslint with your editor. i use [visual studio code](http://code.visualstudio.com), for instance, which has a [nifty plugin](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) that runs eslint for you. if you're not sure about what to do, you can usually google your editor's name plus 'eslint' and that'll get you started - for instance, @ghostfacedcoder recommended WebStorm, so you would google 'webstorm eslint'. hope that helps!
(I'm on the Edge team :)) It's not untouched; we've actually improved some stability issues as recently as Edge 14. But yeah, there are still some open bugs, mostly around supporting multiEntry/compound keys/array keys.
Oh yeah, those things will drain you. Good luck! Be strong! And I'll try to keep checking here back for any other questions you might have. 
I'm not sure I agree with this, as jQuery was also adopted by experienced developers who were tired of having to write nasty cross-browser code. It was simple, a lot lighter than Prototype, and got the job done. Furthermore, it had a really simple API that made programming with the HTML DOM a lot less aggravating. jQuery really shined (and continues to shine) when your site doesn't need a lot of JS.
To run JS outside of the browser you'd use node (most likely). You don't compile an executable. Instead you use the node host to execute your script: `node concat.js arguments-to-concat`. You could even eventually distribute your script in npm so node users can use it via `npm install -g yourthing &amp;&amp; yourthing arguments-to-yourthing`.
naive question, since i've used vue but not on anything enterprise-y: how much would mutability guards (whether as robust as ImmutableJS or as simple as _.clone) help with your situation? granted, that would be the clearest example of fighting the framework you could get, but if it's an option then it'd be handy to know.
&gt; I have no idea how to compile an exe Good news! You don't have to! JavaScript is an interpreted language and the only compiling you (usually) do is handled automatically through a JIT compiler. So basically, no compiling. You just throw it to the runtime and let it do its thing. On windows you have windows script host out of the box you can use. Quick example: // C:\myscript.js WScript.Echo('Hello World!'); Then on the command line: C:\&gt; cscript myscript.js Which produces: Hello World! But you're better off sticking to [Node](https://nodejs.org/en/) which has become the runtime standard for JavaScript. It's based on Chrome so has a bit more consistency with what you get in the browser (like `console.log()` instead of `WScript.Echo()`) and has the benefit of being cross-platform. Node version of the above (once Node is installed)... // C:\myscript.js console.log('Hello World!'); Then on the command line: C:\&gt; node myscript.js Which produces: Hello World! And works on Macs too! Now, I'm not going to sit here and tell you that you should naturally know how to rewrite your code with JavaScript now. But this hopefully at least points you in the right direction for when you want to get started. :)
&gt; because some cunt disabled this "feature". &gt; You don't know how to design for accessibility. Full stop. &gt; some "designer" has gotten the fucked up idea &gt; For fucks sake, you're making a book. Come back and read your commentary after six months. That said, I have picked up what was relevant from your feedback and from the community at lobsters. It is unfortunate (but totally understandable) that lobsters sided with you -- with a certain flair for troll-ey behavior that one expects from a community of hotheads like that -- and then went on to actively remove my thoughts (which were all polite to the end) from that thread because "people simply didn't agree" to something. So it is and so be it. No offense taken. And wishing everyone the best, and onwards on our separate paths. :-) Thanks, Marvin
Hey sorry to bug you, what do you mean by made a framework wrapper, is that just a simple way of including it with an existing framework? Thanks. 
&gt; but this doesn't quite sound right -- reducers are functions, but redux state is still an object, which is the output of the reducer function after receiving an action (or the output of Well, if you can look from standpoint of Observable. From Observable standpoint: const reducer = combineReducers({ ...reducers }); const state = {}; const listeners = []; // from connected components Observable.from(actions) // over time .scan(reducer, state) .subscribe(newState =&gt; listeners.forEach(listener =&gt; listener(newState))); Redux state in time is not a function or an object, but a monad of state. Observable is much easier to grok if you already know some FP. Redux just stripped API to bare minimum and made it more accessible.
Thanks for the post! I've been thinking about how to get people started with web apps. You have given me some things to think about.
Yes, I am aware that WebKit was a fork of KHTML and KJS. I'm not sure how KHTML and KJS are related to me saying that without Safari we would never have gotten WebKit.
It's open source, so fork it, fix it, and submit a pull request. If you do it enough, you might just create a community around it. If community support is not there and you cannot fix the bugs yourself, then using it for actual production projects is a huge mistake.
I think it greatly depends on the browser, I tried Copperlicht with Chrome and just like in the article it felt sluggish, then I used UE4 and with Chrome it wouldn't even start. I then switched to Firefox and it was super smooth to the point where I was questioning that it was running in a browser.
I'm saying we already HAD it. It just didn't have the cutesy name yet. Konqueror was passing ACID2 compliance before other browser engines. So it stands to reason others would have taken note. 
Summary: Author created a first-person shooter using WebGL, then made a quick desktop version in Electron. He also rewrote it in C++. The Electron version had similar rendering performance, but the author noticed input lag. He advises other developers to use caution when deciding to write a game using web technologies. Since the author also mentioned that he was disappointed that Electron doesn't support going fullscreen (despite the existence of the BrowserWindow.setFullScreen API method), I suspect that there were some optimization paths which were not fully explored.
If packaging your markup, logic, and style together makes your code less reusable and maintainable then I'd dare to say you've done something incorrectly. Something might be too tightly coupled to something outside of the component which makes it harder to reuse. 
http://www.tiobe.com/tiobe-index/ Javascript just jumped past it. Clearly not the end-all-be-all measure, but still.
&gt; The short answer is flow doesn't do anything to help a person write code I thought that it's your IDE that helps you write your code and refactoring based on what it knows about the types and interfaces used by your code. The type system of Typescript and Flow seems to be equals so I would assume that the IDE that supports both would perform similarly. Am I wrong? 
Almost. Parameter properties, accessibility modifiers are nice to have though.
Aurelia would look better if they more actively curated their issue list. They couple simply close them, if that's appropiate, or respond with a "can you provide a repo example?" or whatever it may be. I don't really see how that's "complaining". It's simply about perception and signal value. Maybe you don't care about that, but I certainly pick libraries based on that, and I don't pick aurelia. Getting speculative, I'd wonder if they have enough resources. Just compare their issue list with angular2s. I'm not really seeing any month old issues with no responses. Issues look nicely triaged, and all that good stuff. Take a look at this random issue I picked: https://github.com/angular/angular/issues/11735 It's strange because in Rob's own "choosing a JS framework" video he highlights Aurelias community involvement, but that's not an impression I feel carries over to their internet community (of which I assume github is a major part)
You're assuming, that if Apple hadn't forked it, then no progress would have been made on KHTML? Chrome would be using Gecko? Or something else? Neither one of us can make that assumption. To say that we "wouldn't have Chrome" is silly. 
All I said was that **WebKit** wouldn't have existed. Without Safari we **literally** would not have WebKit.
That's what I'm gonna do. I have a pet project written in JS, I'm gonna try Flow with it. Actually the reason I started this thread is because I wanted to re-write that project into TypeScript and I had some issues configuring the typescript loader with webpack. 
Long-term, I want to see safe, lower level access, primarily in parallelization capabilities. Web Assembly is a good start towards that goal. Eventually, I'd like to see at least the capacity to define our own browser-level systems like layout engines. With specialized knowledge of our apps, and the optimization of the relatively taxing security systems between js and browser primitives, we can start to make apps with few to no limitations. Consider that in addition to the complexity, the reason why virtual dom implementations are not already being computed on web worker threads is due to the ridiculously slow communication barrier between them.
How did I forget about parameter properties and accessibility modifiers? I like parameter properties although it's not something I can't live without. Accessibility checks are implemented in Flow in a weird way (underscore notation) so if I were to start using Flow instead of TS I'd still have a way to enforce private methods/variables. &gt; Additionally, interfaces are a very powerful way to describe types in JS Flow has a similar interface system though. What does TS offer regarding interfaces that Flow doesn't?
Thanks. I've seen this before but it doesn't really talk about other features besides the type system. This has actually convinced me to give Flow a try :) 
The Angular team that is paid by Google? Crazy they would be able to put more time in than unpaid OSS contributors.
You're not wrong, bundling in the modern web landscape is a pretty nasty story unfortunately, that TS does not handle. The thing is that TS cannot compile your code into a sensible js file, unless it knows how to actually load your dependencies. While you see types and all that, it's pretty much just smokes and mirrors. TS doesn't know what jquery needs to be loadable, and since the import syntax does not allow specifying that, there's no way for TS to tell, from your code alone. So ultimately, you're not gonna get around using SOME module loader. systemjs is fairly common these days, and I really like it's declarative config. systemjs-builder works great for bundling the resulting app.
Rob has been pretty vocal about the "dedicated company backing aurelia" and how Google didnt care/use angular. That's pretty much the only reason I think it's even worth mentioning.
This is always the challenge I think. How isolated do you go. In my mind if you pass a prop into a component and it changes its look it seems like the component should be responsible for the change of visuals. The outer context can say hey component you are a size=big now and the components internal styling does its thing for the home page. I get what you are saying with tightly coupling but props are the public API interface to help alleviate that. 
Any hope of getting to either a unified format for type descriptions between flow and TypeScript or viable translators? Are there type declarations one supports and not the other, and if so, would a common syntax that both supported, or alternatively both could have type definitions generated from, be an option? Would *really* like library authors on npm to be able to easily provide a single set of type definitions to support both instead of them being separate ecosystems.
Props are for data injection, they don't really have much to do with styling and markup. 
I'd actually quite like to fork Aurelia to keep pull requests actively dealt with and get through that backlog. However, as you say, the inner workings are in certain parts undocumented. I'm also wary of stepping on Rob's toes. Ideally I'd like any fork I undertake to be Rob's-Aurelia Compliant and as non-hostile as possible. It's good to hear people such as yourself speak up to the possibility of a community forming/remaining. However without contact from Rob none of us can really continue along this path in good faith. I'd be interested to see how users of the project with current live projects are coping.
Aurelia 2.0 is going to require Typescript, I guarantee it.
Its a javascript framework like angular.
oh shut up 
/r/iwantout
Weird that he would say Google didn't care/use Angular: https://youtu.be/odY7fUjI1ZU?t=3m26s
yep! just putting some helpers around the plugin so it plays nice. I needed it to be module friendly (webpack) and have it available within my framework's namespace (Vuejs).
Well spoken. Like it or not my advice is good. If OP does not have the time/expertise to fix a bug and no one else is doing it either, then what happens when a serious security issue arises or the next version of JavaScript breaks something? Only a fool would roll an unmaintained library into a product, especially one like Aurelia that you architect an entire project around.
I'd probably start by doing some Google searches and watching the network tab to see where requests are made to. Chrome should allow you to copy a request as a CURL command so you can replay it from the command line. This would probably give you some insight into how possible this is. My guess, however, is that Google's API likely would block the cross-origin request. Note: the comments on [this SO post](http://stackoverflow.com/a/4082976) seem to indicate that making requests programmatically is against the TOS, which makes sense. So doing what you aim to would go against the TOS. 
&gt;There's nothing really wrong with deciding Douglas Crockford shouldn't speak at your conference because too many people think he's grouchy and sexist Yes there is, because that's not the case. He is neither of those things.
&gt; There's nothing *procedurally* wrong with deciding Douglas Crockford shouldn't speak at your conference because too many people think he's grouchy and sexist Do you find this re-write more satisfactory? It was not my intent to imply that it was *correct* to decide that Douglas Crockford should not speak for these reasons.
Sounds like you just don't know how to write JavaScript or use modern Web APIs.
Those are architecture patterns, not design patterns. A design pattern would be the factory pattern.
Sorry it's actually not realistic. Why put your time into a framework that could be dieing and instead learn a framework that has a future? We are all very limited on time. That's why we rely on reliable frameworks for our jobs. We are already pressured to complete one job, how would you like the new unexpected task of maintaining a framework because it lost support. It would suck. 
Have you tried Vue?
Sorry, last I checked interfaces seemed [unsupported](https://github.com/facebook/flow/issues/72) out of principle, but it seems like that's since changed. One thing I'll note is that interfaces don't seem to have any straightforward way to tie in with classes in Flow. For instance, you can't say that a class `implements` a type, meaning there's no way to ensure any sort of shape over your API.
Even if he were grouchy and sexist, it still wouldn't be a good reason.
Pull requests are silently ignored too. Trivial PRs will receive no attention at all for weeks. I *really* don't think it's a good idea to spend your time and effort on improving Aurelia before even knowing if they're going to accept it.
If it's (the support) already bad, then does anything really change for the worse? :P 
If Aurelia was a commercial framework, would you be willing to pay for a license and support? 
Exactly.
Can someone point me to a project that actually uses aurelia? I know there was a big fuzz around it a couple of months ago, but has anyone seriously picked it up for a "real" project?
The material you quote does not seem relevant. It refers to a decision that "...made the US citizen's right to freedom of (political) speech almost absolute." and it is with regards to breaking the law or revolution. The government is not to restrict speech simply to preserve itself or its functioning. What does that have to do with hate speech?
I'm pretty sure it looks different when mods delete comments there, which happens very rarely.
Huh? Shall I not use postgres or Linux because I can't C? They are quite vital to my projects too! Jest aside, that's why competition is good. Nowadays I seldom "go" for a library, but for 3 (yes I implement things 3 times, but its fucking worth it, and for several reasons). Granted, a framework is not that easy to swap. I still cringe at the idea of having a multi framework / multi language site. Yet I have pearl node php Python and even .net in my deployment chain. Moreover, services now come complete with their VM (discourse by example). Sadly we will soon have redux/react, angular0, aurelia, vue, polymer and whatnot modules **on the same page**. The future looks bright ðŸ˜‚ 
Go look at most of the recent changes to the Python language. They added coroutines (and `async`/`await`) and now they've realised that because of the viral awfulness of `async`/`await` they now also need: * `async for` * `async` comprehensions * `async` generators And more soon enough.
Ah! really sorry for that. Thanks for your valuable feedback. I'l get it fix.
Too bad it can't be polyfilled. You're still gonna be stuck with transpiling in web environments for quite a while. Awesome for contained environments like Electron though.
Put New York City on your list. Huge and active communities in anything you are interested in, lots of tech companies hiring, much less pretentious than San Francisco (can't speak for Colorado). 
&gt; Come back and read your commentary after six months. I think you need to calm down a bit. I get that *you* think you being dismissive of *my* point-of-view is the same thing as me being dismissive of *your* point-of-view, but you're wrong, and this isn't about "people simply disagreeing". Also: My colourful words don't mean anything other than I'm angry. It's okay to get angry. When you dismiss my point-of-view *because I'm angry*, you're creating a kind of straw man, so you can pretend that my argument is that you're a cunt, not that you're fostering an environment that hurts me. Try to understand why I might be angry. I'm a little angry because there are people out there who think it's good that I can't use their websites, and I'm *very* angry when they call those websites "accessible" -- because if you take the word "accessible" to mean things that visually impaired people can't access, then the word loses all meaning. It makes me imagine a future where I can't search for an "accessible reader" or a "accessible javascript editor". I hate that world. I hate that your design probably looks good to someone who has normal vision, because I don't want you to inspire other designers to make that world become true. What you're interpreting as "hotheadedness" is really people who can see your point-of-view as insidious as I do, and are trying different ways to tell you that. I don't think anybody is trying to tell you that your design doesn't look good except me, and I'm only trying to tell you that because I can't see it. When you think about this correctly, you'll be able to appreciate that this isn't about "people simply disagreeing" and maybe start thinking about how you can test your designs with those accessibility-tools to make sure that your solutions are *actually* accessible. Good luck.
Async/await is just syntactic sugar for a common promise. synchronized: for (child of children) await child.doSomethingAsync() or in parallel await Promise.all(children.map(child =&gt; doSomethingAsync())) Though it would indeed be nice if it could receive an array so the Promise.all could be omitted. Other than that it is straight forward, if you can then() it, you can await it. It doesn't require twisting and bending javascript as a whole.
No comprehensions in JS so that's not a problem. Async generators are already done with co from tj. Async for is not needed in JS as we have Promise.all and you can always utilize async inside a regular for loop.
You miss my point: it creates a viral sublanguage however you like it. If you have a function that takes a callback (and no I'm not talking about a callback for the purposes of async, I'm talking `sort(listOfPairs, (x =&gt; x[0]))`, you need to duplicate these functions so that they can `await` the callback if the callback is asynchronous. So you have a `sort` and a `sortAsync` now. For everything.
Because `async/await` have a semantic meaning, and generators have another semantic meaning. The fact that you can use generators to achieve a similar effect doesn't really mean anything - static analysis tools won't be able to detect it, and new developers won't be able to understand your code as easily as if you were using dedicated language structures. Because you *can* doesn't mean you *should*. Btw, your code is wrong. You meant to say: let [a, b] = await Promise.all([ getA(), getB() ]); 
Article makes me pick jQuery over Vue or React. Real world makes me pick ng2.
Async/Await and Decorators. (Both of which are available via Typescript â™¥)
In my opinion it has best DX(Developer eXperience) .d.ts as mentioned by Daniel Async/Await support. Decorators support (you have no idea how cool they are until you try it)
asp.net is pretty good too. 
&gt; So you have a sort and a sortAsync now. For everything. You have a point here, I will grant you that. It is not such a big deal IMHO. I bet there will be libraries which will offer async versions of built in methods. Once some of these libs will win, ECMA can put that in ES20XX
As to the first part of what you said, I 100%, completely agree. Mea culpa. Also, I will fix my code. For the record, it used to say ~~let [a, b] = Promise.all(await getA(), await getB());~~. That said, I have no doubt tooling will catch up, and while I *definitely see the risk*, I think that both generators and `await` offer ways to flatten code in ways that will help newcomers follow otherwise incomprehensibly asynchronous code. 
Because .apply() and .call() actually invokes function with given context(this), and .bind() modifies context but does not invoke function. That's explained in the article too... 
Not exactly JavaScript or this week, but i created this very recently and pushed a big update this week https://chrome.google.com/webstore/detail/twitter-web-night-mode/cadmiljohldbooihfbkjkobepojailca
I look at generators as a lower-level construct. Async/Await can just resolve/reject (like the current promise implementation) so it's easy to reason about but not powerful enough for a lot of use cases. My understanding is that much of the work done in generators was able to be built-upon when introducing async/await to the browser.
There are http://bluebirdjs.com/docs/api/promise.promisify.html and https://github.com/sindresorhus/pify, for example, which auto generate promises methods for any objects
Yeah, it looks like you need to read the Vue docs before you assume it can't do that.
&gt; bundling in the modern web landscape is a pretty nasty story That's why I love webpack. Needs some time to get used to how loaders work and why they do what they do, but I cannot imagine starting any big project without it. 
Ten points for TS :) I was experinmenting with these parameters in the past but it didn't work. It seems to do the trick now. Well. Almost. As I see I still need the module loader itself loaded in my browser to use the produced bundle. Not that big of an issue but still the way webpack does it (the bundle contains the module loader) is nicer in my opinion. 
I might have misunderstood. Is this particular problem solvable using render/create element? https://rc.vuejs.org/guide/render-function.html
&gt; It's kinda silly to reject the better tooling, but you can do it if you want. Therefore all JavaScript apps should be written in TypeScript?
&gt; Web assembly is just not limited to js. I think saying that kind of takes away from your point a little. So now its more like saying _new computers are the future for c++_.
Well there are a few differences at this point (`readonly` properties in TypeScript for instance), but I'm not convinced that that alone is a show-stopper.
If you're only supporting newer browsers and they all have generator support, you could use [co](https://github.com/tj/co). 
There are constant releases. Just check out the blog: http://blog.aurelia.io/ I don't have the same feeling about it beeing left to die.
Wow I didn't know about these. Awesome!
how long until this lands in node? 8 months or so?
Really? Didn't know that. Never used IndexedDB or it's variants, mainly due to the shaky and varied implementation, combined with a lack of use-cases. I'm pleasantly surprised by Edge as a consumer and web developer, aside from the lack of plugins so far.
node-4 has generators, so TypeScript async/await will work on node-4.
Or just go for gold and use TypeScript.
Depending on your editor, ESLint can be integrated in your editor so you code gets checked while you type. Check out [Linter-ESLint](https://atom.io/packages/linter-eslint) if you use Atom for instance.
You can use TypeScript async/await and node-4 today.
When I think of jQuery *the most popular JavaScript library* is not what comes to mind... more like *cult worship*.
It is relevant because you claimed hate speech is rarely protected, which is clearly false.
Go into the documentation for it - it doesn't have complete docs for plain JS. Also the API is massively cumbersome in plain JS (it didn't have to be, but they focused on TS while not giving a shit how awful it is to write in plain JS). JS is a second class citizen in A2.
Have you seen [vue-class-component](https://github.com/vuejs/vue-class-component)? It's a pretty simple wrapper for VueJS to help write ES2016 classes with VueJS.
To each his own I guess. Both are great frameworks IMO, and I have nothing against React at all. My brain likes Vue more than React, but that doesn't mean I don't use React sometimes. Vue's version of React Native is extremely young, and I'm not sure if it'll ever get to the point where I'll use it instead of React.
How is that related to this topic?
TypeScript enables the IDE to do it's work by providing meta information about your JavaScript, such as types. As far as I know, flow will tell you if you try to put a string into a var you previously used as a number, but it doesn't provide this type information to the IDE.
I'm looking forward to it being less "cool." The ecosystem can stabilize, there can be something approaching a concensus on best practices, and flavor-of-the-week libraries and patterns can stop being taken too seriously or touted as THE RIGHT WAY... FOR NOW. "Cool" JS is sort of fun to watch but I want to spend less time dealing with broken shit and nonsensical interfaces, more time working on my projects.
in this japaneses page https://ics.media/entry/201 : This site compares canvas rendering libraries, and the result: good &gt; bad pixi.js &gt; CreateJS = Arctic.js &gt; enchant.js pixi.js is fastest. http://www.pixijs.com And this chart library ues pixi.js. https://github.com/anvaka/ngraph.pixi How is this? Notice: pixi.js is high cost when the creation. 
That is correct, which means we could use async/await in browser environments without an intermediary transpiler like babel.
Co uses generators to do basically the same thing as async-await, but in library form. Since generators are more widely implemented ATM, co is an alternative to async-await that does not require the latest bleeding-edge language feature.
New York is smelly haha I don't like that city
Haha good one. Js community is gold, thought that some Developers could share their thoughts and experience
It sadden me how the community is responding to maintainers. I wish we could switch the "You are not active on any of your repos, are going to fix the issues them anytime soon ?" to "You seems to be busy, how can I help ?" I find that maintainers are getting so much pressure from the community. I mean, they are humans like everyone else, I can imagine that sometimes maintainers doesn't want to code and just chill on the couch doing nothing like me, or he might even just taking care of his family, I don't know... I can understand your frustration because you started using it at work but this is a risk you've taken when you decided to use this tool, because I imagine you have taken in consideration the community criteria. He has given away freely a library and probably spent a lot of time on this, I almost feel like you are just shitting all over the maintainer's work.
thanks very much for the response
The TypeScript compiler can emit ES5-compatible code, what is wrong with that?
the way i think i can solve it is by making a separate variable to increase the hobbit[n] and put that in a nested loop. Im sure there has to be a better way!
This is where textContent comes into play. `hobbits` is an array - a list of things. In this case its a list of strings. Strings are a basic data type that represents a bunch of letters and numbers and other characters. The `addChild()` method expects DOM objects. It is used to help you build a DOM, adding one DOM object to another. Its not going to like you trying to give it anything from the hobbits array. It likes it when you do something like adding your `li` to your `ul`: createNewUL.appendChild(createNewLI); This is creating for the DOM what effectively equates to placing `&lt;li&gt;` tags in a `&lt;ul&gt;` tag in HTML. With simple strings, its a little different. You a couple of choices. You can do what you're doing with your `ul` and `li` elements, and create a DOM object from a string, then add that object to its parent. Or you can take a simpler route and simply take an existing element, like a `li`, and set its `textConent` property to the value of a string. This would be like adding text in between `&lt;li&gt;&lt;/li&gt;` tags in HTML. That said, your immediate problem seems to be accessing `hobbits` values. You get those from the array access operator, similar to what you almost had with `hobbits[]`, but you were missing the key, or index specifying which item in that array list you want. Since you're looping over each item in the array, each iteration means you grabbing one value from the array. Which value is represented by the `i` variable in your loop. In the first iteration, `i` is 0 which represents the first item in the (0-based) array. To access it, you would use `hobbits[i]` which for the first iteration is the same as `hobbits[0]`. In the next iteration of the loop, `i` is 1, so `hobbits[i]` is the same as `hobbits[1]` giving you the second value in the array. And so on and so forth until you've gone through the whole array. Then its just a matter of taking that value and giving it to the `textContent` of your `li`. for (i = 0; i &lt; hobbits.length; i++){ var currentHobbit = hobbits[i]; var createNewLI = document.createElement('li'); // ... ? 
I just replied to your other post. I mentioned this as another approach, though I did more directing towards using `textContent` instead. But since you've already gone this far ;), you're almost there except for getting the current text value from the hobbits array during that iteration of the loop. I assigned it to `currentHobbit` in my code sample in the other post, which is what you'll want for your `createTextNode` here.
Well you're probably going to be using a transpiler to convert your es6 to es5 anyway. So you can just use any existing minifier on the transpiled code. 
I am calm and have been all through this discussion. You could easily read *Pride and Prejudice* as a scroll on Gutenberg. No one stops you (or me) from doing that. Anyone could read it like a scroll! But you (not *you* but you!) on the other hand are trying to stop people like me from reading books like ordinary books -- with chunked pages and a behavior (et al page flip) that *is* supercritical for the experience and notion of books. So what is the agenda I ask? Do you want to help native in some way? People tell me it should be like a blog, like a file, like a website, like a plane, like a sports car but all I want it to be is like a *book*. Right here on the browser -- like a first class citizen of the web -- with piecemeal-ed pages, responsive design, gracefully off-lined behavior and without using any third party plugins and also without pulling people into a thing called "format hell". You want to take that choice away from people like me by forcing faux-accessibility features like pinch2zoom that don't even solve the issue of unscaled text correctly. Even at the cost of good performant websites which have nothing to do with books! I'm sure you'll understand this being a developer yourself. 
Typescript really isn't a different language. It has no functional features that ES2015/ES2016 don't also have. It's a superset of Javascript but it's a SUBSET of Babel. It doesn't, for example, [support object spread yet](https://github.com/Microsoft/TypeScript/issues/2103). At least for me, the first time I saw Typescript I thought it was some radically different thing because it was also the first time I saw a lot of ES2015 features. That is, the typical example of "what Typescript looks like" is ES2015 classes with type annotations. That didn't "look like Javascript". It really is though. All of Typescript's contributions to syntax and language features are strictly typing information. They don't affect the logic or structure of the Javascript except to annotate what you're already doing. That is, you can't DO anything in Typescript that you can't do with exactly the same syntax in Javascript.
I just wrote this as a little javascript deal.. http://codepen.io/anon/pen/zKkRwg Use spaces at the end to make it not a full circle.
I doubt you'll find one right now, since 90% of people are transpiling there is no real value in building one except for an 'exploration' project 
You have two options, both buggy: 1. [The "harmony" branch of UglifyJS](https://github.com/mishoo/UglifyJS2/tree/harmony) works for some stuff - I use this in a project where I transpile everything except generators, and it works fine for that. But not every ES2015+ feature is supported, and there is no official release yet. 2. [babili](https://github.com/babel/babili), which is new and under heavy development. Seems even buggier than option 1 currently, but the situation might have improved since I tried it.
you can't really escape from babel in serious projects
I work in a .Net shop and our Node projects are exclusively TypeScript, Babel isn't even on our radar. Numerous projects both small and large, targeting both browser (ES5) and server (ES6).
yeah I don't disagree
interesting
You probably want this: https://github.com/blog/1184-contributing-guidelines :)
THIS! If OP was/is so stressed that these bugs need fixing, enterprise support is available. http://aurelia.io/support.html
IIRC /u/thejameskyle had said that the flow syntax was stricter (I may be misremembering) such that for a given library it was feasible to generate the TypeScript version of the type definitions from the flow version but not vice-versa? Or maybe it was that if you started at the TypeScript version then the generated flow version would be less strict than what it supports natively? My memory is fuzzy, I need to dig up the comments from when the Windows support for flow got posted to reddit. Edit: I think I was remembering this comment? https://www.reddit.com/r/javascript/comments/4vohr4/slug/d608q8i
I'd personally create a gif for the git page showing it being used. It may be hard to see the benefit from just words, for some people. Nice tool!
Or `co`. Still, I'd rather just have it native and skip the babel build step if I don't need it, and if I'm working on a project that isn't typescript (or even compile to native async / await from typescript). @op -- we should be getting this in node 7, I *think*, which is going to start being used in October.
&gt; JavaScript is functional language, not OOP based language. JavaScript's actually a little bit of both. &gt; If I start to learn TypeScript it can keep me in loop for Classes, Interfaces, Inheritance, namespace or Modules and many other features used in languages like c# or Java. If the only reason you want to learn TypeScript is to prepare yourself for other languages, then I vote don't worry about it yet. You can learn those languages when the time comes, but for now I think you should focus on the language you'r currently learning.
No, I said if he can't AND nobody else is either, then it would be foolish to architect it into his product. Edit: Also you seem like a very angry individual, you should work on that.
&gt;Huh? Shall I not use postgres or Linux because I can't C? They are quite vital to my projects too! I get the jest, but if any of those products suffered from a lack of developers who can C and updates and bug fixes were not happening, then yes, you should seriously reconsider putting them into your product.
Exactly my point, if you can't AND nobody else is, then don't use it....
I donâ€™t think there is a simple way of diagramming how JavaScript works. The best you can do are cheat-sheet-style feature lists.
Doesn't seem to work for me: Google Chrome 53.0.2785.116 (Official Build) (64-bit) Revision 3f9c628bfd1de2c62de1ea41d0707d06cc760061-refs/branch-heads/2785@{#886} OS Linux
Oh, thanks for contributing. I guess.
Firefox already matches currently open tabs in the location bar. The search is not as fuzzy as I'd like it to be, but I do find myself hitting ctrl+T to go to a tab I already have open
yeah sorry, I started writing more but then got lazy. Any programming language has a lot of intricacies (even CSS and HTML). You cannot just completely learn a language in 24 hours or even 3 months. That doesn't mean that you need to know everything about it. The best way to learn a programming language and I think in your case, programming in general, is to just google some simple tutorial and start small. You'll get new knowledge on the way. Hell, even after 6-7 years in I still learn new things (but not as often of course).
Public moderation log: https://lobste.rs/moderations/ The last time the mods deleted a comment was February: https://lobste.rs/moderations/page/7
wow, I hate when I am genuinely baffled and then it winds up being a simple case sensitivity issue. Thank you though!
This is why I decided not to use Aurelia and it seems I was right it'd be too risky to depend on one guy who can just change his mind and bury this project.
thanks for the tip! i use the [es-latest](http://babeljs.io/docs/plugins/preset-latest/) babel plugin, which includes [es-2017](http://babeljs.io/docs/plugins/preset-es2017/) which has async/await transpilation. What I meant was when it will make it into node natively so it doesn't need to be transpiled.
I don't think Typescript will "keep you in the loop." It might let you dip your toe in the water with static typing. However, Typescript really is Javascript. The classes and modules in Typescript aren't Typescript---they're Javascript. Specifically, they're ES2015 (aka ES6). Typescript just gives you static typing to let you enforce the correctness of your program. Notably, Typescript's classes are just ES2015 classes, which are just a thin abstraction of the ES5 "module pattern". That is, even if you're using Typescript you're still using prototypal inheritance, which is NOT the kind of class system you'll find in Java or C#. Typescript is fine, but it won't teach you much about C#. You should definitely pick up a second language. It'll make you a better programmer in your first language. Don't worry about losing your skills in the first language. If you don't use Javascript anymore, yeah, you'll get rusty, but if you're using it you won't lose it. I haven't written Java in over ten years but I can still read it. I can even read modern Java because I've been keeping up with all the features Java's been absorbing over the years. Honestly, if you've been writing Javascript for any amount of time you have the cognitive load of writing in three or four other programming languages already. If you know Javascript you probably know some jQuery, which gives you a kind of second domain-specific language.. If you've picked up Angular or React or Angular2 or Ember you have basically learned a third language. If you've done anything with Node, you've picked up a fourth. If you've done anything with Express, you've picked up a fifth on top of Node. If you've used any of the functional programming libraries extensively you've basically picked up a seventh. All of these "languages" offer different semantics and wildly different program structures. They all merely happen to share the same type system. It's probably not fair to call Javascript a functional language. See Haskell, Clojure, F#, or Scala for a better example
Thanks for this! Is there another vimium binding that renders a similar input field? I've accidentally activated said function numerous times but I don't think it had a list of tabs underneath.
I've been on CodeAcademy Pro for a few months and I love it. But sometimes I just want to see a dissection of sorts to remember things quickly if I forget something. 
Oh, I was under the impression that many go like this: write TS-&gt;emit ES6-&gt;Babel transpilation-&gt;ES5-compatible code. The next version of TS will remove the need to emit ES6-&gt;Babel transpilation. A world with vanilla, zero-transpile JS... now that would be a stack worth marveling at.
It's cute that you think that a day old conversation is stale in /r/javascript.
As a core contributor since before the announcement I hope to give some light on the questions brought up. Typically I find most of the open issues are not bugs but actually feature requests. In open source if you try to add too many features you end up with a messy code base trying to cover too many situations. Given that the core of most everything works perfectly the question is what for you want to see active maintenance for in those situations? I can't dedicate as much time to contributing as I could before but I still dedicate hours per week to the community and to merging PRs creating them etc. Most of the open issues are a one person feature request also if it is getting enough up votes it typically gets prioritized. For the issues that are like that we definitely welcome PRs. Peoples lives change all the time and they become more and less available. All that being said I'd ask that anyone who feels that issues are high priority are unresolved to link to them please. Also let's be honest and look at the total number of issues on aurelia repositorys vs some of the others and put some facts behind instead of just stating that there is a problem with unresolved issues.
&gt; Holy shit Direct quote from me. Amazing. :)
My profile that remains on that site says: 0 comments. https://lobste.rs/u/marvindanig I didn't delete any. Something's missing? :-)
That browser vendors are adhering to ONE SINGLE spec and no longer have all these inconsistent APIs, so cross-browser compatibility will no longer be an issue.
Well, in [this thread](https://lobste.rs/s/0zmmsc/why_pinch2zoom_should_be_disabled_on/comments/cfc0i5#c_cfc0i5) I see a lot of &gt;`[Comment removed by author] ` Your account wasn't banned, either. That looks like this: https://lobste.rs/u/ponyfoo Charitably, maybe deactivating your account also deletes all your comments? That would be a surprising "feature". But, I guess it's not productive to pursue this. As you said, separate paths and all. If that^ turns out to be the case we'll fix the bug.
Yeah there is a ton of interest in doing it but the two teams (well before I joined Flow) agreed with the it would result in an implementation of the lowest common denominator which isn't good for anyone. So having a shared format is out (for now). The next question is "What about compiling TS defs to Flow?" We tried that, there's even a command in the CLI to do it still. But it doesn't really work because we'd need to add all sorts of things to match TS looseness. The final idea is to convert Flow defs to TypeScript. This is actually much more plausible and something we're interested in pursuing. It unites one of the biggest community efforts in a pretty close to the ideal workflow. Of course DefinitelyTyped has way more definitions today, but as we rally the JavaScript community to embrace type systems there's a big opportunity to do better. Right now DT is unversioned, overly loose, and often goes out of date or is incorrect because there aren't tests. There's also an opportunity to build a better workflow. Many DT users choose to copy and paste definitions so that they can fix them up but very often don't contribute back. We're working on a workflow that improves this feedback loop. The next few years the community is going to make a lot of progress, as we say at Facebook, this journey is only 1% done. 
Same for me on Windows.
I have no plans to return to lobsters. It was but for censorship that I deleted my account and not the other way round. In chronological order: 1. Initially a few of my comments and a subtree was deleted from the site. Sent a note to @jcs then. 2. Then some more of my comments were deleted because the community was *unable to accommodate* my thoughts, down voted etc. -- so much so that some of 'em trolled me here on reddit later on; but that's not unusual on the Internet! 3. In some time I "deleted" my account as the feature said so on the Settings panel, but they "deactivated" the account instead. This may be as per their policy, but then the button should say "Deactivate", not "Delete". [Bug report] Look, censorship may be due to a bug or something elseâ€¦ but it eventually did censor me. Those comments are against the grain of beliefs held by that community -- fine -- but removing them to prove and press a counter argument is a horrible place to be. Addition(s): I have seen various responses from the moderators @lobsters on how or why my comments were removed. My comments were all polite to the very end and lobsters has even benefitted from those over a period of two years. It is sad to learn that they ~~*are*~~ ended up into censorship but they claim otherwise. [Edits: Language / grammar / more context / even more context]
Javascript already does a lot more than Typescript, which is an outdated interpretation of Javscript with odd additions + static types. I would start with Javascript, not Typescript. If you either need modules or distribution of your work it will need a transpiler anyway so pick Babel. If you later need types, use Flow. A good resource for ES6 you can find here: http://exploringjs.com/es6/index.html As for Java and C#, you'll probably end up writing apps in javascript anyway. At least in a couple of years. [There are desktop apps written in javascript today using electron to package it](https://www.wired.com/2016/05/javascript-conquered-web-now-taking-desktop/). [Entire IDEs are written in it already](https://code.visualstudio.com/), apps you use everyday (Slack, Spotify, etc.). It starts to slip into mobile as well with [React native](https://facebook.github.io/react-native/). It is on the server and in iot in the form of Node. In short, the language has gotten so powerful that C# and Java would actually scramble quite hard to do what you can do with modern day javascript.
Its probably because you are seting the input *NAME* to kogels and then using getElementById. Add id="kogels" as a property for input.
Thanks. Setting up a test env today. Not exactly TDD but I'm new to testing, as I come an agency background where testing was not part of the company culture. Changing that in personal endeavors as of today! 
Does passing your code through Typescript not count as a compile step?
You can set up a project to perform some preprocessing to do something such as transpiling or minification for generating production ready code, but that's more of a conversion than producing a binary. [WebAssembly](https://webassembly.github.io) is looming on the horizon which is a byte code format that JS could compile to, but it's also being marketed as a compile target for other languages too, like c++. Its not quit here yet, though.
FWIW, I did a test and user comments are all deleted when an account is deactivated. Sorry about the other deletions. Anyway, have a good day!
I've been using Vimium forever and forgot about this! Thanks for the reminder
Beware of disinformation in this post
For runtime performance of common dom operations, yes. However, Web Assembly is far faster on parse time (zero, because it is pre-parsed) and is far smaller to download (because it is a binary format). Other improvements it can provide besides raw speed: * the ability to apply assembly-level optimization tools to our code * with time, it will provide easier opportunities to implement low-level memory and parallelism capabilities * once additional languages are supported, easy cross-language bindings without cross-compiling
 var baz = obj.foo.bind(obj); baz(); // 2 You also have to do something like that if you want to create an alias for QSA: &gt; var qsa = document.querySelectorAll.bind(document) undefined &gt; qsa('.md') [&lt;div class=â€‹"md"&gt;â€‹â€¦â€‹&lt;/div&gt;â€‹, &lt;div class=â€‹"md"&gt;â€‹â€¦â€‹&lt;/div&gt;â€‹, &lt;table class=â€‹"md"&gt;â€‹â€¦â€‹&lt;/table&gt;â€‹, &lt;div class=â€‹"md"&gt;â€‹â€¦â€‹&lt;/div&gt;â€‹] &gt; qsa('.md').length 4
If you are going to run that code in the browser, it is a good idea to convert to ES5 and then minify to reduce bandwidth and improve compatibility. If you are going to run the code in nw or electron, I am not sure if there are advantages in minifying the code, since the code is going to be read from the disk and V8 supports a lot of ES6 features already. So if it is a library that is going to be used in both scenarios, it would be interesting to convert to ES5 to not lose compatibility.
Not sure if the author explored this, but he or she could move the CPU heavy procedural generation to a web worker. JavaScript is single threaded and the big disadvantage is that you can't create a thread for GUI like you would in other languages, but web workers can help with this problem.
Breaking the myth that dynamic typed, not exclusively OO, and interpreted languages like JavaScript are not a real languages.
&gt; Explain yourself at least. Ok. &gt; Javascript already does a lot more than Typescript, Objectively false. Typescript is a *superset* of Javascript, therefore there is nothing you can do in JS that you can't do in TS. &gt; which is an outdated interpretation of Javscript It isn't an interpretation of Javascript, it's an extension. And no one who didn't have an axe to grind would call it "outdated", considering that 2.0 was [released two days ago](http://arstechnica.com/information-technology/2016/09/typescript-microsofts-javascript-for-big-applications-reaches-version-2-0/). &gt; As for Java and C#, you'll probably end up writing apps in javascript anyway. What does this mean? Java and C# [aren't going anywhere](http://www.indeed.com/jobtrends/q-java-q-c%23-q-javascript.html). &gt; In short, the language has gotten so powerful that C# and Java would actually scramble quite hard to do what you can do with modern day javascript. All three are turing-complete languages, and all three can be used in any environment (back-end, web, mobile, desktop). None is more "powerful" than the other. Comparing language "power" among turing-complete languages is meaningless. -- &gt; Babel goes a lot further than TS, that is a fact. At the expense of sometimes adopting features before they are finalized. That's a fact. Babel also lacks static type checking. &gt; Flow has been demonstrated to check types deeper. It's more aggressive, true, for better or for worse. Also, TS 2.0 greatly improves it's inference with strict null checks and type guards. Additionally, Flow's tooling isn't nearly as robust as Typescript's, and isn't as widely adopted. &gt; Why would you have him study Typescript? If indeed he wants to be in a better position to learn C# and/or Java, then Typescript would help in that effort considerably.
`this` has dynamic scope, not lexical scope. That means it doesn't depend at all on where the reference to `this` is written (e.g. in a nested scope), what matters is only how it's called at runtime. And calling a function without a dot sets `this` to the global object.
Do this in Typescript, please let array = [1, 2, 3, 4, 5, 6] let newArray = [ ...array, 7 ] let object = { name: "veuxdo", where: "reddit" } let newObject = { ...object, when: "today" } const func = (name, ...args) =&gt; { name: "default", name, ...["start", ...args.slice(-5), "end"] } Typescript btw also includes drafts. So your argument that Babels features aren't finalized is laughable. Most of these features are living standards already, like spread above. Typescript is just slower in adapting them because it has a small set of developers behind it while Babel has a large community. Flow is a gradual type checker which can be applied partially. It is pretty much the opposite of being aggressive. But when you use it, it actually does a damn good job at it, detecting things TS cannot. I never said that C# and Java are going somewhere. I just say that their influence over certain things will lessen. Node is more often than not the choice for server backend over C# and Java for obvious reasons. Doing front-end for desktop and mobile with technologies like React, ReactNative, Angular, Vue, Electron with hundreds of thousands of ready made components out there and cross platform compatibility out of the box is also quite a benefit over C# on dusty XAML. That these language will dominate the low-level is pretty clear. A few years from now they will even safely compile LLVM into webassembly.
Thanks for the idea :) 
I remember this comment, and to be honest it was a huge oversimplification. It's very much not a one-way street. There are a lot of things that TypeScript supports that have no analogue in Flow as well, like module augmentations (necessary to support certain types of real-world libraries like RxJS). Flow declaration files also seem to primarily work in the global scope instead of primarily at the module level. Additionally, contrary to what James says below, declaration files are versioned now and work well in TypeScript 2.0.
That assumes a lot about the user. As a front end engineer- no way I could be productive with only 5 tabs open. Too many sites are stateful and reopening them would waste time.
Spread is critical for handling expressive immutability, which as a concept is probably more important for safe structures than static types. But it's just one example of many. TS also *just* got async, while it was part of living javascript for ages. If you look into any modern React app, official tutorials and documents even, you wouldn't be able to make Typescript compile it. 
You've heard of fetch, right? https://developer.mozilla.org/en/docs/Web/API/Fetch_API
 try { var val = await getStuffDone(); doSomethingWithValue(val) } catch (ex) { ... } yeah sure that's basically the same
Fetch is not fully supported by majority of browsers. All existing library using fetch has fallback to Promises as of now. Having said that, it's good thing to add fetch api as well. I'll try to include that too.
â¤ï¸â¤ï¸ Team Firefox for life!
If you care about an unresolved issue enough to write such a negative post here, then why not incentivize the Aurelia team by paying them to fix it? We do have commercial support officially available. Especially if you depend on the software to make money, I think it's only fair to also pay for priority support or contribute the fixes yourself. I get that people demanding free stuff is the norm in the OSS world, but we could really use more gratitude (a ["thank you"](https://github.com/Microsoft/vscode/issues/10145#issuecomment-245310694) can sometimes be more than enough!), especially from people like you, who depend on it and use it commercially. Otherwise, we do as much as we can **in our free time**, but I can assure you, it's nobody's dream to sieve through countless bug reports, often without reproduction repos, trying to figure out what's wrong in that specific case, rather than e.g. enjoying a good movie with one's SO. Issues are left unassigned, simply because we do not use that GitHub feature much, rest assured, we do triage all issues and deal with them ASAP. You're also quite wrong about Rob being the sole committer. To see how very wrong you are, just [watch this video](https://www.youtube.com/watch?v=rtMMO-NDZfU). Finally, please link to the issue you mentioned and we'll take a look at it. Perhaps it slipped through the cracks.
You can do [server side](https://facebook.github.io/react/docs/environments.html) rendering with React as well.
Fetch has good support from evergreen browsers (see http://caniuse.com/#feat=fetch) and can be polyfilled for IE and Safari (see https://github.com/github/fetch). IMO it's best to stick with the standard in this case. It's only going to become more widely used with time. :)
Agreed. I'll include fetch as well, which will be primary. Promise fallback will be there if fetch fails, and XDR if for IE. I've to skip fetch as of now because of Safari, both desktop and mobile, but including it seems to be good idea. EDIT: The fallback is simple XMLHttpRequest, which is same as mine. I think including fetch shouldn't be big issue for me. But I've to think if it's worth it, given there's existing library.
Yes, I wondered that myself. Also since the author was using Electron (which comes with Node) he could have moved some of that processing to the Node thread.
cooooooool I really just want to type `| ` though. Is there anything different here than `compose`?
I think you will find [Marko](http://markojs.com/) to be a good fit. Marko gives you server-side rendering and custom elements (similar to WebComponents). [markojs.com](http://markojs.com) was built using Marko and you can find the source [here](https://github.com/marko-js/markojs.com).
No it won't. I guarantee it. (Aurelia maintainer Jeremy Danyow here)
I liked Aurelia a lot when I played around with it but then I discovered Vue and liked that more. My $0.02 with Aurelia's future is that while Rob can reassure all day long the fact of the matter is that Aurelia was designed to be a business, meaning it wasn't just an open source project; it was going to be backed by a company whose revenue is tied to the strength of the framework. My assumption is that some or all members of the core team are paid to work on the framework, given that is a business (maybe not, I don't know). Rob joining Microsoft seems to indicate either it wasn't as successful a business launch as he had hoped for, or that he's just not as interested in working on it day-to-day. I would personally argue it does not look great for the company, and consequently the framework.
&gt; Ability to cancel and to set timeout. Those kind of go hand-in-hand. (If you can _cancel_ then you can easily manage your own timeout externally, via a decorator. That's probably better than a built-in timeout IMO because it also lets you add retry-with-decay functionality in as well.) IE8 is a bit unfortunately, yeah. But IE 9/10+ and iOS are pretty common. Polyfills are great in that regard. :D
There is no actual mention of hate speech in the quote, though.
I was suggesting he could make the change. It's the basis of relevancy. 
It's considered an anti pattern by a few hack bloggers. It's not harmful in practice if used by people who know what they're doing.
Yes, thats exactly that I'm suggesting, along with also making a PR. 
Transpiling isn't so bad, and Babel's plugin system means you can do awesome things at build time that would be difficult/slow at runtime.
Not just newcomers. Have you tried to maintain branching promise chains? It's a nightmare even for a seasoned engineer.
I guess we have different opinions on what necessitates a fork.
Forks should be for code changes. What loser forks a repo to add a gif?
It won't make you coffee in the morning, but it's pretty awesome for Chrome. Once you install it, remember '?' to get a popup help window with all the key bindings. Vi bindings for all the things! 
Just by reading the title I hoped it would be a babel plugin that converts `|` to `await`s with parameter-passing. Oh well.
I like it, but do we really need another single-function NPM module who's README is 7x larger than the source code?
It was very large in size, so didn't add it there. Just added the external demo link. http://i.imgur.com/Soqu41O.gifv
Thank you!
For a simple blog you can just use express with a templating engine like Jade. There's no need to over complicate things 
How many repos do you maintain? I don't have time to deal with dumbass pull requests.
It does inside ES6 arrow functions
You have to link the button to do something server side but you don't know what to link it to. Altering console would only alter client side; server side wouldn't be possible. You could try to maybe call the same endpoint that remove item does through the console and hope that works.
That's fair. I was afraid you were saying that it being open source means it's closed to criticism, sorry to assume.
The problem is not in the js ;) onclick does not work on elements that have a negative z-index. Remove this and it should work. You could also take a look at classList element.classList.toggle('on'); To add or remove the on class :) 
Sorry, I might be unclear on this one. The click event works when it's appended to the button. If I wanted it to work by clicking on the lights itself, would I then attach the listener to the li tags instead? Thus, something like this: let el = document.getElementsByTagName('li'); I tried that and it also didn't work...
Because with these examples the "function" keyword would take up more characters than the actual code 
Marko looks really awesome. I will take a closer look into. For the first its a bit confusing that there is a widget framework and a template framework. 
... hopefully using a symbol or keyword other than `|`. A Babel plugin that changes the meaning of already-valid code feels like a very bad idea.
That was my initial thought, but it looks like it can handle multiple async calls and return a promise after, which looks quite tidy.
Twitch viewer... they have good api and you can show off to your friends.
These are all fantastic ideas. I like the idea of taking user input and then tying it to a 3rd party API. Thanks a lot!
The current spec is es7, not 6. Babel directly reflects the tc9 process, even putting drafts into their respective stages, or dimissing/removing drafts that haven't survived. Also, many drafts are *living standards* before they become native, this in fact even helps the committee to track down practical issues that spring up. Oftentimes the polyfills or mock-ups to make these features work are directly from whatwg. TS on the other hand is completely removed. They pick what they feel they like, they add their own stuff that is foreign, omitt other things. The result is a javascript removed from the real world. 
Object spread is a proposal for ES2017. It won't even be in the next version of JavaScript. Array spread, which is from ES6, works fine though. &gt; Typescript btw also includes drafts. Yes, async/await and decorators. It also supported a bunch of ES6 features before they were finalized. That's what makes it a superset of JavaScript. The difference compared to Babel is that it's a fixed set of features. If your project uses TS 2.0, everyone knows what that entails. With Babel and a bunch of (maybe even experimental) plugins, it's a different story, however. Babel-flavored "JavaScript" is a very fragmented language.
&gt; TS also *just* got async You mean for the ES5 target? Async/await was added with 1.7, which was released last November.
I totally get what you're saying and I think you're completely right. `var add = x =&gt; y =&gt; x + y` is much harder to read than var add = function(x) { return function (y) { return x + y; }; }; ... At least in my opinion.
Because once you've gone functional you gotta be the biggest hipster in town.
Good that it is, last time i checked it was still stage-2, doesn't change anything. Are you indicating Microsoft is playing goalkeeper letting in only the "mature drafts"? It all boils down to them picking something and thereby defining what kind of code you write. 
Don't get me wrong, I write tons short hand notation. I just feel like on a topic people already struggle so much with, es6 notation is another unnecessary hurtle. 
Nice!
Well they have the trivial example, but if you look at /u/ElectricOrangeJuice response you see they could have written without es6 syntax.
Chrome native shortcuts on windows: - ctrl+[n]: navigate to nth tab open (left to right), 9 is last tab, 1 is first tab. - ctrl+tab: next tab - ctrl+shift+tab: previous tab
[https://github.com/melanierichards/just-build-websites](https://github.com/melanierichards/just-build-websites) 
I understand what you mean but it's really not what you call the "most advanced notation." Currying is a fundamental part of functional programming and in Javascript this just happens to be the way it's written using the arrow syntax. Sure, it could be written long-form as a function returning a function but I personally think it's a bit clearer this way and better illustrates how the function is composed one parameter at a time. 
They could have using the old syntax, sure. However, I think it's worth demonstrating this topic using the new syntax and is, in my opinion, a clearer demonstration using the arrow syntax than explicitly showing a function returning a function. 
The real MVP, thank you
I think its shortsighted that the functional community (or at least the author) is trying to pick up steam and they think gaining adoption will go smoother by showing an evolutionary chart where functional programmers are at the top and anybody who uses a different paradigm is less intelligent, less evolved. I think the image further reduces adoption from people who are already wary of functional style and can connect with the other styles since the image infers they are somehow inferior for not knowing/using functional. There is no perfect tool or way of programming that should be used for all projects. 
Forgot to post this! [Progressive webapp](https://github.com/hemanth/stock-board-pwa) tutorital. 
I well explained it above; The function is asynchronous, therefore you can't expect it to return a value like a synchronous function does, because the value you want it to return might not be ready at that time you are trying to use it.
There's also RE:DOM https://redom.js.org ðŸ˜Ž
Jade / Pug?
If you have a specific thing you want your website to do, you will probably have some luck finding a small working example that you can pretty much use verbatim. What do you want your website to do? 
Can you elaborate what you're looking for? You can open any of your website's HTML page and inject javascript with a `&lt;script&gt;`
Still data mining 
Reading the comments here I think a lot of people are talking past each other. I don't think ES6 syntax is bad. In fact, I use it every day and I love it when it keeps things simpler. Arrows are cool and destructuring is a fucking godsend. My problem with the example I posted above is that it removes the nesting/indents that add all of the context. The following two examples read pretty much the same to me // ES5 var add = function(x) { return function (y) { return x + y; } } // ES6 const add = (x) =&gt; { return (y) =&gt; { return x + y; } } Readability takes a hit, not when you introduce arrows, but when you remove all the context that the indents provide and turn it into a one-liner ala `var add = x =&gt; y =&gt; x + y` It doesn't have anything to do with ES6. You can do this kind of bs in ES5 as well. Case in point: `2 &gt; 1 ? funcA() : 3 &lt;= 2 ? funcB() : funcC()` Just write it out instead... You'll thank yourself later. if (2 &gt; 1) { funcA(); } else { if (3 &lt;= 2) { funcB(); } else { funcC(); } }
I like newlines for this purpose. ``` var add = x =&gt; y =&gt; x + y ``` I know there are cases when this isn't ideal, but when a block is too hard to read I'll just rewrite it until it is less confusing.
more 'evolved', but still homer simpson
Gas lighting 
&gt;They were hidden from default view due to downvotes Ahh, good catch. I see how this automatic behavior could have been misinterpreted.
I am struggling to understand how people can struggle with arrow functions. I started to use them with C# and Python 5 years ago and I love them so much. They are clean.
&gt; Look ma. No for-loops. And much easier to read and therefore reason about. Seems like a matter of personal preference. I don't have a problem reasoning about for loops and typing one out ("boilerplate") is not much more than typing the map function.
&gt; None were deleted prior to that; How do you know? &gt; and responding with insults It is baffling (may be not) to see that the people who trolled yesterday (and used quite a few expletives!) are also happy to label my thoughts as "insulting". Not *theirs*, but mine! Sure, go ahead if it makes you feel any better. &gt; presumably because you were ignoring everything that was said to you Good to see you found a reason to justify what follows in your sentence next. Jeebus, am only glad to have moved away from that site. 
It does look like the issue is being discussed on the templating repo. I'll bug Jeremy to look in to it, though.
&gt; 1) why is the 'new' keyword optional (a vs b) Because JS is funny like that. `new` can't be omitted if you use ES6's classes, though. &gt; 2) in c, I assumed that using 'fill' would result in 3 sets of independent 'zeros'. it appears to copy by reference. why have the designers of js made it as such? You create one array and then you stick it multiple times into another array. You aren't cloning it. It's always the very same object. &gt; 3) in d, I haven't event used a variable like 'zeros'. Why are things getting copied by reference here as well? this one really confuses me. The array is created right there and *then* handed to the fill function. The fill function then uses this one value which was handed to it to fill the array. For what it's worth, here is how I do it: let a = Array.from({length: 3}, () =&gt; new Array(2).fill(0)); If you do it like this, you only iterate once. If you fill then map, you iterate twice.
My guess as to why more concise syntax is preferred is because these tutorials are intended to show off elm and the fat arrow version of add looks the most like the type signature of the add function in elm: add : Int -&gt; Int -&gt; Int add x y = x + y 
Neat! I don't think `%&gt;%` would clobber any existing javascript out there, right? Probably?
From my limited experience of Javascript, here's what I'm guessing is happening: a) applying new here is inconsequential because Array.fill is guaranteed to return the modified array anyways, so forcing a return value out of the constructor by using new doesn't overwrite what's actually returned from the function by calling fill (Calling Array's constructor might also return an array object regardless, so maybe new has no effect at all?). b) I can't speak for what the designers were thinking when they made JS, but the rule of thumb that I've always used is that everything copies by reference, unless it's a primitive object (number, string). Passing possibly large objects by reference is generally faster in most cases, so it's probably best to stay consistent rather than making awkward exceptions for edge cases, like in your situation. c) Like I said, everything copies by reference unless it's a primitive, so even though you didn't save Array(dim).fill(0), it still makes a temporary object and passes a reference to that temporary object. EDIT: I figure I should also mention that you need to use map here because map is guaranteed to be called once per entry in the array. In situations C and D, you're only creating a new array once for fill's parameter, and then using that one reference to fill the array, which copies the same reference to the same array 3 times. In map, each entry gets the function called, and each call to Array(dim).fill(0) creates a new array, therefore leaving you with 3 arrays instead of just the one.
well, iâ€™d rather use F#â€™s `|&gt;`. the `%&gt;%` only comes from the fact that every function whose name starts and ends with `%` can be used as operator.
Point-free composition and currying vs no point-free composition or currying: var mult5AfterAdd10 = compose(mult5, add(10)); var mult5AfterAdd10 = y =&gt; mult5(add(10, y)); 
awesome, thank you so much. BTW. It would be nice if Aurelia core team make a video teaching about how to contribute to the framework: fixing bugs, new features, etc. I would like to contribute but I don't know where nor how to start :/
isn't the toon kind of stupid anyways? in the context of that all code still has to compile down into pure machine readable form. It's not like your processor understands what openBeer(function(beer) { return this.isHomer }) actually means. 
Isn't this.isHomer always undefined? 
If you are looking for ready made HTML/CSS components you might try any of the usual suspects: Bootstrap, Foundation, PureCSS, etc.
Gzip is done by the server automatically if the browser supports it.
Yep, it just uses css to automatically adapt to the platform your app running on (Android, IOS or Windows).
So true, things get deprecated fast...but I'm still addicted to it for some reason :D
It's not in your sample code, but it's pretty safe to assume `scores` looks something like this: scores = ['a', 'b', 'c', 'd', 'e']; The length is probably different, as are the members, but this is fine for explaining. Every member of an array has a corresponding `index`, which starts with `0` and goes to `length - 1`. In the above example, `scores` has `length` equal to `5`, where index `0` is `'a'`, and index `4` is `'e'`. So, **to access a member of an array**, you use the bracket notation as in your example with an index integer: var foo = scores[0]; console.log(foo); // prints 'a' var bar = scores[3]; console.log(bar); // prints 'd' Makes sense? So your `for` loop is just looping through all the members of array `scores` and adding them to the variable `total_score`.
Nothing. Or, well, it reads a value from a position in scores, and adds it to total_score. As the loop progresses, index is going to be 0, 1, 2, ... n, so it's essentially total_score += scores[0]; total_score += scores[1]; ... total_score += scores[n];
 function makeHobbits() { var hobbitList = document.createElement('ul'); document.body.appendChild(hobbitList) // display an unordered list of hobbits in the shire (which is the first article tag on the page) // each hobbit should be a list item, with text showing their name // give each hobbit a class of hobbit // to save some typing, you can use map instead of a for loop. Its cleaner and has a few extra useful things. /* those extra things aren't really needed here, because appendChild expects an actual DOM NODE, not an array of elements, so we can just take advantage of the cleaner syntax. The extra things are, a for loop just performs a function on items of a collection, but it doesn't actually return a new collection. If I had assigned my array i'm mapping over, to a variable, for example, var hobbitList = hobbits.map(...do something on each hobbit); hobbitList would be a new array with each item modified by the callback function. But again that is not needed here.*/ hobbits.map(function(hobbit){ var li = document.createElement('li'); li.className = 'hobbit' li.textContent = hobbit; return hobbitList.appendChild(li); }) } var hobbits = [ 'Frodo Baggins', 'Samwise \'Sam\' Gamgee', 'Meriadoc \'Merry\' Brandybuck', 'Peregrin \'Pippin\' Took' ]; makeHobbits(); `
Subbed.
Yup. Index is just a variable.
HOLY FUCK I AM SO STUPID. Here I was thinking that was some kind of method that I had not learned about, but it was really a variable I declared just a few lines earlier. This clears EVERYTHING up. Thank you for putting up with my stupidity :P
this is multiplayer. Must have been the only one playing at that moment.
[webgl ghost](https://kitties.neocities.org/ghost.html) made with [regl](http://regl.party)! code: https://github.com/mk30/reglexperiments/tree/master/ghost
No problem! For-loops can be a bit tricky before you get it down, since there is so much going on in them. I'm not a super fan, especially not in JS where there are more elegant, functional solutions to most problem, but loops are essential programming constructs. Good on you for taking an interest, I hope you find it both fun and challenging. 
You forgot the ", 0" bit. If the array is empty, you want 0. &gt; [].reduce((a, b) =&gt; a + b) Uncaught TypeError: Reduce of empty array with no initial value &gt; [].reduce((a, b) =&gt; a + b, 0) 0 [For what it's worth, I didn't mention reduce because OP is a complete beginner who most certainly hasn't seen arrow functions yet.]
You can use a variable that holds an integer to access an array member just the same as an integer. So this: var arr = ['a', 'b', 'c']; console.log(arr[2]); // prints 'c' ...is the same as this; var arr = ['a', 'b', 'c']; var i = 2; console.log(arr[i]); // prints 'c' So now, in your `for` loop, you are defining a variable called `index` to start at value `0`, and for each iteration thereafter to iterate itself by 1, until it is bigger than `scores.length`, and then it will exit the loop. So let's say your data looks like this: var scores = [89, 96, 75]; var total_score = 0; Then we iterate, **first iteration** looks like this; index = 0; // is (index &lt; scores.length)? // (0) &lt; (3) // yes it is, so we go into the block total_score += scores[index]; // which is the same as: total_score = total_score + scores[0]; // so total score is now: 0 + scores[0] = 89 Assuming there is nothing else in the block, now we go back to the loop headers and run again for the **second iteration**: index++ // which is the same as: // index = index + 1 // so index is now: 0 + 1 = 1 // is (index &lt; scores.length)? // (1) &lt; (3) // yes, it still is, so into the block we go total_score += scores[index]; // remember, this is the same as: total_score = total_score + scores[index] // = 89 + scores[1] // = 89 + 96 // so total_score is: 89 + 96 = 185 Now let's go for a **third iteration**: index++ // index was 1, so we increment by another 1 // = 1 + 1 = 2 // is (index &lt; scores.length)? // (2) &lt; (3) // yes, it still is, so back into the block total_score += scores[index]; // the same as: total_score = total_score + scores[index] // = 185 + scores[2] // = 185 + 75 // so total_score is: 185 + 75 = 260 Now we'll try to run another iteration: index++ // = 2 + 1 // = 3 // is (index &lt; scores.length)? // (3) &lt; (3) // nope! so we exit out of the loop // and do not run a fourth iteration So now we have `total_score` equal to `260`, or the sum of all the members of array `scores`. Make sense?
Yes!!! Thank you! That clarifies everything. You are the best!
thanks! hope you'll find some useful info there. will be happy to answer any questions you might have. and please, do give any feedback you have right away :)
No problem friend, happy to help. Feel free to reach out if you have any questions in the future.
Currently it's quite simple. The user uploads their images and the data URIs from the images are passed to a function (referred to as Scramble). The user also submits keys which are validated client side in JS. The keys are also sent to the Scramble function. The function uses the keys to scramble the image before returning the scrambled image for download. The problems I'm encountering are that large images or large volumes of images cause the browser/script to crash. So I was thinking I could send the image URIs to a server, run the Scramble function there, and then prepare the images for download from the server too (as downloading large or multiple images can cause it to crash). Unfortunately I have no idea where to start. As per the advice from /u/xtphty , I've looked at node and phantomJS, but don't know where to start with nodeJS, and am not sure what I would use PhantomJS for. I'm still learning, the website up until this point has mostly been me on stack overflow looking for answers. But I'm close to getting it ready for a sort of alpha stage, apart from this hiccup. Any advice or pointers? Thank you
Yeah I guess it's just personal opinion on my part. 
Your scrambling code may need optimization. 
The effort is laudable, but the limited resources on Aurelia, the small community, and the complicated project setup are huge problems to overcome if you want Aurelia to have any adoption at all in the JS world. I tried to give Aurelia a shot recently since the ergonomics are so nice, but the only way to setup a project is using the CLI which creates a ~~bloated and~~ complicated project. For example, why are you even including [jQuery in the skeleton projects](https://github.com/aurelia/skeleton-navigation/blob/master/skeleton-esnext-webpack/package.json#L88)? After days I found no resources that clearly explained how that project is configured, or how to setup a project from scratch. Nobody on the Gitter channel could point me to anything, nor the Aurelia Twitter. I gave up after a few days. Sure I could have found my way around the project configuration, but why should I have to do that when I can setup a React or Vue project in a matter of hours, from scratch, without having ever used Webpack before.
It would be super helpful to know exactly what your script does/what libraries/APIs it uses (and why you can't just run it on node right out of the box). As someone who has used phantomjs a lot, I would strongly recommend against it unless there's absolutely no other way (at which point it's great). You mentioned image scrambling - can you do the scrambling with [imagemagic](http://www.imagemagick.org/script/index.php)? If so, you can use one of the node imagemagic modules and likely have an extremely easy and performant solution. Without more details, that's the best I can offer.
Reduce number of loops required to apply changes by caching data along the way. Introduce O(1) operations to remove O(n) operations. Read about the dynamic programming solutions for lis or two bridges as an introductory example. Seeing the code probably wouldn't make it harder for me to answer. 
Just like appendChild expects to be passed in DOM objects, it also only exists for DOM objects. The hobbits array is a list of simple strings. Strings themselves, such as what is returned from hobbits[0], don't know anything about the DOM, so you can't call DOM methods from them. The appendChild only exists for DOM objects. But this is where it gets tricky. You're creating `newDiv` correctly. That is a DOM element with the necessary id and class attributes, and you will need to pass it into an `appendChild()` call to add it to the DOM. However, you need to add it to another DOM object. Specifically, you need to add it to the `createNewLI` element you created in your loop earlier that was given the text for Frodo. The question is, how does the function know what `li` that is? Probably the best way to handle this is to pass in the Frodo `li` into the `keepItSecretKeepItSafe()` function through a function parameter. This way the function is more versatile and can be used with any `li` you want. But I'm going to go with the assumption that you can't change that part of the function. So then it becomes a matter of what kind of assumptions can you be making in `keepItSecretKeepItSafe()`. The less "thinking" like this it has to do, the better. So what do we know about the `li` used for Frodo? One is that its the first item in the hobbits list. So from the loop, it will also be the first `li` created for the DOM. With that in mind, we can target it easily with a query using `document.querySelector` which happens to return the first match when used with something like `'.hobbit'` which matches all the hobbit `li` elements. // ... var frodoLI = document.querySelector('.hobbit'); // gets first hobbit frodoLI.appendChild(newDiv); The problem with making assumptions like this is, what happens when the hobbits list changes? Suddenly the first hobbit might not be Frodo any more. For that matter, Frodo might not exist in the list at all. Should the function even run then? I think for now, this gets you what you need to move on at least.
I don't know.
Agreed with /u/EasonG and strongly disagree with the other comments in this post. There's no reason to create a full server-side DOM and canvas with PhantomJS just to do image processing - it's absolutely overkill and far less performant. On the client, extract your image data out, and then pass it to the server for processing. That'll make it easier in the future too to reuse for any clients that aren't JavaScript-based, like an iOS or Android app.
&gt;The only way to setup a project is using the CLI No, we offer multiple skeleton projects based on both Webpack and SystemJS. The CLI is alpha quality at the moment, but we're working to improve it. &gt;For example, why are you even including jQuery in the skeleton projects? Because our community demands it. I personally try not to use jQuery unless absolutely necessary, but our community has told us time and again that they want jQuery included in the skeleton projects. That being said, the Aurelia CLI does not include jQuery in the projects it generates. &gt;the only way to setup a project is using the CLI which creates a bloated and complicated project. I'm genuinely interested to know why you think that it generates a "bloated and complicated project." We believe it creates a nice starting point for a project, while not including anything that isn't necessary for the typical project. For example, the only runtime dependencies of a default project created by our CLI are: `aurelia-bootstrapper`, `aurelia-fetch-client`, `aurelia-animator-css`, and `bluebird`. That isn't bloated, that's fairly minimal. After looking at it, I'm probably going to push for us to remove both the fetch client and animator plugin. I can get up and running with a brand new Aurelia project in just a few keystrokes. Most of the time it takes is running `npm install` for the various build dependencies the cli uses, but you're going to have that when working with any modern framework, especially when you're planning to write ES2015 code. Please let me know why you think a project generated by our CLI is bloated and complicated. We're open to further simplifying this, if it is possible, and if it improves the experience for developers. 
Thanks. Frankly, posts like this make me feel like I'm failing at my job as community lead for the framework. It means I need to do better.
Second this. I can't tell you how many times I've been asked to make a change to the way forms operate natively in the browser that amounted to user frustration instead of user convenience.
I am not funding it. Just something I do for fun :)
thanks! hope you'll find useful stuff in the course. feel free to ask questions and give your feedback on anything :)
Thanks, that's really cool, I haven't seen this before. I like the arrow notation myself, but I'm particularly interested in programming languages and their semantics, formal and/or applied. I agree that there are some basics in programming that everyone \*should\* learn, but it's hard to create and maintain those standards when people mostly have to seek out material themselves and teach it to themselves. It's not curated into a curricula that everyone has access to, and by access, I mean time, and connectivity to the best resources (such as reading forums like this one with regularity). Every time you devote time to one resource, you remove time from accessing another resource. There is so much to know about programming and computer science, that I honestly think, most computer scientists and developers in 2016 \*should\* understand that their colleagues often aren't coming from the knowledge path. That doesn't mean they can't understand what they need to when they need to, it just means that they haven't spent time studying that particular thing. However, I still can't say I'm particularly enthused with teaching currying through the usage of languages that curry functions automatically. It's basically saying, 'you don't have to learn anything about this, because the interpreter/compiler does it for you'. I guess my main problem is with the clickbaity title. 
That's a really good point! A lot of people learning web dev in schools or through books probably won't be exposed to the shiny new toys from ES6 for a while. I also suppose it would be confusing for beginners to have to learn about two types of functions from the get go. It's even more confusing because they're so semantically similar, but not _quite_ the same. And once you're past the beginner stage, it can definitely be a challenge to keep up with all the developments going on in the JS / web dev world. I try my best to keep up with what's going on, but even then it always seems like there's some Hot New Thing that everybody recommends, which ends up leading down a dark, winding rabbit hole of blog posts, babel plugins, polyfills, and head scratching. JavaScript is messy :P
This is a good idea! Maybe make it offline first with Pouch/Couch (replacing Mongo).
Don't try to run before you can walk. Finish your book, get a solid ES5 foundation before getting into fancy stuff. A nice project you can make right now is a calculator. Not very glamorous but you'll start to face real problems.
Yea, and for some work places, using cool new toys often makes code more difficult to use between people, if I'm not there one day and my boss has to modify something, it's important he understand my code without having to dive deep into my own knowledge (which is a lot of computer science and not a lot managing large scale, large user base platforms - like he does). I've made the egregious mistake of pulling out all my cool new tricks and brand new libraries etc, and all I did was create headaches that only I could work with. So adoption to new things in industry is slow to begin with, for good reasons. But I don't even mean the kids in school, because when I TAd classes, lots of kids were diving deep into their own esoteric interests and shiny new things. I just mean, the internet is big, it's not as easy to navigate as Google would have you believe, and there's lots of information that is very hard to find, or simply doesn't exist on it. That puts everyone at a disadvantage for learning things that are just shy of their reach, for whatever reason it is out of their reach, doesn't really matter. There's stuff people would like to learn and they can't always find it, or luckily stumble upon it. I agree ES6 docs are pretty within reach, but I've only read through them because there were problems I needed to solve using JavaScript that I couldn't solve given the tools I currently had, which caused me to go down my own rabbit hole of implementing monads in js just so I could create promises before es6 was being widely used by most browsers. Good for a boring, rainy day to toy with, not so good when there's a problem in production and you are the only one who can think about how to fix it. 
I subcribed to your YouTube channel back when you announced it. Great videos dude, I've been impressed.
Currying should be a last resort. Functional warriors like the author are just going to teach beginners to destroy their performance with unnecessary closures. 99.9% of the time, your required data transformations are known. Needlessly over-genericising and over-simplifying to this degree is ridiculous. If a function should take multiple arguments, so be it. Ditto if you require a stateful object. All the arguments about testability are getting really tired. If you can't write a test that validates state, you fail at testing. If you can't handle a 'for' loop, you fail at programming. Know your problem domain and just use the right tools for the job.
In twitter_cycle.js you use the window load event to call the `randomtip()` function. When you dynamically load and execute twitter_cycle.js with `$.getScript` the window load event has already happened, so your `randomtip` function is never executed. If I understood your problem correctly, the easiest solution would be to just remove the part with `$(window).load(...)` and directly call `randomtip()` instead. If you have any follow-up questions, feel free to ask.
No, you can keep them, I would not want to take away your primary learning tools. I get that having to tie two related thoughts from neighboring sentences can be hard for some. In the sentence immediately following the one you quoted, I stated if the thing in the first sentence does not work, and maintaining the thing yourself is not an option, then using it for a production project was a bad idea. If understanding my original post in its entirety still is to difficult, I may take you up on your offer to lend me your crayons so I can draw you a picture. A very simple picture.
It is a convenient way of an object referring to itself, functions also act like objects in Javascript. See this [stackoverflow discussion](http://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work)
do you mind elaborating a little bit? I did: moveHobbits = ('.theShire').removeChild(theHobbits) ('.rivendell').appendChild(moveHobbits)
You need to be careful with the use of things like branch(predicate, component1, component2) JavaScript is not lazily evaluated, so you could be instantiating the component for the path not taken with bogus, potentially dangerous, data.
I went through your first video, this playlist is really promising! One question, what can we expect to learn after we're done with the course? As in, I understand that you'll walk us through the different segments of the project you described. I'd like to know what we will be able to do by ourselves once we complete the series with you. Keep up the good work!
[Airbnb](https://github.com/airbnb/javascript) has a good style guide that is accompanied by an eslint config file. Edit: fixed typo.
ok will go through this route right now. There isn't any way to append a whole &lt;ul&gt; without doing it one by one in a loop? I was reading through a group chat from our class and one of my classmates said he targeted the parent of the li which was the &lt;ul class = 'theHobbits'&gt; and appended it into the location. Does that mean he did it through a loop as well?
Tried that before too, should have mentioned it - I left it in so the script would work the same in the one example. Still can't figure this issue out, really is getting me frustrated
There isn't currently an ETA on the CLI. I will say that our plan, moving forward is for the CLI to be the "recommended" way to work with an Aurelia project. Having a CLI is important, because it helps encourage IDE integration for developers that find that important. While I can't give any ETA on the CLI, I can say that when we hit Beta, it likely will be no breaking changes from that point on. And when it hits RC, there will definitely be no breaking changes before final.
What about var add = x = &gt; (y = &gt; x+y); or even var add = (x)=&gt;( (y)=&gt; x+y ); I agree the readability is paramount and important above all else in a collaborative environment, but in my opinion whether to use the fat arrow syntax for functions and the provided implicit return is a matter of preference and use-case.
Russ Hanneman has put up a seed round 
What is the purpose of the scrambling?
I came here to say just this. It breaks a common convention. OP, in what way do you believe that this enhances the UX?
Thanks! Glad you found them useful :)
Thanks! Hoping you can find some useful info here. Feel free to ask whatever questions you might have :)
My wording was a bit odd but what I was looking for was the `o` binding. I knew I had seen that 'vomnibar' (I realize what it's called now) but I didn't know what triggered it. I should consult `?` more! Thanks for the tip on `gi`. That's a beauty!
Hearing 'todo list' nowadays makes me want to jump off a bridge. Im so sick of them.
Communication like this goes a long way.
No need to remove node, just append to new location and that's it!
Technically FP is a fair bit older than functional style. It just wasn't widely used.
You can append the ul and that will include all its children. The ul itself is still only one element, so it will work in the appendChild call. Its children are maintained in the move. This could work as a solution if its allowed. Something to consider is what is `.rivendell`? Is it a ul or ol? Or is it something else like a div? If a list (ul or ol), then you'll want to move the li (list item) elements individually in a loop since li elements are meant as children of list elements. If moving to something like a div or any other kind of element, then you'll likely want to move the whole ul. This keeps the list items in a list and doesn't leave an empty, orphaned list back where the ul was originally. On the topic of moving children like this, there's also something called a _document fragment_. It represents a DOM node that can never exist on the DOM and instead simply acts as a container of children in memory. If you attempt to append the fragment to the DOM, it ends up appending its children instead. This doesn't really solve the looping problem because you'd still need a loop to add children (li) to the fragment, but if you ever wanted to add a bunch of elements to a single parent in one shot, if you did it from a fragment, it could work that way. var container = document.createDocumentFragment(); for (var i = 0; i &lt; hobbits.length; i++) { var li = document.createElement('li'); li.textContent = hobbits[i]; container.appendChild(li); } // container is a fragment of li hobbit children var ul = document.createElement('ul'); ul.appendChild(container); // appends container children to ul, not container itself
How much prior JS knowledge do you recommend? Just basic Vanilla JS?
There are parts of a program where performance does not matter and where powerful primitives that enable expressive composition are very desiderable. There are other parts where performance is mandatory and where any abstraction is the wrong abstraction. There is no silver bullet. Just different tools to solve different problems.
This is what I'm using from generator-impero: { "parser": "babel-eslint", "extends": ["standard", "standard-react"], "env": { "browser": true, "es6": true }, "ecmaFeatures": { "modules": true }, "globals": { "DEVMODE": false }, "rules": { "jsx-quotes": [2, "prefer-double"] } } DEVMODE is a global I'm using in Webpack. You can probably take that out. I'm also not sure which of env and ecmaFeatures you'll need at this point, but the above works great for me overall. It extends "standard", the config mentioned above. The jsx-quotes rule is just an override to say that I prefer double quotes in React JSX per convention.
Yup, basic vanilla js should be sufficient. But be ready to read bunch of docs on node, frameworks, etc :)
What about simulating mouse events?
The standard way: var parsed = (new window.DOMParser()).parseFromString(myInput, "application/xml"); Compatibility with older IE: var parsed = obj = new window.ActiveXObject("Microsoft.XMLDOM"); parsed.async = "false"; parsed = obj.loadXML(myInput); Taken from http://mailmarkup.org/xyz/ With this you can then walk the DOM on the `parsed` reference to get anything you need using regular DOM methods. For more about the DOM read this: http://prettydiff.com/guide/unrelated_dom.xhtml
There's a difference between your use of `querySelector` here and `querySelectorAll` in your original post. The prior returns a single element. The latter (`All`) returns an array-like collection of 0 or more elements. `appendChild` will work with a single element, but not a collection of potentially multiple ones, even if "all" result includes just one. If you _do_ use an all query, and want to append from that list, you need to grab a single element from it. You can do this with the array access operators (`[]`) just like you use with arrays, or you can use the method unique to the NodeList collection returned by `querySelectorAll` called `item()` which works the same way. var gatherHobbits = document.querySelectorAll('.theHobbits') location.appendChild(gatherHobbits[0]) // or location.appendChild(gatherHobbits.item(0))
Supersubbed! Especially because of the webpack vid.
Probably won't throw away the code if you go server side. You could have the server render the initial state, display it to the client, then when the client takes over, it becomes a normal JS site again. So, you gain the speed of both the server and the client with one application, pretty cool.
You can find all the code + docs on GitHub, tagged by release. https://github.com/facebook/jest/blob/0.8.0/docs/API.md
I didn't even know top-level await was in talks. Read both of your articles. Good stuff!
I had looked at react-d3 and a few other libraries, but none of them seemed to really offer what I was looking for, so I opted for writing my own custom React code built on top of d3 v4, but without using selections or any DOM manipulation functions. Basically, I found that d3-scale, d3-path, d3-shape and d3-format were all that I needed to put together a pretty comprehensive and responsive animated charting component. To offer more feedback than that, I'd need to know what type of component you're trying to build with react and d3...
Hey. It's [hyperterm](https://hyperterm.org/) + [material theme](https://github.com/dperrera/hyperterm-material) and zsh + [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) (honukai theme).
Could you link to a Github of a library you've made. I would be interested to learn a less complicated way to accomplish this. I don't ever claim to be the best. I'm still learning everyday and I am not prideful. I would quickly revisit this exact project and remake it using your suggested simple technique. Thanks for your comment and the constructive criticism. It helps a ton.
Any body has an idea of how long it will take to migrate from angularjs 1.5 to react. I only have a couple of factories, controllers, and other packages like request and facebook login.
You need the canvas' rendering context [`drawImage`](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/drawImage) method, a bit of math, a keydown envent listener and [an animation loop](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame).
It's quite hard to estimate as it'll depend on your knowledge of react and its ecosystem. If you know it well - the migration should be quite fast. If you are new to it - well, it might take some time to learn it. I think incremental migration (i.e. component by component) is probably the best approach. And there's quite a number of articles about it (just search for ["migrating angular to react"](https://www.google.de/search?hl=en&amp;q=migrating+angular+to+react))
I do go in depth on some topics. It's more like - I don't talk too much about things that are covered in docs since I assume you are good enough to read them on your own. And there's no homework as is, just "go and break stuff to find out how it works" :)
I have used prototype plenty before i just feel it's even uglier. But i understand where your coming from. I see you are prototyping the getA method but returning this.getA(); did you mean this.a; ? can i just put these methods inside of the Person function like "this.getA = function(){}" if so i could remove the prototypes all together and at that point I see how ridiculous my first method really is. Thanks a bunch for your help
This guide is flippin' awesome. I looked up a guide on this a couple months back and couldn't find anything as extensive. THANKS!! p.s. Has anyone written a Node server in typescript?
OK then. This will give you what you need for more data mining. Save it in your web pages: &lt;script&gt; function more() { alert("data mining"); more(); } &lt;/script&gt;
Exactly... article should be renamed to "Poorly named impure functions are harmful".
Just a heads-up, you keep referring to "ES7 syntax", but most/all of the syntactic sugar was added in ES6, and async/await are not in the ES7 spec. https://github.com/tc39/proposals/blob/master/finished-proposals.md
This is probably the world's most helpful response. I believe I have everything set-up nearly correctly. My only question is, how do I invoke the script from the searchbox once then user hits the enter key? Thanks!
Of course, Typescript just transpiles to Javascript. 
Only a masochist uses node on windows. I hired a dev who insisted on using windows for node dev, I eventually forced him to switch to ubuntu. His productivity skyrocketed afterwards simply due to the fact that he was no longer googling obscure file system and node config issues.
I'm not convinced by the author's reasoning against using a single function. He wrote a synchronous version and then said it doesn't work because it's not asynchronous. Then he goes on to show a version that uses 3 functions, but 2 of them just wrap other function calls. Wrapping a single line of code in a function is usually unnecessary. In this instance, I disagree with it for 3 reasons * It adds indirection that doesn't improve maintainability or readability * It increases the amount of code * (Most importantly) It replaces a familiar API with an unfamiliar one Inlining the function calls while maintaining asynchronicity gives: function uploadFile(path) { var file = cleanPath(path); fileExists(file, function(conflicts) { if(!conflicts) { fs.rename(appDir, file, ...); } }); } IMO, this is much easier to understand and test
Are you on Windows?
Yea I know, i was just wondering if anyone had any opinions on it. I really haven't messed around with typescript that much but i feel like strict typing is a good idea for server code.
They're doing yearly releases, so this year we'll be talking about es8 (es2017) a bunch as well. Keep an eye on this page to see what's coming: https://github.com/tc39/proposals 
I find that large Node.js projects need tons of planning to stay manageable, even with Typescript. I find that it comes down to personal preference, although Typescript can help with debugging. 
I believe Ruby's RVM does this and is defined in your bundler file. This should really be in package.json right?
I found this article helpful https://www.exratione.com/2014/09/nodejs-is-too-inefficient-to-monitor-files-so-use-bash-scripts-instead/
It is discussed in the "Solving the problem" part in more detail :)
Probably .bashrc or .bash_profile or something similar.
Glad I can help! *** edit: The easiest way would be to wrap your input in a `&lt;form&gt;` tag and set the `action` attribute to `action="/search"` and add `name="s"` to the `&lt;input/&gt;` tag; example: &lt;div id="searchBar"&gt; &lt;form action="/search" id="search"&gt; &lt;input type="text" name="s"/&gt; &lt;/form&gt; &lt;/div&gt; I suggest using this method, as it doesn't keeps file size low and doesn't bog down the browser with excess Javascript code. *** end edit If you really want to use Javascript for this interaction, still wrap the input in a form tag, and do not set any attributes on it. That way, the form would automatically submit when you press the enter/return key. (it's also valuable as a [semantic HTML element](https://en.wikipedia.org/wiki/Semantic_HTML)) For this to work, you'll have to setup an [event listener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) to let Javascript know you want something to happen when an [event](https://developer.mozilla.org/en-US/docs/Web/Events) happens. The basic structure of an `eventListener` line is `{eventTarget}.addEventListener('{event}', function(eventObject) { /* callback function */ })`: * **eventTarget**: when working with the DOM, this is the element that will have the event happen to it. For this example, the `&lt;form&gt;` element, which we have selected and stored in the `form` variable, is the eventTarget. * **event**: these are different events that Javascript can "listen" for; they can range from DOM events like form submission, text input, and mouse clicks, to browser events like screen resizing or copy/pasting content. For this script, we'll be focusing on the 'submit' event. * **eventObject**: this is an object that has properties that give information on the eventTarget and the event. To use this handy object, you have to wrap any callback code within a function that passes the eventObject (commonly used as a variable `e`/`evt`/`event`), with your own code/function(s) inside that function. It's a little complicated, but for this example we will just be using the `e.preventDefault()` method; this method *prevents* the *default* behavior of the given event from happeningâ€“ in our example, the form submissionâ€“ and allows developers to add code in place of this default behavior. Finally, we're going to move the `searchedTerm` variable inside of the eventListener, otherwise it will capture the value before the user has the chance to input anything. Final HTML: &lt;div id="searchBar"&gt; &lt;form id="search"&gt; &lt;input type="text" name="mySearchField"/&gt; &lt;/form&gt; &lt;/div&gt; Final Javascript: var searchField = document.querySelector('#searchBar input[type="text"]'), form = document.querySelector('form#search'); form.addEventListener('submit', function(e) { e.preventDefault(); var searchedTerm = searchField.value; location.href= '/search?s='+encodeURIComponent(searchedTerm); }) 
thanks! hope you'll find something useful for you there :)
Yeah in reality (as suggested in the part with `//stuff`) the function would probably be longer. Here it's kept simple to illustrate the points without making the reader go through needlessly long code samples. Thanks for the feedback, I'll try to make sure better that there is no confusion about what is for example purposes only vs. what would make sense in a real app :)
I can point you to one public project that I'm working on - https://javascriptkicks.com. It's based on Kicks platform, whose new version is based on Aurelia. We'll soon have other Kicks network projects (like https://dotnetkicks.com/ etc) switched to new version. Beside that, for the last year, I've been working on 4-5 internal/private projects with Aurelia frontend and it's been a joy to work with.
You do say things like: &gt; You can probably spot a flaw here: None of the functions have callback parameters, so we canâ€™t get a result back. And &gt; I also removed moveFile, since it became completely unused None of it seems to explicitly address the fact that checking for conflicts and moving a file are two totally different things. Thank you for sharing your work and your thoughts! Hope you aren't discouraged by the downvotes.
I'm not aware of any examples, but just thinking about it, the search bar at the top is really only a special filter. In the data view of the app, both search and filters could be combined into one set, like ``` // state { filter: { matchTitle: 'the search field value', priceBoundaries: { upper: 100.0, lower: 5.0 }, /* etc */ } } ``` As for how the filtering occurs, that depends on the API you're interacting with. It's better to filter closer to the core, so hopefully your API would allow you to simply send the filter parameters with your `GET` on your items list, and handle pagination for you. Dump the resultant list in your state, perhaps caching it if you'd like faster navigation to the previous page. If you can't query and filter through your API and you also can't change that fact, things get more complicated and more wasteful. If your data set is small enough, you could pull it all down and filter it client-side on the fly. If not, pull down one page, filter it, check to see if the size meets your page size, and if not, pull down another page, filter it, append it to the previously filtered set. Repeat as needed. You'd probably want to cache the raw data sets as you pull them down to prevent redundant requests, assuming your data isn't super-realtime. You can add that caching as a layer around whatever you're using to interface with the API. As for actions, I'd imagine an action for updating each of the various filter fields, search included. I would have these update the `filter` part of the state, and have a saga which listens for such update actions and triggers a re-fetch of the list. That would be search-as-you-type. If that's not performant enough and you'd rather only search on form submission, create an action for the submission event and have the saga listen for that instead.
[It's $70 (US) to buy a license](https://www.sublimetext.com/buy?v=3). I did so a couple years ago -- Sublime has served me well and I'm happy to support them. 
I'm making a pretty big assumption here but I suspect that most people learning these newer tools will be consuming a RESTful API. I'd even accept a ToDo list that leverages a REST backend as a step forward (again, assuming my assumption is even close to correct)
Make sense. Putting `//stuff` in all the examples would probably be enough.
10 is still wasted. I get so many issues, no idea how many hours i have had to google issues and solutions. The absolutely worst is Visual Studio on nodetools. It makes me want to throw the laptop against a wall. Half a day just for a single Azure publish, ram in the gigabytes, computer buzzing and steaming. But all of our partners use Windows, it's infuriating. 
[Nodenv](https://github.com/nodenv/nodenv) does this with `.node-version` files, it will traverse up the file system for the file and if it doesn't find it will use the user's default and failing that the system default.
if you're doing an Ajax request there should be a parsed field on the response already: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML
Paid 80$ few years ago. Totally worth it! I'm using Atom now, just to switch it a little bit.
async is es8 not es7 
It is a video with it's "progress bar" bound to scroll. You scroll the page and the video seeks to appropriate position on it's timeline. Alternatively you can generate couple of frames (images) per second of the video and repaint them over a canvas as user scrolls. 
Sure, it's discussed a bit after that, but perhaps there is something to improve in terms of clarity. And yeah, Reddit is Reddit. Hard to please everyone, so I don't post everything here anyway :)
Thanks all. You're right. It was a difficult question. I struggled to really articulate the issue. Thankfully, I eventually figured it out. I ended up doing the following; var document = XMLManager.fromString(contentAsString); var nodeList = document.getElementsByTagName("m:properties"); var valuePairs = {}; for (var i=0;i&lt;nodeList.length;i++){ var name = nodeList.item(i).getElementsByTagName("d:Name"); var value = nodeList.item(i).getElementsByTagName("d:Value"); var nameText = name.item(0).getChildNodes().item(0).nodeValue; var valueText = value.item(0).getChildNodes().item(0).nodeValue; valuePairs[nameText]=valueText; } 
Are you purchasing bulk licenses or something? It's only 70USD. If you're not in a third world country (absolutely no offense to anyone who is) you could make that fairly quickly walking dogs, mowing lawns, finding a part-time job.. etc.
I love your landing page. I didn't see anything with the 3rd example. Just a blank white page. Nothing in the console, though. 
**TL:DR; Big software company magic.** Just spent a bit digging around in Chrome (v55 on OS X 10.11.4) and trying to piece this together. Contrary to what other users have suggested, the animation effect here appears to be done with image composition rather than a video. That said, Apple has used videos in the past for a similar purpose -- the Mac Pro specifically page comes to mind. For the sake of discussion, let's look at some of the resources used in the "iPhone 7 Camera" section. Here's a list of the relevant non-script assets: - Manifest: http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_manifest.json - Start frame: http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_startframe.jpg - End frame: http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_endframe.jpg - Diffs - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_001.jpg - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_002.jpg - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_003.jpg - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_004.jpg - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_005.jpg - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_006.jpg - http://images.apple.com/media/us/iphone-7/2016/5937a0dc_edb0_4343_af1c_41ff71808fe5/overview/hero-b/flow/large/flow/flow_007.jpg To be honest, there's some pretty tricky stuff going on here that I don't entirely follow. For example, the manifest appears to contain Base64 encoded image data, but so do the "flow" images I listed as diffs above. If you want to dig into this a bit more I'd suggest looking at the following functions in their [main JS file](http://images.apple.com/v/iphone-7/b/built/scripts/main.built.js). - `d._compositeFromSuperKeyframe` - `f.applyFrame` - `f.compositeFrames` - `f._saveKeyframe` EDIT: Included browser info for reference. EDIT2: /u/wollae's response links to a much better description
Have you already managed to get the value out of the input? If so, then all you need to do is this: function Player(name) { this.name = name; ... }
&gt; My objection is about accessibility. The iOS defaults were accessible, by default until you made them less accessible. Granted your concern about accessibility is genuine but I still need the ability to disable pinch2zoom, build something (let's say a game) and then re-enable it because, well, these are really books. It is very easy to implement pinch-zoom frankly, which brings us back to the top of the thread before this heady argument even started: pinch2zoom is only a hack-ey means to make an inaccessible design accessible. The issue is still a design that isn't accessible by default. Have a good week ahead!
my guess from looking is that the json is a config of regions of images like x/y coordinates that are updated on scroll. Then the flows are just a bunch of frames of animation strung together. so the initial image is drawn and then on scroll each frame only the tiny parts that need to be repainted are done so by grabbing just the chunk fo pixels needed from each flow. This is probably not quite as bandwidth efficient as using video which compresses over time but it allows them to have almost no compression artifacts which is why it looks so very crisp. Also mobile safari doesn't allow the play back of video without user interaction so you cant do bg video (though I think they changed that in ios10). So this method works cross browser very well since it's a canvas. 
Ordinary numbering was dropped starting with ES2015.
I've done a little cleaning up from the testing and here's what I think should work, but it isn't. var players = []; var numPlayers = 0; function Player(name){ this.name = name; this.score = 0; this.active = true; this.entry = ""; } function addPlayer(){ var fname = document.getElementById('firstName').value; players[numPlayers] = new Player(fname); numPlayers++; } 
Yes, not being careful about splitting code is the problem not the size of the functions. Even the staircase flow isn't the problem. If the functions had better names and had only one responsibility then reading the code would be much easier. Calling a function `checkConflicts` and then using it to move a file is a recipe for confusion because there is no indication that you'd need to read that function to diagnose file movement operations.
Curious on this. nvm is de facto from what I know and although I can't attest to the implementation, I've been using it for a long while with few issues. Lead developer is always active and helpful on irc too.
Exactly. ES8 isn't a thing. ES7 and ES6 are not really things. ES6 became ES2015. There is likely going to be an ES2017 and this will likely be a part of it. All this was to avoid making another ES6 with a huge number of perpetually unreleased feature. Heck, ES4 was dropped partially due to the fact that it had a ton of features in it (funnily enough, a lot of them ended up in ES6).
Unrelated request: please stop using ES &gt; 6 to refer to the language spec. The name ES6 was officially deprecated in favor of ES2015. All future versions of the ECMAScript spec will be named ES&lt;YEAR&gt;. 
&gt; They're doing yearly releases, so this year we'll be talking about ES2017 a bunch as well. FTFY ;) 
It seems that a lot of people doing data visualisation in React don't find what they want in existing libraries which expose reusable chart components and end up making their own ... Maybe we are still all looking for the best approach and in a few month something will come up ... PS: I made a react-faux-dom based example https://github.com/topheman/d3-react-experiments/releases/tag/v2.1.0 - next step: apply transitions (react-faux-dom uses mixins, I might try to use react-motion)
Hi /u/xxkelinxx, please use an online service to host your code: * [Github Gist](https://gist.github.com/) for simple JS/text dumps * [Pastebin](http://pastebin.com/) for simple JS/text dumps * [Codepen](http://codepen.io/pen/) for JS+HTML+CSS * [JSFiddle](http://jsfiddle.net/) for JS+HTML+CSS Please create a post that links to the code. Thanks!
I switch between both Atom and Sublime Text, and find that the former is slower, significantly enough that switching back to Sublime becomes more of a joy.
https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
$70 ain't thousands... and as a developer myself I feel obligated to support a lone dev writing the software I do my professional work on. So I shelled up my $70, smiled at no unregistered in the top corner. But then again my smile might ve been bc of those lovely fallatio providing angels. Man that was great. 
Laravel runs on your server and Vue runs in your browser. How could they be "the same"?
This works just fine as long as you have an input with id `firstName`. If you just log the value you get for `fname`, does that work? Also, just a tip, every array has a `length` property built-in, so you don't need the `numPlayers` variable. It's just a bit redundant. Your addPlayer function could just be: function addPlayer() { var fname = document.getElementByid('firstName').value; players.push(new Player(fname)); } 
X-Post referenced from /r/reactjs by /u/kanzelm3 [Video: Taming Large React Applications w/ Redux (slide deck posted last week)](https://www.reddit.com/r/reactjs/comments/54nw8m/video_taming_large_react_applications_w_redux/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Jordan's great! But it's [a 3000+ line script](https://github.com/creationix/nvm/blob/master/nvm.sh), whereas [nodenv inits in about 150](https://github.com/nodenv/nodenv/blob/master/libexec/nodenv-init). It's actually a port of [rbenv](https://github.com/rbenv/rbenv), which most of the Ruby community has switched over to for a variety of reasons.
Surely you've written something like `user-info.phps` &lt;div&gt;&lt;?= $user-&gt;username ?&gt;&lt;/div&gt; Right? React, angular, etc are a way to do this in the browser, instead of on the server. In PHP you'd set up variables and render with a PHP template. In react, you'd call some service that gives you back the variables, and you use React to render. In react it would look like `UserInfo.js` function UserInfo ( user ) { return &lt;div&gt;{ user.username }&lt;/div&gt; } What's the benefit? You can make your page interactive. You have all the data you need to understand how to change what your site is showing. In PHP, it would mean completely reloading the page. With a front end renderer, you can just update what the user sees without (essentially) hitting refresh
Here's the answer I gave on Stack Overflow a while back (http://stackoverflow.com/questions/5418369/what-is-the-purpose-of-backbone-js/7250075#7250075). In this case I was asked to explain backbone.js but AngularJS and React attempt to do the same thing. &gt; If you're going to build complex user interfaces in the browser then you will probably find yourself eventually inventing most of the pieces that make up frameworks like Backbone.js and Sammy.js. So the question is, are you building something complicated enough in the browser to merit using it (so you don't end up inventing the same thing yourself). &gt; If what you plan to build is something where the UI regularly changes how it displays but does not go to the server to get entire new pages then you probably need something like Backbone.js or Sammy.js. The cardinal example of something like that is Google's GMail. If you've ever used it you'll notice that it downloads one big chunk of HTML, CSS, and JavaScript when you first log in and then after that everything happens in the background. It can move between reading an email and processing the inbox and searching and back through all of them again without ever asking for a whole new page to be rendered. &gt; It's that kind of app that these frameworks excel at making easier to develop. Without them you'll either end up glomming together a diverse set of individual libraries to get parts of the functionality (for example, jQuery BBQ for history management, Events.js for events, etc.) or you'll end up building everything yourself and having to maintain and test everything yourself as well. Contrast that with something like Backbone.js that has thousands of people watching it on Github, hundreds of forks where people may be working on it, and hundreds of questions already asked and answered here on Stack Overflow. &gt; But none of it is of any importance if what you plan to build is not complicated enough to be worth the learning curve associated with a framework. If you're still building PHP, Java, or something else sites where the back end server is still doing all the heavy lifting of building the web pages upon request by the user and JavaScript/jQuery is just icing upon that process, you aren't going to need or are not yet ready for Backbone.js.
The worst is when you get your version of Visual Studio set up the right way, using the right version of Node as the 'External Web Tool' or whatever it's called, and then when you update Visual Studio or Windows, that gets reset to whatever the crap version of Node is that VS ships with. Infuriating.
Yeah they don't seem that useful. Can someone give me a use case?
Why not just use source maps?
yeah, the guy running it is very responsive and helpful...using it on my site, but unfortunately it doesn't work when I post here! [SiCives](http://sicives.com/)
&gt; All the examples are always To Do lists... Of course todo lists are the only examples given as they are the easiest way of demonstrating CRUD functionality, but that doesnt make Client side JS limited to only todo lists. If you understand OOP, VueJS would be just the V in the typical MVC model as is react, Views are (in general) a way to address formatting your data in the most superficial sense. In contrast angular is a full blown MV* framework. I myself prefer using Vue or React vs angular or ember because it allows me more flexibility in other libraries i want to choose minimizing code bloat. If you want an example of where you could potentially use client side views, how about administering of an eCommerce platform? An owner logs into their site, they have just scored a whole bunch of new products they want to enter into their database via the web interface. Instead of entering in 1 product then uploading, rinse and repeat. What if you could dynamically manage how many items you were entering client side while keeping them logically separated (displayed as cards or something), after each item has data completed the page updates async. In doing so you would prevent the owner from having to refresh the page, and also allow them to keep track of the items they'd entered so far creating better UX. This would be a use case for OOP client side. &gt; I don't understand the purpose. The purpose is offloading work (processing) to the client side while minimizing bandwidth needed and improving caching. If you could serve HTML or serve JSON and let client side OOP handle formatting which would you choose? Bearing in mind of course that your server is handling potentially hundreds, thousands or more of these requests and that caching solutions (redis) use similar JSON-like structures natively. Been a dev for years and still don't understand client side vs server side execution? #Facepalm
It seems that async/await really twists the code around.
&gt; Thank you for your explanation but the last sentence is just rude. If your skin is really that thin you might want to try staying off the internet. #DoubleFaceplam
Good article, but why link to twitter?
Cool typography animation on the landing page. Might give it a try with the JS library!
Frameworks help you write web apps. Any web apps. They are helpers that reduce the amount of work you must do and reduce errors. At least, that is the goal.
Yes. I lived happily ever after. Sublime Text is $70. It is worth it.
&gt; Also when using transpilation is not a thing. Exactly, this is very important to me. I mean, if we're gonna transpile it, we might as well use another language, like C# or Java.
Why are they awaiting `JSON.parse`? Is JSON async now?
The reply to the twitter comments was that await can be used on sync/async code.
In practice, you get a page from your monitoring system about high heap utilization so you go to take a heap snapshot. Then the OOM killer kills the process and you don't get a heap dump at all. To take a heap snapshot you need the size of the heap in free memory. This might not be possible.
Yep, victory from formidable is improving a lot. It's the strongest open source react charting library I've seen so far. I've used react-motion as well for a few projects. It's great for simple animation sequences, but not well suited to charting. I actually tried to use it for animating the first version of my charting library, but when I consulted the author about some specific stuff he straight out said he didn't recommend react-motion for the task. I ended up doing custom interpolation together with requestAnimationFrame, which is working quite well actually. I'm hoping to have time to open source it sometime soon... :-)
GOOD POINT.
&gt; I would rather not have js interacting directly with the database Normally JS simply makes a request to the server for data, the server retrieves the data (from the database or where-ever), packages it up (usually now as JSON) and sends it back to the webpage. That is the stock standard REST approach. If this is done asynchronously it is called AJAX and does allow the page to display the new data without a full page refresh. Why do you need something different?
The problem is not really browser vendors, it's the ecosystem and that there are two dominant, userland module systems. One is asynchronous, the other is not. 
How do I learn this? There is so much to babel.
not depending on jQuery is an advantage
Lazyload.js is a very heavy(8kb + jQuery) plugin as compared to Progressively (~ 2kb). Both of them support throttling i.e. event based loading. Since progressively doesn't depends on any external libraries, so it can be used readily with other frameworks and libraries like angular, react, jQuery etc.
The arrow notation is what got me into currying in the first place, the latter example is far more verbose and straining to me. Edit: meant for orange juice 
What advantage would that give you?
&gt; but maybe open up your mind a bit? I could, how much are you willing to pay me to do so? 
Indent the code (or use this http://jsbeautifier.org/) and specify what **exactly** you want help with.
https://mobile.twitter.com/malyw/status/780460672584970241
I don't think it's a good idea to have different builds for dev and prod, you risk having bugs in prod that don't appear in dev.
Try Ctrl+Shift+R or hashing your files.
You can't refresh source maps like that, it's [a known and old bug in chromium](https://code.google.com/p/chromium/issues/detail?id=508270). Even though it was marked as fixed and some changes were made, it persists.
[WebAssembly](https://webassembly.github.io/)
Especially interesting combined with what Facebook's up to with [Reason and React](https://news.ycombinator.com/item?id=12402113). q/a from [this article](https://www.infoq.com/news/2016/09/bucklescript-10-released): &gt; Q: One recent effort aimed to integrate Reason with BuckleScript. Could you explain how would it work and what advantages it would bring to developers? &gt; Hongbo Zhang: Reason is a JavaScript-like front-end syntax for OCaml developed at Facebook by Jordanâ€™s team. Since OCamlâ€™s compiler tool chain is very modular, it is very easy for us to switch the front end from vanilla OCaml to Reason. Note that Reason is more than just syntax. The team behind Reason also worked very hard to improve the tooling of OCaml, like build system, IDE etc. We work very hard together. For example, the design of BuckleScript FFI took a lot of feedback from Reasonâ€™s team. also this [video](https://www.youtube.com/watch?v=QWfHrbSqnB0&amp;feature=youtu.be&amp;t=29m34s)
But you already have Promise.all the whole point of await is to be synchronized... so that you can have dependencies like cont user = await getUser(); cont userStuff = await getUserStuff(user);
Thanks a lot for the long reply! I'll answer it as soon as I have the time! **Edit: Full answer** So I made it work the way I wanted it, the thing I missed is as you pointed out, the if statement having only one = instead of two or three, so thanks A lot for noticing that! Those other "bugs" was the way I intended the code to work (not the most optimal way but I started working on it and figured I'd learn more by trying to make it work instead of scrapping it and starting over and doing it another way), I intended the loop to run one more time so that it could go through all the index and only run the else if on the last time to make sure it went through all the "beings". Though I don't think this code always adds the current race to the reg array if it's already there since it breaks before coming to that loop.
What's the benefit of this over using progressive JPEG? Is it simply a means of achieving nicer transitions? Nice use of BEM btw. Wish more projects would use it!
Completely disagree with this. All major libraries / companies are using ES2015 and ES6 interchangeably, there is no reason to discourage usage of one over another after all this time. For next releases, it's fine to drop "ES7" name, but for the current one ES6 = ES2015 will always be there. https://facebook.github.io/react-native/docs/javascript-environment.html https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond/#0UT7jugKfbGx1VkS.97 https://hacks.mozilla.org/2015/04/es6-in-depth-an-introduction/ 
Subbed, great work! Will contribute to the gitter when I can.
http://ashrocketship.com/wp-content/uploads/2013/01/dontlikething.png
Anytime I've had an issue with source maps being cached, it turned out that it was actually a problem with new source maps not being copied or served. Check your build and your devserver.
That I get to run a language I'm more familiar with, with feature such as static typing. Yes, I can use Typescript for that, but it's still the same thing about compiling it down to JavaScript, so I'd rather fully switch languages if I have the chance.
God forbid someone has a differing opinion on the Internet! 
&gt; I intended the loop to run one more time so that it could go through all the index and only run the else if on the last time to make sure it went through all the "beings". Fair enough, but running through the loop an extra time is bad design for several reasons: 1. Intentionally iterating through the loop past the end looks like a very common bug, so it's liable to confuse developers (including you, in the future!) and any attempt to "fix" it would then break your code. 2. You're relying on picking up a non-existent item in the array to get an `undefined` value in a very non-obvious way. Generally you should make your code as obvious as possible, and this is unnecessarily cryptic. 3. Your code to handle the special case (where you get to the end of the array and still haven't found "this" race) is inside the loop, which strongly implies to anyone reading the code that it *can* execute on any iteration of the loop... when it can't - it can literally only execute "after you've already finished iterating over the array", so it doesn't belong inside the loop where you're iterating over the array. 4. You have two places where your code forks if you didn't find "this" race inside the `reg` array - one inside the loop (triggered by `else if (i === reg.length)`) and one outside (triggered by `if (known === 0)`). You're basically checking for the same state of affairs ("this race not found in reg"), but in two different places and expressed in two different ways. In general you'll write better code if you try to do one thing at a time, and handle each aspect of your problem in as few places as possible - *first* search through the `reg` array looking to see if you've already seen this creature before, and *then* do things differently depending whether you found it or not. Simplifying your code here, you're doing something like this: for (var i = 0; i &lt;= reg.length; i++) { if (reg[i] === this.race) { known = 1; break; } else if (i === reg.length) { reg.push(this.race); } } if (known === 0) { console.log("New creature!"); } else { console.log("Known creature: ", this.race); } That basically works, but as I said it has a number of confusing or nasty features. Better would be to do something more like this: for (var i = 0; i &lt; reg.length; i++) { if (reg[i] === this.race) { known = 1; break; } } if (known === 0) { reg.push(this.race); console.log("New creature!"); } else console.log("Known creature: ", this.race); } That's shorter and simpler, doesn't rely on intentionally iterating past the end of the array, doesn't rely on implicit undefined` values, and moves all the "did I find the creature or not" logic outside the loop, to a single place in your code.
Nah, the files served are fresh, we update them in one operation with source files themselves. All of them would've been affected. You can open them directly, actually, problems appear only in the dev panel. It's only one downside though. Promises and some other things are hard to debug with source maps for one reason or the other. It turned easier to just read good old source code, that is actually running in browser.
Schrodinger's x?
Wait so because other people did it wrong we should continue to be wrong?
Didn't you read? There's no name mangling. So we should all clearly start using this now. This changes everything. 
Hi, I am the author here, feel free to ask me any question : ) One uniqe thing with BuckleScript is it compiles a single file within 10ms(cold start) while give you a more powerful type system than typescript
I request the Highest of fives
Unpopular advice: Don't bother learning transpilation things like Babel unless you have to. Wait for new things to actually come into JS engines (this Async/Await is a perfect example).
bluebird Promise.each does this for you, not sure if it uses reduce behind the scenes.
&gt; What is the tooling situation like for OCaml? IDEs? refactoring?feedback about types in your editor? There is a type based IDE: https://github.com/the-lambda-church/merlin and plugins on top of it: https://github.com/hackwaly/vscode-ocaml https://nuclide.io/docs/languages/other/ &gt; What is Reason? What does it add apart from syntax? Reason itself is to OCaml is coffescript to JS, however, authors of Reason are very experienced JS developers (mostly are core contributors to React), on top of Reason syntax, they are also working on bindings to React, build system and IDE which fits npm ecosystem better 
Sometimes you just want async actions to go out and wait until the're done. For that Promise.all is needlessly verbose. await should be able to wait for an array of promises.
This feature landed on v8 4.5: https://github.com/v8/v8/commit/13b8a1238b4d08d91938b3fea6bc25a34958ac78 Next realease of node: 7 will use v8 4.4: https://github.com/nodejs/node/tree/master/deps/v8 So my guess is node 8
I knew I was going to regret that sentence. You're right of course. I still think that "reduce" is challenging as a name. While it's true that in the end, I want to reduce a chain of promises down to a binary message "did it work? - Yes or No", it's conceptually challenging when you start off thinking and learning about reduce the way it's normally presented. But again, you're right :). In this scenario, is actually care a lot about the side effects of soe of those promises. For instance, you can't record an event like "user created a new favorite item" until you've created the new favorite item. And since stat-making is relatively unimportant to the overall scheme of things, you don't even necessarily care if worked. 
Yeah, it's often useful to use a single object instead of a list of parameters if you have a lot. function trial ( obj ) { return obj.thing1 + obj.thing2; } var input = { thing1: 4, thing2: 2 }; trial( input ) // == 6
It's going to take me a little while to understand this one :). Thanks for the homework. 
Really liked this course: https://egghead.io/courses/react-fundamentals It's mainly about react but in the beginning it teaches you what a sane dev environment is. As you notice he needs 4 minutes to explain mostly all there is about it, because it's that simple. Webpack and Babel look intimidating (and can be), but in their essential forms they're quite easy to manage. You'll quickly realize what you've missed.
I think you're right. [This returns undefined.](https://jsfiddle.net/r2015knt/)
It uses Array.prototype.map to execute the imgTag function on each element of the foo array. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
Very cool, Im gonna give it a shot
Ahh ok. apologies, haven't really been affected by this
With ES6 syntax, you would use: function trial({input1,input2,input3}) { // Some code } But this assumes you're always passing in an object with the keys input1, input2, and input3 rather than individual values. In the function, they're individualized variables as though they weren't in an object.
yes, you can ocaml from js without doing anything(or as easy as typescript), check out the playground: http://bloomberg.github.io/bucklescript/js-demo/
ok so if you dont mind can I trouble youwith one more question. it keeps saying foo is not defined. when I am pretty sure that it is.
Progressive JPEG's are great and serve the same problem but with a different motive. Progressively is a library, so it has got features apart from just loading the image progressively. It works asynchronously and is event based that you can use to listen when your images load/are loaded. It loads images only when they are visible in the browser viewport saving server requests. Rather than comparing the two it would be a better idea to use them together.
I did not include your foo array in my code example. I have updated it with it.
Though I've been using `es2015` for monthes, I don't event hear it. Thanks a lot dude. Do I need any other polyfill library besides `dist/polyfill.js` if I want to use es7 features?
It's about time. I've been using the RC for months, without any problems. BTW in case you don't know: Leaflet is library for OpenStreetMap. All you need is this, and the configuration for a "tile provider". I think this library and its API is much nicer than that of Google Maps.
I'm confused; it sounds like in agreement. I said after ES &gt; 6 (ES greater than 6). As you indicated, the community has largely known the 6th version of the spec as ES6. The change to ES2015 only came at the very end of the spec's lifecycle. There's no rolling that back. My gripe was with the title of this post and the comments in this thread referring to ES7 and ES8. ES2016 (ES7) was only finalized a couple months ago. Very few people outside the standards process are even thinking about ES2017 yet. Best to adopt the new naming scheme before we get much further. While we're throwing out awesome resources referencing ES6, I'll chip in /u/getify's [ES6 &amp; Beyond](https://www.amazon.com/You-Dont-Know-JS-Beyond/dp/1491904240) ([github](https://github.com/getify/You-Dont-Know-JS/tree/master/es6%20%26%20beyond)). EDIT: Fixed typos
[removed]
Leaflet is just an open-source mapping library, it's agnostic to the tile provider. It can use OpenStreetMap, Google Maps, or any other tile source.
.... can someone explain what I just read? I'm sure it's very smart code, but I have no idea what's going on...
To pick a random comrade, I guess this is what you want to do(?) const tovarischArray = ["Lenin", "Stalin", "Khruschev", "Brezhnev", "Unnamed", "Gorbachev", "Yeltsin", "?"] const comrade = tovarischArray[Math.floor(Math.random() * tovarischArray.length)];
Sure, you can do this pretty easily using [co](https://github.com/tj/co) function sequence(fns) { return co(function*() { var results = []; for (let f of fns) { results.push(yield f()); } return results; }); } I prefer using `reduce` -- in my opinion it's more semantic than mutating an array in a `for` loop. But this works fine too.
Post your code on codepen.io or jsfiddle, that way more people can help :).
But bluebirds Promise.mapSeries does
I switched from 'es2015' to 'modern-browsers/webpack2' a long time ago simply because of how much faster the build step is with less babel transforms. I'd recommend checking that out. Also happy pack is happiness.
https://developer.mozilla.org/en-US/docs/Web/Events
_X-posting my [reply from /r/typescript](https://www.reddit.com/r/typescript/comments/54qe6w/z/d847j4c)_ Coincidentally a cow-orker asked about something similar today (only difference is that we want to stop after the first promise which responds with an answer that fulfils some condition (usually not being `null`)) so I wrote this: function promiseLoop&lt;T, R&gt;(array: T[], operation: (T)=&gt; Promise&lt;R&gt;, predicate: (R)=&gt; boolean = v =&gt; false, initial: R = null): Promise&lt;R&gt; { return array.reduce((promise: Promise&lt;R&gt;, current:T) =&gt; { return promise.then((value: R) =&gt; { if (predicate(value)) return promise; return operation(current); }) }, Promise.resolve(initial)); } The additional functionality here is that you can supply a predicate that, once it's fulfilled, prevents calling the operation on the rest of the elements in the array.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide
Here you have it, I think: http://codepen.io/Paulooze/pen/zKzYLB
Its basically a complicated way of running promises in a sequence and producing an array result of the outcomes. Its similar to `Promise.all` as far as the result goes, but the way the promises are created and run are more spaced out in comparison. While `all` takes a collection of existing promises or values, this approach relies on functions that create promises. Promises are, by definition, always running until resolved. Here, functions are used to create promises so promises only start running/exist when called upon. This happens sequentially as the first promise in the sequence resolves. Notice that even the `delay` calls aren't producing promises; they're producing functions that create promises. This is so the delay of 1000 doesn't start until the delay of 500 completes first. Once the 1000 promise resolves, a function is called that creates the 500 delay promise which then runs until it resolves. As the sequence runs, promises are created and their results are mapped into an array and eventually returned as the value of the final promise then-ed with the `console.log(x)`.
It prevents the parens from being seen as a possible function call. Simple example: (function (val) { console.log(val) })('hello world') This logs 'hello world'. Maybe I share this with someone else so they can paste it into their script. Their script, brilliant as they are, looks like this: alert And when the add the IIFE, you get alert (function (val) { console.log(val) })('hello world') But what JavaScript sees is alert(function (val) { console.log(val) })('hello world') Which when run, will alert the function then complain that the result of the alert call is not a function and produces an error. The semicolon ends whatever expression that might precede the IIFE so that its parens can't be misinterpreted as a function call. alert // ; to end the alert (or anything else up there) ;(function (val) { console.log(val) })('hello world')
I wish that could be possible. But unfortunately, on client side that's impossible since you'll have to 'receive' the image before you could alter it's length/resolution(which can be done using HTML5 canvas). But it just doesn't make if you are making your image progressively load after receiving it from server.
Finally! Leaflet is by far my favorite mapping library, and this release has been a long time coming. It's just so easy to use and extend. I absolutely love the work Mourner has been doing with Leaflet (and with the Mapbox team). I'll likely be switching from MapboxJS/Leaflet over to MapboxGL... and the GL library is not near as nice to use as Leaflet, but they're actively working on getting it there.
Webpack runs at the build step before the app even gets pushed to a server. What I'm imagining is definitely possible as long you have access to the images you're going to be displaying before pushing your content to your server.
Hello, and thank you for your answer! I was thinking more in terms of replacing the numericals in the else if statements with variables that relate to for loops.
i want help with making this old bot, which was used for quizlet.com s space race game, compatible with their new game gravity. function stopquizletbot() { enabled = !1 } function Setup() { /microscatter$/.test(url) ? bno = 0 : /spacerace$/.test(url) ? bno = 1 : (console.error("The quizlet game you are currently on isn't currently supported! Bot disabled!"), enabled = !1); console.log(bno); 0 == bno ? (console.log("Microscatter detected!"), $("a#start").trigger("click"), msctrterms = $("a.cell[data-type=term]"), msctrdefinitions = $("a.cell[data-type=definition]")) : 1 == bno &amp;&amp; console.log("SpaceRace detected!") } function msctrloop() { for (var b = 0; b &lt; msctrterms.length; b++) msctrtoEng($(msctrterms[b]).children().children().html()).trigger("click"), $(msctrterms[b]).trigger("click"); enabled = !1 } function msctrtoEng(b) { for (var d, c = 0; c &lt; msctrterms.length; c++) $(msctrterms[c]).children().children().html() == b &amp;&amp; (d = $(msctrterms[c]).attr("data-id")); for (c = 0; c &lt; msctrdefinitions.length; c++) if ($(msctrdefinitions[c]).attr("data-id") == d) return $(msctrdefinitions[c]); return console.error("moo!"), null } function srloop() { var b = ""; 0 &lt; $(".value").length &amp;&amp; (b = srtoeng($(".free").first().children().text()), $(".value").val(b)); srfailed || srsubmit(); srfailed = !1 } function srsubmit() { var b = $.Event("keydown"); b.which = 13; $("#gun").trigger(b) } function srtoeng(b) { for (var d = 0; d !== sranswers.length;) { if (b == sranswers[d].definition) return sranswers[d].word; d++ } return console.error("mooo!"), srfailed = !0, "" } function a() { console.log(" ____ _ _ _ ____ _ \r\n / __ \ () | | | | | _ \ | | \r\n | | | | _ _ _ _| | ___ | |_ | |) | __ | |_ \r\n | | | || | | || ||_ /| | / _ \| _|| _ &lt; / _ \ | _|\r\n | || || || || | / / | || _/| |_ | |) || () || |_ \r\n \\\ \,|||/||| \| \||/ \/ \__|\r\n \r\n ") } a(); console.log("Welcome to quizletbot by PixelZerg"); var msctrterms = null, msctrdefinitions = null, srfailed = !1, sranswers = null; try { sranswers = eval(/QTerm.dataToArray(.*)/g.exec($("html").html())[0]) } catch (b) {} var bno = -1, url = "", enabled = !0, shownmsg = !1, shownrngmsg = !1; try { url = window.location.href } catch (b) { console.log("catch"), url = document.URL } Setup(); setInterval(function() { enabled ? (0 == bno ? msctrloop() : 1 == bno &amp;&amp; srloop(), shownrngmsg || (console.log("quizletbot running..."), shownrngmsg = !0)) : shownmsg || (console.log("quizletbot stopped!"), shownmsg = !0) }, 1);
Your question isn't completely straightforward. Are you asking how you build a UI in JavaScript? If that's the question, I think directing you to a framework such as Angular or React would be a good start.
Leaflet author here! Feel free to ask any questions about the library and the release.
then make a calculator?
AFAIK is an acronym for 'As Far As I Know'. And i'm not sure what you mean by shifting my comment... I replied to your comment. 
Also, once you embrace the magic of custom transpiler plugins, you begin to see that transpilation has far more utility than simply smoothing over the differences between clients. You can use it to create macros with essentially unlimited power.
Yep. Looks like they did that with just JavaScript and HTML. They didn't even make use of &lt;canvas&gt; or SVG. Looks like they might have used an Adobe tool geared towards a Flash developer that let them target the web browser as a platform. This was found at the top of their JavaScript code. &gt; /* SiteCatalyst code version: H.23.2. &gt; Copyright 1996-2011 Adobe, Inc. All Rights Reserved &gt; More info available at http://www.omniture.com */ 
That's the line that's coming up in the error. But if I delete it, portions of the site break. What should it be changed to?
One use case which occurs to me is if you'd want to declare and set a variable in an if-else statement. You can reduce line count and perhaps make code more readable by doing this if (something === true) { var a = true } else { var a = false } console.log(a) instead of let a if (something === true) { a = true } else { a = false } console.log(a) This example may not persuade you, but imagine working with multiple libraries which need to be required/imported, and if you follow a certain linting standard, typing multiple lines of empty declarations is not very pretty.
Yeah, I get what it's trying to accomplish. I did the same thing in my original example. But what the heck is an "applicative"? 
Inside try catch blocks
*second example should really be using let*
Also, if you want a really cool example of things JavaScript can do, you can look at this Gameboy Advance emulator written with just JavaScript and it uses the &lt;canvas&gt; and &lt;audio&gt; tags. http://endrift.github.io/gbajs/ EDIT: Here's a link to technical demo ROM if you want to see it in action. https://archive.org/download/YoshiStoryGbaTechDemoa3
Tell me, which do you prefer of these two? let x, y, z; if(a) { x = 1; y = 2; z = 3; } else if (b) { x = 0; if(c) { y = 2; if(d) { z = 4; } } } vs: if(a) { var x = 1; var y = 2; var z = 3; } else if(b) { var x = 0; if(c) { var y = 2; if(d) { var z = 4; } } } You should stylistically **never** declare a variable inside of conditionals, even if you make sure you balance them, because collecting all your variable definitions from inside the following code block is a significant cognitive load. In the second example, it'd be very easy to lose track of a redeclaration of z somewhere.
Okay Mr Pedantry, why would you want a variable scoped to the function instead of a local code block?
Or, just point out that the 'else' block is entirely redundant in his example. The 'else' value could simply be the default.
It doesn't answer the question, it redefines it. You haven't contributed in any useful way with your post. 
Very possible, likely the preferable solution. Or async/await given support available.
In a nested environment, I think I would prefer the first example, just for clarity. However, as I am sticking to StandardJS, I would have to write let x let y let z instead of the one liner, and in a setup where there is no nesting, just a lot of these variable declarations, I would probably choose `var`.
So the issue I seem to come by is the x and y variables are null. The code behind (C#) part of it shows my error here: injuryMarker.X = (int)marker.x.Value; injuryMarker.Y = (int)marker.y.Value;
Yeah, I don't really find the first version "more readable". Less typing, yes, but finding the same variable declared multiple times definitely increases my "wtf/minute" rate. Did they do that on purpose? Did they just accidentally pick the same variable name for two things in the same function scope? The only way to tell is to read the rest of the code, and even then it could still be hard to tell. With the second, it's clear that `a` is meant to cover both cases, and I'm no longer surprised to see `console.log(a)` at the end of the code. (I always find function scoping violates the "principle of least astonishment", but maybe that's just my background in other languages)
Option C. var x = a ? 1 : b ? 0 : undefined; var y = a ? 2 : b &amp;&amp; c ? 2 : undefined; var z = a ? 3 : b &amp;&amp; c &amp;&amp; d ? 4 : undefined; 13 lines became 3, much easier to tell how values are determined, much easier to edit, lets you use `const` if appropriate, and makes apparent that the values may be `undefined`. And if `a`, `b`, `c`, or `d` are expensive to get, you can cache them in a single line per, and your code is still much shorter and more readable.
StandardJS is a really ridiculous style guide that I wouldn't ever really adhere to. The rules about semicolons are enough to toss it in the rubbish bin, as there's no compelling reason to leave out a code style feature that only serves to increase readability and decrease the likelihood of typo-tier bugs creeping into your code. That it doesn't enforce stuff like bracing every conditional statement, it allows assignments-in-conditionals without warnings... tons of reason to toss it out, grab eslint and a sane preset, and tweak it to your liking.
Without seeing the entire file for the javascript I can't say for sure, however any time I've run into this error it's almost always because somewhere in the file I have an extra opening '{' or '('. There's nothing syntactically wrong with the portion you sent so the problem is going to be in an outer scope.
To each his own, I suppose. I prefer to enforce readability by indenting properly, not by putting semicolons at the end, which i basically ignore. I agree with the fact that `if (options.quiet !== true) console.log('done')` is to be USUALLY avoided. However, I do use `if (err) return callback(err)` or even `if (something) return` quite often. EDIT: God dammit I always make some mistake in my code. EDIT 2: Wait, StandardJS doesn't allow assignments in conditionals, does it? I'm pretty sure it didn't.
It's there in case the file is merged with another and ends up directly after a statement some dumbass forgot to terminate. It's an instance of fixing the problem in the wrong place IMO - either have your concatenator stick a `;` between each file it joins, or don't end files in unterminated statements - but libraries love to fix out-of scope problems because it makes them "just work".
&gt; I prefer to enforce readability by indenting properly, not by putting semicolons at the end, which i basically ignore. I like my style guide to enforce operators ending lines, not starting them, so that scanning the end of lines for anything but operators is an easy way to spot typo-style errors. foo = 'bar' + 'baz' // i accidentally overwrote my + when I split this "long" string foo = 'bar' 'baz' vs foo = 'bar' 'baz'; Obviously both of these are still valid code, but the latter is more likely for me to spot the error because I'm not used to seeing a quote end a string - I should be looking for a semicolon, and when I don't see one (or a `+`, `?`, `:` etc.), I should investigate further. If I'm used to seeing strings end without semicolons or operators, that line looks natural to me and I don't notice there's an issue until I run the code, rather than before I finish writing it. &gt; EDIT 2: Wait, StandardJS doesn't allow assignments in conditionals, does it? I'm pretty sure it didn't. Yeah they just have to be wrapped with an extra pair of parens: &gt; Wrap conditional assignments with additional parentheses. This makes it clear that the expression is intentionally an assignment (=) rather than a typo for equality (===). http://standardjs.com/rules.html &gt;However, I do use if (err) return callback(err) or even if (something) return quite often. If I see an if statement, I want braces, full stop. It's far too easy to accidentally make something fall out of an if statement without noticing it. You can achieve the same thing on a single line (and I prefer the readability of this approach because of JSX) like `err &amp;&amp; throw err` rather than `if(err) throw err`.
num *= 2
I think it should be grounds for disciplinary action. 
Something like this https://github.com/tcoopman/image-webpack-loader
Sure, if you're used to seeing semicolons, no reason not to use them. I found them to be more of a burden than a help. I guess it depends on the programming background we come from, as I have basically started with JS. I got rid of semicolons in one project just to try it out and I haven't had a problem with any semicolon-missing-typos yet. I have never used the JSX approach outside of JSX. This appeals more to me than the if-one-liner, thanks for that one. About the assignments, well, it is weird, but hey, I don't think there is really chance you accidentally make an assignment and a double parenthesis at the same time.
 try { var result = thisMightFail(); } catch (error) { doSomethingElse(error); } console.log(result);
Words also have different meanings in different contexts. Normal human beings understands this, but if you try to argue like a robot and blindly follow the highest dictionary definition ... well you're going to have a much success communicating with other human beings as a robot does (a modern robot; I'm not talking sci-fi). If you're playing baseball it doesn't matter if "you're out" normally means "leave", even if that's the #1 dictionary definition, because *in the context of baseball* "you're out" just means you go back to the club house and your team has one less "out" left in the inning. Same thing with standard: there's the clear, obvious definition of the word in a programming (or indeed any technical) context, and there's a bunch other definitions. You can use those other definitions if you want, or make up your own definition for the word, but if you don't use the proper definition for a word given the context it's used in, you're not speaking English.
are there any legitimate or clever uses for 'let'? EDIT: I'm getting VAR4LYFE tattooed on my forehead.
BTW, I'm not the author. That's the actual title.
Sublime Text only cost $70 US unless you're buying multiple licenses for a business. It's inexpensive, robust and well-supported. Buy it. 
I switched to Visual Studio Code and was surprised to find that Microsoft built an awesome and useful product that I have little to nothing to complain about.
&gt; are there any legitimate or clever uses for 'let'? `let` is great for loops: for (let i = 0; i &lt; count; i++) ... for (let key in object) ... for (let member of collection) ... In almost all other cases I prefer `const`. Edit: /u/TheIncredibleWalrus pointed out below that you can use `const` in `for-in` and `for-of` loops.
Try fabricjs
Checklist of stuffs ... (1) demonstrate all the basic loops (2) write a fizz buzz (3) add and remove items from an array (4) pass a variable from one function to another, get a modified version of it back (5) make an ajax call to another function, not in the same file, receiving a single data item as a return (6) In a function, write a very simple Json object, and in the next line read one of it's values. (7) make an ajax call to another function not in the same file, where you receive a JSON string. Display one of the values on web page. (8) Pass a parameter to another function, not in the same file, that limits what is going to return, and return it to the original function as a JSON. (9) Using Javascript, make an element on a web page dissappear. (10) Using Javascript, make an element on a web page appear. I'd say you can do that in less than two months pretty easy, and that will cut your teeth on the basics. Watch a ton of javascript videos on you tube. Start with simple things like the stuff I mentioned already. Then move onto videos about AJAX, the Event Loop, Type Coercion ... watch more videos by people like Doug Crockford. Hook up with local professionals. A year will make you very good, if you have a good regimin and you stick to your goals.
&lt;script&gt; for (var num = 100; num &lt;= 800; num=num * 2) { document.write(num + ' &lt;br&gt;'); } &lt;/script&gt;
What do you think about [OpenLayers 3](http://openlayers.org/)?
OK let me explain the basics here in a few minutes. Maps consist out of tiles, which are images of 256 by 256 pixels each. At zoom level 0, the whole world is one tile (well actually it's only a half tile, but the equator is still in the middle). At each increment of the zoom level, the resolution doubles, so each tile is split up into 4 tiles. These tiles have been drawn by a computer program from geographic data (commonly that is OpenSteetMap data), and these tiles are accessible via the web, on a "tile server". Choosing a different tile server results in a different style of map. See [tile servers](http://wiki.openstreetmap.org/wiki/Tile_servers) for examples. Using Leaflet, you *have* to choose a tile server, or you won't see any map. Basically, this implies passing a template string for a tile URL, as a parameter to Leaflet. BTW The standard tile server for OpenStreetMap is Mapnik, although personally, I like the OpenMapSurfer.roads style, from the [Heidelberg University in Germany](http://korona.geog.uni-heidelberg.de/) much better. These tiles *are* compatible with Google Maps, although I doubt that Google would be too happy if you'd use their map tiles just like that. 
But there's more to maps than just the tiles. And interfacing with OpenStreetMap and Nominatim is a snap: geocode the name of a cirty, and you can get its contours in GeoJSON format (if you pass the right parameter), and you can then show that contour on the map in Leaflet *in a single line of code*. You cannot do that with Google Maps's data. I even doubt if Google would be too happy if you even tried it.
There's a `worldCopyJump` Map option that makes the overlays "jump" to respective copies of the world when you pan, but it's not a perfect experience. Implementing fully seamless multi-world overlays is a hard challenge, and a one likely to affect performance in a major way â€” we didn't attempt to tackle it fully yet.
To augment your correct explanation with a frequently-encountered real world example, this throws an error: (function() { })() (function() { })(); This does not: (function() { })() ;(function() { })(); You see this a lot when two IIFE-enclosed scripts are concatenated and the author of the first script failed to include a trailing semicolon.
Why not `window.myvar = 12`?
Are you sure you mean protected? I'm pretty sure this would not work using JavaScript inheritance. Protected variables are typically defined as being "Private variables that are visible only to the Class and it's subclasses". It seems like you've created a sort of map structure that stores variables based on their "this" value. If you want variables that aren't visible to outside objects but exist in current object, you can define your class like so: function SomeClass(addon){ var myPrivate = "I'm private"; if(addon!==undefined){ myPrivate = myPrivate.concat(addon); } this.getMyPrivate = function(){ return myPrivate; } } var someClass1 = new SomeClass(); var someClass2 = new SomeClass(' too'); console.log(someClass1.getMyPrivate()); // I'm private console.log(someClass2.getMyPrivate()); // I'm private too console.log(someClass1.myPrivate); // undefined console.log(someClass2.myPrivate); // undefined This works because a var declaration of a class get scoped to the level of any new objects. Traditional OOP class inheritance falls apart in vanilla JavaScript. If you want complex inheritance to be enforced I suggest checking out TypeScript.
&gt; Why not `window.myvar = 12`? That would certainly be more practical, but it's also 3 characters longer than the `var` method. window.myvar=12 // 15 chars var myvar=12 // 12 chars In non-strict mode, you could omit var and save 4 more characters. myvar=12 // 8 chars
You have my sympathies.
&gt; Using var is ~10x faster currently across the board So stick with `var` if you're developing a [cache attack](https://arxiv.org/pdf/1502.07373.pdf) (PDF)?
Ehh, honestly if you're doing something like this, it should probably be rethought anyway. Personally I wouldn't say this is a valid or safe use of `var`.
Are you completely retarded, you STUPID piece of shit? [**WEBASSEMBLY!!!**](https://webassembly.github.io/) 
&gt; anytime soon Not a native speaker, but AFAIK "going to" refers to the future in English? So you just shifted the frame from your original comment that I replied to? 
True. That was the primary reason AFAIK. A secondary one, at the time, was that the scope and number of features added was gigantic. I think ES4 might have made it had we had the same tools we do today (babel, for example). You might have to do something weird like "strict mode" to signal to the JS engine that we are doing new stuff now to keep the old stuff afloat.
That has the advantage of working inside a function scope, to declare a global variable; it has the disadvantage of making a deletable variable (but that can be overcome with `Object.defineProperty(window, 'myvar', {value: 12});`).
no
This was my initial code, but it's obviously wrong: if (EmployeeSales =&lt; 1000) { EmployeeBonus = 0;} else if (EmployeeSales =&gt;1001 &amp; =&lt;10000) { EmployeeBonus = 100;} else if (EmployeeSales =&gt;10001) { EmployeeBonus= 1000;}
The problem you're seeing isn't about ternaries, it's about complexity on one line. Once a line exceeds a certain complexity you should split it up, no matter where the complexity comes from - an arrow function with two statements, a ternary with three conditions, a function call with 6 arguments, an object with 5 properties, it doesn't matter. At the point a ternary is too complex for one line you can - and I often do - write it like this: var foo = ( firstCondition ? 10 : secondCondition ? 20 : thirdCondition ? 30 : 40 ); Show me another way to write that that's every nearly as terse or readable.
&gt; "Performance" and "transpile" are incompatible, unless you only care about performance in recent browsers. Have you seen how Babel implements block scoping? This ES6 JavaScript let myVar; { let myVar; } transpiles to var myVar; var _myVar; How is the latter less performant? I realize transpilation isn't always so simple and clean, but it's usually not done on the fly, and things like `const` can be statically checked. And if we're talking about older browsers, `let`, `const`, and other ES6 features are non-starters.
I hate that it's starting to look like Haskell because it has none of the properties of Haskell that make all of this stuff useful.
This is what Staging is for! Dev for debugging, Staging for matching Prod as close as possible, Prod for... well, users!
I was flabbergasted a first when coming from a Java background. [This book](http://eloquentjavascript.net) and practice helped me sort things out. 
 let foo = 40 if (thirdCondition) foo = 30 if (secondCondition) foo = 20 if (firstCondition) foo = 10 Or, if the performance of checking insufficient conditions is too great: let foo if (firstCondition) foo = 10 else if (secondCondition) foo = 20 else if (thirdCondition) foo = 30 else foo = 40 This is assuming the conditions aren't mutually exclusive. If they were, the ternary would be an especially bad idea, since the 'else' branch isn't required. I don't think your version is ugly, it's simply a question of risk, especially in a language that encourages ugly one liners. Terseness is great, which is why we should all be writing in Elm or Purescript and using guards. E: formatting.
Coming from a Java, C#, C++ background the best way to learn JavaScript is to avoid inheritance and `this`. You are going to really **REALLY** want to write code in this language similar to how you would write code in the languages you are more familiar with, so you have to break away from this. It also doesn't help that the syntax looks nearly identical. By avoiding inheritance you are effectively forcing yourself to write in JavaScript differently than you would in your more familiar languages. The goal is to learn to embrace the spirit of the language even if you disagree with it. After you have gotten comfortable with the language then you can choose to write in a more OOP style.
Here are the two primary ways I conditionally declare a reference: * ternary - `var a (myCondition === true) ? "primary" : "secondary";` * IIFE - `var a = (function () {return "asdf";}()); //typeof a === "string"`
Uhh, you can use const in non imperative loops. Edit: not sure why I'm being downvoted, you can check it out yourselves: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of
Holy crap, really?! Gonna try this out when I get home. Edit: I wrote some tests this evening and you're right. Thanks for the info. I'm guessing the downvotes were because you did not originally specify "non imperative" loops. `for (const i = 0; i &lt; count; i++) ...` is definitely an error.
I've heard of Webflow, and I think we actually have a site hosted on it right now...However, for this project, I'm not looking for a hosted resource. I need a library or package that I can build on top of/extend to build out some internal tools.
great two ways to do everything
looks like perl
Adding to this, here's a useful strategy for making your braces match. If your IDE has auto-indent (most do), go to the end of the file, erase the last `}`, then retype it. This will quickly give you an idea of what's going on.
That's a pretty nice game you've made. I wish I had done the js13k but I forgot about it until it was too late. How long did it take you to make your game?
&gt; The issue is with "compound let assignments". (using +=) Interesting. I wasn't aware of that. Maybe I'll consider using let after all.
&gt; You could also have it only send changes that occur within view of the player and the surrounding areas. I was thinking of doing that. I am. It's less intensive. I am thinking about passing the data back from server to client. Only problem is... 13x13... that's 169 arrays every key-stroke... that's a lot for the server to handle... no? Even in the localhost... it's like 2-3 seconds...
This seems like an overly complicated solution to a not so complicated problem. This can be solved with a simple function that recursively calls itself to return a promise for the next in the list and then the final iteration resolves the chain. Why the need for $q? Why not use a Promise polyfill?
I mean no disrespect but this seems like a rather long article for something pretty straightforward. I've provided this as a stack overflow answer a couple times. 
[Just whip up a regex.](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454) /s
Oh, god. What is seen cannot be unseen.
Another couple options. These have the benefit of never leaving the variable undefined. We give it a meaningful value in the same statement that we declare it. let a = something === true ? true : false Or if the conditional expression becomes too complex... let a = (function() { if (something === true) { return true } else { return false } }())
Looks a bit like what we did on [Jumpsuit](https://github.com/jumpsuit/jumpsuit). Looks cool, definitely nothing wrong with trying to create something better than what's out there! Even if there are already a million variations--that's what innovation is all about. Keep at it!
Even just adding to it? Thats werid. Babel looks interesting
&gt; No pointers JavaScript doesn't use `*` so it isn't as obvious, but basically every variable of an object is a pointer. // "o1" is effectively a pointer to a heap object var o1 = {n: 42} // "o2" is effectively a pointer to the same object var o2 = o1 // Since they point to the same object, a change through one variable // can be seen through the other variable o2.n = 7 o1.n // 7 &gt; No explicit namespaces More or less true, but [that's changing](http://www.2ality.com/2014/09/es6-modules-final.html). &gt; Specifically inheritance seems really weak in js. It got better in just the last year. class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + ' makes a noise.'); } } class Dog extends Animal { speak() { console.log(this.name + ' barks.'); } } The under-the-hood implementation may be different, but you can still use them largely the same. Just be careful not to overuse inheritance. Remember to prefer composition. &gt; Array.prototype.binIndexOf = ... Admittedly it's tempting, but you shouldn't do this. As you seem to have noticed, unlike C++, JavaScript's classes can be modified on the fly. This was once though to be an advantage, and once upon a time we JavaScripters used this extensively, but it turned out to be a long term maintenance hazard. We are, after all, messing around in someone else's scope/namespace. EDIT: Make sure you run your code through a linter. http://eslint.org/
Yeah I agree, sorry for the confusion. I thought you meant ES &gt;= 6 since you mentioned ES6's name deprecation in the next sentence. If ES7 is supposed to be called ES2016, it's unfortunate companies like Facebook have already started calling it ES7 (look at the FB link I shared above). 
&gt; That feeling when you haven't heard of a transpiler
Picked it up in the humble bundle starch press book bundle. Skimmed through it a bunch. Really need to home in on the objects chapter
 employeeSales &gt; 1000 ? (employeeBonus = employeeSales &lt;= 10000 ? 100 : 1000) : (0); [http://jsbin.com/vanemi/edit?js,console](http://jsbin.com/vanemi/edit?js,console)
It would be silly, would'nt it ?, to attempt any form of web development without having MDN right there in our top bookmarks.
Just wanted to thank you for Leaflet. I've used it on a lot of projects, mostly open data stuff, and I always encourage other developers to use it with OpenStreetMap instead of Google's maps API. I'll definitely check out this version and update my projects to 1.0! Thanks!
Thanks! It took me the entire month for which the competition runs, plus a week beforehand to set up as much of my boilerplate as possible.
there's been a few posts the last few days about it. \#2 on /r/node right now: https://www.reddit.com/r/node/comments/54rueh/using_let_significantly_slower_vs_var_v8_disables/ It's not quite as bad as it sounds... slower, sure - but it may just be the code under test, and overall micro-optimization.
Great work man!
This is true. Ideally you want to go production from the build of dev.
if you're using prototypes then you can put stub methods on the parent object that simply throw some kind of 'method not implemented' exception
I guess this depends on your prior experience and what stage you're at with learning JavaScript. However, here are some that I've found valuable: - Marijn Haverbeke's Eloquent JavaScript: A Modern Introduction to Programming (available online for free: http://eloquentjavascript.net) - Kyle Simpson's You Don't Know JavaScript series of books (also available online for free: https://github.com/getify/You-Dont-Know-JS) - Douglas Crockford's JavaScript: The Good Parts
Better browser support, battle tested behaviour correctness and JIT performance optimizations due to it being in production for years. If you use a linter(and you should), it warns about potencial scoping errors. Just write next loop using j instead of i for iterator.
Also using let in a loop initialises a new variable for each iteration. So this works, for (let i = 0; i &lt; 5; i += 1) { setTimeout(() =&gt; console.log(i), 100); } // 0, 1, 2, 3, 4 (all 5 if using var)
Not an ES6 book, but if you have any prior experience of programming I highly, highly recommend *Javascript for Web Developers* by Nicholas C. Zakas. Even if you don't have any experience in another programming language it's an astonishingly detailed and expansive book. 
If you really want to reduce line count... let a = something ? true : false; We all love ternary ops, right? 
You should check out DevTips channel, he's got some amazing series, one of them being the progress of making he's own website. You should check him out! Here is the link to the project: https://www.youtube.com/playlist?list=PLqGj3iMvMa4KeBN2krBtcO3U90_7SOl-A
Yes, for 3 years already. It's my dream job.
Thank you!
This is a list of JavaScript books that are free to read online: http://jsbooks.revolunet.com/
Years ago a friend of mine recommended this new mapping library that she thought had promise. Since then I use it in every mapping application I develop. Congratulations on 1.0.
First example redeclares "a". Crap like that shouldn't get past your linter.
Even its implementation is cumbersome: running `npm shrinkwrap` multiple times can generate different `npm-shrinkwrap.json` file for me.
You Don't Know JS series are awesome.
Avoid declaring anything in the global space. An extremely large application should have no more than 3 global references. I got my personal project down to a single global reference named `global`. You are going to have to learn the scope rules of the language. * var is function scope * const/let are block scope The hard part will be learning to understand the scope rules in such a way as to expose references in a usable way **without inheritance**. That means you are going to have to learn things like nested scopes and closure. You can namespace your references by declaring them as object properties. This is an easy but very shallow form of organization and has immediate limitations. It is how the jQuery library is organized which makes the code easy to read.
 do { var foo = bar(); } while(!foo); console.log(foo);
https://msdn.microsoft.com/en-us/library/dn584397 You can compile c# to native machine code. You can't compile c# to WEBASSEMBLY. Calm down kid. Maybe one day your fantasy will come true, but it's going to be quite some time until -- and even then it's an if -- you'll be able to replace js with c# for browser. Have you even seen what WEBASSEMBLY code looks like? 
&gt; You can't compile c# to WEBASSEMBLY. AT THIS POINT - and you FUCKING ASSHOLE **WERE TALKING ABOUT THE FUTURE** you STUPID stinking pile of shit.
Are you completely retarded, you STUPID piece of shit? [**WEBASSEMBLY!!!**](https://webassembly.github.io/) 
&gt;Google maps data is usable for free up to a certain number of requests/day, after which you have to pay, which is pretty common. There more to it than just that. &gt;&gt; **[I want to use Google Maps API tiles with Leaflet, can I do that?](https://github.com/Leaflet/Leaflet/blob/master/FAQ.md#i-want-to-use-google-maps-api-tiles-with-leaflet-can-i-do-that)** &gt;&gt; The problem with Google is that its Terms of Use forbid any means of tile access other than through the Google Maps API. &gt;&gt; You can add the Google Maps API as a Leaflet layer with a plugin. But note that the map experience will not be perfect, because Leaflet will just act as a proxy to the Google Maps JS engine, so you won't get all the performance and usability benefits of using Leaflet when the Google layer is on. What's more: just using Google Maps in a web page is no longer "free", at least, not for a widely used website. You can't even use its geocoder or autocomplete without a Google Maps map or a Google Maps marked textbox. And, though Leaflet is not restricted to OSM, but by Jove it surely is the easiest to use with OSM.
/r/LearnJavascript
 I don't know why this is getting down votes, a most elegant solution sir.
settimeout getelementbyid innerhtml recursive function (so that you can use settimetout instead of setinterval -- why? look it up) At this point you'd still have to figure out how to add diff text each time.
good advice reddit. will do also. thanks
I'm assuming because it's a sub-domain of Spotify that they use their own client id, or something similar.
Yup. The var gets hoisted to the function, so any async function that gets it will get it after the for loop has iterated.
It looks like it does not use the standard API as it has its own API. https://yearinmusic.spotify.com/api/app/year-in-music/en-US/worlds-top-artists/global/maroon-5/ this would return a stream url which contains the 30 second preview.
Good parts is way too technical of a deep dive for a beginner. As a seasoned pro it may seem like a good beginner book, but if you have ever taught front end dev then I would suggest it's not the first is book to pickup. 
Which tells me that, like all redditors who recommend it to noobs, you never read the book.
Honestly I prefer the Internet. Either just reading documentation or doing a getting started tutorial then using Google from there. 
What are you going to do with the data, if it's saved locally? So far, what you've described sounds like a Google form.
Well. I learn best by playing with broken things and reading the docs. I later Google all the parts I don't understand. To that end I prefer learning new languages through exercism.io exercises. This method is hardly for everyone, it's just easier for me to grok something new by doing instead of reading. You must absolutely be willing to google everything you don't understand though, or you end up with serious holes in your knowledge.
To a seasoned programmer who is new to JavaScript The Good Parts is a good first read. To someone new to programming in general it is too technical for most.
Same code without the inner function: for (let i = 0; i &lt; 5; i += 1) { setTimeout(console.log, 100, i) } Just sayin! :)
the WeakMap is best for garbage collection but doesn't really change the overall ability to reference the values outside of the classes using _(tom).variable for example. I do like John Resig's [Simple JavaScript Inheritance](http://ejohn.org/blog/simple-javascript-inheritance) Library. But It still has no concept of protected variables (variables that are directly available from within the class and its subclasses but not for instances). I looked up WeakMaps and It is definitely the way to go for garbage collection. I dont mind that the values can be accessed like _(tom).variable, The point is not to make it impossible to access protected variables but more to remove them from direct access within the object. I am using the technique for within my own projects and I will know that if I can't access the variable like tom.variable that will be good enough I will know that _() is reserved for within the class and its subclasses. I hope this makes sense. also upon testing further i do have to use a private key and cant use this as the key. So the _ function looks a bit different but is executed the same way _(this).variable..
I really like using template literals: var url = `${rootpath}/${path}/${to}/${target}` this is assuming rootpath, path, to, and target are all variables or expressions of some kind. whats nice about template literals is you can use any actual strings combined with arbitrary expressions encapsulated in ${}, and you dont have to worry about escaping quotes and other common pain points like that, it beats the hell out of manual string concatenation imo 
I feel like it should be considered correct for a click event to only be able to occur on an element that is actually on the dom, but that is just a personal opinion, and I suspect different browser manufacturers have differing opinions and always will, unless further detail is provided eventually in the spec
If Acrobat meets your need, I would use it. $100 for Acrobat is cheap given that I value my time at $100-150 per hour. Creating a custom application would probably take a few hours. In answer to your original question, no, JavaScript is not a good language for this project. Browser-based JavaScript cannot write files to disk. 
https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#javascript
"edge is actually on a path to being a great browser" Is wishful thinking but utterly clueless imho. Ignoring security whole and microsoft sticking their hands into your browsing data, edge is closed sourced and proprietary. Microsoft has no community input for the js VM code, they can have it be compatible with the standards for a few years and then drop support for the next dozen when they re-gain market share... and none will be able to maintain a "proper" version of Edge. If newer standards are harder to implement they might not spend the money to implement them... etc Same goes for Safari, its hard to believe that a piece of software based on a closed-sourced mentality can live on merit in the world of yearly standards updates.
It really sounds like you want localStorage. localStorage is saved directly to the browser, similar to a cookie. It can get deleted if the user clears their browser cache, but a text document can be deleted as well. You could always add a simple PHP REST endpoint to send the data to and have it emailed to the user.
It's also pretty outdated and some of its advice is debatable at best.
I don't think they'll go away anytime soon. Like others have said users of these browsers normally have no choice because of the company they work. These companies are normally big corporates or governments. I think if you're a web developer, embrace the crappy browsers, if you become an expect in dealing with their problems you can make yourself a pretty penny! 
SOLVED. /u/mrspeaker tip pointed me exactly what was causing it. Thank you.
https://www.watchandcode.com It's not a book, but it was birthed from the frustrations of the books being mentioned. Most importantly, Eloquent JavaScript. 
Similar vanilla solution to /u/rnd005 with some es6 &amp; promise stuff thrown in (and using babel transpile) to simulate getting the words from a server/data-store. http://codepen.io/chrisux/pen/KgqQAR?editors=1010
You can also generate sourcemaps with the node modules, I think. How do you build your app?
Eloquent javascript is *hard* and really not something i would recommend to an absolute beginner.
That's what I thought. localStorage won't work for me then. A text document could be stored in a folder with the file and would be a lot harder to accidentally delete than browser cache. That can be deleted as easy as running CCleaner or some other similar tool, and sometimes that stuff is done on startup or scheduled and the user may not even know it happened. Still, thanks for your help. Now I know it's there if I ever need it for something. Emailing won't work as it complicates the process too much. I will have to figure out some other way.
console.log ? But, why would you ... well, you sure have your reasons.
But why? Why not use [text-overflow: clip ellipsis;](https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow)?
Love vanilla; chocolate is good too.
I wonder if you're tripping up Firefox's popup-blocking heuristics? Most browsers require explicit user interaction to allow popups, and maybe it thinks you're trying to do that. 
I disagree. Why do you think it's too technical? I have brought several new, young engineers up to speed via the book successfully. The book has been invaluable over the years. 
The css community calls it [line clamping](https://css-tricks.com/line-clampin/).
Childs?
I got a voltage sensor, I want to get that value in real time to display something In a web page, I mean If the voltage is under 54 display X in the web page, but if it is above 54 display x in the web page 
&gt; young engineers So they already had some programming experience? Don't get me wrong. It's a great book.
Little practical experience. Literally talking about fresh college grads and interns. 
nice!
Thanks! Free obline: http://speakingjs.com/es5/
Why? Also, very interesting. Is this everyone? I know a lot of models worry about their location being found. Do they know this kind of thing is possible? Or is this just models with some kind of location info turned on?
So...many...dicks....
This is built with react and doesn't use list.js, but sounds similar to what you're looking for: https://github.com/JedWatson/react-select
A project worth less than 100 bucks? Surely any project with basically any time saving application is worth more than 100 bucks. I'm pretty sure we spend more on cake... Daily 
Hmm, looks promising. I will check it out. Thanks!
Actually `let` and `const` weren't (correctly) supported across all major browsers until two weeks ago with the release of Safari 10.
If you require URL templates, then there are URL-template packages &amp; libraries out there. I've used RSSI before, but not a huge fan. It does the trick, but its a bit leveraging as opposed to designed-for. So perhaps (after a brief search) https://github.com/bramstein/url-template or https://github.com/geraintluff/uri-templates both template URL/URIs according to [RFC 6570](https://tools.ietf.org/html/rfc6570) Both would (or perhaps should...) allow something like the following let uri = new URIParser('http://www.example.com/{user}/profile/{action}'); uri.parse({ user: 'test-user', action: 'edit' }); // http://www.example.com/test-user/profile/edit //or let uri = new URIParser( 'http://www.example.com{/forum:forum_id}{/thread:thread_id}{/comment:comment_id}{?action}' ); uri.parse({ forum_id: 1 }); //http://www.example.com/forum/1 uri.parse({ forum_id: 1, thread_id: 14 }); //http://www.example.com/forum/1/thread/14 uri.parse({ forum_id: 1, thread_id: 14, comment_id: 12 }); //http://www.example.com/forum/1/thread/14/comment/12 uri.parse({ forum_id: 1, thread_id: 14, comment_id: 12, action: 'edit' }); //http://www.example.com/forum/1/thread/14/comment/12?action=edit 
Only if the model added location. As the location given is not GPS coordinates but a string, there is a process were the approximate location in randomized into a point in space.
I highly doubt Chromium (which is really what you should be using, unless you have a reason for using Canary) is worse of than Safari or Edge in terms of resource consumption on a neutral OS (e.g. any Linux or BSD distro). On Windows or iOS Edge and Safari can be optimized, but one should also consider they are considerably less safe. I'm not against competition either, but I'm against having essential pieces of software be closed source. If you think its a remotely good idea look at Windows and how it has single handedly forced developers to adopt the online-applications instead of native-applications trend. Closed source will simply never be able to be as secure (not open to public audit and general around-fuckery by the white hat hackers ) nor as advanced in technology. The argument with Safari 10 being 100% ecma script 6 compliant is purely well timed bollocks. Chrome and Firefox have been close to 100% ecma script compliant for over a year, the parts of ES6 they don't support are a handful of trivial prototypes on std objects(and probably not supported because implementing them would break something or because they are waiting for "X" to be implemented in order to implement "Y" using "X"). Just to be clear, the feature that V8 is "lacking" are as follow: return this for RegExp.prototype.compile(); which has been DROPED from the web standard, so I believe the website is mistaken in making it part of the current ES6 standard and should be update Array.prototype.Values, which i assume they aren't implementing because either a) they don't want to introduce the 1001th for loop in .js and haven't thought of a way to make it any more efficient than already existing implementations, b) they forgot, c) they are working on making it efficient enough to be worth it and are not done with it yet. I agree this one should be in but its hardly a fucking deal breaker (Like, say, Safari 9 not supproting promises, let, functions which attach "this" to the scope of the function they are part of and a sum of other fucking essential features for 21th century coding, not 21st century as in "I want to iterate trough arrays in this prcisse way", 21 century as in "I want methods that have direct access to the scope of the object", "I want variables that are only visible inside the scope they were created in" , "I want to have constants"... etc) Symbol.toStringTag affects existing built-ins .... which I honestly don't know what the hell is supposed to do. But the only purpose of Symbol.toStringTag is that of being used by Object.prototype.toString() so the fact that a specific little thing about a method that's not even directly used by the user is missing... well, that's not really that important. I've even tried looking through the specs and around the internet to try and figure out what the fuck this one mean, I haven't been able to, if anyone can explain it to me, props to them. Also, it seems to be there in older versions of V8, so presumably there was a bug with it or somehow they decided the engine is better of without it and droped the feature. Tail call optimization -&gt; Obviously the big one. I understand why people like recursion and I want us to have efficient recursion even if I presonaly don't use it that much. Now, there are 2 things to be mentioned here: -&gt; V8 doesn't GUARANTEE tail call optimization (in the same way most C/C++ compilers don't), e.g. it might very well apply something that is very similar or indeed use tail call optimization in 99% of the cases. It might not, none's guaranting it. But I assume that in many situation there is an underlying mechanism that provides a non memory-hoging enviornment for recurssive functions to run. -&gt; You can actually enable tail call optimization in V8, and its one of the features that (arguably) can be transpiled without any loss of speed. -&gt; It will probably come with the user version of chrome in a few months (I guess it depends on how lazy their QA is) So, while this puts Chromium behind Safari, it rally is behind just by a very small stretch and it doesn't forgive Safari's stone-age implementation up until very recently and the fact that most users will likely stick to 9 for months if not years to come. But "Programming defensively is how web dev is going to be, probably forever. That's the nature of the internet." Yes, you're right, I just had to fix a very un-obvious issue with webpack and I was angry thinking about how nativly supported export/import features are coming to browsers about the same time that humans are supposed to reach Mars, so I wrote the original post.
[Here](https://github.com/javascript-society/javascript-path) we have a list of great JS books.
see answer I wrote to /u/dwighthouse 
As far as globals go. Having a global per script is fine for my application. It's a chrome extension. Everything is sandbox, I have to explicitly use chrome's api to grab variables from any of the other scripts, including globals
you can just use window.open to open/ redirect the user to the pdf http://www.w3schools.com/jsref/met_win_open.asp
$q is baked into the angular framework, so that's why I use it in this scenario. I haven't tried to work out the recursive part, I'll give that a think. I think in the end, it's a pretty simple solution - use reduce :). Most of the article is context and not really related to the core thing, which is just the reduce function. 
That part about this that interests me the most is that you've mentioned python and rails as vehicles to compile JavaScript code. I would think that the advantages of compiling a language with the language itself extend beyond having just one type of code in your repo, not having to switch contexts to work on your build, and not having to force yourself to understand two languages to build your code. I can't say that I've seen a python build tool (or linter, etc, because you're not necessarily pre-building python...) that is built in anything other than python.
It'd be better if you simply use the `+` operator. The `''.concat()` would waste computation since it creates an empty string just to access the `concat()` method.
The title says he wants books "for learning Javascript". 
You said they were all transitioning to Javascript which implies they dumped Java and now do everything in that. That is what would not make sense.
Next time I'll be more specific so you don't jump to conclusions. 
Absolutely
Hi there! Awesome work. I have a question about performance: what would limit performance? IÂ´m thinking on showing millions or billions of elements on the same map and be able to filter classes of markers, for example. Another question is about interfaces: IÂ´m using folium to be able to use Python on the entire stack, but itÂ´s not feature complete with 1.0. Any thoughts on how to do this interfacing? Cheers!
Alrighty. Well a text document is pretty silly. If you're going to do that, you might as well just have a database. There's probably something pretty easy you could do with WordPress and the plugins Contact Form 7 and Members. Or a Rails scaffold. Or adjust the PHP REST endpoint to save it to a db instead. But yeah not really a way to do exactly what you want with just the front-end. Does this have to be web based even? Wouldn't be difficult to do this as a Java program and actually save it to a text file.
I'll try to do better in the future. :P
I thought, it is obvious.
I don't know if I'd bother to put it in the DidMount callback (I'd just define your audio in the constructor initially with this setup). That being said, you're defining audio in another scope, you could always do this.audio = and then call this.audio the same way you have in your playSong function. React has a ton of ways to manage state and data in general, the general rule to follow is the higher you store state the better and looking into immutable/redux is always a good way to go too.
raw.js did the job perfectly for me. https://www.reddit.com/r/rawjs/wiki/documentation
I could tell it was based on the basic example, but that has only a search box- no dropdown. In fact no example on list.js has a dropdown. so this is the variant I needed to see. thanks again.
I mentioned python mainly because it has really good functions for manipulating strings really easily. At my company we send newsletters that are built using my python script because python makes it really easy to parse the HTML.
&gt; I love and use Standard. Which isn't a standard. &gt; The Airbnb guide is also a popular one. [Airbnb's](https://github.com/airbnb/javascript) is the far more popular one. It's also much closer to being a standard. feross/standard is for hipsters. Suggesting it to anyone is bad advice. It's far more likely that they will be involved in projects which use a style guide which is more aligned with Airbnb's.
To clarify, lets say for some reason I wanted to watch the credits of every Simpson episode. First I would find the credits and drop the URLs+location/length of the credit scene, allowing me to type URLofEpisode1(time start = x, clip ends at x), URLofEpisode2(clip coordinates, etc. And from this, it would just play those clips back to back.
The API lets you specify an end time: https://developers.google.com/youtube/player_parameters#IFrame_Player_API
You're welcome.
Would be nice if they touched on using Selector functions instead of manually traversing the application state object inside the connector function.
I never said it was a standard... Just that it is standard (a name, like ember isn't an ember). Either way, I'm not here to argue names. I recommended using a style guide, I gave the one I use and love with some alternatives, and you decided to use that chance to insult and argue about a name... This is why I hate helping in this subreddit.
IMHO if you're trying to use private variables in Javascript, you're doing it wrong. Consider: function Foo() { let privateVar = 'foo'; this.doSomething = function() { doSomethingWith(privateVar); }); } new Foo().doSomething(); vs. function Foo() { this._privateVar = 'foo'; this.doSomething = function() { doSomethingWith(this._privateVar); }); } new Foo().doSomething(); Now, consider what you get for using the first form: your privateVar is truly private. Then, consider what you lose ... * if you're debugging a problem you can't view the variable in your dev tools * if you want to assert something about the private variable in a test, you can't * if you want to make the variable public it takes work (vs. if you have a decent IDE you can rename _privateVar =&gt; publicVar in about 10 seconds) In other words, the fact that Javascript doesn't have private variables is a feature, not a bug. Rather than fight the language to try and get private variables, you'll be better served by thinking like a JS programmer (and not a C/Java/whatever language you used to use that had private vars) and using the language as it was designed. 
I usually don't but ellipsis for multi line text is one place where I pushed back on the design team. They were cool with it when they understood the impact on performance. We used an alternative solution of using a gradient to fade out the text on the last line with CSS and the performance remained buttery smooth. 
If your project is small enough that a transpiler isn't worth the complexity it adds to a build chain, here's a revalation: It's not going to matter if you use var, or `{ const, let }`.
True. For learning, there is no need to concern yourself about compatibility. If it works locally, and you can learn, that is the end-game. And learning ES6 from the get-go is probably the best idea. Besides, the code can be made compatible, by learning about build &amp; transpiling tools - which are required when packaging up &amp; minifying a large project anyway!
Not necessarily. They abstract away the internal structure of the store so simple selectors like 'state.currentUser.user.username' are fine! 
What's obvious to you or me is not necessarily obvious to others. In fact if it were, there would be no basis to this post! 
&gt;alert(EmployeeName + " your salary this month is" + " $" + (EmployeeSales \* 0.1) + Bonus); Okay, what's probably happening here is the operations are being evaluated from left to right. So it concatenates " your salary this month is" onto EmployeeName, and then " $" onto that string, and then EmployeeSales\*0.1 onto that string, and then (having another string, like "John your salary this month is $1500") concatenates Bonus onto it. Which is not what you want, you want Bonus *arithmetically added* to the calculated salary. You can tell the interpreter to do that by adding extra brackets, like this: &gt;alert(EmployeeName + " your salary this month is" + " $" + ((EmployeeSales \* 0.1) + Bonus)); Now the addition will be performed before the result is concatenated with the rest of the string. However, that still leaves the problem of why Bonus is undefined instead of 0, 100 or 1000. My immediate assumption is that this is because Bonus wasn't initialized (you declared it at the top but didn't give it any value) and then was never assigned a value later. That's what would happen if *none* of your if statements activated. Now, when your if statements run, EmployeeSales also hasn't been assigned any value, so it's undefined too. I did a bit of testing in Firebug and it seems that if you use a &lt; or &gt; comparison to compare undefined to *any* number, the result is false. So none of your if statements will activate, and Bonus will be left without a value. Looking at the way you've arranged your code, it seems you're making a common beginner mistake which is to assume that the algebraic-looking equations you write in a language like Javascript are *actual algebraic equations* that *specify* a *persistent* relationship between different values. This is *completely not the case.* Each instruction, whether it's an assignment with = or anything else, only runs *when the program execution reaches it,* whereupon it updates the program data in the specified way and then leaves that data to be (potentially) further modified by other instructions. You cannot write a bunch of if statements and equations at the top of your program and *then* go and fetch the values you want to plug into those equations. The computer can only work with values it already has.
Another problem is this line: ``` EmployeeSales = prompt("Please enter your monthly sales"); ``` Because the input to prompt is interpreted as a string, it needs to be wrapped in `parseInt` to convert it to an integer. 
This is off topic, but have you considered using something like Beautiful Soup to parse your HTML as opposed to parsing HTML strings?
It would appear like this: EmployeeSales = parseInt( prompt("etc"))
What you'll need to do is make sure your alert is inside the loop. In pseudo code it would look something like this ForLoop{ Prompt for name Prompt for Sales IfBlock to set Bonus Alert } Make sure you structure it so the alert isn't happening after the loop has ended, but instead occurs at the end of each go through the loop.
Thank you! @ZamieltheHunter. Is there a way to keep a running total of the 5 sales entries? So at the end I can write document.write(TotalSales) or something
Absolutely! You'll need to declare a variable and initialize it to 0. So add: Var TotalSales = 0 With your other declarations. Then in your loop you should add after you prompt for sales. TotalSales += EmployeeSales This line will add the current value of EmployeeSales to the running total stored in TotalSales. It's equivalent to "set TotalSales equal to TotalSales current value plus EmployeeSales" Then outside of the loop write an alert that will say something like alert("Total Sales are: " + Total Sales)
I wrote a library that makes using speech recognition super easy named HumanInput: https://github.com/liftoff/HumanInput/ Here's an example of how to use it: HI.on('speech"This is a test"', (event, transcript) =&gt; { HI.log.info('Speech recognition!')}); Basically you just provide the string you want to match and the function you want to call when it matches. This enables you to add support for voice commands to any web page. The library does *loads* of other things too... like keyboard shortcuts, gamepad control, and clap detection!
First things first. Are you using [JAVA](https://en.wikipedia.org/wiki/Java_%28programming_language%29) or [JAVASCRIPT](https://en.wikipedia.org/wiki/JavaScript)? If Java, you'll need to head over to: * https://www.reddit.com/r/java * https://www.reddit.com/r/javahelp * https://www.reddit.com/r/learnjava Otherwise you're in the right place
Well crap. It's probably Java. I'll move it to the right subreddit. Thanks for the heads up and sorry for the mispost! :)
Btw, both Safari's layout engine (WebKit) and javascript engine (JavaScriptCore) are both open source, and have been since I can remember. https://webkit.org/ https://github.com/WebKit/webkit/tree/master/Source/JavaScriptCore
Where do I get that "Vanilla JS" framework? It's the fastest of them all... /s Jokes aside, I'm impressed with Inferno's numbers. I'll have to give it a try
Round 4 was released a while ago and Reddit threads were created to blog posts . So this post is essentially a duplicate. [original thread](https://www.reddit.com/r/javascript/comments/52gfym/js_web_frameworks_benchmark_round_4_inferno/)
Gulp is not outdated at all, I don't know where you're pulling that information from.
Well, you know, using impractical variable name is *obviously* bad but still people does that all the time. â˜ž( Í¡Â° ÍœÊ– Í¡Â°)â˜ž
I picked up a copy of Eloquent JS in my first week of learning js for my new job. I enjoyed it! It's a lot more detailed than The Good Parts and assumes less prior knowledge. It also talks about Node and walks you through some projects, if you're interested in that. I'm recommending it on the principle that it has helped and continues to help me.
This is an incredible amount of work for something that I would probably just tell my design lead "no, I'm not doing that" 
thanks for your help I was kinda intimidated when I came here but yo all have been very nice.
A couple years ago, I had a junior dev at work was working on a similar calculator and asked me some questions about key handling and jquery. I wound up [rewriting it](http://gr.ayre.st/s/calculator_demo.html) to demonstrate style and point out things in the comments. It's not a direct critique of your code but maybe you'll find it helpful.
Promises with generator functions are cool
[https://github.com/mini-eggs/ReadReddit](https://github.com/mini-eggs/ReadReddit) feel free to critique it
 operators.indexOf(input) whoa even though I was aware **indexOf** I never thought of using it that way. 
Don't forget to save dom elements to a variable or object if you use it a lot. Every time you do document.(whatever) it's retraverses the dom
The problem is the IF statement is executing before the prompts and EmployeeSales has not been entered yet, thus returning undefined. You need to move the IF statements below once EmployeeSales has been defined in your prompt.
no problem! everyone starts somewhere :) another tip: github has a lot of 'awesome-*' lists (like, say, awesome-eslint) that have tons of links to useful resources. really handy when you want to do some reading on a tool or a new technique! 
Whether your logic was correct or not (didn't check), here are some tips: Pick better variable names, and have them make sense //Receives input var calcArray = []; Don't put comment for comments sake. The most blatant one //define object var calc = { Your indentation and styling are very inconsistent. What's the deal with 9 and 0 being narrower than other numbers :D Hopefully you only want comments on your JS code and not on your UI design 
You can achieve the lights fading out effect with canvas.fillrect(0, 0, width, height) and a fillstyle like 0, 0, 0, 0.1. Needs to run with 30 or 60 fps in a loop/requestAnimationFrame to get smooth. You can define a sequence with your effects and frame number like this: // light index with x, y var lights = { '1': [10, 10], '2': [20, 10], //... // ofc this can be calculated from light index }; var seq = { '100': ['rgba(200, 0, 0, 0.5)', [1, 2, 51, 52]], '200': ['white', [1, 2, 51, 52]], }; // within loop frame += 1; if (frame in seq){ seq[frame][1].forEach(light =&gt; { canvas.fillStyle = seq[frame][0]; // something with path and arc } } That should give you a starting point with hard coded effects, you'll run into performance issues if you want different colors on all 2500 lights at once, because a new path is needed for each color. Switch to webGL then.
and if you *really* want to drill down, you can go even further: var calc = { input: '', operators: ['*', '+', '-', '/'], isOperator: function(input) { return this.operators.indexOf(input) &gt; -1; }, addOperator: function(operator) { if (this.input.length &lt; 1) return; if (this.isOperator(operator)) throw new SyntaxError('Not a valid operator.'); var lastInput = this.input[this.input.length - 1]; if (!this.isOperator(lastInput)) { this.input += operator; } }, addNumber: function(input) { if (!Number.isNaN(parseInt(input))) { this.input += input; } else { throw new TypeError('Input must be a number.'); } }, render: function(input) { document.getElementById("inp").value = String(eval(input) || '').replace(/\*/g, ' x '); }, calculate: function() { this.render(this.input); }, reset: function() { this.render(); } };
Check this out, I think it's almost exactly what you're looking to do...maybe. http://popcornjs.org/
"Do you have some resources to back that up?" Do you ? Browsers bench-marks are hard to do, to say the least. So I don't see how you can make the claim Safari is fast (unless you are on iOS, in which case, I'd take your word for it, but on that os it's basically unfair competition). Also, Chromium is not beta, there is Chromium dev and Chromium nightly but Chromium "standard" is the most stable, fastest and most pleasant web browser I've ever used. With the added advantages of a fucking killer developer console and being 100% open source. 
I'll definitely try it out later! I'll make sure to update you
Now, I wouldn't ask if I had any sort of clue on how to do it. The fact that I don't have much code is because I have recently started with the game as a whole, and got stuck pretty quickly. I have no intention of having people "write my game for me", as I will be editing code to fit it to exactly the way I want, I simply need a functioning guideline to create projectiles in a similar way to that I imagine.
I love scotch.io, check out their tutorials on Vue: https://scotch.io/tag/vue-js
Vue.js is the latest framework fad.
could also use the `includes` method
I agree
You could use setTimeout instead of setInterval. Then after each delay, you can add logic to determine how long the next delay should be. Pseudo code: function update() { // increment or decrement counttx and set countup as per existing code // if reached the limit, pause for one second // otherwise delay by BPMTIMER as normal if (counttx === BPM_TOP || counttx === BPM_BASE) setTimeout(update, 1000); else setTimeout(update, BPMTIMER); } // start the timer update(); 
You could just use Chromium and not use the Google services (e.g. prediction, autocomplete, sync).
egghead
Excellent idea. Thanks!
Hey, I'd advise having a few other object attributes, you need speed, and direction! have a look at the bullet class on my [github](https://github.com/jcb121/lamegame/blob/master/src/js/tool.js) and my [move function](https://github.com/jcb121/lamegame/blob/master/src/js/functions.js) So you can give an object a direction and it will keep going in that direction. you could extend the function to give it a curve also. you just need to be an the center of the canvas and spawn them in all directions. As for the pulsing effects, you need a function that returns between 0 &amp; 1. so you could use a function like `sin` and give it the distance travelled. and then multiply that be the diameter. this will give you a pulse. 
Start with Angular's own [tutorial](https://angular.io/docs/ts/latest/tutorial/), it gives a solid introduction to the fundamentals of the framework. (All in TypeScript, too) You can then use google for more tutorials. Thoughtram website has a lot of great articles that cover the details (with examples) of various Angular 2 concepts. 
nice short read
If you'd like the points to remain static and only have the light effects move, you can use the time passed to create a sin wave. the distance from the center point is used as an offset and added onto the current time index.
The math is a lot simpler with a vector library. I highly recommend using one if you're writing a game. Would look like this: let direction = to.sub(from).normalized() bullet += direction.scaled(time * speed)
&gt; ES7 feature list solidified, relatively small. Yea, the only new features are the `**` operator (Math.pow) and `Array.prototype.includes`. Kinda underwhelming, but ES2017 is just around the corner.
80% of all redditors have just screamed out in horror.
Except that I left the overloaded += there. Heh. bullet = bullet.add(...) Should have looked like that.
I think he's implying people on this sub are overly-reliant on frameworks.
Isn't node inspector built in now?
Even works well on my phone. Very cool. Might be using this in the future. 
Reminds me of http://meta.stackoverflow.com/questions/335328/when-is-use-jquery-not-a-valid-answer-to-a-javascript-question
Yeah, that seem to be the trend.. :/
Funfunfunction on YouTube is great and covers some functional idioms. React is a view library that has functional merits. You may wanna look into lodash fp or ramda to get you started with function composition. 
The official vue.js docs are a great place to start. Just reading through the guide with jsfiddle open taught me. 
I guess FP techniques can be used when they make code clearer. For example, if the code is doing some data transformation or is doing some computation that is not dependent on any side-effects then some of the techniques can be used. Most likely you would choose to use Lodash https://lodash.com/ or Underscore http://underscorejs.org/ which contain a rich set of data manipulation functions. Not to mention that React and Redux are quite functional-like and borrow many ideas from the world of FP to begin with.
I await the dumb ass excuses that always seem to follow. *But but but how else could I do... (fill in the blank)*
I came across this whilst looking for code coverage for Tape. His previous article discusses [node testing strategy](https://remysharp.com/2015/12/14/my-node-test-strategy) which is also interesting.
Currently SVG text are not supported but will be added in future releases.
Node-inspector which is a much slower version if this. Some ides have used nodes native debug API to integrate it into their environments.
Isn't a great strength of modern frameworks their ability to render to different targets, of which DOM is only one. Thus you can use them on the server side, in mobile devices, in some desktop environments (e.g. Ubuntu + React Native), etc.?
How is the recognition done? Is it done locally in a library inside browsers or is your voice sent to a 3rd party like in Siri and alike?
I write all of my projects in typescript and I love it. For configuration It's set it and forget it for me. For versioning, I just use the latest version of typescript everywhere. I understand that might not be possible in an enterprise environment but it might be for you. As far as speed goes (writing code and intellisense) - vscode is crazy fast with intellisense and so is vs. The amazing intellisense allows me to write code without having to check the docs for a library over and over. I can focus on writing my app rather than trying to figure out what types are on an object. I tend to use console.log a lot less because there is less guesswork. If you need some tips for a good work setup I can help you out, let me know.
Previous thread on the topic: https://www.reddit.com/r/javascript/comments/523yik/could_someone_give_me_a_quick_synopsis_of_the/ 
try using webstorm for typescript. Its support is the closest I have found to an equivalent of the VS C# experience. in webstorm, you dont have to setup anything, anytime you make changes to a .ts file, webstorm automatically compiles a js and a map filefor it, these files are shown in the project explorer section under a drop down arrow next to your ts file, so you can view it like its one file, or you can click the arrow to see all 3 files. In your ts file you get great auto completion, method signature tool tips, etc. I think if you try writing ts in webstorm you just might find yourself enjoying ts more than you currently are.
There is no support for `includes` on IE or Android.
Just a polyfill away ;)
Hmm. I dunno, I have a *lot* of love for Visual Studio, I'm pretty reluctant to leave it, especially for an early access IDE. 
You could even polyfill it with `indexOf` ;)
but the whole point is you don't need anything
Yeah I wouldn't use it for production right now, but given JetBrain's pedigree with ReSharper I'm excited to see what they're going to do. Who knows, it might spur Microsoft to make VS even better :)
So I'm using Visual Studio Community 2015 at the moment. What does VS Code do that full Visual Studio 2015 doesn't do? It kinda basically looks just like Sublime. 
Yeah, JetBrains are awesome. I used WebStorm early on when I was only doing front-end stuff, and Resharper is absolute magic. I love dotTrace too
&gt; With C#, Visual Studio gives me glorious intellisense and code completion [...] *You* don't get that with TS? &gt; Second is that writing TS just feels so much slower than writing plain JS. So, you aren't writing any JSDoc comments in JS? Anyhow, writing TS (even if you aren't writhing any doc comments in JS) doesn't feel any slower, because you can auto-complete more. Better tooltips also remove some of the friction. &gt; I have to declare my variable types Most types are inferred. Very few variables need a type annotation. E.g. if you write "let x = 5", it's a number. If you write "let len = 'foo'.lenght", it's a number. If you write "let x = foo()", it's whatever foo claims to return. Don't "over type". Inside of your functions/methods, there should be very few type annotations. You pretty much only need them for arrays or casts. When in doubt, hover a variable to see if its type could be inferred.
Make an iframe and document.write in there. That'll still work. :]
Grasp the fundamentals of data structures and algorithms. But, since you're applying for the role of the front-end, this book will help you understand some of the main ones used. All of the examples and code is written in js and can help you get started. http://shop.oreilly.com/product/0636920029557.do
It uses the Web Speech API as provided by your web browser so it depends on their implementation. Chrome I would imagine sends your voice data to Google, don't know about Firefox.
You are not. To me writing in TypeScript is as boring as writing in Java. It kills all the joy. 
Is there stuff kept up to date? Do you know? One of the worst things when trying to learn Angular 2 is that there's a lot of stuff out there that was done either in beta or early RC's.
Programming is just a way to codify human logic/algorithm. Functional Programming, Imperative Programming (OOP, procedural programming), and Declarative Programming are different ways to codify that logic. If your logic/algorithm is more functional (e.g. transformational) you should use FP, if your logic is more is more imperative (e.g. lots of mutating states, recipe instruction) then you should use Imperative/OOP. You can always spend the time to transform one form of logic to another (either mentally or in code). You are exchanging some of the following: * your own labor * your own learning/knowledge * maintainability * portability * consistency * performance * ease of understanding * etc There are occasions where some of those don't matter. There are also occasions where you would favor one over the other. 
I think I can't access the internal functions because they're private. Just clicked. So AJAXSuccess might be my only option :/
This kind of simplicity is refreshing. Introduction to diffing was also great. It is worth noting that pure DOM solutions like morphdom are used by likes of eBay in Marko etc. and they are performing quite well a. Check it out https://github.com/patrick-steele-idem/morphdom
Two suggestions: * You don't specify the database that you are connecting to, only the server. I don't know about your mongo lib, but you may have to specify this at connection time. * Construct your connection string into a variable and print it to the console and verify that everything is being loaded correctly. Good luck!
Yeah, Morphdom and Marko are great! RE:DOM also uses pure DOM, not vdom.
I think much stuff is brand new. You can find the published date when you click on a playlist.
Yet after ten years of experience with HTML/CSS and 4 of JS I'm still having more trouble keeping my CSS sane than anything else. 
Holy shit, that's super useful, thanks!
It's impossible without doing some kind of normalization. E.g. "matches" and "closest" don't work across all modern browsers yet. And if you have to support older browsers like IE9/10, things get even worse. The "hidden" attribute doesn't work there and "valueAsNumber" is kinda b0rked as well. There are browser differences and you have to take care of them.
Gulp is glorious
General answer from my own experience: always unit test. Language, framework, libraries, doesn't matter. Always unit test.
I have indeed. But i might not understand it correctly. 
Thanks for that. Funfunfunction was great! This has been helpful as well. https://code.tutsplus.com/courses/functional-programming-in-javascript/lessons/introduction 
I had no idea that this worked. This is awesome!
I took a quick look at your code and didn't see you calling these methods anywhere. Did I miss something?
Definitely, yes. That being said, make sure you're writing meaningful tests. As in.... Test the code you're writing. Not testing if the framework or library you're using is working as expected.
Line 81 &amp; 82 (however in the github link line 81 is commented out) edit*: in controller that is.
See I get both the tables, but all the different associations I try, I either got Role table empty, or I get an error saying there is no Role_ID field in User...
Have you tried turning the real iOS calculator app into landscape mode? http://imgur.com/YoPupnW
Your advice to just use attributes when in doubt is a bad one. Attributes and properties are not the same thing. &lt;form id="f"&gt; &lt;input id="i" value="23"&gt; &lt;/form&gt; &lt;script&gt; i.value = 100 // shows 100 i.setAttribute('value',18) // still 100 setTimeout(()=&gt;f.reset(),2000) // resets to 18 &lt;/script&gt;
Yeah, there are some corner cases â€“ I should mention about them, you're right.
thanks for sharing this, it looks neat :) question, tho: can you explain your line-of-reasoning for using eval?
Yes.
I now mentioned about input.value â€“ I can't remember any other non-sync cases? Booleans are of course also tricky, but I already mentioned about them..
I want to be a javascript developer. TS does some great things but we really need to fix the core language and I want to encourage that so I too feel unhappy when I try writing TS.
From the Node.textContent MDN page: &gt; As `innerText` is aware of CSS styling, it will trigger a reflow, whereas `textContent` will not. So does `console.log(foo.innerText)` trigger a reflow, and the `textContent` variant not? Also, something like `foo.textContext = "bar"` still triggers a reflow, right?
What have you made so far?
ah ok, I read recently that Dan Abramov said that you will know when you need to use redux, so I guess this is where I am at.
I think it is time I looked at Redux. my JS isnt bad, and I have picked it up at an ok rate, but I just feel that it also can get slightly confusing, unlike what I ever experienced with Angular. Thanks for your thoughts though, appreciate it. 
This is powered by WebTorrent! The star map data is fetched via a torrent file, over WebRTC! Author's tweet about this: https://twitter.com/flimshaw/status/778028000587710464
[removed]
[dygraphs](http://dygraphs.com/) is my favourite for plotting lots of points. It's not the prettiest and it just does line charts but its interactive features perform very well even when plotting tens of thousands of points. It might be worth looking at [Comparison of Javascript Charting Frameworks](https://en.wikipedia.org/wiki/Comparison_of_JavaScript_charting_frameworks) to see what else is out there.
In my experience that happens a lot less when using a state management library since you can access that decoupled state from almost anywhere. It will still happen occasionally with complex components, but the problem where there's one component (or a handful) at the very top of the tree holding all of the state and passing it down to everything else should go away.
I was in this boat when trying to get an ORM working for a project a few weeks ago. I ended up giving up on both Sequelize and Bookshelf and just using a query builder ([Knex](http://knexjs.org/)).
Ran into this on a project when I was building a thin wrapper around `fetch`. I originally tried to just pass `{method: options.method}`, assuming that an `undefined` value would default to `'GET'`(omitting the `method` property altogether does). Turns out the native implementations seem to coerce `method` to a string if the property is present. Also found it interesting that the `mode` defaults to `'cors'`. 
I've been using RxJS extensively the past few years without any complaints. I actually consider it to be one of the most reliable and stable JavaScript libraries I've worked with. Also, RxJS has been in active development for the past 9 years and is battle-tested in some huge applications (e.g. Netflix). So no, I don't think it's flaky at all. I do however think that it can be unintentionally misused in a lot of ways if you don't fully grasp the ideas behind RxJS or FRP in general. But it can be hugely powerful if you manage to get past the steep learning curve.
If you are just looking for a quick site with no real back end database framework, which is sounds like you are, try checking out Wordpress. There are nice looking and easy to build / host websites to buy / build.
I agree with u/Democratica I also wrote my own. * code - https://github.com/prettydiff/prettydiff/blob/master/test/lint.js * example - https://travis-ci.org/prettydiff/prettydiff/jobs/162680763 I wrote my own because I needed something that could test my application against various different configuration states, manage dependencies (at this time there is only 1), run simulations against the file system, and do much of this asynchronously.
The ideas behind it are quite good. I do not care for the API at all.
Because the latter is saving the exact version, where as using prefixes allow flexibility when it comes to running updates in regards to semver and it is generally accepted that non-breaking updates (bug / perf fixes) are a good thing.
Yep, I built a page once that had to have 3 charts on it, up to 6 lines per chart, and each line had to be able to reasonably handle up to thousands of points, hooking all of them up to the same zoom / scrub feature. Dygraphs was super easy and very speedy. Highly recommended!
I dont bother with TS when there's ES6.
AAAAHHHHHHHHHHH!!!!
I was just using atom as an example. This was a legitimate question. Of course it gets down voted. Thanks Reddit! 
Create an API key, can be just a UUID, for each user and then do a simple check on the server side. You don't need a library for everything :)
[removed]
well, i'd warn you that eval makes your library unusable in production settings. it's simply too huge of a security risk (there's a reason the eslint rule is called 'evil')
You could try using bootstrap, Check out the built in navbar. https://getbootstrap.com/examples/navbar-fixed-top/ They also have really good documentation and have lots of code examples. http://getbootstrap.com/getting-started/ 
Auth is one thing you shouldn't roll your own with. Use JWT or PassportJS. Edit: Also, OAuth2 would be a solid solution. Please, do not roll your own. 
If there is a method to read and then set styling, just read it first, set your value, then reapply styling? (Wild shot in the dark)
innerText is non-standard, so it's better to use textContent anyway..
I'm having a hard time allowing myself to trust a third party with my authentication. Plus, if someone breaks the crypto, they can log in as whoever and you would never knowâ€¦
Wait, what? Where's your source on that. That is the complete opposite of everything I have ever read. How could building this in memory with no reflows be slower? Here's someone's post from last week that I just found: https://coderwall.com/p/o9ws2g/why-you-should-always-append-dom-elements-using-documentfragments And MDN sure still seems to recommend it: https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment
It's true, book really nice.
Should the answer be OAuth 2.0 here? Token and Secret with signed requests? Or is that overkill?
On a side note, where can one go to find algorithms for creating their own line charts? I'm generating pie charts with SVG as a learning exercise and they're coming out nicely. Would love to learn more about creating bar and line charts. I'm interested in things like dynamically scaling the axis range, label step and determing how large labels are so they can be spaced appropriately. Also mapping data point to x,y coordinate, etc.
https://jsfiddle.net/pakastin/1mdemuvr/ vs https://jsfiddle.net/pakastin/aaLpcy8c/ Only browser getting a small benefit is Firefox â€“ all the other browsers are slower with document fragment. Modern browsers are optimized adding bunch of nodes at once without the fragment. ..and using document fragment would only make sense when attaching array of nodes â€“ when you're inserting/removing/reordering here and there using document fragment makes no sense.
The Facebook pages give me head aches, no matter if react, relay, flow, fiber, graph ql. Especially the one about react has kept me from learning it for a long time. The first proper introduction I had was the [fundamentals course on egghead.io](https://egghead.io/courses/react-fundamentals). My bias vanished, jsx, which always seemed weird, became my favorite tool for composing front-end. I've been doing apps in quite a few systems. The way I see it now, they miss the point. They either rely on inflating layout, which lends to spaghetti code (jquery, android), verbose markup with complex data relations, impossible to reason about (xaml), odd and impractical template syntax mostly ripped from conditional logic, makes composing hard, has to be prepped to receive other components (angular, vue, polymer). React solves all of these issues. Markup is small, descriptive and conditional logic is bound to it in a way that feels right. Composing components is similar to putting Lego bricks together, it just comes natural. It fulfills polymers dream of "there's a component for that." React has a huge eco-system and most of the time what you seek you find. State becomes crystal clear, the app rarely does something you can't understand and if it does it is easy to find out why. The dev tools for that are incredible, letting you see and inspect everything. If you work with redux its dev tools allow you to visually roll the app back and forth through its states with a history slider, seeing how the UI is just a dress, reflecting a set of states, it's mindblowing. Overall it changes the way you think about user-interface, composition and state, establishing a more or less clear picture before the app is even built, which is maybe the most important aspect. 
With these tests I show a 20â„… increase on chrome and a 33â„… increase in Firefox running latest versions on my Nexus 6p.
Makes sense. I guess saving time to test all those 80 different cases using unit tests is what actually pays off. ðŸ˜Š
Would have been nice to have a keyboard listener for numpad inputs.
With desktop it's the other way around. But like I said, it only makes sense when creating elements â€“ not when insert/remove/reorder here and there.
I think many people find them useless because they don't use them properly. They are a pretty strong and used by google itself for firebase authentication. Inside the JWT, you can store whatever you want (the user-id, for example). When the server receives a request, you only need to extract the JWT, decrypt it and you already have the user-id, without DB access. From the security point of view, you NEED to release the user 2 JWTs: - authentication JWT: short lifespan (1-2 hours usually) - Refresh JWT: Long lifespan, used to generate a new authentication JWT
One of our APIs expects a JWT to be present in a header field and returns a new one for every request. The latest one is stored in Redis. Once a request comes in, it's checked if the token is there and is valid (TTL and stuff) and then the API does its work.
I'm using express for all middleware part (sessions, cookies, storing redis session etc..) with Passport for authentication (+ Passport can be plugged in express to store sessions). It's working very well.
Also the `href` attribute/property of anchor elements behaves in a different way. &lt;a id="a" href="/drowing"&gt;deep&lt;/a&gt; &lt;script&gt; a.getAttribute('href') // "/drowning" a.href // "http://example.com/drowing" &lt;/script&gt;
nice! good to bear all this in mind 
non cors fetch is mostly useless as the result cannot be read if not in the context of service workers, which cannot be polyfilled anyway.
hey man, i meant angular 1 is seen as outdated, not React. Spaghetti code is probably not the correct term to use, but i mean it gets a bit confusing (at least for me) passing the state and props around. i prob just need more practice. links look good tho, thanks!
Again, how is this different from generating a bearer token? If you need to check against redis anyhow, what's the point of a JWT?
It may work for google for specific cases, but I don't see how it works for a majority of usecases. In most cases, you need more than just the user-id to carry out a request. For instance, I need the user's username, email and fullname for a request. I encode full user details in JWT so I don't need db access on each request. Now, if the user is logged in two places and changes their email from one location, the JWT token in the other location will pass in an incorrect email. How would you resolve this?
I fear that nodejs will have to break compatibility in order to accept ES modules. I don't see how they can be retrofitted without it. require('foo') used to be async by the way, just like requirejs in the early versions of node, but it was a huge pain in the ass.
Whoops. I didn't have that "outdated" mention in my original comment. Started to add it as an edit, thought I hit cancel, but apparently hit save. Sorry. That said, if you do have specific questions or examples of code you're struggling with, feel free to ask here or in Reactiflux. 
That's what I thought. However, you did say "people find them useless because they don't use them properly", and not because it's inherently limiting :)
Not if you account for various flags applications use - is the user active? is the email validated? is the user deleted? is the user blacklisted? 
Just to pile on to thenumber24's reply (because some things are too important to just upvote), "you don't need a library for everything" is extremely wrong-headed when it comes to security. Let people who do security for a living do security. To give an example of why your suggestion is inadequate, which type of UUID do you use? If you don't know much about UUIDs, you might just go with v1. Oops, now your keys are guessable.
no probs! thanks!
My 2 cents: 1) they completely changed the API, so old projects won't be easily ported to v.2, and one has to learn everything from scratch again. 2) since people are using JavaScript for more complicated stuff, it's matured into a more solid language, with features useful to do more complicated stuff. I don't think people don't want to use JavaScript in a OO manner. What makes you think that? 3) I wouldn't say so. Most programmers who don't limit themselves to using JavaScript for date pickers and stuff like that use ES6. You can tell because most examples and tutorials you find online are in ES6. Also, most GitHub projects provide examples in ES6. 4) React has all the momentum now. I don't think that anyone will be able to tell you whether Angular 2 will be as popular as Angular 1, but it doesn't seem like it's happening judging on how things are going so far.
I think you don't understand the "progressive" principle that Vue is based on. Its author made it pretty clear. If you want to make a prototype or write some small script for your page - you can do it with Vue. If you want to use modern tooling, ES6/7 and compile your code in a bundle - you can do it with Vue. And if you need not just a view library, but a whole ecosystem with a data store, router and other features - Vue is also a great choice. It's not hard, it has no "magic". Vue components are straight objects that can be written without any compiler or other tool. Include Vue in your HTML page and write whatever you want without any implicit steps. Vue components support both inheritance and composition (mixins). You can freely customise them if you want without monkey patching. Templates vs. JSX is a matter of personal preference. I don't like JSX, that what I call "odd". UI should be declarative and described in a standard HTML, not in some weird language that cannot be read by designers. But that's just my opinion, and in Vue 2.x you can use both - they just compile into a render function. As for lack of components, it's questionable. Chinese folks have written a lot of amazing stuff. But it's rather obscure for the international community, since in China they don't bother to make English documentation. Here are some great examples: [Element](http://element.eleme.io/#/component/quickstart), [N3](https://n3-components.github.io/N3-components/), [Weex](http://alibaba.github.io/weex/index.html) (React Native alternative).
Express + Passport
Vue's api, and if you don't study it you won't get far: http://vuejs.org/api/ Haven't had to do that with react. Its "magic", if you don't understand how the intricate system works it'll pull the rug underneath your feet: http://vuejs.org/guide/reactivity.html#ad Gotchas, which creep up once you leave the safe haven of the todo demo: https://vuejs.org/2016/02/06/common-gotchas/ Vue mutating your local state, adding hundreds of thousands of watchers if you don't watch out, the solution to that is a hack: https://github.com/vuejs/vue/issues/1988 As for composition, it can not freely compose. You declare that A can be in B, unless A is in vue's global scope. If you refactor A, maving a piece out into C you're cutting wires, moving computed props and methods. In react you constantly move pieces here and there, up and down, seeing how it looks. Refactoring is very simple. JSX makes a lot of sense. But mostly it looks scary because facebook doesn't make much effort to show what it is and does. It already solves problems web components and future web standards haven't begun to address.
Angular 2 is late to the party. It's bloated, requires a heavy toolchain, written in TypeScript. I think people don't feel like they need a big framework anymore with its unique terminology and ecosystem. There are React, Vue and other modern libraries that are way simpler and more flexible. Although I'm sure Angular 2 will be heavily used in enterprise - banks, big companies. Just like Angular 1.x.
Exactly. That's why I just import my MobX stores as modules wherever I need them. You might think that it would make unit testing hard because now I have explicit dependency I have to mock. Wrong. I use plain obsevable objects as stores so setting them to a specific state inside a test is easy as pie.
1. Hatred is a strong word. It's just late, uses muddled concepts, still hung up on the templating paradigm, doesn't solve any issues that aren't already solved, probably better, with react. 2. [The tendency is functional programming, not OO](https://cdn-images-1.medium.com/max/800/1*AM83LP9sGGjIul3c5hIsWg.png). 3. Typescript is not ecmascript. We have ecmascript ratified under es7 or es2016. Most browsers run it. Babel does a perfect job to make it work everywhere and offers future drafts as it directly reflects the tc9 process. TS wouldn't even be able to compile modern javascript as it is widely used. Google for "redux example," a popular state management for js apps, and route that through TS, see what happens. As for static types, there is Flow. 4. It will probably not be as popular as ng1 was. Ng1 had few competing alternatives around and solved issues the others couldn't. Ng2 is just one of many.
This is all a bit above my head, but I've been using ES modules in Node via Babel seemingly without issue - does the Babel ES -&gt; commonjs translation have some of these same issues?
React is explicitely clear about how it manages data. Your data and your component is yours, it won't touch it. Reactive data is bound to transparent rules. Gotchas exist in vue is because it tries to be clever while javascript simply cannot do what it wants in certain cases. Which is why you will eventuelly run into the new-object or replace-object dead-end, then using hacks ($set and $delete). Or use VueX, at which point the 10 second magic vanishes in a puff of smoke. That would still be fine, but vue crawling through "your" data converting everything under the sun into computed setters and getters, that is the biggest problem i have with it. Nothing belongs to you, it does whatever the hell it wants. If you doubt react can save you from building bridges, follow through [this](https://egghead.io/courses/react-fundamentals), just for kicks, try it on a mid-size fun-project. 
So basically, in all situations where you don't have to invalidate the JWT, they are nice. Who needs logout anyway :)
Yes, if you need to do authorization, you're hitting the DB, which means no different from sessions. If you store the permissions in the JWT, you can't change them until the JWT expires, or you are back at the problem with the blacklisting being like a session store.
Did you read http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/ ? You are ignoring the problem where a JWT needs to be invalidated due to changed permissions or user logout. This problem basically boils down to sessions.
Read the report: things seem to work out well, loading doesnâ€™t have to be async.
I use 3scale. It's super awesome. FYI.. I'm not affiliated with them in any way.
It's not obvious when and how they include and it doesn't reflect the proposals. In the end you have a minor typing tool dictate your codes reach. Last year it says "no async, sorry" and today "redux is not for you" (even the official redux docs use spread). Tomorrow they add some drafts and when we're there other drafts will be in effect as living standards. TS is behind the current state of affairs, not in front. Just pointing that out. There are big reasons not to use TS, even if it has its place and some clearly prefer it. But just like Angular 2 has to face React, TS faces Babel and Flow.
You're not wrong but what does that have to do with anything I said? I'm merely explaining what JWT is and what it's not. Mainly that it's a way to store the token with the user id within the token itself without needing a "session store" (token store would've been a better name) , a session store here meaning only the mapping between tokens and actual users (apps, services, or whatever).
Object spread was moved to stage 3 recently: https://github.com/tc39/proposals
They don't say redux is not for you, you can use Object.assign for example. It's not their fault redux (which I agree became a major part of a typical react stack), uses experimental language features in their docs. I agree you'll get a smoother experience using the same tools the framework authors are using obviously, but I don't think using typescript with react is really much work.
Why not take a look at the source of the current ones, that is what open source is all about :)
&gt; Is there any way to access the contents of objects that are created with an immediately invoked function expression on a web page that is being accessed with CasperJS? No. 
Ok, I'm sorry to say this but you basically eating absolute shit with those benchmark or have a computer from ages pasts when single core processors roamed the land and pentium was considered "high end". I have a youtube video running in the background, 5 browsers open and I'm writting this. My CPU is, generally speaking, not over 35% on any of the two cores. And my machine is something I bought for 230 quid the miserably overpriced computer parts &amp; electronics hop shop. If you've seen the processors PEAK at 70% that can be normal (depending on OS), due to keyboard/mouse interrupts (since you said you are logging into gmail). But that's not so much a benchmark for the browsers as a coin toss against the task scheduler. So unless you explain the conditions more, list the tools used (Becuase top is not exactly a fucking benchmarking tool that is able to record a single's process resource consumption) and give a believable reason as to why browsers are able to pump your CPU to the fucking limit.... I call bollocks.
It's not bloated as much as it's written for enterprise systems and small time coders are being told they MUST use it or die and nothing could be further from the truth.
I'm not very sold on angular 2 for similar reasons as stated above, but hate is a strong word. I would definitely use angular 2 in a project if it had already been decided and I got there after that. It would also be a very good experience, compared to angular 1 early days. Regarding TypeScript, I love it. I use it whenever I can. These days of I have to write front end code, I hope it's in either TypeScript or JavaScript + Flow. TypeScript has nothing to do with why many of us aren't sold on Angular 2. But that's just my opinion!
Yup, thousands is the new 12
[CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)
If this is at all possible, I imagine it would be via the chrome debugger protocol. But to instrument the browser to do what You'd do by setting a breakpoint as the code loads (possibly rewrite the code on the fly through a proxy, to inject the "debugger" keyword), and then issuing the correct commands to read the value. Most people would say no ;p
Sure, but blindly following "existing solutions" without knowing what they actually do is much worse. The basics of authentication are well understood and have been around for ages and are not hard or difficult enough to need a library for if you know what you're doing. Also your comment about UUID's and version 1 is, while valid, sure, but also extremely... odd. You're assuming a time based generated UUID, which indeed, if raw, would be idiotic. But that's common sense. No mention of salts. Yes. Libraries are great. But even if you rely on them, you better know wtf they are doing.
A noble spirit embiggens the smallest framework
I really like it. It's a lot like Angular but without the sharp edges.
What do you mean "without the sharp edges"? For me, having first class router is a huge upgrade over Angular. 
I have noticed the community is quite active. Toying around with React felt awkward. I feel like vue, while similar to react, feels much more natural. 
a video to show how the use of couple of principles of the clean code book (its me on the video), namely explanatory variables and progressive refactoring can be used to write an initial version of a RxJs Observable based routine, and then make it more readable and reusable in a step by step way.
My use case is just toggling between languages. For example, showing a linked list implemented in Java, then in Python. I want to be able to change the display language on the fly.
Vue is great in general. I haven't given 2 much attention yet. Once all the libs I use are ready for it we'll probably transition to 2. Imo it is a lot easier to transition to Vue than React coming from Angular.
Hey, I wrote an article about visual TDD and awesome documentation. I made TDD all about fun. Could you tell me what you think ? http://toucantoco.com/front/2016/09/14/visual-tdd.html Cheers!
Filters weren't actually removed. Evan had thought about doing so, but ended up keeping them due to popular demand. Here's the official Vue 2.0 docs page on using filters: http://rc.vuejs.org/guide/syntax.html#Filters
i tried to find a simple development environment for typescript. there is none.
What source(s) are you using? From what I've seen/read the general consensus is that TypeScript is great and is better than Flow and typed Javascript is the future. I do see quite a bit of Angular hate, but that's because unlike TypeScript there are alternatives that are arguably better... and then there was the whole Google screwing up the release.
How can you say that a toolchain and a new syntax(TypeScript) is bad but praise react when react comes with jsx which contains a toolchain as well as a new syntax (jsx). The toolchain or language is not the problem if the api is nice.
Array filters were deprecated, I believe. 
I find Vue 2.0 as something between Angular 1 and React. It's modern and really easy to learn and use.
Writing large scale applications in JavaScript is relatively new in terms of software engineering whereas that is the bread and butter since the beginning. So there is a lot of experience of how to best do stuff like this and a typing system which TypeScript provides lets you carry over some of those principles to JavaScript.
I would have guessed 'same-origin' for the default. Turns out the fetch spec defaults to 'cors', so I guess the browsers are in line there (polyfill defaults to null)
Here's the reason people's initial reactions have been so bad. Imagine you eat waffles for breakfast every day. You are super into waffles. You wear waffle PJs. You spend your free time learning the best ways and variations on waffles. The entire breakfast community has been huge on waffles for years now, with no real competition in sight. Then, one day, the waffle company tells you that they're coming out with a new, better waffle, and that after a point, you can't have regular waffles any more. They're outdated. You won't need them when the new waffles are out. You get hyped waiting on this new, better waffle, but when they finally show it off, it's a slightly burnt pancake. They assure you that the final version won't be burnt, and it was just the first one in the pan. It's going to be fluffy and amazing. And maybe it's delicious. Maybe you'll like it more than waffles. But a pancake isn't a new waffle, it's something entirely different. It's hard to rationally decide if you like this new thing or not when it isn't presented as a new thing, it's presented as the direct successor to something that only shares basic ingredients and the meal you typically eat it at. You've still got your syrup, you can still stack them up, but it's just not the goddamn same. And that makes it hard to enjoy the pancakes, even as they continue to get better and better over time.
Visual Studio 
Update has been added with some performance optimizations !
Doesnt run chrome or at least the usual windows chrome extensions as far as I know. I have a node.js bot running on one.
I'm using Vue 1.x and have found it much easier to grok than Angular. Plus, there's an instant familiarity when transitioning from the Angular mindset which is a big plus for the team.
Thanks for your book, these days that code blindly are gone. Thank you.