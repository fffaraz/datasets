Suffer a fork name quintessence.js due do disagreement about the meaning of five. Enjoy ML flamewars about which is the truest of the two. Then announce the time of peace with merging into a new project called V. 
Reminds me of fuck-it.js' `moreConflict` mode.
So how long does a company name have to be before their trademark is a real trademark? Also seeing as the company has been in existence since before npm even existed it's not like they came storming in with the name after @azer had been using it first. They just moved into a new space and discovered he was using the name they'd been operating under since 2010. 
Trademark infringement is a case for the courts. It is not for NPM to decide. As for policies, number of packages, experience and popularity are absolutely essential when deciding on how policies should be applied. Everyone should be equal before the law, but not everyone is equal before company policy, and that's actually a normal thing. Policies facilitate the functioning of a company or a project, and if an application of a policy results in serious damage to the company, then either the policy should be revised or it has been applied incorrectly. And obviously, the way NPM handled this particular situation was a huge fuck up all around all around.
Doesn't seem to be a huge issue
If you're using CommonJS module syntax then there should be no reason you need to use Bower and npm.
I dunno, where's the servicebus in this? I'm really not comfortable with padding left without a 99.999% SLA. 
It's not the hero we need but it's the hero we deserve. 
Sure, class 09 is general software, but the specifics granted in the trademark are important: &gt; G &amp; S: Computer software for use with mobile phones and portable computing devices to exchange, share and create text with other users; computer software for electronic messaging services; computer software for use with mobile phones and portable computing devices to exchange and share digital photos; computer software for use with mobile phones and portable computing devices to download audio, video, digital photos and programs; electronic payment systems, namely, a computer application software used for processing electronic payments to and from others; computer software for use with mobile phones and portable computing devices to create video and digital photos to share with other users; computer software for use with mobile phones to launch other applications and connect to other software services. azer/kik is a project to create new software projects from the command line. There is no likelyhood of confusion here. IANAL, but this guy is: http://www.avvo.com/legal-answers/can-you-trademark-a-name-that-s-in-the-same-class--1324499.html Also, FWIW, the trademark issue is not yet resolved, and if they ACTUALLY thought they had a case, they should be preventing azer from having a project named 'kik' at all. Just because it's no longer on NPM doesn't mean that it would no longer be infringing. That they aren't going after him still shows that they had no interest in 'defending their mark' and were just bullying him to get the npm name.
kek
I don't _think_ what you're saying is happening, though TBH I'm not quite sure I understand. What happens when your setTimeout is called is the anonymous function you pass into it gets temporarily stored in the process handling the setTimeout API (somewhere in browser code) and your stack is allowed to play out. As it happens, with your code, that basically just unwinds the recursion and goes on to call your "COUNT" log back in global space. Then, after the timeout time completes (0 as far as input goes though I believe all browsers cap it to 4ms now), your function gets added to the event queue and called in its own call stack. In this new stack, the recursion continues as `num%10 !== 0` and eventually unwinds when the last call breaks out when `num` is 0. Something to note is that setTimeout doesn't _block_ anything, such as other messages being added to the event queue. It simply holds on to some code (callback) and throws it into the event queue after some time has passed. 
Because there are some latent problems with scoped packages. Namely that they aren't searchable.
those monsters..
When would you use &lt;Five onFive={ () =&gt; { this.five() } } /&gt;
This is true. There might be an interaction, in which we would need the value of `five`. Final version &lt;Five five={five()} onFive={(five) =&gt; this.five(five)} /&gt;
I never disagreed with any of that. I'm just saying that it is, in fact, confusing, despite everyone insisting that it wouldn't be. I don't know where everyone got the impression that we'd all be looking for Azer's vaporware and not for a package put out by a large, global service, even if we didn't ourselves use that service. WTF?
So are you saying when the call stack has like 6 return() on it then the setTimout() is called from the browsers web API and this allows the stack to unwind?.. I guess my question is "why is the initial stack unwinding at this point?"
https://en.m.wikipedia.org/wiki/Betteridge%27s_law_of_headlines
they threw the word in the room by saying “we don’t mean to be dicks, but [things dicks say]” to which he replied “actually i disagree with you telling me you aren’t dicks”
holy shit it has just clicked.. The repeat() returns once invoking setTimeout() on num%10===0. This return unwinds the call stack. event queue pushed repeat back onto a stack in which recursion happens again..
This project needs a bigger presence, and I well, suck at web design. If anyone wants to help.
Of course - rewarding people by paying them would work - but obviously - as you can see in open source - it does not work here. People could just stick to the game and not do all this awesome stuff - but our world would be worse - so it's a good thing that people break out of the limitations given by the game and create the good stuff anyways... ...so a logical next step for all people involved is to ask the question about how to overcome or change money and how rewards or reputation in general should be handled because money and the traditional game logic is not up to the task.
is this webscale?
they said “we don’t mean to be dicks”, followed by nicely phrased threads that did call for a “compromise” but made clear they only would accept him changing the name. in other words they were complete and utter dicks. azer (and most people here) disagree with their statement about them not being dicks, ’s all.
Whoa. That was a big jump. NPM has been great to the JavaScript community in the past. Can you name another instance of this happening? The one time people think NPM messed up, everyone throws a pissy fit. NPM had a policy no one complained about until now. It was rarely used and was there to avoid confusion. Whether you like kik or think it's for babies, it is a real company with hundreds of millions of users. They were releasing a Node library (No one uses kik and Node! They were changing that, hopefully). You may not agree, but it seems reasonable to think it would create confusion. I am not saying there don't need to be changes. I think the issue is not as big of a deal as people make it though. The biggest issue here is that everyone's build broke.
License key for what?
&gt; This package name is not currently in use, but was formerly occupied by a popular package. To avoid malicious use, npm is hanging on to the package name, but loosely, and we'll probably give it to you if you want it. This is the description for each of these packages. Pretty misleading thread title.
&gt; It is as valid as saying "people that don't wear red shirts are not qualified to make software in the first place", as if I had any right to say who is or is not qualified to make software, based on my own arbitrary criteria. As if people had to qualify to make software. Actually being able to evaluate whether a particular software library should be used in a particular development endeavor is hardly an arbitrary criterion where software development is concerned.
`babble` ?
Yeah, but I need bower for the scss things
:thumbsup
Not really. To be honest, I already have left-pad fatigue article fatigue.
Pico-frameworks, those one-liners.
Perhaps npm should make it forbidden to use "kik", instead of granting to the new party.
Oh yeah good point. Pretty sweet.
Does npm own the trademark "npm"? hmmmm
But to search engines it is. Returning 404 is a sure way of getting your website de-listed.
First, write a method to check if a number is prime. Basically, you will iterate from 2 to n, checking if n % iterator == 0. In your prime factor method, enter a loop, and first check if n is prime (if so, return n). Then, iterate from 2 to n, checking if n is divisible by the iterator. If n is divisible by **i**, check if **i** is prime. If it is not prime, then next in your loop. If it is prime, push the iterator into a result array, reset n to n = n / iterator, and restart the loop with a check for if the new n is prime. If it is, return result_array.concat(n). Finally, I think you are having a lexical scope issue. The variable 'array' is not defined in the interior loop. Fix it by binding the context, or using a closure. Probably you will use .bind(this) as a chained function call on the outer loop. Typed this real quick, let me know if you have problems. The solution I have put forward is to me the most obvious, and it is totally unoptimized, and I didn't check it. 
Interesting idea -- the Judgement of Solomon approach!
The module (and the others like it) is too trivial to pass threshold of originality so any license is meaningless anyway.
You can't unpublish packages from nuget. Also sounds like you're taking this post personally, so perhaps take a step back and catch your breath before mindlessly throwing out ad hominems.
There is a web design company that got the wii.dk domain long before Nintendo made a product with that name, they had to give that domain back and renamed themselves to wiidesign. That said some companies are more aggressive about their trademarks than others. I remember someone made a indie game called AMZ and Amazon sued them for using "AMZ" because they see a possible confusion with their own brand. He wasn't ready to challenge them, and to make matters worse he also owned an affiliate account with Amazon and lost $54k in money because they cut his affiliate check payment. That's not worth the fuss to challenge a big company over.
Sure. When there are multiple promise-returning functions in the mix where making one depends on getting information about another, BUT you want a final result reflecting information from both, it can kick you back into a pyramid structure (because you need a closure to save the old information). Async cleans that up. var apiCall = query =&gt; $.ajax(query); //w/ just Promises, using a closure to retain "user" function getUserAndAvatar(){ return apiCall({url: '/users', id: 3}) .then( user =&gt; { return apiCall({url: '/avatars', avatarid: user.avatarid}) .then(avatar =&gt; ({...user, avatar})); ); } //w/ async async function getUserAndAvatar(){ let user = await apiCall({url: '/users', id: 3}); let avatar = await apiCall({url: '/avatars', avatarid: user.avatarid}); return {...user, avatar}; }
You set `temperatureC` to 32, same as `temperatureF`. Did you mean to set it to 0? If I do, I get a blue background.
oh that make sense! thanks.
I'd love some bad press, because I've really not had any press to date. :) Sadly I've done what you suggest already. The original carnation did exactly that, it literally said what I thought it offered and where possible tried to back it up. Nobody battered an eyelid. The only way to get a framework of the ground is; a) supported by a corporate, b) include a plugin for something that is a) but which uses your own library. Here's a statement of truth; I believe Igaro App can better power your next SPA than Angular. It's faster to learn, significantly more structured and umpteen times faster once you make something larger than a little data binding demo. I dare you to find otherwise. ;)
What's actually wrong with it? Works fine when I adjust temperatureF.
i have been working endlessly to fix it. thank you for checking my work
That would be fucking awesome
Under that reasoning, one could argue that installing a spam filtering module should -to avoid confusing people- provide canned jam capabilities.
I’ll probably add some simple stuff, like loading product data and searching for products by tomorrow, and then publish it. Currently working on parsing the html fragments the API provides, as none of the microdata parsers on npm work properly. Yes, I tried everything with XML, microdata, or RDF in its name.
Yep NuGet is obviously iron clad legally, protected by laws higher than the DMCA, preventing any kind of outside forces to mess with your C# deps thus making it a 3000% better tool than npm, it's also written in C# an obviously big boy language compared to JS which is for idiots. Also you can you just have to send the admins of NuGet a message. And if Microsoft decides to create an official dep solution the first thing to go on NuGet will be all the MS packages it's currently hosting
Throw in JWT in the mix. 
You do pay for them, but just at the same rate as other CloudFront traffic ($0.08/GB or cheaper) - http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html#custom-error-pages-charges
AWS Lambda for the win. 
I'm just looking for Mike Robert's Twitter account bc tweeting npmjs and kik to go fuck themselves feels impersonal.
Plot twist: it runs npm left-pad server side.
And finally, when we stare into the abyss, the abyss will be able to stare back at us.
One suggestion I'd make is to not even have both Fahrenheit and Celsius in your code. Pick one, and if the display temp is the other just convert it. That way you only have to worry about one temperature unit in your code.
I say we do away with npm entirely. Why have dependencies when you can just make a REST call? I say we register * `isarray.io` * `sort.io` * `map.io` * `reduce.io` * `isnan.io` * `tostring.io` * `settimeout.io` * `soap-rpc.io` * `xmlhttprequest.io` No more will we labor under a broken and bloated dependency system!
 var results = []; for (var i = 2; i &lt;= n; i++) { if ( n % i == 0 &amp;&amp; isPrime?(i) == true ) { results.push(i); } } console.log(results);
yes. I have always done that to prevent my builds from suddenly breaking due to incompatibilities between package versions.
There's no suitable replacement, but it would be feasable to [fork their repository](https://github.com/npm/npm) and compile the binary at least to know that you're not unknowingly pulling a Donald Trump sponsored version that replaces lodash or jQuery or something. Besides the binary, it would be cumbersome to map every registry entry, but you could automate the process of generating a flat dependency tree for a project, in which you could replace every npm package with the corresponding git repo, and then run `npm link` (again, with the patched binary, mind you) to know that you're using your local git clones instead of the arbitrary resolution that npmjs would provide.
Your understanding seems to be pretty good. There are more advanced features of webpack that are worth looking into such as code splitting, but you seem to have a very workable setup. People say node.js is for server because many people do use it to serve their content. You certainly don't have to. In fact I'd say managing your client assets is where it excels the most. There are many other viable ways to serve your content. There isn't a whole lot out there that can accomplish what Webpack and babel (Or various other options written for node) can.
Right! That is why your conditional checks if 100 % prime == 0, and if it is, adds it to the result array. 
Wow, that actually sounds... really easy to implement. I still want to get a good grasp of how I'd implement the Sieve of Erasthotenes just for curiosity's sake, but based on your bringing up concats and binds and all that (which flew way over my head) I may need to be on a higher level before tackling that one. Thanks!!!
Some terminology: * Node: Stand-alone javascript V8 engine with some built-in APIs for doing things like reading files. Run javascript almost anywhere. * npm: **N**ode **P**ackage **M**anager, just allows you to install/update/delete dependencies for your node projects * Babel: A *transpiler* which is able to turn ES6/7 code into ES3/5, which can run more easily in the browser. Modular enough to support other uses. * Webpack: A *module loader* which allows you to split your javascript files up, have them require each other, then have them be generated one or more large files with all of the javascript properly organized so that by the time any piece of code runs, all of its dependencies are loaded and ready to go Node allows you to run javascript as a desktop scripting language. If you want to, you can also run servers with it, and there are several popular libraries (express, koa) to do this. However, this can also just be used to "only" bundle up and build out your javascript. From my understanding of what you've said, you are not using these tools incorrectly. Node is just a very general tool.
I always liked the [react howto](https://github.com/petehunt/react-howto) on this subject, which amounts to "keep it simple, stupid". Use react, and only react, until you are feeling a problem that can be solved by the next "step".
I highly recommend you watch [this video](https://www.youtube.com/watch?v=8aGhZQkoFbQ), it will almost certainly clear up any questions you have about the event loop.
And then browsers can optimize the most commonly used services by handling them locally increasing speed and lowering band... wait a second. They almost got us to create a standard library. We've got to keep a better eye out.
Wow. Desperate-for-attention bloggers are jumping all over this one, aren't they?
So I had a quick glimpse of the JS code on my phone. I would like to state that your logical conditionals are badly implemented. Your conditional statements check Fahrenheit first then Celsius. What I mean by this is that logical operator '||' checks the left conditions first and exits on the first 'true' value. So if your Fahrenheit is set to a certain value and not reset when checking for Celsius values, the code will generate unexpected behaviours. Possible solutions are you set a '0' value to a temperature variable when one is not in use, or as someone else already suggested, use one variable to check after converting the value.
the logout button is up there ^
This is a weird comparison, namespaces and modules are not really designed to do the same thing. Namespaces are there to basically allow you to manage having only one global scope for all of your types, and cannot hold things like bare functions or arbitrary code. A slightly more apt one would be to F#'s modules, if we're staying in .NET land.
You know, that's actually partly what I had in mind react-wise when writing. Esp. the "you don't need flux until you really do" section :)
My last job I worked at a ad tech company doing an app that was working on real time bidding, site funnel advertising and big data analysis for some large financial clients. Stack's "problem" has been documented and admitted by them numerous times, they chose C# because everything is a nail and they didn't want to reskill.
That doesn't really sound like it's on the same scale as stack's sites. What don't you like about C#? What do you think they would have been better off using?
and does the path in the URL stay the same? (i.e. not become /index.html as in a redirect)?
how's indexing going? is google able to pick up javascript-generated content for pages that aren't the index page? Google supposedly is meant to be on point now with rendering javascript on their servers and parsing that now. I.e. server side rendering is so supposed to be unnecessary now. I don't get the sense that this is solid yet (or there would be no hype about React server side rendering), but perhaps for a basic page-based site, google can properly render your javascript and discern the pages. Like, for a basic amount of javascript based on *history.pushStateState()*, google can figure out what the pages are. Basically, if we can pull this off, for a larger number of projects we can forgo a node server. But if your solution only goes so far as rendering the right content to users, but to google's crawlers only ever displays the content of the homepage, then having a large library of content/pages won't do much in search engines since their text won't be picked up. 
What is the exact reason Selenium won't work for you? If it is mobile web or mobile app, there is Appium. Philosophically, testing without a layer (e.g. webview) is not considered E2E test. Such test is usually called integration test where I work.
"lawyers banging on your door" can potentially mean 100k+ expenses.
You can use a 6to5 transpiler.
Agreed, IP law is a mess
Yes, it's a joke.
&gt; C# was a bad platform due to being locked into Windows This is biased crap, and wrong. C# is an ECMA standard and there was at least one other implementation of the language (Mono). Xamarin also allowed for cross-platform software. &gt; it had no ability to use modern dev ops tools and modern scaling techniques. What? You're telling me every large C# site ran on a single server because there were no tools available, and it wasn't possible to scale out any .NET services? &gt; Stack has written blogs upon blogs Sources, please, that show their blog posts were about avoiding C#. Otherwise these blog posts are simply them sharing their experience. &gt; to instance as little objects as possible. This is good practice in *any* language. Memory allocation is expensive. &gt; C# only got better because it could finally run on Linux More biased crap. This didn't change C# in the slightest. It's great Microsoft is embracing Linux, but let's be real here. &gt; and you could take advantage of virutalization, orchestration, configuration management and containerization to the fullest You always could &gt; Before 2016 I would never have recommended C# because of how tied it was to Windows. More biased crap. This does not discredit C#.
Maybe you shouldn't randomly install foreign code prior to making sure you know what it is...?
&gt; This is biased crap, and wrong. C# is an ECMA standard and there was at least one other implementation of the language (Mono). Xamarin also allowed for cross-platform software. &gt; Have you even used Mono? Anything not under ECMA has buggy and sometimes different behavior than .NET. MS fucking stopped documenting the standard because of Mono. This is basically the reason SO never moved to Mono. Likewise you need someone with highly specialized skills to set up the basis for that codebase. Beyond the skills SO already has it's just foolish to put yourself in that corner, both as a company and as a professional. &gt;What? You're telling me every large C# site ran on a single server because there were no tools available, and it wasn't possible to scale out any .NET services? Call me back when Windows has real support for seamless configuration management from ground zero, containerization and orchestration. Those are modern tools, Windows is stuck in the early 2000's in terms of how it stacks up for administration compared to modern Linux/Unix environments. You just can't compose Windows machines automatically like you can Linux. &gt; This is good practice in any language. Memory allocation is expensive. Yeah, except in an OOO language you end up not having any kind of organization, and you just have god utilities with harder to compose functions because you're saving N front end objects by not putting it into it's own class. You can't have lazy functionality, because thats N front end objects. The way their code is written is really fucking tight, to the point where it would be infuriating working on it. It's like how using long/short jump on the Linux kernel is standard but you wouldn't code an app with jumps because it becomes a nightmare to maintain especially among your average Enterprise programmer. &gt;Sources, please, that show their blog posts were about avoiding C#. Otherwise these blog posts are simply them sharing their experience. They were sharing their experience, but the point is what they were sharing the hard ship of actually doing what they were doing in .NET that is beyond any other language. &gt;You always could Yeah fucking right, show me any Kuberantes deployment that used Windows .NET dated pre C# on Linux. Show me any Puppet, Chef, Salt, or Ansible repo that allowed for 0-to-100 instancing of servers. Hell show me anything that isn't loading cloned images into a hypervisor server. Anything that is actual service composition.
&gt; `left-pad.io` is 100% REST-compliant as defined by some guy on Hacker News with maximal opinions and minimal evidence. Haha fucking savage.
errr ok.. well mine does.
Linting error: double negative.
LOL
omg Im still reading and sinking these info in but thank you so much for taking your time to explain all of this to me. I tried to hard to learn it online but I just cant find info like these. These explanation probably saved me days of headache. Thank you so much!!! thank you :)
It makes sense though. XML is declarative. And that kind of goes hand in hand with functional programming. It may seem wired at first but that's what everyone said about jsx too. 
It was a joke :P...
i guess you could say you kiked it wait shit no
It's a perfect meaningless project to get practice doing so! Just saying. :)
define-var.io REST API to manage variables in your environment! Simply genius. And yeah. It provides Analytics data as well.
love the smell of eval in the morning
The original path stays in the browser
Noone ever references other systems like this from other languages in this whole discussion and how things are handled there. That would be an interedting blog post. I.e. CPAN from Perl. The lesson JS community needs to learn is not to complain about a free service in the case it's failing. If one module on CPAN doesn't work, well you install the module from some mirror manually. But you don't run around in circles and make a fuss about it on the interweb blogs like this, acting like being surprised that a single point of failure bit you in the butt.
Hit the nail on the head. Monolith libraries aren't the Be-All-End-All-Solution™, and Microlibraries aren't without merit (even teeny tiny ones) Software is complicated. Just be a bit diligent in how you make your choices, that's all.
It gained a lot of early traction and a lot of tutorials were written on it. When I began learning the stack in late 2013, people were already saying to stay away from MongoDB. Personally, I prefer PostgreSQL with an ORM. JSONB (as a data type) is the best of both worlds when you need document storage.
95% of the tutorials out there for javascript use mongodb for a database.So anyone who learns js online starts with mongodb and think its the only solution for persistence.
Who would use something called PEAN?
PKRN... No flow.
http://require-from-twitter.github.io/
http://m.imgur.com/L7YmUWM
I don't know a lot about databases but it seems like the idea du jour that MongoDB is the worst thing since unsliced bread. Haven't really seen much to back the claim up but I'm curious. Meanwhile I've started working with RethinkDB in a project and boy, I think it's pretty great so far. ReQL is fantastic, especially when paired with [RethinkDBDash](https://github.com/neumino/rethinkdbdash) and [RethinkDB-init](https://github.com/thejsj/rethinkdb-init), both of which substantially reduce boilerplate in Node. Haven't even started exploring the realtime aspect of it. But it does seem like compared to Postgre speed would be an issue for large datasets.
You have a bug. When i is 2, it will say: &gt; 2 bottles of beer on the wall, 2 bottles of beer. Take one down and pass it around, 1 bottles of beer on the wall. ... "1 bottles". Rather than duplicating the phrase again, think about ways you can use the same, single phrase but including the right version of "bottle" :)
I like NAPE. Though, stack order should make it more like PNEA. Of course, now Express is "dead", so maybe it should be PANK(oa). Mmmm, bread crumbs.
http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/
all the SQL stuff like relations, cascade on delete and zillions of other SQL features has to be implemented in your API itself. Which sucks if you actually need those features.
"Pea-kern" stack is pronounceable.
Regarding style: It is important to make code readable for future humans as well as machines. This is why we use a lot of formatting like indents and whitespace. We also debate whether to use the opening curly bracket in the same line as the if clause (most say yes). We comment things, but not if they are self-explanatory, and to variables we give names that describe them well.
A lot of crying
People are still saying that about JSX. :) Functional programming in of itself intends to be declarative as possible. You might *say* that this: &lt;reduce array = { [1,2,3,4,5]} initial = { 0 } func = { (a,b) =&gt; a + b } /&gt;(); Is somehow supposed to be better than this (haskell): sum = reduce (+) Or this (ocaml-like, bit more verbose) let sum = List.fold_left (+) 0 But it just looks like needlessly verbose noise to me (as all XML). It's *really* important that your pieces for defining and calling functions is very light in functional programming, because you're going to very quickly start composing them around. As for dealing with the position of arguments being inconvenient in JS by convention, there's some interesting solutions for that. My favorite so far is livescript's ideas, which borrows from F#: require! { { map }: _ } # using lodash map with the forward pipe operator and placeholder variable [1 2 3 4] |&gt; map _, (+ 1) # [2, 3, 4, 5] Which can be chained arbitrarily: [1 2 3 4] |&gt; map _, (+ 1) |&gt; map _, (* 2) # [4, 6, 8, 10] Or composed: [1 2 3 4] |&gt; map _, (+ 1) &gt;&gt; (* 2) &gt;&gt; (- 1) # [3, 5, 7, 9] 
It's good for practicing operators you don't normally use. Thumbs up.
I agree, but I think it's all relative. For something like lodash, I'm happy using a \^, and probably will even use \~. I'm not really worried about it. For something like expressjs, well, they've actually had breaking changes in minor releases (I've experienced them). So I use at least \^, but usually choose a specific version. Plus lodash is a pretty straightforward utility library, but expressjs is a complicated monolith. Basically it all boils down to how complicated the library is, and whether I'm going to read the release notes. If I think I *should* be reading them, by nature of the library, or the authors, or the critical path of my code, I use specific versions. If I'm not (i.e. lodash), whatever, minor versions are fine. 
&gt; Express is hopelessly uncooperative when dealing with promises. How so? I've never had any issues using Promises inside of the Express framework. All my 'controllers' / 'models' / libs are promise'fied (or accept callbacks). I haven't used Koa yet, but the generator functions look like they'd clean up the code quite a bit. 
&gt; why not something like Postgres? When a beginner JS/Node developer needs to persist, MongoDB (and Mongoose) will get you to `Hello World` faster than trying to learn SQL as a DSL. For the most part, a MEAN developer is just writing apps that consume some RESTful API, removing the details of T-SQL, relational databases and rigid schemas can help them get there faster. Is it the _right_ tool for the job? Probably not for production applications. But then, how many of your applications make it to production?
&gt; for a programmer who knows nothing but JS, to insert and retrieve data I always shudder to imagine beginners attacking databases with 0 knowledge of relational DB design. I'm all for smoothing the learning curve and all, but that's setting yourself up for failure. I mean, if you're able to learn Angular, you're able to use MySQL.
Hi there, so this is the sort of info each element has to work with: &lt;div style="padding:15px;background-color:#000;" data-reactid=".0.1.$value/=1$value.$=10.$=10.0.1.$/=11"&gt; &lt;button style="display: inline-block; height: 30px; margin: 2px 2px -2px; padding: 10px 10px 10px; border-width: 0px; border-radius: 4px; font-size: 12px; font-weight: bold; font-family: azo-sans-web, sans-serif; letter-spacing: 0.6px; cursor: pointer; transition: all 0.2s ease-out; -webkit-appearance: none; color: rgb(110, 255, 255); box-shadow: rgb(33, 66, 136) 0px 0px 0px 0px; background-color: rgb(255, 130, 119);" data-reactid=".0.1.$value/=1$value.$=10.$=10.0.1.$/=11.$createButton/=1$createButton"&gt;Create Data&lt;/button&gt;&lt;button style="display:inline-block;height:42px;margin:0;padding-top:11px;padding-right:30px;padding-bottom:10px;padding-left:30px;border-width:0;-webkit-border-radius:4px;font-size:13px;font-weight:bold;font-family:'garamond', sans-serif;letter-spacing:0.6px;cursor:pointer;-webkit-transition:all 0.2s ease-out;-webkit-appearance:none;color:#eee;background-color:transparent;" data-reactid=".0.1.$value/=1$value.$=10.$=10.0.1.$/=11.$cancelButton/=1$cancelButton"&gt;Cancel&lt;/button&gt;&lt;/div&gt; Now, when I first wrote the tests it looked more like: &lt;input id="title" maxlength="255" type="text" placeholder="Enter a title" style="width: 100%; margin: 0px 0px 12px; padding: 6px; border: none; border-radius: 4px; font-size: 14px; box-shadow: none; transition: all 0.15s linear; resize: none; height: 42px; background-color: rgb(234, 234, 234);" data-reactid=".0.1.$projects/=1$projects.$=10.$=10.0.1.$/=10.$form/=1$form.$/=10.$inputText/=1$inputText"&gt; Though there is some react creating this pop up, I can still hit the input id="title" with Selenium. I can't do anything with things like ".0.1.$value/=1$value.$=10.$=10.0.1.$/=11.$createButton/=1$createButton". Clearly I'm wrong that Selenium *won't* do this, but I'm not sure *how* to do it :). 
I would play Dota 2 to pass time Oh, wait... &amp;nbsp; Seriously I've always thought about this, and instantly stopped thinking about it each time because the answer is unpleasant
The problem is that applications depend on libraries. As an application maker I also need my transitive dependencies to be stable. 
 I have a usb stick for the bad days for packages I use if I ever loose connection. Another one for an OSX image in case I need a clean install on my computer. But I have no plan B for an electricity shortage yet :D
objects, orm
Lodash, gulp, grunt, browserify, babel and other really popular libs need to introduce the LTS model of support. With LTS, 2 versions are maintained (cutting edge version, and stable version) and the stable version has a EOL/release schedule, this way people who care about stability know which version to upgrade to, and how to optimize their resources for EOL refactor. 
I'd love to. Where, in the code I pasted in the comment above, should I have Selenium look?
To be fair, Mongo has gotten significantly better recently with its new storage engine options, like WiredTiger. It also still has significantly better performance than other NoSQL document databases, like RethinkDB, despite them crushing it in other ways, i.e. features, query language, scalability, safety, etc.
Not teenagers or those with a teenage mentality? I think you answered your own question.
Right, I mentioned that it wasn't a big deal especially if migrating from micro-libraries. As for the other points, I was writing from the perspective of download size for the client which is particularly important on mobile devices or if the end user doesn't have a good Internet connection. I'm not really concerned about build time or anything like that.
...or hold it to find out.
ahem, yes the argument actually applies to all no sql db, but as mongoDb is more used than others, mongo also happen to be more infamous.
I'm sorry I'm not sure what you're asking. I get selenium to look at ids, classes, sometimes xpath (though it should be avoided). Why do you need to use the `data-reactid` property? Just use Selenium as if it didn't exist. 
i hope you told those developer that some npm package can delete their entire filesystem while they wait for npm install to finish.
Koa feels like an experiment, to me. Koa 1 uses generators, Koa 2 uses ES7 async. So all of the generator based yield this / co that code you're writing today will be oldschool and out dated once the Koa 2 train rolls in. My biggest concern would be: will it be easy to find new devs to work on that old Koa 1 generator based code I'm building my product with? The ecosystem around express just feels so much more established, with far more developers familiar with it. The question, to me, isn't whether or not certain things in express are broken in comparison to Koa, it's whether or not they are broken enough to abandon a pretty big ecosystem in favor of the hot new thing.
Mobile support?
just skimmed it so forgive me if im not correct. practical: * your using 3 for loops through `dots` each frame, this is probably the bottle neck, use 1 loop and get almost 300% more speed * use requestAnimationFrame * use x|0 instead of Math.floor(x) * `pixels = ctx.createImageData(ctx.canvas.width, ctx.canvas.height)` if possible run this FN once, cache the empty image data (slice?) and copy it each time, ex if array`pixels = cachedpixels.slice()`; not practical: * use pre-calculated "random enough" fns, carmack made a FN that returns good random #s for doom (it just cycles through a list of 64 random numbers) * dont use classes/objects * can maybe optimize the math in spots that use division and/or try not to use floats, `foo*1000|0 / grav*1000|0`, some other tricks here im forgetting too. (|0 is math.floor) * could precalculate all of the possible math in some spots, `foo*dot.mass` 
I am running into problems too. Does anyone know of any online resources about this?
thanks for the info. The situation is a bit better than I thought. I assume that unspecified transitive dependencies just 'float' though.
 npm install -g sort-my-shit-for-me
I disagree, the points he brings up with implementing your own code are the same problems that can exist in micro-dependency codebases that you aren't maintaining. 
Looking for sliders like [these](http://www.chadmarchpdx.com/ontap/keg/1)? [Here's](https://github.com/marchchad/chadmarchpdx/blob/master/public/css/style.css#L167) how I did it.
I thought a bit more about it. I think the problem is not npm, but the expectation people have of free services and the mayor reaction to an error on npms side. npm is free to shut down their "Open Source" service any time. npm is not a community driven project, and while npm may read reactions to their actions all over the internet now, they are not obliged to change anything - maybe their terms of their Open-Source service w.r.t. the renaming policies. And due to the change in those terms the users may be free to go. Probably it's a surprise to npm that they became such a central important service, that deleted packages cause such a problem. But users/uploaders/maintainers should have the right to delete their stuff any time - at least IMO. I as maintainer should have the right to pull out badly designed packages (maybe after waking up one morning, realizing everything I did was crap) any time, it's my name on it and if I don't want npm to further make it available it should have to comply. If they change their terms of Open-Source service to deny me that right, well, thats quite a statement. And even then, I should be able not to accept their TOS and delete my content.
Marketing and hype, mainly. I frequently see people coming into #Node.js who legitimately believe that a "stack" is necessary to be able to develop an application. Not because they're 'dumb', but simply because that is all the input they've ever gotten. This is perpetuated in particular by different 'hackathons', which are still heavily sponsored by Google (who created Angular) and MongoDB.
I used Koa everyday in worked and I love it! Here is a cool short article talking about moving from generators to async/await in Koa: http://chrisgriffing.com/coding/javascript/2016/03/14/koa-js-a-happy-path-to-async-await/
I think you're doing just fine actually. What I would have told my younger self in regards to interviews: * Learn the weird parts of JS properly: Scoping, Prototypal Inheritance, Closures.. I had a vague idea of many of these concepts, but never fully got them until recently. They are dead simple once you grasp them, I wish someone told me that years ago. Amazing video I learned from: https://www.youtube.com/watch?v=Bv_5Zv5c-Ts (it's basically the weird parts for dummies, super slow, isolated to only the necessary stuff without too much distracting boilerplate code around them) * Go through some of the example interview puzzles. Not crazy stuff like the pascal triangle. here are some I encountered over the years: * Attaching little helper functions to Number.prototype and String.prototype (reversing a string, etc.) * Something where you need call/apply/bind * Implement a curry function from scratch * The classic for-loop that attaches click handlers to elements and logs a counter * Difference between null and undefined * How to get basic OOP behavior (function constructors and the new keyword are actually mind-blowingly simple once you take the time to dig into it. It's a trap when coming from other languages, JS was supposed to make it look familiar but doesn't really do that much under the hood) * The event loop concept (what is your JS engine doing when nothing happens on a page/a node server is not getting any requests?) * The different approaches to dealing with asynchronicity (callbacks, promises, observers/polling) * more senior JS people LOVE the new Array methods and functional programming style: map, reduce, filter, ... You basically would rarely see any old-style for-loops in these codebases.
if we are talking in philosophical terms, then yes you are absolutely correct. I can even assume that npm did what they did because they got afraid from kik's threat. but we live in real life and people's livelihoods are depended on it.(including npm's). whatever you may believe but know that at the end of the day, npm is a company which provides free services and paid ones. the rules they broke were part of their "agreement" with users. maybe being a free service, they can get some sympathy, but they can not get free-out-of-jail card for their blatant breaking of agreement. nor will npm's role in this incident be ever forgotten. until npm gives a formal apology and bans the kik module --giving ownership to azer at this point is pointless-- from their registry, this incident will not be considered concluded. 
better yet, word = number == 1 ? 'bottle' : 'bottles';
Well I guess anecdotal surveys are the gold standard. But you make a valid point, when enough people don't understand the definition of a word it will change - just like "literally" changed because enough people forgot the meaning of "figuratively". As for the 2% English speaking adult Israelis, it was from Wikipedia (https://en.wikipedia.org/wiki/Languages_of_Israel). I thought the number seemed low, but I assumed my first-hand knowledge of English speaking Israelis was subjectively skewed to young/affluent people. Anyway, the remark clearly offends you regardless of whether the speaker meant any offense at all - which speaks to your sensibilities. I've tried to inform you that the phrase is not gender specific by definition or target audience, it just happens to use gendered pronouns as an artifact of the gendered grammar of Old English (https://en.wikipedia.org/wiki/Gender_in_English). Personally, I would suggest that you just [man up](https://www.google.com/search?q=define+man+up&amp;sourceid=ie7&amp;rls=com.microsoft:en-US:IE-Address&amp;ie=&amp;oe=&amp;rlz=&amp;gws_rd=ssl) about it. 
Not simple enough for Safari, it seems. Other than seemingly-randomly to black or white (on the text itself, presumably for if it's showing a light or dark colour code), it doesn't change colour.
I see what jew did there.
We use Mongo because we we need a document store that is flexible for each customer's unique data set. For us, no to collections are the same. It works pretty well. 
I was going to mention that but it avoids the more obvious question which is what is he testing? It almost sounds like he is testing that the HTML equals some string, which is probably very brittle 
I think the problems are the same, but then they only have to be fixed once for the *entire community*. You can have your dependencies fixed without even realizing there were a problem just because someone else noted and fixed it. This might have some cons in itself (the breakdown that happened is an example), but I believe it's still better than relying on copypasta code.
Ahhh, I was basing that off of the windows calculator, which gives you a division by zero error. But hey, whatever works, it's a nice clean design you have there.
On what is this assumption of yours based? There are lot of performance tests of mongodb vs rethinkdb but almost if not all of them are wrong. You need to know rethinkdb in order to use it properly and efficiently. E.g. mongodb by design does not acknowledge writes while rethinkdb does just that, by default, it can be switched off ofcourse, for each query.
Really? At the latest version is all right. Can you tell me your Safari version?
From the top of my head for looking at your code for 1 minute: 1. Do not use classes objects. Use simple jsons at most. 2. Have a few stateless functions that accept each json object 3. Do not use Math. Use simple hand written calculations 4. Try to use bitwise operators where possible 5. Try to use setImmediate instead of setTimeout, this should speed up things a lot 6. Bonus: try using memoization for the calculations, this should help one bit Good luck
I don't know enough about RethinkDB to comment on that, but I think the first part of your comment is the most compelling. MongoDB has had a lot of significant problems, as many new technologies do, but it's still being developed. A lot of people have formed strong opinions on technologies and ignore the fact that technologies change. "Why is PHP still a thing?" comes to mind. I personally enjoyed working with Mongo, and would use it again if I thought it was the right tool.
I was :( Glad you noticed it! I missed the streak and now I do small projects every now and then. Need to start the streak again. It was hell lot of fun!
Maybe you could add SQL to the stack and call it SNAPE? The Harry Potter reference adds serious nerd cred.
NoSQL Datastores are actually pretty awesome. I wouldn't switch to a relational DB unless I specifically had a need for it. To be fair, I also probably wouldn't use Mongo, but at the time (2 and more years ago) it kind of re-shifted the focus toward the benefits of document stores in a big way while everyone was trying to shoehorn SQL as an answer for all of life's problems -- and a lot (not all) of the complaints against MongoDB are either complaints about distributed systems or NoSQL in general, or arose due to misuse rather than broken functionality. Like I said, I wouldn't pick MongoDB today, but a lot of people making broad statements about SQL vs NoSQL were just bitten by buying into the hype and jumping headfirst into a system they didn't fully research, or are just afraid of learning a new datastore. Couchbase, Rethink, Elasticsearch, InfluxDB, Datomic, are all pretty awesome.
And what are we supposed to do with that?
Interesting... TY
Koa 2 is an experiment absolutely until there is no longer a dependency on babel. Koa 1 was fun to use but it sucked having to thunkify everything. 
Nice idea!
loot and pilage
You guys are awesome! Thanks I understand it now. "this" will refer to the object that owns the executing code. So by doing "var self = this" we are preserving the current context of the "this" keyword before it gets automatically changed to the window object since the foreach is a built in language function and owned by the window object.
Yep. I have to laugh at the redditors thinking postgreSQL is equivalent to Mongo in general while stating Mongo is only for noobs and people who don't know what they're doing. Talk about who is calling the kettle black but this is reddit after all.
1) If you do n/0 and get infinity, pressing the next button should clear the screen. Currently you'd get something like `Infinity5/2` which results in NaN. 2) Add `user-select: none` to the buttons so that they don't get awkwardly selected when the user doubleclicks something 3) A nice GUI improvement might be to add some sort of visual feedback when you're pushing the button down. Not really needed most of the time, but given that pressing buttons is the sole purpose of this site, it might be worth it. Especially since the action occurs when the user lets go of the button, so pressing down feels unresponsive (because nothing happens) 4) I'd replace overflow-x: scroll with auto, because the empty scrollbar is kind of ugly. Only problem is the box would jump around a bit when an overflow happens. So I guess it's a matter of opinion
This is probably an issue with your manifest file. Have you included your website under permissions?
I'm not :( But listening to trippy music + watching that, gave me arguable better trip than weed. (DISCLAIMER: I've no fucking idea what kind of trip weed gives) 
If you click the "Star" links, it'll take you the repository's page and will NOT star it.
I can understand that type of decision, but isn't part of the notion of being *general* trying to fit a broader set of use cases? I've been steering people away from using Lodash as a general lib collection since I made that old PR (and pointing people to he). Now I don't know what to tell them. "Try it, but if you run into something it won't do, use something else." is an awkward piece of advice to give them instead. What I had taken away from the discussion in that PR was "Use Lodash for what Lodash was made for."
Mom? I told you stop reading my posts!
Good to know. Weird interaction though.
No need to slice/copy image data. You can just overwrite each item every time. (Maybe, im on phone and havent looked too closely, so might not true in this case). Thats a great recommendation though. Those are all good recommendations. Edit: Looking at it now, one minor change would be required here. Since not every pixel is being set, there would need to be an initial loop to zero out the pixel array. Otherwise, each frame would bleed into the next one (which is kind of a neat effect in this case, actually).
Personal opinions aside, I get the impression Hapi is a more common Express replacement than Koa, so maybe PHAN? I guess in stack order that's PNHA... 
Using Restify over Koa would give you PRRN?
I'm bored so here's my version: &lt;pre id="output"&gt; &lt;/pre&gt; &lt;script&gt; const pluralize = (number) =&gt; { return number === 1 ? 'bottle' : 'bottles'; }; const stanza = function (number) { return () =&gt; { output.textContent += `${number} ${pluralize(number)} of beer on the wall.\n`; output.textContent += 'Take one down and pass it around.\n'; output.textContent += `${number - 1} ${pluralize(number - 1)} of beer on the wall.\n\n`; }; } function song(bottles, timeout, output) { bottles = bottles || 99; timeout = timeout || 500; output = output || document.getElementById('output'); const totalTime = 500 * bottles; do { setTimeout(stanza(bottles), totalTime - (500 * bottles)); } while(--bottles); setTimeout(() =&gt; { output.textContent += 'No more bottles of beer on the wall, no more bottles of beer. :('}, totalTime); } song(); &lt;/script&gt; Give it try, if you have questions feel free to reply with said questions.
Cool stuff! One thing: 3/10-1/10 = 0.2000 It should be just 0.2
(It was sort of a joke to go for Panko. Express is still fine for most people.) Koa is usually touted as "the" replacement for Express. I think Hapi is much more mature, though. I'm strictly a front-end guy lately, though, so my experience is somewhat limited.
[of course](http://i.imgur.com/W2hq8Bw.png)
I don't think the advice is that awkward. Both responses seem reasonable to me.
At the moment I think that's a bit too much process. Lodash follows semver so publishes patch x.x.n releases for bug fixes, minor x.n.x releases for features, and major n.x.x releases for back-compat breaking changes. Adoption of new major versions has been pretty rapid as well. By May, `^4.0.0` will be in the top 10 most depended upon packages and by the fall it will overtake `^3.0.0`.
First of all thanks for taking time to write this massive feedback. Appreciate it, Magixxxx! 1) Agree with you - clearing screen is must. 2) Agree. Did that in another project, but somehow missed in this :( 3) Nice idea! 4) Are you getting a scrollbar? Which OS/browser? I am on Mac and I am not getting a scrollbar unless number is big enough. Thanks again :-)
They do. Koa is quite nice to work with.
With the best will in the world that's an *incredibly* stupid response. For a start most of his significant criticisms are cited, and when the list of criticisms of a **database system** begins with "it loses data", it's debatable whether any other points are even *necessary* to include.
I'd wager PostgreSQL's JSONB would work even better for you.
That's [security through obscurity](https://en.m.wikipedia.org/wiki/Security_through_obscurity), which is discouraged.
NAPE NATION 
Does anyone know what algorithm Javascript uses when calling the sort method? 
100 is far into DB-specific stuff. Every DB has their own way to write functions, triggers, upserts, etc. The 90% of stuff though, you only need to understand basic schemas, foreign keys, transactions, and crud operation syntax. 
* What error are you seeing? * How do you know it's a security issue? Do you *know*, or are you guessing/assuming? * What code are you using to make the request? * What have you already tried to solve the problem? Also bear in mind that this is almost certainly not a JavaScript problem so much as it's a Chrome extension API problem, so if you try a Chrome dev community (and next time include the above details!) you might have more luck.
Well cited, but most of the sources are blogs. Not really sure what you would source for this kind of thing though. 
why is that? edit: since we don't actually need a relational db
This is done by major Linux distros, NodeJS, NPM, and Firefox. It just funnels users who know they won't have a chance to upgrade to certain versions to lesson exposure of potential breaking bugs. Let's say a security bug is discovered in Lodash (unlikely), Lodash will be pretty much forced to push an update for older versions, or risk those old version being forked (e.g. Heartbleed). If there's no LTS, the distribution of users on old version would be widely distributed. With LTS, there would be a lot more users on LTS version, than non-LTS versions. 
There are now *relational* NoSQL databases now? 0_o How long before these relational NoSQL databases can be queried using the SQL syntax...
How about points from the other side of the fence? Lots and lots of people use and love MongoDB so one anonymous (sort of) guy's article showing one sided views is worthless but I'm sure you'll run with it.
Lose is spelled l-o-s-e
SQL is friendly. Done.
But...but...[MongoDB is webscale](http://www.mongodb-is-web-scale.com/), dammit! edit: that article Sjoerder posted is actually a good read!
that's interesting, thanks. 
Why not move to Koa? Hasn't Express been abandoned and dramatized? PKAN
When I made a Calculator Applet for the Cinnamon Desktop I just plugged in http://mathjs.org/ It's a fairly large piece of code but it supports a massive variety of features. If you want to make a scientific calculator, it's worth a look. My calculator is on github at https://github.com/Lerc/smallcalc 
Proper management of data is important. That means well-defined structures, schema and relationships. MongoDB makes data management feel easy because it just forgoes those things. But when you get to any higher level of complexity, you hurt badly without them. For some work I was doing in robotics, we began with MongoDB, which was nice and easy and cheap to get into. We didn't need someone who was a veteran in databases. I liked that a lot. But we soon had to refactor to PostgreSQL as our system's complexity grew. We were being burned very quickly by a lack of relational structure in particular. We've now got about 100 tables 1 year into development, which in the greater picture is actually still very small compared to where we're hoping to go. I think for cookie cutter projects where a 1-person team has been hired to make yet another website X that has a clear upper design bound, something like MEAN is perfect. Don't be complex if you don't have to be! But it definitely limits how you might evolve the product.
But crazy flat file manipulation won't get you past an "MD1" type of database theory. I could see maybe an MD2. But MD3? Nope.
Why do you need an RGB generator on your phone?
Personally, for me MEAN is just like REST - a container name. You can change underlying tech as per your need So, MEAN must use Database, A Backend framework, a frontend framework and Node.js But I still prefer keeping backend and frontend separate. 
when you get up to really high numbers, it results in 1.123456+e78 (example numbers) as it should, but then if you try to multiply that number, it just multiplies the 78, rather than the actual number. 
http://vikaslalwani.com/projects/snake-game/ Man, that's addictive...
usign jquery: $('.makered').click(function(el){ $('body').css('background-color','red'); }); $('.undo').click(function(el){ $('body').css('background-color','white'); });
Just a few more iterations and we can do it! "Pokemon" here we come!
So how is Head First treating you?
I'd be happy with 80
It's actually cool to have a ton of little projects like that, wish I had as much imagination aha :)
Mind if I ask what jQuery is? (Sorry. I'm new to everything besides HTML and CSS.)
Because mongoose is easy to understand and use.
I don't use mongo and I don't passionately dislike it either, so I really have no dog in this fight. However, that "one anonymous guy's article" is fairly well-cited, and you didn't actually offer a single counter-example - instead you went straight for an irrelevant ad-hom.
If you're on Windows them something like [WampServer](http://www.wampserver.com/en/) or [XAMPP](https://www.apachefriends.org/index.html) is an easy way to get MySQL installed (along with some web-based admin tools).
Idk how it's in italian, but it's literally same in my lang: Word = "Butel" + (i==1?"is":"iai");
&gt; I'm all honesty, if your data is quite relational you're making a mistake with Mongo, and that's coming from someone who tries to find excuses to use it. Don't forget that data that doesn't *seem* relational can easily become relational given a bit of time and some broken assumptions. By using a non-relational DB upfront you're locking yourself into your own assumptions.
How is this solution better than: word = number == 1 ? 'bottle' : 'bottles';
&gt; Apparently putting Webpack and Socket together is something quite advanced Webpack dev server uses websocket to notify browser to reload when new build is finished. If you need your own socket.io, just use a different port and listen there. It shouldn't be hard.
Some of the answers could be a lot more concise if functional constructs were used (e.g.. `map`, `filter`, `reduce`).
You shouldn't inject the style rules directly. Instead, toggle a class on the body. Try this out: **css** body { background-color: white; } .body-style-angry { background-color: red; } **js** var markered = document.getElementsByClass('makered'); markered.forEach(function(element) { element.addEventListener('click', toggleBackground); }); function toggleBackground() { document.body.classList.toggle('body-style-angry'); } So in the JS we get all elements with the class 'makered'. Then we assign an event listener which fires the function toggleBackground anytime that element is clicked, and the toggleBackground function will switch the class of the body thus switching the background color. Why do we do this instead of injecting style rules directly? Well first off it'd be more effort, but in general you want to keep your look separate from your behavior. So all styles should live in css and all behavior in JS.
Just put "undefined" if divided by 0
For the binary one, if you're gonna use toString, you might as well use just say Number(x).toString(2) to convert from dec to binary
Awesome, thanks! Will have to do that now! Looks like it is in popular demand :-)
Haha..thanks!
Our internal questions are documented with both functional and iterative approaches. I give bonus points for functional approach though :)
Use wolframalpha instead. 
awesome. Good job Kamran!
lambo4bkfast, you are not going to like it: http://i.imgur.com/ZzuO32Z.png
Read the fine print; "complex infinity." Look up what that means.
Ahh..got it! thanks :-)
I have the imagination, I actually have quite a few ideas written in different text documents across lots of folders, but I lack the motivation.
Shouldn't this: 'use strict;' Be this: 'use strict'; I'd definitely get JSHint going in your editor of choice.
Instantly! Wow! That's fast. 
That's fair. I've been writing and trashing it all over again. I'll post something to get some feed back. 
Exactly! Which is friendlier: select user.name, min(post.post_date) from user join posts on posts.user_id = user.id group by user_id or learning [an entire aggregation pipeline and a whole set of additional operators](https://docs.mongodb.org/manual/reference/operator/aggregation/group/) (or writing a whole custom map-reduce pipeline in Mongo's custom ES5 repl)? Fine, fine, maybe aggregation isn't fair. A simple query then: select name, email_address from user where isActive = true vs db.users.find( {active: { $in: [true, 1, "true", "yes"] } }, // need to check all possible combinations due to lack of consistent schema {name: 1, emailAddress: 1} ) 
Why does he need a RGB generator at all?
Here's my manifest as it looks right now. { "manifest_version": 2, "name": "CastroLink", "short_name": "CastroLink", "version": "1.0", "description": "Changes the font color for anyone that is on a minor league roster.", "permissions": [ "tabs", "http://games.espn.go.com/flb/*", "activeTab","http://rosterdobby.com/*", "background"], "content_scripts": [ { "matches": ["http://games.espn.go.com/flb/clubhouse*", "http://games.espn.go.com/flb/freeagency*", "http://games.espn.go.com/flb/trade*", "http://rosterdobby.com/*", "http://rosterdobby.com/static/*"], "background": { "scripts": ["background.js"]}, "js" : ["jquery.min.js", "content.js"] } ] } 
You're running into [cross-origin problems](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS). What you're trying to do can't be done.
&gt; cross-origin problems what part of what I am doing cant be done?
https://en.wikipedia.org/w/api.php?action=query&amp;format=json&amp;list=random&amp;rnlimit=13 is the getJSON link
I think they are saying it is better because it is more DRY. That's my guess 
Mandatory disclaimer: this is not serious and not safe.
Your documentation on github is using the word dice incorrectly. "a dice" should be "a die". Dice is plural, die is singular. http://www.dictionary.com/browse/dice 
Thank you. I was to forbid parentheses, but that could become too tricky because you have to know the priorities.
And I love issues, PRs and stars!
Just use a hidden checkbox and some CSS magic. No need for JavaScript here
Add some leading zeros when needed. Some hex values show less than 6 digits, when any of the RGB values is less than 16.
Same deal here. Each product configuration for the customers is pretty different and can be set up in an arbitrary manner, with config forms also being customizable. We have no real need to have to query different configs among different users. So for us MongoDB makes sense.
Are you high? Nothing you've said has contributed to the discussion at hand. You haven't tackled any argument. You've provided no argument of your own. You haven't even had an opinion of your own regarding the subject! All you've done is whine. May be the reason you keep hearing "ad hominem" a lot is because that's exactly what you're doing. Dodging the argument and attacking the person (commenting on a person looks, online name, words used, typos etc).
The conclusion wasn't to use a monolithic lib. It was to use Lodash modules when possible because yada yada.
Looks like you could put your download code in the onComplete function...
You shouldn't be interviewing based off of what other companies do. You should be interviewing based off of what your company needs. Asking questions from a list that you didn't personally create almost guarantees you'll never get the type of employees that you really want.
Well, his conclusion is kind of all over the place and contradicts earlier statements of his that "micro libraries" are good. Perhaps I should have stated that his thesis is strange, but that ultimately letting your build pull pieces from a dependency is good.
Did you read the article I linked you to? It expalins everything in great detail. In short: browsers refuse to load data from not-your-domain for security reasons. You can opt out of the security measures by using a special header, but you have to have access to the server to add that header (and you don't have access to Wikipedia's servers).
It doesn't contradict that. The gist is that by using a collection of microlibs (modules) under a trusted, stable, tested umbrella (lodash) you get the best of both worlds: small focused modules with solid support.
Other dictionaries seem fine with "dice": http://www.oxforddictionaries.com/definition/english/dice http://www.collinsdictionary.com/dictionary/american/dice 
Add an `:active` state to make the button press experience "feel" a little nicer and clicky-er. Other than that, solid work!
That V8 bug thread was a long and interesting read!
Only on reddit would such a thread continue on and on like this, building from nothingness. Get lost kid.
Unless you have a good reason to run the drawGrid function a thousand times each second (do you have a 1000hz display? Where can I get one?), you should change this line setTimeout(function() { DrawGrid(dots) }, 1); To this setTimeout(function() { DrawGrid(dots) }, 16.6); // 16.6 ms = 1000/60 = ~60fps
Probably, haha
You can get the currently active element with `document.activeElement` This can be anything on the page, so check if it's an input by checking `tagName`, probably also good to check that type is text. From there, you can modify the value -- set it to value + whatever your emoji text is.
Doubt anyone does, just wanted to see how it looked while I was browsing on the bus.
Shee-hittttt
...it's already bottlenecked to ~15fps, so this accomplishes very little.
Eh, something might catch your interest occasionally. It isn't really solving a problem, just opening different avenues to keep up with the industry I suppose?
Too bad IO.js didn't survive. At least then we could have PAIN.
I just see "undefined" where I presume the repos should be
I'm pretty sure it's because you don't have a mouse plugged in and /u/Magixxxx does, it's a browser quirk.
It even works in my chrome's console, so it's not just a coincidence of the babel transpilation. Though, I can't recommend you actually do this. 
I like the way you think :)
yeah
This is totally a suggestion because I'm bored too. So feel free to take it or leave it. The setTimeouts seems risky to me. It looks like it's expecting each printing to take less than 500ms. Is that right? I might not be understand the code, but in that case what if there's a million bottles and it starts taking longer to update output the longer the output gets? The browser will start backing up. Can the browser handle a million setTimeouts? Might be safer to use setTimeout as a delay in between each update. I think it would work if you had a method that called stanza then if bottles-- is still &gt; 0 it makes a setTimeout call that waits 500ms and then recursively call itself passing the new smaller bottles. 
I used this method to make a calculator when I was learning c++! You can split out into a lexer, compiler and evaluator and make it into a really simple introduction to how you would go about building a programming language of your own. 
TIL you can lock down dependancies within local gz files. Seems rational. I do want to adopt this! _but what if shrinkpack goes wild.. lol_
Not happening the way you want it, the only way a browser can write a file is if the user specifies where. ActiveX, like what you have here, is considered extremely bad practice.
Hey, thank you for pointing it out. I just fixed that and updated the release. You may update the extension.
While it was obviously very frustrating for Azer and I am generally in support of open source. The guy came off very badly here to me. The whole thing of taking his ball home in a big huff and knowingly causing huge problems for a huge amount of people undermines open source as a whole and make the guy gain a terrible reputation in my eyes. To just pull libraries and tell nobody or give no warning or fallback? It undermines open source totally. It's basically just unprofessional to think he can do that and not think of the consequences. Just take his ball and go home. He had his stance and stuck too it. Ok, I respect that. But his replies were childish. It makes him totally unemployable in the future. It means I'd steer away from anything with his name on it, knowing what will happen the second he disagrees or has a childish grudge which happens all too often in open source communities. I couldn't go to work tomorrow and have a disagreement with my boss or coworkers and just pull the plug on anything I have ever touched. I'd be fired on the spot and never get a job again. That's the problem in open source. It's free so I can do what I want attitude. Sure, you CAN. But if there's no level of trust or any honor system even, then what's the point, anyone can do this at any time and we're lucky nobody has been childish enough to do it already. 
CSS can add a prefix or suffix. I forget the attribute name but you could do the whom thing in CSS with a : Selected or : Hover pseudo class
Thank you Sameer :)
I've done some advanced analysis for you. All profiling was done in Firefox developer Edition, I assume you use Chrome, YMMV. I've managed to increase the framerate quite significantly by two different kinds of optimizations, 1 big one, and a few smaller ones. [The overall winner](https://jsfiddle.net/bvrwf9m8/29/) increases the framerate from 7.5 to 28 fps! [Version 14](https://jsfiddle.net/bvrwf9m8/14/) shows us that about 9% is spent on drawing, while a whopping 80% is spent on updating! average fps on my pc is about 7.5, min is 3.2, max is 17 [Version 18](https://jsfiddle.net/bvrwf9m8/18/) takes a different rendering approach as per this jsperf, it doesn't seem to increase performance however. note though that it does decrease the amount of garbage collection that needs to be done significantly. I heavily prefer this method because it would provide a smoother experience when higher framerates *are* achieved in another way. average fps remains about 7.5, min is 3.6, max is 37 (far better min and max as well!) [Version 19](https://jsfiddle.net/bvrwf9m8/19/) removes any calculation involving dot mass, in your current simulation, all masses are equal to 1. This increases performance a little bit, avg fps is now about 8.6, max is 55.7 and min is 3.7 [Version 20](https://jsfiddle.net/bvrwf9m8/20/) Contrary to what my respondant says, changing your timeout variable from 1 to 16.6 actually impacts performance quite significantly, average fps increased to about 12, max is 16, min is 3.3 [Version 21](https://jsfiddle.net/bvrwf9m8/21/) Contrary to my own expectations, moving the var declarations outside the update function actually drops the average framerate by about 3fps [Version 22](https://jsfiddle.net/bvrwf9m8/22/) removing the var imo = i - 1; and inlining it with the second for loop seems to increase framerate by approx 1 fps. avg is now 13, min is 5.9, max is 60 [Version 23](https://jsfiddle.net/bvrwf9m8/23/) Replacing the Math.floor within the drawing part with | 0 as suggested by the top comment increases the framerate by approx 1 fps again. average is now 14, min is 5.7, max is 60 [Version 24](https://jsfiddle.net/bvrwf9m8/24/) Memoizing Math.sqrt has disastrous results. It made my browser crash, so no profiling on this one :) [Version 25](https://jsfiddle.net/bvrwf9m8/25/) Moving the drawing code into the dots.doMovement() loop increased performance every so slight again, average is now 15, min is 6.5, max is 58 [Version 26](https://jsfiddle.net/bvrwf9m8/26/) Using setImmediate instead of setTimeout, just like requestAnimationFrame, has a very negative impact on performance, average dropped to 8.5, min is 6.4, max is only 10! However, the consistent delay between frame updates (min and max are really close) feels a little nicer to my eyes, there are no jerks or sudden jumps in framerate. Perhaps this framedrop isn't as bad as it looks [Version 27](https://jsfiddle.net/bvrwf9m8/27/) Replaced Vector as an object with {x, y} properties to an array with [0, 1] properties, increased framerate by 3 fps! average is now 18 fps, max is 60, min is 9.3 [Version 28](https://jsfiddle.net/bvrwf9m8/28/) This one is significant, I replaced the object dots with array dots, index 0 = x, index 1 = y, index 2 = vector.x, index 3 = vector.y. average framerate is now 27!!! fps, min is 9.6, max is 60. We've achieved acceptable performance here! [Version 29](https://jsfiddle.net/bvrwf9m8/29/) I expected this to increase performance quite significantly, but it did not at all. I replaced the array of dot arrays with one single big flat Float64Array, dropped 8 frames :( Kinda glad this doesn't work however, it is /extremely/ tedious to write code like this (look at the source code, it's insane) Conclusion: Before I start, the browser I used was Firefox developer edition, with a different browser, your mileage may vary! If you want big performance gains, replace all your objects with arrays, this will nearly double your framerate! If you have a certain threshold you want to reach, reverse the death by a thousand papercuts. Heal your papercuts: 1. Remove unnecessary code (duh) 2. Replace Math.floor(x) with x | 0 3. Do NOT move variable declarations outside the loop or function. This is counterintuitive for me, but the measurements don't lie. 4. Merge loops iterating over the same collection Stuff that does NOT work: 1. Flattening the array of dot arrays to a Float64Array, this decreases performance quite significantly 2. RequestAnimationFrame as well as setImmediate decrease framerate significantly 3. Memoization of simple math functions (math.sqrt in this case) 4. Moving variable declarations outside of the function or for-loop blocks decreases performance slightly (but not much!) 
And if I am making a game?
&gt; ...promoting the web necessitates promoting Javascript (or at least **a language that compiles to it**). Absolutely right: [The Super Surrogates of JavaScript](https://medium.com/javascript-non-grata/the-super-surrogates-of-javascript-862460199915). This was the author's point all along, *though you'd have to follow his other JS-related articles*. 
I agree, and mostly due to pressures from hiring new graduate students is one of the main reasons these algorithm questions stay relevant. Because if you just graduated from a Computer Science program, these sorts of puzzles will still be fresh in your mind. The kind of technical questions you would ask someone will have to be tailored to that person's experience.
Two other people talked about storing canvas image data with TypedArrays. But have you considered coding the n-bodies as represented with TypeArrays as well, instead of individual objects? **Edit** Nope, /r/Combinatorilliance tried Typed64Array and it chugs like molasses on my 2 core Haswell Pentium. Same deal when I changed it to Typed32Arrays. Also consider web workers as another option to use inside that first DrawGrid loop. Another edit: Tried a quick change by caching some repeated values like canvas.ctx.width and canvas.ctx.height into their own global variables, but didn't seem to make a difference.
use the value of current element using innerHTML function and set the new+innerHTML value
Up until now I was using Panda for this but I'll probably start using this tool instead. I think it might be interesting to add a bit more info to the repo cards. Maybe languages used? Good jarb :)
Very cool project! Just one question: did I just miss it in the docs or is there no possibility to get a random number from one of your objects? (E. G. One die throw) 
This sounds like a good use case for a browser extension. I'm pretty sure there already might be a solution in the market (I mean common, we're talking about emojis!) 
You surely mean lodash, the faster fork of underscore? 
Thanks master5o1! Next version will have that capability :-)
heck i just installed it, i don't actually use my new tab page for anything, sooo, might as well!
Thanks drunkenfaggot! Makes sense! And some sort of animation would be nice too. Need to code that soon :-)
I happen to have made one a while back http://codepen.io/anon/pen/RagKWJ
These feel like technical questions for a SWE fresh out of university. I wouldn't ask most of these for a JavaScript / Front End Developer. the README.md title is much better than your reddit title. 
Yes it does, right below the heading. Check http://i.imgur.com/ixantG2r.png
Awesome downloading now
Thank you very much for your remarks! I'll try to follow them as best as I can. Regarding `map`, I would say the function is correctly named. I have a strong Haskell background and in that context this method is very well defined. It is a method that takes functions A =&gt; B and turns random variables with values in A to random variables with values in B. It follows all of the functor laws: random.map(function (x) { return x; }) "===" random random.map(function (x) { return f(g(x)); }) "===" random.map(g).map(f) Is the name `map` really misleading for people with a Javascript background? I mentioned the functional interface because of map, flatMap and always which make random variable an instance of a Monad, and the fact that random variables expose an immutable interface. Anyway, thanks again for your comment! I'll try my best to apply your remarks! 
Thanks very much! Indeed, it is not possible right now. I will implement sampling using the Alias method very soon.
MacBooks hide scrollbars when not in use.
Oh, yeah, forgot about that. Magic mouse means no visible scrollbar. I would test every website with a regular mouse just in case some scrollbars slipped in there. Regardless, you should only set overflow to scroll if you specifically want a scrollbar to *always* be there (even if there is no overflow). 
Nice to see some of my gripes with chrome formulated and tested. Developers tend to love features and thus chrome, it's the classical quality versus quantity. Everything Google has always been let's add more features fast, more power to you. Apple on the other hand is the exact opposite, first think of all the edge cases and come with one albeit limited solution. Both have their merit. There is a middle ground. This reminds me of an article stating we should take a step back from features for some time, and improve opun what we already have. This is off course a touch swallow, because there's always the next must have feature, be it JS ES6 or CSS Houdini. We've come a long way, and Safari really needs to up its game, but there should be a time to reflect on the bigger picture.
I think wreckedadvent is probably correct on your implementation of map. It seems much more like a partially applied fold, given that it is restricted to changing the names ('values') of the domain. I would assume that map would allow me to apply more general transformations; your map is really only applying to a single field. Of course I doubt a more general map would be useful as a public API. But a more specific name like `mapDomain` describes the actual functionality of your map concisely.
Actually, flatMap takes a function from a value to an aleatory. Maybe renaming them to .map(valueToValue) and .flatMap(valueToAleatory) would be clearer?
It's always great to see clean, well documented code. I really like the idea of implementing your own random variables! Some thoughts: All we really need to get rolling is a list that adds up to one and a constructor that maintains the invariant. What is the benefit to implementing it as ..., 'number:1:4': Item { value: 4, probability: { [Number: 0.16666666666666666] s: 1, n: 1, d: 6 } }, ... instead of just querying probability by index? [0.16666, 0.16666, ...] I think the library is great as is, some additional examples of function usage and maybe an es2015 module version would be nice to have. 
Add the checkbox above the &lt;div&gt; and a &lt;label&gt; associated with the checkbox around the div. Shouldn't mess up your styling too much.
Looks amazing and functions great, but if you click on a number in quick succession it selects it (you should disable text selection ;) ).
These questions suck. You should be ashamed to be asking these questions. These types of questions are everything that is wrong the the computer science industry! They're literally cancer! Fuck you. Fuck you! /someone who gets 147000 as the answer to first question
You can set the scrollbar -if any- to always be visible in the system preferences on OS X.
Thanks vhexs! Done! Please do a hard refresh and let me know if you are happy now :-)
Use this in Chrome dev tools, for the greater good: document.body.innerHTML = document.body.innerHTML.replace(/chrome/gi, '__c__'); document.body.innerHTML = document.body.innerHTML.replace(/google/gi, '__g__'); document.body.innerHTML = document.body.innerHTML.replace(/apple/gi, '__a__'); document.body.innerHTML = document.body.innerHTML.replace(/safari/gi, '__s__'); document.body.innerHTML = document.body.innerHTML.replace(/__c__/gi, 'safari'); document.body.innerHTML = document.body.innerHTML.replace(/__s__/gi, 'chrome'); document.body.innerHTML = document.body.innerHTML.replace(/__g__/gi, 'apple'); document.body.innerHTML = document.body.innerHTML.replace(/__a__/gi, 'google');
Yes, I meant it was quite advanced *for me*. :) I'm going to try playing around with ports as soon as I can, thanks!
dont actually do this function callForMissingProperties (target) { return new Proxy(target, { get (target, property, receiver = null) { if (Reflect.has(target, property)) { return Reflect.get(target, property, receiver); } else { return Reflect.apply(target, receiver, [property]); } } }); } function selectId (id) { return document.getElementById(id); } selectId = callForMissingProperties(selectId); // same as `var thing = selectId("thing");` var {thing} = selectId;
Magixxx, I fixed #2, 3, 4 :-) Can you please do a hard refresh and see if it's alright now? 
Done!
which is why *all* JS libraries should be authored in TypeScript :)
Yup, scrollbar is gone!
I've created a small example here: http://cssdeck.com/labs/ytwowahr
It seems the author is not up to date with js. Mongo (and all nosql): Unsuitable for most common and useful DB tasks. people have jumped ship to postgres Express: had a lot of drama 2 weeks back with doug wilson -- major contributor of express --leaving express team and currently in middle of a hostile fork. People have jumped ship to koa and adonis. Angular: angular 1.x is good and becoming better and doomed to die. while angular 2 is not released and is expected to fail by many. People have jumped ship to, well, react, vue, ember, aurelia etc ( too many choices over here) NodeJS: nodejs is strong and will survive the decade for sure.
Sure! I would love to see your code :-) I am at a beginner level, so if you see my code if you will find that I have only used very basic things - arrays and if-else loops to get the job done. I know it's not easy to read and comprehend but I wanted to somehow make it work with what I knew :) Seeing you how did it using regex and JS map would be awesome. Thanks oldesole1!
The name is probably fine for javascript developers, it was just somewhat confusing to me from *my* experience with functional code. I agree with you that it meets the definition of a `map` implementation. Let me try and explain what I mean through some code. My caml is stronger than my haskell, but the syntax should be intelligible to you. I saw your domain as this type: type Computation&lt;'a&gt; = { value: 'a probability: Fraction } type Aleatory&lt;'a&gt; = | Computations of 'a | BadComputation of string Given I had a function called `map` over the type `Aleatory`, I would expect it to behave like this: let map f x = match x with | Computations(xs) -&gt; (f &gt;&gt; Computations) xs | BadComputation(err) -&gt; BadComputation(err) I believe the haskell signature for this would be map :: (a -&gt; b) -&gt; Aleatory a -&gt; Aleatory b This map would allow me to transform any `Aleatory 'a` into an `Aleatory 'b` *generally*. If I'm reading your code right, your map implementation would not allow me to apply a transformation that, for example, lowered the probability of a given item, only transform the "values". Since the concrete version of `Aleatory` is described by the type `[Computation a]`, I would expect `map` to have this signature: map :: ([Computation a] -&gt; [Computation b]) -&gt; Aleatory [Computation a] -&gt; Aleatory [Computation b] But anyway, a general map may not be useful to your consumers. I think a name like `mapValues` or `mapDomain` would be very clear to everyone involved, functional or no, and still be the useful function you want it to be. (side note: it would also be trivial to write a `mapValues` if you had this general `map` function, which is probably part of the reason I expect this behavior) Of course, all of this is just my opinion, since you said you were looking for feedback. :) --- e: I gave it some more thought, and I think I can see it your way. I don't know enough about your domain to know if my original type makes any sense. That's what you're saying, isn't it? The `Computation a` is just an implementation detail. In which case, I could also see the argument in defining `Aleatory` like this: type Aleatory&lt;'a&gt; = | Computations of Computation&lt;'a&gt; list | BadComputation of string In which case, we have this (again): map :: (a -&gt; b) -&gt; Aleatory a -&gt; Aleatory b Which I believe is *your* implementation, which is why I agree with you it meets the definition of a `map`. I'm just not sure it's the most *useful* version of `map` for this type. I'm used to `map` (and types by extension) being as general as possible. I think I would normally expect this `Aleatory` type to be `Either` or `Maybe`, and all of the domain functions simply worked over a list of computations, being lifted up to work with the computational failure through `map` and `bind`. Which is more "correct", then, becomes what the domain design is. I think me and /u/strident-octo-spork were seeing the domain as the first one, while you were seeing it as the second. (though his example seems to indicate he was expecting `'a list` instead of `'a`, so we have *three* possible interpretations of the design) Hopefully this helps to give you some insight about why it tripped me up for a bit, even if you don't agree with my original domain design suggestion.
It *appears* to be easy to use. In practice, it isn't, at all.
Sorry, but I think you're missing some pretty significant knowledge about data models here. Relational databases are for relational data, document stores are for document-shaped data. There isn't a *choice* between these two, because your data fits either one or the other. In practice, the majority of usecases involve relational data, and so a relational database *is* the correct solution. EDIT: And as for the "NoSQL" denomination, well... I'd recommend watching [this presentation](http://www.infoq.com/presentations/nosql-commonalities).
PHP is a bad example. It has various architectural defects that are unlikely to ever get fixed, as it'd make it effectively a completely new language. Even if it has "improved" now, that just means that it's at a point where the better options were 5 years ago. At that point you're arguing that it's "not so bad", not that it's "good". I guess that *does* make it a good comparison, actually, as MongoDB suffers from the same problem. WiredTiger makes MongoDB "not so bad", but it is still lacking a compelling reason as to how MongoDB is a better choice than any of the alternatives that occupy the same space. If, all marketing and bias excluded, you had to make a fresh technical choice today as to what ideal document store to use, I doubt there are any usecases where the answer is "MongoDB".
You think 5 lines of code is enough to get millions of users to shift from NPM?
You're right. But when the users reach the moment when it becomes hard to use, it's already too late to painlessly change.
That would be this [QuirksMode.org](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html) article, for anyone interested.
Thats the one, couldn't find it. Thanks you.
I'm not sure how anyone unbiased could possibly give safari an A+ rank.
I added a way to get random values from the objects, via a generator. You can see the code here: https://github.com/redelmann/Aleatory.js/blob/master/aleatory.js#L380 Unfortunately, I had not the time to thoroughly test it and document it yet. However, this shows that this can easily be done!
Thanks again for your valuable feedback! I'll also think a bit more about it. The original idea was not to allow users to manipulate probabilities directly. The users should not have to worry about them, but just describe their experiments and find out in the end what the outcome probabilities are. Again, thanks :) It's always very valuable to get such good feedback!
Well, it's Flash, and HTML5 methods are still not anywhere near accomplishing what Flash has done for decades.
Well, the only words me and /u/ugwe43to874nf4 both used was "callback" and "transform". So maybe: transform(value); Or: toValueCb(value);
Not only is coercion staying in, but we're even getting methods to control it on more complex types, like with [Symbol.toPrimitive] var object2 = { value:5, increment(){ return ++this.value; }, [Symbol.toPrimitive](hint){ if (hint === "number") { return this.value; } if (hint === "string") { return String(this.value); } return true; } }; Number(object2); //-&gt; 5 `${object2}`; //-&gt; "5"
Isn't mobile chrome still just a skin over the regular shitty android browser, or has that changed now?
NPM had a bad day, yes. Who doesn't? But they're working to ensuring that things like this don't happen again. What sense do you see in proposing an alternative (without any details) to replace something that is widely used and reasonably reliable? If you really want to do this, at least share some information about how the whole thing will be hosted and managed? Who will own it? What will the management structure look like? What will its policies be? How will it differ from npm?
Check out the proposed `async` and `await` keywords for ES`16. They make working with the event loop so much easier.
"Additionally, for HTTP request methods that can cause side-effects on user data (in particular, for HTTP methods OTHERr than GET, or for POST usage with certain MIME types),"
That's a somewhat complicated interface. What use case are you imagining for this?
What? Async/await is for promise code, not really the event loop specifically. 
This talk is great. I link to it whenever someone has some issue understanding the event loop in javascript.
Aw, so sad...oh well, it's still in babel stage-0, which is what I use anyway. Edit: [Actually, they're in stage 3](https://github.com/tc39/ecmascript-asyncawait), so I'm guessing ES8?
Yes, but my point was it was promise-specific. 
I don't really understand what you're saying
the callbacks of *A+ promises* are run in the event loop
Is your data relational? Use Postgres. Is it not? Postgress is probably still a good choice. Migrations actually make things easier, because you're always working with the same data structure.
So, there's APIs that (eventually) run your callback through the event loop. There's promises. Promises are one of those APIs, but not all APIs are promises. For example, `setTimeout`. You cannot use Async/await with anything that adds onto the event loop - only with Promises. If the thing that adds to the event loop doesn't even make sense to await (like `setInterval`), then it's not even a situation where you can wrap it in a promise to use async/await. So it's not abstraction that makes working with the event loop easier, just promises.
&gt; And nobody ever called SQL "friendly" I would go as far as to say that SQL is horrible if you're a *programmer*. If its your first analytics language, and all you do is need raw power to make queries and generate reports, it has no equal. It's a solid and practical implementation of set theory. PL/SQL can go die in a fire though. If you need complex triggers, or even business logic *in* the database, you have bigger problems. &gt; Or with a denormalized document store That's the trick. Let the DBA's properly normalize things for efficiency and organization, but provide the database users with views that make sense for the use-cases at hand. For reasons beyond my comprehension, nobody uses views even though they solve a ton of problems regarding databases, including performance issues that plague ORMs.
Hm. That messed up mine. Maybe I did something wrong. Oh well, I've got the JavaScript working now. But thanks; I'll keep it in mind for future project. :)
Most of the solutions need to be condensed further. For example, the first solution could be: function largestProduct(arr) { var n = arr.length, srr = arr.concat().sort(function (a, b) { //concat so that we don't mutate arr return a - b; }); return Math.max((srr[n - 1] * srr[0] * srr[1]), (srr[n - 1] * srr[n - 2] * srr[n - 3])); } largestProduct([-10, 7, 29, 30, 5, -10, -70]); //21000 This isn't with the intention of merely shortening the code with golfing intent, but genuinely needed refactoring for better clarity and conciseness. Even worse, the original example mutates the array passed as an argument. Without sounding too harsh, the code is not truly JavaScript-esque, if I may call it that. And the second problem too: function findMissingNumber(arr) { var N = -Infinity, M = +Infinity, sum = arr.reduce(function (p, n) { N = Math.max(N, n); M = Math.min(M, n); return p + n; }, 0); return ((N + M)/2 * (arr.length + 1)) - sum; //no need for two N calculations, use averages } findMissingNumber([2, 5, 1, 4, 9, 6, 3, 7]); I can understand if many folks will point out reduce's function invocation overhead over a normal for loop, or even the fact that it may need a polyfill, but I still feel that even an algorithmic question's solution should be 100% reflective of a language's innate style and idiosyncrasies - e.g. var i declaration in a loop header getting hoisted to the function scope is downright wrong to show. 
The bit under "Debatable syntax" that says "Promise conversion rules"? ;)
This week? Here you go: // infamous left-pad algo leftpad = (str, len, pd = ' ') =&gt; Array(len &gt; str.length ? 1+len-str.length : 0).join(pd) + str // detect positive and negative numbers with type checking isPositive = (x) =&gt; +x === x &amp;&amp; x &gt; 0 isNegative = (x) =&gt; +x === x &amp;&amp; x &lt; 0 // transpose a 2-dimensional matrix like [[1,2,3],[4,5,6],[7,8,9]] transpose = m =&gt; m.map((r, ri) =&gt; r.map((c, ci) =&gt; m[ci][ri])) // transpose a flat matrix like [1,2,3,4,5,6,7,8,9] transposeFlat = (m, l = Math.sqrt(m.length)|0) =&gt; m.map((c, i) =&gt; m[(i%l)*l + i/l|0]) // reverse number digits with correct sign handling revNum = (n) =&gt; Math.sign(n)*(''+Math.abs(n)).split('').reverse().join('')||0 
just signed up
If you're new to Mongo, watch [this video](https://www.youtube.com/watch?v=b2F-DItXtZs). Mongo takes a number of liberties to achieve speed &amp;amp; simplicity. You actually get no guarantee that your data is actually written, nor do you have any guarantee as to the order in which a number of closely grouped number of instructions are executed. Furthermore, mongo doesn't have the idea of a transaction: you cannot execute sequence of instructions atomically. All these restrictions aren't really that big of a deal if you're building a small webapp. It's only until you reach a certain scale when instructions start flooding in and you need a cohesive view of your data. Imagine 1000's of users hitting your database: is it mission critical that their data is exactly what they entered? If not, then go ahead, use mongo. Imagine a financial market: it's mission critical that every order be logged and transacted in the order that they are received. Any deviation from this will be disastrous. On the other hand, consider reddit posts. Does it matter if one post is recieved out-of-order? Probably not. Edit: Downvotes are not for differences in opinion. Everything I said is factually correct. 
Postgres really is a great database and gets you relational and document storage.
Related: http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/
this is a really good read. very good real world example and explanations.
Well you're late to that party...
Hi /u/cnmom, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That's been fixed for a long time. The built-in webview has only been based off chrome since android 4.4 though.
I was bored. I don't know everything there is to know about the event loop in Javascript, but the pace of this talk was far too slow for me.
Well, everything depends on how *small* your server really is. &gt; If I need to add a column to my db, or decide to rename a column, do I need to run a migration? Actually, you don't need to run any migration as long as the old and new columns have the same (or compatible) data type. &gt; So I settled on using MongoDB because it seems easy to change the structure of the database whenever I want. For a small-scale project, SQLite 3 may look like a better choice. Outside Meteor, I'd never dare use Mongo with bare data.
Browserify is *not* the only way to generate a single js file for the client. There likely isn't one best solution, but [rollup](https://github.com/rollup/rollup) can do away with commonJs and `require()`. [An example](http://stackoverflow.com/questions/36237079/removing-bundle-dead-code/).
That's why I didn't make a strict statement and said "seems". The actual problem here lies not in Browserify itself but in `babel-polyfill` tremendous size and its runtime inclusion.
We can use yield though today similar to await.
Just to be picky, there is no such thing as ES8, the correct name would be ES2017. However since it's only in stage 3 it's not even sure if it's included in next years release.
All talks are better with at least 1.5x speed on youtube. He does move pretty slowly, 2x works for this one lol. Click the cog, it's on every youtube video.
&gt;But, removing the need for Brunch, we also remove the need to either force CommonJS-ing everything or put modules: false in our configs. With Brunch, I had to do the latter because otherwise a user of my pack wouldn’t be able to declare template-generation functions in a natural way that would be possible without Brunch. Heck, I have written purely client-side libraries, why in the world would anyone want to require() them to reuse on a server? Node doesn’t have addEventListener as well as document.createDocumentFragment! I honestly hate all this CommonJS/AMD intervention on the platform these standards weren’t intended for. **Why complicate all things instead of letting scripts load just in the order they appear?** I feel like this betrays a lack of experience in trying to organize medium-to-large-sized javascript apps. We didn't make things like requireJs or webpack because it was just a Fun Thing To Do, but there was a real problem being solved in terms of trying to organize larger applications. It simply just doesn't scale to manually organize your files when you've got a non-trivial application, and encourages you to make very very large files just so that you don't have to do this, among other unpleasantness (like relying on gobals, since that's the only way to organize code without modules). Also, the "CommonJS/AMD intervention" *was* standardized: it's called ES6 modules. It's pretty ballsy to say the platform wasn't intended for module-based organization at this point.
To actually get the hotloading, you need to respond to the update events in your code. With react this is done via a babel plugin, but since you aren't using that you need to code it yourself: https://github.com/webpack/docs/wiki/hot-module-replacement-with-webpack#what-is-needed-to-use-it
Thanks for the reply, and please forgive my amateur code. The whole site is written in PHP, so i have a function at the top and i have entered this code in: function approveGameRequests() { this.style.backgroundColor = "red"; } But it is still not working.....I will look through the MDN docs.
PostgreSQL is a very stable, very reliable, very durable database. It has very good support for JSON (look up JSONB), so if you need a document-type store or a very flexible schema it'll work very well (and it supports indexes on JSONB columns as well). It has native support for UUIDs. It has support for serializable transactions (do yourself a favor and use them from the start, it will help with a lot of pain). ORMs might help with some of the pain of working with a database, and might not (though usually have some sort of automatic migration). It's also entirely possible to write your own migrations (ALTER TABLE ADD COLUMN etc) and execute the whole migration in a single transaction (so you can execute it, see if something went wrong, and finally commit or rollback it). The problem with ORMs (and a lot of query builders) is that they try to abstract from different databases, which is a questionable goal at best (maybe if the SQL standard was actually reasonable and standard, that might make sense. Also PostgreSQL is probably one of the most standard complaint databases out there). PostgreSQL also expresses a great deal of useful features (expression indexes, exclusion constraints (e.g. no two reservations can reserve a room at the same time), a very powerful UPSERT in 9.5... it goes on and on). It's also solid as a rock. Besides: CREATE TABLE documents ( id UUID PRIMARY KEY, doc JSONB); gives you the flexibility of a document database with a lot of the advantages of a full-fledged relational database (transactions, durability, etc). You can also put constraints on the fields in doc. And one more point: plv8 allows you to write Javascript *in the database*. PostgreSQL can take a bit to get used to (it's absurdly powerful) and I haven't seen a database that focuses on durability and correctness nearly as much. (Use serializable transactions and you might end up finding it very difficult to accidentally lose data.)
It's not good idea to store something in cookies. Think about cookies as a marker. Best alternative is [localStorage](https://www.google.com/#newwindow=1&amp;q=difference+between+localstorage+and+cookies). 
That is, perhaps but almost certainly, one of the best examples for why a marketing person shouldn't write about technical matters.
1. Some things can't be done without native support (or are more performant when implemented natively) 2. Restricting yourself to “only modern browsers/engines” might give you most of ES2015 even today.
I don't personally use Sequelize, but there's a reasonable chance that if you ask in #Node.js on Freenode IRC, somebody will be able to point you at a real-world project using it. As for Node and NPM - perhaps [this](https://gist.github.com/joepie91/95ed77b71790442b7e61) would help? Developing a PostgreSQL version in parallel is not a bad idea at all, by the way. You could probably copy over most of it at some point, without having to do a big daunting rewrite all at once.
tl; dw?
I just tried those commands and they both completed in less than 10 seconds each. I generally don't have any issue with this. I very much doubt the problem here is NPM.
I am working on a solution right now, I created an echo line after my div, as shown to me here by pythonpoole: and I got the click working (when i click, it changes the div color) https://www.reddit.com/r/PHPhelp/comments/4c2iw9/how_can_i_use_a_onclick_function_to_change_the/d1ej74h When I refresh the page currently it will revert it back to a "non-clicked state", whereas I want it to stay in a "clicked-state" even if the page has been refreshed. [edit]:forgot missing comment
If you want to use Postgres from Node.js, you might want to check out Massive.js: https://github.com/robconery/massive-js It's not a complete ORM, but simply makes writing your queries a bunch easier, including support for Postgres' JSONB columns.
I installed my entire dependency tree in a few minutes' time earlier today.
Unless explicitly stated otherwise, I believe you should always assume data and its consistency are important, in which case MongoDB is a poor choice regardless of scale.
Considering the damage potential of a hostile module it is kinda serious.
We need an elegant way to begin with nosql and then migrate when appropriate. I wonder if any ORMs make this possible already. 
Plenty of people work without a degree. Roughly about 15 percent of positions(mostly cto level) won't be available to you. So if you can be satisfied with the rest 85 percent of the job market, don't waste time and money. Work and learn at the same time.
That makes sense to me! Strange that they said in the write up for string padding that the lack of it makes the language feel incomplete. Maybe I'm just ignorant, but I feel like it's just an obscure nice to have haha
Personally, I think the imports are kind of strange, a symptom of the language's lack of focus--if we had standard libraries, then it makes sense. We are of the same opinion. What scares me off in JavaScript is that this thing is a monolith and it became one very quickly, on a foundation which is possibly the most inconsistent in any language. I lack trust in it and this lack of foundational trust flows outward into those who attempt to patch the cracks. Does that make sense?
Eh, a lot of times even if there is something better the teacher wants exactly what they said. I think he should stick with cookies, but note to the teacher that localstorage may have been a better alternative. 
I would say... all framework of all server languages. 
Has WebGL always been allowed in JS1k? I thought it was just canvas 2D but no GL. Because this opens up a lot of crazy possibilities for demos (looking at you, regular coders at Shadertoy).
Point taken, lodash works too, however from a learning perspective i find it's best to start with the root of something and go from there. Learn underscore and then move on and figure out why lodash is better for implementations. Likewise i wouldn't say completely neglect jQuery (as you'll probably have to deal with it at some point). Still do the due diligence and learn about it just try and steer clear in actual implementations.
24 year veteran programmer here. No degree in CS. I haven't made less than 6 figures per year since 1995.
JSPM includes rollup, right?
.
I feel articles like this are misguided. These build tools aren't ruined, nor are they bad. They just might not be suitable *for your use case*. Want a tiny scaffold for your projects? Just shove it up in a git repo, and start each project by cloning it. Want to 'bundle' all your scripts up? Just concat the files. As your project and needs grow, you'll probably start to run into problems or identify optimisations that can be made. Chances are others thought the same, and there's tools out there to solve them.
Anyone know of any good talks on await async?
&gt; I've learned the hard way that Chrome is the new IE. lol.
You can bind to them when you create them. For example: http://codepen.io/anon/pen/JXJrLX
&gt; Imagine that two of my dependencies A and B consume library C. A requires C version 1, B requires C version 2. Assume this makes these C sub dependencies incompatible based on A and B's version constraints. If you're in this situation, you've got bigger problems. &gt; Now assume that A and B are using a function from C that didn't change between versions 1 and 2. Ideally this function would be de-duplicated, but because our dependencies are incompatible it can't be. Tree shaking doesn't fix this problem. Micro packages do fix this problem. If the functions are identical, they can be deduplicated. If they aren't identical, they can't be dedeuplicated. This has nothing to do with whether you've spammed every single utility function into its own dedicated repository or not. Any remotely good optimizer is going to be able to handle that. 
There are plenty of jobs that won't let you get a foot in the door without a BSCS, BSSE or related degree. Similarly, there are plenty of ceilings you'll hit in the industry with a few years of experience under your belt but no degree. You'll make connections pursuing the degree that can easily lead to employment in the future. You will develop strong CS fundamentals and will be able to learn new concepts much quicker. You will be able to pursue internships which count as legitimate work experience and can assist you in landing a job. There was a golden era in the industry where anyone could make it to any level without the degree. That's quickly eroding. With so many qualified BSCS/BSSE/etc. coming out of schools, your competition will be that much more fierce. Plus, since you already have an unrelated Bachelor's, the program will probably only take two years. Ultimately, just remember that people who have 10+ years experience and no degree are NOT in a similar situation to you, because they began their careers when a degree wasn't as important as it is today. Best of luck to you!
[removed]
I think it depends on what kind of developer you eventually want to be. You can get by with self-taught knowledge in a lot of capacities, but there are a lot of jobs that require a certain level of education to even be considered for the job. You can definitely find work without a degree, but as others have said, you'll have ceilings. In your previous career of business management, you'd've had the same ceilings without a degree. It doesn't necessarily make you unhirable but it does limit your possibilities and might make it harder to advance vertically. 
Most of the places I interviewed at were just happy to find someone, anyone, who can code their way out of a paper bag. I didn't really understand why until I did some interviewing myself. The degree is really just there to act as some kind of basic filter to keep the most absurdly unqualified out, 'cause there's a whole lot of those people floating around. OP, if you want a leg up, just get things done. In my experience, showing you can actually do things will count for way more than some piece of paper. Particularly in web-dev, which is very results-orientated.
You just need a degree.... Most of CS you can learn on your own.
&gt;The degree is really just there to act as some kind of basic filter to keep the most absurdly unqualified out Right, and at a lot of places, the lack of degree puts you in the discard pile right off the bat. Ergo, were someone to hedge their bets, they'd shoot for the degree while maintaining personal projects as well. A personal project on its own won't matter if the interviewer never gets to see it because your application was thrown away. On another note, I'm glad you were personally able to find success without a degree.
try this........ var wv = $('body').innerWidth(); var child = $('.child'); var childNumb = child.length; var childWidth = wv / childNumb ; var parent = $('.parent'); var parentWidth = childWidth * childNumb; TweenMax. set(parent, { width: parentWidth }); TweenMax.set(child, { width: childWidth });
Flexbox is fine. People who can't test for shit are bad.
Hey thanks! but do u mind explaining why? like what exactly is causing my error. How does renaming a the jquery module help in this case? Also I thought providePlugin would solve the jquery problem by referencing jquery module whenever webpack see "$" or "jQuery", so my plugin file should be able to use jquery properly right?. Im having a tough time with webpack :(. I literally spent a day trying to debug simple stuff like these
I was an art major and could code better than some of the CS majors coming from state schools. Just because somebody could get at least a passing grade at bachelors CS doesn't mean they know how to code. Now that I'm in a position to hire, I take self taughts who can actually code and communicate over fresh CS or boot camp grads. Truth is right now the market is in the hands of the coder. I'd get in now, I get 10 cold calls from recruiters every week. Go to school when the markets slow or there's a recession and the opportunity cost is lower. Don't listen to this. You have A degree and that's what counts.
How about an engineering degree? I'm currently studying Commerce (probably major in Finance) and Engineering major in Civil).
If you can actually get a job without a degree, then it's not required. Unfortunately, most places, you need that piece of paper to get your foot in the door. Once you get your first job in the field, though, it should be much easier. Experience trumps education. Education or connections... only two real doors to getting into the industry. Once you're here, though, you can stay as long as you want.
As far as non-CS/SE engineering degrees go, I'd much prefer a mechanical engineer or electrical engineer over a civil engineer. In fact, I don't think I'd grant more "points" to a civil engineer than any other random bachelor's degree. Finance, on the other hand, can be used to your advantage if you would like to work as a developer in the financial industry. Those jobs tend to have crazy hours and crazy compensation.
No, Got into 6 figures at age 21 because I skipped school. You'll be learning stuff that is at least 5 years behind most likely and although you will probably learn a lot of valuable core concepts with a bit of self motivation you can find the same information online fo' free. Most companies you'd actually want to work for these days realize this and will be more than happy with you showing them portfolio and experience in replacement of education, and sometimes it's favored over education. 
The main prollyfill for this proposal is actually more efficient than `leftpad`, and a native implementation would be better still: https://github.com/es-shims/String.prototype.padStart (There's also one for the `padEnd` method.)
Webpack is a pain in the ass, to be honest. With one hand it giveth, with the other it taketh away.
A big take away from this is that defered/callbacks are not executed until the stack is empty. 
Things like this link. Thanks for it! Like most functions of a language, they are obvious, yes. But understanding how/where/when to use it is not always. I find that videos about topics usually leave me with one or two, "Oh I never thought about that..." which I feel is what helps me grow as a programmer.
Is your JS being executed in a browser or node?
My bad. I did a little more searching on my phone and you are right. It should inject it whenever $ or jQuery are referenced. I took a look over your webpack.config.js and I've never used the module.loaders.jquery.presets before, so I looked it up. Appending `.map(require.resolve)` to that array may solve your issue. (See http://stackoverflow.com/a/34574630)
here's one, you want to display the time padded with 0s, function formatTime (d) { const h = d.getHours().toString().padStart(2, '0') const m = d.getMinutes().toString().padStart(2, '0') const s = d.getSeconds().toString().padStart(2, '0') return `${h}:${m}:${s}` } formatTime(new Date('2016-03-26T00:00:00')) // 00:00:00 Of course, you could use moment for this - but without that the date methods `getHours`, `getMinutes`, `getSeconds` each return a number which would need to be padded to 2 characters. After writing that, I think the more pertinent point is ... padding of strings is good and all, but any word on Date.prototype.format coming to native ES any time soon?
I've never been in a situation where my lack of a degree held me back. 
If you already have a bachelors you could get a masters but you don't need to get another bachelors for CS. To be honest, there are very few times you need the theory you'll learn in academia. It's funny but one of the few times in my career that I used my degree was making a spreadsheet. XL is so fucking bad that it's the only time an O(n^2) vs O(nlgn) algorithm made a perceptible difference. Other than that, it's mostly just getting other people to be careful, think ahead, test and verify. This ain't rocket surgery.
Oh, hey. I'm the author of this package. Thanks for the post! If anyone has any questions, I'll do my best to answer them.
Yup, I've been working on an application that has a stopwatch, and I remember wishing there was a method like `padStart` to do what you mentioned above.
To be honest, I've never had a situation on my FE code that would benefit invariably from using CSP over promises. CSP *does* reminds me of the actor model (though with different names for things). Also, while there's a surprising number of people who complain about promises "swallowing" errors or whatnot, they're very comfortable for me to work with, given some functional programming background. 
I mostly learn by doing. Find something I want to do, try and do that thing. If I can't do that thing, I'll least learn what I don't know about doing that thing, which will be easy to google and correct. Javascript in particular has a very low barrier to entry to do this kind of thing. You have a browser and a text editor, and that's all you need to get started. 
If you want to store data/states (so they are retained after refreshing or leaving the page), there are several ways to accomplish this (by default no data/states are retained after the user refreshes or navigates away from a page). The most basic way is to simply use JavaScript to set and retrieve a cookie. A cookie is small piece of information a website can store in a user's web browser that can be used to keep track of things like preferences and restore those preferences when the user refreshes or navigates away from the page. Cookies can also be accessed from your PHP script when generating a page. The second way is to make the object (e.g. button) act as a HTML form element that submits data to your PHP server when the user clicks/engages with that button. Your PHP server can store and keep track of the data/states as required (based on the form submission) and use that information to dynamically generate webpages that reflect those saved states. The problem with this second method is that, by default, the form submission will cause the browser to reload the page and this is undesirable because every time the user interacts with an object (e.g. button) that requires you to update state information (e.g. "game approved"), it may take several seconds for the form to submit and the newly generated page to load. To mitigate this problem, you have to employ the use of AJAX to dynamically send an HTTP request to your PHP script (using JavaScript) that will tell the PHP script about the state changes (e.g. 'approve game X') as the user makes the changes and then the next time the user requests the page, the PHP script will dynamically generate the page according to those previously saved states. AJAX is more difficult to implement, but it will produce much better results than simply using browser cookies or using a regular HTML form to submit data. That's because AJAX requests happen in the background so they are invisible to the user and don't impact the functionality or responsiveness of your webpage when a user changes something. Also, unlike the cookie-only method, the AJAX method is server-side so the save states can be stored across different users and different browsers as desired (whereas cookies are specific to one user's browser).
&gt;The single most important runtime plugin which plenty of ES6 features depend on is called babel-polyfill. It's based upon Regenerator and CoreJS and provides support for generators, new array methods, promises, symbols etc. What does it mean to us? It means that if we want to just use new ES6 syntax elements (fat arrows, spread operator, default arguments etc... even classes), we don't need this plugin, but if we want to use any significant ES6 feature, we must import it. This leads me to believe the OP is trying to make things like generators work pleasantly in an ES3/5 environment, which is almost certainly why they're ending up with a 100k file. 
Thanks!!
The only case I knew where a degree held so some back was when I worked at UPS. My supervisor at the time was going back to school to finish his BS-CIS degree to advance. His manager required that he do it because the Job Description said that someone in the position should have a degree.
Thank you so much!
That does seem a bit long. Are you running it locally? It may be your ISP trolling upload speeds...
Stephen Grider has a course on udemy. You start writing a boring add comments box in react, but you start by building it in a chai/mocha testing workflow. If you already do development it's not a bad place to start. If you're totally green to js, find a problem and solve it. Build a simple chat Api in ruby, and start building an async front end, when that's done convert it to sockets. 
What do you mean by 'execute urls'? Do you mean send a request and receive json like a browser might do? Or do you mean receive requests and send json, like a server would do?
This kicks ass. But I see scroll bars in Chrome 49: http://i.imgur.com/nuGdpm9.png 
Thanks for replying. It's been noticeably slow for a few weeks since I started down my project. Ec2 is in us-east-1, bucket is in us standard. Very frustrating. Spent about 2 or 3 hrs today stepping through the aws SDK lib trying to see where the slowdown is. For the longest time I thought it was buffering odd since I'm using a Buffer to convert a base64 string to binary to serve as the body for the request. No luck. It seems like it builds the Body in a timely manner so my last thought is s3 itself. Some people had said online not to expect fast times from s3, but to me this seemed a bit much. 
Thanks underwatersandcastle! I am glad you liked it :-) You can find more here: [http://vikaslalwani.com/projects/](http://vikaslalwani.com/projects/). (warning:projects after day 21 are shitty!)
2013
Generators, promises, new array methods, symbols etc. Anything related to new APIs, not syntactic elements.
How does this Javascript library compares to the other prominent JS libraries?
Hmmm... This makes me wonder if others knew about this vulnerability all these past years.
Side hint: using TypeScript doesn't bring in any dependencies like that
Sorry for not being clear enough, it was late night here in Ukraine. (Btw, pardon my English too) &gt; You're talking about nativism, don't-over-complicate-it, keep-it-simple-stupid but still want to organize your files through grunt/gulp/broccoil/whatever? "Whatever" can include a plain npm runscript or even a standalone shell script. Grunt was just an example. &gt; How exactly is it not manual if you're telling grunt/etc what order to load your files? Do you just have a few globs and hope for the best? Do you remember we are talking about client-side? Its the place where any action entry points usually run independently of the place they are actually situated, as the result of some events. In our particular case, eveything is loaded *before* the `DOMContentLoaded` event is fired, and any entry point runs *after* this event, and the order of loading really doesn't matter as long as it happens this way. Moreover... &gt; You missed my point. If file A wants to talk to file B, you need to put something on the global space without a module loader, or rely on weird tricks And my point was that *just a single file* (bundled from file A and file B and minified) gets sent to the browser. And if *source* file A wants to talk to *source* file B, they don't need to export anything into global scope at all, they can call each others functions within that IIFE I was talking about. &gt; I'm not really sure where you got that figure, but you're almost certainly being disingenuous to me by including some huge unnecessary thing like regenerator. Again, sorry for the late night confusion, I referred to the size not just of a module loader but to the size of a complete emulated ES6 environment on ES5 target (and yes, it's based on `babel-polyfill` which yes, includes Regenerator... if you know any better alternatives, I'm all ears).
Does setting `"vendor/test/a/b": {defaultExtension: "ts" }` in `packages` do the trick?
Thanks, I'll stick with CoffeeScript.
Webstorm or bust.
Did you try the `allowjs` flag in TS1.8? That might be able to pick up types from JavaScript files straight. Traditionally, you can 1) rename the file to TS, fix any errors (re-declaration, etc) 2) define a definition file for it declare module 'vendor/test/a/b' { var test_a_b_static: any; export = test_a_b_static; } 
Does this help download the videos or just stream them ?
One reaction to my book “Speaking JavaScript” was: “Reads like a good novel.” It’s a comprehensive guide to JS for programmers and its complete contents are online; so you can check out for free whether you like it or not: http://speakingjs.com/es5/
&gt; the abstraction is unbalanced versus the benefit This. Both articles I recently posted are actually all about this. Same goes for other frontend development aspects, such as viral Angular/React obsession (and before this - jQuery/Bootstrap obsession). Bringing all that overhead to fields where you keep everything ~~slain and pimple~~ plain and simple and still get things done efficiently. Probably not everyone understands this but there are countries where internet traffic still matters. Mistargeting for fancy fads can cost someone innocent money.
I use webstorm as well. I don't have any complaints!
Why should it? That simulated click is not async, so the behaviour is completely normal. You can wrap the click in an async function (setTimeout with 0 delay) and that will put that click to the end of the loop basically.
Exactly
Also, people should learn how to write proper titles. Reading this title you see Chrome is bad, not mobile chrome is bad. Yep. 
So simulated clicks don't actually trigger events like real clicks? This seems like a strange design decision to me. It'd be easy to just throw the callback onto the queue like an actual click from a user to better simulate the behaviour.
Yes! This video was fantastic. I literally just watched it an hour ago and it's what got me started on this questioning. It sounds like I'm getting confused between async and Web API events. I had assumed that addEventListener was an async function given that it has a callback but, now that I think about it, it's actually setting up a Web API listener. The simulated click must skip this Web API part and just go straight to running the callback.
By calling `cats.click()` you are executing the anonymous function you just bound to the click handler. You are immediately executing it before `alert('finish')`, so it should alert 'cats' before 'finish'. Nothing unexpected here. 
That's... an unproductive way of looking at it. Why would you blindly ignore the fact that different browsers handle flexbox vastly differently and call it "fine"? I realize it's a good tool, and you want to be able to use it, but that shouldn't mean that you should ignore the fact that it's not finished. Just because it's possible to work around bugs doesn't mean we should ignore the fact that they are bugs, and that it shouldn't be our responsibility to work around them to begin with.
Sublime text 2
Webstorm is made for JavaScript dev.
For me, the drama never existed. leftpad = (str, len, pd = ' ') =&gt; Array(len &gt; str.length ? 1+len-str.length : 0).join(pd) + str
And for your own code you hardly ever need such a general solution. E.g. you can pad 4-digits inline with `("0000" + "1").slice(-4)`
&gt; I wish it were completely bug free with zero browser quirks too, but I've been involved in Web Development for 20+ years and that has never been the way Web Development works. No other layout system currently in use in CSS will give you vastly different results depending on which browser you're using. You seem to be very proud of your ability to test. I don't see how that's relevant to this discussion however. 
Do you need it? No. Can it help? Yes. How much can it help? It can vary from a lot to not at all. Having A degree already gives you an advantage. Getting an additional cs degree gives you that extra push over the cliff. But it also takes time. And chances are you won't be using most of what you learn with it. My suggestion is to go for it if you like school, like learning, and to really want get invested in this kind of work and what it's about and don't really care so much about getting out there and getting work right away. If you're looking at this degree simply as a way to help you get a job, don't worry about it. You don't need it, especially in this industry. What you don't already know you learn on the job. And anything you need to know is pretty readily available online. I've been a software developer for many years and only have an art degree. One of my old managers (a developer before a manager) had a history degree, and half of the other people I worked with also did not have cs degrees. It's not needed. You learn interesting things (I had independently taken some cs classes in my spare time), and things that make you better at your job, but you're fine without it.
I mainly use Atom these days. Let me give you an overview about what I think. The cool thing about **Atom** is that it is Open Source, has a nice community, quite a few plugins and it is fast (now). I also enjoy working with **Visual Studio Code** for the same reasons. Microsoft does a great job with it! But it's still missing some features, especially built-in terminal windows and the ability to open multiple folders as a project. I have some quite cool configs for **vim** and **Emacs** and, but I do not use them for web development that much. They are great editors but I often find myself to be more productive with Atom or vscode even though I am quite fluent with vim's/Emacs' shortcuts. As many others, I also used **WebStorm** for a while, even bought a license a few years ago. But I find it too slow, there are noticeable delays in the UI when you work with it. Have just tried the latest version and these are still present. (Even in other products like DataGrip one can notice that). The task runner that recognises my Grunt, Gulp or npm tasks automatically is really cool! Also the terminals are a pleasure to use. I don't like that it does not stick to _common patterns_ like `cmd+p` to open a file. And it's not Open Source. There are a couple of others I've tried, like Coda, Sublime Text 2 &amp; 3 or BBEdit; but I was always missing something.
Yeah. I mean, it must be at least five minutes since anyone has asked that on reddit.
Initially WebStorm, but I found it tries to be toooo clever and ends up being slow and unwieldy with large Ember apps. Presumably you can tweak it? But life is too short and WS is too expensive for it to not just work. Moved to atom and haven't looked back. 
&gt; Imagine library C is underscore. It's not unlikely that you'll need to depend on two libraries A and B which each depend on different major versions of underscore. This is a relatively common problem to run into. It is, which is why we use constraint solvers to try and still only load one version of the dependency. NPM unfortunately is willing to do it anyway, but it's a situation you should really avoid as much as possible - conflicting library versions can cause major problems. If it's a collection of pure functions without any possibility of state leaking out of it you're probably fine, but that's very difficult to guarantee. &gt; The question is how does the optimizer know that the functions are identical. It can coerce the functions to strings and check whether they're identical, but that's too restrictive. A better way to do it would be to check if the functions are compatible within a minor version and to de duplicate in favor of the more recent version. However, that would require you to version every public function separately i.e. micro packages. The optimiser would have an AST level understanding of the whole codebase. At this point, it's relatively trivial to find duplicates, even if the code has changed in structure but still has the same meaning. Even if I have twenty different versions of underscore in the project, if I have a function (say, leftPad) that is identical across all versions, this can easily be detected and optimised. 
I think csp is cool but libraries like co are more javascripty. There's a library called caco that's like co but also supports RxJs streams. I think that gets even close to the channel metaphor.
I'm not familiar with monkey patching (i'm new to javascript) but from brief goolge it looks like the person is overriding the function? 
This could be possible, but it works only in an ES6 environment: ``` const containsHello = multiDimArray.some( row =&gt; row.includes('hello' ) ); ``` 
Just to be clear, in the second example, you're saying that gen(4) still runs four times but the permutations array only remembers the last element pushed, so it returns ["hi"] but this "hi" is from the fourth time it ran through the function?
Wow, that's the first time I've seen a visualization tool... albeit I'm entirely new to programming... this is exciting! Thank you!
I believe I understand what you're saying, but I don't think I necessarily agree. Javascript has always been a bit of a mutt of a language - the creator wanted a scheme interpreter, but had to add "java semantics" to make everyone else happy with it. Thus, we have a language where basically every important abstraction is based off of functions, yet still has things like `new`. Something to keep in mind is the javascript community is probably one of the most diverse, since it's your only real option to talk to the web. That means we have everyone from rubyists, enterprise developers, functional programmers - you name it, they have to use javascript. A language that can service *all* of those groups of people, I think, inherently has to have a little bit of a lack of focus. As for imports, I think they're fine. They remind me both of modules that we already had, and modules in other languages, f# in particular.
It's tough to tell exactly what data structure you're working with from your description. Could you post an example?
Is there somewhere I can read more about .util and .app as w3schools doesn't have anything on it http://www.w3schools.com/jsref/obj_window.asp? Another question is why would they extend .app and .util instead of using standard functions, I'm guessing something is inherited from .app and .util?
&gt; write ES6 for ES6-compliant browsers or controlled environments like servers (where you are completely in charge of all available computing power and take full responsibility of what you do with it), write ES5 for everything else Why not just...use babel? &gt; don't make users suffer by throwing 100KB bloatware at them just because you feel more comfortable writing ES6 when your users can't run it natively with no significant overhead Or you could write ES6, transpile to ES5, and get the best of both worlds? Edit: Ah, I see from your other thread that you dislike the size of the babel-polyfill. You don't actually need to include it to use babel, you know. Figure out what features you want, figure out what browsers you need to support, use whatever polyfills make sense for you. It's absolutely incorrect to suggest you need 100kb of polyfills to use Promises or whatever.
yes, it did run 4 times. function gen(n) { var permutations = []; &lt;- this is the one being returned. if(n === 1){ permutations.push("fiirst"); }else{ gen(n - 1); &lt;- this thing did execute but they did nothing technically because you didn't capture the return value permutations.push("hi"); &lt;- your permutations is empty originally } return permutations; &lt;- permutations is currently ["hi"] } alternative way to do this without changing your function signature to achieve the same thing in first example. function gen(n) { var permutations = []; if(n === 1){ permutations.push("first"); }else{ permutations = permutations.concat(gen(n - 1)); &lt;- concatenates the array returned for each recursive call. permutations.push("hi"); } return permutations; }
(Edit: Not OP) I didn't know about `.some`, thanks! I wasn't worried about performance, so I'd have probably done `.filter(...).length`
Putting this in a top level comment: You have an array of objects, not a multidimensional array. This should work for newer browsers: ``` inventory.some(obj =&gt; Object.keys(obj).includes('name')) ```
It matters in Node where you really should not be transpiling. I also wouldn't necessarily say you're always going to be transpiling; I'm sure there are plenty of front-end jobs out there that aren't using Babel for a variety of reasons. EDIT: I think it's also helpful to know which presets you need to get certain features in Babel (for instance object rest/spread is only in stage 2 currently so the es2015 preset won't give it to you).
They actually allow addresses of more then just .edu , they have an entire git repo of school email addresses. :D
Yea I just figured that out as well. By the way I am making a steam bot, so no browsers are needed. Inventories are saved in arrays of objects, I though it was an multidimentional array, my bad. Thanks! :) **** EDIT: I don't think it will work with node: &gt; *TypeError: Object.keys(...).includes is not a function*
I think there is a small misunderstanding, they are extending window by adding brand new functions that don't already exist on window. They are not overriding. App and util are new functions the author has defined
Does this drastically differ from PyPm, Composer, Gems, Apt, or any other package-management library that supports dependencies?
If you can handle other languages js has a very low threshold to get in. Learning ES5 was more about patterns and best practices to overcome obstacles. I would jump right into ES6, which feels and handles like a complete language in the way you're used to. With that you'll naturally scratch build systems as well since you'll rely on Babel and most likely webpack or gulp to get something out of it. Check out http://exploringjs.com/ for a complete overview of the new JavaScript. http://blog.tighten.co/unpacking-webpack for a introduction into build systems and live debugging http://jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/ for getting Babel to make your es6 understandable to older browsers As for having fun, I had a blast with JavaScript so far because it is very easy to prototype out ideas on your head. This is one of the languages that will make sense while you're working with it without much guidance.
It's fine now but I worry about 20 years from now. There might not be web development jobs like we know it. There will be the need for people who can problem solve and use math, which is what a CS degree will teach you. 
Thanks! Is there also a way to check the content of name?
I mean the object has a lot of properties, one of the property is name, i am talking about the content of that. 
so the value of name
That works perfectly, thanks! 😉 One issue: It doesn't work on Facebook at all, my guess is that they use a different method of rendering text boxes to traditional HTML form fields. Would there be a way to modify this so as it can just add them whenever a cursor is active? 
Is this what you're looking for? `inventory.find(obj =&gt; obj.name === 'name here')` Edit: fixed the code, sorry I was a bit confused.
No. Before promises it used thunks.
I don't get this, why would someone have an issue with yeoman? Its a framework for scaffolding, it doesn't provide the scaffold implementation, if you don't like the code use a different generator, or write your own with functionality to continuously extend the app. It's like blaming bower or npm because you added a crappy dependency.
Just notifying you, I edited + fixed the reply. In case you already looked at it and didn't get a notification for the edit.
Discussion is continuing in my reply chain, I think the end result wanted is: `inventory.find(obj =&gt; obj.name === 'hello')` Yeah it was somewhat confusing and I didn't look at the pastebin, I should've done that earlier.
&gt; I would ask you to keep in mind that the babel-polyfill is a truly massive polyfill attempting to create a full and complete ES6 environment. And if I plan to write ES6 I never think about partial and incomplete environment. What's the point of half-baked solutions? We already have plenty of them! &gt; For most consumers, the important parts of ES6 are the syntax changes. Fat arrows give a standard way to capture this, classes a standard way to create prototype chains, modules a standard way to organize code, etc. Babel can downstep your ES6 syntax into ES3/5 just fine, without any massive polyfill. If everything I wanted were the syntax changes and classes, I'd stick with CoffeeScript. Its syntax is perfect for me. But I really want all the features that make ES6 really superior to any of those ***Scripts. And when I'm speaking of ES6, I'm speaking of it as a whole, not some subset of it. When we can use fat arrows but not generators, it's not ES6, it's a parody. &gt; We've always been in a situation where there was parts of the latest and greatest that just can't be polyfilled. Yes, ES6 proxies can't, but to some point we can live without them. &gt; If you ES6 modules and downstep it with babel, then use something like jspm, webpack, browserify, rollup, whatever, you will not occur this 100kb overhead. But in order not to occur this overhead, I'll be forced to use a very small subset of ES6, which eliminates the entire point of moving to it.
Emacs (spacemacs). Its basically Vim (the modal editing, and keybindings) with Emacs extensibility. Warning! You will get hooked, and will never be able to use any other editor after being a user for 1-2 months. (After you have learnt the basics) It also has a very active community, so you can get help basically around the clock on gitter, and github.
dick some cats
Well, I'll guess we'll have to agree to disagree, then. I'm really excited for the future of libraries that can ulitize proxies, generators, and such in really creative ways, but I don't need them in my day-to-day. I don't consider working without them a "parody" of ES6, since they were mostly intended for library authors anyway. Even stuff like promises are just a native implementation of A+, which we've had for a while in libraries like Q. The main benefit over using ES6 instead of coffeescript, livescript, whatever, is that it's the standard. CS has mostly fallen out of favor, at least on places like here. While people can debate about whether or not ES6 is too bloated, too influenced by sugary compile-tos like coffeescript, or whatever, the one thing that people cannot deny is it is the standard, and it is the future. One way or the other, we'll all have to learn it. Of course, it would be non-trivial to convert over from CS to ES6, particularly the 8kloc that were talking about earlier, so I don't expect you to just drop everything and rush to it. Just something to keep in mind when you start new projects, or write blog posts about just using it instead of ES6. 
postgres has a json datatype. which can store -- take a guess-- json object. if your schema is unstable, then you can use json type column to store unstable columns
[Image](http://imgs.xkcd.com/comics/code_quality.png) [Mobile](https://m.xkcd.com/1513/) **Title:** Code Quality **Title-text:** I honestly didn't think you could even USE emoji in variable names\. Or that there were so many different crying ones\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1513#Explanation) **Stats:** This comic has been referenced 70 times, representing 0.0667% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d1fcdiy)
Thank you all for the response. So, Webstorm I guess.
try setting the widths as percentages as opposed to pixels, that may help with accuracy. Also, strip all your elements (padding, margin, etc to 0 and set border: none). Then from there a further tip is set the background-color of each element temporarily to a color so you can easily see where they are being positioned. This setup should give you a clean scenario to set your elements correctly at certain percentages of the parent/body/etc. Assuming your style is clean on the elements, you should be able to easily set element widths as your attempting to do - I have a feeling there is some default style in each browser that you're not removing that's leading to the width being off a bit between (hence why I recommended stripping all the elements accordingly).
From the example dataset you provided it looks like it's an array of objects, typically called a collection. I don't know if you come from a php background but objects are like associative arrays except in JavaScript they are technically a different data type and inherit from a different prototype. I think what you want is var result = someArray.some(item =&gt; item.name &amp;&amp; item.name == 'hello'); The first check checks of the property exists and then it checks if it equals hello. 
Browserify, with the standalone flag does this.
I find most generators have a couple common problems that make them not worth it for me. First, you don't get updates to your code base. This wouldn't be a problem if you know it inside and out as you'd be able to understand and update it yourself. However that's often not the case. If you build your own generator, I guess that's fine. But then you're potentially generating multiple sites that require updating as well. We've taken the approach of a shared library for our sites. This library has the build system and lots of shared components. This way we don't duplicate code, and we gain updates across all of our sites.
With webpack it would look like ``` webpack &lt;source&gt; &lt;desitination&gt; --output-library-target umd ```
Yeah. I like to see that I am not alone, :)
Then you'd need to either do cd Desktop node main.js or node Desktop/main.js
I've always thought yeoman was great for quickly seeing how 2-3 components are supposed to be integrated, but I rarely actually used the code. It was more like using a scaffold as a cheat sheet to see how to wire things together. But I agree that the way yeoman actually wires things together is rarely useful
thank you bro 
What's wrong with xml? :/
https://www.reddit.com/r/cscareerquestions/
It's not json.
Best for layout. Json is much better for data.
Strings in javascript are UTF-16 or UCS-2, for which some binary sequences are not representable as raw characters. If you must use a string, it's common to encode binary data as base64 or hex. There is a workshop on nodeschool called [bytewiser](http://nodeschool.io/#bytewiser) that covers using node Buffers and typed arrays.
Fun fact: that's almost 10x the amount of subscribers as /r/hillaryclinton
What is BEM? I tried looking it up and no sites that mentioned it explained what it was. All I got is that it involves CSS or something?
It's not like there were thousands of packages relying on on `left-pad`. `line-numbers` relied on `left-pad` and `babel` relied on `line-numbers` and thousands of packages relied on `babel`. All these blog posts and /r/iamverysmart post-mortems were just people jumping on the bandwagon so they could have a cool medium post.
Callback is being treated as every other function, if you want to force alert cats to be executed when the stack is done executing set a timeout of 0 on it, although I don't see why you would want that 
yes
thnx
I agree with you 100%; however employers have the upper hand, you need the job, so if they make you jump through hoops then you do it. While that is the case then guides like these are useful. 
The browser doesn't need to wait for any thing to execute the click callback. Don't be confused by the word "callback", that doesn't necessitate that the function itself is async. Think about async in terms of cooking. You usually start boiling the pasta before you start cutting your veggies. But you don't put the pasta in the pot until the water is boiling. The callback for an asynchronous function runs when the water is boiling, so to speak. The part where this metaphor kind of breaks down is that in real life, the water can start boiling at any point during the veggie-cutting process. With the Event Loop, assuming your veggie-cutting is all synchronous, the post-water-boiling-callback can ONLY execute once all your synchronous veggie-cutting is done, because the async callback runs at the end of the event loop. Async is basically a way to handle future values NOW. In the case of the click handler, there's no future value handled in the present. So its synchronous. All it is doing is saying "when this thing is clicked, do x". And then you triggered the click event, which executed the non-asynchronous callback to the click handler. This would be different if, instead, your click handler callback was an ajax request to fetch some data and then do something with it. But in that case, it would be the callback to the AJAX request, not the actual callback to the click handler, that is asynchronous. tl;dr It's not the fact that a callback is a callback, but whether or not the callback handles some future value in the present, that makes it asynchronous
Anyone know this?
Weird. It works for me, and I'm on a Mac. Are you using Chrome? It might not work in other browsers...
Exactly, people act like you're paying for JUST the degree. You pay for the massive amounts of resources you get access too. (ya its way to much but) You should be making tons of connections in your junior/senior year and probably earlier which should be considered an investment
Not with 'use strict'
Hell, a person I met my freshman year introduced me to his father, who gave me a $4k contract to develop a web application for his company. Afterward, he recommended me on LinkedIn, and I was able to land a job throughout school.
Minification (with uglify or another library) should meet your needs of "obfuscation" well enough i'd think. A helpful side effect is a smaller file size as well.
I checked several dev as well as major subreddits (funny, gifs) and they all had huge downturns at the end of the year. Probably just the holidays.
I don't think people have "an issue with yeoman" per se. People are simply deciding against using scaffolders in general, at least within the context of their own projects.
Removing `user-scalable=no` from the meta viewport tag would probably be workable enough.
Thank you! Just ordered it. I assume it applies to all languages and is more of a meta book, right? 
practical advice: * do you want to start working today? no? go to college * can you get a job faster than 3 months that will lead to a career that can grow to 75k+/yr? no? go to college * you can always go to college later in life, i dont see any reason anyone would think negatively of more education i would recommend at least 1 class or mit-online-free-course, listing some college on resume will help for the job hunting. name recognition matters in the industry more than actual skills, ex-microsoft guys get more jobs than ex-tinycorp. (and microsoft is hiring mostly college grads) tbh as a software engineer no college is fine but a little harder to get an interview
I think we should use jQuery as our president.
The first example allows you to define methods on the resulting objects' prototype chain (which may result in better performance over adding methods to each object). Aside from that, the first method is more declarative (imho) because a reader will understand the object describes a book without reading the keys.
uglify is super easy to use from the command line. Install and usage found here: https://github.com/mishoo/UglifyJS2. Personally, I have a task runner do anything like that in a build step, but for a one-off I'd probably just use a web implemented one like https://marijnhaverbeke.nl/uglifyjs
 {} Though, if I am to be serious, I usually go with a revealing module pattern. var SomeObject = (function () { var api = {}; api.somePrivateMethod = .... return { somePublicPropert: "foo" } })(); Binds scope and does nice things, makes it easy to control visibility and scope, makes composition easy. 
It's a css philosophy that has a lot to do with class names. It emphasizes flat specificity, and class names that describe what the element is, not what it looks like. It stands for Block Element Modifier and has picked up some steam as of late. However it does come with some problems in my opinion like over verbosity and unintuitive modifier ordering. Check out JQuerys chassis project. One of their main discussion points involved BEM and they actually changed over to a newer version of it called BE M HA HA . I've used it in a few projects with a framework called InuitCSS and it's really helped me keep everything clean and efficient.
douglas crockford 2016 
Jay Query 2020
A big comment at the top of my code saying to pay no attention to the code behind the curtain. 
Oh you're probably right. Without looking that closely I thought of the graph as charting new subscriptions but if it's total subscriptions then probably a cleanup.
why do you have a self calling function at the start ?
There's still some advantages of XML. There's a standardized way to write a schema, and a built in way to transform XML into HTML (XSLT) 
Well become C programmer style wizards of the Internet!
It's actually still really good for lots of stuff. One of it's big selling points used to be that it smoothed out all the inconsistencies between browser implementations of things. This is much less of a problem these days but I think jQuery still has a lot going for it in certain applications. 
&gt; The code for leftPad might not be identical across all versions, it might just be functionally equivalent. If the newer leftPad introduces new features in a backwards compatible way, or it has bug fixes, then using the code's AST to check for equivalency won't work. If it's different across versions, then it's different whether you use a micropackage or not. I'm not sure I see how that would make a difference?
I've several times posted to SE with the specific statement "I don't want to solve this problem using jquery" in the text and there are ALWAYS people writing "just use jquery". What if I don't want to load a giant library to solve one little issue, fucker?
I wasn't aware of this, thanks for posting!
As a fairly seasoned developer, I have used a switch statement maybe twice. I find that it is a fairly ugly control flow construct, which always "breaks", and seems to be more verbose than it should be. Hence you have *more readable* solutions like: var lookUp = { 0: 'The variable "number" is set to 0', 1: 'The variable "number" is set to 1', 2: 'The variable "number" is set to 2', default: 'number is greater than 2 or less than 0' } var number = 2; var text = lookUp[number] || lookUp['default']; But in the context of the post, all of this seems entirely unnecessary. var number = 2; var text = (0 &lt;= number &amp;&amp; number &lt;= 2) ? 'The variable "number" is set to ' + number : 'number is greater than 2 or less than 0'; *edit thanks /u/wreckedadvent
If I'm consuming package A and package B which are each consuming different versions of C that are within a minor version of each other, npm will de-dedupe A and B's C dependencies in favor of the more recent version, regardless of whether the code contained within their C's is identical (assuming A and B's C version constraints allow it). Npm can do that because it knows that these C dependencies being within minor versions of one another means that they're interchangeable. It's possible for functions' implementations to change but for them to be equivalent from a consumer's perspective. Again, to summarize, micropackages provide versions for every public imported function, allowing npm to more accurately check imported function equivalency, enabling npm to more aggressively de-duplicate imported functions.
I largely agree with you, but your example makes use of chained comparisons, which javascript does not have. It'll *parse*, but it'll evalute `0 &lt;= number` and either convert this to `true` or `false`. This in turn will be compared as either `1` or `0` against `&lt;= 2`, which will always be `true`. You have to write it like this: var number = 2; var text = (0 &lt;= number &amp;&amp; number &lt;= 2) ? 'The variable "number" is set to ' + number : 'number is greater than 2 or less than 0';
jQuery? its one of the best lib out there dude!
You never saw a switch statement before?
So by convention, it'd be idiomatic to use a switch in that case? At least if you're releasing code and need to worry about not using concepts that'll surprise other developers in the wild... 
Sure haven't, but then I've not used much javascript other than for a few hobby projects here and there.
I second this. Wonderful book.
I think they mean recommending jquery for things like [this](http://stackoverflow.com/a/34458158).
pretty language agnostic, but hey, always good to learn something now
It depends if you ever need an instance of an object vs just... an object. Having an instance basically does 2 things - bind `this` to the object itself within that object, and calls the constructor. Each object is unique but share the same type - `instanceof` works. I would generally favor using a POJO (plain old javascript object) for storing data or acting as a simple static class with methods, and a class for things I'll need more than once with a separate context - separate class variables. For example I'll prefer this: getBooksInformation(function (response) { return response.books.map(function (book) { return { author: book.author.name, isbn: book.metadata.isbn }; }); }); Over this, which seems to be overkill for just storing the info: function Book(bookData) { this.data = bookData; } Book.prototype.getAuthor = function () { return this.data.author.name; }; Book.prototype.getISBN = function () { return this.data.metadata.isbn; }; getBooksInformation(function (response) { return response.books.map(function (book) { return new Book(book); }); }); On the other hand there's no way to tell if a POJO book is a book except duck-typing, whereas you can be reasonably sure every Book instance has a `getAuthor` and `getISBN` method, or if you use `Object.defineProperty`, the equivalent properties. If the concept of a book is prevalent throughout your code then definitely use a class to represent them. If it's something you need in one place or have a single factory for, then POJO is fine. 
Thanks. Just got it. Liking it so far! =]
The most simple way to go is the object literal: var o = { property: "value" }; Many people will recommend silly things like factories, prototypes, and inheritance. You don't any of this insanity. The reference bound to the object (in this case `o`) can be referenced as a closure and populated as needed. This demands some understanding of scope, but it allows everything dynamic the other suggestions have mentioned, but without any repetition and without extra code convention silliness. 
To be honest, that really just seems like grasping at straws. I really can't see that happening often enough to justify spamming the ecosystem with millions of one-function package. If it was really something worth solving, you'd still be better off just adding versioning information on a per-file or function basis rather than turning `underscore` into 12,000 different micro packages. 
Wow, I am impressed you are allowed to do that in JavaScript.... And the fact how awful it is. It would literally evaluate all `case` conditions, worse than an `if-else` chain: var number = 4; function check1(number) { console.log('checking case 1'); return number &gt; 4; } function check2(number) { console.log('checking case 2'); return number === 0; } function check3(number) { console.log('checking case 3'); return number === 4; } var text = (function() { switch (true) { case (check1(number)): return "Number is greater than four"; case (check2(number)): return "Number is zero"; case (check3(number)): return "Number is four"; default: return "Number is something else"; } }()); 
Why not just externalize the methods at step 3? function f() {} function g() {} function createThing() { return { x: 4, y: 3.14, f: f, g: g }; } var o = createThing(); Granted there is some slight performance overhead for having a reference to the functions on every object created, but prototypes are a micro-optimization only useful if you're creating thousands of objects rapidly. In my opinion, this is a much simpler/straightforward way of sharing functionality in objects in JavaScript. Not to mention the methods are explicit, meaning they show up on the object when you inspect it, rather than having to inspect the prototype.
Found this funny: &gt; Experienced Babel 6 users will dismiss my assertion that configuration is hard. "It's easy!" they'll say. You change one file: .babelrc, npm install your presets, install your plugins and modify your update your webpack config and you're good to go! It's 60 seconds work so you are speaking garbage Let me make a simple tutorial for you: A little tongue in cheek, but all you need to do is create a file called `.babelrc` and put in { presets: ["es2015", "stage-2"] } to get everything you could possibly ever want from babel. Then you would need to do npm install --save-dev babel-preset-es2015 babel-preset-stage-2 to have the presets installed. Then, if you don't have `babel-cli` you would do npm install -g babel-cli and then babel example.js -o compiled.js There's more in the handbook here if you're curious: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/user-handbook.md#toc-babel-cli This is babel's most basic usage, and it really, truly isn't hard. It's well documented, and all it's doing is a `String -&gt; String` conversion. I agree that webpack is hard though, which is why I wrote a tutorial for it (shameless plug: https://github.com/AriaFallah/WebpackTutorial) instead of writing a blog post about how shitty webpack's docs are. 
I prefer using Object.create(). It's probably the cleanest way to do it. 
The external functions wouldn't have access to the object state.
Easy prototyping? I love that. What did you make, and how long did it take?
Babel 6 does not believe in sensible defaults. This is a little unfortunate, considering every other javascript transpiler (including Babel 5) *does*. However, this conversation has already been talked to death, particularly when the "fatigue" articles came to be and pointed at babel for contributing to it. 
I've read probably a dozen articles like this. They all assume that there's one master configuration that most people use. The truth is that almost every project needs to be configured differently. I have something like 50 repos on my machine that use Babel. Each of them do wildly different things based on how performant they need to be, how much I care about using the newest syntax, maybe they use React, maybe I'm just testing something out. Babel has a lot to it because it has to support an incredibly diverse and wonderful community. There is no "Babel Community", there's a bunch of people from every JavaScript community that use Babel, each of them have very different priorities and requirements. If you want to see a completely configuration-less Babel that just compiles ES2015 to ES5, you are free to build that using Babel in the background. It's actually quite simple to do. But you will quickly discover that it isn't so simple, and you'll either be limited to a very small subset of the total Babel user-base or you will start working in the same direction we had to with configuration.
Why?
Aurelia is not a replacement for ASP.NET MVC, it would only replace (at most) the razor view files you have. You would still need a server, maybe Web API.
Babel's purpose is to provide a generic JavaScript transpilation framework. Additionally, Babel's main use case is to transform ES2015 to ES5. This can alienate beginners, who simply want to learn the most up-to-date syntax for the language without major setup. The solution? Create a package that provides defaults &amp; wraps the babel packages. Right now doing it yourself uses the packages `babel-cli` and `babel-preset-es2015`. The JavaScript API resides in `babel-core`, other presets are in `babel-preset-*`, and individual plugins are in `babel-plugin-*`. But what if you could just run `npm install --save-dev babel`? Babel 5 worked exactly like this. All the package would need to be is a bin script that passes the es2015 preset through to the core package. No config needed, and the only CLI inputs needed would be an input and output file (or directory). Simple as that! Want better configuration? Need other plugins? Just switch your `babel` devDep for a `babel-cli` devDep, and start installing presets/plugins and adding config to your .babelrc. This way, both systems can exist in harmony with each other.
&gt; At the end of each case statement, you must provide a “break;” to indicate the end of the case so that the program knows to move onto the next case. Is this correct? I thought breaks are there to tell the switch statement to **stop** checking against any remaining cases.
Well, that comparison might not be the most ideal, since webpack is one of the other things that people often cite when they say it contributes to their "javascript fatigue". If you compare setting up a webpack project to a JSPM one, it's night and day. There's a similar situation in setting up babel, compared to something like typescript. And of course, it's much worse for newer developers. There's some light on the horizon, at least. The last time this conversation came up, there was talk of a [babel init](https://phabricator.babeljs.io/T6956) that would allow you to get up and running with babel without any prior knowledge of how to do so. That would be a serious boon, and I hope it goes somewhere.
the fuck? C# MVC and aurelia are way totally different. hell the only ~~thing~~ skill common in them is clean coding. not even object oriented principles can help you there. First of all, do you understand the difference between C# MVC and js aurelia? they are complementary, not competitors with a small blur between their fine line. You can use them both at the same *time* on same *project*. C# MVC is backend .code runs on server and sends html, css and js (aurelia) files to client. while js aurelia is frontend. the code runs on client side browser (between anything from blackberry phone to macbook) and is served from server. whoever told you to switch to javascript and api was most likely saying it from hype surrounding js. make no mistake, more than half of the concepts you learnt on C# MVC are useless here. if you have to make a switch please consider php laravel(very similar to mvc) or nodejs adonis. if you are dead set on using js and aurelia, then learn js but not aurelia. just like C# is quite different than C# Asp.net MVC. similarly javascript is a lot different than js aurelia. if you try to learn aurelia along with js, you will never be able to tell where js ends and aurelia begins. So learn js properly( using vanilla-js only). then move on to vue(because I like vue), gulp/webpack and then and only after then try aurelia. if you are thinking: what is vanillajs/gulp/webpack? and how they ended up here? haha, write a book on your transition from mvc to aurelia. it will be a best seller among programmers for sure. &gt;Whats the best way to handle authentication while being in a Microsoft environment (internal business apps), where windows authentication has been used frequently? ~~one internal site at my company used windows authentication. and it works **on I.E only**~~ better idea would be to make a login form. and check credentials server side. EDIT: as i have not checked the code, I think it is wrong of me to use it as example.
Interesting, didn't do my diligence. Good to learn I am surprised this is allowed, since it cannot be compiled into a jump table or hashtable as would a number or string based switch statement, but hey I don't have to use it, since it doesn't seem to be more performant than if-else 
A Set is the right general data structure, depending on your needs. It's only available in ES6 though so this won't work if you need cross-browser compatibility. If you do, use an Object.create(null) (an object that has a null prototype) and set the URLs as the properties.
Fun way to see this in action. Open up your console and type: foo = console.log foo(1) // throws exception foo.call(console, 1) // identical to console.log(1) 
&gt; Why not just externalize the methods at step 3? You're right. That would work too.
&gt; If it was really something worth solving, you'd still be better off just adding versioning information on a per-file or function basis rather than turning underscore into 12,000 different micro packages. Yes, except npm doesn't allow you to version individual functions within each package, there are no plans to add this feature, and as far as I know it doesn't exist in any other language's package manager either. Micropackages offer a solution to a real problem that js devs encounter frequently. There are legitimate criticisms of micropackages in terms of lack of ease of development and discoverability, but there's a good reason people write them and use them.
That's a great discussion, except for one thing: &gt; So, here's how things evolved. That seems to imply that the features mentioned were added to the language in the order they are listed. Sorry if I misunderstand you, but if this is what you meant, it's not correct. Object literals were not present in JavaScript 1.0 or 1.1. They were [added in JavaScript 1.2](https://news.ycombinator.com/item?id=8344908). Functions and prototypes came first; they were [present in JavaScript 1.0](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype). So this code would have been valid all the way back to JavaScript 1.0, unlike object literals which didn't come along until 1.2: Thing.prototype.f = function() {}; Thing.prototype.g = function() {}; function Thing() { this.x = 42; this.y = 3.14; } var o = new Thing; 
You're right. I probably should have phrased it as, "here's how the concepts build on each other," or something along those lines.
I found useful this one for myself https://www.youtube.com/watch?v=MhkGQAoc7bc
What's the difference between `new x;` and `new x();`?
Well, that's sort of what I meant: If you're going to complain about the current JS ecosystem, and your focus is on *babel* being hard to configure... :)
Is there a difference in ES6?
https://scotch.io/tutorials/learning-react-getting-started-and-concepts this is the best i guess.
&gt; Yes, except npm doesn't allow you to version individual functions within each package This has nothing to do with NPM. It's an optimisation problem, to be solved by an optimiser. NPM does not need to know or care about it, nor should it. &gt; Micropackages offer a solution to a real problem that js devs encounter frequently No they don't. It's a problem that is rare to begin with, since duplicate package versions are a major red flag to avoid in the first place, and is easily solved with a basic optimisation pass. Micropackages simply increase the likelyhood of a version mismatch in the first place. It's an utterly terrible solution to something that isn't a problem to begin with. I can't even imagine the pain of trying to resolve a dependency tree with tens of thousands of functions versioned individually instead of one or two utility packages. It'd take hours just to resolve a simple project, and good luck trying to manage any version upgrades by hand.
&gt; The truth is that almost every project needs to be configured differently. Not only that, but every project needs to be configured differently *over time*. Right now my company uses ES2015 features and target ES5. In four years we may use ES2019 features and target ES2016. Babel could do `["es2015", "stage-2"]` by default, but that's only going to be a sensible for, say, the next few years. At what point should Babel default to ES2016 or ES2017 input? At what point should Babel transpile down to ES2015 rather than ES5? It's highly dependent on your business requirements and which environments/browsers you need to support.
Thanks! I have been working with javascript for about 4 years but I found this very helpful. 
Thanks for the correction. One day, I'll figure out all the quirks in JS semantics.
Thank you, this is a great explanation! 
Google Closure actually has a stellar standard library. Unfortunately, that comes with the requirement that you use Closure, which is overkill in many cases, never mind the compatibility concerns.
Wouldn't `this` be `window`: var otherConsole = { log: function () { console.log(this) } }; window.addEventListener('click', otherConsole.log); // window
You usually do. If there is need to extend or get another instance, I toss methods on it. otherInstance = SomeObject.clone(); For instance. otherInstance.extend({ ... }); Etc.
I second Visual Studio Code... I've switched from WebStorm recently and I like the sleek design (less distraction)
Yeah.
I wrote it wrong I just fixed the question and I haven't learned map yet only basic loops.
 function hasKey(arr){ for (x of arr) if (typeof x.hello != 'undefined') return true return false }
The script doesn't work though?
Left pad is an external dependency, being slightly more readable doesn't even begin to be worth it to have an external dependency.
edit: one guy suggests using `xhr.setRequestHeader('Content-Type', 'text/plain');` and then it works -_- i asked about this and the site the txt file is hosted needs to have the cors header or chrome client wont be able to load it --- cors wont let you load images/js from another site. maybe you can if the url is whitelisted in the manifest (not sure where), but maybe espn doesnt allow cors so blocking it (probably not though).... ask on #chromium on irc: webchat.freenode.net
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/depthhub] [\/u\/MoTTs\_ explains best practices for object instantiation in JavaScript](https://np.reddit.com/r/DepthHub/comments/4c9i48/umotts_explains_best_practices_for_object/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Mind blown. This is so simple. 
I optimized the latest version a bit further: https://jsfiddle.net/bvrwf9m8/30/ i wen from the indirect representation to a direct one, where the dots only have the necessary information. In the calculations i tried to work as close on memory as possible, which on my computer gave me a speedup of ~ 10%.
 var obj = (function () { var test = function () {return "hello";} var c = function (params) { for(var k in params){ this[k] = params; } } c.prototype.hello = function () {console.log(this, test());} return c; })(); Revealing pattern, allows private methods/properties, etc.
Yes, your answer works, thank you. Also there is a simplier way, not resetting the counter, but checking it with %3 instead of &lt;=2. Or even more simplier way, without any counter, but using this if ((j+i+1)%3 == 1) s ="class ='r1'"; else s ="class ='r2'"; A bit harder to understand, but no counter required at all.
Thanks for the explanation. I didn't understand why promises catch like this didn't work as expected: .catch(consol.log) Now I understand.
Right. I would still use a Web API using C#. 
&gt; new is deprecated Lolwut?
Would have loved to see a feature comparison to page.js
Is this finally gonna be the year of JavaScript?
The way I interpreted it was here's how technique has evolved, more or less.
Considering how libraries/packages basicly are the norm in the Node ecosystem + the API docs show no evidence of baked in DB drivers, you're better off just using a library. The simplest solution I can think of without any libraries is to execute command line commands such as: mysql -u USER -p PASSWORD -h MYSQLSERVERNAME -e 'select * from foo...' database-name Disclaimer: This not a good idea. :-) Look up child_process/spawn on how to execute shell commands in Node. Why are you trying to avoid using libraries anyway? You will end up writing all kinds of code for input/output, error handling etc that's already in a bug free library somewhere.
jQuery is a Swiss army knife for DOM manipulation; it doesn't come close to matching the standard library of other languages (eg. Java).
your receiving site needs the cors header. `bar.com` needs to tell chrome, through headers, that it can receive cross origin requests (e.g. from `foo.com`) &gt;The Cross-Origin Resource Sharing standard works by adding new HTTP headers that allow servers **[bar.com]** to describe the set of origins **[foo.com]** that are permitted to read that information using a web browser. https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS
ahh ok thanks a bunch
I think the main argument is essentially that JS classes are not like classes from other languages (such as Java), since it's really just sugar on top of existing prototypal inheritance. They behave no differently than simply creating objects, and you're basically just abstracting it. I think if your experience is primarily Javascript then it probably doesn't matter though, since you will just know that ES6 classes are sugar. Anyways here's the chapter where he talks about in depth (and there's more discussion of classes in other chapters). https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch6.md Keep in mind that my example is also not exactly what Kyle Simpson would do. I overrode `Element.init` in the `Button` object. More in line with his way of thinking would be something like var Element = { init (type = 'div', id = '') { this.type = type this.id = id this.element = this.register() this.element.id = id }, register () { return document.createElement(this.type) } } var Button = Object.create(Element) Button.setup = function (id) { this.init('button', id) } var submitButton = Object.create(Button) submitButton.setup('submit-button') console.log(submitButton.element) So now the new `Button.setup` method is just calling its inherited `init` method...
Sure is a lot of work to create a non-funny joke.
Performance is not really an issue. It's a matter of trading memory (sharing methods between instance) for performance (extra lookup to the prototype object instead of the object fields directly). Personalty the advantage of using prototype if to hide the methods (not iterable). You're attaching behaviour to data, not adding a field to it. You can do it with the factory pattern, but it is not as easy to read.
@kowdermesiter, this router doesn't have a built-in navigation module. So it can work equally well with both #hash-based URLs and HTML5 History API. For example: -- Hash-based URLs, e.g. example.com/#/about function render() { const path = window.location.hash.substr(1) || '/' router.dispatch(path); } window.addEventListener('hashchange', render); render(); -- HTML5 History API, e.g. exampe.com/about import { createHistory } from 'history'; const history = createHistory(...); history.listen(({ pathname as path, query }) =&gt; { router.dispatch({ path, query }); }): 
As an Aurelia core team member my opinion is biased here and I won't touch on any comparisons but here are some tips I have from working with many .NET shops looking to transition to a JavaScript framework but still use .NET - 1. Use ASP.NET 5 if you can. ASP.NET 5 is the least obtrusive version of MVC that stays out of the way so you can separate your client side code from your server-side code and requires the least configuration. If you like strong-typing you can use TypeScript as pointed out, here is a great starter kit - https://github.com/aurelia/skeleton-navigation/tree/master/skeleton-typescript-asp.net5 2. Windows Authentication is definitely the easiest solution that only requires setting up IIS from what I can tell working directly with teams as a consultant who are more familiar with Windows Auth than I am. The gotcha is that the GitHub Fetch standard doesn't allow passing cookies so you probably need to use the http client instead of the fetch client. 3. Consider dropping Visual Studio for development and use it for publishing and such only. Visual Studio doesn't support TypeScript, ES7, etc.. very well and often will hang up on npm installs. If you must use it prepare for a few gotchas (this is independent of Aurelia and is true for any npm dependencies that are large in size) 4. VSCode works great, but it still doesn't have good ES7 support. If you are using TypeScript this doesn't matter. It is still a beta product though so keep that in mind. 5. Join our official gitter - https://gitter.im/Aurelia/Discuss - there are developers in there most hours of the day / night around the world able to lend a helping hand if you hit any snags or need any pointers. Hope this helps!
so much YES, fucking jquery
Seriously no meme, was [trending on github](https://github.com/trending/javascript) this morning.
Presumably some users won't update and people will continue will subsequently want to use es7..n features on browsers that only support es6 so never? 
To get your work done, you don't need a CS degree. It might be a requirement at some of the employers to get your foot in the door, but that depends on where you live. I have a lot of friends (I live in Dallas, TX) who are great programmers, and have the same job as me, but no CS degree.
&gt; non-funny In order to get the joke you need to understand the current state of public npm packages, the overuse of unit tests open projects, PHP's recent code of conduct debates
Using `switch`is and is not idiomatic. It's a language construct that's available as both a compact statement for multiple conditional checks, and one that allows easy fall-through of multiple conditions. Redux tutorials likely use them because, unlike skitch920's statement, they are simple to read and understand, and they don't require pointless work-arounds. Use a switch statement when they make sense; there's nothing wrong with them.
I've got a link collection of high-quality tutorials on React, Redux, ES6, and related topics over at https://github.com/markerikson/react-redux-links . The collection is sorta aimed at people who actually know Javascript already, so I don't have any basic JS tutorials listed in there, but the list is intended as a solid set of starting resources for someone who wants to learn React and Redux.
It is probably more meaningful to write a DB client library. It usually involves setting up some TCP or IPC connection with auth/enrypted/compressed binary protocol on top. Http/XHR is basically a client library for a database (HTTP server) that stores HTML files (with CGI/webapp as stored procedures). Just that in http case, the connection/auth/encryption/compression layers are already implemented for you.
CouchDB's API is HTTP, so you can use it with the built-in 'http' node module. http://couchdb.apache.org/ 
&gt; `this` inside a callback would point to the event rather than to the console object That's the statement I was trying to correct. Unless I misunderstand something, in `$0.addEventListener(event.type, console.log)`, `log` would be getting `window` when it means to get `console`. You has asserted that it would be getting `event`. It doesn't really matter, since unless it gets `console` it's wrong - I just wanted to make sure we had the same understanding of what's going on.
http://courses.reactjsprogram.com/courses/reactjsfundamentals This one is really good and covers a lot of ground
In that case, you probably should look into the protocol of the database in question instead of hacking on shell commands.
Unless I'm totally misreading that page, you'd need to do `console::console.log(something)`, which kind of defeats the purpose. It's a really neat idea, though. I like how it turns `this` into a de-facto stdin, allowing you to compose functions like bash commands.
I'm not sure vanilla reddit has the idea of a current comment. RES adds a class when you click (or keyboard navigate, I assume), though, so you can use that if you have it installed and active. $('.RES-keyNav-activeThing').attr('id') That gets the id of the current active comment. 
Yah man, i hear what you are saying. I must admit to being a bit of a noob when it comes to all that CSP is used for. There's some cool things they are thinking about that doesn't even cross peoples minds. On a random related note, csp inspired me to write alts for promises: https://github.com/richardanaya/alts
This test: var otherConsole = { log: function () { console.log(this) } }; window.addEventListener('click', otherConsole.log); shows `this === window`. Is the test incorrect?
 function shittyTree(totalShitLines){var shit="";var midShit;for(var i=0;i&lt;totalShitLines;i++){midShit=i*2+1;for(var j=0;j&lt;totalShitLines-i;j++){shit+="-"}for(var k=0;k&lt;midShit;k++){shit+=midShit}for(var l=0;l&lt;totalShitLines-i;l++){shit+="-"}shit+="\n"}console.log(shit)}
awesome. how can I use this?
I don't think `div` can be focused unless they have `tabindex` on them though. Can't verify this on the phone, but I don't think reddit has keyboard nav without RES 
I don't much to have to say about the project itself, but this: https://demo.extraverse.io/files/LICENSE For some reason, now I want syntax highlighting on *all* license files. 
Took 1 minute off my build on Team City when I did this. The slowdown is immense.
If you're using XHR within a Chrome extension, you shouldn't have to worry about CORS. Chrome extensions are privileged and can make cross-domain Ajax requests without the remote server needing to support CORS. If you find this isn't working for you, (a) you might need to make the request from a background script (content scripts are not privileged since they run in a page context); (b) it's possible (though unlikely) that the jQuery abstraction is preventing this from working. Try doing a sanity check with the bare `XMLHttpRequest` object. If this is an actual userscript, like a GreaseMonkey-type thing, you shouldn't be using `$.ajax` at all; you should be using [GM_xmlhttpRequest](http://wiki.greasespot.net/GM_xmlhttpRequest).
*My perception* is that the ES6 class critics are a vocal minority. Though, minority or not, they do include some respected people, such as Simpson and Crockford. [I've argued](https://www.reddit.com/r/javascript/comments/4bmiqj/using_classes_in_javascript_es6_best_practice/d1asmsw) that the abstract concept of a class is more important than the concrete implementation, and that there's a wider variety of class implementations out there than just Java's.
&gt; In its unary prefix form, the :: operator creates a bound function such that the base of the supplied reference is bound as the this variable to the target function. Basically, it binds scope to the object it's prefixing. So `::console.log` === `console.log.bind(console)`
Above and beyond! You're awesome, thank you. I'm going to mess around with the tagline selector, currently if you faux-gild a child comment, the parent gets faux-gilded as well. 
You can write ES6 js and convert down to es5 with tools ("transpilers") like babel. Completely fine to do in a prod environment. ES6 is easier to use, harder to screw up (const, let and fat arrow function scopes make a lot more sense).
Obfuscation and size. 
less bytes
Thanks for that great post and the links to your resources!
Yep, for that you would need to use on the server as well, for example: import express from 'express'; import Router from 'universal-router'; // Configure isomorphic router const router = new Router(); router.route('/about', () =&gt; '&lt;h1&gt;About Us&lt;/h1&gt;'); // &lt;- This might be a React component // Configure Node.js/Express app const app = express(); app.get('*', async (req, res, next) =&gt; { try { const html = await router.dispatch({ path: req.path }); res.send(html); } catch (err) { next(err); } }); app.listen(process.env.PORT || 3000); In practice, the router is configured in some external file, and then you import that file in your server-side and client-side bootstrap scripts. See [React Starter Kit](https://github.com/kriasoft/react-starter-kit) as an example (src/server.js, src/client.js)
Soon, very soon, this will draw something inappropriate. 
Another vote for this. Think of a tool or a game or a library anything that interests you. That is the best way to learn anything.
yes, i'm sure. [here's a recent changelog where they explicitly address the issue](https://github.com/npm/npm/blob/master/CHANGELOG.md#performance-improvements). like i said, *mostly* fixed. there's still some work but it's nowhere near the issue it used to be.
That's actually a good idea. I'll have to look into that.
Ah, I see. /u/phkavitha, should've mentioned this sooner, but maybe try upgrading your npm version? `npm install -g npm@latest` should do the trick.
I'm 25 and graduated with a degree in Interpersonal Communication 3 years ago. I was 100% self taught up until I started at a small start up after I graduated doing a lot of front end work and they taught me a ton of C#. Now I'm a full stack developer working with JavaScript &amp; Clojure all day. The most my degree has ever come up in an interview was more out of curiosity than anything, it never hindered my ability to get a job (or interview).
Very nice. Fira Code ligatures are weird but kind of beautiful.
I could push it to production setup that I, personally, own but I'm not going to sell it to my managers just because it allows us to have const, let &amp; fat arrows. Our current stack works as is, and the gains we are to make towards using es6 are minimal compared to the amount of effort required to set it up and ensure that is works perfectly. There's a reason lots of people are complaining about JS environment being a war-torn land between different factions on build tools. At the end of the day, most businesses care more about value than what an IDE contains. And I won't really blame them. With each layer, you are also adding more bugs specific to the layer. On a side note, I'm more ecstatic on tail call optimization, modules, Promises &amp; generators over the small stuff like let/const/fat arrows. The latter are trivial to solve with enough discipline while the former are adding features that were previously hard, if not impossible.
I agree about global modules, but there is some incorrect information in the article. Scripts in the package.json work with local modules automatically. No need to write "./node_modules/.bin/karma start", you can just write "karma start". NPM automatically resolves local module executables.
Indeed, and `./node_modules/.bin` is resolved at the beginning of `$PATH` so local bin files take before globally installed executables.
I'm using npm that comes with node. And, the node version which I'm using is above 4.0 version. 
Except that you still need to configure the build.
Thanks! I didn't know that :)
Guys v2 is out already with better UI (well comparatively) and performance enhancements.
True that. Oddly enough, it's been the place where I've played around with most of the features. Problem with production code in a widely used app, we have ensure all browsers are supported :(
Could you explain the last bit a little deeper as I'm wondering myself what the purpose of build targets would be since your clients run whichever system. Some browsers will support es6, done will not. I use Babel myself but there are huge performance hits in some areas which already forces me to mix es5 and es6, avoiding things like for-of or spreads. 
No need to use bloatware like jQuery, especially when using a *browser*: targetCode = "&lt;a href=#&gt;&lt;span class=gilded-icon data-count=1&gt;&lt;/span&gt;&lt;/a&gt;" addEventListener('click', (e) =&gt; (e = e.target.closest('[data-type="comment"]')) &amp;&amp; e.querySelector('.tagline:first-of-type').insertAdjacentHTML('afterend', targetCode) )
This works better than the parent comment. I gave you 7x fake golds.
Yeah, I strongly agree with this. Rarely is there a good reason for consumers of your project to need to do more than an "npm install" to get started; forcing folks to do do global installs is asking for trouble.
Once you learn the true Force (of the DOM APIs), you'll never be seduced by the dark side (like jQuery). The ten keys to learning it are: `querySelector`, `querySelectorAll`, `addEventListener`, `matches`, `closest`, `matchMedia`, `localStorage`, `DocumentFragment`, `classList` and `insertAdjacentHTML`. Combined with powerful weapons like CSS3 selectors and native ES6 (or even ES5) prototypes, this will allow us to bring the light back into the Web galaxy and overthrow the dark reign of bloatware libraries. Good luck, young Padawan.
Also pragmatic programmer - distilled experience over time. http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X
:] I'm actually a developer already and not OP. I just appreciated copying and pasting your code which worked without side effects. 
If you're trying to show that `this` is always equal to `window` in an unbound handler, then the test is incorrect. What you're actually showing is that `this` is a reference to the object that addEventListener was called on.
What do you mean 'it breaks it'? Why aren't you returning true, instead of the value? Finally, I think it is working, you just need to wrap it in another function, or change the conditionals. * console.log(isPrime?(17)); * or * change the return false -&gt; console.log(false); It might be a problem I don't understand though. e: oh, you can't return false, try returning -1. This is still considered 'falsey' by JS.
Circleci, Travis, sure there are others...
&gt; I actually launched Micro.js a few years back to highlight useful, small libraries Given my admiration of the entire Micro.js project (and most libraries participating in it) I don't really understand the author's point at this matter. Dependency on some Dick's-from-a-mountain left-pad is surely crazy, no one argues with that. The matter is... what do you really expect to see in that "standard library"? Why does everyone connect some miraculous lack of core features to NPM? Node isn't the primary platform JS was invented for! Yes, I know it's an unpopular opinion these days but I still consider browsers the primary JS-driven platform. And yes, browsers are finally taught to run it well, Node's always catching up. Yet I firmly state that this lack is *miraculous*. Have you really forgotten how to program? Have you read even a quarter of MDN on what features you are given right here and now? And ES6 gives you even much more. And its key strength isn't in new standard APIs. It is in abilities to modify the very way your programs behave: proxies, generators, reflections, destructuring. Still some complain about the lack of standard prototype of string padding... how ridiculous. It's sad to see most devs are viewing JavaScript as a sort of unserious, Schizual Basic-like stuff. So they demand some no-brainer things that match their own entry level. Just take some time to actually read the fucking manuals, and lots of silly questions like "where's our leftpad" will vanish in the sight of real perspectives this language opens to you.
I'm no expert or pro... and I'm going to make this as simple/dumbed down as I can... - Most everything in javascript is actually an object. - The built-in objects (Object, Array, Function, etc.) can give rise to new objects. - All arrays in javascript inheret from the built-in Array object via a thing called a prototype. - This inheritance means that all arrays will have the properties of the built-in Array object. Example code with comments: http://codepen.io/anon/pen/RagzwQ?editors=0010 Let's try starting with that... Let me know your questions!
Ahh, good point.
In the OP's case, he actually probably doesn't have to worry about them as all his strings will be URLs. But just check if the string you're going to search for is one of the included function names then... do some error handling... I guess?
&gt;Browsers are good. Dumb HTTP clients like IE are bad. Come on? IE is a browser. Still with a large enough market share to make libraries that abstract their BS very useful, and these problems go deeper than the API's you listed off. Again, In the context of enterprise software JQ is not bloatware and it's madness to claim it is. Adding it to an extremely trivial project? yup I'm right there with you, you don't need it.
A think-out-of-the-box approach: Po2 = (n) =&gt; 1 &lt;&lt; (n.toString(2).length - 1) === n Some tests: Po2(1) //true - 1 is 2^0 Po2(2) //true Po2(3) //false Po2(65536) //true Po2(65537) //false How does it work? Simple. The `n.toString(2).length` snippet counts the bits in the number binary representation. The `1 &lt;&lt;` operator prepares a perfect power of two (provided the actual bit length decreased by 1). Finally, we just have to compare the input to the perfect power of two with `===` operator. That's it.
Your code is almost correct. The problem is that the result of the recursive call is not returned anywhere.
how is that simpler?? Also, im trying to learn recursive functions, thats why Ive been trying to write a recursive function.
Okay, stay with your ActiveX components and other faildows enterprise-grade BS, I'm not going to persuade you anyway.
Cool, thanks, I'll give it a shot and pull it to my lib. 
This on the "simple" setting not only removes comments and white spaces, but also changes variables to a single letter. http://closure-compiler.appspot.com/home
But webpack is amazing. And with tree shaking it's amazinger.
If you haven't already, you can read some of the answers in https://www.reddit.com/r/javascript/comments/4c7dfn/which_way_is_the_best_way_to_create_objects_in/ Many touch upon oop/prototypes (sort comments by `top` to get the better stuff first)
Efficient pure-maths one-liner, no recursion: isPowerOfTwo = x =&gt; ((y) =&gt; isFinite(y) &amp;&amp; Math.floor(y) === y)(Math.log2(x));
 function powerOfTwo(love, life){ if (love.mine &amp;&amp; love.yours){ var total = love.mine + love.yours; } return life * Math.pow (2, total); } Credit to the original developers (the Indigo girls): https://www.youtube.com/watch?v=hj0yVN8pFNw
I appreciate the effort and trying new things, but I don't see any advantage to this over the hundred of template languages that already exist. I think you over estimate your first point. "No need to learn a new language." Yes, it's JS, but the syntax is specific to shaven. If you are trying to get people to avoid learning HTML, I think that is a bad idea. People will have to learn it if they want to do web development. Template languages that look like HTML are much easier to understand. I think that is a large reason why JSX has become so popular. It could have been written in pure JS.
Thank you! I love in-depth optimization analysis like this.
oh okay thanks! I missed that! Another question: why would be function NumberAddition(str) { var sum=0; for (var i=0; i&lt;str.length; i++) { if (str[i].match(/[0-9]+/)) sum+=parseInt(str[i]); } return sum; } NumberAddition("5Hello55") wrong? It adds the numbers, but only as single digits..
yea thats true, i should change it to result&lt;1 and result==1 instead of 2 then. oh and the question is bounded to integers.
Two things: 1. That version of the function iterates through the string character by character. Therefore, `str[i].match` only looks at the one character at the current index in the string. (Btw, if you want to check if a string fulfills a regex, use `str[i].search(regex)`.) 2. The "+" in your regex causes it to match with one *or more* items that fit the expression. So, while `"555".match(/[0-9]/)` would return `["5", "5", "5"]`, `"555".match(/[0-9]+/)` would return `["555"]`.
But thats what I need to do- iterate through the string character by character and then if it finds a number btw 0-9 it adds it to sum. Also, ""+" in your regex causes it to match with one or more items that fit the expression" That's again what I want- if 5 and 5 stand together, I want to treat it as a 55.. 
Thanks for this, /u/klsdfjsdf - I've updated the blog post accordingly.
Update: the FAQ has now been published, and is in the Redux docs at http://redux.js.org/docs/FAQ.html .
Gearz
that is wrong. Angular and react both use HTML as shorthand accessors for javascript. There are tons of cases where a container node is used to mix in functionality in React. You could, in fact, probably code 80-90% of Angular's core directives in React if you wanted to. The most fundamental difference is that Angular uses two-way binding and an inferred/buried update cycle, where React uses a largely externalized data model and a very explicit update cycle. Also, react has a singular repeated atomic structure, where Angular (1.x) uses a multifaceted library of multiple structures. Lastly, Angular's injection allows for very specific stand-in/replacement during testing, largely to support the first aspect (binding), where React doesn't have/need that level of granularity due to its more exposed and one-way write to dom system.
"Resrce", it is the missing letters take on erp
This would be so awesome if Google did this for going through directories under `file://` (I wonder if its possible to change that via a chrome extension, if you can it'd be awesome if you would do that)
I did not get the joke
Hypersonic is a database. http://hsqldb.org/ Therefore, I propose the name Feltch. 
I had to look up the name. I'm not native english speaker. *sigh*.
so because while I iterate through the string I always just look at str[i] which is always just ONE character, so it looks always at just 5 as ONE character, then already adds it?!
... and the database is HyperSQL
The business is technology, and it changes every goddamned second. Show us some cool stuff and STFU. 
Lodash and Underscore are great as a practical utility library, but that's mostly just it, a big giant /utils directory. To me, there should be more than just simple utils, like CSV handling, CLI tools, date/time, proper randomization, SQL support, *cough* *cough* multi-processes/threading *cough*, logging, etc. Most other languages have these kind of things built in.
kik
I think the author is maybe misunderstanding things - most languages use jump tables to jump to the correct case label (most of the time), so the break statement shouldn't affect what bit of code is initially selected. 
&gt; Is it designed to be usable both in 2D and WebGL contexts? Yep. Right now it is for manipulating DOM in 3D (uses CSS transform:matrix3d), but one of the main goals is to blend DOM with WebGL, to be able to move both DOM elements and WebGL meshes in the same 3D space. The last version of Famous, before the project was halted (left with some bugs and performance issues) had a nice prototype of this "mixed mode", which we're taking some inspiration from.
Thanks lewisje, that would be greatly appreciated! I've also left some notes in the code marked with "TODO" where I know performance can be improved. Also, I've gotta update it to the latest Editor's draft.
&gt; I keep repeating myself. Gzip can't remove the duplicate dependencies because they don't necessarily contain duplicate text! The implementation details might completely change between compatible versions! You're completely missing the point I was making. Duplicate packages aren't a problem due to download size, they are a problem due to conflicting dependencies, and in any reasonable project it should be extremely rare to have duplicates in the first place. Regardless, how often is a function going to change across a major point release, without actually changing its behaviour? It seems like we're talking about a pretty small footprint to begin with. &gt; Assuming your packages aren't touching global objects, this should never happen. Do you know how the node module system works? In node duplicate sub dependencies are safe, they're just inefficient in terms of space usage. They definitely aren't safe. Imagine you're building an app using a date picker. That date picker has a dependency on SomeDateLib 1.2 On another section of the app, you have a calendar component. That calendar component has a dependency on SomeDateLib 1.1 You use the date picker to retrieve a SomeDateLib object from the date picker, and pass it to the calendar. One part of your code is creating objects from v1.2 of the library, and passing it to code expecting an object from v1.1 of the library. What happens if those different versions have different structures? You're going to have issues. If you're lucky, it might blow up immediately with a NullPtr. If you're unlucky, it might subtly screw up timezone handling and result in corrupt data making it back into your database. This particular scenario is actually a real world example that happened to our product. Conflicting packages can break in very unintuitive and difficult to debug ways, and the larger and more complex your application and/or dependency tree is, the greater chance you have of something going wrong, often in very subtle ways. As mentioned previously, the only time duplicate package versions are safe is when you have a package entirely consisting of pure functions, with no custom data types, and no state. Anything else is a risk. &gt; The reason these other package managers consider duplicate package versions a fatal error is that these other languages like ruby and python have global module namespaces. That means that unlike node they're unable to safely import multiple versions of the same package. &gt; The ability to support multiple versions of the same module is a language feature, not a drawback! Both Python and Ruby as a language can support multiple package versions, as can many other languages. I've been doing it in Java for years in specifically controlled scenarios. The respective package managers don't support multiple package versions because it cannot be guaranteed to be safe, and developers in these ecosystems universally recognise it as a bad idea. If you need to do it, then it's up to you to bypass the safety measures put in place and add the dependencies manually. &gt; How did you manage this before? You check the source code of the updated package to ensure that there's nothing obviously malicious. You trust the author to obey semver. &gt; Then you run "npm i --save A B C D etc." which will update your dependencies and flatten your dependency tree. &gt; This process is actually easier with micropackages than it is for monoliths. Because your imported code has a smaller surface area, so there's less code to review. The problem is that the people managing the micropackages you're depending on are less likely to have upgraded. Instead of having one major release of a standard library that everyone can upgrade to once every few weeks, package maintainers would have to keep track of potentially hundreds of dependencies and make sure they are all updated. Considering that you might have a new micropackage version somewhere in the ecosystem every day, it's almost certain you'll have conflicting versions, even on small projects. &gt; Why do you think installs would take longer with micro packages? They take less time than they would have had you been importing monoliths. Because dependency resolution runs in non-polynomial time. Time increases exponentially with the number of transient dependencies. Instead of a small project having, say, half a dozen transient dependencies, it could easily have thousands. And a large project could easily be an order of magnitude more than that. That's going to peg your CPU for a very long time just doing constraint resolution to figure out which version of each package you can use to satisfy each package that needs it. &gt; Micro packages minimize the amount of code that needs to be downloaded on install, as they prevent unused code from being downloaded. The amount of code to download from NPM is almost a non issue. We're talking a few megabytes. &gt; Not only that, but the context of this discussion is front end development, using tools like browserify or webpack. Is it? It seems the topic is about NPM in general, not frontend development. In either case, I don't really think it makes any difference to the issue. &gt; On the server space savings on this scale don't really matter. If you're bundling up and sending thousands of dependencies to your client on the web, even micro dependencies, then you've already lost. That's kind of my point. Micropackages are going to turn a small project with 5 dependencies into a project with 500 dependencies. Even just the overhead of webpack/browserify wrappers for each package is going to exceed the moderate space savings micropackages would give you, if any, over normal optimisation techniques. 
It is based on an old project that was named Hypersonic SQL. Some still refer to HSQL as Hypersonic, though technically it's incorrect. 
Gearz Enables Awesome Rapid Software Zines
WebGL can use the float32/64 arrays of a DOMMatrix instance so it's faster than converting from Array of Numbers to float arrays. I think read somewhere that DOMMatrix will be passable to DOM elements directly so we don't have to set the CSS transform:matrix3d property on them. Setting the CSS value is really slow because the HTML engine has to convert them from a string to an array internally, but with DOMMatrix we'll be able to skip that string conversion by passing DOMMatrix directly to the element. I don't remember where I read that. I'll try to remember to come back and post a link if I find it...
[removed]
Not to start an argument or anything, but handling state is built into javascript, just like most languages. Consider developing your own abstractions for handling state. Your solution could very well be better than if you contort your abstractions to match someone else's framework.
Yeah I know, and to be honest a part of the reason my tests were failing was I was writing a lot of c++ code, and because of time i decided to use ruby. But in Ruby you can't do things like counter++. And the app pretty much only says if you passed or not. See unlike real situations, if I don't entirely get what they want me to do I can play around with the input and see what they're feeding me. But in this it's kind of like I am coding blindly, and fighting the clock. But that being said, in general I love problem solving. But hackerRank sometimes feels more like the GMAT's reading section. As in I need to figure out what they are saying, so I know what inputs are fed to me and what/how many times i need to print it. So I will practice it because I must, but I almost feel like memorizing and focusing on fastest solution to generate an output is actually hurting my brains ability to reason. anyways I discovered https://codefights.com and I actually like it, they present problems that are readable. 
Here's a bunch of crappy names, hope one sounds good to you erp.js crudJS CRUDit microwave.js takeout.js McCrud YAFF (Yet another freaking framework) 
I never use global packages, but I always reference `./node_modules/.bin/XYZ` in my `npm run` scripts. TIL I do not have to do this. Thanks for adding this comment!
Unfortunately that would mean some committee would get to decide whether the API would be FP, OOP, etc. 
good to know ;-)
bwhahaha ;-)
Lol, I am pretty stoked though 
"Basic"
Neat stuff, keep up the good work!
&gt; Jay Query 2020 FTFY [Jake Weary 2020](https://youtu.be/UzyoT4DziQ4?t=22m3s)
&gt;If a developer who has never created a SPA wants to create one, it is perfectly viable to use a framework to handle the nitty-gritty details while they concentrate on their business logic. \ if that developer does not know html &amp; css, would you still tell them to learn a framework? definitely no. A dev should know about how things work internally, but the dev should not bother much with it as it takes time. the question is of balance. in my opinion --and many agree with me -- js libraries require no prior knowledge but frameworks require some practical experience. of course exceptions do exist.
what are you trying to do when each image is clicked, what does the image change to?
I want it to change to another image when clicked. Right now I just get this strange dark bar under the image when I click it. 
You need to re-write the logic inside that `validate` method (if it's one you control) so that it works directly on objects, rather than on the string representations you've been passing in; however, you don't need to do anything special to pass in an object initializer (sometimes called an "object literal" despite not quite being a literal value) as an argument to a function.
Yes, that's even better. Not sure about `lastIndexOf` performance though.
Yeah, what in the world are you on about? That's for parsing a CSS color declaration, such as `#a4a4a4` or `rgb(100, 50, 100)` or `blue` or whatever. A rather ordinary and mundane application of a regex.
Certainly. I don't fully know what OP's scenario is, so just went with the existing art
Given OP's question, it sounds like he's likely just starting out. I think using jQuery to work on stepping stones is fine. It's a bit easier to comprehend the following block with the help of jQuery for someone getting started. $('img').click(function () { $(this).attr('src', 'someotherimg.png'); })
Pretty close. Basically what I am trying to do is click on a single image in a grid of images and change that image to something else. So, for example, the first image in your fiddle was the smiley face, if I had a 4 x 4 grid of those smiley face images, clicking on a smiley face (changing it to a sad face image perhaps) would alter only that smiley face image and not the rest in the grid. 
The public `.prototype` property is a property that constructors have that becomes the hidden `[[Prototype]]` property of any object created by calling that constructor with `new`; most of the built-in globals that start with capital letters (`Object`, `Function`, `Array`,``RegExp`, `Date`, and DOM-related globals like `Image`) are constructors, and all functions have properties inherited from `Function.prototype` (even if made with function declarations or function expressions), all regexes have properties from `RegExp.prototype` (even if made with regex literals), and so on. The "scalar primitive types" known as boolean, number, string, and symbol also have corresponding constructors: `Boolean`, `Number`, `String`, and `Symbol`. However, you should never call them as constructors, just occasionally use them as conversion functions; they exist just so you can add new methods that can be called on the corresponding primitive values (older JS engines actually made temporary wrapper objects just to allow expressions like `'lol'.split('o')` to work), and you can't even use `new Symbol` because that throws an error (but passing in a scalar primitive to the `Object` function, whether called with `new` or not, *does* return a wrapper object, even for symbols). As an example, to make a `trim` method for strings in browsers that don't have it, you would define a method called `String.prototype.trim`. There are, however, built-in objects whose names start with capital letters that *aren't* constructors, like `Math`, `JSON`, `Reflect`, and the proposed `SIMD`; these are instead collections of useful functions, organized under the closest thing JS has to a namespace. Also, while anything using the `function` keyword is also a constructor, arrow functions are not constructors and therefore have no `.prototype` property. --- It is possible to set any`*` object (or even `null`) as the hidden `[[Prototype]]` property of a new object, even if it isn't the public `.prototype` property of any constructor, by passing in this object to `Object.create`; also, with `Object.setPrototypeOf` or the special `__proto__` ("dunder proto") property of objects, the `[[Prototype]]` property can be changed (it can be referenced directly with the `__proto__` property or with `Object.getPrototypeOf`). `*`Okay, you can't create a cycle in the prototype chain: If you access `.__proto__` enough times, you must end up at `null`, so if object A is in the prototype chain of object B, then `Object.setPrototypeOf(A, B)` will throw an error, as will `A.__proto__ = B`. This means not just *any* object can be made into another object's prototype. --- The significance of a prototype is that if you try to access a property on an object, and it doesn't have a property with that name, the engine will look at that object's prototype, and it will keep looking all the way up to `null` (which cannot have properties), and if the engine still can't find it, it returns `undefined`; something similar is done with the `in` operator: It returns `true` if the key on the left is found in the object on the right or in any object on its prototype chain, but `false` if the lookup goes all the way to `null` without finding that key. --- A best practice is to keep per-object data on each object (that is, as an "own property"), but to put methods that may work with that data somewhere on the object's prototype chain, to reduce the number of function objects. Another pattern is to use one object to contain default data and then "clone" it by passing it into `Object.create`, and then setting specific per-object data into each clone; it's important to realize that *setting* properties does not look up the prototype chain, just querying for their existence and retrieving their values. That is, if you set a value for a property that exists on an object's prototype chain but not on the object itself, you're "shadowing" the prototype property; also, if you delete a property from an object, any properties with that name on the prototype chain will become accessible again.
I make a throwaway account every time I comment. I don't like accounts. edit: I'm genuinely curious, why are so many people downvoting? I don't see how this habit would piss people off.
officeboy JS. a js app which does your boring routine work
yea but you ahve to keep track of all the indexes, rulesform1 = rulefieldset[1], its gross, use nested objects its easier var ruleFieldsets = { address: { business: "required", contact: "required", address: "required", city: "required", country: { valueNotEquals: "country_select" }, state: { doubleConditions: "state_select" }, zipcode: { required: true, minlength: 5, digits: true }, 'phone: { required: true, phoneCheck: true }' }} $(form).validate({ rules: ruleFieldsets, messages: msgFieldsets }) **option 1 use nested objects one for each form** maybe you were looking for $(form).validate( { rules: ruleFieldsets.address }) to just use the address item from the array? but if so you should still use nested objects not an array there **option two use one object and pluck the rules you need** to pluck each one use lodash _.pluck(ruleFieldSets, ['business','state','city']) or a plucker func: function pluck(obj, keylist){ var output = {} for(var i=0;i&lt;keylist.length;i++) if(typeof obj[keylist[i]] != 'undefined') output[keylist[i]] = obj[keylist[i]] return output } now you can use it to get only the rules you need var rules; // if form 1 rules = pluck(ruleFieldsets.address, ['business', 'country']) $(form).validate({ rules: rules, messages: msgFieldsets }) 
That's exactly what I was looking for. Thanks! Would it be possible to explain a bit what this code is doing? 
&gt; If the package as a whole is has backwards incompatible changes, but the function in question only has backwards compatible changes, then you've reproduced the scenario I've described. Aye, but I consider this to be a relatively rare edge case. You're not going to see a massive percentage of your dependency tree meet this criteria. &gt; Regardless, what's in question is whether micropackages help reduce the size of your javascript payload via more effective de duplication, not whether npm should abort when it fails to de duplicate a package. Micropackages would benefit front end developers in either case. The reason the duplication question is relevant to the discussion is because micropackages will only be useful in the first place if you have a high degree of duplication of packages. Since good practice is to avoid this in the first place, any potential benefit of micropackages will only apply in the rare edge case where you have conflicting versions in the first place. &gt; The space savings you get from micro packages are only really relevant to front end devs. &gt; If we send thousands of micropackages to our client, even if we assume they're only half a kb each minified and gzipped (which is generous), that means your payload is already at least 1 MB! That's way too big! That really depends what you're working on. For a webpage, 1mb is too big. For a thick client application, 1mb is tiny. Regardless, the "thousands of micropackages" problem exists *because* you have micropackages in the first place. Let's take underscore for example. It has ~80 public functions, and a fairly high degree of cohesion between them - so if you're using one tiny part of underscore, there's a good chance you're actually importing a significant percentage of the whole thing anyway. So just by importing one micropackage, you might actually building a dependency tree with, say 40 packages that it depends on. Underscore of course doesn't have any further dependencies itself, so that stops there. But imagine we are importing part of another 'micro library' which has a similar breakdown, and it itself has a few other dependencies with a similar breakdown... you can see at each level of tree we're growing exponentially? Just by importing a few simple top level micropackages, you might actually be pulling in a couple of orders of magnitude more than you think. If you were using more coarsely grained utility packages - the number still increases exponentially, but it might be a few dozen, not a few thousand. To put it another way - a moderately sized project could easily have dependencies on 100,000 functions once you follow the full dependency tree. If each of those is a micro package.... &gt; While I recognize it's possible to encounter performance problems trying to resolve a sufficiently high number of packages, I'd be impressed if you've ever encountered a specific dependency tree that npm takes longer to resolve than it takes to download over the network, particularly for the front end! The computation increases in complexity exponentially that more dependencies it has to calculate. For a sufficiently large number of dependencies, you'll start to hit it.
this is always my problem. 5 minutes with bundled version. less than a minute with latest.
Got an ego to stroke do you? Yes, we can all decipher it, and it takes all of us (even you, Your Majesty) a bit long because of the nasty combination of a punctuation-based language and an implementation that forbids formatting. This wasn't even a serious post, but I seriously think you're nuts if you think lines that are 128 characters long and 75% punctuation are a wonderful thing to have. edit: I love how I can be, without a doubt, technically correct on every point, and still downvoted to hell because reddit doesn't like my tone. Priorities.
Nice! The more the better! I'm going to write a performance test, maybe with the help of jsPerf suite. Update: jsPerf keeps printing "spam detected" on every edit, so I'll present just a native test.
Wow that looks much cooler than Immutable.js
It's not punctuation...it's regex. It's just the form for the format. It's not designed to be readable in a traditional sense. To could just as easily make it a function in javascript or most other languages if you're worried about readability 
Mmm I think this joke is becoming tired now
You missed the point and you're being a dick about it. It's ironic that a remarkably complex variable declaration is named "simple". That is all. I am not calling CSS color parsing exciting, I don't even know how you got there from my post.
Is this what you're trying to achieve? https://jsfiddle.net/svax34m0/
It's not utterly unreadable, its a pretty simple regex that does its job. You can see here the railroad diagram for it. http://imgur.com/GKYnyJu
Still this one as a primer: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
&gt; I've never used a web application that is significantly larger than 1mb! Do you have an example? Off the top of my head - Cloud9, LucidChart, Google Drive. &gt; Again, I'm skeptical that you could construct web app composed of 100,000 micro packages that would have a reasonable payload! 100,000 packages is a lot! I agree. 100,000 packages would be absolutely unviable and would simply not work, the overhead would be too high. But when you do the maths, using micropackages could quite easily hit that number on a reasonably sized project (Which is one of many reasons why I think they are a terrible ide) &gt; I'm asking you, have you ever personally hit this limit with npm? If so can you show me your dependency tree? Not with NPM, but I have on Java projects using Maven. &gt; I ask because I believe you're likely to hit the limit on what's a reasonable amount of code to send a client over the network long before npm dependency resolution starts slowing down due to an excessively large dependency tree. That depends how large each package is. If you're putting every function in its own package... that threshold is pretty damned low. The problem is completely unrelated to the size of the code, and entirely related to the number of dependencies. The larger the tree, the more complex the problem, the slower it will be. Step back a little bit and think about how many functions make up all of the dependencies if a typical web app. Even a small app could easily have tens of thousands of functions in its dependency tree. What are you expecting that to look like when you break it up into micropackages? If you're going to put one function per package.... then ten thousand functions = ten thousand packages. I really don't see how you could expect that to work.
Why is he not using semicolons? Seems idiotic.
This should work ;) https://jsfiddle.net/svax34m0/2/ If you don't understand what's happening just ask!
I'm using it and it's great, thanks. Any thoughts on adding daily (today) filter as on https://github.com/trending page? 
He has a video on that too: https://www.youtube.com/watch?v=gsfbh17Ax9I
(disclaimer: I'm self posting my own blog article, hope this isn't considered spam apologies if it is.) I would just appreciate any feedback on the approaches I took in this article.
It's retro!
Why did you feel the need to add 'seems idiotic' and turn your comment into an insult?
&gt; Google Drive's app.js file is 1.2 mb, Cloud9's is a little under 1mb. Not going to give Lucid Chart my credit card to check their payload size. These packages are not significantly larger than 1mb, unless I'm missing something! You said larger than 1mb. All of the above are over that size by my count after gzip (Going based on Chrome's developer console). That's just for the initial load, extra packages are downloaded as you use more advanced functionality in the app. &gt; I've been working with professionally with npm on and off for the last 3 years. Npm's dependency resolution has never been slow for me! &gt; Any slowness I've experienced with npm has been due to excessive network IO resulting from large dependency trees, large binaries, long post install steps, or slow registries, and even then the longest install I've had was approximately 15 minutes. &gt; I don't think you can extrapolate from maven being slow at dependency resolution to npm being slow as well. There are all kinds of implementation details and constraints that could differ between the two package managers that could produce performance differences. You're completely missing the point. It's not a "flaw" in Maven, or NPM, or any other package manager that complex dependency resolution takes time. It's an NP-Complete problem and every package manager will experience the same issue with a large enough dependency tree. &gt; The number of public functions ... It's not just public functions. If two public functions in a utility library depend on another 'private' function, then you'll need to put that function in its own micropackage, or you're back at square one with duplication. &gt; ... exported by all dependencies and sub dependencies in a typical web app is going to be much smaller than ten thousand. For a small project? Perhaps. But the same NPM ecosystem is going to be used by people writing apps that are that larger than this. 10,000 is really not a large number, especially when writing in an FP style. 
"You have different values than me. Have a downvote".
Because I'm an asshole?
Hey thanks, actually I did not add today on purpose. Because for github they are calculating the trending based upon the number of stars on a specific date while in the API they do not provide such functionality and I am calculating the trending ones based upon the "repositories created in a specific date range with most stars among the other repositories created within the same date range" and for "today" I did not add that because of the recency of creation most of the repositories were showing with a minimal number of stars which wasn't enough to find the trending one. However, I'll see what I can do. Thanks though :)
Feels like the name is missing something. Quotation marks: "standard" Everyone I know uses semi colons.
Pretty excited for this release. I know Reddit isn't the biggest fan of Meteor, but I'm developing a Web app in it now and it is making my life so much easier. Hopefully MDG can get working on their Apollo stack so we aren't stuck with mongo any more!
Yes, I read it just fine. Would you be fine with it if he said "now this example is in java, it's a bit 'out there'?" Invariably it will attract new-comers with the promise of a "basic" article, and him just making stuff up like that and putting it on the article will confuse people. 
I hope those semi-colons work for them. Everyone I work with does not use them, it also works fine. It's just a matter of taste, using standard just stops us having pointless bikeshedding arguments about silly bits of style. Saves so much time and yields clean syntax, in our opinion.
thx. I guess CI thats what I need to search. 
I think the point is that any system, no matter how secure, can fall victim to social engineering, not to downplay the risk. You can't really "fix" social engineering vulnerabilities, you can only mitigate them.
I have yet to find an explanation of React that doesn't meet all of the criteria you just listed. I love Meteor, and am terrified that React will take over because I might as well quit when it does and wait until something else makes sense. It seems like people looked at html, css, and js, found the most convoluted and disruptive way to accomplish menial tasks, wrapped it up, and called it React.
Year: 2016 People still use callbacks instead of promises.
BTW AngularJS includes a subset of jQuery, known as jqLite, so if you use Angular, you probably won't need to load jQuery separately to use its API.
Check out this article for more information on CSS transitions. https://css-tricks.com/almanac/properties/t/transition/
There's nothing clean about having to prefix semi-colons, ever. From one of "standard's" [sources](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding): foo() ;[1,2,3].forEach(bar) This is easily one the most atrocious things I've ever seen. JS is not Python or Ruby. Semi-colons are standard in most major (citation needed), non-whitespace-indented C-like languages. This includes languages such as: C itself, C++, Objective-C, Java, C#, PHP, Perl, and **JS**.
At one point in time we thought we would have to support IE5.5 until the end of days. Then it seemed like we'd be supporting IE6 until end of days. Turns out "end of days" is generally "about 10 years for corporate, 5 years for everyone else". 
I personally love ReactJS. I think it fits my workflow and thinking very well, and it's very fast and easy to use. A co-worker prefers Ember or Angular and finds them more to her liking and thinking. Other people say not to use one at all because of various reasons. What you end up using in the end is going to be a very personal thing, or dictated by the company you work for. What other people say has nothing to do with it. However, you *should* learn the basics of all the hot ones so that you have some idea how they work and what fits your style best.
This guy really *likes* bears
BACKBONE! It will help you learn jquery. Since backbone is largely meant to help you organize your program, you will still gain experience writing your own code instead of learning framework specific code(much more useful in the long run imo). If you are just going with flavor of the week I would go with react/redux(not as easy as people say it is). I would strongly disagree with Angular, especially if you are newer to coding, just because it can get be complicated.
I agree with /u/Magixxxx. I'm not *entirely* sure who this article is aimed at, but it's certainly not basic, and certainly not for beginners. 
npm
&gt; Imho many Developers tend to use as much native JS as possible, due to the problem that excessive usage of JS will cause the client (Browser) to slow down and possibly leak memory. Do what? We're in the age of everything being a SPA, even silly CRUD applications. We just came off of a period of angular being hotter than lava, and now react is looking suspiciously close to were angular was.
I gave a talk as well on generators this past year at JSConf China. Unfortunately the video isn't well stitched together. Generators are super fun and you can write some very expressive and easy to understand code with it. Here it is if anyone is interested: - [Video](https://www.youtube.com/watch?v=HNDRXeaRJO8) - [Slides](https://speakerdeck.com/btholt/unlimited-power-es6-generators) - [Code](https://github.com/btholt/generator-examples)
I like the dojo toolkit, old, stable as fuck, battle tested. I think it fits in your third area. Google 'dojo theme tester' to see what it is able todo :)
Minified version larger than original. Fail.
It seems idiotic rather than fun... Edit: it is fun indeed!
Todays Troll Award goes to....
There's a lot of older stuff like prototype, mootools, dojo. I haven't really heard of anyone using them anymore, so I don't usually advocate new people to look into them.
The control flow doesn't seem at all obvious to me. I'm sure he's got some decent use cases in mind, but I'm blanking on thinking of why I'd want this.
When was the last time you actually wrote out an array literal like that? The example is showing why you would need them. In practice I've never had ASI produce an error in my code. Not to mention that everyone is writing everything in Babel these days and your code doesn't look anything like what you wrote by the time it gets to the browser. 
Meh, I did think it was kind of funny that the var was called "simple" but was followed by a regex which to many developers isn't.
What about array destructuring? You'd have to prefix it with a semi-colon too. Oh, and my favorite: ;(function () { window.alert('ok') }()) I write functions like that every once in a while, especially if I'm quickly prototyping. There's no way I'll remember to prefix it with a semi-colon (and it's remarkably ugly). Admittedly, with `let` writing those functions for scoping isn't really necessary anymore, but that doesn't mean that it's going away anytime soon. Furthermore, Babel won't be around forever and a lot of JS development happens on the server, where Babel isn't really used at all.
&gt;if that developer does not know html &amp; css, would you still tell them to learn a framework? Of course I would. When I started my career, CSS frameworks really weren't a thing. I remember wasting days trying to create the CSS for a client project in 2005. Getting everything to work took a ton of time that could have been spent working on business logic. When I was tasked with rewriting that same software in 2012, I used Bootstrap and didn't worry about it. I still am not a strong at using CSS, but that's okay. I have a multitude of CSS Frameworks available to help me get my job done and keep the client happy with how the website ends up looking. Telling new developers "you need to learn how to do all of this yourself before you can use a framework" is just another form of elitism of senior devs (or those who think they are senior devs). I'd much prefer for my junior devs, especially those brand new to the working world to spend their time learning how to be productive. When they make "dumb" mistakes because they don't understand how some part of whatever framework I have them working in, a targeted lesson to help them understand what they did wrong and why it's wrong (or at least inadvisable) will help much more than any flailing when they have no experience. All programming we do is built upon layers of abstraction. Understanding the abstractions is one thing that helps separate good developers from crappy ones, sure. But forcing new developers to learn everything without any context from experience is of dubious value.
Being an asshole on the internet. This is the real revolutionary here
Would be great if they added support for Chromecast.
Their syntax is largely compatible. If you choose and learn one, you've pretty much learned the other. The main areas of difference that will be relevant to your migration is flow types, by default, do not allow `null` or `undefined`. You have to explicitly make something accept such values, which can be annoying if you have a lot of code which handles `null` or `undefined`. Consequentially, this means it'll be a lot less likely for one of those to appear in your code in the first place. Both to my knowledge allow you to progressively type. In typescript code, most* code without an annotation is considered the `any` type, which means it'll not be type-checked. Flow, by comparison, will attempt to deduce a value. In practice, this means you can write code exactly as you do right now in typescript, and add types later to solidify your API. In flow, you're working with type inference the entire time (unless you explicitly type it away). I think flow would be more comfortable to you if you have a functional language background and want a typing system more like that. Flow is written in Ocaml and there's some noticeable influence. The way it deduces types in particular is very similar to how type inference works in Ocaml and F#. Typescript has other constructs, like `namespace`, which makes it clear that it's targeting developers from languages like C# and Java, who would expect to be able to do things like pass `null` anywhere. Also, typescript has very good tooling integration with visual studio, so it's better if you use that IDE. However, typescript's type system is structural, and offers no nominal hooks. In practice, this means two totally different types are compatible if their "shape" is, which makes it very difficult to effectively 'design with types' as you would in a functional language (or flow). \* typescript has very limited type inference in areas like callbacks passed to typed functions
edited in my post
The article is great, but the Addendum goes off topic to talk about an unrelated and controversial topic (classes) and references a controversial author (Eric Elliott).
Are you saying that you still have trouble understanding React and its concepts, or that you found initial tutorials to be too confusing?
Quick plug for "Batteries included" *plus* BYOA (paradigm agnostic). oh, and faster than everything listed above: https://github.com/leeoniya/domvm Gonna be tagging 1.0 in about a week.
I guess choosing a toolset just by actual hype-level is far away from being a good developer. You choose your toolset by the feature-set and the amount of workload it reduces for you - the same goes actually for the language. I am talking right now about large enterprise web applications and not the "basic &amp; fancy" todo angularjs "app" found on github ;)
Promises in combination with generators are becoming pretty common nowadays, which the video for some reason doesn't acknowledge and instead uses a `resume` callback. For example this is how Koa does it. It basically does the same thing as your code sample, but removes the noise caused by chaining thenables together: files.read("big.file") .then(text =&gt; files.write("uppercase.file", text.toUpperCase())) .then(() =&gt; console.log("Upper case file is done!")) .catch(e =&gt; console.error("Unable to copy file: " + e)); Essentially becomes: try { var text = yield files.read("big.file"); yield files.write("uppercase.file", text.toUpperCase()); console.log("Upper case file is done!"); } catch(e) { console.error("Unable to copy file: " + e); } 
There is already vanillaJS to troll. No more unwanted packages required to troll.
I meant _in the video_ but thanks ;)
You want jsonp
Atom - https://atom.io/
quick combine function (or use lodash): function combine (a,b){ return Object.assign({},a,b) } rules: combine(ruleFieldsets.address, ruleFieldsets.bizDetails)
It is relative to the project you want to build. Each one has its own strengths for different applications. Check out (ToDoMVC)[http://todomvc.com/], they built a guide for this decision specifically.
 document.getElementById("users").selectedIndex = -1; Edit: or if you're more concerned about the clicking outside, here's an example (uses jquery) https://jsfiddle.net/edzp53vo/
Atom. It's great. I switched from Sublime to Atom and never looked back.
Don't jump into koa for your first project. It's not stable and you should learn the fundamentals first. To understand node you have to get comfortable with callbacks, because everything else is an abstraction built on top of them. Don't follow "trends" too closely, you'll get burned by how finicky they are.
Well, it really depends how you've structured your HTML, but in general an approach in plain JS would be something like adding a listener to the mouse click event and then checking if the target you clicked on is equal to your 'users' ID or not.. and then acting accordingly. e.g.: document.addEventListener('click', function(event) { if (event.target.id != 'users') { // run code here to clear the selected options } }); Edit: I do have to say it's a bit strange where you want a drop down to clear a value when you click out of it. If you're trying to use the drop-down as sort of a quasi-navigation and/or function caller (such as, 'run function 1', 'run function 2', and then you want these selected options to stop when you're done, look into adding an event listener 'onchange' to your dropdown; what you can do from there is simply detect when the select element changes, grab the updated value in the select, run your function accordingly, then reset the select).
Will do, I apologize. I've got to say though, I feel like the tone of this entire thread was already pretty terrible, even if nobody else was blatantly name-calling. (Comments since then have been much more polite.)
.. you caught me. Yeah, there's another variable "advanced", which matches rgba and hsla.
"punctuation" as defined by the english language, not any programming language, which is relevant because it's well-documented that people read and understand strings of punctuation more slowly than strings of words.
We went with TypeScript, mostly because we're on Windows and couldn't get Flow to work at all on our code base. And the two are quite compatible. We're keeping an eye on Flow, but TypeScript certainly has a bigger community and greater momentum currently.
Sure. Did you mean that as something negative or just something that's good to know?
Generators are a nice way to produce lazy iterators. For example if you wanted to loop a binary search tree using for-of without munging the entire tree into an array first, a generator would be an ideal way to do that. This would work well for example with the [wu](https://fitzgen.github.io/wu.js/) library.
I thought that `require` would return the already-bundled module if it had already been included via `require`.
Awesome! 
You should learn jQuery because it still exists in a lot of legacy apps but, if I were starting a new application, there really isn't any reason to use jQuery unless you need to support IE 6-8. I'd recommend looking into VueJS. It's got enough of a feature set that will help introduce you to concepts that most of the other SPA frameworks offer but without a lot of the architectural preachiness that Aurelia, Ember, Angular come with. Also, the way Vue handles state (passing top level state to module components via props) is similar to how React works and is also compatible with Flux/Redux. So learning Vue can give you a head start into learning React, which is a hot library right now. More importantly, you should learn the pain points that frameworks/libraries Ember, Vue, Angular, React like help you avoid and how data-binding, componentization, and other core concepts different from manual DOM updates with something like jQuery or vanilla JS.
Thanks everyone for the replies. I still have a lot to learn and I actually learned quite a bit from just some of your replies. Cheers!
I'm not sure how this is much different than *FooProduct* where *FooCorp* goes offline... I remember having to setup a RabbitMQ instance, it was probably 8 months since the prior time I'd needed to do a clean install, and didn't have a prior installer in place... The RabbitMQ site was actually down that afternoon (it was a Saturday)... fortunately, I was able to work around the issue, just the same, it happens. Software distribution goes down from time to time, there are plenty of ways this can happen for both commercial and open-source paths... It's easy enough to use an npm mirror, and isn't really much different than apt, chocolate, gems, maven, or any other centralized repository system...
the TL;DR version: https://en.wikipedia.org/wiki/Cargo_cult The short version: Interviews like this started out at companies like Google, Apple, Microsoft, Facebook and Amazon because all of these companies need engineers with exceptionally strong computer science fundamentals because much of their work is around either managing huge infrastructure, developing things like AI or building the basic tools that the rest of the industry uses. Other companies saw this and then modeled their interview process after these companies after seeing that these companies attracted the best people. For the other companies these tests are mostly irrelevant though as they are making products like blogs, internet lending platforms, hr software, selling beauty products, etc. These products and platforms though profitable aren't revolutionizing the industry, they probably won't be the birthplace of the newest hot programming language or framework and millions of other engineers won't be dependent on their services. It's like the Cheesecake Factory buying an industrial robot. Sure they make a lot of cheesecake, but they don't really need a 100k machine designed for precision welding just to put the strawberries and frosting on. 
I'm getting ready to replace my personal site/page, which IIRC I built around 2008-2010 timeframe... Here's a link to what I have started[1] ... I haven't introduced redux/router etc, so mostly just react base, webpack, and bootstrap4 integration at this point. I've used a similar configuration in a few projects at this point... pushing out the early phases, so that I have examples to work from, but the later parts are more closed... It's worked pretty well, but really is like diving into the deep end when you get started... About the only advanced bit I'm doing is that I do have webpack dev server integrated for dev use, and have a separate publish/run target for production. [1] https://github.com/tracker1/tracker1.info
Nope
You can't have your cake and eat it too, frankly
React is also a library
It makes me hurt a bit to see that I need &gt; 100 dependencies just to tool up just for a build pipe to emulate module support. Of course this is really the fault of JS feeling so incomplete. But it is nice that there's at least a solution to make JS more usable in the modern era. NPM does a good job making it possible to do this. But I would never trust it in production (nor should you ever, as many blogs have said). People need to start doing more engineering and less gluing together components and defend against upstream mutations and dependency issues. Manage your entire dependency tree when you are doing serious development. Npm has the tools required to do this. It just takes attitude adjustment and some work.
I there a way to npm install to the public directory w/out cd'ing to it first?
You are correct. What's the technical distinction between a framework and a library?
&gt; As the content creator you should have the right to unpublish whenever you choose. This isn't how open source works, though. When you publish your code under an open source license, you give users of that code the ability to redistribute that code, even if you stop distributing it yourself.
I do not believe so. 
More of a debate of imperative vs functional approach maybe. I like how with ES2015 and functional style of coding, my declarations have been limited to `import { feature } from 'module'` &amp; sometimes using `const` for initialisation followed by `map`, `filter`, `reduce`, promises and other method chaining goodies! Might not be as performant though, but makes it very easy to maintain, read, and probably refactor. 
Used them for parsing protocol buffers... which works fairly neatly. A generator yields the index of the field. And then a switch actually calls the correct method for the type of the field. So for a protocol buffer message like... message Person { string name = 1; int32 id = 2; string email = 3; } Then bit of code to de-serialize from a buffer var reader = new Proto3Reader(buf) // implements generator as *[Symbol.iterator] for(var index of reader) { switch (index) { case 1: name = reader.readString() break; case 2: id = reader.readInt32() break; case 3: email = reader.readString() break; } }
Yeah definitely. I wonder if that attitude and perception is appreciated: **You don't use npm to publish your software. You give away a copy of your software for npm to publish.**
it's open source. but it's incapable to open very large files (sublime does this without any kind of issue.) 
Frameworks are very opinionated, you can often only use one at a time, and are quite cumbersome. Libraries are most times smaller (though they don't have to be). A library provides a set of tools for accomplishing a task, regardless of how the developer is piecing together the app. jQuery is a library. It offers loads of tools and plays nicely with other libraries (scope is also an important library feature). Angular is a framework. It is incredibly opinionated and will tell you how you have to build your whole application. Where jquery is a part of the puzzle, angular is the nearly finished puzzle with only one or two pieces that aren't there yet.
I remember hearing about something called [`_dereq_`](http://stackoverflow.com/questions/30650532/what-is-dereq-inside-react) that is often used when bundling modules for the Web, and it ensures that you don't get name conflicts from loading dependencies more than once, but it also (getting at your point) doesn't seem to allow sharing a common dependency between builds.
Very impressed
Alternatively you can host your own private npm registry (https://www.npmjs.com/package/sinopia works well)
Then I'm pleased to tell you that isn't the case at all.
You can always host your own private NPM registry: https://www.npmjs.com/package/sinopia
There are two different things in your comment: one is kik's name claim and the other the unpublish issue. I think npm messed up with kik's name dispute but handles the unpublish well (with Op's link etc).
I commend NPM for how they've handled this. If the Javascript and the greater programming community have shown anything by their response to this, it's that you cannot make everyone happy, _no matter what_.
This is.... ridiculous. Written wrongly, every programming language is insecure and the list doesn't include ActionScript... It's just weird. Also, this would literally ban the internet.... since these three languages are oft used on the internet and backends of the internet... I think he'd get more signatures by promoting cyber security and having regulators force encryption...
I'd make a petition to deport the creator of that petition, but no-one pays attention to online petitions anyway.
There may be blogs telling you not to trust NPM in production, but there are lots of real companies using NPM in production. Blogs aren't the best source of information, it's half talented folks spreading their knowledge and half "me too!" barely-beyond-junior devs who want to be well known. 
Honestly, I am so over this topic, people keep blaming npm for this, while in my opinion Azer, or whatever his name is, knew what he was doing, cause he was mad with npm. Npm didn't think everything through, which is completely normal, someone show me a flawless software.
Worked like a charm, man. You're awesome, thanks so much!
this will never take off, not enough industry support and ES6 is already robust enough. Useless post
I look forward to something that will convince me otherwise.
&gt; the packages are now owned by a private company Nitpick, but the company owns the package publishing system, not the packages themselves. The thing that has changed is that people have lost some degree of control over the package publishing system. I feel this is an important distinction.
Yep that's accurate. My example was more case-specific to help people understand why this change is definitely not out of line.
Currently VLC can read every kind of files, FilePlayer depends of the browser :/ but we are adding every features possible offered by the HTML5. We have to know if a Chrome App have the same limits or not. For example, we can't have access to the absolute path of the files (for security issue). Anyway, thank you for your enthusiasm :)
Obviously, npm owns the publishing infrastructure and are perfectly within their rights to do anything they want with it, including discontinuing the entire service tomorrow afternoon, if they see fit. Just as obviously, neither npm nor code authors have exclusive control over OSS-licensed software, beyond the freedom to distribute it (or not) using infrastructure they control. Maybe what isn't so clear is ownership/control over the name "left-pad" or whatever a lib is named. Maybe npm and the OSS community need to develop a clearer consensus over this?
Why not throw away the whole namespaces as the identifier of linking packages? Use it as just a sort of recognition/easy search management and use uuid under the hood for real package-linking. That way, you can unpublish the hell out of the namespaces and nothing will be broken.
I'm a bit confused by the final example. If you were trying to make a "Really big file" all uppercase, wouldn't you want to wield the generator as a stream so that you're not bringing the whole thing into memory then saving it all? Or maybe I'm misunderstanding how that code example works? It looks to show how a generator can make a long-running task async by yielding back to do other things. Maybe that's all he meant to show.
Huh. Have you watched this? https://www.youtube.com/watch?v=x7cQ3mrcKaY Especially from 15:14 on? That's what really sold me on React.
It seems to be a pretty common trend with Facebook libraries, they don't really care about anything other than OS X. If I remember correctly, Flow didn't even work on Linux out of the box when it was released; although it was still possible after fiddling compared to Windows.
Testing on iOS 9.3 Safari on an iPad 4th gen
Pretty much. You are sending your package out into the world and by extension asking people to use it. Or at least, out onto somebody else's private servers. If other people come to depend on your package, it is no longer simply your package.
I still like the idea of having lots of micro-libraries, but in the npm world it's gotten too cargo-cultish. I can see pulling in a dependency for, say, parsing charsets out of a `content-type` header. But below some threshold it starts to become ridiculous. Especially projects that are downloaded thousands or millions of times per week; authors would be doing everyone a favor by inlining the little functions directly into their own codebases. Left-pad was a perfect example.
I agree. I don't think there should be any perception of personal ownership of the destiny of a package. Once it's published, it's published. No take backs. Also guarantees you don't screw with users that might by chance update in those 24h or auto update. Imagine how frustrating it would be to be figuring out a bug due to a seemingly phantom package that only affected a few of your developers.
I'm glad you agree. Actually, a couple of days I started working on making NPM work exactly like this. Check it out: http://everythingstays.com
&gt; there are lots of real companies using NPM in production Can confirm. Also, npm is a dev tool... once your build is certified, you really shouldn't be `npm install`'ing to deploy. That indicates a gaping flaw in your build/deploy process. I'm not suggesting to check `node_modules` into git (I'm personally very against the noise that creates). Even something as basic as creating a tarball, sha256summing it and deploying it would be a better idea than doing an npm install when you need to deploy.
ExlaxJS - "Makes CRUD, fast!"
Yeah. The company I work for used several packages impacted by the `left-pad` nonsense, but we didn't even notice because our deploy process is to: 1. Run `install` on a build server using an npm client which locally caches packages (*not* the actual npm client) 2. Generate a tarball 3. Deploy it to our production servers Not super fancy, but adaquate for a small team like ours. And as a bonus, npm could go down, and unless a developer had just decided to upgrade one of our dependencies, we wouldn't even notice. The `left-pad` issues showed some changes npm needed to make, and I'm glad to see they are, but I think it showed up issues with the way a lot of teams were using npm too.
I would actually upvote you for the first part. I don't really get the mindset of the second sentence (not that it's your opinion necessarily). I mean, they're open source packages likely MIT-licensed. I feel like part of the idea of open source is that you're essentially giving away the code to the community... Giving it and then taking it away (over your own personal politics essentially) after people have come to rely on it seems a little antithetical to this idea. For me, personally.
I can understand how the author really wanted to express the flow/ideology of react through functional code, as it makes concrete what is often seen as 'just the way it is'. However, I think it also kind of convolutes it. Either way I got to have my brain bent by trying to walk through all of the currying.. lol
&gt;CREATOR &gt;M. J. &gt;Mountain View, CA Maybe he's a Rust and Go fanboy working at Google :P
Whoaaa !
Re-re-posting a comment I've made in a few threads now, because I feel this needs to get more awareness: I'm still learning and prototyping my first JS/NPM/React project, but https://github.com/JamieMason/shrinkpack seems to me like it solves _most_ of the issues involved here. It pulls down all the tarballs, and updates the npm-shrinkwrap.json to point to those instead. That way you check in a much smaller "node_shrinkwrap" folder of a few hundred tarballs and 15-20MB, rather than a node_modules folder of 30K files and 150MB and a bunch of platform-specific build outputs. Still doesn't solve the issue of installing new/updated dependencies that might actually require pulling in something that vanished, but at least once you've done an install and run "shrinkpack", you've got everything you need to rebuild right there.
Ok so I just did a huge copy pasta from my code to JSFiddle, https://jsfiddle.net/cp1675u4/ The HTML required tags work on everything but iOS, that is a known issue. And thus is why I have to do my own hackish way of checking the fields now.
Before NPM I only used package managers to conveniently install software by simply typing the package command and the application name. The difference is that these were applications that stand on their own. The only thing the package manager did was combine the distribution and installation into a single command. NPM is different. Very few of the quarter million packages on NPM are complete applications. I would argue that &gt;98% of the stuff on there are micro-modules that do hardly anything but wrap some minor collection of functions that could be included in your application directly just the same. If there is ever a problem with the gem system I could go to a web site and download the latest stable build of compass or rails or whatever just the same. I cannot do that with any of the NPM madness. With NPM you are more reliant upon the NPM system than the products it delivers. That is horrible.
This was a good change, but their justification of why they took @azer/kik is still wobbly. &gt;**We stand by our package name dispute resolution policy, and the decision to which it led us.** &gt;Given two packages vying for the name kik, we believe that a substantial number of users who type npm install kik would be confused to receive code unrelated to the messaging app with over 200 million user (emphasis in source) You can apply this logic to basically any package name you want for any reason, since everyone has different life experiences with different expectations. This is quite worrying to me, and I don't want to let them off of the hook until they resolve this in some way or another.
Nice!
The entire purpose of TypeScript is to exist as a superset of JavaScript. Intentionally breaking working code is against the philosophy of TypeScript. That's why "implicit any" and "null by default" are the defaults in TypeScript.
Refactoring early and often is good practice; it allows you to keep your code tidy and organized. Refactoring, however, should not include algorithmic changes or changes to APIs.
just joined coderwar and it's actually pretty fun. I like it a lot, it had syntax styling, readable tests cases, the problems are readable, the errors are readable. But since lots of companies use HackerRank, I have to learn how to code with the weirdness. The coding experience on HackerRank is like using those [claw machines](http://giphy.com/gifs/no-spock-claw-machine-l41m3Yq3dqnXeGfQY) , sure in real life you use your hands, but to test your ability to use your hands, pick this object up using this fragile claw machine. 
&gt; We’re sorry. Every damn time something goes wrong NPM starts with the same introduction. Look, we all get that shit happens, but I can't believe how often NPM (the company and the software) fails. Stop reacting, look at prior works to learn how to make a god damn package manager, and implement something that isn't so susceptible to breaking so often. This policy doesn't go far enough. Someone may very well have grabbed a package within the 24 hours that it was published (considering how prevalent not locking precise versions is). A package should only be unpublish-able by contacting NPM. The action of unpublishing is to write to a public repository owned by someone else. It's appalling to think about the level of control everyone has over that repository. &gt; In balancing individual and community needs, we’re extremely cognizant that developers feel a sense of ownership over their code. Being able to remove it is a part of that ownership. This idea of ownership needs to change. You own the code, you can distribute the code as you see fit, but once you distribute that code to a separate distribution channel *that* distribution is out of your control. Ridiculous.
i don't know, i think kik handled this exactly how they should have. they contacted the existing holder of the name they wanted, multiple times, and then when he wasn't responsive they contacted the people in charge of the package distribution service. azer was kind of a huge dick, and i do feel that npm folded too quickly, but i feel like kik did exactly what they should have.
&gt; neither npm nor code authors have exclusive control over OSS-licensed software Here's an insightful write-up on open source ownership. http://www.catb.org/esr/writings/homesteading/homesteading/ar01s04.html
&gt; Think back to open source applications outside of NPM. Do any of these popular applications have dependency madness or are they simple a single entity that you download and install? If you had to go through this insanity to run Chrome, Firefox, or your favorite IDE you probably wouldn't use it. This is Apples and Oranges though. If I make a build artifact that's stable regardless of what NPM does to its packages the same way your copy of Chrome or Firefox is. Comparing a build artifact or application to a codebase is ridiculous.
NuGet does this as well.
Flow is not that much better for functional programming. I recently had to investigate programming patterns and make recommendations on which patterns to avoid in TypeScript. In the process, uncovered limitations of the TypeScript type system with functional programming (both in declaration and inference). Below are two that definitely would also apply to Flow: * variadic argument types - Right now you can only define `function foo(...args: any[])`. With variadic argument type support you would be able to define `function foo&lt;T1, T2, T3&gt;(...args: T2[], args: T2, ...args: T3[])` which is basically one of the requirement of defining signature for currying and partial application. * inference dynamic dictionary type - Unlike static languages (including Ocaml) where dictionary types are strictly `interface { [key: TKey]: TValue }`, JS you are allowed to insert random types into a dictionary. Ideally to solve this issue the type system should have inferenced `interface { [key: TKey]: T1 | T2 | T3...}` for a dictionary. However, neither TypeScript nor Flow attempt to inference this, they just settle with `interface { [key: TKey]: any }`. This basically means that anytime you have a dynamic-typed dictionary in a functional chain, the inference is lost. You can avoid this in your own code, but it is pretty prevalent in 3rd party code. 
At the very least, no-implicit-any should be on, which will cause an error on `test(x)`. Changing that to anything other than `number` or `any` will cause an error that the method parameter types are incompatible, so in that (albeit round-about) way, TS will enforce compatible types, even though it's not inferring types here.
They own the distribution.
Neither of them are particularly awesome at it. Flow has better support for properly disjoint unions, though, since it has more literal types (typescript only recently gained string literals). It can also infer the type for higher-order functions, so you can do your partial application through a simple eta conversion. There's also the whole null and undefined being proper bottom values. Typescript is fixing (with a compile flag) that in 2.0, but who knows when that's coming around.
Haven't tested
The error is the strangest part to me, imo. Typescript knows exactly what the type has to be or throws an error, but doesn't infer it. 
Flow definitions are coming in this repository: https://github.com/flowtype/flow-typed
WebStorm supports Flow syntax out of the box, supports error highlighting as you type through its "File Watchers" feature (see the first ticket below), and will support error highlighting out of the box when the second ticket below is resolved: https://youtrack.jetbrains.com/issue/WEB-16607 https://youtrack.jetbrains.com/issue/WEB-14254 Atom supports Flow syntax highlighting and error underlining through the Nuclide set of plugins from Facebook.
You can do this through listeners; just create your radio inputs, set them to the same name and the add a listener that triggers onchange. Then from the onchange call, execute your update depending on what selected radio index was clicked. That's the general approach I'd take. I don't know much about this library though.
It’s under their own namespace. It’s on npmjs.com, not bikasv.com. The problem is people had the illusion that they’re the owners, which they aren’t. Same thing with GitHub. If GitHub wants to give away your username, they can, and there’s nothing you can do about it.
Look into feathersjs.
Lol, I wrote something like this while going through SICP. Using JSON lets you completely skip parsing. 
I think npm handled it well. And I don't mind 2.5 hours of downtime once every few months. I'm not paying anything for the service! Can't complain.
You completely missed the point. All software is ultimately stable if you make it small enough, which doesn't meaning anything. I could take every condition and logic branch out of my application and make it a module of its own (with dependencies if there is a condition inside another convention) and each of these would be extremely stable (on their own). This does absolutely nothing to affirm application health, bloats the code, further locks productivity behind non-essential build tasks, obscures security, and so forth. If you have an artifact just for your build process then why don't you just include it in your build process directly without making it a module?
You unpublish a package that you developed. Not just a name. So whichever way you identify the package it's the same when you remove it and it's not there. So even if left-pad had some kind of uuid it would not matter because after unpublishing it the package whit that certain uuid would not be there.
NPM explicitly rejected that it was a decision they made with trademark/copyright law in mind: &gt;This incident did not arise because of intellectual property law. &gt;We’re aware that Kik and Azer discussed the legal issues surrounding the “Kik” trademark, but that wasn’t pertinent. Our decision relied on our dispute resolution policy. It was solely an editorial choice, made in the best interests of the vast majority of npm’s users. This *is* a generic justification they're making, and this *is* how they plan on utilizing their package name conflict policy. 
Open source licenses give the receiver redistribution rights. That's what open source is fundamentally about.
Express is fine but its future is a little uncertain currently. I like Koa a lot. The syntax is nice. Writing in Express tends to necessitate a lot of callbacks.
Whoever has the bigger corporate dick. Whoever can bankrupt the other with legal costs first. Doesn't even matter about being right or wrong anymore. 
Do you not acknowledge that this situation occurred because the company Kik claimed ownership over the name kik?
Completely ridiculous, no one is just going to type 'npm install random_package_name'. The expectation is only set after someone goes to find out what the package is meant to be used for.
Sigh.
Haha. Times like these I'm glad I'm not a node developer. npm is so clusterfucked...
Just saw this at ember conf today.
I just don't see their reasoning for taking it down if it wasn't an IP issue. Also since when do people just randomly install foreign code without knowing expressly what it's for? Maybe I'm misunderstanding how people use language package managers
Correct me if I'm wrong, but Electron DOES have native Node module support - hell, I'm building an electron application as I write this that uses native modules.
&gt; I just don't see their reasoning for taking it down if it wasn't an IP issue. Lawyers cost money.
I meant &gt;if that developer does not know html &amp; css, would you still tell them to learn a **js** framework?
Such amazing black/white thinking and FUD going on by [curly braces disciples](http://leon.vankammen.eu/tech/bash-coffeescript-es6-and-the-curly-religion.html). Coffeescript is just a terse &amp; human language dialect which compiles to javascript, that's it, get over it. I could totally imagine people still wanting to maintain less serverside code by using coffeescript. I don't see coffeescript (or variations) disappearing soon, simply because it's part of the 1st generation transpilerwave...can't undo that..and Babel doesn't really focus on tersity. Also, the fact that a syntax freezes / moves slow is a good thing, as it allows an ecosystem to mature around it. As the maintainer stated: "ES6 features, just like ES5 features, and ES3 features, are supported on a case-by-case basis. Ideally, they should be added as soon as they're widely supported in shipping JavaScript implementations." So lets get coffeescript straight: it's not a syntax which focuses on novelty nor compatibility with possible feature X of ES13. If you and your team like coffeescript, and it works for you, just use it!
Upgrade path? I think you're misguided on that one. One can always use decaffeinate, or simply compile everything to js (and move into a different direction). 
It seems that many folks seem to judge a syntax based on it's ability to adopt zillion of features/extentions per month. I Don't think that it would make a very stable syntax. ES6/ES7/Coffeescript/Typescript is nice, but at the end of the day they won't produce very different applications. 
I couldn't find my old code, so I just re-wrote it from scratch: https://jsfiddle.net/oldesole1/ecnwyvee/2/ You can add any additional operators to the map and the keys will be automatically included into the regex. This also works with multi-character operators, but you would just need to add them before any shorter operators match as a sub-string.
Dead or stable syntax?
Yes, if you imported strictly one function dependencies you'd potentially hit the limits of your dependency resolver quickly. Still, there are 594 packages on microjs, averaging 1.3 kB each, which is a large number of small top level dependencies. This is probably a more accurate representation of how the npm community uses micro packages in the wild. Micro packages in this case being small packages exposing few functions, as opposed to exposing strictly one. The fewer functions your package exports, the more precise npm can be at deduping. Again, this is assuming 79% of your 1mb web consists of imported functions, which is probably an overestimation.
My point is to never unpublish it. Only to discourage to use the package as much as possible.
Disclaimer: I am not a node developer I would check out adonis. the key feature of adonis is that it is an mvc based opinionated framework with orm and cli tool. while koa and express are libraries not framework. 
It does. You have to jump through some hoops, [but it's doable](https://github.com/atom/electron/blob/master/docs/tutorial/using-native-node-modules.md).
Thank you so much, oldsole1! This helps so much :-) Do you mind if I PM you in case I have any questions about it?
I wanted to make another Javascript WTF. Also, despite the lockdown on the global `NaN` and `Infinity` and `undefined` in ES5+, those still aren't reserved words, and you can still use them as local variable names.
i doubt you will find something to be able to create formatted excel documents, though maybe google sheets can do it, and i imagine there is an api for that ... You could write a csv file using the fileSystem API within chrome, then a csv file can be openned in excel, and it will be a spreadsheet, but you wont get any fancy formatting stuff with it https://developer.chrome.com/apps/fileSystem
And call a doctor.
Just to be clear or at least clearer than /u/steveklabnik1 :-), and to make a point that few people fully grasp: Open Source licenses are *distribution* licenses. They are NOT EULAs or *any* kind of user license. If someone gives you a copy of a program under an Open Source license you are free to use that program *without* even having to accept the license. That's right, you can ignore the license. The only time you need the license is when you want to make a copy and distribute it to someone else. Without the Open Source license you are forbidden by copyright law to make copies. That is what copyright controls, the right to make copies of a work. It doesn't actually control how someone may use a work they have legally obtained. For far too much detail see: http://www.osnews.com/story/22233/The_Difference_Between_EULAs_and_Open_Source_Licenses
Yeah, I was able to do it with Node using the exceljs module, but I don't know why I assumed I would be able to reuse it in the browser. Unfortunately I can't just use a CSV file because the formatting for the excel stuff is required. I think using Google Sheets will be fine, but do you know if I can create/download a sheet dynamically from within a chrome extension?
This is pretty awesome! Ember does solve all the tough problems for you :)
i had the same problem. i added jsdoc comments to all the functions and used jsdoc... the output gave me 80% of what i need. and the best part is what was missing from the docs was very clear afterwords because i designed the system. 
whats the difference between "Free" and "Free of copyright"?
Stick to standards and go Flow. Flow types are also richer than Typescript. Also good not being caught in the Microsoft web.
This depends on the country you are in, however in my country free means that you can use it for private use, while free of copyright means that you can use it commercially without paying royalties. eg You can sing a song at a school function without paying copyright fees (royalties) but if you record it and sell the recordings that is a different matter.
I agree with banning Ruby, but only so I don't have to justify any more why I am not using such a great language.
Hey what about: http://stackoverflow.com/questions/29698796/how-to-convert-html-table-to-excel-with-multiple-sheet#answer-29717451 Not sure on writing Chrome extensions, but that JS works well to render tables directly to Excel. Never mind his HTML; try using his tablesToExcel function.
Woah... this may just work. I'm going to have to give this a try. Thanks a lot!
&gt; Yes, if you imported strictly one function dependencies you'd potentially hit the limits of your dependency resolver quickly. Agreed. &gt; Micro packages in this case being small packages exposing few functions Yep - grouping a bunch of related functionality into a targeted utility library. I agree this is how it should be done. &gt; The fewer functions your package exports, the more precise npm can be at deduping. Agreed, but with an increased package management overhead - so the right balance in my mind would be to use more general utility libraries with tree shaking and deduplication to get as close as reasonable to the most optimal possible bundle size. &gt; Again, this is assuming 79% of your 1mb web consists of imported functions, which is probably an overestimation. I suppose that depends on the breakdown of your project. I've seen projects with over 1mb of dependencies and only a tiny amount of actual application code, and I've seen the opposite. But the total bundle size really doesn't have any real bearing on the issue, it's purely the size of the dependency tree to resolve. You could have a 50mb app (on the extreme side) with only a few dependencies, or a 200kb app with thousands of micro packages (also on the extreme side). 
what language was your muse? Why do you use semi colons?
Shuffling an array doesn't fit in this list. It's not commonly useful. Also I disagree with the clever way to convert a number. Clever code isn't. Write obvious code. Write as if the maintainer has a knife, a mental disorder, and your address. 
This article is missing apply, call and bind, very useful functions that, although aren't used in application code often, are used in third party libraries and are definitely worth knowing. Also, arguments that is implicitly passed to all functions should be mentioned as well (although the need to use arguments is eliminated when rest operator is fully supported)
It's because `localStorage` **only** stores as string, so when you put a number into the store, it transforms it to a string; thus when you retrieve that value you're assuming it's a number, which is incorrect. The solution is to transform the string into a number when you pull it **from** the store: `Number(localStorage.getItem('likesl'))`.
Hypothetically: Okay, so when I want to take my packages off npm I will just publish a version with an empty package with no code in it. Or just put a "return undefined;" at the top. So any author that is pissed off by npm might do this. In this case maybe Azer would have done this instead of deleting his package. And it would have blown up equally. And what about unintentional breakage a new (minor) version might introduce? This will lead to npm checking/testing before publishing stuff? Or will they stop me from publishing new versions?
the cto or similar from kik posted something on medium a while back that included every email sent between them. azer's responses were very short, incredibly rude, and laden with profanity. basically azer said "fuck you" numerous times to kik. he was so childish in this exchange.
You heard this thing, 6 no-nonsense tips to master JavaScript? Yeah, this is going to blow that right out of the water. Listen to this: 7... no-nonsense... tips to master JavaScript. Think about it. You walk into reddit, you see 6 no-nonsense tips sittin' there, there's 7 no-nonsense tips right beside it. Which one are you gonna pick, man? Bingo, man, bingo.
 parseInt("10", 10); // 10 parseInt("abcdefg", 10); NaN parseInt(store.get('likesl'), 10); // number of likes